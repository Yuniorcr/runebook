<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="3d6762a6aa2cf0aca37a59f773d7789ef284a403" translate="yes" xml:space="preserve">
          <source>Note: an important part of this behavior is that the PRNG that Redis implements as &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; is guaranteed to have the same output regardless of the architecture of the system running Redis. 32-bit, 64-bit, big-endian and little-endian systems will all produce the same output.</source>
          <target state="translated">Примечание: важной частью этого поведения является то, что PRNG, который Redis реализует как &lt;code&gt;math.random&lt;/code&gt; и &lt;code&gt;math.randomseed&lt;/code&gt; , гарантированно будет иметь одинаковый результат независимо от архитектуры системы, в которой работает Redis. 32-битные, 64-битные системы с прямым порядком байтов и обратным порядком байтов будут давать одинаковый результат.</target>
        </trans-unit>
        <trans-unit id="19d14832252be8ae1106f6c63fb642cd3e9e2df4" translate="yes" xml:space="preserve">
          <source>Note: as a side effect of calling this function, it is possible that the HyperLogLog is modified, since the last 8 bytes encode the latest computed cardinality for caching purposes. So &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; is technically a write command.</source>
          <target state="translated">Примечание: в качестве побочного эффекта вызова этой функции возможно изменение HyperLogLog, поскольку последние 8 байтов кодируют последнюю вычисленную мощность для целей кэширования. Таким образом, &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; технически является командой записи.</target>
        </trans-unit>
        <trans-unit id="ca716680732d1d3e7b5dc5d38bf23aaa2688e964" translate="yes" xml:space="preserve">
          <source>Note: as you can see Lua arrays are returned as Redis multi bulk replies, that is a Redis return type that your client library will likely convert into an Array type in your programming language.</source>
          <target state="translated">Замечание:как вы можете видеть,массивы Lua возвращаются в виде многократных ответов Redis,то есть тип возврата Redis,который ваша клиентская библиотека,скорее всего,преобразует в тип массива на вашем языке программирования.</target>
        </trans-unit>
        <trans-unit id="a094e9a0339a167054eac3028e87a3e324531dab" translate="yes" xml:space="preserve">
          <source>Note: of course as usually it is not guaranteed that the error text remains the same, however the error code will remain &lt;code&gt;-UNBLOCKED&lt;/code&gt;.</source>
          <target state="translated">Примечание: конечно, как обычно, не гарантируется, что текст ошибки останется прежним, однако код ошибки останется &lt;code&gt;-UNBLOCKED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ba013a44d25a035abd0e8ad87d8b610e34b72b2" translate="yes" xml:space="preserve">
          <source>Note: the command has a complexity of just O(log(N)) because it uses elements ranks (see &lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt;) to get an idea of the range. Because of this there is no need to do a work proportional to the size of the range.</source>
          <target state="translated">Примечание: команда имеет сложность всего O (log (N)), потому что она использует ранги элементов (см. &lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt; ), чтобы получить представление о диапазоне. Благодаря этому нет необходимости проделывать работу, пропорциональную размеру диапазона.</target>
        </trans-unit>
        <trans-unit id="a4cf334aa22d4d43d68ebc7afbb42dd9e08a0e09" translate="yes" xml:space="preserve">
          <source>Note: we use the &lt;strong&gt;COUNT&lt;/strong&gt; option in the example, so that for each stream the call will return at maximum two elements per stream.</source>
          <target state="translated">Примечание: в примере мы используем параметр &lt;strong&gt;COUNT&lt;/strong&gt; , чтобы для каждого потока вызов возвращал не более двух элементов на поток.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="5a4574a1a3d9728a0a89d6b1668d9c8dc4ec0634" translate="yes" xml:space="preserve">
          <source>Notes on published config epochs</source>
          <target state="translated">Примечания к опубликованным эпохам конфигурации</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="20be3b7a30a9bb9f7caa52a82e339d86765a7b3b" translate="yes" xml:space="preserve">
          <source>Number of commands processed</source>
          <target state="translated">Количество обработанных команд</target>
        </trans-unit>
        <trans-unit id="6567d67fead3b983bf0dd26e46b199bad4736caf" translate="yes" xml:space="preserve">
          <source>Number of connections received</source>
          <target state="translated">Количество полученных соединений</target>
        </trans-unit>
        <trans-unit id="c0e73dd590dc420faea4c4ac9906ba30e0259e37" translate="yes" xml:space="preserve">
          <source>Number of elements returned at every SCAN call</source>
          <target state="translated">Количество элементов,возвращаемых при каждом вызове SCAN</target>
        </trans-unit>
        <trans-unit id="f4702f3357a94e0b51c79789087a3eb454b1e296" translate="yes" xml:space="preserve">
          <source>Number of expired keys</source>
          <target state="translated">Количество просроченных ключей</target>
        </trans-unit>
        <trans-unit id="8e0e833a8bbaf63a540fadb74be8461319161578" translate="yes" xml:space="preserve">
          <source>Number of rejected connections</source>
          <target state="translated">Количество отклоненных соединений</target>
        </trans-unit>
        <trans-unit id="828f2a22520c1086f191a7adfcf910b96f4fe93b" translate="yes" xml:space="preserve">
          <source>OBJECT</source>
          <target state="translated">OBJECT</target>
        </trans-unit>
        <trans-unit id="9d8ec388e13faad9823f64e9acce4e1451d4eabf" translate="yes" xml:space="preserve">
          <source>OBJECT  subcommand [arguments [arguments ...]]   Inspect the internals of Redis objects</source>
          <target state="translated">Подкоманда OBJECT [аргументы [аргументы ...]]Проверьте внутреннюю часть объектов Redis</target>
        </trans-unit>
        <trans-unit id="77ba3ba2dc482ece5e336da9db6f45f553748e64" translate="yes" xml:space="preserve">
          <source>Objects can be encoded in different ways:</source>
          <target state="translated">Объекты могут быть закодированы различными способами:</target>
        </trans-unit>
        <trans-unit id="179e9e8b9188e3e0f2e120735c4089249f586f43" translate="yes" xml:space="preserve">
          <source>Obtaining the current length of the slow log</source>
          <target state="translated">Получение текущей длины медленного журнала</target>
        </trans-unit>
        <trans-unit id="5f6babf24c9404230c05a01781cf0ff83f2a099c" translate="yes" xml:space="preserve">
          <source>Of course it is also possible to use any other valid ID. If the specified consumer group already exists, the command returns a &lt;code&gt;-BUSYGROUP&lt;/code&gt; error. Otherwise the operation is performed and OK is returned. There are no hard limits to the number of consumer groups you can associate to a given stream.</source>
          <target state="translated">Конечно, также можно использовать любой другой действительный идентификатор. Если указанная группа потребителей уже существует, команда возвращает ошибку &lt;code&gt;-BUSYGROUP&lt;/code&gt; . В противном случае операция выполняется и возвращается ОК. Нет жестких ограничений на количество групп потребителей, которые вы можете связать с данным потоком.</target>
        </trans-unit>
        <trans-unit id="fdc97913b5ee5e2b94550a726affb680e5e4737b" translate="yes" xml:space="preserve">
          <source>Of course the &quot;5&quot; above is an example. Each LOLWUT version takes a different set of arguments in order to change the output. The user is encouraged to play with it to discover how the output changes adding more numerical arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1bb1ff7a105fafca313a10f02e72dc891fbcf4" translate="yes" xml:space="preserve">
          <source>Of course this is not enough as there are expired keys that will never be accessed again. These keys should be expired anyway, so periodically Redis tests a few keys at random among keys with an expire set. All the keys that are already expired are deleted from the keyspace.</source>
          <target state="translated">Конечно,этого недостаточно,так как есть просроченные ключи,которые больше никогда не будут доступны.Эти ключи должны быть просрочены в любом случае,поэтому периодически Redis тестирует несколько ключей случайным образом среди ключей с набором истекших.Все ключи,срок действия которых уже истек,удаляются из пробела ключей.</target>
        </trans-unit>
        <trans-unit id="e1291438828df902dd44c789d43575a9bce5c968" translate="yes" xml:space="preserve">
          <source>On the other hand, defining commands using a special command or via &lt;code&gt;redis.conf&lt;/code&gt; would be a problem for a few reasons:</source>
          <target state="translated">С другой стороны, определение команд с помощью специальной команды или через &lt;code&gt;redis.conf&lt;/code&gt; было бы проблемой по нескольким причинам:</target>
        </trans-unit>
        <trans-unit id="9bcf11babeeb88215faca3f25a089c7e21ce30f5" translate="yes" xml:space="preserve">
          <source>Once a consumer &lt;em&gt;succesfully&lt;/em&gt; processes a message, it should call &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; so that such message does not get processed again, and as a side effect, the PEL entry about this message is also purged, releasing memory from the Redis server.</source>
          <target state="translated">Как только потребитель &lt;em&gt;успешно&lt;/em&gt; обработает сообщение, он должен вызвать &lt;a href=&quot;xack&quot;&gt;XACK,&lt;/a&gt; чтобы такое сообщение не было обработано снова, и в качестве побочного эффекта запись PEL об этом сообщении также удаляется, освобождая память сервера Redis.</target>
        </trans-unit>
        <trans-unit id="b17fd51767d49ce5f7f1a0550bff325504d720d8" translate="yes" xml:space="preserve">
          <source>Once a consumer &lt;em&gt;successfully&lt;/em&gt; processes a message, it should call &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; so that such message does not get processed again, and as a side effect, the PEL entry about this message is also purged, releasing memory from the Redis server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452b455cbf1a2a31d7d4b5005050bf4551fb3def" translate="yes" xml:space="preserve">
          <source>Once a node is turned into the replica of another master node, there is no need to inform the other cluster nodes about the change: heartbeat packets exchanged between nodes will propagate the new configuration automatically.</source>
          <target state="translated">Как только узел превращается в копию другого основного узла,нет необходимости информировать другие узлы кластера об изменении:пульсирующие пакеты,обмениваемые между узлами,будут автоматически распространять новую конфигурацию.</target>
        </trans-unit>
        <trans-unit id="24b95a3638ec064976a3c5a5f6794040d2c4ed0b" translate="yes" xml:space="preserve">
          <source>Once new data is present on one of the lists, the client returns with the name of the key unblocking it and the popped value.</source>
          <target state="translated">Как только новые данные присутствуют в одном из списков,клиент возвращается с именем разблокирующего его ключа и выскакивающим значением.</target>
        </trans-unit>
        <trans-unit id="dd41998567cd1f4f810cbadee2b74617b57a32fa" translate="yes" xml:space="preserve">
          <source>Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt; and &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt; commands.</source>
          <target state="translated">Когда клиент переходит в состояние подписки, он не должен выдавать никаких других команд, кроме дополнительных команд &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt; , &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; , &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt; и &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a78727304122280256c3edfc937460559a439ea" translate="yes" xml:space="preserve">
          <source>Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt;, &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; and &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b215656d61ce9a1a4991539bbd4f84ece9f512" translate="yes" xml:space="preserve">
          <source>Once we get some replies, the next call will be something like:</source>
          <target state="translated">Как только мы получим несколько ответов,следующий звонок будет что-то вроде:</target>
        </trans-unit>
        <trans-unit id="9de09a5350a4d4653c094b67b0dba8689a762e24" translate="yes" xml:space="preserve">
          <source>One client connection per line (separated by LF)</source>
          <target state="translated">Одно клиентское соединение на линию (разделенное LF)</target>
        </trans-unit>
        <trans-unit id="81d95091e8731132a88b7f9f02a3169be5e6b187" translate="yes" xml:space="preserve">
          <source>One of the guarantees of consumer groups is that a given consumer can only see the history of messages that were delivered to it, so a message has just a single owner. However there is a special feature called &lt;em&gt;message claiming&lt;/em&gt; that allows other consumers to claim messages in case there is a non recoverable failure of some consumer. In order to implement such semantics, consumer groups require explicit acknowledgement of the messages successfully processed by the consumer, via the &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command. This is needed because the stream will track, for each consumer group, who is processing what message.</source>
          <target state="translated">Одна из гарантий групп потребителей заключается в том, что конкретный потребитель может видеть только историю сообщений, которые были ему доставлены, поэтому у сообщения есть только один владелец. Однако существует специальная функция, называемая &lt;em&gt;заявлением сообщения,&lt;/em&gt; которая позволяет другим потребителям запрашивать сообщения в случае неисправимого отказа какого-либо потребителя. Для реализации такой семантики группам потребителей требуется явное подтверждение сообщений, успешно обработанных потребителем, с помощью команды &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; . Это необходимо, потому что поток будет отслеживать для каждой группы потребителей, кто какое сообщение обрабатывает.</target>
        </trans-unit>
        <trans-unit id="19ce1ec3b2311a2d98754806626a6daf14da6b47" translate="yes" xml:space="preserve">
          <source>One of the guarantees of consumer groups is that a given consumer can only see the history of messages that were delivered to it, so a message has just a single owner. However there is a special feature called &lt;em&gt;message claiming&lt;/em&gt; that allows other consumers to claim messages in case there is a non recoverable failure of some consumer. In order to implement such semantics, consumer groups require explicit acknowledgment of the messages successfully processed by the consumer, via the &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command. This is needed because the stream will track, for each consumer group, who is processing what message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="daa479a36fbba3ff638d59ae19308e8976bd5ac3" translate="yes" xml:space="preserve">
          <source>Orders of bits</source>
          <target state="translated">Порядок битов</target>
        </trans-unit>
        <trans-unit id="dcfd7c36726b3d9723cbd1a8981b89247967a629" translate="yes" xml:space="preserve">
          <source>Other consumers may inspect the list of pending messages, that are stale for quite some time, using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command. In order to continue processing such messages, they use &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; to acquire the ownership of the message and continue.</source>
          <target state="translated">Другие потребители могут проверить список ожидающих сообщений, которые устарели в течение некоторого времени, с помощью команды &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; . Чтобы продолжить обработку таких сообщений, они используют &lt;a href=&quot;xclaim&quot;&gt;XCLAIM,&lt;/a&gt; чтобы получить право собственности на сообщение и продолжить.</target>
        </trans-unit>
        <trans-unit id="3c2a27c636dc79870e309393531406e960ec4e18" translate="yes" xml:space="preserve">
          <source>Our previous example returns just the sorted IDs. In some cases, it is more useful to get the actual objects instead of their IDs (&lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;). Retrieving external keys based on the elements in a list, set or sorted set can be done with the following command:</source>
          <target state="translated">Наш предыдущий пример возвращает только отсортированные идентификаторы. В некоторых случаях более полезно получить фактические объекты, а не их идентификаторы ( &lt;code&gt;object_1&lt;/code&gt; , &lt;code&gt;object_2&lt;/code&gt; и &lt;code&gt;object_3&lt;/code&gt; ). Получить внешние ключи на основе элементов списка, набора или отсортированного набора можно с помощью следующей команды:</target>
        </trans-unit>
        <trans-unit id="e9c8427bc7498ec3380d38f116037bdd3bcddf6e" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the actual end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">Индексы вне диапазона не вызовут ошибки. Если &lt;code&gt;start&lt;/code&gt; больше конца списка, возвращается пустой список. Если &lt;code&gt;stop&lt;/code&gt; больше, чем фактический конец списка, Redis будет рассматривать его как последний элемент списка.</target>
        </trans-unit>
        <trans-unit id="c0a3cb19e89ec7bd7c87e53355299d0f62cc91cc" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the largest index in the sorted set, or &lt;code&gt;start &amp;gt;
stop&lt;/code&gt;, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the end of the sorted set Redis will treat it like it is the last element of the sorted set.</source>
          <target state="translated">Индексы вне диапазона не вызовут ошибки. Если &lt;code&gt;start&lt;/code&gt; больше, чем самый большой индекс в отсортированном наборе, или &lt;code&gt;start &amp;gt; stop&lt;/code&gt; , возвращается пустой список. Если &lt;code&gt;stop&lt;/code&gt; больше, чем конец отсортированного набора, Redis будет рассматривать его как последний элемент отсортированного набора.</target>
        </trans-unit>
        <trans-unit id="3dc054b880cd4ad0a83857995e10c362ec4b2504" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error: if &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, or &lt;code&gt;start &amp;gt; end&lt;/code&gt;, the result will be an empty list (which causes &lt;code&gt;key&lt;/code&gt; to be removed). If &lt;code&gt;end&lt;/code&gt; is larger than the end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">Индексы вне диапазона не вызовут ошибки: если &lt;code&gt;start&lt;/code&gt; больше конца списка или &lt;code&gt;start &amp;gt; end&lt;/code&gt; , результатом будет пустой список (что приведет к удалению &lt;code&gt;key&lt;/code&gt; ). Если &lt;code&gt;end&lt;/code&gt; больше, чем конец списка, Redis будет рассматривать его как последний элемент списка.</target>
        </trans-unit>
        <trans-unit id="c4e6b6c77c67abd27de260eb5ce674860a95ad42" translate="yes" xml:space="preserve">
          <source>Out-of-range indexes</source>
          <target state="translated">внебиржевые индексы</target>
        </trans-unit>
        <trans-unit id="c03f08a8f205e4568e916e3cfaa50c6a48749706" translate="yes" xml:space="preserve">
          <source>Output format</source>
          <target state="translated">Выходной формат</target>
        </trans-unit>
        <trans-unit id="275395efd6e79fdbe55cb36a4ebb4892dbdd5c40" translate="yes" xml:space="preserve">
          <source>Output of the command on replicas</source>
          <target state="translated">Вывод команды на реплики</target>
        </trans-unit>
        <trans-unit id="5ea9a43450142f5e1cfd51ca7b6956f8a9dbb82d" translate="yes" xml:space="preserve">
          <source>Overflow control</source>
          <target state="translated">Регулирование переполнения</target>
        </trans-unit>
        <trans-unit id="36fd64a953472994b938bbb13337305e87d9a9eb" translate="yes" xml:space="preserve">
          <source>Overwrites part of the string stored at &lt;em&gt;key&lt;/em&gt;, starting at the specified offset, for the entire length of &lt;em&gt;value&lt;/em&gt;. If the offset is larger than the current length of the string at &lt;em&gt;key&lt;/em&gt;, the string is padded with zero-bytes to make &lt;em&gt;offset&lt;/em&gt; fit. Non-existing keys are considered as empty strings, so this command will make sure it holds a string large enough to be able to set &lt;em&gt;value&lt;/em&gt; at &lt;em&gt;offset&lt;/em&gt;.</source>
          <target state="translated">Заменяет часть строки, хранящейся на &lt;em&gt;ключе&lt;/em&gt; , начиная с указанного смещения, на всю длину &lt;em&gt;значения&lt;/em&gt; . Если смещение больше текущей длины строки в &lt;em&gt;ключе&lt;/em&gt; , строка дополняется нулевыми байтами, чтобы &lt;em&gt;смещение&lt;/em&gt; соответствовало. Несуществующие ключи считаются пустыми строками, поэтому эта команда гарантирует, что она содержит строку, достаточно большую, чтобы можно было установить &lt;em&gt;значение&lt;/em&gt; по &lt;em&gt;смещению&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="34512fba1d256a361565532a3535096429399084" translate="yes" xml:space="preserve">
          <source>PERSIST</source>
          <target state="translated">PERSIST</target>
        </trans-unit>
        <trans-unit id="ae51373f050f6d2b0e0edfdd08e69fc1968bdf20" translate="yes" xml:space="preserve">
          <source>PERSIST  key   Remove the expiration from a key</source>
          <target state="translated">ПЕРСИСТ-ключ Удалить истечение срока действия из ключа</target>
        </trans-unit>
        <trans-unit id="7fa59fa06dcb2c9dc1b2b2bd46df7f33912c57b3" translate="yes" xml:space="preserve">
          <source>PEXPIRE</source>
          <target state="translated">PEXPIRE</target>
        </trans-unit>
        <trans-unit id="77a946764b4ffdf95c5ae217ca7f9cec5340bdc1" translate="yes" xml:space="preserve">
          <source>PEXPIRE  key milliseconds   Set a key's time to live in milliseconds</source>
          <target state="translated">Ключ PEXPIRE в миллисекундах Установить время жизни ключа в миллисекундах</target>
        </trans-unit>
        <trans-unit id="e609e3af460df9737d7d964f8bfec75a3773bde7" translate="yes" xml:space="preserve">
          <source>PEXPIREAT</source>
          <target state="translated">PEXPIREAT</target>
        </trans-unit>
        <trans-unit id="12d0e8f2d7d7718d124f2a5d583dfa8315ee3c0c" translate="yes" xml:space="preserve">
          <source>PEXPIREAT  key milliseconds-timestamp   Set the expiration for a key as a UNIX timestamp specified in milliseconds</source>
          <target state="translated">Штемпель времени ключа PEXPIREAT в миллисекундах Установить срок действия ключа в виде штемпеля времени UNIX,указанного в миллисекундах.</target>
        </trans-unit>
        <trans-unit id="fc7a17907dc63d1312607f17460e9eb6e7871f9d" translate="yes" xml:space="preserve">
          <source>PFADD</source>
          <target state="translated">PFADD</target>
        </trans-unit>
        <trans-unit id="e4e9e83ebacf78fb8cf3124d42502528b53d06ca" translate="yes" xml:space="preserve">
          <source>PFADD  key element [element ...]   Adds the specified elements to the specified HyperLogLog.</source>
          <target state="translated">Ключевой элемент PFADD [элемент ...]Добавляет указанные элементы в указанный HyperLogLog.</target>
        </trans-unit>
        <trans-unit id="274e92a9d4138573a0f107d2e57b9d0b46e7ac01" translate="yes" xml:space="preserve">
          <source>PFCOUNT</source>
          <target state="translated">PFCOUNT</target>
        </trans-unit>
        <trans-unit id="f81913b01d976cbaac4ade6c06f6bf299ee86214" translate="yes" xml:space="preserve">
          <source>PFCOUNT  key [key ...]   Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).</source>
          <target state="translated">Клавиша PFCOUNT [клавиша ...]Возвращает аппроксимированную кардинальность набора(ов),наблюдаемую HyperLogLog на клавише(ах).</target>
        </trans-unit>
        <trans-unit id="62f6ef6fa6924abe295c8c766f2b3e89d6d074fc" translate="yes" xml:space="preserve">
          <source>PFMERGE</source>
          <target state="translated">PFMERGE</target>
        </trans-unit>
        <trans-unit id="2ad005659587e94338ccd67e31dbc3fac2cb1536" translate="yes" xml:space="preserve">
          <source>PFMERGE  destkey sourcekey [sourcekey ...]   Merge N different HyperLogLogs into a single one.</source>
          <target state="translated">Исходный ключ PFMERGE [исходный ключ ...]Объединить N различных HyperLogLogLogs в один.</target>
        </trans-unit>
        <trans-unit id="0b1786a083a9087f0db36b08c1ff81a58930fbc2" translate="yes" xml:space="preserve">
          <source>PING</source>
          <target state="translated">PING</target>
        </trans-unit>
        <trans-unit id="45dae0d4784e1c9ea33d8d88f448f7989ea29500" translate="yes" xml:space="preserve">
          <source>PING  [message]   Ping the server</source>
          <target state="translated">Пинг [сообщение]Пинг сервера</target>
        </trans-unit>
        <trans-unit id="81efb783fc237efd685a1393fa9f947dd8abda5a" translate="yes" xml:space="preserve">
          <source>PSETEX</source>
          <target state="translated">PSETEX</target>
        </trans-unit>
        <trans-unit id="d7c40d1ee18ffeabe6099f89603c950454eb0276" translate="yes" xml:space="preserve">
          <source>PSETEX  key milliseconds value   Set the value and expiration in milliseconds of a key</source>
          <target state="translated">Стоимость ключа PSETEX в миллисекундах Установить стоимость и срок действия ключа в миллисекундах</target>
        </trans-unit>
        <trans-unit id="9e7e79c8d02bde08c4e705066bd533ffa7218538" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE</source>
          <target state="translated">PSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="71ae64e5df443252e78a1d1f929289a8311a1ef4" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE  pattern [pattern ...]   Listen for messages published to channels matching the given patterns</source>
          <target state="translated">Шаблон PSUBSCRIBE [шаблон ...]Прослушивание сообщений,опубликованных в каналах,соответствующих заданным шаблонам.</target>
        </trans-unit>
        <trans-unit id="2c633ee880363a76906d0e48643fc6fd3afe6539" translate="yes" xml:space="preserve">
          <source>PSYNC</source>
          <target state="translated">PSYNC</target>
        </trans-unit>
        <trans-unit id="5d448b1760960854b1253a3a2cad23abdcfdac61" translate="yes" xml:space="preserve">
          <source>PSYNC  replicationid offset   Internal command used for replication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8bdca458042e425d2902f59f800419aed5c8b1" translate="yes" xml:space="preserve">
          <source>PTTL</source>
          <target state="translated">PTTL</target>
        </trans-unit>
        <trans-unit id="05bf8ee07e7053cfaf8f62c038f0255fadf89afe" translate="yes" xml:space="preserve">
          <source>PTTL  key   Get the time to live for a key in milliseconds</source>
          <target state="translated">PTTL ключ Получить время жить для ключа в миллисекундах</target>
        </trans-unit>
        <trans-unit id="ff0fc30c743813f924dff4b751315af42d5ab08b" translate="yes" xml:space="preserve">
          <source>PUBLISH</source>
          <target state="translated">PUBLISH</target>
        </trans-unit>
        <trans-unit id="46e845a027f7bb36580703fc200d9108559fa747" translate="yes" xml:space="preserve">
          <source>PUBLISH  channel message   Post a message to a channel</source>
          <target state="translated">Сообщение канала PUBLISH Отправьте сообщение на канал.</target>
        </trans-unit>
        <trans-unit id="9487f50e961af3141e0c7833372d9b2c28cfa2a4" translate="yes" xml:space="preserve">
          <source>PUBSUB</source>
          <target state="translated">PUBSUB</target>
        </trans-unit>
        <trans-unit id="acad4a3c05b50f5f04a99427d2a3cdbb983fb0b9" translate="yes" xml:space="preserve">
          <source>PUBSUB  subcommand [argument [argument ...]]   Inspect the state of the Pub/Sub subsystem</source>
          <target state="translated">Подкоманда PUBSUB [аргумент [аргумент ...]]Проверка состояния подсистемы Pub/Sub</target>
        </trans-unit>
        <trans-unit id="ca024e3f958c6b7f4c7fa3671697866707cfa352" translate="yes" xml:space="preserve">
          <source>PUBSUB CHANNELS [pattern]</source>
          <target state="translated">PUBSUB КАНАЛЫ [образец]</target>
        </trans-unit>
        <trans-unit id="56e20f63e75d465369356d3ab7aa54f42d22cbb4" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE</source>
          <target state="translated">PUNSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="e54d89cca768ad85f7527ac0169fa1af2910b1cf" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE  [pattern [pattern ...]]   Stop listening for messages posted to channels matching the given patterns</source>
          <target state="translated">PUNSUBSCRIBE [образец [образец ...]]Прекратить прослушивание сообщений,отправленных на каналы,соответствующие заданным шаблонам.</target>
        </trans-unit>
        <trans-unit id="df3251b7546bede28dd0b0e82a26302f58157038" translate="yes" xml:space="preserve">
          <source>Passing keys and arguments as additional &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; arguments is also very useful in this context as the script string remains constant and can be efficiently cached by Redis.</source>
          <target state="translated">Передача ключей и аргументов в качестве дополнительных аргументов &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; также очень полезна в этом контексте, поскольку строка сценария остается постоянной и может быть эффективно кэширована Redis.</target>
        </trans-unit>
        <trans-unit id="19999dd613b36fb0786e599a84893b1e8a156a95" translate="yes" xml:space="preserve">
          <source>Pattern: Circular list</source>
          <target state="translated">Узор:Круглый список</target>
        </trans-unit>
        <trans-unit id="4d81f3aa2a2c95fc4a2b98f51dce59a3bb00d586" translate="yes" xml:space="preserve">
          <source>Pattern: Counter</source>
          <target state="translated">Узор:Счетчик</target>
        </trans-unit>
        <trans-unit id="73ea3bc6eae64663018b769f7c415b912584ee38" translate="yes" xml:space="preserve">
          <source>Pattern: Event notification</source>
          <target state="translated">Узор:Уведомление о событии</target>
        </trans-unit>
        <trans-unit id="9ff13cc43cfbf608a403dd95aced2e1c0f9fa96b" translate="yes" xml:space="preserve">
          <source>Pattern: Navigation session</source>
          <target state="translated">Узор:Сеанс навигации</target>
        </trans-unit>
        <trans-unit id="a7fd682d147cfd39262ca78719007b5177407a15" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter</source>
          <target state="translated">Образец:Ограничитель скорости</target>
        </trans-unit>
        <trans-unit id="527a190ff3f82d3d4bdfebea8586b0d301a67e3d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 1</source>
          <target state="translated">Узор:Ограничитель скорости 1</target>
        </trans-unit>
        <trans-unit id="d037a3f2c416c91b7789e304c06bd5786301383d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 2</source>
          <target state="translated">Узор:Ограничитель скорости 2</target>
        </trans-unit>
        <trans-unit id="18e48daae4954154a5de8c81ecf51283e080aacd" translate="yes" xml:space="preserve">
          <source>Pattern: Reliable queue</source>
          <target state="translated">Узор:Надежная очередь</target>
        </trans-unit>
        <trans-unit id="bc4ebd36f01622a36d608ba3197fe5c6b53d07d7" translate="yes" xml:space="preserve">
          <source>Pattern: Time series</source>
          <target state="translated">Узор:Временной ряд</target>
        </trans-unit>
        <trans-unit id="aaa32185c003a60c49d4fa1de6cdca30261f99bd" translate="yes" xml:space="preserve">
          <source>Pattern: accessing the entire bitmap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa9774204b5b0358a99c12a75b97dace59e135d" translate="yes" xml:space="preserve">
          <source>Pattern: real time metrics using bitmaps</source>
          <target state="translated">Модель:метрика в реальном времени с использованием растровых изображений</target>
        </trans-unit>
        <trans-unit id="387aa2d6e23537ab60fac1801379d3a3550c02d6" translate="yes" xml:space="preserve">
          <source>Pattern: real-time metrics using bitmaps</source>
          <target state="translated">Pattern:метрики в реальном времени с использованием растровых изображений</target>
        </trans-unit>
        <trans-unit id="4fd48af62eda73b71f46321f27a6f38fb4751056" translate="yes" xml:space="preserve">
          <source>Pattern: setting multiple bits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f113cb1df36820baa76cc50b4089ad6af9aea4" translate="yes" xml:space="preserve">
          <source>Pattern: weighted random selection of an element</source>
          <target state="translated">Шаблон:взвешенный случайный выбор элемента</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="65bb2cda328eeb96caf6c6dce99ad10ccece742e" translate="yes" xml:space="preserve">
          <source>Pause the clients using &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;</source>
          <target state="translated">Приостановить клиентов с помощью &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="172162ae29287e5e829be8811d680119905ff86b" translate="yes" xml:space="preserve">
          <source>Perform a bitwise operation between multiple keys (containing string values) and store the result in the destination key.</source>
          <target state="translated">Выполните битовую операцию между несколькими ключами (содержащими значения строк)и сохраните результат в ключе назначения.</target>
        </trans-unit>
        <trans-unit id="1627d1d0d50fdeb9a3dce196f5de79d8f43842c0" translate="yes" xml:space="preserve">
          <source>Perform a blocking SAVE if at least one &lt;strong&gt;save point&lt;/strong&gt; is configured.</source>
          <target state="translated">Выполните блокирующее СОХРАНИТЬ, если настроена хотя бы одна &lt;strong&gt;точка сохранения&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c05e233359dba5b59b70fc0039c9fb4fdb4976d0" translate="yes" xml:space="preserve">
          <source>Perform a partial resynchronization after a disconnection.</source>
          <target state="translated">Выполните частичную ресинхронизацию после отключения.</target>
        </trans-unit>
        <trans-unit id="9d05c962f81bccc17939e7dff46bacb302dd37a2" translate="yes" xml:space="preserve">
          <source>Perform the SHA1 of the input string.</source>
          <target state="translated">Выполните SHA1 входной строки.</target>
        </trans-unit>
        <trans-unit id="0cb883fc85b1fd84aaebb7319c682c586a065641" translate="yes" xml:space="preserve">
          <source>Performance considerations</source>
          <target state="translated">Показатели эффективности</target>
        </trans-unit>
        <trans-unit id="c5453c00c8e4c4429dffd7c57ff9e409df17e57a" translate="yes" xml:space="preserve">
          <source>Performances</source>
          <target state="translated">Performances</target>
        </trans-unit>
        <trans-unit id="98a191010a72a819b496571f1515f19fc5db230c" translate="yes" xml:space="preserve">
          <source>Please check the example below and the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; documentation for more information about the command and its options.</source>
          <target state="translated">Пожалуйста, проверьте пример ниже и документацию &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; для получения дополнительной информации о команде и ее параметрах.</target>
        </trans-unit>
        <trans-unit id="2adb7fe266cd87cc96a429b9dce43b2d62d33470" translate="yes" xml:space="preserve">
          <source>Please for the specific semantics of the command refer to the documentation of &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;.</source>
          <target state="translated">Для получения информации о конкретной семантике команды обратитесь к документации &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d37ebc2f4f2d1c9e1508f49167dd6105a3aa57b4" translate="yes" xml:space="preserve">
          <source>Please note depending on the version of Redis some of the fields have been added or removed. A robust client application should therefore parse the result of this command by skipping unknown properties, and gracefully handle missing fields.</source>
          <target state="translated">Обратите внимание,что в зависимости от версии Redis некоторые из полей были добавлены или удалены.Поэтому надежное клиентское приложение должно разобрать результат этой команды,пропустив неизвестные свойства,и изящно обработать недостающие поля.</target>
        </trans-unit>
        <trans-unit id="cf36c5202e34a4a67ab38d9f9bd7222bda763dfd" translate="yes" xml:space="preserve">
          <source>Please note that before reading this page, if you are new to streams, we recommend to read &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;our introduction to Redis Streams&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что перед чтением этой страницы, если вы новичок в потоках, мы рекомендуем прочитать &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;наше введение в Redis Streams&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="95e0253f33057b2f70a061e11de2d3d4a685d9c7" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; documentation for detailed information about Redis Lua scripting.</source>
          <target state="translated">Пожалуйста, обратитесь к документации &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; для получения подробной информации о сценариях Redis Lua.</target>
        </trans-unit>
        <trans-unit id="67fc81a1bc0292fa12fdf63856d1ae3a69b0523a" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence documentation&lt;/a&gt; for detailed information.</source>
          <target state="translated">Пожалуйста, обратитесь к &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;документации&lt;/a&gt; по постоянству для получения подробной информации.</target>
        </trans-unit>
        <trans-unit id="13eff9f035082f1c14cd73067127e19e708dd746" translate="yes" xml:space="preserve">
          <source>Please see the pattern description in the &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a135ffdb71c43178f876e40f960bf45f1a29237" translate="yes" xml:space="preserve">
          <source>Please see the pattern description in the &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; documentation.</source>
          <target state="translated">См. Описание шаблона в документации &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aed6d393dd61d1ba31957e351636ff901b0e6fa8" translate="yes" xml:space="preserve">
          <source>Posts a message to the given channel.</source>
          <target state="translated">Размещает сообщение на данном канале.</target>
        </trans-unit>
        <trans-unit id="f815dfb4f6f438e54dc2f0a16193e4c96d3c1109" translate="yes" xml:space="preserve">
          <source>Practically speaking, for the client it is much better to simply assume that in the context of a given connection, cached scripts are guaranteed to be there unless an administrator explicitly called the &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; command.</source>
          <target state="translated">С практической точки зрения, для клиента гораздо лучше просто предположить, что в контексте данного соединения кэшированные сценарии гарантированно присутствуют, если администратор явно не вызвал команду &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d8c495de1a9098dd3bc4b934ccc859d56035029" translate="yes" xml:space="preserve">
          <source>Produces an ASCII-art style graph for the specified event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d21fc376a96084ebb73d4e8b35c0a4c4be845e0" translate="yes" xml:space="preserve">
          <source>Provide information on the role of a Redis instance in the context of replication, by returning if the instance is currently a &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;slave&lt;/code&gt;, or &lt;code&gt;sentinel&lt;/code&gt;. The command also returns additional information about the state of the replication (if the role is master or slave) or the list of monitored master names (if the role is sentinel).</source>
          <target state="translated">Предоставьте информацию о роли экземпляра Redis в контексте репликации, вернув, является ли экземпляр в настоящее время &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;slave&lt;/code&gt; или &lt;code&gt;sentinel&lt;/code&gt; . Команда также возвращает дополнительную информацию о состоянии репликации (если роль - главная или подчиненная) или список отслеживаемых главных имен (если роль - дозорная).</target>
        </trans-unit>
        <trans-unit id="7ca91750d60fd45e80636934b3d1f1da26ffd9f9" translate="yes" xml:space="preserve">
          <source>Pub/Sub</source>
          <target state="translated">Pub/Sub</target>
        </trans-unit>
        <trans-unit id="5860c8458788e44e7636fa364548e067049a0d7b" translate="yes" xml:space="preserve">
          <source>QUIT</source>
          <target state="translated">QUIT</target>
        </trans-unit>
        <trans-unit id="7471799996c7de46c4ffa444365596fb514b6f5a" translate="yes" xml:space="preserve">
          <source>QUIT   Close the connection</source>
          <target state="translated">QUIT Закрыть соединение</target>
        </trans-unit>
        <trans-unit id="baa5d3184c0cc0ce5e007af06198524a4d26548f" translate="yes" xml:space="preserve">
          <source>Quit the server.</source>
          <target state="translated">Уходите с сервера.</target>
        </trans-unit>
        <trans-unit id="94386a96dc3f69665a14e74fb2942d92163c5d74" translate="yes" xml:space="preserve">
          <source>RANDOMKEY</source>
          <target state="translated">RANDOMKEY</target>
        </trans-unit>
        <trans-unit id="338552ba06825ef4f555f3d5ff79d40557c925de" translate="yes" xml:space="preserve">
          <source>RANDOMKEY   Return a random key from the keyspace</source>
          <target state="translated">RANDOMKEY Возврат случайного ключа из клавишного пространства</target>
        </trans-unit>
        <trans-unit id="90a97e888676c2d0f3b14c8b4a5ca16d360880bc" translate="yes" xml:space="preserve">
          <source>READONLY</source>
          <target state="translated">READONLY</target>
        </trans-unit>
        <trans-unit id="21d1a8e094bd428debefea84e6dd96322d4c6011" translate="yes" xml:space="preserve">
          <source>READONLY   Enables read queries for a connection to a cluster replica node</source>
          <target state="translated">READONLY Включает запросы на чтение для подключения к узлу реплики кластера.</target>
        </trans-unit>
        <trans-unit id="5305e8529d963d471cecc6faf967cedff2ea7494" translate="yes" xml:space="preserve">
          <source>READWRITE</source>
          <target state="translated">READWRITE</target>
        </trans-unit>
        <trans-unit id="2ae19352a72e6e879b7c82d353a544f20f6b355b" translate="yes" xml:space="preserve">
          <source>READWRITE   Disables read queries for a connection to a cluster replica node</source>
          <target state="translated">READWRITE Отключает запросы на чтение для подключения к узлу реплики кластера</target>
        </trans-unit>
        <trans-unit id="4756081595ff9366e8b59c094aebf3df53a8fc98" translate="yes" xml:space="preserve">
          <source>RENAME</source>
          <target state="translated">RENAME</target>
        </trans-unit>
        <trans-unit id="434016433de8ed51fc6a3df25c58d49e8397ca2e" translate="yes" xml:space="preserve">
          <source>RENAME  key newkey   Rename a key</source>
          <target state="translated">Переименовать ключ Переименовать ключ</target>
        </trans-unit>
        <trans-unit id="eb9b6064a90c47e23a80adefc9b43f4215668dbe" translate="yes" xml:space="preserve">
          <source>RENAMENX</source>
          <target state="translated">RENAMENX</target>
        </trans-unit>
        <trans-unit id="e1288934ac4d4000f51ff88bf791420487a34758" translate="yes" xml:space="preserve">
          <source>RENAMENX  key newkey   Rename a key, only if the new key does not exist</source>
          <target state="translated">Переименовать ключ Переименовать ключ,только если новый ключ не существует.</target>
        </trans-unit>
        <trans-unit id="12c92fcd35c554e1970345d0c852363a2bfff485" translate="yes" xml:space="preserve">
          <source>REPLICAOF</source>
          <target state="translated">REPLICAOF</target>
        </trans-unit>
        <trans-unit id="81253c78d1304948f92fc2d7488335ba2280cd3f" translate="yes" xml:space="preserve">
          <source>REPLICAOF  host port   Make the server a replica of another instance, or promote it as master.</source>
          <target state="translated">REPLICAOF порт хоста Сделать сервер копией другого экземпляра,или продвинуть его в качестве ведущего.</target>
        </trans-unit>
        <trans-unit id="995f2d9ddfbe7ab63a2a7ddd59856b61ae272710" translate="yes" xml:space="preserve">
          <source>RESET</source>
          <target state="translated">RESET</target>
        </trans-unit>
        <trans-unit id="1b3151a71b95e8cdeb31ff88835e69beefec4ac4" translate="yes" xml:space="preserve">
          <source>RESET   Reset the connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8135bcdb582d28d5425eef52faf6ac80eefb26" translate="yes" xml:space="preserve">
          <source>RESTORE</source>
          <target state="translated">RESTORE</target>
        </trans-unit>
        <trans-unit id="693be3f2ba1e3d54a77f2bd81f59053740c9352a" translate="yes" xml:space="preserve">
          <source>RESTORE  key ttl serialized-value [REPLACE]   Create a key using the provided serialized value, previously obtained using DUMP.</source>
          <target state="translated">RESTORE ключ ttl сериализованного значения [REPLACE]Создайте ключ,используя предоставленное сериализованное значение,ранее полученное с помощью DUMP.</target>
        </trans-unit>
        <trans-unit id="e604e0070c2d8dbd159ab393d370ee42dc12812f" translate="yes" xml:space="preserve">
          <source>RESTORE  key ttl serialized-value [REPLACE] [ABSTTL] [IDLETIME seconds] [FREQ frequency]   Create a key using the provided serialized value, previously obtained using DUMP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1631070e7f0b44982ae66b11640654e7ec5dc4bd" translate="yes" xml:space="preserve">
          <source>ROLE</source>
          <target state="translated">ROLE</target>
        </trans-unit>
        <trans-unit id="5b2e8afa66ad35a6843b32ab5ca521321ed80e09" translate="yes" xml:space="preserve">
          <source>ROLE   Return the role of the instance in the context of replication</source>
          <target state="translated">ROLE Возврат роли экземпляра в контексте репликации</target>
        </trans-unit>
        <trans-unit id="b7ce3009275f8c79b50c7f42dcb85f259fc1334f" translate="yes" xml:space="preserve">
          <source>RPOP</source>
          <target state="translated">RPOP</target>
        </trans-unit>
        <trans-unit id="daae95751cd7b3b0d6286ba595f17b95a4dbf14d" translate="yes" xml:space="preserve">
          <source>RPOP  key   Remove and get the last element in a list</source>
          <target state="translated">Клавиша RPOP Удалить и получить последний элемент в списке</target>
        </trans-unit>
        <trans-unit id="153bcead99c65ede929618b160dd530ec6817223" translate="yes" xml:space="preserve">
          <source>RPOP  key [count]   Remove and get the last elements in a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc91e22c7eda82f26217a9a276a557189795a83" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH</source>
          <target state="translated">RPOPLPUSH</target>
        </trans-unit>
        <trans-unit id="9b4f14c63b639db09e2a8cbabb9aee76bf074fd7" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH  source destination   Remove the last element in a list, prepend it to another list and return it</source>
          <target state="translated">Назначение источника RPOPLPUSH Удалить последний элемент списка,подготовить его к другому списку и вернуть его.</target>
        </trans-unit>
        <trans-unit id="b9d73dc860be3da3eb63b95dc888be66d34c596b" translate="yes" xml:space="preserve">
          <source>RPUSH</source>
          <target state="translated">RPUSH</target>
        </trans-unit>
        <trans-unit id="3c855c64755366500528d84baa161e66c153eb2f" translate="yes" xml:space="preserve">
          <source>RPUSH  key element [element ...]   Append one or multiple elements to a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9293df01dd3379605fef72d334681379153757" translate="yes" xml:space="preserve">
          <source>RPUSH  key value [value ...]   Append one or multiple values to a list</source>
          <target state="translated">RPUSH-значение клавиши [значение ...]Добавить одно или несколько значений в список.</target>
        </trans-unit>
        <trans-unit id="a2fe5b491151e540de6422c6e85592df5f204dc3" translate="yes" xml:space="preserve">
          <source>RPUSHX</source>
          <target state="translated">RPUSHX</target>
        </trans-unit>
        <trans-unit id="9ca949029559acfa6521e4bf6649e713de5742b1" translate="yes" xml:space="preserve">
          <source>RPUSHX  key element [element ...]   Append an element to a list, only if the list exists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d6ff5cbc32d5fc0ed38bfb10b34d14916d1c00" translate="yes" xml:space="preserve">
          <source>RPUSHX  key value   Append a value to a list, only if the list exists</source>
          <target state="translated">RPUSHX значение ключа Добавить значение к списку,только если список существует.</target>
        </trans-unit>
        <trans-unit id="a31a9b75b6318e8c48bf5d454b96698ee608da57" translate="yes" xml:space="preserve">
          <source>Range of integer scores that can be expressed precisely</source>
          <target state="translated">Диапазон целочисленных баллов,которые могут быть выражены точно</target>
        </trans-unit>
        <trans-unit id="df8903174eb3eac863f1253076caa8171702cb53" translate="yes" xml:space="preserve">
          <source>Range: 3900-4000</source>
          <target state="translated">Диапазон:3900-4000</target>
        </trans-unit>
        <trans-unit id="e1d33f7270a253d76d9b6fe1deb9155ecce0ca42" translate="yes" xml:space="preserve">
          <source>Read data from one or multiple streams, only returning entries with an ID greater than the last received ID reported by the caller. This command has an option to block if items are not available, in a similar fashion to &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; or &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; and others.</source>
          <target state="translated">Считывать данные из одного или нескольких потоков, возвращая только записи с идентификатором, превышающим последний полученный идентификатор, указанный вызывающей стороной. Эта команда имеет возможность блокировать , если элементы будут недоступны, аналогичным образом к &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; или &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; и другим.</target>
        </trans-unit>
        <trans-unit id="58ccdcefd173a8269ea376346a634ff6e968e57b" translate="yes" xml:space="preserve">
          <source>Read only variants</source>
          <target state="translated">Только для чтения варианты</target>
        </trans-unit>
        <trans-unit id="b8590ac877c85f2030d4921db5e93ead78595a0f" translate="yes" xml:space="preserve">
          <source>Read queries against a Redis Cluster slave node are disabled by default, but you can use the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command to change this behavior on a per- connection basis. The &lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt; command resets the readonly mode flag of a connection back to readwrite.</source>
          <target state="translated">Запросы чтения к подчиненному узлу Redis Cluster по умолчанию отключены, но вы можете использовать команду &lt;a href=&quot;readonly&quot;&gt;READONLY,&lt;/a&gt; чтобы изменить это поведение для каждого соединения. Команда &lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt; сбрасывает флаг режима только для чтения соединения обратно на чтение и запись.</target>
        </trans-unit>
        <trans-unit id="9ec77fdefc87d676b3e9acb9a7b04ded405da8e4" translate="yes" xml:space="preserve">
          <source>Reading application code, the complete semantics might not be clear since the application calls commands defined server side.</source>
          <target state="translated">Читая код приложения,полная семантика может быть нечеткой,так как приложение вызывает команды,определенные на стороне сервера.</target>
        </trans-unit>
        <trans-unit id="116cec955773e978e0eecf1499a10199d4278c99" translate="yes" xml:space="preserve">
          <source>Reading the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streams introduction&lt;/a&gt; is highly suggested in order to understand more about the streams overall behavior and semantics.</source>
          <target state="translated">Настоятельно рекомендуется прочитать &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;введение Redis Streams&lt;/a&gt; , чтобы лучше понять общее поведение и семантику потоков.</target>
        </trans-unit>
        <trans-unit id="88951d0701502f598feecc55f4d3172c32a2db31" translate="yes" xml:space="preserve">
          <source>Reading the slow log</source>
          <target state="translated">Чтение медленного журнала</target>
        </trans-unit>
        <trans-unit id="a87de541283ca3bc3c0a398706ee3346da0564e3" translate="yes" xml:space="preserve">
          <source>Recent versions of Redis Sentinel (Redis 2.8.12 or greater) use CLIENT KILL in order to kill clients when an instance is reconfigured, in order to force clients to perform the handshake with one Sentinel again and update its configuration.</source>
          <target state="translated">Последние версии Redis Sentinel (Redis 2.8.12 или более поздние)используют CLIENT KILL (УДОБИТЕЛЬНОЕ ПОЛУЧЕНИЕ)для того,чтобы убить клиентов при изменении конфигурации экземпляра,чтобы заставить клиентов выполнить повторное рукопожатие с одним Sentinel и обновить его конфигурацию.</target>
        </trans-unit>
        <trans-unit id="68c1dff2ef06724a3eb5f0a503f24117784a62d1" translate="yes" xml:space="preserve">
          <source>Reconfigure clients to connect with the new master.</source>
          <target state="translated">Реконфигурируйте клиентов для связи с новым мастером.</target>
        </trans-unit>
        <trans-unit id="24071b57a13027c01339027dcccb98218f052a8f" translate="yes" xml:space="preserve">
          <source>Redis</source>
          <target state="translated">Redis</target>
        </trans-unit>
        <trans-unit id="64fb7fd6108bc6be312c9ee1e4ae786b08c32a13" translate="yes" xml:space="preserve">
          <source>Redis 3.2 introduced an optional &lt;code&gt;count&lt;/code&gt; argument that can be passed to &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; in order to retrieve multiple elements in a single call.</source>
          <target state="translated">Redis 3.2 представил необязательный аргумент &lt;code&gt;count&lt;/code&gt; , который можно передать в &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; , чтобы получить несколько элементов за один вызов.</target>
        </trans-unit>
        <trans-unit id="ff9622e92b582b377cd9d107f3253f8a189b7cf9" translate="yes" xml:space="preserve">
          <source>Redis 6 connections starts in RESP2 mode, so clients implementing RESP2 do not need to change (nor there are short term plans to drop support for RESP2). Clients that want to handshake the RESP3 mode need to call the &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command, using &quot;3&quot; as first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09da59c00f13190142c29bd0fc09b7580fb99363" translate="yes" xml:space="preserve">
          <source>Redis Cluster live resharding explained</source>
          <target state="translated">Кластер Redis в прямом эфире объяснил</target>
        </trans-unit>
        <trans-unit id="8be0343488efef207b0826c15486c08f81f5710d" translate="yes" xml:space="preserve">
          <source>Redis HyperLogLogs are represented using a double representation: the &lt;em&gt;sparse&lt;/em&gt; representation suitable for HLLs counting a small number of elements (resulting in a small number of registers set to non-zero value), and a &lt;em&gt;dense&lt;/em&gt; representation suitable for higher cardinalities. Redis automatically switches from the sparse to the dense representation when needed.</source>
          <target state="translated">Redis HyperLogLogs представлены с использованием двойного представления: &lt;em&gt;разреженное&lt;/em&gt; представление, подходящее для HLL, подсчитывающее небольшое количество элементов (что приводит к небольшому количеству регистров, установленных на ненулевое значение), и &lt;em&gt;плотное&lt;/em&gt; представление, подходящее для более высоких мощностей. Redis автоматически переключается с разреженного на плотное представление, когда это необходимо.</target>
        </trans-unit>
        <trans-unit id="2e645ecd73ea1ffa136575150e55a17bbdaf4a35" translate="yes" xml:space="preserve">
          <source>Redis Nil bulk reply and Nil multi bulk reply -&amp;gt; Lua false boolean type</source>
          <target state="translated">Redis Nil массовый ответ и Nil мульти массовый ответ -&amp;gt; логический тип Lua false</target>
        </trans-unit>
        <trans-unit id="12deb2b7b17fe48280b9acc8ac6e268a2fccdfc8" translate="yes" xml:space="preserve">
          <source>Redis bulk reply -&amp;gt; Lua string</source>
          <target state="translated">Redis массовый ответ -&amp;gt; строка Lua</target>
        </trans-unit>
        <trans-unit id="28c992585f8b92e96ef7862e17fbc69b72429ffe" translate="yes" xml:space="preserve">
          <source>Redis commands that may return elements in random order, like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (because Redis Sets are &lt;em&gt;unordered&lt;/em&gt;) have a different behavior when called from Lua, and undergo a silent lexicographical sorting filter before returning data to Lua scripts. So &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; will always return the Set elements in the same order, while the same command invoked from normal clients may return different results even if the key contains exactly the same elements.</source>
          <target state="translated">Команды Redis, которые могут возвращать элементы в случайном порядке, такие как &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (поскольку наборы Redis &lt;em&gt;неупорядочены&lt;/em&gt; ), имеют другое поведение при вызове из Lua и проходят тихий лексикографический фильтр сортировки перед возвратом данных в сценарии Lua. Таким образом, &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; всегда будет возвращать элементы Set в одном и том же порядке, в то время как одна и та же команда, вызванная из обычных клиентов, может возвращать разные результаты, даже если ключ содержит точно такие же элементы.</target>
        </trans-unit>
        <trans-unit id="9030a22b56473e440d80783adf7755f42e3cd798" translate="yes" xml:space="preserve">
          <source>Redis commands usually accept one key, two keys, or an unlimited number of keys.</source>
          <target state="translated">Команды Redis обычно принимают один ключ,два ключа или неограниченное количество ключей.</target>
        </trans-unit>
        <trans-unit id="4798309557a5e9b4d97ab42c59e238806f00fa04" translate="yes" xml:space="preserve">
          <source>Redis different selectable databases are a form of namespacing: all the databases are anyway persisted together in the same RDB / AOF file. However different databases can have keys having the same name, and there are commands available like &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;, &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; or &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; that work on specific databases.</source>
          <target state="translated">Различные выбираемые базы данных Redis - это форма пространственного именования: все базы данных в любом случае сохраняются вместе в одном файле RDB / AOF. Однако разные базы данных могут иметь ключи с одинаковыми именами, и доступны такие команды, как &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; , &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; или &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY,&lt;/a&gt; которые работают с конкретными базами данных.</target>
        </trans-unit>
        <trans-unit id="9e3076b9d3288c97597280422f53f06eb0450c13" translate="yes" xml:space="preserve">
          <source>Redis double reply -&amp;gt; Lua table with a single &lt;code&gt;score&lt;/code&gt; field containing a Lua number representing the double value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a48311c837dbe1e0c3cec8f3114d4df2e8c16385" translate="yes" xml:space="preserve">
          <source>Redis error reply -&amp;gt; Lua table with a single &lt;code&gt;err&lt;/code&gt; field containing the error</source>
          <target state="translated">Ответ об ошибке Redis -&amp;gt; Таблица Lua с одним полем &lt;code&gt;err&lt;/code&gt; , содержащим ошибку</target>
        </trans-unit>
        <trans-unit id="26c2d6e6bcc8ce21554bdf0baf74815e6f8c13dd" translate="yes" xml:space="preserve">
          <source>Redis false reply -&amp;gt; Lua false boolean value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="562ad79eb5fcdcd97d8a0283855bce99c0023855" translate="yes" xml:space="preserve">
          <source>Redis integer reply -&amp;gt; Lua number</source>
          <target state="translated">Целочисленный ответ Redis -&amp;gt; номер Lua</target>
        </trans-unit>
        <trans-unit id="53c0959152bcf66e99f3ab4d98ebaba488b539de" translate="yes" xml:space="preserve">
          <source>Redis is UTF-8 aware, assuming you correctly set the &lt;code&gt;!LC_COLLATE&lt;/code&gt; environment variable.</source>
          <target state="translated">Redis поддерживает UTF-8, если вы правильно установили переменную среды &lt;code&gt;!LC_COLLATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac11208b3186492fddcf23ffb985bed2f4b921dd" translate="yes" xml:space="preserve">
          <source>Redis is now able to delete keys in the background in a different thread without blocking the server. An &lt;code&gt;ASYNC&lt;/code&gt; option was added to &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; and &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; in order to let the entire dataset or a single database to be freed asynchronously.</source>
          <target state="translated">Redis теперь может удалять ключи в фоновом режиме в другом потоке, не блокируя сервер. &lt;code&gt;ASYNC&lt;/code&gt; вариант был добавлен в &lt;a href=&quot;flushall&quot;&gt;FlushAll&lt;/a&gt; и &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; для того , чтобы позволить весь набор данных или единой базы данных , которые будут освобождены асинхронно.</target>
        </trans-unit>
        <trans-unit id="f26191bd07f5d296d686b49ddf0fea28de008280" translate="yes" xml:space="preserve">
          <source>Redis is often used as a messaging server to implement processing of background jobs or other kinds of messaging tasks. A simple form of queue is often obtained pushing values into a list in the producer side, and waiting for this values in the consumer side using &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; (using polling), or &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; if the client is better served by a blocking operation.</source>
          <target state="translated">Redis часто используется в качестве сервера обмена сообщениями для выполнения обработки фоновых заданий или других задач обмена сообщениями. Простая форма очереди часто получается путем помещения значений в список на стороне производителя и ожидания этих значений на стороне потребителя с использованием &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; (с использованием опроса) или &lt;a href=&quot;brpop&quot;&gt;BRPOP,&lt;/a&gt; если клиент лучше обслуживается операцией блокировки.</target>
        </trans-unit>
        <trans-unit id="42a27bac8c1f348420272658d3c655887b07c3ba" translate="yes" xml:space="preserve">
          <source>Redis keys are expired in two ways: a passive way, and an active way.</source>
          <target state="translated">Срок действия клавиш Redis истекает двумя способами:пассивным и активным.</target>
        </trans-unit>
        <trans-unit id="ea38abb16e6fc53c1055d716b8dafffc97128c14" translate="yes" xml:space="preserve">
          <source>Redis logs that a script is running too long.</source>
          <target state="translated">Redis записывает,что сценарий работает слишком долго.</target>
        </trans-unit>
        <trans-unit id="07c6c60386c8d0b1cb8c0291d6e6212cf17c794b" translate="yes" xml:space="preserve">
          <source>Redis map reply -&amp;gt; Lua table with a single &lt;code&gt;map&lt;/code&gt; field containing a Lua table representing the fields and values of the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ada15ccb812ae3dfe260cac4cea16ab388a5061" translate="yes" xml:space="preserve">
          <source>Redis multi bulk reply -&amp;gt; Lua table (may have other Redis data types nested)</source>
          <target state="translated">Многократный массовый ответ Redis -&amp;gt; Таблица Lua (могут быть вложены другие типы данных Redis)</target>
        </trans-unit>
        <trans-unit id="6afefff72418c96bb7166299d904551e6e4c186a" translate="yes" xml:space="preserve">
          <source>Redis new RESP3 single null value -&amp;gt; Lua nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb910cc16645a1fbd760219098ebcbf7bc9f050c" translate="yes" xml:space="preserve">
          <source>Redis offers a SCRIPT command that can be used in order to control the scripting subsystem. SCRIPT currently accepts three different commands:</source>
          <target state="translated">Redis предлагает команду SCRIPT,которую можно использовать для управления подсистемой сценариев.В настоящее время SCRIPT принимает три различные команды:</target>
        </trans-unit>
        <trans-unit id="0ab17f17e02f188a1bdf8cac0d6180f82fee1717" translate="yes" xml:space="preserve">
          <source>Redis return values are converted into Lua data types when Lua calls a Redis command using &lt;code&gt;call()&lt;/code&gt; or &lt;code&gt;pcall()&lt;/code&gt;. Similarly, Lua data types are converted into the Redis protocol when calling a Redis command and when a Lua script returns a value, so that scripts can control what &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; will return to the client.</source>
          <target state="translated">Возвращаемые значения Redis преобразуются в типы данных Lua, когда Lua вызывает команду Redis с помощью &lt;code&gt;call()&lt;/code&gt; или &lt;code&gt;pcall()&lt;/code&gt; . Точно так же типы данных Lua преобразуются в протокол Redis при вызове команды Redis и когда сценарий Lua возвращает значение, так что сценарии могут управлять тем, что &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; будет возвращать клиенту.</target>
        </trans-unit>
        <trans-unit id="0fa967ae24b949a1700795759c8cdfe062988a8a" translate="yes" xml:space="preserve">
          <source>Redis scripts are not allowed to create global variables, in order to avoid leaking data into the Lua state. If a script needs to maintain state between calls (a pretty uncommon need) it should use Redis keys instead.</source>
          <target state="translated">Скрипты Redis не позволяют создавать глобальные переменные,чтобы избежать утечки данных в состояние Lua.Если скрипту необходимо поддерживать состояние между вызовами (довольно редкая необходимость),он должен использовать клавиши Redis.</target>
        </trans-unit>
        <trans-unit id="62adbd77b4f8fad448a651b5f523abd0f146da57" translate="yes" xml:space="preserve">
          <source>Redis set reply -&amp;gt; Lua table with a single &lt;code&gt;set&lt;/code&gt; field containing a Lua table representing the elements of the set as fields, having as value just &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e62135b0922f82850c893085d4cd08cc6fd7ccb4" translate="yes" xml:space="preserve">
          <source>Redis slow log overview</source>
          <target state="translated">Медленный обзор журнала Redis</target>
        </trans-unit>
        <trans-unit id="add967db3e0dd55b3522bf60d87afa3192a4838a" translate="yes" xml:space="preserve">
          <source>Redis sorted sets use a &lt;em&gt;double 64-bit floating point number&lt;/em&gt; to represent the score. In all the architectures we support, this is represented as an &lt;strong&gt;IEEE 754 floating point number&lt;/strong&gt;, that is able to represent precisely integer numbers between &lt;code&gt;-(2^53)&lt;/code&gt; and &lt;code&gt;+(2^53)&lt;/code&gt; included. In more practical terms, all the integers between -9007199254740992 and 9007199254740992 are perfectly representable. Larger integers, or fractions, are internally represented in exponential form, so it is possible that you get only an approximation of the decimal number, or of the very big integer, that you set as score.</source>
          <target state="translated">Сортированные наборы Redis используют &lt;em&gt;двойное 64-битное число&lt;/em&gt; с &lt;em&gt;плавающей запятой&lt;/em&gt; для представления оценки. Во всех поддерживаемых нами архитектурах это представлено как число с &lt;strong&gt;плавающей запятой IEEE 754&lt;/strong&gt; , которое может точно представлять целые числа от &lt;code&gt;-(2^53)&lt;/code&gt; до &lt;code&gt;+(2^53)&lt;/code&gt; включительно. С практической точки зрения, все целые числа от -9007199254740992 до 9007199254740992 прекрасно представимы. Более крупные целые числа или дроби внутренне представлены в экспоненциальной форме, поэтому возможно, что вы получите только приблизительное значение десятичного числа или очень большого целого числа, которое вы установили в качестве оценки.</target>
        </trans-unit>
        <trans-unit id="738a4a620b4c28b97c15ca1b2edd5526cb23af29" translate="yes" xml:space="preserve">
          <source>Redis status reply -&amp;gt; Lua table with a single &lt;code&gt;ok&lt;/code&gt; field containing the status</source>
          <target state="translated">Ответ статуса Redis -&amp;gt; Таблица Lua с единственным полем &lt;code&gt;ok&lt;/code&gt; , содержащим статус</target>
        </trans-unit>
        <trans-unit id="db935d0902ab47146d7cddc707ae23f8dbd30e13" translate="yes" xml:space="preserve">
          <source>Redis stores integers in their integer representation, so for string values that actually hold an integer, there is no overhead for storing the string representation of the integer.</source>
          <target state="translated">Redis хранит целые числа в их целочисленном представлении,поэтому для строковых значений,которые на самом деле содержат целое число,нет накладных расходов на хранение строкового представления целого числа.</target>
        </trans-unit>
        <trans-unit id="b6955638f080137455ca2315a3e774bacb29e670" translate="yes" xml:space="preserve">
          <source>Redis streams are represented in a way that makes them memory efficient: a radix tree is used in order to index macro-nodes that pack linearly tens of stream entries. Normally what happens when you delete an entry from a stream is that the entry is not &lt;em&gt;really&lt;/em&gt; evicted, it just gets marked as deleted.</source>
          <target state="translated">Потоки Redis представлены таким образом, чтобы они экономили память: для индексации макроузлов, которые линейно упаковывают десятки записей потока, используется основание системы счисления. Обычно то , что происходит при удалении записи из потока является то , что запись не &lt;em&gt;действительно&lt;/em&gt; выселили, он просто получает помечаются как удаленные.</target>
        </trans-unit>
        <trans-unit id="5d32a14fd1723b346b2a3b7e8ab15af43e61bb43" translate="yes" xml:space="preserve">
          <source>Redis true reply -&amp;gt; Lua true boolean value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7af6984c788798f4aee1b72f3fb15136c972f4" translate="yes" xml:space="preserve">
          <source>Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;. From the point of view of all the other clients the effects of a script are either still not visible or already completed.</source>
          <target state="translated">Redis использует один и тот же интерпретатор Lua для выполнения всех команд. Также Redis гарантирует, что сценарий выполняется атомарно: ни один другой сценарий или команда Redis не будет выполняться во время выполнения сценария. Эта семантика аналогична семантике &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; . С точки зрения всех остальных клиентов эффекты сценария либо еще не видны, либо уже выполнены.</target>
        </trans-unit>
        <trans-unit id="358fd429e373e6f088abb4b934d2faf8511ecbc9" translate="yes" xml:space="preserve">
          <source>Redis versions prior of Redis 6 were only able to understand the one argument version of the command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315e6feef25876fa664b37d723e94c657b1c8f6a" translate="yes" xml:space="preserve">
          <source>Redis will block the script with an error if a script calls a Redis command able to alter the data set &lt;strong&gt;after&lt;/strong&gt; a Redis &lt;em&gt;random&lt;/em&gt; command like &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;, &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;, &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;. This means that if a script is read-only and does not modify the data set it is free to call those commands. Note that a &lt;em&gt;random command&lt;/em&gt; does not necessarily mean a command that uses random numbers: any non-deterministic command is considered a random command (the best example in this regard is the &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; command).</source>
          <target state="translated">Redis будет блокировать скрипт с ошибкой , если сценарий вызывает Redis команды может изменить набор данных , &lt;strong&gt;после&lt;/strong&gt; того, как в Redis &lt;em&gt;случайной&lt;/em&gt; команды как использование &lt;a href=&quot;randomkey&quot;&gt;случайного&lt;/a&gt; , &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt; , &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; . Это означает, что если сценарий доступен только для чтения и не изменяет набор данных, эти команды можно вызывать. Обратите внимание, что &lt;em&gt;случайная команда&lt;/em&gt; не обязательно означает команду, использующую случайные числа: любая недетерминированная команда считается случайной командой (лучшим примером в этом отношении является команда &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1d65bbb9c212a9d98ffb329def918b64ef3d8889" translate="yes" xml:space="preserve">
          <source>Refreshing expires</source>
          <target state="translated">Истечение срока освежения</target>
        </trans-unit>
        <trans-unit id="26ca731c99535195e55e64ad25c62f00fdbd2a4c" translate="yes" xml:space="preserve">
          <source>Reliable queues</source>
          <target state="translated">Надежные хвосты</target>
        </trans-unit>
        <trans-unit id="ea59d67e277c60b336a409408ff4d775b8225584" translate="yes" xml:space="preserve">
          <source>Remove a specific consumer from a consumer group.</source>
          <target state="translated">Удалить конкретного потребителя из группы потребителей.</target>
        </trans-unit>
        <trans-unit id="ce4d2a865a5a06124187f3a0d8a5354cd701d61f" translate="yes" xml:space="preserve">
          <source>Remove the existing timeout on &lt;code&gt;key&lt;/code&gt;, turning the key from &lt;em&gt;volatile&lt;/em&gt; (a key with an expire set) to &lt;em&gt;persistent&lt;/em&gt; (a key that will never expire as no timeout is associated).</source>
          <target state="translated">Удалите существующий тайм-аут &lt;code&gt;key&lt;/code&gt; , превратив ключ из &lt;em&gt;изменчивого&lt;/em&gt; (ключ с установленным сроком действия) в &lt;em&gt;постоянный&lt;/em&gt; (ключ, который никогда не истечет, поскольку тайм-аут не связан).</target>
        </trans-unit>
        <trans-unit id="c1d260f4e3da83fa28a692c23e66ed0cb15dd796" translate="yes" xml:space="preserve">
          <source>Remove the specified members from the set stored at &lt;code&gt;key&lt;/code&gt;. Specified members that are not a member of this set are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty set and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Удалите указанные элементы из набора, хранящегося в &lt;code&gt;key&lt;/code&gt; . Указанные элементы, не входящие в этот набор, игнорируются. Если &lt;code&gt;key&lt;/code&gt; не существует, он рассматривается как пустой набор, и эта команда возвращает &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de0b8cb5dfcd4da1251a55ebacec477902ab7fa1" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (inclusive).</source>
          <target state="translated">Удаляет все элементы в отсортированном наборе, хранящемся в &lt;code&gt;key&lt;/code&gt; с оценкой от &lt;code&gt;min&lt;/code&gt; до &lt;code&gt;max&lt;/code&gt; (включительно).</target>
        </trans-unit>
        <trans-unit id="cbb3fc019bde7aa5a4f4696386c7635ab2172c17" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with rank between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are &lt;code&gt;0&lt;/code&gt; -based indexes with &lt;code&gt;0&lt;/code&gt; being the element with the lowest score. These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score. For example: &lt;code&gt;-1&lt;/code&gt; is the element with the highest score, &lt;code&gt;-2&lt;/code&gt; the element with the second highest score and so forth.</source>
          <target state="translated">Удаляет все элементы в отсортированном наборе, хранящемся в &lt;code&gt;key&lt;/code&gt; с рангом от &lt;code&gt;start&lt;/code&gt; до &lt;code&gt;stop&lt;/code&gt; . И &lt;code&gt;start&lt;/code&gt; , и &lt;code&gt;stop&lt;/code&gt; - это индексы на основе &lt;code&gt;0&lt;/code&gt; , где &lt;code&gt;0&lt;/code&gt; - это элемент с наименьшей оценкой. Эти индексы могут быть отрицательными числами, где они указывают смещения, начиная с элемента с наивысшей оценкой. Например: &lt;code&gt;-1&lt;/code&gt; - элемент с наивысшим баллом, &lt;code&gt;-2&lt;/code&gt; - элемент со вторым наивысшим баллом и так далее.</target>
        </trans-unit>
        <trans-unit id="da37c36034834387a9dd7fbda191a975ebb105b0" translate="yes" xml:space="preserve">
          <source>Removes and returns one or more random elements from the set value store at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Удаляет и возвращает один или несколько случайных элементов из хранилища заданных значений по &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbdedbfa9e258d96431019af8d58bcfa65137941" translate="yes" xml:space="preserve">
          <source>Removes and returns one or more random members from the set value store at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870ac46dca2c1a6689064e1cced801af5e158f69" translate="yes" xml:space="preserve">
          <source>Removes and returns the first element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Удаляет и возвращает первый элемент списка, хранящегося в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abb0c00334891c9a62b73bcc7669016da3f5a06d" translate="yes" xml:space="preserve">
          <source>Removes and returns the first elements of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2ce52901cbc45793a1c6bb41b722b9057d2bc4" translate="yes" xml:space="preserve">
          <source>Removes and returns the last element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Удаляет и возвращает последний элемент списка, хранящегося в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="068c1fcc92f924f323a2866cd513ee38912fea94" translate="yes" xml:space="preserve">
          <source>Removes and returns the last elements of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52acb45013cdb2a41dc580913c01c50bd6ebca86" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the highest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Удаляет и возвращает до &lt;code&gt;count&lt;/code&gt; - членов с самыми высокими баллами в отсортированном наборе хранящегося на &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac48e8c652eae033a19d95a11cb8d9dbd5e35dab" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the lowest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Удаляет и возвращает элементы с наименьшими баллами в отсортированном наборе, хранящемся в &lt;code&gt;key&lt;/code&gt; для &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f36f141768a197b4276a61d3b54c8f396195cafb" translate="yes" xml:space="preserve">
          <source>Removes the first &lt;code&gt;count&lt;/code&gt; occurrences of elements equal to &lt;code&gt;element&lt;/code&gt; from the list stored at &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;count&lt;/code&gt; argument influences the operation in the following ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6ffaff6ffe08c9f43baab9718f030d2162d111" translate="yes" xml:space="preserve">
          <source>Removes the first &lt;code&gt;count&lt;/code&gt; occurrences of elements equal to &lt;code&gt;value&lt;/code&gt; from the list stored at &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;count&lt;/code&gt; argument influences the operation in the following ways:</source>
          <target state="translated">Удаляет первое &lt;code&gt;count&lt;/code&gt; вхождений элементов, равных &lt;code&gt;value&lt;/code&gt; из списка, хранящегося в &lt;code&gt;key&lt;/code&gt; . &lt;code&gt;count&lt;/code&gt; аргументов влияет на работу следующими способами:</target>
        </trans-unit>
        <trans-unit id="494ca7e2faa6bd5b36a369eb7746bb78fb3e96bc" translate="yes" xml:space="preserve">
          <source>Removes the specified entries from a stream, and returns the number of entries deleted, that may be different from the number of IDs passed to the command in case certain IDs do not exist.</source>
          <target state="translated">Удаляет указанные записи из потока и возвращает количество удаленных записей,которое может отличаться от количества переданных в команду IDов в случае,если определенных IDов не существует.</target>
        </trans-unit>
        <trans-unit id="594397839f7156989bc1b259c19072c5484f7bdc" translate="yes" xml:space="preserve">
          <source>Removes the specified fields from the hash stored at &lt;code&gt;key&lt;/code&gt;. Specified fields that do not exist within this hash are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty hash and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Удаляет указанные поля из хэша, хранящегося в &lt;code&gt;key&lt;/code&gt; . Указанные поля, которых нет в этом хэше, игнорируются. Если &lt;code&gt;key&lt;/code&gt; не существует, он рассматривается как пустой хеш, и эта команда возвращает &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="322e3109be94b3ac9ea4c2a44f232f96c6cd905a" translate="yes" xml:space="preserve">
          <source>Removes the specified keys. A key is ignored if it does not exist.</source>
          <target state="translated">Удаляет указанные клавиши.Ключ игнорируется,если он не существует.</target>
        </trans-unit>
        <trans-unit id="933e4f3eff042f249c190608a122f8e43bd494af" translate="yes" xml:space="preserve">
          <source>Removes the specified members from the sorted set stored at &lt;code&gt;key&lt;/code&gt;. Non existing members are ignored.</source>
          <target state="translated">Удаляет указанные элементы из отсортированного набора, хранящегося в &lt;code&gt;key&lt;/code&gt; . Несуществующие члены игнорируются.</target>
        </trans-unit>
        <trans-unit id="17baa9fe7f8ed0143fa7df75975e104465db4e59" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt; if &lt;code&gt;newkey&lt;/code&gt; does not yet exist. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">Переименовывает &lt;code&gt;key&lt;/code&gt; в &lt;code&gt;newkey&lt;/code&gt; , если &lt;code&gt;newkey&lt;/code&gt; еще не существует. Если &lt;code&gt;key&lt;/code&gt; не существует, он возвращает ошибку .</target>
        </trans-unit>
        <trans-unit id="0155259665636f6ceaaa0a0ebda67bb195d98a6d" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt;. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist. If &lt;code&gt;newkey&lt;/code&gt; already exists it is overwritten, when this happens &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; executes an implicit &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation, so if the deleted key contains a very big value it may cause high latency even if &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; itself is usually a constant-time operation.</source>
          <target state="translated">Переименовывает &lt;code&gt;key&lt;/code&gt; в &lt;code&gt;newkey&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; не существует, он возвращает ошибку . Если &lt;code&gt;newkey&lt;/code&gt; уже существует, он перезаписывается, когда это происходит, &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; выполняет неявную операцию &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; , поэтому, если удаленный ключ содержит очень большое значение, это может вызвать большую задержку, даже если само &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; обычно является операцией с постоянным временем.</target>
        </trans-unit>
        <trans-unit id="351fb2e9d60cd91bf6510354de71fa6c06419ab4" translate="yes" xml:space="preserve">
          <source>Replicas broadcast their master's config epochs (in order to get an &lt;code&gt;UPDATE&lt;/code&gt; message if they are found to be stale), so the real config epoch of the replica (which is meaningless more or less, since they don't serve hash slots) can be only obtained checking the node flagged as &lt;code&gt;myself&lt;/code&gt;, which is the entry of the node we are asking to generate &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output. The other replicas epochs reflect what they publish in heartbeat packets, which is, the configuration epoch of the masters they are currently replicating.</source>
          <target state="translated">Реплики транслируют эпохи конфигурации своего хозяина (чтобы получить сообщение &lt;code&gt;UPDATE&lt;/code&gt; если обнаруживается, что они устарели), поэтому реальная эпоха конфигурации реплики (что более или менее бессмысленно, поскольку они не обслуживают хэш-слоты) может быть удалось получить только проверку узла, помеченного как &lt;code&gt;myself&lt;/code&gt; , который является записью узла, который мы запрашиваем для генерации вывода &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; . Другие эпохи реплик отражают то, что они публикуют в контрольных пакетах, то есть эпоху конфигурации мастеров, которые они в настоящее время реплицируют.</target>
        </trans-unit>
        <trans-unit id="57ee014fca43ed90896705e17d43f35b06757596" translate="yes" xml:space="preserve">
          <source>Replicating commands instead of scripts</source>
          <target state="translated">Тиражирование команд вместо сценариев</target>
        </trans-unit>
        <trans-unit id="054fb8240ac6c1ab20550a9e5b79d9d4cd6d1345" translate="yes" xml:space="preserve">
          <source>Request for authentication in a password-protected Redis server. Redis can be instructed to require a password before allowing clients to execute commands. This is done using the &lt;code&gt;requirepass&lt;/code&gt; directive in the configuration file.</source>
          <target state="translated">Запрос на аутентификацию на сервере Redis, защищенном паролем. Redis может быть проинструктирован запрашивать пароль перед тем, как позволить клиентам выполнять команды. Это делается с &lt;code&gt;requirepass&lt;/code&gt; директивы requirepass в файле конфигурации.</target>
        </trans-unit>
        <trans-unit id="da1bb4a2fc17746f7a5baea5144086fae0563a1a" translate="yes" xml:space="preserve">
          <source>Reset a Redis Cluster node, in a more or less drastic way depending on the reset type, that can be &lt;strong&gt;hard&lt;/strong&gt; or &lt;strong&gt;soft&lt;/strong&gt;. Note that this command &lt;strong&gt;does not work for masters if they hold one or more keys&lt;/strong&gt;, in that case to completely reset a master node keys must be removed first, e.g. by using &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; first, and then &lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt;.</source>
          <target state="translated">Сброс узла Redis Cluster более или менее радикальным способом в зависимости от типа сброса, который может быть &lt;strong&gt;жестким&lt;/strong&gt; или &lt;strong&gt;мягким&lt;/strong&gt; . Обратите внимание, что эта команда &lt;strong&gt;не работает для мастеров, если они удерживают один или несколько ключей.&lt;/strong&gt; В этом случае для полного сброса главного узла ключи должны быть сначала удалены, например, сначала с помощью &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; , а затем &lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b45f167ccc9268d6db2b2030f5f33cd642304b9" translate="yes" xml:space="preserve">
          <source>Resets the statistics reported by Redis using the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command.</source>
          <target state="translated">Сбрасывает статистику, сообщаемую Redis, с помощью команды &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b4926f937540a054f457674fa7da321fbd6a1f7" translate="yes" xml:space="preserve">
          <source>Resetting the slow log.</source>
          <target state="translated">Сброс медленного журнала.</target>
        </trans-unit>
        <trans-unit id="401feffc58d082a7dc99bf3cdbc90af756748e94" translate="yes" xml:space="preserve">
          <source>Reshard all the hash slots from D to nodes A, B, C.</source>
          <target state="translated">Перезагрузите все хэш-слоты от D до узлов A,B,C.</target>
        </trans-unit>
        <trans-unit id="d71f5749e9e28d5922b96f1c26e811052165fc71" translate="yes" xml:space="preserve">
          <source>Retrieving external keys</source>
          <target state="translated">Получение внешних ключей</target>
        </trans-unit>
        <trans-unit id="6fc93fde5d23bf392c79a9f984537ca96d065420" translate="yes" xml:space="preserve">
          <source>Return a random key from the currently selected database.</source>
          <target state="translated">Возврат случайного ключа из текущей выбранной базы данных.</target>
        </trans-unit>
        <trans-unit id="6fd47a35bf916d5d67439ea375fe4e2fb769d84c" translate="yes" xml:space="preserve">
          <source>Return the UNIX TIME of the last DB save executed with success. A client may check if a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command succeeded reading the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; value, then issuing a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command and checking at regular intervals every N seconds if &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; changed.</source>
          <target state="translated">Возвращает UNIX TIME последнего успешного сохранения БД. Клиент может проверить , если &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; команда успешно читает &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; значение, а затем выдачи &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; команды и проверки через регулярные промежутки времени каждые N секунд , если &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; изменилось.</target>
        </trans-unit>
        <trans-unit id="7298f92c54146228ead6d1a31b40025056a03b02" translate="yes" xml:space="preserve">
          <source>Return the distance between two members in the geospatial index represented by the sorted set.</source>
          <target state="translated">Возврат расстояния между двумя членами в геопространственном индексе,представленном отсортированным набором.</target>
        </trans-unit>
        <trans-unit id="da507356e98e4d51d3b0a5e69a99468bdb6da16d" translate="yes" xml:space="preserve">
          <source>Return the members of a sorted set populated with geospatial information using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;, which are within the borders of the area specified by a given shape. This command extends the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; command, so in addition to searching within circular areas, it supports searching within rectangular areas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb126873153beb4e986e8428f3f0a902f06d1bc" translate="yes" xml:space="preserve">
          <source>Return the members of a sorted set populated with geospatial information using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;, which are within the borders of the area specified with the center location and the maximum distance from the center (the radius).</source>
          <target state="translated">Возврат элементов отсортированного набора, заполненного геопространственной информацией с помощью &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; , которые находятся в границах области, указанной с центральным расположением и максимальным расстоянием от центра (радиусом).</target>
        </trans-unit>
        <trans-unit id="a7ff116fa994743f4fb0646cce53a6396e097c89" translate="yes" xml:space="preserve">
          <source>Return the number of keys in the currently-selected database.</source>
          <target state="translated">Вернуть количество ключей в текущей выбранной базе данных.</target>
        </trans-unit>
        <trans-unit id="06398ca22b9ef82a3c94cf8b1160f8f9c766b74a" translate="yes" xml:space="preserve">
          <source>Return the position of the first bit set to 1 or 0 in a string.</source>
          <target state="translated">Возвращает позицию первого бита,установленного в 1 или 0 в строке.</target>
        </trans-unit>
        <trans-unit id="1d1482b5db471b056549fa1a5580198ec9701587" translate="yes" xml:space="preserve">
          <source>Return the positions (longitude,latitude) of all the specified members of the geospatial index represented by the sorted set at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">Возвращает позиции (долготу, широту) всех указанных элементов геопространственного индекса, представленного отсортированным набором в &lt;em&gt;ключе&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="38c82e40bf5034793c00ae747edeb8cd30dfe3ef" translate="yes" xml:space="preserve">
          <source>Return the username the current connection is authenticated with. New connections are authenticated with the &quot;default&quot; user. They can change user using &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0492bdeb7afe890056ed3d150bcd3cc644b0be83" translate="yes" xml:space="preserve">
          <source>Return valid &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; strings representing the position of one or more elements in a sorted set value representing a geospatial index (where elements were added using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;).</source>
          <target state="translated">Вернуть действительные строки &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash,&lt;/a&gt; представляющие положение одного или нескольких элементов в отсортированном значении набора, представляющем геопространственный индекс (где элементы были добавлены с помощью &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="232f3db04c4faa620bfbfc11fd3689a472ef9881" translate="yes" xml:space="preserve">
          <source>Return value</source>
          <target state="translated">Возвращаемая величина</target>
        </trans-unit>
        <trans-unit id="864674bcd0783b3457690f475310b938e42a7db7" translate="yes" xml:space="preserve">
          <source>Returning a maximum number of entries</source>
          <target state="translated">Возвращение максимального количества записей</target>
        </trans-unit>
        <trans-unit id="8f278b9f0e4f851622b8ed184503714c9eb2b40b" translate="yes" xml:space="preserve">
          <source>Returning items in a specific time range. This is possible because Stream IDs are &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;related to time&lt;/a&gt;.</source>
          <target state="translated">Возврат товаров за определенный период времени. Это возможно, потому что идентификаторы потоков &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;связаны со временем&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fecab38b77030a1f63f2810d6747aa68c069f23" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about all Redis commands.</source>
          <target state="translated">Возвращает &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;массив&lt;/a&gt; с подробностями обо всех командах Redis.</target>
        </trans-unit>
        <trans-unit id="fc344310aece8efa4afcb637dd3fdf8dc24fa45b" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about multiple Redis commands.</source>
          <target state="translated">Возвращает &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;ответ&lt;/a&gt; в виде массива с подробностями о нескольких командах Redis.</target>
        </trans-unit>
        <trans-unit id="4a134a2f3cf379373d004a605091cb6cf69dedcb" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of keys from a full Redis command.</source>
          <target state="translated">Возвращает &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;массив ответов&lt;/a&gt; ключей от полной команды Redis.</target>
        </trans-unit>
        <trans-unit id="bce4982fceed9f9a0c759decc9c92ecb37cc9be2" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt; of number of total commands in this Redis server.</source>
          <target state="translated">Возвращает &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;целочисленный ответ&lt;/a&gt; общего количества команд на этом сервере Redis.</target>
        </trans-unit>
        <trans-unit id="a915d042e7bc17cfcfeeccbd870dfc5af9c1ca16" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;PONG&lt;/code&gt; if no argument is provided, otherwise return a copy of the argument as a bulk. This command is often used to test if a connection is still alive, or to measure latency.</source>
          <target state="translated">Возвращает &lt;code&gt;PONG&lt;/code&gt; , если аргумент не указан, в противном случае возвращает копию аргумента как массив. Эта команда часто используется для проверки активности соединения или для измерения задержки.</target>
        </trans-unit>
        <trans-unit id="dd1b58db010b114867573670782f464e9b034412" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">Возвращает &lt;code&gt;message&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8491e8a1858fe4a13538635b038fd1bb846df79" translate="yes" xml:space="preserve">
          <source>Returns all field names in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает все имена полей в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="514836e0465ae87a7f738140eb4e2b3ae4475e1f" translate="yes" xml:space="preserve">
          <source>Returns all fields and values of the hash stored at &lt;code&gt;key&lt;/code&gt;. In the returned value, every field name is followed by its value, so the length of the reply is twice the size of the hash.</source>
          <target state="translated">Возвращает все поля и значения хэша, хранящегося в &lt;code&gt;key&lt;/code&gt; . В возвращаемом значении за каждым именем поля следует его значение, поэтому длина ответа в два раза превышает размер хэша.</target>
        </trans-unit>
        <trans-unit id="e9924b464875fe91e2b89cf6f97649ff9ec1b5ce" translate="yes" xml:space="preserve">
          <source>Returns all keys matching &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">Возвращает все ключи, соответствующие &lt;code&gt;pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ceba3296cc87483f6becfe1cdae897e811a1b1e" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; (including elements with score equal to &lt;code&gt;max&lt;/code&gt; or &lt;code&gt;min&lt;/code&gt;). In contrary to the default ordering of sorted sets, for this command the elements are considered to be ordered from high to low scores.</source>
          <target state="translated">Возвращает все элементы в отсортированном наборе с &lt;code&gt;key&lt;/code&gt; с оценкой от &lt;code&gt;max&lt;/code&gt; до &lt;code&gt;min&lt;/code&gt; (включая элементы с оценкой, равной &lt;code&gt;max&lt;/code&gt; или &lt;code&gt;min&lt;/code&gt; ). В отличие от упорядочения сортированных наборов по умолчанию, для этой команды элементы считаются упорядоченными от высоких до низких оценок.</target>
        </trans-unit>
        <trans-unit id="6def9bec387c3e744963c6ac4b0bf7f4010504e6" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (including elements with score equal to &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt;). The elements are considered to be ordered from low to high scores.</source>
          <target state="translated">Возвращает все элементы в отсортированном наборе с &lt;code&gt;key&lt;/code&gt; с оценкой от &lt;code&gt;min&lt;/code&gt; до &lt;code&gt;max&lt;/code&gt; (включая элементы с оценкой, равной &lt;code&gt;min&lt;/code&gt; или &lt;code&gt;max&lt;/code&gt; ). Элементы считаются отсортированными от низкого до высокого баллов.</target>
        </trans-unit>
        <trans-unit id="1925ffaf420a57d589c1888eb5b09007e4f1d203" translate="yes" xml:space="preserve">
          <source>Returns all the members of the set value stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает все элементы установленного значения, хранящегося в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c11f5fe0471c6d472d362d6dbbf041c048b49125" translate="yes" xml:space="preserve">
          <source>Returns all values in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает все значения в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4792ce321c7a364f3dc2071cf137fcc522daf25d" translate="yes" xml:space="preserve">
          <source>Returns an integer identifying the hash slot the specified key hashes to. This command is mainly useful for debugging and testing, since it exposes via an API the underlying Redis implementation of the hashing algorithm. Example use cases for this command:</source>
          <target state="translated">Возвращает целое число,идентифицирующее хэш-слот,к которому относятся указанные ключевые хэши.Эта команда в основном полезна для отладки и тестирования,так как раскрывает через API базовую реализацию алгоритма хэширования Redis.Примеры использования данной команды:</target>
        </trans-unit>
        <trans-unit id="899ca03feedce83f7aa728b87a784b60bd95adf0" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;field&lt;/code&gt; is an existing field in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает, если &lt;code&gt;field&lt;/code&gt; является существующим полем в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e13b7a867bbaf0e4121d5da403d54edbe4a8b1f" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;key&lt;/code&gt; exists.</source>
          <target state="translated">Возвращает, если &lt;code&gt;key&lt;/code&gt; существует.</target>
        </trans-unit>
        <trans-unit id="163373a24e8be296b7e7c88d0c4da2f59ceca677" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;member&lt;/code&gt; is a member of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает, если &lt;code&gt;member&lt;/code&gt; является членом набора, хранящегося в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abd92cbd9d7d0b6e4392a36873fd8c21767b398a" translate="yes" xml:space="preserve">
          <source>Returns information about the existence of the scripts in the script cache.</source>
          <target state="translated">Возвращает информацию о существовании скриптов в кэше скриптов.</target>
        </trans-unit>
        <trans-unit id="820ae40f339c061fc09ac87d928788d5e7ea006a" translate="yes" xml:space="preserve">
          <source>Returns information about the modules loaded to the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13855077d7cb93a1fce1c3432c59e7e463ea29a6" translate="yes" xml:space="preserve">
          <source>Returns or stores the elements contained in the &lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;list&lt;/a&gt;, &lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;set&lt;/a&gt; or &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted set&lt;/a&gt; at &lt;code&gt;key&lt;/code&gt;. By default, sorting is numeric and elements are compared by their value interpreted as double precision floating point number. This is &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; in its simplest form:</source>
          <target state="translated">Возвращает или сохраняет элементы, содержащиеся в &lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;списке&lt;/a&gt; , &lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;набор&lt;/a&gt; или &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;отсортированный набор&lt;/a&gt; по &lt;code&gt;key&lt;/code&gt; . По умолчанию сортировка является числовой, и элементы сравниваются по их значению, интерпретируемому как число двойной точности с плавающей запятой. Это &lt;a href=&quot;sort&quot;&gt;СОРТИРОВКА&lt;/a&gt; в простейшей форме:</target>
        </trans-unit>
        <trans-unit id="f68574957008d127438140f50ac56b278260cf09" translate="yes" xml:space="preserve">
          <source>Returns the bit value at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">Возвращает битовое значение по &lt;em&gt;смещению&lt;/em&gt; в строковом значении, хранящемся в &lt;em&gt;ключе&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e6d63c7c2388918da907438c78c891dff4a16999" translate="yes" xml:space="preserve">
          <source>Returns the element at index &lt;code&gt;index&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt;. The index is zero-based, so &lt;code&gt;0&lt;/code&gt; means the first element, &lt;code&gt;1&lt;/code&gt; the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, &lt;code&gt;-1&lt;/code&gt; means the last element, &lt;code&gt;-2&lt;/code&gt; means the penultimate and so forth.</source>
          <target state="translated">Возвращает элемент по индексу &lt;code&gt;index&lt;/code&gt; в списке, хранящемся в &lt;code&gt;key&lt;/code&gt; . Индекс отсчитывается от нуля, поэтому &lt;code&gt;0&lt;/code&gt; означает первый элемент, &lt;code&gt;1&lt;/code&gt; - второй элемент и так далее. Отрицательные индексы могут использоваться для обозначения элементов, начинающихся в конце списка. Здесь &lt;code&gt;-1&lt;/code&gt; означает последний элемент, &lt;code&gt;-2&lt;/code&gt; означает предпоследний и так далее.</target>
        </trans-unit>
        <trans-unit id="669652a24b746680e968eb8d19e304712aaafbef" translate="yes" xml:space="preserve">
          <source>Returns the length of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is interpreted as an empty list and &lt;code&gt;0&lt;/code&gt; is returned. An error is returned when the value stored at &lt;code&gt;key&lt;/code&gt; is not a list.</source>
          <target state="translated">Возвращает длину списка, хранящегося в &lt;code&gt;key&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; не существует, он интерпретируется как пустой список и возвращается &lt;code&gt;0&lt;/code&gt; . Ошибка возвращается, если значение, хранящееся в &lt;code&gt;key&lt;/code&gt; , не является списком.</target>
        </trans-unit>
        <trans-unit id="b1b9de7b079dd5e1ad7bef3504c123ad01db9ecc" translate="yes" xml:space="preserve">
          <source>Returns the length of the string value stored at &lt;code&gt;key&lt;/code&gt;. An error is returned when &lt;code&gt;key&lt;/code&gt; holds a non-string value.</source>
          <target state="translated">Возвращает длину строкового значения, хранящегося в &lt;code&gt;key&lt;/code&gt; . Ошибка возвращается, если &lt;code&gt;key&lt;/code&gt; содержит нестроковое значение.</target>
        </trans-unit>
        <trans-unit id="5ca8167d0a845062b5e1c8307dc022d4e1bbe99c" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the difference between the first set and all the successive sets.</source>
          <target state="translated">Возвращает членов множества,образовавшегося в результате разницы между первым множеством и всеми последующими множествами.</target>
        </trans-unit>
        <trans-unit id="65286cf35136f5258861b04a7983164ea5b463a3" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the intersection of all the given sets.</source>
          <target state="translated">Возвращает членов множества,полученных в результате пересечения всех заданных множеств.</target>
        </trans-unit>
        <trans-unit id="473b41ab8be68badcb9ee743f59ebda61ccb6efd" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the union of all the given sets.</source>
          <target state="translated">Возвращает членов набора,образовавшегося в результате объединения всех данных наборов.</target>
        </trans-unit>
        <trans-unit id="5f50e5f3ee257d3917e04c66ed0f097e9a6cbcd0" translate="yes" xml:space="preserve">
          <source>Returns the node's id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae58574da7b69acb45d5608e905fbe416f5828a3" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">Возвращает количество элементов в отсортированном наборе с &lt;code&gt;key&lt;/code&gt; с оценкой от &lt;code&gt;min&lt;/code&gt; до &lt;code&gt;max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ba5a6e2cdf681a72b81189fc73dab62a38a2630" translate="yes" xml:space="preserve">
          <source>Returns the number of entries inside a stream. If the specified key does not exist the command returns zero, as if the stream was empty. However note that unlike other Redis types, zero-length streams are possible, so you should call &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; or &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; in order to check if a key exists or not.</source>
          <target state="translated">Возвращает количество записей внутри потока. Если указанный ключ не существует, команда возвращает ноль, как если бы поток был пуст. Однако обратите внимание, что в отличие от других типов Redis, потоки нулевой длины возможны, поэтому вам следует вызвать &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; или &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; , чтобы проверить, существует ли ключ или нет.</target>
        </trans-unit>
        <trans-unit id="05ec2c01f1e7966c86d566259fe9827a1ce5788e" translate="yes" xml:space="preserve">
          <source>Returns the number of fields contained in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает количество полей, содержащихся в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cba9b6e741951a2ea3575443214cf403c194bc0f" translate="yes" xml:space="preserve">
          <source>Returns the number of keys in the specified Redis Cluster hash slot. The command only queries the local data set, so contacting a node that is not serving the specified hash slot will always result in a count of zero being returned.</source>
          <target state="translated">Возвращает количество ключей в указанном слоте хэша кластера Redis.Команда запрашивает только локальный набор данных,поэтому при обращении к узлу,который не обслуживает указанный хеш-слот,всегда возвращается счетчик нуля.</target>
        </trans-unit>
        <trans-unit id="567352a29cfaef33a8cd3fcbcac829c78575fb62" translate="yes" xml:space="preserve">
          <source>Returns the number of subscribers (not counting clients subscribed to patterns) for the specified channels.</source>
          <target state="translated">Возвращает количество подписчиков (не считая клиентов,подписавшихся на шаблоны)для указанных каналов.</target>
        </trans-unit>
        <trans-unit id="56eb7af42eb7b4bb5b7efb363837228225fedb8e" translate="yes" xml:space="preserve">
          <source>Returns the number of subscriptions to patterns (that are performed using the &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; command). Note that this is not just the count of clients subscribed to patterns but the total number of patterns all the clients are subscribed to.</source>
          <target state="translated">Возвращает количество подписок на шаблоны (которые выполняются с помощью команды &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; ). Обратите внимание, что это не только количество клиентов, подписанных на шаблоны, но и общее количество шаблонов, на которые подписаны все клиенты.</target>
        </trans-unit>
        <trans-unit id="029e626a83e98d1ddd2b45f2a08391faf674382c" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from high to low. The rank (or index) is 0-based, which means that the member with the highest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Возвращает ранг &lt;code&gt;member&lt;/code&gt; в отсортированном наборе, хранящемся в &lt;code&gt;key&lt;/code&gt; , с оценками, упорядоченными от большего к меньшему. Ранг (или индекс) отсчитывается от 0, что означает, что член с наивысшим баллом имеет ранг &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04ac6b8e04ac2d5fa91a42abbe270ab24969dcf8" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from low to high. The rank (or index) is 0-based, which means that the member with the lowest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Возвращает ранг &lt;code&gt;member&lt;/code&gt; в отсортированном наборе, хранящемся в &lt;code&gt;key&lt;/code&gt; , с оценками, упорядоченными от меньшего к большему. Ранг (или индекс) отсчитывается от 0, что означает, что член с наименьшей оценкой имеет ранг &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dac65708cc841972517b49f4a323aba557dd7743" translate="yes" xml:space="preserve">
          <source>Returns the remaining time to live of a key that has a timeout. This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.</source>
          <target state="translated">Возвращает оставшееся время жизни ключа с тайм-аутом.Эта функция самопроверки позволяет клиенту Redis проверять,сколько секунд данный ключ будет продолжать оставаться частью набора данных.</target>
        </trans-unit>
        <trans-unit id="bdaf416765952fb3c543f080075ad7115471f130" translate="yes" xml:space="preserve">
          <source>Returns the score of &lt;code&gt;member&lt;/code&gt; in the sorted set at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает оценку &lt;code&gt;member&lt;/code&gt; в отсортированном наборе по &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bb764cd364e3749541c7692eea4d198b1e88fce" translate="yes" xml:space="preserve">
          <source>Returns the scores associated with the specified &lt;code&gt;members&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0525192497ba351f01f7c69505a721186043f122" translate="yes" xml:space="preserve">
          <source>Returns the set cardinality (number of elements) of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает установленную мощность (количество элементов) набора, хранящегося в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="538e8ccb043255bf1866a8c948a35b08642708eb" translate="yes" xml:space="preserve">
          <source>Returns the sorted set cardinality (number of elements) of the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает количество элементов отсортированного набора (количество элементов) отсортированного набора, хранящегося в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aed5ad61cf2dae51ecb526ffeb96e8ae6f66dd61" translate="yes" xml:space="preserve">
          <source>Returns the specified elements of the list stored at &lt;code&gt;key&lt;/code&gt;. The offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, with &lt;code&gt;0&lt;/code&gt; being the first element of the list (the head of the list), &lt;code&gt;1&lt;/code&gt; being the next element and so on.</source>
          <target state="translated">Возвращает указанные элементы списка, хранящегося в &lt;code&gt;key&lt;/code&gt; . Смещения &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;stop&lt;/code&gt; - это индексы, отсчитываемые от нуля, где &lt;code&gt;0&lt;/code&gt; - это первый элемент списка (заголовок списка), &lt;code&gt;1&lt;/code&gt; - следующий элемент и так далее.</target>
        </trans-unit>
        <trans-unit id="165e254b16f95c82b554bb625de96b2c2d45635e" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the highest to the lowest score. Descending lexicographical order is used for elements with equal score.</source>
          <target state="translated">Возвращает указанный диапазон элементов в отсортированном наборе, хранящемся в &lt;code&gt;key&lt;/code&gt; . Элементы считаются упорядоченными от самого высокого до самого низкого балла. Лексикографический порядок по убыванию используется для элементов с равным количеством баллов.</target>
        </trans-unit>
        <trans-unit id="c5f3848ec567b8c9da3f19a86ff736fd69145ae8" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the lowest to the highest score. Lexicographical order is used for elements with equal score.</source>
          <target state="translated">Возвращает указанный диапазон элементов в отсортированном наборе, хранящемся в &lt;code&gt;key&lt;/code&gt; . Элементы считаются упорядоченными от наименьшего к наибольшему количеству баллов. Лексикографический порядок используется для элементов с равным количеством баллов.</target>
        </trans-unit>
        <trans-unit id="d28b315a7a61b9bf04b21fccdd6ae5bd4f8eb130" translate="yes" xml:space="preserve">
          <source>Returns the string length of the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;. If the &lt;code&gt;key&lt;/code&gt; or the &lt;code&gt;field&lt;/code&gt; do not exist, 0 is returned.</source>
          <target state="translated">Возвращает длину строки значения, связанного с &lt;code&gt;field&lt;/code&gt; в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; или &lt;code&gt;field&lt;/code&gt; не существуют, возвращается 0.</target>
        </trans-unit>
        <trans-unit id="ffb4e3b3a6a5708cfdef83bd04363741160ed0a4" translate="yes" xml:space="preserve">
          <source>Returns the string representation of the type of the value stored at &lt;code&gt;key&lt;/code&gt;. The different types that can be returned are: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;zset&lt;/code&gt; and &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">Возвращает строковое представление типа значения, хранящегося в &lt;code&gt;key&lt;/code&gt; . Могут быть возвращены различные типы: &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;zset&lt;/code&gt; и &lt;code&gt;hash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9feb2d475967dd13f03c72121d597fd1520318c" translate="yes" xml:space="preserve">
          <source>Returns the string representation of the type of the value stored at &lt;code&gt;key&lt;/code&gt;. The different types that can be returned are: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;zset&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a246620818088ec9a16f70b9fb4ae809aad9ad2" translate="yes" xml:space="preserve">
          <source>Returns the substring of the string value stored at &lt;code&gt;key&lt;/code&gt;, determined by the offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; (both are inclusive). Negative offsets can be used in order to provide an offset starting from the end of the string. So -1 means the last character, -2 the penultimate and so forth.</source>
          <target state="translated">Возвращает подстроку строкового значения, хранящегося в &lt;code&gt;key&lt;/code&gt; , определяемого смещениями &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;end&lt;/code&gt; (оба включены). Отрицательные смещения могут использоваться для обеспечения смещения, начиная с конца строки. Итак, -1 означает последний символ, -2 - предпоследний и так далее.</target>
        </trans-unit>
        <trans-unit id="ff8cb8f9712a465de8610b460278556869c01387" translate="yes" xml:space="preserve">
          <source>Returns the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает значение, связанное с &lt;code&gt;field&lt;/code&gt; в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e8fea73a6efe9b1e714890adedb119e477e5b94" translate="yes" xml:space="preserve">
          <source>Returns the values associated with the specified &lt;code&gt;fields&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает значения, связанные с указанными &lt;code&gt;fields&lt;/code&gt; в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a3f6c24ab0b5bf50119e41442adccdd069520b2" translate="yes" xml:space="preserve">
          <source>Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value &lt;code&gt;nil&lt;/code&gt; is returned. Because of this, the operation never fails.</source>
          <target state="translated">Возвращает значения всех указанных ключей. Для каждого ключа, который не содержит строковое значение или не существует, возвращается специальное значение &lt;code&gt;nil&lt;/code&gt; . Благодаря этому операция никогда не заканчивается неудачей.</target>
        </trans-unit>
        <trans-unit id="0b14b8f8217819a1f6163396383d48d4cd2d94d9" translate="yes" xml:space="preserve">
          <source>Returns whether each &lt;code&gt;member&lt;/code&gt; is a member of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fe03995fd835515d8b0c378391e0d80d6d96a2" translate="yes" xml:space="preserve">
          <source>Running the bitmap incrementally using the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;&lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; optional parameters, accumulating the results client-side, and optionally caching the result into a key.</source>
          <target state="translated">&lt;a href=&quot;bitcount&quot;&gt;Постепенный &lt;/a&gt;&lt;em&gt;запуск&lt;/em&gt; растрового изображения с использованием необязательных параметров BITCOUNT &lt;em&gt;start&lt;/em&gt; и &lt;em&gt;end&lt;/em&gt; , накопление результатов на стороне клиента и необязательное кэширование результата в ключ.</target>
        </trans-unit>
        <trans-unit id="afc896d0c818d9d81d1502addeeed94d978515cb" translate="yes" xml:space="preserve">
          <source>SADD</source>
          <target state="translated">SADD</target>
        </trans-unit>
        <trans-unit id="afe4d83e232611365cc3a02706eeee448267b671" translate="yes" xml:space="preserve">
          <source>SADD  key member [member ...]   Add one or more members to a set</source>
          <target state="translated">Член ключа SADD [член ...]Добавить одного или нескольких членов в набор.</target>
        </trans-unit>
        <trans-unit id="508156a39b09ccfe61cc81d984e9317e5e0d8eec" translate="yes" xml:space="preserve">
          <source>SAVE</source>
          <target state="translated">SAVE</target>
        </trans-unit>
        <trans-unit id="a806788f2be230df4e533ace9d23ff41f5ebd919" translate="yes" xml:space="preserve">
          <source>SAVE   Synchronously save the dataset to disk</source>
          <target state="translated">SAVE Синхронно сохранять набор данных на диск</target>
        </trans-unit>
        <trans-unit id="65b4fd3a026ef6fa00d5747035f289ef54695f24" translate="yes" xml:space="preserve">
          <source>SAVE and NOSAVE modifiers</source>
          <target state="translated">модификаторы SAVE и NOSAVE</target>
        </trans-unit>
        <trans-unit id="c5a19955ea5dab3fd18ab68f367f98693df1b60b" translate="yes" xml:space="preserve">
          <source>SCAN</source>
          <target state="translated">SCAN</target>
        </trans-unit>
        <trans-unit id="f6a353aff0f0da25a0e7f7c1d96621ee0a75fe99" translate="yes" xml:space="preserve">
          <source>SCAN  cursor [MATCH pattern] [COUNT count]   Incrementally iterate the keys space</source>
          <target state="translated">Курсор SCAN [Шаблон сравнения][Количество СОЕДИНЕНИЙ]Интенсивно перемещайте пробелы клавиш.</target>
        </trans-unit>
        <trans-unit id="72556acd6ec7fd4188e74406d411c51d45f1c442" translate="yes" xml:space="preserve">
          <source>SCAN  cursor [MATCH pattern] [COUNT count] [TYPE type]   Incrementally iterate the keys space</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f904e681db7d6de1d40ec70145524cd0367d1bf0" translate="yes" xml:space="preserve">
          <source>SCAN basic usage</source>
          <target state="translated">базовое использование SCAN</target>
        </trans-unit>
        <trans-unit id="aa3b23325236e95772d7cd2d8a5db2f2530e669f" translate="yes" xml:space="preserve">
          <source>SCAN is a cursor based iterator. This means that at every call of the command, the server returns an updated cursor that the user needs to use as the cursor argument in the next call.</source>
          <target state="translated">SCAN-это итератор на основе курсора.Это означает,что при каждом вызове команды сервер возвращает обновленный курсор,который пользователь должен использовать в качестве аргумента курсора при следующем вызове.</target>
        </trans-unit>
        <trans-unit id="0431790b7b638b530f089a6638b4b046bf245d05" translate="yes" xml:space="preserve">
          <source>SCARD</source>
          <target state="translated">SCARD</target>
        </trans-unit>
        <trans-unit id="45b0af77625a8e40fbd9c79a72bf85a01a682a2e" translate="yes" xml:space="preserve">
          <source>SCARD  key   Get the number of members in a set</source>
          <target state="translated">Ключ SCARD Получить количество членов в наборе.</target>
        </trans-unit>
        <trans-unit id="46ab5a918078b88865c34d46d45763f78a5cc2a8" translate="yes" xml:space="preserve">
          <source>SCRIPT</source>
          <target state="translated">SCRIPT</target>
        </trans-unit>
        <trans-unit id="942ec0d4567f537a05d81b40e79ed670c8098df1" translate="yes" xml:space="preserve">
          <source>SCRIPT DEBUG  YES|SYNC|NO   Set the debug mode for executed scripts.</source>
          <target state="translated">SCRIPT DEBUG YES|SYNC|NO Установите отладочный режим для выполняемых скриптов.</target>
        </trans-unit>
        <trans-unit id="d4f0300810cbd56a02078e94b26444e04a369df1" translate="yes" xml:space="preserve">
          <source>SCRIPT EXISTS  sha1 [sha1 ...]   Check existence of scripts in the script cache.</source>
          <target state="translated">SCRIPT EXISTS sha1 [sha1 ...]Проверка существования скриптов в кэше скриптов.</target>
        </trans-unit>
        <trans-unit id="155351693709972a944322985f623357a60203d8" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH</source>
          <target state="translated">КРИПТОВЫЙ ФЛУШ</target>
        </trans-unit>
        <trans-unit id="ff5ac14542c8a5c4ff717c937c92483157332c48" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH   Remove all the scripts from the script cache.</source>
          <target state="translated">SCRIPT FLUSH Удалить все сценарии из кэша сценариев.</target>
        </trans-unit>
        <trans-unit id="5e2a68acdd358effce354e479fe828441291386c" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL</source>
          <target state="translated">СКРИПТ-КИЛЛ</target>
        </trans-unit>
        <trans-unit id="898216faf82d0e8094a40fff1a1d11316572b3a1" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL   Kill the script currently in execution.</source>
          <target state="translated">SCRIPT KILL Убейте выполняемый в данный момент скрипт.</target>
        </trans-unit>
        <trans-unit id="bf00a0ed4afe21cec9ac5006aa471a2c75ce80dd" translate="yes" xml:space="preserve">
          <source>SCRIPT LOAD  script   Load the specified Lua script into the script cache.</source>
          <target state="translated">Сценарий SCRIPT LOAD Загрузите указанный скрипт Lua в кэш скриптов.</target>
        </trans-unit>
        <trans-unit id="605e7c9dd422426230eae60c02acc7d7a5705884" translate="yes" xml:space="preserve">
          <source>SDIFF</source>
          <target state="translated">SDIFF</target>
        </trans-unit>
        <trans-unit id="18d8e0e316b86cf9a259f83877f9d4536e919048" translate="yes" xml:space="preserve">
          <source>SDIFF  key [key ...]   Subtract multiple sets</source>
          <target state="translated">SDIFF клавиша [клавиша ...]Вычитание нескольких наборов</target>
        </trans-unit>
        <trans-unit id="144b2bd3509fd63bb1b369b8c7665713eb587bd9" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE</source>
          <target state="translated">SDIFFSTORE</target>
        </trans-unit>
        <trans-unit id="de1820fefd3db78a9062bc31ca0bace599879b7b" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE  destination key [key ...]   Subtract multiple sets and store the resulting set in a key</source>
          <target state="translated">SDIFFSTORE целевая клавиша [клавиша ...]Вычитание нескольких наборов и сохранение полученного набора в клавише</target>
        </trans-unit>
        <trans-unit id="a4942c26d0735947d8a22a2fbe2735a12e381808" translate="yes" xml:space="preserve">
          <source>SELECT</source>
          <target state="translated">SELECT</target>
        </trans-unit>
        <trans-unit id="f439068c5eb4482362ce42c7382665b32a13512a" translate="yes" xml:space="preserve">
          <source>SELECT  index   Change the selected database for the current connection</source>
          <target state="translated">SELECT-индекс Изменение выбранной базы данных для текущего соединения</target>
        </trans-unit>
        <trans-unit id="55c5d81017a30edf1e47ba1b78c377a5e5ebfd50" translate="yes" xml:space="preserve">
          <source>SET</source>
          <target state="translated">SET</target>
        </trans-unit>
        <trans-unit id="b2f1db45c77eaf2c94d566bc200555c564e53670" translate="yes" xml:space="preserve">
          <source>SET  key value [EX seconds|PX milliseconds|KEEPTTL] [NX|XX] [GET]   Set the string value of a key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a720b839d692fc7a7e17565ac1e4963650fe98" translate="yes" xml:space="preserve">
          <source>SET  key value [expiration EX seconds|PX milliseconds] [NX|XX]   Set the string value of a key</source>
          <target state="translated">SET ключевое значение [истечение EX seconds|PX миллисекунд][NX|XX]Установите значение строки ключа.</target>
        </trans-unit>
        <trans-unit id="7df70cb863a3d3a5e4a199b5d8ef3c9851ce87bf" translate="yes" xml:space="preserve">
          <source>SETBIT</source>
          <target state="translated">SETBIT</target>
        </trans-unit>
        <trans-unit id="b66f69a03f672489d4ae1d69a757435c5b63bd51" translate="yes" xml:space="preserve">
          <source>SETBIT  key offset value   Sets or clears the bit at offset in the string value stored at key</source>
          <target state="translated">SETBIT-значение смещения ключа Устанавливает или очищает бит при смещении в строке значение,сохраненное в ключе</target>
        </trans-unit>
        <trans-unit id="c92872db8021ac60dd456ca7447fb52919f32143" translate="yes" xml:space="preserve">
          <source>SETEX</source>
          <target state="translated">SETEX</target>
        </trans-unit>
        <trans-unit id="0b5df1d3ddffe0fdbb568accc5d3c3dac5121afc" translate="yes" xml:space="preserve">
          <source>SETEX  key seconds value   Set the value and expiration of a key</source>
          <target state="translated">Значение параметра SETEX key seconds Установите значение и срок годности ключа.</target>
        </trans-unit>
        <trans-unit id="1ace6531f1c27b916c1368f17e1a7ae87aa79f97" translate="yes" xml:space="preserve">
          <source>SETNX</source>
          <target state="translated">SETNX</target>
        </trans-unit>
        <trans-unit id="a50f293fa49f962b5d82c0bb86c82df413a498b7" translate="yes" xml:space="preserve">
          <source>SETNX  key value   Set the value of a key, only if the key does not exist</source>
          <target state="translated">Значение клавиши SETNX Установите значение клавиши,только если клавиша не существует.</target>
        </trans-unit>
        <trans-unit id="c1d82383232438676e2182b69bf2797640b1fcd2" translate="yes" xml:space="preserve">
          <source>SETRANGE</source>
          <target state="translated">SETRANGE</target>
        </trans-unit>
        <trans-unit id="a2132f99e69e7919051651c2b4fc7de24734eba2" translate="yes" xml:space="preserve">
          <source>SETRANGE  key offset value   Overwrite part of a string at key starting at the specified offset</source>
          <target state="translated">SETRANGE значение смещения ключа Перезапись части строки при ключе,начинающемся с заданного смещения</target>
        </trans-unit>
        <trans-unit id="ec493147ec1b78adab002626ee80cc23772aded8" translate="yes" xml:space="preserve">
          <source>SHUTDOWN</source>
          <target state="translated">SHUTDOWN</target>
        </trans-unit>
        <trans-unit id="606e1ec5d1ea13b283de4e59cd16289518254c6c" translate="yes" xml:space="preserve">
          <source>SHUTDOWN  [NOSAVE|SAVE]   Synchronously save the dataset to disk and then shut down the server</source>
          <target state="translated">SHUTDOWN [NOSAVE|SAVE]Синхронно сохраните набор данных на диск,а затем выключите сервер.</target>
        </trans-unit>
        <trans-unit id="c340be94a16bd060ccd24ece053ed10ff4cfb1a2" translate="yes" xml:space="preserve">
          <source>SINTER</source>
          <target state="translated">SINTER</target>
        </trans-unit>
        <trans-unit id="acc6f9a5a6867145ccd5835b170277c3127f8f60" translate="yes" xml:space="preserve">
          <source>SINTER  key [key ...]   Intersect multiple sets</source>
          <target state="translated">Клавиша SINTER [клавиша ...]Пересекает несколько наборов.</target>
        </trans-unit>
        <trans-unit id="ae286ac2efddc7ffc6de81fb4eef82083c5d0d0a" translate="yes" xml:space="preserve">
          <source>SINTERSTORE</source>
          <target state="translated">SINTERSTORE</target>
        </trans-unit>
        <trans-unit id="3cc889bdb24445318099b6bfa98a849204bc5321" translate="yes" xml:space="preserve">
          <source>SINTERSTORE  destination key [key ...]   Intersect multiple sets and store the resulting set in a key</source>
          <target state="translated">SINTERSTORE целевая клавиша [клавиша ...]Пересечение нескольких наборов и сохранение результирующего набора в клавишу</target>
        </trans-unit>
        <trans-unit id="8074903f43c428dec41033b139437bb9d7e46e61" translate="yes" xml:space="preserve">
          <source>SISMEMBER</source>
          <target state="translated">SISMEMBER</target>
        </trans-unit>
        <trans-unit id="2613d73d648b1f6845f55faac8664acb5e2e9af6" translate="yes" xml:space="preserve">
          <source>SISMEMBER  key member   Determine if a given value is a member of a set</source>
          <target state="translated">Ключевой член СИСМЕМБЕР Определить,является ли заданное значение членом набора</target>
        </trans-unit>
        <trans-unit id="bb3731aa645af4f77072e934700ff033a81e173b" translate="yes" xml:space="preserve">
          <source>SLAVEOF</source>
          <target state="translated">SLAVEOF</target>
        </trans-unit>
        <trans-unit id="9bb4401fd3b09a14ad63da1fc4e0ebcc9c0ee189" translate="yes" xml:space="preserve">
          <source>SLAVEOF  host port   Make the server a replica of another instance, or promote it as master. Deprecated starting with Redis 5. Use REPLICAOF instead.</source>
          <target state="translated">SLAVEOF порт хоста Сделать сервер копией другого экземпляра,или продвинуть его в качестве мастера.Исключено,начиная с Redis 5.Вместо этого используйте REPLICAOF.</target>
        </trans-unit>
        <trans-unit id="4078b703021998b0c963d9636d85d96b1ddfa618" translate="yes" xml:space="preserve">
          <source>SLOWLOG</source>
          <target state="translated">SLOWLOG</target>
        </trans-unit>
        <trans-unit id="acfcd934ccfd2203f5ccc3e824371c24109642b8" translate="yes" xml:space="preserve">
          <source>SLOWLOG  subcommand [argument]   Manages the Redis slow queries log</source>
          <target state="translated">Подкоманда SLOWLOG [аргумент]Управляет журналом медленных запросов Redis.</target>
        </trans-unit>
        <trans-unit id="e6687e28d8b75312f0ea51bc9520b394ec2a7a63" translate="yes" xml:space="preserve">
          <source>SMEMBERS</source>
          <target state="translated">SMEMBERS</target>
        </trans-unit>
        <trans-unit id="fe66421f332187f83010e275c4b51042858f5234" translate="yes" xml:space="preserve">
          <source>SMEMBERS  key   Get all the members in a set</source>
          <target state="translated">Клавиша SMEMBERS Получить все члены в набор</target>
        </trans-unit>
        <trans-unit id="3a5a30822e064f7dd03cefac6d437e4654f3aca9" translate="yes" xml:space="preserve">
          <source>SMISMEMBER</source>
          <target state="translated">SMISMEMBER</target>
        </trans-unit>
        <trans-unit id="aaa0292e655dd3747fc97cd25825a806d4aa708b" translate="yes" xml:space="preserve">
          <source>SMISMEMBER  key member [member ...]   Returns the membership associated with the given elements for a set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f84dbd21a3d84899dade0a24ef5c6978f0403e" translate="yes" xml:space="preserve">
          <source>SMOVE</source>
          <target state="translated">SMOVE</target>
        </trans-unit>
        <trans-unit id="1f7888e464279456fc99ea1259b436e9ad0d4f64" translate="yes" xml:space="preserve">
          <source>SMOVE  source destination member   Move a member from one set to another</source>
          <target state="translated">SMOVE член-получатель источника Перемещение члена из одного набора в другой</target>
        </trans-unit>
        <trans-unit id="2434fe1de87e4949f51786cc87dd6a83c095a422" translate="yes" xml:space="preserve">
          <source>SORT</source>
          <target state="translated">SORT</target>
        </trans-unit>
        <trans-unit id="8e248ec645f54a08b3eb01462adb200f94f15d79" translate="yes" xml:space="preserve">
          <source>SORT  key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]   Sort the elements in a list, set or sorted set</source>
          <target state="translated">Клавиша SORT [BY pattern][LIMIT offset count][GET pattern [GET pattern ...]].[ASC|DESC][ALPHA][STORE destination]Сортировка элементов в списке,установка или сортировка множества.</target>
        </trans-unit>
        <trans-unit id="757f5e1ed1192585c3e7deb4986d7e204a0c8613" translate="yes" xml:space="preserve">
          <source>SPOP</source>
          <target state="translated">SPOP</target>
        </trans-unit>
        <trans-unit id="a1bcd919a884989656266471e065ce0ed9f3b014" translate="yes" xml:space="preserve">
          <source>SPOP  key [count]   Remove and return one or multiple random members from a set</source>
          <target state="translated">Клавиша SPOP [считать]Удаление и возврат одного или нескольких случайных членов из набора</target>
        </trans-unit>
        <trans-unit id="fa889adf02f632d165c3f2d12d9b5ec8d781cbb2" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER</source>
          <target state="translated">SRANDMEMBER</target>
        </trans-unit>
        <trans-unit id="a3aa05de6787d8cb6b5fb2eeb41ce24756a254c7" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER  key [count]   Get one or multiple random members from a set</source>
          <target state="translated">Клавиша SRANDMEMBER [считать]Получить один или несколько случайных членов из набора</target>
        </trans-unit>
        <trans-unit id="a25d27e5f9def5c1d9e1a790c413156760a00937" translate="yes" xml:space="preserve">
          <source>SREM</source>
          <target state="translated">SREM</target>
        </trans-unit>
        <trans-unit id="68363946a4081440ca501f29c43f5fbe4f7eefc4" translate="yes" xml:space="preserve">
          <source>SREM  key member [member ...]   Remove one or more members from a set</source>
          <target state="translated">Ключевой член ППСР [член ...]Исключить одного или нескольких членов из набора.</target>
        </trans-unit>
        <trans-unit id="39f084973b61a7bea28e4e94336a3c5a0bf9fee7" translate="yes" xml:space="preserve">
          <source>SSCAN</source>
          <target state="translated">SSCAN</target>
        </trans-unit>
        <trans-unit id="9c2bba696b7b86cd88c82a287899370d9f0e3bb5" translate="yes" xml:space="preserve">
          <source>SSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate Set elements</source>
          <target state="translated">Курсор клавиши SSCAN [Шаблон сравнения][Количество СОЕДИНЕНИЙ]Интенсивная итерация Элементы набора</target>
        </trans-unit>
        <trans-unit id="746fc78a74ffba46a591afc21fe85ad08b00b6da" translate="yes" xml:space="preserve">
          <source>STRALGO</source>
          <target state="translated">STRALGO</target>
        </trans-unit>
        <trans-unit id="3faaaa804aaa356ec8a33bd42d375f1bc189c7e7" translate="yes" xml:space="preserve">
          <source>STRALGO  LCS algo-specific-argument [algo-specific-argument ...]   Run algorithms (currently LCS) against strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89c4cb21a1d403bb307b502f69a87f9e3b3a8ab" translate="yes" xml:space="preserve">
          <source>STRLEN</source>
          <target state="translated">STRLEN</target>
        </trans-unit>
        <trans-unit id="ba1403b52701f08d29eb084587b5d84ec8dde893" translate="yes" xml:space="preserve">
          <source>STRLEN  key   Get the length of the value stored in a key</source>
          <target state="translated">Клавиша STRLEN Получить длину значения,сохраненного в клавише.</target>
        </trans-unit>
        <trans-unit id="43a6e12318adbbee03f06872c109322b0f558e29" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE</source>
          <target state="translated">SUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="47236795c3b9acd1da0f66ecb88ffdd913189ac5" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE  channel [channel ...]   Listen for messages published to the given channels</source>
          <target state="translated">SUBSCRIBE-канал [канал ...]Прослушивание сообщений,опубликованных по данным каналам.</target>
        </trans-unit>
        <trans-unit id="a9a4bd3707fb7f204fddf46673a38114093dbb82" translate="yes" xml:space="preserve">
          <source>SUNION</source>
          <target state="translated">SUNION</target>
        </trans-unit>
        <trans-unit id="5b757c33f2f9e74b674645b6ccda3d80138ff877" translate="yes" xml:space="preserve">
          <source>SUNION  key [key ...]   Add multiple sets</source>
          <target state="translated">Клавиша SUNION [клавиша ...]Добавить несколько наборов</target>
        </trans-unit>
        <trans-unit id="48b1035f133322c326cae720a6ee6ad1108226dc" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE</source>
          <target state="translated">SUNIONSTORE</target>
        </trans-unit>
        <trans-unit id="be4a84a92460ba7a99f970a1bd856700c5285869" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE  destination key [key ...]   Add multiple sets and store the resulting set in a key</source>
          <target state="translated">SUNIONSTORE целевая клавиша [клавиша ...]Добавьте несколько наборов и сохраните полученный набор в виде клавиши.</target>
        </trans-unit>
        <trans-unit id="52e8b5aa51a1b6c9b46c6f4abe8b613e777665e4" translate="yes" xml:space="preserve">
          <source>SWAPDB</source>
          <target state="translated">SWAPDB</target>
        </trans-unit>
        <trans-unit id="b86537c7b961d4302819caedcc63376c729b2e03" translate="yes" xml:space="preserve">
          <source>SWAPDB  index index   Swaps two Redis databases</source>
          <target state="translated">SWAPDB индексный индекс свопы две базы данных Redis</target>
        </trans-unit>
        <trans-unit id="77754660ca2a32513ded08ad488bd2a9af650258" translate="yes" xml:space="preserve">
          <source>SWAPDB  index1 index2   Swaps two Redis databases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f8d236566d2393cd3a112e7190d8837c8004cc2" translate="yes" xml:space="preserve">
          <source>SYNC</source>
          <target state="translated">SYNC</target>
        </trans-unit>
        <trans-unit id="7dade54cfe46a1450fe32e252c2fe2557e402641" translate="yes" xml:space="preserve">
          <source>SYNC   Internal command used for replication</source>
          <target state="translated">SYNC Внутренняя команда,используемая для репликации</target>
        </trans-unit>
        <trans-unit id="b54491fb2810da81b1ac818eeb380198be74decd" translate="yes" xml:space="preserve">
          <source>Same result format as &lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt; except you can specify which commands get returned.</source>
          <target state="translated">Тот же формат результата, что и &lt;a href=&quot;command&quot;&gt;COMMAND,&lt;/a&gt; за исключением того, что вы можете указать, какие команды будут возвращены.</target>
        </trans-unit>
        <trans-unit id="1cc201c6f067fb6b6182b441f2b6dc0f4b71649b" translate="yes" xml:space="preserve">
          <source>Sample Output (new version, includes IDs)</source>
          <target state="translated">Вывод образца (новая версия,включает в себя идентификаторы)</target>
        </trans-unit>
        <trans-unit id="fb0cb1b1aa0fcb98cea480e75b0d7dffc839cef1" translate="yes" xml:space="preserve">
          <source>Sample Output (old version)</source>
          <target state="translated">Вывод образца (старая версия)</target>
        </trans-unit>
        <trans-unit id="7a614be0679e1660abb7ab566a46118d4e5207f9" translate="yes" xml:space="preserve">
          <source>Sandbox and maximum execution time</source>
          <target state="translated">Песочница и максимальное время исполнения</target>
        </trans-unit>
        <trans-unit id="c660854037806380c25fadc61428fa995d1aa015" translate="yes" xml:space="preserve">
          <source>Save the DB in background.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444bd4af75b503112dd46c6982e0bae0a08cf7c2" translate="yes" xml:space="preserve">
          <source>Save the DB in background. The OK code is immediately returned. Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits. A client may be able to check if the operation succeeded using the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; command.</source>
          <target state="translated">Сохраните БД в фоновом режиме. Код ОК немедленно возвращается. Redis разветвляется, родитель продолжает обслуживать клиентов, потомок сохраняет БД на диск, а затем завершает работу. Клиент может проверить &lt;a href=&quot;lastsave&quot;&gt;успешность&lt;/a&gt; операции с помощью команды LASTSAVE .</target>
        </trans-unit>
        <trans-unit id="6e73e4e94939b275e189527f28b962ac1035dc5b" translate="yes" xml:space="preserve">
          <source>Scan guarantees</source>
          <target state="translated">Гарантии сканирования</target>
        </trans-unit>
        <trans-unit id="983987071368a426b6b0e610cd5b5142cb273380" translate="yes" xml:space="preserve">
          <source>Script cache semantics</source>
          <target state="translated">семантика кэша сценария</target>
        </trans-unit>
        <trans-unit id="7522becbe814d8b8cbc378f8930c8ca68bb2b8b5" translate="yes" xml:space="preserve">
          <source>Scripting</source>
          <target state="translated">Scripting</target>
        </trans-unit>
        <trans-unit id="745fe7d4baa466214b942befb3f50f3311c89d23" translate="yes" xml:space="preserve">
          <source>Scripts are also subject to a maximum execution time (five seconds by default). This default timeout is huge since a script should usually run in under a millisecond. The limit is mostly to handle accidental infinite loops created during development.</source>
          <target state="translated">На скрипты также распространяется максимальное время выполнения (по умолчанию пять секунд).Этот стандартный таймаут огромен,так как скрипт обычно должен выполняться менее чем за миллисекунду.Ограничением в основном является обработка случайных бесконечных циклов,создаваемых во время разработки.</target>
        </trans-unit>
        <trans-unit id="aef3e907fc9586fb823b51b6f43074de8b409561" translate="yes" xml:space="preserve">
          <source>Scripts as pure functions</source>
          <target state="translated">Скрипты как чистые функции</target>
        </trans-unit>
        <trans-unit id="18ec3225e4d3fe66e7449672a6973e4c283e8bfa" translate="yes" xml:space="preserve">
          <source>Scripts should never try to access the external system, like the file system or any other system call. A script should only operate on Redis data and passed arguments.</source>
          <target state="translated">Скрипты никогда не должны пытаться получить доступ к внешней системе,например,к файловой системе или любому другому системному вызову.Скрипт должен работать только с данными Redis и переданными аргументами.</target>
        </trans-unit>
        <trans-unit id="96faa0a78d5b1890951d8f5b8b1cde571bd90423" translate="yes" xml:space="preserve">
          <source>Second replica</source>
          <target state="translated">Вторая реплика</target>
        </trans-unit>
        <trans-unit id="3eb4e043552c7873cf099793db5b7d1e5db95809" translate="yes" xml:space="preserve">
          <source>Security notice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a6bb51bed42ec84477a8c64f567145dc6b3f5b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; for documentation.</source>
          <target state="translated">См. &lt;a href=&quot;flushall&quot;&gt;Документацию в FLUSHALL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82b75cc42f6596f8de98cea0e684609b487d2473" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; for extra information on increment/decrement operations.</source>
          <target state="translated">См. &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; для получения дополнительной информации об операциях увеличения / уменьшения.</target>
        </trans-unit>
        <trans-unit id="b864667dcad5904883861ad9695e349acea56ad8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107b4f4ca6c2e49d71158688712e821a1f6afcf3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; for more information.</source>
          <target state="translated">См. &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="54208184c8545cb10751d54f17912e96124fdcce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">См. &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; для документации &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7350f489b2f884299284e290b37d7bb050416da" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">См. &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; для документации &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23e07b46cb9a86395d17dec6e25da38c0a253bd8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">См. &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; для документации &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf5419ddb7be58d105f864a1bb383d4d274d8979" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; when you need the elements ordered from highest to lowest score (and descending lexicographical order for elements with equal score).</source>
          <target state="translated">См. &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE,&lt;/a&gt; если вам нужны элементы, упорядоченные от наивысшего к наименьшему баллу (и нисходящий лексикографический порядок для элементов с одинаковым баллом).</target>
        </trans-unit>
        <trans-unit id="a4157bb7f9bac5025b0c70053cd9e97522de9f5f" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; command that returns the same information with milliseconds resolution (Only available in Redis 2.6 or greater).</source>
          <target state="translated">См. Также команду &lt;a href=&quot;pttl&quot;&gt;PTTL,&lt;/a&gt; которая возвращает ту же информацию с разрешением в миллисекунды (доступно только в Redis 2.6 или выше).</target>
        </trans-unit>
        <trans-unit id="3f65c6fd246f3e1cbd884a1abc8369fa9e3fec12" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being that it pops elements from the tail of a list instead of popping from the head.</source>
          <target state="translated">См. Точную семантику в &lt;a href=&quot;blpop&quot;&gt;документации&lt;/a&gt; по BLPOP , поскольку &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; идентичен &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; с той лишь разницей, что он выталкивает элементы из хвоста списка, а не из начала.</target>
        </trans-unit>
        <trans-unit id="98f2a156aa61e815ac476620027b033818a3853f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being the data structure being popped from.</source>
          <target state="translated">См. Точную семантику в &lt;a href=&quot;blpop&quot;&gt;документации&lt;/a&gt; по BLPOP , поскольку &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; идентичен &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; с той лишь разницей, что структура данных извлекается из.</target>
        </trans-unit>
        <trans-unit id="682db2e97701526e3ecf1f9201b3297eab6f9ec7" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; is identical to &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; with the only difference being that it pops members with the highest scores instead of popping the ones with the lowest scores.</source>
          <target state="translated">См. &lt;a href=&quot;bzpopmin&quot;&gt;Документацию BZPOPMIN&lt;/a&gt; для получения точной семантики, поскольку &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; идентичен &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; с той лишь разницей, что он выталкивает элементы с наивысшими оценками вместо того, чтобы выталкивать те, которые имеют самые низкие оценки.</target>
        </trans-unit>
        <trans-unit id="58bc20fb0dd298ffb8cf41a50998826b6c62ee0f" translate="yes" xml:space="preserve">
          <source>See the article called &quot;&lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Fast easy realtime metrics using Redis bitmaps&lt;/a&gt;&quot; for a interesting use cases.</source>
          <target state="translated">См. Статью &amp;laquo; &lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Быстрые и простые метрики в реальном времени с использованием растровых изображений Redis&lt;/a&gt; &amp;raquo;, где описаны интересные варианты использования.</target>
        </trans-unit>
        <trans-unit id="2b55d9f15b0ea2d72611a684c74d755e0354f5c5" translate="yes" xml:space="preserve">
          <source>Select the Redis logical database having the specified zero-based numeric index. New connections always use the database 0.</source>
          <target state="translated">Выберите логическую базу данных Redis с указанным нулевым цифровым индексом.Новые соединения всегда используют БД 0.</target>
        </trans-unit>
        <trans-unit id="5e585c2b51baeb7604c1d696f4c6be82b1e7c611" translate="yes" xml:space="preserve">
          <source>Selectable Redis databases are a form of namespacing: all databases are still persisted in the same RDB / AOF file. However different databases can have keys with the same name, and commands like &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;, &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; or &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; work on specific databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19899928b5f8951aa558a826d2465808d72a01a5" translate="yes" xml:space="preserve">
          <source>Selective replication of commands</source>
          <target state="translated">Селективная репликация команд</target>
        </trans-unit>
        <trans-unit id="49cedc3ef8c6db0043eba553132d30f3fe261b2a" translate="yes" xml:space="preserve">
          <source>Sentinel output</source>
          <target state="translated">Часовой выход</target>
        </trans-unit>
        <trans-unit id="23e75937982f844ac2efdda93d0cf6e15629e1a7" translate="yes" xml:space="preserve">
          <source>Serialization format</source>
          <target state="translated">формат сериализации</target>
        </trans-unit>
        <trans-unit id="7af4afd659e0dc29f7d2d75a3f48646f5eb4ec0b" translate="yes" xml:space="preserve">
          <source>Serialize the value stored at key in a Redis-specific format and return it to the user. The returned value can be synthesized back into a Redis key using the &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command.</source>
          <target state="translated">Сериализуйте значение, хранящееся в ключе, в формате, специфичном для Redis, и верните его пользователю. Возвращаемое значение можно синтезировать обратно в ключ Redis с помощью команды &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="c0ae85ee6d7ed57f6a577247b126ae67f64df433" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold string &lt;code&gt;value&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist. In that case, it is equal to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. When &lt;code&gt;key&lt;/code&gt; already holds a value, no operation is performed. &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; is short for &quot;&lt;strong&gt;SET&lt;/strong&gt; if &lt;strong&gt;N&lt;/strong&gt;ot e&lt;strong&gt;X&lt;/strong&gt;ists&quot;.</source>
          <target state="translated">Установите &lt;code&gt;key&lt;/code&gt; для хранения строкового &lt;code&gt;value&lt;/code&gt; если &lt;code&gt;key&lt;/code&gt; не существует. В этом случае он равен &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; . Когда &lt;code&gt;key&lt;/code&gt; уже содержит значение, операция не выполняется. &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; является аббревиатурой &amp;laquo; &lt;strong&gt;SET&lt;/strong&gt; , если &lt;strong&gt;N&lt;/strong&gt; ВЗ е &lt;strong&gt;X&lt;/strong&gt; сты&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="68ffd036a56e1e5a5a24f70d86f4819eb308fad6" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt; and set &lt;code&gt;key&lt;/code&gt; to timeout after a given number of seconds. This command is equivalent to executing the following commands:</source>
          <target state="translated">Установите &lt;code&gt;key&lt;/code&gt; для удержания строкового &lt;code&gt;value&lt;/code&gt; и установите для &lt;code&gt;key&lt;/code&gt; ожидания по истечении заданного количества секунд. Эта команда эквивалентна выполнению следующих команд:</target>
        </trans-unit>
        <trans-unit id="e17569ffaef1d28acdfd66d09de8af3c0b06dd1a" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; already holds a value, it is overwritten, regardless of its type. Any previous time to live associated with the key is discarded on successful &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation.</source>
          <target state="translated">Установите &lt;code&gt;key&lt;/code&gt; для хранения строкового &lt;code&gt;value&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; уже содержит значение, оно перезаписывается независимо от его типа. Любое предыдущее время жизни, связанное с ключом, сбрасывается при успешной операции &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f4c1e8e25a5de08761510d1ae33392ed98c3afb" translate="yes" xml:space="preserve">
          <source>Set a timeout on &lt;code&gt;key&lt;/code&gt;. After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is often said to be &lt;em&gt;volatile&lt;/em&gt; in Redis terminology.</source>
          <target state="translated">Установите таймаут на &lt;code&gt;key&lt;/code&gt; . По истечении таймаута ключ будет автоматически удален. В терминологии Redis ключ с соответствующим таймаутом часто называют &lt;em&gt;изменчивым&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="eaec93cdacc6eb6c55472f85e73e6fb3ad082dbe" translate="yes" xml:space="preserve">
          <source>Set the consumer group &lt;em&gt;last delivered ID&lt;/em&gt; to something else.</source>
          <target state="translated">Установите другой &lt;em&gt;идентификатор&lt;/em&gt; группы потребителей, &lt;em&gt;доставленный последней&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5d89ad31b7de012f12a03f34f4620f730e4db31a" translate="yes" xml:space="preserve">
          <source>Set the debug mode for subsequent scripts executed with &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;. Redis includes a complete Lua debugger, codename LDB, that can be used to make the task of writing complex scripts much simpler. In debug mode Redis acts as a remote debugging server and a client, such as &lt;code&gt;redis-cli&lt;/code&gt;, can execute scripts step by step, set breakpoints, inspect variables and more - for additional information about LDB refer to the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Lua debugger&lt;/a&gt; page.</source>
          <target state="translated">Установите режим отладки для последующих скриптов, выполняемых с &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; . Redis включает в себя полный отладчик Lua под кодовым именем LDB, который можно использовать, чтобы значительно упростить задачу написания сложных сценариев. В режиме отладки Redis действует как сервер удаленной отладки, а клиент, такой как &lt;code&gt;redis-cli&lt;/code&gt; , может выполнять сценарии шаг за шагом, устанавливать точки останова, проверять переменные и многое другое - для получения дополнительной информации о LDB обратитесь к странице &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;отладчика Redis Lua&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6550b71f96cbf89e715fc6e575e8db9958a3525f" translate="yes" xml:space="preserve">
          <source>Set the destination node slot to &lt;em&gt;importing&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Установите слот узла назначения в состояние &lt;em&gt;импорта&lt;/em&gt; с помощью &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84c2dc8e1aa43a852766a49a5d96696d6e7e9329" translate="yes" xml:space="preserve">
          <source>Set the source node slot to &lt;em&gt;migrating&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Установите слот исходного узла в состояние &lt;em&gt;миграции&lt;/em&gt; с помощью &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ab262f44dfc9e1ee8adf98c1aa64de34434fa83" translate="yes" xml:space="preserve">
          <source>Sets</source>
          <target state="translated">Sets</target>
        </trans-unit>
        <trans-unit id="d9264103cd2db8160e2072438f28377ce6a9fc7b" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, only if &lt;code&gt;field&lt;/code&gt; does not yet exist. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists, this operation has no effect.</source>
          <target state="translated">Устанавливает &lt;code&gt;field&lt;/code&gt; в хэше, хранящемся под &lt;code&gt;key&lt;/code&gt; в &lt;code&gt;value&lt;/code&gt; , только если &lt;code&gt;field&lt;/code&gt; еще не существует. Если &lt;code&gt;key&lt;/code&gt; не существует, создается новый ключ, содержащий хеш. Если &lt;code&gt;field&lt;/code&gt; уже существует, эта операция не действует.</target>
        </trans-unit>
        <trans-unit id="4067fd3c70d6275dbeb4b012c5dce8cf613a429a" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists in the hash, it is overwritten.</source>
          <target state="translated">Устанавливает &lt;code&gt;field&lt;/code&gt; в хэше, хранящемся под &lt;code&gt;key&lt;/code&gt; к &lt;code&gt;value&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; не существует, создается новый ключ, содержащий хеш. Если &lt;code&gt;field&lt;/code&gt; уже существует в хэше, оно перезаписывается.</target>
        </trans-unit>
        <trans-unit id="e0c3c8b5846a6b7343db97e53a136456e18a31e2" translate="yes" xml:space="preserve">
          <source>Sets can be encoded as &lt;code&gt;intset&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;intset&lt;/code&gt; is a special encoding used for small sets composed solely of integers.</source>
          <target state="translated">Наборы могут быть закодированы как &lt;code&gt;intset&lt;/code&gt; или &lt;code&gt;hashtable&lt;/code&gt; . &lt;code&gt;intset&lt;/code&gt; это специальное кодирование , используемое для небольших наборов , состоящих исключительно из целых чисел.</target>
        </trans-unit>
        <trans-unit id="e2de8a522a3c6c1fa9f2cb3110ab55a427778354" translate="yes" xml:space="preserve">
          <source>Sets or clears the bit at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">Устанавливает или очищает бит по &lt;em&gt;смещению&lt;/em&gt; в строковом значении, хранящемся в &lt;em&gt;ключе&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e97dcc6f663f896d57a6785f5e028d865ad0719f" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; replaces existing values with new values, just as regular &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. See &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; if you don't want to overwrite existing values.</source>
          <target state="translated">Устанавливает для заданных ключей соответствующие значения. &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; заменяет существующие значения новыми значениями, как и обычный &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; . См. &lt;a href=&quot;msetnx&quot;&gt;MSETNX,&lt;/a&gt; если вы не хотите перезаписывать существующие значения.</target>
        </trans-unit>
        <trans-unit id="5a2c8ceb3bc610f26a67627aba4acc8339a9ce7d" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; will not perform any operation at all even if just a single key already exists.</source>
          <target state="translated">Устанавливает для заданных ключей соответствующие значения. &lt;a href=&quot;msetnx&quot;&gt;MSETNX вообще&lt;/a&gt; не будет выполнять никаких операций, даже если уже существует только один ключ.</target>
        </trans-unit>
        <trans-unit id="97465787360d692779d220c22de863eac3b87265" translate="yes" xml:space="preserve">
          <source>Sets the list element at &lt;code&gt;index&lt;/code&gt; to &lt;code&gt;element&lt;/code&gt;. For more information on the &lt;code&gt;index&lt;/code&gt; argument, see &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8750c7a418a307afb7502f752e1bd4c1264fa761" translate="yes" xml:space="preserve">
          <source>Sets the list element at &lt;code&gt;index&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. For more information on the &lt;code&gt;index&lt;/code&gt; argument, see &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;.</source>
          <target state="translated">Устанавливает элемент списка по &lt;code&gt;index&lt;/code&gt; в &lt;code&gt;value&lt;/code&gt; . Дополнительные сведения об аргументе &lt;code&gt;index&lt;/code&gt; см . В разделе &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3acb8a6c67905faa893fe92726100c83a3b40b2e" translate="yes" xml:space="preserve">
          <source>Sets the specified fields to their respective values in the hash stored at &lt;code&gt;key&lt;/code&gt;. This command overwrites any specified fields already existing in the hash. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created.</source>
          <target state="translated">Устанавливает для указанных полей соответствующие значения в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; . Эта команда перезаписывает любые указанные поля, уже существующие в хэше. Если &lt;code&gt;key&lt;/code&gt; не существует, создается новый ключ, содержащий хеш.</target>
        </trans-unit>
        <trans-unit id="66e4a6395d06dd6c9ac9889a54defa5d69368f6e" translate="yes" xml:space="preserve">
          <source>Similarly to get just the last element added into the stream it is enough to send:</source>
          <target state="translated">Аналогично тому,чтобы получить только последний элемент,добавленный в поток,достаточно отправить:</target>
        </trans-unit>
        <trans-unit id="e66ca1aceaf1d95b66f61ef999386ba4322050ac" translate="yes" xml:space="preserve">
          <source>Simple string reply</source>
          <target state="translated">Простой строковый ответ</target>
        </trans-unit>
        <trans-unit id="d1d2334a81971315130c4fe2db94eeb5d843a482" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; and &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; have a &lt;code&gt;STORE&lt;/code&gt; and &lt;code&gt;STOREDIST&lt;/code&gt; option they are technically flagged as writing commands in the Redis command table. For this reason read-only replicas will flag them, and Redis Cluster replicas will redirect them to the master instance even if the connection is in read only mode (See the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command of Redis Cluster).</source>
          <target state="translated">Поскольку &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; и &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; имеют опции &lt;code&gt;STORE&lt;/code&gt; и &lt;code&gt;STOREDIST&lt;/code&gt; , они технически помечены как записывающие команды в таблице команд Redis. По этой причине реплики, доступные только для чтения, &lt;a href=&quot;readonly&quot;&gt;помечают&lt;/a&gt; их, а реплики Redis Cluster перенаправляют их на главный экземпляр, даже если соединение находится в режиме только для чтения (см. Команду READONLY для Redis Cluster).</target>
        </trans-unit>
        <trans-unit id="97d9bd95aec04226ad20ff34e75e5087d27999bb" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; returns the number of replicas reached both in case of failure and success, the client should check that the returned value is equal or greater to the replication level it demanded.</source>
          <target state="translated">Поскольку &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; возвращает количество реплик, достигнутых как в случае сбоя, так и в случае успеха, клиент должен проверить, что возвращаемое значение равно или больше требуемого уровня репликации.</target>
        </trans-unit>
        <trans-unit id="d91e505ea765c9a82be96ae5534dfec641b36446" translate="yes" xml:space="preserve">
          <source>Since Redis 2.4 the AOF rewrite is automatically triggered by Redis, however the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; command can be used to trigger a rewrite at any time.</source>
          <target state="translated">Начиная с Redis 2.4, перезапись AOF автоматически запускается Redis, однако команду &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; можно использовать для запуска перезаписи в любое время.</target>
        </trans-unit>
        <trans-unit id="fea1afb4200834342d36841c2047774edeed20c3" translate="yes" xml:space="preserve">
          <source>Since Redis 2.6 the expire error is from 0 to 1 milliseconds.</source>
          <target state="translated">Так как Redis 2.6 ошибка истечения срока действия составляет от 0 до 1 миллисекунды.</target>
        </trans-unit>
        <trans-unit id="c0dcf1f129fbdd5b581db58c1a230256a6836c37" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 it is possible to specify multiple keys instead of a single one. In such a case, it returns the total number of keys existing. Note that returning 1 or 0 for a single key is just a special case of the variadic usage, so the command is completely backward compatible.</source>
          <target state="translated">Начиная с версии 3.0.3 в Redis можно указывать несколько ключей вместо одного.В этом случае возвращается общее количество существующих ключей.Обратите внимание,что возврат 1 или 0 для одного ключа является лишь частным случаем разновидного использования,поэтому команда полностью обратно совместима.</target>
        </trans-unit>
        <trans-unit id="f8bcf2ebedfce566d24835d3a2aba17bb7c2d1ca" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 the command accepts a variable number of keys and the return value is generalized:</source>
          <target state="translated">Так как в Redis 3.0.3 команда принимает переменное количество ключей,а возвращаемое значение является обобщенным:</target>
        </trans-unit>
        <trans-unit id="e151485b203362c942ed95e59fd38510a0f0ba0d" translate="yes" xml:space="preserve">
          <source>Since Redis 3.2.10 / 4.0.0, this command also prevents keys to be evicted or expired during the time clients are paused. This way the dataset is guaranteed to be static not just from the point of view of clients not being able to write, but also from the point of view of internal operations.</source>
          <target state="translated">Начиная с версии 3.2.10/4.0.0,эта команда также предотвращает вытеснение или истечение срока действия ключей во время приостановки работы клиентов.Таким образом,набор данных гарантированно будет статичным не только с точки зрения невозможности записи,но и с точки зрения внутренних операций.</target>
        </trans-unit>
        <trans-unit id="b23d8947d72fa1ab05d11117a996f014677a635b" translate="yes" xml:space="preserve">
          <source>Since in the second call the returned cursor is 0, the server signaled to the caller that the iteration finished, and the collection was completely explored. Starting an iteration with a cursor value of 0, and calling &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; until the returned cursor is 0 again is called a &lt;strong&gt;full iteration&lt;/strong&gt;.</source>
          <target state="translated">Поскольку во втором вызове возвращенный курсор равен 0, сервер сигнализировал вызывающему, что итерация завершена, и коллекция была полностью исследована. Запуск итерации со значением курсора 0 и вызов &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; до тех пор, пока возвращенный курсор снова не станет 0, называется &lt;strong&gt;полной итерацией&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5ff6f2c9633e20e1d4f2fc7a23a6109e8917c9ab" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;increment&lt;/code&gt; argument is signed, both increment and decrement operations can be performed:</source>
          <target state="translated">Поскольку аргумент &lt;code&gt;increment&lt;/code&gt; подписан, могут выполняться операции как увеличения, так и уменьшения:</target>
        </trans-unit>
        <trans-unit id="37a6aaafe1e5adca5e6fbd58e615c9ceed7c328a" translate="yes" xml:space="preserve">
          <source>Since the currently selected database is a property of the connection, clients should track the currently selected database and re-select it on reconnection. While there is no command in order to query the selected database in the current connection, the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; output shows, for each client, the currently selected database.</source>
          <target state="translated">Поскольку текущая выбранная база данных является свойством соединения, клиенты должны отслеживать текущую выбранную базу данных и повторно выбирать ее при повторном подключении. Хотя нет команды для запроса выбранной базы данных в текущем соединении, выходные данные &lt;a href=&quot;client-list&quot;&gt;СПИСОК КЛИЕНТОВ&lt;/a&gt; показывают для каждого клиента текущую выбранную базу данных.</target>
        </trans-unit>
        <trans-unit id="52b5e60090730a6d250177de9e20295f9eac7ba4" translate="yes" xml:space="preserve">
          <source>Since the introduction of partial resynchronization with replicas (PSYNC feature) Redis replicas asynchronously ping their master with the offset they already processed in the replication stream. This is used in multiple ways:</source>
          <target state="translated">С момента введения частичной ресинхронизации с репликами (функция PSYNC)реплики ресинхронизируются асинхронно пингом своего мастера со смещением,которое они уже обработали в потоке репликации.Это используется несколькими способами:</target>
        </trans-unit>
        <trans-unit id="22f6371320dc02af91620e9a2e69ac86d721aec2" translate="yes" xml:space="preserve">
          <source>Since there is no state server side, but the full state is captured by the cursor, the caller is free to terminate an iteration half-way without signaling this to the server in any way. An infinite number of iterations can be started and never terminated without any issue.</source>
          <target state="translated">Так как нет государственной стороны сервера,но полное состояние перехватывается курсором,вызывающий абонент может завершить итерацию на полпути,не сообщая об этом серверу ни в коем случае.Бесконечное количество итераций может быть запущено и никогда не завершено без каких-либо проблем.</target>
        </trans-unit>
        <trans-unit id="262e696e012026f3d4f6a8415b02d5a7c46227f9" translate="yes" xml:space="preserve">
          <source>Since these commands allow for incremental iteration, returning only a small number of elements per call, they can be used in production without the downside of commands like &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; or &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; that may block the server for a long time (even several seconds) when called against big collections of keys or elements.</source>
          <target state="translated">Поскольку эти команды допускают инкрементную итерацию, возвращая только небольшое количество элементов за вызов, их можно использовать в производственной &lt;a href=&quot;smembers&quot;&gt;среде без обратной&lt;/a&gt; стороны таких команд, как &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; или SMEMBERS, которые могут блокировать сервер на долгое время (даже несколько секунд) при вызове большие коллекции ключей или элементов.</target>
        </trans-unit>
        <trans-unit id="3c0c8d4b217b1b3c149a8290667da3e389e7ef26" translate="yes" xml:space="preserve">
          <source>Since this involves approximations, in order to avoid C is set to, like, 0.998 instead of 1, we just modify the above algorithm to make sure the last score is 1 (left as an exercise for the reader...).</source>
          <target state="translated">Так как это включает в себя аппроксимации,для того,чтобы избежать C установлено значение 0.998 вместо 1,мы просто модифицируем вышеприведенный алгоритм,чтобы убедиться,что последняя оценка равна 1 (слева в качестве упражнения для читателя...).</target>
        </trans-unit>
        <trans-unit id="7872f5590df64a34d5d83302b83736d78de377e5" translate="yes" xml:space="preserve">
          <source>Since version 2.1.6, &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; can be exclusive, following the syntax of &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">Начиная с версии 2.1.6, &lt;code&gt;min&lt;/code&gt; и &lt;code&gt;max&lt;/code&gt; могут быть исключительными, следуя синтаксису &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62c6108c3b6b3ae8ea558c2fa3e4a664136371f3" translate="yes" xml:space="preserve">
          <source>Since version 6.2 it is possible to filter entries by their idle-time, given in milliseconds (useful for &lt;code&gt;XCLAIM&lt;/code&gt;ing entries that have not been processed for some time):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1d2abc7675af0239fa910c466960e644589788" translate="yes" xml:space="preserve">
          <source>Single number: 3894</source>
          <target state="translated">Единый номер:3894</target>
        </trans-unit>
        <trans-unit id="f4a53209e61b36ab81faa5f943fba8e855032018" translate="yes" xml:space="preserve">
          <source>Skip sorting the elements</source>
          <target state="translated">Пропустить сортировку элементов</target>
        </trans-unit>
        <trans-unit id="8eab09bbd450823e91103eb2aaa19c7c3697409f" translate="yes" xml:space="preserve">
          <source>So for example the command &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; will return each item in the following way:</source>
          <target state="translated">Так, например, команда &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; вернет каждый элемент следующим образом:</target>
        </trans-unit>
        <trans-unit id="76d0f19de574ac1304a0b3b169f72caa92244d72" translate="yes" xml:space="preserve">
          <source>So for instance, to get all the elements from the higher ID to the lower ID one could use:</source>
          <target state="translated">Так,например,чтобы получить все элементы с более высокого ID на более низкий ID,можно было бы использовать:</target>
        </trans-unit>
        <trans-unit id="605cfa3fd340ae3e5e756672779740b80a689628" translate="yes" xml:space="preserve">
          <source>So in order for a given node to accept another one into the list of nodes composing a Redis Cluster, there are only two ways:</source>
          <target state="translated">Таким образом,для того,чтобы данный узел принял другой в список узлов,составляющих кластер Redis,есть только два способа:</target>
        </trans-unit>
        <trans-unit id="2350b72b46e64aeb370c2cbfa4c601de95c3d620" translate="yes" xml:space="preserve">
          <source>So we start with a list of keys, and later continue with all the associated IDs, representing &lt;em&gt;the last ID we received for that stream&lt;/em&gt;, so that the call will serve us only greater IDs from the same stream.</source>
          <target state="translated">Итак, мы начинаем со списка ключей, а затем продолжаем со всеми связанными идентификаторами, представляющими &lt;em&gt;последний идентификатор, который мы получили для этого потока&lt;/em&gt; , так что вызов будет обслуживать нам только большие идентификаторы из того же потока.</target>
        </trans-unit>
        <trans-unit id="46ddca2244f21f2b27c1eb6025f1e694d4b8bea0" translate="yes" xml:space="preserve">
          <source>So what the command really does is:</source>
          <target state="translated">Итак,что на самом деле делает команда:</target>
        </trans-unit>
        <trans-unit id="f434d4f52b4b99882f1b83c63bcdd004df128d69" translate="yes" xml:space="preserve">
          <source>So, if we link node A with node B via &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;, and B with C, A and C will find their ways to handshake and create a link.</source>
          <target state="translated">Итак, если мы свяжем узел A с узлом B через &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; , а B с C, A и C найдут свои способы рукопожатия и создания ссылки.</target>
        </trans-unit>
        <trans-unit id="60790236df4f5916ea98a7288f81aafe33a99ab5" translate="yes" xml:space="preserve">
          <source>So, using &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt;, when a new cluster is created, we can assign a different progressive configuration epoch to each node before joining the cluster together.</source>
          <target state="translated">Итак, с помощью &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt; , когда создается новый кластер, мы можем назначить разные эпохи прогрессивной конфигурации каждому узлу перед объединением кластера.</target>
        </trans-unit>
        <trans-unit id="f4318ce82f602a680da3fd3d1f1b92cbeae45d01" translate="yes" xml:space="preserve">
          <source>So, we want to say, give me the first element starting from the tail of the list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173217936882f8d5719c8defa86bf0d23eac51fe" translate="yes" xml:space="preserve">
          <source>Some Redis commands have no predetermined key locations. For those commands, flag &lt;code&gt;movablekeys&lt;/code&gt; is added to the command flags &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;. Your Redis Cluster client needs to parse commands marked &lt;code&gt;movablekeys&lt;/code&gt; to locate all relevant key positions.</source>
          <target state="translated">Некоторые команды Redis не имеют заранее определенного расположения клавиш. Для этих команд флаг &lt;code&gt;movablekeys&lt;/code&gt; добавлен в &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;ответ массива&lt;/a&gt; флагов команды . Вашему клиенту Redis Cluster необходимо проанализировать команды, помеченные как &lt;code&gt;movablekeys&lt;/code&gt; , чтобы найти все соответствующие ключевые позиции.</target>
        </trans-unit>
        <trans-unit id="ddceed7fe40007b57317ba7df983076bcd185123" translate="yes" xml:space="preserve">
          <source>Some consumer A reads a message via &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; from a stream, in the context of that consumer group.</source>
          <target state="translated">Некоторый потребитель A читает сообщение через &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; из потока в контексте этой группы потребителей.</target>
        </trans-unit>
        <trans-unit id="28d440075fc880e5ff5b66c8a65009bc3be5acfb" translate="yes" xml:space="preserve">
          <source>Sometimes it can be useful for clients to completely disable replies from the Redis server. For example when the client sends fire and forget commands or performs a mass loading of data, or in caching contexts where new data is streamed constantly. In such contexts to use server time and bandwidth in order to send back replies to clients, which are going to be ignored, is considered wasteful.</source>
          <target state="translated">Иногда клиентам может быть полезно полностью отключить ответы с сервера Redis.Например,когда клиент посылает пожар и забывает команды или выполняет массовую загрузку данных,или в контекстах кэширования,когда новые данные передаются постоянно.В таких контекстах использование времени и полосы пропускания сервера для обратной отправки клиентам ответов,которые будут игнорироваться,считается расточительным.</target>
        </trans-unit>
        <trans-unit id="a1fbf7ca3941093b616976378d4450adc4f2adb7" translate="yes" xml:space="preserve">
          <source>Sometimes it may be useful to remove old consumers since they are no longer used. This form returns the number of pending messages that the consumer had before it was deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="295b7c77aec21f1ec78f8bb6debbc23501dae53f" translate="yes" xml:space="preserve">
          <source>Sometimes we need just the length of the match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a212e08b7709fdef0e43a6ae14d5840bfa05846" translate="yes" xml:space="preserve">
          <source>Sometimes we want to return not just the Nth matching element, but the position of all the first N matching elements. This can be achieved using the &lt;code&gt;COUNT&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43292f17e4e5fce7b6e4920a4500928789cc3b9d" translate="yes" xml:space="preserve">
          <source>Sometimes you want to sort elements using external keys as weights to compare instead of comparing the actual elements in the list, set or sorted set. Let's say the list &lt;code&gt;mylist&lt;/code&gt; contains the elements &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; representing unique IDs of objects stored in &lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;. When these objects have associated weights stored in &lt;code&gt;weight_1&lt;/code&gt;, &lt;code&gt;weight_2&lt;/code&gt; and &lt;code&gt;weight_3&lt;/code&gt;, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; can be instructed to use these weights to sort &lt;code&gt;mylist&lt;/code&gt; with the following statement:</source>
          <target state="translated">Иногда вы хотите отсортировать элементы, используя внешние ключи в качестве весов для сравнения, вместо сравнения фактических элементов в списке, наборе или отсортированном наборе. Допустим, список &lt;code&gt;mylist&lt;/code&gt; содержит элементы &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; и &lt;code&gt;3&lt;/code&gt; , представляющие уникальные идентификаторы объектов, хранящихся в &lt;code&gt;object_1&lt;/code&gt; , &lt;code&gt;object_2&lt;/code&gt; и &lt;code&gt;object_3&lt;/code&gt; . Когда эти объекты имеют связанные веса, хранящиеся в &lt;code&gt;weight_1&lt;/code&gt; , &lt;code&gt;weight_2&lt;/code&gt; и &lt;code&gt;weight_3&lt;/code&gt; , &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; можно указать использовать эти веса для сортировки &lt;code&gt;mylist&lt;/code&gt; с помощью следующего оператора:</target>
        </trans-unit>
        <trans-unit id="b2397d818d7562914c5b062b54f97e833db314f2" translate="yes" xml:space="preserve">
          <source>Sorted Sets</source>
          <target state="translated">Сортированные наборы</target>
        </trans-unit>
        <trans-unit id="25ab5e6a0d5f2c9c6bc25d348c156dc61d5c8552" translate="yes" xml:space="preserve">
          <source>Sorted Sets can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;skiplist&lt;/code&gt; format. As for the List type small sorted sets can be specially encoded using &lt;code&gt;ziplist&lt;/code&gt;, while the &lt;code&gt;skiplist&lt;/code&gt; encoding is the one that works with sorted sets of any size.</source>
          <target state="translated">Сортированные наборы могут быть закодированы в &lt;code&gt;ziplist&lt;/code&gt; или &lt;code&gt;skiplist&lt;/code&gt; . Что касается типа списка, то небольшие отсортированные наборы могут быть специально закодированы с помощью &lt;code&gt;ziplist&lt;/code&gt; , а кодировка &lt;code&gt;skiplist&lt;/code&gt; - это та, которая работает с отсортированными наборами любого размера.</target>
        </trans-unit>
        <trans-unit id="86e387fe2a33fb39f76cfff98ea344b952f84a62" translate="yes" xml:space="preserve">
          <source>Sorted sets 101</source>
          <target state="translated">Сортированные наборы 101</target>
        </trans-unit>
        <trans-unit id="785f83ba9125723b72d2c573196ef8beabb345a8" translate="yes" xml:space="preserve">
          <source>Sorted sets are sorted by their score in an ascending way. The same element only exists a single time, no repeated elements are permitted. The score can be modified both by &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; that will update the element score, and as a side effect, its position on the sorted set, and by &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt; that can be used in order to update the score relatively to its previous value.</source>
          <target state="translated">Отсортированные наборы отсортированы по количеству очков в порядке возрастания. Один и тот же элемент существует только один раз, повторение элементов не допускается. Оценка может быть изменена как с помощью &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; , который обновит оценку элемента, так и в качестве побочного эффекта, его позиции в отсортированном наборе, а также с помощью &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY,&lt;/a&gt; который может использоваться для обновления оценки относительно ее предыдущего значения.</target>
        </trans-unit>
        <trans-unit id="2f2a07b6f7677455f1b32d657bbc8366bfa48bf3" translate="yes" xml:space="preserve">
          <source>Sorting by external keys</source>
          <target state="translated">Сортировка по внешним ключам</target>
        </trans-unit>
        <trans-unit id="614fb399b6728ae041f21780ab6202d98e11c79a" translate="yes" xml:space="preserve">
          <source>Special conditions not allowing the command execution</source>
          <target state="translated">Специальные условия,не допускающие выполнения команды</target>
        </trans-unit>
        <trans-unit id="0869a917cb9ab140bb00f5d52e7332ad6727fd9a" translate="yes" xml:space="preserve">
          <source>Special slot entries</source>
          <target state="translated">Специальные записи слотов</target>
        </trans-unit>
        <trans-unit id="549c2b56d95e908566338d2fd5914a21fd08d936" translate="yes" xml:space="preserve">
          <source>Specifically if a given write is transferred to one or more replicas, it is more likely (but not guaranteed) that if the master fails, we'll be able to promote, during a failover, a replica that received the write: both Sentinel and Redis Cluster will do a best-effort attempt to promote the best replica among the set of available replicas.</source>
          <target state="translated">В частности,если заданная запись переносится на одну или более копий,более вероятно (но не гарантированно),что в случае сбоя мастера,мы сможем продвигать,во время обхода отказа,копии,получившие запись:и Sentinel,и Redis Cluster сделают лучшую попытку продвинуть лучшую копию среди множества доступных реплик.</target>
        </trans-unit>
        <trans-unit id="d526406a65071e1fec15bd4174751e7a5bc387d7" translate="yes" xml:space="preserve">
          <source>Specifically this is what Redis does 10 times per second:</source>
          <target state="translated">В частности,это то,что Рэдис делает 10 раз в секунду:</target>
        </trans-unit>
        <trans-unit id="2fa9940f1d66c2c57fbda5e1ef12bce097cf18d3" translate="yes" xml:space="preserve">
          <source>Specifically, it lists the user's ACL flags, password hashes and key name patterns. Note that command rules are returned as a string in the same format used with the &lt;a href=&quot;acl-setuser&quot;&gt;ACL SETUSER&lt;/a&gt; command. This description of command rules reflects the user's effective permissions, so while it may not be identical to the set of rules used to configure the user, it is still functionally identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ff7d39e693899b2fb01c2af7e0b9aad8efd43b" translate="yes" xml:space="preserve">
          <source>Specifically:</source>
          <target state="translated">Specifically:</target>
        </trans-unit>
        <trans-unit id="37ec7d989573caff7ef9f45953dba8d022709000" translate="yes" xml:space="preserve">
          <source>Specification of the behavior when count is passed</source>
          <target state="translated">Спецификация поведения при подсчете</target>
        </trans-unit>
        <trans-unit id="14c30af049c8842dbcbd1159d5db60d5f0981029" translate="yes" xml:space="preserve">
          <source>Specifying a Stream ID as an argument</source>
          <target state="translated">Указание идентификатора потока в качестве аргумента</target>
        </trans-unit>
        <trans-unit id="1544a5bc78a2aee56854818668d14afd235ec6c9" translate="yes" xml:space="preserve">
          <source>Start slot range</source>
          <target state="translated">Диапазон стартовых слотов</target>
        </trans-unit>
        <trans-unit id="ee455845986f290115764586b0c8b62db6794d99" translate="yes" xml:space="preserve">
          <source>Starting from Redis version 2.6, when called with the additional &lt;code&gt;count&lt;/code&gt; argument, return an array of &lt;code&gt;count&lt;/code&gt;&lt;strong&gt;distinct elements&lt;/strong&gt; if &lt;code&gt;count&lt;/code&gt; is positive. If called with a negative &lt;code&gt;count&lt;/code&gt; the behavior changes and the command is allowed to return the &lt;strong&gt;same element multiple times&lt;/strong&gt;. In this case the number of returned elements is the absolute value of the specified &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">Начиная с Redis версии 2.6, при вызове с дополнительным &lt;code&gt;count&lt;/code&gt; аргументов, возвращает массив &lt;code&gt;count&lt;/code&gt; &lt;strong&gt;различных элементов&lt;/strong&gt; , если &lt;code&gt;count&lt;/code&gt; положителен. Если вызывается с отрицательным &lt;code&gt;count&lt;/code&gt; поведение меняется, и команде разрешается возвращать один и тот &lt;strong&gt;же элемент несколько раз&lt;/strong&gt; . В этом случае количество возвращаемых элементов является абсолютным значением указанного &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83f9c28598d952311fc09fa54e334ed57a68832b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.6.12 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; supports a set of options that modify its behavior:</source>
          <target state="translated">Начиная с Redis 2.6.12 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; поддерживает набор параметров, изменяющих его поведение:</target>
        </trans-unit>
        <trans-unit id="f154b597ac1178d82fc4c50afc3e83d654688468" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.8 the return value in case of error changed:</source>
          <target state="translated">Начиная с регистратора Redis 2.8 возвращаемое значение при ошибке изменяется:</target>
        </trans-unit>
        <trans-unit id="cb9c10a639cbbf2b71b38cd0e777ffb915ed4e8b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.0.6 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; supports a new bulk-migration mode that uses pipelining in order to migrate multiple keys between instances without incurring in the round trip time latency and other overheads that there are when moving each key with a single &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; call.</source>
          <target state="translated">Начиная с Redis 3.0.6, &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; поддерживает новый режим массовой миграции, который использует конвейерную обработку для переноса нескольких ключей между экземплярами без задержки времени &lt;a href=&quot;migrate&quot;&gt;приема-передачи&lt;/a&gt; и других накладных расходов, которые возникают при перемещении каждого ключа с помощью одного вызова MIGRATE .</target>
        </trans-unit>
        <trans-unit id="6578980d36f8246047edd57af78a6f9934454cea" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, Redis has support for native Lua debugging. The Redis Lua debugger is a remote debugger consisting of a server, which is Redis itself, and a client, which is by default &lt;code&gt;redis-cli&lt;/code&gt;.</source>
          <target state="translated">Начиная с Redis 3.2, Redis поддерживает встроенную отладку Lua. Отладчик Redis Lua - это удаленный отладчик, состоящий из сервера, которым является сам Redis, и клиента, которым по умолчанию является &lt;code&gt;redis-cli&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b01b9bd2a097f98e87d6033b411073bab6691f7" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, it is possible to select an alternative replication method. Instead of replication whole scripts, we can just replicate single write commands generated by the script. We call this &lt;strong&gt;script effects replication&lt;/strong&gt;.</source>
          <target state="translated">Начиная с Redis 3.2, есть возможность выбрать альтернативный метод репликации. Вместо репликации целых сценариев мы можем просто реплицировать отдельные команды записи, созданные сценарием. Мы называем этот &lt;strong&gt;сценарий репликацией эффектов&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2b5108a4d347209131d9cdaa00d48ad36bea64af" translate="yes" xml:space="preserve">
          <source>Starting with Redis version 6, the server supports two different protocols. One is called RESP2, and is the old protocol: all the new connections to the server start in this mode. However clients are able to negotiate the new protocol using the &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command: this way the connection is put in RESP3 mode. In this mode certain commands, like for instance &lt;a href=&quot;hgetall&quot;&gt;HGETALL&lt;/a&gt;, reply with a new data type (the Map data type in this specific case). The RESP3 protocol is semantically more powerful, however most scripts are OK with using just RESP2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ffd355623442762e32037427cffdb34a18e3984" translate="yes" xml:space="preserve">
          <source>Step 4 does not technically need to use &lt;code&gt;SETSLOT&lt;/code&gt; in the nodes not involved in the resharding, since the configuration will eventually propagate itself, however it is a good idea to do so in order to stop nodes from pointing to the wrong node for the hash slot moved as soon as possible, resulting in less redirections to find the right node.</source>
          <target state="translated">На шаге 4 технически нет необходимости использовать &lt;code&gt;SETSLOT&lt;/code&gt; на узлах, не участвующих в перешардинге, поскольку конфигурация в конечном итоге будет распространяться сама, однако это хорошая идея, чтобы не дать узлам указывать на неправильный узел для хэш-слота. перемещен как можно скорее, что приведет к меньшему количеству перенаправлений для поиска нужного узла.</target>
        </trans-unit>
        <trans-unit id="f75b76768d708a29fc0fb9becaf181931853bd99" translate="yes" xml:space="preserve">
          <source>Step Count</source>
          <target state="translated">Счетчик шагов</target>
        </trans-unit>
        <trans-unit id="f7fa846d5511789adfec64aa9b8751f7351a0ca5" translate="yes" xml:space="preserve">
          <source>Stop all the clients.</source>
          <target state="translated">Остановите всех клиентов.</target>
        </trans-unit>
        <trans-unit id="6cb759f69a54fcb63d47af649e368c12075f71be" translate="yes" xml:space="preserve">
          <source>Storing the result of a SORT operation</source>
          <target state="translated">Хранение результата операции SORT</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="61c2b2148d7f362f23210527dbc1bd6b0437b131" translate="yes" xml:space="preserve">
          <source>Stream IDs are composed of two parts, a Unix millisecond time stamp and a sequence number for entries inserted in the same millisecond. It is possible to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; specifying just the first part of the ID, the millisecond time, like in the following example:</source>
          <target state="translated">Идентификаторы потока состоят из двух частей: отметки времени миллисекунды Unix и порядкового номера для записей, вставленных в одну и ту же миллисекунду. Можно использовать &lt;a href=&quot;xrange&quot;&gt;XRANGE,&lt;/a&gt; указав только первую часть идентификатора, миллисекунду, как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="e577b53fb1794580c0560fa9502cf28744dcd504" translate="yes" xml:space="preserve">
          <source>Stream entries are returned, including fields and values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e700aeb9d8c3a456c6730300f1abde75268288" translate="yes" xml:space="preserve">
          <source>Streams are not auto-deleted once they have no entries inside (for instance after an &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; call), because the stream may have consumer groups associated with it.</source>
          <target state="translated">Потоки не удаляются автоматически, если внутри них нет записей (например, после вызова &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; ), поскольку с потоком могут быть связаны группы потребителей.</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="48c2711e04347f7b6d1ddd6b4a79296a8d2830ea" translate="yes" xml:space="preserve">
          <source>Strings are compared as binary array of bytes. Because of how the ASCII character set is specified, this means that usually this also have the effect of comparing normal ASCII characters in an obvious dictionary way. However this is not true if non plain ASCII strings are used (for example utf8 strings).</source>
          <target state="translated">Строки сравниваются как двоичный массив байт.Из-за того,как указан набор ASCII-символов,это означает,что обычно это также влияет на сравнение обычных ASCII-символов в очевидном словарном смысле.Однако это не так,если используются не простые ASCII-символы (например,строки utf8).</target>
        </trans-unit>
        <trans-unit id="2593368d27635cc5293b7e53f7145a56dff05dd8" translate="yes" xml:space="preserve">
          <source>Strings can be encoded as &lt;code&gt;raw&lt;/code&gt; (normal string encoding) or &lt;code&gt;int&lt;/code&gt; (strings representing integers in a 64 bit signed interval are encoded in this way in order to save space).</source>
          <target state="translated">Строки могут быть закодированы как &lt;code&gt;raw&lt;/code&gt; (нормальная кодировка строк) или &lt;code&gt;int&lt;/code&gt; (строки, представляющие целые числа в 64-битном интервале со знаком, кодируются таким образом для экономии места).</target>
        </trans-unit>
        <trans-unit id="d5294ece475c0dd1b0e5c4f6f621c1e0c0bf7039" translate="yes" xml:space="preserve">
          <source>Strings with a similar prefix are nearby, but the contrary is not true, it is possible that strings with different prefixes are nearby too.</source>
          <target state="translated">Строки с похожим префиксом находятся поблизости,но это не так,возможно,что строки с разными префиксами тоже находятся поблизости.</target>
        </trans-unit>
        <trans-unit id="3f9d46e5fb83a7700b4c788a03b12a80a7e61e08" translate="yes" xml:space="preserve">
          <source>Subcommand &lt;code&gt;encoding&lt;/code&gt; returns a bulk reply.</source>
          <target state="translated">&lt;code&gt;encoding&lt;/code&gt; подкоманды возвращает массовый ответ.</target>
        </trans-unit>
        <trans-unit id="03e52fefcd721e1070e1756817dc5fb3908630a4" translate="yes" xml:space="preserve">
          <source>Subcommands &lt;code&gt;refcount&lt;/code&gt; and &lt;code&gt;idletime&lt;/code&gt; return integers.</source>
          <target state="translated">Подкоманды &lt;code&gt;refcount&lt;/code&gt; и &lt;code&gt;idletime&lt;/code&gt; возвращают целые числа.</target>
        </trans-unit>
        <trans-unit id="9cdf88a718c3f491225fa1cc2fd76602c7208ad1" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the given patterns.</source>
          <target state="translated">Подписывает клиента на данные шаблоны.</target>
        </trans-unit>
        <trans-unit id="481c5cf231fde7f8730860922d6f3194fc5f2170" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the specified channels.</source>
          <target state="translated">Подписывает клиента на указанные каналы.</target>
        </trans-unit>
        <trans-unit id="4a47fd9934d349f948abbf361726590ff096c6b8" translate="yes" xml:space="preserve">
          <source>Summary form of XPENDING</source>
          <target state="translated">Краткая форма XPENDING</target>
        </trans-unit>
        <trans-unit id="dfe7ee6f8d575326187ecdb8ea7e6fb7cbf4ec35" translate="yes" xml:space="preserve">
          <source>Supported glob-style patterns:</source>
          <target state="translated">Поддерживаемые узоры в стиле глобуса:</target>
        </trans-unit>
        <trans-unit id="ced890cac00d712740bdc4d39c1db48f7483c499" translate="yes" xml:space="preserve">
          <source>Supported subcommands and integer types</source>
          <target state="translated">Поддерживаемые подкоманды и целочисленные типы</target>
        </trans-unit>
        <trans-unit id="108e22a5749de8f07b0272d8029eeb2811ea28dd" translate="yes" xml:space="preserve">
          <source>Switch the connection to a different protocol. Redis version 6 or greater are able to support two protocols, the old protocol, RESP2, and a new one introduced with Redis 6, RESP3. RESP3 has certain advantages since when the connection is in this mode, Redis is able to reply with more semantical replies: for instance &lt;a href=&quot;hgetall&quot;&gt;HGETALL&lt;/a&gt; will return a &lt;em&gt;map type&lt;/em&gt;, so a client library implementation no longer requires to know in advance to translate the array into a hash before returning it to the caller. For a full coverage of RESP3 please &lt;a href=&quot;https://github.com/antirez/resp3&quot;&gt;check this repository&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8398e47e81dab008569a234703960eb8bab2f11" translate="yes" xml:space="preserve">
          <source>TAKEOVER option: manual failover without cluster consensus</source>
          <target state="translated">Опция TAKEOVER:ручное преодоление отказа без достижения консенсуса по кластерам</target>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="8696f7a4c64b4516c2d96434e8b7824957a37d2a" translate="yes" xml:space="preserve">
          <source>TIME   Return the current server time</source>
          <target state="translated">ВРЕМЯ Возврат текущего времени сервера</target>
        </trans-unit>
        <trans-unit id="c701f5f92060225c236ac0e6b3051e03bb0ad061" translate="yes" xml:space="preserve">
          <source>TOUCH</source>
          <target state="translated">TOUCH</target>
        </trans-unit>
        <trans-unit id="ad5ae533c502772151a704d28a2bece0e0f4ca1b" translate="yes" xml:space="preserve">
          <source>TOUCH  key [key ...]   Alters the last access time of a key(s). Returns the number of existing keys specified.</source>
          <target state="translated">TOUCH ключ [ключ ...]Изменяет последнее время доступа к ключу(ам).Возвращает указанное количество существующих ключей.</target>
        </trans-unit>
        <trans-unit id="878260dfb888c3312c119e6db2253c2aa207ae98" translate="yes" xml:space="preserve">
          <source>TTL</source>
          <target state="translated">TTL</target>
        </trans-unit>
        <trans-unit id="8ef7742bd419d3406904eb9723c6ce85d49c0f81" translate="yes" xml:space="preserve">
          <source>TTL  key   Get the time to live for a key</source>
          <target state="translated">TTL ключ Получить время жить для ключа</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="7d0cfb250d49bba162e019907ea71cfcab32d9f4" translate="yes" xml:space="preserve">
          <source>TYPE  key   Determine the type stored at key</source>
          <target state="translated">Клавиша TYPE Определите тип,сохраненный в клавиатуре.</target>
        </trans-unit>
        <trans-unit id="5bbc08d2de04a7034dc9edbe2e20759367a5f82f" translate="yes" xml:space="preserve">
          <source>Taking a separated key that is incremented every time the bitmap is modified. This can be very efficient and atomic using a small Redis Lua script.</source>
          <target state="translated">Взятие отдельного ключа,который инкрементируется каждый раз при изменении растровой карты.Это может быть очень эффективно и атомарно при использовании небольшого скрипта Redis Lua.</target>
        </trans-unit>
        <trans-unit id="8b5d4fb8b75675d300f4de7425675abc3149473f" translate="yes" xml:space="preserve">
          <source>Terminating iterations in the middle</source>
          <target state="translated">Прекращение итераций в середине</target>
        </trans-unit>
        <trans-unit id="8a78f0cb0822107a63b906522f8970fb02d3906a" translate="yes" xml:space="preserve">
          <source>Test 20 random keys from the set of keys with an associated expire.</source>
          <target state="translated">Проверьте 20 случайных ключей из набора ключей с ассоциированным истечением срока годности.</target>
        </trans-unit>
        <trans-unit id="0c0c5f66ed89ad8b7f73f25128b137a4d67fcbb8" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; and the analogous &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; commands, you can use Redis strings as a linear array with O(1) random access. This is a very fast and efficient storage in many real world use cases.</source>
          <target state="translated">Благодаря &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; и аналогичным командам &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; вы можете использовать строки Redis как линейный массив с произвольным доступом O (1). Это очень быстрое и эффективное хранилище во многих реальных случаях использования.</target>
        </trans-unit>
        <trans-unit id="8026b8ed5921c819cac7c44288be64954a1b0af5" translate="yes" xml:space="preserve">
          <source>That is, the second occurrence of &quot;c&quot; is at position 6. A negative &quot;rank&quot; as the &lt;code&gt;RANK&lt;/code&gt; argument tells &lt;a href=&quot;lpos&quot;&gt;LPOS&lt;/a&gt; to invert the search direction, starting from the tail to the head.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733be8ce43bb740e68f58527c40732d288c9eb0b" translate="yes" xml:space="preserve">
          <source>That said, &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; can be used, and was historically used, as a locking primitive. For example, to acquire the lock of the key &lt;code&gt;foo&lt;/code&gt;, the client could try the following:</source>
          <target state="translated">Тем не менее, &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; может использоваться и исторически использовался как блокирующий примитив. Например, чтобы получить блокировку ключа &lt;code&gt;foo&lt;/code&gt; , клиент может попробовать следующее:</target>
        </trans-unit>
        <trans-unit id="b0aa14a2afe89147b651f01c25f18c35b9adb8d8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;acl-help&quot;&gt;ACL HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d6d135447dbf512e1ae2af8102405447c9f874" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; command can be used to create a very compact representation of a list of fixed-size samples, usually referred as &lt;em&gt;time series&lt;/em&gt;. Every time a new sample arrives we can store it using the command</source>
          <target state="translated">&lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; команда может быть использована для создания очень компактного представления списка образцов фиксированного размера, обычно называют &lt;em&gt;время серии&lt;/em&gt; . Каждый раз, когда приходит новый образец, мы можем сохранить его, используя команду</target>
        </trans-unit>
        <trans-unit id="af3680004f1f3af89a74cfdd597524f1d5b57aa0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; command supports four bitwise operations: &lt;strong&gt;AND&lt;/strong&gt;, &lt;strong&gt;OR&lt;/strong&gt;, &lt;strong&gt;XOR&lt;/strong&gt; and &lt;strong&gt;NOT&lt;/strong&gt;, thus the valid forms to call the command are:</source>
          <target state="translated">Команда &lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; поддерживает четыре побитовых операции: &lt;strong&gt;AND&lt;/strong&gt; , &lt;strong&gt;OR&lt;/strong&gt; , &lt;strong&gt;XOR&lt;/strong&gt; и &lt;strong&gt;NOT&lt;/strong&gt; , поэтому допустимые формы для вызова команды:</target>
        </trans-unit>
        <trans-unit id="4dd66d959585425a19858f722e901be8748f987c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt; returns the name of the current connection as set by &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;. Since every new connection starts without an associated name, if no name was assigned a null bulk reply is returned.</source>
          <target state="translated">&lt;a href=&quot;client-getname&quot;&gt;КЛИЕНТ GetName&lt;/a&gt; возвращает имя текущего соединения , как установлено &lt;a href=&quot;client-setname&quot;&gt;КЛИЕНТА SetName&lt;/a&gt; . Поскольку каждое новое соединение начинается без связанного имени, если имя не было назначено, возвращается нулевой массовый ответ.</target>
        </trans-unit>
        <trans-unit id="1660d56ff9988d9b97b8e4b556121bfa1958f2dd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; command closes a given client connection. This command support two formats, the old format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77571e239b6c4924e5ae8625b133ece1b2fb165b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; command closes a given client connection. Up to Redis 2.8.11 it was possible to close a connection only by client address, using the following form:</source>
          <target state="translated">Команда &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; закрывает заданное клиентское соединение. До Redis 2.8.11 можно было закрыть соединение только по адресу клиента, используя следующую форму:</target>
        </trans-unit>
        <trans-unit id="c0d7e72efd1901513aa26d76fc6efa880b0ffcd7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command returns information and statistics about the client connections server in a mostly human readable format.</source>
          <target state="translated">Команда &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; возвращает информацию и статистику о сервере клиентских подключений в удобочитаемом формате.</target>
        </trans-unit>
        <trans-unit id="99ea497bab9ec2eb991df932e164aeadc0d98009" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-reply&quot;&gt;CLIENT REPLY&lt;/a&gt; command controls whether the server will reply the client's commands. The following modes are available:</source>
          <target state="translated">Команда &lt;a href=&quot;client-reply&quot;&gt;CLIENT REPLY&lt;/a&gt; определяет, будет ли сервер отвечать на команды клиента. Доступны следующие режимы:</target>
        </trans-unit>
        <trans-unit id="66ef05bc81ce96b58454a695580464830edc9445" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; command assigns a name to the current connection.</source>
          <target state="translated">Команда &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; присваивает имя текущему соединению.</target>
        </trans-unit>
        <trans-unit id="43f3ab9bcc1ea0150ec08bf3548ed1a84c95f9e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-bumpepoch&quot;&gt;CLUSTER BUMPEPOCH&lt;/a&gt; command triggers an increment to the cluster's config epoch from the connected node. The epoch will be incremented if the node's config epoch is zero, or if it is less than the cluster's greatest epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5540561e37398d0ed7b865d91ceff7a71f6377" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-flushslots&quot;&gt;CLUSTER FLUSHSLOTS&lt;/a&gt; deletes all information about slots from the connected node. It can only be called when the database is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca5f595e917e610d79a666d6599f3f325569dcf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-myid&quot;&gt;CLUSTER MYID&lt;/a&gt; command returns the unique, auto-generated identifier that is associated with the connected cluster node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ca3ac0a9d2f6b99b3b3cfed122170d73c27a26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; command is an important piece used by Redis Cluster in order to migrate all the keys contained in one hash slot from one node to another. This is how the migration is orchestrated, with the help of other commands as well. We'll call the node that has the current ownership of the hash slot the &lt;code&gt;source&lt;/code&gt; node, and the node where we want to migrate the &lt;code&gt;destination&lt;/code&gt; node.</source>
          <target state="translated">Команда &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; - важная часть, используемая Redis Cluster для переноса всех ключей, содержащихся в одном хэш-слоте, с одного узла на другой. Таким образом осуществляется миграция с помощью других команд. Мы назовем узел, который в настоящее время владеет хэш-слотом, &lt;code&gt;source&lt;/code&gt; узлом, а узел, на который мы хотим перенести узел &lt;code&gt;destination&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9969254dbf9ad62d16ce54578a579c12bed90714" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; command is used to read the configuration parameters of a running Redis server. Not all the configuration parameters are supported in Redis 2.4, while Redis 2.6 can read the whole configuration of a server using this command.</source>
          <target state="translated">Команда &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; используется для чтения параметров конфигурации работающего сервера Redis. Не все параметры конфигурации поддерживаются в Redis 2.4, в то время как Redis 2.6 может прочитать всю конфигурацию сервера с помощью этой команды.</target>
        </trans-unit>
        <trans-unit id="b44e010365af8a822e0e64c895b3b9356396e69b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITE&lt;/a&gt; command rewrites the &lt;code&gt;redis.conf&lt;/code&gt; file the server was started with, applying the minimal changes needed to make it reflect the configuration currently used by the server, which may be different compared to the original one because of the use of the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command.</source>
          <target state="translated">Команда &lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITE&lt;/a&gt; перезаписывает файл &lt;code&gt;redis.conf&lt;/code&gt; , с которого был запущен сервер, применяя минимальные изменения, необходимые для того, чтобы он отражал текущую конфигурацию, используемую сервером, которая может отличаться от исходной из-за использования &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; команда.</target>
        </trans-unit>
        <trans-unit id="a94ff0d50f7b4db45f039a4dafafa3f4c9259a89" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command is used in order to reconfigure the server at run time without the need to restart Redis. You can change both trivial parameters or switch from one to another persistence option using this command.</source>
          <target state="translated">Команда &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; используется для перенастройки сервера во время выполнения без необходимости перезапуска Redis. Вы можете изменить оба тривиальных параметра или переключиться с одного параметра сохранения на другой с помощью этой команды.</target>
        </trans-unit>
        <trans-unit id="166c68e394d8ab06f1a3bb76f56f32a612a6683d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command forces you to send the script body again and again. Redis does not need to recompile the script every time as it uses an internal caching mechanism, however paying the cost of the additional bandwidth may not be optimal in many contexts.</source>
          <target state="translated">Команда &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; заставляет вас снова и снова отправлять тело скрипта. Redis не нужно перекомпилировать скрипт каждый раз, так как он использует внутренний механизм кэширования, однако оплата дополнительной полосы пропускания может быть неоптимальной во многих контекстах.</target>
        </trans-unit>
        <trans-unit id="bd6411fae08a91e9b321232ed876a3d9070cad9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; family of commands is able to associate an expire to a given key, at the cost of some additional memory used by the key. When a key has an expire set, Redis will make sure to remove the key when the specified amount of time elapsed.</source>
          <target state="translated">&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; семейство команд может связать истекают к данному ключу, за счет некоторой дополнительной памяти , используемой ключом. Если для ключа установлен срок действия, Redis обязательно удалит ключ по истечении указанного времени.</target>
        </trans-unit>
        <trans-unit id="9537af381c721635428a198bca98f65d00f50bfa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command has a useful reply that will state a number of facts about the server: the exact version, the set of modules loaded, the client ID, the replication role and so forth. Because of that, and given that the &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command also works with &quot;2&quot; as argument, both in order to downgrade the protocol back to version 2, or just to get the reply from the server without switching the protocol, client library authors may consider using this command instead of the canonical &lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt; when setting up the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae44c019fde6841c16a68c04d38047f2e0f60739" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command returns information and statistics about the server in a format that is simple to parse by computers and easy to read by humans.</source>
          <target state="translated">Команда &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; возвращает информацию и статистику о сервере в формате, который легко анализируется компьютерами и легко читается людьми.</target>
        </trans-unit>
        <trans-unit id="a72bec6083e79854302b4e9ff14a0e8f3e859562" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-doctor&quot;&gt;LATENCY DOCTOR&lt;/a&gt; command reports about different latency-related issues and advises about possible remedies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1066b09a9b25b6b6ed879ca10e517428a219419a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-help&quot;&gt;LATENCY HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50807ff2bf2c847fd5988e426fdf8c05c9a36546" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-history&quot;&gt;LATENCY HISTORY&lt;/a&gt; command returns the raw data of the &lt;code&gt;event&lt;/code&gt;'s latency spikes time series.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c78093ad61fe69ebb2499c714e0f2256697635" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-latest&quot;&gt;LATENCY LATEST&lt;/a&gt; command reports the latest latency events logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147880a1d1ea91581373c0559cd3dfedfc864e5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-reset&quot;&gt;LATENCY RESET&lt;/a&gt; command resets the latency spikes time series of all, or only some, events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c3a5fba12b1ed2508a72f81c29ed6c56b41d88" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt; command reports about different memory-related issues that the Redis server experiences, and advises about possible remedies.</source>
          <target state="translated">Команда &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt; сообщает о различных проблемах, связанных с памятью, с которыми сталкивается сервер Redis, и дает советы о возможных решениях.</target>
        </trans-unit>
        <trans-unit id="09f518db007c555b3fc51849cb715d5f37978149" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-help&quot;&gt;MEMORY HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="translated">Команда &lt;a href=&quot;memory-help&quot;&gt;MEMORY HELP&lt;/a&gt; возвращает полезный текст, описывающий различные подкоманды.</target>
        </trans-unit>
        <trans-unit id="ff16e624359e33f1f97dfa1a1d20188c59460b7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-malloc-stats&quot;&gt;MEMORY MALLOC-STATS&lt;/a&gt; command provides an internal statistics report from the memory allocator.</source>
          <target state="translated">Команда &lt;a href=&quot;memory-malloc-stats&quot;&gt;MEMORY MALLOC-STATS&lt;/a&gt; предоставляет отчет внутренней статистики от распределителя памяти.</target>
        </trans-unit>
        <trans-unit id="abed28f03c444a07fa9a013ee06dd6217f071068" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-purge&quot;&gt;MEMORY PURGE&lt;/a&gt; command attempts to purge dirty pages so these can be reclaimed by the allocator.</source>
          <target state="translated">Команда &lt;a href=&quot;memory-purge&quot;&gt;MEMORY PURGE&lt;/a&gt; пытается очистить грязные страницы, чтобы они могли быть восстановлены распределителем.</target>
        </trans-unit>
        <trans-unit id="6661981989e0edd2ff7e2bf5fdb3e79066d8b8f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-stats&quot;&gt;MEMORY STATS&lt;/a&gt; command returns an &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; about the memory usage of the server.</source>
          <target state="translated">Команда &lt;a href=&quot;memory-stats&quot;&gt;MEMORY STATS&lt;/a&gt; возвращает &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;массивный ответ&lt;/a&gt; об использовании памяти сервером.</target>
        </trans-unit>
        <trans-unit id="753fff2843cf4f675766fb16f94fa6b171989202" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-usage&quot;&gt;MEMORY USAGE&lt;/a&gt; command reports the number of bytes that a key and its value require to be stored in RAM.</source>
          <target state="translated">Команда &lt;a href=&quot;memory-usage&quot;&gt;MEMORY USAGE&lt;/a&gt; сообщает о количестве байтов, которое ключ и его значение требуют для хранения в ОЗУ.</target>
        </trans-unit>
        <trans-unit id="2af70a6f2971f44c0c1aa28591f8b6524acbcca6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command allows to inspect the internals of Redis Objects associated with keys. It is useful for debugging or to understand if your keys are using the specially encoded data types to save space. Your application may also use the information reported by the &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command to implement application level key eviction policies when using Redis as a Cache.</source>
          <target state="translated">Команда &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; позволяет проверять внутреннюю структуру объектов Redis, связанных с ключами. Это полезно для отладки или для понимания того, используют ли ваши ключи специально закодированные типы данных для экономии места. Ваше приложение может также использовать информацию, сообщаемую командой &lt;a href=&quot;object&quot;&gt;OBJECT,&lt;/a&gt; для реализации политик удаления ключей на уровне приложения при использовании Redis в качестве кэша.</target>
        </trans-unit>
        <trans-unit id="eea48beebb7220fe5ecc2f8e71ddc8ce2e90d62c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command supports multiple sub commands:</source>
          <target state="translated">Команда &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; поддерживает несколько подкоманд:</target>
        </trans-unit>
        <trans-unit id="ca3cc9ef5973b2b3ef21bdff9c9e13b41c03044f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;psync&quot;&gt;PSYNC&lt;/a&gt; command is called by Redis replicas for initiating a replication stream from the master.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc73cb913e243c94705a7071cd05dd7f69ae35a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; command can change the replication settings of a replica on the fly.</source>
          <target state="translated">Команда &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; может изменять настройки репликации реплики на лету.</target>
        </trans-unit>
        <trans-unit id="4ce9249bde2a45fd1e0f497151a2d69b16bbda13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rpushx&quot;&gt;RPUSHX&lt;/a&gt; command only pushes the element if the key already exists.</source>
          <target state="translated">Команда &lt;a href=&quot;rpushx&quot;&gt;RPUSHX&lt;/a&gt; подталкивает элемент, только если ключ уже существует.</target>
        </trans-unit>
        <trans-unit id="614a32f854070cdcbbba350287fb7c58ac067da4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; commands performs a &lt;strong&gt;synchronous&lt;/strong&gt; save of the dataset producing a &lt;em&gt;point in time&lt;/em&gt; snapshot of all the data inside the Redis instance, in the form of an RDB file.</source>
          <target state="translated">&lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; команда выполняет &lt;strong&gt;синхронное&lt;/strong&gt; сохранение набора данных , производящий &lt;em&gt;момент время&lt;/em&gt; снимок всех данных внутри экземпляра Redis, в виде файла RDB.</target>
        </trans-unit>
        <trans-unit id="67466c1875af0bcc544ed2934fa216ebaf0fb8ec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; algorithm is guaranteed to terminate only if the size of the iterated collection remains bounded to a given maximum size, otherwise iterating a collection that always grows may result into &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; to never terminate a full iteration.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;СКАН&lt;/a&gt; алгоритм гарантированно прекратить , только если размер итерированных остатков коллекции ограниченных к заданному максимальному размеру, в противном случае итерации коллекции , которая всегда растет , может привести к &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; , чтобы не завершать полные итерации.</target>
        </trans-unit>
        <trans-unit id="9b83fdceccccced73f803ea3fe0587ccedbc5d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command and the closely related commands &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; are used in order to incrementally iterate over a collection of elements.</source>
          <target state="translated">Команда &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; и тесно связанные команды &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; и &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; используются для пошагового итерации по набору элементов.</target>
        </trans-unit>
        <trans-unit id="debbeaf11369c9e161ae3c316731408d752cc02f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command, and the other commands in the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family, are able to provide to the user a set of guarantees associated to full iterations.</source>
          <target state="translated">Команда &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; и другие команды семейства &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; могут предоставить пользователю набор гарантий, связанных с полными итерациями.</target>
        </trans-unit>
        <trans-unit id="1745a85b233cd9864512e1af6c727c0eb8686c05" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command supports a set of options that modify its behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8bb1ffaa9cf08918dd7437412b9271325c4076a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; command can change the replication settings of a replica on the fly. If a Redis server is already acting as replica, the command &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE will turn off the replication, turning the Redis server into a MASTER. In the proper form &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port will make the server a replica of another server listening at the specified hostname and port.</source>
          <target state="translated">Команда &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; может изменять настройки репликации реплики на лету. Если сервер Redis уже действует как реплика, команда &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE отключит репликацию, превратив сервер Redis в ГЛАВНЫЙ. В правильной форме порт &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname сделает сервер репликой другого сервера, прослушивающего указанное имя хоста и порт.</target>
        </trans-unit>
        <trans-unit id="0ff4cdfae050eccc9a56820c72e2716bcf7a7f22" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sync&quot;&gt;SYNC&lt;/a&gt; command is called by Redis replicas for initiating a replication stream from the master. It has been replaced in newer versions of Redis by &lt;a href=&quot;psync&quot;&gt;PSYNC&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3e1b27429bbc884368294b8f7962375860257e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; command returns the current server time as a two items lists: a Unix timestamp and the amount of microseconds already elapsed in the current second. Basically the interface is very similar to the one of the &lt;code&gt;gettimeofday&lt;/code&gt; system call.</source>
          <target state="translated">Команда &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; возвращает текущее серверное время в виде двух списков элементов: метки времени Unix и количества микросекунд, уже прошедших в текущей секунде. В основном интерфейс очень похож на &lt;code&gt;gettimeofday&lt;/code&gt; системного вызова gettimeofday .</target>
        </trans-unit>
        <trans-unit id="70be0ca493bf011ad2206bbde68c46ec552ad130" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command removes one or multiple messages from the &lt;em&gt;pending entries list&lt;/em&gt; (PEL) of a stream consumer group. A message is pending, and as such stored inside the PEL, when it was delivered to some consumer, normally as a side effect of calling &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;, or when a consumer took ownership of a message calling &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;. The pending message was delivered to some consumer but the server is yet not sure it was processed at least once. So new calls to &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; to grab the messages history for a consumer (for instance using an ID of 0), will return such message. Similarly the pending message will be listed by the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command, that inspects the PEL.</source>
          <target state="translated">Команда &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; удаляет одно или несколько сообщений из &lt;em&gt;списка ожидающих записей&lt;/em&gt; (PEL) группы потребителей потока. Сообщение ожидает обработки и как таковое хранится в PEL, когда оно было доставлено какому-либо потребителю, обычно как побочный эффект вызова &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; , или когда потребитель стал владельцем сообщения, вызывающего &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; . Ожидающее сообщение было доставлено какому-то потребителю, но сервер еще не уверен, что оно было обработано хотя бы один раз. Таким образом, новые вызовы &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; для получения истории сообщений для потребителя (например, с использованием идентификатора 0) вернут такое сообщение. Точно так же ожидающее сообщение будет указано командой &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; , которая проверяет PEL.</target>
        </trans-unit>
        <trans-unit id="7dd37542831e217f80423791c1758b898b47cbcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command allows iterating over the pending entries just like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; and &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; allow for the stream's entries. You can do this by prefixing the ID of the last-read pending entry with the &lt;code&gt;(&lt;/code&gt; character that denotes an open (exclusive) range, and proving it to the subsequent call to the command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f919fa1bdb0a477435ee790e9628136dda8f63ea" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command is the interface to inspect the list of pending messages, and is as thus a very important command in order to observe and understand what is happening with a streams consumer groups: what clients are active, what messages are pending to be consumed, or to see if there are idle messages. Moreover this command, together with &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; is used in order to implement recovering of consumers that are failing for a long time, and as a result certain messages are not processed: a different consumer can claim the message and continue. This is better explained in the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;streams intro&lt;/a&gt; and in the &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; command page, and is not covered here.</source>
          <target state="translated">Команда &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; - это интерфейс для проверки списка ожидающих сообщений, и поэтому она является очень важной командой для наблюдения и понимания того, что происходит с группами потребителей потоков: какие клиенты активны, какие сообщения ожидают обработки, или чтобы увидеть, есть ли свободные сообщения. Более того, эта команда вместе с &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; используется для реализации восстановления потребителей, которые терпят неудачу в течение длительного времени, и в результате определенные сообщения не обрабатываются: другой потребитель может запросить сообщение и продолжить. Это лучше объясняется во &lt;a href=&quot;xclaim&quot;&gt;введении&lt;/a&gt; к &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;потокам&lt;/a&gt; и на странице команд XCLAIM и здесь не рассматривается.</target>
        </trans-unit>
        <trans-unit id="be7aa14ec80fad3a57ca56d203c2ac6e1198edd2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; command has a number of applications:</source>
          <target state="translated">Команда &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; имеет ряд применений:</target>
        </trans-unit>
        <trans-unit id="1033731d720ba1e5c57d34f9f982462de081667c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command is a special version of the &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; command with support for consumer groups. Probably you will have to understand the &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; command before reading this page will makes sense.</source>
          <target state="translated">Команда &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; - это специальная версия команды &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; с поддержкой групп потребителей. Вероятно, вам нужно будет понять команду &lt;a href=&quot;xread&quot;&gt;XREAD,&lt;/a&gt; прежде чем чтение этой страницы будет иметь смысл.</target>
        </trans-unit>
        <trans-unit id="7ac305f70170c901011610af97e0bc42f712f0a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; ID is effectively just exactly as specifying &lt;code&gt;0-0&lt;/code&gt;, while &lt;code&gt;+&lt;/code&gt; is equivalent to &lt;code&gt;18446744073709551615-18446744073709551615&lt;/code&gt;, however they are nicer to type.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; ID эффективно только точно как задание &lt;code&gt;0-0&lt;/code&gt; , в то время как &lt;code&gt;+&lt;/code&gt; эквивалентно &lt;code&gt;18446744073709551615-18446744073709551615&lt;/code&gt; , однако они лучше печатать.</target>
        </trans-unit>
        <trans-unit id="ad556b3da4050d845b9c3a874361828db5c442a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; special IDs mean respectively the minimum ID possible and the maximum ID possible inside a stream, so the following command will just return every entry in the stream:</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; и &lt;code&gt;+&lt;/code&gt; специальные идентификаторы означают соответственно минимальный идентификатор возможного и максимально возможный идентификатор внутри потока, так что следующая команда будет просто возвращать каждую запись в потоке:</target>
        </trans-unit>
        <trans-unit id="7b7c72e7ac11e971e25ca474ee3da37e97621a8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BY&lt;/code&gt; option can also take a non-existent key, which causes &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; to skip the sorting operation. This is useful if you want to retrieve external keys (see the &lt;code&gt;GET&lt;/code&gt; option below) without the overhead of sorting.</source>
          <target state="translated">Опция &lt;code&gt;BY&lt;/code&gt; также может принимать несуществующий ключ, из-за чего &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; пропускает операцию сортировки. Это полезно, если вы хотите получить внешние ключи (см. &lt;code&gt;GET&lt;/code&gt; ниже) без дополнительных затрат на сортировку.</target>
        </trans-unit>
        <trans-unit id="04d5c46b7c9e4c0432ac2f85c4c63dc2b3333abd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BY&lt;/code&gt; option takes a pattern (equal to &lt;code&gt;weight_*&lt;/code&gt; in this example) that is used to generate the keys that are used for sorting. These key names are obtained substituting the first occurrence of &lt;code&gt;*&lt;/code&gt; with the actual value of the element in the list (&lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; in this example).</source>
          <target state="translated">Параметр &lt;code&gt;BY&lt;/code&gt; принимает шаблон (равный &lt;code&gt;weight_*&lt;/code&gt; в этом примере), который используется для генерации ключей, используемых для сортировки. Эти имена ключей получаются путем замены первого появления &lt;code&gt;*&lt;/code&gt; на фактическое значение элемента в списке ( &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; и &lt;code&gt;3&lt;/code&gt; в этом примере).</target>
        </trans-unit>
        <trans-unit id="bd7cf93ba7657f4f2966769280d74bac3ba29a14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COUNT&lt;/code&gt; option is used to limit the amount of stream/PEL entries that are returned (The first &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; entries are returned). The default &lt;code&gt;COUNT&lt;/code&gt; is 10 and a &lt;code&gt;COUNT&lt;/code&gt; of 0 means that all entries will be returned (Execution time may be long if the stream has a lot of entries)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7781d414a168c2c6071c960ca2a2f476d429921c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELSLOTS&lt;/code&gt; command asks a particular Redis Cluster node to forget which master is serving the hash slots specified as arguments.</source>
          <target state="translated">Команда &lt;code&gt;DELSLOTS&lt;/code&gt; просит конкретный узел кластера Redis забыть, какой мастер обслуживает хэш-слоты, указанные в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="f40cf7905426fe2efaf1d7bb82912ca46b5d481b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; option can be used multiple times in order to get more keys for every element of the original list, set or sorted set.</source>
          <target state="translated">&lt;code&gt;GET&lt;/code&gt; опция может быть использована несколько раз для того , чтобы получить больше ключей для каждого элемента исходного списка, набора или отсортированного набора.</target>
        </trans-unit>
        <trans-unit id="d2200d7bc7ff4797c7f7c14add0d36376defba47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ID&lt;/code&gt; filter only returns entries for clients with IDs matching the &lt;code&gt;client-id&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692cd27ca778c52fb164170863c312f93a4febd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOACK&lt;/code&gt; subcommand can be used to avoid adding the message to the PEL in cases where reliability is not a requirement and the occasional message loss is acceptable. This is equivalent to acknowledging the message when it is read.</source>
          <target state="translated">&lt;code&gt;NOACK&lt;/code&gt; субкоманда может быть использована , чтобы избежать добавления сообщения в PEL в тех случаях , когда надежность не является обязательным требование и случайные потери сообщения является приемлемой. Это эквивалентно подтверждению сообщения при его прочтении.</target>
        </trans-unit>
        <trans-unit id="70ae9c69379861ae43b186cc1aea347b195c9116" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NODE&lt;/code&gt; subcommand is the one with the most complex semantics. It associates the hash slot with the specified node, however the command works only in specific situations and has different side effects depending on the slot state. The following is the set of pre-conditions and side effects of the command:</source>
          <target state="translated">&lt;code&gt;NODE&lt;/code&gt; субкоманда является один с наиболее сложной семантикой. Он связывает хэш-слот с указанным узлом, однако команда работает только в определенных ситуациях и имеет различные побочные эффекты в зависимости от состояния слота. Ниже приводится набор предварительных условий и побочных эффектов команды:</target>
        </trans-unit>
        <trans-unit id="f3353a302ef9a9215dfe9198dea9a7e8ef365e65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aof_delayed_fsync&lt;/code&gt; counter</source>
          <target state="translated">&lt;code&gt;aof_delayed_fsync&lt;/code&gt; счетчик</target>
        </trans-unit>
        <trans-unit id="8b5f4a6fffad95a3f4be7e216981db9fcd1d6fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; argument is available since version 3.2.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; аргументов доступен , начиная с версии 3.2.</target>
        </trans-unit>
        <trans-unit id="8ce90da51cb5b392562f97eba72b463845c11c4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ip:port&lt;/code&gt; should match a line returned by the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command (&lt;code&gt;addr&lt;/code&gt; field).</source>
          <target state="translated">&lt;code&gt;ip:port&lt;/code&gt; должен соответствовать линиям , возвращаемых &lt;a href=&quot;client-list&quot;&gt;КЛИЕНТ LIST&lt;/a&gt; команды ( &lt;code&gt;addr&lt;/code&gt; поле).</target>
        </trans-unit>
        <trans-unit id="5777eb84fcb1170d8747af88e5c07f98feb04ee9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;message&lt;/code&gt; argument is simply a string. Example:</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; аргумент это просто строка. Пример:</target>
        </trans-unit>
        <trans-unit id="9ea110d8be26fa3611a695ea1e98f388ddefd010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments have the same meaning as described for &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; и &lt;code&gt;max&lt;/code&gt; аргументы имеют такое же значение , как описано для &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="109dd07703928b5f87b169ad0c30d69a49fafa5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments have the same semantic as described for &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; и &lt;code&gt;max&lt;/code&gt; аргументы имеют ту же семантику , как описано для &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07c405abf8ce41269def6794789e4d59831e2dc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;score&lt;/code&gt; value should be the string representation of a numeric value, and accepts double precision floating point numbers. It is possible to provide a negative value to decrement the score.</source>
          <target state="translated">Значение &lt;code&gt;score&lt;/code&gt; должно быть строковым представлением числового значения и принимать числа с плавающей запятой двойной точности. Для уменьшения оценки можно указать отрицательное значение.</target>
        </trans-unit>
        <trans-unit id="4192359597f0ce567f180b8ce4e1911ba0a4fee7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as a double value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f5712887288aace7cb25c9ca1f98dbdf6c03f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as an double value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca4c3a5926b2e82699f6692683e7c60016ad3961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as an integer value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; аргумент интерпретируется как целое значение , определяющее максимальное количество секунд , чтобы заблокировать. Нулевой таймаут может использоваться для блокировки на неопределенный срок.</target>
        </trans-unit>
        <trans-unit id="1ad755fb1756745bfb0855cce9d6737683c771bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument is the same string name that the &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; command returns. Note a quirk where some Redis types, such as GeoHashes, HyperLogLogs, Bitmaps, and Bitfields, may internally be implemented using other Redis types, such as a string or zset, so can't be distinguished from other keys of that same type by &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;. For example, a ZSET and GEOHASH:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70e592aaa3d9e8f7df4a512dc479e926a2adbc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; argument between the &lt;strong&gt;MAXLEN&lt;/strong&gt; option and the actual count means that the user is not really requesting that the stream length is exactly 1000 items, but instead it could be a few tens of entries more, but never less than 1000 items. When this option modifier is used, the trimming is performed only when Redis is able to remove a whole macro node. This makes it much more efficient, and it is usually what you want.</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; Аргумент между &lt;strong&gt;MAXLEN&lt;/strong&gt; опцией и фактическими средствами подсчета , что пользователь действительно не прошу, чтобы длина потока ровно 1000 пунктов, но вместо этого может быть несколько десятков записей больше, но не менее чем 1000 наименований. Когда используется этот модификатор параметра, обрезка выполняется только тогда, когда Redis может удалить весь макроузел. Это делает его намного более эффективным, и обычно это именно то, что вам нужно.</target>
        </trans-unit>
        <trans-unit id="ea8b5fbf2699e6884711237f84a50ed662e87dcb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;STREAMS&lt;/strong&gt; option is mandatory and MUST be the final option because such option gets a variable length of argument in the following format:</source>
          <target state="translated">Опция &lt;strong&gt;STREAMS&lt;/strong&gt; является обязательной и ДОЛЖНА быть последней опцией, потому что такая опция получает аргумент переменной длины в следующем формате:</target>
        </trans-unit>
        <trans-unit id="f1467c9ba6d40cf52b5cdae46604d845510d3c66" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;TAKEOVER&lt;/strong&gt; option implies everything &lt;strong&gt;FORCE&lt;/strong&gt; implies, but also does not uses any cluster authorization in order to failover. A replica receiving &lt;code&gt;CLUSTER FAILOVER TAKEOVER&lt;/code&gt; will instead:</source>
          <target state="translated">Параметр &lt;strong&gt;TAKEOVER&lt;/strong&gt; подразумевает все, что подразумевает &lt;strong&gt;FORCE&lt;/strong&gt; , но также не использует авторизацию кластера для переключения при отказе. Реплика, получающая &lt;code&gt;CLUSTER FAILOVER TAKEOVER&lt;/code&gt; , вместо этого:</target>
        </trans-unit>
        <trans-unit id="706ee50ff413a981311879f38f0325b685e418ae" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;cluster&lt;/strong&gt; section currently only contains a unique field:</source>
          <target state="translated">Раздел &lt;strong&gt;кластера в&lt;/strong&gt; настоящее время содержит только уникальное поле:</target>
        </trans-unit>
        <trans-unit id="e18469751043e4051869a86bbcba03716b45e346" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;commandstats&lt;/strong&gt; section provides statistics based on the command type, including the number of calls, the total CPU time consumed by these commands, and the average CPU consumed per command execution.</source>
          <target state="translated">Раздел &lt;strong&gt;commandstats&lt;/strong&gt; предоставляет статистику, основанную на типе команды, включая количество вызовов, общее время ЦП, потребляемое этими командами, и среднее потребление ЦП на выполнение команды.</target>
        </trans-unit>
        <trans-unit id="f90c39a55fa63248e76899e871ade6a1431c29d1" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;keyspace&lt;/strong&gt; section provides statistics on the main dictionary of each database. The statistics are the number of keys, and the number of keys with an expiration.</source>
          <target state="translated">Раздел &lt;strong&gt;keypace&lt;/strong&gt; предоставляет статистику по основному словарю каждой базы данных. Статистика - это количество ключей и количество ключей с истечением срока действия.</target>
        </trans-unit>
        <trans-unit id="3a0202270041736b1216ba5baa1f54459be4f741" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;modules&lt;/strong&gt; section contains additional information about loaded modules if the modules provide it. The field part of properties lines in this section is always prefixed with the module's name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac8492c1e70ee526ecccc4abef734bddc537815" translate="yes" xml:space="preserve">
          <source>The AUTH command authenticates the current connection in two cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff483a1ce1f770bdb2f62a76889e8f7ada78a73" translate="yes" xml:space="preserve">
          <source>The CJSON library provides extremely fast JSON manipulation within Lua.</source>
          <target state="translated">Библиотека CJSON обеспечивает чрезвычайно быструю манипуляцию JSON внутри Lua.</target>
        </trans-unit>
        <trans-unit id="7530389adb107898a8e0437c53cce50bad07ea36" translate="yes" xml:space="preserve">
          <source>The COUNT option</source>
          <target state="translated">Вариант COUNT</target>
        </trans-unit>
        <trans-unit id="e8dffa28f7261bfe8a1090fc2b6db1ae98bb313f" translate="yes" xml:space="preserve">
          <source>The HyperLogLog data structure can be used in order to count &lt;strong&gt;unique&lt;/strong&gt; elements in a set using just a small constant amount of memory, specifically 12k bytes for every HyperLogLog (plus a few bytes for the key itself).</source>
          <target state="translated">Структуру данных HyperLogLog можно использовать для подсчета &lt;strong&gt;уникальных&lt;/strong&gt; элементов в наборе, используя лишь небольшой постоянный объем памяти, в частности 12 Кбайт для каждого HyperLogLog (плюс несколько байтов для самого ключа).</target>
        </trans-unit>
        <trans-unit id="5d5e9e7569c5ac826ef312fb92859c0deffb60e9" translate="yes" xml:space="preserve">
          <source>The HyperLogLog, being a Redis string, can be retrieved with &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; and restored with &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. Calling &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;, &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; or &lt;a href=&quot;pfmerge&quot;&gt;PFMERGE&lt;/a&gt; commands with a corrupted HyperLogLog is never a problem, it may return random values but does not affect the stability of the server. Most of the times when corrupting a sparse representation, the server recognizes the corruption and returns an error.</source>
          <target state="translated">HyperLogLog, являющийся строкой Redis, может быть получен с помощью &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; и восстановлен с помощью &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; . Вызов &lt;a href=&quot;pfadd&quot;&gt;команд PFADD&lt;/a&gt; , &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; или &lt;a href=&quot;pfmerge&quot;&gt;PFMERGE&lt;/a&gt; с поврежденным HyperLogLog никогда не является проблемой, он может возвращать случайные значения, но не влияет на стабильность сервера. В большинстве случаев при повреждении разреженного представления сервер распознает повреждение и возвращает ошибку.</target>
        </trans-unit>
        <trans-unit id="b9ffa717a680ea863704c9d4cbe178090dee5908" translate="yes" xml:space="preserve">
          <source>The ID is monotonically incremental. If the ID of a connection is greater than the ID of another connection, it is guaranteed that the second connection was established with the server at a later time.</source>
          <target state="translated">Идентификатор монотонно инкрементальный.Если ID соединения больше ID другого соединения,гарантируется,что второе соединение было установлено с сервером позже.</target>
        </trans-unit>
        <trans-unit id="7f2d6cad55038bdb71cc5342903dad20539f48ed" translate="yes" xml:space="preserve">
          <source>The ID is never reset in the course of the Redis server execution, only a server restart will reset it.</source>
          <target state="translated">Идентификатор никогда не сбрасывается в ходе выполнения сервера Redis,только перезагрузка сервера сбрасывает его.</target>
        </trans-unit>
        <trans-unit id="5028f5e06740630088beea552d56dbc9a9d96305" translate="yes" xml:space="preserve">
          <source>The ID of the last entry is &lt;code&gt;1526985685298-0&lt;/code&gt;, so we just add 1 to the sequence to obtain &lt;code&gt;1526985685298-1&lt;/code&gt;, and continue our iteration:</source>
          <target state="translated">Идентификатор последней записи - &lt;code&gt;1526985685298-0&lt;/code&gt; , поэтому мы просто добавляем 1 к последовательности, чтобы получить &lt;code&gt;1526985685298-1&lt;/code&gt; , и продолжаем нашу итерацию:</target>
        </trans-unit>
        <trans-unit id="7eefbc13fad88639889dfca1eea5bd903a412b2f" translate="yes" xml:space="preserve">
          <source>The ID of the last entry is &lt;code&gt;1526985685298-0&lt;/code&gt;, so we just prefix it with a '(', and continue our iteration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc0d85cea060a3580771bdafcea7e5bc90996bb" translate="yes" xml:space="preserve">
          <source>The ID of the message.</source>
          <target state="translated">Идентификатор сообщения.</target>
        </trans-unit>
        <trans-unit id="10ecce9f88d9ae56cb1bcd6efbec98fbc1a5f68e" translate="yes" xml:space="preserve">
          <source>The ID to specify in the &lt;strong&gt;STREAMS&lt;/strong&gt; option when using &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; can be one of the following two:</source>
          <target state="translated">Идентификатор, который нужно указать в параметре &lt;strong&gt;STREAMS&lt;/strong&gt; при использовании &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP,&lt;/a&gt; может быть одним из следующих двух:</target>
        </trans-unit>
        <trans-unit id="a5addd3dd6a1b78a37c68a12e4b0f086415a0b5b" translate="yes" xml:space="preserve">
          <source>The IP of the master.</source>
          <target state="translated">IP мастера.</target>
        </trans-unit>
        <trans-unit id="5bcb92df23fdb05d8a0140fd9087b6b631c09793" translate="yes" xml:space="preserve">
          <source>The LCS subcommand implements the longest common subsequence algorithm. Note that this is different than the longest common string algorithm, since matching characters in the string does not need to be contiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e326a0ab79090e9945701455a9f67576780adbaf" translate="yes" xml:space="preserve">
          <source>The LOLWUT command displays the Redis version: however as a side effect of doing so, it also creates a piece of generative computer art that is different with each version of Redis. The command was introduced in Redis 5 and announced with this &lt;a href=&quot;http://antirez.com/news/123&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f53ea350a50177374bcdd35f9332bb81e5298f0" translate="yes" xml:space="preserve">
          <source>The Lua Bit Operations Module adds bitwise operations on numbers. It is available for scripting in Redis since version 2.8.18.</source>
          <target state="translated">Модуль Lua Bit Operations Module добавляет битовые операции над числами.Он доступен для скриптов в Redis начиная с версии 2.8.18.</target>
        </trans-unit>
        <trans-unit id="1051d37718542a5598a286cc56e5f5aaafbf73d5" translate="yes" xml:space="preserve">
          <source>The Lua PRNG in this mode is seeded randomly at every call.</source>
          <target state="translated">Lua PRNG в этом режиме посылается случайным образом при каждом вызове.</target>
        </trans-unit>
        <trans-unit id="a8d85991ddfb0f169b9f806f86a3cc0413e31e4e" translate="yes" xml:space="preserve">
          <source>The Lua debugger is described in the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Lua scripts debugging&lt;/a&gt; section of the Redis documentation.</source>
          <target state="translated">Отладчик Lua описан в разделе &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;отладки сценариев Lua&lt;/a&gt; документации Redis.</target>
        </trans-unit>
        <trans-unit id="4515a3f12b04929b3987b1647823726616d895eb" translate="yes" xml:space="preserve">
          <source>The Lua engine always assumes to run in RESP2 mode when talking with Redis, so whatever the connection that is invoking the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; or &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; command is in RESP2 or RESP3 mode, Lua scripts will, by default, still see the same kind of replies they used to see in the past from Redis, when calling commands using the &lt;code&gt;redis.call()&lt;/code&gt; built-in function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a696a748eaeb904c163e6d11e4f1f007a0ef038" translate="yes" xml:space="preserve">
          <source>The MATCH option</source>
          <target state="translated">Опция MATCH</target>
        </trans-unit>
        <trans-unit id="4eb0859176601ed31b0ed60fbf24deb7442f3423" translate="yes" xml:space="preserve">
          <source>The PUBSUB command is an introspection command that allows to inspect the state of the Pub/Sub subsystem. It is composed of subcommands that are documented separately. The general form is:</source>
          <target state="translated">Команда PUBSUB-это команда интроспекции,позволяющая проверить состояние подсистемы Pub/Sub.Она состоит из подкоманд,которые документируются отдельно.Общая форма:</target>
        </trans-unit>
        <trans-unit id="82e7a6dd485996953664282bec28fa4f1043afe7" translate="yes" xml:space="preserve">
          <source>The Redis Lua interpreter loads the following Lua libraries:</source>
          <target state="translated">Интерпретатор Redis Lua загружает следующие библиотеки Lua:</target>
        </trans-unit>
        <trans-unit id="bb0c5eade03c486c5f8281c1da8633f26a4b714d" translate="yes" xml:space="preserve">
          <source>The Redis Slow Log is a system to log queries that exceeded a specified execution time. The execution time does not include I/O operations like talking with the client, sending the reply and so forth, but just the time needed to actually execute the command (this is the only stage of command execution where the thread is blocked and can not serve other requests in the meantime).</source>
          <target state="translated">Redis Slow Log-это система для записи в журнал запросов,которые превысили заданное время выполнения.Время выполнения не включает в себя операции ввода/вывода,такие как разговор с клиентом,отправка ответа и т.д.,а только время,необходимое для фактического выполнения команды (это единственный этап выполнения команды,на котором поток заблокирован и не может обслуживать другие запросы в то же время).</target>
        </trans-unit>
        <trans-unit id="63b3dcb2e93d3c4b06fb3ccd03dd7de69fb04d43" translate="yes" xml:space="preserve">
          <source>The SCRIPT command</source>
          <target state="translated">Команда SCRIPT</target>
        </trans-unit>
        <trans-unit id="7b0199097175bc8f260d469794e2e96bed7dab06" translate="yes" xml:space="preserve">
          <source>The STRALGO implements complex algorithms that operate on strings. Right now the only algorithm implemented is the LCS algorithm (longest common substring). However new algorithms could be implemented in the future. The goal of this command is to provide to Redis users algorithms that need fast implementations and are normally not provided in the standard library of most programming languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04ad115145f4340fd6a7e75d3c008104af8a7d2" translate="yes" xml:space="preserve">
          <source>The TYPE option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9be29f5758f4e3311e10dd99d11effd38e89f6" translate="yes" xml:space="preserve">
          <source>The ability to see all the requests processed by the server is useful in order to spot bugs in an application both when using Redis as a database and as a distributed caching system.</source>
          <target state="translated">Возможность видеть все запросы,обрабатываемые сервером,полезна для обнаружения ошибок в приложении как при использовании Redis в качестве базы данных,так и в качестве распределенной системы кэширования.</target>
        </trans-unit>
        <trans-unit id="a9a4c4b85d74e390cf97f77d86569a9c392136a7" translate="yes" xml:space="preserve">
          <source>The above command will create a user called &lt;code&gt;virginia&lt;/code&gt; that is active (the on rule), can access any key (allkeys rule), and can call the set command (+set rule). Then another SETUSER call can modify the user rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f195a8757b1d8a55a19d37ee9ad3a22c5c0a4e17" translate="yes" xml:space="preserve">
          <source>The above makes it very simple to implement a system where a set of items must be processed by N workers continuously as fast as possible. An example is a monitoring system that must check that a set of web sites are reachable, with the smallest delay possible, using a number of parallel workers.</source>
          <target state="translated">Вышеизложенное позволяет очень просто реализовать систему,в которой набор элементов должен непрерывно обрабатываться N рабочими как можно быстрее.Примером может служить система мониторинга,которая должна проверять доступность набора web-сайтов с минимальной задержкой,используя несколько параллельных рабочих.</target>
        </trans-unit>
        <trans-unit id="75a3a44602ce55e23d207b895b5a485f6d4a2fc0" translate="yes" xml:space="preserve">
          <source>The above pattern works even if the following two conditions:</source>
          <target state="translated">Вышеприведенный образец работает даже при следующих двух условиях:</target>
        </trans-unit>
        <trans-unit id="27a55611f4365743e826db0b0f9378c4a66a4f67" translate="yes" xml:space="preserve">
          <source>The above rule will not apply the new rule to the user virginia, so other than &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;, the user virginia will now be able to also use the &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d153745d60911da280f1df79b2e372158711e77" translate="yes" xml:space="preserve">
          <source>The above script sets the key &lt;code&gt;foo&lt;/code&gt; to the string &lt;code&gt;bar&lt;/code&gt;. However it violates the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command semantics as all the keys that the script uses should be passed using the &lt;code&gt;KEYS&lt;/code&gt; array:</source>
          <target state="translated">Вышеупомянутый сценарий устанавливает ключ &lt;code&gt;foo&lt;/code&gt; в строку &lt;code&gt;bar&lt;/code&gt; . Однако это нарушает &lt;a href=&quot;eval&quot;&gt;семантику&lt;/a&gt; команды EVAL, так как все ключи, которые использует скрипт, должны передаваться с использованием массива &lt;code&gt;KEYS&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0dd21e93f4a7ab544f682629858a1ca7196710f4" translate="yes" xml:space="preserve">
          <source>The additional elements of the array depends on the role.</source>
          <target state="translated">Дополнительные элементы массива зависят от роли.</target>
        </trans-unit>
        <trans-unit id="b4c1764b30cb0625e6c253a27bb41e84ea603d9e" translate="yes" xml:space="preserve">
          <source>The algorithm used, that is implemented inside dict.c, samples the hash table buckets to find a non-empty one. Once a non empty bucket is found, since we use chaining in our hash table implementation, the number of elements inside the bucket is checked and a random element is selected.</source>
          <target state="translated">Используемый алгоритм,реализованный внутри dict.c,сэмплирует ведра хэш-таблицы,чтобы найти непустое.Как только найдено непустое ведро,так как в реализации хэш-таблицы мы используем цепочки,проверяется количество элементов внутри ведра и выбирается случайный элемент.</target>
        </trans-unit>
        <trans-unit id="6de2e476596fcaba51a4ddd43e2a8bd4d48c346f" translate="yes" xml:space="preserve">
          <source>The amount of data received from the replica so far in terms of master replication offset.</source>
          <target state="translated">Количество данных,полученных на данный момент от реплики,с точки зрения смещения мастер-репликации.</target>
        </trans-unit>
        <trans-unit id="5d8b8009ef4dd06c8c025f1eed58b5b1787f1f48" translate="yes" xml:space="preserve">
          <source>The amount of time needed for its execution, in microseconds.</source>
          <target state="translated">Количество времени,необходимое для его исполнения,в микросекундах.</target>
        </trans-unit>
        <trans-unit id="e5407b8706df1e8319a7a989bf68d7ad75911c3a" translate="yes" xml:space="preserve">
          <source>The approximated number of unique elements observed via &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;.</source>
          <target state="translated">Приблизительное количество уникальных элементов, наблюдаемых с помощью &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d3457f0c58f45dac774e34be45c19b72f462db2" translate="yes" xml:space="preserve">
          <source>The arguments of the &lt;code&gt;redis.call()&lt;/code&gt; and &lt;code&gt;redis.pcall()&lt;/code&gt; functions are all the arguments of a well formed Redis command:</source>
          <target state="translated">Аргументы функций &lt;code&gt;redis.call()&lt;/code&gt; и &lt;code&gt;redis.pcall()&lt;/code&gt; - это все аргументы правильно сформированной команды Redis:</target>
        </trans-unit>
        <trans-unit id="120865be87c8e6ca3cb347b65ffdefe018090581" translate="yes" xml:space="preserve">
          <source>The array composing the arguments of the command.</source>
          <target state="translated">Массив,составляющий аргументы команды.</target>
        </trans-unit>
        <trans-unit id="a010440d8c2596df424c379b3133bfd83782f2d9" translate="yes" xml:space="preserve">
          <source>The assigned name is displayed in the output of &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; so that it is possible to identify the client that performed a given connection.</source>
          <target state="translated">Назначенное имя отображается в выходных данных &lt;a href=&quot;client-list&quot;&gt;СПИСКА КЛИЕНТОВ,&lt;/a&gt; чтобы можно было идентифицировать клиента, который выполнил данное соединение.</target>
        </trans-unit>
        <trans-unit id="885f9339188f139f7b1172052e203973f59a224e" translate="yes" xml:space="preserve">
          <source>The basic idea is that nodes by default don't trust each other, and are considered unknown, so that it is unlikely that different cluster nodes will mix into a single one because of system administration errors or network addresses modifications.</source>
          <target state="translated">Основная идея заключается в том,что узлы по умолчанию не доверяют друг другу и считаются неизвестными,поэтому маловероятно,что различные узлы кластера будут смешиваться в один из-за ошибок системного администрирования или изменения сетевых адресов.</target>
        </trans-unit>
        <trans-unit id="d3155ed9386ade27ef1929683ef41081fb15be86" translate="yes" xml:space="preserve">
          <source>The basic usage is the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9c85f3c202fdd59f8f147e36c3ec1f770f703e" translate="yes" xml:space="preserve">
          <source>The behavior of Redis 2.4 creates a lot of problems when replicating or persisting data into the AOF file, so the much more generic and semantically simpler behavior was introduced into Redis 2.6 to prevent problems.</source>
          <target state="translated">Поведение в Redis 2.4 создает много проблем при копировании или сохранении данных в AOF-файле,поэтому гораздо более общее и семантически простое поведение было введено в Redis 2.6 для предотвращения проблем.</target>
        </trans-unit>
        <trans-unit id="b344dc2bc04bb34933613eb7044804cab8c272df" translate="yes" xml:space="preserve">
          <source>The binary nature of the comparison allows to use sorted sets as a general purpose index, for example the first part of the element can be a 64 bit big endian number: since big endian numbers have the most significant bytes in the initial positions, the binary comparison will match the numerical comparison of the numbers. This can be used in order to implement range queries on 64 bit values. As in the example below, after the first 8 bytes we can store the value of the element we are actually indexing.</source>
          <target state="translated">Двоичная природа сравнения позволяет использовать отсортированные множества в качестве индекса общего назначения,например,первая часть элемента может быть 64-битным большим эндийским числом:поскольку большие эндийские числа имеют наиболее значимые байты в исходных позициях,то двоичное сравнение будет соответствовать числовому сравнению чисел.Это может быть использовано для реализации запросов диапазона на 64-битных значениях.Как и в примере ниже,после первых 8 байт мы можем сохранить значение элемента,который мы фактически индексируем.</target>
        </trans-unit>
        <trans-unit id="f19a05fbdb75f958bfa6f09541362b1de2c7798d" translate="yes" xml:space="preserve">
          <source>The bit is either set or cleared depending on &lt;em&gt;value&lt;/em&gt;, which can be either 0 or 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3282d877e14a9e1a4f618e1ae58563eb55cb394" translate="yes" xml:space="preserve">
          <source>The bit is either set or cleared depending on &lt;em&gt;value&lt;/em&gt;, which can be either 0 or 1. When &lt;em&gt;key&lt;/em&gt; does not exist, a new string value is created. The string is grown to make sure it can hold a bit at &lt;em&gt;offset&lt;/em&gt;. The &lt;em&gt;offset&lt;/em&gt; argument is required to be greater than or equal to 0, and smaller than 2&lt;sup&gt;32&lt;/sup&gt; (this limits bitmaps to 512MB). When the string at &lt;em&gt;key&lt;/em&gt; is grown, added bits are set to 0.</source>
          <target state="translated">Бит устанавливается или сбрасывается в зависимости от &lt;em&gt;значения&lt;/em&gt; , которое может быть либо 0, либо 1. Когда &lt;em&gt;ключ&lt;/em&gt; не существует, создается новое строковое значение. Строка увеличивается, чтобы убедиться, что она может удерживать немного &lt;em&gt;смещения&lt;/em&gt; . &lt;em&gt;Смещения&lt;/em&gt; аргумент должен быть больше или равен 0, и меньше , чем 2 &lt;sup&gt;32&lt;/sup&gt; (это ограничивает растровые изображения до 512 МБ). Когда строка в &lt;em&gt;ключе&lt;/em&gt; увеличивается, добавленные биты устанавливаются в 0.</target>
        </trans-unit>
        <trans-unit id="0b7af7df323735c0dce87d77fcd93c888e45e3a0" translate="yes" xml:space="preserve">
          <source>The client explicitly checks the &lt;code&gt;runid&lt;/code&gt; field in the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command in order to make sure the server was not restarted and is still the same process.</source>
          <target state="translated">Клиент явно проверяет поле &lt;code&gt;runid&lt;/code&gt; в команде &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; , чтобы убедиться, что сервер не был перезапущен и это все тот же процесс.</target>
        </trans-unit>
        <trans-unit id="9350ca0340f5b792f129eec734a9c6029b8bad38" translate="yes" xml:space="preserve">
          <source>The client flags can be a combination of:</source>
          <target state="translated">Клиентские флаги могут быть комбинацией:</target>
        </trans-unit>
        <trans-unit id="ef7c4ea851346ff688f43804007664e07a0ee9aa" translate="yes" xml:space="preserve">
          <source>The client library implementation can always optimistically send &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; under the hood even when the client actually calls &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;, in the hope the script was already seen by the server. If the &lt;code&gt;NOSCRIPT&lt;/code&gt; error is returned &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; will be used instead.</source>
          <target state="translated">Реализация клиентской библиотеки всегда может оптимистично послать &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; под капотом, даже когда клиент действительно вызывает &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; , в надежде, что сценарий уже был замечен сервером. Если &lt;code&gt;NOSCRIPT&lt;/code&gt; ошибка &lt;a href=&quot;eval&quot;&gt;NOSCRIPT&lt;/a&gt; , вместо нее будет использоваться EVAL .</target>
        </trans-unit>
        <trans-unit id="5dfcddce441b9e425d29945dfa151dd5838c9e0e" translate="yes" xml:space="preserve">
          <source>The client library implementation should take one of the following approaches:</source>
          <target state="translated">Реализация клиентской библиотеки должна осуществляться одним из следующих подходов:</target>
        </trans-unit>
        <trans-unit id="cea5f73089ab49d55692f68c7533b954be4a4271" translate="yes" xml:space="preserve">
          <source>The client sent a command about hash slots never served by the master of this replica.</source>
          <target state="translated">Клиент отправил команду о хэш-слотах,никогда не обслуживаемых мастером этой реплики.</target>
        </trans-unit>
        <trans-unit id="4f3cae0941780fdfb0d5aa096cbd40be72c4d373" translate="yes" xml:space="preserve">
          <source>The client will have to acknowledge the message processing using &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; in order for the pending entry to be removed from the PEL. The PEL can be inspected using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command.</source>
          <target state="translated">Клиент должен будет подтвердить обработку сообщения с помощью &lt;a href=&quot;xack&quot;&gt;XACK,&lt;/a&gt; чтобы ожидающая запись была удалена из PEL. PEL можно проверить с помощью команды &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82fd513f621c09ac0869a99d08b31390f0bc842b" translate="yes" xml:space="preserve">
          <source>The cluster was reconfigured (for example resharded) and the replica is no longer able to serve commands for a given hash slot.</source>
          <target state="translated">Кластер был переконфигурирован (например,перестроен),и реплика больше не может обслуживать команды для заданного слота хэша.</target>
        </trans-unit>
        <trans-unit id="9940f805fd9de379d7d0c58cd1b84f3338b5e58f" translate="yes" xml:space="preserve">
          <source>The cmsgpack library provides simple and fast MessagePack manipulation within Lua.</source>
          <target state="translated">Библиотека cmsgpack обеспечивает простую и быструю манипуляцию с MessagePack внутри Lua.</target>
        </trans-unit>
        <trans-unit id="0b9bb30b2dbe12e3fa62af10a99007a2ae4848a9" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; is also able to iterate the stream. The command &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; can iterate the stream reverse, from higher IDs (or times) to lower IDs (or times).</source>
          <target state="translated">Команда &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; также может выполнять итерацию потока. Команда &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; может выполнять итерацию потока в обратном направлении, от более высоких идентификаторов (или времени) к более низким идентификаторам (или времени).</target>
        </trans-unit>
        <trans-unit id="4fbd17702a2c89af4ecc45167e7c6a7b02c943ed" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;SET resource-name anystring NX EX max-lock-time&lt;/code&gt; is a simple way to implement a locking system with Redis.</source>
          <target state="translated">Команда &lt;code&gt;SET resource-name anystring NX EX max-lock-time&lt;/code&gt; - это простой способ реализовать систему блокировки с Redis.</target>
        </trans-unit>
        <trans-unit id="2dbda62e4a8fd31c5ca6fc1f4cddf22961ead108" translate="yes" xml:space="preserve">
          <source>The command &lt;strong&gt;will always return&lt;/strong&gt; the number of replicas that acknowledged the write commands sent before the &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; command, both in the case where the specified number of replicas are reached, or when the timeout is reached.</source>
          <target state="translated">Команда &lt;strong&gt;всегда будет возвращать&lt;/strong&gt; количество реплик, которые подтвердили команды записи, отправленные до команды &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; , как в случае достижения указанного количества реплик, так и при достижении тайм-аута.</target>
        </trans-unit>
        <trans-unit id="4a44b122481ff3652c96ef6533c739e783fe19c3" translate="yes" xml:space="preserve">
          <source>The command also has a reciprocal command returning items in the reverse order, called &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt;, which is otherwise identical.</source>
          <target state="translated">У команды также есть обратная команда, возвращающая элементы в обратном порядке, называемая &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; , которая в остальном идентична.</target>
        </trans-unit>
        <trans-unit id="b51d9780c5d61a87b53bd27d3ac5c24a4b0638d8" translate="yes" xml:space="preserve">
          <source>The command behavior can be modified by two options: &lt;strong&gt;FORCE&lt;/strong&gt; and &lt;strong&gt;TAKEOVER&lt;/strong&gt;.</source>
          <target state="translated">Поведение команды можно изменить двумя вариантами: &lt;strong&gt;FORCE&lt;/strong&gt; и &lt;strong&gt;TAKEOVER&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0e77b773bc1837b920cb41a24e1a0ef629792be6" translate="yes" xml:space="preserve">
          <source>The command behavior is the following:</source>
          <target state="translated">Поведение команды следующее:</target>
        </trans-unit>
        <trans-unit id="913ef9d1ec1890a263c7a3667b134a3de340bd38" translate="yes" xml:space="preserve">
          <source>The command can accept a variable number of arguments so it always returns an array of positions even when a single element is specified.</source>
          <target state="translated">Команда может принимать переменное количество аргументов,поэтому она всегда возвращает массив позиций,даже если указан один элемент.</target>
        </trans-unit>
        <trans-unit id="b9a60a6fc9ab713863d0cdace7cfdb88da1428ea" translate="yes" xml:space="preserve">
          <source>The command can be called with four different arguments:</source>
          <target state="translated">Команда может быть вызвана с четырьмя различными аргументами:</target>
        </trans-unit>
        <trans-unit id="d2095dc05dd59018ca256f0a5fc566c35f0f4cc7" translate="yes" xml:space="preserve">
          <source>The command default is to return unsorted items. Two different sorting methods can be invoked using the following two options:</source>
          <target state="translated">Командой по умолчанию является возврат неотсортированных элементов.Два различных метода сортировки могут быть вызваны с помощью следующих двух опций:</target>
        </trans-unit>
        <trans-unit id="958832c31d8e5542b245102310cbd53d9f34320f" translate="yes" xml:space="preserve">
          <source>The command does not succeed and returns an error in the following cases:</source>
          <target state="translated">Команда не срабатывает и возвращает ошибку в следующих случаях:</target>
        </trans-unit>
        <trans-unit id="32a8711ea8a78a0226239432ccf720cba86e66af" translate="yes" xml:space="preserve">
          <source>The command fails if the same slot is specified multiple times.</source>
          <target state="translated">Команда не работает,если один и тот же слот указан несколько раз.</target>
        </trans-unit>
        <trans-unit id="b6f1f38c10e41d6cb188193c5859a8d2a04588ed" translate="yes" xml:space="preserve">
          <source>The command has multiple options, however most are mainly for internal use in order to transfer the effects of &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; or other commands to the AOF file and to propagate the same effects to the slaves, and are unlikely to be useful to normal users:</source>
          <target state="translated">У команды есть несколько параметров, однако большинство из них в основном предназначены для внутреннего использования, чтобы передавать эффекты &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; или других команд в файл AOF и распространять те же эффекты на ведомые устройства, и вряд ли будут полезны для обычных пользователей:</target>
        </trans-unit>
        <trans-unit id="aff611203495e6eb730550d71c578dbd6ea9eaee" translate="yes" xml:space="preserve">
          <source>The command internally uses &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt; to generate the serialized version of the key value, and &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; in order to synthesize the key in the target instance. The source instance acts as a client for the target instance. If the target instance returns OK to the &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command, the source instance deletes the key using &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;.</source>
          <target state="translated">Команда внутри использует &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt; для создания сериализованной версии значения ключа и &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; для синтеза ключа в целевом экземпляре. Исходный экземпляр действует как клиент для целевого экземпляра. Если целевой экземпляр возвращает OK команде &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; , исходный экземпляр удаляет ключ с помощью &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8dc74da7f9aeeb2a318e48a6c60e1183a0da365" translate="yes" xml:space="preserve">
          <source>The command is always propagated in the replication link and the Append Only File as a &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; operation, so that differences in the underlying floating point math implementation will not be sources of inconsistency.</source>
          <target state="translated">Команда всегда распространяется в ссылке репликации и добавлении только файла как операция &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; , так что различия в базовой математической реализации с плавающей запятой не будут источником несогласованности.</target>
        </trans-unit>
        <trans-unit id="89297d1be1338bce5eaa89c5524f124377b2d8a5" translate="yes" xml:space="preserve">
          <source>The command is always propagated in the replication link and the Append Only File as a &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation, so that differences in the underlying floating point math implementation will not be sources of inconsistency.</source>
          <target state="translated">Команда всегда распространяется в ссылке репликации и добавлении только файла как операция &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; , так что различия в базовой математической реализации с плавающей запятой не будут источником несогласованности.</target>
        </trans-unit>
        <trans-unit id="a86933f06a2ba31db5ee212ee8cc903bc3c40f34" translate="yes" xml:space="preserve">
          <source>The command is atomic and blocks the two instances for the time required to transfer the key, at any given time the key will appear to exist in a given instance or in the other instance, unless a timeout error occurs. In 3.2 and above, multiple keys can be pipelined in a single call to &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; by passing the empty string (&quot;&quot;) as key and adding the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; clause.</source>
          <target state="translated">Команда является атомарной и блокирует два экземпляра на время, необходимое для передачи ключа, в любой момент времени ключ будет существовать в данном экземпляре или в другом экземпляре, если не произойдет ошибка тайм-аута. В версии 3.2 и выше несколько ключей можно конвейеризовать в одном вызове &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; , передав пустую строку (&quot;&quot;) в качестве ключа и добавив предложение &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4335b586f31c83a0ae96d3ccf6ca0cfaf3a8429" translate="yes" xml:space="preserve">
          <source>The command is used in order to remove a node, specified via its node ID, from the set of &lt;em&gt;known nodes&lt;/em&gt; of the Redis Cluster node receiving the command. In other words the specified node is removed from the &lt;em&gt;nodes table&lt;/em&gt; of the node receiving the command.</source>
          <target state="translated">Команда используется для удаления узла, указанного через его идентификатор узла, из набора &lt;em&gt;известных узлов узла&lt;/em&gt; Redis Cluster, получающего команду. Другими словами, указанный узел удаляется из &lt;em&gt;таблицы узлов&lt;/em&gt; узла, получившего команду.</target>
        </trans-unit>
        <trans-unit id="9389c07b5be98086699ffdc71ab5655cfb6ab6aa" translate="yes" xml:space="preserve">
          <source>The command just returns the ID of the current connection. Every connection ID has certain guarantees:</source>
          <target state="translated">Команда просто возвращает идентификатор текущего соединения.Каждый ID соединения имеет определенные гарантии:</target>
        </trans-unit>
        <trans-unit id="1e36a1bc65a56400c52d66e29f9ce1757bbf2e26" translate="yes" xml:space="preserve">
          <source>The command may fail with an error for several reasons: if the file cannot be written or if the server is not configured to use an external ACL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344468f4b5f6d51949f0a2c14063fc0a3b852987" translate="yes" xml:space="preserve">
          <source>The command may fail with an error for several reasons: if the file is not readable, if there is an error inside the file, and in such case the error will be reported to the user in the error. Finally the command will fail if the server is not configured to use an external ACL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa2b5549f1c670208cc851a7701050140450874" translate="yes" xml:space="preserve">
          <source>The command may reply with an error in certain cases, as documented above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0d0753b06a3754e2b6097d7df536fcb852c4ed" translate="yes" xml:space="preserve">
          <source>The command only works if all the specified slots are already associated with some node.</source>
          <target state="translated">Команда работает только в том случае,если все указанные слоты уже связаны с каким-либо узлом.</target>
        </trans-unit>
        <trans-unit id="43abdb47aec6d5ef3beb1e76ddc4c6370f0f6354" translate="yes" xml:space="preserve">
          <source>The command only works if all the specified slots are, from the point of view of the node receiving the command, currently not assigned. A node will refuse to take ownership for slots that already belong to some other node (including itself).</source>
          <target state="translated">Команда работает только в том случае,если все указанные слоты,с точки зрения узла,принимающего команду,в данный момент не назначены.Узел откажется брать в собственность слоты,которые уже принадлежат какому-либо другому узлу (в том числе и самому себе).</target>
        </trans-unit>
        <trans-unit id="63f80c4f55dda4254e917500ebea54b888f88f18" translate="yes" xml:space="preserve">
          <source>The command optionally returns additional information using the following options:</source>
          <target state="translated">Команда опционально возвращает дополнительную информацию с помощью следующих опций:</target>
        </trans-unit>
        <trans-unit id="94c796162b217920f7fda542eef1c135d9fe60f2" translate="yes" xml:space="preserve">
          <source>The command output is an hexadecimal representation of a binary string. By default it emits 256 bits (so 64 hex characters). The user can provide an argument in form of number of bits to emit from 1 to 1024 to change the output length. Note that the number of bits provided is always rounded to the next multiple of 4. So for instance asking for just 1 bit password will result in 4 bits to be emitted, in the form of a single hex character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f65176db9808f7847abb3d37f52b1528a65ac2" translate="yes" xml:space="preserve">
          <source>The command performs the following actions:</source>
          <target state="translated">Команда выполняет следующие действия:</target>
        </trans-unit>
        <trans-unit id="4778a65d0ba749aa47da2ae16d4895853e331c48" translate="yes" xml:space="preserve">
          <source>The command provides a list of replica nodes replicating from the specified master node. The list is provided in the same format used by &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; (please refer to its documentation for the specification of the format).</source>
          <target state="translated">Команда предоставляет список узлов реплик, реплицируемых с указанного главного узла. Список предоставляется в том же формате, что и &lt;a href=&quot;cluster-nodes&quot;&gt;КЛАСТЕРНЫЕ УЗЛЫ&lt;/a&gt; (спецификации формата см. В документации к нему).</target>
        </trans-unit>
        <trans-unit id="75946e7c075807ac0ec08889c9ae03a9a184e3d3" translate="yes" xml:space="preserve">
          <source>The command reconfigures a node as a replica of the specified master. If the node receiving the command is an &lt;em&gt;empty master&lt;/em&gt;, as a side effect of the command, the node role is changed from master to replica.</source>
          <target state="translated">Команда перенастраивает узел как копию указанного мастера. Если узел, получающий команду, является &lt;em&gt;пустым мастером&lt;/em&gt; , в качестве побочного эффекта команды роль узла изменяется с мастера на реплику.</target>
        </trans-unit>
        <trans-unit id="4ebd54c736f27aa3986d5c357015059ce2df6b55" translate="yes" xml:space="preserve">
          <source>The command returns 11 characters Geohash strings, so no precision is loss compared to the Redis internal 52 bit representation. The returned Geohashes have the following properties:</source>
          <target state="translated">Команда возвращает 11 символов Geohash строк,поэтому точность не теряется по сравнению с внутренним 52-битным представлением Redis.Возвращаемый Geohash имеет следующие свойства:</target>
        </trans-unit>
        <trans-unit id="68e0628c08bc7ef387bda65ff2fbb36117fe6040" translate="yes" xml:space="preserve">
          <source>The command returns &lt;code&gt;-1&lt;/code&gt; if the key exists but has no associated expire.</source>
          <target state="translated">Команда возвращает &lt;code&gt;-1&lt;/code&gt; , если ключ существует, но не имеет срока действия.</target>
        </trans-unit>
        <trans-unit id="9900e726bbbfd1d7f718d4225bf8abc8e591a526" translate="yes" xml:space="preserve">
          <source>The command returns &lt;code&gt;-2&lt;/code&gt; if the key does not exist.</source>
          <target state="translated">Команда возвращает &lt;code&gt;-2&lt;/code&gt; , если ключ не существует.</target>
        </trans-unit>
        <trans-unit id="263f04bc6090861d15e393e44fe1a4d42bd2408e" translate="yes" xml:space="preserve">
          <source>The command returns a &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;Null reply&lt;/a&gt; when used with the &lt;code&gt;NOMKSTREAM&lt;/code&gt; option and the key doesn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf3ff8b30b845ead44db4d82109c56f01457aed" translate="yes" xml:space="preserve">
          <source>The command returns all the messages successfully claimed, in the same format as &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;. However if the &lt;code&gt;JUSTID&lt;/code&gt; option was specified, only the message IDs are reported, without including the actual message.</source>
          <target state="translated">Команда возвращает все успешно &lt;a href=&quot;xrange&quot;&gt;запрошенные&lt;/a&gt; сообщения в том же формате, что и XRANGE . Однако, если была &lt;code&gt;JUSTID&lt;/code&gt; опция JUSTID, сообщаются только идентификаторы сообщений, без включения фактического сообщения.</target>
        </trans-unit>
        <trans-unit id="d91929db6b639c8bbfadd32a8fc0bdbaccdfc27a" translate="yes" xml:space="preserve">
          <source>The command returns all the rules defined for an existing ACL user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a71cfae2a2b43a889c9e6bd259963281080b15" translate="yes" xml:space="preserve">
          <source>The command returns an array of elements. The first element is the role of the instance, as one of the following three strings:</source>
          <target state="translated">Команда возвращает массив элементов.Первый элемент-это роль экземпляра,как одной из следующих трех строк:</target>
        </trans-unit>
        <trans-unit id="aa91d91e133acc78d18bba2922ce5bd5a6f7f354" translate="yes" xml:space="preserve">
          <source>The command returns an array of keys names stored in the contacted node and hashing to the specified hash slot. The maximum number of keys to return is specified via the &lt;code&gt;count&lt;/code&gt; argument, so that it is possible for the user of this API to batch-processing keys.</source>
          <target state="translated">Команда возвращает массив имен ключей, хранящихся в узле, с которым осуществляется контакт, и хэширования в указанный хэш-слот. Максимальное количество возвращаемых ключей указывается с помощью аргумента &lt;code&gt;count&lt;/code&gt; , так что пользователь этого API может использовать ключи пакетной обработки.</target>
        </trans-unit>
        <trans-unit id="e6bc3ec726a066c82649799db4b402b18c37620c" translate="yes" xml:space="preserve">
          <source>The command returns an array of results: each element of the returned array is an array composed of a two element containing the key name and the entries reported for that key. The entries reported are full stream entries, having IDs and the list of all the fields and values. Field and values are guaranteed to be reported in the same order they were added by &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;.</source>
          <target state="translated">Команда возвращает массив результатов: каждый элемент возвращенного массива представляет собой массив, состоящий из двух элементов, содержащих имя ключа и записи, указанные для этого ключа. Сообщаемые записи представляют собой записи полного потока, имеющие идентификаторы и список всех полей и значений. Поле и значения гарантированно будут сообщены в том же порядке, в котором они были добавлены &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="59dca4232b984a49106f20180ccd68dd85cde434" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a four elements array representing the event's name, timestamp, latest and all-time latency measurements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59bdbda1d4276c59a205bc75690c8792da83930" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a two elements array representing longitude and latitude (x,y) of each member name passed as argument to the command.</source>
          <target state="translated">Команда возвращает массив,в котором каждый элемент представляет собой массив из двух элементов,представляющих долготу и широту (x,y)каждого имени члена,переданного в качестве аргумента команде.</target>
        </trans-unit>
        <trans-unit id="c2da6177dc0df5d03aa7780c4ae1b3e2b3b664b6" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a two elements array representing the timestamp and the latency of the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="299bd584711e094e5bb4f6fecbd5c79b634a792b" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is the Geohash corresponding to each member name passed as argument to the command.</source>
          <target state="translated">Команда возвращает массив,где каждый элемент-это Geohash,соответствующий каждому имени члена,переданному в качестве аргумента команде.</target>
        </trans-unit>
        <trans-unit id="63618225d498ac1d95054dac445c00eb7942b4b2" translate="yes" xml:space="preserve">
          <source>The command returns an array with each entry being the corresponding result of the sub command given at the same position. &lt;code&gt;OVERFLOW&lt;/code&gt; subcommands don't count as generating a reply.</source>
          <target state="translated">Команда возвращает массив, каждая запись которого является соответствующим результатом подкоманды, заданной в той же позиции. &lt;code&gt;OVERFLOW&lt;/code&gt; OVERFLOW не считаются генерацией ответа.</target>
        </trans-unit>
        <trans-unit id="0d3fdeb1c470e8f290735d9f570986e08dde9291" translate="yes" xml:space="preserve">
          <source>The command returns an error when the &lt;code&gt;destination&lt;/code&gt; key already exists. The &lt;code&gt;REPLACE&lt;/code&gt; option removes the &lt;code&gt;destination&lt;/code&gt; key before copying the value to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599682f8e696ffcef9a41f128a35f008ec692b72" translate="yes" xml:space="preserve">
          <source>The command returns data in different format depending on the way it is called, as previously explained in this page. However the reply is always an array of items.</source>
          <target state="translated">Команда возвращает данные в различном формате в зависимости от способа их вызова,как уже объяснялось ранее на этой странице.Однако ответ всегда представляет собой массив элементов.</target>
        </trans-unit>
        <trans-unit id="64555ea6ac3dd842f32e77db3528c6314f55ca4d" translate="yes" xml:space="preserve">
          <source>The command returns data in the same format as &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;.</source>
          <target state="translated">Команда возвращает данные в том же формате, что и &lt;a href=&quot;cluster-nodes&quot;&gt;КЛАСТЕРНЫЕ УЗЛЫ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f11ff6c087b294c263c888936947fb519a703574" translate="yes" xml:space="preserve">
          <source>The command returns information about the current client connection's use of the &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;server assisted client side caching&lt;/a&gt; feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84d7525c4b51e3bbe67ae31259831e14b15be40" translate="yes" xml:space="preserve">
          <source>The command returns information and statistics about the current client connection in a mostly human readable format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854de1e7ab31a436fe3503c72376101ec2883922" translate="yes" xml:space="preserve">
          <source>The command returns the ID of the added entry. The ID is the one auto-generated if &lt;code&gt;*&lt;/code&gt; is passed as ID argument, otherwise the command just returns the same ID specified by the user during insertion.</source>
          <target state="translated">Команда возвращает идентификатор добавленной записи. Идентификатор создается автоматически, если &lt;code&gt;*&lt;/code&gt; передается в качестве аргумента идентификатора, в противном случае команда просто возвращает тот же идентификатор, который был указан пользователем во время вставки.</target>
        </trans-unit>
        <trans-unit id="7247b723aad05766caad65ebc7ede74ba6d1e1dd" translate="yes" xml:space="preserve">
          <source>The command returns the distance as a double (represented as a string) in the specified unit, or NULL if one or both the elements are missing.</source>
          <target state="translated">Команда возвращает расстояние в виде двойника (представленного в виде строки)в указанном модуле,или NULL,если один или оба элемента отсутствуют.</target>
        </trans-unit>
        <trans-unit id="a226a6dbee33f1a9bdf015f4eb2291dd60f7022b" translate="yes" xml:space="preserve">
          <source>The command returns the entries with IDs matching the specified range, from the higher ID to the lower ID matching. The returned entries are complete, that means that the ID and all the fields they are composed are returned. Moreover the entries are returned with their fields and values in the exact same order as &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; added them.</source>
          <target state="translated">Команда возвращает записи с идентификаторами, соответствующими указанному диапазону, от более высокого идентификатора до более низкого идентификатора, соответствующего совпадению. Возвращенные записи являются полными, это означает, что возвращается идентификатор и все поля, которые они составляют. Более того, записи возвращаются с их полями и значениями в том же порядке, в &lt;a href=&quot;xadd&quot;&gt;каком они были&lt;/a&gt; добавлены XADD .</target>
        </trans-unit>
        <trans-unit id="444f426015abc65778606f24926eb62888ddcfbe" translate="yes" xml:space="preserve">
          <source>The command returns the entries with IDs matching the specified range. The returned entries are complete, that means that the ID and all the fields they are composed are returned. Moreover, the entries are returned with their fields and values in the exact same order as &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; added them.</source>
          <target state="translated">Команда возвращает записи с идентификаторами, соответствующими указанному диапазону. Возвращенные записи являются полными, это означает, что возвращается идентификатор и все поля, которые они составляют. Более того, записи возвращаются с их полями и значениями в том же порядке, в &lt;a href=&quot;xadd&quot;&gt;каком они были&lt;/a&gt; добавлены XADD .</target>
        </trans-unit>
        <trans-unit id="62939248d8e32365e6957d42055f2de89814a292" translate="yes" xml:space="preserve">
          <source>The command returns the index of matching elements inside a Redis list. By default, when no options are given, it will scan the list from head to tail, looking for the first match of &quot;element&quot;. If the element is found, its index (the zero-based position in the list) is returned. Otherwise, if no match is found, NULL is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f216246f788da7553b72042887561f848de4e55c" translate="yes" xml:space="preserve">
          <source>The command returns the integer representing the matching element, or null if there is no match. However, if the &lt;code&gt;COUNT&lt;/code&gt; option is given the command returns an array (empty if there are no matches).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a3d21f3dbcaa198bbe343d23738bbd28a872e1" translate="yes" xml:space="preserve">
          <source>The command returns the number of &lt;em&gt;failure reports&lt;/em&gt; for the specified node. Failure reports are the way Redis Cluster uses in order to promote a &lt;code&gt;PFAIL&lt;/code&gt; state, that means a node is not reachable, to a &lt;code&gt;FAIL&lt;/code&gt; state, that means that the majority of masters in the cluster agreed within a window of time that the node is not reachable.</source>
          <target state="translated">Команда возвращает количество &lt;em&gt;отчетов&lt;/em&gt; об &lt;em&gt;ошибках&lt;/em&gt; для указанного узла. Отчеты о сбоях - это способ, которым Redis Cluster использует для &lt;code&gt;PFAIL&lt;/code&gt; состояния PFAIL , что означает, что узел недоступен, в состояние &lt;code&gt;FAIL&lt;/code&gt; , что означает, что большинство мастеров в кластере согласились в течение определенного промежутка времени, что узел недоступен. достижимый.</target>
        </trans-unit>
        <trans-unit id="11d6963d3c757dd171e4446f81aa6fbb2b4f3cbe" translate="yes" xml:space="preserve">
          <source>The command returns the number of entries deleted from the stream.</source>
          <target state="translated">Команда возвращает количество удаленных из потока записей.</target>
        </trans-unit>
        <trans-unit id="90a0913f53aff4fc9a2c5f477057692b16cb61c2" translate="yes" xml:space="preserve">
          <source>The command returns the number of messages successfully acknowledged. Certain message IDs may no longer be part of the PEL (for example because they have been already acknowledge), and XACK will not count them as successfully acknowledged.</source>
          <target state="translated">Команда возвращает количество успешно подтвержденных сообщений.Некоторые идентификаторы сообщений могут больше не быть частью PEL (например,потому что они уже были подтверждены),и XACK не будет считать их успешно подтвержденными.</target>
        </trans-unit>
        <trans-unit id="25862d0137651f4c50c642c84cec4c703a39cc67" translate="yes" xml:space="preserve">
          <source>The command returns the position of the first bit set to 1 or 0 according to the request.</source>
          <target state="translated">Команда возвращает позицию первого бита,установленную в соответствии с запросом на 1 или 0.</target>
        </trans-unit>
        <trans-unit id="0f2fe335e56363e46ba8079d81809ab997be12eb" translate="yes" xml:space="preserve">
          <source>The command returns the stream entries matching a given range of IDs. The range is specified by a minimum and maximum ID. All the entires having an ID between the two specified or exactly one of the two IDs specified (closed interval) are returned.</source>
          <target state="translated">Команда возвращает записи потока,соответствующие заданному диапазону идентификаторов.Диапазон задается минимальным и максимальным ID.Возвращаются все права,имеющие ID между двумя указанными или точно один из двух указанных ID (закрытый интервал).</target>
        </trans-unit>
        <trans-unit id="383ccd477dc944e0c3ebd47dbea4b6b2017eb35b" translate="yes" xml:space="preserve">
          <source>The command returns the stream entries matching a given range of IDs. The range is specified by a minimum and maximum ID. All the entries having an ID between the two specified or exactly one of the two IDs specified (closed interval) are returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be8f3674812a7bb5d9fb3101b17c38b3646405b" translate="yes" xml:space="preserve">
          <source>The command shows a list of all the usernames of the currently configured users in the Redis ACL system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13c06047a0b602e177d71981a4d9e29349f77a37" translate="yes" xml:space="preserve">
          <source>The command shows a list of recent ACL security events:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2382a9cd868ca3bdb3953efcef5f79ded0789a3c" translate="yes" xml:space="preserve">
          <source>The command shows the available ACL categories if called without arguments. If a category name is given, the command shows all the Redis commands in the specified category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724b74eeaa692174c50661ecd1cc035a30521473" translate="yes" xml:space="preserve">
          <source>The command shows the currently active ACL rules in the Redis server. Each line in the returned array defines a different user, and the format is the same used in the redis.conf file or the external ACL file, so you can cut and paste what is returned by the ACL LIST command directly inside a configuration file if you wish (but make sure to check &lt;a href=&quot;acl-save&quot;&gt;ACL SAVE&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b22d366f18019ba16fe8b5883618685376f0fb" translate="yes" xml:space="preserve">
          <source>The command takes arguments in the standard format x,y so the longitude must be specified before the latitude. There are limits to the coordinates that can be indexed: areas very near to the poles are not indexable. The exact limits, as specified by EPSG:900913 / EPSG:3785 / OSGEO:41001 are the following:</source>
          <target state="translated">Команда принимает аргументы в стандартном формате x,y поэтому долгота должна быть указана перед широтой.Существуют пределы координат,которые могут быть проиндексированы:области,находящиеся в непосредственной близости от полюсов,не могут быть проиндексированы.Точные ограничения,заданные EPSG:900913/EPSG:3785/OSGEO:41001,следующие:</target>
        </trans-unit>
        <trans-unit id="69e46f6ba0a5d03f8dc0e5aa7af7b003d2e71820" translate="yes" xml:space="preserve">
          <source>The command treats a Redis string as a array of bits, and is capable of addressing specific integer fields of varying bit widths and arbitrary non (necessary) aligned offset. In practical terms using this command you can set, for example, a signed 5 bits integer at bit offset 1234 to a specific value, retrieve a 31 bit unsigned integer from offset 4567. Similarly the command handles increments and decrements of the specified integers, providing guaranteed and well specified overflow and underflow behavior that the user can configure.</source>
          <target state="translated">Команда рассматривает строку Redis как массив битов и способна обращаться к определенным целочисленным полям различной ширины битов и произвольному не выровненному (необходимому)смещению.На практике с помощью этой команды можно задать,например,знаковое 5-битное целое число со смещением битов 1234 к конкретному значению,получить 31-битное неподписанное целое число со смещением 4567.Аналогично команда обрабатывает инкременты и декременты указанных целых чисел,обеспечивая гарантированное и хорошо заданное поведение при переполнении и недополнении,которое пользователь может настроить.</target>
        </trans-unit>
        <trans-unit id="13c5fae6e8ea2d19068840627307808e57ed434f" translate="yes" xml:space="preserve">
          <source>The command will fail if the specified node is not known or if it is not a master according to the node table of the node receiving the command.</source>
          <target state="translated">Команда будет неудачной,если указанный узел неизвестен или если он не является ведущим по таблице узлов узла,принимающего команду.</target>
        </trans-unit>
        <trans-unit id="83094ac4a33e4188f42d4a2c20d7dbf3f6620df3" translate="yes" xml:space="preserve">
          <source>The command will report an error when the user attempts to index coordinates outside the specified ranges.</source>
          <target state="translated">Команда сообщит об ошибке,когда пользователь попытается индексировать координаты за пределами заданных диапазонов.</target>
        </trans-unit>
        <trans-unit id="c3184d09a508b5c6fdb922b8b826ae4f98d9a67a" translate="yes" xml:space="preserve">
          <source>The command will return up to 160 timestamp-latency pairs for the &lt;code&gt;event&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a427adc7c29c84562496f4e3dd746f3b4883cbf" translate="yes" xml:space="preserve">
          <source>The command with its set of subcommands is useful in order to start and end cluster live resharding operations, which are accomplished by setting a hash slot in migrating state in the source node, and importing state in the destination node.</source>
          <target state="translated">Команда с ее набором подкоманд полезна для начала и окончания операций по перезагрузке кластера в реальном времени,которые выполняются установкой хэш-слота в состоянии миграции на исходном узле,и импортом состояния на целевом узле.</target>
        </trans-unit>
        <trans-unit id="f34a45ceabab28f1008f0f9d2405fbba32c8e338" translate="yes" xml:space="preserve">
          <source>The command works in the same way even if the script was already present in the script cache.</source>
          <target state="translated">Команда работает таким же образом,даже если скрипт уже присутствовал в кэше скриптов.</target>
        </trans-unit>
        <trans-unit id="58212b0000147d5bba3264e4996ad46fd286b905" translate="yes" xml:space="preserve">
          <source>The common use case for this command is to retrieve geospatial items near a specified point not farther than a given amount of meters (or other units). This allows, for example, to suggest mobile users of an application nearby places.</source>
          <target state="translated">Обычным случаем использования данной команды является извлечение геопространственных объектов вблизи определенной точки не дальше заданного количества метров (или других единиц).Это позволяет,например,предложить мобильным пользователям приложение в близлежащих местах.</target>
        </trans-unit>
        <trans-unit id="83d84f2e6d0bc285dccf475994bf2dfe5a7034d1" translate="yes" xml:space="preserve">
          <source>The computed merged HyperLogLog is set to the destination variable, which is created if does not exist (defaulting to an empty HyperLogLog).</source>
          <target state="translated">Вычисленный объединенный HyperLogLog имеет значение переменной назначения,которая создается,если она не существует (по умолчанию пустой HyperLogLogLog).</target>
        </trans-unit>
        <trans-unit id="892b6264b392f8ad48dfbfcfe6dff8a94a45c598" translate="yes" xml:space="preserve">
          <source>The configuration can be done by editing &lt;code&gt;redis.conf&lt;/code&gt; or while the server is running using the &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; and &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; commands.</source>
          <target state="translated">Конфигурация может быть выполнена путем редактирования &lt;code&gt;redis.conf&lt;/code&gt; или во время работы сервера с помощью команд &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; и &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9924fa1c31458da66b46121ed81593fd5a4fbad" translate="yes" xml:space="preserve">
          <source>The connection name can be inspected using &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt;.</source>
          <target state="translated">Имя соединения можно проверить с помощью &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6da99886277806746e8e984d617153310b22b176" translate="yes" xml:space="preserve">
          <source>The connection we have with the server is persistent and was never closed so far.</source>
          <target state="translated">Соединение,которое у нас есть с сервером,является постоянным и до сих пор не было закрыто.</target>
        </trans-unit>
        <trans-unit id="812045821e03fcc1f9ffc04b5ef35de3b612856e" translate="yes" xml:space="preserve">
          <source>The consumer group will be destroyed even if there are active consumers and pending messages, so make sure to call this command only when really needed.</source>
          <target state="translated">Группа потребителей будет уничтожена,даже если есть активные потребители и отложенные сообщения,поэтому обязательно вызывайте эту команду только тогда,когда это действительно необходимо.</target>
        </trans-unit>
        <trans-unit id="8d4c2cd743047005cdb993a3a9d7afc356bb6664" translate="yes" xml:space="preserve">
          <source>The consumer will do:</source>
          <target state="translated">Потребитель сделает:</target>
        </trans-unit>
        <trans-unit id="a09ada6e198e1cc27a58e1c5cd2063765d34a60e" translate="yes" xml:space="preserve">
          <source>The coordinates as a two items x,y array (longitude,latitude).</source>
          <target state="translated">Координаты как два элемента массива x,y (долгота,широта).</target>
        </trans-unit>
        <trans-unit id="d6f85adf1bad41bef7242defbfacbfdea663e0f0" translate="yes" xml:space="preserve">
          <source>The counter is created in a way that it only will survive one second, starting from the first request performed in the current second. If there are more than 10 requests in the same second the counter will reach a value greater than 10, otherwise it will expire and start again from 0.</source>
          <target state="translated">Счетчик создается таким образом,что выдерживает только одну секунду,начиная с первого запроса,выполненного в текущей второй.Если в одной и той же секунде поступит более 10 запросов,счетчик достигнет значения больше 10,в противном случае срок его действия истечет и начнется заново с 0.</target>
        </trans-unit>
        <trans-unit id="224e5c836dc00eb5744ec82792c094203a16fc27" translate="yes" xml:space="preserve">
          <source>The counter pattern is the most obvious thing you can do with Redis atomic increment operations. The idea is simply send an &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; command to Redis every time an operation occurs. For instance in a web application we may want to know how many page views this user did every day of the year.</source>
          <target state="translated">Шаблон счетчика - наиболее очевидная вещь, которую вы можете сделать с помощью операций атомарного приращения Redis. Идея состоит в том, чтобы просто отправлять команду &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; в Redis каждый раз, когда происходит операция. Например, в веб-приложении мы можем захотеть узнать, сколько просмотров страниц этот пользователь делал каждый день в году.</target>
        </trans-unit>
        <trans-unit id="b77e139112433671a542addfa1a32daf47ee322d" translate="yes" xml:space="preserve">
          <source>The crashed client C3 still holds it, so Redis will reply with &lt;code&gt;0&lt;/code&gt; to C4.</source>
          <target state="translated">Сбойный клиент C3 по-прежнему держит его, поэтому Redis ответит &lt;code&gt;0&lt;/code&gt; на C4.</target>
        </trans-unit>
        <trans-unit id="8423b58d7e3aaab1a157d34537088cf7071837ad" translate="yes" xml:space="preserve">
          <source>The current field content or the specified increment are not parsable as a double precision floating point number.</source>
          <target state="translated">Текущее содержимое поля или указанный приращение не разбивается на число с плавающей точкой двойной точности.</target>
        </trans-unit>
        <trans-unit id="838fa5216f1f1cdff3694527a8a6d1c1f9f94411" translate="yes" xml:space="preserve">
          <source>The current key content or the specified increment are not parsable as a double precision floating point number.</source>
          <target state="translated">Текущее содержание ключа или указанный приращение не разбивается на число с плавающей точкой двойной точности.</target>
        </trans-unit>
        <trans-unit id="931ea7e75c2dded718677c9f4a1676825fcb3baa" translate="yes" xml:space="preserve">
          <source>The current master replication offset, which is an offset that masters and replicas share to understand, in partial resynchronizations, the part of the replication stream the replicas needs to fetch to continue.</source>
          <target state="translated">Текущее смещение репликации мастера,которое является смещением,совместно используемым мастерами и репликами для понимания,при частичной ресинхронизации,той части потока репликации,которую реплики должны получить для продолжения.</target>
        </trans-unit>
        <trans-unit id="b7064688c0f4d788a94324f8ce3624a598ba7058" translate="yes" xml:space="preserve">
          <source>The current score of an element can be retrieved using the &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; command, that can also be used to verify if an element already exists or not.</source>
          <target state="translated">&lt;a href=&quot;zscore&quot;&gt;Текущую&lt;/a&gt; оценку элемента можно получить с помощью команды ZSCORE , которая также может использоваться для проверки того, существует ли элемент уже или нет.</target>
        </trans-unit>
        <trans-unit id="30d1eb14ec245a20077a7d25213dc588a8512c5c" translate="yes" xml:space="preserve">
          <source>The cursor returned by the previous call to SCAN in order to continue the iteration.</source>
          <target state="translated">Курсор,возвращенный при предыдущем вызове SCAN для продолжения итерации.</target>
        </trans-unit>
        <trans-unit id="219c36e5291d2c3051ee7cf69aa75399bb2fc52c" translate="yes" xml:space="preserve">
          <source>The cursor value of 0 when starting an iteration.</source>
          <target state="translated">Значение курсора 0 при запуске итерации.</target>
        </trans-unit>
        <trans-unit id="93cb8fd7598a4e9c87b91141380a4bde0e9f7ad1" translate="yes" xml:space="preserve">
          <source>The default COUNT value is 10.</source>
          <target state="translated">По умолчанию значение COUNT равно 10.</target>
        </trans-unit>
        <trans-unit id="1472348f89b9c094e365f856bf74ca11dcb1cdde" translate="yes" xml:space="preserve">
          <source>The deliveries counter, that is the fourth element in the array, is incremented when some other consumer &lt;em&gt;claims&lt;/em&gt; the message with &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;, or when the message is delivered again via &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;, when accessing the history of a consumer in a consumer group (see the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; page for more info).</source>
          <target state="translated">Поставки счетчик, то есть четвертый элемент в массиве, увеличивается , когда какой -либо другой потребитель &lt;em&gt;утверждает&lt;/em&gt; , что сообщение с &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; , или когда сообщение будет доставлено снова через &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; , при обращении к истории потребителя в группе потребителей (см &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; страницу для получения дополнительной информации).</target>
        </trans-unit>
        <trans-unit id="c29b8b8f823cca94ef6ad774fed42578a146e94a" translate="yes" xml:space="preserve">
          <source>The difference between this command and the vanilla &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; is that this one supports consumer groups.</source>
          <target state="translated">Разница между этой командой и &lt;a href=&quot;xread&quot;&gt;обычной XREAD в&lt;/a&gt; том, что она поддерживает группы потребителей.</target>
        </trans-unit>
        <trans-unit id="3c1c5811c1d1a274026dcc95a504bdc2dd6d5a09" translate="yes" xml:space="preserve">
          <source>The distance from the center as a floating point number, in the same unit specified in the radius.</source>
          <target state="translated">Расстояние от центра в виде числа с плавающей точкой,в той же единице,которая указана в радиусе.</target>
        </trans-unit>
        <trans-unit id="e1121b0e8297b7fecce16b935b4718ce15930933" translate="yes" xml:space="preserve">
          <source>The distance from the center as a floating point number, in the same unit specified in the shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3afe599a4181bcd5a732c0ec177cb011be65df41" translate="yes" xml:space="preserve">
          <source>The distance is computed assuming that the Earth is a perfect sphere, so errors up to 0.5% are possible in edge cases.</source>
          <target state="translated">Расстояние вычисляется в предположении,что Земля является идеальной сферой,поэтому ошибки до 0.5% возможны в краевых случаях.</target>
        </trans-unit>
        <trans-unit id="a8be9ff0b07a549071a611002c4a08732b5c80a8" translate="yes" xml:space="preserve">
          <source>The distribution of the returned elements is far from perfect when the number of elements in the set is small, this is due to the fact that we used an approximated random element function that does not really guarantees good distribution.</source>
          <target state="translated">Распределение возвращаемых элементов далеко не идеально,когда количество элементов в наборе мало,это связано с тем,что мы использовали аппроксимированную функцию случайных элементов,которая на самом деле не гарантирует хорошее распределение.</target>
        </trans-unit>
        <trans-unit id="e2451d0313184cb7cb1bfd5f5707106d6b571329" translate="yes" xml:space="preserve">
          <source>The elements are considered to be ordered from lower to higher strings as compared byte-by-byte using the &lt;code&gt;memcmp()&lt;/code&gt; C function. Longer strings are considered greater than shorter strings if the common part is identical.</source>
          <target state="translated">Считается, что элементы упорядочены от младших к &lt;code&gt;memcmp()&lt;/code&gt; строкам по сравнению побайтно с использованием функции C memcmp () . Более длинные строки считаются более короткими, если общая часть идентична.</target>
        </trans-unit>
        <trans-unit id="7dd12a75b48ac332a2dfe23f1549d87b855bfd6d" translate="yes" xml:space="preserve">
          <source>The elements having the same score are returned in lexicographical order (this follows from a property of the sorted set implementation in Redis and does not involve further computation).</source>
          <target state="translated">Элементы,имеющие одинаковую оценку,возвращаются в лексикографическом порядке (это вытекает из свойства реализации отсортированного набора в Redis и не требует дополнительных вычислений).</target>
        </trans-unit>
        <trans-unit id="12d2f968d07516f9654dcc50b588d898c0361273" translate="yes" xml:space="preserve">
          <source>The elements having the same score are returned in reverse lexicographical order.</source>
          <target state="translated">Элементы,имеющие одинаковую оценку,возвращаются в обратном лексикографическом порядке.</target>
        </trans-unit>
        <trans-unit id="8a7336e9649584aeb5dd7541a2422de663fa783e" translate="yes" xml:space="preserve">
          <source>The entry's unique ID can be used in order to avoid processing slow log entries multiple times (for instance you may have a script sending you an email alert for every new slow log entry).</source>
          <target state="translated">Уникальный ID записи может быть использован для того,чтобы избежать обработки медленных записей журнала несколько раз (например,у вас может быть скрипт,посылающий вам предупреждение по электронной почте для каждой новой записи медленного журнала).</target>
        </trans-unit>
        <trans-unit id="4c3c6b922261a4a3c02503cd2200bbc2e1969187" translate="yes" xml:space="preserve">
          <source>The exact behavior of this command is identical to the one of the &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; command, please refer to the documentation of &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; for further information.</source>
          <target state="translated">Точное поведение этой команды идентично один из &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; команды, пожалуйста , обратитесь к документации &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="81ef5cb9ba6108b82ece4143c01d73481b4f607e" translate="yes" xml:space="preserve">
          <source>The fact that the user can count on Redis not removing scripts is semantically useful in the context of pipelining.</source>
          <target state="translated">Тот факт,что пользователь может рассчитывать на то,что Redis не удалит скрипты,семантически полезен в контексте обвязки.</target>
        </trans-unit>
        <trans-unit id="a0c00c319cfd875c00a2280921682c92066dd97a" translate="yes" xml:space="preserve">
          <source>The feature will remain active in the current connection for all its life, unless tracking is turned on with &lt;code&gt;CLIENT TRACKING off&lt;/code&gt; at some point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccad1b83c48c6dc04cc17404f3912c32d936c720" translate="yes" xml:space="preserve">
          <source>The field contains a value of the wrong type (not a string).</source>
          <target state="translated">Поле содержит значение неправильного типа (не строку).</target>
        </trans-unit>
        <trans-unit id="6058628e04e98718045db43e11d253a6db12f594" translate="yes" xml:space="preserve">
          <source>The file descriptor events can be:</source>
          <target state="translated">События с дескрипторами файлов могут быть:</target>
        </trans-unit>
        <trans-unit id="d4261d3e5eb2c06f28ad9faa68309fdf262f21cb" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is a Lua 5.1 script. The script does not need to define a Lua function (and should not). It is just a Lua program that will run in the context of the Redis server.</source>
          <target state="translated">Первый аргумент &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; - это сценарий Lua 5.1. Сценарий не должен определять функцию Lua (и не должен). Это просто программа Lua, которая будет работать в контексте сервера Redis.</target>
        </trans-unit>
        <trans-unit id="46870f99efa0c3b2959dcb93e1e13013212f023d" translate="yes" xml:space="preserve">
          <source>The first argument of the command selects the algorithm to use, right now the argument must be &quot;LCS&quot;, since this is the only implemented one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647fb34e5b11b941bb5e49ce5d7abfd78a858447" translate="yes" xml:space="preserve">
          <source>The first case will return the first 10 (or less) PEL entries of the entire group that are idle for over 9 seconds, whereas in the second case only those of &lt;code&gt;consumer-123&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cbda77e6bd32de6a17a5ed2d8395d40439856eb" translate="yes" xml:space="preserve">
          <source>The following are a few examples of importing and migrating slots:</source>
          <target state="translated">Ниже приведены несколько примеров импортирования и миграции слотов:</target>
        </trans-unit>
        <trans-unit id="6c3d5dc29a069636be48f90bb368850ce3fda788" translate="yes" xml:space="preserve">
          <source>The following are the list of options that modify the behavior of the command when enabling tracking:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b94aea73b4255f0bc659c9805b5380b0565b107" translate="yes" xml:space="preserve">
          <source>The following command removes the association for slots 5000 and 5001 from the node receiving the command:</source>
          <target state="translated">Следующая команда удаляет ассоциацию для слотов 5000 и 5001 из узла,принимающего команду:</target>
        </trans-unit>
        <trans-unit id="784815ebd70c0fe925bcd60bddc497d55949fa3a" translate="yes" xml:space="preserve">
          <source>The following documentation is a reference manual about the capabilities of this command, however our &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACL tutorial&lt;/a&gt; may be a more gentle introduction to how the ACL system works in general.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00075a28fdc9ff572c3eac87bcaf7c44d932e7da" translate="yes" xml:space="preserve">
          <source>The following example should clarify what stated above:</source>
          <target state="translated">Следующий пример должен прояснить то,что было сказано выше:</target>
        </trans-unit>
        <trans-unit id="1ec034b27145454749448bb4c66e40315aa13e2f" translate="yes" xml:space="preserve">
          <source>The following example using &lt;code&gt;WITHSCORES&lt;/code&gt; shows how the command returns always an array, but this time, populated with &lt;em&gt;element_1&lt;/em&gt;, &lt;em&gt;score_1&lt;/em&gt;, &lt;em&gt;element_2&lt;/em&gt;, &lt;em&gt;score_2&lt;/em&gt;, ..., &lt;em&gt;element_N&lt;/em&gt;, &lt;em&gt;score_N&lt;/em&gt;.</source>
          <target state="translated">В следующем примере с использованием &lt;code&gt;WITHSCORES&lt;/code&gt; показано, как команда всегда возвращает массив, но на этот раз заполненный &lt;em&gt;элементами &lt;/em&gt;&lt;em&gt;element_1&lt;/em&gt; , &lt;em&gt;score_1&lt;/em&gt; , &lt;em&gt;element_2&lt;/em&gt; , &lt;em&gt;score_2&lt;/em&gt; , ..., &lt;em&gt;element_N&lt;/em&gt; , &lt;em&gt;score_N&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="69face26cb0b6283ed9eddef9110c599dd9ae6eb" translate="yes" xml:space="preserve">
          <source>The following field is always provided:</source>
          <target state="translated">Всегда указывается следующее поле:</target>
        </trans-unit>
        <trans-unit id="5fede26fc672e9d5137b89bc60a98de02e5d6528" translate="yes" xml:space="preserve">
          <source>The following is an example of &lt;code&gt;OVERFLOW FAIL&lt;/code&gt; returning NULL.</source>
          <target state="translated">Ниже приведен пример, когда &lt;code&gt;OVERFLOW FAIL&lt;/code&gt; возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="f26894ffa2e5bfa52e8acebe022822e6a159ac5d" translate="yes" xml:space="preserve">
          <source>The following is the list of supported commands.</source>
          <target state="translated">Ниже приведен список поддерживаемых команд.</target>
        </trans-unit>
        <trans-unit id="487db5ff0187b77e2cfe37d8572892092c01e33a" translate="yes" xml:space="preserve">
          <source>The following pattern is discouraged in favor of &lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;the Redlock algorithm&lt;/a&gt; which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.</source>
          <target state="translated">Следующий шаблон не рекомендуется в пользу &lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;алгоритма Redlock,&lt;/a&gt; который лишь немного сложнее реализовать, но предлагает лучшие гарантии и является отказоустойчивым.</target>
        </trans-unit>
        <trans-unit id="8e9fc798f24c122b5b0b23c06739d7c4c95610dd" translate="yes" xml:space="preserve">
          <source>The following pattern is discouraged in favor of &lt;a href=&quot;https://redis.io/topics/distlock&quot;&gt;the Redlock algorithm&lt;/a&gt; which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685c86199b8431155924b73d00e71167faabb72e" translate="yes" xml:space="preserve">
          <source>The form &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE will stop replication, turning the server into a MASTER, but will not discard the replication. So, if the old master stops working, it is possible to turn the replica into a master and set the application to use this new master in read/write. Later when the other Redis server is fixed, it can be reconfigured to work as a replica.</source>
          <target state="translated">Форма &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE остановит репликацию, превратив сервер в МАСТЕР, но не отбросит репликацию. Итак, если старый мастер перестает работать, можно превратить реплику в мастер и настроить приложение на использование этого нового мастера при чтении / записи. Позже, когда другой сервер Redis будет исправлен, его можно будет перенастроить для работы в качестве реплики.</target>
        </trans-unit>
        <trans-unit id="2a758769f42fa16fd49a6c65e260a443efa58858" translate="yes" xml:space="preserve">
          <source>The form &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE will stop replication, turning the server into a MASTER, but will not discard the replication. So, if the old master stops working, it is possible to turn the replica into a master and set the application to use this new master in read/write. Later when the other Redis server is fixed, it can be reconfigured to work as a replica.</source>
          <target state="translated">Форма &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE остановит репликацию, превратив сервер в MASTER, но не отбросит репликацию. Итак, если старый мастер перестает работать, можно превратить реплику в мастер и настроить приложение на использование этого нового мастера при чтении / записи. Позже, когда другой сервер Redis будет исправлен, его можно будет перенастроить для работы в качестве реплики.</target>
        </trans-unit>
        <trans-unit id="cfb81787e75be423c5bbd1da337f47a738269c3b" translate="yes" xml:space="preserve">
          <source>The function handles out of range requests by limiting the resulting range to the actual length of the string.</source>
          <target state="translated">Функция обрабатывает запросы вне диапазона,ограничивая результирующий диапазон фактической длиной строки.</target>
        </trans-unit>
        <trans-unit id="bae822e06654577340df39aec8c279a41923dbdf" translate="yes" xml:space="preserve">
          <source>The function returns true if the script effects replication was enabled, otherwise if the function was called after the script already called some write command, it returns false, and normal whole script replication is used.</source>
          <target state="translated">Функция возвращает true,если репликация сценарных эффектов была включена,в противном случае,если функция была вызвана после того,как сценарий уже вызвал некоторые команды записи,он возвращает false,и нормальный весь сценарий репликации используется.</target>
        </trans-unit>
        <trans-unit id="e3d352c9158e45827d58fa0bb1daa62cb827202a" translate="yes" xml:space="preserve">
          <source>The geohash integer.</source>
          <target state="translated">Целое геохаш.</target>
        </trans-unit>
        <trans-unit id="a74105f90399289d271dac87ebbc775e37f16a9d" translate="yes" xml:space="preserve">
          <source>The graph is normalized in the min-max scale so that the zero (the underscore in the lower row) is the minimum, and a # in the higher row is the maximum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1802968f15db7e03ec0c89118a7963b7fbc9d55a" translate="yes" xml:space="preserve">
          <source>The group name is just the name of a consumer group associated to the stream. The group is created using the &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; command. The consumer name is the string that is used by the client to identify itself inside the group. The consumer is auto created inside the consumer group the first time it is saw. Different clients should select a different consumer name.</source>
          <target state="translated">Имя группы - это просто имя группы потребителей, связанной с потоком. Группа создается с помощью команды &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; . Имя потребителя - это строка, которая используется клиентом для идентификации себя внутри группы. Потребитель автоматически создается внутри группы потребителей при первом просмотре. Разным клиентам следует выбирать разные имена потребителей.</target>
        </trans-unit>
        <trans-unit id="9501214421f828fe1bcfe6cfb269ae7881da1706" translate="yes" xml:space="preserve">
          <source>The id of the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dfb24eb9709d7c83208076fd77b0d419da27db0" translate="yes" xml:space="preserve">
          <source>The information about memory usage is provided as metrics and their respective values. The following metrics are reported:</source>
          <target state="translated">Информация об использовании памяти предоставляется в виде метрик и соответствующих им значений.Сообщаются следующие метрики:</target>
        </trans-unit>
        <trans-unit id="34a2e40e15b32f6149b206a299f7840113d10818" translate="yes" xml:space="preserve">
          <source>The key contains a value of the wrong type (not a string).</source>
          <target state="translated">Ключ содержит значение неправильного типа (не строку).</target>
        </trans-unit>
        <trans-unit id="09d97b8e7dc4c8276b96f5602bc74dea1d0e36c5" translate="yes" xml:space="preserve">
          <source>The key may be on both the instances.</source>
          <target state="translated">Ключ может быть на обоих случаях.</target>
        </trans-unit>
        <trans-unit id="317c7c0e8fc5ce228ab50cadfc186268268a73ba" translate="yes" xml:space="preserve">
          <source>The key may be only in the source instance.</source>
          <target state="translated">Ключ может быть только в исходном экземпляре.</target>
        </trans-unit>
        <trans-unit id="770d7559e7b2fdc7128e6105d19ea9ca36a0376e" translate="yes" xml:space="preserve">
          <source>The key time to live can be updated or entirely removed using the &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; and &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; command (or other strictly related commands).</source>
          <target state="translated">Ключевое время жизни может быть обновлено или полностью удалено с помощью &lt;a href=&quot;expire&quot;&gt;команд EXPIRE&lt;/a&gt; и &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; (или других строго связанных команд).</target>
        </trans-unit>
        <trans-unit id="547c694280239130253479a419ced5c053003ea8" translate="yes" xml:space="preserve">
          <source>The last ID returned is &lt;code&gt;1526985712947-0&lt;/code&gt;, since the sequence number is already zero, the next ID I'll use instead of the &lt;code&gt;+&lt;/code&gt; special ID will be &lt;code&gt;1526985712946-18446744073709551615&lt;/code&gt;, or just &lt;code&gt;18446744073709551615&lt;/code&gt;:</source>
          <target state="translated">Последний возвращенный идентификатор - &lt;code&gt;1526985712947-0&lt;/code&gt; , поскольку порядковый номер уже равен нулю, следующим идентификатором, который я буду использовать вместо специального идентификатора &lt;code&gt;+&lt;/code&gt; , будет &lt;code&gt;1526985712946-18446744073709551615&lt;/code&gt; , или просто &lt;code&gt;18446744073709551615&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="11471f50fbf81f6258a27201c930e977959ad0cd" translate="yes" xml:space="preserve">
          <source>The last argument is the ID of the last item in the stream to consider already delivered. In the above case we used the special ID '$' (that means: the ID of the last item in the stream). In this case the consumers fetching data from that consumer group will only see new elements arriving in the stream.</source>
          <target state="translated">Последним аргументом является идентификатор последнего элемента в потоке для рассмотрения уже доставленного.В приведенном выше случае мы использовали специальный идентификатор '$' (т.е.ID последнего элемента в потоке).В этом случае потребители,получающие данные от этой группы потребителей,будут видеть только новые элементы,поступающие в поток.</target>
        </trans-unit>
        <trans-unit id="42e7923c299c01e54ed6170cd5e8fc34b5599898" translate="yes" xml:space="preserve">
          <source>The last example shows how it is possible to receive the exact return value of &lt;code&gt;redis.call()&lt;/code&gt; or &lt;code&gt;redis.pcall()&lt;/code&gt; from Lua that would be returned if the command was called directly.</source>
          <target state="translated">Последний пример показывает, как можно получить точное возвращаемое значение &lt;code&gt;redis.call()&lt;/code&gt; или &lt;code&gt;redis.pcall()&lt;/code&gt; из Lua, которое было бы возвращено, если бы команда была вызвана напрямую.</target>
        </trans-unit>
        <trans-unit id="898edad6fe267446764a3f01813e23c34e6a4dc9" translate="yes" xml:space="preserve">
          <source>The lexicographic ordering used is binary, it compares strings as array of bytes.</source>
          <target state="translated">Используемая лексикографическая последовательность является двоичной,она сравнивает строки в виде массива байт.</target>
        </trans-unit>
        <trans-unit id="e89335ad1d56e8f847f0e52f7c837e0cf165daeb" translate="yes" xml:space="preserve">
          <source>The limitation of this pattern is that we are forced into an append-only mode of operation, there is no way to cut the time series to a given size easily because Redis currently lacks a command able to trim string objects. However the space efficiency of time series stored in this way is remarkable.</source>
          <target state="translated">Ограничение этого шаблона состоит в том,что мы вынуждены работать в режиме только для приложений,нет возможности легко обрезать временные ряды до заданного размера,так как в настоящее время в Redis отсутствует команда,способная обрезать строковые объекты.Однако эффективность использования пространства хранимых таким образом временных рядов примечательна.</target>
        </trans-unit>
        <trans-unit id="da33cd971f0747462e42ccd2282a1e6fb83aa7be" translate="yes" xml:space="preserve">
          <source>The list of configuration parameters supported by &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; can be obtained issuing a &lt;code&gt;CONFIG GET *&lt;/code&gt; command, that is the symmetrical command used to obtain information about the configuration of a running Redis instance.</source>
          <target state="translated">Список параметров конфигурации, поддерживаемых &lt;a href=&quot;config-set&quot;&gt;CONFIG SET,&lt;/a&gt; можно получить, &lt;code&gt;CONFIG GET *&lt;/code&gt; команду CONFIG GET * , то есть симметричную команду, используемую для получения информации о конфигурации запущенного экземпляра Redis.</target>
        </trans-unit>
        <trans-unit id="8095634a38168f2c281c9616bbb338721d7efd28" translate="yes" xml:space="preserve">
          <source>The lock will be auto-released after the expire time is reached.</source>
          <target state="translated">Замок будет автоматически снят по истечении времени истечения срока годности.</target>
        </trans-unit>
        <trans-unit id="08a7894ad23c8503b151cc8bfa325bf87f080cfd" translate="yes" xml:space="preserve">
          <source>The main drawback with the &lt;em&gt;whole scripts replication&lt;/em&gt; approach is that scripts are required to have the following property:</source>
          <target state="translated">Основным недостатком подхода к &lt;em&gt;репликации всего сценария&lt;/em&gt; является то, что сценарии должны обладать следующим свойством:</target>
        </trans-unit>
        <trans-unit id="7e2e2adfa0c27b3c4fcd6715d167f77cf7aab615" translate="yes" xml:space="preserve">
          <source>The main usage of this command is during rehashing of cluster slots from one node to another. The way the rehashing is performed is exposed in the Redis Cluster specification, or in a more simple to digest form, as an appendix of the &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; command documentation.</source>
          <target state="translated">В основном эта команда используется во время перехеширования слотов кластера с одного узла на другой. Способ выполнения &lt;a href=&quot;cluster-setslot&quot;&gt;повторного хеширования&lt;/a&gt; представлен в спецификации Redis Cluster или в более простой для восприятия форме в качестве приложения к документации команды CLUSTER SETSLOT .</target>
        </trans-unit>
        <trans-unit id="51aa615de4288430f4f542dd741b0be9823a9984" translate="yes" xml:space="preserve">
          <source>The master output is composed of the following parts:</source>
          <target state="translated">Выход ведущего устройства состоит из следующих частей:</target>
        </trans-unit>
        <trans-unit id="9294413196a1d66d0e89a267022407a00ed67b4f" translate="yes" xml:space="preserve">
          <source>The master replies to the replica with the current &lt;em&gt;replication offset&lt;/em&gt;.</source>
          <target state="translated">Мастер отвечает реплике с текущим &lt;em&gt;смещением репликации&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9aa0f4e849bf549de77dfa2bc7bf7ffcfaf99bf4" translate="yes" xml:space="preserve">
          <source>The meaning of &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are the same of the &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; command. Similarly, this command actually returns the same elements that &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; would return if called with the same &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments.</source>
          <target state="translated">Значение &lt;code&gt;min&lt;/code&gt; и &lt;code&gt;max&lt;/code&gt; такое же, как у команды &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; . Точно так же эта команда фактически возвращает те же элементы, которые &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; вернет при вызове с теми же аргументами &lt;code&gt;min&lt;/code&gt; и &lt;code&gt;max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e23ac08d91ce30fa5d8f4e6bbb8d1a66fed8600" translate="yes" xml:space="preserve">
          <source>The meaning of each filed is the following:</source>
          <target state="translated">Смысл каждой поданной заявки заключается в следующем:</target>
        </trans-unit>
        <trans-unit id="69174101963d6daf8e0c498390ca52d478774c02" translate="yes" xml:space="preserve">
          <source>The meaning of the two states is explained in the Redis Specification, however the gist of the two states is the following:</source>
          <target state="translated">Смысл этих двух состояний объясняется в Спецификации Рэдиса,однако суть этих двух состояний заключается в следующем:</target>
        </trans-unit>
        <trans-unit id="5fe7d63b1ebc573c80de8db8907af87f4669998b" translate="yes" xml:space="preserve">
          <source>The more simple and direct implementation of this pattern is the following:</source>
          <target state="translated">Более простая и непосредственная реализация этой схемы заключается в следующем:</target>
        </trans-unit>
        <trans-unit id="8eafae6da4cd26a48b49e41708a6136f1a6de4a6" translate="yes" xml:space="preserve">
          <source>The motivation for this command is that the ability to store many small integers as a single large bitmap (or segmented over a few keys to avoid having huge keys) is extremely memory efficient, and opens new use cases for Redis to be applied, especially in the field of real time analytics. This use cases are supported by the ability to specify the overflow in a controlled way.</source>
          <target state="translated">Мотивация этой команды заключается в том,что возможность хранить много маленьких целых чисел в виде одной большой растровой карты (или сегментированной по нескольким клавишам,чтобы избежать наличия огромных клавиш)чрезвычайно эффективна с точки зрения памяти,и открывает новые возможности для применения Redis,особенно в области анализа в реальном времени.Такие сценарии использования поддерживаются возможностью задавать переполнение контролируемым способом.</target>
        </trans-unit>
        <trans-unit id="8a6f6dffc18be981185e9a84435cd70cbbe693b9" translate="yes" xml:space="preserve">
          <source>The name of the consumer that fetched the message and has still to acknowledge it. We call it the current &lt;em&gt;owner&lt;/em&gt; of the message.</source>
          <target state="translated">Имя потребителя, который получил сообщение и еще не подтвердил его. Мы называем его текущим &lt;em&gt;владельцем&lt;/em&gt; сообщения.</target>
        </trans-unit>
        <trans-unit id="95a0cef10627d21f971cf58ca481b45ed9811331" translate="yes" xml:space="preserve">
          <source>The new configuration is persisted on disk in the node cluster configuration file.</source>
          <target state="translated">Новая конфигурация сохраняется на диске в файле конфигурации узлового кластера.</target>
        </trans-unit>
        <trans-unit id="ce3fd26b48bfdbc550ce60034f680213e04e3fa5" translate="yes" xml:space="preserve">
          <source>The new format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69cbd0fd1035f94debad3eb8086987173fc0e180" translate="yes" xml:space="preserve">
          <source>The new score of &lt;code&gt;member&lt;/code&gt; (a double precision floating point number) represented as string, or &lt;code&gt;nil&lt;/code&gt; if the operation was aborted (when called with either the &lt;code&gt;XX&lt;/code&gt; or the &lt;code&gt;NX&lt;/code&gt; option).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1512d4f9273a472bf5054bc09af80c7b583c9993" translate="yes" xml:space="preserve">
          <source>The node ID identifies the same node we are sending the command to.</source>
          <target state="translated">Идентификатор узла идентифицирует тот же узел,которому мы посылаем команду.</target>
        </trans-unit>
        <trans-unit id="4a94b0edb207a0f9aad4e9890ab6a41a4abc596d" translate="yes" xml:space="preserve">
          <source>The node ID of the removed node gets added to the ban-list, for 1 minute.</source>
          <target state="translated">Идентификатор удаленного узла добавляется в бан-лист,на 1 минуту.</target>
        </trans-unit>
        <trans-unit id="7282e91e365e1582b64fd77e649fb8fae6ff8480" translate="yes" xml:space="preserve">
          <source>The node current &lt;em&gt;config epoch&lt;/em&gt; is zero.</source>
          <target state="translated">&lt;em&gt;Эпоха&lt;/em&gt; текущей &lt;em&gt;конфигурации&lt;/em&gt; узла равна нулю.</target>
        </trans-unit>
        <trans-unit id="96c472bb576e96ca78ba9e6916a3879a69d9af69" translate="yes" xml:space="preserve">
          <source>The node is empty, no keys are stored at all in the key space.</source>
          <target state="translated">Узел пуст,в пространстве клавиш не хранятся никакие клавиши.</target>
        </trans-unit>
        <trans-unit id="c909806a718de9cb07358d8ed9ed00c019748494" translate="yes" xml:space="preserve">
          <source>The node is not serving any hash slots.</source>
          <target state="translated">Узел не обслуживает ни одного хэш-слота.</target>
        </trans-unit>
        <trans-unit id="ce819a3025f8ff3393901c2c8e810e36e0f1c69b" translate="yes" xml:space="preserve">
          <source>The node receiving the command is a replica, and the specified node ID identifies its current master.</source>
          <target state="translated">Узел,принимающий команду,является репликой,а указанный идентификатор узла идентифицирует его текущего ведущего.</target>
        </trans-unit>
        <trans-unit id="3debb3fa567694b78b44554108f738a7a81cf421" translate="yes" xml:space="preserve">
          <source>The node will skip all the node IDs listed in the ban-list when processing gossip sections received in heartbeat packets from other nodes.</source>
          <target state="translated">Узел пропустит все идентификаторы узлов,перечисленные в бан-листе при обработке сплетен,полученных в пульсирующих пакетах от других узлов.</target>
        </trans-unit>
        <trans-unit id="a02415f9a093ecefd5c824168bfb43638285dd33" translate="yes" xml:space="preserve">
          <source>The nodes table of the node is empty.</source>
          <target state="translated">Таблица узлов узла пуста.</target>
        </trans-unit>
        <trans-unit id="a21d4be2cd3c8386a5bd51f51d8e281923d2f322" translate="yes" xml:space="preserve">
          <source>The number of bits set to 1.</source>
          <target state="translated">Количество битов установлено на 1.</target>
        </trans-unit>
        <trans-unit id="59385708853390f9ca74251fea5131270265eecd" translate="yes" xml:space="preserve">
          <source>The number of elements added to the sorted set, not including elements already existing for which the score was updated.</source>
          <target state="translated">Количество элементов,добавленных в отсортированный набор,без учета уже существующих элементов,по которым был обновлен счет.</target>
        </trans-unit>
        <trans-unit id="dc1eea05d5c0b5d2f315739abfba0f7deefc344d" translate="yes" xml:space="preserve">
          <source>The number of elements added to the sorted sets, not including elements already existing for which the score was updated.</source>
          <target state="translated">Количество элементов,добавленных в отсортированные сеты,без учета уже существующих элементов,по которым был обновлен счет.</target>
        </trans-unit>
        <trans-unit id="e1784080520f069f819c069f9066d039833cf4fa" translate="yes" xml:space="preserve">
          <source>The number of keys existing among the ones specified as arguments. Keys mentioned multiple times and existing are counted multiple times.</source>
          <target state="translated">Количество ключей,существующих среди указанных в качестве аргументов.Ключи,упомянутые несколько раз и существующие,подсчитываются несколько раз.</target>
        </trans-unit>
        <trans-unit id="3563b055f87d27dac0ac55fd291fab644c82615a" translate="yes" xml:space="preserve">
          <source>The number of members removed from the sorted set, not including non existing members.</source>
          <target state="translated">Количество членов,исключенных из отсортированного набора,не включая несуществующих членов.</target>
        </trans-unit>
        <trans-unit id="2eae56d8105036d6f2b2f01b5669d022f7996c37" translate="yes" xml:space="preserve">
          <source>The number of milliseconds that elapsed since the last time this message was delivered to this consumer.</source>
          <target state="translated">Количество миллисекунд,прошедших с момента последней доставки этого сообщения этому потребителю.</target>
        </trans-unit>
        <trans-unit id="bbb45a4c926e88dd9593fe92bcaf35382576535c" translate="yes" xml:space="preserve">
          <source>The number of returned elements can be limited using the &lt;code&gt;LIMIT&lt;/code&gt; modifier. This modifier takes the &lt;code&gt;offset&lt;/code&gt; argument, specifying the number of elements to skip and the &lt;code&gt;count&lt;/code&gt; argument, specifying the number of elements to return from starting at &lt;code&gt;offset&lt;/code&gt;. The following example will return 10 elements of the sorted version of &lt;code&gt;mylist&lt;/code&gt;, starting at element 0 (&lt;code&gt;offset&lt;/code&gt; is zero-based):</source>
          <target state="translated">Количество возвращаемых элементов можно ограничить с помощью модификатора &lt;code&gt;LIMIT&lt;/code&gt; . Этот модификатор принимает аргумент &lt;code&gt;offset&lt;/code&gt; , определяющий количество элементов, которые необходимо пропустить, и аргумент &lt;code&gt;count&lt;/code&gt; , определяющий количество элементов, которые нужно вернуть, начиная с &lt;code&gt;offset&lt;/code&gt; . В следующем примере будет возвращено 10 элементов отсортированной версии &lt;code&gt;mylist&lt;/code&gt; , начиная с элемента 0 ( &lt;code&gt;offset&lt;/code&gt; отсчитывается от нуля):</target>
        </trans-unit>
        <trans-unit id="2eeaa2bda10c14131d8f8224aae3f44fbab1d33b" translate="yes" xml:space="preserve">
          <source>The number of times this message was delivered.</source>
          <target state="translated">Количество раз,когда это сообщение было доставлено.</target>
        </trans-unit>
        <trans-unit id="4b95ac5bed75bd380b7e253506beeb45e5dcdf48" translate="yes" xml:space="preserve">
          <source>The old master receives the configuration update: unblocks its clients and starts replying with redirection messages so that they'll continue the chat with the new master.</source>
          <target state="translated">Старый мастер получает обновление конфигурации:разблокирует своих клиентов и начинает отвечать сообщениями о перенаправлении,чтобы они продолжили чат с новым мастером.</target>
        </trans-unit>
        <trans-unit id="1d689942edb764c6bd34cea24670f1e2f9a34fe2" translate="yes" xml:space="preserve">
          <source>The only valid cursors to use are:</source>
          <target state="translated">Использовать только действительные курсоры:</target>
        </trans-unit>
        <trans-unit id="71d7b3a0d8bb44887a86cd184249f11ce4bd68cd" translate="yes" xml:space="preserve">
          <source>The only way to flush the script cache is by explicitly calling the &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; command, which will &lt;em&gt;completely flush&lt;/em&gt; the scripts cache removing all the scripts executed so far.</source>
          <target state="translated">Единственный способ очистить кеш скриптов - явным образом вызвать команду &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; , которая &lt;em&gt;полностью очистит&lt;/em&gt; кеш скриптов, удалив все скрипты, выполненные на данный момент.</target>
        </trans-unit>
        <trans-unit id="851a4dff1ddadeea08eb160100034cb226114c6d" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LIMIT&lt;/code&gt; argument can be used to only get a range of the matching elements (similar to &lt;em&gt;SELECT LIMIT offset, count&lt;/em&gt; in SQL). A negative &lt;code&gt;count&lt;/code&gt; returns all elements from the &lt;code&gt;offset&lt;/code&gt;. Keep in mind that if &lt;code&gt;offset&lt;/code&gt; is large, the sorted set needs to be traversed for &lt;code&gt;offset&lt;/code&gt; elements before getting to the elements to return, which can add up to O(N) time complexity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79325b395f9601a80868e44ee285b402fa0bfad" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LIMIT&lt;/code&gt; argument can be used to only get a range of the matching elements (similar to &lt;em&gt;SELECT LIMIT offset, count&lt;/em&gt; in SQL). Keep in mind that if &lt;code&gt;offset&lt;/code&gt; is large, the sorted set needs to be traversed for &lt;code&gt;offset&lt;/code&gt; elements before getting to the elements to return, which can add up to O(N) time complexity.</source>
          <target state="translated">Необязательный аргумент &lt;code&gt;LIMIT&lt;/code&gt; может использоваться только для получения диапазона совпадающих элементов (аналогично &lt;em&gt;смещению SELECT LIMIT, count&lt;/em&gt; в SQL). Имейте в виду, что если &lt;code&gt;offset&lt;/code&gt; велико, отсортированный набор должен быть пройден для элементов &lt;code&gt;offset&lt;/code&gt; прежде чем переходить к элементам для возврата, что может привести к временной сложности O (N).</target>
        </trans-unit>
        <trans-unit id="500dba23b5e32b54cd518b60d5bf8b2bf6fe3ec8" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WITHSCORES&lt;/code&gt; argument makes the command return both the element and its score, instead of the element alone. This option is available since Redis 2.0.</source>
          <target state="translated">Необязательный аргумент &lt;code&gt;WITHSCORES&lt;/code&gt; заставляет команду возвращать и элемент, и его оценку, а не только элемент. Эта опция доступна, начиная с Redis 2.0.</target>
        </trans-unit>
        <trans-unit id="0f54b06c2148c9b6919787651cb0104f905c8131" translate="yes" xml:space="preserve">
          <source>The optional argument specifies how many entries to show. By default up to ten failures are returned. The special &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; argument clears the log. Entries are displayed starting from the most recent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b302b8ebe5d4f766a30687aa495211b0a41cc8" translate="yes" xml:space="preserve">
          <source>The optional arguments and options can modify the command's behavior. The &lt;code&gt;RANK&lt;/code&gt; option specifies the &quot;rank&quot; of the first element to return, in case there are multiple matches. A rank of 1 means to return the first match, 2 to return the second match, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8aa34d3ef4ed317f6f4c66d1281cf452a3e134" translate="yes" xml:space="preserve">
          <source>The optional parameter can be used to select a specific section of information:</source>
          <target state="translated">Дополнительный параметр может использоваться для выбора определенного раздела информации:</target>
        </trans-unit>
        <trans-unit id="d3f8920e23cd2f39487b2140b719e87054ae2b2b" translate="yes" xml:space="preserve">
          <source>The order of step 1 and 2 is important. We want the destination node to be ready to accept &lt;code&gt;ASK&lt;/code&gt; redirections when the source node is configured to redirect.</source>
          <target state="translated">Порядок шагов 1 и 2 важен. Мы хотим, чтобы целевой узел был готов принимать перенаправления &lt;code&gt;ASK&lt;/code&gt; , когда исходный узел настроен на перенаправление.</target>
        </trans-unit>
        <trans-unit id="b62304b58ff7ffb9f9709c25da7f4765174f07a9" translate="yes" xml:space="preserve">
          <source>The output of the command is just a space-separated CSV string, where each line represents a node in the cluster. The following is an example of output:</source>
          <target state="translated">Вывод команды представляет собой разделенную пробелами строку CSV,где каждая строка представляет собой узел в кластере.Ниже приведен пример вывода:</target>
        </trans-unit>
        <trans-unit id="27eaed3275801016a87c11dc8a65ad526a22ea0c" translate="yes" xml:space="preserve">
          <source>The port number of the master.</source>
          <target state="translated">Номер порта мастера.</target>
        </trans-unit>
        <trans-unit id="251a4c07dcd21d1710028ff045133e0223bd8086" translate="yes" xml:space="preserve">
          <source>The position is returned, thinking of the string as an array of bits from left to right, where the first byte's most significant bit is at position 0, the second byte's most significant bit is at position 8, and so forth.</source>
          <target state="translated">Возвращается позиция,думая о строке как о массиве битов слева направо,где первый байт самый значащий в позиции 0,второй байт самый значащий в позиции 8,и так далее.</target>
        </trans-unit>
        <trans-unit id="cf1bf81ee9d88a76e67d9f14175bdac96ea2eae6" translate="yes" xml:space="preserve">
          <source>The position of the specified member is used as the center of the query.</source>
          <target state="translated">В качестве центра запроса используется позиция указанного члена.</target>
        </trans-unit>
        <trans-unit id="fe9f9e53a4720c0a3b3f8dd9ba6795a8d524ecc9" translate="yes" xml:space="preserve">
          <source>The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.</source>
          <target state="translated">Точность вывода фиксируется на уровне 17 цифр после запятой независимо от фактической внутренней точности вычисления.</target>
        </trans-unit>
        <trans-unit id="77e23fa703efecfb1c5bf352cb4f0529fa3a9d39" translate="yes" xml:space="preserve">
          <source>The query's center point is provided by one of these mandatory options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e2a1f42bcb6a5e4c6e642aa88cfced9dff68d3" translate="yes" xml:space="preserve">
          <source>The query's shape is provided by one of these mandatory options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9079c728747b4e6051aebcc896878af23a86276" translate="yes" xml:space="preserve">
          <source>The radius is specified in one of the following units:</source>
          <target state="translated">Радиус указывается в одном из следующих блоков:</target>
        </trans-unit>
        <trans-unit id="5d69c6f303471181769a8ce1e67050c18c180806" translate="yes" xml:space="preserve">
          <source>The range is close (inclusive) by default, meaning that the reply can include entries with IDs matching the query's start and end intervals. It is possible to specify an open interval (exclusive) by prefixing the ID with the character &lt;code&gt;(&lt;/code&gt;. This is useful for iterating the stream, as explained below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa101056c680bd6adea2c67580ad18683b432390" translate="yes" xml:space="preserve">
          <source>The range of values supported by &lt;a href=&quot;hincrby&quot;&gt;HINCRBY&lt;/a&gt; is limited to 64 bit signed integers.</source>
          <target state="translated">Диапазон значений, поддерживаемых &lt;a href=&quot;hincrby&quot;&gt;HINCRBY&lt;/a&gt; , ограничен 64-битными целыми числами со знаком .</target>
        </trans-unit>
        <trans-unit id="33bdfca071502b90c1a8026acb1caf737da192b8" translate="yes" xml:space="preserve">
          <source>The rate limiter pattern is a special counter that is used to limit the rate at which an operation can be performed. The classical materialization of this pattern involves limiting the number of requests that can be performed against a public API.</source>
          <target state="translated">Шаблон ограничителя скорости представляет собой специальный счетчик,который используется для ограничения скорости,с которой может быть выполнена операция.Классическая материализация этого шаблона предполагает ограничение количества запросов,которые могут быть выполнены против публичного API.</target>
        </trans-unit>
        <trans-unit id="602f859c103a55957a4cbd71395a1cae9a978824" translate="yes" xml:space="preserve">
          <source>The reason is that sending a script to another Redis instance is often much faster than sending the multiple commands the script generates, so if the client is sending many scripts to the master, converting the scripts into individual commands for the replica / AOF would result in too much bandwidth for the replication link or the Append Only File (and also too much CPU since dispatching a command received via network is a lot more work for Redis compared to dispatching a command invoked by Lua scripts).</source>
          <target state="translated">Причина в том,что отправка сценария в другой экземпляр Redis часто намного быстрее,чем отправка нескольких команд,которые сценарий генерирует,поэтому если клиент посылает много сценариев мастеру,преобразование сценариев в отдельные команды для реплики/AOF приведет к слишком большой пропускной способности для ссылки репликации или Append Only File (а также слишком много CPU,так как отправка команды,полученной по сети гораздо больше работы для Redis по сравнению с отправкой команды,вызванной сценариями Lua).</target>
        </trans-unit>
        <trans-unit id="f4d6d43d2e03d821aeb88801c0d8fb884cbca911" translate="yes" xml:space="preserve">
          <source>The reason why scripts can be cached for long time is that it is unlikely for a well written application to have enough different scripts to cause memory problems. Every script is conceptually like the implementation of a new command, and even a large application will likely have just a few hundred of them. Even if the application is modified many times and scripts will change, the memory used is negligible.</source>
          <target state="translated">Причина,по которой скрипты могут кэшироваться в течение длительного времени,заключается в том,что хорошо написанное приложение вряд ли будет иметь достаточно различных скриптов,чтобы вызвать проблемы с памятью.Каждый скрипт концептуально похож на реализацию новой команды,и даже в большом приложении их,скорее всего,будет всего несколько сотен.Даже если приложение модифицируется много раз и меняются скрипты,используемая память ничтожно мала.</target>
        </trans-unit>
        <trans-unit id="0e5533e8fee1cbd59ebef949c8411c0d7d01dc8e" translate="yes" xml:space="preserve">
          <source>The replica output is composed of the following parts:</source>
          <target state="translated">Вывод реплики состоит из следующих частей:</target>
        </trans-unit>
        <trans-unit id="d985304abe6bf0f8f4ea24090445b6bf55af90d3" translate="yes" xml:space="preserve">
          <source>The replica starts a failover, obtains a new configuration epoch from the majority of the masters, and broadcasts the new configuration.</source>
          <target state="translated">Реплика начинает обход отказа,получает новую эпоху конфигурации от большинства мастеров и транслирует новую конфигурацию.</target>
        </trans-unit>
        <trans-unit id="7c096a5e647ff1a64af00045529cba5bd168f06b" translate="yes" xml:space="preserve">
          <source>The replica tells the master to stop processing queries from clients.</source>
          <target state="translated">Реплика говорит мастеру,чтобы остановить обработку запросов от клиентов.</target>
        </trans-unit>
        <trans-unit id="e43729fea60babeefa0888b3097ef84a1143b1a0" translate="yes" xml:space="preserve">
          <source>The replica waits for the replication offset to match on its side, to make sure it processed all the data from the master before it continues.</source>
          <target state="translated">Реплика ждет смещения репликации,чтобы убедиться,что она обработала все данные от мастера,прежде чем продолжить.</target>
        </trans-unit>
        <trans-unit id="71f9285cf89c4539aedf2939b67fe3ee74695f78" translate="yes" xml:space="preserve">
          <source>The reply format is identical to that of &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt;, and the content consists only of information about the current client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6d847d0bceaf13a4c9effd31564050074fa753" translate="yes" xml:space="preserve">
          <source>The reported information contains all of the fields reported by the simple form of &lt;code&gt;XINFO STREAM&lt;/code&gt;, with some additional information:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb0e618b4e3d9e5fe2c17d1edb7fb80034a8b4f" translate="yes" xml:space="preserve">
          <source>The reported usage is the total of memory allocations for data and administrative overheads that a key its value require.</source>
          <target state="translated">Отчетное использование представляет собой общее количество выделенной памяти для данных и административных накладных расходов,что является ключевым значением,требуемым для него.</target>
        </trans-unit>
        <trans-unit id="79c8f80736bb00aecddcc76c1b8f02af94064a15" translate="yes" xml:space="preserve">
          <source>The representation is neutral from the point of view of the processor word size and endianness, so the same representation is used by 32 bit and 64 bit processor, big endian or little endian.</source>
          <target state="translated">Представление нейтрально с точки зрения размера и эндианности слова процессора,поэтому одно и то же представление используется 32-битным и 64-битным процессором,большим эндианом или маленьким эндианом.</target>
        </trans-unit>
        <trans-unit id="d07c8ceb7018e1bcd908f1c44ebce957404cda02" translate="yes" xml:space="preserve">
          <source>The representation used by &lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt; considers the bitmap as having the bit number 0 to be the most significant bit of the first byte, and so forth, so for example setting a 5 bits unsigned integer to value 23 at offset 7 into a bitmap previously set to all zeroes, will produce the following representation:</source>
          <target state="translated">Представление, используемое &lt;a href=&quot;bitfield&quot;&gt;BITFIELD,&lt;/a&gt; рассматривает битовую карту как имеющую номер бита 0 как самый старший бит первого байта и так далее, поэтому, например, установка 5-битового целого числа без знака на значение 23 со смещением 7 в битовой карте, ранее установленной на все нули, даст следующее представление:</target>
        </trans-unit>
        <trans-unit id="69c89883952564695abb2bebcaf5f11f6b3d6f75" translate="yes" xml:space="preserve">
          <source>The result of the operation is always stored at &lt;code&gt;destkey&lt;/code&gt;.</source>
          <target state="translated">Результат операции всегда сохраняется в &lt;code&gt;destkey&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8563416a363c2cdbe31060c220e5e3844f6d8270" translate="yes" xml:space="preserve">
          <source>The return type of the command is a &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;.</source>
          <target state="translated">Тип возврата команды - это &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;ответ в&lt;/a&gt; виде массива .</target>
        </trans-unit>
        <trans-unit id="29bc7d6c144c9d4891cb5866b63897dea6e00bee" translate="yes" xml:space="preserve">
          <source>The returned cardinality of the observed set is not exact, but approximated with a standard error of 0.81%.</source>
          <target state="translated">Возвращаемая кардинальность наблюдаемого набора не является точной,но аппроксимируется со стандартной погрешностью 0,81%.</target>
        </trans-unit>
        <trans-unit id="f485b5467a04f58f023ce0589b088bae79cd349e" translate="yes" xml:space="preserve">
          <source>The rewrite is performed in a very conservative way:</source>
          <target state="translated">Переписывание выполнено очень консервативно:</target>
        </trans-unit>
        <trans-unit id="3d4aef252f6710693b627be68f7b05c7734609ba" translate="yes" xml:space="preserve">
          <source>The rewrite will be only triggered by Redis if there is not already a background process doing persistence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ba82b2fd87a033c00319b26e5a7be447966868" translate="yes" xml:space="preserve">
          <source>The rewrite will be only triggered by Redis if there is not already a background process doing persistence. Specifically:</source>
          <target state="translated">Перезапись будет инициирована Redis только в том случае,если еще нет фонового процесса,выполняющего персистентность.В частности:</target>
        </trans-unit>
        <trans-unit id="1f1d9ccb03a5f0171c2e12fc9e5717671728f51a" translate="yes" xml:space="preserve">
          <source>The same bit position convention is followed by &lt;a href=&quot;getbit&quot;&gt;GETBIT&lt;/a&gt; and &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt;.</source>
          <target state="translated">За тем же соглашением о битовой позиции следуют &lt;a href=&quot;getbit&quot;&gt;GETBIT&lt;/a&gt; и &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2db5a15e45c348362ce43e64d992a94fa7834d6c" translate="yes" xml:space="preserve">
          <source>The same holds true for non-existent keys, that are considered as a stream of zero bytes up to the length of the longest string.</source>
          <target state="translated">То же самое справедливо и для несуществующих ключей,которые рассматриваются как поток нулевых байт до длины самой длинной строки.</target>
        </trans-unit>
        <trans-unit id="459993ded23b09fc27e5d6a4bf1ae20c56fbcf0c" translate="yes" xml:space="preserve">
          <source>The save parameter is a single string of space-separated integers. Every pair of integers represent a seconds/modifications threshold.</source>
          <target state="translated">Параметр save представляет собой единую строку целых чисел,разделенных пробелами.Каждая пара целых чисел представляет собой порог секунд/модификаций.</target>
        </trans-unit>
        <trans-unit id="19337abd9b3767724cccba46357082deb732a2c0" translate="yes" xml:space="preserve">
          <source>The score values should be the string representation of a double precision floating point number. &lt;code&gt;+inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; values are valid values as well.</source>
          <target state="translated">Значения оценки должны быть строковым представлением числа с плавающей запятой двойной точности. Значения &lt;code&gt;+inf&lt;/code&gt; и &lt;code&gt;-inf&lt;/code&gt; также являются допустимыми.</target>
        </trans-unit>
        <trans-unit id="8704ce1cdf5da36cc8175add936925537e2b6762" translate="yes" xml:space="preserve">
          <source>The script is guaranteed to stay in the script cache forever (unless &lt;code&gt;SCRIPT
FLUSH&lt;/code&gt; is called).</source>
          <target state="translated">Сценарий гарантированно останется в кеше сценария навсегда (если не вызывается &lt;code&gt;SCRIPT FLUSH&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="84e6859345305305b03236c94f49ebcdfaf9f284" translate="yes" xml:space="preserve">
          <source>The script must always evaluates the same Redis &lt;em&gt;write&lt;/em&gt; commands with the same arguments given the same input data set. Operations performed by the script cannot depend on any hidden (non-explicit) information or state that may change as script execution proceeds or between different executions of the script, nor can it depend on any external input from I/O devices.</source>
          <target state="translated">Сценарий всегда должен оценивать одни и те же команды &lt;em&gt;записи&lt;/em&gt; Redis с одинаковыми аргументами при одном и том же наборе входных данных. Операции, выполняемые сценарием, не могут зависеть от какой-либо скрытой (неявной) информации или состояния, которые могут изменяться по мере выполнения сценария или между различными выполнениями сценария, а также не могут зависеть от какого-либо внешнего ввода от устройств ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="f6f50abe88117410baf6ae78d63eac9d06193d38" translate="yes" xml:space="preserve">
          <source>The script should be called with &lt;code&gt;EVAL ...script... 1 resource-name token-value&lt;/code&gt;</source>
          <target state="translated">Сценарий должен вызываться с &lt;code&gt;EVAL ...script... 1 resource-name token-value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae5f9a8c3637986eaac0c1b5c2a821ed62bfff96" translate="yes" xml:space="preserve">
          <source>The second argument of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is the number of arguments that follows the script (starting from the third argument) that represent Redis key names. The arguments can be accessed by Lua using the &lt;code&gt;KEYS&lt;/code&gt; global variable in the form of a one-based array (so &lt;code&gt;KEYS[1]&lt;/code&gt;, &lt;code&gt;KEYS[2]&lt;/code&gt;, ...).</source>
          <target state="translated">Второй аргумент &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; - это количество аргументов, следующих за сценарием (начиная с третьего аргумента), которые представляют имена ключей Redis. Lua может получить доступ к аргументам с &lt;code&gt;KEYS&lt;/code&gt; глобальной переменной KEYS в виде массива с &lt;code&gt;KEYS[1]&lt;/code&gt; (так KEYS [1] , &lt;code&gt;KEYS[2]&lt;/code&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="5e06049c7fb2a08a77ed966e80b1bd0de88bb6c2" translate="yes" xml:space="preserve">
          <source>The semantic change between patch level releases was needed since the old behavior was inherently incompatible with the Redis replication layer and was the cause of bugs.</source>
          <target state="translated">Сематическое изменение между выпусками на уровне патчей было необходимо,так как старое поведение по своей природе было несовместимо со слоем репликации Redis и являлось причиной ошибок.</target>
        </trans-unit>
        <trans-unit id="c86d0b330e63015ff6018ffba522da6d3c2c8fb8" translate="yes" xml:space="preserve">
          <source>The sentinel output is composed of the following parts:</source>
          <target state="translated">Выходной сигнал часового механизма состоит из следующих частей:</target>
        </trans-unit>
        <trans-unit id="295a39c211fe9b12478b873df477a317d327e2b4" translate="yes" xml:space="preserve">
          <source>The serialization format is opaque and non-standard, however it has a few semantic characteristics:</source>
          <target state="translated">Формат сериализации непрозрачен и нестандартен,однако имеет несколько семантических характеристик:</target>
        </trans-unit>
        <trans-unit id="06e5cb4e4d36f51aabfd49438bd236dcf9c4976a" translate="yes" xml:space="preserve">
          <source>The serialized value does NOT contain expire information. In order to capture the time to live of the current value the &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; command should be used.</source>
          <target state="translated">Сериализованное значение НЕ содержит информации об истечении срока действия. Чтобы зафиксировать время жизни текущего значения, следует использовать команду &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd5acc612a2b52a80de5b2a3e24e38f5ba00302b" translate="yes" xml:space="preserve">
          <source>The size of the string stored in the destination key, that is equal to the size of the longest input string.</source>
          <target state="translated">Размер строки,хранящейся в ключе назначения,который равен размеру самой длинной входной строки.</target>
        </trans-unit>
        <trans-unit id="1a0a5df2b74e73a15c2817e253d14a10935a2191" translate="yes" xml:space="preserve">
          <source>The slow log is accumulated in memory, so no file is written with information about the slow command executions. This makes the slow log remarkably fast at the point that you can enable the logging of all the commands (setting the &lt;em&gt;slowlog-log-slower-than&lt;/em&gt; config parameter to zero) with minor performance hit.</source>
          <target state="translated">Журнал медленных операций накапливается в памяти, поэтому файл с информацией о медленном выполнении команд не записывается. Это делает медленный журнал чрезвычайно быстрым, когда вы можете включить ведение журнала всех команд (установив для параметра &lt;em&gt;конфигурации slowlog-log-slower-than&lt;/em&gt; нулевое значение) с незначительным &lt;em&gt;снижением&lt;/em&gt; производительности.</target>
        </trans-unit>
        <trans-unit id="4eaa8de726819dc3e71079d7a6f328e12fd9ddc2" translate="yes" xml:space="preserve">
          <source>The sparse representation uses a run-length encoding optimized to store efficiently a big number of registers set to zero. The dense representation is a Redis string of 12288 bytes in order to store 16384 6-bit counters. The need for the double representation comes from the fact that using 12k (which is the dense representation memory requirement) to encode just a few registers for smaller cardinalities is extremely suboptimal.</source>
          <target state="translated">В разреженном представлении используется кодировка длины пробега,оптимизированная для эффективного хранения большого количества регистров,установленных на ноль.Плотное представление представляет собой строку Redis размером 12288 байт для хранения 16384 6-битных счетчиков.Необходимость двойного представления обусловлена тем,что использование 12k (что является требованием к плотной памяти представления)для кодирования всего нескольких регистров для меньших кардиналов является крайне неоптимальным.</target>
        </trans-unit>
        <trans-unit id="8eeebccfe9d0cfc87769de4a2c07747fec580fbc" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;$&lt;/code&gt; ID.</source>
          <target state="translated">Специальный &lt;code&gt;$&lt;/code&gt; ID.</target>
        </trans-unit>
        <trans-unit id="0f067eeaba3e5a87a3236774a27fada6161ea70f" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;&amp;gt;&lt;/code&gt; ID, which means that the consumer want to receive only messages that were &lt;em&gt;never delivered to any other consumer&lt;/em&gt;. It just means, give me new messages.</source>
          <target state="translated">Специальный &lt;code&gt;&amp;gt;&lt;/code&gt; ID, который означает, что потребитель хочет получать только сообщения, которые &lt;em&gt;никогда не&lt;/em&gt; были &lt;em&gt;доставлены другим потребителям&lt;/em&gt; . Это просто означает, дайте мне новые сообщения.</target>
        </trans-unit>
        <trans-unit id="5029fc6d051bb809efc7fcb4a44af5a544f6b49f" translate="yes" xml:space="preserve">
          <source>The specified node ID does not identify the instance we are sending the command to.</source>
          <target state="translated">Указанный ID узла не идентифицирует экземпляр,которому мы посылаем команду.</target>
        </trans-unit>
        <trans-unit id="15f8e4eecac9b5616dbc97abb4f74fd51bce6356" translate="yes" xml:space="preserve">
          <source>The specified node ID exists in its nodes table.</source>
          <target state="translated">Указанный идентификатор узла существует в его таблице узлов.</target>
        </trans-unit>
        <trans-unit id="07565949c7a13614b4cf396e3dee4474076dd98c" translate="yes" xml:space="preserve">
          <source>The specified node ID is a master.</source>
          <target state="translated">Указанный идентификатор узла является основным.</target>
        </trans-unit>
        <trans-unit id="92c45a066b5df5b3300ad8d74734dc668cec5a44" translate="yes" xml:space="preserve">
          <source>The specified node ID is not found in the nodes table.</source>
          <target state="translated">Указанный идентификатор узла в таблице узлов не найден.</target>
        </trans-unit>
        <trans-unit id="dadcfd8e793bf395f94eff22f99b0da2a7a715b6" translate="yes" xml:space="preserve">
          <source>The specified node gets removed from the nodes table.</source>
          <target state="translated">Указанный узел удаляется из таблицы узлов.</target>
        </trans-unit>
        <trans-unit id="3be929a4c6ff231339b330125852213fb5229ce4" translate="yes" xml:space="preserve">
          <source>The state of the replication from the point of view of the master, that can be &lt;code&gt;connect&lt;/code&gt; (the instance needs to connect to its master), &lt;code&gt;connecting&lt;/code&gt; (the master-replica connection is in progress), &lt;code&gt;sync&lt;/code&gt; (the master and replica are trying to perform the synchronization), &lt;code&gt;connected&lt;/code&gt; (the replica is online).</source>
          <target state="translated">Состояние репликации с точки зрения мастера, который может &lt;code&gt;connect&lt;/code&gt; (экземпляр должен подключиться к своему мастеру), &lt;code&gt;connecting&lt;/code&gt; (выполняется соединение мастер-реплика), &lt;code&gt;sync&lt;/code&gt; (мастер и реплика пытаются выполнить синхронизацию), &lt;code&gt;connected&lt;/code&gt; (реплика в сети).</target>
        </trans-unit>
        <trans-unit id="b8b0d67ec2d33e9415285fa0b1b04c01c7c00db9" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;-&amp;gt;&lt;/code&gt; is used to separate the key name from the hash field name. The key is substituted as documented above, and the hash stored at the resulting key is accessed to retrieve the specified hash field.</source>
          <target state="translated">Строка &lt;code&gt;-&amp;gt;&lt;/code&gt; используется для отделения имени ключа от имени хэш-поля. Ключ заменяется, как описано выше, и осуществляется доступ к хешу, хранящемуся в результирующем ключе, для получения указанного поля хеширования.</target>
        </trans-unit>
        <trans-unit id="f708ccbae2afe95a0cd4653de56c8fb34c79374e" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">Строка &lt;code&gt;master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2940a9d939b4548e348a547825fc4662aaec04e" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;sentinel&lt;/code&gt;.</source>
          <target state="translated">Строковый &lt;code&gt;sentinel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d8519eae0e62aff504d921a1adc6159ed001fa3" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;slave&lt;/code&gt;, because of backward compatbility (see note at the end of this page).</source>
          <target state="translated">Строка &lt;code&gt;slave&lt;/code&gt; , из - за обратной compatbility (смотри примечание в конце этой страницы).</target>
        </trans-unit>
        <trans-unit id="6831b1a65326ef3cc261059e475703f978f1b6bb" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;slave&lt;/code&gt;, because of backward compatibility (see note at the end of this page).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a409de83f682db65c898664c9dbb138b1160b8f1" translate="yes" xml:space="preserve">
          <source>The summary provides a good overview, but sometimes we are interested in the details. In order to see all the pending messages with more associated information we need to also pass a range of IDs, in a similar way we do it with &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, and a non optional &lt;em&gt;count&lt;/em&gt; argument, to limit the number of messages returned per call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cc70797e244120c92cdce0be9d797bbb5993d5" translate="yes" xml:space="preserve">
          <source>The supported types are up to 64 bits for signed integers, and up to 63 bits for unsigned integers. This limitation with unsigned integers is due to the fact that currently the Redis protocol is unable to return 64 bit unsigned integers as replies.</source>
          <target state="translated">Поддерживаемые типы-до 64 бит для знаковых целых,и до 63 бит для беззнаковых целых.Это ограничение для беззнаковых целых чисел связано с тем,что в настоящее время протокол Redis не может возвращать 64-битные беззнаковые целые числа в качестве ответов.</target>
        </trans-unit>
        <trans-unit id="7a2d3466f691698508a75fad6644713be3c44a8f" translate="yes" xml:space="preserve">
          <source>The symmetric command used to alter the configuration at run time is &lt;code&gt;CONFIG
SET&lt;/code&gt;.</source>
          <target state="translated">Симметричная команда, используемая для изменения конфигурации во время выполнения, - это &lt;code&gt;CONFIG SET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4ef14ef5924effb0e2166473b48d643f3dd0b5a" translate="yes" xml:space="preserve">
          <source>The system administrator sends a &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; command to force a node to meet another one.</source>
          <target state="translated">Системный администратор отправляет команду &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET,&lt;/a&gt; чтобы заставить узел встретиться с другим.</target>
        </trans-unit>
        <trans-unit id="f7dd65cc5a619424783dd395e5066f1952bf62a3" translate="yes" xml:space="preserve">
          <source>The third nested reply is guaranteed to be the IP/Port pair of the master instance for the slot range. All IP/Port pairs after the third nested reply are replicas of the master.</source>
          <target state="translated">Третий вложенный ответ гарантированно будет парой IP/Port ведущего экземпляра для диапазона слотов.Все пары IP/Port после третьего вложенного ответа являются репликами ведущего.</target>
        </trans-unit>
        <trans-unit id="bc7c54ea663acc1cd16d645f286e49bdb17828f2" translate="yes" xml:space="preserve">
          <source>The time-complexity for this operation is O(N), N being the number of keys in all existing databases.</source>
          <target state="translated">Сложность во времени для этой операции-O(N),N-количество ключей во всех существующих базах данных.</target>
        </trans-unit>
        <trans-unit id="5dd2a246bdbf984a712d84e324dfcd54e3e83cfb" translate="yes" xml:space="preserve">
          <source>The time-complexity for this operation is O(N), N being the number of keys in the database.</source>
          <target state="translated">Сложность во времени для этой операции-O(N),N-количество ключей в базе данных.</target>
        </trans-unit>
        <trans-unit id="33b9dc1580854319ae2c493dffcae592f1834dfc" translate="yes" xml:space="preserve">
          <source>The timeout can also be cleared, turning the key back into a persistent key, using the &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; command.</source>
          <target state="translated">Тайм-аут также можно сбросить, превратив ключ обратно в постоянный ключ, с помощью команды &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a3cd5936158e61d7536637d6c3696dfb0161419" translate="yes" xml:space="preserve">
          <source>The timeout specifies the maximum idle time in any moment of the communication with the destination instance in milliseconds. This means that the operation does not need to be completed within the specified amount of milliseconds, but that the transfer should make progresses without blocking for more than the specified amount of milliseconds.</source>
          <target state="translated">Таймаут указывает максимальное время простоя в любой момент связи с конечным пунктом в миллисекундах.Это означает,что операция не обязательно должна быть завершена в течение указанного количества миллисекунд,но перевод должен осуществляться без блокировки более чем на указанное количество миллисекунд.</target>
        </trans-unit>
        <trans-unit id="47a97f0f97c34f511b051b78756091a74729e20b" translate="yes" xml:space="preserve">
          <source>The timeout will only be cleared by commands that delete or overwrite the contents of the key, including &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;, &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;, &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; and all the &lt;code&gt;*STORE&lt;/code&gt; commands. This means that all the operations that conceptually &lt;em&gt;alter&lt;/em&gt; the value stored at the key without replacing it with a new one will leave the timeout untouched. For instance, incrementing the value of a key with &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;, pushing a new value into a list with &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, or altering the field value of a hash with &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; are all operations that will leave the timeout untouched.</source>
          <target state="translated">Тайм-аут будет очищен только командами, которые удаляют или перезаписывают содержимое ключа, включая &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; , &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; , &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; и все команды &lt;code&gt;*STORE&lt;/code&gt; . Это означает, что все операции, которые концептуально &lt;em&gt;изменяют&lt;/em&gt; значение, хранящееся в ключе, без замены его новым, не изменят тайм-аут. Например, увеличение значения ключа с помощью &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; , добавление нового значения в список с помощью &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; или изменение значения поля хэша с помощью &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; - все это операции, которые не затрагивают тайм-аут.</target>
        </trans-unit>
        <trans-unit id="b4902022e2711d4049af153f6960e9c07559e3db" translate="yes" xml:space="preserve">
          <source>The unit must be one of the following, and defaults to meters:</source>
          <target state="translated">Устройство должно быть одним из следующих,а по умолчанию-счетчиками:</target>
        </trans-unit>
        <trans-unit id="a995cbd615ab3e6d82df762d54a3d2493e68cc0e" translate="yes" xml:space="preserve">
          <source>The unix timestamp at which the logged command was processed.</source>
          <target state="translated">Штемпель времени unix,при котором была обработана команда протоколирования.</target>
        </trans-unit>
        <trans-unit id="a0310f88660618094c01bca5ea0d0463bbd02002" translate="yes" xml:space="preserve">
          <source>The user just turned on AOF, and the server triggered the first AOF rewrite in order to create the initial AOF file. In this context, stopping will result in losing the dataset at all: once restarted, the server will potentially have AOF enabled without having any AOF file at all.</source>
          <target state="translated">Пользователь просто включил AOF,и сервер инициировал первую перезапись AOF,чтобы создать исходный AOF-файл.В этом контексте остановка приведет к полной потере набора данных:после перезагрузки на сервере может быть включен AOF без AOF-файла вообще.</target>
        </trans-unit>
        <trans-unit id="5f17b8b7fd14b72046eefe6ae0e142f682927503" translate="yes" xml:space="preserve">
          <source>The user should be aware that if the same existing key is mentioned in the arguments multiple times, it will be counted multiple times. So if &lt;code&gt;somekey&lt;/code&gt; exists, &lt;code&gt;EXISTS somekey somekey&lt;/code&gt; will return 2.</source>
          <target state="translated">Пользователь должен знать, что если один и тот же существующий ключ упоминается в аргументах несколько раз, он будет подсчитан несколько раз. Поэтому, если &lt;code&gt;somekey&lt;/code&gt; существует, &lt;code&gt;EXISTS somekey somekey&lt;/code&gt; вернет 2.</target>
        </trans-unit>
        <trans-unit id="a2b1b03bb92333675d117bc7fc8c0c76fc472f63" translate="yes" xml:space="preserve">
          <source>The user should take in mind that single-key and multiple-keys executions of this command are semantically different and have different performances.</source>
          <target state="translated">Пользователь должен помнить,что однокнопочные и многокнопочные исполнения этой команды семантически отличаются друг от друга и имеют разную производительность.</target>
        </trans-unit>
        <trans-unit id="aee2053c45b6ced184922e49824bb87ce4f26e87" translate="yes" xml:space="preserve">
          <source>The vertical labels under each graph column represent the amount of seconds, minutes, hours or days ago the event happened. For example &quot;15s&quot; means that the first graphed event happened 15 seconds ago.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0c79b31b353c9ce51c111498c89af1634cee6b" translate="yes" xml:space="preserve">
          <source>The way the sorted set is populated is using a technique called &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt;. Latitude and Longitude bits are interleaved in order to form an unique 52 bit integer. We know that a sorted set double score can represent a 52 bit integer without losing precision.</source>
          <target state="translated">Для заполнения отсортированного набора используется метод &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; . Биты широты и долготы чередуются для образования уникального 52-битного целого числа. Мы знаем, что двойная оценка отсортированного набора может представлять 52-битное целое число без потери точности.</target>
        </trans-unit>
        <trans-unit id="7b31bb2e561758eaef35a12c00599f8b3a9ccbe4" translate="yes" xml:space="preserve">
          <source>Then instead of starting the iteration again from &lt;code&gt;-&lt;/code&gt;, as the start of the range we use the entry ID of the &lt;em&gt;last&lt;/em&gt; entry returned by the previous &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; call as an exclusive interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="473281da4300480447326ee40d8d889bb9d90481" translate="yes" xml:space="preserve">
          <source>Then instead of starting the iteration again from &lt;code&gt;-&lt;/code&gt;, as the start of the range we use the entry ID of the &lt;em&gt;last&lt;/em&gt; entry returned by the previous &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; call, adding the sequence part of the ID by one.</source>
          <target state="translated">Затем вместо того, чтобы снова начинать итерацию с &lt;code&gt;-&lt;/code&gt; , в качестве начала диапазона мы используем идентификатор записи &lt;em&gt;последней&lt;/em&gt; записи, возвращенной предыдущим &lt;a href=&quot;xrange&quot;&gt;вызовом XRANGE&lt;/a&gt; , добавляя часть идентификатора последовательности на единицу.</target>
        </trans-unit>
        <trans-unit id="49d73108f34c912bc3dcd46d706878a2b1cfa83b" translate="yes" xml:space="preserve">
          <source>Then suddenly that consumer fails forever.</source>
          <target state="translated">А потом внезапно этот потребитель терпит неудачу навсегда.</target>
        </trans-unit>
        <trans-unit id="c54ead856d23cc39661d8102bdb6330ddb30ed3d" translate="yes" xml:space="preserve">
          <source>Then we may want to know what commands are part of a given category:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66921f715545a310ecff4dca64b25267fdd5efb" translate="yes" xml:space="preserve">
          <source>There are also optional fields emitted only by Redis 4.0 or greater:</source>
          <target state="translated">Существуют также необязательные поля,излучаемые только Redis 4.0 или выше:</target>
        </trans-unit>
        <trans-unit id="a381e0a250a57263ea1da7d6465921f290bc2868" translate="yes" xml:space="preserve">
          <source>There are cases when you need to set all the bits of single bitmap at once, for example when initializing it to a default non-zero value. It is possible to do this with multiple calls to the &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; command, one for each bit that needs to be set. However, so as an optimization you can use a single &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command to set the entire bitmap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf4557f2ee4da2fe1ae76ce2cecd829e57c75d9" translate="yes" xml:space="preserve">
          <source>There are conditions when we want just to terminate a Redis instance ASAP, regardless of what its content is. In such a case, the right combination of commands is to send a &lt;strong&gt;CONFIG appendonly no&lt;/strong&gt; followed by a &lt;strong&gt;SHUTDOWN NOSAVE&lt;/strong&gt;. The first command will turn off the AOF if needed, and will terminate the AOF rewriting child if there is one active. The second command will not have any problem to execute since the AOF is no longer enabled.</source>
          <target state="translated">Существуют условия, когда мы хотим как можно скорее завершить работу экземпляра Redis, независимо от его содержимого. В таком случае правильная комбинация команд состоит в том, чтобы послать &lt;strong&gt;CONFIG, только добавление no,&lt;/strong&gt; за которым следует &lt;strong&gt;SHUTDOWN NOSAVE&lt;/strong&gt; . Первая команда отключит AOF, если это необходимо, и завершит перезапись дочернего элемента AOF, если он активен. У второй команды не возникнет проблем с выполнением, поскольку AOF больше не включен.</target>
        </trans-unit>
        <trans-unit id="158a7d63bcc769d78e3493a2bc55c7a4ee6bce03" translate="yes" xml:space="preserve">
          <source>There are multiple clients rotating the list: they'll fetch different elements, until all the elements of the list are visited, and the process restarts.</source>
          <target state="translated">Существует несколько клиентов,вращающих список:они будут извлекать различные элементы,пока не посетят все элементы списка,и процесс не перезапустится.</target>
        </trans-unit>
        <trans-unit id="bdda3afdb8163e659ca9981491dbe7bcadb74afd" translate="yes" xml:space="preserve">
          <source>There are situations where this is not enough, and we want a replica to failover without any agreement with the rest of the cluster. A real world use case for this is to mass promote replicas in a different data center to masters in order to perform a data center switch, while all the masters are down or partitioned away.</source>
          <target state="translated">Бывают ситуации,когда этого недостаточно,и нам нужна копия для обхода отказа без согласования с остальными участниками кластера.Реальным случаем использования для этого является массовое продвижение реплик в другом центре данных для мастеров,чтобы выполнить коммутатор центра данных,в то время как все мастера находятся внизу или разделены на части.</target>
        </trans-unit>
        <trans-unit id="6bd7c5396466fc74307415d5fb57447e1fc4a356" translate="yes" xml:space="preserve">
          <source>There are times when a list can receive multiple elements in the context of the same conceptual command:</source>
          <target state="translated">Бывают случаи,когда список может получить несколько элементов в контексте одной и той же концептуальной команды:</target>
        </trans-unit>
        <trans-unit id="8e2a3e6a950f5d8a609385be1af06951e77dc2ea" translate="yes" xml:space="preserve">
          <source>There are two helper functions to return Redis types from Lua.</source>
          <target state="translated">Есть две вспомогательные функции для возврата типов Redis из Lua.</target>
        </trans-unit>
        <trans-unit id="be8d4180a42a37a500975b93ef1e55ade0e6286d" translate="yes" xml:space="preserve">
          <source>There are two ways in order to specify offsets in the bitfield command. If a number without any prefix is specified, it is used just as a zero based bit offset inside the string.</source>
          <target state="translated">Есть два способа указать смещения в команде bitfield.Если указано число без префикса,то оно используется просто как нулевое смещение битов внутри строки.</target>
        </trans-unit>
        <trans-unit id="d75f55602fddc93ba9011e7393a6bc36a64ba5a7" translate="yes" xml:space="preserve">
          <source>There is &lt;a href=&quot;http://www.lua.org/pil/19.1.html&quot;&gt;no simple way to have nils inside Lua arrays&lt;/a&gt;, this is a result of Lua table semantics, so when Redis converts a Lua array into Redis protocol the conversion is stopped if a nil is encountered.</source>
          <target state="translated">Нет &lt;a href=&quot;http://www.lua.org/pil/19.1.html&quot;&gt;простого способа иметь nils внутри массивов Lua&lt;/a&gt; , это результат семантики таблицы Lua, поэтому, когда Redis преобразует массив Lua в протокол Redis, преобразование останавливается, если встречается nil.</target>
        </trans-unit>
        <trans-unit id="b1c93389b4b0093ccfd4821330160b8a97df2879" translate="yes" xml:space="preserve">
          <source>There is &lt;a href=&quot;https://www.lua.org/pil/19.1.html&quot;&gt;no simple way to have nils inside Lua arrays&lt;/a&gt;, this is a result of Lua table semantics, so when Redis converts a Lua array into Redis protocol the conversion is stopped if a nil is encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1181df382608fdc99dac69533a65959f383591cd" translate="yes" xml:space="preserve">
          <source>There is a different way to fix this issue without using scripting, but using Redis lists instead of counters. The implementation is more complex and uses more advanced features but has the advantage of remembering the IP addresses of the clients currently performing an API call, that may be useful or not depending on the application.</source>
          <target state="translated">Есть другой способ исправить эту проблему без использования скриптов,но с использованием списков Redis вместо счетчиков.Реализация более сложна и использует более продвинутые возможности,но имеет преимущество запоминания IP-адресов клиентов,выполняющих вызов API,что может быть полезно или нет в зависимости от приложения.</target>
        </trans-unit>
        <trans-unit id="2318fb4edc6b835e7f3009f7b1cfc0bceadc13e5" translate="yes" xml:space="preserve">
          <source>There is a stream with an associated consumer group.</source>
          <target state="translated">Есть поток с ассоциированной группой потребителей.</target>
        </trans-unit>
        <trans-unit id="f5813da89c7be6046d913f1f5df04a5cf2e30994" translate="yes" xml:space="preserve">
          <source>There is an additional Lua-to-Redis conversion rule that has no corresponding Redis to Lua conversion rule:</source>
          <target state="translated">Существует дополнительное правило преобразования Lua-to-Redis,которое не имеет соответствующего Redis к правилу преобразования Lua:</target>
        </trans-unit>
        <trans-unit id="3c2e8ff8c03c52243caafd83d9c21a0190459a1a" translate="yes" xml:space="preserve">
          <source>There is another subcommand that only changes the behavior of successive &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; subcommand calls by setting the overflow behavior:</source>
          <target state="translated">Существует еще одна подкоманда, которая изменяет поведение только последовательных &lt;a href=&quot;incrby&quot;&gt;вызовов&lt;/a&gt; подкоманды INCRBY , задавая поведение переполнения:</target>
        </trans-unit>
        <trans-unit id="ad004d677ac8d1220049f68515cbe366e16611b0" translate="yes" xml:space="preserve">
          <source>There is no difference between using the helper functions or directly returning the table with the specified format, so the following two forms are equivalent:</source>
          <target state="translated">Нет никакой разницы между использованием вспомогательных функций или непосредственным возвратом таблицы с заданным форматом,поэтому следующие две формы эквивалентны:</target>
        </trans-unit>
        <trans-unit id="688604faa0496cccdc56e5c3415b7e254e6c2086" translate="yes" xml:space="preserve">
          <source>There is no guarantee that it is actually the higher configuration epoch, since, for example, we can use the &lt;strong&gt;TAKEOVER&lt;/strong&gt; option within a minority, nor any message exchange is performed to generate the new configuration epoch.</source>
          <target state="translated">Нет никакой гарантии, что это действительно более высокая эпоха конфигурации, так как, например, мы можем использовать опцию &lt;strong&gt;TAKEOVER&lt;/strong&gt; в меньшинстве, и никакой обмен сообщениями не выполняется для создания новой эпохи конфигурации.</target>
        </trans-unit>
        <trans-unit id="f9d2324c27d0bdf5977e444923fed05e29f7f2d5" translate="yes" xml:space="preserve">
          <source>There is no limit to the length of the name that can be assigned if not the usual limits of the Redis string type (512 MB). However it is not possible to use spaces in the connection name as this would violate the format of the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; reply.</source>
          <target state="translated">Нет никаких ограничений на длину имени, которое может быть присвоено, если не обычные ограничения строкового типа Redis (512 МБ). Однако нельзя использовать пробелы в имени соединения, так как это нарушит формат ответа &lt;a href=&quot;client-list&quot;&gt;СПИСКА КЛИЕНТОВ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="939fac74be0ef5905e18fc0965563dbdb047a83f" translate="yes" xml:space="preserve">
          <source>There is one key thing to understand: in case Lua replies with RESP3 types, but the connection calling Lua is in RESP2 mode, Redis will automatically convert the RESP3 protocol to RESP2 compatible protocol, as it happens for normal commands. For instance returning a map type to a connection in RESP2 mode will have the effect of returning a flat array of fields and values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5147f1530dd4898c039cd6ac5ba9eae79430a62" translate="yes" xml:space="preserve">
          <source>These are the counters that are reset:</source>
          <target state="translated">Это счетчики,которые сбрасываются:</target>
        </trans-unit>
        <trans-unit id="3f9525d03220e878ebb457481ab1b1546ad897b4" translate="yes" xml:space="preserve">
          <source>These bytes are pure overhead at the moment as no actual data is stored, and are used for maintaining the internal data structures of the server. Longer keys and values show asymptotically linear usage.</source>
          <target state="translated">Эти байты в данный момент являются чистыми накладными расходами,так как не хранятся фактические данные,и используются для поддержания внутренних структур данных сервера.Более длинные ключи и значения показывают асимптотически линейное использование.</target>
        </trans-unit>
        <trans-unit id="0c0d7819e41ea841eca9c54ef01aab00acdd805e" translate="yes" xml:space="preserve">
          <source>These offsets can also be negative numbers indicating offsets starting at the end of the list. For example, &lt;code&gt;-1&lt;/code&gt; is the last element of the list, &lt;code&gt;-2&lt;/code&gt; the penultimate, and so on.</source>
          <target state="translated">Эти смещения также могут быть отрицательными числами, указывающими смещения, начинающиеся в конце списка. Например, &lt;code&gt;-1&lt;/code&gt; - последний элемент списка, &lt;code&gt;-2&lt;/code&gt; - предпоследний и т. Д.</target>
        </trans-unit>
        <trans-unit id="3327f4f330ea4245b93a5884cfe66d7c642a01a1" translate="yes" xml:space="preserve">
          <source>These prerequisites are needed since usually, manually altering the configuration epoch of a node is unsafe, we want to be sure that the node with the higher configuration epoch value (that is the last that failed over) wins over other nodes in claiming the hash slots ownership.</source>
          <target state="translated">Эти предпосылки необходимы,так как обычно ручное изменение эпохи конфигурации узла небезопасно,мы хотим быть уверены,что узел с более высоким значением эпохи конфигурации (т.е.последним,которое не удалось выполнить)выигрывает у других узлов,претендуя на владение хэш-слотами.</target>
        </trans-unit>
        <trans-unit id="74cdd9a11d855a7fe9706564ff82f50aed545b21" translate="yes" xml:space="preserve">
          <source>They can be shortened removing characters from the right. It will lose precision but will still point to the same area.</source>
          <target state="translated">Их можно укоротить,удалив символы справа.Это приведет к потере точности,но все равно будет указывать на ту же область.</target>
        </trans-unit>
        <trans-unit id="de21a5f9f7664481a629fd440bf41584926e640e" translate="yes" xml:space="preserve">
          <source>They correspond directly to the normal Redis log levels. Only logs emitted by scripting using a log level that is equal or greater than the currently configured Redis instance log level will be emitted.</source>
          <target state="translated">Они напрямую соответствуют обычным уровням журнала Redis.Только журналы,испускаемые скриптами,использующими уровень журнала,равный или превышающий настроенный в данный момент уровень журнала экземпляра Redis,будут испускаться.</target>
        </trans-unit>
        <trans-unit id="1163c9f8d8e2d599dd815fa54afcf7fcd4819d93" translate="yes" xml:space="preserve">
          <source>Things like using the system time, calling Redis random commands like &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;, or using Lua random number generator, could result into scripts that will not always evaluate in the same way.</source>
          <target state="translated">Такие вещи, как использование системного времени, вызов случайных команд Redis, таких как &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; , или использование генератора случайных чисел Lua, могут привести к созданию сценариев, которые не всегда будут оцениваться одинаково.</target>
        </trans-unit>
        <trans-unit id="3a6c24e6bcae98d8b374c6b8a2cb2e847242de7f" translate="yes" xml:space="preserve">
          <source>Think at a Lua script where we perform an intersection between two sets. Pick five random elements, and create a new set with this five random elements. Finally we delete the temporary key representing the intersection between the two original sets. What we want to replicate is only the creation of the new set with the five elements. It's not useful to also replicate the commands creating the temporary key.</source>
          <target state="translated">Подумайте о сценарии Луа,где мы выполняем пересечение двух множеств.Выберите пять случайных элементов и создайте новое множество с этими пятью случайными элементами.Наконец,мы удаляем временный ключ,представляющий собой пересечение двух исходных множеств.То,что мы хотим повторить,это только создание нового множества с пятью элементами.Не полезно также реплицировать команды,создающие временный ключ.</target>
        </trans-unit>
        <trans-unit id="d05a95556307e74d8c3d500f8eaf5b432fd6a284" translate="yes" xml:space="preserve">
          <source>This avoids that a client will try to release the lock after the expire time deleting the key created by another client that acquired the lock later.</source>
          <target state="translated">Это позволяет избежать того,что клиент будет пытаться освободить замок по истечении срока действия,удаляя ключ,созданный другим клиентом,который приобрел замок позже.</target>
        </trans-unit>
        <trans-unit id="e05975c8ace39fb16ed1689fdd42d78b56751af2" translate="yes" xml:space="preserve">
          <source>This can be a problem with some application where we want a more reliable messaging system. When this is the case, please check the &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; command, that is a variant of &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; that adds the returned element to a target list before returning it to the client.</source>
          <target state="translated">Это может быть проблемой в некоторых приложениях, где нам нужна более надежная система обмена сообщениями. В этом случае проверьте команду &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; , которая представляет собой вариант &lt;a href=&quot;blpop&quot;&gt;BLPOP,&lt;/a&gt; который добавляет возвращаемый элемент в целевой список перед возвратом его клиенту.</target>
        </trans-unit>
        <trans-unit id="7d43703d663f6362b0a28ec9100f4db91d08a310" translate="yes" xml:space="preserve">
          <source>This can be fixed easily turning the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; with optional &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; into a Lua script that is send using the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command (only available since Redis version 2.6).</source>
          <target state="translated">Это можно легко исправить, превратив &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; с дополнительным &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; в сценарий Lua, который отправляется с помощью команды &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; (доступно только с версии Redis 2.6).</target>
        </trans-unit>
        <trans-unit id="72b1b07f3e247301ca1521cd5c3a4e2df6db2967" translate="yes" xml:space="preserve">
          <source>This command accepts one or more SHA1 digests and returns a list of ones or zeros to signal if the scripts are already defined or not inside the script cache. This can be useful before a pipelining operation to ensure that scripts are loaded (and if not, to load them using &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt;) so that the pipelining operation can be performed solely using &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; instead of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; to save bandwidth.</source>
          <target state="translated">Эта команда принимает один или несколько дайджестов SHA1 и возвращает список единиц или нулей, чтобы указать, определены ли сценарии уже или нет в кеше сценариев. Это может быть полезно перед операцией конвейерной обработки, чтобы гарантировать загрузку сценариев (а если нет, загрузить их с помощью &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; ), чтобы операция конвейерной обработки могла выполняться исключительно с использованием &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; вместо &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; для экономии полосы пропускания.</target>
        </trans-unit>
        <trans-unit id="dcfeceb3df3a9d1203f8df4602183697ddf7897a" translate="yes" xml:space="preserve">
          <source>This command accepts two non mandatory options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43467785cd12ce45437b2b4eecb4c3b0671ef615" translate="yes" xml:space="preserve">
          <source>This command blocks the current client until all the previous write commands are successfully transferred and acknowledged by at least the specified number of replicas. If the timeout, specified in milliseconds, is reached, the command returns even if the specified number of replicas were not yet reached.</source>
          <target state="translated">Эта команда блокирует текущего клиента до тех пор,пока все предыдущие команды записи не будут успешно переданы и подтверждены,по крайней мере,указанным количеством копий.При достижении таймаута,указанного в миллисекундах,команда возвращается,даже если указанное количество реплик еще не было достигнуто.</target>
        </trans-unit>
        <trans-unit id="7a62033f131f44c3fe86c2c4ab2196a020d7e337" translate="yes" xml:space="preserve">
          <source>This command can be called with multiple streams if we want to read at the same time from a number of keys. This is a key feature of &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; because especially when blocking with &lt;strong&gt;BLOCK&lt;/strong&gt;, to be able to listen with a single connection to multiple keys is a vital feature.</source>
          <target state="translated">Эта команда может быть вызвана с несколькими потоками, если мы хотим читать одновременно с нескольких ключей. Это ключевая функция &lt;a href=&quot;xread&quot;&gt;XREAD,&lt;/a&gt; потому что, особенно при блокировке с помощью &lt;strong&gt;BLOCK&lt;/strong&gt; , возможность прослушивания с помощью одного соединения с несколькими клавишами является жизненно важной функцией.</target>
        </trans-unit>
        <trans-unit id="ea63b36c2daa60b6b416fb9f70368e117feeda86" translate="yes" xml:space="preserve">
          <source>This command can unblock, from a different connection, a client blocked in a blocking operation, such as for instance &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; or &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; or &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">Эта команда может разблокировать, из другого соединения, клиент блокируется в операции блокировки, такие , как, например , &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; или &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; или &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d6f9176a21b0c3f64b6d59331a54d4112960a8c" translate="yes" xml:space="preserve">
          <source>This command comes in place of the now deprecated &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;. Doing &lt;code&gt;BLMOVE RIGHT LEFT&lt;/code&gt; is equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4b7969f891e0631e6b36c849a8182bdc4a8ebc" translate="yes" xml:space="preserve">
          <source>This command comes in place of the now deprecated &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;. Doing &lt;code&gt;LMOVE RIGHT LEFT&lt;/code&gt; is equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f02c76dc59dbdc13fe5dd0f4a1731c43a14ddd0" translate="yes" xml:space="preserve">
          <source>This command controls the tracking of the keys in the next command executed by the connection, when tracking is enabled in &lt;code&gt;OPTIN&lt;/code&gt; or &lt;code&gt;OPTOUT&lt;/code&gt; mode. Please check the &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;client side caching documentation&lt;/a&gt; for background information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f8b881a98ea2d40bfed754bab550d934301142" translate="yes" xml:space="preserve">
          <source>This command copies the value stored at the &lt;code&gt;source&lt;/code&gt; key to the &lt;code&gt;destination&lt;/code&gt; key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff095ce217da2e3523c4effed757c97e397dac6" translate="yes" xml:space="preserve">
          <source>This command enables the tracking feature of the Redis server, that is used for &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;server assisted client side caching&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b31d1c2eb93e0473a8a5492fa02a9c8c2c2d69" translate="yes" xml:space="preserve">
          <source>This command is currently implemented only when using &lt;strong&gt;jemalloc&lt;/strong&gt; as an allocator, and evaluates to a benign NOOP for all others.</source>
          <target state="translated">Эта команда в настоящее время реализована только при использовании &lt;strong&gt;jemalloc&lt;/strong&gt; в качестве распределителя и оценивается как &lt;strong&gt;мягкий&lt;/strong&gt; NOOP для всех остальных.</target>
        </trans-unit>
        <trans-unit id="932344d8190e35db9df40d94e5197fd7c1d13364" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sdiff&quot;&gt;SDIFF&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">Эта команда &lt;a href=&quot;sdiff&quot;&gt;аналогична SDIFF&lt;/a&gt; , но вместо возврата результирующего набора она сохраняется в месте &lt;code&gt;destination&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="507f9a2dec2a09af16c3fc0fe75de6b0370a3364" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">Эта команда &lt;a href=&quot;sinter&quot;&gt;аналогична SINTER&lt;/a&gt; , но вместо возврата результирующего набора она сохраняется в месте &lt;code&gt;destination&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86af64e6b7731ea035f82e2694ba78f231528031" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sunion&quot;&gt;SUNION&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">Эта команда эквивалентна &lt;a href=&quot;sunion&quot;&gt;SUNION&lt;/a&gt; , но вместо возврата результирующего набора она сохраняется в месте &lt;code&gt;destination&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e32e7ca3fa8b824bc6b60a666e52d947d9640ed" translate="yes" xml:space="preserve">
          <source>This command is especially useful together with &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; which was introduced also in Redis 5 together with &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt;. Check the &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; command page for a pattern involving the two commands.</source>
          <target state="translated">Эта команда особенно полезна вместе с &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK,&lt;/a&gt; которая также была представлена ​​в Redis 5 вместе с &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; . Проверьте командную страницу &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; для шаблона, включающего две команды.</target>
        </trans-unit>
        <trans-unit id="86526f15e70874597af78fb5a748e15addec9fd4" translate="yes" xml:space="preserve">
          <source>This command is exactly like &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; with the sole difference that instead of taking, as the center of the area to query, a longitude and latitude value, it takes the name of a member already existing inside the geospatial index represented by the sorted set.</source>
          <target state="translated">Эта команда точно такая же, как &lt;a href=&quot;georadius&quot;&gt;GEORADIUS,&lt;/a&gt; с той лишь разницей, что вместо того, чтобы принимать в качестве центра области для запроса значения долготы и широты, она принимает имя члена, уже существующего внутри геопространственного индекса, представленного отсортированным набором.</target>
        </trans-unit>
        <trans-unit id="20782308b0ebe308769b63e3df355d6efd05d3a3" translate="yes" xml:space="preserve">
          <source>This command is exactly like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, but with the notable difference of returning the entries in reverse order, and also taking the start-end range in reverse order: in &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; you need to state the &lt;em&gt;end&lt;/em&gt; ID and later the &lt;em&gt;start&lt;/em&gt; ID, and the command will produce all the element between (or exactly like) the two IDs, starting from the &lt;em&gt;end&lt;/em&gt; side.</source>
          <target state="translated">Эта команда точно такая же, как &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; , но с заметной разницей в том, что возвращает записи в обратном порядке, а также принимает диапазон начала-конца в обратном порядке: в &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; вам нужно указать &lt;em&gt;конечный&lt;/em&gt; идентификатор, а затем &lt;em&gt;начальный&lt;/em&gt; идентификатор и команду создаст весь элемент между (или точно так же) двумя идентификаторами, начиная с &lt;em&gt;конечной&lt;/em&gt; стороны.</target>
        </trans-unit>
        <trans-unit id="076bd15f23123ea6b78baa94e15f792d2be93592" translate="yes" xml:space="preserve">
          <source>This command is like &lt;a href=&quot;geosearch&quot;&gt;GEOSEARCH&lt;/a&gt;, but stores the result in destination key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0909cd0cbb5b65dceb56a6821a06b32b029f0ae" translate="yes" xml:space="preserve">
          <source>This command is mainly used in the event a &lt;code&gt;nodes.conf&lt;/code&gt; node state file gets lost / deleted for some reason, and we want to generate it again from scratch. It can also be useful in case of mundane alterations of a node cluster configuration via the &lt;code&gt;CLUSTER&lt;/code&gt; command in order to ensure the new configuration is persisted on disk, however all the commands should normally be able to auto schedule to persist the configuration on disk when it is important to do so for the correctness of the system in the event of a restart.</source>
          <target state="translated">Эта команда в основном используется в случае потери / удаления файла состояния узла &lt;code&gt;nodes.conf&lt;/code&gt; по какой-либо причине, и мы хотим сгенерировать его снова с нуля. Это также может быть полезно в случае случайных изменений конфигурации кластера узлов с помощью команды &lt;code&gt;CLUSTER&lt;/code&gt; , чтобы гарантировать, что новая конфигурация сохраняется на диске, однако все команды обычно должны иметь возможность автоматического планирования для сохранения конфигурации на диске, когда она Это важно сделать для корректной работы системы в случае перезапуска.</target>
        </trans-unit>
        <trans-unit id="b0d65e64e68abf2d5af87daf134cb637fc1df1f2" translate="yes" xml:space="preserve">
          <source>This command is mainly useful for debugging, when the failure detector of Redis Cluster is not operating as we believe it should.</source>
          <target state="translated">Эта команда в основном полезна для отладки,когда детектор сбоев Redis Cluster работает не так,как нам кажется.</target>
        </trans-unit>
        <trans-unit id="30fc3be6e9d8c6b14224168e93a2ce61a33ebf6a" translate="yes" xml:space="preserve">
          <source>This command is mainly useful to kill a script that is running for too much time(for instance because it entered an infinite loop because of a bug). The script will be killed and the client currently blocked into EVAL will see the command returning with an error.</source>
          <target state="translated">Эта команда в основном полезна для того,чтобы убить скрипт,который выполняется слишком долго (например,из-за того,что он вошел в бесконечный цикл из-за ошибки).Скрипт будет убит,а клиент,заблокированный в настоящее время в EVAL,увидит команду,возвращающуюся с ошибкой.</target>
        </trans-unit>
        <trans-unit id="37c2b15b0fd4a88889c5862b221daca96c7ea555" translate="yes" xml:space="preserve">
          <source>This command is mainly useful to re-provision a Redis Cluster node in order to be used in the context of a new, different cluster. The command is also extensively used by the Redis Cluster testing framework in order to reset the state of the cluster every time a new test unit is executed.</source>
          <target state="translated">Эта команда в основном полезна для перепрофилирования узла Redis Cluster для использования в контексте нового,другого кластера.Эта команда также широко используется в тестирующей инфраструктуре Redis Cluster для сброса состояния кластера каждый раз при выполнении нового тестового модуля.</target>
        </trans-unit>
        <trans-unit id="fed8489efd023df6aa3b9c8828a92cf9cbe79777" translate="yes" xml:space="preserve">
          <source>This command is similar to &lt;a href=&quot;zdiffstore&quot;&gt;ZDIFFSTORE&lt;/a&gt;, but instead of storing the resulting sorted set, it is returned to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b570683c8482e1a6ba032781b807f8695533eb" translate="yes" xml:space="preserve">
          <source>This command is similar to &lt;a href=&quot;zinterstore&quot;&gt;ZINTERSTORE&lt;/a&gt;, but instead of storing the resulting sorted set, it is returned to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d880d1fb82050509f79c50bd6fb5ec73f51cf212" translate="yes" xml:space="preserve">
          <source>This command is similar to &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;, but instead of storing the resulting sorted set, it is returned to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de9c0357b2f6bf5f5b30bfd602eff2f9c1cbcf1" translate="yes" xml:space="preserve">
          <source>This command is the most powerful analysis tool in the latency monitoring framework, and is able to provide additional statistical data like the average period between latency spikes, the median deviation, and a human-readable analysis of the event. For certain events, like &lt;code&gt;fork&lt;/code&gt;, additional information is provided, like the rate at which the system forks processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9cd1ceade82d616f55d37288e27be4ecc550c1" translate="yes" xml:space="preserve">
          <source>This command is the only way to force Redis to flush the scripts cache. It is most useful in a cloud environment where the same instance can be reassigned to a different user. It is also useful for testing client libraries' implementations of the scripting feature.</source>
          <target state="translated">Эта команда-единственный способ заставить Redis очистить кэш сценариев.Она наиболее полезна в облачной среде,где один и тот же экземпляр может быть переназначен другому пользователю.Она также полезна для тестирования реализации возможностей скриптов в клиентских библиотеках.</target>
        </trans-unit>
        <trans-unit id="8562c28aa29c0aee65ed6fb4a3d690ee24e35388" translate="yes" xml:space="preserve">
          <source>This command is the only way to interrupt a long-running script that reaches the configured maximum execution time for scripts. The SCRIPT KILL command can only be used with scripts that did not modify the dataset during their execution (since stopping a read-only script does not violate the scripting engine's guaranteed atomicity). See the next sections for more information about long running scripts.</source>
          <target state="translated">Эта команда-единственный способ прервать работу долгоработающего скрипта,который достигает настроенного максимального времени выполнения скриптов.Команда SCRIPT KILL может быть использована только с теми скриптами,которые не изменяли набор данных во время своего выполнения (так как остановка скрипта,доступного только для чтения,не нарушает гарантированную атомарность механизма сценариев).Дополнительную информацию о долгоработающих скриптах смотрите в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="74540a3a51962d64e542e90991498fda99b11c4b" translate="yes" xml:space="preserve">
          <source>This command is used in order to manage the consumer groups associated with a stream data structure. Using &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; you can:</source>
          <target state="translated">Эта команда используется для управления группами потребителей, связанными со структурой данных потока. Используя &lt;a href=&quot;xgroup&quot;&gt;XGROUP,&lt;/a&gt; вы можете:</target>
        </trans-unit>
        <trans-unit id="0f3f38de2ae9dc1853425848b341ace4420d82e4" translate="yes" xml:space="preserve">
          <source>This command is used in order to read and reset the Redis slow queries log.</source>
          <target state="translated">Эта команда используется для чтения и сброса журнала медленных запросов Redis.</target>
        </trans-unit>
        <trans-unit id="4469a3906600e48388ff32654f41a170c058ed11" translate="yes" xml:space="preserve">
          <source>This command is useful as it makes able to switch clients from a Redis instance to another one in a controlled way. For example during an instance upgrade the system administrator could do the following:</source>
          <target state="translated">Эта команда полезна,поскольку она позволяет контролировать переключение клиентов с экземпляра Redis на другой экземпляр.Например,во время обновления экземпляра системный администратор может сделать следующее:</target>
        </trans-unit>
        <trans-unit id="7716c05ccc0dd7cac30547152d82c808312925c0" translate="yes" xml:space="preserve">
          <source>This command is useful especially when we are monitoring many keys with a limited number of connections. For instance we may want to monitor multiple streams with &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; without using more than N connections. However at some point the consumer process is informed that there is one more stream key to monitor. In order to avoid using more connections, the best behavior would be to stop the blocking command from one of the connections in the pool, add the new key, and issue the blocking command again.</source>
          <target state="translated">Эта команда особенно полезна, когда мы отслеживаем множество ключей с ограниченным количеством подключений. Например, мы можем захотеть отслеживать несколько потоков с помощью &lt;a href=&quot;xread&quot;&gt;XREAD,&lt;/a&gt; не используя более N подключений. Однако в какой-то момент потребительский процесс получает информацию о том, что необходимо отслеживать еще один ключ потока. Чтобы избежать использования большего количества подключений, лучше всего остановить команду блокировки от одного из подключений в пуле, добавить новый ключ и снова выполнить команду блокировки.</target>
        </trans-unit>
        <trans-unit id="59ff8c186eb229a2dac30dbd70e43e24baabed7c" translate="yes" xml:space="preserve">
          <source>This command is useful in order to modify a node's view of the cluster configuration. Specifically it assigns a set of hash slots to the node receiving the command. If the command is successful, the node will map the specified hash slots to itself, and will start broadcasting the new configuration.</source>
          <target state="translated">Эта команда полезна для изменения представления узла о конфигурации кластера.Конкретно она назначает набор хэш-слотов узлу,получающему команду.Если команда окажется успешной,узел отобразит указанные хэш-слоты на себя и начнет трансляцию новой конфигурации.</target>
        </trans-unit>
        <trans-unit id="afcb99c36c15189824ecdc3091bf486391211187" translate="yes" xml:space="preserve">
          <source>This command is very similar to &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;: it removes the specified keys. Just like &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; a key is ignored if it does not exist. However the command performs the actual memory reclaiming in a different thread, so it is not blocking, while &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; is. This is where the command name comes from: the command just &lt;strong&gt;unlinks&lt;/strong&gt; the keys from the keyspace. The actual removal will happen later asynchronously.</source>
          <target state="translated">Эта команда очень похожа на &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; : она удаляет указанные ключи. Так же, как и &lt;a href=&quot;del&quot;&gt;DEL,&lt;/a&gt; ключ игнорируется, если он не существует. Однако команда выполняет фактическое освобождение памяти в другом потоке, поэтому она не блокируется, в то время как &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; . Отсюда и происходит название команды: команда просто &lt;strong&gt;отсоединяет&lt;/strong&gt; ключи от пространства ключей. Фактическое удаление произойдет позже асинхронно.</target>
        </trans-unit>
        <trans-unit id="8d70f66fb80485b6d531d7d9ab8ad149118bee56" translate="yes" xml:space="preserve">
          <source>This command loads and initializes the Redis module from the dynamic library specified by the &lt;code&gt;path&lt;/code&gt; argument. The &lt;code&gt;path&lt;/code&gt; should be the absolute path of the library, including the full filename. Any additional arguments are passed unmodified to the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7d9161cbb27663ecc1a90a3f6bb05f23dbad84" translate="yes" xml:space="preserve">
          <source>This command only works in cluster mode and is useful in the following Redis Cluster operations:</source>
          <target state="translated">Эта команда работает только в кластерном режиме и полезна при следующих операциях Redis Cluster:</target>
        </trans-unit>
        <trans-unit id="ae45a8ae2f8e5aecd7b6912a681c88c74a505274" translate="yes" xml:space="preserve">
          <source>This command only works in cluster mode and may be useful for debugging and in order to manually orchestrate a cluster configuration when a new cluster is created. It is currently not used by &lt;code&gt;redis-trib&lt;/code&gt;, and mainly exists for API completeness.</source>
          <target state="translated">Эта команда работает только в режиме кластера и может быть полезна для отладки и для ручной оркестровки конфигурации кластера при создании нового кластера. В настоящее время он не используется &lt;code&gt;redis-trib&lt;/code&gt; и существует в основном для полноты API.</target>
        </trans-unit>
        <trans-unit id="b0562f793b35f58a57b7250775581e06cabbe124" translate="yes" xml:space="preserve">
          <source>This command performs a full reset of the connection's server-side context, mimicking the effect of disconnecting and reconnecting again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5304131d86dfa25555f9abe5b57dd4ad31bed60" translate="yes" xml:space="preserve">
          <source>This command registers the specified script in the Redis script cache. The command is useful in all the contexts where we want to make sure that &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; will not fail (for instance during a pipeline or MULTI/EXEC operation), without the need to actually execute the script.</source>
          <target state="translated">Эта команда регистрирует указанный сценарий в кэше сценариев Redis. Команда полезна во всех контекстах, где мы хотим убедиться, что &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; не выйдет из строя (например, во время конвейера или операции MULTI / EXEC), без необходимости фактического выполнения сценария.</target>
        </trans-unit>
        <trans-unit id="09806309aef17ea4d51d659e1cc3d714503d0680" translate="yes" xml:space="preserve">
          <source>This command returns the client ID we are redirecting our &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;tracking&lt;/a&gt; notifications to. We set a client to redirect to when using &lt;a href=&quot;client-tracking&quot;&gt;CLIENT TRACKING&lt;/a&gt; to enable tracking. However in order to avoid forcing client libraries implementations to remember the ID notifications are redirected to, this command exists in order to improve introspection and allow clients to check later if redirection is active and towards which client ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef7e7424bc09f286d32a4b812efe8253277e59f5" translate="yes" xml:space="preserve">
          <source>This command returns the number of failure reports for the current node which are currently not expired (so received within two times the &lt;em&gt;node timeout&lt;/em&gt; time). The count does not include what the node we are asking this count believes about the node ID we pass as argument, the count &lt;em&gt;only&lt;/em&gt; includes the failure reports the node received from other nodes.</source>
          <target state="translated">Эта команда возвращает количество отчетов об ошибках для текущего узла, срок действия которых в настоящее время не истек (т.е. получено в течение &lt;em&gt;двухкратного&lt;/em&gt; времени &lt;em&gt;тайм-аута узла&lt;/em&gt; ). Счетчик не включает то, что узел, который мы запрашиваем, верит в этот подсчет об идентификаторе узла, который мы передаем в качестве аргумента, счетчик включает &lt;em&gt;только&lt;/em&gt; отчеты об ошибках, полученные узлом от других узлов.</target>
        </trans-unit>
        <trans-unit id="541223fddf4b501cc96317842ccc50859641cd10" translate="yes" xml:space="preserve">
          <source>This command sets a specific &lt;em&gt;config epoch&lt;/em&gt; in a fresh node. It only works when:</source>
          <target state="translated">Эта команда устанавливает определенную &lt;em&gt;эпоху конфигурации&lt;/em&gt; в новом узле. Работает только когда:</target>
        </trans-unit>
        <trans-unit id="18e23f892090be38939eafd00c77e503dab8c192" translate="yes" xml:space="preserve">
          <source>This command swaps two Redis databases, so that immediately all the clients connected to a given database will see the data of the other database, and the other way around. Example:</source>
          <target state="translated">Эта команда меняет местами две базы данных Redis,так что все клиенты,подключенные к данной базе данных,сразу же увидят данные другой базы данных,и наоборот.Пример:</target>
        </trans-unit>
        <trans-unit id="75c1ca96e42909a085011b83f917c82db8bdd8f7" translate="yes" xml:space="preserve">
          <source>This command unloads the module specified by &lt;code&gt;name&lt;/code&gt;. Note that the module's name is reported by the &lt;a href=&quot;module-list&quot;&gt;MODULE LIST&lt;/a&gt; command, and may differ from the dynamic library's filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6adc7a43ee507fff544bbc6adc515bc47ac97ad4" translate="yes" xml:space="preserve">
          <source>This command was introduced in the middle of a Redis stable release, specifically with Redis 2.8.12.</source>
          <target state="translated">Эта команда была введена в середине стабильного релиза Redis,а именно в Redis 2.8.12.</target>
        </trans-unit>
        <trans-unit id="838bb242e39a256bd97fcf68121a5b0ba9ba6cad" translate="yes" xml:space="preserve">
          <source>This command works exactly like &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; but the time to live of the key is specified in milliseconds instead of seconds.</source>
          <target state="translated">Эта команда работает точно так же, как &lt;a href=&quot;expire&quot;&gt;EXPIRE,&lt;/a&gt; но время жизни ключа указывается в миллисекундах, а не в секундах.</target>
        </trans-unit>
        <trans-unit id="7341623725ef962c36ad811614642ab5632c4c2c" translate="yes" xml:space="preserve">
          <source>This command, that can only be sent to a Redis Cluster replica node, forces the replica to start a manual failover of its master instance.</source>
          <target state="translated">Эта команда,которую можно отправить только на узел реплики Redis Cluster,заставляет реплику запустить ручной обход отказа ее основного экземпляра.</target>
        </trans-unit>
        <trans-unit id="4da304a4683087def0d8d26eb2c481c6af27db0a" translate="yes" xml:space="preserve">
          <source>This conversion between data types is designed in a way that if a Redis type is converted into a Lua type, and then the result is converted back into a Redis type, the result is the same as the initial value.</source>
          <target state="translated">Это преобразование между типами данных построено таким образом,что если тип Redis преобразуется в тип Lua,а затем результат преобразуется обратно в тип Redis,то результат будет таким же,как и начальное значение.</target>
        </trans-unit>
        <trans-unit id="e18d68145955b4559f3ba803d90954ff94c0dac8" translate="yes" xml:space="preserve">
          <source>This dynamic is clearly explained in the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Stream intro documentation&lt;/a&gt;.</source>
          <target state="translated">Эта динамика четко объяснена во &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;вводной документации Stream&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19d5d3191e2445ef69de01881bb5939b9f401be6" translate="yes" xml:space="preserve">
          <source>This example shows the application in the context of Redis streams, however the pattern is a general one and can be applied to other cases.</source>
          <target state="translated">В данном примере приложение показано в контексте потоков Redis,однако образец является общим и может быть применен в других случаях.</target>
        </trans-unit>
        <trans-unit id="7b81b5550c835cb846e3da1e36e1dc058efa8bc9" translate="yes" xml:space="preserve">
          <source>This form just authenticates against the password set with &lt;code&gt;requirepass&lt;/code&gt;. In this configuration Redis will deny any command executed by the just connected clients, unless the connection gets authenticated via &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c30a4ad86f29101d3c1fcdfab12485ff0ca6c027" translate="yes" xml:space="preserve">
          <source>This format allows for radius querying by checking the 1+8 areas needed to cover the whole radius, and discarding elements outside the radius. The areas are checked by calculating the range of the box covered removing enough bits from the less significant part of the sorted set score, and computing the score range to query in the sorted set for each area.</source>
          <target state="translated">Этот формат позволяет осуществлять запрос по радиусу,проверяя области 1+8,необходимые для покрытия всего радиуса,и отбрасывая элементы за пределами радиуса.Области проверяются путем вычисления диапазона покрываемого поля,удаляющего достаточное количество битов из менее значимой части отсортированного множества,а также путем вычисления диапазона оценки для запроса в отсортированном множестве для каждой области.</target>
        </trans-unit>
        <trans-unit id="5f7d96d3049d4f76efb356668757ef71fbc55342" translate="yes" xml:space="preserve">
          <source>This has the same effect as running &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt; with one argument &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Это имеет тот же эффект, что и запуск &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt; с одним &lt;code&gt;key&lt;/code&gt; аргумента .</target>
        </trans-unit>
        <trans-unit id="5d0bfed0b5c7c513675b9c26b7ab5ed0c6f3d603" translate="yes" xml:space="preserve">
          <source>This is a good overview, but sometimes we are interested in the details. In order to see all the pending messages with more associated information we need to also pass a range of IDs, in a similar way we do it with &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, and a non optional &lt;em&gt;count&lt;/em&gt; argument, to limit the number of messages returned per call:</source>
          <target state="translated">Это хороший обзор, но иногда нас интересуют детали. Чтобы увидеть все ожидающие сообщения с дополнительной связанной информацией, нам необходимо также передать диапазон идентификаторов, аналогично тому, как мы делаем это с &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; , и необязательным аргументом &lt;em&gt;count&lt;/em&gt; , чтобы ограничить количество сообщений, возвращаемых за один вызов:</target>
        </trans-unit>
        <trans-unit id="90aa8094613e02ff36a67a68b984d933a74e701a" translate="yes" xml:space="preserve">
          <source>This is a list of all the supported Redis ACL rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b4d531c8516c33061d94d3a8959add03c42f29" translate="yes" xml:space="preserve">
          <source>This is a trivial probabilistic algorithm, basically the assumption is that our sample is representative of the whole key space, and we continue to expire until the percentage of keys that are likely to be expired is under 25%</source>
          <target state="translated">Это тривиальный вероятностный алгоритм,в основе которого лежит предположение,что наша выборка репрезентативна для всего пространства ключей,и мы продолжаем истекать до тех пор,пока процент ключей,которые могут истечь,не достигнет 25%.</target>
        </trans-unit>
        <trans-unit id="c48adb8e8d877ae182110cc1e68d2e6bc1d83311" translate="yes" xml:space="preserve">
          <source>This is an example of blocking invocation, where the command later returns a null reply because the timeout has elapsed without new data arriving:</source>
          <target state="translated">Это пример блокирования вызова,когда команда позже возвращает нулевой ответ,так как таймаут истек без поступления новых данных:</target>
        </trans-unit>
        <trans-unit id="622bd341d8dc701d53c24284f457bffb1eb9df29" translate="yes" xml:space="preserve">
          <source>This is an example of iteration using &lt;strong&gt;MATCH&lt;/strong&gt;:</source>
          <target state="translated">Это пример итерации с использованием &lt;strong&gt;MATCH&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4d789554ece00f72c77acd57e4f313f31c717e24" translate="yes" xml:space="preserve">
          <source>This is an introspection command used in order to retrieve different information about the streams and associated consumer groups. Three forms are possible:</source>
          <target state="translated">Это команда самоанализа,используемая для получения различной информации о потоках и связанных с ними группах потребителей.Возможны три формы:</target>
        </trans-unit>
        <trans-unit id="fa13476351797926204e99a9b54034d28b5780cc" translate="yes" xml:space="preserve">
          <source>This is easy to see intuitively: if the collection grows there is more and more work to do in order to visit all the possible elements, and the ability to terminate the iteration depends on the number of calls to &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; and its COUNT option value compared with the rate at which the collection grows.</source>
          <target state="translated">Это легко увидеть интуитивно: если коллекция растет, необходимо выполнить все больше и больше работы, чтобы посетить все возможные элементы, а возможность завершить итерацию зависит от количества вызовов &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; и его значения параметра COUNT по сравнению с скорость роста коллекции.</target>
        </trans-unit>
        <trans-unit id="5ecf6a9694906630d3be8ffa19f791d25178c710" translate="yes" xml:space="preserve">
          <source>This is how a typical &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; call looks like in the first iteration of a consumer willing to consume only new entries:</source>
          <target state="translated">Вот как выглядит типичный вызов &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; в первой итерации потребителя, желающего потреблять только новые записи:</target>
        </trans-unit>
        <trans-unit id="720fb76cbe63b3ee37bb596512afa1691c9ba3f2" translate="yes" xml:space="preserve">
          <source>This is how to understand if you want to use a consumer group or not:</source>
          <target state="translated">Это то,как понять,хотите ли вы использовать группу потребителей или нет:</target>
        </trans-unit>
        <trans-unit id="2d94df873adfd43289accd82b71abdee4a8063f4" translate="yes" xml:space="preserve">
          <source>This is how we use this command in order to mount such an algorithm:</source>
          <target state="translated">Вот как мы используем эту команду для монтирования такого алгоритма:</target>
        </trans-unit>
        <trans-unit id="c0d3b602529b7dea150254bfa283c67fb2eed932" translate="yes" xml:space="preserve">
          <source>This is the output you should post in the Redis mailing list if you are looking for help about Latency related issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9658590fc318422333085d731b93a7035c7459f" translate="yes" xml:space="preserve">
          <source>This is useful in several ways depending on the use case:</source>
          <target state="translated">Это полезно несколькими способами в зависимости от варианта использования:</target>
        </trans-unit>
        <trans-unit id="bcf3a4afdd1a41afed7a49db731a6c6ebfa0cc2a" translate="yes" xml:space="preserve">
          <source>This is useful to an application that wants to fetch raw data in order to perform monitoring, display graphs, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a58d44535039d5a20b0fa97b3b1ee43b1b6dd46" translate="yes" xml:space="preserve">
          <source>This is usually needed only when the instance is going to be instantiated for another customer or application in a cloud environment.</source>
          <target state="translated">Обычно это необходимо только тогда,когда экземпляр будет инстанцирован для другого клиента или приложения в облачной среде.</target>
        </trans-unit>
        <trans-unit id="bbfa8fbc11f623748d63d11e9bf5ee03c12ff234" translate="yes" xml:space="preserve">
          <source>This manual page also covers the &lt;code&gt;GEORADIUS_RO&lt;/code&gt; and &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; variants (see the section below for more information).</source>
          <target state="translated">Эта страница руководства также охватывает варианты &lt;code&gt;GEORADIUS_RO&lt;/code&gt; и &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; (дополнительную информацию см. В разделе ниже).</target>
        </trans-unit>
        <trans-unit id="d223d35db64e1d19fc9f2926f21b42e4ab2344a9" translate="yes" xml:space="preserve">
          <source>This means that at any given moment the maximum amount of keys already expired that are using memory is at max equal to max amount of write operations per second divided by 4.</source>
          <target state="translated">Это означает,что в любой момент времени максимальное количество уже истекших ключей,использующих память,равно максимальному количеству операций записи в секунду,деленному на 4.</target>
        </trans-unit>
        <trans-unit id="aabcd9a95a39d430c629afa9fad1b539c022ac85" translate="yes" xml:space="preserve">
          <source>This means that if you have two non-empty buckets in the entire hash table, and one has three elements while one has just one, the element that is alone in its bucket will be returned with much higher probability.</source>
          <target state="translated">Это означает,что если у вас есть два непустых ведра во всей хэш-таблице,и в одном из них три элемента,а в другом только один,то с гораздо большей вероятностью будет возвращен элемент,находящийся в одиночестве в своем ведре.</target>
        </trans-unit>
        <trans-unit id="249f94aa848de22f03290fa35dfb93a51fdb5d7d" translate="yes" xml:space="preserve">
          <source>This means that this command should be used with care only by applications orchestrating Redis Cluster, like &lt;code&gt;redis-trib&lt;/code&gt;, and the command if used out of the right context can leave the cluster in a wrong state or cause data loss.</source>
          <target state="translated">Это означает, что эту команду следует использовать с осторожностью только приложениями, управляющими Redis Cluster, такими как &lt;code&gt;redis-trib&lt;/code&gt; , и команда, если ее использовать вне правильного контекста, может оставить кластер в неправильном состоянии или вызвать потерю данных.</target>
        </trans-unit>
        <trans-unit id="b4b18f04b9acb83f71f24c60b244188e2d234cce" translate="yes" xml:space="preserve">
          <source>This means that you set:</source>
          <target state="translated">Это значит,что ты установил:</target>
        </trans-unit>
        <trans-unit id="8a0b4cfa314b524daabda36aba34d428f894ef1e" translate="yes" xml:space="preserve">
          <source>This operation is similar to &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;, that returns one or more random elements from a set but does not remove it.</source>
          <target state="translated">Эта операция аналогична &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt; , которая возвращает один или несколько случайных элементов из набора, но не удаляет его.</target>
        </trans-unit>
        <trans-unit id="b82ae6d609ba5f4bff538ca99ae907087f8e8c97" translate="yes" xml:space="preserve">
          <source>This pair of commands will push a new element on the list, while making sure that the list will not grow larger than 100 elements. This is very useful when using Redis to store logs for example. It is important to note that when used in this way &lt;a href=&quot;ltrim&quot;&gt;LTRIM&lt;/a&gt; is an O(1) operation because in the average case just one element is removed from the tail of the list.</source>
          <target state="translated">Эта пара команд поместит новый элемент в список, при этом следя за тем, чтобы список не увеличивался более чем до 100 элементов. Это очень полезно, например, при использовании Redis для хранения журналов. Важно отметить, что при таком использовании &lt;a href=&quot;ltrim&quot;&gt;LTRIM&lt;/a&gt; является операцией O (1), потому что в среднем случае из хвоста списка удаляется только один элемент.</target>
        </trans-unit>
        <trans-unit id="80b9715de053267e5fffa59b0b1112d991e9ba3f" translate="yes" xml:space="preserve">
          <source>This pattern is easily modified to use counters using &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; instead of lists using &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;.</source>
          <target state="translated">Этот шаблон легко изменить для использования счетчиков с использованием &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; вместо списков с использованием &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d386987d572848d3712f1ff810e5567134c02087" translate="yes" xml:space="preserve">
          <source>This simple pattern can be extended in many ways:</source>
          <target state="translated">Эта простая модель может быть расширена различными способами:</target>
        </trans-unit>
        <trans-unit id="92785c4b9f557c4d2558a4fa95a80f3ac27c63a5" translate="yes" xml:space="preserve">
          <source>This subcommand is the reverse of &lt;code&gt;MIGRATING&lt;/code&gt;, and prepares the destination node to import keys from the specified source node. The command only works if the node is not already owner of the specified hash slot.</source>
          <target state="translated">Эта подкоманда противоположна &lt;code&gt;MIGRATING&lt;/code&gt; и подготавливает целевой узел к импорту ключей из указанного исходного узла. Команда работает, только если узел еще не является владельцем указанного хэш-слота.</target>
        </trans-unit>
        <trans-unit id="3af1b4ceac0630f2f07d73ce38551a82afebcee6" translate="yes" xml:space="preserve">
          <source>This subcommand just clears migrating / importing state from the slot. It is mainly used to fix a cluster stuck in a wrong state by &lt;code&gt;redis-trib fix&lt;/code&gt;. Normally the two states are cleared automatically at the end of the migration using the &lt;code&gt;SETSLOT ... NODE ...&lt;/code&gt; subcommand as explained in the next section.</source>
          <target state="translated">Эта подкоманда просто очищает состояние миграции / импорта из слота. В основном он используется для исправления &lt;code&gt;redis-trib fix&lt;/code&gt; в неправильном состоянии кластера с помощью redis-trib fix . Обычно два состояния сбрасываются автоматически в конце миграции с помощью &lt;code&gt;SETSLOT ... NODE ...&lt;/code&gt; как описано в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="9fe3e638e8830d97f18b8e18e7bb1f71a19b5a85" translate="yes" xml:space="preserve">
          <source>This subcommand sets a slot to &lt;em&gt;migrating&lt;/em&gt; state. In order to set a slot in this state, the node receiving the command must be the hash slot owner, otherwise an error is returned.</source>
          <target state="translated">Эта подкоманда устанавливает слот в состояние &lt;em&gt;миграции&lt;/em&gt; . Чтобы установить слот в это состояние, узел, получающий команду, должен быть владельцем хэш-слота, иначе будет возвращена ошибка.</target>
        </trans-unit>
        <trans-unit id="edb8d5f6aeacab24056a48e5cdeee519f5cf870a" translate="yes" xml:space="preserve">
          <source>This way clients are moved away from the old master to the new master atomically and only when the replica that is turning into the new master has processed all of the replication stream from the old master.</source>
          <target state="translated">Таким образом,клиенты перемещаются от старого мастера к новому только тогда,когда реплика,превращающаяся в нового мастера,обработала весь поток репликации от старого мастера.</target>
        </trans-unit>
        <trans-unit id="eabc7eeeb462a96b3b77723425f464bf9ccbef27" translate="yes" xml:space="preserve">
          <source>This way we have a 60 second window to inform all the nodes in the cluster that we want to remove a node.</source>
          <target state="translated">В этом случае у нас есть 60-секундное окно,информирующее все узлы кластера о том,что мы хотим удалить узел.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
