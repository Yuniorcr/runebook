<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="75d00cd00e1f2b13a890f0d28b95cf6fbe73de9c" translate="yes" xml:space="preserve">
          <source>An error is returned for out of range indexes.</source>
          <target state="translated">Возвращается ошибка для индексов вне диапазона.</target>
        </trans-unit>
        <trans-unit id="e1e52880ba8cd5516094695a791c7cb25bb9cf75" translate="yes" xml:space="preserve">
          <source>An error is returned if &lt;code&gt;source&lt;/code&gt; or &lt;code&gt;destination&lt;/code&gt; does not hold a set value.</source>
          <target state="translated">Ошибка возвращается, если &lt;code&gt;source&lt;/code&gt; или &lt;code&gt;destination&lt;/code&gt; не содержат заданного значения.</target>
        </trans-unit>
        <trans-unit id="c6dddcbd9570408a2bf9a7b091594de5d13db0b1" translate="yes" xml:space="preserve">
          <source>An error is returned if there is already a background save running or if there is another non-background-save process running, specifically an in-progress AOF rewrite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f347bee22b5d2cb10d2901659685fcd72a034c77" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists and does not hold a sorted set.</source>
          <target state="translated">Ошибка возвращается, если &lt;code&gt;key&lt;/code&gt; существует и не содержит отсортированного набора.</target>
        </trans-unit>
        <trans-unit id="e231fa35664a84f1e5009d81e7f6bba1d485eec3" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists but does not hold a list value.</source>
          <target state="translated">Ошибка возвращается, если &lt;code&gt;key&lt;/code&gt; существует, но не содержит значения списка.</target>
        </trans-unit>
        <trans-unit id="6bdfaaedacc744e822937a491c0aa265faa0a3c9" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists but does not hold a sorted set.</source>
          <target state="translated">Ошибка возвращается, если &lt;code&gt;key&lt;/code&gt; существует, но не содержит отсортированного набора.</target>
        </trans-unit>
        <trans-unit id="cafd7db432cc1bfe0eb095227c59268bb7b93c9e" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;seconds&lt;/code&gt; is invalid.</source>
          <target state="translated">Ошибка возвращается, если &lt;code&gt;seconds&lt;/code&gt; недействительны.</target>
        </trans-unit>
        <trans-unit id="8e9136354e1045681dd2f7a86b9527fc481d91cd" translate="yes" xml:space="preserve">
          <source>An error is returned when the value stored at &lt;code&gt;key&lt;/code&gt; is not a set.</source>
          <target state="translated">Ошибка возвращается, если значение, хранящееся в &lt;code&gt;key&lt;/code&gt; , не установлено.</target>
        </trans-unit>
        <trans-unit id="b4eb1a0965c235064ac8aba79722ddaff3491eef" translate="yes" xml:space="preserve">
          <source>An example of Sentinel output:</source>
          <target state="translated">Пример выхода Sentinel:</target>
        </trans-unit>
        <trans-unit id="e3a2b833146840fa4cd410d9b71d1f7b478f823c" translate="yes" xml:space="preserve">
          <source>An example of output when &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; is called in a master instance:</source>
          <target state="translated">Пример вывода при вызове &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; в главном экземпляре:</target>
        </trans-unit>
        <trans-unit id="579d469e7cac2523515437d9b8d6112fe3d93c9e" translate="yes" xml:space="preserve">
          <source>An example of output when &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; is called in a replica instance:</source>
          <target state="translated">Пример вывода , когда &lt;a href=&quot;role&quot;&gt;Роль&lt;/a&gt; вызывается в случае реплик:</target>
        </trans-unit>
        <trans-unit id="1d6f1c424d50ab94243fe38cbdfeabffd674d66c" translate="yes" xml:space="preserve">
          <source>An example of unlock script would be similar to the following:</source>
          <target state="translated">Пример скрипта разблокировки будет аналогичен следующему:</target>
        </trans-unit>
        <trans-unit id="89fe7da248c22605a4e15750b1f9beb107181168" translate="yes" xml:space="preserve">
          <source>An example sampling the temperature of a sensor using fixed-size strings (using a binary format is better in real implementations).</source>
          <target state="translated">Пример выборки температуры датчика с использованием строк фиксированного размера (в реальных реализациях лучше использовать двоичный формат).</target>
        </trans-unit>
        <trans-unit id="4eae947ad09e05cad458fca2075b30ae1b15869c" translate="yes" xml:space="preserve">
          <source>An interesting pattern using &lt;code&gt;SORT ... STORE&lt;/code&gt; consists in associating an &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; timeout to the resulting key so that in applications where the result of a &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; operation can be cached for some time. Other clients will use the cached list instead of calling &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; for every request. When the key will timeout, an updated version of the cache can be created by calling &lt;code&gt;SORT ... STORE&lt;/code&gt; again.</source>
          <target state="translated">Интересный паттерн с использованием &lt;code&gt;SORT ... STORE&lt;/code&gt; заключается в &lt;a href=&quot;expire&quot;&gt;связывании&lt;/a&gt; тайм-аута EXPIRE с результирующим ключом, чтобы в приложениях, где результат операции &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; можно было кэшировать на некоторое время. Другие клиенты будут использовать кэшированный список вместо вызова &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; для каждого запроса. Когда истечет время ожидания ключа, можно создать обновленную версию кеша, снова вызвав &lt;code&gt;SORT ... STORE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c296bdf9668142740fec726611d45d470138dafa" translate="yes" xml:space="preserve">
          <source>An iteration starts when the cursor is set to 0, and terminates when the cursor returned by the server is 0. The following is an example of SCAN iteration:</source>
          <target state="translated">Итерация начинается,когда курсор установлен на 0,и заканчивается,когда курсор,возвращаемый сервером,равен 0.Ниже приведен пример SCAN-итерации:</target>
        </trans-unit>
        <trans-unit id="060444849d7b2e77c482c80d4ddc007637e5e3e9" translate="yes" xml:space="preserve">
          <source>And so for until the iteration is complete and no result is returned. See the &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; page about iterating for more information.</source>
          <target state="translated">И так до тех пор, пока итерация не будет завершена и результат не будет возвращен. См. &lt;a href=&quot;xrange&quot;&gt;Страницу XRANGE&lt;/a&gt; об итерациях для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="abbabebfac6efc7292e2eb1b2e18a22fb8f0b07b" translate="yes" xml:space="preserve">
          <source>And so forth.</source>
          <target state="translated">И так далее.</target>
        </trans-unit>
        <trans-unit id="4c3a5cf2099eac6b70d3351f9f2b307f8576cbfe" translate="yes" xml:space="preserve">
          <source>And so forth. Eventually this will allow to visit all the entries in the stream. Obviously, we can start the iteration from any ID, or even from a specific time, by providing a given incomplete start ID. Moreover, we can limit the iteration to a given ID or time, by providing an end ID or incomplete ID instead of &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">И так далее. В конце концов это позволит посетить все записи в потоке. Очевидно, мы можем начать итерацию с любого идентификатора или даже с определенного времени, указав данный неполный идентификатор запуска. Более того, мы можем ограничить итерацию заданным идентификатором или временем, указав конечный идентификатор или неполный идентификатор вместо &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd50a85c7e0471c36280c42d04f369b2283aaee5" translate="yes" xml:space="preserve">
          <source>And so forth. Eventually, the call will not return any item, but just an empty array, then we know that there is nothing more to fetch from our stream (and we would have to retry the operation, hence this command also supports a blocking mode).</source>
          <target state="translated">И так далее.В конце концов,вызов не вернет ни одного элемента,а только пустой массив,тогда мы знаем,что больше нечего извлекать из нашего потока (и нам пришлось бы повторять операцию,следовательно,эта команда также поддерживает режим блокировки).</target>
        </trans-unit>
        <trans-unit id="087d39ee1a0310d3323a4cfd02c6576b584cb468" translate="yes" xml:space="preserve">
          <source>Another example: if we imagine a cluster formed of the following four nodes called A, B, C and D, we may send just the following set of commands to A:</source>
          <target state="translated">Другой пример:если мы представим кластер,состоящий из следующих четырех узлов под названием A,B,C и D,мы можем послать только следующий набор команд в A:</target>
        </trans-unit>
        <trans-unit id="852a8d39c81588746b082fd9f4167b5bb251bb69" translate="yes" xml:space="preserve">
          <source>Any other ID, that is, 0 or any other valid ID or incomplete ID (just the millisecond time part), will have the effect of returning entries that are pending for the consumer sending the command with IDs greater than the one provided. So basically if the ID is not &lt;code&gt;&amp;gt;&lt;/code&gt;, then the command will just let the client access its pending entries: messages delivered to it, but not yet acknowledged. Note that in this case, both &lt;code&gt;BLOCK&lt;/code&gt; and &lt;code&gt;NOACK&lt;/code&gt; are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0eff051adefea749add42d4d6cb2b879ab75ce" translate="yes" xml:space="preserve">
          <source>Any other ID, that is, 0 or any other valid ID or incomplete ID (just the millisecond time part), will have the effect of returning entries that are pending for the consumer sending the command. So basically if the ID is not &lt;code&gt;&amp;gt;&lt;/code&gt;, then the command will just let the client access its pending entries: delivered to it, but not yet acknowledged.</source>
          <target state="translated">Любой другой идентификатор, то есть 0 или любой другой допустимый идентификатор или неполный идентификатор (только часть времени в миллисекундах), будет иметь эффект возврата записей, ожидающих отправки потребителем, отправляющим команду. Таким образом, в основном, если идентификатор не &lt;code&gt;&amp;gt;&lt;/code&gt; , тогда команда просто позволит клиенту получить доступ к своим ожидающим записям: доставлено ему, но еще не подтверждено.</target>
        </trans-unit>
        <trans-unit id="bf48c58a252cd0f11f754a6235c3bf6580ab92b5" translate="yes" xml:space="preserve">
          <source>Anyway even assuming a single-instance locking primitive, starting with 2.6.12 it is possible to create a much simpler locking primitive, equivalent to the one discussed here, using the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command to acquire the lock, and a simple Lua script to release the lock. The pattern is documented in the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command page.</source>
          <target state="translated">В любом случае, даже предполагая примитив блокировки одного экземпляра, начиная с версии 2.6.12, можно создать гораздо более простой примитив блокировки, эквивалентный описанному здесь, используя команду &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; для получения блокировки и простой сценарий Lua для освобождения замок. Шаблон задокументирован на странице команд &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="274153f2cd2566cd42de1da9ffc1b6d3d2cf50ae" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; is similar to &lt;a href=&quot;zrange&quot;&gt;ZRANGE&lt;/a&gt;.</source>
          <target state="translated">За исключением обратного порядка, &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; аналогичен &lt;a href=&quot;zrange&quot;&gt;ZRANGE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dae9346322df90f8b168ba54317fbcb22d67c378" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrangebylex&quot;&gt;ZREVRANGEBYLEX&lt;/a&gt; is similar to &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;.</source>
          <target state="translated">За исключением обратного порядка, &lt;a href=&quot;zrevrangebylex&quot;&gt;ZREVRANGEBYLEX&lt;/a&gt; похож на &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5c43ee3f0eb54ffe03d2d092f2d6166614a936e" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrangebyscore&quot;&gt;ZREVRANGEBYSCORE&lt;/a&gt; is similar to &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">За исключением обратного порядка, &lt;a href=&quot;zrevrangebyscore&quot;&gt;ZREVRANGEBYSCORE&lt;/a&gt; похож на &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5abab69f4dc0a66b2f4a79cd40ada74327713efb" translate="yes" xml:space="preserve">
          <source>Appendix: Redis expires</source>
          <target state="translated">Приложение:Срок действия Redis истекает</target>
        </trans-unit>
        <trans-unit id="9ff199315ef371177323189f4cb9355c80a5471f" translate="yes" xml:space="preserve">
          <source>Appends the specified stream entry to the stream at the specified key. If the key does not exist, as a side effect of running this command the key is created with a stream value.</source>
          <target state="translated">Прикладывает к потоку запись в указанном потоке по указанному ключу.Если ключ не существует,то в качестве побочного эффекта выполнения данной команды создается ключ со значением потока.</target>
        </trans-unit>
        <trans-unit id="32f650d6228cf15fb1f6755ed7de0b1329f744eb" translate="yes" xml:space="preserve">
          <source>Appends the specified stream entry to the stream at the specified key. If the key does not exist, as a side effect of running this command the key is created with a stream value. The creation of stream's key can be disabled with the &lt;code&gt;NOMKSTREAM&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a442180dde4ebe00bdaaebef087550dde9ed275" translate="yes" xml:space="preserve">
          <source>As a side effect a pending message entry is created in the pending entries list (PEL) of the consumer group: it means the message was delivered to a given consumer, but it was not yet acknowledged via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;.</source>
          <target state="translated">В качестве побочного эффекта в списке ожидающих записей (PEL) группы потребителей создается запись ожидающего сообщения: это означает, что сообщение было доставлено данному потребителю, но еще не было подтверждено через &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8d3a747f6516b67780fd78990e06b49b5087892" translate="yes" xml:space="preserve">
          <source>As a side effect of &lt;code&gt;A&lt;/code&gt; knowing and being known by all the other nodes, it will send gossip sections in the heartbeat packets that will allow each other node to create a link with each other one, forming a full mesh in a matter of seconds, even if the cluster is large.</source>
          <target state="translated">В качестве побочного эффекта того, что &lt;code&gt;A&lt;/code&gt; знает и известен всем другим узлам, он будет отправлять разделы сплетен в пакетах пульса, которые позволят каждому другому узлу создать связь друг с другом, образуя полную сетку за считанные секунды, даже если кластер большой.</target>
        </trans-unit>
        <trans-unit id="90aa44b5c0b6d562f721575257b4845fb2c1994d" translate="yes" xml:space="preserve">
          <source>As a side effect of the command execution, if a slot among the ones specified as argument is set as &lt;code&gt;importing&lt;/code&gt;, this state gets cleared once the node assigns the (previously unbound) slot to itself.</source>
          <target state="translated">В качестве побочного эффекта выполнения команды, если слот среди указанных в качестве аргумента установлен как &lt;code&gt;importing&lt;/code&gt; , это состояние очищается, как только узел назначает (ранее несвязанный) слот самому себе.</target>
        </trans-unit>
        <trans-unit id="a31cef2ee08d5e8239d818737dfa96674f437698" translate="yes" xml:space="preserve">
          <source>As a side effect of the command execution, the node may go into &lt;em&gt;down&lt;/em&gt; state because not all hash slots are covered.</source>
          <target state="translated">В качестве побочного эффекта выполнения команды узел может перейти в &lt;em&gt;нерабочее&lt;/em&gt; состояние, поскольку не все хэш-слоты покрыты.</target>
        </trans-unit>
        <trans-unit id="fdfda2f0f0a65c5c9350447421bdbd24d0c16cd7" translate="yes" xml:space="preserve">
          <source>As a side effect of this command the HyperLogLog internals may be updated to reflect a different estimation of the number of unique items added so far (the cardinality of the set).</source>
          <target state="translated">В качестве побочного эффекта этой команды внутренние компоненты HyperLogLog могут быть обновлены,чтобы отразить различные оценки количества уникальных элементов,добавленных на данный момент (кардинальность набора).</target>
        </trans-unit>
        <trans-unit id="e3b0ef422a5105dd7a168f1bd22deb9e931a8ad3" translate="yes" xml:space="preserve">
          <source>As already stated, calls to &lt;code&gt;redis.call()&lt;/code&gt; resulting in a Redis command error will stop the execution of the script and return an error, in a way that makes it obvious that the error was generated by a script:</source>
          <target state="translated">Как уже говорилось, вызовы &lt;code&gt;redis.call()&lt;/code&gt; приводящие к ошибке команды Redis, остановят выполнение сценария и вернут ошибку таким образом, чтобы было очевидно, что ошибка была сгенерирована сценарием:</target>
        </trans-unit>
        <trans-unit id="09ac6956fbf7cebafd273a67f1e1e0cc18c9d7d7" translate="yes" xml:space="preserve">
          <source>As of Redis 4.0.0, HSET is variadic and allows for multiple &lt;code&gt;field&lt;/code&gt;/&lt;code&gt;value&lt;/code&gt; pairs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824fabdff9eac7426b269cefa6ab8cb7c6a7fa7e" translate="yes" xml:space="preserve">
          <source>As of v5.0, the optional &lt;code&gt;TYPE type&lt;/code&gt; subcommand can be used to filter the list by clients' type, where &lt;em&gt;type&lt;/em&gt; is one of &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;replica&lt;/code&gt; and &lt;code&gt;pubsub&lt;/code&gt;. Note that clients blocked into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; command are considered to belong to the &lt;code&gt;normal&lt;/code&gt; class.</source>
          <target state="translated">Начиная с версии 5.0, необязательная подкоманда &lt;code&gt;TYPE type&lt;/code&gt; может использоваться для фильтрации списка по типу клиентов, где &lt;em&gt;типом&lt;/em&gt; может быть &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;replica&lt;/code&gt; и &lt;code&gt;pubsub&lt;/code&gt; . Обратите внимание, что клиенты, заблокированные в команде &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; , считаются принадлежащими к &lt;code&gt;normal&lt;/code&gt; классу.</target>
        </trans-unit>
        <trans-unit id="f7fd0e1ced5f80a8c1942174a609b55088d136aa" translate="yes" xml:space="preserve">
          <source>As of version 6.0 you can use this option to ask &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; to only return objects that match a given &lt;code&gt;type&lt;/code&gt;, allowing you to iterate through the database looking for keys of a specific type. The &lt;strong&gt;TYPE&lt;/strong&gt; option is only available on the whole-database &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, not &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; or &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f512cd2f467fc007a16339b78f3f8bd4aa4ddc3" translate="yes" xml:space="preserve">
          <source>As per Redis 4.0.0, HMSET is considered deprecated. Please use &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e2ff1f75cd0a86ae75552c78ee5cbb2c5d2636" translate="yes" xml:space="preserve">
          <source>As per Redis 6.2, GETSET is considered deprecated. Please use &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; with &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; parameter in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca69203d6944d9aedfa83b1745a14df6f143d34" translate="yes" xml:space="preserve">
          <source>As per Redis 6.2.0, BRPOPLPUSH is considered deprecated. Please use &lt;a href=&quot;blmove&quot;&gt;BLMOVE&lt;/a&gt; in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50625700b094276571780430ad92d3906e72fb6e" translate="yes" xml:space="preserve">
          <source>As per Redis 6.2.0, RPOPLPUSH is considered deprecated. Please use &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf598b1b6e40341f8808136a0a46e1f4d5d8d97" translate="yes" xml:space="preserve">
          <source>As you can see 3.333 is converted into 3, &lt;em&gt;somekey&lt;/em&gt; is excluded, and the &lt;em&gt;bar&lt;/em&gt; string is never returned as there is a nil before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20dcd69a8805b2228dfb60a21cf7d97acd5f67c" translate="yes" xml:space="preserve">
          <source>As you can see 3.333 is converted into 3, and the &lt;em&gt;bar&lt;/em&gt; string is never returned as there is a nil before.</source>
          <target state="translated">Как видите, 3.333 конвертируется в 3, и строка &lt;em&gt;такта&lt;/em&gt; никогда не возвращается, так как раньше было ноль.</target>
        </trans-unit>
        <trans-unit id="ec8e8f706055fbdba6360cfb1b417dae6427300e" translate="yes" xml:space="preserve">
          <source>As you can see &lt;strong&gt;NOT&lt;/strong&gt; is special as it only takes an input key, because it performs inversion of bits so it only makes sense as an unary operator.</source>
          <target state="translated">Как видите, оператор &lt;strong&gt;NOT&lt;/strong&gt; является особенным, поскольку он принимает только ключ ввода, поскольку выполняет инверсию битов, поэтому имеет смысл только как унарный оператор.</target>
        </trans-unit>
        <trans-unit id="a732d9b394f216e3ee5501e430e6cf1a3865a69a" translate="yes" xml:space="preserve">
          <source>As you can see in this way removing a node is fragile, we need to send &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; commands to all the nodes ASAP hoping there are no gossip sections processing in the meantime. Because of this problem the command implements a ban-list with an expire time for each entry.</source>
          <target state="translated">Как вы можете видеть, удаление узла таким способом - дело хрупкое, поэтому нам нужно как можно скорее отправить команды &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; всем узлам, надеясь, что тем временем не будут обрабатываться разделы сплетен. Из-за этой проблемы команда реализует запретный список со сроком действия для каждой записи.</target>
        </trans-unit>
        <trans-unit id="aeec0e9426a0a0a54fbf363e2b26ff697ce52419" translate="yes" xml:space="preserve">
          <source>As you can see most of the calls returned zero elements, but the last call where a COUNT of 1000 was used in order to force the command to do more scanning for that iteration.</source>
          <target state="translated">Как вы видите,большинство вызовов возвращали нулевые элементы,но последний вызов,где COUNT из 1000 был использован для того,чтобы заставить команду выполнить больше сканирования для этой итерации.</target>
        </trans-unit>
        <trans-unit id="f1947772b8e632184927e0616393e7edcce03ca1" translate="yes" xml:space="preserve">
          <source>As you can see the &lt;strong&gt;SCAN return value&lt;/strong&gt; is an array of two values: the first value is the new cursor to use in the next call, the second value is an array of elements.</source>
          <target state="translated">Как видите, &lt;strong&gt;возвращаемое значение SCAN&lt;/strong&gt; представляет собой массив из двух значений: первое значение - это новый курсор, который будет использоваться в следующем вызове, второе значение - это массив элементов.</target>
        </trans-unit>
        <trans-unit id="53b31465005a9966a63fe8728e23f94c240abdb1" translate="yes" xml:space="preserve">
          <source>Ask the server to close the connection. The connection is closed as soon as all pending replies have been written to the client.</source>
          <target state="translated">Попросите сервер закрыть соединение.Соединение закрывается,как только все отложенные ответы будут написаны клиенту.</target>
        </trans-unit>
        <trans-unit id="14070ea7474a205db9d3fb81cc4d13bc90f1f1d9" translate="yes" xml:space="preserve">
          <source>Assign itself all the hash slots of its master, and propagate the new configuration to every node which is reachable ASAP, and eventually to every other node.</source>
          <target state="translated">Назначьте себе все хэш-слоты своего хэша и распространите новую конфигурацию на каждый узел,доступный ASAP,и,в конце концов,на каждый другой узел.</target>
        </trans-unit>
        <trans-unit id="dad88cac85a84619b71e6377f7daff4cceaf9449" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;mylist&lt;/code&gt; is a list of numbers, this command will return the same list with the elements sorted from small to large. In order to sort the numbers from large to small, use the &lt;code&gt;DESC&lt;/code&gt; modifier:</source>
          <target state="translated">Предполагая, что &lt;code&gt;mylist&lt;/code&gt; - это список чисел, эта команда вернет тот же список с элементами, отсортированными от маленького к большому. Чтобы отсортировать числа от больших к меньшим, используйте модификатор &lt;code&gt;DESC&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="010bc7ebc048785c84f0ef161a24878d38afdc74" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; and &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; commands only delete keys that were present at the time the command was invoked. Keys created during an asynchronous flush will be unaffected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917fb2b280881b904605b028a37696fbc08e07d1" translate="yes" xml:space="preserve">
          <source>At this point the new conversions are available, specifically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f85fbfa8d38f4d4fc4368e61ca47c40b831995" translate="yes" xml:space="preserve">
          <source>At this point you add all the elements into a sorted set using this algorithm:</source>
          <target state="translated">На этом этапе вы добавляете все элементы в отсортированный набор,используя этот алгоритм:</target>
        </trans-unit>
        <trans-unit id="7f922bf277a422b7aa1b3e6b1ecb1c33f7f356b4" translate="yes" xml:space="preserve">
          <source>At this point, each time you want to get a weighted random element, just compute a random number between 0 and 1 (which is like calling &lt;code&gt;rand()&lt;/code&gt; in most languages), so you can just do:</source>
          <target state="translated">На этом этапе каждый раз, когда вы хотите получить взвешенный случайный элемент, просто вычисляйте случайное число от 0 до 1 (что похоже на вызов &lt;code&gt;rand()&lt;/code&gt; в большинстве языков), поэтому вы можете просто сделать:</target>
        </trans-unit>
        <trans-unit id="eeda06eb4e4b735e9051a2d2f05c160b9b8289f8" translate="yes" xml:space="preserve">
          <source>Atomic rewrite process</source>
          <target state="translated">Атомный процесс переписывания</target>
        </trans-unit>
        <trans-unit id="9081c20623d6921cb283f837b5ab328f068f4ee0" translate="yes" xml:space="preserve">
          <source>Atomically returns and removes the first/last element (head/tail depending on the &lt;code&gt;wherefrom&lt;/code&gt; argument) of the list stored at &lt;code&gt;source&lt;/code&gt;, and pushes the element at the first/last element (head/tail depending on the &lt;code&gt;whereto&lt;/code&gt; argument) of the list stored at &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f74a4fa429114feaddb20d28202c0f4085635272" translate="yes" xml:space="preserve">
          <source>Atomically returns and removes the last element (tail) of the list stored at &lt;code&gt;source&lt;/code&gt;, and pushes the element at the first element (head) of the list stored at &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">Атомарно возвращает и удаляет последний элемент (хвост) списка, хранящегося в &lt;code&gt;source&lt;/code&gt; , и подталкивает элемент к первому элементу (заголовку) списка, хранящегося в месте &lt;code&gt;destination&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6a41c1878a1c7a7b99d6378b8645723ed06556f" translate="yes" xml:space="preserve">
          <source>Atomically sets &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt; and returns the old value stored at &lt;code&gt;key&lt;/code&gt;. Returns an error when &lt;code&gt;key&lt;/code&gt; exists but does not hold a string value.</source>
          <target state="translated">Атомарно устанавливает &lt;code&gt;key&lt;/code&gt; в &lt;code&gt;value&lt;/code&gt; и возвращает старое значение, хранящееся в &lt;code&gt;key&lt;/code&gt; . Возвращает ошибку, если &lt;code&gt;key&lt;/code&gt; существует, но не содержит строковое значение.</target>
        </trans-unit>
        <trans-unit id="8b11c68f40fb668f25d5ebde4e4f0d736514c197" translate="yes" xml:space="preserve">
          <source>Atomically transfer a key from a source Redis instance to a destination Redis instance. On success the key is deleted from the original instance and is guaranteed to exist in the target instance.</source>
          <target state="translated">Атоматическая передача ключа из исходного экземпляра Redis в целевой экземпляр Redis.При успешной передаче ключ удаляется из исходного экземпляра и гарантируется его существование в целевом экземпляре.</target>
        </trans-unit>
        <trans-unit id="120b36c4fdcd059217cbe9ce714cea19b13fd52a" translate="yes" xml:space="preserve">
          <source>Atomicity of scripts</source>
          <target state="translated">Атомность сценариев</target>
        </trans-unit>
        <trans-unit id="6a7f6b699ae2620127572c6b19a3962b68ea30ba" translate="yes" xml:space="preserve">
          <source>Available libraries</source>
          <target state="translated">Доступные библиотеки</target>
        </trans-unit>
        <trans-unit id="fc1c7e083bc573df54c3a610bc7a64ef713879e0" translate="yes" xml:space="preserve">
          <source>B sends node A a heartbeat packet, where node D is listed.</source>
          <target state="translated">B посылает узлу A пакет с сердцебиением,где узел D указан в списке.</target>
        </trans-unit>
        <trans-unit id="7729f6e6ec6ba874a64709376383726e87372daa" translate="yes" xml:space="preserve">
          <source>BGREWRITEAOF</source>
          <target state="translated">BGREWRITEAOF</target>
        </trans-unit>
        <trans-unit id="458f7ff8a0210a97fe946685d4c3eaec2c4d3268" translate="yes" xml:space="preserve">
          <source>BGREWRITEAOF   Asynchronously rewrite the append-only file</source>
          <target state="translated">BGREWRITEAOF Асинхронно перезаписывайте файл только для приложения</target>
        </trans-unit>
        <trans-unit id="a27e9a0dccc378a573407c1d809762f71f913c63" translate="yes" xml:space="preserve">
          <source>BGSAVE</source>
          <target state="translated">BGSAVE</target>
        </trans-unit>
        <trans-unit id="7faf716555dfc6c9000f52854e242ef60d56665d" translate="yes" xml:space="preserve">
          <source>BGSAVE   Asynchronously save the dataset to disk</source>
          <target state="translated">BGSAVE Асинхронно сохранять набор данных на диск</target>
        </trans-unit>
        <trans-unit id="ab695def32445abd5af69c89b4fc9a578a6be30c" translate="yes" xml:space="preserve">
          <source>BGSAVE  [SCHEDULE]   Asynchronously save the dataset to disk</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa73037de86a35867f756331811a0b553f9a4512" translate="yes" xml:space="preserve">
          <source>BITCOUNT</source>
          <target state="translated">BITCOUNT</target>
        </trans-unit>
        <trans-unit id="558065aa2007c718ef4867af43bb99fd2d71d712" translate="yes" xml:space="preserve">
          <source>BITCOUNT  key [start end]   Count set bits in a string</source>
          <target state="translated">Клавиша BITCOUNT [start end]Считать установленные биты в строке</target>
        </trans-unit>
        <trans-unit id="4648876b3aec23fc361c9cc8f6b361de8992e75b" translate="yes" xml:space="preserve">
          <source>BITFIELD</source>
          <target state="translated">BITFIELD</target>
        </trans-unit>
        <trans-unit id="4e856b858022af2e0acd6b68544eced1b0992122" translate="yes" xml:space="preserve">
          <source>BITFIELD  key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]   Perform arbitrary bitfield integer operations on strings</source>
          <target state="translated">BITFIELD ключ [GET type offset][SET type offset value][INCRBY type offset increment][OVERFLOW WRAP|SAT|FAIL]Выполняйте произвольные операции с целыми битовыми полями над строками.</target>
        </trans-unit>
        <trans-unit id="a5aaf403ca55d3d64f12bde81881e9c02072728a" translate="yes" xml:space="preserve">
          <source>BITOP</source>
          <target state="translated">BITOP</target>
        </trans-unit>
        <trans-unit id="fbf06b661d51c935ecb7a0e541d91fa350da1c52" translate="yes" xml:space="preserve">
          <source>BITOP  operation destkey key [key ...]   Perform bitwise operations between strings</source>
          <target state="translated">BITOP-операция клавиша назначения [клавиша ...]Выполнение битовых операций между строками</target>
        </trans-unit>
        <trans-unit id="6429405be50a33193090d8d4c0a4575b80d167fc" translate="yes" xml:space="preserve">
          <source>BITPOS</source>
          <target state="translated">BITPOS</target>
        </trans-unit>
        <trans-unit id="3eedfee8a6aaf27b486a0a74ef694737767592c5" translate="yes" xml:space="preserve">
          <source>BITPOS  key bit [start] [end]   Find first bit set or clear in a string</source>
          <target state="translated">Бит ключа BITPOS [start][end]Найти первый бит в строке или очистить его.</target>
        </trans-unit>
        <trans-unit id="fc2dfb0c3d9a6c59a7ce67610ea5adaf29a615be" translate="yes" xml:space="preserve">
          <source>BLMOVE</source>
          <target state="translated">BLMOVE</target>
        </trans-unit>
        <trans-unit id="db9a7aeda5f34e5b6dc6bfc16ff9ad89a6ecbdee" translate="yes" xml:space="preserve">
          <source>BLMOVE  source destination LEFT|RIGHT LEFT|RIGHT timeout   Pop an element from a list, push it to another list and return it; or block until one is available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05499a7141cb9854f00176880caa9ac423867f3" translate="yes" xml:space="preserve">
          <source>BLPOP</source>
          <target state="translated">BLPOP</target>
        </trans-unit>
        <trans-unit id="0412d709e7cedab62c94968e19cc0014d112f86b" translate="yes" xml:space="preserve">
          <source>BLPOP  key [key ...] timeout   Remove and get the first element in a list, or block until one is available</source>
          <target state="translated">Тайм-аут клавиши BLPOP [клавиша ...]Удалить и получить первый элемент в списке,или заблокировать до тех пор,пока он не станет доступен</target>
        </trans-unit>
        <trans-unit id="5fa06c19410e8a659911506832eca92eaf0050d6" translate="yes" xml:space="preserve">
          <source>BRPOP</source>
          <target state="translated">BRPOP</target>
        </trans-unit>
        <trans-unit id="30c26bc19b012eb7d9f5f55b03c3f9d84b9cf9c5" translate="yes" xml:space="preserve">
          <source>BRPOP  key [key ...] timeout   Remove and get the last element in a list, or block until one is available</source>
          <target state="translated">Тайм-аут клавиши BRPOP [клавиша ...]Удалить и получить последний элемент в списке,или блокировать до тех пор,пока он не станет доступен.</target>
        </trans-unit>
        <trans-unit id="c32cdb6143356d21802163582eddef7653863e06" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH</source>
          <target state="translated">BRPOPLPUSH</target>
        </trans-unit>
        <trans-unit id="74721eebf76b2ddc61de86b46cc0aec39763409c" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH  source destination timeout   Pop a value from a list, push it to another list and return it; or block until one is available</source>
          <target state="translated">Таймаут источника BRPOPLPUSH Выводить значение из списка,нажимать на него в другом списке и возвращать его;или блокировать до тех пор,пока оно не станет доступным.</target>
        </trans-unit>
        <trans-unit id="06a6c1ed02823440cc121edde6eb065e5de27fb8" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH  source destination timeout   Pop an element from a list, push it to another list and return it; or block until one is available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe7a2ea791972d134e771e602c9bb77407df350d" translate="yes" xml:space="preserve">
          <source>BZPOPMAX</source>
          <target state="translated">BZPOPMAX</target>
        </trans-unit>
        <trans-unit id="b6758ab6d65fab9e15ff22d76094622028d82dec" translate="yes" xml:space="preserve">
          <source>BZPOPMAX  key [key ...] timeout   Remove and return the member with the highest score from one or more sorted sets, or block until one is available</source>
          <target state="translated">BZPOPMAX ключ [ключ ...]тайм-аут Удалить и вернуть члена с наибольшим количеством очков из одного или нескольких отсортированных наборов,или заблокировать до тех пор,пока один из них не будет доступен</target>
        </trans-unit>
        <trans-unit id="cc5c70cba5a0768ab8e3b521a15ca38c10af43e5" translate="yes" xml:space="preserve">
          <source>BZPOPMIN</source>
          <target state="translated">BZPOPMIN</target>
        </trans-unit>
        <trans-unit id="34934a39c9faa59399a1c05af5d02cc1bce19590" translate="yes" xml:space="preserve">
          <source>BZPOPMIN  key [key ...] timeout   Remove and return the member with the lowest score from one or more sorted sets, or block until one is available</source>
          <target state="translated">BZPOPMIN ключ [ключ ...]тайм-аут Удалить и вернуть члена с наименьшим количеством очков из одного или нескольких отсортированных множеств,или заблокировать до тех пор,пока один из них не станет доступным.</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="baab43179123dd499c2cc2c83ab2bfdd9cbd1aec" translate="yes" xml:space="preserve">
          <source>Bandwidth and EVALSHA</source>
          <target state="translated">Полоса пропускания и EVALSHA</target>
        </trans-unit>
        <trans-unit id="65f639d2a40570f68ed54fc56bf243ceac2035a0" translate="yes" xml:space="preserve">
          <source>Basic usage:</source>
          <target state="translated">Основное использование:</target>
        </trans-unit>
        <trans-unit id="7df3c519fe73f3ffe3f8fb928955ded445b7f85e" translate="yes" xml:space="preserve">
          <source>Basically the command sets a state in the connection, that is valid only for the next command execution, that will modify the behavior of client tracking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12e09074a5a31051e466bb25ea4c7f7009a10585" translate="yes" xml:space="preserve">
          <source>Basically we have a counter for every IP, for every different second. But this counters are always incremented setting an expire of 10 seconds so that they'll be removed by Redis automatically when the current second is a different one.</source>
          <target state="translated">В основном,у нас есть счетчик для каждого IP,для каждой секунды.Но эти счетчики всегда инкрементируются,устанавливая срок годности в 10 секунд,так что они будут автоматически удалены Redis,когда текущая секунда является другой.</target>
        </trans-unit>
        <trans-unit id="3bc673f7ca5e59c74c138e173d60ace2cc7f15b0" translate="yes" xml:space="preserve">
          <source>Basically, the function considers the right of the string as padded with zeros if you look for clear bits and specify no range or the &lt;em&gt;start&lt;/em&gt; argument &lt;strong&gt;only&lt;/strong&gt;.</source>
          <target state="translated">В основном, функция рассматривает право строки , как заполняется нулями , если вы посмотрите на четкие биты и опускаете указание диапазона или &lt;em&gt;стартовый&lt;/em&gt; аргумент &lt;strong&gt;только&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="14b677b3a5e36da0c5dac8a200bd5400f84443e8" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; streams back &lt;strong&gt;all&lt;/strong&gt; commands, its use comes at a cost. The following (totally unscientific) benchmark numbers illustrate what the cost of running &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; can be.</source>
          <target state="translated">Поскольку &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; передает &lt;strong&gt;все&lt;/strong&gt; команды обратно , его использование требует затрат. Следующие (совершенно ненаучные) результаты тестов показывают, &lt;a href=&quot;monitor&quot;&gt;сколько&lt;/a&gt; может стоить использование МОНИТОРА .</target>
        </trans-unit>
        <trans-unit id="168e98970df56293fbc42baf15adc634cb88819b" translate="yes" xml:space="preserve">
          <source>Because Redis does not have control over how its allocations are mapped to memory pages, high &lt;code&gt;used_memory_rss&lt;/code&gt; is often the result of a spike in memory usage.</source>
          <target state="translated">Поскольку Redis не контролирует, как его выделения отображаются на страницы памяти, высокий уровень &lt;code&gt;used_memory_rss&lt;/code&gt; часто является результатом всплеска использования памяти.</target>
        </trans-unit>
        <trans-unit id="9157dfb92d6b10926d702b4d13ee089e71af6988" translate="yes" xml:space="preserve">
          <source>Because Redis' strings are binary-safe, a bitmap is trivially encoded as a bytes stream. The first byte of the string corresponds to offsets 0..7 of the bitmap, the second byte to the 8..15 range, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba14992feb507791cf455ac84d4bc0c1654fa142" translate="yes" xml:space="preserve">
          <source>Because of security concerns, all administrative commands are not logged by &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;'s output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c7ae78faec3383e9f506c3f0134610891480461" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; semantic, C4 can check if the old value stored at &lt;code&gt;key&lt;/code&gt; is still an expired timestamp. If it is, the lock was acquired.</source>
          <target state="translated">Из-за семантики &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; C4 может проверить, является ли старое значение, хранящееся в &lt;code&gt;key&lt;/code&gt; , все еще устаревшей меткой времени. Если да, то блокировка была получена.</target>
        </trans-unit>
        <trans-unit id="02e8504630183a9016b44fe68aa220f28cac8de4" translate="yes" xml:space="preserve">
          <source>Because of the first &lt;em&gt;normalized&lt;/em&gt; part in every element (before the colon character), we are forcing a given comparison, however after the range is queries using &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; the application can display to the user the second part of the string, after the colon.</source>
          <target state="translated">Из-за первой &lt;em&gt;нормализованной&lt;/em&gt; части в каждом элементе (перед символом двоеточия) мы &lt;a href=&quot;zrangebylex&quot;&gt;вызываем&lt;/a&gt; данное сравнение, однако после того, как диапазон представляет собой запросы с использованием ZRANGEBYLEX, приложение может отображать пользователю вторую часть строки после двоеточия.</target>
        </trans-unit>
        <trans-unit id="7d59e94adcd8272e3572e2454feb728deea07f9f" translate="yes" xml:space="preserve">
          <source>Because of the high performance nature of Redis, it is possible to try a lot of passwords in parallel in very short time, so make sure to generate a strong and very long password so that this attack is infeasible. A good way to generate strong passwords is via the &lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05dcf4c78858f10b7a1c629d42f2c28c91d50489" translate="yes" xml:space="preserve">
          <source>Because of this semantic &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; can be used in order to set different keys representing different fields of an unique logic object in a way that ensures that either all the fields or none at all are set.</source>
          <target state="translated">Из-за этой семантики &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; можно использовать для установки разных ключей, представляющих разные поля уникального логического объекта, таким образом, чтобы гарантировать, что либо все поля, либо ни одно не будут установлены.</target>
        </trans-unit>
        <trans-unit id="5743095da9632a185291117b22aab7a1ce272b02" translate="yes" xml:space="preserve">
          <source>Because of this the &lt;strong&gt;TAKEOVER&lt;/strong&gt; option should be used with care.</source>
          <target state="translated">По этой &lt;strong&gt;причине&lt;/strong&gt; следует использовать опцию &lt;strong&gt;TAKEOVER&lt;/strong&gt; с осторожностью.</target>
        </trans-unit>
        <trans-unit id="409eae8dc6d494086fe4746042f7a180a489be81" translate="yes" xml:space="preserve">
          <source>Because when a given node is part of the cluster, all the other nodes participating in the cluster knows about it, in order for a node to be completely removed from a cluster, the &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; command must be sent to all the remaining nodes, regardless of the fact they are masters or replicas.</source>
          <target state="translated">Поскольку, когда данный узел является частью кластера, все остальные узлы, участвующие в кластере, знают об этом, для того чтобы узел был полностью удален из кластера, команда &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; должна быть отправлена ​​всем остальным узлам, независимо от того. по факту они мастера или реплики.</target>
        </trans-unit>
        <trans-unit id="b69310332fe10ffd788fd56a9c44b252e49e79dc" translate="yes" xml:space="preserve">
          <source>Behavior of &lt;code&gt;BLPOP&lt;/code&gt; when multiple elements are pushed inside a list.</source>
          <target state="translated">Поведение &lt;code&gt;BLPOP&lt;/code&gt; , когда несколько элементов помещаются в список.</target>
        </trans-unit>
        <trans-unit id="ece0bd32123faa73ffba96af59789eb1a4470a5d" translate="yes" xml:space="preserve">
          <source>Benchmark result &lt;strong&gt;with&lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; running (&lt;code&gt;redis-cli monitor &amp;gt; /dev/null&lt;/code&gt;):</source>
          <target state="translated">Результат Benchmark &lt;strong&gt;с &lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; работает ( &lt;code&gt;redis-cli monitor &amp;gt; /dev/null&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="e3f9de77c51bcc4c2a59cae3df6e39530202793d" translate="yes" xml:space="preserve">
          <source>Benchmark result &lt;strong&gt;without&lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; running:</source>
          <target state="translated">Результат &lt;a href=&quot;monitor&quot;&gt;теста &lt;/a&gt;&lt;strong&gt;без&lt;/strong&gt; запущенного МОНИТОРА :</target>
        </trans-unit>
        <trans-unit id="a0cee838302dd7dccb0ba96b0e4f12c473f5ce1f" translate="yes" xml:space="preserve">
          <source>Bitmaps are a very space-efficient representation of certain kinds of information. One example is a Web application that needs the history of user visits, so that for instance it is possible to determine what users are good targets of beta features.</source>
          <target state="translated">Битовые карты представляют собой очень компактное представление определенных видов информации.Одним из примеров является веб-приложение,которому нужна история посещений пользователей,чтобы,например,можно было определить,какие пользователи являются хорошими мишенями бета-функций.</target>
        </trans-unit>
        <trans-unit id="927448b58910f0636586793360308442afd14b22" translate="yes" xml:space="preserve">
          <source>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type (for more information refer to the &lt;a href=&quot;https://redis.io/topics/data-types-intro#bitmaps&quot;&gt;Bitmaps section of the Data Types Introduction page&lt;/a&gt;). This means that bitmaps can be used with string commands, and most importantly with &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; and &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c5f7ddc4fdd4c0470d5c822a63678ca6ac8364" translate="yes" xml:space="preserve">
          <source>Bits and positional offsets</source>
          <target state="translated">Битовые и позиционные смещения</target>
        </trans-unit>
        <trans-unit id="01b1462f91bf6adae4924e41a337cd3105d30fba" translate="yes" xml:space="preserve">
          <source>Blocking behavior</source>
          <target state="translated">Блокирующее поведение</target>
        </trans-unit>
        <trans-unit id="0138f8dd5046866e565b72d9550fe5224c0fb4c2" translate="yes" xml:space="preserve">
          <source>Blocking for data</source>
          <target state="translated">Блокировка для данных</target>
        </trans-unit>
        <trans-unit id="b9cbba32c11fb20d3cd9b4d8a8851ece3dbdac10" translate="yes" xml:space="preserve">
          <source>Blocking list operations on lists or sorted sets have a &lt;em&gt;pop&lt;/em&gt; behavior. Bascially, the element is removed from the list or sorted set in order to be returned to the client. In this scenario you want the items to be consumed in a fair way, depending on the moment clients blocked on a given key arrived. Normally Redis uses the FIFO semantics in this use cases.</source>
          <target state="translated">Операции со списком блокировки для списков или отсортированных наборов имеют &lt;em&gt;всплывающее&lt;/em&gt; поведение. Как правило, элемент удаляется из списка или отсортированного набора, чтобы вернуть его клиенту. В этом сценарии вы хотите, чтобы товары потреблялись справедливым образом, в зависимости от момента прибытия клиентов, заблокированных по данному ключу. Обычно в таких случаях Redis использует семантику FIFO.</target>
        </trans-unit>
        <trans-unit id="c7b48b477a47bc528502abd2750eaf8176a42526" translate="yes" xml:space="preserve">
          <source>Blocking list operations on lists or sorted sets have a &lt;em&gt;pop&lt;/em&gt; behavior. Basically, the element is removed from the list or sorted set in order to be returned to the client. In this scenario you want the items to be consumed in a fair way, depending on the moment clients blocked on a given key arrived. Normally Redis uses the FIFO semantics in this use cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83af529ff0234ebb19ae9fc92954913ed20af976" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, where &lt;code&gt;0&lt;/code&gt; is the first element, &lt;code&gt;1&lt;/code&gt; is the next element and so on. They can also be negative numbers indicating offsets from the end of the sorted set, with &lt;code&gt;-1&lt;/code&gt; being the last element of the sorted set, &lt;code&gt;-2&lt;/code&gt; the penultimate element and so on.</source>
          <target state="translated">И &lt;code&gt;start&lt;/code&gt; , и &lt;code&gt;stop&lt;/code&gt; - это индексы с отсчетом от нуля, где &lt;code&gt;0&lt;/code&gt; - первый элемент, &lt;code&gt;1&lt;/code&gt; - следующий элемент и так далее. Они также могут быть отрицательными числами, указывающими смещение от конца отсортированного набора, где &lt;code&gt;-1&lt;/code&gt; - последний элемент отсортированного набора, &lt;code&gt;-2&lt;/code&gt; - предпоследний элемент и т. Д.</target>
        </trans-unit>
        <trans-unit id="23a10624171d72fb4e9f07612b39ccbc04699493" translate="yes" xml:space="preserve">
          <source>Both commands were introduced in Redis 3.2.10 and Redis 4.0.0 respectively.</source>
          <target state="translated">Обе команды были введены в Redis 3.2.10 и Redis 4.0.0 соответственно.</target>
        </trans-unit>
        <trans-unit id="3146bb227c4234d6267f94725155f23545044b63" translate="yes" xml:space="preserve">
          <source>Both quantities are 64-bit numbers. When an ID is auto-generated, the first part is the Unix time in milliseconds of the Redis instance generating the ID. The second part is just a sequence number and is used in order to distinguish IDs generated in the same millisecond.</source>
          <target state="translated">Оба количества-64-битные числа.Когда ID генерируется автоматически,первой частью является Unix-время в миллисекундах экземпляра Redis,генерирующего ID.Вторая часть является просто порядковым номером и используется для того,чтобы различать ID,генерируемые в одних и тех же миллисекундах.</target>
        </trans-unit>
        <trans-unit id="4a1f2ae398c91bf9d6a2b34bf5c23ed87585d341" translate="yes" xml:space="preserve">
          <source>Both representations are prefixed with a 16 bytes header, that includes a magic, an encoding / version field, and the cached cardinality estimation computed, stored in little endian format (the most significant bit is 1 if the estimation is invalid since the HyperLogLog was updated since the cardinality was computed).</source>
          <target state="translated">Оба представления имеют префикс с 16-байтным заголовком,который включает в себя магию,поле кодировки/версии,и кэшированную оценку кардинальности,хранящуюся в формате little endian (наиболее значимый бит-1,если оценка недействительна,поскольку HyperLogLog был обновлен,поскольку кардинальность была вычислена).</target>
        </trans-unit>
        <trans-unit id="c7a36cc87678ec27033bceb0e99f2d1deac9e434" translate="yes" xml:space="preserve">
          <source>Both the value already contained in the string key and the increment argument can be optionally provided in exponential notation, however the value computed after the increment is stored consistently in the same format, that is, an integer number followed (if needed) by a dot, and a variable number of digits representing the decimal part of the number. Trailing zeroes are always removed.</source>
          <target state="translated">И значение,уже содержащееся в строковом ключе,и аргумент инкремента могут быть опционально представлены в экспоненциальной нотации,однако значение,вычисленное после инкремента,сохраняется последовательно в одном и том же формате,т.е.целое число,за которым (при необходимости)следует точка,и переменное число цифр,представляющее собой десятичную часть числа.Трейлинговые нули всегда удаляются.</target>
        </trans-unit>
        <trans-unit id="046892586ee04199d779966b3fd711b935a2c4ee" translate="yes" xml:space="preserve">
          <source>Breaking the compatibility with the past was considered but rejected, at least for Redis 4.0, so instead two read only variants of the commands were added. They are exactly like the original commands but refuse the &lt;code&gt;STORE&lt;/code&gt; and &lt;code&gt;STOREDIST&lt;/code&gt; options. The two variants are called &lt;code&gt;GEORADIUS_RO&lt;/code&gt; and &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt;, and can safely be used in replicas.</source>
          <target state="translated">Нарушение совместимости с прошлым было рассмотрено, но отклонено, по крайней мере, для Redis 4.0, поэтому вместо этого были добавлены два варианта команд только для чтения. Они точно такие же, как и исходные команды, но не &lt;code&gt;STOREDIST&lt;/code&gt; параметры &lt;code&gt;STORE&lt;/code&gt; и STOREDIST . Эти два варианта называются &lt;code&gt;GEORADIUS_RO&lt;/code&gt; и &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; и могут безопасно использоваться в репликах.</target>
        </trans-unit>
        <trans-unit id="11d2a59be0a7424e67e9c632e3f055f99238638f" translate="yes" xml:space="preserve">
          <source>Bulk string reply</source>
          <target state="translated">Ответ по объемной строке</target>
        </trans-unit>
        <trans-unit id="3e53e1d484c0afdd9ee478c43d641e56563db80a" translate="yes" xml:space="preserve">
          <source>But in the above case the output would be the same, since we have pending messages only for a single consumer. However what is important to keep in mind is that this operation, filtering by a specific consumer, is not inefficient even when there are many pending messages from many consumers: we have a pending entries list data structure both globally, and for every consumer, so we can very efficiently show just messages pending for a single consumer.</source>
          <target state="translated">Но в вышеуказанном случае вывод был бы тем же самым,так как мы имеем отложенные сообщения только для одного потребителя.Однако важно помнить,что эта операция,фильтрация по конкретному потребителю,не является неэффективной даже при наличии множества отложенных сообщений от многих потребителей:у нас есть структура данных списка отложенных сообщений как в глобальном масштабе,так и для каждого потребителя,поэтому мы можем очень эффективно показывать только отложенные сообщения для одного потребителя.</target>
        </trans-unit>
        <trans-unit id="9fb6518aff837e3fbb56cbdada4b700f62c1931e" translate="yes" xml:space="preserve">
          <source>By default (if /dev/urandom is available) the password is strong and can be used for other uses in the context of a Redis application, for instance in order to create unique session identifiers or other kind of unguessable and not colliding IDs. The password generation is also very cheap because we don't really ask /dev/urandom for bits at every execution. At startup Redis creates a seed using /dev/urandom, then it will use SHA256 in counter mode, with HMAC-SHA256(seed,counter) as primitive, in order to create more random bytes as needed. This means that the application developer should be feel free to abuse &lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt; to create as many secure pseudorandom strings as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8217506d8ebbaa0e107de581511ee5f509b818" translate="yes" xml:space="preserve">
          <source>By default all the bytes contained in the string are examined. It is possible to specify the counting operation only in an interval passing the additional arguments &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt;.</source>
          <target state="translated">По умолчанию проверяются все байты, содержащиеся в строке. Указать операцию подсчета можно только в интервале, передавая дополнительные аргументы &lt;em&gt;start&lt;/em&gt; и &lt;em&gt;end&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9e9840a0fb9a28f465bc984e84fdef1e46818881" translate="yes" xml:space="preserve">
          <source>By default all the matching items are returned. It is possible to limit the results to the first N matching items by using the &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;&lt;/strong&gt; option. However note that internally the command needs to perform an effort proportional to the number of items matching the specified area, so to query very large areas with a very small &lt;code&gt;COUNT&lt;/code&gt; option may be slow even if just a few results are returned. On the other hand &lt;code&gt;COUNT&lt;/code&gt; can be a very effective way to reduce bandwidth usage if normally just the first results are used.</source>
          <target state="translated">По умолчанию возвращаются все подходящие элементы. Можно ограничить результаты до первых N совпадающих элементов, используя параметр &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; &lt;/strong&gt; . Однако обратите внимание, что внутренне команда должна выполнять усилие, пропорциональное количеству элементов, соответствующих указанной области, поэтому запрос очень больших областей с очень маленькой опцией &lt;code&gt;COUNT&lt;/code&gt; может быть медленным, даже если возвращено всего несколько результатов. С другой стороны, &lt;code&gt;COUNT&lt;/code&gt; может быть очень эффективным способом уменьшить использование полосы пропускания, если обычно используются только первые результаты.</target>
        </trans-unit>
        <trans-unit id="38a3d7ce77609a064a8c66435e5a2ddef01589e2" translate="yes" xml:space="preserve">
          <source>By default the &lt;a href=&quot;lolwut&quot;&gt;LOLWUT&lt;/a&gt; command will display the piece corresponding to the current Redis version, however it is possible to display a specific version using the following form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9b368afa2761dde4363a1630f17429f8bc58b2" translate="yes" xml:space="preserve">
          <source>By default the client is unblocked as if the timeout of the command was reached, however if an additional (and optional) argument is passed, it is possible to specify the unblocking behavior, that can be &lt;strong&gt;TIMEOUT&lt;/strong&gt; (the default) or &lt;strong&gt;ERROR&lt;/strong&gt;. If &lt;strong&gt;ERROR&lt;/strong&gt; is specified, the behavior is to unblock the client returning as error the fact that the client was force-unblocked. Specifically the client will receive the following error:</source>
          <target state="translated">По умолчанию клиент разблокирован, как если бы тайм-аут команды был достигнут, однако, если передан дополнительный (и необязательный) аргумент, можно указать поведение разблокировки, которое может быть &lt;strong&gt;TIMEOUT&lt;/strong&gt; (по умолчанию) или &lt;strong&gt;ERROR&lt;/strong&gt; . Если указана &lt;strong&gt;ОШИБКА&lt;/strong&gt; , поведение заключается в том, чтобы разблокировать клиента, возвращая как ошибку тот факт, что клиент был принудительно разблокирован. В частности, клиент получит следующую ошибку:</target>
        </trans-unit>
        <trans-unit id="876aa0f6c00a7c0060c29d93b8e069bbd151098c" translate="yes" xml:space="preserve">
          <source>By default the command returns the items to the client. It is possible to store the results with one of these options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91bf3b958012756b0a4a417df15abcf41ceea42c" translate="yes" xml:space="preserve">
          <source>By default the scripting engine is always set to &lt;code&gt;REPL_ALL&lt;/code&gt;. By calling this function the user can switch on/off AOF and or replicas propagation, and turn them back later at her/his wish.</source>
          <target state="translated">По умолчанию &lt;code&gt;REPL_ALL&lt;/code&gt; сценариев всегда установлен на REPL_ALL . Вызывая эту функцию, пользователь может включить / выключить распространение AOF и / или реплик и вернуть их позже по своему желанию.</target>
        </trans-unit>
        <trans-unit id="d3714f33148cc538954cff3b58af732446c5cd76" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; returns the sorted elements to the client. With the &lt;code&gt;STORE&lt;/code&gt; option, the result will be stored as a list at the specified key instead of being returned to the client.</source>
          <target state="translated">По умолчанию &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; возвращает отсортированные элементы клиенту. С опцией &lt;code&gt;STORE&lt;/code&gt; результат будет сохранен в виде списка с указанным ключом, а не будет возвращен клиенту.</target>
        </trans-unit>
        <trans-unit id="2ee8f070e37dc92ade46a57ac677a11708d8c9aa" translate="yes" xml:space="preserve">
          <source>By default, &lt;strong&gt;WRAP&lt;/strong&gt; is used if not otherwise specified.</source>
          <target state="translated">По умолчанию используется &lt;strong&gt;WRAP,&lt;/strong&gt; если не указано иное.</target>
        </trans-unit>
        <trans-unit id="f7b1d35e79bbf2da51d0b5f48b7d7d355bd0c2fd" translate="yes" xml:space="preserve">
          <source>By default, all the bytes contained in the string are examined. It is possible to look for bits only in a specified interval passing the additional arguments &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; (it is possible to just pass &lt;em&gt;start&lt;/em&gt;, the operation will assume that the end is the last byte of the string. However there are semantic differences as explained later). The range is interpreted as a range of bytes and not a range of bits, so &lt;code&gt;start=0&lt;/code&gt; and &lt;code&gt;end=2&lt;/code&gt; means to look at the first three bytes.</source>
          <target state="translated">По умолчанию проверяются все байты, содержащиеся в строке. Можно искать биты только в указанном интервале, передавая дополнительные аргументы &lt;em&gt;start&lt;/em&gt; и &lt;em&gt;end&lt;/em&gt; (можно просто передать &lt;em&gt;start&lt;/em&gt; , операция будет предполагать, что конец - это последний байт строки. Однако есть семантические различия, как объяснено потом). Диапазон интерпретируется как диапазон байтов, а не как диапазон битов, поэтому &lt;code&gt;start=0&lt;/code&gt; и &lt;code&gt;end=2&lt;/code&gt; означает просмотр первых трех байтов.</target>
        </trans-unit>
        <trans-unit id="ac56e3917c99c4ddfa64494c6e26b8240c053966" translate="yes" xml:space="preserve">
          <source>By default, all the matching items are returned. It is possible to limit the results to the first N matching items by using the &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;&lt;/strong&gt; option. However note that internally the command needs to perform an effort proportional to the number of items matching the specified area, so to query very large areas with a very small &lt;code&gt;COUNT&lt;/code&gt; option may be slow even if just a few results are returned. On the other hand &lt;code&gt;COUNT&lt;/code&gt; can be a very effective way to reduce bandwidth usage if normally just the first results are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f97c897415a76335a4f3d3db770776a7a0ccedc3" translate="yes" xml:space="preserve">
          <source>By default, it stores the results in the &lt;code&gt;destintion&lt;/code&gt; sorted set with their geospatial information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcfb1fa8d4e16c5703f601d9b874b8021ef089f" translate="yes" xml:space="preserve">
          <source>By default, or when provided with the optional &lt;code&gt;=&lt;/code&gt; argument, the command performs exact trimming. That means that the trimmed stream's length will be exactly the minimum between its original length and the specified maximum length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dfdd218a8c7dcfad82b579c16fc98a90e0423ca" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;destination&lt;/code&gt; key is created in the logical database used by the connection. The &lt;code&gt;DB&lt;/code&gt; option allows specifying an alternative logical database index for the destination key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf8d58c1f5391dbccf4f7678d43b4f133487bae" translate="yes" xml:space="preserve">
          <source>By default, the command pops a single element from the beginning of the list. When provided with the optional &lt;code&gt;count&lt;/code&gt; argument, the reply will consist of up to &lt;code&gt;count&lt;/code&gt; elements, depending on the list's length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fecef221e5ae822414f939e112035853e985bf7" translate="yes" xml:space="preserve">
          <source>By default, the command pops a single element from the end of the list. When provided with the optional &lt;code&gt;count&lt;/code&gt; argument, the reply will consist of up to &lt;code&gt;count&lt;/code&gt; elements, depending on the list's length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b7bd3b6d4bf2d2679ef9988f3c531b70e60e21c" translate="yes" xml:space="preserve">
          <source>By default, the command pops a single member from the set. When provided with the optional &lt;code&gt;count&lt;/code&gt; argument, the reply will consist of up to &lt;code&gt;count&lt;/code&gt; members, depending on the set's cardinality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877bdcad724a6306efbd3a664f11efc0ec0b6fe6" translate="yes" xml:space="preserve">
          <source>By default, the command returns unsorted items. Two different sorting methods can be invoked using one of the following two options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5529ebf0aa9355a448e5873d36ba97d16befd8bf" translate="yes" xml:space="preserve">
          <source>By default, the interval specified by &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; is closed (inclusive). It is possible to specify an open interval (exclusive) by prefixing the score with the character &lt;code&gt;(&lt;/code&gt;. For example:</source>
          <target state="translated">По умолчанию интервал, заданный параметрами &lt;code&gt;min&lt;/code&gt; и &lt;code&gt;max&lt;/code&gt; , закрыт (включительно). Можно указать открытый интервал (исключительный), добавив к баллу префикс символа &lt;code&gt;(&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="b8a1843f4f52d23022ae70457e87a2bbc0c8ed29" translate="yes" xml:space="preserve">
          <source>By default, the resulting score of an element is the sum of its scores in the sorted sets where it exists.</source>
          <target state="translated">По умолчанию результирующая оценка элемента-это сумма его оценок в отсортированных множествах,где он существует.</target>
        </trans-unit>
        <trans-unit id="4665873e5c58037455475bf4706b458811098286" translate="yes" xml:space="preserve">
          <source>By default, the resulting score of an element is the sum of its scores in the sorted sets where it exists. Because intersection requires an element to be a member of every given sorted set, this results in the score of every element in the resulting sorted set to be equal to the number of input sorted sets.</source>
          <target state="translated">По умолчанию результирующая оценка элемента-это сумма его оценок в отсортированных множествах,где он существует.Поскольку пересечение требует,чтобы элемент был членом каждого данного отсортированного множества,это приводит к тому,что оценка каждого элемента в результирующем отсортированном множестве будет равна количеству входных отсортированных множеств.</target>
        </trans-unit>
        <trans-unit id="9bd72014f313a48aa376a2f9743fd29947ddbfa2" translate="yes" xml:space="preserve">
          <source>By getting the string representation of a bitmap, the client can then parse the response's bytes by extracting the bit values using native bit operations in its native programming language. Symmetrically, it is also possible to set an entire bitmap by performing the bits-to-bytes encoding in the client and calling &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; with the resultant string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855731f4a53411098556da94791141678c87de9e" translate="yes" xml:space="preserve">
          <source>C1 and C2 read &lt;code&gt;lock.foo&lt;/code&gt; to check the timestamp, because they both received &lt;code&gt;0&lt;/code&gt; after executing &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, as the lock is still held by C3 that crashed after holding the lock.</source>
          <target state="translated">C1 и C2 читают &lt;code&gt;lock.foo&lt;/code&gt; , чтобы проверить временную метку, потому что оба они получили &lt;code&gt;0&lt;/code&gt; после выполнения &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; , поскольку блокировка все еще удерживается C3, который разбился после удержания блокировки.</target>
        </trans-unit>
        <trans-unit id="2d7ad86157ffa8a81154afc21adf4e9506f4075d" translate="yes" xml:space="preserve">
          <source>C1 sends &lt;code&gt;DEL lock.foo&lt;/code&gt;</source>
          <target state="translated">C1 отправляет &lt;code&gt;DEL lock.foo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59e76a6cffa5164edb0398cd905358d159247029" translate="yes" xml:space="preserve">
          <source>C1 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; and it succeeds</source>
          <target state="translated">C1 отправляет &lt;code&gt;SETNX lock.foo&lt;/code&gt; и успешно</target>
        </trans-unit>
        <trans-unit id="4f7c62ca261230ba7bd6b9233369caaf27e7f01d" translate="yes" xml:space="preserve">
          <source>C2 sends &lt;code&gt;DEL lock.foo&lt;/code&gt;</source>
          <target state="translated">C2 отправляет &lt;code&gt;DEL lock.foo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="193179deba47ad9e120a60484e3cc95253ac5a6a" translate="yes" xml:space="preserve">
          <source>C2 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; and it succeeds</source>
          <target state="translated">C2 отправляет &lt;code&gt;SETNX lock.foo&lt;/code&gt; и успешно</target>
        </trans-unit>
        <trans-unit id="151ee6de467b9561ff1e9f5ec7724e1aafaaa74e" translate="yes" xml:space="preserve">
          <source>C4 sends &lt;code&gt;GET lock.foo&lt;/code&gt; to check if the lock expired. If it is not, it will sleep for some time and retry from the start.</source>
          <target state="translated">C4 отправляет &lt;code&gt;GET lock.foo&lt;/code&gt; , чтобы проверить, истек ли срок блокировки. Если это не так, он будет спать некоторое время и повторить попытку с самого начала.</target>
        </trans-unit>
        <trans-unit id="80d7499d35c9d242f43ac8ad8f3d435904ce4b07" translate="yes" xml:space="preserve">
          <source>C4 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; in order to acquire the lock</source>
          <target state="translated">C4 отправляет &lt;code&gt;SETNX lock.foo&lt;/code&gt; , чтобы получить блокировку</target>
        </trans-unit>
        <trans-unit id="810aa98e90b76fd25ebaacd1fecaebbe5cca1fd8" translate="yes" xml:space="preserve">
          <source>CJSON</source>
          <target state="translated">CJSON</target>
        </trans-unit>
        <trans-unit id="289fd6dd86c78fc18484670bd5337ffc1457b23f" translate="yes" xml:space="preserve">
          <source>CLIENT</source>
          <target state="translated">CLIENT</target>
        </trans-unit>
        <trans-unit id="63a953234a4a4b23595b8f5c3d66ad8e228bb360" translate="yes" xml:space="preserve">
          <source>CLIENT CACHING  YES|NO   Instruct the server about tracking or not keys in the next request</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a086feff67c072f67169a1a10544440c06a27bb" translate="yes" xml:space="preserve">
          <source>CLIENT GETNAME   Get the current connection name</source>
          <target state="translated">ГЕТНАМИ КЛИЕНТА Получить текущее имя подключения.</target>
        </trans-unit>
        <trans-unit id="4c39ac03d0deadf47c0778e94147170cfe5cc290" translate="yes" xml:space="preserve">
          <source>CLIENT GETREDIR   Get tracking notifications redirection client ID if any</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f043bd4293df18cf326994e345f63d6a607a715" translate="yes" xml:space="preserve">
          <source>CLIENT ID   Returns the client ID for the current connection</source>
          <target state="translated">CLIENT ID Возвращает идентификатор клиента для текущего соединения</target>
        </trans-unit>
        <trans-unit id="2cc6c98e277f7b4b6dd7682b2772443f1b2745eb" translate="yes" xml:space="preserve">
          <source>CLIENT INFO   Returns information about the current client connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a606744e377765ead3bebe7af7be75bec984bac6" translate="yes" xml:space="preserve">
          <source>CLIENT KILL  [ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [ADDR ip:port] [SKIPME yes/no]   Kill the connection of a client</source>
          <target state="translated">CLIENT KILL [ip:port][ID клиент-ид][ТИП normal|master|slave|pubsub][ADDR ip:port][SKIPME да/нет]Убить подключение клиента.</target>
        </trans-unit>
        <trans-unit id="0962c4ff7046d5e0349aa07792ed564b6ac58b3e" translate="yes" xml:space="preserve">
          <source>CLIENT KILL  [ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [USER username] [ADDR ip:port] [SKIPME yes/no]   Kill the connection of a client</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f78df8d4251b437ca6d0591e3d79df9db9a668" translate="yes" xml:space="preserve">
          <source>CLIENT KILL and Redis Sentinel</source>
          <target state="translated">КЛИЕНТСКАЯ УБИЖНИКА и РЕДИС Сентинел</target>
        </trans-unit>
        <trans-unit id="5abdfb863c66ad1708626a5caaaa3f3ae356f31e" translate="yes" xml:space="preserve">
          <source>CLIENT LIST  [TYPE normal|master|replica|pubsub]   Get the list of client connections</source>
          <target state="translated">СПИСОК КЛИЕНТОВ [ТИП normal|master|replica|pubsub]Получить список соединений с клиентами.</target>
        </trans-unit>
        <trans-unit id="0f9e74e993d542e852824191d195f334f18cdbad" translate="yes" xml:space="preserve">
          <source>CLIENT LIST  [TYPE normal|master|replica|pubsub] [ID client-id [client-id ...]]   Get the list of client connections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdde82d80a6c631c41a96bc80027350e01ff9d66" translate="yes" xml:space="preserve">
          <source>CLIENT PAUSE  timeout   Stop processing commands from clients for some time</source>
          <target state="translated">Тайм-аут ПОДДЕРЖКИ КЛИЕНТА Остановить обработку команд от клиентов на некоторое время</target>
        </trans-unit>
        <trans-unit id="cdc920d32af4c13e5383224eaafad4a5e97a22e0" translate="yes" xml:space="preserve">
          <source>CLIENT REPLY  ON|OFF|SKIP   Instruct the server whether to reply to commands</source>
          <target state="translated">ОТЧЕТ ПО КЛИЕНТУ ON|OFF|SKIP Сообщить серверу,отвечать ли на команды.</target>
        </trans-unit>
        <trans-unit id="5de18cdee05387ac2edf2c59d640ef325da93c25" translate="yes" xml:space="preserve">
          <source>CLIENT SETNAME  connection-name   Set the current connection name</source>
          <target state="translated">НАСТРОЙКА НАСТРОЙКИ КЛИЕНТА-имя соединения Установите текущее имя соединения</target>
        </trans-unit>
        <trans-unit id="95279f3b4d86b3dc0268ddf4db1feb274847cc8c" translate="yes" xml:space="preserve">
          <source>CLIENT TRACKING  ON|OFF [REDIRECT client-id] [PREFIX prefix [PREFIX prefix ...]] [BCAST] [OPTIN] [OPTOUT] [NOLOOP]   Enable or disable server assisted client side caching support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd550a8d7b9512156ea1471fdd3b700157d0ab6e" translate="yes" xml:space="preserve">
          <source>CLIENT TRACKINGINFO   Return information about server assisted client side caching for the current connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326b6f4d4510070631ac4ab9eaf85a825c42c2a7" translate="yes" xml:space="preserve">
          <source>CLIENT UNBLOCK  client-id [TIMEOUT|ERROR]   Unblock a client blocked in a blocking command from a different connection</source>
          <target state="translated">Клиент-ид БЛОКИРОВКИ КЛИЕНТА [TIMEOUT|ERROR]Разблокировать клиента,заблокированного в команде блокировки,от другого соединения.</target>
        </trans-unit>
        <trans-unit id="e3b9b52696ca51803a72a1787b8689b560877e3b" translate="yes" xml:space="preserve">
          <source>CLUSTER</source>
          <target state="translated">CLUSTER</target>
        </trans-unit>
        <trans-unit id="89c0d390cdc52475692a036944dfe3e1af10aa52" translate="yes" xml:space="preserve">
          <source>CLUSTER ADDSLOTS  slot [slot ...]   Assign new hash slots to receiving node</source>
          <target state="translated">Слот CLUSTER ADDSLOTS [слот ...]Присвоить новые хэш-слоты принимающему узлу</target>
        </trans-unit>
        <trans-unit id="00fb8c41d977c173c87d67428daf985f10049f97" translate="yes" xml:space="preserve">
          <source>CLUSTER BUMPEPOCH   Advance the cluster config epoch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc6a3f907637996a1389e46617de4c73581acb5f" translate="yes" xml:space="preserve">
          <source>CLUSTER COUNT-FAILURE-REPORTS  node-id   Return the number of failure reports active for a given node</source>
          <target state="translated">ЗАКАЗЧИК-ДОКЛАДЫ-ОТЧЕТЫ-узел-ид Вернуть количество отчетов о неисправностях,активных для данного узла</target>
        </trans-unit>
        <trans-unit id="8de0ad0623c7725bc7b50d19dfafe919652d9ddd" translate="yes" xml:space="preserve">
          <source>CLUSTER COUNTKEYSINSLOT  slot   Return the number of local keys in the specified hash slot</source>
          <target state="translated">Слот CLUSTER COUNTKEYSINSLOT Возврат числа локальных ключей в указанном хеш-слоте</target>
        </trans-unit>
        <trans-unit id="a291825c5518befaa628dbca584ac74adfdd3dc0" translate="yes" xml:space="preserve">
          <source>CLUSTER DELSLOTS  slot [slot ...]   Set hash slots as unbound in receiving node</source>
          <target state="translated">Слот CLUSTER DELSLOTS [слот ...]Установите хэш-слоты как несвязанные в принимающем узле</target>
        </trans-unit>
        <trans-unit id="9b2690b6fa91e96bd2f73d5972dcb19de160e151" translate="yes" xml:space="preserve">
          <source>CLUSTER FAILOVER  [FORCE|TAKEOVER]   Forces a replica to perform a manual failover of its master.</source>
          <target state="translated">CLUSTER FAILOVER [FORCE|TAKEOVER]Заставляет реплику выполнить ручной обход отказа мастера.</target>
        </trans-unit>
        <trans-unit id="94cefd9c3cfc8c0aca11125b97d7b0fd362d0d4a" translate="yes" xml:space="preserve">
          <source>CLUSTER FLUSHSLOTS   Delete a node's own slots information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e739c9ee11fd419a688da991d447a266021c6ef0" translate="yes" xml:space="preserve">
          <source>CLUSTER FORGET  node-id   Remove a node from the nodes table</source>
          <target state="translated">ЗАБЫТА узла CLUSTER FORGET Удалить узел из таблицы узлов</target>
        </trans-unit>
        <trans-unit id="63b393dc8cc3734128967f68eb934005c0c5a24f" translate="yes" xml:space="preserve">
          <source>CLUSTER GETKEYSINSLOT  slot count   Return local key names in the specified hash slot</source>
          <target state="translated">CLUSTER GETKEYSINSLOT Счет слотов Возвращать имена локальных ключей в указанный хэш-слот</target>
        </trans-unit>
        <trans-unit id="96ff44fb1ff41b2047e38a9dd4b9b91ab3a48e50" translate="yes" xml:space="preserve">
          <source>CLUSTER INFO   Provides info about Redis Cluster node state</source>
          <target state="translated">CLUSTER INFO Предоставляет информацию о состоянии узла кластера Redis.</target>
        </trans-unit>
        <trans-unit id="bceb7d0f89d15cad163cf00743841fee0d54ad57" translate="yes" xml:space="preserve">
          <source>CLUSTER KEYSLOT  key   Returns the hash slot of the specified key</source>
          <target state="translated">Ключ CLUSTER KEYSLOT Возвращает хэш-слот указанного ключа</target>
        </trans-unit>
        <trans-unit id="db6dfe9195f872c1e24e77eca06229e51f545369" translate="yes" xml:space="preserve">
          <source>CLUSTER MEET  ip port   Force a node cluster to handshake with another node</source>
          <target state="translated">CLUSTER MEET ip port Заставить узловой кластер пожать руку с другим узлом</target>
        </trans-unit>
        <trans-unit id="4c0ca20cada3909d25d2d4e2035e56d2e9daba1b" translate="yes" xml:space="preserve">
          <source>CLUSTER MYID   Return the node id</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45bb4b8fb75be9f6506f8df1b5feecc8fcb42818" translate="yes" xml:space="preserve">
          <source>CLUSTER NODES   Get Cluster config for the node</source>
          <target state="translated">Узлы CLUSTER NODES Получить конфигурацию кластера для узла</target>
        </trans-unit>
        <trans-unit id="cb1b81c97abbdb844bd68109bd5c641a604ec477" translate="yes" xml:space="preserve">
          <source>CLUSTER REPLICAS  node-id   List replica nodes of the specified master node</source>
          <target state="translated">CLUSTER REPLICAS узел-идентификатор Список копий узлов указанного ведущего узла</target>
        </trans-unit>
        <trans-unit id="0c1d4ab714df1ed96b53ecea55f9b15118926ddd" translate="yes" xml:space="preserve">
          <source>CLUSTER REPLICATE  node-id   Reconfigure a node as a replica of the specified master node</source>
          <target state="translated">CLUSTER REPLICATE nodee-id Реконфигурируйте узел как реплику указанного ведущего узла</target>
        </trans-unit>
        <trans-unit id="fdd669bf0a4695d61100d82b95672d6f0265fa98" translate="yes" xml:space="preserve">
          <source>CLUSTER RESET  [HARD|SOFT]   Reset a Redis Cluster node</source>
          <target state="translated">CLUSTER RESET [HARD|SOFT]Сброс узла кластера Redis</target>
        </trans-unit>
        <trans-unit id="4452e5582d47e8dfe0990f92ac43fa0dcf4415d8" translate="yes" xml:space="preserve">
          <source>CLUSTER SAVECONFIG   Forces the node to save cluster state on disk</source>
          <target state="translated">CLUSTER SAVECONFIG заставляет узел сохранять состояние кластера на диске.</target>
        </trans-unit>
        <trans-unit id="0352d198b3e3c3480eec41371b3ead5bc1188b13" translate="yes" xml:space="preserve">
          <source>CLUSTER SET-CONFIG-EPOCH  config-epoch   Set the configuration epoch in a new node</source>
          <target state="translated">CLUSTER SET-CONFIG-EPOCH config-epoch Установить эпоху конфигурирования в новом узле</target>
        </trans-unit>
        <trans-unit id="717b30894068edcc566f30c183079158fcd2ebb3" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT  slot IMPORTING|MIGRATING|STABLE|NODE [node-id]   Bind a hash slot to a specific node</source>
          <target state="translated">Слот CLUSTER SETSLOT IMPORTING|MIGRATING|STABLE|NODE [nodee-id]Привязать слот для хэша к определенному узлу</target>
        </trans-unit>
        <trans-unit id="6998d43f245cd331b3038d9db49ce51e5fbe657b" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; IMPORTING &lt;code&gt;&amp;lt;source-node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">КЛАСТЕР SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; ИМПОРТ &lt;code&gt;&amp;lt;source-node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df0cda76712dac386672dd77ffb08df9386d4ded" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; MIGRATING &lt;code&gt;&amp;lt;destination-node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">КЛАСТЕР SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; MIGRATING &lt;code&gt;&amp;lt;destination-node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e87c55a08cdeb007d9466cda6f41bd3aa8b0b08f" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; NODE &lt;code&gt;&amp;lt;node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; УЗЕЛ &lt;code&gt;&amp;lt;node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8050d05e7c830b724efadb1fb19908cbba0c3b12" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; STABLE</source>
          <target state="translated">СЛОТ КЛАСТЕРА &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; СТАБИЛЬНЫЙ</target>
        </trans-unit>
        <trans-unit id="87d7c95e3334e2c65e594f6606b11d6fa033b8e3" translate="yes" xml:space="preserve">
          <source>CLUSTER SLAVES  node-id   List replica nodes of the specified master node</source>
          <target state="translated">CLUSTER SLAVES node-id Список копий узлов указанного ведущего узла</target>
        </trans-unit>
        <trans-unit id="0b83235580afb6dcdbb5aaae9069030836332846" translate="yes" xml:space="preserve">
          <source>CLUSTER SLOTS   Get array of Cluster slot to node mappings</source>
          <target state="translated">CLUSTER SLOTS Получить массив кластерных слотов для сопоставления узлов</target>
        </trans-unit>
        <trans-unit id="2e4854d8dd31ab3a1bd0bbce1a9b8c73da88c413" translate="yes" xml:space="preserve">
          <source>COMMAND</source>
          <target state="translated">COMMAND</target>
        </trans-unit>
        <trans-unit id="5d475d3ae2a090a5dd4fb9bcb4834f2b0f5e8e36" translate="yes" xml:space="preserve">
          <source>COMMAND   Get array of Redis command details</source>
          <target state="translated">КОММАНДА Получить массив деталей команды Redis</target>
        </trans-unit>
        <trans-unit id="243f2ac950baaf718523fe42c2f35baa4d002daa" translate="yes" xml:space="preserve">
          <source>COMMAND COUNT   Get total number of Redis commands</source>
          <target state="translated">КОММАНДНЫЙ СОВЕТ Получить общее количество команд Redis</target>
        </trans-unit>
        <trans-unit id="b5c43f716c4692946b372734d13302625935ddef" translate="yes" xml:space="preserve">
          <source>COMMAND GETKEYS   Extract keys given a full Redis command</source>
          <target state="translated">КОММАНДНЫЕ ГЕТКЕЙСЫ Извлекайте ключи по полной команде Redis.</target>
        </trans-unit>
        <trans-unit id="e4f0ee016bdc14d304548515037906095d7beb51" translate="yes" xml:space="preserve">
          <source>COMMAND INFO  command-name [command-name ...]   Get array of specific Redis command details</source>
          <target state="translated">COMMAND INFO имя команды [имя команды ...]Получить массив конкретных деталей команды Redis.</target>
        </trans-unit>
        <trans-unit id="2fb60054b43a25d7a958d3d19bdb1aa7809577a8" translate="yes" xml:space="preserve">
          <source>CONFIG</source>
          <target state="translated">CONFIG</target>
        </trans-unit>
        <trans-unit id="d3f495884e312ef94089cef1025f98afac649a7f" translate="yes" xml:space="preserve">
          <source>CONFIG GET  parameter   Get the value of a configuration parameter</source>
          <target state="translated">CONFIG GET параметр Получить значение конфигурационного параметра</target>
        </trans-unit>
        <trans-unit id="d6c004f361be600273602c08f69569c9b929d35b" translate="yes" xml:space="preserve">
          <source>CONFIG RESETSTAT   Reset the stats returned by INFO</source>
          <target state="translated">CONFIG RESETSTAT Сброс статистики,возвращаемой INFO</target>
        </trans-unit>
        <trans-unit id="07fd8b85f66f97280cb2ad55982da60cacbe7682" translate="yes" xml:space="preserve">
          <source>CONFIG REWRITE   Rewrite the configuration file with the in memory configuration</source>
          <target state="translated">CONFIG REWRITE Перезапись файла конфигурации с конфигурацией в памяти</target>
        </trans-unit>
        <trans-unit id="d27538b14c1ebc5ce34011e7bb5ef99fff52c53d" translate="yes" xml:space="preserve">
          <source>CONFIG REWRITE is also able to rewrite the configuration file from scratch if the original one no longer exists for some reason. However if the server was started without a configuration file at all, the CONFIG REWRITE will just return an error.</source>
          <target state="translated">CONFIG REWRITE также может перезаписать конфигурационный файл с нуля,если оригинальный по каким-то причинам больше не существует.Однако если сервер был запущен вообще без конфигурационного файла,то CONFIG REWRITE просто вернет ошибку.</target>
        </trans-unit>
        <trans-unit id="bcdc354e91b58a18cc7f424a767e01c256e6b42b" translate="yes" xml:space="preserve">
          <source>CONFIG SET  parameter value   Set a configuration parameter to the given value</source>
          <target state="translated">CONFIG SET параметр Установите конфигурационный параметр на заданное значение.</target>
        </trans-unit>
        <trans-unit id="aecf0292da85cb2048d8b648567127d024d4074f" translate="yes" xml:space="preserve">
          <source>COPY</source>
          <target state="translated">COPY</target>
        </trans-unit>
        <trans-unit id="b3729b7bb933c36d809f0e8ba9d3228341d27148" translate="yes" xml:space="preserve">
          <source>COPY  source destination [DB destination-db] [REPLACE]   Copy a key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba6c24ce4497d078be48b670ad16cc43d57f929" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; with a broken, negative, out of range, or otherwise invalid cursor, will result into undefined behavior but never into a crash. What will be undefined is that the guarantees about the returned elements can no longer be ensured by the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; implementation.</source>
          <target state="translated">Вызов &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; с неработающим, отрицательным, выходящим за пределы диапазона или другим недействительным курсором приведет к неопределенному поведению, но никогда к сбою. Что будет неопределенным, так это то, что гарантии в отношении возвращаемых элементов больше не могут быть обеспечены реализацией &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f46be6632e20880fa3190f308734a7c2debc935" translate="yes" xml:space="preserve">
          <source>Calling SCAN with a corrupted cursor</source>
          <target state="translated">Вызов SCAN с поврежденным курсором</target>
        </trans-unit>
        <trans-unit id="1e0b7fe9d077c2aa9a5144f650dffdcf03fa241c" translate="yes" xml:space="preserve">
          <source>Capped streams</source>
          <target state="translated">Закрытые потоки</target>
        </trans-unit>
        <trans-unit id="677509e3c92011eb7431eb950f99423de593897c" translate="yes" xml:space="preserve">
          <source>Care should be taken when executing &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; in the context of a pipelined request, since even in a pipeline the order of execution of commands must be guaranteed. If &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; will return a &lt;code&gt;NOSCRIPT&lt;/code&gt; error the command can not be reissued later otherwise the order of execution is violated.</source>
          <target state="translated">Следует проявлять осторожность при выполнении &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; в контексте конвейерного запроса, поскольку даже в конвейере должен быть гарантирован порядок выполнения команд. Если &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; вернет ошибку &lt;code&gt;NOSCRIPT&lt;/code&gt; , команду нельзя будет повторить позже, иначе порядок выполнения будет нарушен.</target>
        </trans-unit>
        <trans-unit id="3c95b0aba9bde834d03663b5e6a82abbc6926a9f" translate="yes" xml:space="preserve">
          <source>Checking for all the available categories is as simple as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eaf1e254fa69f8ab1d24e1e39a78203c7080474" translate="yes" xml:space="preserve">
          <source>Client IP address and port (4.0 only).</source>
          <target state="translated">IP-адрес и порт клиента (только 4.0).</target>
        </trans-unit>
        <trans-unit id="5cf75075a191bc11d161c66570997946e05f966f" translate="yes" xml:space="preserve">
          <source>Client libraries may use Redis in order to test their own hashing algorithm, generating random keys and hashing them with both their local implementation and using Redis &lt;a href=&quot;cluster-keyslot&quot;&gt;CLUSTER KEYSLOT&lt;/a&gt; command, then checking if the result is the same.</source>
          <target state="translated">Клиентские библиотеки могут использовать Redis для тестирования своего собственного алгоритма хеширования, генерации случайных ключей и хеширования их как с их локальной реализацией, так и с помощью команды Redis &lt;a href=&quot;cluster-keyslot&quot;&gt;CLUSTER KEYSLOT&lt;/a&gt; , а затем проверки того, является ли результат таким же.</target>
        </trans-unit>
        <trans-unit id="5993bbb849b531146b7a95269c1882c6ff8a9ed3" translate="yes" xml:space="preserve">
          <source>Client name if set via the &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; command (4.0 only).</source>
          <target state="translated">Имя клиента, если установлено с помощью команды &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; (только 4.0).</target>
        </trans-unit>
        <trans-unit id="d75dc68bbdd56c9cbd58d4bbdabda84bcca2c47f" translate="yes" xml:space="preserve">
          <source>Cluster</source>
          <target state="translated">Cluster</target>
        </trans-unit>
        <trans-unit id="4a4e6b60b2ae77bbe874af6a70cdbaba6049e713" translate="yes" xml:space="preserve">
          <source>Cluster clients must be aware of key positions in commands so commands can go to matching instances, but Redis commands vary between accepting one key, multiple keys, or even multiple keys separated by other data.</source>
          <target state="translated">Клиенты кластера должны знать о ключевых позициях в командах,чтобы команды могли перейти к соответствующим экземплярам,но команды Redis различаются между принятием одного ключа,нескольких ключей или даже нескольких ключей,разделенных другими данными.</target>
        </trans-unit>
        <trans-unit id="13fb8a1716343d8d81faf3b82f500e80a846e807" translate="yes" xml:space="preserve">
          <source>Cluster note: in a Redis Cluster clients can subscribe to every node, and can also publish to every other node. The cluster will make sure that published messages are forwarded as needed. That said, &lt;a href=&quot;pubsub&quot;&gt;PUBSUB&lt;/a&gt;'s replies in a cluster only report information from the node's Pub/Sub context, rather than the entire cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c356fac15c94ebf5b7447ee6cfaeb09fa342b3" translate="yes" xml:space="preserve">
          <source>Command Arity</source>
          <target state="translated">Командная способность</target>
        </trans-unit>
        <trans-unit id="b25b9ea512e65182e9de25869fda9886e798f471" translate="yes" xml:space="preserve">
          <source>Command Name</source>
          <target state="translated">Имя команды</target>
        </trans-unit>
        <trans-unit id="72da5b475c49e9d5cba38602d80b0de205cc6bb7" translate="yes" xml:space="preserve">
          <source>Command arity &lt;em&gt;includes&lt;/em&gt; counting the command name itself.</source>
          <target state="translated">Арность команды &lt;em&gt;включает&lt;/em&gt; подсчет самого имени команды.</target>
        </trans-unit>
        <trans-unit id="7b7be4b904754c3884cb0bf72bfeb125fc2e6d02" translate="yes" xml:space="preserve">
          <source>Command arity follows a simple pattern:</source>
          <target state="translated">Командная арифметика следует простой схеме:</target>
        </trans-unit>
        <trans-unit id="da09292eaa6e23b8b1b1824949fffe53ca537116" translate="yes" xml:space="preserve">
          <source>Command flags is &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; containing one or more status replies:</source>
          <target state="translated">Командные флаги - это &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;массивный ответ,&lt;/a&gt; содержащий один или несколько статусных ответов:</target>
        </trans-unit>
        <trans-unit id="d8fdc321243166f52a9f1732c47f181f168fb6cd" translate="yes" xml:space="preserve">
          <source>Command name is the command returned as a lowercase string.</source>
          <target state="translated">Имя команды-это команда,возвращаемая в виде строки в нижнем регистре.</target>
        </trans-unit>
        <trans-unit id="c03350e2365b375b5bb4ce53303074533ba05e9e" translate="yes" xml:space="preserve">
          <source>Command options</source>
          <target state="translated">Опции команд</target>
        </trans-unit>
        <trans-unit id="a4618f4b2f49e68da5c5eab1cb65f4e2cbae4e8c" translate="yes" xml:space="preserve">
          <source>Commands about keys already migrated are correctly processed in the context of the node which is the target of the migration, the new hash slot owner, in order to guarantee consistency.</source>
          <target state="translated">Команды о уже перемещенных ключах корректно обрабатываются в контексте узла,на который осуществляется миграция,нового владельца хеш-слота,чтобы гарантировать согласованность.</target>
        </trans-unit>
        <trans-unit id="b7c78328ebde5dad6a0b828ac630676fb4437227" translate="yes" xml:space="preserve">
          <source>Commands about this hash slot are refused and a &lt;code&gt;MOVED&lt;/code&gt; redirection is generated as usually, but in the case the command follows an &lt;code&gt;ASKING&lt;/code&gt; command, in this case the command is executed.</source>
          <target state="translated">Команды для этого хэш-слота &lt;code&gt;MOVED&lt;/code&gt; перенаправление MOVED создается как обычно, но в случае, если команда следует за командой &lt;code&gt;ASKING&lt;/code&gt; , в этом случае команда выполняется.</target>
        </trans-unit>
        <trans-unit id="aa013f0386471baba0b09b24b999134de43d82e4" translate="yes" xml:space="preserve">
          <source>Commands denied because accessing keys not allowed in the current ACL rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aef01612894a7eb8b7ac8feeb71f973dac67ca6" translate="yes" xml:space="preserve">
          <source>Commands denied because against the current ACL rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5080f3f78852fa61575aea2ee4cbd726a5e4c31e" translate="yes" xml:space="preserve">
          <source>Commands not logged by MONITOR</source>
          <target state="translated">Команды,не зарегистрированные МОНИТОРОМ</target>
        </trans-unit>
        <trans-unit id="b16b78407a41c93dd4cb4577acb6af8003abc8f6" translate="yes" xml:space="preserve">
          <source>Comments and the overall structure of the original redis.conf are preserved as much as possible.</source>
          <target state="translated">Комментарии и общая структура оригинального redis.conf сохранены в максимально возможной степени.</target>
        </trans-unit>
        <trans-unit id="b2729f5c12d7e85d14c701273c4956c936eacdf5" translate="yes" xml:space="preserve">
          <source>Complete list of commands currently requiring key location parsing:</source>
          <target state="translated">Полный список команд,требующих в настоящее время разбора местоположения ключей:</target>
        </trans-unit>
        <trans-unit id="85cf1af73ea4830e4844b1efcacdc1968badce3f" translate="yes" xml:space="preserve">
          <source>Computes the difference between the first and all successive input sorted sets and stores the result in &lt;code&gt;destination&lt;/code&gt;. The total number of input keys is specified by &lt;code&gt;numkeys&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc6213bb38f415f44656ea01a54b34f86489a7e" translate="yes" xml:space="preserve">
          <source>Computes the intersection of &lt;code&gt;numkeys&lt;/code&gt; sorted sets given by the specified keys, and stores the result in &lt;code&gt;destination&lt;/code&gt;. It is mandatory to provide the number of input keys (&lt;code&gt;numkeys&lt;/code&gt;) before passing the input keys and the other (optional) arguments.</source>
          <target state="translated">Вычисляет пересечение отсортированных наборов &lt;code&gt;numkeys&lt;/code&gt; , заданных указанными ключами, и сохраняет результат в месте &lt;code&gt;destination&lt;/code&gt; . Перед передачей ключей ввода и других (необязательных) аргументов необходимо &lt;code&gt;numkeys&lt;/code&gt; количество ключей ввода ( numkeys ).</target>
        </trans-unit>
        <trans-unit id="9e0628d44bd94fff2a05cbf6e7329ac8c1542b4c" translate="yes" xml:space="preserve">
          <source>Computes the union of &lt;code&gt;numkeys&lt;/code&gt; sorted sets given by the specified keys, and stores the result in &lt;code&gt;destination&lt;/code&gt;. It is mandatory to provide the number of input keys (&lt;code&gt;numkeys&lt;/code&gt;) before passing the input keys and the other (optional) arguments.</source>
          <target state="translated">Вычисляет объединение отсортированных наборов &lt;code&gt;numkeys&lt;/code&gt; , заданных указанными ключами, и сохраняет результат в месте &lt;code&gt;destination&lt;/code&gt; . Перед передачей ключей ввода и других (необязательных) аргументов необходимо &lt;code&gt;numkeys&lt;/code&gt; количество ключей ввода ( numkeys ).</target>
        </trans-unit>
        <trans-unit id="1ac361d8a1971640b6145bcc2b23471d096806f1" translate="yes" xml:space="preserve">
          <source>Conditions where a SHUTDOWN fails</source>
          <target state="translated">Условия,при которых SHUTDOWN выходит из строя.</target>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="ce5886d8502f58f63f333861b5077fd91e99a286" translate="yes" xml:space="preserve">
          <source>Consistency and WAIT</source>
          <target state="translated">Последовательность и WAIT</target>
        </trans-unit>
        <trans-unit id="5f2f16b6f5d5be95f9b3876b338cd86be1794d28" translate="yes" xml:space="preserve">
          <source>Consistency with range functions in various programming languages</source>
          <target state="translated">Согласованность с функциями диапазона на различных языках программирования</target>
        </trans-unit>
        <trans-unit id="b36b2f89bb23664788c6f3dd35338c638ba28a39" translate="yes" xml:space="preserve">
          <source>Consumer groups in 30 seconds</source>
          <target state="translated">Группы потребителей за 30 секунд</target>
        </trans-unit>
        <trans-unit id="bd58f13135bb4a18278653a136394b666aadff83" translate="yes" xml:space="preserve">
          <source>Consumers in a consumer group are auto-created every time a new consumer name is mentioned by some command. However sometimes it may be useful to remove old consumers since they are no longer used. This form returns the number of pending messages that the consumer had before it was deleted.</source>
          <target state="translated">Потребители в группе потребителей создаются автоматически каждый раз,когда какая-либо команда упоминает новое имя потребителя.Однако иногда бывает полезно удалить старых потребителей,так как они больше не используются.Эта форма возвращает количество ожидающих отправки сообщений,которые были у потребителя до того,как он был удален.</target>
        </trans-unit>
        <trans-unit id="93fee3ae260963d2ed888e760affe7075d85b781" translate="yes" xml:space="preserve">
          <source>Consumers in a consumer group are auto-created every time a new consumer name is mentioned by some command. They can also be explicitly created by using the following form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e04bdc35bafea7cf8c81eec69e12b57349af7a26" translate="yes" xml:space="preserve">
          <source>Conversion between Lua and Redis data types</source>
          <target state="translated">Преобразование между типами данных Lua и Redis</target>
        </trans-unit>
        <trans-unit id="c74388ea06d766117ef931f93cf1e85e7c07bf21" translate="yes" xml:space="preserve">
          <source>Cost of running &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;</source>
          <target state="translated">Стоимость работы &lt;a href=&quot;monitor&quot;&gt;МОНИТОРА&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f43fec16935ea429ca6c4332ec8b80a51c3b6c5e" translate="yes" xml:space="preserve">
          <source>Cost of running MONITOR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55d91fd97c87e8a34c622a7e4794ffcc51bd61d" translate="yes" xml:space="preserve">
          <source>Count argument extension</source>
          <target state="translated">Расширение аргумента счёта</target>
        </trans-unit>
        <trans-unit id="ed6fd4dc25ec3bdb3875f3c7192bde09b87a5801" translate="yes" xml:space="preserve">
          <source>Count the number of set bits (population counting) in a string.</source>
          <target state="translated">Считать количество установленных битов (подсчет населения)в строке.</target>
        </trans-unit>
        <trans-unit id="852a7b974be96bbc7c6036398114250aedbb0dca" translate="yes" xml:space="preserve">
          <source>Create a key associated with a value that is obtained by deserializing the provided serialized value (obtained via &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt;).</source>
          <target state="translated">Создайте ключ, связанный со значением, полученным путем десериализации предоставленного сериализованного значения (полученного с помощью &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1b9548967da77ce66eb092905a2179716e7c9d5d" translate="yes" xml:space="preserve">
          <source>Create a new consumer group associated with a stream.</source>
          <target state="translated">Создайте новую группу потребителей,связанную с потоком.</target>
        </trans-unit>
        <trans-unit id="5c0f29bb78fb88abe065ad6df1e2bc2b5123eed8" translate="yes" xml:space="preserve">
          <source>Create an ACL user with the specified rules or modify the rules of an existing user. This is the main interface in order to manipulate Redis ACL users interactively: if the username does not exist, the command creates the username without any privilege, then reads from left to right all the rules provided as successive arguments, setting the user ACL rules as specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8db62ea4abea13f4e50ca9316893c361ba8afd9" translate="yes" xml:space="preserve">
          <source>D ends re-added in the nodes table of A.</source>
          <target state="translated">D заканчивается заново в таблице узлов A.</target>
        </trans-unit>
        <trans-unit id="d6ddfbac6ec07c32e2eb043cdffc4a0b7cf14714" translate="yes" xml:space="preserve">
          <source>D is now empty, but still listed in the nodes table of A, B and C.</source>
          <target state="translated">D теперь пустая,но все еще числится в таблице узлов A,B и C.</target>
        </trans-unit>
        <trans-unit id="5231dbf5c92399c707fd162111bff340755773aa" translate="yes" xml:space="preserve">
          <source>DBSIZE</source>
          <target state="translated">DBSIZE</target>
        </trans-unit>
        <trans-unit id="cd67c53a53d3f0097d3c5a23561287ae0d9fb415" translate="yes" xml:space="preserve">
          <source>DBSIZE   Return the number of keys in the selected database</source>
          <target state="translated">DBSIZE Вернуть количество ключей в выбранной базе данных</target>
        </trans-unit>
        <trans-unit id="3f67e8f4eecf241b91f4cc8c976a487ade34d09d" translate="yes" xml:space="preserve">
          <source>DEBUG</source>
          <target state="translated">DEBUG</target>
        </trans-unit>
        <trans-unit id="64d12201fd531f0183ba8e8b6982cd30fb3885db" translate="yes" xml:space="preserve">
          <source>DEBUG OBJECT  key   Get debugging information about a key</source>
          <target state="translated">DEBUG OBJECT ключ Получить отладочную информацию о ключе</target>
        </trans-unit>
        <trans-unit id="a9e1eb844a55b579a65a4c4467b589dca48f8f1a" translate="yes" xml:space="preserve">
          <source>DEBUG SEGFAULT   Make the server crash</source>
          <target state="translated">DEBUG SEGFAULT Заставьте сервер аварийно завершить работу.</target>
        </trans-unit>
        <trans-unit id="d05cdacee2c153d405a26e62250727ce77ea0892" translate="yes" xml:space="preserve">
          <source>DECR</source>
          <target state="translated">DECR</target>
        </trans-unit>
        <trans-unit id="60ab4c3e9133d30eaf0ded676cadb4c538c56082" translate="yes" xml:space="preserve">
          <source>DECR  key   Decrement the integer value of a key by one</source>
          <target state="translated">DECR ключ Уменьшение целочисленного значения ключа на единицу</target>
        </trans-unit>
        <trans-unit id="dd8d57c1b1a5522fa21a54d374912c18ca797f47" translate="yes" xml:space="preserve">
          <source>DECRBY</source>
          <target state="translated">DECRBY</target>
        </trans-unit>
        <trans-unit id="8c2782a79fd11dffe9a2c86222797cdb763ac992" translate="yes" xml:space="preserve">
          <source>DECRBY  key decrement   Decrement the integer value of a key by the given number</source>
          <target state="translated">Декремент ключа DECRBY Уменьшение целочисленного значения ключа на заданное число</target>
        </trans-unit>
        <trans-unit id="4d017cb3dcf43d965d38a31c9ad97cefabc893fb" translate="yes" xml:space="preserve">
          <source>DEL</source>
          <target state="translated">DEL</target>
        </trans-unit>
        <trans-unit id="85fb2865a5ba87d91f28447addbf73c6630fa434" translate="yes" xml:space="preserve">
          <source>DEL  key [key ...]   Delete a key</source>
          <target state="translated">Удалить клавишу DEL [клавиша ...]Удалить клавишу</target>
        </trans-unit>
        <trans-unit id="f70fbda4bf2a0042e1d9cc7f61715651b43106d6" translate="yes" xml:space="preserve">
          <source>DISCARD</source>
          <target state="translated">DISCARD</target>
        </trans-unit>
        <trans-unit id="7bb67c7109691456662bb20fddb311696e25ac95" translate="yes" xml:space="preserve">
          <source>DISCARD   Discard all commands issued after MULTI</source>
          <target state="translated">DISCARD Отбрасывать все команды,выданные после MULTI</target>
        </trans-unit>
        <trans-unit id="fac3a6812b938bfbdd2af221e2fba7ec856f466e" translate="yes" xml:space="preserve">
          <source>DUMP</source>
          <target state="translated">DUMP</target>
        </trans-unit>
        <trans-unit id="88b9c1225fe8ce252d48041c949b9e8d2d7b90b3" translate="yes" xml:space="preserve">
          <source>DUMP  key   Return a serialized version of the value stored at the specified key.</source>
          <target state="translated">DUMP ключ Возврат сериализованной версии значения,сохраненного на указанном ключе.</target>
        </trans-unit>
        <trans-unit id="4220ea2836e7841048c2cdb7caf3ef474641deb4" translate="yes" xml:space="preserve">
          <source>Debugging Lua scripts</source>
          <target state="translated">Отладка скриптов Lua</target>
        </trans-unit>
        <trans-unit id="f34ef3d0e6d55088a63bbe9a7135854f8a4a3c06" translate="yes" xml:space="preserve">
          <source>Decrements the number stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;decrement&lt;/code&gt;. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">Уменьшает число, хранящееся в &lt;code&gt;key&lt;/code&gt; путем &lt;code&gt;decrement&lt;/code&gt; . Если ключ не существует, перед выполнением операции ему присваивается значение &lt;code&gt;0&lt;/code&gt; . Ошибка возвращается, если ключ содержит значение неправильного типа или строку, которая не может быть представлена ​​как целое число. Эта операция ограничена 64-битными целыми числами со знаком.</target>
        </trans-unit>
        <trans-unit id="eabc98dcb44b2f848dc2b5fd749cc1976767b1ef" translate="yes" xml:space="preserve">
          <source>Decrements the number stored at &lt;code&gt;key&lt;/code&gt; by one. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to &lt;strong&gt;64 bit signed integers&lt;/strong&gt;.</source>
          <target state="translated">Уменьшает число, хранящееся в &lt;code&gt;key&lt;/code&gt; на единицу. Если ключ не существует, перед выполнением операции ему присваивается значение &lt;code&gt;0&lt;/code&gt; . Ошибка возвращается, если ключ содержит значение неправильного типа или строку, которая не может быть представлена ​​как целое число. Эта операция ограничена &lt;strong&gt;64-битными целыми числами со знаком&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="543341d8d409be4e8e87f012a0d71ed9115a00c9" translate="yes" xml:space="preserve">
          <source>Delete all the keys found expired.</source>
          <target state="translated">Удалите все найденные ключи с истекшим сроком действия.</target>
        </trans-unit>
        <trans-unit id="093f69205f9dd67871820195d9a0ab6b921ee71c" translate="yes" xml:space="preserve">
          <source>Delete all the keys of all the existing databases, not just the currently selected one. This command never fails.</source>
          <target state="translated">Удалить все ключи всех существующих баз данных,а не только текущей выбранной.Эта команда никогда не подводит.</target>
        </trans-unit>
        <trans-unit id="1a8bf3d0326f070451b1d5d0c69c59a369de9555" translate="yes" xml:space="preserve">
          <source>Delete all the keys of the currently selected DB. This command never fails.</source>
          <target state="translated">Удалить все клавиши текущей выбранной БД.Эта команда никогда не подводит.</target>
        </trans-unit>
        <trans-unit id="26c0e71676fb555cdd0bb73d03160139913dfe07" translate="yes" xml:space="preserve">
          <source>Delete all the specified ACL users and terminate all the connections that are authenticated with such users. Note: the special &lt;code&gt;default&lt;/code&gt; user cannot be removed from the system, this is the default user that every new connection is authenticated with. The list of users may include usernames that do not exist, in such case no operation is performed for the non existing users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5165f9fa25a0905a85123f97b0428c87e1a5bb61" translate="yes" xml:space="preserve">
          <source>Deletes all slots from a node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a85a3d0c778d43ae904d63695fe309c4c3c24d" translate="yes" xml:space="preserve">
          <source>Deployment is hard if we have to make sure all instances contain a given command, especially in a distributed environment.</source>
          <target state="translated">Установка является сложной задачей,если нам нужно убедиться,что все экземпляры содержат заданную команду,особенно в распределенной среде.</target>
        </trans-unit>
        <trans-unit id="5ff30b622ac74ad50b3a17678781b111c2a76d5c" translate="yes" xml:space="preserve">
          <source>Design pattern</source>
          <target state="translated">Шаблон проектирования</target>
        </trans-unit>
        <trans-unit id="21a2deb58a8a8547be11baa26a8458026dc5e0be" translate="yes" xml:space="preserve">
          <source>Design pattern: Locking with &lt;code&gt;SETNX&lt;/code&gt;</source>
          <target state="translated">Шаблон дизайна: Блокировка с помощью &lt;code&gt;SETNX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa7fb27a452f3b56f97bc25556a2c1c23541060b" translate="yes" xml:space="preserve">
          <source>Destroy a consumer group.</source>
          <target state="translated">Уничтожить группу потребителей.</target>
        </trans-unit>
        <trans-unit id="2a999a830e915e0d76daa09bf5db1dee24489f35" translate="yes" xml:space="preserve">
          <source>Details on strings comparison</source>
          <target state="translated">Подробности сравнения строк</target>
        </trans-unit>
        <trans-unit id="b5cf1dd7b9908b60a915b47bdf1a512163a4abd6" translate="yes" xml:space="preserve">
          <source>Details on why the ban-list is needed</source>
          <target state="translated">Подробная информация о том,зачем нужен бан-лист.</target>
        </trans-unit>
        <trans-unit id="e861bf6485a8747057af520bff1e2bd98ca908ee" translate="yes" xml:space="preserve">
          <source>Detect timed out replicas.</source>
          <target state="translated">Обнаружение реплик с таймером.</target>
        </trans-unit>
        <trans-unit id="c1a87c7e48f6afb9828d520eaa5085ecfdb87723" translate="yes" xml:space="preserve">
          <source>Differences between XREAD and XREADGROUP</source>
          <target state="translated">Различия между XREAD и XREADGROUP</target>
        </trans-unit>
        <trans-unit id="954c7e91bbe922ce8d0679c169669338d8457c3c" translate="yes" xml:space="preserve">
          <source>Differences in Redis prior 2.1.3</source>
          <target state="translated">Различия в Redis до 2.1.3</target>
        </trans-unit>
        <trans-unit id="d60417fd68044b5a922b2a39105c16f898e592ce" translate="yes" xml:space="preserve">
          <source>Different instances may have different implementations of a command.</source>
          <target state="translated">Различные экземпляры могут иметь разную реализацию команды.</target>
        </trans-unit>
        <trans-unit id="0e666a0e590c18bbb2775c33bdd4b4b2755c4fd8" translate="yes" xml:space="preserve">
          <source>Different return values are used for different subcommands.</source>
          <target state="translated">Различные значения возврата используются для разных подкоманд.</target>
        </trans-unit>
        <trans-unit id="8519d2a89e19a4522b7059222e7d87dd5565a1b3" translate="yes" xml:space="preserve">
          <source>Disables read queries for a connection to a Redis Cluster slave node.</source>
          <target state="translated">Отключает запросы на чтение для подключения к ведомому узлу кластера Redis.</target>
        </trans-unit>
        <trans-unit id="3c9664e573a114e8272bfbfb19ccbd51925d8d78" translate="yes" xml:space="preserve">
          <source>Distribution of returned elements</source>
          <target state="translated">Распределение возвращаемых элементов</target>
        </trans-unit>
        <trans-unit id="7ccde4db71eed2460dfb04d6817e8c9f76a501f5" translate="yes" xml:space="preserve">
          <source>Due to the single-threaded nature of Redis, it is not possible to kill a client connection while it is executing a command. From the client point of view, the connection can never be closed in the middle of the execution of a command. However, the client will notice the connection has been closed only when the next command is sent (and results in network error).</source>
          <target state="translated">В связи с однопоточной природой Redis,невозможно убить клиентское соединение во время выполнения команды.С точки зрения клиента,соединение никогда не может быть закрыто в середине выполнения команды.Однако клиент заметит,что соединение было закрыто только тогда,когда будет отправлена следующая команда (и это приведет к сетевой ошибке).</target>
        </trans-unit>
        <trans-unit id="6781cfc8284296eb70ba05270579b9deac096a80" translate="yes" xml:space="preserve">
          <source>ECHO</source>
          <target state="translated">ECHO</target>
        </trans-unit>
        <trans-unit id="e7ec2091f33799c975a8d7a6ea9bc9b6bc50c88f" translate="yes" xml:space="preserve">
          <source>ECHO  message   Echo the given string</source>
          <target state="translated">Сообщение ECHO Эхо данной строки</target>
        </trans-unit>
        <trans-unit id="225a586b70502eff079ebfff31adfbc6e0bf2d35" translate="yes" xml:space="preserve">
          <source>EVAL</source>
          <target state="translated">EVAL</target>
        </trans-unit>
        <trans-unit id="ea1523936796cac657906bcb4392d72c0f622a53" translate="yes" xml:space="preserve">
          <source>EVAL  script numkeys key [key ...] arg [arg ...]   Execute a Lua script server side</source>
          <target state="translated">EVAL скрипт numkeys ключ [ключ ...]arg [аргумент ...]Выполнить на стороне сервера сценариев Lua.</target>
        </trans-unit>
        <trans-unit id="8b8522c1abed78aca4ba0ae5b2f9d4375bf6841d" translate="yes" xml:space="preserve">
          <source>EVALSHA</source>
          <target state="translated">EVALSHA</target>
        </trans-unit>
        <trans-unit id="9ca231b5b5f90e450c680cb2bea30ab1800479a3" translate="yes" xml:space="preserve">
          <source>EVALSHA  sha1 numkeys key [key ...] arg [arg ...]   Execute a Lua script server side</source>
          <target state="translated">EVALSHA sha1 numkeys ключ [ключ ...]arg [аргумент ...]Выполните сторону сервера сценариев Lua.</target>
        </trans-unit>
        <trans-unit id="e29c908995e16002c05ec47ec36aaf34a1bd4b78" translate="yes" xml:space="preserve">
          <source>EVALSHA in the context of pipelining</source>
          <target state="translated">ОВАЛША в контексте трубопроводов</target>
        </trans-unit>
        <trans-unit id="ea837e81db8c2bd7fcea29a56cd54086382f1f43" translate="yes" xml:space="preserve">
          <source>EXEC</source>
          <target state="translated">EXEC</target>
        </trans-unit>
        <trans-unit id="2b1156bdd8031e124d3a9ae093559b5a4386e538" translate="yes" xml:space="preserve">
          <source>EXEC   Execute all commands issued after MULTI</source>
          <target state="translated">EXEC Выполнять все команды,выданные после MULTI</target>
        </trans-unit>
        <trans-unit id="644b5806e118fe0af3936c64572a1496ddda7507" translate="yes" xml:space="preserve">
          <source>EXISTS</source>
          <target state="translated">EXISTS</target>
        </trans-unit>
        <trans-unit id="08807aa77041e8b29bbcefa207328a0789129027" translate="yes" xml:space="preserve">
          <source>EXISTS  key [key ...]   Determine if a key exists</source>
          <target state="translated">EXISTS ключ [ключ ...]Определите,существует ли ключ.</target>
        </trans-unit>
        <trans-unit id="1215753c2320bb44b6a871baac293e5bf276e781" translate="yes" xml:space="preserve">
          <source>EXPIRE</source>
          <target state="translated">EXPIRE</target>
        </trans-unit>
        <trans-unit id="436d86e478f5d801c08f118762eb43ed84923c39" translate="yes" xml:space="preserve">
          <source>EXPIRE  key seconds   Set a key's time to live in seconds</source>
          <target state="translated">Секунды клавиши EXPIRE Установить время клавиши,чтобы жить в секундах</target>
        </trans-unit>
        <trans-unit id="ce90cafacba153e381a002cc83387fcbd4d6f68f" translate="yes" xml:space="preserve">
          <source>EXPIREAT</source>
          <target state="translated">EXPIREAT</target>
        </trans-unit>
        <trans-unit id="34c23f46d63812eec7d4e21acb84ed6214c2b5cc" translate="yes" xml:space="preserve">
          <source>EXPIREAT  key timestamp   Set the expiration for a key as a UNIX timestamp</source>
          <target state="translated">Штемпель времени ключа EXPIREAT Устанавливает срок действия ключа в виде штемпеля времени UNIX.</target>
        </trans-unit>
        <trans-unit id="1f423012c27396dae7aa028cc182a29eea955b66" translate="yes" xml:space="preserve">
          <source>Each failure report has a time to live of two times the &lt;em&gt;node timeout&lt;/em&gt; time.</source>
          <target state="translated">Каждый отчет об отказе имеет время жизни, в два раза превышающее время &lt;em&gt;ожидания узла&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e89059e939f6644b3364536eb50a1abdc89a1613" translate="yes" xml:space="preserve">
          <source>Each line is composed of a succession of &lt;code&gt;property=value&lt;/code&gt; fields separated by a space character.</source>
          <target state="translated">Каждая строка состоит из последовательности полей &lt;code&gt;property=value&lt;/code&gt; разделенных пробелом.</target>
        </trans-unit>
        <trans-unit id="4918aff92ee02999f29bacd99ab30d0a000253c7" translate="yes" xml:space="preserve">
          <source>Each line is composed of the following fields:</source>
          <target state="translated">Каждая строка состоит из следующих полей:</target>
        </trans-unit>
        <trans-unit id="853014cc58f5042914b68be7e44d86291316a8d3" translate="yes" xml:space="preserve">
          <source>Each nested result is:</source>
          <target state="translated">Каждый вложенный результат:</target>
        </trans-unit>
        <trans-unit id="001afdca6677847da08247ab1ec58a7506cae0eb" translate="yes" xml:space="preserve">
          <source>Each node in a Redis Cluster has its view of the current cluster configuration, given by the set of known nodes, the state of the connection we have with such nodes, their flags, properties and assigned slots, and so forth.</source>
          <target state="translated">Каждый узел в кластере Redis имеет свое представление о текущей конфигурации кластера,заданное набором известных узлов,состоянием соединения,которое мы имеем с такими узлами,их флагами,свойствами и назначенными слотами,и так далее.</target>
        </trans-unit>
        <trans-unit id="ebe29cd1a064ec2dc6312d2e8c8e3c40f46f1f35" translate="yes" xml:space="preserve">
          <source>Each reported event has the following fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4031491a0a21d3efcb1ae0e642e160153ab9452c" translate="yes" xml:space="preserve">
          <source>Each result includes all active replicas of the master instance for the listed slot range. Failed replicas are not returned.</source>
          <target state="translated">Каждый результат включает в себя все активные реплики ведущего экземпляра для указанного диапазона слотов.Неудачные реплики не возвращаются.</target>
        </trans-unit>
        <trans-unit id="39a5a1ac33abf7ccbf42de1a62abad74d800f2a8" translate="yes" xml:space="preserve">
          <source>Each subcommand is documented below. At the end you'll find a description of how live resharding is performed using this command and other related commands.</source>
          <target state="translated">Каждая подкоманда документирована ниже.В конце вы найдете описание того,как с помощью этой команды и других связанных с ней команд выполняется перестановка в реальном времени.</target>
        </trans-unit>
        <trans-unit id="2d0820e2ed028ade2f8d73ff5b41f73cd289b4e1" translate="yes" xml:space="preserve">
          <source>Each top-level result contains six nested results. Each nested result is:</source>
          <target state="translated">Каждый результат верхнего уровня содержит шесть вложенных результатов.Каждый вложенный результат:</target>
        </trans-unit>
        <trans-unit id="b5f7d21b9ba2cb092f0980b7560e9cd91a246461" translate="yes" xml:space="preserve">
          <source>Effects on the node:</source>
          <target state="translated">Воздействие на узел:</target>
        </trans-unit>
        <trans-unit id="1940e8677e72b823aadf3f1babad911e272f4f7b" translate="yes" xml:space="preserve">
          <source>Elements that were not constantly present in the collection during a full iteration, may be returned or not: it is undefined.</source>
          <target state="translated">Элементы,которые не постоянно присутствовали в коллекции во время полной итерации,могут быть возвращены или нет:не определено.</target>
        </trans-unit>
        <trans-unit id="fa43f0d9868a88416f82c35ed64e1745c1e56215" translate="yes" xml:space="preserve">
          <source>Elements with the same score</source>
          <target state="translated">Элементы с одинаковым баллом</target>
        </trans-unit>
        <trans-unit id="127cfef1e8e010cbd37725ea8863aa38e5d50815" translate="yes" xml:space="preserve">
          <source>Emitting Redis logs from scripts</source>
          <target state="translated">Имитация журналов Redis из сценариев</target>
        </trans-unit>
        <trans-unit id="1f733b322f80ecf7300735b8315383e95cf78665" translate="yes" xml:space="preserve">
          <source>Enables read queries for a connection to a Redis Cluster replica node.</source>
          <target state="translated">Включает запросы на чтение для подключения к узлу реплики Redis Cluster.</target>
        </trans-unit>
        <trans-unit id="6fb65c66a66392a71ca206846f2ac13ca3b45368" translate="yes" xml:space="preserve">
          <source>End slot range</source>
          <target state="translated">Диапазон концевых щелей</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">обработка ошибок</target>
        </trans-unit>
        <trans-unit id="6ad4930b258ad43ab07d5ba00c43530ba3b62093" translate="yes" xml:space="preserve">
          <source>Evaluates a script cached on the server side by its SHA1 digest. Scripts are cached on the server side using the &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; command. The command is otherwise identical to &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;.</source>
          <target state="translated">Оценивает сценарий, кэшированный на стороне сервера, по его дайджесту SHA1. Сценарии кэшируются на стороне сервера с помощью команды &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; . В остальном команда идентична &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3784064b237e9150f97da5ef4677aaab4b0c6d07" translate="yes" xml:space="preserve">
          <source>Even if other clients are actively pushing new items at the end of the list.</source>
          <target state="translated">Даже если другие клиенты активно продвигают новые элементы в конце списка.</target>
        </trans-unit>
        <trans-unit id="7dd20b200cf466b9bb17c87ac888deb51e1a343f" translate="yes" xml:space="preserve">
          <source>Even running instances will always check the computer clock, so for instance if you set a key with a time to live of 1000 seconds, and then set your computer time 2000 seconds in the future, the key will be expired immediately, instead of lasting for 1000 seconds.</source>
          <target state="translated">Даже запущенные экземпляры всегда будут проверять компьютерные часы,поэтому,например,если Вы установите ключ со временем жизни 1000 секунд,а затем установите компьютерное время 2000 секунд в будущем,то срок действия ключа истечет немедленно,вместо того,чтобы длиться 1000 секунд.</target>
        </trans-unit>
        <trans-unit id="d27fcdec12658758c11ddcfe5132a9543098333e" translate="yes" xml:space="preserve">
          <source>Event name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad3a7a35d62cd7230213de79ba4b1043488e12a" translate="yes" xml:space="preserve">
          <source>Eventually if all the entries in a macro-node are marked as deleted, the whole node is destroyed and the memory reclaimed. This means that if you delete a large amount of entries from a stream, for instance more than 50% of the entries appended to the stream, the memory usage per entry may increment, since what happens is that the stream will start to be fragmented. However the stream performances will remain the same.</source>
          <target state="translated">В конце концов,если все записи в макро-узле будут помечены как удаленные,весь узел будет уничтожен,а память восстановлена.Это означает,что если вы удалите из потока большое количество записей,например,более 50% записей,приложенных к потоку,то использование памяти на одну запись может увеличиться,так как в этом случае поток начнет фрагментироваться.Однако производительность потока останется прежней.</target>
        </trans-unit>
        <trans-unit id="792161cf042fd5babb68da92f1bbb2902dc3526e" translate="yes" xml:space="preserve">
          <source>Every Redis instance is &lt;em&gt;guaranteed&lt;/em&gt; to have all the above libraries so you can be sure that the environment for your Redis scripts is always the same.</source>
          <target state="translated">Каждый экземпляр Redis &lt;em&gt;гарантированно&lt;/em&gt; имеет все указанные выше библиотеки, поэтому вы можете быть уверены, что среда для ваших сценариев Redis всегда одинакова.</target>
        </trans-unit>
        <trans-unit id="ff1000733402cd15305f0a4763cbc390865561a4" translate="yes" xml:space="preserve">
          <source>Every entry is composed of four (or six starting with Redis 4.0) fields:</source>
          <target state="translated">Каждая запись состоит из четырех (или шести,начинающихся с Redis 4.0)полей:</target>
        </trans-unit>
        <trans-unit id="c3f1325124fc7f8408e9843db0ab98baea3e119b" translate="yes" xml:space="preserve">
          <source>Every new connection starts without an assigned name.</source>
          <target state="translated">Каждое новое соединение начинается без имени.</target>
        </trans-unit>
        <trans-unit id="51df853590a285fd9b12bc8e0d4650ccb232f700" translate="yes" xml:space="preserve">
          <source>Every time a node processes gossip packets from other nodes, it creates (and refreshes the TTL if needed) &lt;strong&gt;failure reports&lt;/strong&gt;, remembering that a given node said another given node is in &lt;code&gt;PFAIL&lt;/code&gt; condition.</source>
          <target state="translated">Каждый раз, когда узел обрабатывает пакеты сплетен от других узлов, он создает (и при необходимости обновляет TTL) &lt;strong&gt;отчеты&lt;/strong&gt; об &lt;strong&gt;ошибках&lt;/strong&gt; , помня, что данный узел сказал, что другой данный узел находится в состоянии &lt;code&gt;PFAIL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8f9b9897ccaf6988795d0fa2e49d6b67f29b456" translate="yes" xml:space="preserve">
          <source>Every time a user performs a page view, the application can register that in the current day the user visited the web site using the &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; command setting the bit corresponding to the current day.</source>
          <target state="translated">Каждый раз, когда пользователь выполняет просмотр страницы, приложение может регистрировать, что в текущий день пользователь посетил веб-сайт, используя команду &lt;a href=&quot;setbit&quot;&gt;SETBIT,&lt;/a&gt; устанавливающую бит, соответствующий текущему дню.</target>
        </trans-unit>
        <trans-unit id="434360186a18d9c330717a5f17d631c11575acb2" translate="yes" xml:space="preserve">
          <source>Every time this script executed the resulting list will have exactly the following elements:</source>
          <target state="translated">Каждый раз при выполнении этого скрипта результирующий список будет содержать точно следующие элементы:</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="815030c996b00efbe374a3c45d7121d3e9fc4929" translate="yes" xml:space="preserve">
          <source>Example of zero padding:</source>
          <target state="translated">Пример нулевой набивки:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="c687d1b70c080536289366ba8155bc643fc72076" translate="yes" xml:space="preserve">
          <source>Exclusive intervals and infinity</source>
          <target state="translated">Эксклюзивные интервалы и бесконечность</target>
        </trans-unit>
        <trans-unit id="114f30848cb8a83d62c97a5a6476b435a78150bd" translate="yes" xml:space="preserve">
          <source>Exclusive ranges</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55912897a10d768ac59806e69e2501c331778457" translate="yes" xml:space="preserve">
          <source>Exclusive ranges and iterating the PEL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e788d736a6e3a42271b3b6edc6a324f07e11667" translate="yes" xml:space="preserve">
          <source>Executed scripts are guaranteed to be in the script cache of a given execution of a Redis instance forever. This means that if an &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is performed against a Redis instance all the subsequent &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; calls will succeed.</source>
          <target state="translated">Выполненные сценарии гарантированно навсегда останутся в кеше сценариев данного выполнения экземпляра Redis. Это означает, что если &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; выполняется для экземпляра Redis, все последующие вызовы &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; будут успешными.</target>
        </trans-unit>
        <trans-unit id="446763d77e17832a47ad829663f2f4ba29ce76f7" translate="yes" xml:space="preserve">
          <source>Executes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">Выполняет все ранее поставленные в очередь команды в &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;транзакции&lt;/a&gt; и восстанавливает нормальное состояние соединения.</target>
        </trans-unit>
        <trans-unit id="d80b1a46f6734fb75c0119610c9901aef0c08607" translate="yes" xml:space="preserve">
          <source>Executing a Lua Script with Redis 2.6 or newer.</source>
          <target state="translated">Выполнение скрипта Lua с Redis 2.6 или новее.</target>
        </trans-unit>
        <trans-unit id="e1a9d983dc0912bcd36f098a1b8c4b6851a2ccbc" translate="yes" xml:space="preserve">
          <source>Expire accuracy</source>
          <target state="translated">Точность истечения срока годности</target>
        </trans-unit>
        <trans-unit id="5bbbfc0dcb3f1ea6203152c364bf711f30071354" translate="yes" xml:space="preserve">
          <source>Expires and persistence</source>
          <target state="translated">Истечение срока годности и настойчивость</target>
        </trans-unit>
        <trans-unit id="a4432b0943d588c17ab5d7e63d136bb9786a862c" translate="yes" xml:space="preserve">
          <source>Extended form of XPENDING</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceae3e065a822da58b9dd577a4a2215264628a2c" translate="yes" xml:space="preserve">
          <source>FLUSHALL</source>
          <target state="translated">FLUSHALL</target>
        </trans-unit>
        <trans-unit id="a1dc7fedbb3161c8d2db024cd3ee46e2af26f812" translate="yes" xml:space="preserve">
          <source>FLUSHALL  [ASYNC]   Remove all keys from all databases</source>
          <target state="translated">FLUSHALL [ASYNC]Удалить все ключи из всех баз данных.</target>
        </trans-unit>
        <trans-unit id="10bb3c2c2d36018ba538d533264f2171634a8d95" translate="yes" xml:space="preserve">
          <source>FLUSHDB</source>
          <target state="translated">FLUSHDB</target>
        </trans-unit>
        <trans-unit id="b40b961b1c26ac58fbd9ac2f12f0c446fb2897d9" translate="yes" xml:space="preserve">
          <source>FLUSHDB  [ASYNC]   Remove all keys from the current database</source>
          <target state="translated">FLUSHDB [ASYNC]Удалить все ключи из текущей базы данных.</target>
        </trans-unit>
        <trans-unit id="a5f0b2c20a29e7587597abea3e79fa609ca01e4c" translate="yes" xml:space="preserve">
          <source>FORCE option: manual failover when the master is down</source>
          <target state="translated">Опция FORCE:ручное переключение при отказе ведущего устройства.</target>
        </trans-unit>
        <trans-unit id="f9c28b26fa472599864dea91ca5f8cd92a5475d7" translate="yes" xml:space="preserve">
          <source>Failures to authenticate their connections with &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt; or &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0878bdd16e36ba72b474afe51ae9c582fef6d5" translate="yes" xml:space="preserve">
          <source>Fetching a single entry from a stream, providing the ID of the entry to fetch two times: as start and end of the query interval.</source>
          <target state="translated">Захват одной записи из потока,предоставляя идентификатор записи для получения два раза:как начало и конец интервала запроса.</target>
        </trans-unit>
        <trans-unit id="d11485369737f36370f75a3ff43b46d72effc624" translate="yes" xml:space="preserve">
          <source>Fetching data from a stream via a consumer group, and not acknowledging such data, has the effect of creating &lt;em&gt;pending entries&lt;/em&gt;. This is well explained in the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command, and even better in our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. The &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command will immediately remove the pending entry from the Pending Entry List (PEL) since once a message is successfully processed, there is no longer need for the consumer group to track it and to remember the current owner of the message.</source>
          <target state="translated">Получение данных из потока через группу потребителей без подтверждения таких данных приводит к созданию &lt;em&gt;ожидающих записей&lt;/em&gt; . Это хорошо объясняется в команде &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; и даже лучше в нашем &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;введении в Redis Streams&lt;/a&gt; . Команда &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; немедленно удалит ожидающую запись из списка ожидающих записей (PEL), поскольку после успешной обработки сообщения группе потребителей больше не нужно отслеживать его и запоминать текущего владельца сообщения.</target>
        </trans-unit>
        <trans-unit id="13b9c9d38a4b96f103ca63910ffc56743e00fd12" translate="yes" xml:space="preserve">
          <source>Fetching single items</source>
          <target state="translated">Приобретение отдельных предметов</target>
        </trans-unit>
        <trans-unit id="894f8f81f5445488b186c9a058eccf6bacfbb0db" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get help from the command, in case the user can't remember the exact syntax, by using the &lt;code&gt;HELP&lt;/code&gt; subcommand:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8330be22b4e169fe5141dfbcacb82dc81724e13f" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get help from the command, in case the user can't remember the exact syntax, by using the &lt;code&gt;HELP&lt;/code&gt; subcommnad:</source>
          <target state="translated">Наконец, можно получить помощь от команды, если пользователь не может вспомнить точный синтаксис, с помощью подкоманды &lt;code&gt;HELP&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5388f4a7abea666722d4311743c9d3e1d5bfc3b1" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get the list of every consumer in a specific consumer group:</source>
          <target state="translated">Наконец,можно получить список каждого потребителя в определенной группе:</target>
        </trans-unit>
        <trans-unit id="7cbe1b741345fc3839fb4d58149e9dd7af6c272a" translate="yes" xml:space="preserve">
          <source>Finally it is possible to pass an additional argument to the command, in order to see the messages having a specific owner:</source>
          <target state="translated">Наконец,можно передать дополнительный аргумент команде,чтобы увидеть сообщения с определенным владельцем:</target>
        </trans-unit>
        <trans-unit id="58b2c6378bac42febc100a9e0341d2094c29e52e" translate="yes" xml:space="preserve">
          <source>Finally it possible to set the next message to deliver using the &lt;code&gt;SETID&lt;/code&gt; subcommand. Normally the next ID is set when the consumer is created, as the last argument of &lt;code&gt;XGROUP CREATE&lt;/code&gt;. However using this form the next ID can be modified later without deleting and creating the consumer group again. For instance if you want the consumers in a consumer group to re-process all the messages in a stream, you may want to set its next ID to 0:</source>
          <target state="translated">Наконец, можно настроить доставку следующего сообщения с помощью подкоманды &lt;code&gt;SETID&lt;/code&gt; . Обычно следующий идентификатор устанавливается при создании потребителя в качестве последнего аргумента &lt;code&gt;XGROUP CREATE&lt;/code&gt; . Однако с помощью этой формы следующий идентификатор можно изменить позже без повторного удаления и создания группы потребителей. Например, если вы хотите, чтобы потребители в группе потребителей повторно обрабатывали все сообщения в потоке, вы можете установить для его следующего идентификатора значение 0:</target>
        </trans-unit>
        <trans-unit id="53e0098dbba7db3bdb2ae206e024574f2dd74ced" translate="yes" xml:space="preserve">
          <source>Finally to also have the match len:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8081b937f79256e42e7fd856b20cf39a90419c3e" translate="yes" xml:space="preserve">
          <source>Finally to get some help if you don't remember the syntax, use the HELP subcommand:</source>
          <target state="translated">Наконец,чтобы получить помощь,если вы не помните синтаксис,используйте подкоманду HELP:</target>
        </trans-unit>
        <trans-unit id="4827d8054bd5c8af82f3e09e291390e27412f49f" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;MAXLEN&lt;/code&gt; option tells the command to compare the provided element only with a given maximum number of list items. So for instance specifying &lt;code&gt;MAXLEN 1000&lt;/code&gt; will make sure that the command performs only 1000 comparisons, effectively running the algorithm on a subset of the list (the first part or the last part depending on the fact we use a positive or negative rank). This is useful to limit the maximum complexity of the command. It is also useful when we expect the match to be found very early, but want to be sure that in case this is not true, the command does not take too much time to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc63c9b0ba92886f08fc9cdd2dca430983266b7e" translate="yes" xml:space="preserve">
          <source>First Key in Argument List</source>
          <target state="translated">Первый ключ в списке аргументов</target>
        </trans-unit>
        <trans-unit id="a8e315abf463cfb1c344b54fca5c387403cc9c5a" translate="yes" xml:space="preserve">
          <source>First replica of master for slot range</source>
          <target state="translated">Первая реплика мастера для слот-диапазона</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="4e0b6894626b05a7f879581f17814069cc8b9e6d" translate="yes" xml:space="preserve">
          <source>Flush the Append Only File if AOF is enabled.</source>
          <target state="translated">Промойте файл только для приложений,если включена функция AOF.</target>
        </trans-unit>
        <trans-unit id="3b424754326ab3315277697bc94804652181fadd" translate="yes" xml:space="preserve">
          <source>Flush the Lua scripts cache.</source>
          <target state="translated">Промой кэш сценариев Луа.</target>
        </trans-unit>
        <trans-unit id="f6bb844e2e06d69091cb567be5df64888a2d1098" translate="yes" xml:space="preserve">
          <source>Flushes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">Сбрасывает все ранее поставленные в очередь команды в &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;транзакции&lt;/a&gt; и восстанавливает нормальное состояние соединения.</target>
        </trans-unit>
        <trans-unit id="8c64c01f5213c6c086d3f83c900e781d98a8b4d5" translate="yes" xml:space="preserve">
          <source>Flushes all the previously watched keys for a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">Сбрасывает все ранее просмотренные ключи для &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;транзакции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e859a22c051906372e6ed21806faadd4fdf27b1c" translate="yes" xml:space="preserve">
          <source>For Redis 2.6 what happens is that the command performing multiple pushes is executed, and &lt;em&gt;only after&lt;/em&gt; the execution of the command the blocked clients are served. Consider this sequence of commands.</source>
          <target state="translated">Для Redis 2.6 происходит то, что выполняется команда, выполняющая несколько нажатий, и &lt;em&gt;только после&lt;/em&gt; выполнения команды обслуживаются заблокированные клиенты. Рассмотрим эту последовательность команд.</target>
        </trans-unit>
        <trans-unit id="c9543ba9d8e4550fc68513216cde163b99c314dc" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;WEIGHTS&lt;/code&gt; and &lt;code&gt;AGGREGATE&lt;/code&gt; options, see &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;.</source>
          <target state="translated">Для описания &lt;code&gt;WEIGHTS&lt;/code&gt; и &lt;code&gt;AGGREGATE&lt;/code&gt; параметров см &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9618151d729f751e6074523159514ecdfdb57ef1" translate="yes" xml:space="preserve">
          <source>For an introduction to HyperLogLog data structure check the &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; command page.</source>
          <target state="translated">Чтобы получить представление о структуре данных &lt;a href=&quot;pfcount&quot;&gt;HyperLogLog, посетите&lt;/a&gt; страницу команды PFCOUNT .</target>
        </trans-unit>
        <trans-unit id="6fcc6360d01cc6597619a76bd12e34dfa8c068d5" translate="yes" xml:space="preserve">
          <source>For an introduction to sorted sets, see the data types page on &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted sets&lt;/a&gt;.</source>
          <target state="translated">Для ознакомления с отсортированными наборами см. Страницу типов данных о &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;отсортированных наборах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e36005d4ed916277f75df55af354619d0ef5d5b" translate="yes" xml:space="preserve">
          <source>For each command type, the following line is added:</source>
          <target state="translated">Для каждого типа команды добавляется следующая строка:</target>
        </trans-unit>
        <trans-unit id="e6d8b4b7b9b4f1b118134e1b85eed9b0b1555262" translate="yes" xml:space="preserve">
          <source>For each consumer group listed the command also shows the number of consumers known in that group and the pending messages (delivered but not yet acknowledged) in that group.</source>
          <target state="translated">Для каждой перечисленной группы потребителей команда также показывает количество потребителей,известных в этой группе,и ожидающих сообщений (доставленных,но еще не подтвержденных)в этой группе.</target>
        </trans-unit>
        <trans-unit id="2f01796f139a1dd83db65e8858f0ea9b62d77fdf" translate="yes" xml:space="preserve">
          <source>For each database, the following line is added:</source>
          <target state="translated">Для каждой базы данных добавляется следующая строка:</target>
        </trans-unit>
        <trans-unit id="0553e67e4dc3e5df5405dbaf017a41c48cd92358" translate="yes" xml:space="preserve">
          <source>For each replica, the following line is added:</source>
          <target state="translated">Для каждой копии добавляется следующая строка:</target>
        </trans-unit>
        <trans-unit id="4121db15148ef3ce1e89f4557d512e7c05a4cd89" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;field&lt;/code&gt; that does not exist in the hash, a &lt;code&gt;nil&lt;/code&gt; value is returned. Because non-existing keys are treated as empty hashes, running &lt;a href=&quot;hmget&quot;&gt;HMGET&lt;/a&gt; against a non-existing &lt;code&gt;key&lt;/code&gt; will return a list of &lt;code&gt;nil&lt;/code&gt; values.</source>
          <target state="translated">Для каждого &lt;code&gt;field&lt;/code&gt; , которого нет в хэше, возвращается &lt;code&gt;nil&lt;/code&gt; значение. Поскольку несуществующие ключи обрабатываются как пустые хэши, запуск &lt;a href=&quot;hmget&quot;&gt;HMGET&lt;/a&gt; для несуществующего &lt;code&gt;key&lt;/code&gt; вернет список &lt;code&gt;nil&lt;/code&gt; значений.</target>
        </trans-unit>
        <trans-unit id="ebdc0b5372eb98dde6f0761af59221e15f0a9f9e" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;member&lt;/code&gt; that does not exist in the sorted set, a &lt;code&gt;nil&lt;/code&gt; value is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4313528e119e8db789aa6be23b8a03a247c203b4" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;member&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; is returned if the value is a member of the set, or &lt;code&gt;0&lt;/code&gt; if the element is not a member of the set or if &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b69fc5b2026538496f23b6b8fb03889d7e1936d3" translate="yes" xml:space="preserve">
          <source>For eviction purposes, you may use the &lt;code&gt;IDLETIME&lt;/code&gt; or &lt;code&gt;FREQ&lt;/code&gt; modifiers. See &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; for more information (Redis 5.0 or greater).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910c18521d782016253b4584c3c1718149e1c25d" translate="yes" xml:space="preserve">
          <source>For example a common problem when implementing Markov chains and other algorithms is to select an element at random from a set, but different elements may have different weights that change how likely it is they are picked.</source>
          <target state="translated">Например,общая проблема при реализации цепочек Маркова и других алгоритмов заключается в случайном выборе элемента из множества,но разные элементы могут иметь разные веса,которые меняют вероятность того,что они будут выбраны.</target>
        </trans-unit>
        <trans-unit id="00e8032c1c0863c866e402146d15139ddaca7eea" translate="yes" xml:space="preserve">
          <source>For example in order to take the count of all the unique search queries performed in a day, a program needs to call &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; every time a query is processed. The estimated number of unique queries can be retrieved with &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; at any time.</source>
          <target state="translated">Например, чтобы подсчитать все уникальные поисковые запросы, выполненные за день, программе необходимо вызывать &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; каждый раз, когда запрос обрабатывается. Приблизительное количество уникальных запросов можно получить с помощью &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; в любое время.</target>
        </trans-unit>
        <trans-unit id="862ca7fa622c308433f665edc841f44e39e5d232" translate="yes" xml:space="preserve">
          <source>For example the following command assigns slots 1 2 3 to the node receiving the command:</source>
          <target state="translated">Например,следующая команда присваивает узлу,принимающему команду,слоты 1 2 3:</target>
        </trans-unit>
        <trans-unit id="49606e7b6de7a4d4946192e9ed0aa5fb1d49ac0b" translate="yes" xml:space="preserve">
          <source>For example the following command increments an 5 bit signed integer at bit offset 100, and gets the value of the 4 bit unsigned integer at bit offset 0:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b525686b0a28b28e11781b09afa87dd48c9db63b" translate="yes" xml:space="preserve">
          <source>For example the following command increments an 8 bit signed integer at bit offset 100, and gets the value of the 4 bit unsigned integer at bit offset 0:</source>
          <target state="translated">Например,следующая команда увеличивает 8-битное подписанное целое число при смещении бита 100 и получает значение 4-битного неподписанного целого при смещении бита 0:</target>
        </trans-unit>
        <trans-unit id="a97e5209e5c4a8fe8fdeedf84b0123aa8fa78b8b" translate="yes" xml:space="preserve">
          <source>For example the following command will trim the stream to exactly the latest 1000 items:</source>
          <target state="translated">Например,следующая команда обрезает поток точно до последних 1000 элементов:</target>
        </trans-unit>
        <trans-unit id="bb5422e2190f7f64ad2cf5faf5279a8730064c02" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; will remove the last two occurrences of &lt;code&gt;&quot;hello&quot;&lt;/code&gt; in the list stored at &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">Например, &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; удалит два последних вхождения слова &lt;code&gt;&quot;hello&quot;&lt;/code&gt; из списка, хранящегося в &lt;code&gt;list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="806b6380a574787b8a29a883731b6c80cdcdcc0d" translate="yes" xml:space="preserve">
          <source>For example, after setting a few bits, getting the string value of the bitmap would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b555dc3155500027017fa2a4b40d9e13b0289813" translate="yes" xml:space="preserve">
          <source>For example, if I have two streams &lt;code&gt;mystream&lt;/code&gt; and &lt;code&gt;writers&lt;/code&gt;, and I want to read data from both the streams starting from the first element they contain, I could call &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; like in the following example.</source>
          <target state="translated">Например, если у меня есть два потока, &lt;code&gt;mystream&lt;/code&gt; и &lt;code&gt;writers&lt;/code&gt; , и я хочу читать данные из обоих потоков, начиная с первого содержащегося в них элемента, я мог бы вызвать &lt;a href=&quot;xread&quot;&gt;XREAD,&lt;/a&gt; как в следующем примере.</target>
        </trans-unit>
        <trans-unit id="cd44de0983e01c60e504cf2bf01e0f7c36d85e53" translate="yes" xml:space="preserve">
          <source>For example, the example above could be replaced by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="d36a4d27e7c4e26652f2b3ff43e697bb99cdbe49" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; will modify the list stored at &lt;code&gt;foobar&lt;/code&gt; so that only the first three elements of the list will remain.</source>
          <target state="translated">Например: &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; изменит список, хранящийся в &lt;code&gt;foobar&lt;/code&gt; , так, что останутся только первые три элемента списка.</target>
        </trans-unit>
        <trans-unit id="aac3daaf191be281b6ccb464e390234af5058fcd" translate="yes" xml:space="preserve">
          <source>For example: consider &lt;code&gt;source&lt;/code&gt; holding the list &lt;code&gt;a,b,c&lt;/code&gt;, and &lt;code&gt;destination&lt;/code&gt; holding the list &lt;code&gt;x,y,z&lt;/code&gt;. Executing &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; results in &lt;code&gt;source&lt;/code&gt; holding &lt;code&gt;a,b&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; holding &lt;code&gt;c,x,y,z&lt;/code&gt;.</source>
          <target state="translated">Например: рассмотрим &lt;code&gt;source&lt;/code&gt; содержащий список &lt;code&gt;a,b,c&lt;/code&gt; , и &lt;code&gt;destination&lt;/code&gt; содержащий список &lt;code&gt;x,y,z&lt;/code&gt; . Исполнительные &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; результаты в &lt;code&gt;source&lt;/code&gt; , держась за &lt;code&gt;a,b&lt;/code&gt; и &lt;code&gt;destination&lt;/code&gt; проведение &lt;code&gt;c,x,y,z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58bac03f69d7fb418a6dae21d7a1d10de406cdc5" translate="yes" xml:space="preserve">
          <source>For example: consider &lt;code&gt;source&lt;/code&gt; holding the list &lt;code&gt;a,b,c&lt;/code&gt;, and &lt;code&gt;destination&lt;/code&gt; holding the list &lt;code&gt;x,y,z&lt;/code&gt;. Executing &lt;code&gt;LMOVE source destination RIGHT LEFT&lt;/code&gt; results in &lt;code&gt;source&lt;/code&gt; holding &lt;code&gt;a,b&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; holding &lt;code&gt;c,x,y,z&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a6b3077ebbc22869bdfb44c11c89f9170d1471" translate="yes" xml:space="preserve">
          <source>For expires to work well, the computer time must be taken stable. If you move an RDB file from two computers with a big desync in their clocks, funny things may happen (like all the keys loaded to be expired at loading time).</source>
          <target state="translated">Для того,чтобы истечение срока годности заработало хорошо,компьютерное время должно быть стабильным.Если переместить RDB-файл с двух компьютеров с большим десинхронизатором в часах,могут произойти забавные вещи (как все загруженные ключи,срок действия которых истекает во время загрузки).</target>
        </trans-unit>
        <trans-unit id="f28bf0b4c581b256fa3b954009c5dc47ca8cc986" translate="yes" xml:space="preserve">
          <source>For further information about Redis streams please check our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams document&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации о потоках Redis ознакомьтесь с нашим &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;введением в документ Redis Streams&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9419f194b12efba96ec9e9a8a47640ef77051d15" translate="yes" xml:space="preserve">
          <source>For instance an application with a persistent connection to Redis can be sure that if a script was sent once it is still in memory, so EVALSHA can be used against those scripts in a pipeline without the chance of an error being generated due to an unknown script (we'll see this problem in detail later).</source>
          <target state="translated">Например,приложение с постоянным соединением с Redis может быть уверено,что если скрипт был отправлен,когда он еще находится в памяти,то EVALSHA может быть использована против этих скриптов в конвейере без шансов на генерацию ошибки из-за неизвестного скрипта (мы увидим эту проблему подробнее позже).</target>
        </trans-unit>
        <trans-unit id="dc915bb7cfa9bbec54b9f20262e4f69d0c2936e5" translate="yes" xml:space="preserve">
          <source>For instance in the above example, the last items that we received for the stream &lt;code&gt;mystream&lt;/code&gt; has ID &lt;code&gt;1526999352406-0&lt;/code&gt;, while for the stream &lt;code&gt;writers&lt;/code&gt; has the ID &lt;code&gt;1526985685298-0&lt;/code&gt;.</source>
          <target state="translated">Например , в приведенном выше примере, последние элементы , которые мы получили для потока &lt;code&gt;mystream&lt;/code&gt; имеет идентификатор &lt;code&gt;1526999352406-0&lt;/code&gt; , в то время как для потока &lt;code&gt;writers&lt;/code&gt; имеет идентификатор &lt;code&gt;1526985685298-0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12e98a029b908a48582debab0c6f730b78e90807" translate="yes" xml:space="preserve">
          <source>For instance the LCS between &quot;foo&quot; and &quot;fao&quot; is &quot;fo&quot;, since scanning the two strings from left to right, the longest common set of characters is composed of the first &quot;f&quot; and then the &quot;o&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abfec42c58b79c70de1796787342d5de058e9f11" translate="yes" xml:space="preserve">
          <source>For instance what in &lt;code&gt;redis.conf&lt;/code&gt; looks like:</source>
          <target state="translated">Например, как выглядит в &lt;code&gt;redis.conf&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="310775bb715bff8a1231237bf82d220b152e2252" translate="yes" xml:space="preserve">
          <source>For instance when Redis is used in order to implement a queue, producers and consumers of messages may want to set the name of the connection according to their role.</source>
          <target state="translated">Например,когда Redis используется для реализации очереди,производители и потребители сообщений могут захотеть установить имя соединения в соответствии со своей ролью.</target>
        </trans-unit>
        <trans-unit id="de61480f11e8a3010955bfd7cae332ac3deef0b2" translate="yes" xml:space="preserve">
          <source>For instance, in the above example the element &quot;c&quot; is present multiple times, if I want the index of the second match, I'll write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fe68157034ba62944abb2ee31fe519ec8ceb83" translate="yes" xml:space="preserve">
          <source>For more information about replication in Redis please check the &lt;a href=&quot;https://redis.io/topics/replication&quot;&gt;replication page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14c631da3e9eabaf78a7f5c398db9fc1eb1c9a2" translate="yes" xml:space="preserve">
          <source>For more information refer to the &lt;a href=&quot;https://redis.io/topics/latency-monitor&quot;&gt;Latency Monitoring Framework page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1d2a650d31219d2da12b4e4c6aaa52db811850" translate="yes" xml:space="preserve">
          <source>For most commands the first key is position 1. Position 0 is always the command name itself.</source>
          <target state="translated">Для большинства команд первой клавишей является позиция 1.Позиция 0 всегда является именем самой команды.</target>
        </trans-unit>
        <trans-unit id="f3b735d69f1d53bb920c323089af35c7960cd5bc" translate="yes" xml:space="preserve">
          <source>For nested data types, the optional &lt;code&gt;SAMPLES&lt;/code&gt; option can be provided, where &lt;code&gt;count&lt;/code&gt; is the number of sampled nested values. By default, this option is set to &lt;code&gt;5&lt;/code&gt;. To sample the all of the nested values, use &lt;code&gt;SAMPLES 0&lt;/code&gt;.</source>
          <target state="translated">Для вложенных типов данных может быть предоставлена необязательная опция &lt;code&gt;SAMPLES&lt;/code&gt; , где &lt;code&gt;count&lt;/code&gt; - количество выбранных вложенных значений. По умолчанию для этого параметра установлено значение &lt;code&gt;5&lt;/code&gt; . Чтобы выбрать все вложенные значения, используйте &lt;code&gt;SAMPLES 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29cc98c67031f5feb4c8c0734d6bcf119180ebd0" translate="yes" xml:space="preserve">
          <source>For real-time metrics and statistics involving large inputs a good approach is to use a replica (with read-only option disabled) where the bit-wise operations are performed to avoid blocking the master instance.</source>
          <target state="translated">Для метрик и статистики реального времени с большими входными данными хорошим подходом является использование реплики (с отключенной опцией &quot;только для чтения&quot;),где выполняются битовые операции,чтобы избежать блокирования ведущего экземпляра.</target>
        </trans-unit>
        <trans-unit id="86c11a7ed67c320eacf7f860ba9da8b316757034" translate="yes" xml:space="preserve">
          <source>For security concerns, certain special administration commands like &lt;code&gt;CONFIG&lt;/code&gt; are not logged into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; output.</source>
          <target state="translated">По соображениям безопасности некоторые специальные административные команды, такие как &lt;code&gt;CONFIG&lt;/code&gt; , не записываются в вывод &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="906c5a5f8c50388c930df8c6fdc394c6fc2a805e" translate="yes" xml:space="preserve">
          <source>For the LCS algorithm:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c60647d6f0b610c394981eaeb8a9621bab7be5" translate="yes" xml:space="preserve">
          <source>For the subsequent calls, you'll need to programmatically advance the last entry's ID returned. Most Redis client should abstract this detail, but the implementation can also be in the application if needed. In the example above, this means incrementing the sequence of &lt;code&gt;1526985685298-0&lt;/code&gt; by one, from 0 to 1. The second call would, therefore, be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d4a1b4aeeb486fd399846319b2294f91ddedb8b" translate="yes" xml:space="preserve">
          <source>For this reason, Redis 3.2 introduces a new command that only works when script effects replication is enabled, and is able to control the scripting replication engine. The command is called &lt;code&gt;redis.set_repl()&lt;/code&gt; and fails raising an error if called when script effects replication is disabled.</source>
          <target state="translated">По этой причине в Redis 3.2 представлена ​​новая команда, которая работает только при включенной репликации эффектов сценария и может управлять механизмом репликации сценариев. Команда называется &lt;code&gt;redis.set_repl()&lt;/code&gt; и не вызывает ошибку, если вызывается, когда репликация эффектов сценария отключена.</target>
        </trans-unit>
        <trans-unit id="51865baeeba9dd27720c605912d3014b8edbbb78" translate="yes" xml:space="preserve">
          <source>Forces a node to save the &lt;code&gt;nodes.conf&lt;/code&gt; configuration on disk. Before to return the command calls &lt;code&gt;fsync(2)&lt;/code&gt; in order to make sure the configuration is flushed on the computer disk.</source>
          <target state="translated">&lt;code&gt;nodes.conf&lt;/code&gt; узел сохранять конфигурацию nodes.conf на диске. Перед возвратом команда вызывает &lt;code&gt;fsync(2)&lt;/code&gt; , чтобы убедиться, что конфигурация сброшена на диск компьютера.</target>
        </trans-unit>
        <trans-unit id="620cbfd5798a03238a582c36dc6180b1d68a8181" translate="yes" xml:space="preserve">
          <source>Fortunately, it's possible to avoid this issue using the following algorithm. Let's see how C4, our sane client, uses the good algorithm:</source>
          <target state="translated">К счастью,этой проблемы можно избежать,используя следующий алгоритм.Посмотрим,как C4,наш вменяемый клиент,использует хороший алгоритм:</target>
        </trans-unit>
        <trans-unit id="e02d5afefc425c600d8eecdd85f79d3604e46010" translate="yes" xml:space="preserve">
          <source>From the point of view of the syntax, the commands are almost the same, however &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;&lt;em&gt;requires&lt;/em&gt; a special and mandatory option:</source>
          <target state="translated">С точки зрения синтаксиса команды практически одинаковы, однако для &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP &lt;/a&gt;&lt;em&gt;требуется&lt;/em&gt; специальная и обязательная опция:</target>
        </trans-unit>
        <trans-unit id="86f3ae974780a50a7664a8c324379a24cfdab877" translate="yes" xml:space="preserve">
          <source>Fun fact: Reddit's 2017 April fools' project &lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r/place&lt;/a&gt; was &lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;built using the Redis BITFIELD command&lt;/a&gt; in order to take an in-memory representation of the collaborative canvas.</source>
          <target state="translated">Интересный факт: апрельский проект Reddit &lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r / place&lt;/a&gt; 2017 года был &lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;построен с использованием команды Redis BITFIELD&lt;/a&gt; , чтобы получить представление совместной работы в памяти.</target>
        </trans-unit>
        <trans-unit id="53eb3603814482cd94f53dcb8dd480c97fb7a365" translate="yes" xml:space="preserve">
          <source>Furthermore, the following commands are also not logged:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ad85263278e1f788abee93dcd93c6b5f400940" translate="yes" xml:space="preserve">
          <source>GEOADD</source>
          <target state="translated">GEOADD</target>
        </trans-unit>
        <trans-unit id="fe36dd170b2d009a6fb9b3209da995c6be0a8014" translate="yes" xml:space="preserve">
          <source>GEOADD  key longitude latitude member [longitude latitude member ...]   Add one or more geospatial items in the geospatial index represented using a sorted set</source>
          <target state="translated">Член ключевой долготы ГЕОАДД [член широты долготы ...]Добавить один или несколько геопространственных элементов в геопространственный индекс,представленный с помощью отсортированного набора</target>
        </trans-unit>
        <trans-unit id="9aee98cec79ef9607b17d14a98e26344f2559e24" translate="yes" xml:space="preserve">
          <source>GEODIST</source>
          <target state="translated">GEODIST</target>
        </trans-unit>
        <trans-unit id="d87009d6893410d7c22a72e0781ff862c94b8508" translate="yes" xml:space="preserve">
          <source>GEODIST  key member1 member2 [m|km|ft|mi]   Returns the distance between two members of a geospatial index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a8e4fd28c6ceedcd2cf757094650298262be7f7" translate="yes" xml:space="preserve">
          <source>GEODIST  key member1 member2 [unit]   Returns the distance between two members of a geospatial index</source>
          <target state="translated">Ключевой член ГЕОДИСТ1 член2 [единица измерения]Возвращает расстояние между двумя членами геопространственного индекса</target>
        </trans-unit>
        <trans-unit id="d944f228d17ba584e232ef6b37a2330565210913" translate="yes" xml:space="preserve">
          <source>GEOHASH</source>
          <target state="translated">GEOHASH</target>
        </trans-unit>
        <trans-unit id="15d5ff901e592f20465c4a81d62cdf535660ac71" translate="yes" xml:space="preserve">
          <source>GEOHASH  key member [member ...]   Returns members of a geospatial index as standard geohash strings</source>
          <target state="translated">Ключевой член ГЭОГАШ [член ...]Возвращает членов геопространственного индекса в виде стандартных геохаш-строк</target>
        </trans-unit>
        <trans-unit id="567f488d82e3265931365c2760b37b40e268471e" translate="yes" xml:space="preserve">
          <source>GEOPOS</source>
          <target state="translated">GEOPOS</target>
        </trans-unit>
        <trans-unit id="681795a057130a9988e5c024a1915dc60c2ecb58" translate="yes" xml:space="preserve">
          <source>GEOPOS  key member [member ...]   Returns longitude and latitude of members of a geospatial index</source>
          <target state="translated">Основной член ГЕОПОС [член ...]Возвращает долготу и широту членов геопространственного индекса</target>
        </trans-unit>
        <trans-unit id="f883ad1ea5b9628a7c035af52696e8e216f48428" translate="yes" xml:space="preserve">
          <source>GEORADIUS</source>
          <target state="translated">GEORADIUS</target>
        </trans-unit>
        <trans-unit id="78a8e700f33e02c64280e94efe97493736549c5c" translate="yes" xml:space="preserve">
          <source>GEORADIUS  key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point</source>
          <target state="translated">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHOORD][WITHHASH][WITHASH][COUNT count][ASC|DESC][STORE key][STOREDIST key]Запрос отсортированного набора,представляющего собой геопространственный индекс,для получения членов,соответствующих заданному максимальному расстоянию от точки.</target>
        </trans-unit>
        <trans-unit id="ae4c6b87ec31f7b6af274155550a43bc379afb42" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER</source>
          <target state="translated">GEORADIUSBYMEMBER</target>
        </trans-unit>
        <trans-unit id="cf98dab16a680969ed5a7c59dd91c064dd5ffd22" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER  key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member</source>
          <target state="translated">GEORADIUSBYMEMBER радиус члена-ключа m|km|ft|mi [WITHOORD][WITHASH][WITHASH][COUNT count][ASC|DESC][STORE key][STOREDIST key]Запрос отсортированного набора,представляющего собой геопространственный индекс,для получения членов,соответствующих заданному максимальному расстоянию от члена.</target>
        </trans-unit>
        <trans-unit id="8c656e42e400e0e0513de5eb5312afe50a9bf1f5" translate="yes" xml:space="preserve">
          <source>GEOSEARCH</source>
          <target state="translated">GEOSEARCH</target>
        </trans-unit>
        <trans-unit id="3f9c1bdbc9920ba8577c53041094c05d6b105844" translate="yes" xml:space="preserve">
          <source>GEOSEARCH  key [FROMMEMBER member] [FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi] [BYBOX width height m|km|ft|mi] [ASC|DESC] [COUNT count] [WITHCOORD] [WITHDIST] [WITHHASH]   Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6122a14306dc58653c28237fae16723377d12d" translate="yes" xml:space="preserve">
          <source>GEOSEARCHSTORE</source>
          <target state="translated">GEOSEARCHSTORE</target>
        </trans-unit>
        <trans-unit id="8ad42c0130aa6e2dd8ebab61f847d23ba5e52254" translate="yes" xml:space="preserve">
          <source>GEOSEARCHSTORE  destination source [FROMMEMBER member] [FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi] [BYBOX width height m|km|ft|mi] [ASC|DESC] [COUNT count] [WITHCOORD] [WITHDIST] [WITHHASH] [STOREDIST]   Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle, and store the result in another key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="7d7f9a21ff2fe871d6f138989249c29532bb7fdc" translate="yes" xml:space="preserve">
          <source>GET  key   Get the value of a key</source>
          <target state="translated">GET ключ Получить значение ключа</target>
        </trans-unit>
        <trans-unit id="ef9841e66f1ceb2a8ca3c4b61209bfb1ccb07d46" translate="yes" xml:space="preserve">
          <source>GETBIT</source>
          <target state="translated">GETBIT</target>
        </trans-unit>
        <trans-unit id="c67560b598b48f8d8597f643fcac2a09acec11dd" translate="yes" xml:space="preserve">
          <source>GETBIT  key offset   Returns the bit value at offset in the string value stored at key</source>
          <target state="translated">Смещение ключа GETBIT Возвращает значение бита при смещении в строке,сохраненное в ключе</target>
        </trans-unit>
        <trans-unit id="171dc01acd21b14b16885f344959333f303f7868" translate="yes" xml:space="preserve">
          <source>GETRANGE</source>
          <target state="translated">GETRANGE</target>
        </trans-unit>
        <trans-unit id="120d6e3c8bea25d9ffe941d0b9d148464db210c6" translate="yes" xml:space="preserve">
          <source>GETRANGE  key start end   Get a substring of the string stored at a key</source>
          <target state="translated">GETRANGE ключ начала конца Получить подстроку строки,хранящуюся в ключе</target>
        </trans-unit>
        <trans-unit id="6a4472582074006f8a0d04a695a91bfb64d3f211" translate="yes" xml:space="preserve">
          <source>GETSET</source>
          <target state="translated">GETSET</target>
        </trans-unit>
        <trans-unit id="ea14ecdc443c7b2197bfb8f599d84d9e3ddc91a9" translate="yes" xml:space="preserve">
          <source>GETSET  key value   Set the string value of a key and return its old value</source>
          <target state="translated">Значение ключа GETSET Задайте строковое значение ключа и верните его старое значение.</target>
        </trans-unit>
        <trans-unit id="0f33bfb55b7c38358e7fef810b5a8c3a19e508c9" translate="yes" xml:space="preserve">
          <source>Generate a new &lt;code&gt;configEpoch&lt;/code&gt; unilaterally, just taking the current greatest epoch available and incrementing it if its local configuration epoch is not already the greatest.</source>
          <target state="translated">Сгенерируйте новую &lt;code&gt;configEpoch&lt;/code&gt; в одностороннем порядке, просто взяв текущую самую большую доступную эпоху и увеличив ее, если ее локальная эпоха конфигурации еще не является самой большой.</target>
        </trans-unit>
        <trans-unit id="8770e1d00765da154add27070eb66b76abb639e9" translate="yes" xml:space="preserve">
          <source>Geo</source>
          <target state="translated">Geo</target>
        </trans-unit>
        <trans-unit id="00754e7ec718eca2346352874423afcfcd99de6c" translate="yes" xml:space="preserve">
          <source>Geohash string properties</source>
          <target state="translated">свойства геохаш-строки</target>
        </trans-unit>
        <trans-unit id="fcba9fe6c6b3ee7a7679d8a80f01c177efafb91f" translate="yes" xml:space="preserve">
          <source>Get keys from the source node with &lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt; command and move them into the destination node using the &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; command.</source>
          <target state="translated">Получите ключи от исходного узла с &lt;a href=&quot;cluster-getkeysinslot&quot;&gt;помощью&lt;/a&gt; команды CLUSTER GETKEYSINSLOT и переместите их в целевой узел с помощью команды &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09aec2d48c2bf33e9f4de1efe0b69e4c3361c2f6" translate="yes" xml:space="preserve">
          <source>Get the value of &lt;code&gt;key&lt;/code&gt;. If the key does not exist the special value &lt;code&gt;nil&lt;/code&gt; is returned. An error is returned if the value stored at &lt;code&gt;key&lt;/code&gt; is not a string, because &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; only handles string values.</source>
          <target state="translated">Получите значение &lt;code&gt;key&lt;/code&gt; . Если ключ не существует, возвращается специальное значение &lt;code&gt;nil&lt;/code&gt; . Ошибка возвращается, если значение, хранящееся в &lt;code&gt;key&lt;/code&gt; , не является строкой, потому что &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; обрабатывает только строковые значения.</target>
        </trans-unit>
        <trans-unit id="4f07c68cfde1cce4484071399ec3dcac10ef3226" translate="yes" xml:space="preserve">
          <source>Given a list of SHA1 digests as arguments this command returns an array of 1 or 0, where 1 means the specific SHA1 is recognized as a script already present in the scripting cache, while 0 means that a script with this SHA1 was never seen before (or at least never seen after the latest SCRIPT FLUSH command).</source>
          <target state="translated">Получив список SHA1 дайджестов в качестве аргументов,эта команда возвращает массив 1 или 0,где 1 означает,что определенный SHA1 распознан как скрипт,уже присутствующий в кэше скриптов,в то время как 0 означает,что скрипт с этим SHA1 никогда не был замечен ранее (или,по крайней мере,никогда не был замечен после последней команды SCRIPT FLUSH).</target>
        </trans-unit>
        <trans-unit id="5e47705fe8d80f510ddf59025f5bedac0bd2d833" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, it is often useful to obtain back the coordinates of specified members. When the geospatial index is populated via &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; the coordinates are converted into a 52 bit geohash, so the coordinates returned may not be exactly the ones used in order to add the elements, but small errors may be introduced.</source>
          <target state="translated">Учитывая отсортированный набор, представляющий геопространственный индекс, заполненный с помощью команды &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; , часто бывает полезно получить обратно координаты указанных элементов. Когда геопространственный индекс заполняется с помощью &lt;a href=&quot;geoadd&quot;&gt;GEOADD,&lt;/a&gt; координаты преобразуются в 52-битный геохеш, поэтому возвращаемые координаты могут быть не совсем теми, которые использовались для добавления элементов, но могут быть внесены небольшие ошибки.</target>
        </trans-unit>
        <trans-unit id="1a98977aea8887ddd5a1edb60251e403b53795ab" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, the command returns the distance between the two specified members in the specified unit.</source>
          <target state="translated">Учитывая отсортированный набор, представляющий геопространственный индекс, заполненный с помощью команды &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; , команда возвращает расстояние между двумя указанными элементами в указанной единице.</target>
        </trans-unit>
        <trans-unit id="f45f257965d0c26e93bb5789953aca2dc751ef9e" translate="yes" xml:space="preserve">
          <source>Global variables protection</source>
          <target state="translated">Защита глобальных переменных</target>
        </trans-unit>
        <trans-unit id="107625e2c3bcf140428d9df7e4e1066049947d81" translate="yes" xml:space="preserve">
          <source>Groups, consumers and PELs are returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d1555c45e5fc58578080840f0c6368a6d6cb11" translate="yes" xml:space="preserve">
          <source>Guarantee of termination</source>
          <target state="translated">Гарантия прекращения действия</target>
        </trans-unit>
        <trans-unit id="5205aa5d3ee9c438b38044d5999ac4ba4201f832" translate="yes" xml:space="preserve">
          <source>HDEL</source>
          <target state="translated">HDEL</target>
        </trans-unit>
        <trans-unit id="f0d9eb5c49197bfd6feeb0c9d7b482f5e211f201" translate="yes" xml:space="preserve">
          <source>HDEL  key field [field ...]   Delete one or more hash fields</source>
          <target state="translated">Поле клавиши HDEL [поле ...]Удалить одно или несколько полей хэша</target>
        </trans-unit>
        <trans-unit id="c65f99f8c5376adadddc46d5cbcf5762f9e55eb7" translate="yes" xml:space="preserve">
          <source>HELLO</source>
          <target state="translated">HELLO</target>
        </trans-unit>
        <trans-unit id="194f965f233e82e8b705df8610029d9234df6a34" translate="yes" xml:space="preserve">
          <source>HELLO  protover [AUTH username password] [SETNAME clientname]   switch Redis protocol</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48dcfbcf4eca1611582a1cc8baa82d9d2fa2960" translate="yes" xml:space="preserve">
          <source>HEXISTS</source>
          <target state="translated">HEXISTS</target>
        </trans-unit>
        <trans-unit id="a807653048c48da53e448a2b285039ef0573aae8" translate="yes" xml:space="preserve">
          <source>HEXISTS  key field   Determine if a hash field exists</source>
          <target state="translated">Ключевое поле HEXISTS Определить,существует ли поле хэша</target>
        </trans-unit>
        <trans-unit id="2aa481a50927484124964b6f73bac3881de47ff3" translate="yes" xml:space="preserve">
          <source>HGET</source>
          <target state="translated">HGET</target>
        </trans-unit>
        <trans-unit id="53e1681d3979ea38127102b70459b3a4ea647f65" translate="yes" xml:space="preserve">
          <source>HGET  key field   Get the value of a hash field</source>
          <target state="translated">Поле клавиши HGET Получить значение поля хэша</target>
        </trans-unit>
        <trans-unit id="0949fe15e4d07355cc1f8bdf2d7d0a3bc27e0498" translate="yes" xml:space="preserve">
          <source>HGETALL</source>
          <target state="translated">HGETALL</target>
        </trans-unit>
        <trans-unit id="a9f2d8c36ab9a92512a3abf304cf22c78a10d32a" translate="yes" xml:space="preserve">
          <source>HGETALL  key   Get all the fields and values in a hash</source>
          <target state="translated">Клавиша HGETALL Получить все поля и значения в виде хэша.</target>
        </trans-unit>
        <trans-unit id="bec3f40ebfc071338931e9ec346c383954f688e2" translate="yes" xml:space="preserve">
          <source>HINCRBY</source>
          <target state="translated">HINCRBY</target>
        </trans-unit>
        <trans-unit id="85ba7d4ce6a861db6587eaef82d0c559a1acad5a" translate="yes" xml:space="preserve">
          <source>HINCRBY  key field increment   Increment the integer value of a hash field by the given number</source>
          <target state="translated">Приращение поля ключа HINCRBY Измените целое значение поля хэша на заданное число</target>
        </trans-unit>
        <trans-unit id="a93522c3800a73e9eb332f7f840625aacdc296f3" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT</source>
          <target state="translated">HINCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="b074f9cd10320d76be5375524c56b4c4f5083f25" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT  key field increment   Increment the float value of a hash field by the given amount</source>
          <target state="translated">Увеличение ключевого поля HINCRBYFLOAT Увеличение плавающего значения хэш-поля на заданную величину</target>
        </trans-unit>
        <trans-unit id="a857392e173da21b13e4d3e033f1d7d6aadde58a" translate="yes" xml:space="preserve">
          <source>HKEYS</source>
          <target state="translated">HKEYS</target>
        </trans-unit>
        <trans-unit id="4880894873a3e4a3dcf54bf74bebf960afb44a7c" translate="yes" xml:space="preserve">
          <source>HKEYS  key   Get all the fields in a hash</source>
          <target state="translated">Клавиша HKEYS Получить все поля в хэше.</target>
        </trans-unit>
        <trans-unit id="4d36dfb03a6ecdea21a171dc0c30adebe8d01184" translate="yes" xml:space="preserve">
          <source>HLEN</source>
          <target state="translated">HLEN</target>
        </trans-unit>
        <trans-unit id="bcfcea9d003f5af07b2bb8099e2b496b1e9e832a" translate="yes" xml:space="preserve">
          <source>HLEN  key   Get the number of fields in a hash</source>
          <target state="translated">Клавиша HLEN Получить количество полей в хэше.</target>
        </trans-unit>
        <trans-unit id="480987a6e9c4e7cd1d65f5ffad4b88a1132f2c6f" translate="yes" xml:space="preserve">
          <source>HMGET</source>
          <target state="translated">HMGET</target>
        </trans-unit>
        <trans-unit id="5b7367a8f047e6e2ad4600495794ba1f6c7d8f47" translate="yes" xml:space="preserve">
          <source>HMGET  key field [field ...]   Get the values of all the given hash fields</source>
          <target state="translated">Ключевое поле HMGET [поле ...]Получить значения всех заданных хэш-полей.</target>
        </trans-unit>
        <trans-unit id="fb5089ab3a0516d344f9de817ed332775e142279" translate="yes" xml:space="preserve">
          <source>HMSET</source>
          <target state="translated">HMSET</target>
        </trans-unit>
        <trans-unit id="b9ce7bb49b575eba9a143cb12bd3a727345953bd" translate="yes" xml:space="preserve">
          <source>HMSET  key field value [field value ...]   Set multiple hash fields to multiple values</source>
          <target state="translated">Значение ключевого поля HMSET [значение поля ...]Установите несколько хеш-полей на несколько значений.</target>
        </trans-unit>
        <trans-unit id="f36a969e90bd023793807636ddb180dde5956fd7" translate="yes" xml:space="preserve">
          <source>HSCAN</source>
          <target state="translated">HSCAN</target>
        </trans-unit>
        <trans-unit id="1f717593e9570c814ba25178e664e1d1c164122d" translate="yes" xml:space="preserve">
          <source>HSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate hash fields and associated values</source>
          <target state="translated">Курсор HSCAN [MATCH pattern][COUNT count]Инкрементально итерационные поля хэшей и связанные с ними значения</target>
        </trans-unit>
        <trans-unit id="00cee6cf2b7799f7538096724dbd92d41cec6aeb" translate="yes" xml:space="preserve">
          <source>HSET</source>
          <target state="translated">HSET</target>
        </trans-unit>
        <trans-unit id="665396b991835984fc7e3e34cd2fe5312ecf417d" translate="yes" xml:space="preserve">
          <source>HSET  key field value   Set the string value of a hash field</source>
          <target state="translated">Значение поля ключа HSET Установить строковое значение поля хэша</target>
        </trans-unit>
        <trans-unit id="bc6fdaa755b1bfae0ec78315f5fb3674c528f4e4" translate="yes" xml:space="preserve">
          <source>HSET  key field value [field value ...]   Set the string value of a hash field</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f08f81142bc45f390db40acaf0af8de40d5f8df0" translate="yes" xml:space="preserve">
          <source>HSETNX</source>
          <target state="translated">HSETNX</target>
        </trans-unit>
        <trans-unit id="8f0805bb5892aca6c147d761f188dcc8c135168b" translate="yes" xml:space="preserve">
          <source>HSETNX  key field value   Set the value of a hash field, only if the field does not exist</source>
          <target state="translated">Значение ключевого поля HSETNX Задайте значение поля хэша,только если поле не существует.</target>
        </trans-unit>
        <trans-unit id="653e2c00767d7da99a4ad249e0220683a0f21927" translate="yes" xml:space="preserve">
          <source>HSTRLEN</source>
          <target state="translated">HSTRLEN</target>
        </trans-unit>
        <trans-unit id="bb8103389cfdcecf46656f06573ed3513c20d29d" translate="yes" xml:space="preserve">
          <source>HSTRLEN  key field   Get the length of the value of a hash field</source>
          <target state="translated">Поле клавиши HSTRLEN Получить длину поля хэша</target>
        </trans-unit>
        <trans-unit id="75c2a102095c5cfb3745c7635997fd6d46e1ed99" translate="yes" xml:space="preserve">
          <source>HVALS</source>
          <target state="translated">HVALS</target>
        </trans-unit>
        <trans-unit id="2cf3758bf2c3fcb0cf4699e1fad2c529e7f60c18" translate="yes" xml:space="preserve">
          <source>HVALS  key   Get all the values in a hash</source>
          <target state="translated">Клавиша HVALS Получить все значения в хэше.</target>
        </trans-unit>
        <trans-unit id="1679a916ecf39377920740d5654170e7e20f04f9" translate="yes" xml:space="preserve">
          <source>Handling deadlocks</source>
          <target state="translated">Работа с тупиками</target>
        </trans-unit>
        <trans-unit id="17348a159bc90f6828002f9fa69a3bdc1006ad33" translate="yes" xml:space="preserve">
          <source>Handling of strings with different lengths</source>
          <target state="translated">Обработка струн разной длины</target>
        </trans-unit>
        <trans-unit id="5551ebd48f7eaa66477f72c449e4b2ccfc0f9609" translate="yes" xml:space="preserve">
          <source>Hashes</source>
          <target state="translated">Hashes</target>
        </trans-unit>
        <trans-unit id="abef659c43351c90fc57bd2f1f2ca21c74a56b5c" translate="yes" xml:space="preserve">
          <source>Hashes can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is a special encoding used for small hashes.</source>
          <target state="translated">Хэши могут быть закодированы как &lt;code&gt;ziplist&lt;/code&gt; или &lt;code&gt;hashtable&lt;/code&gt; . &lt;code&gt;ziplist&lt;/code&gt; специальная кодировка , используемая для малых хешей.</target>
        </trans-unit>
        <trans-unit id="a9f98aceea4b6640fde4f0db2b67c8b62670525a" translate="yes" xml:space="preserve">
          <source>Helper functions to return Redis types</source>
          <target state="translated">Функции помощника для возврата типов Redis</target>
        </trans-unit>
        <trans-unit id="71f2a2c44b12e8d025ffdb0ba44d167f2eb32dc5" translate="yes" xml:space="preserve">
          <source>Here are a few conversion examples:</source>
          <target state="translated">Вот несколько примеров преобразования:</target>
        </trans-unit>
        <trans-unit id="bd16d98ee220a06318e7c2f0edf89d89e391fb27" translate="yes" xml:space="preserve">
          <source>Here is the description of fields for Redis &amp;gt;= 2.4.</source>
          <target state="translated">Вот описание полей для Redis&amp;gt; = 2.4.</target>
        </trans-unit>
        <trans-unit id="1953d7d107ad4ade79603b02cdb1e8adc699e514" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;clients&lt;/strong&gt; section:</source>
          <target state="translated">Вот значение всех полей в разделе &lt;strong&gt;клиентов&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="aa545dc398491c6907d2041f2ded31d190284a9f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;cpu&lt;/strong&gt; section:</source>
          <target state="translated">Вот значение всех полей в разделе &lt;strong&gt;cpu&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="d3d5c7888fb0526434ccb545db7ed9e893e48b61" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;memory&lt;/strong&gt; section:</source>
          <target state="translated">Вот значение всех полей в разделе &lt;strong&gt;памяти&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="d1e56b526c805770cba7347f8a39b9426d10e67e" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;persistence&lt;/strong&gt; section:</source>
          <target state="translated">Вот значение всех полей в разделе &lt;strong&gt;постоянства&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="799881fdedd2437b9e8155aa33f7576cc6d468a1" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;replication&lt;/strong&gt; section:</source>
          <target state="translated">Вот значение всех полей в разделе &lt;strong&gt;репликации&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="0d613b28b44d140ea4afd266be689c2f86ce192d" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;server&lt;/strong&gt; section:</source>
          <target state="translated">Вот значение всех полей в разделе &lt;strong&gt;сервера&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="9700349259df5577664d69e8579a5af99e65c52f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;stats&lt;/strong&gt; section:</source>
          <target state="translated">Вот значение всех полей в разделе &lt;strong&gt;статистики&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4bd3033708ea4b8a6d1fbb504db04260b3b5e786" translate="yes" xml:space="preserve">
          <source>Here is the meaning of the fields:</source>
          <target state="translated">Вот значение полей:</target>
        </trans-unit>
        <trans-unit id="e97f41ad39a769cdba126aa050e98bd0bf28b8b9" translate="yes" xml:space="preserve">
          <source>Here's the default configuration for the default user:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d96106a2b4866d88034cf3cbc99a16013a0e36c" translate="yes" xml:space="preserve">
          <source>Hint: it is possible to switch to a different key based on the current Unix time, in this way it is possible to have just a relatively small amount of samples per key, to avoid dealing with very big keys, and to make this pattern more friendly to be distributed across many Redis instances.</source>
          <target state="translated">Подсказка:можно переключиться на другой ключ,основанный на текущем времени Unix,таким образом можно иметь только относительно небольшое количество выборок на ключ,чтобы избежать работы с очень большими ключами,и сделать этот шаблон более дружелюбным для распространения во многих экземплярах Redis.</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="b51e386256184dc34229a5ca92a34accb7024327" translate="yes" xml:space="preserve">
          <source>How Redis expires keys</source>
          <target state="translated">Как Redis истекает срок действия ключей</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">Как это работает?</target>
        </trans-unit>
        <trans-unit id="88559343d1f8627b05ed905092ec3f856b6418a7" translate="yes" xml:space="preserve">
          <source>How expires are handled in the replication link and AOF file</source>
          <target state="translated">Как истекает срок действия в ссылке репликации и AOF-файле</target>
        </trans-unit>
        <trans-unit id="a8dbfaf95083e1d6e63da157f09e95d8c10fa20f" translate="yes" xml:space="preserve">
          <source>How multiple clients blocked on a single stream are served</source>
          <target state="translated">Как обслуживается несколько клиентов,заблокированных в одном потоке</target>
        </trans-unit>
        <trans-unit id="d5868df09b7eeb0561970a8e423e96c9ad849dbe" translate="yes" xml:space="preserve">
          <source>How to specify intervals</source>
          <target state="translated">Как указать интервалы</target>
        </trans-unit>
        <trans-unit id="d7cd6ea4777d91cd4768a12501593a68c032c01e" translate="yes" xml:space="preserve">
          <source>However Lua scripts running in Redis 6 or greater, are able to switch to RESP3 mode, and get the replies using the new available types. Similarly Lua scripts are able to reply to clients using the new types. Please make sure to understand &lt;a href=&quot;https://github.com/antirez/resp3&quot;&gt;the capabilities for RESP3&lt;/a&gt; before continuing reading this section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a00a1128dbff721f5566b479531909bd1900b68" translate="yes" xml:space="preserve">
          <source>However because &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has very little state associated (just the cursor) it has the following drawbacks:</source>
          <target state="translated">Однако, поскольку &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; имеет очень мало связанного состояния (только курсор), он имеет следующие недостатки:</target>
        </trans-unit>
        <trans-unit id="d5314787731edc5f7c64fb20d0e8d7d8aa980d1c" translate="yes" xml:space="preserve">
          <source>However if the offset is prefixed with a &lt;code&gt;#&lt;/code&gt; character, the specified offset is multiplied by the integer type width, so for example:</source>
          <target state="translated">Однако, если смещение предваряется символом &lt;code&gt;#&lt;/code&gt; , указанное смещение умножается на ширину целочисленного типа, например:</target>
        </trans-unit>
        <trans-unit id="f5cfa667464e115c28334f27e6f622c0e6fc2a1c" translate="yes" xml:space="preserve">
          <source>However in this context the obtained queue is not &lt;em&gt;reliable&lt;/em&gt; as messages can be lost, for example in the case there is a network problem or if the consumer crashes just after the message is received but it is still to process.</source>
          <target state="translated">Однако в этом контексте полученная очередь не является &lt;em&gt;надежной,&lt;/em&gt; поскольку сообщения могут быть потеряны, например, в случае проблемы с сетью или в случае отказа потребителя сразу после того, как сообщение получено, но оно еще не обработано.</target>
        </trans-unit>
        <trans-unit id="32db1099030ce3f6b2493101785b95bdd63b63e3" translate="yes" xml:space="preserve">
          <source>However it returns OK to the caller ASAP, so the &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; command execution is not paused by itself.</source>
          <target state="translated">Однако он возвращает OK вызывающему как можно скорее, поэтому выполнение команды &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; не приостанавливается само по себе.</target>
        </trans-unit>
        <trans-unit id="5ebc54eeb70e7c4776f4ca626c28b6528713adcd" translate="yes" xml:space="preserve">
          <source>However node hash slots can be in a special state, used in order to communicate errors after a node restart (mismatch between the keys in the AOF/RDB file, and the node hash slots configuration), or when there is a resharding operation in progress. This two states are &lt;strong&gt;importing&lt;/strong&gt; and &lt;strong&gt;migrating&lt;/strong&gt;.</source>
          <target state="translated">Однако хеш-слоты узла могут находиться в особом состоянии, используемом для передачи сообщений об ошибках после перезапуска узла (несоответствие между ключами в файле AOF / RDB и конфигурацией хэш-слотов узла) или когда выполняется операция повторного определения размера. . Эти два государства &lt;strong&gt;импортируют&lt;/strong&gt; и &lt;strong&gt;мигрируют&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="74506a394d8d9a9db887f0b3d8806ba4f46848f4" translate="yes" xml:space="preserve">
          <source>However note that with streams this is not a problem: stream entries are not removed from the stream when clients are served, so every client waiting will be served as soon as an &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; command provides data to the stream.</source>
          <target state="translated">Однако обратите внимание, что с потоками это не проблема: записи потока не удаляются из потока при обслуживании клиентов, поэтому каждый ожидающий клиент будет обслуживаться, как только команда &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; предоставит данные потоку.</target>
        </trans-unit>
        <trans-unit id="5d5d9fa16c29cdab06e0b69ea5b8063d64e64fa1" translate="yes" xml:space="preserve">
          <source>However note that:</source>
          <target state="translated">Однако обратите внимание:</target>
        </trans-unit>
        <trans-unit id="c2edee6acbd228e132336d8defe53364f46f07e4" translate="yes" xml:space="preserve">
          <source>However once the data structures are bigger and are promoted to use real hash tables, the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of commands will resort to the normal behavior. Note that since this special behavior of returning all the elements is true only for small aggregates, it has no effects on the command complexity or latency. However the exact limits to get converted into real hash tables are &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;user configurable&lt;/a&gt;, so the maximum number of elements you can see returned in a single call depends on how big an aggregate data type could be and still use the packed representation.</source>
          <target state="translated">Однако, как только структуры данных станут больше и будут продвигаться для использования реальных хэш-таблиц, семейство команд &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; вернется к нормальному поведению. Обратите внимание, что, поскольку это особое поведение, заключающееся в возврате всех элементов, верно только для небольших агрегатов, оно не влияет на сложность команды или задержку. Однако точные ограничения на преобразование в реальные хеш-таблицы &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;настраиваются пользователем&lt;/a&gt; , поэтому максимальное количество элементов, которые вы можете увидеть, возвращаемые за один вызов, зависит от того, насколько большим может быть агрегированный тип данных и при этом использовать упакованное представление.</target>
        </trans-unit>
        <trans-unit id="b21c3d5072091035e19308ba188163eb9b4582ee" translate="yes" xml:space="preserve">
          <source>However starting with Redis 2.8.12 or greater, the command accepts the following form:</source>
          <target state="translated">Однако,начиная с пункта 2.8.12 красного цвета или выше,команда принимает следующую форму:</target>
        </trans-unit>
        <trans-unit id="3d9349e56b3bf2d47d692509fd1873664bc86e71" translate="yes" xml:space="preserve">
          <source>However the command cannot simply drop the node from the internal node table of the node receiving the command, it also implements a ban-list, not allowing the same node to be added again as a side effect of processing the &lt;em&gt;gossip section&lt;/em&gt; of the heartbeat packets received from other nodes.</source>
          <target state="translated">Однако команда не может просто удалить узел из таблицы внутренних узлов узла, получающего команду, она также реализует запретный список, не позволяя добавить тот же узел снова в качестве побочного эффекта обработки &lt;em&gt;секции сплетен&lt;/em&gt; в контрольных пакетах. получены от других узлов.</target>
        </trans-unit>
        <trans-unit id="77d71597c94f649040209c65345b9adb784d1ada" translate="yes" xml:space="preserve">
          <source>However the number of returned elements is reasonable, that is, in practical terms SCAN may return a maximum number of elements in the order of a few tens of elements when iterating a large collection, or may return all the elements of the collection in a single call when the iterated collection is small enough to be internally represented as an encoded data structure (this happens for small sets, hashes and sorted sets).</source>
          <target state="translated">Однако количество возвращаемых элементов является разумным,т.е.с практической точки зрения SCAN может возвращать максимальное количество элементов порядка нескольких десятков элементов при итерации большой коллекции или может возвращать все элементы коллекции за один вызов,когда итерационная коллекция достаточно мала,чтобы быть внутренне представленной в виде закодированной структуры данных (это бывает для маленьких наборов,хэшей и отсортированных наборов).</target>
        </trans-unit>
        <trans-unit id="4a9bd4d796e3f1d19b335cd4b8d1d2f3544974af" translate="yes" xml:space="preserve">
          <source>However the user can apply a transformation to the encoded string so that the first part of the element inserted in the sorted set will compare as the user requires for the specific application. For example if I want to add strings that will be compared in a case-insensitive way, but I still want to retrieve the real case when querying, I can add strings in the following way:</source>
          <target state="translated">Однако пользователь может применить преобразование к кодированной строке так,чтобы первая часть элемента,вставленного в отсортированный набор,сравнивалась так,как это требуется пользователю для конкретного приложения.Например,если я хочу добавить строки,которые будут сравниваться без учета регистра,но я все равно хочу получить реальный случай при запросе,я могу добавить строки следующим образом:</target>
        </trans-unit>
        <trans-unit id="794f44a2bce77c8dc3d6e6888d73f15fd3089fde" translate="yes" xml:space="preserve">
          <source>However the user is still able to write commands with random behavior using the following simple trick. Imagine I want to write a Redis script that will populate a list with N random integers.</source>
          <target state="translated">Однако пользователь все еще может записывать команды со случайным поведением,используя следующий простой трюк.Представьте,что я хочу написать скрипт Redis,который будет заполнять список N случайными числами.</target>
        </trans-unit>
        <trans-unit id="fb5b52cca56c4cdd87edf1dfc660cd981c3a9505" translate="yes" xml:space="preserve">
          <source>However there is a way for the user to tune the order of magnitude of the number of returned elements per call using the &lt;strong&gt;COUNT&lt;/strong&gt; option.</source>
          <target state="translated">Однако у пользователя есть способ настроить порядок количества возвращаемых элементов на вызов, используя параметр &lt;strong&gt;COUNT&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7f8f1c30670b30342c4d809208def1afc1fbfd2c" translate="yes" xml:space="preserve">
          <source>However there is an exception to this rule, and it is when a new cluster is created from scratch. Redis Cluster &lt;em&gt;config epoch collision resolution&lt;/em&gt; algorithm can deal with new nodes all configured with the same configuration at startup, but this process is slow and should be the exception, only to make sure that whatever happens, two more nodes eventually always move away from the state of having the same configuration epoch.</source>
          <target state="translated">Однако из этого правила есть исключение, и это когда новый кластер создается с нуля. Алгоритм &lt;em&gt;разрешения конфликтов эпохи конфигурации&lt;/em&gt; Redis Cluster может иметь дело с новыми узлами, настроенными с одинаковой конфигурацией при запуске, но этот процесс медленный и должен быть исключением, только чтобы убедиться, что что бы ни случилось, еще два узла в конечном итоге всегда уходят из состояния. иметь ту же конфигурацию эпохи.</target>
        </trans-unit>
        <trans-unit id="142631746a79e235cfed163ccdfe702d6be0326c" translate="yes" xml:space="preserve">
          <source>However this also means that executing slow scripts is not a good idea. It is not hard to create fast scripts, as the script overhead is very low, but if you are going to use slow scripts you should be aware that while the script is running no other client can execute commands.</source>
          <target state="translated">Однако это также означает,что выполнение медленных скриптов не является хорошей идеей.Нетрудно создавать быстрые скрипты,так как накладные расходы на выполнение скриптов очень низки,но если вы собираетесь использовать медленные скрипты,вы должны знать,что в то время как скрипт работает,ни один другой клиент не может выполнять команды.</target>
        </trans-unit>
        <trans-unit id="0a33083c754611907b7f894af6eb43aadc3e4c17" translate="yes" xml:space="preserve">
          <source>However this is a useful feature since, sometimes, we need to execute certain commands only in the master in order to create, for example, intermediate values.</source>
          <target state="translated">Однако это полезная функция,так как иногда нужно выполнять определенные команды только в мастере,чтобы создать,например,промежуточные значения.</target>
        </trans-unit>
        <trans-unit id="d0af8abe6ce309a54e5c3abb2294351b6406b863" translate="yes" xml:space="preserve">
          <source>However this is just a best-effort attempt so it is possible to still lose a write synchronously replicated to multiple replicas.</source>
          <target state="translated">Однако это всего лишь самая удачная попытка,поэтому можно потерять запись,синхронно реплицированную на несколько копий.</target>
        </trans-unit>
        <trans-unit id="ddd90e4937b6a5514534f2c76508301017283476" translate="yes" xml:space="preserve">
          <source>However trying to execute it again results into an error since the slots are already assigned:</source>
          <target state="translated">Однако повторная попытка его выполнения приводит к ошибке,так как слоты уже назначены:</target>
        </trans-unit>
        <trans-unit id="8abb1412bd4f6007eadde6067935f55706c8b96f" translate="yes" xml:space="preserve">
          <source>However using &lt;strong&gt;FORCE&lt;/strong&gt; we still need the majority of masters to be available in order to authorize the failover and generate a new configuration epoch for the replica that is going to become master.</source>
          <target state="translated">Однако при использовании &lt;strong&gt;FORCE&lt;/strong&gt; нам по-прежнему нужно, чтобы большинство мастеров было доступно для авторизации аварийного переключения и создания новой эпохи конфигурации для реплики, которая станет мастером.</target>
        </trans-unit>
        <trans-unit id="c681766630e9b93da85df642b31ac53297dab87b" translate="yes" xml:space="preserve">
          <source>However what is often very useful, is to know the match position in each strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7eb54420a392ba9d9fb195f48555b2f9849c4e4" translate="yes" xml:space="preserve">
          <source>However while blocking commands like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; are able to provide all the elements that are part of a Set in a given moment, The SCAN family of commands only offer limited guarantees about the returned elements since the collection that we incrementally iterate can change during the iteration process.</source>
          <target state="translated">Однако, в то время как команды блокировки, такие как &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; , могут предоставить все элементы, которые являются частью Set в данный момент, семейство команд SCAN предлагает только ограниченные гарантии в отношении возвращаемых элементов, поскольку коллекция, которую мы последовательно повторяем, может измениться в процессе итерации. .</target>
        </trans-unit>
        <trans-unit id="8368348c7a15aab35b99bad0b61100388ed947ac" translate="yes" xml:space="preserve">
          <source>However while the replicas connected to a master will not expire keys independently (but will wait for the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; coming from the master), they'll still take the full state of the expires existing in the dataset, so when a replica is elected to master it will be able to expire the keys independently, fully acting as a master.</source>
          <target state="translated">Однако, хотя реплики, подключенные к мастеру, не будут истекать ключами независимо (но будут ждать &lt;a href=&quot;del&quot;&gt;DEL,&lt;/a&gt; поступающего от мастера), они все равно будут принимать полное состояние истечения срока действия, существующего в наборе данных, поэтому, когда реплика будет выбрана мастером он сможет самостоятельно истекать срок действия ключей, полностью выступая в роли мастера.</target>
        </trans-unit>
        <trans-unit id="e7564bd1b123b79267215f60720a7ba2c7d0f2a4" translate="yes" xml:space="preserve">
          <source>However, note that:</source>
          <target state="translated">Однако,обратите внимание:</target>
        </trans-unit>
        <trans-unit id="ae8b2a13bc4ae56dbd4d97a2490048eefaa8824d" translate="yes" xml:space="preserve">
          <source>However, this behavior changes if you are looking for clear bits and specify a range with both &lt;strong&gt;start&lt;/strong&gt; and &lt;strong&gt;end&lt;/strong&gt;. If no clear bit is found in the specified range, the function returns -1 as the user specified a clear range and there are no 0 bits in that range.</source>
          <target state="translated">Однако это поведение изменяется, если вы ищете чистые биты и указываете диапазон с &lt;strong&gt;началом&lt;/strong&gt; и &lt;strong&gt;концом&lt;/strong&gt; . Если в указанном диапазоне не найден бит сброса, функция возвращает -1, поскольку пользователь указал диапазон очистки, и в этом диапазоне нет 0 битов.</target>
        </trans-unit>
        <trans-unit id="078d1434700af53deba94cb889757980e4b68051" translate="yes" xml:space="preserve">
          <source>Humans may use this command in order to check what is the hash slot, and then the associated Redis Cluster node, responsible for a given key.</source>
          <target state="translated">Люди могут использовать эту команду,чтобы проверить,что такое слот хэша,а затем связанный с ним узел кластера Redis,отвечающий за данный ключ.</target>
        </trans-unit>
        <trans-unit id="d68bb5655889a7436b2eff6315d03293170f63d0" translate="yes" xml:space="preserve">
          <source>HyperLogLog</source>
          <target state="translated">HyperLogLog</target>
        </trans-unit>
        <trans-unit id="58b5c100f0d44808f0dbfcc3722f78c2d81f1aaf" translate="yes" xml:space="preserve">
          <source>HyperLogLog representation</source>
          <target state="translated">представление HyperLogLog</target>
        </trans-unit>
        <trans-unit id="28c10e9d5a5781ed8d9e57c706ceb5a1dd97ff5f" translate="yes" xml:space="preserve">
          <source>I can start with this small Ruby program:</source>
          <target state="translated">Я могу начать с этой маленькой программы Руби:</target>
        </trans-unit>
        <trans-unit id="5188851d79e499077ff8c17718081d6a2d5d7980" translate="yes" xml:space="preserve">
          <source>IDs are guaranteed to be always incremental: If you compare the ID of the entry just inserted it will be greater than any other past ID, so entries are totally ordered inside a stream. In order to guarantee this property, if the current top ID in the stream has a time greater than the current local time of the instance, the top entry time will be used instead, and the sequence part of the ID incremented. This may happen when, for instance, the local clock jumps backward, or if after a failover the new master has a different absolute time.</source>
          <target state="translated">Идентификаторы гарантированно всегда инкрементальны:если вы сравните идентификатор только что вставленной записи,то он будет больше,чем любой другой предыдущий идентификатор,поэтому записи полностью упорядочены внутри потока.Чтобы гарантировать это свойство,если текущий ID топа в потоке имеет время больше,чем текущее локальное время экземпляра,вместо него будет использовано время входа топа,а последовательная часть ID инкрементируется.Это может произойти,например,когда локальные часы прыгают назад,или если после обхода отказа новый мастер имеет другое абсолютное время.</target>
        </trans-unit>
        <trans-unit id="c0f8745b1bebe7ddae3a87f4efc1207e5b87a40b" translate="yes" xml:space="preserve">
          <source>IDs are specified by two numbers separated by a &lt;code&gt;-&lt;/code&gt; character:</source>
          <target state="translated">Идентификаторы указываются двумя числами, разделенными знаком &lt;code&gt;-&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="70aab9650acd50b2b8e1776f69b86b88bbbe99e5" translate="yes" xml:space="preserve">
          <source>INCR</source>
          <target state="translated">INCR</target>
        </trans-unit>
        <trans-unit id="c59620ba3e9207aaf8fb1bf70e412a9caa358cb2" translate="yes" xml:space="preserve">
          <source>INCR  key   Increment the integer value of a key by one</source>
          <target state="translated">Ключ INCR Увеличивает целое значение ключа на единицу</target>
        </trans-unit>
        <trans-unit id="af14b6096425a1f909b7628ce8491716c2d581ba" translate="yes" xml:space="preserve">
          <source>INCRBY</source>
          <target state="translated">INCRBY</target>
        </trans-unit>
        <trans-unit id="9ab1bc6a3a0563b50a9e4bcb930106db12e2ae4e" translate="yes" xml:space="preserve">
          <source>INCRBY  key increment   Increment the integer value of a key by the given amount</source>
          <target state="translated">Приращение ключа INCRBY Увеличивает целое значение ключа на заданную сумму</target>
        </trans-unit>
        <trans-unit id="769650b0192d046cb68b526ab27d41d927ea5cc8" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT</source>
          <target state="translated">INCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="2e3bba4aaf8bd64291b4999ea2633e1cde536fe3" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT  key increment   Increment the float value of a key by the given amount</source>
          <target state="translated">Инкремент ключа INCRBYFLOAT Увеличение плавающего значения ключа на заданную величину</target>
        </trans-unit>
        <trans-unit id="9c9cf999829193894067bbd9e1484756ab736ac0" translate="yes" xml:space="preserve">
          <source>INFO</source>
          <target state="translated">INFO</target>
        </trans-unit>
        <trans-unit id="42089cfb2067d721afeae473b5079898e863248e" translate="yes" xml:space="preserve">
          <source>INFO  [section]   Get information and statistics about the server</source>
          <target state="translated">INFO [раздел]Получить информацию и статистику о сервере.</target>
        </trans-unit>
        <trans-unit id="fc967bd2cc1b3485f1ee6c3bccb3832c0009ded5" translate="yes" xml:space="preserve">
          <source>Ideally, the &lt;code&gt;used_memory_rss&lt;/code&gt; value should be only slightly higher than &lt;code&gt;used_memory&lt;/code&gt;. When rss &amp;gt;&amp;gt; used, a large difference means there is memory fragmentation (internal or external), which can be evaluated by checking &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt;. When used &amp;gt;&amp;gt; rss, it means part of Redis memory has been swapped off by the operating system: expect some significant latencies.</source>
          <target state="translated">В идеале значение &lt;code&gt;used_memory_rss&lt;/code&gt; должно быть лишь немного выше, чем &lt;code&gt;used_memory&lt;/code&gt; . При использовании rss &amp;gt;&amp;gt; большая разница означает фрагментацию памяти (внутреннюю или внешнюю), которую можно оценить, проверив &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt; . Когда используется &amp;gt;&amp;gt; rss, это означает, что часть памяти Redis была отключена операционной системой: ожидайте значительных задержек.</target>
        </trans-unit>
        <trans-unit id="73b4eda93b2219c5cea27cedcc70f71581e15c99" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; fails, no data gets lost as the old AOF will be untouched.</source>
          <target state="translated">Если &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; выходит из строя, данные не теряются, так как старый AOF останется нетронутым.</target>
        </trans-unit>
        <trans-unit id="1d20f361447b1eebe4e4808ffc994e347a4065d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;0&lt;/code&gt; the key is already locked by some other client. We can either return to the caller if it's a non blocking lock, or enter a loop retrying to hold the lock until we succeed or some kind of timeout expires.</source>
          <target state="translated">Если &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; возвращает &lt;code&gt;0&lt;/code&gt; , ключ уже заблокирован другим клиентом. Мы можем либо вернуться к вызывающему, если это неблокирующая блокировка, либо войти в цикл, пытаясь удерживать блокировку до тех пор, пока мы не добьемся успеха, или пока не истечет какой-то тайм-аут.</target>
        </trans-unit>
        <trans-unit id="b2860996021d578f69065139684f5cafa8d2519b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;1&lt;/code&gt; the client acquired the lock, setting the &lt;code&gt;lock.foo&lt;/code&gt; key to the Unix time at which the lock should no longer be considered valid. The client will later use &lt;code&gt;DEL lock.foo&lt;/code&gt; in order to release the lock.</source>
          <target state="translated">Если &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; возвращает &lt;code&gt;1&lt;/code&gt; ,значит, клиент получил блокировку, установив для ключа &lt;code&gt;lock.foo&lt;/code&gt; время Unix, при котором блокировка больше не должна считаться действительной. Позже клиент будет использовать &lt;code&gt;DEL lock.foo&lt;/code&gt; , чтобы снять блокировку.</target>
        </trans-unit>
        <trans-unit id="a5eee6810815d94e86b03260de66be0feb7ce88c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt; was used, &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; unwatches all keys watched by the connection.</source>
          <target state="translated">Если &lt;a href=&quot;watch&quot;&gt;ЧАСЫ&lt;/a&gt; использовался, &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; unwatches все ключи отслеживаемых соединения.</target>
        </trans-unit>
        <trans-unit id="db30f622717bd53f660e926c446f65281d373325" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BGSAVE SCHEDULE&lt;/code&gt; is used, the command will immediately return &lt;code&gt;OK&lt;/code&gt; when an AOF rewrite is in progress and schedule the background save to run at the next opportunity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ed44b2bda4227d511c46587683f47a00d993b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITHCOORD&lt;/code&gt;, &lt;code&gt;WITHDIST&lt;/code&gt; or &lt;code&gt;WITHHASH&lt;/code&gt; options are specified, the command returns an array of arrays, where each sub-array represents a single item.</source>
          <target state="translated">Если &lt;code&gt;WITHCOORD&lt;/code&gt; , &lt;code&gt;WITHDIST&lt;/code&gt; или &lt;code&gt;WITHHASH&lt;/code&gt; , команда возвращает массив массивов, где каждый подмассив представляет отдельный элемент.</target>
        </trans-unit>
        <trans-unit id="73dfe5f15062ceece61a6acc3449e57743eeff88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;destination&lt;/code&gt; already exists, it is overwritten.</source>
          <target state="translated">Если &lt;code&gt;destination&lt;/code&gt; уже существует, он перезаписывается.</target>
        </trans-unit>
        <trans-unit id="ec00a71247f51a83461ff727be4fdc2a9b8eef53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; already exists and is a string, this command appends the &lt;code&gt;value&lt;/code&gt; at the end of the string. If &lt;code&gt;key&lt;/code&gt; does not exist it is created and set as an empty string, so &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; will be similar to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; in this special case.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; уже существует и является строкой, эта команда добавляет &lt;code&gt;value&lt;/code&gt; в конец строки. Если &lt;code&gt;key&lt;/code&gt; не существует, он создается и устанавливается как пустая строка, поэтому &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; будет аналогичен &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; в этом особом случае.</target>
        </trans-unit>
        <trans-unit id="f65de86e658742c07d7bc6102da39df199a9b701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist a nil bulk reply is returned.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, возвращается нулевой массовый ответ.</target>
        </trans-unit>
        <trans-unit id="bd4417fe5a7c2042f71015b09d46b92838be30fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified members as sole members is created, like if the sorted set was empty. If the key exists but does not hold a sorted set, an error is returned.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, создается новый отсортированный набор с указанными членами в качестве единственных, как если бы отсортированный набор был пуст. Если ключ существует, но не содержит отсортированного набора, возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="e64662be889ce64c17aaa1cc9189ce3256310f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;member&lt;/code&gt; не существует в отсортированном наборе или &lt;code&gt;key&lt;/code&gt; не существует, &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;массовый строковый ответ&lt;/a&gt; : &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f23ea3c8266e3f5959aed27b93602e9cafb796f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;member&lt;/code&gt; не существует в отсортированном наборе или &lt;code&gt;key&lt;/code&gt; не существует, возвращается &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e3e9eec1dfb85dde46f12f033df8c95cb570dc1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; exists in the sorted set, &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the rank of &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;member&lt;/code&gt; существует в отсортированном наборе, &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Целочисленный ответ&lt;/a&gt; : ранг &lt;code&gt;member&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0602d8252b35c86b3177857f428ef2b6ebe2844" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;password&lt;/code&gt; matches the password in the configuration file, the server replies with the &lt;code&gt;OK&lt;/code&gt; status code and starts accepting commands. Otherwise, an error is returned and the clients needs to try a new password.</source>
          <target state="translated">Если &lt;code&gt;password&lt;/code&gt; совпадает с паролем в файле конфигурации, сервер отвечает кодом состояния &lt;code&gt;OK&lt;/code&gt; и начинает принимать команды. В противном случае возвращается ошибка, и клиентам необходимо попробовать новый пароль.</target>
        </trans-unit>
        <trans-unit id="25efaee0f3cfe5471248ed210126224686506e29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; does not exist, the value &lt;code&gt;nil&lt;/code&gt; is returned and no operation is performed. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are the same, the operation is equivalent to removing the first/last element from the list and pushing it as first/last element of the list, so it can be considered as a list rotation command (or a no-op if &lt;code&gt;wherefrom&lt;/code&gt; is the same as &lt;code&gt;whereto&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a36f67086d264992352bae73959a976d08f592" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; does not exist, the value &lt;code&gt;nil&lt;/code&gt; is returned and no operation is performed. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are the same, the operation is equivalent to removing the last element from the list and pushing it as first element of the list, so it can be considered as a list rotation command.</source>
          <target state="translated">Если &lt;code&gt;source&lt;/code&gt; не существует, возвращается значение &lt;code&gt;nil&lt;/code&gt; и никакая операция не выполняется. Если &lt;code&gt;source&lt;/code&gt; и &lt;code&gt;destination&lt;/code&gt; совпадают, операция эквивалентна удалению последнего элемента из списка и продвижению его в качестве первого элемента списка, поэтому ее можно рассматривать как команду вращения списка.</target>
        </trans-unit>
        <trans-unit id="5b26bcfdadbb106d42a10a68f68adf4977b43380" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ttl&lt;/code&gt; is 0 the key is created without any expire, otherwise the specified expire time (in milliseconds) is set.</source>
          <target state="translated">Если &lt;code&gt;ttl&lt;/code&gt; равен 0, ключ создается без истечения срока действия, в противном случае устанавливается указанное время истечения срока действия (в миллисекундах).</target>
        </trans-unit>
        <trans-unit id="2c1e9f5fc6b657f9746f093601d0e06e3be8a993" translate="yes" xml:space="preserve">
          <source>If AOF is activated, these additional fields will be added:</source>
          <target state="translated">Если AOF активирована,эти дополнительные поля будут добавлены:</target>
        </trans-unit>
        <trans-unit id="3a074c9af49d118ca170e19c962a9318fe91cfe4" translate="yes" xml:space="preserve">
          <source>If a Redis 6.0 instance, or greater, is using the &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;Redis ACL system&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52fb5f5179b2d79edc8c3b551f845f186e716372" translate="yes" xml:space="preserve">
          <source>If a Redis child is creating a snapshot on disk, the AOF rewrite is &lt;em&gt;scheduled&lt;/em&gt; but not started until the saving child producing the RDB file terminates. In this case the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; will still return an OK code, but with an appropriate message. You can check if an AOF rewrite is scheduled looking at the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command as of Redis 2.6.</source>
          <target state="translated">Если дочерний элемент Redis создает моментальный снимок на диске, перезапись AOF &lt;em&gt;планируется,&lt;/em&gt; но не запускается до тех пор, пока не завершится сохранение дочернего элемента, создающего файл RDB. В этом случае &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; все равно будет возвращать код ОК, но с соответствующим сообщением. Вы можете проверить, запланирована ли перезапись AOF, просмотрев команду &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; в Redis 2.6.</target>
        </trans-unit>
        <trans-unit id="a26aac34716b82962d62dd7eb321e26db471b019" translate="yes" xml:space="preserve">
          <source>If a Redis child is creating a snapshot on disk, the AOF rewrite is &lt;em&gt;scheduled&lt;/em&gt; but not started until the saving child producing the RDB file terminates. In this case the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; will still return an positive status reply, but with an appropriate message. You can check if an AOF rewrite is scheduled looking at the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command as of Redis 2.6 or successive versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fab76e64c7a99cf5ff09d3faf8bcf4e7b29c3b9" translate="yes" xml:space="preserve">
          <source>If a Redis server is already acting as replica, the command &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE will turn off the replication, turning the Redis server into a MASTER. In the proper form &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will make the server a replica of another server listening at the specified hostname and port.</source>
          <target state="translated">Если сервер Redis уже работает как реплика, команда &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE отключит репликацию, превратив сервер Redis в ГЛАВНЫЙ. В правильной форме &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port сделает сервер репликой другого сервера, прослушивающего указанные имя хоста и порт.</target>
        </trans-unit>
        <trans-unit id="6bba5cc9a8544de84799044ff9489eaddadc2beb" translate="yes" xml:space="preserve">
          <source>If a SYNC operation is on-going, these additional fields are provided:</source>
          <target state="translated">Если операция SYNC продолжается,то предоставляются эти дополнительные поля:</target>
        </trans-unit>
        <trans-unit id="b39dab88e7088d47355746e00cd5a3b16aea36b7" translate="yes" xml:space="preserve">
          <source>If a cluster instance has non-contiguous slots (e.g. 1-400,900,1800-6000) then master and replica IP/Port results will be duplicated for each top-level slot range reply.</source>
          <target state="translated">Если экземпляр кластера имеет несмежные слоты (например,1-400 900 1800-6000),то результаты IP/Port будут дублироваться для каждого ответа диапазона слотов верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="59220272c64271f85f1f97cc7691835ad64c2de3" translate="yes" xml:space="preserve">
          <source>If a command accepts an unlimited number of keys, the last key position is -1.</source>
          <target state="translated">Если команда принимает неограниченное количество ключей,то последняя позиция ключа -1.</target>
        </trans-unit>
        <trans-unit id="140a2742270e0d194dfebacb6a9c7a4820592aff" translate="yes" xml:space="preserve">
          <source>If a command accepts one key, the first key and last key positions is 1.</source>
          <target state="translated">Если команда принимает один ключ,то первый и последний-1.</target>
        </trans-unit>
        <trans-unit id="c31655fb4face26cd02e88dd6486f34dd31bb51e" translate="yes" xml:space="preserve">
          <source>If a command accepts two keys (e.g. &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;, &lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt;, &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, ...) then the last key position is the location of the last key in the argument list.</source>
          <target state="translated">Если команда принимает два ключа (например, &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; , &lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt; , &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; , ...), то позиция последнего ключа - это положение последнего ключа в списке аргументов.</target>
        </trans-unit>
        <trans-unit id="610d9883b3ed9e5bbf61e781dfb38f2ca5532e85" translate="yes" xml:space="preserve">
          <source>If a command is received about a key that does not exists, an &lt;code&gt;ASK&lt;/code&gt; redirection is emitted by the node, asking the client to retry only that specific query into &lt;code&gt;destination-node&lt;/code&gt;. In this case the client should not update its hash slot to node mapping.</source>
          <target state="translated">Если получена команда о ключе , который не существует, &lt;code&gt;ASK&lt;/code&gt; Перенаправление излучаемый узлом, чтобы просить клиента повторить только то , что конкретный запрос в &lt;code&gt;destination-node&lt;/code&gt; . В этом случае клиент не должен обновлять свой хэш-слот для сопоставления узлов.</target>
        </trans-unit>
        <trans-unit id="adc3a75aac4d6b35ed7b12ce05235e4cc640c05b" translate="yes" xml:space="preserve">
          <source>If a command is received about an existing key, the command is processed as usually.</source>
          <target state="translated">Если поступает команда о существующем ключе,команда обрабатывается,как обычно.</target>
        </trans-unit>
        <trans-unit id="a64d2ec3bb10e34eb579070274923657d7138a2a" translate="yes" xml:space="preserve">
          <source>If a key is overwritten by &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, like in the case of an existing key &lt;code&gt;Key_A&lt;/code&gt; that is overwritten by a call like &lt;code&gt;RENAME Key_B Key_A&lt;/code&gt;, it does not matter if the original &lt;code&gt;Key_A&lt;/code&gt; had a timeout associated or not, the new key &lt;code&gt;Key_A&lt;/code&gt; will inherit all the characteristics of &lt;code&gt;Key_B&lt;/code&gt;.</source>
          <target state="translated">Если ключ перезаписывается с помощью &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; , как в случае существующего ключа &lt;code&gt;Key_A&lt;/code&gt; , который перезаписывается вызовом типа &lt;code&gt;RENAME Key_B Key_A&lt;/code&gt; , не имеет значения, был ли у исходного &lt;code&gt;Key_A&lt;/code&gt; связанный тайм-аут или нет, новый ключ &lt;code&gt;Key_A&lt;/code&gt; унаследует все характеристики &lt;code&gt;Key_B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0360f4a1e3e37b28bbc1c81856843472bd113d44" translate="yes" xml:space="preserve">
          <source>If a key is renamed with &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, the associated time to live is transferred to the new key name.</source>
          <target state="translated">Если ключ переименован с помощью &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; , связанное время жизни переносится на новое имя ключа.</target>
        </trans-unit>
        <trans-unit id="dba073505eef52f13e35c2d2b072e15bc497f1c3" translate="yes" xml:space="preserve">
          <source>If a load operation is on-going, these additional fields will be added:</source>
          <target state="translated">Если операция загрузки продолжается,эти дополнительные поля будут добавлены:</target>
        </trans-unit>
        <trans-unit id="a8036cb18b462f0b09c70d787c53e11501cfbc97" translate="yes" xml:space="preserve">
          <source>If a node with unbound hash slots receives a heartbeat packet from another node that claims to be the owner of some of those hash slots, the association is established instantly. Moreover, if a heartbeat or update message is received with a configuration epoch greater than the node's own, the association is re-established.</source>
          <target state="translated">Если узел с несвязанными хэш-слотами получает от другого узла,который утверждает,что является владельцем некоторых из этих хэш-слотов,ассоциация создается мгновенно.Более того,при получении сообщения об ударе сердца или обновлении с эпохой конфигурации,превышающей собственную,ассоциация восстанавливается.</target>
        </trans-unit>
        <trans-unit id="e6947348d36ca3b7d6ec64b0d3d493bff74f2cca" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">Если сервер уже является копией какого-либо мастера, &lt;a href=&quot;replicaof&quot;&gt;порт&lt;/a&gt; имени хоста REPLICAOF остановит репликацию на старом сервере и начнет синхронизацию с новым, отбросив старый набор данных.</target>
        </trans-unit>
        <trans-unit id="8355cef42438c57bf29e119daff3edf69a2eafac" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">Если сервер уже является копией какого-либо мастера, порт &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname остановит репликацию на старый сервер и начнет синхронизацию с новым, отбросив старый набор данных.</target>
        </trans-unit>
        <trans-unit id="796f8c82d2cb3bc6674d519060d62df76a47b5cf" translate="yes" xml:space="preserve">
          <source>If an AOF rewrite is already in progress the command returns an error and no AOF rewrite will be scheduled for a later time.</source>
          <target state="translated">Если перезапись AOF уже выполняется,команда возвращает ошибку,и перезапись AOF не будет запланирована на более позднее время.</target>
        </trans-unit>
        <trans-unit id="aa95f2ff011f2ee3af55365c22aa9caf33f28db8" translate="yes" xml:space="preserve">
          <source>If an option already exists in the old redis.conf file, it will be rewritten at the same position (line number).</source>
          <target state="translated">Если опция уже существует в старом файле redis.conf,то она будет переписана в той же позиции (номер строки).</target>
        </trans-unit>
        <trans-unit id="4658daabd5c918d6c9d2de1223a7f5eb6d9fd842" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to a non-default value, it is appended at the end of the file.</source>
          <target state="translated">Если опция еще не присутствует,но установлена в значение не по умолчанию,она добавляется в конце файла.</target>
        </trans-unit>
        <trans-unit id="e4228aca6b611c430e003ee894c91eb30a1b6cd7" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to its default value, it is not added by the rewrite process.</source>
          <target state="translated">Если опция еще не присутствует,но установлена в значение по умолчанию,то в процессе перезаписи она не добавляется.</target>
        </trans-unit>
        <trans-unit id="b63f671253761bdf3174af266654497deb63ef4b" translate="yes" xml:space="preserve">
          <source>If another client, for instance C5, was faster than C4 and acquired the lock with the &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation, the C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation will return a non expired timestamp. C4 will simply restart from the first step. Note that even if C4 set the key a bit a few seconds in the future this is not a problem.</source>
          <target state="translated">Если другой клиент, например C5, был быстрее, чем C4, и получил блокировку с &lt;a href=&quot;getset&quot;&gt;помощью&lt;/a&gt; операции GETSET, операция C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; вернет метку времени, срок действия которой не истек. C4 просто перезапустится с первого шага. Обратите внимание, что даже если C4 установит ключ на несколько секунд в будущем, это не проблема.</target>
        </trans-unit>
        <trans-unit id="37cf40db32d54ae3579f3237037ff5c92145f193" translate="yes" xml:space="preserve">
          <source>If at a given time a node has another node flagged with &lt;code&gt;PFAIL&lt;/code&gt;, and at the same time collected the majority of other master nodes &lt;em&gt;failure reports&lt;/em&gt; about this node (including itself if it is a master), then it elevates the failure state of the node from &lt;code&gt;PFAIL&lt;/code&gt; to &lt;code&gt;FAIL&lt;/code&gt;, and broadcasts a message forcing all the nodes that can be reached to flag the node as &lt;code&gt;FAIL&lt;/code&gt;.</source>
          <target state="translated">Если в данный момент у узла есть другой узел, помеченный с помощью &lt;code&gt;PFAIL&lt;/code&gt; , и в то же время собрано большинство &lt;em&gt;отчетов&lt;/em&gt; об &lt;em&gt;отказе&lt;/em&gt; других главных узлов об этом узле (включая его самого, если он является главным), то он повышает состояние отказа узла. от &lt;code&gt;PFAIL&lt;/code&gt; до &lt;code&gt;FAIL&lt;/code&gt; и передает сообщение, вынуждающее все узлы, которые могут быть достигнуты, пометить узел как &lt;code&gt;FAIL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f5470ee8997d2330c4f1d3cb52035e4a73f57ce" translate="yes" xml:space="preserve">
          <source>If count is bigger than the number of elements inside the Set, the command will only return the whole set without additional elements.</source>
          <target state="translated">Если счетчик больше,чем количество элементов внутри множества,команда вернет только весь набор без дополнительных элементов.</target>
        </trans-unit>
        <trans-unit id="b7b84ded8883c2f1d689aced4377969210247451" translate="yes" xml:space="preserve">
          <source>If every line in the file is valid, all the ACLs are loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7166a4c2e9e0a7b189fdf30ab0234c6d47986ab4" translate="yes" xml:space="preserve">
          <source>If instead the message was already delivered to this consumer, and it is just re-fetching the same message again, then the &lt;em&gt;last delivery counter&lt;/em&gt; is updated to the current time, and the &lt;em&gt;number of deliveries&lt;/em&gt; is incremented by one. You can access those message properties using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command.</source>
          <target state="translated">Если вместо этого сообщение уже было доставлено этому потребителю, и он просто повторно выбирает то же сообщение снова, то &lt;em&gt;последний счетчик доставки&lt;/em&gt; обновляется до текущего времени, а &lt;em&gt;количество доставок&lt;/em&gt; увеличивается на единицу. Вы можете получить доступ к этим свойствам сообщения с помощью команды &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb7b53c8c56d77ba922276fcf8d6fc9a5555deb" translate="yes" xml:space="preserve">
          <source>If instead you want consumers to fetch the whole stream history, use zero as the starting ID for the consumer group:</source>
          <target state="translated">Если вместо этого вы хотите,чтобы потребители получали всю историю потока,используйте ноль в качестве стартового идентификатора для группы потребителей:</target>
        </trans-unit>
        <trans-unit id="766551fe9e9ea8009a726c50e78e04cbf000fc57" translate="yes" xml:space="preserve">
          <source>If more than 25% of keys were expired, start again from step 1.</source>
          <target state="translated">Если более 25% ключей истекли,начните заново с шага 1.</target>
        </trans-unit>
        <trans-unit id="18ba579c412c6a80f5484abbbc6da80390ec5935" translate="yes" xml:space="preserve">
          <source>If multiple clients are blocked for the same key, the first client to be served is the one that was waiting for more time (the first that blocked for the key). Once a client is unblocked it does not retain any priority, when it blocks again with the next call to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; it will be served accordingly to the number of clients already blocked for the same key, that will all be served before it (from the first to the last that blocked).</source>
          <target state="translated">Если несколько клиентов заблокированы для одного и того же ключа, первым обслуживаемым клиентом будет тот, который ждал больше времени (первый, который заблокировался для ключа). После того, как клиент разблокирован, он не сохраняет никакого приоритета, когда он снова блокируется при следующем вызове &lt;a href=&quot;blpop&quot;&gt;BLPOP,&lt;/a&gt; он будет обслуживаться в соответствии с количеством клиентов, уже заблокированных для того же ключа, которые все будут обслуживаться до него (с первого до последнего что заблокировано).</target>
        </trans-unit>
        <trans-unit id="2d45448e42846cf1223f90529d7153a4f2ea7d57" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;pattern&lt;/code&gt; is specified, all the channels are listed, otherwise if pattern is specified only channels matching the specified glob-style pattern are listed.</source>
          <target state="translated">Если &lt;code&gt;pattern&lt;/code&gt; не указан, отображаются все каналы, в противном случае, если указан шаблон, отображаются только каналы, соответствующие заданному шаблону стиля глобуса.</target>
        </trans-unit>
        <trans-unit id="ea2697ae6fd039b4a66dbcb2f98b8550bd0df116" translate="yes" xml:space="preserve">
          <source>If no reset type is specified, the default is &lt;strong&gt;soft&lt;/strong&gt;.</source>
          <target state="translated">Если тип сброса не указан, по умолчанию используется &lt;strong&gt;мягкий&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7a5e1cf1e0228d3ddab066d68bd268b73f915f6a" translate="yes" xml:space="preserve">
          <source>If none of the specified keys exist, &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; blocks the connection until another client performs an &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; or &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; operation against one of the keys.</source>
          <target state="translated">Если ни один из указанных ключей не существует, &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; блокирует соединение до тех пор, пока другой клиент не выполнит &lt;a href=&quot;lpush&quot;&gt;операцию LPUSH&lt;/a&gt; или &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; с одним из ключей.</target>
        </trans-unit>
        <trans-unit id="dfae9157f2f024976d442ab776949fdf1b2e1598" translate="yes" xml:space="preserve">
          <source>If one or both the members are missing, the command returns NULL.</source>
          <target state="translated">Если один или оба члена отсутствуют,команда возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="65c7882ecd3026e90538dbca3412ed2c9efa54bf" translate="yes" xml:space="preserve">
          <source>If one or more line in the file is not valid, nothing is loaded, and the old ACL rules defined in the server memory continue to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eccea0e4c99dbf5582f258e7eec112ee8e36e5c" translate="yes" xml:space="preserve">
          <source>If persistence is enabled this commands makes sure that Redis is switched off without the lost of any data. This is not guaranteed if the client uses simply &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; and then &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; because other clients may alter the DB data between the two commands.</source>
          <target state="translated">Если постоянство включено, эти команды гарантируют, что Redis выключен без потери каких-либо данных. Это не гарантируется, если клиент использует просто &lt;a href=&quot;save&quot;&gt;SAVE,&lt;/a&gt; а затем &lt;a href=&quot;quit&quot;&gt;QUIT,&lt;/a&gt; потому что другие клиенты могут изменять данные DB между двумя командами.</target>
        </trans-unit>
        <trans-unit id="3c4893d742c042232e8b2da1b66fa8109b95fc06" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; option is specified, the return value will be &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;:</source>
          <target state="translated">Если указана опция &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; , возвращаемое значение будет &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;массовым строковым ответом&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5342c7f917832f9f61b997cae89d595cc203017d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ABSTTL&lt;/code&gt; modifier was used, &lt;code&gt;ttl&lt;/code&gt; should represent an absolute &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix timestamp&lt;/a&gt; (in milliseconds) in which the key will expire. (Redis 5.0 or greater).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0a958c78e44fc13ec8f13707e023532ae594ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ABSTTL&lt;/code&gt; modifier was used, &lt;code&gt;ttl&lt;/code&gt; should represent an absolute &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix timestamp&lt;/a&gt; (in milliseconds) in which the key will expire. (Redis 5.0 or greater).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c94188363158a9ff98bf015f1ddfb2076ba94d" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;BLOCK&lt;/strong&gt; option is not used, the command is synchronous, and can be considered somewhat related to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;: it will return a range of items inside streams, however it has two fundamental differences compared to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; even if we just consider the synchronous usage:</source>
          <target state="translated">Если опция &lt;strong&gt;BLOCK&lt;/strong&gt; не используется, команда является синхронной и может считаться в некоторой степени связанной с &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; : она будет возвращать диапазон элементов внутри потоков, однако у нее есть два фундаментальных отличия от &lt;a href=&quot;xrange&quot;&gt;XRANGE,&lt;/a&gt; даже если мы просто рассматриваем синхронное использование:</target>
        </trans-unit>
        <trans-unit id="2a8ebc8cb8dd39729bf6fdaaa9469b8e9dd31c5f" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;FORCE&lt;/strong&gt; option is given, the replica does not perform any handshake with the master, that may be not reachable, but instead just starts a failover ASAP starting from point 4. This is useful when we want to start a manual failover while the master is no longer reachable.</source>
          <target state="translated">Если задана опция &lt;strong&gt;FORCE&lt;/strong&gt; , реплика не выполняет никакого установления связи с мастером, которое может быть недоступно, а вместо этого просто запускает аварийное переключение как можно скорее, начиная с точки 4. Это полезно, когда мы хотим запустить аварийное переключение вручную, пока мастер больше недоступен.</target>
        </trans-unit>
        <trans-unit id="41e165a8913dade3e9bd91924016ff8d6cab273f" translate="yes" xml:space="preserve">
          <source>If the AOF rewrite could start, but the attempt at starting it fails (for instance because of an error in creating the child process), an error is returned to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32dde384b66bbd79b525259d52aa9797e8b17bb3" translate="yes" xml:space="preserve">
          <source>If the Redis server is password protected via the &lt;code&gt;requirepass&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fded77f647c95a1a86355a7eafad08fd193bd854" translate="yes" xml:space="preserve">
          <source>If the above condition happens using a Redis 2.6 server or greater, Client &lt;strong&gt;A&lt;/strong&gt; will be served with the &lt;code&gt;c&lt;/code&gt; element, because after the &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; command the list contains &lt;code&gt;c,b,a&lt;/code&gt;, so taking an element from the left means to return &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Если указанное выше условие происходит с использованием сервера Redis 2.6 или выше, клиент &lt;strong&gt;A&lt;/strong&gt; будет обслуживаться с элементом &lt;code&gt;c&lt;/code&gt; , потому что после команды &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; список содержит &lt;code&gt;c,b,a&lt;/code&gt; , поэтому выбор элемента слева означает возврат &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc531ff7f9715b58415dfa6813dab3cc7b073afd" translate="yes" xml:space="preserve">
          <source>If the approximated cardinality estimated by the HyperLogLog changed after executing the command, &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; returns 1, otherwise 0 is returned. The command automatically creates an empty HyperLogLog structure (that is, a Redis String of a specified length and with a given encoding) if the specified key does not exist.</source>
          <target state="translated">Если приблизительное количество элементов, оцененное HyperLogLog, изменилось после выполнения команды, &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; возвращает 1, в противном случае возвращается 0. Команда автоматически создает пустую структуру HyperLogLog (то есть строку Redis указанной длины и с заданной кодировкой), если указанный ключ не существует.</target>
        </trans-unit>
        <trans-unit id="2a7df869ee4ed74778e5142a4cec6fc019c36dbe" translate="yes" xml:space="preserve">
          <source>If the client is subscribed to a channel or a pattern, it will instead return a multi-bulk with a &quot;pong&quot; in the first position and an empty bulk in the second position, unless an argument is provided in which case it returns a copy of the argument.</source>
          <target state="translated">Если клиент подписан на канал или шаблон,то вместо этого он вернет многоточечный с &quot;понгом&quot; в первой позиции и пустым объемом во второй,если только не указан аргумент,и в этом случае он вернет копию аргумента.</target>
        </trans-unit>
        <trans-unit id="1e3b4ecb886491d18a97620613800a70a1d78a2c" translate="yes" xml:space="preserve">
          <source>If the client tries to blocks for multiple keys, but at least one key contains elements, the returned key / element pair is the first key from left to right that has one or more elements. In this case the client is not blocked. So for instance &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt;, assuming that both &lt;code&gt;key2&lt;/code&gt; and &lt;code&gt;key4&lt;/code&gt; are non-empty, will always return an element from &lt;code&gt;key2&lt;/code&gt;.</source>
          <target state="translated">Если клиент пытается выполнить блокировку для нескольких ключей, но хотя бы один ключ содержит элементы, возвращенная пара ключ / элемент является первым ключом слева направо, который имеет один или несколько элементов. В этом случае клиент не заблокирован. Так, например, &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt; , предполагая, что и &lt;code&gt;key2&lt;/code&gt; , и &lt;code&gt;key4&lt;/code&gt; непустые, всегда будет возвращать элемент из &lt;code&gt;key2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4c4a551c5294109d275f4efb02ba586ea39cd4b" translate="yes" xml:space="preserve">
          <source>If the command contains multiple keys, in case none exist, the behavior is the same as point 2, if all exist, it is the same as point 1, however if only a partial number of keys exist, the command emits a &lt;code&gt;TRYAGAIN&lt;/code&gt; error in order for the keys interested to finish being migrated to the target node, so that the multi keys command can be executed.</source>
          <target state="translated">Если команда содержит несколько ключей, если ни один из них не существует, поведение такое же, как в пункте 2, если все существуют, то же самое, что и в пункте 1, однако, если существует только частичное количество ключей, команда выдает ошибку &lt;code&gt;TRYAGAIN&lt;/code&gt; в порядок завершения миграции заинтересованных ключей в целевой узел, чтобы можно было выполнить команду multi keys.</target>
        </trans-unit>
        <trans-unit id="b47c13f341545793a768bad91b706c8230117dd6" translate="yes" xml:space="preserve">
          <source>If the command is sent as part of a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; transaction, the command does not block but instead just return ASAP the number of replicas that acknowledged the previous write commands.</source>
          <target state="translated">Если команда отправляется как часть транзакции &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; , команда не блокируется, а вместо этого просто возвращает как можно скорее количество реплик, подтвердивших предыдущие команды записи.</target>
        </trans-unit>
        <trans-unit id="b2647b206316067e60c5c58ad3dabbd5311d10db" translate="yes" xml:space="preserve">
          <source>If the command is successful the new incremented value is stored as the new value of the key (replacing the old one), and returned to the caller as a string.</source>
          <target state="translated">При успешном выполнении команды новое инкрементированное значение сохраняется как новое значение ключа (заменяя старое)и возвращается вызывающему абоненту в виде строки.</target>
        </trans-unit>
        <trans-unit id="e13c77b4e4b0cd6a39fdb6c6dd3019929d6f047e" translate="yes" xml:space="preserve">
          <source>If the command succeeds the new replica will immediately try to contact its master in order to replicate from it.</source>
          <target state="translated">Если команда будет успешной,то новая реплика немедленно попытается связаться со своим мастером,чтобы реплицировать с него.</target>
        </trans-unit>
        <trans-unit id="58e50abae2f1a6949ff81b62d232f71c48c7e358" translate="yes" xml:space="preserve">
          <source>If the current hash slot owner is the node receiving the command, but for effect of the command the slot would be assigned to a different node, the command will return an error if there are still keys for that hash slot in the node receiving the command.</source>
          <target state="translated">Если текущий владелец хеш-слота является узлом,принимающим команду,но для выполнения команды слот будет назначен другому узлу,команда вернет ошибку,если в узле,принимающем команду,все еще есть ключи для этого хеш-слота.</target>
        </trans-unit>
        <trans-unit id="8bdc0729f7e8e3e8d69c4bf5f17ea02031eef1ea" translate="yes" xml:space="preserve">
          <source>If the destination variable exists, it is treated as one of the source sets and its cardinality will be included in the cardinality of the computed HyperLogLog.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16a9421e847dd28010cba3e62963f9099073a99" translate="yes" xml:space="preserve">
          <source>If the elements in the sorted set have different scores, the returned elements are unspecified.</source>
          <target state="translated">Если элементы в отсортированном наборе имеют разную оценку,возвращаемые элементы являются неуказанными.</target>
        </trans-unit>
        <trans-unit id="3481b2e7b6d800470df672a8874ad9a04f6afdca" translate="yes" xml:space="preserve">
          <source>If the instance is a replica, these additional fields are provided:</source>
          <target state="translated">Если экземпляр является копией,то предоставляются эти дополнительные поля:</target>
        </trans-unit>
        <trans-unit id="a39168a871f5b0b2ac68a8345a687deba4b95089" translate="yes" xml:space="preserve">
          <source>If the link between master and replica is down, an additional field is provided:</source>
          <target state="translated">Если связь между ведущим устройством и репликой нарушена,предоставляется дополнительное поле:</target>
        </trans-unit>
        <trans-unit id="5d43590cf68cfd82fc6f591b087a5f138a1a7c3f" translate="yes" xml:space="preserve">
          <source>If the message was never delivered to anyone, that is, if we are talking about a new message, then a PEL (Pending Entry List) is created.</source>
          <target state="translated">Если сообщение никому не было доставлено,то есть,если мы говорим о новом сообщении,то создается PEL (Pending Entry List).</target>
        </trans-unit>
        <trans-unit id="638ffe7f713cb2cff80e46aae12ead14d0ec33c3" translate="yes" xml:space="preserve">
          <source>If the node is a replica it is turned into an (empty) master. Its dataset is flushed, so at the end the node will be an empty master.</source>
          <target state="translated">Если узел является репликой,он превращается в (пустой)мастер.Его набор данных промывается,поэтому в конце узел становится пустым мастером.</target>
        </trans-unit>
        <trans-unit id="1785c288c16b021950b10d9d886a7eae6f023094" translate="yes" xml:space="preserve">
          <source>If the node receiving the command is not already a replica, but is a master, the command will only succeed, and the node will be converted into a replica, only if the following additional conditions are met:</source>
          <target state="translated">Если узел,получающий команду,еще не является репликой,а является ведущим,то команда будет успешной,и узел будет преобразован в реплику,только если будут выполнены следующие дополнительные условия:</target>
        </trans-unit>
        <trans-unit id="0d7f2602b57e25d3482f6de95a393b6a52d114e4" translate="yes" xml:space="preserve">
          <source>If the object you try to inspect is missing, a null bulk reply is returned.</source>
          <target state="translated">Если объект,который вы пытаетесь осмотреть,отсутствует,возвращается нулевой массовый ответ.</target>
        </trans-unit>
        <trans-unit id="502f345996f0414bbb8039bdf0ba7a24bdfc3f8f" translate="yes" xml:space="preserve">
          <source>If the password provided via AUTH matches the password in the configuration file, the server replies with the &lt;code&gt;OK&lt;/code&gt; status code and starts accepting commands. Otherwise, an error is returned and the clients needs to try a new password.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8069378ad909326b9b791fda111aafbf70922eb2" translate="yes" xml:space="preserve">
          <source>If the rules contain errors, the error is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8b33783f226cf240802124131a6b3112f200a2" translate="yes" xml:space="preserve">
          <source>If the script already called write commands the only allowed command becomes &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; that stops the server without saving the current data set on disk (basically the server is aborted).</source>
          <target state="translated">Если сценарий уже вызвал команды записи, единственной допустимой командой становится &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; , которая останавливает сервер без сохранения текущего набора данных на диске (в основном сервер прерывается).</target>
        </trans-unit>
        <trans-unit id="7d7312df2553f6628fdfae5411ba0776826d8dfb" translate="yes" xml:space="preserve">
          <source>If the script already performed write operations it can not be killed in this way because it would violate Lua script atomicity contract. In such a case only &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; is able to kill the script, killing the Redis process in an hard way preventing it to persist with half-written information.</source>
          <target state="translated">Если скрипт уже выполнял операции записи, его нельзя убить таким образом, потому что это нарушит контракт атомарности скрипта Lua. В таком случае только &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; может убить скрипт, жестко убивая процесс Redis, предотвращая его сохранение с наполовину записанной информацией.</target>
        </trans-unit>
        <trans-unit id="5aeedf1a85f8e143cfd4057ccfb92d5e01611feb" translate="yes" xml:space="preserve">
          <source>If the server does not remember a script with this SHA1 digest, a special error is returned telling the client to use &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; instead.</source>
          <target state="translated">Если сервер не помнит сценарий с этим дайджестом SHA1, возвращается специальная ошибка, в которой клиенту следует использовать &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c526024cc2b0adff52463eae82153b3e7035275" translate="yes" xml:space="preserve">
          <source>If the server is configured with the &lt;code&gt;min-slaves-to-write&lt;/code&gt; (or starting with Redis 5 with the &lt;code&gt;min-replicas-to-write&lt;/code&gt;) directive, an additional field is provided:</source>
          <target state="translated">Если сервер настроен с помощью директивы &lt;code&gt;min-slaves-to-write&lt;/code&gt; (или начиная с Redis 5 с помощью &lt;code&gt;min-replicas-to-write&lt;/code&gt; ), предоставляется дополнительное поле:</target>
        </trans-unit>
        <trans-unit id="160c785d0bbfa994844826d34af71d6ba78bcac0" translate="yes" xml:space="preserve">
          <source>If the server still remembers a script with a matching SHA1 digest, the script is executed.</source>
          <target state="translated">Если сервер все еще помнит скрипт с соответствующим SHA1 дайджестом,то скрипт выполняется.</target>
        </trans-unit>
        <trans-unit id="a73ff8adff60cf3faa9396c7d82031cce8e1eee5" translate="yes" xml:space="preserve">
          <source>If the slot is in &lt;em&gt;migrating&lt;/em&gt; state, the state gets cleared when the slot is assigned to another node.</source>
          <target state="translated">Если слот находится в состоянии &lt;em&gt;миграции&lt;/em&gt; , состояние очищается, когда слот назначается другому узлу.</target>
        </trans-unit>
        <trans-unit id="4fb7824817ed0173726151921ede13e72a5a9bcf" translate="yes" xml:space="preserve">
          <source>If the slot was in &lt;em&gt;importing&lt;/em&gt; state in the node receiving the command, and the command assigns the slot to this node (which happens in the target node at the end of the resharding of a hash slot from one node to another), the command has the following side effects: A) the &lt;em&gt;importing&lt;/em&gt; state is cleared. B) If the node config epoch is not already the greatest of the cluster, it generates a new one and assigns the new config epoch to itself. This way its new hash slot ownership will win over any past configuration created by previous failovers or slot migrations.</source>
          <target state="translated">Если слот находился в состоянии &lt;em&gt;импорта&lt;/em&gt; в узле, принимающем команду, и команда назначает слот этому узлу (что происходит в целевом узле в конце перешардинга хэш-слота от одного узла к другому), команда имеет следующие побочные эффекты: A) состояние &lt;em&gt;импорта&lt;/em&gt; очищено. B) Если эпоха конфигурации узла еще не является самой большой в кластере, она генерирует новую и назначает новую эпоху конфигурации себе. Таким образом, его новое владение хеш-слотом победит любую предыдущую конфигурацию, созданную предыдущими отработками отказа или миграциями слотов.</target>
        </trans-unit>
        <trans-unit id="e8cd47d9356aab972b5f2bd3e87e1b06b6cacf48" translate="yes" xml:space="preserve">
          <source>If the source set does not exist or does not contain the specified element, no operation is performed and &lt;code&gt;0&lt;/code&gt; is returned. Otherwise, the element is removed from the source set and added to the destination set. When the specified element already exists in the destination set, it is only removed from the source set.</source>
          <target state="translated">Если исходный набор не существует или не содержит указанный элемент, никакая операция не выполняется и возвращается &lt;code&gt;0&lt;/code&gt; . В противном случае элемент удаляется из исходного набора и добавляется в целевой набор. Если указанный элемент уже существует в целевом наборе, он удаляется только из исходного набора.</target>
        </trans-unit>
        <trans-unit id="3ca48297ca2c9df85be826386d88391801b54916" translate="yes" xml:space="preserve">
          <source>If the specified stream doesn't exist when creating a group, an error will be returned. You can use the optional &lt;code&gt;MKSTREAM&lt;/code&gt; subcommand as the last argument after the &lt;code&gt;ID&lt;/code&gt; to automatically create the stream, if it doesn't exist. Note that if the stream is created in this way it will have a length of 0:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a65b6aeeded425b23af7e95965a0f641dbdc37" translate="yes" xml:space="preserve">
          <source>If the user already exists, the provided ACL rules are simply applied &lt;em&gt;in addition&lt;/em&gt; to the rules already set. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da52acca0f5817a572a7d2dfec4d48663d8d1b71" translate="yes" xml:space="preserve">
          <source>If the user inserts all the elements in a sorted set with the same score (for example 0), all the elements of the sorted set are sorted lexicographically, and range queries on elements are possible using the command &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; (Note: it is also possible to query sorted sets by range of scores using &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;).</source>
          <target state="translated">Если пользователь вставляет все элементы в отсортированный набор с одинаковой оценкой (например, 0), все элементы отсортированного набора сортируются лексикографически, и запросы диапазона для элементов возможны с помощью команды &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; (Примечание: также возможно для запроса отсортированных наборов по диапазону оценок с помощью &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bb5f5ae1336c1db943d20a454954235747a6d64e" translate="yes" xml:space="preserve">
          <source>If the user will be idle more than 60 seconds, the key will be deleted and only subsequent page views that have less than 60 seconds of difference will be recorded.</source>
          <target state="translated">Если пользователь простаивает более 60 секунд,ключ будет удален,и будут записаны только последующие просмотры страниц с разницей менее 60 секунд.</target>
        </trans-unit>
        <trans-unit id="dca107e1698238aa60bfb450d46b8e949be6578e" translate="yes" xml:space="preserve">
          <source>If there are no keys to migrate in the source instance &lt;code&gt;NOKEY&lt;/code&gt; is returned. Because missing keys are possible in normal conditions, from expiry for example, &lt;code&gt;NOKEY&lt;/code&gt; isn't an error.</source>
          <target state="translated">Если в исходном экземпляре нет ключей для миграции, возвращается &lt;code&gt;NOKEY&lt;/code&gt; . Поскольку отсутствие ключей возможно в обычных условиях, например, по истечении срока действия, &lt;code&gt;NOKEY&lt;/code&gt; не является ошибкой.</target>
        </trans-unit>
        <trans-unit id="65645be10cc140f75bd2c8251142687f4fa78461" translate="yes" xml:space="preserve">
          <source>If we generate a configuration epoch which happens to collide with another instance, eventually our configuration epoch, or the one of another instance with our same epoch, will be moved away using the &lt;em&gt;configuration epoch collision resolution algorithm&lt;/em&gt;.</source>
          <target state="translated">Если мы генерируем эпоху конфигурации, которая сталкивается с другим экземпляром, в конечном итоге наша эпоха конфигурации или эпоха другого экземпляра с той же эпохой будет удалена с использованием &lt;em&gt;алгоритма разрешения конфликтов эпохи конфигурации&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b6f79d56180a9ad1d3aeb8220feacf255be61da4" translate="yes" xml:space="preserve">
          <source>If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1, the function returns the first bit not part of the string on the right. So if the string is three bytes set to the value &lt;code&gt;0xff&lt;/code&gt; the command &lt;code&gt;BITPOS key 0&lt;/code&gt; will return 24, since up to bit 23 all the bits are 1.</source>
          <target state="translated">Если мы ищем чистые биты (битовый аргумент равен 0), а строка содержит только бит, установленный в 1, функция возвращает первый бит, а не часть строки справа. Таким образом, если строка состоит из трех байтов, для которых установлено значение &lt;code&gt;0xff&lt;/code&gt; , команда &lt;code&gt;BITPOS key 0&lt;/code&gt; вернет 24, поскольку до бита 23 все биты равны 1.</target>
        </trans-unit>
        <trans-unit id="44b33ba5659f824ae39b000fc70d2cf7d6138c7b" translate="yes" xml:space="preserve">
          <source>If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is returned.</source>
          <target state="translated">Если мы ищем установленные биты (аргумент бит равен 1),а строка пуста или состоит только из нулевых байт,то возвращается -1.</target>
        </trans-unit>
        <trans-unit id="2012c008377fbb50737408462ade88dce859c2ba" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; or &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt;, there's no need to manually call &lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt;.</source>
          <target state="translated">Если вы вызываете &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; или &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; , нет необходимости вручную вызывать &lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7adf0ee2bf057d6e4f3261ad571f6a13a6962d80" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want all the clients to get all the messages, you do not need a consumer group.</source>
          <target state="translated">Если у вас есть поток и несколько клиентов,и вы хотите,чтобы все клиенты получали все сообщения,вам не нужна группа потребителей.</target>
        </trans-unit>
        <trans-unit id="7914b0ae2e05e8d2f74a0d7390601ab548d893de" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want the stream to be &lt;em&gt;partitioned&lt;/em&gt; or &lt;em&gt;sharded&lt;/em&gt; across your clients, so that each client will get a sub set of the messages arriving in a stream, you need a consumer group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="560057ad39d223339741232ee3fcc91b0feb1edf" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want the stream to be &lt;em&gt;partitioned&lt;/em&gt; or &lt;em&gt;shareded&lt;/em&gt; across your clients, so that each client will get a sub set of the messages arriving in a stream, you need a consumer group.</source>
          <target state="translated">Если у вас есть поток и несколько клиентов, и вы хотите, чтобы поток был &lt;em&gt;разделен&lt;/em&gt; или &lt;em&gt;совместно использовался&lt;/em&gt; вашими клиентами, чтобы каждый клиент получал подмножество сообщений, поступающих в поток, вам нужна группа потребителей.</target>
        </trans-unit>
        <trans-unit id="b31dd57013b909fbb7b7346c7faa280640e4841b" translate="yes" xml:space="preserve">
          <source>If you like science fiction, think of time flowing at infinite speed inside a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block...</source>
          <target state="translated">Если вам нравится научная фантастика, подумайте о времени, текущем с бесконечной скоростью внутри блока &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; ...</target>
        </trans-unit>
        <trans-unit id="c010cb9076ea01e47bb02d7ca64129ac264912a3" translate="yes" xml:space="preserve">
          <source>If you look for an &lt;code&gt;XGET&lt;/code&gt; command you'll be disappointed because &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; is effectively the way to go in order to fetch a single entry from a stream. All you have to do is to specify the ID two times in the arguments of XRANGE:</source>
          <target state="translated">Если вы &lt;code&gt;XGET&lt;/code&gt; команду XGET, вы будете разочарованы, потому что &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; - это эффективный способ получить одну запись из потока. Все, что вам нужно сделать, это указать идентификатор два раза в аргументах XRANGE:</target>
        </trans-unit>
        <trans-unit id="9b173c7e7e26659d2dc21433cf73d902805a206a" translate="yes" xml:space="preserve">
          <source>If you request details about non-existing commands, their return position will be nil.</source>
          <target state="translated">Если вы запросите информацию о несуществующих командах,их возвращаемая позиция будет равна нулю.</target>
        </trans-unit>
        <trans-unit id="12acfb0048a8a9bf03f38f7e388902128cc410f3" translate="yes" xml:space="preserve">
          <source>Imagine you have a web service and you are interested in the latest N pages &lt;em&gt;recently&lt;/em&gt; visited by your users, such that each adjacent page view was not performed more than 60 seconds after the previous. Conceptually you may consider this set of page views as a &lt;em&gt;Navigation session&lt;/em&gt; of your user, that may contain interesting information about what kind of products he or she is looking for currently, so that you can recommend related products.</source>
          <target state="translated">Представьте, что у вас есть веб-служба, и вас интересуют последние N страниц, которые &lt;em&gt;недавно&lt;/em&gt; посещали ваши пользователи, так что просмотр каждой соседней страницы не выполнялся более чем через 60 секунд после предыдущей. Концептуально вы можете рассматривать этот набор просмотров страниц как &lt;em&gt;сеанс навигации&lt;/em&gt; вашего пользователя, который может содержать интересную информацию о том, какие продукты он или она ищет в настоящее время, чтобы вы могли рекомендовать связанные продукты.</target>
        </trans-unit>
        <trans-unit id="3fb9a33bf9d1d9a11eb463de937edd8bbe41eff8" translate="yes" xml:space="preserve">
          <source>Imagine you have elements A, B and C with weights 1, 2 and 3. You compute the sum of the weights, which is 1+2+3 = 6</source>
          <target state="translated">Представьте,что у вас есть элементы A,B и C с весами 1,2 и 3.Вы вычисляете сумму весов,которая составляет 1+2+3=6.</target>
        </trans-unit>
        <trans-unit id="28adac3b6124834ed39c280b45702edaf27ac85d" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">Реализуйте &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">Детали внедрения</target>
        </trans-unit>
        <trans-unit id="11672e7162d8cdc131bd8b02c509dcb60a9d776d" translate="yes" xml:space="preserve">
          <source>Implementation details and notes</source>
          <target state="translated">Детали и примечания по осуществлению</target>
        </trans-unit>
        <trans-unit id="cc7649d9b862b15149646b67450f76a9d95f07c8" translate="yes" xml:space="preserve">
          <source>Implementation details: MEET and PING packets</source>
          <target state="translated">Детали реализации:Пакеты MEET и PING</target>
        </trans-unit>
        <trans-unit id="c5a3d437892d8fb38c145f676153ba0009f546b9" translate="yes" xml:space="preserve">
          <source>Important: &lt;strong&gt;there is no need to use the same COUNT value&lt;/strong&gt; for every iteration. The caller is free to change the count from one iteration to the other as required, as long as the cursor passed in the next call is the one obtained in the previous call to the command.</source>
          <target state="translated">Важно: &lt;strong&gt;нет необходимости использовать одно и то же значение COUNT&lt;/strong&gt; для каждой итерации. Вызывающий может изменять счетчик от одной итерации к другой по мере необходимости, пока курсор, переданный в следующем вызове, является курсором, полученным в предыдущем вызове команды.</target>
        </trans-unit>
        <trans-unit id="b6980584e557c93bab34f4259447d38dd3a9c928" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are emitted in the &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output as follows:</source>
          <target state="translated">Слоты импорта и миграции выводятся в выходных данных &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="50ac60eae9cbac9b1534be93c64ff4eb8e05e3df" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are provided as &lt;strong&gt;additional info&lt;/strong&gt;. If the node has a given hash slot assigned, it will be also a plain number in the list of hash slots, so clients that don't have a clue about hash slots migrations can just skip this special fields.</source>
          <target state="translated">Импорт и мигрирующие слотов предоставляются в качестве &lt;strong&gt;дополнительной информации&lt;/strong&gt; . Если узлу назначен данный хэш-слот, он также будет простым числом в списке хеш-слотов, поэтому клиенты, которые не имеют представления о миграции хэш-слотов, могут просто пропустить эти специальные поля.</target>
        </trans-unit>
        <trans-unit id="779e3f1f46c82af5ed6e618104fadfbd8c5eb506" translate="yes" xml:space="preserve">
          <source>In Cluster mode, both &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;newkey&lt;/code&gt; must be in the same &lt;strong&gt;hash slot&lt;/strong&gt;, meaning that in practice only keys that have the same hash tag can be reliably renamed in cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69ceca772f34d784aadd1c27595fdabe97b5262" translate="yes" xml:space="preserve">
          <source>In Redis 2.4 the expire might not be pin-point accurate, and it could be between zero to one seconds out.</source>
          <target state="translated">В Redis 2.4 срок годности может быть неточным,и может находиться в диапазоне от нуля до одной секунды.</target>
        </trans-unit>
        <trans-unit id="404f7b7c02b7867c0901ee21294f6e2f5fef0d3c" translate="yes" xml:space="preserve">
          <source>In Redis 2.6 or older the command returns &lt;code&gt;-1&lt;/code&gt; if the key does not exist or if the key exist but has no associated expire.</source>
          <target state="translated">В Redis 2.6 и старше команда возвращает &lt;code&gt;-1&lt;/code&gt; , если ключ не существует или если ключ существует, но не имеет связанного срока действия.</target>
        </trans-unit>
        <trans-unit id="8b69e0b775a7565070cf9c5f2db4bd807c015a5f" translate="yes" xml:space="preserve">
          <source>In Redis Cluster, each node keeps track of which master is serving a particular hash slot.</source>
          <target state="translated">В кластере Redis каждый узел отслеживает,какой мастер обслуживает определенный слот для хэша.</target>
        </trans-unit>
        <trans-unit id="d172f4fd77faed8def89fa030ed71bc01d833ea7" translate="yes" xml:space="preserve">
          <source>In Redis version 4, commands that may return elements in random order, like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (because Redis Sets are &lt;em&gt;unordered&lt;/em&gt;) have a different behavior when called from Lua, and undergo a silent lexicographical sorting filter before returning data to Lua scripts. So &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; will always return the Set elements in the same order, while the same command invoked from normal clients may return different results even if the key contains exactly the same elements. However starting with Redis 5 there is no longer such ordering step, because Redis 5 replicates scripts in a way that no longer needs non-deterministic commands to be converted into deterministic ones. In general, even when developing for Redis 4, never assume that certain commands in Lua will be ordered, but instead rely on the documentation of the original command you call to see the properties it provides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0bdbf698aa8eaf887d7877ad1c2d9ea20b7520a" translate="yes" xml:space="preserve">
          <source>In Redis versions prior &lt;strong&gt;2.1.3&lt;/strong&gt; altering a key with an expire set using a command altering its value had the effect of removing the key entirely. This semantics was needed because of limitations in the replication layer that are now fixed.</source>
          <target state="translated">В версиях Redis до &lt;strong&gt;2.1.3&lt;/strong&gt; изменение ключа с установленным сроком действия с помощью команды, изменяющей его значение, приводило к полному удалению ключа. Эта семантика была необходима из-за ограничений на уровне репликации, которые теперь исправлены.</target>
        </trans-unit>
        <trans-unit id="532b5a4c8c089bdea2a3dcd755e5c2d0a78f31ac" translate="yes" xml:space="preserve">
          <source>In a Redis Cluster clients can publish to every node. The cluster makes sure that published messages are forwarded as needed, so clients can subscribe to any channel by connecting to any one of the nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f272b3296928896a7fa9c51b4f28ffa23b9540" translate="yes" xml:space="preserve">
          <source>In future versions of Redis it is possible that we'll trigger a node garbage collection in case a given macro-node reaches a given amount of deleted entries. Currently with the usage we anticipate for this data structure, it is not a good idea to add such complexity.</source>
          <target state="translated">В будущих версиях Redis можно запускать сбор мусора узлов в случае,если заданный макрос-узел достигнет заданного количества удаленных записей.В настоящее время при использовании,которое мы ожидаем для этой структуры данных,не стоит добавлять такую сложность.</target>
        </trans-unit>
        <trans-unit id="420ffa2728e82649ac426218fc502611ceb5c012" translate="yes" xml:space="preserve">
          <source>In general what you should know is that setting the &lt;code&gt;appendonly&lt;/code&gt; parameter to &lt;code&gt;yes&lt;/code&gt; will start a background process to save the initial append-only file (obtained from the in memory data set), and will append all the subsequent commands on the append-only file, thus obtaining exactly the same effect of a Redis server that started with AOF turned on since the start.</source>
          <target state="translated">В общем, вы должны знать, что установка для параметра &lt;code&gt;appendonly&lt;/code&gt; значения &lt;code&gt;yes&lt;/code&gt; запустит фоновый процесс для сохранения исходного файла только для добавления (полученного из набора данных в памяти) и добавит все последующие команды в файл только для добавления , таким образом получая точно такой же эффект, как и на сервере Redis, который запускался с включенным с самого начала AOF.</target>
        </trans-unit>
        <trans-unit id="464e556758431df2768b0136fb61ecadb0a9af07" translate="yes" xml:space="preserve">
          <source>In its synchronous form, the command can get new data as long as there are more items available. However, at some point, we'll have to wait for producers of data to use &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; to push new entries inside the streams we are consuming. In order to avoid polling at a fixed or adaptive interval the command is able to block if it could not return any data, according to the specified streams and IDs, and automatically unblock once one of the requested keys accept data.</source>
          <target state="translated">В синхронной форме команда может получать новые данные, если доступно больше элементов. Однако в какой-то момент нам придется подождать, пока производители данных не будут использовать &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; для проталкивания новых записей в потоки, которые мы потребляем. Чтобы избежать опроса с фиксированным или адаптивным интервалом, команда может блокировать, если она не может вернуть какие-либо данные в соответствии с указанными потоками и идентификаторами, и автоматически разблокировать, как только один из запрошенных ключей примет данные.</target>
        </trans-unit>
        <trans-unit id="f71d43ee55e218973fa1e5cb6ebd10de6f4de1c3" translate="yes" xml:space="preserve">
          <source>In options where bytes or other quantities are specified, it is not possible to use the &lt;code&gt;redis.conf&lt;/code&gt; abbreviated form (&lt;code&gt;10k&lt;/code&gt;, &lt;code&gt;2gb&lt;/code&gt; ... and so forth), everything should be specified as a well-formed 64-bit integer, in the base unit of the configuration directive. However since Redis version 3.0 or greater, it is possible to use &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; with memory units for &lt;code&gt;maxmemory&lt;/code&gt;, client output buffers, and replication backlog size.</source>
          <target state="translated">В опциях, где указаны байты или другие количества, невозможно использовать сокращенную форму &lt;code&gt;redis.conf&lt;/code&gt; ( &lt;code&gt;10k&lt;/code&gt; , &lt;code&gt;2gb&lt;/code&gt; ... и т. Д.), Все должно быть указано как правильно сформированное 64-битное целое число в базовый блок директивы конфигурации. Однако, начиная с Redis версии 3.0 или выше, можно использовать &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; с модулями памяти для &lt;code&gt;maxmemory&lt;/code&gt; , клиентскими буферами вывода и размером невыполненного журнала репликации.</target>
        </trans-unit>
        <trans-unit id="a7b5d3135e15286cfdbe38c07d4aa01f9fe0988a" translate="yes" xml:space="preserve">
          <source>In order to authenticate the current connection with one of the connections defined in the ACL list (see &lt;a href=&quot;acl-setuser&quot;&gt;ACL SETUSER&lt;/a&gt;) and the official &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACL guide&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74befe185bf5845d0b7429c8d4ecaac4587e1561" translate="yes" xml:space="preserve">
          <source>In order to avoid these problems while avoiding the bandwidth penalty, Redis implements the &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; command.</source>
          <target state="translated">Чтобы избежать этих проблем, избегая &lt;a href=&quot;evalsha&quot;&gt;потери&lt;/a&gt; полосы пропускания, Redis реализует команду EVALSHA .</target>
        </trans-unit>
        <trans-unit id="4e60382da8db79c78bf47f321f4d7ec3aa869b88" translate="yes" xml:space="preserve">
          <source>In order to block, the &lt;strong&gt;BLOCK&lt;/strong&gt; option is used, together with the number of milliseconds we want to block before timing out. Normally Redis blocking commands take timeouts in seconds, however this command takes a millisecond timeout, even if normally the server will have a timeout resolution near to 0.1 seconds. This time it is possible to block for a shorter time in certain use cases, and if the server internals will improve over time, it is possible that the resolution of timeouts will improve.</source>
          <target state="translated">Для блокировки используется опция &lt;strong&gt;BLOCK&lt;/strong&gt; вместе с количеством миллисекунд, которое мы хотим заблокировать до истечения времени ожидания. Обычно команды блокировки Redis берут тайм-аут в секундах, однако эта команда занимает миллисекундный тайм-аут, даже если обычно сервер имеет разрешение тайм-аута около 0,1 секунды. На этот раз в определенных случаях использования можно заблокировать на более короткое время, и если внутреннее устройство сервера со временем улучшится, возможно, улучшится разрешение тайм-аутов.</target>
        </trans-unit>
        <trans-unit id="0040f93cb8c4b8bdab630ff12697ba1b0160ca64" translate="yes" xml:space="preserve">
          <source>In order to enable script effects replication, you need to issue the following Lua command before any write operated by the script:</source>
          <target state="translated">Для того,чтобы включить репликацию скриптовых эффектов,вам нужно выпустить следующую команду Lua перед любой записью,управляемой сценарием:</target>
        </trans-unit>
        <trans-unit id="013756f6d564f805aee9f75f0b5914a1c30d7b5d" translate="yes" xml:space="preserve">
          <source>In order to enable this form, the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; option is used, and the normal &lt;em&gt;key&lt;/em&gt; argument is set to an empty string. The actual key names will be provided after the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; argument itself, like in the following example:</source>
          <target state="translated">Чтобы включить эту форму, используется опция &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; , а в качестве аргумента обычного &lt;em&gt;ключа&lt;/em&gt; устанавливается пустая строка. Фактические имена ключей будут указаны после самого аргумента &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; , как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="ae1f75fb4769a06b17ea6f198ef59cd43ba00d55" translate="yes" xml:space="preserve">
          <source>In order to enable tracking, use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e7cf3fffb86f4198755cdccfe390f7daca4376b" translate="yes" xml:space="preserve">
          <source>In order to enforce this behavior in scripts Redis does the following:</source>
          <target state="translated">Для того,чтобы навязать такое поведение в скриптах,Redis делает следующее:</target>
        </trans-unit>
        <trans-unit id="4210ec3e973c5d5ac271cc1ab7ffcffaa3f2c4da" translate="yes" xml:space="preserve">
          <source>In order to fix a broken cluster where certain slots are unassigned.</source>
          <target state="translated">Для исправления сломанного кластера,в котором некоторые слоты не назначены.</target>
        </trans-unit>
        <trans-unit id="4708216948f38c6f376d2b00aef53c77bfc810bd" translate="yes" xml:space="preserve">
          <source>In order to iterate a stream, we can proceed as follows. Let's assume that we want two elements per iteration. We start fetching the first two elements, which is trivial:</source>
          <target state="translated">Для того,чтобы выполнить итерацию потока,мы можем действовать следующим образом.Предположим,что нам нужны два элемента на одну итерацию.Мы начнем извлекать первые два элемента,что тривиально:</target>
        </trans-unit>
        <trans-unit id="93f82278196654b93d4f14013ea15fe416b7d299" translate="yes" xml:space="preserve">
          <source>In order to make it a pure function, but still be sure that every invocation of the script will result in different random elements, we can simply add an additional argument to the script that will be used in order to seed the Lua pseudo-random number generator. The new script is as follows:</source>
          <target state="translated">Для того,чтобы сделать его чистой функции,но все же будьте уверены,что каждый вызов сценария приведет к различным случайным элементам,мы можем просто добавить дополнительный аргумент в сценарий,который будет использоваться для того,чтобы посеять Lua генератор псевдослучайных чисел.Новый сценарий выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="5e754dbb6b6073549994be57928409b8a9518fbf" translate="yes" xml:space="preserve">
          <source>In order to make sure the redis.conf file is always consistent, that is, on errors or crashes you always end with the old file, or the new one, the rewrite is performed with a single &lt;code&gt;write(2)&lt;/code&gt; call that has enough content to be at least as big as the old file. Sometimes additional padding in the form of comments is added in order to make sure the resulting file is big enough, and later the file gets truncated to remove the padding at the end.</source>
          <target state="translated">Чтобы файл redis.conf всегда был согласован, то есть при ошибках или сбоях вы всегда заканчиваете старый файл или новый, перезапись выполняется одним вызовом &lt;code&gt;write(2)&lt;/code&gt; который имеет достаточно содержимого. быть как минимум такого же размера, как старый файл. Иногда добавляется дополнительное заполнение в виде комментариев, чтобы убедиться, что полученный файл достаточно велик, а позже файл усекается, чтобы удалить заполнение в конце.</target>
        </trans-unit>
        <trans-unit id="45b71d9b591350682c94742bdef7ff99466f0e92" translate="yes" xml:space="preserve">
          <source>In order to make this locking algorithm more robust, a client holding a lock should always check the timeout didn't expire before unlocking the key with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; because client failures can be complex, not just crashing but also blocking a lot of time against some operations and trying to issue &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; after a lot of time (when the LOCK is already held by another client).</source>
          <target state="translated">Чтобы сделать этот алгоритм блокировки более надежным, клиент, удерживающий блокировку, всегда должен проверять, не истек ли тайм-аут, прежде чем разблокировать ключ с помощью &lt;a href=&quot;del&quot;&gt;DEL,&lt;/a&gt; потому что сбои клиента могут быть сложными, не только сбоями, но и блокировкой большого количества времени для некоторых операций и пытается выдать &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; через много времени (когда LOCK уже удерживается другим клиентом).</target>
        </trans-unit>
        <trans-unit id="26d3078f4ebbdf0701299addb5fed6bbed540a2c" translate="yes" xml:space="preserve">
          <source>In order to obtain a correct behavior without sacrificing consistency, when a key expires, a &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation is synthesized in both the AOF file and gains all the attached replicas nodes. This way the expiration process is centralized in the master instance, and there is no chance of consistency errors.</source>
          <target state="translated">Чтобы получить правильное поведение без ущерба для согласованности, когда срок действия ключа истекает, операция &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; синтезируется в файле AOF и получает все присоединенные узлы реплик. Таким образом, процесс истечения срока действия централизован в главном экземпляре, и нет никаких шансов на ошибки согласованности.</target>
        </trans-unit>
        <trans-unit id="a4d1c1dcdd2afe763b414a4824111916d472be49" translate="yes" xml:space="preserve">
          <source>In order to switch to RESP3 a script should call this function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40403839cd4ec5549ce4c8b0b88fe76bd596deee" translate="yes" xml:space="preserve">
          <source>In other words there is a one-to-one conversion between Lua and Redis types. The following table shows you all the conversions rules:</source>
          <target state="translated">Другими словами,между типами Lua и Redis существует преобразование один в один.В следующей таблице приведены все правила преобразования:</target>
        </trans-unit>
        <trans-unit id="b63d884600898ba55bb1960529b41996e05a6f02" translate="yes" xml:space="preserve">
          <source>In practical terms, Redis databases should be used to separate different keys belonging to the same application (if needed), and not to use a single Redis instance for multiple unrelated applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73283192b40f30e6bf23bca973e203da21ec7a06" translate="yes" xml:space="preserve">
          <source>In practical terms, Redis databases should mainly used in order to, if needed, separate different keys belonging to the same application, and not in order to use a single Redis instance for multiple unrelated applications.</source>
          <target state="translated">С практической точки зрения,базы данных Redis должны использоваться главным образом для того,чтобы,при необходимости,разделять различные ключи,принадлежащие одному и тому же приложению,а не для того,чтобы использовать один экземпляр Redis для нескольких несвязанных приложений.</target>
        </trans-unit>
        <trans-unit id="1cb1bb56f86e93948082da017865db052e971cd7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;COUNT&lt;/code&gt; option documentation, we state that sometimes this family of commands may return all the elements of a Set, Hash or Sorted Set at once in a single call, regardless of the &lt;code&gt;COUNT&lt;/code&gt; option value. The reason why this happens is that the cursor-based iterator can be implemented, and is useful, only when the aggregate data type that we are scanning is represented as an hash table. However Redis uses a &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;memory optimization&lt;/a&gt; where small aggregate data types, until they reach a given amount of items or a given max size of single elements, are represented using a compact single-allocation packed encoding. When this is the case, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has no meaningful cursor to return, and must iterate the whole data structure at once, so the only sane behavior it has is to return everything in a call.</source>
          <target state="translated">В документации опции &lt;code&gt;COUNT&lt;/code&gt; мы заявляем, что иногда это семейство команд может возвращать все элементы Set, Hash или Sorted Set одновременно за один вызов, независимо от значения опции &lt;code&gt;COUNT&lt;/code&gt; . Причина, по которой это происходит, заключается в том, что итератор на основе курсора может быть реализован и полезен только тогда, когда совокупный тип данных, который мы сканируем, представлен в виде хеш-таблицы. Однако Redis использует &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;оптимизацию памяти, при&lt;/a&gt; которой небольшие агрегированные типы данных, пока они не достигнут заданного количества элементов или заданного максимального размера отдельных элементов, представлены с использованием компактного упакованного кодирования с одним распределением. В этом случае &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; не имеет значимого курсора для возврата и должен перебирать всю структуру данных сразу, поэтому единственное разумное поведение, которое он имеет, - это возвращать все в вызове.</target>
        </trans-unit>
        <trans-unit id="8c0e05b70b67e4b92ac3373b78b09162115732be" translate="yes" xml:space="preserve">
          <source>In the above case the entry &lt;code&gt;1526985054069-0&lt;/code&gt; exists, otherwise the server would have sent us the next one. Using &lt;code&gt;COUNT&lt;/code&gt; is also the base in order to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; as an iterator.</source>
          <target state="translated">В приведенном выше случае существует запись &lt;code&gt;1526985054069-0&lt;/code&gt; , иначе сервер отправил бы нам следующий. Использование &lt;code&gt;COUNT&lt;/code&gt; также является основой для использования &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; в качестве итератора.</target>
        </trans-unit>
        <trans-unit id="f40be215733bf9374d8b827188eeddff85363cc0" translate="yes" xml:space="preserve">
          <source>In the above example of counting days, even after 10 years the application is online we still have just &lt;code&gt;365*10&lt;/code&gt; bits of data per user, that is just 456 bytes per user. With this amount of data &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; is still as fast as any other O(1) Redis command like &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; or &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;.</source>
          <target state="translated">В приведенном выше примере подсчета дней даже после 10 лет работы приложения в сети у нас все еще остается всего &lt;code&gt;365*10&lt;/code&gt; бит данных на пользователя, то есть всего 456 байт на пользователя. С таким объемом данных &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; по-прежнему работает так же быстро, как и любая другая команда O (1) Redis, например &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; или &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76a0365bc0972ed4321b2f354ddf621810b8b004" translate="yes" xml:space="preserve">
          <source>In the above example we claim the message with ID &lt;code&gt;1526569498055-0&lt;/code&gt;, only if the message is idle for at least one hour without the original consumer or some other consumer making progresses (acknowledging or claiming it), and assigns the ownership to the consumer &lt;code&gt;Alice&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере мы заявляем о сообщении с идентификатором &lt;code&gt;1526569498055-0&lt;/code&gt; , только если сообщение бездействует в течение как минимум одного часа, а исходный потребитель или какой-либо другой потребитель не выполняет никаких действий (подтверждая или заявляя его), и передаёт право владения потребителю &lt;code&gt;Alice&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bef89cf285951fc9b88c842b027336864d10794" translate="yes" xml:space="preserve">
          <source>In the above example you can see that the reported information are the number of elements of the stream, details about the radix tree representing the stream mostly useful for optimization and debugging tasks, the number of consumer groups associated with the stream, the last generated ID that may not be the same as the last entry ID in case some entry was deleted. Finally the full first and last entry in the stream are shown, in order to give some sense about what is the stream content.</source>
          <target state="translated">В приведенном выше примере видно,что сообщенная информация-это количество элементов потока,подробности о дереве радиксов,представляющем поток,наиболее полезном для задач оптимизации и отладки,количество групп потребителей,связанных с потоком,последний сгенерированный идентификатор,который может не совпадать с последним идентификатором записи в случае,если какая-то запись была удалена.Наконец,показывается полная первая и последняя запись в потоке,чтобы дать некоторое представление о том,что такое содержимое потока.</target>
        </trans-unit>
        <trans-unit id="5e1f5dbd04f5dc1db0a038c0d0e6f0ff4a4acd34" translate="yes" xml:space="preserve">
          <source>In the above locking algorithm there is a problem: what happens if a client fails, crashes, or is otherwise not able to release the lock? It's possible to detect this condition because the lock key contains a UNIX timestamp. If such a timestamp is equal to the current Unix time the lock is no longer valid.</source>
          <target state="translated">В описанном выше алгоритме блокировки возникает проблема:что произойдет,если клиент не справится,выйдет из строя или иным образом не сможет отпустить блокировку? Это условие можно обнаружить,так как ключ блокировки содержит временную метку UNIX.Если такая метка времени равна текущему Unix-времени,то замок больше недействителен.</target>
        </trans-unit>
        <trans-unit id="7063c49f04f76f5d83a38b2826e82b8706b19e78" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;, keys are every other position so the step value is 2. Compare with &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; above where the step value is just 1.</source>
          <target state="translated">В случае &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; ключи находятся в любой другой позиции, поэтому значение шага равно 2. Сравните с &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; выше, где значение шага равно 1.</target>
        </trans-unit>
        <trans-unit id="51cf6b9278dbdee20c8485961f1e557cd7119742" translate="yes" xml:space="preserve">
          <source>In the context of a node that has received a &lt;code&gt;DELSLOTS&lt;/code&gt; command and has consequently removed the associations for the passed hash slots, we say those hash slots are &lt;em&gt;unbound&lt;/em&gt;. Note that the existence of unbound hash slots occurs naturally when a node has not been configured to handle them (something that can be done with the &lt;code&gt;ADDSLOTS&lt;/code&gt; command) and if it has not received any information about who owns those hash slots (something that it can learn from heartbeat or update messages).</source>
          <target state="translated">В контексте узла , который получил &lt;code&gt;DELSLOTS&lt;/code&gt; команды и , следовательно , удаляются ассоциациями для пройденного хэша - слотов, мы говорим , эти хэш - слоты &lt;em&gt;несвязанные&lt;/em&gt; . Обратите внимание, что наличие несвязанных хэш-слотов возникает естественным образом, когда узел не настроен для их обработки (что можно сделать с &lt;code&gt;ADDSLOTS&lt;/code&gt; команды ADDSLOTS ) и если он не получил никакой информации о том, кому принадлежат эти хеш-слоты (что-то, что он может узнать из сообщений сердцебиения или обновления).</target>
        </trans-unit>
        <trans-unit id="0c3893e92cc9396f13c9f99b5e7ad611d2ac46c2" translate="yes" xml:space="preserve">
          <source>In the context of a stream consumer group, this command changes the ownership of a pending message, so that the new owner is the consumer specified as the command argument. Normally this is what happens:</source>
          <target state="translated">В контексте группы потребителей потока эта команда изменяет право собственности на ожидающее сообщение,так что новым владельцем является потребитель,указанный в качестве аргумента команды.Обычно так и происходит:</target>
        </trans-unit>
        <trans-unit id="57bf1b4701a5c94880ee6e46bfe56ac8c7000db8" translate="yes" xml:space="preserve">
          <source>In the example above, the first call uses zero as a cursor, to start the iteration. The second call uses the cursor returned by the previous call as the first element of the reply, that is, 17.</source>
          <target state="translated">В приведенном выше примере первый вызов использует ноль в качестве курсора,чтобы начать итерацию.При втором вызове в качестве первого элемента ответа используется курсор,возвращенный при предыдущем вызове,то есть 17.</target>
        </trans-unit>
        <trans-unit id="64f37e2cb3f5829eb3ba5c3a4f7f3eea2d872acc" translate="yes" xml:space="preserve">
          <source>In the extended form we no longer see the summary information, instead there are detailed information for each message in the pending entries list. For each message four attributes are returned:</source>
          <target state="translated">В расширенной форме мы больше не видим сводную информацию,вместо этого имеется подробная информация по каждому сообщению в списке ожидающих отправки записей.Для каждого сообщения возвращаются четыре атрибута:</target>
        </trans-unit>
        <trans-unit id="611f148b8dfb6f6978d2aeb35216b9ff55929cae" translate="yes" xml:space="preserve">
          <source>In the extended form we no longer see the summary information, instead there is detailed information for each message in the pending entries list. For each message four attributes are returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec3c889a89e0a9bff423ca26bc6e8f597b12b82" translate="yes" xml:space="preserve">
          <source>In the following example the first call to &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not use a timeout and asks for the write to reach 1 replica. It returns with success. In the second attempt instead we put a timeout, and ask for the replication of the write to two replicas. Since there is a single replica available, after one second &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; unblocks and returns 1, the number of replicas reached.</source>
          <target state="translated">В следующем примере первый вызов &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; не использует тайм-аут и требует, чтобы запись достигла 1 реплики. Он возвращается с успехом. Во второй попытке вместо этого мы устанавливаем тайм-аут и запрашиваем репликацию записи на две реплики. Поскольку доступна одна реплика, через одну секунду &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; разблокируется и возвращает 1, количество достигнутых реплик.</target>
        </trans-unit>
        <trans-unit id="8e23d6a61281506fa3e98f414bcf348728e15107" translate="yes" xml:space="preserve">
          <source>In the following example we can see how floats and arrays containing nils and keys are handled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275502ca7bb30b2b024cd13d4001c3a1615096d6" translate="yes" xml:space="preserve">
          <source>In the following example we can see how floats and arrays with nils are handled:</source>
          <target state="translated">В следующем примере мы видим,как обрабатываются поплавки и массивы с нулями:</target>
        </trans-unit>
        <trans-unit id="67aa25f5afe2285456ce925944008c892a8bde6a" translate="yes" xml:space="preserve">
          <source>In the following example we'll show why the command must not just remove a given node from the nodes table, but also prevent it for being re-inserted again for some time.</source>
          <target state="translated">В следующем примере мы покажем,почему команда должна не только удалить данный узел из таблицы узлов,но и предотвратить его повторное включение на некоторое время.</target>
        </trans-unit>
        <trans-unit id="1b27ba03d8db2c5155774200622adb0e3f3e2724" translate="yes" xml:space="preserve">
          <source>In the following example you can see how the encoding changes once Redis is no longer able to use the space saving encoding.</source>
          <target state="translated">В следующем примере видно,как меняется кодировка после того,как Redis больше не может использовать кодировку,экономящую место.</target>
        </trans-unit>
        <trans-unit id="d52481dfbaf58234ade345bdada825c509d89e9a" translate="yes" xml:space="preserve">
          <source>In the specific case of the implementation of &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;, Redis remembers, for each client, the replication offset of the produced replication stream when a given write command was executed in the context of a given client. When &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; is called Redis checks if the specified number of replicas already acknowledged this offset or a greater one.</source>
          <target state="translated">В конкретном случае реализации &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; Redis запоминает для каждого клиента смещение репликации созданного потока репликации, когда данная команда записи была выполнена в контексте данного клиента. Когда &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; вызывается, Redis проверяет, подтвердило ли указанное количество реплик это смещение или большее.</target>
        </trans-unit>
        <trans-unit id="903ead95cd2a4a5b9cbb852a8e750aedc79fee51" translate="yes" xml:space="preserve">
          <source>In this case, &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; will auto-complete the start interval with &lt;code&gt;-0&lt;/code&gt; and end interval with &lt;code&gt;-18446744073709551615&lt;/code&gt;, in order to return all the entries that were generated between a given millisecond and the end of the other specified millisecond. This also means that repeating the same millisecond two times, we get all the entries within such millisecond, because the sequence number range will be from zero to the maximum.</source>
          <target state="translated">В этом случае &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; автоматически завершит начальный интервал с помощью &lt;code&gt;-0&lt;/code&gt; и конечный интервал с помощью &lt;code&gt;-18446744073709551615&lt;/code&gt; , чтобы вернуть все записи, которые были сгенерированы между данной миллисекундой и концом другой указанной миллисекунды. Это также означает, что, повторяя одну и ту же миллисекунду два раза, мы получаем все записи в пределах этой миллисекунды, потому что диапазон порядковых номеров будет от нуля до максимума.</target>
        </trans-unit>
        <trans-unit id="9a9dd8640d5d9c354f3497144f8f471bfe5130bf" translate="yes" xml:space="preserve">
          <source>In this form the command returns general information about the stream stored at the specified key.</source>
          <target state="translated">В этой форме команда возвращает общую информацию о потоке,хранящемся на указанном ключе.</target>
        </trans-unit>
        <trans-unit id="fb6df0247f8ef1848f5f3284e1802dec98219082" translate="yes" xml:space="preserve">
          <source>In this form the command returns the entire state of the stream, including entries, groups, consumers and PELs. This form is available since Redis 6.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9dc316159e0ab75070b1301d7b7adb86e569cda" translate="yes" xml:space="preserve">
          <source>In this form we just get as output all the consumer groups associated with the stream:</source>
          <target state="translated">В этой форме мы просто получаем на выходе все группы потребителей,связанные с потоком:</target>
        </trans-unit>
        <trans-unit id="ddaa9f098110e2f5ed979aa965f072762268f6b4" translate="yes" xml:space="preserve">
          <source>In this form, the command outputs the total number of pending messages for this consumer group, which is one, followed by the smallest and greatest ID among the pending messages, and then list every consumer in the consumer group with at least one pending message, and the number of pending messages it has.</source>
          <target state="translated">В этой форме команда выводит общее количество ожидающих сообщений для этой группы потребителей,которое составляет одно,за которым следует наименьший и наибольший идентификатор среди ожидающих сообщений,а затем перечисляет каждого потребителя в группе потребителей с как минимум одним ожидающим сообщения,а также количество ожидающих сообщений,которое у него есть.</target>
        </trans-unit>
        <trans-unit id="7449f50cc271410bffecdb508cde8a6a6c5d9a68" translate="yes" xml:space="preserve">
          <source>In this particular case, running a single &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; client can reduce the throughput by more than 50%. Running more &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; clients will reduce throughput even more.</source>
          <target state="translated">В этом конкретном случае запуск одного клиента &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; может снизить пропускную способность более чем на 50%. Использование большего количества клиентов &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; еще больше снизит пропускную способность.</target>
        </trans-unit>
        <trans-unit id="9499b337b96eb666a58f2a5ab4a4329e2007a622" translate="yes" xml:space="preserve">
          <source>In this replication mode, while Lua scripts are executed, Redis collects all the commands executed by the Lua scripting engine that actually modify the dataset. When the script execution finishes, the sequence of commands that the script generated are wrapped into a MULTI / EXEC transaction and are sent to replicas and AOF.</source>
          <target state="translated">В этом режиме репликации,в то время как Lua скрипты выполняются,Redis собирает все команды,выполняемые Lua скриптовый движок,которые на самом деле изменить набор данных.Когда выполнение сценария заканчивается,последовательность команд,что сгенерированный сценарий обернуты в MULTI/EXEC сделки и отправляются на реплики и AOF.</target>
        </trans-unit>
        <trans-unit id="9c59d992fdad2d2103f7862e5997a95c45fa8f53" translate="yes" xml:space="preserve">
          <source>In this way the example consumer code will fetch only new messages, process them, and acknowledge them via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;. However the example code above is not complete, because it does not handle recovering after a crash. What will happen if we crash in the middle of processing messages, is that our messages will remain in the pending entries list, so we can access our history by giving &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; initially an ID of 0, and performing the same loop. Once providing an ID of 0 the reply is an empty set of messages, we know that we processed and acknowledged all the pending messages: we can start to use &lt;code&gt;&amp;gt;&lt;/code&gt; as ID, in order to get the new messages and rejoin the consumers that are processing new things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef44dcb3d65131c01d1f4f06af638521f8511b76" translate="yes" xml:space="preserve">
          <source>In this way the example consumer code will fetch only new messages, process them, and acknowledge them via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;. However the example code above is not complete, because it does not handle recovering after a crash. What will happen if we crash in the middle of processing messages, is that our messages will remain in the pending entries list, so we can access our history by giving &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; initially an ID of 0, and performing the same loop. Once providing and ID of 0 the reply is an empty set of messages, we know that we processed and acknowledged all the pending messages: we can start to use &lt;code&gt;&amp;gt;&lt;/code&gt; as ID, in order to get the new messages and rejoin the consumers that are processing new things.</source>
          <target state="translated">Таким образом, пример кода потребителя будет извлекать только новые сообщения, обрабатывать их и подтверждать их через &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; . Однако приведенный выше пример кода не является полным, потому что он не поддерживает восстановление после сбоя. Что произойдет, если мы выйдем из строя в середине обработки сообщений, так это то, что наши сообщения останутся в списке ожидающих записей, поэтому мы можем получить доступ к нашей истории, задав &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; изначально идентификатор 0 и выполнив тот же цикл. После предоставления и идентификатора 0 ответ представляет собой пустой набор сообщений, мы знаем, что мы обработали и подтвердили все ожидающие сообщения: мы можем начать использовать &lt;code&gt;&amp;gt;&lt;/code&gt; в качестве идентификатора, чтобы получить новые сообщения и повторно присоединиться к потребителям, которые обрабатывают новые вещи.</target>
        </trans-unit>
        <trans-unit id="0c6aff080ab580caca11c078c7c0fd0c074cc4b5" translate="yes" xml:space="preserve">
          <source>In this way when a node in migrating state generates an &lt;code&gt;ASK&lt;/code&gt; redirection, the client contacts the target node, sends &lt;code&gt;ASKING&lt;/code&gt;, and immediately after sends the command. This way commands about non-existing keys in the old node or keys already migrated to the target node are executed in the target node, so that:</source>
          <target state="translated">Таким образом, когда узел в состоянии миграции генерирует перенаправление &lt;code&gt;ASK&lt;/code&gt; , клиент связывается с целевым узлом, отправляет &lt;code&gt;ASKING&lt;/code&gt; и сразу после этого отправляет команду. Таким образом, команды для несуществующих ключей в старом узле или ключей, уже перенесенных на целевой узел, выполняются в целевом узле, так что:</target>
        </trans-unit>
        <trans-unit id="8a4976fd385ad81414ef5f0b5eb1d542ebee200c" translate="yes" xml:space="preserve">
          <source>Incomplete IDs</source>
          <target state="translated">Незавершенные документы</target>
        </trans-unit>
        <trans-unit id="d076531fdc3e2f8747b11778603627c7ff4c3c03" translate="yes" xml:space="preserve">
          <source>Increment the specified &lt;code&gt;field&lt;/code&gt; of a hash stored at &lt;code&gt;key&lt;/code&gt;, and representing a floating point number, by the specified &lt;code&gt;increment&lt;/code&gt;. If the increment value is negative, the result is to have the hash field value &lt;strong&gt;decremented&lt;/strong&gt; instead of incremented. If the field does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">Увеличивает указанное &lt;code&gt;field&lt;/code&gt; хэша, хранящегося в &lt;code&gt;key&lt;/code&gt; и представляющего число с плавающей запятой, на указанное &lt;code&gt;increment&lt;/code&gt; . Если значение приращения отрицательное, результатом будет &lt;strong&gt;уменьшение&lt;/strong&gt; значения хэш-поля вместо увеличения. Если поле не существует, перед выполнением операции ему присваивается значение &lt;code&gt;0&lt;/code&gt; . Ошибка возвращается, если возникает одно из следующих условий:</target>
        </trans-unit>
        <trans-unit id="0b2569a3073ebcb62549ecb7ec5a99e5e6f20a57" translate="yes" xml:space="preserve">
          <source>Increment the string representing a floating point number stored at &lt;code&gt;key&lt;/code&gt; by the specified &lt;code&gt;increment&lt;/code&gt;. By using a negative &lt;code&gt;increment&lt;/code&gt; value, the result is that the value stored at the key is decremented (by the obvious properties of addition). If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">Увеличивает строку, представляющую число с плавающей запятой, хранящееся в &lt;code&gt;key&lt;/code&gt; , на указанное &lt;code&gt;increment&lt;/code&gt; . Использование отрицательного значения &lt;code&gt;increment&lt;/code&gt; приводит к тому, что значение, хранящееся в ключе, уменьшается (в силу очевидных свойств сложения). Если ключ не существует, он устанавливается в &lt;code&gt;0&lt;/code&gt; перед выполнением операции. Ошибка возвращается, если возникает одно из следующих условий:</target>
        </trans-unit>
        <trans-unit id="b0ab00f78f69567a82e2e724fbf2c011708c66b2" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; does not exist the value is set to &lt;code&gt;0&lt;/code&gt; before the operation is performed.</source>
          <target state="translated">Приращивает номер , сохраненный в &lt;code&gt;field&lt;/code&gt; в хэш хранится в &lt;code&gt;key&lt;/code&gt; путем &lt;code&gt;increment&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; не существует, создается новый ключ, содержащий хеш. Если &lt;code&gt;field&lt;/code&gt; не существует, перед выполнением операции устанавливается значение &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05fa8f17b5cc5360627e65f0e1bfbcb74f909616" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">Увеличивает число, сохраненное в &lt;code&gt;key&lt;/code&gt; на &lt;code&gt;increment&lt;/code&gt; . Если ключ не существует, он устанавливается в &lt;code&gt;0&lt;/code&gt; перед выполнением операции. Ошибка возвращается, если ключ содержит значение неправильного типа или строку, которая не может быть представлена ​​как целое число. Эта операция ограничена 64-битными целыми числами со знаком.</target>
        </trans-unit>
        <trans-unit id="f9bd9898aaa3a2048914100ede9b89ccf7adc73a" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by one. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">Увеличивает число, хранящееся в &lt;code&gt;key&lt;/code&gt; на единицу. Если ключ не существует, он устанавливается в &lt;code&gt;0&lt;/code&gt; перед выполнением операции. Ошибка возвращается, если ключ содержит значение неправильного типа или строку, которая не может быть представлена ​​как целое число. Эта операция ограничена 64-битными целыми числами со знаком.</target>
        </trans-unit>
        <trans-unit id="b3b4497f3f9f641c1f07a98ba2294810e7c1c3a5" translate="yes" xml:space="preserve">
          <source>Increments the score of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, it is added with &lt;code&gt;increment&lt;/code&gt; as its score (as if its previous score was &lt;code&gt;0.0&lt;/code&gt;). If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified &lt;code&gt;member&lt;/code&gt; as its sole member is created.</source>
          <target state="translated">Увеличивает оценку &lt;code&gt;member&lt;/code&gt; в отсортированном наборе, хранящемся по &lt;code&gt;key&lt;/code&gt; на &lt;code&gt;increment&lt;/code&gt; . Если &lt;code&gt;member&lt;/code&gt; не существует в отсортированном наборе, он добавляется с &lt;code&gt;increment&lt;/code&gt; качестве его оценки (как если бы его предыдущая оценка была &lt;code&gt;0.0&lt;/code&gt; ). Если &lt;code&gt;key&lt;/code&gt; не существует, создается новый отсортированный набор с указанным &lt;code&gt;member&lt;/code&gt; качестве его единственного члена.</target>
        </trans-unit>
        <trans-unit id="b9e98de9b6972c3697024196bb1cf498f5df1583" translate="yes" xml:space="preserve">
          <source>Information about slots propagation and warnings</source>
          <target state="translated">Информация о распространении слотов и предупреждения</target>
        </trans-unit>
        <trans-unit id="2adcb9298d658f855997a0893baf52120d4879fe" translate="yes" xml:space="preserve">
          <source>Initiates a replication stream from the master.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df92aa3b0e06eb79bf7c8f7098db769523ac9333" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the head of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operations. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">Вставьте все указанные значения в начало списка, хранящегося в &lt;code&gt;key&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; не существует, он создается как пустой список перед выполнением операций push. Когда &lt;code&gt;key&lt;/code&gt; содержит значение, не являющееся списком, возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="d56f1eeeec0b6889ab12fc76a629d9cf4f377993" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operation. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">Вставьте все указанные значения в конец списка, хранящегося в &lt;code&gt;key&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; не существует, он создается как пустой список перед выполнением операции push. Когда &lt;code&gt;key&lt;/code&gt; содержит значение, не являющееся списком, возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="76405c7e5205b84962c7bcad1e955500c9c01bf2" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;element&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt; either before or after the reference value &lt;code&gt;pivot&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41914bb38b36cf790ad6dea5c850ff4f739bdf2f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the head of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">Вставляет &lt;code&gt;value&lt;/code&gt; в начало списка, хранящегося в &lt;code&gt;key&lt;/code&gt; , только если &lt;code&gt;key&lt;/code&gt; уже существует и содержит список. В отличие от &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; , если &lt;code&gt;key&lt;/code&gt; еще не существует , операции выполняться не будут.</target>
        </trans-unit>
        <trans-unit id="483c4cdd37e1303cef072b494af9c173f5ba1e3a" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">Вставляет &lt;code&gt;value&lt;/code&gt; в конец списка, хранящегося в &lt;code&gt;key&lt;/code&gt; , только если &lt;code&gt;key&lt;/code&gt; уже существует и содержит список. В отличие от &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; , если &lt;code&gt;key&lt;/code&gt; еще не существует , операции выполняться не будут.</target>
        </trans-unit>
        <trans-unit id="d817081530a979658954b262ec5b27debd913f6b" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt; either before or after the reference value &lt;code&gt;pivot&lt;/code&gt;.</source>
          <target state="translated">Вставки &lt;code&gt;value&lt;/code&gt; в списке хранится в &lt;code&gt;key&lt;/code&gt; либо до , либо после того, как опорное значение &lt;code&gt;pivot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5796a562198c08a1669595d2cc6b1a7851ecca7f" translate="yes" xml:space="preserve">
          <source>Inserts specified values at the head of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8b02564feb5003f96c3e70699d8d56ef9971fc" translate="yes" xml:space="preserve">
          <source>Inserts specified values at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2cd21b122572712ccbe21dcfb324c039d60a6f" translate="yes" xml:space="preserve">
          <source>Instead Redis 2.4 works in a different way: clients are served &lt;em&gt;in the context&lt;/em&gt; of the push operation, so as long as &lt;code&gt;LPUSH foo a b c&lt;/code&gt; starts pushing the first element to the list, it will be delivered to the Client &lt;strong&gt;A&lt;/strong&gt;, that will receive &lt;code&gt;a&lt;/code&gt; (the first element pushed).</source>
          <target state="translated">Вместо Redis 2.4 работает по-другому: клиенты обслуживаются &lt;em&gt;в контексте&lt;/em&gt; операции нажимной, так долго , как &lt;code&gt;LPUSH foo a b c&lt;/code&gt; начинает толкая первый элемент в список, то он будет доставлен Клиент &lt;strong&gt;A&lt;/strong&gt; , который будет получать ( первый нажатый элемент). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="895d5878b1e7aebe2b652bf4030490cc648a385d" translate="yes" xml:space="preserve">
          <source>Instead of releasing the lock with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;, send a script that only removes the key if the value matches.</source>
          <target state="translated">Вместо того, чтобы снимать блокировку с помощью &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; , отправьте сценарий, который удаляет ключ, только если значение совпадает.</target>
        </trans-unit>
        <trans-unit id="e1fb6600644f1089e2f02671b1d169470ef167d3" translate="yes" xml:space="preserve">
          <source>Instead of setting a fixed string, set a non-guessable large random string, called token.</source>
          <target state="translated">Вместо того,чтобы задавать фиксированную строку,установите не угадываемую большую случайную строку,называемую токеном.</target>
        </trans-unit>
        <trans-unit id="7e8138295a5156481cc0eb58921ff5f1b45d907b" translate="yes" xml:space="preserve">
          <source>Instead, if the lock is expired because the Unix time at &lt;code&gt;lock.foo&lt;/code&gt; is older than the current Unix time, C4 tries to perform:</source>
          <target state="translated">Вместо этого, если срок действия блокировки истек, потому что время Unix в &lt;code&gt;lock.foo&lt;/code&gt; старше текущего времени Unix, C4 пытается выполнить:</target>
        </trans-unit>
        <trans-unit id="9e41d77e11789212e3a04485592bea0019722472" translate="yes" xml:space="preserve">
          <source>Instruct Redis to start an &lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;Append Only File&lt;/a&gt; rewrite process. The rewrite will create a small optimized version of the current Append Only File.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;Дайте&lt;/a&gt; указание Redis запустить процесс перезаписи файла только для добавления . Перезапись создаст небольшую оптимизированную версию текущего файла только для добавления.</target>
        </trans-unit>
        <trans-unit id="5d3a484e0575c563f1fd55a805b93fd40c42e60d" translate="yes" xml:space="preserve">
          <source>Integer reply</source>
          <target state="translated">Целочисленный ответ</target>
        </trans-unit>
        <trans-unit id="b78aed63c34c1be3f06c6bc59978ffe5ffe055ac" translate="yes" xml:space="preserve">
          <source>Introduction to EVAL</source>
          <target state="translated">Введение в EVAL</target>
        </trans-unit>
        <trans-unit id="698c191721344bee0279a531fba2023586cfe9e4" translate="yes" xml:space="preserve">
          <source>It can also take the following values:</source>
          <target state="translated">Он также может принимать следующие значения:</target>
        </trans-unit>
        <trans-unit id="35178e7f69534d7802151005b608f5f33b33d650" translate="yes" xml:space="preserve">
          <source>It contains a 64-bit checksum that is used to make sure errors will be detected. The &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command makes sure to check the checksum before synthesizing a key using the serialized value.</source>
          <target state="translated">Он содержит 64-битную контрольную сумму, которая используется для обнаружения ошибок. Команда &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; проверяет контрольную сумму перед синтезом ключа с использованием сериализованного значения.</target>
        </trans-unit>
        <trans-unit id="d3cca1eb042dc5b5456d254387aa0bc9411f0e98" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;very important&lt;/strong&gt; to understand that you should use the &lt;code&gt;$&lt;/code&gt; ID only for the first call to &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;. Later the ID should be the one of the last reported item in the stream, otherwise you could miss all the entries that are added in between.</source>
          <target state="translated">Это &lt;strong&gt;очень важно&lt;/strong&gt; понять , что вы должны использовать &lt;code&gt;$&lt;/code&gt; ID только для первого вызова &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; . Позже идентификатор должен быть одним из последних отправленных сообщений в потоке, иначе вы можете пропустить все записи, добавленные между ними.</target>
        </trans-unit>
        <trans-unit id="80e58a0abe147b5052a4b292609ed6e990761a9f" translate="yes" xml:space="preserve">
          <source>It is also possible to &lt;code&gt;GET&lt;/code&gt; the element itself using the special pattern &lt;code&gt;#&lt;/code&gt;:</source>
          <target state="translated">Также возможно &lt;code&gt;GET&lt;/code&gt; сам элемент, используя специальный шаблон &lt;code&gt;#&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="98ad7fac6612120c355f6682c4b1a531c848bd30" translate="yes" xml:space="preserve">
          <source>It is also possible to compute the LCS between the content of two keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33a1c4c42a6d6feaa0bef4f81f6ace9278b22e9" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; and &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; string commands to efficiently access a range of bit offsets in a bitmap. Below is a sample implementation in idiomatic Redis Lua scripting that can be run with the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344f6904cadbf67817bc580b98a14096a5ecb81b" translate="yes" xml:space="preserve">
          <source>It is important to note that step 3 is the only time when a Redis Cluster node will create a new config epoch without agreement from other nodes. This only happens when a manual configuration is operated. However it is impossible that this creates a non-transient setup where two nodes have the same config epoch, since Redis Cluster uses a config epoch collision resolution algorithm.</source>
          <target state="translated">Важно отметить,что шаг 3-это единственное время,когда узел кластера Redis Cluster создаст новую эпоху конфигурации без согласования с другими узлами.Это происходит только при ручной настройке.Однако невозможно,чтобы это создало непереходящую установку,где два узла имеют одну и ту же эпоху конфигурирования,так как Redis Cluster использует алгоритм разрешения столкновений конфиговой эпохи.</target>
        </trans-unit>
        <trans-unit id="75e2007346bb90c5a30dbb62b43b72fa8d6f2346" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;strong&gt;MATCH&lt;/strong&gt; filter is applied after elements are retrieved from the collection, just before returning data to the client. This means that if the pattern matches very little elements inside the collection, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; will likely return no elements in most iterations. An example is shown below:</source>
          <target state="translated">Важно отметить, что фильтр &lt;strong&gt;MATCH&lt;/strong&gt; применяется после извлечения элементов из коллекции, непосредственно перед возвратом данных клиенту. Это означает, что если шаблон соответствует очень маленьким элементам внутри коллекции, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; , скорее всего, не вернет никаких элементов в большинстве итераций. Пример показан ниже:</target>
        </trans-unit>
        <trans-unit id="05004148ae7826284b52ac4960264eb06c78f9cd" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;strong&gt;TYPE&lt;/strong&gt; filter is also applied after elements are retrieved from the database, so the option does not reduce the amount of work the server has to do to complete a full iteration, and for rare types you may receive no elements in many iterations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a489978b872ba9db6fad974b8d4112fa3f8ddea" translate="yes" xml:space="preserve">
          <source>It is important to understand that this command &lt;em&gt;fans out&lt;/em&gt; to all the clients that are waiting for the same range of IDs, so every consumer will get a copy of the data, unlike to what happens when blocking list pop operations are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6bd66f1e8688cc2dae7b39af1276712b3930256" translate="yes" xml:space="preserve">
          <source>It is important to understand that this command is &lt;em&gt;fans out&lt;/em&gt; to all the clients that are waiting for the same range of IDs, so every consumer will get a copy of the data, unlike to what happens when blocking list pop operations are used.</source>
          <target state="translated">Важно понимать, что эта команда &lt;em&gt;распространяется&lt;/em&gt; для всех клиентов, ожидающих одного и того же диапазона идентификаторов, поэтому каждый потребитель получит копию данных, в отличие от того, что происходит при использовании всплывающих операций списка блокировки.</target>
        </trans-unit>
        <trans-unit id="c855a69b0dba328dc98ac3bd3b714e220d6e64d4" translate="yes" xml:space="preserve">
          <source>It is never repeated, so if &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; returns the same number, the caller can be sure that the underlying client did not disconnect and reconnect the connection, but it is still the same connection.</source>
          <target state="translated">Он никогда не повторяется, поэтому, если &lt;a href=&quot;client-id&quot;&gt;ИД КЛИЕНТА&lt;/a&gt; возвращает тот же номер, вызывающий может быть уверен, что базовый клиент не отключил и не подключил повторно соединение, но это все равно то же соединение.</target>
        </trans-unit>
        <trans-unit id="18c6232a5064b912687168695e794e952ea903ef" translate="yes" xml:space="preserve">
          <source>It is not possible for the key to get lost in the event of a timeout, but the client calling &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;, in the event of a timeout error, should check if the key is &lt;em&gt;also&lt;/em&gt; present in the target instance and act accordingly.</source>
          <target state="translated">Невозможно потерять ключ в случае тайм-аута, но клиент, вызывающий &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; , в случае ошибки тайм-аута должен проверить, присутствует ли ключ &lt;em&gt;также&lt;/em&gt; в целевом экземпляре, и действовать соответственно.</target>
        </trans-unit>
        <trans-unit id="7a383107db035b97cc0f3e4c5c6844b9b02c255f" translate="yes" xml:space="preserve">
          <source>It is possible for an infinite number of clients to iterate the same collection at the same time, as the full state of the iterator is in the cursor, that is obtained and returned to the client at every call. Server side no state is taken at all.</source>
          <target state="translated">Возможно,что бесконечное количество клиентов может итерировать одну и ту же коллекцию одновременно,так как полное состояние итератора находится в курсоре,который получается и возвращается клиенту при каждом вызове.Со стороны сервера состояние не принимается вообще.</target>
        </trans-unit>
        <trans-unit id="a485e395caaea14094a0b8ec68e5e3e0a8915e73" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; using as argument a key that already has an existing expire set. In this case the time to live of a key is &lt;em&gt;updated&lt;/em&gt; to the new value. There are many useful applications for this, an example is documented in the &lt;em&gt;Navigation session&lt;/em&gt; pattern section below.</source>
          <target state="translated">Можно вызвать &lt;a href=&quot;expire&quot;&gt;EXPIRE,&lt;/a&gt; используя в качестве аргумента ключ, для которого уже установлен срок действия. В этом случае время жизни ключа &lt;em&gt;обновляется&lt;/em&gt; до нового значения. Для этого существует множество полезных приложений, пример которых задокументирован в разделе &amp;laquo; Шаблон &lt;em&gt;сеанса навигации&lt;/em&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="a7f5fb81c26b1abadccf00465e65f7fa65dea140" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; inside Lua scripts like with normal clients, However one subtle aspect of the behavior changes between Redis 2.8.11 and Redis 2.8.12. Before the 2.8.12 release the database selected by the Lua script was &lt;em&gt;transferred&lt;/em&gt; to the calling script as current database. Starting from Redis 2.8.12 the database selected by the Lua script only affects the execution of the script itself, but does not modify the database selected by the client calling the script.</source>
          <target state="translated">Можно вызвать &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; внутри сценариев Lua, как и в случае с обычными клиентами, однако один тонкий аспект поведения меняется между Redis 2.8.11 и Redis 2.8.12. До выпуска 2.8.12 база данных, выбранная сценарием Lua, &lt;em&gt;передавалась&lt;/em&gt; вызывающему сценарию в качестве текущей базы данных. Начиная с Redis 2.8.12, база данных, выбранная сценарием Lua, влияет только на выполнение самого сценария, но не изменяет базу данных, выбранную клиентом, вызывающим сценарий.</target>
        </trans-unit>
        <trans-unit id="0958a04d7552830b3684f48a6c436807896935c0" translate="yes" xml:space="preserve">
          <source>It is possible to call Redis commands from a Lua script using two different Lua functions:</source>
          <target state="translated">Можно вызывать команды Redis из скрипта Lua,используя две различные функции Lua:</target>
        </trans-unit>
        <trans-unit id="b0a209f43840d7a1f6f04e02663cf8a792cab884" translate="yes" xml:space="preserve">
          <source>It is possible to entirely remove the connection name setting it to the empty string, that is not a valid connection name since it serves to this specific purpose.</source>
          <target state="translated">Можно полностью удалить имя соединения,установив его в пустую строку,что не является действительным именем соединения,так как оно служит именно этой цели.</target>
        </trans-unit>
        <trans-unit id="db23050fd5ba19a3417f8b624df748886d949634" translate="yes" xml:space="preserve">
          <source>It is possible to get just the length of the slow log using the command &lt;strong&gt;SLOWLOG LEN&lt;/strong&gt;.</source>
          <target state="translated">Можно получить только длину медленного журнала, используя команду &lt;strong&gt;SLOWLOG LEN&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="db19130f0bd00fca33ef9a77ffc0a1ce2466b31d" translate="yes" xml:space="preserve">
          <source>It is possible to give the command in the following special form in order to make it more efficient:</source>
          <target state="translated">Чтобы сделать команду более эффективной,можно дать команду в следующей специальной форме:</target>
        </trans-unit>
        <trans-unit id="e24f1bfbfced0e2fc3e90a67dd138360e0226aa2" translate="yes" xml:space="preserve">
          <source>It is possible to limit the size of the stream to a maximum number of elements using the &lt;strong&gt;MAXLEN&lt;/strong&gt; option.</source>
          <target state="translated">Можно ограничить размер потока максимальным количеством элементов с &lt;strong&gt;помощью&lt;/strong&gt; опции &lt;strong&gt;MAXLEN&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="712b25407c86c3da9193a8517aa1f28826626087" translate="yes" xml:space="preserve">
          <source>It is possible to limit the size of the stream to a maximum number of elements using the &lt;strong&gt;MAXLEN&lt;/strong&gt; option. By default, or when used with the &lt;code&gt;=&lt;/code&gt; argument, the &lt;strong&gt;MAXLEN&lt;/strong&gt; option performs an exact trimming. That means that the trimmed stream's length will be exactly the minimum between its original length and the specified maximum length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2ff105ab5c2c719dd08acac18181138935047b" translate="yes" xml:space="preserve">
          <source>It is possible to make this system more robust modifying the unlock schema as follows:</source>
          <target state="translated">Можно сделать эту систему более надежной,модифицируя схему разблокировки следующим образом:</target>
        </trans-unit>
        <trans-unit id="493e108b328a9e96e14d97d5ac7db908da18cbb1" translate="yes" xml:space="preserve">
          <source>It is possible to modify the maximum time a script can be executed with millisecond precision, either via &lt;code&gt;redis.conf&lt;/code&gt; or using the CONFIG GET / CONFIG SET command. The configuration parameter affecting max execution time is called &lt;code&gt;lua-time-limit&lt;/code&gt;.</source>
          <target state="translated">Можно изменить максимальное время, в течение которого сценарий может выполняться с точностью до миллисекунды, либо через &lt;code&gt;redis.conf&lt;/code&gt; , либо с помощью команды CONFIG GET / CONFIG SET. Параметр конфигурации, влияющий на максимальное время выполнения, называется &lt;code&gt;lua-time-limit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16570d1ed8c0ba499d85c4796bacd5587bfbf468" translate="yes" xml:space="preserve">
          <source>It is possible to only iterate elements matching a given glob-style pattern, similarly to the behavior of the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; command that takes a pattern as only argument.</source>
          <target state="translated">Можно перебирать только элементы, соответствующие заданному шаблону стиля глобуса, аналогично поведению команды &lt;a href=&quot;keys&quot;&gt;KEYS,&lt;/a&gt; которая принимает шаблон как единственный аргумент.</target>
        </trans-unit>
        <trans-unit id="1b6a2609bc05ff6f008c837f6095456b47106ecb" translate="yes" xml:space="preserve">
          <source>It is possible to pass an additional argument to the command, in order to see the messages having a specific owner:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c90a5608f4fab2983bbd179b23cb40526ff6f3e" translate="yes" xml:space="preserve">
          <source>It is possible to pass the &lt;code&gt;WITHSCORES&lt;/code&gt; option in order to return the scores of the elements together with the elements. The returned list will contain &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; instead of &lt;code&gt;value1,...,valueN&lt;/code&gt;. Client libraries are free to return a more appropriate data type (suggestion: an array with (value, score) arrays/tuples).</source>
          <target state="translated">Можно передать опцию &lt;code&gt;WITHSCORES&lt;/code&gt; , чтобы возвращать оценки элементов вместе с элементами. &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; список будет содержать значение1, счет1, ..., значениеN, счетN вместо значения1 &lt;code&gt;value1,...,valueN&lt;/code&gt; . Клиентские библиотеки могут возвращать более подходящий тип данных (предложение: массив с массивами / кортежами (значение, оценка)).</target>
        </trans-unit>
        <trans-unit id="5fd91c3878c3497da37709cc86d8056d11e4d945" translate="yes" xml:space="preserve">
          <source>It is possible to provide multiple filters at the same time. The command will handle multiple filters via logical AND. For example:</source>
          <target state="translated">Возможно предоставление нескольких фильтров одновременно.Команда будет обрабатывать несколько фильтров с помощью логического AND.Например:</target>
        </trans-unit>
        <trans-unit id="1c3121b308c1fd1777b057f001ac070f1a4f6932" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;c&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;a&lt;/code&gt; as third element.</source>
          <target state="translated">Можно протолкнуть несколько элементов с помощью одного вызова команды, просто указав несколько аргументов в конце команды. Элементы вставляются один за другим в заголовок списка, от крайнего левого элемента до крайнего правого. Так, например, команда &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; приведет к созданию списка, содержащего &lt;code&gt;c&lt;/code&gt; как первый элемент, &lt;code&gt;b&lt;/code&gt; как второй элемент и &lt;code&gt;a&lt;/code&gt; как третий элемент.</target>
        </trans-unit>
        <trans-unit id="f7c76d9bc80fdf12c410c3b35eb8ad68df167802" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;a&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;c&lt;/code&gt; as third element.</source>
          <target state="translated">Можно протолкнуть несколько элементов с помощью одного вызова команды, просто указав несколько аргументов в конце команды. Элементы вставляются один за другим в конец списка, от крайнего левого элемента до крайнего правого элемента. Так, например, команда &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; приведет к созданию списка, содержащего &lt;code&gt;a&lt;/code&gt; как первый элемент, &lt;code&gt;b&lt;/code&gt; как второй элемент и &lt;code&gt;c&lt;/code&gt; как третий элемент.</target>
        </trans-unit>
        <trans-unit id="6156ba53b9a2d5fcb6563a933eb7f9a8915352ac" translate="yes" xml:space="preserve">
          <source>It is possible to reset only specific events by providing the &lt;code&gt;event&lt;/code&gt; names as arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b01178931bb71c8630b481c710157203df1e465" translate="yes" xml:space="preserve">
          <source>It is possible to send &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; in a MULTI/EXEC block together with the &lt;code&gt;INFO replication&lt;/code&gt; command in order to get the current master offset at the time the clients are blocked. This way it is possible to wait for a specific offset in the replica side in order to make sure all the replication stream was processed.</source>
          <target state="translated">Можно отправить &lt;a href=&quot;client-pause&quot;&gt;ПАУЗУ КЛИЕНТА&lt;/a&gt; в блоке MULTI / EXEC вместе с командой &lt;code&gt;INFO replication&lt;/code&gt; , чтобы получить текущее смещение мастера на момент блокировки клиентов. Таким образом, можно дождаться определенного смещения на стороне реплики, чтобы убедиться, что весь поток репликации был обработан.</target>
        </trans-unit>
        <trans-unit id="0ec5055f100665a2489124e5d7125126bd09824c" translate="yes" xml:space="preserve">
          <source>It is possible to specify an optional modifier to alter the behavior of the command. Specifically:</source>
          <target state="translated">Можно указать опциональный модификатор для изменения поведения команды.В частности:</target>
        </trans-unit>
        <trans-unit id="45f8f96397f97e0b1f0e90886760fbff08204ef1" translate="yes" xml:space="preserve">
          <source>It is possible to switch persistence from RDB snapshotting to append-only file (and the other way around) using the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command. For more information about how to do that please check the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence page&lt;/a&gt;.</source>
          <target state="translated">Можно переключить сохраняемость с моментального снимка RDB на файл только для добавления (и наоборот) с помощью команды &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; . Для получения дополнительной информации о том, как это сделать, посетите &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;страницу сохранения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2a6138f902bc8b4bcfbc90caefbe979c90132a" translate="yes" xml:space="preserve">
          <source>It is possible to terminate a script that executes only read-only commands using the &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; command. This does not violate the scripting semantic as no data was yet written to the dataset by the script.</source>
          <target state="translated">Можно завершить сценарий, выполняющий только команды только для чтения, с помощью команды &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; . Это не нарушает семантику сценария, поскольку сценарий еще не записал данные в набор данных.</target>
        </trans-unit>
        <trans-unit id="e71c9ce4c62f0cde3cb804acf308d1e98fe95b09" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; and &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; together at every page view to have a counter counting only the latest N page views separated by less than the specified amount of seconds.</source>
          <target state="translated">Можно использовать &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; и &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; вместе при каждом просмотре страницы, чтобы счетчик подсчитывал только последние N просмотров страниц, разделенных меньшим, чем указанное количество секунд.</target>
        </trans-unit>
        <trans-unit id="2dd681e578f9014910b8ac5ae0c3612f0ad14944" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;BY&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; options against hash fields with the following syntax:</source>
          <target state="translated">Можно использовать параметры &lt;code&gt;BY&lt;/code&gt; и &lt;code&gt;GET&lt;/code&gt; для хэш-полей со следующим синтаксисом:</target>
        </trans-unit>
        <trans-unit id="b7c843f5e285c955a784fb3560240c16b6f9efa9" translate="yes" xml:space="preserve">
          <source>It is possible to use them in &lt;code&gt;geohash.org&lt;/code&gt; URLs such as &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt;. This is an &lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;example of such URL&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;geohash.org&lt;/code&gt; можно использовать в URL-адресах geohash.org, например &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt; . Это &lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;пример такого URL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b30cb831388a0a49ee8acf0fd13e74a7abc3ab8f" translate="yes" xml:space="preserve">
          <source>It is possible to write to the Redis log file from Lua scripts using the &lt;code&gt;redis.log&lt;/code&gt; function.</source>
          <target state="translated">Можно записывать в файл журнала Redis из скриптов Lua с &lt;code&gt;redis.log&lt;/code&gt; функции redis.log .</target>
        </trans-unit>
        <trans-unit id="dee99c37f02de301ed26c2711bf105931901e4b7" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the highest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">Это блокирующая версия,потому что она блокирует соединение,когда нет членов,чтобы всплыть из любого из данных отсортированных множеств.Член с наибольшим количеством баллов выпадает из первого отсортированного набора,который не является пустым,при этом данные ключи проверяются в том порядке,в котором они были даны.</target>
        </trans-unit>
        <trans-unit id="b7063c25aabd8a7e88f52a969b68eec3fd17473b" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the lowest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">Это блокирующая версия,потому что она блокирует соединение,когда нет членов,чтобы всплыть из любого из данных отсортированных множеств.Член с наименьшим количеством баллов выпадает из первого отсортированного множества,которое не является пустым,при этом данные ключи проверяются в том порядке,в котором они были даны.</target>
        </trans-unit>
        <trans-unit id="164013c6ace79ff08b57e9e952d3d8fc12045787" translate="yes" xml:space="preserve">
          <source>It just assumes that the Earth is a sphere, since the used distance formula is the Haversine formula. This formula is only an approximation when applied to the Earth, which is not a perfect sphere. The introduced errors are not an issue when used in the context of social network sites that need to query by radius and most other applications. However in the worst case the error may be up to 0.5%, so you may want to consider other systems for error-critical applications.</source>
          <target state="translated">Она просто предполагает,что Земля-это сфера,так как используемая формула расстояния-это формула Хаверсина.Эта формула является лишь приближением,когда она применяется к Земле,которая не является идеальной сферой.Введенные ошибки не являются проблемой при использовании в контексте сайтов социальных сетей,которые необходимо запрашивать по радиусу и большинству других приложений.Однако в худшем случае ошибка может составлять до 0,5%,поэтому можно рассмотреть другие системы для приложений,критичных к ошибкам.</target>
        </trans-unit>
        <trans-unit id="78cca099dcd0e67e0e370e606d28021ee24c5299" translate="yes" xml:space="preserve">
          <source>It should display some computer art. There are no limits as long as the output works well in a normal terminal display. However the output should not be limited to graphics (like LOLWUT 5 and 6 actually do), but can be generative poetry and other non graphical things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="886b0ba44681d142ee0340c1b1c340fb49ca65a9" translate="yes" xml:space="preserve">
          <source>It starts accepting commands again from other clients, but will reply with a BUSY error to all the clients sending normal commands. The only allowed commands in this status are &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; and &lt;code&gt;SHUTDOWN
NOSAVE&lt;/code&gt;.</source>
          <target state="translated">Он снова начинает принимать команды от других клиентов, но ответит ошибкой BUSY всем клиентам, отправляющим обычные команды. Единственными разрешенными командами в этом состоянии являются &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; и &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9c449f7e951338dc4ce45209e7239b6180f2387" translate="yes" xml:space="preserve">
          <source>It stops processing all the pending commands from normal and pub/sub clients. However interactions with replicas will continue normally.</source>
          <target state="translated">Она прекращает обработку всех отложенных команд от обычных и паба/субклиентов.Однако взаимодействие с репликами будет продолжаться нормально.</target>
        </trans-unit>
        <trans-unit id="de49d1f951abef9774a1080b68edfd084cab6b36" translate="yes" xml:space="preserve">
          <source>It supports several other functions: &lt;code&gt;bit.tobit&lt;/code&gt;, &lt;code&gt;bit.tohex&lt;/code&gt;, &lt;code&gt;bit.bnot&lt;/code&gt;, &lt;code&gt;bit.band&lt;/code&gt;, &lt;code&gt;bit.bor&lt;/code&gt;, &lt;code&gt;bit.bxor&lt;/code&gt;, &lt;code&gt;bit.lshift&lt;/code&gt;, &lt;code&gt;bit.rshift&lt;/code&gt;, &lt;code&gt;bit.arshift&lt;/code&gt;, &lt;code&gt;bit.rol&lt;/code&gt;, &lt;code&gt;bit.ror&lt;/code&gt;, &lt;code&gt;bit.bswap&lt;/code&gt;. All available functions are documented in the &lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp documentation&lt;/a&gt;</source>
          <target state="translated">Он поддерживает несколько других функций: &lt;code&gt;bit.tobit&lt;/code&gt; , &lt;code&gt;bit.tohex&lt;/code&gt; , &lt;code&gt;bit.bnot&lt;/code&gt; , &lt;code&gt;bit.band&lt;/code&gt; , &lt;code&gt;bit.bor&lt;/code&gt; , &lt;code&gt;bit.bxor&lt;/code&gt; , &lt;code&gt;bit.lshift&lt;/code&gt; , &lt;code&gt;bit.rshift&lt;/code&gt; , &lt;code&gt;bit.arshift&lt;/code&gt; , &lt;code&gt;bit.rol&lt;/code&gt; , &lt;code&gt;bit.ror&lt;/code&gt; , &lt;code&gt;bit.bswap&lt;/code&gt; . Все доступные функции задокументированы в документации &lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="49c10040c2d176504fa4270533a1f6d22770dff5" translate="yes" xml:space="preserve">
          <source>It supports several other functions: &lt;code&gt;bit.tobit&lt;/code&gt;, &lt;code&gt;bit.tohex&lt;/code&gt;, &lt;code&gt;bit.bnot&lt;/code&gt;, &lt;code&gt;bit.band&lt;/code&gt;, &lt;code&gt;bit.bor&lt;/code&gt;, &lt;code&gt;bit.bxor&lt;/code&gt;, &lt;code&gt;bit.lshift&lt;/code&gt;, &lt;code&gt;bit.rshift&lt;/code&gt;, &lt;code&gt;bit.arshift&lt;/code&gt;, &lt;code&gt;bit.rol&lt;/code&gt;, &lt;code&gt;bit.ror&lt;/code&gt;, &lt;code&gt;bit.bswap&lt;/code&gt;. All available functions are documented in the &lt;a href=&quot;https://bitop.luajit.org/api.html&quot;&gt;Lua BitOp documentation&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6a033ac7293343a89e1b83064df26de033f26b" translate="yes" xml:space="preserve">
          <source>Iteratating a stream incrementally, returning just a few items at every iteration. However it is semantically much more robust than the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of functions.</source>
          <target state="translated">Постепенная итерация потока с возвратом всего нескольких элементов на каждой итерации. Однако семантически он намного надежнее, чем семейство функций &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa52c04afc758e80cafb88b8a1109903b053dfb" translate="yes" xml:space="preserve">
          <source>Iterating a stream</source>
          <target state="translated">перетекание ручья</target>
        </trans-unit>
        <trans-unit id="51c1f7544778c11ca5b79e2c5f951971fc09700a" translate="yes" xml:space="preserve">
          <source>Iterating a stream incrementally, returning just a few items at every iteration. However it is semantically much more robust than the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb66fccc1c9fe8583ef2426d5ce548dc6f7ff69" translate="yes" xml:space="preserve">
          <source>Iterating with XREVRANGE</source>
          <target state="translated">Итерация с XREVRANGE</target>
        </trans-unit>
        <trans-unit id="ac745b350ec3c8d6357a81e49fd4c8b3f51fac37" translate="yes" xml:space="preserve">
          <source>Iterating with earlier versions of Redis</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4794d4e58656f4a052385045d3fd4b0331ebddea" translate="yes" xml:space="preserve">
          <source>Iteration of a Hash value.</source>
          <target state="translated">Итерация хеш-значения.</target>
        </trans-unit>
        <trans-unit id="ac97fd8044e211b8965191abd3e1372d4a6075d6" translate="yes" xml:space="preserve">
          <source>KEYS</source>
          <target state="translated">KEYS</target>
        </trans-unit>
        <trans-unit id="d4d3343d1b4f35172b9d4fabff52e12ab9514f83" translate="yes" xml:space="preserve">
          <source>KEYS  pattern   Find all keys matching the given pattern</source>
          <target state="translated">Шаблон KEYS Найдите все клавиши,соответствующие заданному шаблону.</target>
        </trans-unit>
        <trans-unit id="8001eeb819fd035ff21dae0c64b60f000bfc9daa" translate="yes" xml:space="preserve">
          <source>Key step count allows us to find key positions in commands like &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; where the format is &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt;.</source>
          <target state="translated">Ключ подсчета шаг позволяет нам находить ключевые позиции в командах , как &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; , где формат &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="5e0969e73b8800b103eeedd8f6bcdbbbf0f4fa78" translate="yes" xml:space="preserve">
          <source>Keys are checked in the order that they are given. Let's say that the key &lt;code&gt;list1&lt;/code&gt; doesn't exist and &lt;code&gt;list2&lt;/code&gt; and &lt;code&gt;list3&lt;/code&gt; hold non-empty lists. Consider the following command:</source>
          <target state="translated">Ключи проверяются в том порядке, в котором они даются. Предположим, что ключевой &lt;code&gt;list1&lt;/code&gt; не существует, а &lt;code&gt;list2&lt;/code&gt; и &lt;code&gt;list3&lt;/code&gt; содержат непустые списки. Рассмотрим следующую команду:</target>
        </trans-unit>
        <trans-unit id="393be168e99116be87234133e2763b06336c48c1" translate="yes" xml:space="preserve">
          <source>Keys expiring information is stored as absolute Unix timestamps (in milliseconds in case of Redis version 2.6 or greater). This means that the time is flowing even when the Redis instance is not active.</source>
          <target state="translated">Информация об истекающих ключах хранится в виде абсолютных меток времени Unix (в миллисекундах в случае Redis версии 2.6 или выше).Это означает,что время течет,даже когда экземпляр Redis не активен.</target>
        </trans-unit>
        <trans-unit id="d3023dfa16df6ad208cc7d5460854b58da1edb26" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets.</source>
          <target state="translated">Несуществующие ключи считаются пустыми наборами.</target>
        </trans-unit>
        <trans-unit id="d71481abd644158f5a9fbc5c9cecdf74dc0540c6" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets. With one of the keys being an empty set, the resulting set is also empty (since set intersection with an empty set always results in an empty set).</source>
          <target state="translated">Несуществующие ключи считаются пустыми наборами.Если одна из клавиш является пустым набором,результирующий набор также является пустым (так как пересечение набора с пустым всегда приводит к пустому набору).</target>
        </trans-unit>
        <trans-unit id="a78a3a71051e865654da3b71a5c55513e9449b8a" translate="yes" xml:space="preserve">
          <source>Keys with an expire</source>
          <target state="translated">Ключи с истекшим сроком действия</target>
        </trans-unit>
        <trans-unit id="7bcef127a442604057181ff7e89e6774cfcbdec1" translate="yes" xml:space="preserve">
          <source>Keyspace hits</source>
          <target state="translated">Хиты по клавишам</target>
        </trans-unit>
        <trans-unit id="0ecc36a9eabb580bee92d3334fc963c0e285c8f2" translate="yes" xml:space="preserve">
          <source>Keyspace misses</source>
          <target state="translated">Пропуски на клавиатуре</target>
        </trans-unit>
        <trans-unit id="18937f1c4a4cfb92babe800429a63d572cde1150" translate="yes" xml:space="preserve">
          <source>Kills the currently executing Lua script, assuming no write operation was yet performed by the script.</source>
          <target state="translated">Убивает выполняемый в настоящее время скрипт Lua,предполагая,что операция записи еще не была выполнена скриптом.</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a452e11c491a60de5436b1999a469cdaa66c0c00" translate="yes" xml:space="preserve">
          <source>LASTSAVE</source>
          <target state="translated">LASTSAVE</target>
        </trans-unit>
        <trans-unit id="fb2ee42881d40ddc3d3aec1d41500b08e5d25e19" translate="yes" xml:space="preserve">
          <source>LASTSAVE   Get the UNIX time stamp of the last successful save to disk</source>
          <target state="translated">LASTSAVE Получить метку времени UNIX последнего успешного сохранения на диск</target>
        </trans-unit>
        <trans-unit id="49d6c10ecea9234f6d1697a89998efd2571a5a9d" translate="yes" xml:space="preserve">
          <source>LATENCY</source>
          <target state="translated">LATENCY</target>
        </trans-unit>
        <trans-unit id="0501d335a5299cb1743cbb10c7b8477444d0a1c2" translate="yes" xml:space="preserve">
          <source>LATENCY DOCTOR   Return a human readable latency analysis report.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186301f764b22cd2877e1aabbbb1538d6d5f7100" translate="yes" xml:space="preserve">
          <source>LATENCY GRAPH  event   Return a latency graph for the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd2b2b9b61f8de610b1da572e4c2d464408238b" translate="yes" xml:space="preserve">
          <source>LATENCY HELP   Show helpful text about the different subcommands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4448a36c961ebd2847369404270a681d688d37d" translate="yes" xml:space="preserve">
          <source>LATENCY HISTORY  event   Return timestamp-latency samples for the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40376256cb5363f7be31b5131fdde6f208ad798b" translate="yes" xml:space="preserve">
          <source>LATENCY LATEST   Return the latest latency samples for all events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46ae60e5ee406730f6e4d649edcf9436c10620d" translate="yes" xml:space="preserve">
          <source>LATENCY RESET  [event [event ...]]   Reset latency data for one or more events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6fdb30d112715d0c3b5d8a01834e5fa3472abec" translate="yes" xml:space="preserve">
          <source>LCS algorithm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89288dff0eca7e3500efaf0b7acd0c70cae1edc4" translate="yes" xml:space="preserve">
          <source>LCS is very useful in order to evaluate how similar two strings are. Strings can represent many things. For instance if two strings are DNA sequences, the LCS will provide a measure of similarity between the two DNA sequences. If the strings represent some text edited by some user, the LCS could represent how different the new text is compared to the old one, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ffd63c8ba805a842d4d3d2465da47916360545" translate="yes" xml:space="preserve">
          <source>LDB can be enabled in one of two modes: asynchronous or synchronous. In asynchronous mode the server creates a forked debugging session that does not block and all changes to the data are &lt;strong&gt;rolled back&lt;/strong&gt; after the session finishes, so debugging can be restarted using the same initial state. The alternative synchronous debug mode blocks the server while the debugging session is active and retains all changes to the data set once it ends.</source>
          <target state="translated">LDB можно включить в одном из двух режимов: асинхронном или синхронном. В асинхронном режиме сервер создает разветвленный сеанс отладки, который не блокируется, и все изменения данных &lt;strong&gt;откатываются&lt;/strong&gt; после завершения сеанса, поэтому отладку можно перезапустить с тем же начальным состоянием. Альтернативный синхронный режим отладки блокирует сервер, пока сеанс отладки активен, и сохраняет все изменения в наборе данных после его завершения.</target>
        </trans-unit>
        <trans-unit id="14d2c13614325f3af7fa95efeb5dd818bb2ab0d1" translate="yes" xml:space="preserve">
          <source>LINDEX</source>
          <target state="translated">LINDEX</target>
        </trans-unit>
        <trans-unit id="a2dedc00417f0b7b29562ddaa4e03af088097cdb" translate="yes" xml:space="preserve">
          <source>LINDEX  key index   Get an element from a list by its index</source>
          <target state="translated">Индекс ключей LINDEX Получить элемент из списка по его индексу</target>
        </trans-unit>
        <trans-unit id="40088c47225008784271c2935753b4ae98fd6ec7" translate="yes" xml:space="preserve">
          <source>LINSERT</source>
          <target state="translated">LINSERT</target>
        </trans-unit>
        <trans-unit id="b2f2247f94ae9fe4fba40fd22b1b94acb748b154" translate="yes" xml:space="preserve">
          <source>LINSERT  key BEFORE|AFTER pivot element   Insert an element before or after another element in a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca09700aae0c450ed6c327c789e3e1e3fef9f931" translate="yes" xml:space="preserve">
          <source>LINSERT  key BEFORE|AFTER pivot value   Insert an element before or after another element in a list</source>
          <target state="translated">Клавиша LINSERT BEFORE|AFTER Поворотное значение Вставьте элемент до или после другого элемента в список.</target>
        </trans-unit>
        <trans-unit id="19ce1639e2d6248a60334eca45396c2f1f706007" translate="yes" xml:space="preserve">
          <source>LLEN</source>
          <target state="translated">LLEN</target>
        </trans-unit>
        <trans-unit id="defc92ee8b39130b63cdf033e9edada00210e4f3" translate="yes" xml:space="preserve">
          <source>LLEN  key   Get the length of a list</source>
          <target state="translated">Клавиша LLEN Получить длину списка.</target>
        </trans-unit>
        <trans-unit id="cb98d0989512bc7d03fd0083653a3d72b76da663" translate="yes" xml:space="preserve">
          <source>LMOVE</source>
          <target state="translated">LMOVE</target>
        </trans-unit>
        <trans-unit id="78baeb2f5149c1548b47f47678b64129f94c3043" translate="yes" xml:space="preserve">
          <source>LMOVE  source destination LEFT|RIGHT LEFT|RIGHT   Pop an element from a list, push it to another list and return it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd49a9c6357f14037353e324dbbd426c30c77ff" translate="yes" xml:space="preserve">
          <source>LOLWUT</source>
          <target state="translated">LOLWUT</target>
        </trans-unit>
        <trans-unit id="91989e8620d79bb9a73795ebf9495785796e20eb" translate="yes" xml:space="preserve">
          <source>LOLWUT  [VERSION version]   Display some computer art and the Redis version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e5b9325998311e1bd0cdebf30f7c4698bea549" translate="yes" xml:space="preserve">
          <source>LOLWUT implementations should be safe and carefully checked for security, and resist to untrusted inputs if they take arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b789d56cc69b68e8cc9454d61b8f6bcb54c00bd" translate="yes" xml:space="preserve">
          <source>LOLWUT must always display the Redis version at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7fd4a8e75c582938a820d5ac113cfb69399cf55" translate="yes" xml:space="preserve">
          <source>LOLWUT output should be completely useless. Displaying some useful Redis internal metrics does not count as a valid LOLWUT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93af8b70d5c9191d5ace878da62d412c38ce8b2" translate="yes" xml:space="preserve">
          <source>LOLWUT output should be fast to generate so that the command can be called in production instances without issues. It should remain fast even when the user experiments with odd parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f982fb7857c5b2bb4e69ef661e4d5d07a8ccdf1" translate="yes" xml:space="preserve">
          <source>LOLWUT wants to be a reminder that there is more in programming than just putting some code together in order to create something useful. Every LOLWUT version should have the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f58be63c72a45daadb6f09041398ad98c6ac9a7" translate="yes" xml:space="preserve">
          <source>LPOP</source>
          <target state="translated">LPOP</target>
        </trans-unit>
        <trans-unit id="c0a0f50764c15280585040d66db05c7ea7d4701a" translate="yes" xml:space="preserve">
          <source>LPOP  key   Remove and get the first element in a list</source>
          <target state="translated">Клавиша LPOP Удалить и получить первый элемент в списке</target>
        </trans-unit>
        <trans-unit id="75ee742440d0263541b4bf6b56f59ba72ebbd18e" translate="yes" xml:space="preserve">
          <source>LPOP  key [count]   Remove and get the first elements in a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8692b4b41c5b80f3fc1b6efeb4604f7278100aec" translate="yes" xml:space="preserve">
          <source>LPOS</source>
          <target state="translated">LPOS</target>
        </trans-unit>
        <trans-unit id="2f8be8617cbb634559fc59c4d3862bfd42f75d83" translate="yes" xml:space="preserve">
          <source>LPOS  key element [RANK rank] [COUNT num-matches] [MAXLEN len]   Return the index of matching elements on a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f49fc76e42ddd892d0dbf761cab7456fba6707a" translate="yes" xml:space="preserve">
          <source>LPUSH</source>
          <target state="translated">LPUSH</target>
        </trans-unit>
        <trans-unit id="5005b933581b136ea08ec907be2cf03efef61621" translate="yes" xml:space="preserve">
          <source>LPUSH  key element [element ...]   Prepend one or multiple elements to a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3260ebe55f682088cc638c2329d0a5d2a5f9c43" translate="yes" xml:space="preserve">
          <source>LPUSH  key value [value ...]   Prepend one or multiple values to a list</source>
          <target state="translated">Значение клавиши LPUSH [значение ...]Подготовьте одно или несколько значений в список.</target>
        </trans-unit>
        <trans-unit id="73023347f78efa6f33e2849831f260102f26f9dc" translate="yes" xml:space="preserve">
          <source>LPUSHX</source>
          <target state="translated">LPUSHX</target>
        </trans-unit>
        <trans-unit id="ed89f101b9e76dd34f817063ee39924d1d879b9e" translate="yes" xml:space="preserve">
          <source>LPUSHX  key element [element ...]   Prepend an element to a list, only if the list exists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11960d83f4ba3a64c1274bec7eeaf405b1c4abbe" translate="yes" xml:space="preserve">
          <source>LPUSHX  key value   Prepend a value to a list, only if the list exists</source>
          <target state="translated">Значение ключа LPUSHX Подготовить значение к списку,только если список существует.</target>
        </trans-unit>
        <trans-unit id="3b47c23e3107b92100b9303bb9ab3d1a9ccc56bd" translate="yes" xml:space="preserve">
          <source>LRANGE</source>
          <target state="translated">LRANGE</target>
        </trans-unit>
        <trans-unit id="326594fa342712e825205a5b864121b10bd2f5cf" translate="yes" xml:space="preserve">
          <source>LRANGE  key start stop   Get a range of elements from a list</source>
          <target state="translated">Остановка запуска по клавише LRANGE Получить ряд элементов из списка</target>
        </trans-unit>
        <trans-unit id="abfc25d80dc9a80384bd4c9697b510b323ecc45b" translate="yes" xml:space="preserve">
          <source>LREM</source>
          <target state="translated">LREM</target>
        </trans-unit>
        <trans-unit id="254b612ba99c38d18c49c669440c641123e2f3a7" translate="yes" xml:space="preserve">
          <source>LREM  key count element   Remove elements from a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b649e2191175bc6abf8bc7b2d0b6ec6fbf904d" translate="yes" xml:space="preserve">
          <source>LREM  key count value   Remove elements from a list</source>
          <target state="translated">LREM значение подсчета ключей Удалить элементы из списка</target>
        </trans-unit>
        <trans-unit id="70e8f03d6f4f36a9430ac8c4d4a1515597b0b252" translate="yes" xml:space="preserve">
          <source>LSET</source>
          <target state="translated">LSET</target>
        </trans-unit>
        <trans-unit id="67b8e37be9910fff9bc7142f035eae99cc3cc4f5" translate="yes" xml:space="preserve">
          <source>LSET  key index element   Set the value of an element in a list by its index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f03203283df161a2d6f2abf4d29626d32823249" translate="yes" xml:space="preserve">
          <source>LSET  key index value   Set the value of an element in a list by its index</source>
          <target state="translated">Значение индекса ключа LSET Установить значение элемента в списке по его индексу</target>
        </trans-unit>
        <trans-unit id="13cbd920c001e22788dd4d82cdc291c6caac4662" translate="yes" xml:space="preserve">
          <source>LTRIM</source>
          <target state="translated">LTRIM</target>
        </trans-unit>
        <trans-unit id="6c5b375830efe50dd05881b52f80e2aa747afced" translate="yes" xml:space="preserve">
          <source>LTRIM  key start stop   Trim a list to the specified range</source>
          <target state="translated">Стартовая остановка с помощью клавиши LTRIM Обрезать список до заданного диапазона</target>
        </trans-unit>
        <trans-unit id="de6a27da313b316346ea7dcf9f866c5fcdaff765" translate="yes" xml:space="preserve">
          <source>Last Key in Argument List</source>
          <target state="translated">Последний ключ в списке аргументов</target>
        </trans-unit>
        <trans-unit id="65fe7d4d518c0668f04d8585ccfbc20334e6fd38" translate="yes" xml:space="preserve">
          <source>Lastly, there are three important rules to note:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e1040fdde9172717ea80a7cdcb3b316461fb75" translate="yes" xml:space="preserve">
          <source>Later it will be trivial to know the number of single days the user visited the web site simply calling the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; command against the bitmap.</source>
          <target state="translated">Позже будет тривиально узнать количество дней, в течение которых пользователь посещал веб-сайт, просто вызвав команду &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; для растрового изображения.</target>
        </trans-unit>
        <trans-unit id="78d7ed93f503a940a73a89268b71f5daa31c6b65" translate="yes" xml:space="preserve">
          <source>Latest event latency in millisecond.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6167261c71ec337f0f15b900208ad184a4f7b0c9" translate="yes" xml:space="preserve">
          <source>Latest fork(2) time</source>
          <target state="translated">Последнее время вилки(2)</target>
        </trans-unit>
        <trans-unit id="0122f9d36a5bc7edfbaa17dc0a7b017882cfb3ae" translate="yes" xml:space="preserve">
          <source>Let's assume we have four nodes, A, B, C and D. In order to end with just a three nodes cluster A, B, C we may follow these steps:</source>
          <target state="translated">Предположим,что у нас есть четыре узла,A,B,C и D.Для того,чтобы закончить работу всего с тремя узлами кластера A,B,C,мы можем выполнить следующие шаги:</target>
        </trans-unit>
        <trans-unit id="2f5c5e27076a7756eeef955cec8a1510af3fb9c4" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike License 4.0.</source>
          <target state="translated">Лицензия Creative Commons Attribution-ShareAlike License 4.0.</target>
        </trans-unit>
        <trans-unit id="98cf5d780c53575d17f1d32cf3823650dcaa6c52" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; this command returns the remaining time to live of a key that has an expire set, with the sole difference that &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; returns the amount of remaining time in seconds while &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; returns it in milliseconds.</source>
          <target state="translated">Как и &lt;a href=&quot;ttl&quot;&gt;TTL,&lt;/a&gt; эта команда возвращает оставшееся время жизни ключа, для которого установлен срок действия, с той лишь разницей, что &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; возвращает оставшееся время в секундах, а &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; возвращает его в миллисекундах.</target>
        </trans-unit>
        <trans-unit id="199ff2ec8051414c46a22a354ba2c4bf9f64de93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; this command can be used in order to iterate the whole stream content, however note that in this case, the next command calls should use the ID of the last entry, with the sequence number decremneted by one. However if the sequence number is already 0, the time part of the ID should be decremented by 1, and the sequence part should be set to the maxium possible sequence number, that is, 18446744073709551615, or could be omitted at all, and the command will automatically assume it to be such a number (see &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; for more info about incomplete IDs).</source>
          <target state="translated">Как и &lt;a href=&quot;xrange&quot;&gt;XRANGE,&lt;/a&gt; эту команду можно использовать для итерации всего содержимого потока, однако обратите внимание, что в этом случае следующие вызовы команды должны использовать идентификатор последней записи с порядковым номером, уменьшенным на единицу. Однако, если порядковый номер уже равен 0, временная часть идентификатора должна быть уменьшена на 1, а часть последовательности должна быть установлена ​​на максимально возможный порядковый номер, то есть 18446744073709551615, или может быть опущена вообще, а команда автоматически предположит, что это именно такой номер (см. &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; для получения дополнительной информации о неполных идентификаторах).</target>
        </trans-unit>
        <trans-unit id="7a5a0a2011829340fa32a8f044e479cef542a701" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command can be used in a blocking way. There are no differences in this regard.</source>
          <target state="translated">Как и &lt;a href=&quot;xread&quot;&gt;XREAD,&lt;/a&gt; команду &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; можно использовать для блокировки. Никаких отличий по этому поводу нет.</target>
        </trans-unit>
        <trans-unit id="964c6e379f4b517ab54346bbc59cea679f55f58d" translate="yes" xml:space="preserve">
          <source>Like for the &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; command start and end can contain negative values in order to index bytes starting from the end of the string, where -1 is the last byte, -2 is the penultimate, and so forth.</source>
          <target state="translated">Как и для команды &lt;a href=&quot;getrange&quot;&gt;GETRANGE,&lt;/a&gt; начало и конец могут содержать отрицательные значения для индексации байтов, начиная с конца строки, где -1 - последний байт, -2 - предпоследний и т. Д.</target>
        </trans-unit>
        <trans-unit id="ce45b8148c6f69841bc195d50623329ea61f3da8" translate="yes" xml:space="preserve">
          <source>Lines can contain a section name (starting with a # character) or a property. All the properties are in the form of &lt;code&gt;field:value&lt;/code&gt; terminated by &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">Строки могут содержать название раздела (начинающееся с символа #) или свойство. Все свойства представлены в виде &lt;code&gt;field:value&lt;/code&gt; оканчивающегося &lt;code&gt;\r\n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39de9fe457bd2e361245f87b008646c82403b58e" translate="yes" xml:space="preserve">
          <source>List of rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="899acbf6050de7813479a962bcb80b73089f0f38" translate="yes" xml:space="preserve">
          <source>Lists can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;linkedlist&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is the special representation that is used to save space for small lists.</source>
          <target state="translated">Списки могут быть закодированы как &lt;code&gt;ziplist&lt;/code&gt; или связанный &lt;code&gt;linkedlist&lt;/code&gt; . &lt;code&gt;ziplist&lt;/code&gt; это специальное представление, которое используется для экономии места для небольших списков.</target>
        </trans-unit>
        <trans-unit id="db5be7f471516f84344dd104ba9b8aa174ce8d02" translate="yes" xml:space="preserve">
          <source>Lists the currently &lt;em&gt;active channels&lt;/em&gt;. An active channel is a Pub/Sub channel with one or more subscribers (not including clients subscribed to patterns).</source>
          <target state="translated">Список текущих &lt;em&gt;активных каналов&lt;/em&gt; . Активный канал - это канал Pub / Sub с одним или несколькими подписчиками (не включая клиентов, подписанных на шаблоны).</target>
        </trans-unit>
        <trans-unit id="dcea1d44bcfef24039b8c1d6348290fc06d43c9a" translate="yes" xml:space="preserve">
          <source>Load a script into the scripts cache, without executing it. After the specified command is loaded into the script cache it will be callable using &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; with the correct SHA1 digest of the script, exactly like after the first successful invocation of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;.</source>
          <target state="translated">Загружать скрипт в кеш скриптов, не выполняя его. После загрузки указанной команды в кэш сценария ее можно будет вызвать с помощью &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; с правильным дайджестом сценария SHA1, точно так же, как после первого успешного вызова &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="735c2e48480d01f1dceaeb55af3cf36dcdd6249a" translate="yes" xml:space="preserve">
          <source>Loads a module from a dynamic library at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="694b70e7b053ef29ce888020d6a15ef0d17437e5" translate="yes" xml:space="preserve">
          <source>Lua boolean -&amp;gt; Redis boolean true or false. &lt;strong&gt;Note that this is a change compared to the RESP2 mode&lt;/strong&gt;, where returning true from Lua returned the number 1 to the Redis client, and returning false used to return NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd47c9d2232eb759e90bf52905602d787217e6e" translate="yes" xml:space="preserve">
          <source>Lua boolean false -&amp;gt; Redis Nil bulk reply.</source>
          <target state="translated">Lua boolean false -&amp;gt; массовый ответ Redis Nil.</target>
        </trans-unit>
        <trans-unit id="197815ca05866b7c30c1048b9d86321ee4ce6238" translate="yes" xml:space="preserve">
          <source>Lua boolean true -&amp;gt; Redis integer reply with value of 1.</source>
          <target state="translated">Lua boolean true -&amp;gt; Целочисленный ответ Redis со значением 1.</target>
        </trans-unit>
        <trans-unit id="02dda41ef75370280dc992551fadb03b88d21b1f" translate="yes" xml:space="preserve">
          <source>Lua does not export commands to access the system time or other external state.</source>
          <target state="translated">Lua не экспортирует команды для доступа к системному времени или другому внешнему состоянию.</target>
        </trans-unit>
        <trans-unit id="738b234f859993680828647d652f6de5655b0815" translate="yes" xml:space="preserve">
          <source>Lua has a single numerical type, Lua numbers. There is no distinction between integers and floats. So we always convert Lua numbers into integer replies, removing the decimal part of the number if any. &lt;strong&gt;If you want to return a float from Lua you should return it as a string&lt;/strong&gt;, exactly like Redis itself does (see for instance the &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; command).</source>
          <target state="translated">Lua имеет единственный числовой тип - числа Lua. Нет различия между целыми числами и числами с плавающей запятой. Поэтому мы всегда конвертируем числа Lua в целочисленные ответы, удаляя десятичную часть числа, если таковая имеется. &lt;strong&gt;Если вы хотите вернуть число с плавающей запятой из Lua, вы должны вернуть его как строку&lt;/strong&gt; , как это делает сам Redis (см., Например, команду &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8a5d229484ee19b076e60e7fc0d0b8345579dcc1" translate="yes" xml:space="preserve">
          <source>Lua null -&amp;gt; Redis RESP3 new null reply (protocol &lt;code&gt;&quot;_\r\n&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c212b1d165a2bdadf01bf8c01c306a9c3e780aa" translate="yes" xml:space="preserve">
          <source>Lua number -&amp;gt; Redis integer reply (the number is converted into an integer)</source>
          <target state="translated">Число Lua -&amp;gt; Целочисленный ответ Redis (число преобразуется в целое число)</target>
        </trans-unit>
        <trans-unit id="0fcb79bd3680efc38fab49be15ad5a556da29a6c" translate="yes" xml:space="preserve">
          <source>Lua pseudo random number generation functions &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; are modified in order to always have the same seed every time a new script is executed. This means that calling &lt;code&gt;math.random&lt;/code&gt; will always generate the same sequence of numbers every time a script is executed if &lt;code&gt;math.randomseed&lt;/code&gt; is not used.</source>
          <target state="translated">Функции генерации псевдослучайных чисел Lua &lt;code&gt;math.random&lt;/code&gt; и &lt;code&gt;math.randomseed&lt;/code&gt; изменены таким образом, чтобы всегда иметь одно и то же начальное число при каждом запуске нового скрипта. Это означает, что вызов &lt;code&gt;math.random&lt;/code&gt; всегда будет генерировать одну и ту же последовательность чисел каждый раз, когда выполняется скрипт, если &lt;code&gt;math.randomseed&lt;/code&gt; не используется.</target>
        </trans-unit>
        <trans-unit id="e026038d7a23da497563d39bf562be4e8b076af8" translate="yes" xml:space="preserve">
          <source>Lua scripts can return a value that is converted from the Lua type to the Redis protocol using a set of conversion rules.</source>
          <target state="translated">Скрипты Lua могут возвращать значение,которое преобразуется из типа Lua в протокол Redis с помощью набора правил преобразования.</target>
        </trans-unit>
        <trans-unit id="eec8779958c6af77259f2bed4f2206965d44330b" translate="yes" xml:space="preserve">
          <source>Lua string -&amp;gt; Redis bulk reply</source>
          <target state="translated">Строка Lua -&amp;gt; массовый ответ Redis</target>
        </trans-unit>
        <trans-unit id="0b78d29489185b7463559dbd5991d9b98e6ea241" translate="yes" xml:space="preserve">
          <source>Lua table (array) -&amp;gt; Redis multi bulk reply (truncated to the first nil inside the Lua array if any)</source>
          <target state="translated">Таблица Lua (массив) -&amp;gt; Многократный массовый ответ Redis (усеченный до первого нуля внутри массива Lua, если таковой имеется)</target>
        </trans-unit>
        <trans-unit id="011559d094bdd466ae90420b82cf3259960bb378" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;double&lt;/code&gt; field set to a field-value Lua table -&amp;gt; Redis double reply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92dffb8e404af7ee6cc40117a693313890548b7f" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;err&lt;/code&gt; field -&amp;gt; Redis error reply</source>
          <target state="translated">Lua таблица с одной &lt;code&gt;err&lt;/code&gt; поле -&amp;gt; Redis ошибка ответ</target>
        </trans-unit>
        <trans-unit id="31b3bac91c4fbeb254b85ca62a253ad709c8a47f" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;map&lt;/code&gt; field set to a field-value Lua table -&amp;gt; Redis map reply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860f10116eaffeabf918bd97496952f6a8568b86" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;ok&lt;/code&gt; field -&amp;gt; Redis status reply</source>
          <target state="translated">Таблица Lua с одним полем &lt;code&gt;ok&lt;/code&gt; -&amp;gt; ответ статуса Redis</target>
        </trans-unit>
        <trans-unit id="c86e8370e8448b07f033d118ba308f34fc561150" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;set&lt;/code&gt; field set to a field-value Lua table -&amp;gt; Redis set reply, the values are discarded and can be anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b1c471ce1efbe25d7232b293140a21b7fea826" translate="yes" xml:space="preserve">
          <source>MEMORY</source>
          <target state="translated">MEMORY</target>
        </trans-unit>
        <trans-unit id="5f530d724793deebbb2b735aad30cfb0c16904b5" translate="yes" xml:space="preserve">
          <source>MEMORY DOCTOR   Outputs memory problems report</source>
          <target state="translated">ДОКТОР ПАМЯТИ Выходит отчет о проблемах с памятью</target>
        </trans-unit>
        <trans-unit id="f41c78df06ee10a6b220b355855965b8d5802f0d" translate="yes" xml:space="preserve">
          <source>MEMORY HELP   Show helpful text about the different subcommands</source>
          <target state="translated">MEMORY HELP Показать полезный текст о различных подкомандах</target>
        </trans-unit>
        <trans-unit id="c46a26bce66617f3cb9ccdc83db737a6115fdc5d" translate="yes" xml:space="preserve">
          <source>MEMORY MALLOC-STATS   Show allocator internal stats</source>
          <target state="translated">ПАМЯТЬ МАЛЛОК-СТАТЫ Показывать внутреннюю статистику распределителя</target>
        </trans-unit>
        <trans-unit id="eb96d4965b5bb6522ee6573db44c8a6e1ce6edba" translate="yes" xml:space="preserve">
          <source>MEMORY PURGE   Ask the allocator to release memory</source>
          <target state="translated">ЦЕПЬ ПАМЯТИ Попросите аллокатор освободить память.</target>
        </trans-unit>
        <trans-unit id="d3303c80cf9ee1aa6f783b72419ffa190e2a905d" translate="yes" xml:space="preserve">
          <source>MEMORY STATS   Show memory usage details</source>
          <target state="translated">Показать статистику использования памяти</target>
        </trans-unit>
        <trans-unit id="de9aed5605340cafa3f173e741e4bc7253d17f99" translate="yes" xml:space="preserve">
          <source>MEMORY USAGE  key [SAMPLES count]   Estimate the memory usage of a key</source>
          <target state="translated">Ключ использования памяти [SAMPLES счет]Оценка использования памяти ключа</target>
        </trans-unit>
        <trans-unit id="eb4b445b699787b561e4b67d4f6b08a7ef32cf55" translate="yes" xml:space="preserve">
          <source>MGET</source>
          <target state="translated">MGET</target>
        </trans-unit>
        <trans-unit id="ffbcf2b819692d7b52978ca1ef1e227536a082fe" translate="yes" xml:space="preserve">
          <source>MGET  key [key ...]   Get the values of all the given keys</source>
          <target state="translated">Клавиша MGET [клавиша ...]Получить значения всех данных клавиш.</target>
        </trans-unit>
        <trans-unit id="883beaf0f91aca7f9ebc4802e0bab2501cbbc8ea" translate="yes" xml:space="preserve">
          <source>MIGRATE</source>
          <target state="translated">MIGRATE</target>
        </trans-unit>
        <trans-unit id="c26be640f072695430c6befbdaab1be7da9a4af0" translate="yes" xml:space="preserve">
          <source>MIGRATE  host port key|&quot;&quot; destination-db timeout [COPY] [REPLACE] [AUTH password] [AUTH2 username password] [KEYS key [key ...]]   Atomically transfer a key from a Redis instance to another one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f0b2cdf3b3d88df6ed56ef5576fa5ec1a8aa5b1" translate="yes" xml:space="preserve">
          <source>MIGRATE  host port key|&quot;&quot; destination-db timeout [COPY] [REPLACE] [KEYS key [key ...]]   Atomically transfer a key from a Redis instance to another one.</source>
          <target state="translated">Порт хоста MIGRATE key|&quot;&quot;-тайм-аут назначения db [КОПИ][ЗАМЕНА][клавиша KEYS [ключ ...]]].Атоматическая передача ключа из экземпляра Redis в другой экземпляр.</target>
        </trans-unit>
        <trans-unit id="66bffe2295ae671e5d45439c77216938c792414b" translate="yes" xml:space="preserve">
          <source>MODULE</source>
          <target state="translated">MODULE</target>
        </trans-unit>
        <trans-unit id="43ac8ce01de13f2da2af292daa0522a8dce0815f" translate="yes" xml:space="preserve">
          <source>MODULE LIST   List all modules loaded by the server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead5dec077ff0d8c33078bffc3edb3a161d0c8b1" translate="yes" xml:space="preserve">
          <source>MODULE LOAD  path [ arg [arg ...]]   Load a module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d0e227668f65977f974daf28058d755a01a58f" translate="yes" xml:space="preserve">
          <source>MODULE UNLOAD  name   Unload a module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da5b5979c630adef5abc39370410d7de4a1b8ef" translate="yes" xml:space="preserve">
          <source>MONITOR</source>
          <target state="translated">MONITOR</target>
        </trans-unit>
        <trans-unit id="55d4d86d6d24375e297cf38db11a4bacd4febc84" translate="yes" xml:space="preserve">
          <source>MONITOR   Listen for all requests received by the server in real time</source>
          <target state="translated">МОНИТОР Прослушивать все запросы,получаемые сервером в режиме реального времени</target>
        </trans-unit>
        <trans-unit id="3bf08a84f15b98ce4d14b707f4a093b3cc8b853e" translate="yes" xml:space="preserve">
          <source>MOVE</source>
          <target state="translated">MOVE</target>
        </trans-unit>
        <trans-unit id="001d5d6407276cba944eda42b69684ebbbae5d55" translate="yes" xml:space="preserve">
          <source>MOVE  key db   Move a key to another database</source>
          <target state="translated">MOVE ключ db Перемещение ключа в другой банк данных</target>
        </trans-unit>
        <trans-unit id="4a4d41a590643b6020afed2c32a7fa4d49b49601" translate="yes" xml:space="preserve">
          <source>MSET</source>
          <target state="translated">MSET</target>
        </trans-unit>
        <trans-unit id="9a5861cd64b36ffe83c01382e80e50105a256980" translate="yes" xml:space="preserve">
          <source>MSET  key value [key value ...]   Set multiple keys to multiple values</source>
          <target state="translated">Значение клавиши MSET [значение клавиши ...]Установить несколько клавиш на несколько значений</target>
        </trans-unit>
        <trans-unit id="f7daca0dd0ee4f7979861ac9b4fb059852d07494" translate="yes" xml:space="preserve">
          <source>MSETNX</source>
          <target state="translated">MSETNX</target>
        </trans-unit>
        <trans-unit id="48498dbffef6df5e6474fe5db88a9722de54676a" translate="yes" xml:space="preserve">
          <source>MSETNX  key value [key value ...]   Set multiple keys to multiple values, only if none of the keys exist</source>
          <target state="translated">MSETNX значение клавиши [значение клавиши ...]Установите несколько клавиш на несколько значений,только если ни одна из клавиш не существует.</target>
        </trans-unit>
        <trans-unit id="73cadb41b45514de9061a72461b466eafd7a01b0" translate="yes" xml:space="preserve">
          <source>MULTI</source>
          <target state="translated">MULTI</target>
        </trans-unit>
        <trans-unit id="bb76d99632737ac9f4ecd1c2218ac5cae7373df0" translate="yes" xml:space="preserve">
          <source>MULTI   Mark the start of a transaction block</source>
          <target state="translated">MULTI Отметьте начало блока транзакций</target>
        </trans-unit>
        <trans-unit id="5162c1f5fa963969d600908fd5531f9515bcd0ad" translate="yes" xml:space="preserve">
          <source>Manually issue the &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; command to stop a &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; stream running via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="translated">Вручную &lt;a href=&quot;quit&quot;&gt;введите&lt;/a&gt; команду QUIT, чтобы остановить поток &lt;a href=&quot;monitor&quot;&gt;МОНИТОРА,&lt;/a&gt; работающий через &lt;code&gt;telnet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ab2b333d1a4eb7dc9f5b2c393ae0acfe6aa0aa8" translate="yes" xml:space="preserve">
          <source>Manually issue the &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; commands to stop a &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; stream running via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195fbe53b32ee6173d85e3798809ae2267b7bfce" translate="yes" xml:space="preserve">
          <source>Marks the given keys to be watched for conditional execution of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">Отмечает указанные ключи для отслеживания условного выполнения &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;транзакции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8683729a7a727945cae9baf35f4c55f1439a9ae" translate="yes" xml:space="preserve">
          <source>Marks the start of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; block. Subsequent commands will be queued for atomic execution using &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;.</source>
          <target state="translated">Отмечает начало блока &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;транзакции&lt;/a&gt; . Последующие команды будут помещены в очередь для атомарного выполнения с использованием &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f713e2ee906af8b74a13e92b2e0d07f7715b2d2e" translate="yes" xml:space="preserve">
          <source>Master for slot range represented as nested IP/Port array</source>
          <target state="translated">Мастер для диапазона слотов,представленных в виде вложенного массива IP/Port</target>
        </trans-unit>
        <trans-unit id="826539552e055ad1bd8dd2263cef37308d024f80" translate="yes" xml:space="preserve">
          <source>Master output</source>
          <target state="translated">Мастер-выпуск</target>
        </trans-unit>
        <trans-unit id="221cc49f520f042d2c8db1934cf7365d8019893a" translate="yes" xml:space="preserve">
          <source>Matches are produced from the last one to the first one, since this is how the algorithm works, and it more efficient to emit things in the same order. The above array means that the first match (second element of the array) is between positions 2-3 of the first string and 0-1 of the second. Then there is another match between 4-7 and 5-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a00e4f9797b4c734ae7a585f001ffa257119f27" translate="yes" xml:space="preserve">
          <source>Meaning of the flags (field number 3):</source>
          <target state="translated">Значение флагов (поле 3):</target>
        </trans-unit>
        <trans-unit id="716383f923909d0c089205fcba00d4705b3601a5" translate="yes" xml:space="preserve">
          <source>Merge multiple HyperLogLog values into an unique value that will approximate the cardinality of the union of the observed Sets of the source HyperLogLog structures.</source>
          <target state="translated">Соедините несколько значений HyperLogLog в уникальное значение,которое будет аппроксимировать кардинальность объединения наблюдаемых наборов исходных структур HyperLogLog.</target>
        </trans-unit>
        <trans-unit id="d48699ea9bf170ea49610c0892198d522150833b" translate="yes" xml:space="preserve">
          <source>Migrating multiple keys with a single command call</source>
          <target state="translated">Миграция нескольких клавиш одним вызовом команды</target>
        </trans-unit>
        <trans-unit id="1dc9fdcdad40a742a94a677f3b78a05f4ed5e6b5" translate="yes" xml:space="preserve">
          <source>Migration and importing slots are only added to the node flagged as &lt;code&gt;myself&lt;/code&gt;. This information is local to a node, for its own slots.</source>
          <target state="translated">Слоты для миграции и импорта добавляются только к узлу, отмеченному как &lt;code&gt;myself&lt;/code&gt; . Эта информация является локальной для узла для его собственных слотов.</target>
        </trans-unit>
        <trans-unit id="b39875ef4297a449c400e22ef1b7f5a9df1b0b1a" translate="yes" xml:space="preserve">
          <source>Modules that register custom data types can not be unloaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf4ac897fe1476ddf0632fbae3fd4061b3a77806" translate="yes" xml:space="preserve">
          <source>More details about the Redis HyperLogLog implementation can be found in &lt;a href=&quot;http://antirez.com/news/75&quot;&gt;this blog post&lt;/a&gt;. The source code of the implementation in the &lt;code&gt;hyperloglog.c&lt;/code&gt; file is also easy to read and understand, and includes a full specification for the exact encoding used for the sparse and dense representations.</source>
          <target state="translated">Более подробную информацию о реализации Redis HyperLogLog можно найти в &lt;a href=&quot;http://antirez.com/news/75&quot;&gt;этом сообщении блога&lt;/a&gt; . Исходный код реализации в файле &lt;code&gt;hyperloglog.c&lt;/code&gt; также легко читать и понимать и включает полную спецификацию точной кодировки, используемой для разреженных и плотных представлений.</target>
        </trans-unit>
        <trans-unit id="66fbce4faebab20f5ca1d3b33c08e967f22406cb" translate="yes" xml:space="preserve">
          <source>More information about the Current Epoch and Config Epoch variables are available in the Redis Cluster specification document.</source>
          <target state="translated">Более подробная информация о переменных Current Epoch (Текущая эпоха)и Config Epoch (Настройка эпохи)доступна в спецификационном документе Redis Cluster (Кластер Redis).</target>
        </trans-unit>
        <trans-unit id="76f5a5481231f7dff85e48d6a0993bd209662a44" translate="yes" xml:space="preserve">
          <source>Moreover &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; does not need to be reciprocal. If I send the command to A in order to join B, I don't need to also send it to B in order to join A.</source>
          <target state="translated">Более того, &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; не обязательно должен быть взаимным. Если я отправлю команду A, чтобы присоединиться к B, мне не нужно также отправлять ее B, чтобы присоединиться к A.</target>
        </trans-unit>
        <trans-unit id="9e46ae1b67b3a95c0efb340b998c24643ca486fb" translate="yes" xml:space="preserve">
          <source>Moreover, as a side effect, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will increment the count of attempted deliveries of the message unless the &lt;code&gt;JUSTID&lt;/code&gt; option has been specified (which only delivers the message ID, not the message itself). In this way messages that cannot be processed for some reason, for instance because the consumers crash attempting to process them, will start to have a larger counter and can be detected inside the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8993f2e40360ac488b5303cad3bacad41d3a08f1" translate="yes" xml:space="preserve">
          <source>Moreover, as a side effect, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will increment the count of attempted deliveries of the message. In this way messages that cannot be processed for some reason, for instance because the consumers crash attempting to process them, will start to have a larger counter and can be detected inside the system.</source>
          <target state="translated">Более того, в качестве побочного эффекта &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; увеличит счетчик попыток доставки сообщения. Таким образом, сообщения, которые не могут быть обработаны по какой-либо причине, например, из-за сбоя потребителей, пытающихся их обработать, начнут иметь больший счетчик и могут быть обнаружены внутри системы.</target>
        </trans-unit>
        <trans-unit id="6330fc6bbcd49c1766a676116e26172a91d38595" translate="yes" xml:space="preserve">
          <source>Moreover, if you are new to streams, we recommend to read our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. Make sure to understand the concept of consumer group in the introduction so that following how this command works will be simpler.</source>
          <target state="translated">Более того, если вы новичок в потоках, мы рекомендуем прочитать наше &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;введение в Redis Streams&lt;/a&gt; . Убедитесь, что вы понимаете концепцию группы потребителей во введении, чтобы было проще понять, как работает эта команда.</target>
        </trans-unit>
        <trans-unit id="fde66fa86f8517d887e54616bf1fb31656fc7f81" translate="yes" xml:space="preserve">
          <source>Motivations</source>
          <target state="translated">Motivations</target>
        </trans-unit>
        <trans-unit id="eaf7a15ddfb6c5c306f486c8bf293512f163a845" translate="yes" xml:space="preserve">
          <source>Movable Keys</source>
          <target state="translated">Подвижные ключи</target>
        </trans-unit>
        <trans-unit id="f77b47b8d13d94af9785e089c536b9963ca2c823" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;key&lt;/code&gt; from the currently selected database (see &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt;) to the specified destination database. When &lt;code&gt;key&lt;/code&gt; already exists in the destination database, or it does not exist in the source database, it does nothing. It is possible to use &lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt; as a locking primitive because of this.</source>
          <target state="translated">Переместить &lt;code&gt;key&lt;/code&gt; из текущей выбранной базы данных (см. &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; ) в указанную целевую базу данных. Когда &lt;code&gt;key&lt;/code&gt; уже существует в целевой базе данных или его нет в исходной базе данных, он ничего не делает. Из-за этого можно использовать &lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt; как блокирующий примитив.</target>
        </trans-unit>
        <trans-unit id="17c083c9f9d68a5d0169cd11d9c0c04115759b24" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;member&lt;/code&gt; from the set at &lt;code&gt;source&lt;/code&gt; to the set at &lt;code&gt;destination&lt;/code&gt;. This operation is atomic. In every given moment the element will appear to be a member of &lt;code&gt;source&lt;/code&gt;&lt;strong&gt;or&lt;/strong&gt;&lt;code&gt;destination&lt;/code&gt; for other clients.</source>
          <target state="translated">Переместить &lt;code&gt;member&lt;/code&gt; из набора в &lt;code&gt;source&lt;/code&gt; в набор в месте &lt;code&gt;destination&lt;/code&gt; . Эта операция атомарна. В каждый данный момент элемент будет казаться элементом &lt;code&gt;source&lt;/code&gt; &lt;strong&gt;или &lt;/strong&gt; &lt;code&gt;destination&lt;/code&gt; для других клиентов.</target>
        </trans-unit>
        <trans-unit id="95a91b78dd0ce912aadce361711a043cae9a887e" translate="yes" xml:space="preserve">
          <source>Multiple parallel iterations</source>
          <target state="translated">Многочисленные параллельные итерации</target>
        </trans-unit>
        <trans-unit id="f492964822aab7cec6aa84fefaffe8fba8b6cd36" translate="yes" xml:space="preserve">
          <source>Nested Result Array</source>
          <target state="translated">Массив вложенных результатов</target>
        </trans-unit>
        <trans-unit id="fdc70576104b358de95d88f0255666aac631aff0" translate="yes" xml:space="preserve">
          <source>New fields are regularly added for debugging purpose. Some could be removed in the future. A version safe Redis client using this command should parse the output accordingly (i.e. handling gracefully missing fields, skipping unknown fields).</source>
          <target state="translated">Для отладки регулярно добавляются новые поля.Некоторые из них могут быть удалены в будущем.Клиент Redis,безопасный для версий,используя эту команду,должен разобрать вывод соответствующим образом (т.е.обрабатывать изящно пропущенные поля,пропускать неизвестные поля).</target>
        </trans-unit>
        <trans-unit id="861e51e24f78632f52937df883ebeed5a0766d52" translate="yes" xml:space="preserve">
          <source>New keys are always created in the target node. During a hash slot migration we'll have to move only old keys, not new ones.</source>
          <target state="translated">Новые клавиши всегда создаются в целевом узле.При переносе хэш-слота нам придется перемещать только старые ключи,а не новые.</target>
        </trans-unit>
        <trans-unit id="97bfa87b383568ddb64d92c09cf59316bbb313bd" translate="yes" xml:space="preserve">
          <source>No repeated elements are returned.</source>
          <target state="translated">Повторяющиеся элементы не возвращаются.</target>
        </trans-unit>
        <trans-unit id="75e932f04e490ddd2c64a4420d419573bd058eac" translate="yes" xml:space="preserve">
          <source>Nodes in &lt;code&gt;PFAIL&lt;/code&gt; state are provided in gossip sections of heartbeat packets.</source>
          <target state="translated">Узлы в состоянии &lt;code&gt;PFAIL&lt;/code&gt; предоставляются в секциях сплетен пакетов подтверждения .</target>
        </trans-unit>
        <trans-unit id="c02697f1f51c2f137246d46e8911c8e7f53e6636" translate="yes" xml:space="preserve">
          <source>Non existing elements are reported as NULL elements of the array.</source>
          <target state="translated">Несуществующие элементы сообщаются как NULL-элементы массива.</target>
        </trans-unit>
        <trans-unit id="5dfb2fbf84cf8de01a0c2542d485d2207dc976ae" translate="yes" xml:space="preserve">
          <source>Non used lines are blanked. For instance if you used to have multiple &lt;code&gt;save&lt;/code&gt; directives, but the current configuration has fewer or none as you disabled RDB persistence, all the lines will be blanked.</source>
          <target state="translated">Неиспользуемые строки очищаются. Например, если у вас было несколько директив &lt;code&gt;save&lt;/code&gt; , но в текущей конфигурации их меньше или нет, поскольку вы отключили сохранение RDB, все строки будут пустыми.</target>
        </trans-unit>
        <trans-unit id="de44f50198c0734dcccb5b1c5d4825eb72c13aba" translate="yes" xml:space="preserve">
          <source>Non-blocking behavior</source>
          <target state="translated">Блокирующее поведение</target>
        </trans-unit>
        <trans-unit id="5cbfa62b0d0a8a33923d06127db99370a393ad0d" translate="yes" xml:space="preserve">
          <source>Non-blocking usage</source>
          <target state="translated">Неблокирующее использование</target>
        </trans-unit>
        <trans-unit id="bcbbb0c35f64190eb100cd6befa838fbd5037874" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings, so the command will return zero.</source>
          <target state="translated">Несуществующие ключи рассматриваются как пустые строки,поэтому команда вернет ноль.</target>
        </trans-unit>
        <trans-unit id="46b493cea7b65b3003ea2e423707591849b0ee78" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings.</source>
          <target state="translated">Несуществующие ключи рассматриваются как пустые строки.</target>
        </trans-unit>
        <trans-unit id="9a60acaa61d5a344489afdd9e5311dbf8888aa00" translate="yes" xml:space="preserve">
          <source>Normally &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; is simply used in order to get range of items where the score is the indexed integer key, however it is possible to do less obvious things with the command.</source>
          <target state="translated">Обычно &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; просто используется для получения диапазона элементов, где оценка является индексированным целочисленным ключом, однако с помощью команды можно делать менее очевидные вещи.</target>
        </trans-unit>
        <trans-unit id="4dba9f7be4e65fcc1fd8d86533e96e912932e110" translate="yes" xml:space="preserve">
          <source>Normally Redis keys are created without an associated time to live. The key will simply live forever, unless it is removed by the user in an explicit way, for instance using the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; command.</source>
          <target state="translated">Обычно ключи Redis создаются без привязки к времени жизни. Ключ просто будет жить вечно, если он не будет удален пользователем явным образом, например, с помощью команды &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="488e099ce2d3130dde9348d7a491fea120dffc25" translate="yes" xml:space="preserve">
          <source>Normally Redis represents positions of elements using a variation of the Geohash technique where positions are encoded using 52 bit integers. The encoding is also different compared to the standard because the initial min and max coordinates used during the encoding and decoding process are different. This command however &lt;strong&gt;returns a standard Geohash&lt;/strong&gt; in the form of a string as described in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Wikipedia article&lt;/a&gt; and compatible with the &lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; web site.</source>
          <target state="translated">Обычно Redis представляет позиции элементов с использованием разновидности метода Geohash, где позиции кодируются с использованием 52-битных целых чисел. Кодирование также отличается от стандартного, потому что начальные минимальные и максимальные координаты, используемые в процессе кодирования и декодирования, различны. Однако эта команда &lt;strong&gt;возвращает стандартный Geohash&lt;/strong&gt; в виде строки, как описано в &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;статье Википедии&lt;/a&gt; и совместимо с веб-сайтом &lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48fbc2c3360b2ccdab702dc73f1af3fdad88932d" translate="yes" xml:space="preserve">
          <source>Normally hash slots associated to a given node are in one of the following formats, as already explained above:</source>
          <target state="translated">Обычно,как уже объяснялось выше,хэш-слоты,связанные с данным узлом,представлены в одном из следующих форматов:</target>
        </trans-unit>
        <trans-unit id="20da22f8d3c73a214f41394b1c9a9c08c0230154" translate="yes" xml:space="preserve">
          <source>Normally if there is an AOF child process performing an AOF rewrite, Redis will simply kill it and exit. However there are two conditions where it is unsafe to do so, and the &lt;strong&gt;SHUTDOWN&lt;/strong&gt; command will be refused with an error instead. This happens when:</source>
          <target state="translated">Обычно, если есть дочерний процесс AOF, выполняющий перезапись AOF, Redis просто убивает его и завершает работу. Однако есть два условия, при которых это небезопасно, и вместо этого команда &lt;strong&gt;SHUTDOWN&lt;/strong&gt; будет отклонена с ошибкой. Это случается, когда:</target>
        </trans-unit>
        <trans-unit id="f552eaf00c55408f0aa996335bcd91c4da8dcdb7" translate="yes" xml:space="preserve">
          <source>Normally replica nodes will redirect clients to the authoritative master for the hash slot involved in a given command, however clients can use replicas in order to scale reads using the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command.</source>
          <target state="translated">Обычно узлы реплик перенаправляют клиентов к авторитетному мастеру для хэш-слота, задействованного в данной команде, однако клиенты могут использовать реплики для масштабирования &lt;a href=&quot;readonly&quot;&gt;операций&lt;/a&gt; чтения с помощью команды READONLY .</target>
        </trans-unit>
        <trans-unit id="0b040d0fd81d55e920e28d6b8b43687a96fedfb9" translate="yes" xml:space="preserve">
          <source>Normally replicating scripts instead of the effects of the scripts makes sense, however not in all the cases. So starting with Redis 3.2, the scripting engine is able to, alternatively, replicate the sequence of write commands resulting from the script execution, instead of replication the script itself. See the next section for more information. In this section we'll assume that scripts are replicated by sending the whole script. Let's call this replication mode &lt;strong&gt;whole scripts replication&lt;/strong&gt;.</source>
          <target state="translated">Обычно копирование сценариев вместо эффектов сценариев имеет смысл, но не во всех случаях. Таким образом, начиная с Redis 3.2, обработчик сценариев может, в качестве альтернативы, реплицировать последовательность команд записи, возникающую в результате выполнения сценария, вместо репликации самого сценария. См. Следующий раздел для получения дополнительной информации. В этом разделе мы предполагаем, что сценарии реплицируются путем отправки всего сценария. Назовем этот режим репликации репликацией &lt;strong&gt;целых скриптов&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="632bc7f3cbfc39c1e051fc94bc2f5127d08b095a" translate="yes" xml:space="preserve">
          <source>Normally the OK code is immediately returned. Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2018dd71c22fe4b55fd2f381e3bcbd8ea7b844" translate="yes" xml:space="preserve">
          <source>Normally you may think at a Redis stream as an append-only data structure, however Redis streams are represented in memory, so we are able to also delete entries. This may be useful, for instance, in order to comply with certain privacy policies.</source>
          <target state="translated">Обычно вы можете думать в потоке Redis как о структуре данных только для приложений,однако потоки Redis представлены в памяти,поэтому мы также можем удалять записи.Это может быть полезно,например,для соблюдения определенных политик конфиденциальности.</target>
        </trans-unit>
        <trans-unit id="675cc42aab3b45855f7e4f48b1a8a2f9ea1abcdc" translate="yes" xml:space="preserve">
          <source>Normally you use the command like that in order to get new messages and process them. In pseudo-code:</source>
          <target state="translated">Обычно вы используете такую команду,чтобы получать новые сообщения и обрабатывать их.В псевдокоде:</target>
        </trans-unit>
        <trans-unit id="92faf092f64b7750013de7ad70293bed4c22e467" translate="yes" xml:space="preserve">
          <source>Note for Lua newbies: in order to avoid using global variables in your scripts simply declare every variable you are going to use using the &lt;em&gt;local&lt;/em&gt; keyword.</source>
          <target state="translated">Примечание для новичков в Lua: чтобы избежать использования глобальных переменных в ваших скриптах, просто объявите каждую переменную, которую вы собираетесь использовать, с помощью ключевого слова &lt;em&gt;local&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="386ff54d1c33b65d55947a3bc043df349ed6b50a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; all work very similarly, so this documentation covers all the four commands. However an obvious difference is that in the case of &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; the first argument is the name of the key holding the Set, Hash or Sorted Set value. The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command does not need any key name argument as it iterates keys in the current database, so the iterated object is the database itself.</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; , &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; и &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; работают очень похоже, поэтому эта документация охватывает все четыре команды. Однако очевидное различие состоит в том, что в случае &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; и &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; первым аргументом является имя ключа, содержащего значение Set, Hash или Sorted Set. &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; команда не требует ключа имя аргумента , как он перебирает ключи в текущей базе данных, поэтому итерированные объект самой базы данных.</target>
        </trans-unit>
        <trans-unit id="b8af6b6330cf6687e8cc50e67b81c7d7beffd113" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not make Redis a strongly consistent store: while synchronous replication is part of a replicated state machine, it is not the only thing needed. However in the context of Sentinel or Redis Cluster failover, &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; improves the real world data safety.</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; не делает Redis строго согласованным хранилищем: хотя синхронная репликация является частью реплицированного конечного автомата, это не единственное, что необходимо. Однако в контексте аварийного переключения Sentinel или Redis Cluster &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; повышает безопасность данных в реальном мире.</target>
        </trans-unit>
        <trans-unit id="196f50bc6a6ac776d1991175d0001fae97125b81" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; is also available since Redis 3.2.10 and Redis 4.0.0 in order to provide a read-only command that can be used in replicas. See the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; page for more information.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; также доступен, начиная с Redis 3.2.10 и Redis 4.0.0, чтобы предоставить команду только для чтения, которую можно использовать в репликах. См. &lt;a href=&quot;georadius&quot;&gt;Страницу GEORADIUS&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="7f4713a8dfe3582f9f0fc3ed836bf0396dfbd617" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;TAKEOVER violates the last-failover-wins principle&lt;/strong&gt; of Redis Cluster, since the configuration epoch generated by the replica violates the normal generation of configuration epochs in several ways:</source>
          <target state="translated">Обратите внимание, что &lt;strong&gt;TAKEOVER нарушает принцип&lt;/strong&gt; Redis Cluster с &lt;strong&gt;последним отказоустойчивым переключением&lt;/strong&gt; , поскольку эпоха конфигурации, сгенерированная репликой, нарушает нормальную генерацию эпох конфигурации несколькими способами:</target>
        </trans-unit>
        <trans-unit id="b1e5f99b4ded8ce6be23a9f6f9872d3e5595ab46" translate="yes" xml:space="preserve">
          <source>Note that Redis Cluster needs to form a full mesh (each node is connected with each other node), but in order to create a cluster, there is no need to send all the &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; commands needed to form the full mesh. What matter is to send enough &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; messages so that each node can reach each other node through a &lt;em&gt;chain of known nodes&lt;/em&gt;. Thanks to the exchange of gossip information in heartbeat packets, the missing links will be created.</source>
          <target state="translated">Обратите внимание, что Redis Cluster должен формировать полную сетку (каждый узел связан друг с другом узлом), но для создания кластера нет необходимости отправлять все команды &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET,&lt;/a&gt; необходимые для формирования полной сетки. Важно отправить достаточно сообщений &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET,&lt;/a&gt; чтобы каждый узел мог достичь друг друга через &lt;em&gt;цепочку известных узлов&lt;/em&gt; . Благодаря обмену информацией о сплетнях в контрольных пакетах будут созданы недостающие ссылки.</target>
        </trans-unit>
        <trans-unit id="2d97296cb1d6030b84b67b56dc33de3881c08256" translate="yes" xml:space="preserve">
          <source>Note that a script can switch back and forth from RESP3 and RESP2 by calling the function with the argument '3' or '2'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17fc5decb8a235b9d4881b1185aa05ef897a69aa" translate="yes" xml:space="preserve">
          <source>Note that bit positions are returned always as absolute values starting from bit zero even when &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; are used to specify a range.</source>
          <target state="translated">Обратите внимание, что позиции битов всегда возвращаются как абсолютные значения, начиная с нуля, даже если &lt;em&gt;начало&lt;/em&gt; и &lt;em&gt;конец&lt;/em&gt; используются для указания диапазона.</target>
        </trans-unit>
        <trans-unit id="d47127e4277fb6af8f1ec3e041d7aadf84ff3fe6" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;/&lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt; with a non-positive timeout or &lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt;/&lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; with a time in the past will result in the key being &lt;a href=&quot;del&quot;&gt;deleted&lt;/a&gt; rather than expired (accordingly, the emitted &lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;key event&lt;/a&gt; will be &lt;code&gt;del&lt;/code&gt;, not &lt;code&gt;expired&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание , что вызов &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; / &lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt; с неположительным таймом - аутом или &lt;a href=&quot;expireat&quot;&gt;ExpireAt&lt;/a&gt; / &lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; со временем в прошлом приведет к ключевым существам &lt;a href=&quot;del&quot;&gt;удаляется&lt;/a&gt; , а не истекли (соответственно, излучаемое &lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;ключевое событие&lt;/a&gt; станет &lt;code&gt;del&lt;/code&gt; , не &lt;code&gt;expired&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="134cdffcc8cc8242a1731baa707e6b6f212bd203" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;OVERFLOW&lt;/code&gt; statement only affects the &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; commands that follow it in the list of subcommands, up to the next &lt;code&gt;OVERFLOW&lt;/code&gt; statement.</source>
          <target state="translated">Обратите внимание , что каждое &lt;code&gt;OVERFLOW&lt;/code&gt; заявление затрагивает только &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; команды , которые следуют за ней в списке подкомандами, до следующего &lt;code&gt;OVERFLOW&lt;/code&gt; заявления.</target>
        </trans-unit>
        <trans-unit id="c59e6cb007a017cde6a0590f3fe3a6903d02fdbc" translate="yes" xml:space="preserve">
          <source>Note that for correctly implementing this pattern it is important to avoid multiple clients rebuilding the cache at the same time. Some kind of locking is needed here (for instance using &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что для правильной реализации этого шаблона важно избегать одновременного восстановления кеша несколькими клиентами. Здесь нужна какая-то блокировка (например, с помощью &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ab5932614de576b14cea0fbf3d424f67389687d0" translate="yes" xml:space="preserve">
          <source>Note that for the same reason a Lua script or a &lt;code&gt;MULTI/EXEC&lt;/code&gt; block may push elements into a list and afterward &lt;strong&gt;delete the list&lt;/strong&gt;. In this case the blocked clients will not be served at all and will continue to be blocked as long as no data is present on the list after the execution of a single command, transaction, or script.</source>
          <target state="translated">Обратите внимание, что по той же причине сценарий Lua или блок &lt;code&gt;MULTI/EXEC&lt;/code&gt; могут помещать элементы в список, а затем &lt;strong&gt;удалять список&lt;/strong&gt; . В этом случае заблокированные клиенты не будут обслуживаться вообще и будут продолжать блокироваться до тех пор, пока в списке нет данных после выполнения одной команды, транзакции или сценария.</target>
        </trans-unit>
        <trans-unit id="fcc828a00ba6196c133772751828406df7944657" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">Обратите внимание, что если реплика добавляется, перемещается или удаляется с данного главного узла, и мы запрашиваем &lt;a href=&quot;cluster-replicas&quot;&gt;КЛАСТЕРНЫЕ РЕПЛИКИ&lt;/a&gt; на узел, который еще не получил обновление конфигурации, он может показать устаревшую информацию. Однако в конечном итоге (в течение нескольких секунд, если нет сетевых разделов) все узлы согласятся о наборе узлов, связанных с данным мастером.</target>
        </trans-unit>
        <trans-unit id="21094e1f69e7fc1828b555fe35532f052b5ac245" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">Обратите внимание: если реплика добавляется, перемещается или удаляется с данного главного узла, и мы запрашиваем &lt;a href=&quot;cluster-slaves&quot;&gt;КЛАСТЕРНЫЕ ВЕДОМЫЕ&lt;/a&gt; у узла, который еще не получил обновление конфигурации, он может показать устаревшую информацию. Однако в конечном итоге (в течение нескольких секунд, если нет сетевых разделов) все узлы согласятся о наборе узлов, связанных с данным мастером.</target>
        </trans-unit>
        <trans-unit id="92bc3cdf3318fb930ded8c852b6a00267accad1a" translate="yes" xml:space="preserve">
          <source>Note that if you have a list of numbers from 0 to 100, &lt;code&gt;LRANGE list 0 10&lt;/code&gt; will return 11 elements, that is, the rightmost item is included. This &lt;strong&gt;may or may not&lt;/strong&gt; be consistent with behavior of range-related functions in your programming language of choice (think Ruby's &lt;code&gt;Range.new&lt;/code&gt;, &lt;code&gt;Array#slice&lt;/code&gt; or Python's &lt;code&gt;range()&lt;/code&gt; function).</source>
          <target state="translated">Обратите внимание, что если у вас есть список чисел от 0 до 100, &lt;code&gt;LRANGE list 0 10&lt;/code&gt; вернет 11 элементов, то есть будет включен самый правый элемент. Это &lt;strong&gt;может или не&lt;/strong&gt; может согласовываться с поведением функций, связанных с диапазоном, на выбранном вами языке программирования (подумайте о Ruby &lt;code&gt;Range.new&lt;/code&gt; , &lt;code&gt;Array#slice&lt;/code&gt; или функции Python &lt;code&gt;range()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b145f3c9b171e7c40ecd23d7161660cea0ebde1c" translate="yes" xml:space="preserve">
          <source>Note that it is valid to call this command without channels. In this case it will just return an empty list.</source>
          <target state="translated">Обратите внимание,что можно вызывать эту команду и без каналов.В этом случае она просто вернет пустой список.</target>
        </trans-unit>
        <trans-unit id="7cbc0087feeeb4b8394154849c8ec33aeb518c13" translate="yes" xml:space="preserve">
          <source>Note that non-existing keys are treated like empty lists, so when &lt;code&gt;key&lt;/code&gt; does not exist, the command will always return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что несуществующие ключи обрабатываются как пустые списки, поэтому, когда &lt;code&gt;key&lt;/code&gt; не существует, команда всегда будет возвращать &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e83de8fca6610aa183e7aad22115791cd55bc9fb" translate="yes" xml:space="preserve">
          <source>Note that normally clients willing to fetch the map between Cluster hash slots and node addresses should use &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; instead. &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;, that provides more information, should be used for administrative tasks, debugging, and configuration inspections. It is also used by &lt;code&gt;redis-trib&lt;/code&gt; in order to manage a cluster.</source>
          <target state="translated">Обратите внимание, что обычно клиенты, желающие получить карту между хэш-слотами кластера и адресами узлов, должны вместо этого использовать &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; . &lt;a href=&quot;cluster-nodes&quot;&gt;КЛАСТЕРНЫЕ УЗЛЫ&lt;/a&gt; , которые предоставляют больше информации, следует использовать для административных задач, отладки и проверки конфигурации. Он также используется &lt;code&gt;redis-trib&lt;/code&gt; для управления кластером.</target>
        </trans-unit>
        <trans-unit id="1f6b2fdffdf326f5f641aa170f10beb1a26d5924" translate="yes" xml:space="preserve">
          <source>Note that once a node assigns a set of slots to itself, it will start propagating this information in heartbeat packet headers. However the other nodes will accept the information only if they have the slot as not already bound with another node, or if the configuration epoch of the node advertising the new hash slot, is greater than the node currently listed in the table.</source>
          <target state="translated">Обратите внимание,что как только узел назначит себе набор слотов,он начнет распространять эту информацию в заголовках пульсирующих пакетов.Однако другие узлы будут принимать информацию только в том случае,если у них есть слот,который ещё не связан с другим узлом,или если эпоха конфигурации узла,рекламирующего новый слот для хэшей,больше,чем узел,перечисленный в настоящее время в таблице.</target>
        </trans-unit>
        <trans-unit id="34efcb15ecc544550f9bd4f238eeb1c37bfe6eb5" translate="yes" xml:space="preserve">
          <source>Note that the command implements the full hashing algorithm, including support for &lt;strong&gt;hash tags&lt;/strong&gt;, that is the special property of Redis Cluster key hashing algorithm, of hashing just what is between &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; if such a pattern is found inside the key name, in order to force multiple keys to be handled by the same node.</source>
          <target state="translated">Обратите внимание, что команда реализует полный алгоритм хеширования, включая поддержку &lt;strong&gt;хэш-тегов&lt;/strong&gt; , что является специальным свойством алгоритма хеширования ключей Redis Cluster, хеширования только того, что находится между &lt;code&gt;{&lt;/code&gt; и &lt;code&gt;}&lt;/code&gt; , если такой шаблон найден внутри имени ключа, по порядку чтобы заставить несколько ключей обрабатываться одним и тем же узлом.</target>
        </trans-unit>
        <trans-unit id="44319adff6c7cf60df65ef2f592ee1b07d9db575" translate="yes" xml:space="preserve">
          <source>Note that the format does not have any space, so &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output format is plain CSV with space as separator even when this special slots are emitted. However a complete parser for the format should be able to handle them.</source>
          <target state="translated">Обратите внимание, что в этом формате нет пробелов, поэтому выходной формат &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; - это простой CSV с пробелом в качестве разделителя, даже если эти специальные слоты выбрасываются. Однако полный синтаксический анализатор формата должен уметь их обрабатывать.</target>
        </trans-unit>
        <trans-unit id="277c523b6a84e71c0289aa21eae881f107096f52" translate="yes" xml:space="preserve">
          <source>Note that the indexes are still reported in the &quot;natural&quot; way, that is, considering the first element starting from the head of the list at index 0, the next element at index 1, and so forth. This basically means that the returned indexes are stable whatever the rank is positive or negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf3d39f27c1b799248d5e59a73b1a5b0f086afd" translate="yes" xml:space="preserve">
          <source>Note that the maximum offset that you can set is 2&lt;sup&gt;29&lt;/sup&gt; -1 (536870911), as Redis Strings are limited to 512 megabytes. If you need to grow beyond this size, you can use multiple keys.</source>
          <target state="translated">Обратите внимание, что максимальное смещение, которое вы можете установить, составляет 2 &lt;sup&gt;29&lt;/sup&gt; -1 (536870911), так как Redis Strings ограничены 512 мегабайтами. Если вам нужно выйти за пределы этого размера, вы можете использовать несколько ключей.</target>
        </trans-unit>
        <trans-unit id="365b9132d09f3318597589e9536ca42a38461cb4" translate="yes" xml:space="preserve">
          <source>Note that the message is claimed only if its idle time is greater the minimum idle time we specify when calling &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;. Because as a side effect &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will also reset the idle time (since this is a new attempt at processing the message), two consumers trying to claim a message at the same time will never both succeed: only one will successfully claim the message. This avoids that we process a given message multiple times in a trivial way (yet multiple processing is possible and unavoidable in the general case).</source>
          <target state="translated">Обратите внимание, что сообщение &lt;a href=&quot;xclaim&quot;&gt;запрашивается,&lt;/a&gt; только если его время простоя больше минимального времени простоя, которое мы указываем при вызове XCLAIM . Поскольку в качестве побочного эффекта &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; также сбрасывает время простоя (поскольку это новая попытка обработки сообщения), два потребителя, пытающиеся запросить сообщение одновременно, никогда не будут успешными: только один успешно запросит сообщение. Это позволяет избежать того, чтобы мы обрабатывали данное сообщение несколько раз тривиальным способом (хотя в общем случае множественная обработка возможна и неизбежна).</target>
        </trans-unit>
        <trans-unit id="dbbe3c8e1b4fe3c7e220f023943635e1ebf82c17" translate="yes" xml:space="preserve">
          <source>Note that this algorithm runs in &lt;code&gt;O(N*M)&lt;/code&gt; time, where N is the length of the first string and M is the length of the second string. So either spin a different Redis instance in order to run this algorithm, or make sure to run it against very small strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900544e94991ba5defea5df80a0dccc1aa474e00" translate="yes" xml:space="preserve">
          <source>Note that this command is not suitable when you need a guaranteed uniform distribution of the returned elements. For more information about the algorithms used for &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt;, look up both the Knuth sampling and Floyd sampling algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581b6da11286a19b84f5dbf7d26c9c4e1e18433c" translate="yes" xml:space="preserve">
          <source>Note that this command is not suitable when you need a guaranteed uniform distribution of the returned elements. For more information about the algorithms used for SPOP, look up both the Knuth sampling and Floyd sampling algorithms.</source>
          <target state="translated">Обратите внимание,что эта команда не подходит,когда требуется гарантированное равномерное распределение возвращаемых элементов.Для получения более подробной информации об алгоритмах,используемых для SPOP,посмотрите как на алгоритмы Knuth sampling,так и Floyd sampling.</target>
        </trans-unit>
        <trans-unit id="7aae41763fe9b0bc6731024cb063283c77ec4608" translate="yes" xml:space="preserve">
          <source>Note that this implementation of workers is trivially scalable and reliable, because even if a message is lost the item is still in the queue and will be processed at the next iteration.</source>
          <target state="translated">Обратите внимание,что эта реализация рабочих тривиально масштабируема и надежна,так как даже если сообщение потеряно,элемент все равно находится в очереди и будет обработан на следующей итерации.</target>
        </trans-unit>
        <trans-unit id="de6800f82ca82bf510c822b7935a67d6ca2bf21c" translate="yes" xml:space="preserve">
          <source>Note that we have a race here, but it is not a problem: &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; may return false but the key may be created by another client before we create it inside the &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block. However this race will just miss an API call under rare conditions, so the rate limiting will still work correctly.</source>
          <target state="translated">Обратите внимание, что у нас здесь гонка, но это не проблема: &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; может вернуть false, но ключ может быть создан другим клиентом до того, как мы создадим его внутри блока &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; . Однако эта гонка просто пропустит вызов API в редких случаях, поэтому ограничение скорости по-прежнему будет работать правильно.</target>
        </trans-unit>
        <trans-unit id="290162572eb7adbad822a4117dca945c127babde" translate="yes" xml:space="preserve">
          <source>Note that you need a recent version of redis-cli in order to read the slow log output, since it uses some features of the protocol that were not formerly implemented in redis-cli (deeply nested multi bulk replies).</source>
          <target state="translated">Обратите внимание,что вам нужна последняя версия redis-cli,чтобы читать медленный лог-выход,так как она использует некоторые возможности протокола,которые ранее не были реализованы в redis-cli (глубоко вложенные многопараметрические ответы).</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">Обратите внимание:</target>
        </trans-unit>
        <trans-unit id="851be398fabf2219f9c3aa64609a72f0559cc785" translate="yes" xml:space="preserve">
          <source>Note the used of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; in order to make sure that we'll both increment and set the expire at every API call.</source>
          <target state="translated">Обратите внимание на использование &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; и &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; , чтобы убедиться, что мы увеличиваем и устанавливаем срок действия при каждом вызове API.</target>
        </trans-unit>
        <trans-unit id="0ab5850865b49bbe39f155ec6e364488933508f0" translate="yes" xml:space="preserve">
          <source>Note this rule is not enforced in order to provide the user with opportunities to abuse the Redis single instance configuration, at the cost of writing scripts not compatible with Redis Cluster.</source>
          <target state="translated">Обратите внимание,что это правило не применяется для того,чтобы предоставить пользователю возможность злоупотреблять конфигурацией одного экземпляра Redis,за счет написания сценариев,несовместимых с Redis Cluster.</target>
        </trans-unit>
        <trans-unit id="9dfbcfbbaf119bccc3c44b098de0573996677b97" translate="yes" xml:space="preserve">
          <source>Note: A Redis instance that is configured for not persisting on disk (no AOF configured, nor &quot;save&quot; directive) will not dump the RDB file on &lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN&lt;/a&gt;, as usually you don't want Redis instances used only for caching to block on when shutting down.</source>
          <target state="translated">Примечание. Экземпляр Redis, который настроен так, чтобы не сохраняться на диске (не настроен AOF или директива &amp;laquo;save&amp;raquo;), не будет сбрасывать файл RDB при &lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN&lt;/a&gt; , поскольку обычно вы не хотите, чтобы экземпляры Redis, используемые только для кеширования, блокировались, когда Выключение.</target>
        </trans-unit>
        <trans-unit id="4ffe4a3dcb4982dba6203770d54b7b49b3ebdb4a" translate="yes" xml:space="preserve">
          <source>Note: Since the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command options can replace &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;, &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;, &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e3fa9c72775db4fd05d5cf7a3a493e93afca05" translate="yes" xml:space="preserve">
          <source>Note: Since the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command options can replace &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;, &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.</source>
          <target state="translated">Примечание. Поскольку параметры команды &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; могут заменять &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; , &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt; , &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt; , возможно, что в будущих версиях Redis эти три команды будут устаревшими и окончательно удалены.</target>
        </trans-unit>
        <trans-unit id="81129f6603906deb00ee7e872ec230ada40b4ee1" translate="yes" xml:space="preserve">
          <source>Note: The &lt;strong&gt;GT&lt;/strong&gt;, &lt;strong&gt;LT&lt;/strong&gt; and &lt;strong&gt;NX&lt;/strong&gt; options are mutually exclusive.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
