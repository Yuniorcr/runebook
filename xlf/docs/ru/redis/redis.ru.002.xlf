<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="c687d1b70c080536289366ba8155bc643fc72076" translate="yes" xml:space="preserve">
          <source>Exclusive intervals and infinity</source>
          <target state="translated">Эксклюзивные интервалы и бесконечность</target>
        </trans-unit>
        <trans-unit id="8e788d736a6e3a42271b3b6edc6a324f07e11667" translate="yes" xml:space="preserve">
          <source>Executed scripts are guaranteed to be in the script cache of a given execution of a Redis instance forever. This means that if an &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is performed against a Redis instance all the subsequent &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; calls will succeed.</source>
          <target state="translated">Выполненные сценарии гарантированно навсегда останутся в кеше сценариев данного выполнения экземпляра Redis. Это означает, что если &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; выполняется для экземпляра Redis, все последующие вызовы &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; будут успешными.</target>
        </trans-unit>
        <trans-unit id="446763d77e17832a47ad829663f2f4ba29ce76f7" translate="yes" xml:space="preserve">
          <source>Executes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">Выполняет все ранее поставленные в очередь команды в &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;транзакции&lt;/a&gt; и восстанавливает нормальное состояние соединения.</target>
        </trans-unit>
        <trans-unit id="d80b1a46f6734fb75c0119610c9901aef0c08607" translate="yes" xml:space="preserve">
          <source>Executing a Lua Script with Redis 2.6 or newer.</source>
          <target state="translated">Выполнение скрипта Lua с Redis 2.6 или новее.</target>
        </trans-unit>
        <trans-unit id="e1a9d983dc0912bcd36f098a1b8c4b6851a2ccbc" translate="yes" xml:space="preserve">
          <source>Expire accuracy</source>
          <target state="translated">Точность истечения срока годности</target>
        </trans-unit>
        <trans-unit id="5bbbfc0dcb3f1ea6203152c364bf711f30071354" translate="yes" xml:space="preserve">
          <source>Expires and persistence</source>
          <target state="translated">Истечение срока годности и настойчивость</target>
        </trans-unit>
        <trans-unit id="ceae3e065a822da58b9dd577a4a2215264628a2c" translate="yes" xml:space="preserve">
          <source>FLUSHALL</source>
          <target state="translated">FLUSHALL</target>
        </trans-unit>
        <trans-unit id="a1dc7fedbb3161c8d2db024cd3ee46e2af26f812" translate="yes" xml:space="preserve">
          <source>FLUSHALL  [ASYNC]   Remove all keys from all databases</source>
          <target state="translated">FLUSHALL [ASYNC]Удалить все ключи из всех баз данных.</target>
        </trans-unit>
        <trans-unit id="10bb3c2c2d36018ba538d533264f2171634a8d95" translate="yes" xml:space="preserve">
          <source>FLUSHDB</source>
          <target state="translated">FLUSHDB</target>
        </trans-unit>
        <trans-unit id="b40b961b1c26ac58fbd9ac2f12f0c446fb2897d9" translate="yes" xml:space="preserve">
          <source>FLUSHDB  [ASYNC]   Remove all keys from the current database</source>
          <target state="translated">FLUSHDB [ASYNC]Удалить все ключи из текущей базы данных.</target>
        </trans-unit>
        <trans-unit id="a5f0b2c20a29e7587597abea3e79fa609ca01e4c" translate="yes" xml:space="preserve">
          <source>FORCE option: manual failover when the master is down</source>
          <target state="translated">Опция FORCE:ручное переключение при отказе ведущего устройства.</target>
        </trans-unit>
        <trans-unit id="4a0878bdd16e36ba72b474afe51ae9c582fef6d5" translate="yes" xml:space="preserve">
          <source>Fetching a single entry from a stream, providing the ID of the entry to fetch two times: as start and end of the query interval.</source>
          <target state="translated">Захват одной записи из потока,предоставляя идентификатор записи для получения два раза:как начало и конец интервала запроса.</target>
        </trans-unit>
        <trans-unit id="d11485369737f36370f75a3ff43b46d72effc624" translate="yes" xml:space="preserve">
          <source>Fetching data from a stream via a consumer group, and not acknowledging such data, has the effect of creating &lt;em&gt;pending entries&lt;/em&gt;. This is well explained in the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command, and even better in our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. The &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command will immediately remove the pending entry from the Pending Entry List (PEL) since once a message is successfully processed, there is no longer need for the consumer group to track it and to remember the current owner of the message.</source>
          <target state="translated">Получение данных из потока через группу потребителей без подтверждения таких данных приводит к созданию &lt;em&gt;ожидающих записей&lt;/em&gt; . Это хорошо объясняется в команде &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; и даже лучше в нашем &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;введении в Redis Streams&lt;/a&gt; . Команда &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; немедленно удалит ожидающую запись из списка ожидающих записей (PEL), поскольку после успешной обработки сообщения группе потребителей больше не нужно отслеживать его и запоминать текущего владельца сообщения.</target>
        </trans-unit>
        <trans-unit id="13b9c9d38a4b96f103ca63910ffc56743e00fd12" translate="yes" xml:space="preserve">
          <source>Fetching single items</source>
          <target state="translated">Приобретение отдельных предметов</target>
        </trans-unit>
        <trans-unit id="8330be22b4e169fe5141dfbcacb82dc81724e13f" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get help from the command, in case the user can't remember the exact syntax, by using the &lt;code&gt;HELP&lt;/code&gt; subcommnad:</source>
          <target state="translated">Наконец, можно получить помощь от команды, если пользователь не может вспомнить точный синтаксис, с помощью подкоманды &lt;code&gt;HELP&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5388f4a7abea666722d4311743c9d3e1d5bfc3b1" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get the list of every consumer in a specific consumer group:</source>
          <target state="translated">Наконец,можно получить список каждого потребителя в определенной группе:</target>
        </trans-unit>
        <trans-unit id="7cbe1b741345fc3839fb4d58149e9dd7af6c272a" translate="yes" xml:space="preserve">
          <source>Finally it is possible to pass an additional argument to the command, in order to see the messages having a specific owner:</source>
          <target state="translated">Наконец,можно передать дополнительный аргумент команде,чтобы увидеть сообщения с определенным владельцем:</target>
        </trans-unit>
        <trans-unit id="58b2c6378bac42febc100a9e0341d2094c29e52e" translate="yes" xml:space="preserve">
          <source>Finally it possible to set the next message to deliver using the &lt;code&gt;SETID&lt;/code&gt; subcommand. Normally the next ID is set when the consumer is created, as the last argument of &lt;code&gt;XGROUP CREATE&lt;/code&gt;. However using this form the next ID can be modified later without deleting and creating the consumer group again. For instance if you want the consumers in a consumer group to re-process all the messages in a stream, you may want to set its next ID to 0:</source>
          <target state="translated">Наконец, можно настроить доставку следующего сообщения с помощью подкоманды &lt;code&gt;SETID&lt;/code&gt; . Обычно следующий идентификатор устанавливается при создании потребителя в качестве последнего аргумента &lt;code&gt;XGROUP CREATE&lt;/code&gt; . Однако с помощью этой формы следующий идентификатор можно изменить позже без повторного удаления и создания группы потребителей. Например, если вы хотите, чтобы потребители в группе потребителей повторно обрабатывали все сообщения в потоке, вы можете установить для его следующего идентификатора значение 0:</target>
        </trans-unit>
        <trans-unit id="8081b937f79256e42e7fd856b20cf39a90419c3e" translate="yes" xml:space="preserve">
          <source>Finally to get some help if you don't remember the syntax, use the HELP subcommand:</source>
          <target state="translated">Наконец,чтобы получить помощь,если вы не помните синтаксис,используйте подкоманду HELP:</target>
        </trans-unit>
        <trans-unit id="fc63c9b0ba92886f08fc9cdd2dca430983266b7e" translate="yes" xml:space="preserve">
          <source>First Key in Argument List</source>
          <target state="translated">Первый ключ в списке аргументов</target>
        </trans-unit>
        <trans-unit id="a8e315abf463cfb1c344b54fca5c387403cc9c5a" translate="yes" xml:space="preserve">
          <source>First replica of master for slot range</source>
          <target state="translated">Первая реплика мастера для слот-диапазона</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="4e0b6894626b05a7f879581f17814069cc8b9e6d" translate="yes" xml:space="preserve">
          <source>Flush the Append Only File if AOF is enabled.</source>
          <target state="translated">Промойте файл только для приложений,если включена функция AOF.</target>
        </trans-unit>
        <trans-unit id="3b424754326ab3315277697bc94804652181fadd" translate="yes" xml:space="preserve">
          <source>Flush the Lua scripts cache.</source>
          <target state="translated">Промой кэш сценариев Луа.</target>
        </trans-unit>
        <trans-unit id="f6bb844e2e06d69091cb567be5df64888a2d1098" translate="yes" xml:space="preserve">
          <source>Flushes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">Сбрасывает все ранее поставленные в очередь команды в &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;транзакции&lt;/a&gt; и восстанавливает нормальное состояние соединения.</target>
        </trans-unit>
        <trans-unit id="8c64c01f5213c6c086d3f83c900e781d98a8b4d5" translate="yes" xml:space="preserve">
          <source>Flushes all the previously watched keys for a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">Сбрасывает все ранее просмотренные ключи для &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;транзакции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e859a22c051906372e6ed21806faadd4fdf27b1c" translate="yes" xml:space="preserve">
          <source>For Redis 2.6 what happens is that the command performing multiple pushes is executed, and &lt;em&gt;only after&lt;/em&gt; the execution of the command the blocked clients are served. Consider this sequence of commands.</source>
          <target state="translated">Для Redis 2.6 происходит то, что выполняется команда, выполняющая несколько нажатий, и &lt;em&gt;только после&lt;/em&gt; выполнения команды обслуживаются заблокированные клиенты. Рассмотрим эту последовательность команд.</target>
        </trans-unit>
        <trans-unit id="c9543ba9d8e4550fc68513216cde163b99c314dc" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;WEIGHTS&lt;/code&gt; and &lt;code&gt;AGGREGATE&lt;/code&gt; options, see &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;.</source>
          <target state="translated">Для описания &lt;code&gt;WEIGHTS&lt;/code&gt; и &lt;code&gt;AGGREGATE&lt;/code&gt; параметров см &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9618151d729f751e6074523159514ecdfdb57ef1" translate="yes" xml:space="preserve">
          <source>For an introduction to HyperLogLog data structure check the &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; command page.</source>
          <target state="translated">Чтобы получить представление о структуре данных &lt;a href=&quot;pfcount&quot;&gt;HyperLogLog, посетите&lt;/a&gt; страницу команды PFCOUNT .</target>
        </trans-unit>
        <trans-unit id="6fcc6360d01cc6597619a76bd12e34dfa8c068d5" translate="yes" xml:space="preserve">
          <source>For an introduction to sorted sets, see the data types page on &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted sets&lt;/a&gt;.</source>
          <target state="translated">Для ознакомления с отсортированными наборами см. Страницу типов данных о &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;отсортированных наборах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e36005d4ed916277f75df55af354619d0ef5d5b" translate="yes" xml:space="preserve">
          <source>For each command type, the following line is added:</source>
          <target state="translated">Для каждого типа команды добавляется следующая строка:</target>
        </trans-unit>
        <trans-unit id="e6d8b4b7b9b4f1b118134e1b85eed9b0b1555262" translate="yes" xml:space="preserve">
          <source>For each consumer group listed the command also shows the number of consumers known in that group and the pending messages (delivered but not yet acknowledged) in that group.</source>
          <target state="translated">Для каждой перечисленной группы потребителей команда также показывает количество потребителей,известных в этой группе,и ожидающих сообщений (доставленных,но еще не подтвержденных)в этой группе.</target>
        </trans-unit>
        <trans-unit id="2f01796f139a1dd83db65e8858f0ea9b62d77fdf" translate="yes" xml:space="preserve">
          <source>For each database, the following line is added:</source>
          <target state="translated">Для каждой базы данных добавляется следующая строка:</target>
        </trans-unit>
        <trans-unit id="0553e67e4dc3e5df5405dbaf017a41c48cd92358" translate="yes" xml:space="preserve">
          <source>For each replica, the following line is added:</source>
          <target state="translated">Для каждой копии добавляется следующая строка:</target>
        </trans-unit>
        <trans-unit id="4121db15148ef3ce1e89f4557d512e7c05a4cd89" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;field&lt;/code&gt; that does not exist in the hash, a &lt;code&gt;nil&lt;/code&gt; value is returned. Because non-existing keys are treated as empty hashes, running &lt;a href=&quot;hmget&quot;&gt;HMGET&lt;/a&gt; against a non-existing &lt;code&gt;key&lt;/code&gt; will return a list of &lt;code&gt;nil&lt;/code&gt; values.</source>
          <target state="translated">Для каждого &lt;code&gt;field&lt;/code&gt; , которого нет в хэше, возвращается &lt;code&gt;nil&lt;/code&gt; значение. Поскольку несуществующие ключи обрабатываются как пустые хэши, запуск &lt;a href=&quot;hmget&quot;&gt;HMGET&lt;/a&gt; для несуществующего &lt;code&gt;key&lt;/code&gt; вернет список &lt;code&gt;nil&lt;/code&gt; значений.</target>
        </trans-unit>
        <trans-unit id="910c18521d782016253b4584c3c1718149e1c25d" translate="yes" xml:space="preserve">
          <source>For example a common problem when implementing Markov chains and other algorithms is to select an element at random from a set, but different elements may have different weights that change how likely it is they are picked.</source>
          <target state="translated">Например,общая проблема при реализации цепочек Маркова и других алгоритмов заключается в случайном выборе элемента из множества,но разные элементы могут иметь разные веса,которые меняют вероятность того,что они будут выбраны.</target>
        </trans-unit>
        <trans-unit id="00e8032c1c0863c866e402146d15139ddaca7eea" translate="yes" xml:space="preserve">
          <source>For example in order to take the count of all the unique search queries performed in a day, a program needs to call &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; every time a query is processed. The estimated number of unique queries can be retrieved with &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; at any time.</source>
          <target state="translated">Например, чтобы подсчитать все уникальные поисковые запросы, выполненные за день, программе необходимо вызывать &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; каждый раз, когда запрос обрабатывается. Приблизительное количество уникальных запросов можно получить с помощью &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; в любое время.</target>
        </trans-unit>
        <trans-unit id="862ca7fa622c308433f665edc841f44e39e5d232" translate="yes" xml:space="preserve">
          <source>For example the following command assigns slots 1 2 3 to the node receiving the command:</source>
          <target state="translated">Например,следующая команда присваивает узлу,принимающему команду,слоты 1 2 3:</target>
        </trans-unit>
        <trans-unit id="b525686b0a28b28e11781b09afa87dd48c9db63b" translate="yes" xml:space="preserve">
          <source>For example the following command increments an 8 bit signed integer at bit offset 100, and gets the value of the 4 bit unsigned integer at bit offset 0:</source>
          <target state="translated">Например,следующая команда увеличивает 8-битное подписанное целое число при смещении бита 100 и получает значение 4-битного неподписанного целого при смещении бита 0:</target>
        </trans-unit>
        <trans-unit id="a97e5209e5c4a8fe8fdeedf84b0123aa8fa78b8b" translate="yes" xml:space="preserve">
          <source>For example the following command will trim the stream to exactly the latest 1000 items:</source>
          <target state="translated">Например,следующая команда обрезает поток точно до последних 1000 элементов:</target>
        </trans-unit>
        <trans-unit id="bb5422e2190f7f64ad2cf5faf5279a8730064c02" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; will remove the last two occurrences of &lt;code&gt;&quot;hello&quot;&lt;/code&gt; in the list stored at &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">Например, &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; удалит два последних вхождения слова &lt;code&gt;&quot;hello&quot;&lt;/code&gt; из списка, хранящегося в &lt;code&gt;list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b555dc3155500027017fa2a4b40d9e13b0289813" translate="yes" xml:space="preserve">
          <source>For example, if I have two streams &lt;code&gt;mystream&lt;/code&gt; and &lt;code&gt;writers&lt;/code&gt;, and I want to read data from both the streams starting from the first element they contain, I could call &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; like in the following example.</source>
          <target state="translated">Например, если у меня есть два потока, &lt;code&gt;mystream&lt;/code&gt; и &lt;code&gt;writers&lt;/code&gt; , и я хочу читать данные из обоих потоков, начиная с первого содержащегося в них элемента, я мог бы вызвать &lt;a href=&quot;xread&quot;&gt;XREAD,&lt;/a&gt; как в следующем примере.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="d36a4d27e7c4e26652f2b3ff43e697bb99cdbe49" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; will modify the list stored at &lt;code&gt;foobar&lt;/code&gt; so that only the first three elements of the list will remain.</source>
          <target state="translated">Например: &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; изменит список, хранящийся в &lt;code&gt;foobar&lt;/code&gt; , так, что останутся только первые три элемента списка.</target>
        </trans-unit>
        <trans-unit id="aac3daaf191be281b6ccb464e390234af5058fcd" translate="yes" xml:space="preserve">
          <source>For example: consider &lt;code&gt;source&lt;/code&gt; holding the list &lt;code&gt;a,b,c&lt;/code&gt;, and &lt;code&gt;destination&lt;/code&gt; holding the list &lt;code&gt;x,y,z&lt;/code&gt;. Executing &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; results in &lt;code&gt;source&lt;/code&gt; holding &lt;code&gt;a,b&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; holding &lt;code&gt;c,x,y,z&lt;/code&gt;.</source>
          <target state="translated">Например: рассмотрим &lt;code&gt;source&lt;/code&gt; содержащий список &lt;code&gt;a,b,c&lt;/code&gt; , и &lt;code&gt;destination&lt;/code&gt; содержащий список &lt;code&gt;x,y,z&lt;/code&gt; . Исполнительные &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; результаты в &lt;code&gt;source&lt;/code&gt; , держась за &lt;code&gt;a,b&lt;/code&gt; и &lt;code&gt;destination&lt;/code&gt; проведение &lt;code&gt;c,x,y,z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9a6b3077ebbc22869bdfb44c11c89f9170d1471" translate="yes" xml:space="preserve">
          <source>For expires to work well, the computer time must be taken stable. If you move an RDB file from two computers with a big desync in their clocks, funny things may happen (like all the keys loaded to be expired at loading time).</source>
          <target state="translated">Для того,чтобы истечение срока годности заработало хорошо,компьютерное время должно быть стабильным.Если переместить RDB-файл с двух компьютеров с большим десинхронизатором в часах,могут произойти забавные вещи (как все загруженные ключи,срок действия которых истекает во время загрузки).</target>
        </trans-unit>
        <trans-unit id="f28bf0b4c581b256fa3b954009c5dc47ca8cc986" translate="yes" xml:space="preserve">
          <source>For further information about Redis streams please check our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams document&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации о потоках Redis ознакомьтесь с нашим &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;введением в документ Redis Streams&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9419f194b12efba96ec9e9a8a47640ef77051d15" translate="yes" xml:space="preserve">
          <source>For instance an application with a persistent connection to Redis can be sure that if a script was sent once it is still in memory, so EVALSHA can be used against those scripts in a pipeline without the chance of an error being generated due to an unknown script (we'll see this problem in detail later).</source>
          <target state="translated">Например,приложение с постоянным соединением с Redis может быть уверено,что если скрипт был отправлен,когда он еще находится в памяти,то EVALSHA может быть использована против этих скриптов в конвейере без шансов на генерацию ошибки из-за неизвестного скрипта (мы увидим эту проблему подробнее позже).</target>
        </trans-unit>
        <trans-unit id="dc915bb7cfa9bbec54b9f20262e4f69d0c2936e5" translate="yes" xml:space="preserve">
          <source>For instance in the above example, the last items that we received for the stream &lt;code&gt;mystream&lt;/code&gt; has ID &lt;code&gt;1526999352406-0&lt;/code&gt;, while for the stream &lt;code&gt;writers&lt;/code&gt; has the ID &lt;code&gt;1526985685298-0&lt;/code&gt;.</source>
          <target state="translated">Например , в приведенном выше примере, последние элементы , которые мы получили для потока &lt;code&gt;mystream&lt;/code&gt; имеет идентификатор &lt;code&gt;1526999352406-0&lt;/code&gt; , в то время как для потока &lt;code&gt;writers&lt;/code&gt; имеет идентификатор &lt;code&gt;1526985685298-0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abfec42c58b79c70de1796787342d5de058e9f11" translate="yes" xml:space="preserve">
          <source>For instance what in &lt;code&gt;redis.conf&lt;/code&gt; looks like:</source>
          <target state="translated">Например, как выглядит в &lt;code&gt;redis.conf&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="310775bb715bff8a1231237bf82d220b152e2252" translate="yes" xml:space="preserve">
          <source>For instance when Redis is used in order to implement a queue, producers and consumers of messages may want to set the name of the connection according to their role.</source>
          <target state="translated">Например,когда Redis используется для реализации очереди,производители и потребители сообщений могут захотеть установить имя соединения в соответствии со своей ролью.</target>
        </trans-unit>
        <trans-unit id="4d1d2a650d31219d2da12b4e4c6aaa52db811850" translate="yes" xml:space="preserve">
          <source>For most commands the first key is position 1. Position 0 is always the command name itself.</source>
          <target state="translated">Для большинства команд первой клавишей является позиция 1.Позиция 0 всегда является именем самой команды.</target>
        </trans-unit>
        <trans-unit id="f3b735d69f1d53bb920c323089af35c7960cd5bc" translate="yes" xml:space="preserve">
          <source>For nested data types, the optional &lt;code&gt;SAMPLES&lt;/code&gt; option can be provided, where &lt;code&gt;count&lt;/code&gt; is the number of sampled nested values. By default, this option is set to &lt;code&gt;5&lt;/code&gt;. To sample the all of the nested values, use &lt;code&gt;SAMPLES 0&lt;/code&gt;.</source>
          <target state="translated">Для вложенных типов данных может быть предоставлена необязательная опция &lt;code&gt;SAMPLES&lt;/code&gt; , где &lt;code&gt;count&lt;/code&gt; - количество выбранных вложенных значений. По умолчанию для этого параметра установлено значение &lt;code&gt;5&lt;/code&gt; . Чтобы выбрать все вложенные значения, используйте &lt;code&gt;SAMPLES 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29cc98c67031f5feb4c8c0734d6bcf119180ebd0" translate="yes" xml:space="preserve">
          <source>For real-time metrics and statistics involving large inputs a good approach is to use a replica (with read-only option disabled) where the bit-wise operations are performed to avoid blocking the master instance.</source>
          <target state="translated">Для метрик и статистики реального времени с большими входными данными хорошим подходом является использование реплики (с отключенной опцией &quot;только для чтения&quot;),где выполняются битовые операции,чтобы избежать блокирования ведущего экземпляра.</target>
        </trans-unit>
        <trans-unit id="86c11a7ed67c320eacf7f860ba9da8b316757034" translate="yes" xml:space="preserve">
          <source>For security concerns, certain special administration commands like &lt;code&gt;CONFIG&lt;/code&gt; are not logged into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; output.</source>
          <target state="translated">По соображениям безопасности некоторые специальные административные команды, такие как &lt;code&gt;CONFIG&lt;/code&gt; , не записываются в вывод &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d4a1b4aeeb486fd399846319b2294f91ddedb8b" translate="yes" xml:space="preserve">
          <source>For this reason, Redis 3.2 introduces a new command that only works when script effects replication is enabled, and is able to control the scripting replication engine. The command is called &lt;code&gt;redis.set_repl()&lt;/code&gt; and fails raising an error if called when script effects replication is disabled.</source>
          <target state="translated">По этой причине в Redis 3.2 представлена ​​новая команда, которая работает только при включенной репликации эффектов сценария и может управлять механизмом репликации сценариев. Команда называется &lt;code&gt;redis.set_repl()&lt;/code&gt; и не вызывает ошибку, если вызывается, когда репликация эффектов сценария отключена.</target>
        </trans-unit>
        <trans-unit id="51865baeeba9dd27720c605912d3014b8edbbb78" translate="yes" xml:space="preserve">
          <source>Forces a node to save the &lt;code&gt;nodes.conf&lt;/code&gt; configuration on disk. Before to return the command calls &lt;code&gt;fsync(2)&lt;/code&gt; in order to make sure the configuration is flushed on the computer disk.</source>
          <target state="translated">&lt;code&gt;nodes.conf&lt;/code&gt; узел сохранять конфигурацию nodes.conf на диске. Перед возвратом команда вызывает &lt;code&gt;fsync(2)&lt;/code&gt; , чтобы убедиться, что конфигурация сброшена на диск компьютера.</target>
        </trans-unit>
        <trans-unit id="620cbfd5798a03238a582c36dc6180b1d68a8181" translate="yes" xml:space="preserve">
          <source>Fortunately, it's possible to avoid this issue using the following algorithm. Let's see how C4, our sane client, uses the good algorithm:</source>
          <target state="translated">К счастью,этой проблемы можно избежать,используя следующий алгоритм.Посмотрим,как C4,наш вменяемый клиент,использует хороший алгоритм:</target>
        </trans-unit>
        <trans-unit id="e02d5afefc425c600d8eecdd85f79d3604e46010" translate="yes" xml:space="preserve">
          <source>From the point of view of the syntax, the commands are almost the same, however &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;&lt;em&gt;requires&lt;/em&gt; a special and mandatory option:</source>
          <target state="translated">С точки зрения синтаксиса команды практически одинаковы, однако для &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP &lt;/a&gt;&lt;em&gt;требуется&lt;/em&gt; специальная и обязательная опция:</target>
        </trans-unit>
        <trans-unit id="86f3ae974780a50a7664a8c324379a24cfdab877" translate="yes" xml:space="preserve">
          <source>Fun fact: Reddit's 2017 April fools' project &lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r/place&lt;/a&gt; was &lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;built using the Redis BITFIELD command&lt;/a&gt; in order to take an in-memory representation of the collaborative canvas.</source>
          <target state="translated">Интересный факт: апрельский проект Reddit &lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r / place&lt;/a&gt; 2017 года был &lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;построен с использованием команды Redis BITFIELD&lt;/a&gt; , чтобы получить представление совместной работы в памяти.</target>
        </trans-unit>
        <trans-unit id="29ad85263278e1f788abee93dcd93c6b5f400940" translate="yes" xml:space="preserve">
          <source>GEOADD</source>
          <target state="translated">GEOADD</target>
        </trans-unit>
        <trans-unit id="fe36dd170b2d009a6fb9b3209da995c6be0a8014" translate="yes" xml:space="preserve">
          <source>GEOADD  key longitude latitude member [longitude latitude member ...]   Add one or more geospatial items in the geospatial index represented using a sorted set</source>
          <target state="translated">Член ключевой долготы ГЕОАДД [член широты долготы ...]Добавить один или несколько геопространственных элементов в геопространственный индекс,представленный с помощью отсортированного набора</target>
        </trans-unit>
        <trans-unit id="9aee98cec79ef9607b17d14a98e26344f2559e24" translate="yes" xml:space="preserve">
          <source>GEODIST</source>
          <target state="translated">GEODIST</target>
        </trans-unit>
        <trans-unit id="0a8e4fd28c6ceedcd2cf757094650298262be7f7" translate="yes" xml:space="preserve">
          <source>GEODIST  key member1 member2 [unit]   Returns the distance between two members of a geospatial index</source>
          <target state="translated">Ключевой член ГЕОДИСТ1 член2 [единица измерения]Возвращает расстояние между двумя членами геопространственного индекса</target>
        </trans-unit>
        <trans-unit id="d944f228d17ba584e232ef6b37a2330565210913" translate="yes" xml:space="preserve">
          <source>GEOHASH</source>
          <target state="translated">GEOHASH</target>
        </trans-unit>
        <trans-unit id="15d5ff901e592f20465c4a81d62cdf535660ac71" translate="yes" xml:space="preserve">
          <source>GEOHASH  key member [member ...]   Returns members of a geospatial index as standard geohash strings</source>
          <target state="translated">Ключевой член ГЭОГАШ [член ...]Возвращает членов геопространственного индекса в виде стандартных геохаш-строк</target>
        </trans-unit>
        <trans-unit id="567f488d82e3265931365c2760b37b40e268471e" translate="yes" xml:space="preserve">
          <source>GEOPOS</source>
          <target state="translated">GEOPOS</target>
        </trans-unit>
        <trans-unit id="681795a057130a9988e5c024a1915dc60c2ecb58" translate="yes" xml:space="preserve">
          <source>GEOPOS  key member [member ...]   Returns longitude and latitude of members of a geospatial index</source>
          <target state="translated">Основной член ГЕОПОС [член ...]Возвращает долготу и широту членов геопространственного индекса</target>
        </trans-unit>
        <trans-unit id="f883ad1ea5b9628a7c035af52696e8e216f48428" translate="yes" xml:space="preserve">
          <source>GEORADIUS</source>
          <target state="translated">GEORADIUS</target>
        </trans-unit>
        <trans-unit id="78a8e700f33e02c64280e94efe97493736549c5c" translate="yes" xml:space="preserve">
          <source>GEORADIUS  key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point</source>
          <target state="translated">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHOORD][WITHHASH][WITHASH][COUNT count][ASC|DESC][STORE key][STOREDIST key]Запрос отсортированного набора,представляющего собой геопространственный индекс,для получения членов,соответствующих заданному максимальному расстоянию от точки.</target>
        </trans-unit>
        <trans-unit id="ae4c6b87ec31f7b6af274155550a43bc379afb42" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER</source>
          <target state="translated">GEORADIUSBYMEMBER</target>
        </trans-unit>
        <trans-unit id="cf98dab16a680969ed5a7c59dd91c064dd5ffd22" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER  key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member</source>
          <target state="translated">GEORADIUSBYMEMBER радиус члена-ключа m|km|ft|mi [WITHOORD][WITHASH][WITHASH][COUNT count][ASC|DESC][STORE key][STOREDIST key]Запрос отсортированного набора,представляющего собой геопространственный индекс,для получения членов,соответствующих заданному максимальному расстоянию от члена.</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="7d7f9a21ff2fe871d6f138989249c29532bb7fdc" translate="yes" xml:space="preserve">
          <source>GET  key   Get the value of a key</source>
          <target state="translated">GET ключ Получить значение ключа</target>
        </trans-unit>
        <trans-unit id="ef9841e66f1ceb2a8ca3c4b61209bfb1ccb07d46" translate="yes" xml:space="preserve">
          <source>GETBIT</source>
          <target state="translated">GETBIT</target>
        </trans-unit>
        <trans-unit id="c67560b598b48f8d8597f643fcac2a09acec11dd" translate="yes" xml:space="preserve">
          <source>GETBIT  key offset   Returns the bit value at offset in the string value stored at key</source>
          <target state="translated">Смещение ключа GETBIT Возвращает значение бита при смещении в строке,сохраненное в ключе</target>
        </trans-unit>
        <trans-unit id="171dc01acd21b14b16885f344959333f303f7868" translate="yes" xml:space="preserve">
          <source>GETRANGE</source>
          <target state="translated">GETRANGE</target>
        </trans-unit>
        <trans-unit id="120d6e3c8bea25d9ffe941d0b9d148464db210c6" translate="yes" xml:space="preserve">
          <source>GETRANGE  key start end   Get a substring of the string stored at a key</source>
          <target state="translated">GETRANGE ключ начала конца Получить подстроку строки,хранящуюся в ключе</target>
        </trans-unit>
        <trans-unit id="6a4472582074006f8a0d04a695a91bfb64d3f211" translate="yes" xml:space="preserve">
          <source>GETSET</source>
          <target state="translated">GETSET</target>
        </trans-unit>
        <trans-unit id="ea14ecdc443c7b2197bfb8f599d84d9e3ddc91a9" translate="yes" xml:space="preserve">
          <source>GETSET  key value   Set the string value of a key and return its old value</source>
          <target state="translated">Значение ключа GETSET Задайте строковое значение ключа и верните его старое значение.</target>
        </trans-unit>
        <trans-unit id="0f33bfb55b7c38358e7fef810b5a8c3a19e508c9" translate="yes" xml:space="preserve">
          <source>Generate a new &lt;code&gt;configEpoch&lt;/code&gt; unilaterally, just taking the current greatest epoch available and incrementing it if its local configuration epoch is not already the greatest.</source>
          <target state="translated">Сгенерируйте новую &lt;code&gt;configEpoch&lt;/code&gt; в одностороннем порядке, просто взяв текущую самую большую доступную эпоху и увеличив ее, если ее локальная эпоха конфигурации еще не является самой большой.</target>
        </trans-unit>
        <trans-unit id="8770e1d00765da154add27070eb66b76abb639e9" translate="yes" xml:space="preserve">
          <source>Geo</source>
          <target state="translated">Geo</target>
        </trans-unit>
        <trans-unit id="00754e7ec718eca2346352874423afcfcd99de6c" translate="yes" xml:space="preserve">
          <source>Geohash string properties</source>
          <target state="translated">свойства геохаш-строки</target>
        </trans-unit>
        <trans-unit id="fcba9fe6c6b3ee7a7679d8a80f01c177efafb91f" translate="yes" xml:space="preserve">
          <source>Get keys from the source node with &lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt; command and move them into the destination node using the &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; command.</source>
          <target state="translated">Получите ключи от исходного узла с &lt;a href=&quot;cluster-getkeysinslot&quot;&gt;помощью&lt;/a&gt; команды CLUSTER GETKEYSINSLOT и переместите их в целевой узел с помощью команды &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09aec2d48c2bf33e9f4de1efe0b69e4c3361c2f6" translate="yes" xml:space="preserve">
          <source>Get the value of &lt;code&gt;key&lt;/code&gt;. If the key does not exist the special value &lt;code&gt;nil&lt;/code&gt; is returned. An error is returned if the value stored at &lt;code&gt;key&lt;/code&gt; is not a string, because &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; only handles string values.</source>
          <target state="translated">Получите значение &lt;code&gt;key&lt;/code&gt; . Если ключ не существует, возвращается специальное значение &lt;code&gt;nil&lt;/code&gt; . Ошибка возвращается, если значение, хранящееся в &lt;code&gt;key&lt;/code&gt; , не является строкой, потому что &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; обрабатывает только строковые значения.</target>
        </trans-unit>
        <trans-unit id="4f07c68cfde1cce4484071399ec3dcac10ef3226" translate="yes" xml:space="preserve">
          <source>Given a list of SHA1 digests as arguments this command returns an array of 1 or 0, where 1 means the specific SHA1 is recognized as a script already present in the scripting cache, while 0 means that a script with this SHA1 was never seen before (or at least never seen after the latest SCRIPT FLUSH command).</source>
          <target state="translated">Получив список SHA1 дайджестов в качестве аргументов,эта команда возвращает массив 1 или 0,где 1 означает,что определенный SHA1 распознан как скрипт,уже присутствующий в кэше скриптов,в то время как 0 означает,что скрипт с этим SHA1 никогда не был замечен ранее (или,по крайней мере,никогда не был замечен после последней команды SCRIPT FLUSH).</target>
        </trans-unit>
        <trans-unit id="5e47705fe8d80f510ddf59025f5bedac0bd2d833" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, it is often useful to obtain back the coordinates of specified members. When the geospatial index is populated via &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; the coordinates are converted into a 52 bit geohash, so the coordinates returned may not be exactly the ones used in order to add the elements, but small errors may be introduced.</source>
          <target state="translated">Учитывая отсортированный набор, представляющий геопространственный индекс, заполненный с помощью команды &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; , часто бывает полезно получить обратно координаты указанных элементов. Когда геопространственный индекс заполняется с помощью &lt;a href=&quot;geoadd&quot;&gt;GEOADD,&lt;/a&gt; координаты преобразуются в 52-битный геохеш, поэтому возвращаемые координаты могут быть не совсем теми, которые использовались для добавления элементов, но могут быть внесены небольшие ошибки.</target>
        </trans-unit>
        <trans-unit id="1a98977aea8887ddd5a1edb60251e403b53795ab" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, the command returns the distance between the two specified members in the specified unit.</source>
          <target state="translated">Учитывая отсортированный набор, представляющий геопространственный индекс, заполненный с помощью команды &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; , команда возвращает расстояние между двумя указанными элементами в указанной единице.</target>
        </trans-unit>
        <trans-unit id="f45f257965d0c26e93bb5789953aca2dc751ef9e" translate="yes" xml:space="preserve">
          <source>Global variables protection</source>
          <target state="translated">Защита глобальных переменных</target>
        </trans-unit>
        <trans-unit id="15d1555c45e5fc58578080840f0c6368a6d6cb11" translate="yes" xml:space="preserve">
          <source>Guarantee of termination</source>
          <target state="translated">Гарантия прекращения действия</target>
        </trans-unit>
        <trans-unit id="5205aa5d3ee9c438b38044d5999ac4ba4201f832" translate="yes" xml:space="preserve">
          <source>HDEL</source>
          <target state="translated">HDEL</target>
        </trans-unit>
        <trans-unit id="f0d9eb5c49197bfd6feeb0c9d7b482f5e211f201" translate="yes" xml:space="preserve">
          <source>HDEL  key field [field ...]   Delete one or more hash fields</source>
          <target state="translated">Поле клавиши HDEL [поле ...]Удалить одно или несколько полей хэша</target>
        </trans-unit>
        <trans-unit id="b48dcfbcf4eca1611582a1cc8baa82d9d2fa2960" translate="yes" xml:space="preserve">
          <source>HEXISTS</source>
          <target state="translated">HEXISTS</target>
        </trans-unit>
        <trans-unit id="a807653048c48da53e448a2b285039ef0573aae8" translate="yes" xml:space="preserve">
          <source>HEXISTS  key field   Determine if a hash field exists</source>
          <target state="translated">Ключевое поле HEXISTS Определить,существует ли поле хэша</target>
        </trans-unit>
        <trans-unit id="2aa481a50927484124964b6f73bac3881de47ff3" translate="yes" xml:space="preserve">
          <source>HGET</source>
          <target state="translated">HGET</target>
        </trans-unit>
        <trans-unit id="53e1681d3979ea38127102b70459b3a4ea647f65" translate="yes" xml:space="preserve">
          <source>HGET  key field   Get the value of a hash field</source>
          <target state="translated">Поле клавиши HGET Получить значение поля хэша</target>
        </trans-unit>
        <trans-unit id="0949fe15e4d07355cc1f8bdf2d7d0a3bc27e0498" translate="yes" xml:space="preserve">
          <source>HGETALL</source>
          <target state="translated">HGETALL</target>
        </trans-unit>
        <trans-unit id="a9f2d8c36ab9a92512a3abf304cf22c78a10d32a" translate="yes" xml:space="preserve">
          <source>HGETALL  key   Get all the fields and values in a hash</source>
          <target state="translated">Клавиша HGETALL Получить все поля и значения в виде хэша.</target>
        </trans-unit>
        <trans-unit id="bec3f40ebfc071338931e9ec346c383954f688e2" translate="yes" xml:space="preserve">
          <source>HINCRBY</source>
          <target state="translated">HINCRBY</target>
        </trans-unit>
        <trans-unit id="85ba7d4ce6a861db6587eaef82d0c559a1acad5a" translate="yes" xml:space="preserve">
          <source>HINCRBY  key field increment   Increment the integer value of a hash field by the given number</source>
          <target state="translated">Приращение поля ключа HINCRBY Измените целое значение поля хэша на заданное число</target>
        </trans-unit>
        <trans-unit id="a93522c3800a73e9eb332f7f840625aacdc296f3" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT</source>
          <target state="translated">HINCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="b074f9cd10320d76be5375524c56b4c4f5083f25" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT  key field increment   Increment the float value of a hash field by the given amount</source>
          <target state="translated">Увеличение ключевого поля HINCRBYFLOAT Увеличение плавающего значения хэш-поля на заданную величину</target>
        </trans-unit>
        <trans-unit id="a857392e173da21b13e4d3e033f1d7d6aadde58a" translate="yes" xml:space="preserve">
          <source>HKEYS</source>
          <target state="translated">HKEYS</target>
        </trans-unit>
        <trans-unit id="4880894873a3e4a3dcf54bf74bebf960afb44a7c" translate="yes" xml:space="preserve">
          <source>HKEYS  key   Get all the fields in a hash</source>
          <target state="translated">Клавиша HKEYS Получить все поля в хэше.</target>
        </trans-unit>
        <trans-unit id="4d36dfb03a6ecdea21a171dc0c30adebe8d01184" translate="yes" xml:space="preserve">
          <source>HLEN</source>
          <target state="translated">HLEN</target>
        </trans-unit>
        <trans-unit id="bcfcea9d003f5af07b2bb8099e2b496b1e9e832a" translate="yes" xml:space="preserve">
          <source>HLEN  key   Get the number of fields in a hash</source>
          <target state="translated">Клавиша HLEN Получить количество полей в хэше.</target>
        </trans-unit>
        <trans-unit id="480987a6e9c4e7cd1d65f5ffad4b88a1132f2c6f" translate="yes" xml:space="preserve">
          <source>HMGET</source>
          <target state="translated">HMGET</target>
        </trans-unit>
        <trans-unit id="5b7367a8f047e6e2ad4600495794ba1f6c7d8f47" translate="yes" xml:space="preserve">
          <source>HMGET  key field [field ...]   Get the values of all the given hash fields</source>
          <target state="translated">Ключевое поле HMGET [поле ...]Получить значения всех заданных хэш-полей.</target>
        </trans-unit>
        <trans-unit id="fb5089ab3a0516d344f9de817ed332775e142279" translate="yes" xml:space="preserve">
          <source>HMSET</source>
          <target state="translated">HMSET</target>
        </trans-unit>
        <trans-unit id="b9ce7bb49b575eba9a143cb12bd3a727345953bd" translate="yes" xml:space="preserve">
          <source>HMSET  key field value [field value ...]   Set multiple hash fields to multiple values</source>
          <target state="translated">Значение ключевого поля HMSET [значение поля ...]Установите несколько хеш-полей на несколько значений.</target>
        </trans-unit>
        <trans-unit id="f36a969e90bd023793807636ddb180dde5956fd7" translate="yes" xml:space="preserve">
          <source>HSCAN</source>
          <target state="translated">HSCAN</target>
        </trans-unit>
        <trans-unit id="1f717593e9570c814ba25178e664e1d1c164122d" translate="yes" xml:space="preserve">
          <source>HSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate hash fields and associated values</source>
          <target state="translated">Курсор HSCAN [MATCH pattern][COUNT count]Инкрементально итерационные поля хэшей и связанные с ними значения</target>
        </trans-unit>
        <trans-unit id="00cee6cf2b7799f7538096724dbd92d41cec6aeb" translate="yes" xml:space="preserve">
          <source>HSET</source>
          <target state="translated">HSET</target>
        </trans-unit>
        <trans-unit id="665396b991835984fc7e3e34cd2fe5312ecf417d" translate="yes" xml:space="preserve">
          <source>HSET  key field value   Set the string value of a hash field</source>
          <target state="translated">Значение поля ключа HSET Установить строковое значение поля хэша</target>
        </trans-unit>
        <trans-unit id="f08f81142bc45f390db40acaf0af8de40d5f8df0" translate="yes" xml:space="preserve">
          <source>HSETNX</source>
          <target state="translated">HSETNX</target>
        </trans-unit>
        <trans-unit id="8f0805bb5892aca6c147d761f188dcc8c135168b" translate="yes" xml:space="preserve">
          <source>HSETNX  key field value   Set the value of a hash field, only if the field does not exist</source>
          <target state="translated">Значение ключевого поля HSETNX Задайте значение поля хэша,только если поле не существует.</target>
        </trans-unit>
        <trans-unit id="653e2c00767d7da99a4ad249e0220683a0f21927" translate="yes" xml:space="preserve">
          <source>HSTRLEN</source>
          <target state="translated">HSTRLEN</target>
        </trans-unit>
        <trans-unit id="bb8103389cfdcecf46656f06573ed3513c20d29d" translate="yes" xml:space="preserve">
          <source>HSTRLEN  key field   Get the length of the value of a hash field</source>
          <target state="translated">Поле клавиши HSTRLEN Получить длину поля хэша</target>
        </trans-unit>
        <trans-unit id="75c2a102095c5cfb3745c7635997fd6d46e1ed99" translate="yes" xml:space="preserve">
          <source>HVALS</source>
          <target state="translated">HVALS</target>
        </trans-unit>
        <trans-unit id="2cf3758bf2c3fcb0cf4699e1fad2c529e7f60c18" translate="yes" xml:space="preserve">
          <source>HVALS  key   Get all the values in a hash</source>
          <target state="translated">Клавиша HVALS Получить все значения в хэше.</target>
        </trans-unit>
        <trans-unit id="1679a916ecf39377920740d5654170e7e20f04f9" translate="yes" xml:space="preserve">
          <source>Handling deadlocks</source>
          <target state="translated">Работа с тупиками</target>
        </trans-unit>
        <trans-unit id="17348a159bc90f6828002f9fa69a3bdc1006ad33" translate="yes" xml:space="preserve">
          <source>Handling of strings with different lengths</source>
          <target state="translated">Обработка струн разной длины</target>
        </trans-unit>
        <trans-unit id="5551ebd48f7eaa66477f72c449e4b2ccfc0f9609" translate="yes" xml:space="preserve">
          <source>Hashes</source>
          <target state="translated">Hashes</target>
        </trans-unit>
        <trans-unit id="abef659c43351c90fc57bd2f1f2ca21c74a56b5c" translate="yes" xml:space="preserve">
          <source>Hashes can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is a special encoding used for small hashes.</source>
          <target state="translated">Хэши могут быть закодированы как &lt;code&gt;ziplist&lt;/code&gt; или &lt;code&gt;hashtable&lt;/code&gt; . &lt;code&gt;ziplist&lt;/code&gt; специальная кодировка , используемая для малых хешей.</target>
        </trans-unit>
        <trans-unit id="a9f98aceea4b6640fde4f0db2b67c8b62670525a" translate="yes" xml:space="preserve">
          <source>Helper functions to return Redis types</source>
          <target state="translated">Функции помощника для возврата типов Redis</target>
        </trans-unit>
        <trans-unit id="71f2a2c44b12e8d025ffdb0ba44d167f2eb32dc5" translate="yes" xml:space="preserve">
          <source>Here are a few conversion examples:</source>
          <target state="translated">Вот несколько примеров преобразования:</target>
        </trans-unit>
        <trans-unit id="bd16d98ee220a06318e7c2f0edf89d89e391fb27" translate="yes" xml:space="preserve">
          <source>Here is the description of fields for Redis &amp;gt;= 2.4.</source>
          <target state="translated">Вот описание полей для Redis&amp;gt; = 2.4.</target>
        </trans-unit>
        <trans-unit id="1953d7d107ad4ade79603b02cdb1e8adc699e514" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;clients&lt;/strong&gt; section:</source>
          <target state="translated">Вот значение всех полей в разделе &lt;strong&gt;клиентов&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="aa545dc398491c6907d2041f2ded31d190284a9f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;cpu&lt;/strong&gt; section:</source>
          <target state="translated">Вот значение всех полей в разделе &lt;strong&gt;cpu&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="d3d5c7888fb0526434ccb545db7ed9e893e48b61" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;memory&lt;/strong&gt; section:</source>
          <target state="translated">Вот значение всех полей в разделе &lt;strong&gt;памяти&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="d1e56b526c805770cba7347f8a39b9426d10e67e" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;persistence&lt;/strong&gt; section:</source>
          <target state="translated">Вот значение всех полей в разделе &lt;strong&gt;постоянства&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="799881fdedd2437b9e8155aa33f7576cc6d468a1" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;replication&lt;/strong&gt; section:</source>
          <target state="translated">Вот значение всех полей в разделе &lt;strong&gt;репликации&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="0d613b28b44d140ea4afd266be689c2f86ce192d" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;server&lt;/strong&gt; section:</source>
          <target state="translated">Вот значение всех полей в разделе &lt;strong&gt;сервера&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="9700349259df5577664d69e8579a5af99e65c52f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;stats&lt;/strong&gt; section:</source>
          <target state="translated">Вот значение всех полей в разделе &lt;strong&gt;статистики&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4bd3033708ea4b8a6d1fbb504db04260b3b5e786" translate="yes" xml:space="preserve">
          <source>Here is the meaning of the fields:</source>
          <target state="translated">Вот значение полей:</target>
        </trans-unit>
        <trans-unit id="4d96106a2b4866d88034cf3cbc99a16013a0e36c" translate="yes" xml:space="preserve">
          <source>Hint: it is possible to switch to a different key based on the current Unix time, in this way it is possible to have just a relatively small amount of samples per key, to avoid dealing with very big keys, and to make this pattern more friendly to be distributed across many Redis instances.</source>
          <target state="translated">Подсказка:можно переключиться на другой ключ,основанный на текущем времени Unix,таким образом можно иметь только относительно небольшое количество выборок на ключ,чтобы избежать работы с очень большими ключами,и сделать этот шаблон более дружелюбным для распространения во многих экземплярах Redis.</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="b51e386256184dc34229a5ca92a34accb7024327" translate="yes" xml:space="preserve">
          <source>How Redis expires keys</source>
          <target state="translated">Как Redis истекает срок действия ключей</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">Как это работает?</target>
        </trans-unit>
        <trans-unit id="88559343d1f8627b05ed905092ec3f856b6418a7" translate="yes" xml:space="preserve">
          <source>How expires are handled in the replication link and AOF file</source>
          <target state="translated">Как истекает срок действия в ссылке репликации и AOF-файле</target>
        </trans-unit>
        <trans-unit id="a8dbfaf95083e1d6e63da157f09e95d8c10fa20f" translate="yes" xml:space="preserve">
          <source>How multiple clients blocked on a single stream are served</source>
          <target state="translated">Как обслуживается несколько клиентов,заблокированных в одном потоке</target>
        </trans-unit>
        <trans-unit id="d5868df09b7eeb0561970a8e423e96c9ad849dbe" translate="yes" xml:space="preserve">
          <source>How to specify intervals</source>
          <target state="translated">Как указать интервалы</target>
        </trans-unit>
        <trans-unit id="7a00a1128dbff721f5566b479531909bd1900b68" translate="yes" xml:space="preserve">
          <source>However because &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has very little state associated (just the cursor) it has the following drawbacks:</source>
          <target state="translated">Однако, поскольку &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; имеет очень мало связанного состояния (только курсор), он имеет следующие недостатки:</target>
        </trans-unit>
        <trans-unit id="d5314787731edc5f7c64fb20d0e8d7d8aa980d1c" translate="yes" xml:space="preserve">
          <source>However if the offset is prefixed with a &lt;code&gt;#&lt;/code&gt; character, the specified offset is multiplied by the integer type width, so for example:</source>
          <target state="translated">Однако, если смещение предваряется символом &lt;code&gt;#&lt;/code&gt; , указанное смещение умножается на ширину целочисленного типа, например:</target>
        </trans-unit>
        <trans-unit id="f5cfa667464e115c28334f27e6f622c0e6fc2a1c" translate="yes" xml:space="preserve">
          <source>However in this context the obtained queue is not &lt;em&gt;reliable&lt;/em&gt; as messages can be lost, for example in the case there is a network problem or if the consumer crashes just after the message is received but it is still to process.</source>
          <target state="translated">Однако в этом контексте полученная очередь не является &lt;em&gt;надежной,&lt;/em&gt; поскольку сообщения могут быть потеряны, например, в случае проблемы с сетью или в случае отказа потребителя сразу после того, как сообщение получено, но оно еще не обработано.</target>
        </trans-unit>
        <trans-unit id="32db1099030ce3f6b2493101785b95bdd63b63e3" translate="yes" xml:space="preserve">
          <source>However it returns OK to the caller ASAP, so the &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; command execution is not paused by itself.</source>
          <target state="translated">Однако он возвращает OK вызывающему как можно скорее, поэтому выполнение команды &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; не приостанавливается само по себе.</target>
        </trans-unit>
        <trans-unit id="5ebc54eeb70e7c4776f4ca626c28b6528713adcd" translate="yes" xml:space="preserve">
          <source>However node hash slots can be in a special state, used in order to communicate errors after a node restart (mismatch between the keys in the AOF/RDB file, and the node hash slots configuration), or when there is a resharding operation in progress. This two states are &lt;strong&gt;importing&lt;/strong&gt; and &lt;strong&gt;migrating&lt;/strong&gt;.</source>
          <target state="translated">Однако хеш-слоты узла могут находиться в особом состоянии, используемом для передачи сообщений об ошибках после перезапуска узла (несоответствие между ключами в файле AOF / RDB и конфигурацией хэш-слотов узла) или когда выполняется операция повторного определения размера. . Эти два государства &lt;strong&gt;импортируют&lt;/strong&gt; и &lt;strong&gt;мигрируют&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="74506a394d8d9a9db887f0b3d8806ba4f46848f4" translate="yes" xml:space="preserve">
          <source>However note that with streams this is not a problem: stream entries are not removed from the stream when clients are served, so every client waiting will be served as soon as an &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; command provides data to the stream.</source>
          <target state="translated">Однако обратите внимание, что с потоками это не проблема: записи потока не удаляются из потока при обслуживании клиентов, поэтому каждый ожидающий клиент будет обслуживаться, как только команда &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; предоставит данные потоку.</target>
        </trans-unit>
        <trans-unit id="5d5d9fa16c29cdab06e0b69ea5b8063d64e64fa1" translate="yes" xml:space="preserve">
          <source>However note that:</source>
          <target state="translated">Однако обратите внимание:</target>
        </trans-unit>
        <trans-unit id="c2edee6acbd228e132336d8defe53364f46f07e4" translate="yes" xml:space="preserve">
          <source>However once the data structures are bigger and are promoted to use real hash tables, the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of commands will resort to the normal behavior. Note that since this special behavior of returning all the elements is true only for small aggregates, it has no effects on the command complexity or latency. However the exact limits to get converted into real hash tables are &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;user configurable&lt;/a&gt;, so the maximum number of elements you can see returned in a single call depends on how big an aggregate data type could be and still use the packed representation.</source>
          <target state="translated">Однако, как только структуры данных станут больше и будут продвигаться для использования реальных хэш-таблиц, семейство команд &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; вернется к нормальному поведению. Обратите внимание, что, поскольку это особое поведение, заключающееся в возврате всех элементов, верно только для небольших агрегатов, оно не влияет на сложность команды или задержку. Однако точные ограничения на преобразование в реальные хеш-таблицы &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;настраиваются пользователем&lt;/a&gt; , поэтому максимальное количество элементов, которые вы можете увидеть, возвращаемые за один вызов, зависит от того, насколько большим может быть агрегированный тип данных и при этом использовать упакованное представление.</target>
        </trans-unit>
        <trans-unit id="b21c3d5072091035e19308ba188163eb9b4582ee" translate="yes" xml:space="preserve">
          <source>However starting with Redis 2.8.12 or greater, the command accepts the following form:</source>
          <target state="translated">Однако,начиная с пункта 2.8.12 красного цвета или выше,команда принимает следующую форму:</target>
        </trans-unit>
        <trans-unit id="3d9349e56b3bf2d47d692509fd1873664bc86e71" translate="yes" xml:space="preserve">
          <source>However the command cannot simply drop the node from the internal node table of the node receiving the command, it also implements a ban-list, not allowing the same node to be added again as a side effect of processing the &lt;em&gt;gossip section&lt;/em&gt; of the heartbeat packets received from other nodes.</source>
          <target state="translated">Однако команда не может просто удалить узел из таблицы внутренних узлов узла, получающего команду, она также реализует запретный список, не позволяя добавить тот же узел снова в качестве побочного эффекта обработки &lt;em&gt;секции сплетен&lt;/em&gt; в контрольных пакетах. получены от других узлов.</target>
        </trans-unit>
        <trans-unit id="77d71597c94f649040209c65345b9adb784d1ada" translate="yes" xml:space="preserve">
          <source>However the number of returned elements is reasonable, that is, in practical terms SCAN may return a maximum number of elements in the order of a few tens of elements when iterating a large collection, or may return all the elements of the collection in a single call when the iterated collection is small enough to be internally represented as an encoded data structure (this happens for small sets, hashes and sorted sets).</source>
          <target state="translated">Однако количество возвращаемых элементов является разумным,т.е.с практической точки зрения SCAN может возвращать максимальное количество элементов порядка нескольких десятков элементов при итерации большой коллекции или может возвращать все элементы коллекции за один вызов,когда итерационная коллекция достаточно мала,чтобы быть внутренне представленной в виде закодированной структуры данных (это бывает для маленьких наборов,хэшей и отсортированных наборов).</target>
        </trans-unit>
        <trans-unit id="4a9bd4d796e3f1d19b335cd4b8d1d2f3544974af" translate="yes" xml:space="preserve">
          <source>However the user can apply a transformation to the encoded string so that the first part of the element inserted in the sorted set will compare as the user requires for the specific application. For example if I want to add strings that will be compared in a case-insensitive way, but I still want to retrieve the real case when querying, I can add strings in the following way:</source>
          <target state="translated">Однако пользователь может применить преобразование к кодированной строке так,чтобы первая часть элемента,вставленного в отсортированный набор,сравнивалась так,как это требуется пользователю для конкретного приложения.Например,если я хочу добавить строки,которые будут сравниваться без учета регистра,но я все равно хочу получить реальный случай при запросе,я могу добавить строки следующим образом:</target>
        </trans-unit>
        <trans-unit id="794f44a2bce77c8dc3d6e6888d73f15fd3089fde" translate="yes" xml:space="preserve">
          <source>However the user is still able to write commands with random behavior using the following simple trick. Imagine I want to write a Redis script that will populate a list with N random integers.</source>
          <target state="translated">Однако пользователь все еще может записывать команды со случайным поведением,используя следующий простой трюк.Представьте,что я хочу написать скрипт Redis,который будет заполнять список N случайными числами.</target>
        </trans-unit>
        <trans-unit id="fb5b52cca56c4cdd87edf1dfc660cd981c3a9505" translate="yes" xml:space="preserve">
          <source>However there is a way for the user to tune the order of magnitude of the number of returned elements per call using the &lt;strong&gt;COUNT&lt;/strong&gt; option.</source>
          <target state="translated">Однако у пользователя есть способ настроить порядок количества возвращаемых элементов на вызов, используя параметр &lt;strong&gt;COUNT&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7f8f1c30670b30342c4d809208def1afc1fbfd2c" translate="yes" xml:space="preserve">
          <source>However there is an exception to this rule, and it is when a new cluster is created from scratch. Redis Cluster &lt;em&gt;config epoch collision resolution&lt;/em&gt; algorithm can deal with new nodes all configured with the same configuration at startup, but this process is slow and should be the exception, only to make sure that whatever happens, two more nodes eventually always move away from the state of having the same configuration epoch.</source>
          <target state="translated">Однако из этого правила есть исключение, и это когда новый кластер создается с нуля. Алгоритм &lt;em&gt;разрешения конфликтов эпохи конфигурации&lt;/em&gt; Redis Cluster может иметь дело с новыми узлами, настроенными с одинаковой конфигурацией при запуске, но этот процесс медленный и должен быть исключением, только чтобы убедиться, что что бы ни случилось, еще два узла в конечном итоге всегда уходят из состояния. иметь ту же конфигурацию эпохи.</target>
        </trans-unit>
        <trans-unit id="142631746a79e235cfed163ccdfe702d6be0326c" translate="yes" xml:space="preserve">
          <source>However this also means that executing slow scripts is not a good idea. It is not hard to create fast scripts, as the script overhead is very low, but if you are going to use slow scripts you should be aware that while the script is running no other client can execute commands.</source>
          <target state="translated">Однако это также означает,что выполнение медленных скриптов не является хорошей идеей.Нетрудно создавать быстрые скрипты,так как накладные расходы на выполнение скриптов очень низки,но если вы собираетесь использовать медленные скрипты,вы должны знать,что в то время как скрипт работает,ни один другой клиент не может выполнять команды.</target>
        </trans-unit>
        <trans-unit id="0a33083c754611907b7f894af6eb43aadc3e4c17" translate="yes" xml:space="preserve">
          <source>However this is a useful feature since, sometimes, we need to execute certain commands only in the master in order to create, for example, intermediate values.</source>
          <target state="translated">Однако это полезная функция,так как иногда нужно выполнять определенные команды только в мастере,чтобы создать,например,промежуточные значения.</target>
        </trans-unit>
        <trans-unit id="d0af8abe6ce309a54e5c3abb2294351b6406b863" translate="yes" xml:space="preserve">
          <source>However this is just a best-effort attempt so it is possible to still lose a write synchronously replicated to multiple replicas.</source>
          <target state="translated">Однако это всего лишь самая удачная попытка,поэтому можно потерять запись,синхронно реплицированную на несколько копий.</target>
        </trans-unit>
        <trans-unit id="ddd90e4937b6a5514534f2c76508301017283476" translate="yes" xml:space="preserve">
          <source>However trying to execute it again results into an error since the slots are already assigned:</source>
          <target state="translated">Однако повторная попытка его выполнения приводит к ошибке,так как слоты уже назначены:</target>
        </trans-unit>
        <trans-unit id="8abb1412bd4f6007eadde6067935f55706c8b96f" translate="yes" xml:space="preserve">
          <source>However using &lt;strong&gt;FORCE&lt;/strong&gt; we still need the majority of masters to be available in order to authorize the failover and generate a new configuration epoch for the replica that is going to become master.</source>
          <target state="translated">Однако при использовании &lt;strong&gt;FORCE&lt;/strong&gt; нам по-прежнему нужно, чтобы большинство мастеров было доступно для авторизации аварийного переключения и создания новой эпохи конфигурации для реплики, которая станет мастером.</target>
        </trans-unit>
        <trans-unit id="f7eb54420a392ba9d9fb195f48555b2f9849c4e4" translate="yes" xml:space="preserve">
          <source>However while blocking commands like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; are able to provide all the elements that are part of a Set in a given moment, The SCAN family of commands only offer limited guarantees about the returned elements since the collection that we incrementally iterate can change during the iteration process.</source>
          <target state="translated">Однако, в то время как команды блокировки, такие как &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; , могут предоставить все элементы, которые являются частью Set в данный момент, семейство команд SCAN предлагает только ограниченные гарантии в отношении возвращаемых элементов, поскольку коллекция, которую мы последовательно повторяем, может измениться в процессе итерации. .</target>
        </trans-unit>
        <trans-unit id="8368348c7a15aab35b99bad0b61100388ed947ac" translate="yes" xml:space="preserve">
          <source>However while the replicas connected to a master will not expire keys independently (but will wait for the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; coming from the master), they'll still take the full state of the expires existing in the dataset, so when a replica is elected to master it will be able to expire the keys independently, fully acting as a master.</source>
          <target state="translated">Однако, хотя реплики, подключенные к мастеру, не будут истекать ключами независимо (но будут ждать &lt;a href=&quot;del&quot;&gt;DEL,&lt;/a&gt; поступающего от мастера), они все равно будут принимать полное состояние истечения срока действия, существующего в наборе данных, поэтому, когда реплика будет выбрана мастером он сможет самостоятельно истекать срок действия ключей, полностью выступая в роли мастера.</target>
        </trans-unit>
        <trans-unit id="e7564bd1b123b79267215f60720a7ba2c7d0f2a4" translate="yes" xml:space="preserve">
          <source>However, note that:</source>
          <target state="translated">Однако,обратите внимание:</target>
        </trans-unit>
        <trans-unit id="ae8b2a13bc4ae56dbd4d97a2490048eefaa8824d" translate="yes" xml:space="preserve">
          <source>However, this behavior changes if you are looking for clear bits and specify a range with both &lt;strong&gt;start&lt;/strong&gt; and &lt;strong&gt;end&lt;/strong&gt;. If no clear bit is found in the specified range, the function returns -1 as the user specified a clear range and there are no 0 bits in that range.</source>
          <target state="translated">Однако это поведение изменяется, если вы ищете чистые биты и указываете диапазон с &lt;strong&gt;началом&lt;/strong&gt; и &lt;strong&gt;концом&lt;/strong&gt; . Если в указанном диапазоне не найден бит сброса, функция возвращает -1, поскольку пользователь указал диапазон очистки, и в этом диапазоне нет 0 битов.</target>
        </trans-unit>
        <trans-unit id="078d1434700af53deba94cb889757980e4b68051" translate="yes" xml:space="preserve">
          <source>Humans may use this command in order to check what is the hash slot, and then the associated Redis Cluster node, responsible for a given key.</source>
          <target state="translated">Люди могут использовать эту команду,чтобы проверить,что такое слот хэша,а затем связанный с ним узел кластера Redis,отвечающий за данный ключ.</target>
        </trans-unit>
        <trans-unit id="d68bb5655889a7436b2eff6315d03293170f63d0" translate="yes" xml:space="preserve">
          <source>HyperLogLog</source>
          <target state="translated">HyperLogLog</target>
        </trans-unit>
        <trans-unit id="58b5c100f0d44808f0dbfcc3722f78c2d81f1aaf" translate="yes" xml:space="preserve">
          <source>HyperLogLog representation</source>
          <target state="translated">представление HyperLogLog</target>
        </trans-unit>
        <trans-unit id="28c10e9d5a5781ed8d9e57c706ceb5a1dd97ff5f" translate="yes" xml:space="preserve">
          <source>I can start with this small Ruby program:</source>
          <target state="translated">Я могу начать с этой маленькой программы Руби:</target>
        </trans-unit>
        <trans-unit id="5188851d79e499077ff8c17718081d6a2d5d7980" translate="yes" xml:space="preserve">
          <source>IDs are guaranteed to be always incremental: If you compare the ID of the entry just inserted it will be greater than any other past ID, so entries are totally ordered inside a stream. In order to guarantee this property, if the current top ID in the stream has a time greater than the current local time of the instance, the top entry time will be used instead, and the sequence part of the ID incremented. This may happen when, for instance, the local clock jumps backward, or if after a failover the new master has a different absolute time.</source>
          <target state="translated">Идентификаторы гарантированно всегда инкрементальны:если вы сравните идентификатор только что вставленной записи,то он будет больше,чем любой другой предыдущий идентификатор,поэтому записи полностью упорядочены внутри потока.Чтобы гарантировать это свойство,если текущий ID топа в потоке имеет время больше,чем текущее локальное время экземпляра,вместо него будет использовано время входа топа,а последовательная часть ID инкрементируется.Это может произойти,например,когда локальные часы прыгают назад,или если после обхода отказа новый мастер имеет другое абсолютное время.</target>
        </trans-unit>
        <trans-unit id="c0f8745b1bebe7ddae3a87f4efc1207e5b87a40b" translate="yes" xml:space="preserve">
          <source>IDs are specified by two numbers separated by a &lt;code&gt;-&lt;/code&gt; character:</source>
          <target state="translated">Идентификаторы указываются двумя числами, разделенными знаком &lt;code&gt;-&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="70aab9650acd50b2b8e1776f69b86b88bbbe99e5" translate="yes" xml:space="preserve">
          <source>INCR</source>
          <target state="translated">INCR</target>
        </trans-unit>
        <trans-unit id="c59620ba3e9207aaf8fb1bf70e412a9caa358cb2" translate="yes" xml:space="preserve">
          <source>INCR  key   Increment the integer value of a key by one</source>
          <target state="translated">Ключ INCR Увеличивает целое значение ключа на единицу</target>
        </trans-unit>
        <trans-unit id="af14b6096425a1f909b7628ce8491716c2d581ba" translate="yes" xml:space="preserve">
          <source>INCRBY</source>
          <target state="translated">INCRBY</target>
        </trans-unit>
        <trans-unit id="9ab1bc6a3a0563b50a9e4bcb930106db12e2ae4e" translate="yes" xml:space="preserve">
          <source>INCRBY  key increment   Increment the integer value of a key by the given amount</source>
          <target state="translated">Приращение ключа INCRBY Увеличивает целое значение ключа на заданную сумму</target>
        </trans-unit>
        <trans-unit id="769650b0192d046cb68b526ab27d41d927ea5cc8" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT</source>
          <target state="translated">INCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="2e3bba4aaf8bd64291b4999ea2633e1cde536fe3" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT  key increment   Increment the float value of a key by the given amount</source>
          <target state="translated">Инкремент ключа INCRBYFLOAT Увеличение плавающего значения ключа на заданную величину</target>
        </trans-unit>
        <trans-unit id="9c9cf999829193894067bbd9e1484756ab736ac0" translate="yes" xml:space="preserve">
          <source>INFO</source>
          <target state="translated">INFO</target>
        </trans-unit>
        <trans-unit id="42089cfb2067d721afeae473b5079898e863248e" translate="yes" xml:space="preserve">
          <source>INFO  [section]   Get information and statistics about the server</source>
          <target state="translated">INFO [раздел]Получить информацию и статистику о сервере.</target>
        </trans-unit>
        <trans-unit id="fc967bd2cc1b3485f1ee6c3bccb3832c0009ded5" translate="yes" xml:space="preserve">
          <source>Ideally, the &lt;code&gt;used_memory_rss&lt;/code&gt; value should be only slightly higher than &lt;code&gt;used_memory&lt;/code&gt;. When rss &amp;gt;&amp;gt; used, a large difference means there is memory fragmentation (internal or external), which can be evaluated by checking &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt;. When used &amp;gt;&amp;gt; rss, it means part of Redis memory has been swapped off by the operating system: expect some significant latencies.</source>
          <target state="translated">В идеале значение &lt;code&gt;used_memory_rss&lt;/code&gt; должно быть лишь немного выше, чем &lt;code&gt;used_memory&lt;/code&gt; . При использовании rss &amp;gt;&amp;gt; большая разница означает фрагментацию памяти (внутреннюю или внешнюю), которую можно оценить, проверив &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt; . Когда используется &amp;gt;&amp;gt; rss, это означает, что часть памяти Redis была отключена операционной системой: ожидайте значительных задержек.</target>
        </trans-unit>
        <trans-unit id="73b4eda93b2219c5cea27cedcc70f71581e15c99" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; fails, no data gets lost as the old AOF will be untouched.</source>
          <target state="translated">Если &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; выходит из строя, данные не теряются, так как старый AOF останется нетронутым.</target>
        </trans-unit>
        <trans-unit id="1d20f361447b1eebe4e4808ffc994e347a4065d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;0&lt;/code&gt; the key is already locked by some other client. We can either return to the caller if it's a non blocking lock, or enter a loop retrying to hold the lock until we succeed or some kind of timeout expires.</source>
          <target state="translated">Если &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; возвращает &lt;code&gt;0&lt;/code&gt; , ключ уже заблокирован другим клиентом. Мы можем либо вернуться к вызывающему, если это неблокирующая блокировка, либо войти в цикл, пытаясь удерживать блокировку до тех пор, пока мы не добьемся успеха, или пока не истечет какой-то тайм-аут.</target>
        </trans-unit>
        <trans-unit id="b2860996021d578f69065139684f5cafa8d2519b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;1&lt;/code&gt; the client acquired the lock, setting the &lt;code&gt;lock.foo&lt;/code&gt; key to the Unix time at which the lock should no longer be considered valid. The client will later use &lt;code&gt;DEL lock.foo&lt;/code&gt; in order to release the lock.</source>
          <target state="translated">Если &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; возвращает &lt;code&gt;1&lt;/code&gt; ,значит, клиент получил блокировку, установив для ключа &lt;code&gt;lock.foo&lt;/code&gt; время Unix, при котором блокировка больше не должна считаться действительной. Позже клиент будет использовать &lt;code&gt;DEL lock.foo&lt;/code&gt; , чтобы снять блокировку.</target>
        </trans-unit>
        <trans-unit id="a5eee6810815d94e86b03260de66be0feb7ce88c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt; was used, &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; unwatches all keys watched by the connection.</source>
          <target state="translated">Если &lt;a href=&quot;watch&quot;&gt;ЧАСЫ&lt;/a&gt; использовался, &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; unwatches все ключи отслеживаемых соединения.</target>
        </trans-unit>
        <trans-unit id="20ed44b2bda4227d511c46587683f47a00d993b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITHCOORD&lt;/code&gt;, &lt;code&gt;WITHDIST&lt;/code&gt; or &lt;code&gt;WITHHASH&lt;/code&gt; options are specified, the command returns an array of arrays, where each sub-array represents a single item.</source>
          <target state="translated">Если &lt;code&gt;WITHCOORD&lt;/code&gt; , &lt;code&gt;WITHDIST&lt;/code&gt; или &lt;code&gt;WITHHASH&lt;/code&gt; , команда возвращает массив массивов, где каждый подмассив представляет отдельный элемент.</target>
        </trans-unit>
        <trans-unit id="73dfe5f15062ceece61a6acc3449e57743eeff88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;destination&lt;/code&gt; already exists, it is overwritten.</source>
          <target state="translated">Если &lt;code&gt;destination&lt;/code&gt; уже существует, он перезаписывается.</target>
        </trans-unit>
        <trans-unit id="ec00a71247f51a83461ff727be4fdc2a9b8eef53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; already exists and is a string, this command appends the &lt;code&gt;value&lt;/code&gt; at the end of the string. If &lt;code&gt;key&lt;/code&gt; does not exist it is created and set as an empty string, so &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; will be similar to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; in this special case.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; уже существует и является строкой, эта команда добавляет &lt;code&gt;value&lt;/code&gt; в конец строки. Если &lt;code&gt;key&lt;/code&gt; не существует, он создается и устанавливается как пустая строка, поэтому &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; будет аналогичен &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; в этом особом случае.</target>
        </trans-unit>
        <trans-unit id="f65de86e658742c07d7bc6102da39df199a9b701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist a nil bulk reply is returned.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, возвращается нулевой массовый ответ.</target>
        </trans-unit>
        <trans-unit id="bd4417fe5a7c2042f71015b09d46b92838be30fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified members as sole members is created, like if the sorted set was empty. If the key exists but does not hold a sorted set, an error is returned.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, создается новый отсортированный набор с указанными членами в качестве единственных, как если бы отсортированный набор был пуст. Если ключ существует, но не содержит отсортированного набора, возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="e64662be889ce64c17aaa1cc9189ce3256310f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;member&lt;/code&gt; не существует в отсортированном наборе или &lt;code&gt;key&lt;/code&gt; не существует, &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;массовый строковый ответ&lt;/a&gt; : &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f23ea3c8266e3f5959aed27b93602e9cafb796f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;member&lt;/code&gt; не существует в отсортированном наборе или &lt;code&gt;key&lt;/code&gt; не существует, возвращается &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e3e9eec1dfb85dde46f12f033df8c95cb570dc1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; exists in the sorted set, &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the rank of &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;member&lt;/code&gt; существует в отсортированном наборе, &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Целочисленный ответ&lt;/a&gt; : ранг &lt;code&gt;member&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0602d8252b35c86b3177857f428ef2b6ebe2844" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;password&lt;/code&gt; matches the password in the configuration file, the server replies with the &lt;code&gt;OK&lt;/code&gt; status code and starts accepting commands. Otherwise, an error is returned and the clients needs to try a new password.</source>
          <target state="translated">Если &lt;code&gt;password&lt;/code&gt; совпадает с паролем в файле конфигурации, сервер отвечает кодом состояния &lt;code&gt;OK&lt;/code&gt; и начинает принимать команды. В противном случае возвращается ошибка, и клиентам необходимо попробовать новый пароль.</target>
        </trans-unit>
        <trans-unit id="d8a36f67086d264992352bae73959a976d08f592" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; does not exist, the value &lt;code&gt;nil&lt;/code&gt; is returned and no operation is performed. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are the same, the operation is equivalent to removing the last element from the list and pushing it as first element of the list, so it can be considered as a list rotation command.</source>
          <target state="translated">Если &lt;code&gt;source&lt;/code&gt; не существует, возвращается значение &lt;code&gt;nil&lt;/code&gt; и никакая операция не выполняется. Если &lt;code&gt;source&lt;/code&gt; и &lt;code&gt;destination&lt;/code&gt; совпадают, операция эквивалентна удалению последнего элемента из списка и продвижению его в качестве первого элемента списка, поэтому ее можно рассматривать как команду вращения списка.</target>
        </trans-unit>
        <trans-unit id="5b26bcfdadbb106d42a10a68f68adf4977b43380" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ttl&lt;/code&gt; is 0 the key is created without any expire, otherwise the specified expire time (in milliseconds) is set.</source>
          <target state="translated">Если &lt;code&gt;ttl&lt;/code&gt; равен 0, ключ создается без истечения срока действия, в противном случае устанавливается указанное время истечения срока действия (в миллисекундах).</target>
        </trans-unit>
        <trans-unit id="2c1e9f5fc6b657f9746f093601d0e06e3be8a993" translate="yes" xml:space="preserve">
          <source>If AOF is activated, these additional fields will be added:</source>
          <target state="translated">Если AOF активирована,эти дополнительные поля будут добавлены:</target>
        </trans-unit>
        <trans-unit id="52fb5f5179b2d79edc8c3b551f845f186e716372" translate="yes" xml:space="preserve">
          <source>If a Redis child is creating a snapshot on disk, the AOF rewrite is &lt;em&gt;scheduled&lt;/em&gt; but not started until the saving child producing the RDB file terminates. In this case the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; will still return an OK code, but with an appropriate message. You can check if an AOF rewrite is scheduled looking at the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command as of Redis 2.6.</source>
          <target state="translated">Если дочерний элемент Redis создает моментальный снимок на диске, перезапись AOF &lt;em&gt;планируется,&lt;/em&gt; но не запускается до тех пор, пока не завершится сохранение дочернего элемента, создающего файл RDB. В этом случае &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; все равно будет возвращать код ОК, но с соответствующим сообщением. Вы можете проверить, запланирована ли перезапись AOF, просмотрев команду &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; в Redis 2.6.</target>
        </trans-unit>
        <trans-unit id="7fab76e64c7a99cf5ff09d3faf8bcf4e7b29c3b9" translate="yes" xml:space="preserve">
          <source>If a Redis server is already acting as replica, the command &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE will turn off the replication, turning the Redis server into a MASTER. In the proper form &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will make the server a replica of another server listening at the specified hostname and port.</source>
          <target state="translated">Если сервер Redis уже работает как реплика, команда &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE отключит репликацию, превратив сервер Redis в ГЛАВНЫЙ. В правильной форме &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port сделает сервер репликой другого сервера, прослушивающего указанные имя хоста и порт.</target>
        </trans-unit>
        <trans-unit id="6bba5cc9a8544de84799044ff9489eaddadc2beb" translate="yes" xml:space="preserve">
          <source>If a SYNC operation is on-going, these additional fields are provided:</source>
          <target state="translated">Если операция SYNC продолжается,то предоставляются эти дополнительные поля:</target>
        </trans-unit>
        <trans-unit id="b39dab88e7088d47355746e00cd5a3b16aea36b7" translate="yes" xml:space="preserve">
          <source>If a cluster instance has non-contiguous slots (e.g. 1-400,900,1800-6000) then master and replica IP/Port results will be duplicated for each top-level slot range reply.</source>
          <target state="translated">Если экземпляр кластера имеет несмежные слоты (например,1-400 900 1800-6000),то результаты IP/Port будут дублироваться для каждого ответа диапазона слотов верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="59220272c64271f85f1f97cc7691835ad64c2de3" translate="yes" xml:space="preserve">
          <source>If a command accepts an unlimited number of keys, the last key position is -1.</source>
          <target state="translated">Если команда принимает неограниченное количество ключей,то последняя позиция ключа -1.</target>
        </trans-unit>
        <trans-unit id="140a2742270e0d194dfebacb6a9c7a4820592aff" translate="yes" xml:space="preserve">
          <source>If a command accepts one key, the first key and last key positions is 1.</source>
          <target state="translated">Если команда принимает один ключ,то первый и последний-1.</target>
        </trans-unit>
        <trans-unit id="c31655fb4face26cd02e88dd6486f34dd31bb51e" translate="yes" xml:space="preserve">
          <source>If a command accepts two keys (e.g. &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;, &lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt;, &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, ...) then the last key position is the location of the last key in the argument list.</source>
          <target state="translated">Если команда принимает два ключа (например, &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; , &lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt; , &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; , ...), то позиция последнего ключа - это положение последнего ключа в списке аргументов.</target>
        </trans-unit>
        <trans-unit id="610d9883b3ed9e5bbf61e781dfb38f2ca5532e85" translate="yes" xml:space="preserve">
          <source>If a command is received about a key that does not exists, an &lt;code&gt;ASK&lt;/code&gt; redirection is emitted by the node, asking the client to retry only that specific query into &lt;code&gt;destination-node&lt;/code&gt;. In this case the client should not update its hash slot to node mapping.</source>
          <target state="translated">Если получена команда о ключе , который не существует, &lt;code&gt;ASK&lt;/code&gt; Перенаправление излучаемый узлом, чтобы просить клиента повторить только то , что конкретный запрос в &lt;code&gt;destination-node&lt;/code&gt; . В этом случае клиент не должен обновлять свой хэш-слот для сопоставления узлов.</target>
        </trans-unit>
        <trans-unit id="adc3a75aac4d6b35ed7b12ce05235e4cc640c05b" translate="yes" xml:space="preserve">
          <source>If a command is received about an existing key, the command is processed as usually.</source>
          <target state="translated">Если поступает команда о существующем ключе,команда обрабатывается,как обычно.</target>
        </trans-unit>
        <trans-unit id="a64d2ec3bb10e34eb579070274923657d7138a2a" translate="yes" xml:space="preserve">
          <source>If a key is overwritten by &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, like in the case of an existing key &lt;code&gt;Key_A&lt;/code&gt; that is overwritten by a call like &lt;code&gt;RENAME Key_B Key_A&lt;/code&gt;, it does not matter if the original &lt;code&gt;Key_A&lt;/code&gt; had a timeout associated or not, the new key &lt;code&gt;Key_A&lt;/code&gt; will inherit all the characteristics of &lt;code&gt;Key_B&lt;/code&gt;.</source>
          <target state="translated">Если ключ перезаписывается с помощью &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; , как в случае существующего ключа &lt;code&gt;Key_A&lt;/code&gt; , который перезаписывается вызовом типа &lt;code&gt;RENAME Key_B Key_A&lt;/code&gt; , не имеет значения, был ли у исходного &lt;code&gt;Key_A&lt;/code&gt; связанный тайм-аут или нет, новый ключ &lt;code&gt;Key_A&lt;/code&gt; унаследует все характеристики &lt;code&gt;Key_B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0360f4a1e3e37b28bbc1c81856843472bd113d44" translate="yes" xml:space="preserve">
          <source>If a key is renamed with &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, the associated time to live is transferred to the new key name.</source>
          <target state="translated">Если ключ переименован с помощью &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; , связанное время жизни переносится на новое имя ключа.</target>
        </trans-unit>
        <trans-unit id="dba073505eef52f13e35c2d2b072e15bc497f1c3" translate="yes" xml:space="preserve">
          <source>If a load operation is on-going, these additional fields will be added:</source>
          <target state="translated">Если операция загрузки продолжается,эти дополнительные поля будут добавлены:</target>
        </trans-unit>
        <trans-unit id="a8036cb18b462f0b09c70d787c53e11501cfbc97" translate="yes" xml:space="preserve">
          <source>If a node with unbound hash slots receives a heartbeat packet from another node that claims to be the owner of some of those hash slots, the association is established instantly. Moreover, if a heartbeat or update message is received with a configuration epoch greater than the node's own, the association is re-established.</source>
          <target state="translated">Если узел с несвязанными хэш-слотами получает от другого узла,который утверждает,что является владельцем некоторых из этих хэш-слотов,ассоциация создается мгновенно.Более того,при получении сообщения об ударе сердца или обновлении с эпохой конфигурации,превышающей собственную,ассоциация восстанавливается.</target>
        </trans-unit>
        <trans-unit id="e6947348d36ca3b7d6ec64b0d3d493bff74f2cca" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">Если сервер уже является копией какого-либо мастера, &lt;a href=&quot;replicaof&quot;&gt;порт&lt;/a&gt; имени хоста REPLICAOF остановит репликацию на старом сервере и начнет синхронизацию с новым, отбросив старый набор данных.</target>
        </trans-unit>
        <trans-unit id="8355cef42438c57bf29e119daff3edf69a2eafac" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">Если сервер уже является копией какого-либо мастера, порт &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname остановит репликацию на старый сервер и начнет синхронизацию с новым, отбросив старый набор данных.</target>
        </trans-unit>
        <trans-unit id="796f8c82d2cb3bc6674d519060d62df76a47b5cf" translate="yes" xml:space="preserve">
          <source>If an AOF rewrite is already in progress the command returns an error and no AOF rewrite will be scheduled for a later time.</source>
          <target state="translated">Если перезапись AOF уже выполняется,команда возвращает ошибку,и перезапись AOF не будет запланирована на более позднее время.</target>
        </trans-unit>
        <trans-unit id="aa95f2ff011f2ee3af55365c22aa9caf33f28db8" translate="yes" xml:space="preserve">
          <source>If an option already exists in the old redis.conf file, it will be rewritten at the same position (line number).</source>
          <target state="translated">Если опция уже существует в старом файле redis.conf,то она будет переписана в той же позиции (номер строки).</target>
        </trans-unit>
        <trans-unit id="4658daabd5c918d6c9d2de1223a7f5eb6d9fd842" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to a non-default value, it is appended at the end of the file.</source>
          <target state="translated">Если опция еще не присутствует,но установлена в значение не по умолчанию,она добавляется в конце файла.</target>
        </trans-unit>
        <trans-unit id="e4228aca6b611c430e003ee894c91eb30a1b6cd7" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to its default value, it is not added by the rewrite process.</source>
          <target state="translated">Если опция еще не присутствует,но установлена в значение по умолчанию,то в процессе перезаписи она не добавляется.</target>
        </trans-unit>
        <trans-unit id="b63f671253761bdf3174af266654497deb63ef4b" translate="yes" xml:space="preserve">
          <source>If another client, for instance C5, was faster than C4 and acquired the lock with the &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation, the C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation will return a non expired timestamp. C4 will simply restart from the first step. Note that even if C4 set the key a bit a few seconds in the future this is not a problem.</source>
          <target state="translated">Если другой клиент, например C5, был быстрее, чем C4, и получил блокировку с &lt;a href=&quot;getset&quot;&gt;помощью&lt;/a&gt; операции GETSET, операция C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; вернет метку времени, срок действия которой не истек. C4 просто перезапустится с первого шага. Обратите внимание, что даже если C4 установит ключ на несколько секунд в будущем, это не проблема.</target>
        </trans-unit>
        <trans-unit id="37cf40db32d54ae3579f3237037ff5c92145f193" translate="yes" xml:space="preserve">
          <source>If at a given time a node has another node flagged with &lt;code&gt;PFAIL&lt;/code&gt;, and at the same time collected the majority of other master nodes &lt;em&gt;failure reports&lt;/em&gt; about this node (including itself if it is a master), then it elevates the failure state of the node from &lt;code&gt;PFAIL&lt;/code&gt; to &lt;code&gt;FAIL&lt;/code&gt;, and broadcasts a message forcing all the nodes that can be reached to flag the node as &lt;code&gt;FAIL&lt;/code&gt;.</source>
          <target state="translated">Если в данный момент у узла есть другой узел, помеченный с помощью &lt;code&gt;PFAIL&lt;/code&gt; , и в то же время собрано большинство &lt;em&gt;отчетов&lt;/em&gt; об &lt;em&gt;отказе&lt;/em&gt; других главных узлов об этом узле (включая его самого, если он является главным), то он повышает состояние отказа узла. от &lt;code&gt;PFAIL&lt;/code&gt; до &lt;code&gt;FAIL&lt;/code&gt; и передает сообщение, вынуждающее все узлы, которые могут быть достигнуты, пометить узел как &lt;code&gt;FAIL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f5470ee8997d2330c4f1d3cb52035e4a73f57ce" translate="yes" xml:space="preserve">
          <source>If count is bigger than the number of elements inside the Set, the command will only return the whole set without additional elements.</source>
          <target state="translated">Если счетчик больше,чем количество элементов внутри множества,команда вернет только весь набор без дополнительных элементов.</target>
        </trans-unit>
        <trans-unit id="7166a4c2e9e0a7b189fdf30ab0234c6d47986ab4" translate="yes" xml:space="preserve">
          <source>If instead the message was already delivered to this consumer, and it is just re-fetching the same message again, then the &lt;em&gt;last delivery counter&lt;/em&gt; is updated to the current time, and the &lt;em&gt;number of deliveries&lt;/em&gt; is incremented by one. You can access those message properties using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command.</source>
          <target state="translated">Если вместо этого сообщение уже было доставлено этому потребителю, и он просто повторно выбирает то же сообщение снова, то &lt;em&gt;последний счетчик доставки&lt;/em&gt; обновляется до текущего времени, а &lt;em&gt;количество доставок&lt;/em&gt; увеличивается на единицу. Вы можете получить доступ к этим свойствам сообщения с помощью команды &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb7b53c8c56d77ba922276fcf8d6fc9a5555deb" translate="yes" xml:space="preserve">
          <source>If instead you want consumers to fetch the whole stream history, use zero as the starting ID for the consumer group:</source>
          <target state="translated">Если вместо этого вы хотите,чтобы потребители получали всю историю потока,используйте ноль в качестве стартового идентификатора для группы потребителей:</target>
        </trans-unit>
        <trans-unit id="766551fe9e9ea8009a726c50e78e04cbf000fc57" translate="yes" xml:space="preserve">
          <source>If more than 25% of keys were expired, start again from step 1.</source>
          <target state="translated">Если более 25% ключей истекли,начните заново с шага 1.</target>
        </trans-unit>
        <trans-unit id="18ba579c412c6a80f5484abbbc6da80390ec5935" translate="yes" xml:space="preserve">
          <source>If multiple clients are blocked for the same key, the first client to be served is the one that was waiting for more time (the first that blocked for the key). Once a client is unblocked it does not retain any priority, when it blocks again with the next call to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; it will be served accordingly to the number of clients already blocked for the same key, that will all be served before it (from the first to the last that blocked).</source>
          <target state="translated">Если несколько клиентов заблокированы для одного и того же ключа, первым обслуживаемым клиентом будет тот, который ждал больше времени (первый, который заблокировался для ключа). После того, как клиент разблокирован, он не сохраняет никакого приоритета, когда он снова блокируется при следующем вызове &lt;a href=&quot;blpop&quot;&gt;BLPOP,&lt;/a&gt; он будет обслуживаться в соответствии с количеством клиентов, уже заблокированных для того же ключа, которые все будут обслуживаться до него (с первого до последнего что заблокировано).</target>
        </trans-unit>
        <trans-unit id="2d45448e42846cf1223f90529d7153a4f2ea7d57" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;pattern&lt;/code&gt; is specified, all the channels are listed, otherwise if pattern is specified only channels matching the specified glob-style pattern are listed.</source>
          <target state="translated">Если &lt;code&gt;pattern&lt;/code&gt; не указан, отображаются все каналы, в противном случае, если указан шаблон, отображаются только каналы, соответствующие заданному шаблону стиля глобуса.</target>
        </trans-unit>
        <trans-unit id="ea2697ae6fd039b4a66dbcb2f98b8550bd0df116" translate="yes" xml:space="preserve">
          <source>If no reset type is specified, the default is &lt;strong&gt;soft&lt;/strong&gt;.</source>
          <target state="translated">Если тип сброса не указан, по умолчанию используется &lt;strong&gt;мягкий&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7a5e1cf1e0228d3ddab066d68bd268b73f915f6a" translate="yes" xml:space="preserve">
          <source>If none of the specified keys exist, &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; blocks the connection until another client performs an &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; or &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; operation against one of the keys.</source>
          <target state="translated">Если ни один из указанных ключей не существует, &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; блокирует соединение до тех пор, пока другой клиент не выполнит &lt;a href=&quot;lpush&quot;&gt;операцию LPUSH&lt;/a&gt; или &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; с одним из ключей.</target>
        </trans-unit>
        <trans-unit id="dfae9157f2f024976d442ab776949fdf1b2e1598" translate="yes" xml:space="preserve">
          <source>If one or both the members are missing, the command returns NULL.</source>
          <target state="translated">Если один или оба члена отсутствуют,команда возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="4eccea0e4c99dbf5582f258e7eec112ee8e36e5c" translate="yes" xml:space="preserve">
          <source>If persistence is enabled this commands makes sure that Redis is switched off without the lost of any data. This is not guaranteed if the client uses simply &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; and then &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; because other clients may alter the DB data between the two commands.</source>
          <target state="translated">Если постоянство включено, эти команды гарантируют, что Redis выключен без потери каких-либо данных. Это не гарантируется, если клиент использует просто &lt;a href=&quot;save&quot;&gt;SAVE,&lt;/a&gt; а затем &lt;a href=&quot;quit&quot;&gt;QUIT,&lt;/a&gt; потому что другие клиенты могут изменять данные DB между двумя командами.</target>
        </trans-unit>
        <trans-unit id="3c4893d742c042232e8b2da1b66fa8109b95fc06" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; option is specified, the return value will be &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;:</source>
          <target state="translated">Если указана опция &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; , возвращаемое значение будет &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;массовым строковым ответом&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="48c94188363158a9ff98bf015f1ddfb2076ba94d" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;BLOCK&lt;/strong&gt; option is not used, the command is synchronous, and can be considered somewhat related to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;: it will return a range of items inside streams, however it has two fundamental differences compared to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; even if we just consider the synchronous usage:</source>
          <target state="translated">Если опция &lt;strong&gt;BLOCK&lt;/strong&gt; не используется, команда является синхронной и может считаться в некоторой степени связанной с &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; : она будет возвращать диапазон элементов внутри потоков, однако у нее есть два фундаментальных отличия от &lt;a href=&quot;xrange&quot;&gt;XRANGE,&lt;/a&gt; даже если мы просто рассматриваем синхронное использование:</target>
        </trans-unit>
        <trans-unit id="2a8ebc8cb8dd39729bf6fdaaa9469b8e9dd31c5f" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;FORCE&lt;/strong&gt; option is given, the replica does not perform any handshake with the master, that may be not reachable, but instead just starts a failover ASAP starting from point 4. This is useful when we want to start a manual failover while the master is no longer reachable.</source>
          <target state="translated">Если задана опция &lt;strong&gt;FORCE&lt;/strong&gt; , реплика не выполняет никакого установления связи с мастером, которое может быть недоступно, а вместо этого просто запускает аварийное переключение как можно скорее, начиная с точки 4. Это полезно, когда мы хотим запустить аварийное переключение вручную, пока мастер больше недоступен.</target>
        </trans-unit>
        <trans-unit id="fded77f647c95a1a86355a7eafad08fd193bd854" translate="yes" xml:space="preserve">
          <source>If the above condition happens using a Redis 2.6 server or greater, Client &lt;strong&gt;A&lt;/strong&gt; will be served with the &lt;code&gt;c&lt;/code&gt; element, because after the &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; command the list contains &lt;code&gt;c,b,a&lt;/code&gt;, so taking an element from the left means to return &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Если указанное выше условие происходит с использованием сервера Redis 2.6 или выше, клиент &lt;strong&gt;A&lt;/strong&gt; будет обслуживаться с элементом &lt;code&gt;c&lt;/code&gt; , потому что после команды &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; список содержит &lt;code&gt;c,b,a&lt;/code&gt; , поэтому выбор элемента слева означает возврат &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc531ff7f9715b58415dfa6813dab3cc7b073afd" translate="yes" xml:space="preserve">
          <source>If the approximated cardinality estimated by the HyperLogLog changed after executing the command, &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; returns 1, otherwise 0 is returned. The command automatically creates an empty HyperLogLog structure (that is, a Redis String of a specified length and with a given encoding) if the specified key does not exist.</source>
          <target state="translated">Если приблизительное количество элементов, оцененное HyperLogLog, изменилось после выполнения команды, &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; возвращает 1, в противном случае возвращается 0. Команда автоматически создает пустую структуру HyperLogLog (то есть строку Redis указанной длины и с заданной кодировкой), если указанный ключ не существует.</target>
        </trans-unit>
        <trans-unit id="2a7df869ee4ed74778e5142a4cec6fc019c36dbe" translate="yes" xml:space="preserve">
          <source>If the client is subscribed to a channel or a pattern, it will instead return a multi-bulk with a &quot;pong&quot; in the first position and an empty bulk in the second position, unless an argument is provided in which case it returns a copy of the argument.</source>
          <target state="translated">Если клиент подписан на канал или шаблон,то вместо этого он вернет многоточечный с &quot;понгом&quot; в первой позиции и пустым объемом во второй,если только не указан аргумент,и в этом случае он вернет копию аргумента.</target>
        </trans-unit>
        <trans-unit id="1e3b4ecb886491d18a97620613800a70a1d78a2c" translate="yes" xml:space="preserve">
          <source>If the client tries to blocks for multiple keys, but at least one key contains elements, the returned key / element pair is the first key from left to right that has one or more elements. In this case the client is not blocked. So for instance &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt;, assuming that both &lt;code&gt;key2&lt;/code&gt; and &lt;code&gt;key4&lt;/code&gt; are non-empty, will always return an element from &lt;code&gt;key2&lt;/code&gt;.</source>
          <target state="translated">Если клиент пытается выполнить блокировку для нескольких ключей, но хотя бы один ключ содержит элементы, возвращенная пара ключ / элемент является первым ключом слева направо, который имеет один или несколько элементов. В этом случае клиент не заблокирован. Так, например, &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt; , предполагая, что и &lt;code&gt;key2&lt;/code&gt; , и &lt;code&gt;key4&lt;/code&gt; непустые, всегда будет возвращать элемент из &lt;code&gt;key2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4c4a551c5294109d275f4efb02ba586ea39cd4b" translate="yes" xml:space="preserve">
          <source>If the command contains multiple keys, in case none exist, the behavior is the same as point 2, if all exist, it is the same as point 1, however if only a partial number of keys exist, the command emits a &lt;code&gt;TRYAGAIN&lt;/code&gt; error in order for the keys interested to finish being migrated to the target node, so that the multi keys command can be executed.</source>
          <target state="translated">Если команда содержит несколько ключей, если ни один из них не существует, поведение такое же, как в пункте 2, если все существуют, то же самое, что и в пункте 1, однако, если существует только частичное количество ключей, команда выдает ошибку &lt;code&gt;TRYAGAIN&lt;/code&gt; в порядок завершения миграции заинтересованных ключей в целевой узел, чтобы можно было выполнить команду multi keys.</target>
        </trans-unit>
        <trans-unit id="b47c13f341545793a768bad91b706c8230117dd6" translate="yes" xml:space="preserve">
          <source>If the command is sent as part of a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; transaction, the command does not block but instead just return ASAP the number of replicas that acknowledged the previous write commands.</source>
          <target state="translated">Если команда отправляется как часть транзакции &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; , команда не блокируется, а вместо этого просто возвращает как можно скорее количество реплик, подтвердивших предыдущие команды записи.</target>
        </trans-unit>
        <trans-unit id="b2647b206316067e60c5c58ad3dabbd5311d10db" translate="yes" xml:space="preserve">
          <source>If the command is successful the new incremented value is stored as the new value of the key (replacing the old one), and returned to the caller as a string.</source>
          <target state="translated">При успешном выполнении команды новое инкрементированное значение сохраняется как новое значение ключа (заменяя старое)и возвращается вызывающему абоненту в виде строки.</target>
        </trans-unit>
        <trans-unit id="e13c77b4e4b0cd6a39fdb6c6dd3019929d6f047e" translate="yes" xml:space="preserve">
          <source>If the command succeeds the new replica will immediately try to contact its master in order to replicate from it.</source>
          <target state="translated">Если команда будет успешной,то новая реплика немедленно попытается связаться со своим мастером,чтобы реплицировать с него.</target>
        </trans-unit>
        <trans-unit id="58e50abae2f1a6949ff81b62d232f71c48c7e358" translate="yes" xml:space="preserve">
          <source>If the current hash slot owner is the node receiving the command, but for effect of the command the slot would be assigned to a different node, the command will return an error if there are still keys for that hash slot in the node receiving the command.</source>
          <target state="translated">Если текущий владелец хеш-слота является узлом,принимающим команду,но для выполнения команды слот будет назначен другому узлу,команда вернет ошибку,если в узле,принимающем команду,все еще есть ключи для этого хеш-слота.</target>
        </trans-unit>
        <trans-unit id="b16a9421e847dd28010cba3e62963f9099073a99" translate="yes" xml:space="preserve">
          <source>If the elements in the sorted set have different scores, the returned elements are unspecified.</source>
          <target state="translated">Если элементы в отсортированном наборе имеют разную оценку,возвращаемые элементы являются неуказанными.</target>
        </trans-unit>
        <trans-unit id="3481b2e7b6d800470df672a8874ad9a04f6afdca" translate="yes" xml:space="preserve">
          <source>If the instance is a replica, these additional fields are provided:</source>
          <target state="translated">Если экземпляр является копией,то предоставляются эти дополнительные поля:</target>
        </trans-unit>
        <trans-unit id="a39168a871f5b0b2ac68a8345a687deba4b95089" translate="yes" xml:space="preserve">
          <source>If the link between master and replica is down, an additional field is provided:</source>
          <target state="translated">Если связь между ведущим устройством и репликой нарушена,предоставляется дополнительное поле:</target>
        </trans-unit>
        <trans-unit id="5d43590cf68cfd82fc6f591b087a5f138a1a7c3f" translate="yes" xml:space="preserve">
          <source>If the message was never delivered to anyone, that is, if we are talking about a new message, then a PEL (Pending Entry List) is created.</source>
          <target state="translated">Если сообщение никому не было доставлено,то есть,если мы говорим о новом сообщении,то создается PEL (Pending Entry List).</target>
        </trans-unit>
        <trans-unit id="638ffe7f713cb2cff80e46aae12ead14d0ec33c3" translate="yes" xml:space="preserve">
          <source>If the node is a replica it is turned into an (empty) master. Its dataset is flushed, so at the end the node will be an empty master.</source>
          <target state="translated">Если узел является репликой,он превращается в (пустой)мастер.Его набор данных промывается,поэтому в конце узел становится пустым мастером.</target>
        </trans-unit>
        <trans-unit id="1785c288c16b021950b10d9d886a7eae6f023094" translate="yes" xml:space="preserve">
          <source>If the node receiving the command is not already a replica, but is a master, the command will only succeed, and the node will be converted into a replica, only if the following additional conditions are met:</source>
          <target state="translated">Если узел,получающий команду,еще не является репликой,а является ведущим,то команда будет успешной,и узел будет преобразован в реплику,только если будут выполнены следующие дополнительные условия:</target>
        </trans-unit>
        <trans-unit id="0d7f2602b57e25d3482f6de95a393b6a52d114e4" translate="yes" xml:space="preserve">
          <source>If the object you try to inspect is missing, a null bulk reply is returned.</source>
          <target state="translated">Если объект,который вы пытаетесь осмотреть,отсутствует,возвращается нулевой массовый ответ.</target>
        </trans-unit>
        <trans-unit id="ed8b33783f226cf240802124131a6b3112f200a2" translate="yes" xml:space="preserve">
          <source>If the script already called write commands the only allowed command becomes &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; that stops the server without saving the current data set on disk (basically the server is aborted).</source>
          <target state="translated">Если сценарий уже вызвал команды записи, единственной допустимой командой становится &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; , которая останавливает сервер без сохранения текущего набора данных на диске (в основном сервер прерывается).</target>
        </trans-unit>
        <trans-unit id="7d7312df2553f6628fdfae5411ba0776826d8dfb" translate="yes" xml:space="preserve">
          <source>If the script already performed write operations it can not be killed in this way because it would violate Lua script atomicity contract. In such a case only &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; is able to kill the script, killing the Redis process in an hard way preventing it to persist with half-written information.</source>
          <target state="translated">Если скрипт уже выполнял операции записи, его нельзя убить таким образом, потому что это нарушит контракт атомарности скрипта Lua. В таком случае только &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; может убить скрипт, жестко убивая процесс Redis, предотвращая его сохранение с наполовину записанной информацией.</target>
        </trans-unit>
        <trans-unit id="5aeedf1a85f8e143cfd4057ccfb92d5e01611feb" translate="yes" xml:space="preserve">
          <source>If the server does not remember a script with this SHA1 digest, a special error is returned telling the client to use &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; instead.</source>
          <target state="translated">Если сервер не помнит сценарий с этим дайджестом SHA1, возвращается специальная ошибка, в которой клиенту следует использовать &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c526024cc2b0adff52463eae82153b3e7035275" translate="yes" xml:space="preserve">
          <source>If the server is configured with the &lt;code&gt;min-slaves-to-write&lt;/code&gt; (or starting with Redis 5 with the &lt;code&gt;min-replicas-to-write&lt;/code&gt;) directive, an additional field is provided:</source>
          <target state="translated">Если сервер настроен с помощью директивы &lt;code&gt;min-slaves-to-write&lt;/code&gt; (или начиная с Redis 5 с помощью &lt;code&gt;min-replicas-to-write&lt;/code&gt; ), предоставляется дополнительное поле:</target>
        </trans-unit>
        <trans-unit id="160c785d0bbfa994844826d34af71d6ba78bcac0" translate="yes" xml:space="preserve">
          <source>If the server still remembers a script with a matching SHA1 digest, the script is executed.</source>
          <target state="translated">Если сервер все еще помнит скрипт с соответствующим SHA1 дайджестом,то скрипт выполняется.</target>
        </trans-unit>
        <trans-unit id="a73ff8adff60cf3faa9396c7d82031cce8e1eee5" translate="yes" xml:space="preserve">
          <source>If the slot is in &lt;em&gt;migrating&lt;/em&gt; state, the state gets cleared when the slot is assigned to another node.</source>
          <target state="translated">Если слот находится в состоянии &lt;em&gt;миграции&lt;/em&gt; , состояние очищается, когда слот назначается другому узлу.</target>
        </trans-unit>
        <trans-unit id="4fb7824817ed0173726151921ede13e72a5a9bcf" translate="yes" xml:space="preserve">
          <source>If the slot was in &lt;em&gt;importing&lt;/em&gt; state in the node receiving the command, and the command assigns the slot to this node (which happens in the target node at the end of the resharding of a hash slot from one node to another), the command has the following side effects: A) the &lt;em&gt;importing&lt;/em&gt; state is cleared. B) If the node config epoch is not already the greatest of the cluster, it generates a new one and assigns the new config epoch to itself. This way its new hash slot ownership will win over any past configuration created by previous failovers or slot migrations.</source>
          <target state="translated">Если слот находился в состоянии &lt;em&gt;импорта&lt;/em&gt; в узле, принимающем команду, и команда назначает слот этому узлу (что происходит в целевом узле в конце перешардинга хэш-слота от одного узла к другому), команда имеет следующие побочные эффекты: A) состояние &lt;em&gt;импорта&lt;/em&gt; очищено. B) Если эпоха конфигурации узла еще не является самой большой в кластере, она генерирует новую и назначает новую эпоху конфигурации себе. Таким образом, его новое владение хеш-слотом победит любую предыдущую конфигурацию, созданную предыдущими отработками отказа или миграциями слотов.</target>
        </trans-unit>
        <trans-unit id="e8cd47d9356aab972b5f2bd3e87e1b06b6cacf48" translate="yes" xml:space="preserve">
          <source>If the source set does not exist or does not contain the specified element, no operation is performed and &lt;code&gt;0&lt;/code&gt; is returned. Otherwise, the element is removed from the source set and added to the destination set. When the specified element already exists in the destination set, it is only removed from the source set.</source>
          <target state="translated">Если исходный набор не существует или не содержит указанный элемент, никакая операция не выполняется и возвращается &lt;code&gt;0&lt;/code&gt; . В противном случае элемент удаляется из исходного набора и добавляется в целевой набор. Если указанный элемент уже существует в целевом наборе, он удаляется только из исходного набора.</target>
        </trans-unit>
        <trans-unit id="da52acca0f5817a572a7d2dfec4d48663d8d1b71" translate="yes" xml:space="preserve">
          <source>If the user inserts all the elements in a sorted set with the same score (for example 0), all the elements of the sorted set are sorted lexicographically, and range queries on elements are possible using the command &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; (Note: it is also possible to query sorted sets by range of scores using &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;).</source>
          <target state="translated">Если пользователь вставляет все элементы в отсортированный набор с одинаковой оценкой (например, 0), все элементы отсортированного набора сортируются лексикографически, и запросы диапазона для элементов возможны с помощью команды &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; (Примечание: также возможно для запроса отсортированных наборов по диапазону оценок с помощью &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bb5f5ae1336c1db943d20a454954235747a6d64e" translate="yes" xml:space="preserve">
          <source>If the user will be idle more than 60 seconds, the key will be deleted and only subsequent page views that have less than 60 seconds of difference will be recorded.</source>
          <target state="translated">Если пользователь простаивает более 60 секунд,ключ будет удален,и будут записаны только последующие просмотры страниц с разницей менее 60 секунд.</target>
        </trans-unit>
        <trans-unit id="dca107e1698238aa60bfb450d46b8e949be6578e" translate="yes" xml:space="preserve">
          <source>If there are no keys to migrate in the source instance &lt;code&gt;NOKEY&lt;/code&gt; is returned. Because missing keys are possible in normal conditions, from expiry for example, &lt;code&gt;NOKEY&lt;/code&gt; isn't an error.</source>
          <target state="translated">Если в исходном экземпляре нет ключей для миграции, возвращается &lt;code&gt;NOKEY&lt;/code&gt; . Поскольку отсутствие ключей возможно в обычных условиях, например, по истечении срока действия, &lt;code&gt;NOKEY&lt;/code&gt; не является ошибкой.</target>
        </trans-unit>
        <trans-unit id="65645be10cc140f75bd2c8251142687f4fa78461" translate="yes" xml:space="preserve">
          <source>If we generate a configuration epoch which happens to collide with another instance, eventually our configuration epoch, or the one of another instance with our same epoch, will be moved away using the &lt;em&gt;configuration epoch collision resolution algorithm&lt;/em&gt;.</source>
          <target state="translated">Если мы генерируем эпоху конфигурации, которая сталкивается с другим экземпляром, в конечном итоге наша эпоха конфигурации или эпоха другого экземпляра с той же эпохой будет удалена с использованием &lt;em&gt;алгоритма разрешения конфликтов эпохи конфигурации&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b6f79d56180a9ad1d3aeb8220feacf255be61da4" translate="yes" xml:space="preserve">
          <source>If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1, the function returns the first bit not part of the string on the right. So if the string is three bytes set to the value &lt;code&gt;0xff&lt;/code&gt; the command &lt;code&gt;BITPOS key 0&lt;/code&gt; will return 24, since up to bit 23 all the bits are 1.</source>
          <target state="translated">Если мы ищем чистые биты (битовый аргумент равен 0), а строка содержит только бит, установленный в 1, функция возвращает первый бит, а не часть строки справа. Таким образом, если строка состоит из трех байтов, для которых установлено значение &lt;code&gt;0xff&lt;/code&gt; , команда &lt;code&gt;BITPOS key 0&lt;/code&gt; вернет 24, поскольку до бита 23 все биты равны 1.</target>
        </trans-unit>
        <trans-unit id="44b33ba5659f824ae39b000fc70d2cf7d6138c7b" translate="yes" xml:space="preserve">
          <source>If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is returned.</source>
          <target state="translated">Если мы ищем установленные биты (аргумент бит равен 1),а строка пуста или состоит только из нулевых байт,то возвращается -1.</target>
        </trans-unit>
        <trans-unit id="2012c008377fbb50737408462ade88dce859c2ba" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; or &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt;, there's no need to manually call &lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt;.</source>
          <target state="translated">Если вы вызываете &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; или &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; , нет необходимости вручную вызывать &lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7adf0ee2bf057d6e4f3261ad571f6a13a6962d80" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want all the clients to get all the messages, you do not need a consumer group.</source>
          <target state="translated">Если у вас есть поток и несколько клиентов,и вы хотите,чтобы все клиенты получали все сообщения,вам не нужна группа потребителей.</target>
        </trans-unit>
        <trans-unit id="560057ad39d223339741232ee3fcc91b0feb1edf" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want the stream to be &lt;em&gt;partitioned&lt;/em&gt; or &lt;em&gt;shareded&lt;/em&gt; across your clients, so that each client will get a sub set of the messages arriving in a stream, you need a consumer group.</source>
          <target state="translated">Если у вас есть поток и несколько клиентов, и вы хотите, чтобы поток был &lt;em&gt;разделен&lt;/em&gt; или &lt;em&gt;совместно использовался&lt;/em&gt; вашими клиентами, чтобы каждый клиент получал подмножество сообщений, поступающих в поток, вам нужна группа потребителей.</target>
        </trans-unit>
        <trans-unit id="b31dd57013b909fbb7b7346c7faa280640e4841b" translate="yes" xml:space="preserve">
          <source>If you like science fiction, think of time flowing at infinite speed inside a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block...</source>
          <target state="translated">Если вам нравится научная фантастика, подумайте о времени, текущем с бесконечной скоростью внутри блока &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; ...</target>
        </trans-unit>
        <trans-unit id="c010cb9076ea01e47bb02d7ca64129ac264912a3" translate="yes" xml:space="preserve">
          <source>If you look for an &lt;code&gt;XGET&lt;/code&gt; command you'll be disappointed because &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; is effectively the way to go in order to fetch a single entry from a stream. All you have to do is to specify the ID two times in the arguments of XRANGE:</source>
          <target state="translated">Если вы &lt;code&gt;XGET&lt;/code&gt; команду XGET, вы будете разочарованы, потому что &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; - это эффективный способ получить одну запись из потока. Все, что вам нужно сделать, это указать идентификатор два раза в аргументах XRANGE:</target>
        </trans-unit>
        <trans-unit id="9b173c7e7e26659d2dc21433cf73d902805a206a" translate="yes" xml:space="preserve">
          <source>If you request details about non-existing commands, their return position will be nil.</source>
          <target state="translated">Если вы запросите информацию о несуществующих командах,их возвращаемая позиция будет равна нулю.</target>
        </trans-unit>
        <trans-unit id="12acfb0048a8a9bf03f38f7e388902128cc410f3" translate="yes" xml:space="preserve">
          <source>Imagine you have a web service and you are interested in the latest N pages &lt;em&gt;recently&lt;/em&gt; visited by your users, such that each adjacent page view was not performed more than 60 seconds after the previous. Conceptually you may consider this set of page views as a &lt;em&gt;Navigation session&lt;/em&gt; of your user, that may contain interesting information about what kind of products he or she is looking for currently, so that you can recommend related products.</source>
          <target state="translated">Представьте, что у вас есть веб-служба, и вас интересуют последние N страниц, которые &lt;em&gt;недавно&lt;/em&gt; посещали ваши пользователи, так что просмотр каждой соседней страницы не выполнялся более чем через 60 секунд после предыдущей. Концептуально вы можете рассматривать этот набор просмотров страниц как &lt;em&gt;сеанс навигации&lt;/em&gt; вашего пользователя, который может содержать интересную информацию о том, какие продукты он или она ищет в настоящее время, чтобы вы могли рекомендовать связанные продукты.</target>
        </trans-unit>
        <trans-unit id="3fb9a33bf9d1d9a11eb463de937edd8bbe41eff8" translate="yes" xml:space="preserve">
          <source>Imagine you have elements A, B and C with weights 1, 2 and 3. You compute the sum of the weights, which is 1+2+3 = 6</source>
          <target state="translated">Представьте,что у вас есть элементы A,B и C с весами 1,2 и 3.Вы вычисляете сумму весов,которая составляет 1+2+3=6.</target>
        </trans-unit>
        <trans-unit id="28adac3b6124834ed39c280b45702edaf27ac85d" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">Реализуйте &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">Детали внедрения</target>
        </trans-unit>
        <trans-unit id="11672e7162d8cdc131bd8b02c509dcb60a9d776d" translate="yes" xml:space="preserve">
          <source>Implementation details and notes</source>
          <target state="translated">Детали и примечания по осуществлению</target>
        </trans-unit>
        <trans-unit id="cc7649d9b862b15149646b67450f76a9d95f07c8" translate="yes" xml:space="preserve">
          <source>Implementation details: MEET and PING packets</source>
          <target state="translated">Детали реализации:Пакеты MEET и PING</target>
        </trans-unit>
        <trans-unit id="c5a3d437892d8fb38c145f676153ba0009f546b9" translate="yes" xml:space="preserve">
          <source>Important: &lt;strong&gt;there is no need to use the same COUNT value&lt;/strong&gt; for every iteration. The caller is free to change the count from one iteration to the other as required, as long as the cursor passed in the next call is the one obtained in the previous call to the command.</source>
          <target state="translated">Важно: &lt;strong&gt;нет необходимости использовать одно и то же значение COUNT&lt;/strong&gt; для каждой итерации. Вызывающий может изменять счетчик от одной итерации к другой по мере необходимости, пока курсор, переданный в следующем вызове, является курсором, полученным в предыдущем вызове команды.</target>
        </trans-unit>
        <trans-unit id="b6980584e557c93bab34f4259447d38dd3a9c928" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are emitted in the &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output as follows:</source>
          <target state="translated">Слоты импорта и миграции выводятся в выходных данных &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="50ac60eae9cbac9b1534be93c64ff4eb8e05e3df" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are provided as &lt;strong&gt;additional info&lt;/strong&gt;. If the node has a given hash slot assigned, it will be also a plain number in the list of hash slots, so clients that don't have a clue about hash slots migrations can just skip this special fields.</source>
          <target state="translated">Импорт и мигрирующие слотов предоставляются в качестве &lt;strong&gt;дополнительной информации&lt;/strong&gt; . Если узлу назначен данный хэш-слот, он также будет простым числом в списке хеш-слотов, поэтому клиенты, которые не имеют представления о миграции хэш-слотов, могут просто пропустить эти специальные поля.</target>
        </trans-unit>
        <trans-unit id="e69ceca772f34d784aadd1c27595fdabe97b5262" translate="yes" xml:space="preserve">
          <source>In Redis 2.4 the expire might not be pin-point accurate, and it could be between zero to one seconds out.</source>
          <target state="translated">В Redis 2.4 срок годности может быть неточным,и может находиться в диапазоне от нуля до одной секунды.</target>
        </trans-unit>
        <trans-unit id="404f7b7c02b7867c0901ee21294f6e2f5fef0d3c" translate="yes" xml:space="preserve">
          <source>In Redis 2.6 or older the command returns &lt;code&gt;-1&lt;/code&gt; if the key does not exist or if the key exist but has no associated expire.</source>
          <target state="translated">В Redis 2.6 и старше команда возвращает &lt;code&gt;-1&lt;/code&gt; , если ключ не существует или если ключ существует, но не имеет связанного срока действия.</target>
        </trans-unit>
        <trans-unit id="8b69e0b775a7565070cf9c5f2db4bd807c015a5f" translate="yes" xml:space="preserve">
          <source>In Redis Cluster, each node keeps track of which master is serving a particular hash slot.</source>
          <target state="translated">В кластере Redis каждый узел отслеживает,какой мастер обслуживает определенный слот для хэша.</target>
        </trans-unit>
        <trans-unit id="d0bdbf698aa8eaf887d7877ad1c2d9ea20b7520a" translate="yes" xml:space="preserve">
          <source>In Redis versions prior &lt;strong&gt;2.1.3&lt;/strong&gt; altering a key with an expire set using a command altering its value had the effect of removing the key entirely. This semantics was needed because of limitations in the replication layer that are now fixed.</source>
          <target state="translated">В версиях Redis до &lt;strong&gt;2.1.3&lt;/strong&gt; изменение ключа с установленным сроком действия с помощью команды, изменяющей его значение, приводило к полному удалению ключа. Эта семантика была необходима из-за ограничений на уровне репликации, которые теперь исправлены.</target>
        </trans-unit>
        <trans-unit id="34f272b3296928896a7fa9c51b4f28ffa23b9540" translate="yes" xml:space="preserve">
          <source>In future versions of Redis it is possible that we'll trigger a node garbage collection in case a given macro-node reaches a given amount of deleted entries. Currently with the usage we anticipate for this data structure, it is not a good idea to add such complexity.</source>
          <target state="translated">В будущих версиях Redis можно запускать сбор мусора узлов в случае,если заданный макрос-узел достигнет заданного количества удаленных записей.В настоящее время при использовании,которое мы ожидаем для этой структуры данных,не стоит добавлять такую сложность.</target>
        </trans-unit>
        <trans-unit id="420ffa2728e82649ac426218fc502611ceb5c012" translate="yes" xml:space="preserve">
          <source>In general what you should know is that setting the &lt;code&gt;appendonly&lt;/code&gt; parameter to &lt;code&gt;yes&lt;/code&gt; will start a background process to save the initial append-only file (obtained from the in memory data set), and will append all the subsequent commands on the append-only file, thus obtaining exactly the same effect of a Redis server that started with AOF turned on since the start.</source>
          <target state="translated">В общем, вы должны знать, что установка для параметра &lt;code&gt;appendonly&lt;/code&gt; значения &lt;code&gt;yes&lt;/code&gt; запустит фоновый процесс для сохранения исходного файла только для добавления (полученного из набора данных в памяти) и добавит все последующие команды в файл только для добавления , таким образом получая точно такой же эффект, как и на сервере Redis, который запускался с включенным с самого начала AOF.</target>
        </trans-unit>
        <trans-unit id="464e556758431df2768b0136fb61ecadb0a9af07" translate="yes" xml:space="preserve">
          <source>In its synchronous form, the command can get new data as long as there are more items available. However, at some point, we'll have to wait for producers of data to use &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; to push new entries inside the streams we are consuming. In order to avoid polling at a fixed or adaptive interval the command is able to block if it could not return any data, according to the specified streams and IDs, and automatically unblock once one of the requested keys accept data.</source>
          <target state="translated">В синхронной форме команда может получать новые данные, если доступно больше элементов. Однако в какой-то момент нам придется подождать, пока производители данных не будут использовать &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; для проталкивания новых записей в потоки, которые мы потребляем. Чтобы избежать опроса с фиксированным или адаптивным интервалом, команда может блокировать, если она не может вернуть какие-либо данные в соответствии с указанными потоками и идентификаторами, и автоматически разблокировать, как только один из запрошенных ключей примет данные.</target>
        </trans-unit>
        <trans-unit id="f71d43ee55e218973fa1e5cb6ebd10de6f4de1c3" translate="yes" xml:space="preserve">
          <source>In options where bytes or other quantities are specified, it is not possible to use the &lt;code&gt;redis.conf&lt;/code&gt; abbreviated form (&lt;code&gt;10k&lt;/code&gt;, &lt;code&gt;2gb&lt;/code&gt; ... and so forth), everything should be specified as a well-formed 64-bit integer, in the base unit of the configuration directive. However since Redis version 3.0 or greater, it is possible to use &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; with memory units for &lt;code&gt;maxmemory&lt;/code&gt;, client output buffers, and replication backlog size.</source>
          <target state="translated">В опциях, где указаны байты или другие количества, невозможно использовать сокращенную форму &lt;code&gt;redis.conf&lt;/code&gt; ( &lt;code&gt;10k&lt;/code&gt; , &lt;code&gt;2gb&lt;/code&gt; ... и т. Д.), Все должно быть указано как правильно сформированное 64-битное целое число в базовый блок директивы конфигурации. Однако, начиная с Redis версии 3.0 или выше, можно использовать &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; с модулями памяти для &lt;code&gt;maxmemory&lt;/code&gt; , клиентскими буферами вывода и размером невыполненного журнала репликации.</target>
        </trans-unit>
        <trans-unit id="74befe185bf5845d0b7429c8d4ecaac4587e1561" translate="yes" xml:space="preserve">
          <source>In order to avoid these problems while avoiding the bandwidth penalty, Redis implements the &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; command.</source>
          <target state="translated">Чтобы избежать этих проблем, избегая &lt;a href=&quot;evalsha&quot;&gt;потери&lt;/a&gt; полосы пропускания, Redis реализует команду EVALSHA .</target>
        </trans-unit>
        <trans-unit id="4e60382da8db79c78bf47f321f4d7ec3aa869b88" translate="yes" xml:space="preserve">
          <source>In order to block, the &lt;strong&gt;BLOCK&lt;/strong&gt; option is used, together with the number of milliseconds we want to block before timing out. Normally Redis blocking commands take timeouts in seconds, however this command takes a millisecond timeout, even if normally the server will have a timeout resolution near to 0.1 seconds. This time it is possible to block for a shorter time in certain use cases, and if the server internals will improve over time, it is possible that the resolution of timeouts will improve.</source>
          <target state="translated">Для блокировки используется опция &lt;strong&gt;BLOCK&lt;/strong&gt; вместе с количеством миллисекунд, которое мы хотим заблокировать до истечения времени ожидания. Обычно команды блокировки Redis берут тайм-аут в секундах, однако эта команда занимает миллисекундный тайм-аут, даже если обычно сервер имеет разрешение тайм-аута около 0,1 секунды. На этот раз в определенных случаях использования можно заблокировать на более короткое время, и если внутреннее устройство сервера со временем улучшится, возможно, улучшится разрешение тайм-аутов.</target>
        </trans-unit>
        <trans-unit id="0040f93cb8c4b8bdab630ff12697ba1b0160ca64" translate="yes" xml:space="preserve">
          <source>In order to enable script effects replication, you need to issue the following Lua command before any write operated by the script:</source>
          <target state="translated">Для того,чтобы включить репликацию скриптовых эффектов,вам нужно выпустить следующую команду Lua перед любой записью,управляемой сценарием:</target>
        </trans-unit>
        <trans-unit id="013756f6d564f805aee9f75f0b5914a1c30d7b5d" translate="yes" xml:space="preserve">
          <source>In order to enable this form, the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; option is used, and the normal &lt;em&gt;key&lt;/em&gt; argument is set to an empty string. The actual key names will be provided after the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; argument itself, like in the following example:</source>
          <target state="translated">Чтобы включить эту форму, используется опция &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; , а в качестве аргумента обычного &lt;em&gt;ключа&lt;/em&gt; устанавливается пустая строка. Фактические имена ключей будут указаны после самого аргумента &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; , как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="7e7cf3fffb86f4198755cdccfe390f7daca4376b" translate="yes" xml:space="preserve">
          <source>In order to enforce this behavior in scripts Redis does the following:</source>
          <target state="translated">Для того,чтобы навязать такое поведение в скриптах,Redis делает следующее:</target>
        </trans-unit>
        <trans-unit id="4210ec3e973c5d5ac271cc1ab7ffcffaa3f2c4da" translate="yes" xml:space="preserve">
          <source>In order to fix a broken cluster where certain slots are unassigned.</source>
          <target state="translated">Для исправления сломанного кластера,в котором некоторые слоты не назначены.</target>
        </trans-unit>
        <trans-unit id="4708216948f38c6f376d2b00aef53c77bfc810bd" translate="yes" xml:space="preserve">
          <source>In order to iterate a stream, we can proceed as follows. Let's assume that we want two elements per iteration. We start fetching the first two elements, which is trivial:</source>
          <target state="translated">Для того,чтобы выполнить итерацию потока,мы можем действовать следующим образом.Предположим,что нам нужны два элемента на одну итерацию.Мы начнем извлекать первые два элемента,что тривиально:</target>
        </trans-unit>
        <trans-unit id="93f82278196654b93d4f14013ea15fe416b7d299" translate="yes" xml:space="preserve">
          <source>In order to make it a pure function, but still be sure that every invocation of the script will result in different random elements, we can simply add an additional argument to the script that will be used in order to seed the Lua pseudo-random number generator. The new script is as follows:</source>
          <target state="translated">Для того,чтобы сделать его чистой функции,но все же будьте уверены,что каждый вызов сценария приведет к различным случайным элементам,мы можем просто добавить дополнительный аргумент в сценарий,который будет использоваться для того,чтобы посеять Lua генератор псевдослучайных чисел.Новый сценарий выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="5e754dbb6b6073549994be57928409b8a9518fbf" translate="yes" xml:space="preserve">
          <source>In order to make sure the redis.conf file is always consistent, that is, on errors or crashes you always end with the old file, or the new one, the rewrite is performed with a single &lt;code&gt;write(2)&lt;/code&gt; call that has enough content to be at least as big as the old file. Sometimes additional padding in the form of comments is added in order to make sure the resulting file is big enough, and later the file gets truncated to remove the padding at the end.</source>
          <target state="translated">Чтобы файл redis.conf всегда был согласован, то есть при ошибках или сбоях вы всегда заканчиваете старый файл или новый, перезапись выполняется одним вызовом &lt;code&gt;write(2)&lt;/code&gt; который имеет достаточно содержимого. быть как минимум такого же размера, как старый файл. Иногда добавляется дополнительное заполнение в виде комментариев, чтобы убедиться, что полученный файл достаточно велик, а позже файл усекается, чтобы удалить заполнение в конце.</target>
        </trans-unit>
        <trans-unit id="45b71d9b591350682c94742bdef7ff99466f0e92" translate="yes" xml:space="preserve">
          <source>In order to make this locking algorithm more robust, a client holding a lock should always check the timeout didn't expire before unlocking the key with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; because client failures can be complex, not just crashing but also blocking a lot of time against some operations and trying to issue &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; after a lot of time (when the LOCK is already held by another client).</source>
          <target state="translated">Чтобы сделать этот алгоритм блокировки более надежным, клиент, удерживающий блокировку, всегда должен проверять, не истек ли тайм-аут, прежде чем разблокировать ключ с помощью &lt;a href=&quot;del&quot;&gt;DEL,&lt;/a&gt; потому что сбои клиента могут быть сложными, не только сбоями, но и блокировкой большого количества времени для некоторых операций и пытается выдать &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; через много времени (когда LOCK уже удерживается другим клиентом).</target>
        </trans-unit>
        <trans-unit id="26d3078f4ebbdf0701299addb5fed6bbed540a2c" translate="yes" xml:space="preserve">
          <source>In order to obtain a correct behavior without sacrificing consistency, when a key expires, a &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation is synthesized in both the AOF file and gains all the attached replicas nodes. This way the expiration process is centralized in the master instance, and there is no chance of consistency errors.</source>
          <target state="translated">Чтобы получить правильное поведение без ущерба для согласованности, когда срок действия ключа истекает, операция &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; синтезируется в файле AOF и получает все присоединенные узлы реплик. Таким образом, процесс истечения срока действия централизован в главном экземпляре, и нет никаких шансов на ошибки согласованности.</target>
        </trans-unit>
        <trans-unit id="40403839cd4ec5549ce4c8b0b88fe76bd596deee" translate="yes" xml:space="preserve">
          <source>In other words there is a one-to-one conversion between Lua and Redis types. The following table shows you all the conversions rules:</source>
          <target state="translated">Другими словами,между типами Lua и Redis существует преобразование один в один.В следующей таблице приведены все правила преобразования:</target>
        </trans-unit>
        <trans-unit id="73283192b40f30e6bf23bca973e203da21ec7a06" translate="yes" xml:space="preserve">
          <source>In practical terms, Redis databases should mainly used in order to, if needed, separate different keys belonging to the same application, and not in order to use a single Redis instance for multiple unrelated applications.</source>
          <target state="translated">С практической точки зрения,базы данных Redis должны использоваться главным образом для того,чтобы,при необходимости,разделять различные ключи,принадлежащие одному и тому же приложению,а не для того,чтобы использовать один экземпляр Redis для нескольких несвязанных приложений.</target>
        </trans-unit>
        <trans-unit id="1cb1bb56f86e93948082da017865db052e971cd7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;COUNT&lt;/code&gt; option documentation, we state that sometimes this family of commands may return all the elements of a Set, Hash or Sorted Set at once in a single call, regardless of the &lt;code&gt;COUNT&lt;/code&gt; option value. The reason why this happens is that the cursor-based iterator can be implemented, and is useful, only when the aggregate data type that we are scanning is represented as an hash table. However Redis uses a &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;memory optimization&lt;/a&gt; where small aggregate data types, until they reach a given amount of items or a given max size of single elements, are represented using a compact single-allocation packed encoding. When this is the case, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has no meaningful cursor to return, and must iterate the whole data structure at once, so the only sane behavior it has is to return everything in a call.</source>
          <target state="translated">В документации опции &lt;code&gt;COUNT&lt;/code&gt; мы заявляем, что иногда это семейство команд может возвращать все элементы Set, Hash или Sorted Set одновременно за один вызов, независимо от значения опции &lt;code&gt;COUNT&lt;/code&gt; . Причина, по которой это происходит, заключается в том, что итератор на основе курсора может быть реализован и полезен только тогда, когда совокупный тип данных, который мы сканируем, представлен в виде хеш-таблицы. Однако Redis использует &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;оптимизацию памяти, при&lt;/a&gt; которой небольшие агрегированные типы данных, пока они не достигнут заданного количества элементов или заданного максимального размера отдельных элементов, представлены с использованием компактного упакованного кодирования с одним распределением. В этом случае &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; не имеет значимого курсора для возврата и должен перебирать всю структуру данных сразу, поэтому единственное разумное поведение, которое он имеет, - это возвращать все в вызове.</target>
        </trans-unit>
        <trans-unit id="8c0e05b70b67e4b92ac3373b78b09162115732be" translate="yes" xml:space="preserve">
          <source>In the above case the entry &lt;code&gt;1526985054069-0&lt;/code&gt; exists, otherwise the server would have sent us the next one. Using &lt;code&gt;COUNT&lt;/code&gt; is also the base in order to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; as an iterator.</source>
          <target state="translated">В приведенном выше случае существует запись &lt;code&gt;1526985054069-0&lt;/code&gt; , иначе сервер отправил бы нам следующий. Использование &lt;code&gt;COUNT&lt;/code&gt; также является основой для использования &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; в качестве итератора.</target>
        </trans-unit>
        <trans-unit id="f40be215733bf9374d8b827188eeddff85363cc0" translate="yes" xml:space="preserve">
          <source>In the above example of counting days, even after 10 years the application is online we still have just &lt;code&gt;365*10&lt;/code&gt; bits of data per user, that is just 456 bytes per user. With this amount of data &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; is still as fast as any other O(1) Redis command like &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; or &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;.</source>
          <target state="translated">В приведенном выше примере подсчета дней даже после 10 лет работы приложения в сети у нас все еще остается всего &lt;code&gt;365*10&lt;/code&gt; бит данных на пользователя, то есть всего 456 байт на пользователя. С таким объемом данных &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; по-прежнему работает так же быстро, как и любая другая команда O (1) Redis, например &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; или &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76a0365bc0972ed4321b2f354ddf621810b8b004" translate="yes" xml:space="preserve">
          <source>In the above example we claim the message with ID &lt;code&gt;1526569498055-0&lt;/code&gt;, only if the message is idle for at least one hour without the original consumer or some other consumer making progresses (acknowledging or claiming it), and assigns the ownership to the consumer &lt;code&gt;Alice&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере мы заявляем о сообщении с идентификатором &lt;code&gt;1526569498055-0&lt;/code&gt; , только если сообщение бездействует в течение как минимум одного часа, а исходный потребитель или какой-либо другой потребитель не выполняет никаких действий (подтверждая или заявляя его), и передаёт право владения потребителю &lt;code&gt;Alice&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bef89cf285951fc9b88c842b027336864d10794" translate="yes" xml:space="preserve">
          <source>In the above example you can see that the reported information are the number of elements of the stream, details about the radix tree representing the stream mostly useful for optimization and debugging tasks, the number of consumer groups associated with the stream, the last generated ID that may not be the same as the last entry ID in case some entry was deleted. Finally the full first and last entry in the stream are shown, in order to give some sense about what is the stream content.</source>
          <target state="translated">В приведенном выше примере видно,что сообщенная информация-это количество элементов потока,подробности о дереве радиксов,представляющем поток,наиболее полезном для задач оптимизации и отладки,количество групп потребителей,связанных с потоком,последний сгенерированный идентификатор,который может не совпадать с последним идентификатором записи в случае,если какая-то запись была удалена.Наконец,показывается полная первая и последняя запись в потоке,чтобы дать некоторое представление о том,что такое содержимое потока.</target>
        </trans-unit>
        <trans-unit id="5e1f5dbd04f5dc1db0a038c0d0e6f0ff4a4acd34" translate="yes" xml:space="preserve">
          <source>In the above locking algorithm there is a problem: what happens if a client fails, crashes, or is otherwise not able to release the lock? It's possible to detect this condition because the lock key contains a UNIX timestamp. If such a timestamp is equal to the current Unix time the lock is no longer valid.</source>
          <target state="translated">В описанном выше алгоритме блокировки возникает проблема:что произойдет,если клиент не справится,выйдет из строя или иным образом не сможет отпустить блокировку? Это условие можно обнаружить,так как ключ блокировки содержит временную метку UNIX.Если такая метка времени равна текущему Unix-времени,то замок больше недействителен.</target>
        </trans-unit>
        <trans-unit id="7063c49f04f76f5d83a38b2826e82b8706b19e78" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;, keys are every other position so the step value is 2. Compare with &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; above where the step value is just 1.</source>
          <target state="translated">В случае &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; ключи находятся в любой другой позиции, поэтому значение шага равно 2. Сравните с &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; выше, где значение шага равно 1.</target>
        </trans-unit>
        <trans-unit id="51cf6b9278dbdee20c8485961f1e557cd7119742" translate="yes" xml:space="preserve">
          <source>In the context of a node that has received a &lt;code&gt;DELSLOTS&lt;/code&gt; command and has consequently removed the associations for the passed hash slots, we say those hash slots are &lt;em&gt;unbound&lt;/em&gt;. Note that the existence of unbound hash slots occurs naturally when a node has not been configured to handle them (something that can be done with the &lt;code&gt;ADDSLOTS&lt;/code&gt; command) and if it has not received any information about who owns those hash slots (something that it can learn from heartbeat or update messages).</source>
          <target state="translated">В контексте узла , который получил &lt;code&gt;DELSLOTS&lt;/code&gt; команды и , следовательно , удаляются ассоциациями для пройденного хэша - слотов, мы говорим , эти хэш - слоты &lt;em&gt;несвязанные&lt;/em&gt; . Обратите внимание, что наличие несвязанных хэш-слотов возникает естественным образом, когда узел не настроен для их обработки (что можно сделать с &lt;code&gt;ADDSLOTS&lt;/code&gt; команды ADDSLOTS ) и если он не получил никакой информации о том, кому принадлежат эти хеш-слоты (что-то, что он может узнать из сообщений сердцебиения или обновления).</target>
        </trans-unit>
        <trans-unit id="0c3893e92cc9396f13c9f99b5e7ad611d2ac46c2" translate="yes" xml:space="preserve">
          <source>In the context of a stream consumer group, this command changes the ownership of a pending message, so that the new owner is the consumer specified as the command argument. Normally this is what happens:</source>
          <target state="translated">В контексте группы потребителей потока эта команда изменяет право собственности на ожидающее сообщение,так что новым владельцем является потребитель,указанный в качестве аргумента команды.Обычно так и происходит:</target>
        </trans-unit>
        <trans-unit id="57bf1b4701a5c94880ee6e46bfe56ac8c7000db8" translate="yes" xml:space="preserve">
          <source>In the example above, the first call uses zero as a cursor, to start the iteration. The second call uses the cursor returned by the previous call as the first element of the reply, that is, 17.</source>
          <target state="translated">В приведенном выше примере первый вызов использует ноль в качестве курсора,чтобы начать итерацию.При втором вызове в качестве первого элемента ответа используется курсор,возвращенный при предыдущем вызове,то есть 17.</target>
        </trans-unit>
        <trans-unit id="64f37e2cb3f5829eb3ba5c3a4f7f3eea2d872acc" translate="yes" xml:space="preserve">
          <source>In the extended form we no longer see the summary information, instead there are detailed information for each message in the pending entries list. For each message four attributes are returned:</source>
          <target state="translated">В расширенной форме мы больше не видим сводную информацию,вместо этого имеется подробная информация по каждому сообщению в списке ожидающих отправки записей.Для каждого сообщения возвращаются четыре атрибута:</target>
        </trans-unit>
        <trans-unit id="bec3c889a89e0a9bff423ca26bc6e8f597b12b82" translate="yes" xml:space="preserve">
          <source>In the following example the first call to &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not use a timeout and asks for the write to reach 1 replica. It returns with success. In the second attempt instead we put a timeout, and ask for the replication of the write to two replicas. Since there is a single replica available, after one second &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; unblocks and returns 1, the number of replicas reached.</source>
          <target state="translated">В следующем примере первый вызов &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; не использует тайм-аут и требует, чтобы запись достигла 1 реплики. Он возвращается с успехом. Во второй попытке вместо этого мы устанавливаем тайм-аут и запрашиваем репликацию записи на две реплики. Поскольку доступна одна реплика, через одну секунду &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; разблокируется и возвращает 1, количество достигнутых реплик.</target>
        </trans-unit>
        <trans-unit id="275502ca7bb30b2b024cd13d4001c3a1615096d6" translate="yes" xml:space="preserve">
          <source>In the following example we can see how floats and arrays with nils are handled:</source>
          <target state="translated">В следующем примере мы видим,как обрабатываются поплавки и массивы с нулями:</target>
        </trans-unit>
        <trans-unit id="67aa25f5afe2285456ce925944008c892a8bde6a" translate="yes" xml:space="preserve">
          <source>In the following example we'll show why the command must not just remove a given node from the nodes table, but also prevent it for being re-inserted again for some time.</source>
          <target state="translated">В следующем примере мы покажем,почему команда должна не только удалить данный узел из таблицы узлов,но и предотвратить его повторное включение на некоторое время.</target>
        </trans-unit>
        <trans-unit id="1b27ba03d8db2c5155774200622adb0e3f3e2724" translate="yes" xml:space="preserve">
          <source>In the following example you can see how the encoding changes once Redis is no longer able to use the space saving encoding.</source>
          <target state="translated">В следующем примере видно,как меняется кодировка после того,как Redis больше не может использовать кодировку,экономящую место.</target>
        </trans-unit>
        <trans-unit id="d52481dfbaf58234ade345bdada825c509d89e9a" translate="yes" xml:space="preserve">
          <source>In the specific case of the implementation of &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;, Redis remembers, for each client, the replication offset of the produced replication stream when a given write command was executed in the context of a given client. When &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; is called Redis checks if the specified number of replicas already acknowledged this offset or a greater one.</source>
          <target state="translated">В конкретном случае реализации &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; Redis запоминает для каждого клиента смещение репликации созданного потока репликации, когда данная команда записи была выполнена в контексте данного клиента. Когда &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; вызывается, Redis проверяет, подтвердило ли указанное количество реплик это смещение или большее.</target>
        </trans-unit>
        <trans-unit id="903ead95cd2a4a5b9cbb852a8e750aedc79fee51" translate="yes" xml:space="preserve">
          <source>In this case, &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; will auto-complete the start interval with &lt;code&gt;-0&lt;/code&gt; and end interval with &lt;code&gt;-18446744073709551615&lt;/code&gt;, in order to return all the entries that were generated between a given millisecond and the end of the other specified millisecond. This also means that repeating the same millisecond two times, we get all the entries within such millisecond, because the sequence number range will be from zero to the maximum.</source>
          <target state="translated">В этом случае &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; автоматически завершит начальный интервал с помощью &lt;code&gt;-0&lt;/code&gt; и конечный интервал с помощью &lt;code&gt;-18446744073709551615&lt;/code&gt; , чтобы вернуть все записи, которые были сгенерированы между данной миллисекундой и концом другой указанной миллисекунды. Это также означает, что, повторяя одну и ту же миллисекунду два раза, мы получаем все записи в пределах этой миллисекунды, потому что диапазон порядковых номеров будет от нуля до максимума.</target>
        </trans-unit>
        <trans-unit id="9a9dd8640d5d9c354f3497144f8f471bfe5130bf" translate="yes" xml:space="preserve">
          <source>In this form the command returns general information about the stream stored at the specified key.</source>
          <target state="translated">В этой форме команда возвращает общую информацию о потоке,хранящемся на указанном ключе.</target>
        </trans-unit>
        <trans-unit id="d9dc316159e0ab75070b1301d7b7adb86e569cda" translate="yes" xml:space="preserve">
          <source>In this form we just get as output all the consumer groups associated with the stream:</source>
          <target state="translated">В этой форме мы просто получаем на выходе все группы потребителей,связанные с потоком:</target>
        </trans-unit>
        <trans-unit id="ddaa9f098110e2f5ed979aa965f072762268f6b4" translate="yes" xml:space="preserve">
          <source>In this form, the command outputs the total number of pending messages for this consumer group, which is one, followed by the smallest and greatest ID among the pending messages, and then list every consumer in the consumer group with at least one pending message, and the number of pending messages it has.</source>
          <target state="translated">В этой форме команда выводит общее количество ожидающих сообщений для этой группы потребителей,которое составляет одно,за которым следует наименьший и наибольший идентификатор среди ожидающих сообщений,а затем перечисляет каждого потребителя в группе потребителей с как минимум одним ожидающим сообщения,а также количество ожидающих сообщений,которое у него есть.</target>
        </trans-unit>
        <trans-unit id="7449f50cc271410bffecdb508cde8a6a6c5d9a68" translate="yes" xml:space="preserve">
          <source>In this particular case, running a single &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; client can reduce the throughput by more than 50%. Running more &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; clients will reduce throughput even more.</source>
          <target state="translated">В этом конкретном случае запуск одного клиента &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; может снизить пропускную способность более чем на 50%. Использование большего количества клиентов &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; еще больше снизит пропускную способность.</target>
        </trans-unit>
        <trans-unit id="9499b337b96eb666a58f2a5ab4a4329e2007a622" translate="yes" xml:space="preserve">
          <source>In this replication mode, while Lua scripts are executed, Redis collects all the commands executed by the Lua scripting engine that actually modify the dataset. When the script execution finishes, the sequence of commands that the script generated are wrapped into a MULTI / EXEC transaction and are sent to replicas and AOF.</source>
          <target state="translated">В этом режиме репликации,в то время как Lua скрипты выполняются,Redis собирает все команды,выполняемые Lua скриптовый движок,которые на самом деле изменить набор данных.Когда выполнение сценария заканчивается,последовательность команд,что сгенерированный сценарий обернуты в MULTI/EXEC сделки и отправляются на реплики и AOF.</target>
        </trans-unit>
        <trans-unit id="ef44dcb3d65131c01d1f4f06af638521f8511b76" translate="yes" xml:space="preserve">
          <source>In this way the example consumer code will fetch only new messages, process them, and acknowledge them via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;. However the example code above is not complete, because it does not handle recovering after a crash. What will happen if we crash in the middle of processing messages, is that our messages will remain in the pending entries list, so we can access our history by giving &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; initially an ID of 0, and performing the same loop. Once providing and ID of 0 the reply is an empty set of messages, we know that we processed and acknowledged all the pending messages: we can start to use &lt;code&gt;&amp;gt;&lt;/code&gt; as ID, in order to get the new messages and rejoin the consumers that are processing new things.</source>
          <target state="translated">Таким образом, пример кода потребителя будет извлекать только новые сообщения, обрабатывать их и подтверждать их через &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; . Однако приведенный выше пример кода не является полным, потому что он не поддерживает восстановление после сбоя. Что произойдет, если мы выйдем из строя в середине обработки сообщений, так это то, что наши сообщения останутся в списке ожидающих записей, поэтому мы можем получить доступ к нашей истории, задав &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; изначально идентификатор 0 и выполнив тот же цикл. После предоставления и идентификатора 0 ответ представляет собой пустой набор сообщений, мы знаем, что мы обработали и подтвердили все ожидающие сообщения: мы можем начать использовать &lt;code&gt;&amp;gt;&lt;/code&gt; в качестве идентификатора, чтобы получить новые сообщения и повторно присоединиться к потребителям, которые обрабатывают новые вещи.</target>
        </trans-unit>
        <trans-unit id="0c6aff080ab580caca11c078c7c0fd0c074cc4b5" translate="yes" xml:space="preserve">
          <source>In this way when a node in migrating state generates an &lt;code&gt;ASK&lt;/code&gt; redirection, the client contacts the target node, sends &lt;code&gt;ASKING&lt;/code&gt;, and immediately after sends the command. This way commands about non-existing keys in the old node or keys already migrated to the target node are executed in the target node, so that:</source>
          <target state="translated">Таким образом, когда узел в состоянии миграции генерирует перенаправление &lt;code&gt;ASK&lt;/code&gt; , клиент связывается с целевым узлом, отправляет &lt;code&gt;ASKING&lt;/code&gt; и сразу после этого отправляет команду. Таким образом, команды для несуществующих ключей в старом узле или ключей, уже перенесенных на целевой узел, выполняются в целевом узле, так что:</target>
        </trans-unit>
        <trans-unit id="8a4976fd385ad81414ef5f0b5eb1d542ebee200c" translate="yes" xml:space="preserve">
          <source>Incomplete IDs</source>
          <target state="translated">Незавершенные документы</target>
        </trans-unit>
        <trans-unit id="d076531fdc3e2f8747b11778603627c7ff4c3c03" translate="yes" xml:space="preserve">
          <source>Increment the specified &lt;code&gt;field&lt;/code&gt; of a hash stored at &lt;code&gt;key&lt;/code&gt;, and representing a floating point number, by the specified &lt;code&gt;increment&lt;/code&gt;. If the increment value is negative, the result is to have the hash field value &lt;strong&gt;decremented&lt;/strong&gt; instead of incremented. If the field does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">Увеличивает указанное &lt;code&gt;field&lt;/code&gt; хэша, хранящегося в &lt;code&gt;key&lt;/code&gt; и представляющего число с плавающей запятой, на указанное &lt;code&gt;increment&lt;/code&gt; . Если значение приращения отрицательное, результатом будет &lt;strong&gt;уменьшение&lt;/strong&gt; значения хэш-поля вместо увеличения. Если поле не существует, перед выполнением операции ему присваивается значение &lt;code&gt;0&lt;/code&gt; . Ошибка возвращается, если возникает одно из следующих условий:</target>
        </trans-unit>
        <trans-unit id="0b2569a3073ebcb62549ecb7ec5a99e5e6f20a57" translate="yes" xml:space="preserve">
          <source>Increment the string representing a floating point number stored at &lt;code&gt;key&lt;/code&gt; by the specified &lt;code&gt;increment&lt;/code&gt;. By using a negative &lt;code&gt;increment&lt;/code&gt; value, the result is that the value stored at the key is decremented (by the obvious properties of addition). If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">Увеличивает строку, представляющую число с плавающей запятой, хранящееся в &lt;code&gt;key&lt;/code&gt; , на указанное &lt;code&gt;increment&lt;/code&gt; . Использование отрицательного значения &lt;code&gt;increment&lt;/code&gt; приводит к тому, что значение, хранящееся в ключе, уменьшается (в силу очевидных свойств сложения). Если ключ не существует, он устанавливается в &lt;code&gt;0&lt;/code&gt; перед выполнением операции. Ошибка возвращается, если возникает одно из следующих условий:</target>
        </trans-unit>
        <trans-unit id="b0ab00f78f69567a82e2e724fbf2c011708c66b2" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; does not exist the value is set to &lt;code&gt;0&lt;/code&gt; before the operation is performed.</source>
          <target state="translated">Приращивает номер , сохраненный в &lt;code&gt;field&lt;/code&gt; в хэш хранится в &lt;code&gt;key&lt;/code&gt; путем &lt;code&gt;increment&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; не существует, создается новый ключ, содержащий хеш. Если &lt;code&gt;field&lt;/code&gt; не существует, перед выполнением операции устанавливается значение &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05fa8f17b5cc5360627e65f0e1bfbcb74f909616" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">Увеличивает число, сохраненное в &lt;code&gt;key&lt;/code&gt; на &lt;code&gt;increment&lt;/code&gt; . Если ключ не существует, он устанавливается в &lt;code&gt;0&lt;/code&gt; перед выполнением операции. Ошибка возвращается, если ключ содержит значение неправильного типа или строку, которая не может быть представлена ​​как целое число. Эта операция ограничена 64-битными целыми числами со знаком.</target>
        </trans-unit>
        <trans-unit id="f9bd9898aaa3a2048914100ede9b89ccf7adc73a" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by one. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">Увеличивает число, хранящееся в &lt;code&gt;key&lt;/code&gt; на единицу. Если ключ не существует, он устанавливается в &lt;code&gt;0&lt;/code&gt; перед выполнением операции. Ошибка возвращается, если ключ содержит значение неправильного типа или строку, которая не может быть представлена ​​как целое число. Эта операция ограничена 64-битными целыми числами со знаком.</target>
        </trans-unit>
        <trans-unit id="b3b4497f3f9f641c1f07a98ba2294810e7c1c3a5" translate="yes" xml:space="preserve">
          <source>Increments the score of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, it is added with &lt;code&gt;increment&lt;/code&gt; as its score (as if its previous score was &lt;code&gt;0.0&lt;/code&gt;). If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified &lt;code&gt;member&lt;/code&gt; as its sole member is created.</source>
          <target state="translated">Увеличивает оценку &lt;code&gt;member&lt;/code&gt; в отсортированном наборе, хранящемся по &lt;code&gt;key&lt;/code&gt; на &lt;code&gt;increment&lt;/code&gt; . Если &lt;code&gt;member&lt;/code&gt; не существует в отсортированном наборе, он добавляется с &lt;code&gt;increment&lt;/code&gt; качестве его оценки (как если бы его предыдущая оценка была &lt;code&gt;0.0&lt;/code&gt; ). Если &lt;code&gt;key&lt;/code&gt; не существует, создается новый отсортированный набор с указанным &lt;code&gt;member&lt;/code&gt; качестве его единственного члена.</target>
        </trans-unit>
        <trans-unit id="b9e98de9b6972c3697024196bb1cf498f5df1583" translate="yes" xml:space="preserve">
          <source>Information about slots propagation and warnings</source>
          <target state="translated">Информация о распространении слотов и предупреждения</target>
        </trans-unit>
        <trans-unit id="df92aa3b0e06eb79bf7c8f7098db769523ac9333" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the head of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operations. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">Вставьте все указанные значения в начало списка, хранящегося в &lt;code&gt;key&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; не существует, он создается как пустой список перед выполнением операций push. Когда &lt;code&gt;key&lt;/code&gt; содержит значение, не являющееся списком, возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="d56f1eeeec0b6889ab12fc76a629d9cf4f377993" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operation. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">Вставьте все указанные значения в конец списка, хранящегося в &lt;code&gt;key&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; не существует, он создается как пустой список перед выполнением операции push. Когда &lt;code&gt;key&lt;/code&gt; содержит значение, не являющееся списком, возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="41914bb38b36cf790ad6dea5c850ff4f739bdf2f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the head of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">Вставляет &lt;code&gt;value&lt;/code&gt; в начало списка, хранящегося в &lt;code&gt;key&lt;/code&gt; , только если &lt;code&gt;key&lt;/code&gt; уже существует и содержит список. В отличие от &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; , если &lt;code&gt;key&lt;/code&gt; еще не существует , операции выполняться не будут.</target>
        </trans-unit>
        <trans-unit id="483c4cdd37e1303cef072b494af9c173f5ba1e3a" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">Вставляет &lt;code&gt;value&lt;/code&gt; в конец списка, хранящегося в &lt;code&gt;key&lt;/code&gt; , только если &lt;code&gt;key&lt;/code&gt; уже существует и содержит список. В отличие от &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; , если &lt;code&gt;key&lt;/code&gt; еще не существует , операции выполняться не будут.</target>
        </trans-unit>
        <trans-unit id="d817081530a979658954b262ec5b27debd913f6b" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt; either before or after the reference value &lt;code&gt;pivot&lt;/code&gt;.</source>
          <target state="translated">Вставки &lt;code&gt;value&lt;/code&gt; в списке хранится в &lt;code&gt;key&lt;/code&gt; либо до , либо после того, как опорное значение &lt;code&gt;pivot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b2cd21b122572712ccbe21dcfb324c039d60a6f" translate="yes" xml:space="preserve">
          <source>Instead Redis 2.4 works in a different way: clients are served &lt;em&gt;in the context&lt;/em&gt; of the push operation, so as long as &lt;code&gt;LPUSH foo a b c&lt;/code&gt; starts pushing the first element to the list, it will be delivered to the Client &lt;strong&gt;A&lt;/strong&gt;, that will receive &lt;code&gt;a&lt;/code&gt; (the first element pushed).</source>
          <target state="translated">Вместо Redis 2.4 работает по-другому: клиенты обслуживаются &lt;em&gt;в контексте&lt;/em&gt; операции нажимной, так долго , как &lt;code&gt;LPUSH foo a b c&lt;/code&gt; начинает толкая первый элемент в список, то он будет доставлен Клиент &lt;strong&gt;A&lt;/strong&gt; , который будет получать ( первый нажатый элемент). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="895d5878b1e7aebe2b652bf4030490cc648a385d" translate="yes" xml:space="preserve">
          <source>Instead of releasing the lock with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;, send a script that only removes the key if the value matches.</source>
          <target state="translated">Вместо того, чтобы снимать блокировку с помощью &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; , отправьте сценарий, который удаляет ключ, только если значение совпадает.</target>
        </trans-unit>
        <trans-unit id="e1fb6600644f1089e2f02671b1d169470ef167d3" translate="yes" xml:space="preserve">
          <source>Instead of setting a fixed string, set a non-guessable large random string, called token.</source>
          <target state="translated">Вместо того,чтобы задавать фиксированную строку,установите не угадываемую большую случайную строку,называемую токеном.</target>
        </trans-unit>
        <trans-unit id="7e8138295a5156481cc0eb58921ff5f1b45d907b" translate="yes" xml:space="preserve">
          <source>Instead, if the lock is expired because the Unix time at &lt;code&gt;lock.foo&lt;/code&gt; is older than the current Unix time, C4 tries to perform:</source>
          <target state="translated">Вместо этого, если срок действия блокировки истек, потому что время Unix в &lt;code&gt;lock.foo&lt;/code&gt; старше текущего времени Unix, C4 пытается выполнить:</target>
        </trans-unit>
        <trans-unit id="9e41d77e11789212e3a04485592bea0019722472" translate="yes" xml:space="preserve">
          <source>Instruct Redis to start an &lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;Append Only File&lt;/a&gt; rewrite process. The rewrite will create a small optimized version of the current Append Only File.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;Дайте&lt;/a&gt; указание Redis запустить процесс перезаписи файла только для добавления . Перезапись создаст небольшую оптимизированную версию текущего файла только для добавления.</target>
        </trans-unit>
        <trans-unit id="5d3a484e0575c563f1fd55a805b93fd40c42e60d" translate="yes" xml:space="preserve">
          <source>Integer reply</source>
          <target state="translated">Целочисленный ответ</target>
        </trans-unit>
        <trans-unit id="b78aed63c34c1be3f06c6bc59978ffe5ffe055ac" translate="yes" xml:space="preserve">
          <source>Introduction to EVAL</source>
          <target state="translated">Введение в EVAL</target>
        </trans-unit>
        <trans-unit id="698c191721344bee0279a531fba2023586cfe9e4" translate="yes" xml:space="preserve">
          <source>It can also take the following values:</source>
          <target state="translated">Он также может принимать следующие значения:</target>
        </trans-unit>
        <trans-unit id="35178e7f69534d7802151005b608f5f33b33d650" translate="yes" xml:space="preserve">
          <source>It contains a 64-bit checksum that is used to make sure errors will be detected. The &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command makes sure to check the checksum before synthesizing a key using the serialized value.</source>
          <target state="translated">Он содержит 64-битную контрольную сумму, которая используется для обнаружения ошибок. Команда &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; проверяет контрольную сумму перед синтезом ключа с использованием сериализованного значения.</target>
        </trans-unit>
        <trans-unit id="d3cca1eb042dc5b5456d254387aa0bc9411f0e98" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;very important&lt;/strong&gt; to understand that you should use the &lt;code&gt;$&lt;/code&gt; ID only for the first call to &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;. Later the ID should be the one of the last reported item in the stream, otherwise you could miss all the entries that are added in between.</source>
          <target state="translated">Это &lt;strong&gt;очень важно&lt;/strong&gt; понять , что вы должны использовать &lt;code&gt;$&lt;/code&gt; ID только для первого вызова &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; . Позже идентификатор должен быть одним из последних отправленных сообщений в потоке, иначе вы можете пропустить все записи, добавленные между ними.</target>
        </trans-unit>
        <trans-unit id="80e58a0abe147b5052a4b292609ed6e990761a9f" translate="yes" xml:space="preserve">
          <source>It is also possible to &lt;code&gt;GET&lt;/code&gt; the element itself using the special pattern &lt;code&gt;#&lt;/code&gt;:</source>
          <target state="translated">Также возможно &lt;code&gt;GET&lt;/code&gt; сам элемент, используя специальный шаблон &lt;code&gt;#&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="344f6904cadbf67817bc580b98a14096a5ecb81b" translate="yes" xml:space="preserve">
          <source>It is important to note that step 3 is the only time when a Redis Cluster node will create a new config epoch without agreement from other nodes. This only happens when a manual configuration is operated. However it is impossible that this creates a non-transient setup where two nodes have the same config epoch, since Redis Cluster uses a config epoch collision resolution algorithm.</source>
          <target state="translated">Важно отметить,что шаг 3-это единственное время,когда узел кластера Redis Cluster создаст новую эпоху конфигурации без согласования с другими узлами.Это происходит только при ручной настройке.Однако невозможно,чтобы это создало непереходящую установку,где два узла имеют одну и ту же эпоху конфигурирования,так как Redis Cluster использует алгоритм разрешения столкновений конфиговой эпохи.</target>
        </trans-unit>
        <trans-unit id="75e2007346bb90c5a30dbb62b43b72fa8d6f2346" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;strong&gt;MATCH&lt;/strong&gt; filter is applied after elements are retrieved from the collection, just before returning data to the client. This means that if the pattern matches very little elements inside the collection, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; will likely return no elements in most iterations. An example is shown below:</source>
          <target state="translated">Важно отметить, что фильтр &lt;strong&gt;MATCH&lt;/strong&gt; применяется после извлечения элементов из коллекции, непосредственно перед возвратом данных клиенту. Это означает, что если шаблон соответствует очень маленьким элементам внутри коллекции, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; , скорее всего, не вернет никаких элементов в большинстве итераций. Пример показан ниже:</target>
        </trans-unit>
        <trans-unit id="c6bd66f1e8688cc2dae7b39af1276712b3930256" translate="yes" xml:space="preserve">
          <source>It is important to understand that this command is &lt;em&gt;fans out&lt;/em&gt; to all the clients that are waiting for the same range of IDs, so every consumer will get a copy of the data, unlike to what happens when blocking list pop operations are used.</source>
          <target state="translated">Важно понимать, что эта команда &lt;em&gt;распространяется&lt;/em&gt; для всех клиентов, ожидающих одного и того же диапазона идентификаторов, поэтому каждый потребитель получит копию данных, в отличие от того, что происходит при использовании всплывающих операций списка блокировки.</target>
        </trans-unit>
        <trans-unit id="c855a69b0dba328dc98ac3bd3b714e220d6e64d4" translate="yes" xml:space="preserve">
          <source>It is never repeated, so if &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; returns the same number, the caller can be sure that the underlying client did not disconnect and reconnect the connection, but it is still the same connection.</source>
          <target state="translated">Он никогда не повторяется, поэтому, если &lt;a href=&quot;client-id&quot;&gt;ИД КЛИЕНТА&lt;/a&gt; возвращает тот же номер, вызывающий может быть уверен, что базовый клиент не отключил и не подключил повторно соединение, но это все равно то же соединение.</target>
        </trans-unit>
        <trans-unit id="18c6232a5064b912687168695e794e952ea903ef" translate="yes" xml:space="preserve">
          <source>It is not possible for the key to get lost in the event of a timeout, but the client calling &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;, in the event of a timeout error, should check if the key is &lt;em&gt;also&lt;/em&gt; present in the target instance and act accordingly.</source>
          <target state="translated">Невозможно потерять ключ в случае тайм-аута, но клиент, вызывающий &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; , в случае ошибки тайм-аута должен проверить, присутствует ли ключ &lt;em&gt;также&lt;/em&gt; в целевом экземпляре, и действовать соответственно.</target>
        </trans-unit>
        <trans-unit id="7a383107db035b97cc0f3e4c5c6844b9b02c255f" translate="yes" xml:space="preserve">
          <source>It is possible for an infinite number of clients to iterate the same collection at the same time, as the full state of the iterator is in the cursor, that is obtained and returned to the client at every call. Server side no state is taken at all.</source>
          <target state="translated">Возможно,что бесконечное количество клиентов может итерировать одну и ту же коллекцию одновременно,так как полное состояние итератора находится в курсоре,который получается и возвращается клиенту при каждом вызове.Со стороны сервера состояние не принимается вообще.</target>
        </trans-unit>
        <trans-unit id="a485e395caaea14094a0b8ec68e5e3e0a8915e73" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; using as argument a key that already has an existing expire set. In this case the time to live of a key is &lt;em&gt;updated&lt;/em&gt; to the new value. There are many useful applications for this, an example is documented in the &lt;em&gt;Navigation session&lt;/em&gt; pattern section below.</source>
          <target state="translated">Можно вызвать &lt;a href=&quot;expire&quot;&gt;EXPIRE,&lt;/a&gt; используя в качестве аргумента ключ, для которого уже установлен срок действия. В этом случае время жизни ключа &lt;em&gt;обновляется&lt;/em&gt; до нового значения. Для этого существует множество полезных приложений, пример которых задокументирован в разделе &amp;laquo; Шаблон &lt;em&gt;сеанса навигации&lt;/em&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="a7f5fb81c26b1abadccf00465e65f7fa65dea140" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; inside Lua scripts like with normal clients, However one subtle aspect of the behavior changes between Redis 2.8.11 and Redis 2.8.12. Before the 2.8.12 release the database selected by the Lua script was &lt;em&gt;transferred&lt;/em&gt; to the calling script as current database. Starting from Redis 2.8.12 the database selected by the Lua script only affects the execution of the script itself, but does not modify the database selected by the client calling the script.</source>
          <target state="translated">Можно вызвать &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; внутри сценариев Lua, как и в случае с обычными клиентами, однако один тонкий аспект поведения меняется между Redis 2.8.11 и Redis 2.8.12. До выпуска 2.8.12 база данных, выбранная сценарием Lua, &lt;em&gt;передавалась&lt;/em&gt; вызывающему сценарию в качестве текущей базы данных. Начиная с Redis 2.8.12, база данных, выбранная сценарием Lua, влияет только на выполнение самого сценария, но не изменяет базу данных, выбранную клиентом, вызывающим сценарий.</target>
        </trans-unit>
        <trans-unit id="0958a04d7552830b3684f48a6c436807896935c0" translate="yes" xml:space="preserve">
          <source>It is possible to call Redis commands from a Lua script using two different Lua functions:</source>
          <target state="translated">Можно вызывать команды Redis из скрипта Lua,используя две различные функции Lua:</target>
        </trans-unit>
        <trans-unit id="b0a209f43840d7a1f6f04e02663cf8a792cab884" translate="yes" xml:space="preserve">
          <source>It is possible to entirely remove the connection name setting it to the empty string, that is not a valid connection name since it serves to this specific purpose.</source>
          <target state="translated">Можно полностью удалить имя соединения,установив его в пустую строку,что не является действительным именем соединения,так как оно служит именно этой цели.</target>
        </trans-unit>
        <trans-unit id="db23050fd5ba19a3417f8b624df748886d949634" translate="yes" xml:space="preserve">
          <source>It is possible to get just the length of the slow log using the command &lt;strong&gt;SLOWLOG LEN&lt;/strong&gt;.</source>
          <target state="translated">Можно получить только длину медленного журнала, используя команду &lt;strong&gt;SLOWLOG LEN&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="db19130f0bd00fca33ef9a77ffc0a1ce2466b31d" translate="yes" xml:space="preserve">
          <source>It is possible to give the command in the following special form in order to make it more efficient:</source>
          <target state="translated">Чтобы сделать команду более эффективной,можно дать команду в следующей специальной форме:</target>
        </trans-unit>
        <trans-unit id="e24f1bfbfced0e2fc3e90a67dd138360e0226aa2" translate="yes" xml:space="preserve">
          <source>It is possible to limit the size of the stream to a maximum number of elements using the &lt;strong&gt;MAXLEN&lt;/strong&gt; option.</source>
          <target state="translated">Можно ограничить размер потока максимальным количеством элементов с &lt;strong&gt;помощью&lt;/strong&gt; опции &lt;strong&gt;MAXLEN&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ee2ff105ab5c2c719dd08acac18181138935047b" translate="yes" xml:space="preserve">
          <source>It is possible to make this system more robust modifying the unlock schema as follows:</source>
          <target state="translated">Можно сделать эту систему более надежной,модифицируя схему разблокировки следующим образом:</target>
        </trans-unit>
        <trans-unit id="493e108b328a9e96e14d97d5ac7db908da18cbb1" translate="yes" xml:space="preserve">
          <source>It is possible to modify the maximum time a script can be executed with millisecond precision, either via &lt;code&gt;redis.conf&lt;/code&gt; or using the CONFIG GET / CONFIG SET command. The configuration parameter affecting max execution time is called &lt;code&gt;lua-time-limit&lt;/code&gt;.</source>
          <target state="translated">Можно изменить максимальное время, в течение которого сценарий может выполняться с точностью до миллисекунды, либо через &lt;code&gt;redis.conf&lt;/code&gt; , либо с помощью команды CONFIG GET / CONFIG SET. Параметр конфигурации, влияющий на максимальное время выполнения, называется &lt;code&gt;lua-time-limit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16570d1ed8c0ba499d85c4796bacd5587bfbf468" translate="yes" xml:space="preserve">
          <source>It is possible to only iterate elements matching a given glob-style pattern, similarly to the behavior of the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; command that takes a pattern as only argument.</source>
          <target state="translated">Можно перебирать только элементы, соответствующие заданному шаблону стиля глобуса, аналогично поведению команды &lt;a href=&quot;keys&quot;&gt;KEYS,&lt;/a&gt; которая принимает шаблон как единственный аргумент.</target>
        </trans-unit>
        <trans-unit id="4c90a5608f4fab2983bbd179b23cb40526ff6f3e" translate="yes" xml:space="preserve">
          <source>It is possible to pass the &lt;code&gt;WITHSCORES&lt;/code&gt; option in order to return the scores of the elements together with the elements. The returned list will contain &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; instead of &lt;code&gt;value1,...,valueN&lt;/code&gt;. Client libraries are free to return a more appropriate data type (suggestion: an array with (value, score) arrays/tuples).</source>
          <target state="translated">Можно передать опцию &lt;code&gt;WITHSCORES&lt;/code&gt; , чтобы возвращать оценки элементов вместе с элементами. &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; список будет содержать значение1, счет1, ..., значениеN, счетN вместо значения1 &lt;code&gt;value1,...,valueN&lt;/code&gt; . Клиентские библиотеки могут возвращать более подходящий тип данных (предложение: массив с массивами / кортежами (значение, оценка)).</target>
        </trans-unit>
        <trans-unit id="5fd91c3878c3497da37709cc86d8056d11e4d945" translate="yes" xml:space="preserve">
          <source>It is possible to provide multiple filters at the same time. The command will handle multiple filters via logical AND. For example:</source>
          <target state="translated">Возможно предоставление нескольких фильтров одновременно.Команда будет обрабатывать несколько фильтров с помощью логического AND.Например:</target>
        </trans-unit>
        <trans-unit id="1c3121b308c1fd1777b057f001ac070f1a4f6932" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;c&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;a&lt;/code&gt; as third element.</source>
          <target state="translated">Можно протолкнуть несколько элементов с помощью одного вызова команды, просто указав несколько аргументов в конце команды. Элементы вставляются один за другим в заголовок списка, от крайнего левого элемента до крайнего правого. Так, например, команда &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; приведет к созданию списка, содержащего &lt;code&gt;c&lt;/code&gt; как первый элемент, &lt;code&gt;b&lt;/code&gt; как второй элемент и &lt;code&gt;a&lt;/code&gt; как третий элемент.</target>
        </trans-unit>
        <trans-unit id="f7c76d9bc80fdf12c410c3b35eb8ad68df167802" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;a&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;c&lt;/code&gt; as third element.</source>
          <target state="translated">Можно протолкнуть несколько элементов с помощью одного вызова команды, просто указав несколько аргументов в конце команды. Элементы вставляются один за другим в конец списка, от крайнего левого элемента до крайнего правого элемента. Так, например, команда &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; приведет к созданию списка, содержащего &lt;code&gt;a&lt;/code&gt; как первый элемент, &lt;code&gt;b&lt;/code&gt; как второй элемент и &lt;code&gt;c&lt;/code&gt; как третий элемент.</target>
        </trans-unit>
        <trans-unit id="1b01178931bb71c8630b481c710157203df1e465" translate="yes" xml:space="preserve">
          <source>It is possible to send &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; in a MULTI/EXEC block together with the &lt;code&gt;INFO replication&lt;/code&gt; command in order to get the current master offset at the time the clients are blocked. This way it is possible to wait for a specific offset in the replica side in order to make sure all the replication stream was processed.</source>
          <target state="translated">Можно отправить &lt;a href=&quot;client-pause&quot;&gt;ПАУЗУ КЛИЕНТА&lt;/a&gt; в блоке MULTI / EXEC вместе с командой &lt;code&gt;INFO replication&lt;/code&gt; , чтобы получить текущее смещение мастера на момент блокировки клиентов. Таким образом, можно дождаться определенного смещения на стороне реплики, чтобы убедиться, что весь поток репликации был обработан.</target>
        </trans-unit>
        <trans-unit id="0ec5055f100665a2489124e5d7125126bd09824c" translate="yes" xml:space="preserve">
          <source>It is possible to specify an optional modifier to alter the behavior of the command. Specifically:</source>
          <target state="translated">Можно указать опциональный модификатор для изменения поведения команды.В частности:</target>
        </trans-unit>
        <trans-unit id="45f8f96397f97e0b1f0e90886760fbff08204ef1" translate="yes" xml:space="preserve">
          <source>It is possible to switch persistence from RDB snapshotting to append-only file (and the other way around) using the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command. For more information about how to do that please check the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence page&lt;/a&gt;.</source>
          <target state="translated">Можно переключить сохраняемость с моментального снимка RDB на файл только для добавления (и наоборот) с помощью команды &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; . Для получения дополнительной информации о том, как это сделать, посетите &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;страницу сохранения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2a6138f902bc8b4bcfbc90caefbe979c90132a" translate="yes" xml:space="preserve">
          <source>It is possible to terminate a script that executes only read-only commands using the &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; command. This does not violate the scripting semantic as no data was yet written to the dataset by the script.</source>
          <target state="translated">Можно завершить сценарий, выполняющий только команды только для чтения, с помощью команды &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; . Это не нарушает семантику сценария, поскольку сценарий еще не записал данные в набор данных.</target>
        </trans-unit>
        <trans-unit id="e71c9ce4c62f0cde3cb804acf308d1e98fe95b09" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; and &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; together at every page view to have a counter counting only the latest N page views separated by less than the specified amount of seconds.</source>
          <target state="translated">Можно использовать &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; и &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; вместе при каждом просмотре страницы, чтобы счетчик подсчитывал только последние N просмотров страниц, разделенных меньшим, чем указанное количество секунд.</target>
        </trans-unit>
        <trans-unit id="2dd681e578f9014910b8ac5ae0c3612f0ad14944" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;BY&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; options against hash fields with the following syntax:</source>
          <target state="translated">Можно использовать параметры &lt;code&gt;BY&lt;/code&gt; и &lt;code&gt;GET&lt;/code&gt; для хэш-полей со следующим синтаксисом:</target>
        </trans-unit>
        <trans-unit id="b7c843f5e285c955a784fb3560240c16b6f9efa9" translate="yes" xml:space="preserve">
          <source>It is possible to use them in &lt;code&gt;geohash.org&lt;/code&gt; URLs such as &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt;. This is an &lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;example of such URL&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;geohash.org&lt;/code&gt; можно использовать в URL-адресах geohash.org, например &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt; . Это &lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;пример такого URL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b30cb831388a0a49ee8acf0fd13e74a7abc3ab8f" translate="yes" xml:space="preserve">
          <source>It is possible to write to the Redis log file from Lua scripts using the &lt;code&gt;redis.log&lt;/code&gt; function.</source>
          <target state="translated">Можно записывать в файл журнала Redis из скриптов Lua с &lt;code&gt;redis.log&lt;/code&gt; функции redis.log .</target>
        </trans-unit>
        <trans-unit id="dee99c37f02de301ed26c2711bf105931901e4b7" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the highest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">Это блокирующая версия,потому что она блокирует соединение,когда нет членов,чтобы всплыть из любого из данных отсортированных множеств.Член с наибольшим количеством баллов выпадает из первого отсортированного набора,который не является пустым,при этом данные ключи проверяются в том порядке,в котором они были даны.</target>
        </trans-unit>
        <trans-unit id="b7063c25aabd8a7e88f52a969b68eec3fd17473b" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the lowest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">Это блокирующая версия,потому что она блокирует соединение,когда нет членов,чтобы всплыть из любого из данных отсортированных множеств.Член с наименьшим количеством баллов выпадает из первого отсортированного множества,которое не является пустым,при этом данные ключи проверяются в том порядке,в котором они были даны.</target>
        </trans-unit>
        <trans-unit id="164013c6ace79ff08b57e9e952d3d8fc12045787" translate="yes" xml:space="preserve">
          <source>It just assumes that the Earth is a sphere, since the used distance formula is the Haversine formula. This formula is only an approximation when applied to the Earth, which is not a perfect sphere. The introduced errors are not an issue when used in the context of social network sites that need to query by radius and most other applications. However in the worst case the error may be up to 0.5%, so you may want to consider other systems for error-critical applications.</source>
          <target state="translated">Она просто предполагает,что Земля-это сфера,так как используемая формула расстояния-это формула Хаверсина.Эта формула является лишь приближением,когда она применяется к Земле,которая не является идеальной сферой.Введенные ошибки не являются проблемой при использовании в контексте сайтов социальных сетей,которые необходимо запрашивать по радиусу и большинству других приложений.Однако в худшем случае ошибка может составлять до 0,5%,поэтому можно рассмотреть другие системы для приложений,критичных к ошибкам.</target>
        </trans-unit>
        <trans-unit id="886b0ba44681d142ee0340c1b1c340fb49ca65a9" translate="yes" xml:space="preserve">
          <source>It starts accepting commands again from other clients, but will reply with a BUSY error to all the clients sending normal commands. The only allowed commands in this status are &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; and &lt;code&gt;SHUTDOWN
NOSAVE&lt;/code&gt;.</source>
          <target state="translated">Он снова начинает принимать команды от других клиентов, но ответит ошибкой BUSY всем клиентам, отправляющим обычные команды. Единственными разрешенными командами в этом состоянии являются &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; и &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9c449f7e951338dc4ce45209e7239b6180f2387" translate="yes" xml:space="preserve">
          <source>It stops processing all the pending commands from normal and pub/sub clients. However interactions with replicas will continue normally.</source>
          <target state="translated">Она прекращает обработку всех отложенных команд от обычных и паба/субклиентов.Однако взаимодействие с репликами будет продолжаться нормально.</target>
        </trans-unit>
        <trans-unit id="de49d1f951abef9774a1080b68edfd084cab6b36" translate="yes" xml:space="preserve">
          <source>It supports several other functions: &lt;code&gt;bit.tobit&lt;/code&gt;, &lt;code&gt;bit.tohex&lt;/code&gt;, &lt;code&gt;bit.bnot&lt;/code&gt;, &lt;code&gt;bit.band&lt;/code&gt;, &lt;code&gt;bit.bor&lt;/code&gt;, &lt;code&gt;bit.bxor&lt;/code&gt;, &lt;code&gt;bit.lshift&lt;/code&gt;, &lt;code&gt;bit.rshift&lt;/code&gt;, &lt;code&gt;bit.arshift&lt;/code&gt;, &lt;code&gt;bit.rol&lt;/code&gt;, &lt;code&gt;bit.ror&lt;/code&gt;, &lt;code&gt;bit.bswap&lt;/code&gt;. All available functions are documented in the &lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp documentation&lt;/a&gt;</source>
          <target state="translated">Он поддерживает несколько других функций: &lt;code&gt;bit.tobit&lt;/code&gt; , &lt;code&gt;bit.tohex&lt;/code&gt; , &lt;code&gt;bit.bnot&lt;/code&gt; , &lt;code&gt;bit.band&lt;/code&gt; , &lt;code&gt;bit.bor&lt;/code&gt; , &lt;code&gt;bit.bxor&lt;/code&gt; , &lt;code&gt;bit.lshift&lt;/code&gt; , &lt;code&gt;bit.rshift&lt;/code&gt; , &lt;code&gt;bit.arshift&lt;/code&gt; , &lt;code&gt;bit.rol&lt;/code&gt; , &lt;code&gt;bit.ror&lt;/code&gt; , &lt;code&gt;bit.bswap&lt;/code&gt; . Все доступные функции задокументированы в документации &lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa6a033ac7293343a89e1b83064df26de033f26b" translate="yes" xml:space="preserve">
          <source>Iteratating a stream incrementally, returning just a few items at every iteration. However it is semantically much more robust than the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of functions.</source>
          <target state="translated">Постепенная итерация потока с возвратом всего нескольких элементов на каждой итерации. Однако семантически он намного надежнее, чем семейство функций &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa52c04afc758e80cafb88b8a1109903b053dfb" translate="yes" xml:space="preserve">
          <source>Iterating a stream</source>
          <target state="translated">перетекание ручья</target>
        </trans-unit>
        <trans-unit id="6cb66fccc1c9fe8583ef2426d5ce548dc6f7ff69" translate="yes" xml:space="preserve">
          <source>Iterating with XREVRANGE</source>
          <target state="translated">Итерация с XREVRANGE</target>
        </trans-unit>
        <trans-unit id="4794d4e58656f4a052385045d3fd4b0331ebddea" translate="yes" xml:space="preserve">
          <source>Iteration of a Hash value.</source>
          <target state="translated">Итерация хеш-значения.</target>
        </trans-unit>
        <trans-unit id="ac97fd8044e211b8965191abd3e1372d4a6075d6" translate="yes" xml:space="preserve">
          <source>KEYS</source>
          <target state="translated">KEYS</target>
        </trans-unit>
        <trans-unit id="d4d3343d1b4f35172b9d4fabff52e12ab9514f83" translate="yes" xml:space="preserve">
          <source>KEYS  pattern   Find all keys matching the given pattern</source>
          <target state="translated">Шаблон KEYS Найдите все клавиши,соответствующие заданному шаблону.</target>
        </trans-unit>
        <trans-unit id="8001eeb819fd035ff21dae0c64b60f000bfc9daa" translate="yes" xml:space="preserve">
          <source>Key step count allows us to find key positions in commands like &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; where the format is &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt;.</source>
          <target state="translated">Ключ подсчета шаг позволяет нам находить ключевые позиции в командах , как &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; , где формат &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="5e0969e73b8800b103eeedd8f6bcdbbbf0f4fa78" translate="yes" xml:space="preserve">
          <source>Keys are checked in the order that they are given. Let's say that the key &lt;code&gt;list1&lt;/code&gt; doesn't exist and &lt;code&gt;list2&lt;/code&gt; and &lt;code&gt;list3&lt;/code&gt; hold non-empty lists. Consider the following command:</source>
          <target state="translated">Ключи проверяются в том порядке, в котором они даются. Предположим, что ключевой &lt;code&gt;list1&lt;/code&gt; не существует, а &lt;code&gt;list2&lt;/code&gt; и &lt;code&gt;list3&lt;/code&gt; содержат непустые списки. Рассмотрим следующую команду:</target>
        </trans-unit>
        <trans-unit id="393be168e99116be87234133e2763b06336c48c1" translate="yes" xml:space="preserve">
          <source>Keys expiring information is stored as absolute Unix timestamps (in milliseconds in case of Redis version 2.6 or greater). This means that the time is flowing even when the Redis instance is not active.</source>
          <target state="translated">Информация об истекающих ключах хранится в виде абсолютных меток времени Unix (в миллисекундах в случае Redis версии 2.6 или выше).Это означает,что время течет,даже когда экземпляр Redis не активен.</target>
        </trans-unit>
        <trans-unit id="d3023dfa16df6ad208cc7d5460854b58da1edb26" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets.</source>
          <target state="translated">Несуществующие ключи считаются пустыми наборами.</target>
        </trans-unit>
        <trans-unit id="d71481abd644158f5a9fbc5c9cecdf74dc0540c6" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets. With one of the keys being an empty set, the resulting set is also empty (since set intersection with an empty set always results in an empty set).</source>
          <target state="translated">Несуществующие ключи считаются пустыми наборами.Если одна из клавиш является пустым набором,результирующий набор также является пустым (так как пересечение набора с пустым всегда приводит к пустому набору).</target>
        </trans-unit>
        <trans-unit id="a78a3a71051e865654da3b71a5c55513e9449b8a" translate="yes" xml:space="preserve">
          <source>Keys with an expire</source>
          <target state="translated">Ключи с истекшим сроком действия</target>
        </trans-unit>
        <trans-unit id="7bcef127a442604057181ff7e89e6774cfcbdec1" translate="yes" xml:space="preserve">
          <source>Keyspace hits</source>
          <target state="translated">Хиты по клавишам</target>
        </trans-unit>
        <trans-unit id="0ecc36a9eabb580bee92d3334fc963c0e285c8f2" translate="yes" xml:space="preserve">
          <source>Keyspace misses</source>
          <target state="translated">Пропуски на клавиатуре</target>
        </trans-unit>
        <trans-unit id="18937f1c4a4cfb92babe800429a63d572cde1150" translate="yes" xml:space="preserve">
          <source>Kills the currently executing Lua script, assuming no write operation was yet performed by the script.</source>
          <target state="translated">Убивает выполняемый в настоящее время скрипт Lua,предполагая,что операция записи еще не была выполнена скриптом.</target>
        </trans-unit>
        <trans-unit id="a452e11c491a60de5436b1999a469cdaa66c0c00" translate="yes" xml:space="preserve">
          <source>LASTSAVE</source>
          <target state="translated">LASTSAVE</target>
        </trans-unit>
        <trans-unit id="fb2ee42881d40ddc3d3aec1d41500b08e5d25e19" translate="yes" xml:space="preserve">
          <source>LASTSAVE   Get the UNIX time stamp of the last successful save to disk</source>
          <target state="translated">LASTSAVE Получить метку времени UNIX последнего успешного сохранения на диск</target>
        </trans-unit>
        <trans-unit id="b9ffd63c8ba805a842d4d3d2465da47916360545" translate="yes" xml:space="preserve">
          <source>LDB can be enabled in one of two modes: asynchronous or synchronous. In asynchronous mode the server creates a forked debugging session that does not block and all changes to the data are &lt;strong&gt;rolled back&lt;/strong&gt; after the session finishes, so debugging can be restarted using the same initial state. The alternative synchronous debug mode blocks the server while the debugging session is active and retains all changes to the data set once it ends.</source>
          <target state="translated">LDB можно включить в одном из двух режимов: асинхронном или синхронном. В асинхронном режиме сервер создает разветвленный сеанс отладки, который не блокируется, и все изменения данных &lt;strong&gt;откатываются&lt;/strong&gt; после завершения сеанса, поэтому отладку можно перезапустить с тем же начальным состоянием. Альтернативный синхронный режим отладки блокирует сервер, пока сеанс отладки активен, и сохраняет все изменения в наборе данных после его завершения.</target>
        </trans-unit>
        <trans-unit id="14d2c13614325f3af7fa95efeb5dd818bb2ab0d1" translate="yes" xml:space="preserve">
          <source>LINDEX</source>
          <target state="translated">LINDEX</target>
        </trans-unit>
        <trans-unit id="a2dedc00417f0b7b29562ddaa4e03af088097cdb" translate="yes" xml:space="preserve">
          <source>LINDEX  key index   Get an element from a list by its index</source>
          <target state="translated">Индекс ключей LINDEX Получить элемент из списка по его индексу</target>
        </trans-unit>
        <trans-unit id="40088c47225008784271c2935753b4ae98fd6ec7" translate="yes" xml:space="preserve">
          <source>LINSERT</source>
          <target state="translated">LINSERT</target>
        </trans-unit>
        <trans-unit id="ca09700aae0c450ed6c327c789e3e1e3fef9f931" translate="yes" xml:space="preserve">
          <source>LINSERT  key BEFORE|AFTER pivot value   Insert an element before or after another element in a list</source>
          <target state="translated">Клавиша LINSERT BEFORE|AFTER Поворотное значение Вставьте элемент до или после другого элемента в список.</target>
        </trans-unit>
        <trans-unit id="19ce1639e2d6248a60334eca45396c2f1f706007" translate="yes" xml:space="preserve">
          <source>LLEN</source>
          <target state="translated">LLEN</target>
        </trans-unit>
        <trans-unit id="defc92ee8b39130b63cdf033e9edada00210e4f3" translate="yes" xml:space="preserve">
          <source>LLEN  key   Get the length of a list</source>
          <target state="translated">Клавиша LLEN Получить длину списка.</target>
        </trans-unit>
        <trans-unit id="6f58be63c72a45daadb6f09041398ad98c6ac9a7" translate="yes" xml:space="preserve">
          <source>LPOP</source>
          <target state="translated">LPOP</target>
        </trans-unit>
        <trans-unit id="c0a0f50764c15280585040d66db05c7ea7d4701a" translate="yes" xml:space="preserve">
          <source>LPOP  key   Remove and get the first element in a list</source>
          <target state="translated">Клавиша LPOP Удалить и получить первый элемент в списке</target>
        </trans-unit>
        <trans-unit id="4f49fc76e42ddd892d0dbf761cab7456fba6707a" translate="yes" xml:space="preserve">
          <source>LPUSH</source>
          <target state="translated">LPUSH</target>
        </trans-unit>
        <trans-unit id="a3260ebe55f682088cc638c2329d0a5d2a5f9c43" translate="yes" xml:space="preserve">
          <source>LPUSH  key value [value ...]   Prepend one or multiple values to a list</source>
          <target state="translated">Значение клавиши LPUSH [значение ...]Подготовьте одно или несколько значений в список.</target>
        </trans-unit>
        <trans-unit id="73023347f78efa6f33e2849831f260102f26f9dc" translate="yes" xml:space="preserve">
          <source>LPUSHX</source>
          <target state="translated">LPUSHX</target>
        </trans-unit>
        <trans-unit id="11960d83f4ba3a64c1274bec7eeaf405b1c4abbe" translate="yes" xml:space="preserve">
          <source>LPUSHX  key value   Prepend a value to a list, only if the list exists</source>
          <target state="translated">Значение ключа LPUSHX Подготовить значение к списку,только если список существует.</target>
        </trans-unit>
        <trans-unit id="3b47c23e3107b92100b9303bb9ab3d1a9ccc56bd" translate="yes" xml:space="preserve">
          <source>LRANGE</source>
          <target state="translated">LRANGE</target>
        </trans-unit>
        <trans-unit id="326594fa342712e825205a5b864121b10bd2f5cf" translate="yes" xml:space="preserve">
          <source>LRANGE  key start stop   Get a range of elements from a list</source>
          <target state="translated">Остановка запуска по клавише LRANGE Получить ряд элементов из списка</target>
        </trans-unit>
        <trans-unit id="abfc25d80dc9a80384bd4c9697b510b323ecc45b" translate="yes" xml:space="preserve">
          <source>LREM</source>
          <target state="translated">LREM</target>
        </trans-unit>
        <trans-unit id="f0b649e2191175bc6abf8bc7b2d0b6ec6fbf904d" translate="yes" xml:space="preserve">
          <source>LREM  key count value   Remove elements from a list</source>
          <target state="translated">LREM значение подсчета ключей Удалить элементы из списка</target>
        </trans-unit>
        <trans-unit id="70e8f03d6f4f36a9430ac8c4d4a1515597b0b252" translate="yes" xml:space="preserve">
          <source>LSET</source>
          <target state="translated">LSET</target>
        </trans-unit>
        <trans-unit id="4f03203283df161a2d6f2abf4d29626d32823249" translate="yes" xml:space="preserve">
          <source>LSET  key index value   Set the value of an element in a list by its index</source>
          <target state="translated">Значение индекса ключа LSET Установить значение элемента в списке по его индексу</target>
        </trans-unit>
        <trans-unit id="13cbd920c001e22788dd4d82cdc291c6caac4662" translate="yes" xml:space="preserve">
          <source>LTRIM</source>
          <target state="translated">LTRIM</target>
        </trans-unit>
        <trans-unit id="6c5b375830efe50dd05881b52f80e2aa747afced" translate="yes" xml:space="preserve">
          <source>LTRIM  key start stop   Trim a list to the specified range</source>
          <target state="translated">Стартовая остановка с помощью клавиши LTRIM Обрезать список до заданного диапазона</target>
        </trans-unit>
        <trans-unit id="de6a27da313b316346ea7dcf9f866c5fcdaff765" translate="yes" xml:space="preserve">
          <source>Last Key in Argument List</source>
          <target state="translated">Последний ключ в списке аргументов</target>
        </trans-unit>
        <trans-unit id="d4e1040fdde9172717ea80a7cdcb3b316461fb75" translate="yes" xml:space="preserve">
          <source>Later it will be trivial to know the number of single days the user visited the web site simply calling the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; command against the bitmap.</source>
          <target state="translated">Позже будет тривиально узнать количество дней, в течение которых пользователь посещал веб-сайт, просто вызвав команду &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; для растрового изображения.</target>
        </trans-unit>
        <trans-unit id="6167261c71ec337f0f15b900208ad184a4f7b0c9" translate="yes" xml:space="preserve">
          <source>Latest fork(2) time</source>
          <target state="translated">Последнее время вилки(2)</target>
        </trans-unit>
        <trans-unit id="0122f9d36a5bc7edfbaa17dc0a7b017882cfb3ae" translate="yes" xml:space="preserve">
          <source>Let's assume we have four nodes, A, B, C and D. In order to end with just a three nodes cluster A, B, C we may follow these steps:</source>
          <target state="translated">Предположим,что у нас есть четыре узла,A,B,C и D.Для того,чтобы закончить работу всего с тремя узлами кластера A,B,C,мы можем выполнить следующие шаги:</target>
        </trans-unit>
        <trans-unit id="2f5c5e27076a7756eeef955cec8a1510af3fb9c4" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike License 4.0.</source>
          <target state="translated">Лицензия Creative Commons Attribution-ShareAlike License 4.0.</target>
        </trans-unit>
        <trans-unit id="98cf5d780c53575d17f1d32cf3823650dcaa6c52" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; this command returns the remaining time to live of a key that has an expire set, with the sole difference that &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; returns the amount of remaining time in seconds while &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; returns it in milliseconds.</source>
          <target state="translated">Как и &lt;a href=&quot;ttl&quot;&gt;TTL,&lt;/a&gt; эта команда возвращает оставшееся время жизни ключа, для которого установлен срок действия, с той лишь разницей, что &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; возвращает оставшееся время в секундах, а &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; возвращает его в миллисекундах.</target>
        </trans-unit>
        <trans-unit id="199ff2ec8051414c46a22a354ba2c4bf9f64de93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; this command can be used in order to iterate the whole stream content, however note that in this case, the next command calls should use the ID of the last entry, with the sequence number decremneted by one. However if the sequence number is already 0, the time part of the ID should be decremented by 1, and the sequence part should be set to the maxium possible sequence number, that is, 18446744073709551615, or could be omitted at all, and the command will automatically assume it to be such a number (see &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; for more info about incomplete IDs).</source>
          <target state="translated">Как и &lt;a href=&quot;xrange&quot;&gt;XRANGE,&lt;/a&gt; эту команду можно использовать для итерации всего содержимого потока, однако обратите внимание, что в этом случае следующие вызовы команды должны использовать идентификатор последней записи с порядковым номером, уменьшенным на единицу. Однако, если порядковый номер уже равен 0, временная часть идентификатора должна быть уменьшена на 1, а часть последовательности должна быть установлена ​​на максимально возможный порядковый номер, то есть 18446744073709551615, или может быть опущена вообще, а команда автоматически предположит, что это именно такой номер (см. &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; для получения дополнительной информации о неполных идентификаторах).</target>
        </trans-unit>
        <trans-unit id="7a5a0a2011829340fa32a8f044e479cef542a701" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command can be used in a blocking way. There are no differences in this regard.</source>
          <target state="translated">Как и &lt;a href=&quot;xread&quot;&gt;XREAD,&lt;/a&gt; команду &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; можно использовать для блокировки. Никаких отличий по этому поводу нет.</target>
        </trans-unit>
        <trans-unit id="964c6e379f4b517ab54346bbc59cea679f55f58d" translate="yes" xml:space="preserve">
          <source>Like for the &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; command start and end can contain negative values in order to index bytes starting from the end of the string, where -1 is the last byte, -2 is the penultimate, and so forth.</source>
          <target state="translated">Как и для команды &lt;a href=&quot;getrange&quot;&gt;GETRANGE,&lt;/a&gt; начало и конец могут содержать отрицательные значения для индексации байтов, начиная с конца строки, где -1 - последний байт, -2 - предпоследний и т. Д.</target>
        </trans-unit>
        <trans-unit id="ce45b8148c6f69841bc195d50623329ea61f3da8" translate="yes" xml:space="preserve">
          <source>Lines can contain a section name (starting with a # character) or a property. All the properties are in the form of &lt;code&gt;field:value&lt;/code&gt; terminated by &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">Строки могут содержать название раздела (начинающееся с символа #) или свойство. Все свойства представлены в виде &lt;code&gt;field:value&lt;/code&gt; оканчивающегося &lt;code&gt;\r\n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="899acbf6050de7813479a962bcb80b73089f0f38" translate="yes" xml:space="preserve">
          <source>Lists can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;linkedlist&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is the special representation that is used to save space for small lists.</source>
          <target state="translated">Списки могут быть закодированы как &lt;code&gt;ziplist&lt;/code&gt; или связанный &lt;code&gt;linkedlist&lt;/code&gt; . &lt;code&gt;ziplist&lt;/code&gt; это специальное представление, которое используется для экономии места для небольших списков.</target>
        </trans-unit>
        <trans-unit id="db5be7f471516f84344dd104ba9b8aa174ce8d02" translate="yes" xml:space="preserve">
          <source>Lists the currently &lt;em&gt;active channels&lt;/em&gt;. An active channel is a Pub/Sub channel with one or more subscribers (not including clients subscribed to patterns).</source>
          <target state="translated">Список текущих &lt;em&gt;активных каналов&lt;/em&gt; . Активный канал - это канал Pub / Sub с одним или несколькими подписчиками (не включая клиентов, подписанных на шаблоны).</target>
        </trans-unit>
        <trans-unit id="dcea1d44bcfef24039b8c1d6348290fc06d43c9a" translate="yes" xml:space="preserve">
          <source>Load a script into the scripts cache, without executing it. After the specified command is loaded into the script cache it will be callable using &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; with the correct SHA1 digest of the script, exactly like after the first successful invocation of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;.</source>
          <target state="translated">Загружать скрипт в кеш скриптов, не выполняя его. После загрузки указанной команды в кэш сценария ее можно будет вызвать с помощью &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; с правильным дайджестом сценария SHA1, точно так же, как после первого успешного вызова &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bcd47c9d2232eb759e90bf52905602d787217e6e" translate="yes" xml:space="preserve">
          <source>Lua boolean false -&amp;gt; Redis Nil bulk reply.</source>
          <target state="translated">Lua boolean false -&amp;gt; массовый ответ Redis Nil.</target>
        </trans-unit>
        <trans-unit id="197815ca05866b7c30c1048b9d86321ee4ce6238" translate="yes" xml:space="preserve">
          <source>Lua boolean true -&amp;gt; Redis integer reply with value of 1.</source>
          <target state="translated">Lua boolean true -&amp;gt; Целочисленный ответ Redis со значением 1.</target>
        </trans-unit>
        <trans-unit id="02dda41ef75370280dc992551fadb03b88d21b1f" translate="yes" xml:space="preserve">
          <source>Lua does not export commands to access the system time or other external state.</source>
          <target state="translated">Lua не экспортирует команды для доступа к системному времени или другому внешнему состоянию.</target>
        </trans-unit>
        <trans-unit id="738b234f859993680828647d652f6de5655b0815" translate="yes" xml:space="preserve">
          <source>Lua has a single numerical type, Lua numbers. There is no distinction between integers and floats. So we always convert Lua numbers into integer replies, removing the decimal part of the number if any. &lt;strong&gt;If you want to return a float from Lua you should return it as a string&lt;/strong&gt;, exactly like Redis itself does (see for instance the &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; command).</source>
          <target state="translated">Lua имеет единственный числовой тип - числа Lua. Нет различия между целыми числами и числами с плавающей запятой. Поэтому мы всегда конвертируем числа Lua в целочисленные ответы, удаляя десятичную часть числа, если таковая имеется. &lt;strong&gt;Если вы хотите вернуть число с плавающей запятой из Lua, вы должны вернуть его как строку&lt;/strong&gt; , как это делает сам Redis (см., Например, команду &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7c212b1d165a2bdadf01bf8c01c306a9c3e780aa" translate="yes" xml:space="preserve">
          <source>Lua number -&amp;gt; Redis integer reply (the number is converted into an integer)</source>
          <target state="translated">Число Lua -&amp;gt; Целочисленный ответ Redis (число преобразуется в целое число)</target>
        </trans-unit>
        <trans-unit id="0fcb79bd3680efc38fab49be15ad5a556da29a6c" translate="yes" xml:space="preserve">
          <source>Lua pseudo random number generation functions &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; are modified in order to always have the same seed every time a new script is executed. This means that calling &lt;code&gt;math.random&lt;/code&gt; will always generate the same sequence of numbers every time a script is executed if &lt;code&gt;math.randomseed&lt;/code&gt; is not used.</source>
          <target state="translated">Функции генерации псевдослучайных чисел Lua &lt;code&gt;math.random&lt;/code&gt; и &lt;code&gt;math.randomseed&lt;/code&gt; изменены таким образом, чтобы всегда иметь одно и то же начальное число при каждом запуске нового скрипта. Это означает, что вызов &lt;code&gt;math.random&lt;/code&gt; всегда будет генерировать одну и ту же последовательность чисел каждый раз, когда выполняется скрипт, если &lt;code&gt;math.randomseed&lt;/code&gt; не используется.</target>
        </trans-unit>
        <trans-unit id="e026038d7a23da497563d39bf562be4e8b076af8" translate="yes" xml:space="preserve">
          <source>Lua scripts can return a value that is converted from the Lua type to the Redis protocol using a set of conversion rules.</source>
          <target state="translated">Скрипты Lua могут возвращать значение,которое преобразуется из типа Lua в протокол Redis с помощью набора правил преобразования.</target>
        </trans-unit>
        <trans-unit id="eec8779958c6af77259f2bed4f2206965d44330b" translate="yes" xml:space="preserve">
          <source>Lua string -&amp;gt; Redis bulk reply</source>
          <target state="translated">Строка Lua -&amp;gt; массовый ответ Redis</target>
        </trans-unit>
        <trans-unit id="0b78d29489185b7463559dbd5991d9b98e6ea241" translate="yes" xml:space="preserve">
          <source>Lua table (array) -&amp;gt; Redis multi bulk reply (truncated to the first nil inside the Lua array if any)</source>
          <target state="translated">Таблица Lua (массив) -&amp;gt; Многократный массовый ответ Redis (усеченный до первого нуля внутри массива Lua, если таковой имеется)</target>
        </trans-unit>
        <trans-unit id="92dffb8e404af7ee6cc40117a693313890548b7f" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;err&lt;/code&gt; field -&amp;gt; Redis error reply</source>
          <target state="translated">Lua таблица с одной &lt;code&gt;err&lt;/code&gt; поле -&amp;gt; Redis ошибка ответ</target>
        </trans-unit>
        <trans-unit id="860f10116eaffeabf918bd97496952f6a8568b86" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;ok&lt;/code&gt; field -&amp;gt; Redis status reply</source>
          <target state="translated">Таблица Lua с одним полем &lt;code&gt;ok&lt;/code&gt; -&amp;gt; ответ статуса Redis</target>
        </trans-unit>
        <trans-unit id="f4b1c471ce1efbe25d7232b293140a21b7fea826" translate="yes" xml:space="preserve">
          <source>MEMORY</source>
          <target state="translated">MEMORY</target>
        </trans-unit>
        <trans-unit id="5f530d724793deebbb2b735aad30cfb0c16904b5" translate="yes" xml:space="preserve">
          <source>MEMORY DOCTOR   Outputs memory problems report</source>
          <target state="translated">ДОКТОР ПАМЯТИ Выходит отчет о проблемах с памятью</target>
        </trans-unit>
        <trans-unit id="f41c78df06ee10a6b220b355855965b8d5802f0d" translate="yes" xml:space="preserve">
          <source>MEMORY HELP   Show helpful text about the different subcommands</source>
          <target state="translated">MEMORY HELP Показать полезный текст о различных подкомандах</target>
        </trans-unit>
        <trans-unit id="c46a26bce66617f3cb9ccdc83db737a6115fdc5d" translate="yes" xml:space="preserve">
          <source>MEMORY MALLOC-STATS   Show allocator internal stats</source>
          <target state="translated">ПАМЯТЬ МАЛЛОК-СТАТЫ Показывать внутреннюю статистику распределителя</target>
        </trans-unit>
        <trans-unit id="eb96d4965b5bb6522ee6573db44c8a6e1ce6edba" translate="yes" xml:space="preserve">
          <source>MEMORY PURGE   Ask the allocator to release memory</source>
          <target state="translated">ЦЕПЬ ПАМЯТИ Попросите аллокатор освободить память.</target>
        </trans-unit>
        <trans-unit id="d3303c80cf9ee1aa6f783b72419ffa190e2a905d" translate="yes" xml:space="preserve">
          <source>MEMORY STATS   Show memory usage details</source>
          <target state="translated">Показать статистику использования памяти</target>
        </trans-unit>
        <trans-unit id="de9aed5605340cafa3f173e741e4bc7253d17f99" translate="yes" xml:space="preserve">
          <source>MEMORY USAGE  key [SAMPLES count]   Estimate the memory usage of a key</source>
          <target state="translated">Ключ использования памяти [SAMPLES счет]Оценка использования памяти ключа</target>
        </trans-unit>
        <trans-unit id="eb4b445b699787b561e4b67d4f6b08a7ef32cf55" translate="yes" xml:space="preserve">
          <source>MGET</source>
          <target state="translated">MGET</target>
        </trans-unit>
        <trans-unit id="ffbcf2b819692d7b52978ca1ef1e227536a082fe" translate="yes" xml:space="preserve">
          <source>MGET  key [key ...]   Get the values of all the given keys</source>
          <target state="translated">Клавиша MGET [клавиша ...]Получить значения всех данных клавиш.</target>
        </trans-unit>
        <trans-unit id="883beaf0f91aca7f9ebc4802e0bab2501cbbc8ea" translate="yes" xml:space="preserve">
          <source>MIGRATE</source>
          <target state="translated">MIGRATE</target>
        </trans-unit>
        <trans-unit id="2f0b2cdf3b3d88df6ed56ef5576fa5ec1a8aa5b1" translate="yes" xml:space="preserve">
          <source>MIGRATE  host port key|&quot;&quot; destination-db timeout [COPY] [REPLACE] [KEYS key [key ...]]   Atomically transfer a key from a Redis instance to another one.</source>
          <target state="translated">Порт хоста MIGRATE key|&quot;&quot;-тайм-аут назначения db [КОПИ][ЗАМЕНА][клавиша KEYS [ключ ...]]].Атоматическая передача ключа из экземпляра Redis в другой экземпляр.</target>
        </trans-unit>
        <trans-unit id="6da5b5979c630adef5abc39370410d7de4a1b8ef" translate="yes" xml:space="preserve">
          <source>MONITOR</source>
          <target state="translated">MONITOR</target>
        </trans-unit>
        <trans-unit id="55d4d86d6d24375e297cf38db11a4bacd4febc84" translate="yes" xml:space="preserve">
          <source>MONITOR   Listen for all requests received by the server in real time</source>
          <target state="translated">МОНИТОР Прослушивать все запросы,получаемые сервером в режиме реального времени</target>
        </trans-unit>
        <trans-unit id="3bf08a84f15b98ce4d14b707f4a093b3cc8b853e" translate="yes" xml:space="preserve">
          <source>MOVE</source>
          <target state="translated">MOVE</target>
        </trans-unit>
        <trans-unit id="001d5d6407276cba944eda42b69684ebbbae5d55" translate="yes" xml:space="preserve">
          <source>MOVE  key db   Move a key to another database</source>
          <target state="translated">MOVE ключ db Перемещение ключа в другой банк данных</target>
        </trans-unit>
        <trans-unit id="4a4d41a590643b6020afed2c32a7fa4d49b49601" translate="yes" xml:space="preserve">
          <source>MSET</source>
          <target state="translated">MSET</target>
        </trans-unit>
        <trans-unit id="9a5861cd64b36ffe83c01382e80e50105a256980" translate="yes" xml:space="preserve">
          <source>MSET  key value [key value ...]   Set multiple keys to multiple values</source>
          <target state="translated">Значение клавиши MSET [значение клавиши ...]Установить несколько клавиш на несколько значений</target>
        </trans-unit>
        <trans-unit id="f7daca0dd0ee4f7979861ac9b4fb059852d07494" translate="yes" xml:space="preserve">
          <source>MSETNX</source>
          <target state="translated">MSETNX</target>
        </trans-unit>
        <trans-unit id="48498dbffef6df5e6474fe5db88a9722de54676a" translate="yes" xml:space="preserve">
          <source>MSETNX  key value [key value ...]   Set multiple keys to multiple values, only if none of the keys exist</source>
          <target state="translated">MSETNX значение клавиши [значение клавиши ...]Установите несколько клавиш на несколько значений,только если ни одна из клавиш не существует.</target>
        </trans-unit>
        <trans-unit id="73cadb41b45514de9061a72461b466eafd7a01b0" translate="yes" xml:space="preserve">
          <source>MULTI</source>
          <target state="translated">MULTI</target>
        </trans-unit>
        <trans-unit id="bb76d99632737ac9f4ecd1c2218ac5cae7373df0" translate="yes" xml:space="preserve">
          <source>MULTI   Mark the start of a transaction block</source>
          <target state="translated">MULTI Отметьте начало блока транзакций</target>
        </trans-unit>
        <trans-unit id="5162c1f5fa963969d600908fd5531f9515bcd0ad" translate="yes" xml:space="preserve">
          <source>Manually issue the &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; command to stop a &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; stream running via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="translated">Вручную &lt;a href=&quot;quit&quot;&gt;введите&lt;/a&gt; команду QUIT, чтобы остановить поток &lt;a href=&quot;monitor&quot;&gt;МОНИТОРА,&lt;/a&gt; работающий через &lt;code&gt;telnet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="195fbe53b32ee6173d85e3798809ae2267b7bfce" translate="yes" xml:space="preserve">
          <source>Marks the given keys to be watched for conditional execution of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">Отмечает указанные ключи для отслеживания условного выполнения &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;транзакции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8683729a7a727945cae9baf35f4c55f1439a9ae" translate="yes" xml:space="preserve">
          <source>Marks the start of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; block. Subsequent commands will be queued for atomic execution using &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;.</source>
          <target state="translated">Отмечает начало блока &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;транзакции&lt;/a&gt; . Последующие команды будут помещены в очередь для атомарного выполнения с использованием &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f713e2ee906af8b74a13e92b2e0d07f7715b2d2e" translate="yes" xml:space="preserve">
          <source>Master for slot range represented as nested IP/Port array</source>
          <target state="translated">Мастер для диапазона слотов,представленных в виде вложенного массива IP/Port</target>
        </trans-unit>
        <trans-unit id="826539552e055ad1bd8dd2263cef37308d024f80" translate="yes" xml:space="preserve">
          <source>Master output</source>
          <target state="translated">Мастер-выпуск</target>
        </trans-unit>
        <trans-unit id="3a00e4f9797b4c734ae7a585f001ffa257119f27" translate="yes" xml:space="preserve">
          <source>Meaning of the flags (field number 3):</source>
          <target state="translated">Значение флагов (поле 3):</target>
        </trans-unit>
        <trans-unit id="716383f923909d0c089205fcba00d4705b3601a5" translate="yes" xml:space="preserve">
          <source>Merge multiple HyperLogLog values into an unique value that will approximate the cardinality of the union of the observed Sets of the source HyperLogLog structures.</source>
          <target state="translated">Соедините несколько значений HyperLogLog в уникальное значение,которое будет аппроксимировать кардинальность объединения наблюдаемых наборов исходных структур HyperLogLog.</target>
        </trans-unit>
        <trans-unit id="d48699ea9bf170ea49610c0892198d522150833b" translate="yes" xml:space="preserve">
          <source>Migrating multiple keys with a single command call</source>
          <target state="translated">Миграция нескольких клавиш одним вызовом команды</target>
        </trans-unit>
        <trans-unit id="1dc9fdcdad40a742a94a677f3b78a05f4ed5e6b5" translate="yes" xml:space="preserve">
          <source>Migration and importing slots are only added to the node flagged as &lt;code&gt;myself&lt;/code&gt;. This information is local to a node, for its own slots.</source>
          <target state="translated">Слоты для миграции и импорта добавляются только к узлу, отмеченному как &lt;code&gt;myself&lt;/code&gt; . Эта информация является локальной для узла для его собственных слотов.</target>
        </trans-unit>
        <trans-unit id="bf4ac897fe1476ddf0632fbae3fd4061b3a77806" translate="yes" xml:space="preserve">
          <source>More details about the Redis HyperLogLog implementation can be found in &lt;a href=&quot;http://antirez.com/news/75&quot;&gt;this blog post&lt;/a&gt;. The source code of the implementation in the &lt;code&gt;hyperloglog.c&lt;/code&gt; file is also easy to read and understand, and includes a full specification for the exact encoding used for the sparse and dense representations.</source>
          <target state="translated">Более подробную информацию о реализации Redis HyperLogLog можно найти в &lt;a href=&quot;http://antirez.com/news/75&quot;&gt;этом сообщении блога&lt;/a&gt; . Исходный код реализации в файле &lt;code&gt;hyperloglog.c&lt;/code&gt; также легко читать и понимать и включает полную спецификацию точной кодировки, используемой для разреженных и плотных представлений.</target>
        </trans-unit>
        <trans-unit id="66fbce4faebab20f5ca1d3b33c08e967f22406cb" translate="yes" xml:space="preserve">
          <source>More information about the Current Epoch and Config Epoch variables are available in the Redis Cluster specification document.</source>
          <target state="translated">Более подробная информация о переменных Current Epoch (Текущая эпоха)и Config Epoch (Настройка эпохи)доступна в спецификационном документе Redis Cluster (Кластер Redis).</target>
        </trans-unit>
        <trans-unit id="76f5a5481231f7dff85e48d6a0993bd209662a44" translate="yes" xml:space="preserve">
          <source>Moreover &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; does not need to be reciprocal. If I send the command to A in order to join B, I don't need to also send it to B in order to join A.</source>
          <target state="translated">Более того, &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; не обязательно должен быть взаимным. Если я отправлю команду A, чтобы присоединиться к B, мне не нужно также отправлять ее B, чтобы присоединиться к A.</target>
        </trans-unit>
        <trans-unit id="8993f2e40360ac488b5303cad3bacad41d3a08f1" translate="yes" xml:space="preserve">
          <source>Moreover, as a side effect, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will increment the count of attempted deliveries of the message. In this way messages that cannot be processed for some reason, for instance because the consumers crash attempting to process them, will start to have a larger counter and can be detected inside the system.</source>
          <target state="translated">Более того, в качестве побочного эффекта &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; увеличит счетчик попыток доставки сообщения. Таким образом, сообщения, которые не могут быть обработаны по какой-либо причине, например, из-за сбоя потребителей, пытающихся их обработать, начнут иметь больший счетчик и могут быть обнаружены внутри системы.</target>
        </trans-unit>
        <trans-unit id="6330fc6bbcd49c1766a676116e26172a91d38595" translate="yes" xml:space="preserve">
          <source>Moreover, if you are new to streams, we recommend to read our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. Make sure to understand the concept of consumer group in the introduction so that following how this command works will be simpler.</source>
          <target state="translated">Более того, если вы новичок в потоках, мы рекомендуем прочитать наше &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;введение в Redis Streams&lt;/a&gt; . Убедитесь, что вы понимаете концепцию группы потребителей во введении, чтобы было проще понять, как работает эта команда.</target>
        </trans-unit>
        <trans-unit id="fde66fa86f8517d887e54616bf1fb31656fc7f81" translate="yes" xml:space="preserve">
          <source>Motivations</source>
          <target state="translated">Motivations</target>
        </trans-unit>
        <trans-unit id="eaf7a15ddfb6c5c306f486c8bf293512f163a845" translate="yes" xml:space="preserve">
          <source>Movable Keys</source>
          <target state="translated">Подвижные ключи</target>
        </trans-unit>
        <trans-unit id="f77b47b8d13d94af9785e089c536b9963ca2c823" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;key&lt;/code&gt; from the currently selected database (see &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt;) to the specified destination database. When &lt;code&gt;key&lt;/code&gt; already exists in the destination database, or it does not exist in the source database, it does nothing. It is possible to use &lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt; as a locking primitive because of this.</source>
          <target state="translated">Переместить &lt;code&gt;key&lt;/code&gt; из текущей выбранной базы данных (см. &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; ) в указанную целевую базу данных. Когда &lt;code&gt;key&lt;/code&gt; уже существует в целевой базе данных или его нет в исходной базе данных, он ничего не делает. Из-за этого можно использовать &lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt; как блокирующий примитив.</target>
        </trans-unit>
        <trans-unit id="17c083c9f9d68a5d0169cd11d9c0c04115759b24" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;member&lt;/code&gt; from the set at &lt;code&gt;source&lt;/code&gt; to the set at &lt;code&gt;destination&lt;/code&gt;. This operation is atomic. In every given moment the element will appear to be a member of &lt;code&gt;source&lt;/code&gt;&lt;strong&gt;or&lt;/strong&gt;&lt;code&gt;destination&lt;/code&gt; for other clients.</source>
          <target state="translated">Переместить &lt;code&gt;member&lt;/code&gt; из набора в &lt;code&gt;source&lt;/code&gt; в набор в месте &lt;code&gt;destination&lt;/code&gt; . Эта операция атомарна. В каждый данный момент элемент будет казаться элементом &lt;code&gt;source&lt;/code&gt; &lt;strong&gt;или &lt;/strong&gt; &lt;code&gt;destination&lt;/code&gt; для других клиентов.</target>
        </trans-unit>
        <trans-unit id="95a91b78dd0ce912aadce361711a043cae9a887e" translate="yes" xml:space="preserve">
          <source>Multiple parallel iterations</source>
          <target state="translated">Многочисленные параллельные итерации</target>
        </trans-unit>
        <trans-unit id="f492964822aab7cec6aa84fefaffe8fba8b6cd36" translate="yes" xml:space="preserve">
          <source>Nested Result Array</source>
          <target state="translated">Массив вложенных результатов</target>
        </trans-unit>
        <trans-unit id="fdc70576104b358de95d88f0255666aac631aff0" translate="yes" xml:space="preserve">
          <source>New fields are regularly added for debugging purpose. Some could be removed in the future. A version safe Redis client using this command should parse the output accordingly (i.e. handling gracefully missing fields, skipping unknown fields).</source>
          <target state="translated">Для отладки регулярно добавляются новые поля.Некоторые из них могут быть удалены в будущем.Клиент Redis,безопасный для версий,используя эту команду,должен разобрать вывод соответствующим образом (т.е.обрабатывать изящно пропущенные поля,пропускать неизвестные поля).</target>
        </trans-unit>
        <trans-unit id="861e51e24f78632f52937df883ebeed5a0766d52" translate="yes" xml:space="preserve">
          <source>New keys are always created in the target node. During a hash slot migration we'll have to move only old keys, not new ones.</source>
          <target state="translated">Новые клавиши всегда создаются в целевом узле.При переносе хэш-слота нам придется перемещать только старые ключи,а не новые.</target>
        </trans-unit>
        <trans-unit id="97bfa87b383568ddb64d92c09cf59316bbb313bd" translate="yes" xml:space="preserve">
          <source>No repeated elements are returned.</source>
          <target state="translated">Повторяющиеся элементы не возвращаются.</target>
        </trans-unit>
        <trans-unit id="75e932f04e490ddd2c64a4420d419573bd058eac" translate="yes" xml:space="preserve">
          <source>Nodes in &lt;code&gt;PFAIL&lt;/code&gt; state are provided in gossip sections of heartbeat packets.</source>
          <target state="translated">Узлы в состоянии &lt;code&gt;PFAIL&lt;/code&gt; предоставляются в секциях сплетен пакетов подтверждения .</target>
        </trans-unit>
        <trans-unit id="c02697f1f51c2f137246d46e8911c8e7f53e6636" translate="yes" xml:space="preserve">
          <source>Non existing elements are reported as NULL elements of the array.</source>
          <target state="translated">Несуществующие элементы сообщаются как NULL-элементы массива.</target>
        </trans-unit>
        <trans-unit id="5dfb2fbf84cf8de01a0c2542d485d2207dc976ae" translate="yes" xml:space="preserve">
          <source>Non used lines are blanked. For instance if you used to have multiple &lt;code&gt;save&lt;/code&gt; directives, but the current configuration has fewer or none as you disabled RDB persistence, all the lines will be blanked.</source>
          <target state="translated">Неиспользуемые строки очищаются. Например, если у вас было несколько директив &lt;code&gt;save&lt;/code&gt; , но в текущей конфигурации их меньше или нет, поскольку вы отключили сохранение RDB, все строки будут пустыми.</target>
        </trans-unit>
        <trans-unit id="de44f50198c0734dcccb5b1c5d4825eb72c13aba" translate="yes" xml:space="preserve">
          <source>Non-blocking behavior</source>
          <target state="translated">Блокирующее поведение</target>
        </trans-unit>
        <trans-unit id="5cbfa62b0d0a8a33923d06127db99370a393ad0d" translate="yes" xml:space="preserve">
          <source>Non-blocking usage</source>
          <target state="translated">Неблокирующее использование</target>
        </trans-unit>
        <trans-unit id="bcbbb0c35f64190eb100cd6befa838fbd5037874" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings, so the command will return zero.</source>
          <target state="translated">Несуществующие ключи рассматриваются как пустые строки,поэтому команда вернет ноль.</target>
        </trans-unit>
        <trans-unit id="46b493cea7b65b3003ea2e423707591849b0ee78" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings.</source>
          <target state="translated">Несуществующие ключи рассматриваются как пустые строки.</target>
        </trans-unit>
        <trans-unit id="9a60acaa61d5a344489afdd9e5311dbf8888aa00" translate="yes" xml:space="preserve">
          <source>Normally &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; is simply used in order to get range of items where the score is the indexed integer key, however it is possible to do less obvious things with the command.</source>
          <target state="translated">Обычно &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; просто используется для получения диапазона элементов, где оценка является индексированным целочисленным ключом, однако с помощью команды можно делать менее очевидные вещи.</target>
        </trans-unit>
        <trans-unit id="4dba9f7be4e65fcc1fd8d86533e96e912932e110" translate="yes" xml:space="preserve">
          <source>Normally Redis keys are created without an associated time to live. The key will simply live forever, unless it is removed by the user in an explicit way, for instance using the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; command.</source>
          <target state="translated">Обычно ключи Redis создаются без привязки к времени жизни. Ключ просто будет жить вечно, если он не будет удален пользователем явным образом, например, с помощью команды &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="488e099ce2d3130dde9348d7a491fea120dffc25" translate="yes" xml:space="preserve">
          <source>Normally Redis represents positions of elements using a variation of the Geohash technique where positions are encoded using 52 bit integers. The encoding is also different compared to the standard because the initial min and max coordinates used during the encoding and decoding process are different. This command however &lt;strong&gt;returns a standard Geohash&lt;/strong&gt; in the form of a string as described in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Wikipedia article&lt;/a&gt; and compatible with the &lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; web site.</source>
          <target state="translated">Обычно Redis представляет позиции элементов с использованием разновидности метода Geohash, где позиции кодируются с использованием 52-битных целых чисел. Кодирование также отличается от стандартного, потому что начальные минимальные и максимальные координаты, используемые в процессе кодирования и декодирования, различны. Однако эта команда &lt;strong&gt;возвращает стандартный Geohash&lt;/strong&gt; в виде строки, как описано в &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;статье Википедии&lt;/a&gt; и совместимо с веб-сайтом &lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48fbc2c3360b2ccdab702dc73f1af3fdad88932d" translate="yes" xml:space="preserve">
          <source>Normally hash slots associated to a given node are in one of the following formats, as already explained above:</source>
          <target state="translated">Обычно,как уже объяснялось выше,хэш-слоты,связанные с данным узлом,представлены в одном из следующих форматов:</target>
        </trans-unit>
        <trans-unit id="20da22f8d3c73a214f41394b1c9a9c08c0230154" translate="yes" xml:space="preserve">
          <source>Normally if there is an AOF child process performing an AOF rewrite, Redis will simply kill it and exit. However there are two conditions where it is unsafe to do so, and the &lt;strong&gt;SHUTDOWN&lt;/strong&gt; command will be refused with an error instead. This happens when:</source>
          <target state="translated">Обычно, если есть дочерний процесс AOF, выполняющий перезапись AOF, Redis просто убивает его и завершает работу. Однако есть два условия, при которых это небезопасно, и вместо этого команда &lt;strong&gt;SHUTDOWN&lt;/strong&gt; будет отклонена с ошибкой. Это случается, когда:</target>
        </trans-unit>
        <trans-unit id="f552eaf00c55408f0aa996335bcd91c4da8dcdb7" translate="yes" xml:space="preserve">
          <source>Normally replica nodes will redirect clients to the authoritative master for the hash slot involved in a given command, however clients can use replicas in order to scale reads using the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command.</source>
          <target state="translated">Обычно узлы реплик перенаправляют клиентов к авторитетному мастеру для хэш-слота, задействованного в данной команде, однако клиенты могут использовать реплики для масштабирования &lt;a href=&quot;readonly&quot;&gt;операций&lt;/a&gt; чтения с помощью команды READONLY .</target>
        </trans-unit>
        <trans-unit id="0b040d0fd81d55e920e28d6b8b43687a96fedfb9" translate="yes" xml:space="preserve">
          <source>Normally replicating scripts instead of the effects of the scripts makes sense, however not in all the cases. So starting with Redis 3.2, the scripting engine is able to, alternatively, replicate the sequence of write commands resulting from the script execution, instead of replication the script itself. See the next section for more information. In this section we'll assume that scripts are replicated by sending the whole script. Let's call this replication mode &lt;strong&gt;whole scripts replication&lt;/strong&gt;.</source>
          <target state="translated">Обычно копирование сценариев вместо эффектов сценариев имеет смысл, но не во всех случаях. Таким образом, начиная с Redis 3.2, обработчик сценариев может, в качестве альтернативы, реплицировать последовательность команд записи, возникающую в результате выполнения сценария, вместо репликации самого сценария. См. Следующий раздел для получения дополнительной информации. В этом разделе мы предполагаем, что сценарии реплицируются путем отправки всего сценария. Назовем этот режим репликации репликацией &lt;strong&gt;целых скриптов&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="de2018dd71c22fe4b55fd2f381e3bcbd8ea7b844" translate="yes" xml:space="preserve">
          <source>Normally you may think at a Redis stream as an append-only data structure, however Redis streams are represented in memory, so we are able to also delete entries. This may be useful, for instance, in order to comply with certain privacy policies.</source>
          <target state="translated">Обычно вы можете думать в потоке Redis как о структуре данных только для приложений,однако потоки Redis представлены в памяти,поэтому мы также можем удалять записи.Это может быть полезно,например,для соблюдения определенных политик конфиденциальности.</target>
        </trans-unit>
        <trans-unit id="675cc42aab3b45855f7e4f48b1a8a2f9ea1abcdc" translate="yes" xml:space="preserve">
          <source>Normally you use the command like that in order to get new messages and process them. In pseudo-code:</source>
          <target state="translated">Обычно вы используете такую команду,чтобы получать новые сообщения и обрабатывать их.В псевдокоде:</target>
        </trans-unit>
        <trans-unit id="92faf092f64b7750013de7ad70293bed4c22e467" translate="yes" xml:space="preserve">
          <source>Note for Lua newbies: in order to avoid using global variables in your scripts simply declare every variable you are going to use using the &lt;em&gt;local&lt;/em&gt; keyword.</source>
          <target state="translated">Примечание для новичков в Lua: чтобы избежать использования глобальных переменных в ваших скриптах, просто объявите каждую переменную, которую вы собираетесь использовать, с помощью ключевого слова &lt;em&gt;local&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="386ff54d1c33b65d55947a3bc043df349ed6b50a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; all work very similarly, so this documentation covers all the four commands. However an obvious difference is that in the case of &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; the first argument is the name of the key holding the Set, Hash or Sorted Set value. The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command does not need any key name argument as it iterates keys in the current database, so the iterated object is the database itself.</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; , &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; и &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; работают очень похоже, поэтому эта документация охватывает все четыре команды. Однако очевидное различие состоит в том, что в случае &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; и &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; первым аргументом является имя ключа, содержащего значение Set, Hash или Sorted Set. &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; команда не требует ключа имя аргумента , как он перебирает ключи в текущей базе данных, поэтому итерированные объект самой базы данных.</target>
        </trans-unit>
        <trans-unit id="b8af6b6330cf6687e8cc50e67b81c7d7beffd113" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not make Redis a strongly consistent store: while synchronous replication is part of a replicated state machine, it is not the only thing needed. However in the context of Sentinel or Redis Cluster failover, &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; improves the real world data safety.</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; не делает Redis строго согласованным хранилищем: хотя синхронная репликация является частью реплицированного конечного автомата, это не единственное, что необходимо. Однако в контексте аварийного переключения Sentinel или Redis Cluster &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; повышает безопасность данных в реальном мире.</target>
        </trans-unit>
        <trans-unit id="196f50bc6a6ac776d1991175d0001fae97125b81" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; is also available since Redis 3.2.10 and Redis 4.0.0 in order to provide a read-only command that can be used in replicas. See the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; page for more information.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; также доступен, начиная с Redis 3.2.10 и Redis 4.0.0, чтобы предоставить команду только для чтения, которую можно использовать в репликах. См. &lt;a href=&quot;georadius&quot;&gt;Страницу GEORADIUS&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="7f4713a8dfe3582f9f0fc3ed836bf0396dfbd617" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;TAKEOVER violates the last-failover-wins principle&lt;/strong&gt; of Redis Cluster, since the configuration epoch generated by the replica violates the normal generation of configuration epochs in several ways:</source>
          <target state="translated">Обратите внимание, что &lt;strong&gt;TAKEOVER нарушает принцип&lt;/strong&gt; Redis Cluster с &lt;strong&gt;последним отказоустойчивым переключением&lt;/strong&gt; , поскольку эпоха конфигурации, сгенерированная репликой, нарушает нормальную генерацию эпох конфигурации несколькими способами:</target>
        </trans-unit>
        <trans-unit id="b1e5f99b4ded8ce6be23a9f6f9872d3e5595ab46" translate="yes" xml:space="preserve">
          <source>Note that Redis Cluster needs to form a full mesh (each node is connected with each other node), but in order to create a cluster, there is no need to send all the &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; commands needed to form the full mesh. What matter is to send enough &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; messages so that each node can reach each other node through a &lt;em&gt;chain of known nodes&lt;/em&gt;. Thanks to the exchange of gossip information in heartbeat packets, the missing links will be created.</source>
          <target state="translated">Обратите внимание, что Redis Cluster должен формировать полную сетку (каждый узел связан друг с другом узлом), но для создания кластера нет необходимости отправлять все команды &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET,&lt;/a&gt; необходимые для формирования полной сетки. Важно отправить достаточно сообщений &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET,&lt;/a&gt; чтобы каждый узел мог достичь друг друга через &lt;em&gt;цепочку известных узлов&lt;/em&gt; . Благодаря обмену информацией о сплетнях в контрольных пакетах будут созданы недостающие ссылки.</target>
        </trans-unit>
        <trans-unit id="17fc5decb8a235b9d4881b1185aa05ef897a69aa" translate="yes" xml:space="preserve">
          <source>Note that bit positions are returned always as absolute values starting from bit zero even when &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; are used to specify a range.</source>
          <target state="translated">Обратите внимание, что позиции битов всегда возвращаются как абсолютные значения, начиная с нуля, даже если &lt;em&gt;начало&lt;/em&gt; и &lt;em&gt;конец&lt;/em&gt; используются для указания диапазона.</target>
        </trans-unit>
        <trans-unit id="d47127e4277fb6af8f1ec3e041d7aadf84ff3fe6" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;/&lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt; with a non-positive timeout or &lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt;/&lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; with a time in the past will result in the key being &lt;a href=&quot;del&quot;&gt;deleted&lt;/a&gt; rather than expired (accordingly, the emitted &lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;key event&lt;/a&gt; will be &lt;code&gt;del&lt;/code&gt;, not &lt;code&gt;expired&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание , что вызов &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; / &lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt; с неположительным таймом - аутом или &lt;a href=&quot;expireat&quot;&gt;ExpireAt&lt;/a&gt; / &lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; со временем в прошлом приведет к ключевым существам &lt;a href=&quot;del&quot;&gt;удаляется&lt;/a&gt; , а не истекли (соответственно, излучаемое &lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;ключевое событие&lt;/a&gt; станет &lt;code&gt;del&lt;/code&gt; , не &lt;code&gt;expired&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="134cdffcc8cc8242a1731baa707e6b6f212bd203" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;OVERFLOW&lt;/code&gt; statement only affects the &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; commands that follow it in the list of subcommands, up to the next &lt;code&gt;OVERFLOW&lt;/code&gt; statement.</source>
          <target state="translated">Обратите внимание , что каждое &lt;code&gt;OVERFLOW&lt;/code&gt; заявление затрагивает только &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; команды , которые следуют за ней в списке подкомандами, до следующего &lt;code&gt;OVERFLOW&lt;/code&gt; заявления.</target>
        </trans-unit>
        <trans-unit id="c59e6cb007a017cde6a0590f3fe3a6903d02fdbc" translate="yes" xml:space="preserve">
          <source>Note that for correctly implementing this pattern it is important to avoid multiple clients rebuilding the cache at the same time. Some kind of locking is needed here (for instance using &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что для правильной реализации этого шаблона важно избегать одновременного восстановления кеша несколькими клиентами. Здесь нужна какая-то блокировка (например, с помощью &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ab5932614de576b14cea0fbf3d424f67389687d0" translate="yes" xml:space="preserve">
          <source>Note that for the same reason a Lua script or a &lt;code&gt;MULTI/EXEC&lt;/code&gt; block may push elements into a list and afterward &lt;strong&gt;delete the list&lt;/strong&gt;. In this case the blocked clients will not be served at all and will continue to be blocked as long as no data is present on the list after the execution of a single command, transaction, or script.</source>
          <target state="translated">Обратите внимание, что по той же причине сценарий Lua или блок &lt;code&gt;MULTI/EXEC&lt;/code&gt; могут помещать элементы в список, а затем &lt;strong&gt;удалять список&lt;/strong&gt; . В этом случае заблокированные клиенты не будут обслуживаться вообще и будут продолжать блокироваться до тех пор, пока в списке нет данных после выполнения одной команды, транзакции или сценария.</target>
        </trans-unit>
        <trans-unit id="fcc828a00ba6196c133772751828406df7944657" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">Обратите внимание, что если реплика добавляется, перемещается или удаляется с данного главного узла, и мы запрашиваем &lt;a href=&quot;cluster-replicas&quot;&gt;КЛАСТЕРНЫЕ РЕПЛИКИ&lt;/a&gt; на узел, который еще не получил обновление конфигурации, он может показать устаревшую информацию. Однако в конечном итоге (в течение нескольких секунд, если нет сетевых разделов) все узлы согласятся о наборе узлов, связанных с данным мастером.</target>
        </trans-unit>
        <trans-unit id="21094e1f69e7fc1828b555fe35532f052b5ac245" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">Обратите внимание: если реплика добавляется, перемещается или удаляется с данного главного узла, и мы запрашиваем &lt;a href=&quot;cluster-slaves&quot;&gt;КЛАСТЕРНЫЕ ВЕДОМЫЕ&lt;/a&gt; у узла, который еще не получил обновление конфигурации, он может показать устаревшую информацию. Однако в конечном итоге (в течение нескольких секунд, если нет сетевых разделов) все узлы согласятся о наборе узлов, связанных с данным мастером.</target>
        </trans-unit>
        <trans-unit id="92bc3cdf3318fb930ded8c852b6a00267accad1a" translate="yes" xml:space="preserve">
          <source>Note that if you have a list of numbers from 0 to 100, &lt;code&gt;LRANGE list 0 10&lt;/code&gt; will return 11 elements, that is, the rightmost item is included. This &lt;strong&gt;may or may not&lt;/strong&gt; be consistent with behavior of range-related functions in your programming language of choice (think Ruby's &lt;code&gt;Range.new&lt;/code&gt;, &lt;code&gt;Array#slice&lt;/code&gt; or Python's &lt;code&gt;range()&lt;/code&gt; function).</source>
          <target state="translated">Обратите внимание, что если у вас есть список чисел от 0 до 100, &lt;code&gt;LRANGE list 0 10&lt;/code&gt; вернет 11 элементов, то есть будет включен самый правый элемент. Это &lt;strong&gt;может или не&lt;/strong&gt; может согласовываться с поведением функций, связанных с диапазоном, на выбранном вами языке программирования (подумайте о Ruby &lt;code&gt;Range.new&lt;/code&gt; , &lt;code&gt;Array#slice&lt;/code&gt; или функции Python &lt;code&gt;range()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b145f3c9b171e7c40ecd23d7161660cea0ebde1c" translate="yes" xml:space="preserve">
          <source>Note that it is valid to call this command without channels. In this case it will just return an empty list.</source>
          <target state="translated">Обратите внимание,что можно вызывать эту команду и без каналов.В этом случае она просто вернет пустой список.</target>
        </trans-unit>
        <trans-unit id="7cbc0087feeeb4b8394154849c8ec33aeb518c13" translate="yes" xml:space="preserve">
          <source>Note that non-existing keys are treated like empty lists, so when &lt;code&gt;key&lt;/code&gt; does not exist, the command will always return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что несуществующие ключи обрабатываются как пустые списки, поэтому, когда &lt;code&gt;key&lt;/code&gt; не существует, команда всегда будет возвращать &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e83de8fca6610aa183e7aad22115791cd55bc9fb" translate="yes" xml:space="preserve">
          <source>Note that normally clients willing to fetch the map between Cluster hash slots and node addresses should use &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; instead. &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;, that provides more information, should be used for administrative tasks, debugging, and configuration inspections. It is also used by &lt;code&gt;redis-trib&lt;/code&gt; in order to manage a cluster.</source>
          <target state="translated">Обратите внимание, что обычно клиенты, желающие получить карту между хэш-слотами кластера и адресами узлов, должны вместо этого использовать &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; . &lt;a href=&quot;cluster-nodes&quot;&gt;КЛАСТЕРНЫЕ УЗЛЫ&lt;/a&gt; , которые предоставляют больше информации, следует использовать для административных задач, отладки и проверки конфигурации. Он также используется &lt;code&gt;redis-trib&lt;/code&gt; для управления кластером.</target>
        </trans-unit>
        <trans-unit id="1f6b2fdffdf326f5f641aa170f10beb1a26d5924" translate="yes" xml:space="preserve">
          <source>Note that once a node assigns a set of slots to itself, it will start propagating this information in heartbeat packet headers. However the other nodes will accept the information only if they have the slot as not already bound with another node, or if the configuration epoch of the node advertising the new hash slot, is greater than the node currently listed in the table.</source>
          <target state="translated">Обратите внимание,что как только узел назначит себе набор слотов,он начнет распространять эту информацию в заголовках пульсирующих пакетов.Однако другие узлы будут принимать информацию только в том случае,если у них есть слот,который ещё не связан с другим узлом,или если эпоха конфигурации узла,рекламирующего новый слот для хэшей,больше,чем узел,перечисленный в настоящее время в таблице.</target>
        </trans-unit>
        <trans-unit id="34efcb15ecc544550f9bd4f238eeb1c37bfe6eb5" translate="yes" xml:space="preserve">
          <source>Note that the command implements the full hashing algorithm, including support for &lt;strong&gt;hash tags&lt;/strong&gt;, that is the special property of Redis Cluster key hashing algorithm, of hashing just what is between &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; if such a pattern is found inside the key name, in order to force multiple keys to be handled by the same node.</source>
          <target state="translated">Обратите внимание, что команда реализует полный алгоритм хеширования, включая поддержку &lt;strong&gt;хэш-тегов&lt;/strong&gt; , что является специальным свойством алгоритма хеширования ключей Redis Cluster, хеширования только того, что находится между &lt;code&gt;{&lt;/code&gt; и &lt;code&gt;}&lt;/code&gt; , если такой шаблон найден внутри имени ключа, по порядку чтобы заставить несколько ключей обрабатываться одним и тем же узлом.</target>
        </trans-unit>
        <trans-unit id="44319adff6c7cf60df65ef2f592ee1b07d9db575" translate="yes" xml:space="preserve">
          <source>Note that the format does not have any space, so &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output format is plain CSV with space as separator even when this special slots are emitted. However a complete parser for the format should be able to handle them.</source>
          <target state="translated">Обратите внимание, что в этом формате нет пробелов, поэтому выходной формат &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; - это простой CSV с пробелом в качестве разделителя, даже если эти специальные слоты выбрасываются. Однако полный синтаксический анализатор формата должен уметь их обрабатывать.</target>
        </trans-unit>
        <trans-unit id="6cf3d39f27c1b799248d5e59a73b1a5b0f086afd" translate="yes" xml:space="preserve">
          <source>Note that the maximum offset that you can set is 2&lt;sup&gt;29&lt;/sup&gt; -1 (536870911), as Redis Strings are limited to 512 megabytes. If you need to grow beyond this size, you can use multiple keys.</source>
          <target state="translated">Обратите внимание, что максимальное смещение, которое вы можете установить, составляет 2 &lt;sup&gt;29&lt;/sup&gt; -1 (536870911), так как Redis Strings ограничены 512 мегабайтами. Если вам нужно выйти за пределы этого размера, вы можете использовать несколько ключей.</target>
        </trans-unit>
        <trans-unit id="365b9132d09f3318597589e9536ca42a38461cb4" translate="yes" xml:space="preserve">
          <source>Note that the message is claimed only if its idle time is greater the minimum idle time we specify when calling &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;. Because as a side effect &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will also reset the idle time (since this is a new attempt at processing the message), two consumers trying to claim a message at the same time will never both succeed: only one will successfully claim the message. This avoids that we process a given message multiple times in a trivial way (yet multiple processing is possible and unavoidable in the general case).</source>
          <target state="translated">Обратите внимание, что сообщение &lt;a href=&quot;xclaim&quot;&gt;запрашивается,&lt;/a&gt; только если его время простоя больше минимального времени простоя, которое мы указываем при вызове XCLAIM . Поскольку в качестве побочного эффекта &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; также сбрасывает время простоя (поскольку это новая попытка обработки сообщения), два потребителя, пытающиеся запросить сообщение одновременно, никогда не будут успешными: только один успешно запросит сообщение. Это позволяет избежать того, чтобы мы обрабатывали данное сообщение несколько раз тривиальным способом (хотя в общем случае множественная обработка возможна и неизбежна).</target>
        </trans-unit>
        <trans-unit id="581b6da11286a19b84f5dbf7d26c9c4e1e18433c" translate="yes" xml:space="preserve">
          <source>Note that this command is not suitable when you need a guaranteed uniform distribution of the returned elements. For more information about the algorithms used for SPOP, look up both the Knuth sampling and Floyd sampling algorithms.</source>
          <target state="translated">Обратите внимание,что эта команда не подходит,когда требуется гарантированное равномерное распределение возвращаемых элементов.Для получения более подробной информации об алгоритмах,используемых для SPOP,посмотрите как на алгоритмы Knuth sampling,так и Floyd sampling.</target>
        </trans-unit>
        <trans-unit id="7aae41763fe9b0bc6731024cb063283c77ec4608" translate="yes" xml:space="preserve">
          <source>Note that this implementation of workers is trivially scalable and reliable, because even if a message is lost the item is still in the queue and will be processed at the next iteration.</source>
          <target state="translated">Обратите внимание,что эта реализация рабочих тривиально масштабируема и надежна,так как даже если сообщение потеряно,элемент все равно находится в очереди и будет обработан на следующей итерации.</target>
        </trans-unit>
        <trans-unit id="de6800f82ca82bf510c822b7935a67d6ca2bf21c" translate="yes" xml:space="preserve">
          <source>Note that we have a race here, but it is not a problem: &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; may return false but the key may be created by another client before we create it inside the &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block. However this race will just miss an API call under rare conditions, so the rate limiting will still work correctly.</source>
          <target state="translated">Обратите внимание, что у нас здесь гонка, но это не проблема: &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; может вернуть false, но ключ может быть создан другим клиентом до того, как мы создадим его внутри блока &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; . Однако эта гонка просто пропустит вызов API в редких случаях, поэтому ограничение скорости по-прежнему будет работать правильно.</target>
        </trans-unit>
        <trans-unit id="290162572eb7adbad822a4117dca945c127babde" translate="yes" xml:space="preserve">
          <source>Note that you need a recent version of redis-cli in order to read the slow log output, since it uses some features of the protocol that were not formerly implemented in redis-cli (deeply nested multi bulk replies).</source>
          <target state="translated">Обратите внимание,что вам нужна последняя версия redis-cli,чтобы читать медленный лог-выход,так как она использует некоторые возможности протокола,которые ранее не были реализованы в redis-cli (глубоко вложенные многопараметрические ответы).</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">Обратите внимание:</target>
        </trans-unit>
        <trans-unit id="851be398fabf2219f9c3aa64609a72f0559cc785" translate="yes" xml:space="preserve">
          <source>Note the used of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; in order to make sure that we'll both increment and set the expire at every API call.</source>
          <target state="translated">Обратите внимание на использование &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; и &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; , чтобы убедиться, что мы увеличиваем и устанавливаем срок действия при каждом вызове API.</target>
        </trans-unit>
        <trans-unit id="0ab5850865b49bbe39f155ec6e364488933508f0" translate="yes" xml:space="preserve">
          <source>Note this rule is not enforced in order to provide the user with opportunities to abuse the Redis single instance configuration, at the cost of writing scripts not compatible with Redis Cluster.</source>
          <target state="translated">Обратите внимание,что это правило не применяется для того,чтобы предоставить пользователю возможность злоупотреблять конфигурацией одного экземпляра Redis,за счет написания сценариев,несовместимых с Redis Cluster.</target>
        </trans-unit>
        <trans-unit id="9dfbcfbbaf119bccc3c44b098de0573996677b97" translate="yes" xml:space="preserve">
          <source>Note: A Redis instance that is configured for not persisting on disk (no AOF configured, nor &quot;save&quot; directive) will not dump the RDB file on &lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN&lt;/a&gt;, as usually you don't want Redis instances used only for caching to block on when shutting down.</source>
          <target state="translated">Примечание. Экземпляр Redis, который настроен так, чтобы не сохраняться на диске (не настроен AOF или директива &amp;laquo;save&amp;raquo;), не будет сбрасывать файл RDB при &lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN&lt;/a&gt; , поскольку обычно вы не хотите, чтобы экземпляры Redis, используемые только для кеширования, блокировались, когда Выключение.</target>
        </trans-unit>
        <trans-unit id="40e3fa9c72775db4fd05d5cf7a3a493e93afca05" translate="yes" xml:space="preserve">
          <source>Note: Since the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command options can replace &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;, &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.</source>
          <target state="translated">Примечание. Поскольку параметры команды &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; могут заменять &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; , &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt; , &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt; , возможно, что в будущих версиях Redis эти три команды будут устаревшими и окончательно удалены.</target>
        </trans-unit>
        <trans-unit id="3d6762a6aa2cf0aca37a59f773d7789ef284a403" translate="yes" xml:space="preserve">
          <source>Note: an important part of this behavior is that the PRNG that Redis implements as &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; is guaranteed to have the same output regardless of the architecture of the system running Redis. 32-bit, 64-bit, big-endian and little-endian systems will all produce the same output.</source>
          <target state="translated">Примечание: важной частью этого поведения является то, что PRNG, который Redis реализует как &lt;code&gt;math.random&lt;/code&gt; и &lt;code&gt;math.randomseed&lt;/code&gt; , гарантированно будет иметь одинаковый результат независимо от архитектуры системы, в которой работает Redis. 32-битные, 64-битные системы с прямым порядком байтов и обратным порядком байтов будут давать одинаковый результат.</target>
        </trans-unit>
        <trans-unit id="19d14832252be8ae1106f6c63fb642cd3e9e2df4" translate="yes" xml:space="preserve">
          <source>Note: as a side effect of calling this function, it is possible that the HyperLogLog is modified, since the last 8 bytes encode the latest computed cardinality for caching purposes. So &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; is technically a write command.</source>
          <target state="translated">Примечание: в качестве побочного эффекта вызова этой функции возможно изменение HyperLogLog, поскольку последние 8 байтов кодируют последнюю вычисленную мощность для целей кэширования. Таким образом, &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; технически является командой записи.</target>
        </trans-unit>
        <trans-unit id="ca716680732d1d3e7b5dc5d38bf23aaa2688e964" translate="yes" xml:space="preserve">
          <source>Note: as you can see Lua arrays are returned as Redis multi bulk replies, that is a Redis return type that your client library will likely convert into an Array type in your programming language.</source>
          <target state="translated">Замечание:как вы можете видеть,массивы Lua возвращаются в виде многократных ответов Redis,то есть тип возврата Redis,который ваша клиентская библиотека,скорее всего,преобразует в тип массива на вашем языке программирования.</target>
        </trans-unit>
        <trans-unit id="a094e9a0339a167054eac3028e87a3e324531dab" translate="yes" xml:space="preserve">
          <source>Note: of course as usually it is not guaranteed that the error text remains the same, however the error code will remain &lt;code&gt;-UNBLOCKED&lt;/code&gt;.</source>
          <target state="translated">Примечание: конечно, как обычно, не гарантируется, что текст ошибки останется прежним, однако код ошибки останется &lt;code&gt;-UNBLOCKED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ba013a44d25a035abd0e8ad87d8b610e34b72b2" translate="yes" xml:space="preserve">
          <source>Note: the command has a complexity of just O(log(N)) because it uses elements ranks (see &lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt;) to get an idea of the range. Because of this there is no need to do a work proportional to the size of the range.</source>
          <target state="translated">Примечание: команда имеет сложность всего O (log (N)), потому что она использует ранги элементов (см. &lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt; ), чтобы получить представление о диапазоне. Благодаря этому нет необходимости проделывать работу, пропорциональную размеру диапазона.</target>
        </trans-unit>
        <trans-unit id="a4cf334aa22d4d43d68ebc7afbb42dd9e08a0e09" translate="yes" xml:space="preserve">
          <source>Note: we use the &lt;strong&gt;COUNT&lt;/strong&gt; option in the example, so that for each stream the call will return at maximum two elements per stream.</source>
          <target state="translated">Примечание: в примере мы используем параметр &lt;strong&gt;COUNT&lt;/strong&gt; , чтобы для каждого потока вызов возвращал не более двух элементов на поток.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="5a4574a1a3d9728a0a89d6b1668d9c8dc4ec0634" translate="yes" xml:space="preserve">
          <source>Notes on published config epochs</source>
          <target state="translated">Примечания к опубликованным эпохам конфигурации</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="20be3b7a30a9bb9f7caa52a82e339d86765a7b3b" translate="yes" xml:space="preserve">
          <source>Number of commands processed</source>
          <target state="translated">Количество обработанных команд</target>
        </trans-unit>
        <trans-unit id="6567d67fead3b983bf0dd26e46b199bad4736caf" translate="yes" xml:space="preserve">
          <source>Number of connections received</source>
          <target state="translated">Количество полученных соединений</target>
        </trans-unit>
        <trans-unit id="c0e73dd590dc420faea4c4ac9906ba30e0259e37" translate="yes" xml:space="preserve">
          <source>Number of elements returned at every SCAN call</source>
          <target state="translated">Количество элементов,возвращаемых при каждом вызове SCAN</target>
        </trans-unit>
        <trans-unit id="f4702f3357a94e0b51c79789087a3eb454b1e296" translate="yes" xml:space="preserve">
          <source>Number of expired keys</source>
          <target state="translated">Количество просроченных ключей</target>
        </trans-unit>
        <trans-unit id="8e0e833a8bbaf63a540fadb74be8461319161578" translate="yes" xml:space="preserve">
          <source>Number of rejected connections</source>
          <target state="translated">Количество отклоненных соединений</target>
        </trans-unit>
        <trans-unit id="828f2a22520c1086f191a7adfcf910b96f4fe93b" translate="yes" xml:space="preserve">
          <source>OBJECT</source>
          <target state="translated">OBJECT</target>
        </trans-unit>
        <trans-unit id="9d8ec388e13faad9823f64e9acce4e1451d4eabf" translate="yes" xml:space="preserve">
          <source>OBJECT  subcommand [arguments [arguments ...]]   Inspect the internals of Redis objects</source>
          <target state="translated">Подкоманда OBJECT [аргументы [аргументы ...]]Проверьте внутреннюю часть объектов Redis</target>
        </trans-unit>
        <trans-unit id="77ba3ba2dc482ece5e336da9db6f45f553748e64" translate="yes" xml:space="preserve">
          <source>Objects can be encoded in different ways:</source>
          <target state="translated">Объекты могут быть закодированы различными способами:</target>
        </trans-unit>
        <trans-unit id="179e9e8b9188e3e0f2e120735c4089249f586f43" translate="yes" xml:space="preserve">
          <source>Obtaining the current length of the slow log</source>
          <target state="translated">Получение текущей длины медленного журнала</target>
        </trans-unit>
        <trans-unit id="5f6babf24c9404230c05a01781cf0ff83f2a099c" translate="yes" xml:space="preserve">
          <source>Of course it is also possible to use any other valid ID. If the specified consumer group already exists, the command returns a &lt;code&gt;-BUSYGROUP&lt;/code&gt; error. Otherwise the operation is performed and OK is returned. There are no hard limits to the number of consumer groups you can associate to a given stream.</source>
          <target state="translated">Конечно, также можно использовать любой другой действительный идентификатор. Если указанная группа потребителей уже существует, команда возвращает ошибку &lt;code&gt;-BUSYGROUP&lt;/code&gt; . В противном случае операция выполняется и возвращается ОК. Нет жестких ограничений на количество групп потребителей, которые вы можете связать с данным потоком.</target>
        </trans-unit>
        <trans-unit id="ff1bb1ff7a105fafca313a10f02e72dc891fbcf4" translate="yes" xml:space="preserve">
          <source>Of course this is not enough as there are expired keys that will never be accessed again. These keys should be expired anyway, so periodically Redis tests a few keys at random among keys with an expire set. All the keys that are already expired are deleted from the keyspace.</source>
          <target state="translated">Конечно,этого недостаточно,так как есть просроченные ключи,которые больше никогда не будут доступны.Эти ключи должны быть просрочены в любом случае,поэтому периодически Redis тестирует несколько ключей случайным образом среди ключей с набором истекших.Все ключи,срок действия которых уже истек,удаляются из пробела ключей.</target>
        </trans-unit>
        <trans-unit id="e1291438828df902dd44c789d43575a9bce5c968" translate="yes" xml:space="preserve">
          <source>On the other hand, defining commands using a special command or via &lt;code&gt;redis.conf&lt;/code&gt; would be a problem for a few reasons:</source>
          <target state="translated">С другой стороны, определение команд с помощью специальной команды или через &lt;code&gt;redis.conf&lt;/code&gt; было бы проблемой по нескольким причинам:</target>
        </trans-unit>
        <trans-unit id="9bcf11babeeb88215faca3f25a089c7e21ce30f5" translate="yes" xml:space="preserve">
          <source>Once a consumer &lt;em&gt;succesfully&lt;/em&gt; processes a message, it should call &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; so that such message does not get processed again, and as a side effect, the PEL entry about this message is also purged, releasing memory from the Redis server.</source>
          <target state="translated">Как только потребитель &lt;em&gt;успешно&lt;/em&gt; обработает сообщение, он должен вызвать &lt;a href=&quot;xack&quot;&gt;XACK,&lt;/a&gt; чтобы такое сообщение не было обработано снова, и в качестве побочного эффекта запись PEL об этом сообщении также удаляется, освобождая память сервера Redis.</target>
        </trans-unit>
        <trans-unit id="452b455cbf1a2a31d7d4b5005050bf4551fb3def" translate="yes" xml:space="preserve">
          <source>Once a node is turned into the replica of another master node, there is no need to inform the other cluster nodes about the change: heartbeat packets exchanged between nodes will propagate the new configuration automatically.</source>
          <target state="translated">Как только узел превращается в копию другого основного узла,нет необходимости информировать другие узлы кластера об изменении:пульсирующие пакеты,обмениваемые между узлами,будут автоматически распространять новую конфигурацию.</target>
        </trans-unit>
        <trans-unit id="24b95a3638ec064976a3c5a5f6794040d2c4ed0b" translate="yes" xml:space="preserve">
          <source>Once new data is present on one of the lists, the client returns with the name of the key unblocking it and the popped value.</source>
          <target state="translated">Как только новые данные присутствуют в одном из списков,клиент возвращается с именем разблокирующего его ключа и выскакивающим значением.</target>
        </trans-unit>
        <trans-unit id="dd41998567cd1f4f810cbadee2b74617b57a32fa" translate="yes" xml:space="preserve">
          <source>Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt; and &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt; commands.</source>
          <target state="translated">Когда клиент переходит в состояние подписки, он не должен выдавать никаких других команд, кроме дополнительных команд &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt; , &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; , &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt; и &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4b215656d61ce9a1a4991539bbd4f84ece9f512" translate="yes" xml:space="preserve">
          <source>Once we get some replies, the next call will be something like:</source>
          <target state="translated">Как только мы получим несколько ответов,следующий звонок будет что-то вроде:</target>
        </trans-unit>
        <trans-unit id="9de09a5350a4d4653c094b67b0dba8689a762e24" translate="yes" xml:space="preserve">
          <source>One client connection per line (separated by LF)</source>
          <target state="translated">Одно клиентское соединение на линию (разделенное LF)</target>
        </trans-unit>
        <trans-unit id="81d95091e8731132a88b7f9f02a3169be5e6b187" translate="yes" xml:space="preserve">
          <source>One of the guarantees of consumer groups is that a given consumer can only see the history of messages that were delivered to it, so a message has just a single owner. However there is a special feature called &lt;em&gt;message claiming&lt;/em&gt; that allows other consumers to claim messages in case there is a non recoverable failure of some consumer. In order to implement such semantics, consumer groups require explicit acknowledgement of the messages successfully processed by the consumer, via the &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command. This is needed because the stream will track, for each consumer group, who is processing what message.</source>
          <target state="translated">Одна из гарантий групп потребителей заключается в том, что конкретный потребитель может видеть только историю сообщений, которые были ему доставлены, поэтому у сообщения есть только один владелец. Однако существует специальная функция, называемая &lt;em&gt;заявлением сообщения,&lt;/em&gt; которая позволяет другим потребителям запрашивать сообщения в случае неисправимого отказа какого-либо потребителя. Для реализации такой семантики группам потребителей требуется явное подтверждение сообщений, успешно обработанных потребителем, с помощью команды &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; . Это необходимо, потому что поток будет отслеживать для каждой группы потребителей, кто какое сообщение обрабатывает.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="daa479a36fbba3ff638d59ae19308e8976bd5ac3" translate="yes" xml:space="preserve">
          <source>Orders of bits</source>
          <target state="translated">Порядок битов</target>
        </trans-unit>
        <trans-unit id="dcfd7c36726b3d9723cbd1a8981b89247967a629" translate="yes" xml:space="preserve">
          <source>Other consumers may inspect the list of pending messages, that are stale for quite some time, using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command. In order to continue processing such messages, they use &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; to acquire the ownership of the message and continue.</source>
          <target state="translated">Другие потребители могут проверить список ожидающих сообщений, которые устарели в течение некоторого времени, с помощью команды &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; . Чтобы продолжить обработку таких сообщений, они используют &lt;a href=&quot;xclaim&quot;&gt;XCLAIM,&lt;/a&gt; чтобы получить право собственности на сообщение и продолжить.</target>
        </trans-unit>
        <trans-unit id="3c2a27c636dc79870e309393531406e960ec4e18" translate="yes" xml:space="preserve">
          <source>Our previous example returns just the sorted IDs. In some cases, it is more useful to get the actual objects instead of their IDs (&lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;). Retrieving external keys based on the elements in a list, set or sorted set can be done with the following command:</source>
          <target state="translated">Наш предыдущий пример возвращает только отсортированные идентификаторы. В некоторых случаях более полезно получить фактические объекты, а не их идентификаторы ( &lt;code&gt;object_1&lt;/code&gt; , &lt;code&gt;object_2&lt;/code&gt; и &lt;code&gt;object_3&lt;/code&gt; ). Получить внешние ключи на основе элементов списка, набора или отсортированного набора можно с помощью следующей команды:</target>
        </trans-unit>
        <trans-unit id="e9c8427bc7498ec3380d38f116037bdd3bcddf6e" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the actual end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">Индексы вне диапазона не вызовут ошибки. Если &lt;code&gt;start&lt;/code&gt; больше конца списка, возвращается пустой список. Если &lt;code&gt;stop&lt;/code&gt; больше, чем фактический конец списка, Redis будет рассматривать его как последний элемент списка.</target>
        </trans-unit>
        <trans-unit id="c0a3cb19e89ec7bd7c87e53355299d0f62cc91cc" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the largest index in the sorted set, or &lt;code&gt;start &amp;gt;
stop&lt;/code&gt;, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the end of the sorted set Redis will treat it like it is the last element of the sorted set.</source>
          <target state="translated">Индексы вне диапазона не вызовут ошибки. Если &lt;code&gt;start&lt;/code&gt; больше, чем самый большой индекс в отсортированном наборе, или &lt;code&gt;start &amp;gt; stop&lt;/code&gt; , возвращается пустой список. Если &lt;code&gt;stop&lt;/code&gt; больше, чем конец отсортированного набора, Redis будет рассматривать его как последний элемент отсортированного набора.</target>
        </trans-unit>
        <trans-unit id="3dc054b880cd4ad0a83857995e10c362ec4b2504" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error: if &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, or &lt;code&gt;start &amp;gt; end&lt;/code&gt;, the result will be an empty list (which causes &lt;code&gt;key&lt;/code&gt; to be removed). If &lt;code&gt;end&lt;/code&gt; is larger than the end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">Индексы вне диапазона не вызовут ошибки: если &lt;code&gt;start&lt;/code&gt; больше конца списка или &lt;code&gt;start &amp;gt; end&lt;/code&gt; , результатом будет пустой список (что приведет к удалению &lt;code&gt;key&lt;/code&gt; ). Если &lt;code&gt;end&lt;/code&gt; больше, чем конец списка, Redis будет рассматривать его как последний элемент списка.</target>
        </trans-unit>
        <trans-unit id="c4e6b6c77c67abd27de260eb5ce674860a95ad42" translate="yes" xml:space="preserve">
          <source>Out-of-range indexes</source>
          <target state="translated">внебиржевые индексы</target>
        </trans-unit>
        <trans-unit id="c03f08a8f205e4568e916e3cfaa50c6a48749706" translate="yes" xml:space="preserve">
          <source>Output format</source>
          <target state="translated">Выходной формат</target>
        </trans-unit>
        <trans-unit id="275395efd6e79fdbe55cb36a4ebb4892dbdd5c40" translate="yes" xml:space="preserve">
          <source>Output of the command on replicas</source>
          <target state="translated">Вывод команды на реплики</target>
        </trans-unit>
        <trans-unit id="5ea9a43450142f5e1cfd51ca7b6956f8a9dbb82d" translate="yes" xml:space="preserve">
          <source>Overflow control</source>
          <target state="translated">Регулирование переполнения</target>
        </trans-unit>
        <trans-unit id="36fd64a953472994b938bbb13337305e87d9a9eb" translate="yes" xml:space="preserve">
          <source>Overwrites part of the string stored at &lt;em&gt;key&lt;/em&gt;, starting at the specified offset, for the entire length of &lt;em&gt;value&lt;/em&gt;. If the offset is larger than the current length of the string at &lt;em&gt;key&lt;/em&gt;, the string is padded with zero-bytes to make &lt;em&gt;offset&lt;/em&gt; fit. Non-existing keys are considered as empty strings, so this command will make sure it holds a string large enough to be able to set &lt;em&gt;value&lt;/em&gt; at &lt;em&gt;offset&lt;/em&gt;.</source>
          <target state="translated">Заменяет часть строки, хранящейся на &lt;em&gt;ключе&lt;/em&gt; , начиная с указанного смещения, на всю длину &lt;em&gt;значения&lt;/em&gt; . Если смещение больше текущей длины строки в &lt;em&gt;ключе&lt;/em&gt; , строка дополняется нулевыми байтами, чтобы &lt;em&gt;смещение&lt;/em&gt; соответствовало. Несуществующие ключи считаются пустыми строками, поэтому эта команда гарантирует, что она содержит строку, достаточно большую, чтобы можно было установить &lt;em&gt;значение&lt;/em&gt; по &lt;em&gt;смещению&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="34512fba1d256a361565532a3535096429399084" translate="yes" xml:space="preserve">
          <source>PERSIST</source>
          <target state="translated">PERSIST</target>
        </trans-unit>
        <trans-unit id="ae51373f050f6d2b0e0edfdd08e69fc1968bdf20" translate="yes" xml:space="preserve">
          <source>PERSIST  key   Remove the expiration from a key</source>
          <target state="translated">ПЕРСИСТ-ключ Удалить истечение срока действия из ключа</target>
        </trans-unit>
        <trans-unit id="7fa59fa06dcb2c9dc1b2b2bd46df7f33912c57b3" translate="yes" xml:space="preserve">
          <source>PEXPIRE</source>
          <target state="translated">PEXPIRE</target>
        </trans-unit>
        <trans-unit id="77a946764b4ffdf95c5ae217ca7f9cec5340bdc1" translate="yes" xml:space="preserve">
          <source>PEXPIRE  key milliseconds   Set a key's time to live in milliseconds</source>
          <target state="translated">Ключ PEXPIRE в миллисекундах Установить время жизни ключа в миллисекундах</target>
        </trans-unit>
        <trans-unit id="e609e3af460df9737d7d964f8bfec75a3773bde7" translate="yes" xml:space="preserve">
          <source>PEXPIREAT</source>
          <target state="translated">PEXPIREAT</target>
        </trans-unit>
        <trans-unit id="12d0e8f2d7d7718d124f2a5d583dfa8315ee3c0c" translate="yes" xml:space="preserve">
          <source>PEXPIREAT  key milliseconds-timestamp   Set the expiration for a key as a UNIX timestamp specified in milliseconds</source>
          <target state="translated">Штемпель времени ключа PEXPIREAT в миллисекундах Установить срок действия ключа в виде штемпеля времени UNIX,указанного в миллисекундах.</target>
        </trans-unit>
        <trans-unit id="fc7a17907dc63d1312607f17460e9eb6e7871f9d" translate="yes" xml:space="preserve">
          <source>PFADD</source>
          <target state="translated">PFADD</target>
        </trans-unit>
        <trans-unit id="e4e9e83ebacf78fb8cf3124d42502528b53d06ca" translate="yes" xml:space="preserve">
          <source>PFADD  key element [element ...]   Adds the specified elements to the specified HyperLogLog.</source>
          <target state="translated">Ключевой элемент PFADD [элемент ...]Добавляет указанные элементы в указанный HyperLogLog.</target>
        </trans-unit>
        <trans-unit id="274e92a9d4138573a0f107d2e57b9d0b46e7ac01" translate="yes" xml:space="preserve">
          <source>PFCOUNT</source>
          <target state="translated">PFCOUNT</target>
        </trans-unit>
        <trans-unit id="f81913b01d976cbaac4ade6c06f6bf299ee86214" translate="yes" xml:space="preserve">
          <source>PFCOUNT  key [key ...]   Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).</source>
          <target state="translated">Клавиша PFCOUNT [клавиша ...]Возвращает аппроксимированную кардинальность набора(ов),наблюдаемую HyperLogLog на клавише(ах).</target>
        </trans-unit>
        <trans-unit id="62f6ef6fa6924abe295c8c766f2b3e89d6d074fc" translate="yes" xml:space="preserve">
          <source>PFMERGE</source>
          <target state="translated">PFMERGE</target>
        </trans-unit>
        <trans-unit id="2ad005659587e94338ccd67e31dbc3fac2cb1536" translate="yes" xml:space="preserve">
          <source>PFMERGE  destkey sourcekey [sourcekey ...]   Merge N different HyperLogLogs into a single one.</source>
          <target state="translated">Исходный ключ PFMERGE [исходный ключ ...]Объединить N различных HyperLogLogLogs в один.</target>
        </trans-unit>
        <trans-unit id="0b1786a083a9087f0db36b08c1ff81a58930fbc2" translate="yes" xml:space="preserve">
          <source>PING</source>
          <target state="translated">PING</target>
        </trans-unit>
        <trans-unit id="45dae0d4784e1c9ea33d8d88f448f7989ea29500" translate="yes" xml:space="preserve">
          <source>PING  [message]   Ping the server</source>
          <target state="translated">Пинг [сообщение]Пинг сервера</target>
        </trans-unit>
        <trans-unit id="81efb783fc237efd685a1393fa9f947dd8abda5a" translate="yes" xml:space="preserve">
          <source>PSETEX</source>
          <target state="translated">PSETEX</target>
        </trans-unit>
        <trans-unit id="d7c40d1ee18ffeabe6099f89603c950454eb0276" translate="yes" xml:space="preserve">
          <source>PSETEX  key milliseconds value   Set the value and expiration in milliseconds of a key</source>
          <target state="translated">Стоимость ключа PSETEX в миллисекундах Установить стоимость и срок действия ключа в миллисекундах</target>
        </trans-unit>
        <trans-unit id="9e7e79c8d02bde08c4e705066bd533ffa7218538" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE</source>
          <target state="translated">PSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="71ae64e5df443252e78a1d1f929289a8311a1ef4" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE  pattern [pattern ...]   Listen for messages published to channels matching the given patterns</source>
          <target state="translated">Шаблон PSUBSCRIBE [шаблон ...]Прослушивание сообщений,опубликованных в каналах,соответствующих заданным шаблонам.</target>
        </trans-unit>
        <trans-unit id="7b8bdca458042e425d2902f59f800419aed5c8b1" translate="yes" xml:space="preserve">
          <source>PTTL</source>
          <target state="translated">PTTL</target>
        </trans-unit>
        <trans-unit id="05bf8ee07e7053cfaf8f62c038f0255fadf89afe" translate="yes" xml:space="preserve">
          <source>PTTL  key   Get the time to live for a key in milliseconds</source>
          <target state="translated">PTTL ключ Получить время жить для ключа в миллисекундах</target>
        </trans-unit>
        <trans-unit id="ff0fc30c743813f924dff4b751315af42d5ab08b" translate="yes" xml:space="preserve">
          <source>PUBLISH</source>
          <target state="translated">PUBLISH</target>
        </trans-unit>
        <trans-unit id="46e845a027f7bb36580703fc200d9108559fa747" translate="yes" xml:space="preserve">
          <source>PUBLISH  channel message   Post a message to a channel</source>
          <target state="translated">Сообщение канала PUBLISH Отправьте сообщение на канал.</target>
        </trans-unit>
        <trans-unit id="9487f50e961af3141e0c7833372d9b2c28cfa2a4" translate="yes" xml:space="preserve">
          <source>PUBSUB</source>
          <target state="translated">PUBSUB</target>
        </trans-unit>
        <trans-unit id="acad4a3c05b50f5f04a99427d2a3cdbb983fb0b9" translate="yes" xml:space="preserve">
          <source>PUBSUB  subcommand [argument [argument ...]]   Inspect the state of the Pub/Sub subsystem</source>
          <target state="translated">Подкоманда PUBSUB [аргумент [аргумент ...]]Проверка состояния подсистемы Pub/Sub</target>
        </trans-unit>
        <trans-unit id="ca024e3f958c6b7f4c7fa3671697866707cfa352" translate="yes" xml:space="preserve">
          <source>PUBSUB CHANNELS [pattern]</source>
          <target state="translated">PUBSUB КАНАЛЫ [образец]</target>
        </trans-unit>
        <trans-unit id="56e20f63e75d465369356d3ab7aa54f42d22cbb4" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE</source>
          <target state="translated">PUNSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="e54d89cca768ad85f7527ac0169fa1af2910b1cf" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE  [pattern [pattern ...]]   Stop listening for messages posted to channels matching the given patterns</source>
          <target state="translated">PUNSUBSCRIBE [образец [образец ...]]Прекратить прослушивание сообщений,отправленных на каналы,соответствующие заданным шаблонам.</target>
        </trans-unit>
        <trans-unit id="df3251b7546bede28dd0b0e82a26302f58157038" translate="yes" xml:space="preserve">
          <source>Passing keys and arguments as additional &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; arguments is also very useful in this context as the script string remains constant and can be efficiently cached by Redis.</source>
          <target state="translated">Передача ключей и аргументов в качестве дополнительных аргументов &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; также очень полезна в этом контексте, поскольку строка сценария остается постоянной и может быть эффективно кэширована Redis.</target>
        </trans-unit>
        <trans-unit id="19999dd613b36fb0786e599a84893b1e8a156a95" translate="yes" xml:space="preserve">
          <source>Pattern: Circular list</source>
          <target state="translated">Узор:Круглый список</target>
        </trans-unit>
        <trans-unit id="4d81f3aa2a2c95fc4a2b98f51dce59a3bb00d586" translate="yes" xml:space="preserve">
          <source>Pattern: Counter</source>
          <target state="translated">Узор:Счетчик</target>
        </trans-unit>
        <trans-unit id="73ea3bc6eae64663018b769f7c415b912584ee38" translate="yes" xml:space="preserve">
          <source>Pattern: Event notification</source>
          <target state="translated">Узор:Уведомление о событии</target>
        </trans-unit>
        <trans-unit id="9ff13cc43cfbf608a403dd95aced2e1c0f9fa96b" translate="yes" xml:space="preserve">
          <source>Pattern: Navigation session</source>
          <target state="translated">Узор:Сеанс навигации</target>
        </trans-unit>
        <trans-unit id="a7fd682d147cfd39262ca78719007b5177407a15" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter</source>
          <target state="translated">Образец:Ограничитель скорости</target>
        </trans-unit>
        <trans-unit id="527a190ff3f82d3d4bdfebea8586b0d301a67e3d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 1</source>
          <target state="translated">Узор:Ограничитель скорости 1</target>
        </trans-unit>
        <trans-unit id="d037a3f2c416c91b7789e304c06bd5786301383d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 2</source>
          <target state="translated">Узор:Ограничитель скорости 2</target>
        </trans-unit>
        <trans-unit id="18e48daae4954154a5de8c81ecf51283e080aacd" translate="yes" xml:space="preserve">
          <source>Pattern: Reliable queue</source>
          <target state="translated">Узор:Надежная очередь</target>
        </trans-unit>
        <trans-unit id="bc4ebd36f01622a36d608ba3197fe5c6b53d07d7" translate="yes" xml:space="preserve">
          <source>Pattern: Time series</source>
          <target state="translated">Узор:Временной ряд</target>
        </trans-unit>
        <trans-unit id="6aa9774204b5b0358a99c12a75b97dace59e135d" translate="yes" xml:space="preserve">
          <source>Pattern: real time metrics using bitmaps</source>
          <target state="translated">Модель:метрика в реальном времени с использованием растровых изображений</target>
        </trans-unit>
        <trans-unit id="387aa2d6e23537ab60fac1801379d3a3550c02d6" translate="yes" xml:space="preserve">
          <source>Pattern: real-time metrics using bitmaps</source>
          <target state="translated">Pattern:метрики в реальном времени с использованием растровых изображений</target>
        </trans-unit>
        <trans-unit id="d8f113cb1df36820baa76cc50b4089ad6af9aea4" translate="yes" xml:space="preserve">
          <source>Pattern: weighted random selection of an element</source>
          <target state="translated">Шаблон:взвешенный случайный выбор элемента</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="65bb2cda328eeb96caf6c6dce99ad10ccece742e" translate="yes" xml:space="preserve">
          <source>Pause the clients using &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;</source>
          <target state="translated">Приостановить клиентов с помощью &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="172162ae29287e5e829be8811d680119905ff86b" translate="yes" xml:space="preserve">
          <source>Perform a bitwise operation between multiple keys (containing string values) and store the result in the destination key.</source>
          <target state="translated">Выполните битовую операцию между несколькими ключами (содержащими значения строк)и сохраните результат в ключе назначения.</target>
        </trans-unit>
        <trans-unit id="1627d1d0d50fdeb9a3dce196f5de79d8f43842c0" translate="yes" xml:space="preserve">
          <source>Perform a blocking SAVE if at least one &lt;strong&gt;save point&lt;/strong&gt; is configured.</source>
          <target state="translated">Выполните блокирующее СОХРАНИТЬ, если настроена хотя бы одна &lt;strong&gt;точка сохранения&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c05e233359dba5b59b70fc0039c9fb4fdb4976d0" translate="yes" xml:space="preserve">
          <source>Perform a partial resynchronization after a disconnection.</source>
          <target state="translated">Выполните частичную ресинхронизацию после отключения.</target>
        </trans-unit>
        <trans-unit id="9d05c962f81bccc17939e7dff46bacb302dd37a2" translate="yes" xml:space="preserve">
          <source>Perform the SHA1 of the input string.</source>
          <target state="translated">Выполните SHA1 входной строки.</target>
        </trans-unit>
        <trans-unit id="0cb883fc85b1fd84aaebb7319c682c586a065641" translate="yes" xml:space="preserve">
          <source>Performance considerations</source>
          <target state="translated">Показатели эффективности</target>
        </trans-unit>
        <trans-unit id="c5453c00c8e4c4429dffd7c57ff9e409df17e57a" translate="yes" xml:space="preserve">
          <source>Performances</source>
          <target state="translated">Performances</target>
        </trans-unit>
        <trans-unit id="98a191010a72a819b496571f1515f19fc5db230c" translate="yes" xml:space="preserve">
          <source>Please check the example below and the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; documentation for more information about the command and its options.</source>
          <target state="translated">Пожалуйста, проверьте пример ниже и документацию &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; для получения дополнительной информации о команде и ее параметрах.</target>
        </trans-unit>
        <trans-unit id="2adb7fe266cd87cc96a429b9dce43b2d62d33470" translate="yes" xml:space="preserve">
          <source>Please for the specific semantics of the command refer to the documentation of &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;.</source>
          <target state="translated">Для получения информации о конкретной семантике команды обратитесь к документации &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d37ebc2f4f2d1c9e1508f49167dd6105a3aa57b4" translate="yes" xml:space="preserve">
          <source>Please note depending on the version of Redis some of the fields have been added or removed. A robust client application should therefore parse the result of this command by skipping unknown properties, and gracefully handle missing fields.</source>
          <target state="translated">Обратите внимание,что в зависимости от версии Redis некоторые из полей были добавлены или удалены.Поэтому надежное клиентское приложение должно разобрать результат этой команды,пропустив неизвестные свойства,и изящно обработать недостающие поля.</target>
        </trans-unit>
        <trans-unit id="cf36c5202e34a4a67ab38d9f9bd7222bda763dfd" translate="yes" xml:space="preserve">
          <source>Please note that before reading this page, if you are new to streams, we recommend to read &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;our introduction to Redis Streams&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что перед чтением этой страницы, если вы новичок в потоках, мы рекомендуем прочитать &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;наше введение в Redis Streams&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="95e0253f33057b2f70a061e11de2d3d4a685d9c7" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; documentation for detailed information about Redis Lua scripting.</source>
          <target state="translated">Пожалуйста, обратитесь к документации &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; для получения подробной информации о сценариях Redis Lua.</target>
        </trans-unit>
        <trans-unit id="67fc81a1bc0292fa12fdf63856d1ae3a69b0523a" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence documentation&lt;/a&gt; for detailed information.</source>
          <target state="translated">Пожалуйста, обратитесь к &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;документации&lt;/a&gt; по постоянству для получения подробной информации.</target>
        </trans-unit>
        <trans-unit id="7a135ffdb71c43178f876e40f960bf45f1a29237" translate="yes" xml:space="preserve">
          <source>Please see the pattern description in the &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; documentation.</source>
          <target state="translated">См. Описание шаблона в документации &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aed6d393dd61d1ba31957e351636ff901b0e6fa8" translate="yes" xml:space="preserve">
          <source>Posts a message to the given channel.</source>
          <target state="translated">Размещает сообщение на данном канале.</target>
        </trans-unit>
        <trans-unit id="f815dfb4f6f438e54dc2f0a16193e4c96d3c1109" translate="yes" xml:space="preserve">
          <source>Practically speaking, for the client it is much better to simply assume that in the context of a given connection, cached scripts are guaranteed to be there unless an administrator explicitly called the &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; command.</source>
          <target state="translated">С практической точки зрения, для клиента гораздо лучше просто предположить, что в контексте данного соединения кэшированные сценарии гарантированно присутствуют, если администратор явно не вызвал команду &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d21fc376a96084ebb73d4e8b35c0a4c4be845e0" translate="yes" xml:space="preserve">
          <source>Provide information on the role of a Redis instance in the context of replication, by returning if the instance is currently a &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;slave&lt;/code&gt;, or &lt;code&gt;sentinel&lt;/code&gt;. The command also returns additional information about the state of the replication (if the role is master or slave) or the list of monitored master names (if the role is sentinel).</source>
          <target state="translated">Предоставьте информацию о роли экземпляра Redis в контексте репликации, вернув, является ли экземпляр в настоящее время &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;slave&lt;/code&gt; или &lt;code&gt;sentinel&lt;/code&gt; . Команда также возвращает дополнительную информацию о состоянии репликации (если роль - главная или подчиненная) или список отслеживаемых главных имен (если роль - дозорная).</target>
        </trans-unit>
        <trans-unit id="7ca91750d60fd45e80636934b3d1f1da26ffd9f9" translate="yes" xml:space="preserve">
          <source>Pub/Sub</source>
          <target state="translated">Pub/Sub</target>
        </trans-unit>
        <trans-unit id="5860c8458788e44e7636fa364548e067049a0d7b" translate="yes" xml:space="preserve">
          <source>QUIT</source>
          <target state="translated">QUIT</target>
        </trans-unit>
        <trans-unit id="7471799996c7de46c4ffa444365596fb514b6f5a" translate="yes" xml:space="preserve">
          <source>QUIT   Close the connection</source>
          <target state="translated">QUIT Закрыть соединение</target>
        </trans-unit>
        <trans-unit id="baa5d3184c0cc0ce5e007af06198524a4d26548f" translate="yes" xml:space="preserve">
          <source>Quit the server.</source>
          <target state="translated">Уходите с сервера.</target>
        </trans-unit>
        <trans-unit id="94386a96dc3f69665a14e74fb2942d92163c5d74" translate="yes" xml:space="preserve">
          <source>RANDOMKEY</source>
          <target state="translated">RANDOMKEY</target>
        </trans-unit>
        <trans-unit id="338552ba06825ef4f555f3d5ff79d40557c925de" translate="yes" xml:space="preserve">
          <source>RANDOMKEY   Return a random key from the keyspace</source>
          <target state="translated">RANDOMKEY Возврат случайного ключа из клавишного пространства</target>
        </trans-unit>
        <trans-unit id="90a97e888676c2d0f3b14c8b4a5ca16d360880bc" translate="yes" xml:space="preserve">
          <source>READONLY</source>
          <target state="translated">READONLY</target>
        </trans-unit>
        <trans-unit id="21d1a8e094bd428debefea84e6dd96322d4c6011" translate="yes" xml:space="preserve">
          <source>READONLY   Enables read queries for a connection to a cluster replica node</source>
          <target state="translated">READONLY Включает запросы на чтение для подключения к узлу реплики кластера.</target>
        </trans-unit>
        <trans-unit id="5305e8529d963d471cecc6faf967cedff2ea7494" translate="yes" xml:space="preserve">
          <source>READWRITE</source>
          <target state="translated">READWRITE</target>
        </trans-unit>
        <trans-unit id="2ae19352a72e6e879b7c82d353a544f20f6b355b" translate="yes" xml:space="preserve">
          <source>READWRITE   Disables read queries for a connection to a cluster replica node</source>
          <target state="translated">READWRITE Отключает запросы на чтение для подключения к узлу реплики кластера</target>
        </trans-unit>
        <trans-unit id="4756081595ff9366e8b59c094aebf3df53a8fc98" translate="yes" xml:space="preserve">
          <source>RENAME</source>
          <target state="translated">RENAME</target>
        </trans-unit>
        <trans-unit id="434016433de8ed51fc6a3df25c58d49e8397ca2e" translate="yes" xml:space="preserve">
          <source>RENAME  key newkey   Rename a key</source>
          <target state="translated">Переименовать ключ Переименовать ключ</target>
        </trans-unit>
        <trans-unit id="eb9b6064a90c47e23a80adefc9b43f4215668dbe" translate="yes" xml:space="preserve">
          <source>RENAMENX</source>
          <target state="translated">RENAMENX</target>
        </trans-unit>
        <trans-unit id="e1288934ac4d4000f51ff88bf791420487a34758" translate="yes" xml:space="preserve">
          <source>RENAMENX  key newkey   Rename a key, only if the new key does not exist</source>
          <target state="translated">Переименовать ключ Переименовать ключ,только если новый ключ не существует.</target>
        </trans-unit>
        <trans-unit id="12c92fcd35c554e1970345d0c852363a2bfff485" translate="yes" xml:space="preserve">
          <source>REPLICAOF</source>
          <target state="translated">REPLICAOF</target>
        </trans-unit>
        <trans-unit id="81253c78d1304948f92fc2d7488335ba2280cd3f" translate="yes" xml:space="preserve">
          <source>REPLICAOF  host port   Make the server a replica of another instance, or promote it as master.</source>
          <target state="translated">REPLICAOF порт хоста Сделать сервер копией другого экземпляра,или продвинуть его в качестве ведущего.</target>
        </trans-unit>
        <trans-unit id="6a8135bcdb582d28d5425eef52faf6ac80eefb26" translate="yes" xml:space="preserve">
          <source>RESTORE</source>
          <target state="translated">RESTORE</target>
        </trans-unit>
        <trans-unit id="693be3f2ba1e3d54a77f2bd81f59053740c9352a" translate="yes" xml:space="preserve">
          <source>RESTORE  key ttl serialized-value [REPLACE]   Create a key using the provided serialized value, previously obtained using DUMP.</source>
          <target state="translated">RESTORE ключ ttl сериализованного значения [REPLACE]Создайте ключ,используя предоставленное сериализованное значение,ранее полученное с помощью DUMP.</target>
        </trans-unit>
        <trans-unit id="1631070e7f0b44982ae66b11640654e7ec5dc4bd" translate="yes" xml:space="preserve">
          <source>ROLE</source>
          <target state="translated">ROLE</target>
        </trans-unit>
        <trans-unit id="5b2e8afa66ad35a6843b32ab5ca521321ed80e09" translate="yes" xml:space="preserve">
          <source>ROLE   Return the role of the instance in the context of replication</source>
          <target state="translated">ROLE Возврат роли экземпляра в контексте репликации</target>
        </trans-unit>
        <trans-unit id="b7ce3009275f8c79b50c7f42dcb85f259fc1334f" translate="yes" xml:space="preserve">
          <source>RPOP</source>
          <target state="translated">RPOP</target>
        </trans-unit>
        <trans-unit id="daae95751cd7b3b0d6286ba595f17b95a4dbf14d" translate="yes" xml:space="preserve">
          <source>RPOP  key   Remove and get the last element in a list</source>
          <target state="translated">Клавиша RPOP Удалить и получить последний элемент в списке</target>
        </trans-unit>
        <trans-unit id="5fc91e22c7eda82f26217a9a276a557189795a83" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH</source>
          <target state="translated">RPOPLPUSH</target>
        </trans-unit>
        <trans-unit id="9b4f14c63b639db09e2a8cbabb9aee76bf074fd7" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH  source destination   Remove the last element in a list, prepend it to another list and return it</source>
          <target state="translated">Назначение источника RPOPLPUSH Удалить последний элемент списка,подготовить его к другому списку и вернуть его.</target>
        </trans-unit>
        <trans-unit id="b9d73dc860be3da3eb63b95dc888be66d34c596b" translate="yes" xml:space="preserve">
          <source>RPUSH</source>
          <target state="translated">RPUSH</target>
        </trans-unit>
        <trans-unit id="cc9293df01dd3379605fef72d334681379153757" translate="yes" xml:space="preserve">
          <source>RPUSH  key value [value ...]   Append one or multiple values to a list</source>
          <target state="translated">RPUSH-значение клавиши [значение ...]Добавить одно или несколько значений в список.</target>
        </trans-unit>
        <trans-unit id="a2fe5b491151e540de6422c6e85592df5f204dc3" translate="yes" xml:space="preserve">
          <source>RPUSHX</source>
          <target state="translated">RPUSHX</target>
        </trans-unit>
        <trans-unit id="61d6ff5cbc32d5fc0ed38bfb10b34d14916d1c00" translate="yes" xml:space="preserve">
          <source>RPUSHX  key value   Append a value to a list, only if the list exists</source>
          <target state="translated">RPUSHX значение ключа Добавить значение к списку,только если список существует.</target>
        </trans-unit>
        <trans-unit id="a31a9b75b6318e8c48bf5d454b96698ee608da57" translate="yes" xml:space="preserve">
          <source>Range of integer scores that can be expressed precisely</source>
          <target state="translated">Диапазон целочисленных баллов,которые могут быть выражены точно</target>
        </trans-unit>
        <trans-unit id="df8903174eb3eac863f1253076caa8171702cb53" translate="yes" xml:space="preserve">
          <source>Range: 3900-4000</source>
          <target state="translated">Диапазон:3900-4000</target>
        </trans-unit>
        <trans-unit id="e1d33f7270a253d76d9b6fe1deb9155ecce0ca42" translate="yes" xml:space="preserve">
          <source>Read data from one or multiple streams, only returning entries with an ID greater than the last received ID reported by the caller. This command has an option to block if items are not available, in a similar fashion to &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; or &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; and others.</source>
          <target state="translated">Считывать данные из одного или нескольких потоков, возвращая только записи с идентификатором, превышающим последний полученный идентификатор, указанный вызывающей стороной. Эта команда имеет возможность блокировать , если элементы будут недоступны, аналогичным образом к &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; или &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; и другим.</target>
        </trans-unit>
        <trans-unit id="58ccdcefd173a8269ea376346a634ff6e968e57b" translate="yes" xml:space="preserve">
          <source>Read only variants</source>
          <target state="translated">Только для чтения варианты</target>
        </trans-unit>
        <trans-unit id="b8590ac877c85f2030d4921db5e93ead78595a0f" translate="yes" xml:space="preserve">
          <source>Read queries against a Redis Cluster slave node are disabled by default, but you can use the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command to change this behavior on a per- connection basis. The &lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt; command resets the readonly mode flag of a connection back to readwrite.</source>
          <target state="translated">Запросы чтения к подчиненному узлу Redis Cluster по умолчанию отключены, но вы можете использовать команду &lt;a href=&quot;readonly&quot;&gt;READONLY,&lt;/a&gt; чтобы изменить это поведение для каждого соединения. Команда &lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt; сбрасывает флаг режима только для чтения соединения обратно на чтение и запись.</target>
        </trans-unit>
        <trans-unit id="9ec77fdefc87d676b3e9acb9a7b04ded405da8e4" translate="yes" xml:space="preserve">
          <source>Reading application code, the complete semantics might not be clear since the application calls commands defined server side.</source>
          <target state="translated">Читая код приложения,полная семантика может быть нечеткой,так как приложение вызывает команды,определенные на стороне сервера.</target>
        </trans-unit>
        <trans-unit id="116cec955773e978e0eecf1499a10199d4278c99" translate="yes" xml:space="preserve">
          <source>Reading the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streams introduction&lt;/a&gt; is highly suggested in order to understand more about the streams overall behavior and semantics.</source>
          <target state="translated">Настоятельно рекомендуется прочитать &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;введение Redis Streams&lt;/a&gt; , чтобы лучше понять общее поведение и семантику потоков.</target>
        </trans-unit>
        <trans-unit id="88951d0701502f598feecc55f4d3172c32a2db31" translate="yes" xml:space="preserve">
          <source>Reading the slow log</source>
          <target state="translated">Чтение медленного журнала</target>
        </trans-unit>
        <trans-unit id="a87de541283ca3bc3c0a398706ee3346da0564e3" translate="yes" xml:space="preserve">
          <source>Recent versions of Redis Sentinel (Redis 2.8.12 or greater) use CLIENT KILL in order to kill clients when an instance is reconfigured, in order to force clients to perform the handshake with one Sentinel again and update its configuration.</source>
          <target state="translated">Последние версии Redis Sentinel (Redis 2.8.12 или более поздние)используют CLIENT KILL (УДОБИТЕЛЬНОЕ ПОЛУЧЕНИЕ)для того,чтобы убить клиентов при изменении конфигурации экземпляра,чтобы заставить клиентов выполнить повторное рукопожатие с одним Sentinel и обновить его конфигурацию.</target>
        </trans-unit>
        <trans-unit id="68c1dff2ef06724a3eb5f0a503f24117784a62d1" translate="yes" xml:space="preserve">
          <source>Reconfigure clients to connect with the new master.</source>
          <target state="translated">Реконфигурируйте клиентов для связи с новым мастером.</target>
        </trans-unit>
        <trans-unit id="24071b57a13027c01339027dcccb98218f052a8f" translate="yes" xml:space="preserve">
          <source>Redis</source>
          <target state="translated">Redis</target>
        </trans-unit>
        <trans-unit id="64fb7fd6108bc6be312c9ee1e4ae786b08c32a13" translate="yes" xml:space="preserve">
          <source>Redis 3.2 introduced an optional &lt;code&gt;count&lt;/code&gt; argument that can be passed to &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; in order to retrieve multiple elements in a single call.</source>
          <target state="translated">Redis 3.2 представил необязательный аргумент &lt;code&gt;count&lt;/code&gt; , который можно передать в &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; , чтобы получить несколько элементов за один вызов.</target>
        </trans-unit>
        <trans-unit id="09da59c00f13190142c29bd0fc09b7580fb99363" translate="yes" xml:space="preserve">
          <source>Redis Cluster live resharding explained</source>
          <target state="translated">Кластер Redis в прямом эфире объяснил</target>
        </trans-unit>
        <trans-unit id="8be0343488efef207b0826c15486c08f81f5710d" translate="yes" xml:space="preserve">
          <source>Redis HyperLogLogs are represented using a double representation: the &lt;em&gt;sparse&lt;/em&gt; representation suitable for HLLs counting a small number of elements (resulting in a small number of registers set to non-zero value), and a &lt;em&gt;dense&lt;/em&gt; representation suitable for higher cardinalities. Redis automatically switches from the sparse to the dense representation when needed.</source>
          <target state="translated">Redis HyperLogLogs представлены с использованием двойного представления: &lt;em&gt;разреженное&lt;/em&gt; представление, подходящее для HLL, подсчитывающее небольшое количество элементов (что приводит к небольшому количеству регистров, установленных на ненулевое значение), и &lt;em&gt;плотное&lt;/em&gt; представление, подходящее для более высоких мощностей. Redis автоматически переключается с разреженного на плотное представление, когда это необходимо.</target>
        </trans-unit>
        <trans-unit id="2e645ecd73ea1ffa136575150e55a17bbdaf4a35" translate="yes" xml:space="preserve">
          <source>Redis Nil bulk reply and Nil multi bulk reply -&amp;gt; Lua false boolean type</source>
          <target state="translated">Redis Nil массовый ответ и Nil мульти массовый ответ -&amp;gt; логический тип Lua false</target>
        </trans-unit>
        <trans-unit id="12deb2b7b17fe48280b9acc8ac6e268a2fccdfc8" translate="yes" xml:space="preserve">
          <source>Redis bulk reply -&amp;gt; Lua string</source>
          <target state="translated">Redis массовый ответ -&amp;gt; строка Lua</target>
        </trans-unit>
        <trans-unit id="28c992585f8b92e96ef7862e17fbc69b72429ffe" translate="yes" xml:space="preserve">
          <source>Redis commands that may return elements in random order, like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (because Redis Sets are &lt;em&gt;unordered&lt;/em&gt;) have a different behavior when called from Lua, and undergo a silent lexicographical sorting filter before returning data to Lua scripts. So &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; will always return the Set elements in the same order, while the same command invoked from normal clients may return different results even if the key contains exactly the same elements.</source>
          <target state="translated">Команды Redis, которые могут возвращать элементы в случайном порядке, такие как &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (поскольку наборы Redis &lt;em&gt;неупорядочены&lt;/em&gt; ), имеют другое поведение при вызове из Lua и проходят тихий лексикографический фильтр сортировки перед возвратом данных в сценарии Lua. Таким образом, &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; всегда будет возвращать элементы Set в одном и том же порядке, в то время как одна и та же команда, вызванная из обычных клиентов, может возвращать разные результаты, даже если ключ содержит точно такие же элементы.</target>
        </trans-unit>
        <trans-unit id="9030a22b56473e440d80783adf7755f42e3cd798" translate="yes" xml:space="preserve">
          <source>Redis commands usually accept one key, two keys, or an unlimited number of keys.</source>
          <target state="translated">Команды Redis обычно принимают один ключ,два ключа или неограниченное количество ключей.</target>
        </trans-unit>
        <trans-unit id="4798309557a5e9b4d97ab42c59e238806f00fa04" translate="yes" xml:space="preserve">
          <source>Redis different selectable databases are a form of namespacing: all the databases are anyway persisted together in the same RDB / AOF file. However different databases can have keys having the same name, and there are commands available like &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;, &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; or &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; that work on specific databases.</source>
          <target state="translated">Различные выбираемые базы данных Redis - это форма пространственного именования: все базы данных в любом случае сохраняются вместе в одном файле RDB / AOF. Однако разные базы данных могут иметь ключи с одинаковыми именами, и доступны такие команды, как &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; , &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; или &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY,&lt;/a&gt; которые работают с конкретными базами данных.</target>
        </trans-unit>
        <trans-unit id="a48311c837dbe1e0c3cec8f3114d4df2e8c16385" translate="yes" xml:space="preserve">
          <source>Redis error reply -&amp;gt; Lua table with a single &lt;code&gt;err&lt;/code&gt; field containing the error</source>
          <target state="translated">Ответ об ошибке Redis -&amp;gt; Таблица Lua с одним полем &lt;code&gt;err&lt;/code&gt; , содержащим ошибку</target>
        </trans-unit>
        <trans-unit id="562ad79eb5fcdcd97d8a0283855bce99c0023855" translate="yes" xml:space="preserve">
          <source>Redis integer reply -&amp;gt; Lua number</source>
          <target state="translated">Целочисленный ответ Redis -&amp;gt; номер Lua</target>
        </trans-unit>
        <trans-unit id="53c0959152bcf66e99f3ab4d98ebaba488b539de" translate="yes" xml:space="preserve">
          <source>Redis is UTF-8 aware, assuming you correctly set the &lt;code&gt;!LC_COLLATE&lt;/code&gt; environment variable.</source>
          <target state="translated">Redis поддерживает UTF-8, если вы правильно установили переменную среды &lt;code&gt;!LC_COLLATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac11208b3186492fddcf23ffb985bed2f4b921dd" translate="yes" xml:space="preserve">
          <source>Redis is now able to delete keys in the background in a different thread without blocking the server. An &lt;code&gt;ASYNC&lt;/code&gt; option was added to &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; and &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; in order to let the entire dataset or a single database to be freed asynchronously.</source>
          <target state="translated">Redis теперь может удалять ключи в фоновом режиме в другом потоке, не блокируя сервер. &lt;code&gt;ASYNC&lt;/code&gt; вариант был добавлен в &lt;a href=&quot;flushall&quot;&gt;FlushAll&lt;/a&gt; и &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; для того , чтобы позволить весь набор данных или единой базы данных , которые будут освобождены асинхронно.</target>
        </trans-unit>
        <trans-unit id="f26191bd07f5d296d686b49ddf0fea28de008280" translate="yes" xml:space="preserve">
          <source>Redis is often used as a messaging server to implement processing of background jobs or other kinds of messaging tasks. A simple form of queue is often obtained pushing values into a list in the producer side, and waiting for this values in the consumer side using &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; (using polling), or &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; if the client is better served by a blocking operation.</source>
          <target state="translated">Redis часто используется в качестве сервера обмена сообщениями для выполнения обработки фоновых заданий или других задач обмена сообщениями. Простая форма очереди часто получается путем помещения значений в список на стороне производителя и ожидания этих значений на стороне потребителя с использованием &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; (с использованием опроса) или &lt;a href=&quot;brpop&quot;&gt;BRPOP,&lt;/a&gt; если клиент лучше обслуживается операцией блокировки.</target>
        </trans-unit>
        <trans-unit id="42a27bac8c1f348420272658d3c655887b07c3ba" translate="yes" xml:space="preserve">
          <source>Redis keys are expired in two ways: a passive way, and an active way.</source>
          <target state="translated">Срок действия клавиш Redis истекает двумя способами:пассивным и активным.</target>
        </trans-unit>
        <trans-unit id="ea38abb16e6fc53c1055d716b8dafffc97128c14" translate="yes" xml:space="preserve">
          <source>Redis logs that a script is running too long.</source>
          <target state="translated">Redis записывает,что сценарий работает слишком долго.</target>
        </trans-unit>
        <trans-unit id="5ada15ccb812ae3dfe260cac4cea16ab388a5061" translate="yes" xml:space="preserve">
          <source>Redis multi bulk reply -&amp;gt; Lua table (may have other Redis data types nested)</source>
          <target state="translated">Многократный массовый ответ Redis -&amp;gt; Таблица Lua (могут быть вложены другие типы данных Redis)</target>
        </trans-unit>
        <trans-unit id="cb910cc16645a1fbd760219098ebcbf7bc9f050c" translate="yes" xml:space="preserve">
          <source>Redis offers a SCRIPT command that can be used in order to control the scripting subsystem. SCRIPT currently accepts three different commands:</source>
          <target state="translated">Redis предлагает команду SCRIPT,которую можно использовать для управления подсистемой сценариев.В настоящее время SCRIPT принимает три различные команды:</target>
        </trans-unit>
        <trans-unit id="0ab17f17e02f188a1bdf8cac0d6180f82fee1717" translate="yes" xml:space="preserve">
          <source>Redis return values are converted into Lua data types when Lua calls a Redis command using &lt;code&gt;call()&lt;/code&gt; or &lt;code&gt;pcall()&lt;/code&gt;. Similarly, Lua data types are converted into the Redis protocol when calling a Redis command and when a Lua script returns a value, so that scripts can control what &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; will return to the client.</source>
          <target state="translated">Возвращаемые значения Redis преобразуются в типы данных Lua, когда Lua вызывает команду Redis с помощью &lt;code&gt;call()&lt;/code&gt; или &lt;code&gt;pcall()&lt;/code&gt; . Точно так же типы данных Lua преобразуются в протокол Redis при вызове команды Redis и когда сценарий Lua возвращает значение, так что сценарии могут управлять тем, что &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; будет возвращать клиенту.</target>
        </trans-unit>
        <trans-unit id="0fa967ae24b949a1700795759c8cdfe062988a8a" translate="yes" xml:space="preserve">
          <source>Redis scripts are not allowed to create global variables, in order to avoid leaking data into the Lua state. If a script needs to maintain state between calls (a pretty uncommon need) it should use Redis keys instead.</source>
          <target state="translated">Скрипты Redis не позволяют создавать глобальные переменные,чтобы избежать утечки данных в состояние Lua.Если скрипту необходимо поддерживать состояние между вызовами (довольно редкая необходимость),он должен использовать клавиши Redis.</target>
        </trans-unit>
        <trans-unit id="e62135b0922f82850c893085d4cd08cc6fd7ccb4" translate="yes" xml:space="preserve">
          <source>Redis slow log overview</source>
          <target state="translated">Медленный обзор журнала Redis</target>
        </trans-unit>
        <trans-unit id="add967db3e0dd55b3522bf60d87afa3192a4838a" translate="yes" xml:space="preserve">
          <source>Redis sorted sets use a &lt;em&gt;double 64-bit floating point number&lt;/em&gt; to represent the score. In all the architectures we support, this is represented as an &lt;strong&gt;IEEE 754 floating point number&lt;/strong&gt;, that is able to represent precisely integer numbers between &lt;code&gt;-(2^53)&lt;/code&gt; and &lt;code&gt;+(2^53)&lt;/code&gt; included. In more practical terms, all the integers between -9007199254740992 and 9007199254740992 are perfectly representable. Larger integers, or fractions, are internally represented in exponential form, so it is possible that you get only an approximation of the decimal number, or of the very big integer, that you set as score.</source>
          <target state="translated">Сортированные наборы Redis используют &lt;em&gt;двойное 64-битное число&lt;/em&gt; с &lt;em&gt;плавающей запятой&lt;/em&gt; для представления оценки. Во всех поддерживаемых нами архитектурах это представлено как число с &lt;strong&gt;плавающей запятой IEEE 754&lt;/strong&gt; , которое может точно представлять целые числа от &lt;code&gt;-(2^53)&lt;/code&gt; до &lt;code&gt;+(2^53)&lt;/code&gt; включительно. С практической точки зрения, все целые числа от -9007199254740992 до 9007199254740992 прекрасно представимы. Более крупные целые числа или дроби внутренне представлены в экспоненциальной форме, поэтому возможно, что вы получите только приблизительное значение десятичного числа или очень большого целого числа, которое вы установили в качестве оценки.</target>
        </trans-unit>
        <trans-unit id="738a4a620b4c28b97c15ca1b2edd5526cb23af29" translate="yes" xml:space="preserve">
          <source>Redis status reply -&amp;gt; Lua table with a single &lt;code&gt;ok&lt;/code&gt; field containing the status</source>
          <target state="translated">Ответ статуса Redis -&amp;gt; Таблица Lua с единственным полем &lt;code&gt;ok&lt;/code&gt; , содержащим статус</target>
        </trans-unit>
        <trans-unit id="db935d0902ab47146d7cddc707ae23f8dbd30e13" translate="yes" xml:space="preserve">
          <source>Redis stores integers in their integer representation, so for string values that actually hold an integer, there is no overhead for storing the string representation of the integer.</source>
          <target state="translated">Redis хранит целые числа в их целочисленном представлении,поэтому для строковых значений,которые на самом деле содержат целое число,нет накладных расходов на хранение строкового представления целого числа.</target>
        </trans-unit>
        <trans-unit id="b6955638f080137455ca2315a3e774bacb29e670" translate="yes" xml:space="preserve">
          <source>Redis streams are represented in a way that makes them memory efficient: a radix tree is used in order to index macro-nodes that pack linearly tens of stream entries. Normally what happens when you delete an entry from a stream is that the entry is not &lt;em&gt;really&lt;/em&gt; evicted, it just gets marked as deleted.</source>
          <target state="translated">Потоки Redis представлены таким образом, чтобы они экономили память: для индексации макроузлов, которые линейно упаковывают десятки записей потока, используется основание системы счисления. Обычно то , что происходит при удалении записи из потока является то , что запись не &lt;em&gt;действительно&lt;/em&gt; выселили, он просто получает помечаются как удаленные.</target>
        </trans-unit>
        <trans-unit id="fa7af6984c788798f4aee1b72f3fb15136c972f4" translate="yes" xml:space="preserve">
          <source>Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;. From the point of view of all the other clients the effects of a script are either still not visible or already completed.</source>
          <target state="translated">Redis использует один и тот же интерпретатор Lua для выполнения всех команд. Также Redis гарантирует, что сценарий выполняется атомарно: ни один другой сценарий или команда Redis не будет выполняться во время выполнения сценария. Эта семантика аналогична семантике &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; . С точки зрения всех остальных клиентов эффекты сценария либо еще не видны, либо уже выполнены.</target>
        </trans-unit>
        <trans-unit id="315e6feef25876fa664b37d723e94c657b1c8f6a" translate="yes" xml:space="preserve">
          <source>Redis will block the script with an error if a script calls a Redis command able to alter the data set &lt;strong&gt;after&lt;/strong&gt; a Redis &lt;em&gt;random&lt;/em&gt; command like &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;, &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;, &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;. This means that if a script is read-only and does not modify the data set it is free to call those commands. Note that a &lt;em&gt;random command&lt;/em&gt; does not necessarily mean a command that uses random numbers: any non-deterministic command is considered a random command (the best example in this regard is the &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; command).</source>
          <target state="translated">Redis будет блокировать скрипт с ошибкой , если сценарий вызывает Redis команды может изменить набор данных , &lt;strong&gt;после&lt;/strong&gt; того, как в Redis &lt;em&gt;случайной&lt;/em&gt; команды как использование &lt;a href=&quot;randomkey&quot;&gt;случайного&lt;/a&gt; , &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt; , &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; . Это означает, что если сценарий доступен только для чтения и не изменяет набор данных, эти команды можно вызывать. Обратите внимание, что &lt;em&gt;случайная команда&lt;/em&gt; не обязательно означает команду, использующую случайные числа: любая недетерминированная команда считается случайной командой (лучшим примером в этом отношении является команда &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1d65bbb9c212a9d98ffb329def918b64ef3d8889" translate="yes" xml:space="preserve">
          <source>Refreshing expires</source>
          <target state="translated">Истечение срока освежения</target>
        </trans-unit>
        <trans-unit id="26ca731c99535195e55e64ad25c62f00fdbd2a4c" translate="yes" xml:space="preserve">
          <source>Reliable queues</source>
          <target state="translated">Надежные хвосты</target>
        </trans-unit>
        <trans-unit id="ea59d67e277c60b336a409408ff4d775b8225584" translate="yes" xml:space="preserve">
          <source>Remove a specific consumer from a consumer group.</source>
          <target state="translated">Удалить конкретного потребителя из группы потребителей.</target>
        </trans-unit>
        <trans-unit id="ce4d2a865a5a06124187f3a0d8a5354cd701d61f" translate="yes" xml:space="preserve">
          <source>Remove the existing timeout on &lt;code&gt;key&lt;/code&gt;, turning the key from &lt;em&gt;volatile&lt;/em&gt; (a key with an expire set) to &lt;em&gt;persistent&lt;/em&gt; (a key that will never expire as no timeout is associated).</source>
          <target state="translated">Удалите существующий тайм-аут &lt;code&gt;key&lt;/code&gt; , превратив ключ из &lt;em&gt;изменчивого&lt;/em&gt; (ключ с установленным сроком действия) в &lt;em&gt;постоянный&lt;/em&gt; (ключ, который никогда не истечет, поскольку тайм-аут не связан).</target>
        </trans-unit>
        <trans-unit id="c1d260f4e3da83fa28a692c23e66ed0cb15dd796" translate="yes" xml:space="preserve">
          <source>Remove the specified members from the set stored at &lt;code&gt;key&lt;/code&gt;. Specified members that are not a member of this set are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty set and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Удалите указанные элементы из набора, хранящегося в &lt;code&gt;key&lt;/code&gt; . Указанные элементы, не входящие в этот набор, игнорируются. Если &lt;code&gt;key&lt;/code&gt; не существует, он рассматривается как пустой набор, и эта команда возвращает &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de0b8cb5dfcd4da1251a55ebacec477902ab7fa1" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (inclusive).</source>
          <target state="translated">Удаляет все элементы в отсортированном наборе, хранящемся в &lt;code&gt;key&lt;/code&gt; с оценкой от &lt;code&gt;min&lt;/code&gt; до &lt;code&gt;max&lt;/code&gt; (включительно).</target>
        </trans-unit>
        <trans-unit id="cbb3fc019bde7aa5a4f4696386c7635ab2172c17" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with rank between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are &lt;code&gt;0&lt;/code&gt; -based indexes with &lt;code&gt;0&lt;/code&gt; being the element with the lowest score. These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score. For example: &lt;code&gt;-1&lt;/code&gt; is the element with the highest score, &lt;code&gt;-2&lt;/code&gt; the element with the second highest score and so forth.</source>
          <target state="translated">Удаляет все элементы в отсортированном наборе, хранящемся в &lt;code&gt;key&lt;/code&gt; с рангом от &lt;code&gt;start&lt;/code&gt; до &lt;code&gt;stop&lt;/code&gt; . И &lt;code&gt;start&lt;/code&gt; , и &lt;code&gt;stop&lt;/code&gt; - это индексы на основе &lt;code&gt;0&lt;/code&gt; , где &lt;code&gt;0&lt;/code&gt; - это элемент с наименьшей оценкой. Эти индексы могут быть отрицательными числами, где они указывают смещения, начиная с элемента с наивысшей оценкой. Например: &lt;code&gt;-1&lt;/code&gt; - элемент с наивысшим баллом, &lt;code&gt;-2&lt;/code&gt; - элемент со вторым наивысшим баллом и так далее.</target>
        </trans-unit>
        <trans-unit id="da37c36034834387a9dd7fbda191a975ebb105b0" translate="yes" xml:space="preserve">
          <source>Removes and returns one or more random elements from the set value store at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Удаляет и возвращает один или несколько случайных элементов из хранилища заданных значений по &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="870ac46dca2c1a6689064e1cced801af5e158f69" translate="yes" xml:space="preserve">
          <source>Removes and returns the first element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Удаляет и возвращает первый элемент списка, хранящегося в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec2ce52901cbc45793a1c6bb41b722b9057d2bc4" translate="yes" xml:space="preserve">
          <source>Removes and returns the last element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Удаляет и возвращает последний элемент списка, хранящегося в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52acb45013cdb2a41dc580913c01c50bd6ebca86" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the highest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Удаляет и возвращает до &lt;code&gt;count&lt;/code&gt; - членов с самыми высокими баллами в отсортированном наборе хранящегося на &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac48e8c652eae033a19d95a11cb8d9dbd5e35dab" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the lowest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Удаляет и возвращает элементы с наименьшими баллами в отсортированном наборе, хранящемся в &lt;code&gt;key&lt;/code&gt; для &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c6ffaff6ffe08c9f43baab9718f030d2162d111" translate="yes" xml:space="preserve">
          <source>Removes the first &lt;code&gt;count&lt;/code&gt; occurrences of elements equal to &lt;code&gt;value&lt;/code&gt; from the list stored at &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;count&lt;/code&gt; argument influences the operation in the following ways:</source>
          <target state="translated">Удаляет первое &lt;code&gt;count&lt;/code&gt; вхождений элементов, равных &lt;code&gt;value&lt;/code&gt; из списка, хранящегося в &lt;code&gt;key&lt;/code&gt; . &lt;code&gt;count&lt;/code&gt; аргументов влияет на работу следующими способами:</target>
        </trans-unit>
        <trans-unit id="494ca7e2faa6bd5b36a369eb7746bb78fb3e96bc" translate="yes" xml:space="preserve">
          <source>Removes the specified entries from a stream, and returns the number of entries deleted, that may be different from the number of IDs passed to the command in case certain IDs do not exist.</source>
          <target state="translated">Удаляет указанные записи из потока и возвращает количество удаленных записей,которое может отличаться от количества переданных в команду IDов в случае,если определенных IDов не существует.</target>
        </trans-unit>
        <trans-unit id="594397839f7156989bc1b259c19072c5484f7bdc" translate="yes" xml:space="preserve">
          <source>Removes the specified fields from the hash stored at &lt;code&gt;key&lt;/code&gt;. Specified fields that do not exist within this hash are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty hash and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Удаляет указанные поля из хэша, хранящегося в &lt;code&gt;key&lt;/code&gt; . Указанные поля, которых нет в этом хэше, игнорируются. Если &lt;code&gt;key&lt;/code&gt; не существует, он рассматривается как пустой хеш, и эта команда возвращает &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="322e3109be94b3ac9ea4c2a44f232f96c6cd905a" translate="yes" xml:space="preserve">
          <source>Removes the specified keys. A key is ignored if it does not exist.</source>
          <target state="translated">Удаляет указанные клавиши.Ключ игнорируется,если он не существует.</target>
        </trans-unit>
        <trans-unit id="933e4f3eff042f249c190608a122f8e43bd494af" translate="yes" xml:space="preserve">
          <source>Removes the specified members from the sorted set stored at &lt;code&gt;key&lt;/code&gt;. Non existing members are ignored.</source>
          <target state="translated">Удаляет указанные элементы из отсортированного набора, хранящегося в &lt;code&gt;key&lt;/code&gt; . Несуществующие члены игнорируются.</target>
        </trans-unit>
        <trans-unit id="17baa9fe7f8ed0143fa7df75975e104465db4e59" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt; if &lt;code&gt;newkey&lt;/code&gt; does not yet exist. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">Переименовывает &lt;code&gt;key&lt;/code&gt; в &lt;code&gt;newkey&lt;/code&gt; , если &lt;code&gt;newkey&lt;/code&gt; еще не существует. Если &lt;code&gt;key&lt;/code&gt; не существует, он возвращает ошибку .</target>
        </trans-unit>
        <trans-unit id="0155259665636f6ceaaa0a0ebda67bb195d98a6d" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt;. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist. If &lt;code&gt;newkey&lt;/code&gt; already exists it is overwritten, when this happens &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; executes an implicit &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation, so if the deleted key contains a very big value it may cause high latency even if &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; itself is usually a constant-time operation.</source>
          <target state="translated">Переименовывает &lt;code&gt;key&lt;/code&gt; в &lt;code&gt;newkey&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; не существует, он возвращает ошибку . Если &lt;code&gt;newkey&lt;/code&gt; уже существует, он перезаписывается, когда это происходит, &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; выполняет неявную операцию &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; , поэтому, если удаленный ключ содержит очень большое значение, это может вызвать большую задержку, даже если само &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; обычно является операцией с постоянным временем.</target>
        </trans-unit>
        <trans-unit id="351fb2e9d60cd91bf6510354de71fa6c06419ab4" translate="yes" xml:space="preserve">
          <source>Replicas broadcast their master's config epochs (in order to get an &lt;code&gt;UPDATE&lt;/code&gt; message if they are found to be stale), so the real config epoch of the replica (which is meaningless more or less, since they don't serve hash slots) can be only obtained checking the node flagged as &lt;code&gt;myself&lt;/code&gt;, which is the entry of the node we are asking to generate &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output. The other replicas epochs reflect what they publish in heartbeat packets, which is, the configuration epoch of the masters they are currently replicating.</source>
          <target state="translated">Реплики транслируют эпохи конфигурации своего хозяина (чтобы получить сообщение &lt;code&gt;UPDATE&lt;/code&gt; если обнаруживается, что они устарели), поэтому реальная эпоха конфигурации реплики (что более или менее бессмысленно, поскольку они не обслуживают хэш-слоты) может быть удалось получить только проверку узла, помеченного как &lt;code&gt;myself&lt;/code&gt; , который является записью узла, который мы запрашиваем для генерации вывода &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; . Другие эпохи реплик отражают то, что они публикуют в контрольных пакетах, то есть эпоху конфигурации мастеров, которые они в настоящее время реплицируют.</target>
        </trans-unit>
        <trans-unit id="57ee014fca43ed90896705e17d43f35b06757596" translate="yes" xml:space="preserve">
          <source>Replicating commands instead of scripts</source>
          <target state="translated">Тиражирование команд вместо сценариев</target>
        </trans-unit>
        <trans-unit id="054fb8240ac6c1ab20550a9e5b79d9d4cd6d1345" translate="yes" xml:space="preserve">
          <source>Request for authentication in a password-protected Redis server. Redis can be instructed to require a password before allowing clients to execute commands. This is done using the &lt;code&gt;requirepass&lt;/code&gt; directive in the configuration file.</source>
          <target state="translated">Запрос на аутентификацию на сервере Redis, защищенном паролем. Redis может быть проинструктирован запрашивать пароль перед тем, как позволить клиентам выполнять команды. Это делается с &lt;code&gt;requirepass&lt;/code&gt; директивы requirepass в файле конфигурации.</target>
        </trans-unit>
        <trans-unit id="da1bb4a2fc17746f7a5baea5144086fae0563a1a" translate="yes" xml:space="preserve">
          <source>Reset a Redis Cluster node, in a more or less drastic way depending on the reset type, that can be &lt;strong&gt;hard&lt;/strong&gt; or &lt;strong&gt;soft&lt;/strong&gt;. Note that this command &lt;strong&gt;does not work for masters if they hold one or more keys&lt;/strong&gt;, in that case to completely reset a master node keys must be removed first, e.g. by using &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; first, and then &lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt;.</source>
          <target state="translated">Сброс узла Redis Cluster более или менее радикальным способом в зависимости от типа сброса, который может быть &lt;strong&gt;жестким&lt;/strong&gt; или &lt;strong&gt;мягким&lt;/strong&gt; . Обратите внимание, что эта команда &lt;strong&gt;не работает для мастеров, если они удерживают один или несколько ключей.&lt;/strong&gt; В этом случае для полного сброса главного узла ключи должны быть сначала удалены, например, сначала с помощью &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; , а затем &lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b45f167ccc9268d6db2b2030f5f33cd642304b9" translate="yes" xml:space="preserve">
          <source>Resets the statistics reported by Redis using the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command.</source>
          <target state="translated">Сбрасывает статистику, сообщаемую Redis, с помощью команды &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b4926f937540a054f457674fa7da321fbd6a1f7" translate="yes" xml:space="preserve">
          <source>Resetting the slow log.</source>
          <target state="translated">Сброс медленного журнала.</target>
        </trans-unit>
        <trans-unit id="401feffc58d082a7dc99bf3cdbc90af756748e94" translate="yes" xml:space="preserve">
          <source>Reshard all the hash slots from D to nodes A, B, C.</source>
          <target state="translated">Перезагрузите все хэш-слоты от D до узлов A,B,C.</target>
        </trans-unit>
        <trans-unit id="d71f5749e9e28d5922b96f1c26e811052165fc71" translate="yes" xml:space="preserve">
          <source>Retrieving external keys</source>
          <target state="translated">Получение внешних ключей</target>
        </trans-unit>
        <trans-unit id="6fc93fde5d23bf392c79a9f984537ca96d065420" translate="yes" xml:space="preserve">
          <source>Return a random key from the currently selected database.</source>
          <target state="translated">Возврат случайного ключа из текущей выбранной базы данных.</target>
        </trans-unit>
        <trans-unit id="6fd47a35bf916d5d67439ea375fe4e2fb769d84c" translate="yes" xml:space="preserve">
          <source>Return the UNIX TIME of the last DB save executed with success. A client may check if a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command succeeded reading the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; value, then issuing a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command and checking at regular intervals every N seconds if &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; changed.</source>
          <target state="translated">Возвращает UNIX TIME последнего успешного сохранения БД. Клиент может проверить , если &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; команда успешно читает &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; значение, а затем выдачи &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; команды и проверки через регулярные промежутки времени каждые N секунд , если &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; изменилось.</target>
        </trans-unit>
        <trans-unit id="7298f92c54146228ead6d1a31b40025056a03b02" translate="yes" xml:space="preserve">
          <source>Return the distance between two members in the geospatial index represented by the sorted set.</source>
          <target state="translated">Возврат расстояния между двумя членами в геопространственном индексе,представленном отсортированным набором.</target>
        </trans-unit>
        <trans-unit id="1bb126873153beb4e986e8428f3f0a902f06d1bc" translate="yes" xml:space="preserve">
          <source>Return the members of a sorted set populated with geospatial information using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;, which are within the borders of the area specified with the center location and the maximum distance from the center (the radius).</source>
          <target state="translated">Возврат элементов отсортированного набора, заполненного геопространственной информацией с помощью &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; , которые находятся в границах области, указанной с центральным расположением и максимальным расстоянием от центра (радиусом).</target>
        </trans-unit>
        <trans-unit id="a7ff116fa994743f4fb0646cce53a6396e097c89" translate="yes" xml:space="preserve">
          <source>Return the number of keys in the currently-selected database.</source>
          <target state="translated">Вернуть количество ключей в текущей выбранной базе данных.</target>
        </trans-unit>
        <trans-unit id="06398ca22b9ef82a3c94cf8b1160f8f9c766b74a" translate="yes" xml:space="preserve">
          <source>Return the position of the first bit set to 1 or 0 in a string.</source>
          <target state="translated">Возвращает позицию первого бита,установленного в 1 или 0 в строке.</target>
        </trans-unit>
        <trans-unit id="1d1482b5db471b056549fa1a5580198ec9701587" translate="yes" xml:space="preserve">
          <source>Return the positions (longitude,latitude) of all the specified members of the geospatial index represented by the sorted set at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">Возвращает позиции (долготу, широту) всех указанных элементов геопространственного индекса, представленного отсортированным набором в &lt;em&gt;ключе&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0492bdeb7afe890056ed3d150bcd3cc644b0be83" translate="yes" xml:space="preserve">
          <source>Return valid &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; strings representing the position of one or more elements in a sorted set value representing a geospatial index (where elements were added using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;).</source>
          <target state="translated">Вернуть действительные строки &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash,&lt;/a&gt; представляющие положение одного или нескольких элементов в отсортированном значении набора, представляющем геопространственный индекс (где элементы были добавлены с помощью &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="232f3db04c4faa620bfbfc11fd3689a472ef9881" translate="yes" xml:space="preserve">
          <source>Return value</source>
          <target state="translated">Возвращаемая величина</target>
        </trans-unit>
        <trans-unit id="864674bcd0783b3457690f475310b938e42a7db7" translate="yes" xml:space="preserve">
          <source>Returning a maximum number of entries</source>
          <target state="translated">Возвращение максимального количества записей</target>
        </trans-unit>
        <trans-unit id="8f278b9f0e4f851622b8ed184503714c9eb2b40b" translate="yes" xml:space="preserve">
          <source>Returning items in a specific time range. This is possible because Stream IDs are &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;related to time&lt;/a&gt;.</source>
          <target state="translated">Возврат товаров за определенный период времени. Это возможно, потому что идентификаторы потоков &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;связаны со временем&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fecab38b77030a1f63f2810d6747aa68c069f23" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about all Redis commands.</source>
          <target state="translated">Возвращает &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;массив&lt;/a&gt; с подробностями обо всех командах Redis.</target>
        </trans-unit>
        <trans-unit id="fc344310aece8efa4afcb637dd3fdf8dc24fa45b" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about multiple Redis commands.</source>
          <target state="translated">Возвращает &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;ответ&lt;/a&gt; в виде массива с подробностями о нескольких командах Redis.</target>
        </trans-unit>
        <trans-unit id="4a134a2f3cf379373d004a605091cb6cf69dedcb" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of keys from a full Redis command.</source>
          <target state="translated">Возвращает &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;массив ответов&lt;/a&gt; ключей от полной команды Redis.</target>
        </trans-unit>
        <trans-unit id="bce4982fceed9f9a0c759decc9c92ecb37cc9be2" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt; of number of total commands in this Redis server.</source>
          <target state="translated">Возвращает &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;целочисленный ответ&lt;/a&gt; общего количества команд на этом сервере Redis.</target>
        </trans-unit>
        <trans-unit id="a915d042e7bc17cfcfeeccbd870dfc5af9c1ca16" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;PONG&lt;/code&gt; if no argument is provided, otherwise return a copy of the argument as a bulk. This command is often used to test if a connection is still alive, or to measure latency.</source>
          <target state="translated">Возвращает &lt;code&gt;PONG&lt;/code&gt; , если аргумент не указан, в противном случае возвращает копию аргумента как массив. Эта команда часто используется для проверки активности соединения или для измерения задержки.</target>
        </trans-unit>
        <trans-unit id="dd1b58db010b114867573670782f464e9b034412" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">Возвращает &lt;code&gt;message&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8491e8a1858fe4a13538635b038fd1bb846df79" translate="yes" xml:space="preserve">
          <source>Returns all field names in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает все имена полей в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="514836e0465ae87a7f738140eb4e2b3ae4475e1f" translate="yes" xml:space="preserve">
          <source>Returns all fields and values of the hash stored at &lt;code&gt;key&lt;/code&gt;. In the returned value, every field name is followed by its value, so the length of the reply is twice the size of the hash.</source>
          <target state="translated">Возвращает все поля и значения хэша, хранящегося в &lt;code&gt;key&lt;/code&gt; . В возвращаемом значении за каждым именем поля следует его значение, поэтому длина ответа в два раза превышает размер хэша.</target>
        </trans-unit>
        <trans-unit id="e9924b464875fe91e2b89cf6f97649ff9ec1b5ce" translate="yes" xml:space="preserve">
          <source>Returns all keys matching &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">Возвращает все ключи, соответствующие &lt;code&gt;pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ceba3296cc87483f6becfe1cdae897e811a1b1e" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; (including elements with score equal to &lt;code&gt;max&lt;/code&gt; or &lt;code&gt;min&lt;/code&gt;). In contrary to the default ordering of sorted sets, for this command the elements are considered to be ordered from high to low scores.</source>
          <target state="translated">Возвращает все элементы в отсортированном наборе с &lt;code&gt;key&lt;/code&gt; с оценкой от &lt;code&gt;max&lt;/code&gt; до &lt;code&gt;min&lt;/code&gt; (включая элементы с оценкой, равной &lt;code&gt;max&lt;/code&gt; или &lt;code&gt;min&lt;/code&gt; ). В отличие от упорядочения сортированных наборов по умолчанию, для этой команды элементы считаются упорядоченными от высоких до низких оценок.</target>
        </trans-unit>
        <trans-unit id="6def9bec387c3e744963c6ac4b0bf7f4010504e6" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (including elements with score equal to &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt;). The elements are considered to be ordered from low to high scores.</source>
          <target state="translated">Возвращает все элементы в отсортированном наборе с &lt;code&gt;key&lt;/code&gt; с оценкой от &lt;code&gt;min&lt;/code&gt; до &lt;code&gt;max&lt;/code&gt; (включая элементы с оценкой, равной &lt;code&gt;min&lt;/code&gt; или &lt;code&gt;max&lt;/code&gt; ). Элементы считаются отсортированными от низкого до высокого баллов.</target>
        </trans-unit>
        <trans-unit id="1925ffaf420a57d589c1888eb5b09007e4f1d203" translate="yes" xml:space="preserve">
          <source>Returns all the members of the set value stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает все элементы установленного значения, хранящегося в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c11f5fe0471c6d472d362d6dbbf041c048b49125" translate="yes" xml:space="preserve">
          <source>Returns all values in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает все значения в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4792ce321c7a364f3dc2071cf137fcc522daf25d" translate="yes" xml:space="preserve">
          <source>Returns an integer identifying the hash slot the specified key hashes to. This command is mainly useful for debugging and testing, since it exposes via an API the underlying Redis implementation of the hashing algorithm. Example use cases for this command:</source>
          <target state="translated">Возвращает целое число,идентифицирующее хэш-слот,к которому относятся указанные ключевые хэши.Эта команда в основном полезна для отладки и тестирования,так как раскрывает через API базовую реализацию алгоритма хэширования Redis.Примеры использования данной команды:</target>
        </trans-unit>
        <trans-unit id="899ca03feedce83f7aa728b87a784b60bd95adf0" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;field&lt;/code&gt; is an existing field in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает, если &lt;code&gt;field&lt;/code&gt; является существующим полем в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e13b7a867bbaf0e4121d5da403d54edbe4a8b1f" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;key&lt;/code&gt; exists.</source>
          <target state="translated">Возвращает, если &lt;code&gt;key&lt;/code&gt; существует.</target>
        </trans-unit>
        <trans-unit id="163373a24e8be296b7e7c88d0c4da2f59ceca677" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;member&lt;/code&gt; is a member of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает, если &lt;code&gt;member&lt;/code&gt; является членом набора, хранящегося в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abd92cbd9d7d0b6e4392a36873fd8c21767b398a" translate="yes" xml:space="preserve">
          <source>Returns information about the existence of the scripts in the script cache.</source>
          <target state="translated">Возвращает информацию о существовании скриптов в кэше скриптов.</target>
        </trans-unit>
        <trans-unit id="13855077d7cb93a1fce1c3432c59e7e463ea29a6" translate="yes" xml:space="preserve">
          <source>Returns or stores the elements contained in the &lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;list&lt;/a&gt;, &lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;set&lt;/a&gt; or &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted set&lt;/a&gt; at &lt;code&gt;key&lt;/code&gt;. By default, sorting is numeric and elements are compared by their value interpreted as double precision floating point number. This is &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; in its simplest form:</source>
          <target state="translated">Возвращает или сохраняет элементы, содержащиеся в &lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;списке&lt;/a&gt; , &lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;набор&lt;/a&gt; или &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;отсортированный набор&lt;/a&gt; по &lt;code&gt;key&lt;/code&gt; . По умолчанию сортировка является числовой, и элементы сравниваются по их значению, интерпретируемому как число двойной точности с плавающей запятой. Это &lt;a href=&quot;sort&quot;&gt;СОРТИРОВКА&lt;/a&gt; в простейшей форме:</target>
        </trans-unit>
        <trans-unit id="f68574957008d127438140f50ac56b278260cf09" translate="yes" xml:space="preserve">
          <source>Returns the bit value at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">Возвращает битовое значение по &lt;em&gt;смещению&lt;/em&gt; в строковом значении, хранящемся в &lt;em&gt;ключе&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e6d63c7c2388918da907438c78c891dff4a16999" translate="yes" xml:space="preserve">
          <source>Returns the element at index &lt;code&gt;index&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt;. The index is zero-based, so &lt;code&gt;0&lt;/code&gt; means the first element, &lt;code&gt;1&lt;/code&gt; the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, &lt;code&gt;-1&lt;/code&gt; means the last element, &lt;code&gt;-2&lt;/code&gt; means the penultimate and so forth.</source>
          <target state="translated">Возвращает элемент по индексу &lt;code&gt;index&lt;/code&gt; в списке, хранящемся в &lt;code&gt;key&lt;/code&gt; . Индекс отсчитывается от нуля, поэтому &lt;code&gt;0&lt;/code&gt; означает первый элемент, &lt;code&gt;1&lt;/code&gt; - второй элемент и так далее. Отрицательные индексы могут использоваться для обозначения элементов, начинающихся в конце списка. Здесь &lt;code&gt;-1&lt;/code&gt; означает последний элемент, &lt;code&gt;-2&lt;/code&gt; означает предпоследний и так далее.</target>
        </trans-unit>
        <trans-unit id="669652a24b746680e968eb8d19e304712aaafbef" translate="yes" xml:space="preserve">
          <source>Returns the length of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is interpreted as an empty list and &lt;code&gt;0&lt;/code&gt; is returned. An error is returned when the value stored at &lt;code&gt;key&lt;/code&gt; is not a list.</source>
          <target state="translated">Возвращает длину списка, хранящегося в &lt;code&gt;key&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; не существует, он интерпретируется как пустой список и возвращается &lt;code&gt;0&lt;/code&gt; . Ошибка возвращается, если значение, хранящееся в &lt;code&gt;key&lt;/code&gt; , не является списком.</target>
        </trans-unit>
        <trans-unit id="b1b9de7b079dd5e1ad7bef3504c123ad01db9ecc" translate="yes" xml:space="preserve">
          <source>Returns the length of the string value stored at &lt;code&gt;key&lt;/code&gt;. An error is returned when &lt;code&gt;key&lt;/code&gt; holds a non-string value.</source>
          <target state="translated">Возвращает длину строкового значения, хранящегося в &lt;code&gt;key&lt;/code&gt; . Ошибка возвращается, если &lt;code&gt;key&lt;/code&gt; содержит нестроковое значение.</target>
        </trans-unit>
        <trans-unit id="5ca8167d0a845062b5e1c8307dc022d4e1bbe99c" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the difference between the first set and all the successive sets.</source>
          <target state="translated">Возвращает членов множества,образовавшегося в результате разницы между первым множеством и всеми последующими множествами.</target>
        </trans-unit>
        <trans-unit id="65286cf35136f5258861b04a7983164ea5b463a3" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the intersection of all the given sets.</source>
          <target state="translated">Возвращает членов множества,полученных в результате пересечения всех заданных множеств.</target>
        </trans-unit>
        <trans-unit id="473b41ab8be68badcb9ee743f59ebda61ccb6efd" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the union of all the given sets.</source>
          <target state="translated">Возвращает членов набора,образовавшегося в результате объединения всех данных наборов.</target>
        </trans-unit>
        <trans-unit id="ae58574da7b69acb45d5608e905fbe416f5828a3" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">Возвращает количество элементов в отсортированном наборе с &lt;code&gt;key&lt;/code&gt; с оценкой от &lt;code&gt;min&lt;/code&gt; до &lt;code&gt;max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ba5a6e2cdf681a72b81189fc73dab62a38a2630" translate="yes" xml:space="preserve">
          <source>Returns the number of entries inside a stream. If the specified key does not exist the command returns zero, as if the stream was empty. However note that unlike other Redis types, zero-length streams are possible, so you should call &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; or &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; in order to check if a key exists or not.</source>
          <target state="translated">Возвращает количество записей внутри потока. Если указанный ключ не существует, команда возвращает ноль, как если бы поток был пуст. Однако обратите внимание, что в отличие от других типов Redis, потоки нулевой длины возможны, поэтому вам следует вызвать &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; или &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; , чтобы проверить, существует ли ключ или нет.</target>
        </trans-unit>
        <trans-unit id="05ec2c01f1e7966c86d566259fe9827a1ce5788e" translate="yes" xml:space="preserve">
          <source>Returns the number of fields contained in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает количество полей, содержащихся в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cba9b6e741951a2ea3575443214cf403c194bc0f" translate="yes" xml:space="preserve">
          <source>Returns the number of keys in the specified Redis Cluster hash slot. The command only queries the local data set, so contacting a node that is not serving the specified hash slot will always result in a count of zero being returned.</source>
          <target state="translated">Возвращает количество ключей в указанном слоте хэша кластера Redis.Команда запрашивает только локальный набор данных,поэтому при обращении к узлу,который не обслуживает указанный хеш-слот,всегда возвращается счетчик нуля.</target>
        </trans-unit>
        <trans-unit id="567352a29cfaef33a8cd3fcbcac829c78575fb62" translate="yes" xml:space="preserve">
          <source>Returns the number of subscribers (not counting clients subscribed to patterns) for the specified channels.</source>
          <target state="translated">Возвращает количество подписчиков (не считая клиентов,подписавшихся на шаблоны)для указанных каналов.</target>
        </trans-unit>
        <trans-unit id="56eb7af42eb7b4bb5b7efb363837228225fedb8e" translate="yes" xml:space="preserve">
          <source>Returns the number of subscriptions to patterns (that are performed using the &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; command). Note that this is not just the count of clients subscribed to patterns but the total number of patterns all the clients are subscribed to.</source>
          <target state="translated">Возвращает количество подписок на шаблоны (которые выполняются с помощью команды &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; ). Обратите внимание, что это не только количество клиентов, подписанных на шаблоны, но и общее количество шаблонов, на которые подписаны все клиенты.</target>
        </trans-unit>
        <trans-unit id="029e626a83e98d1ddd2b45f2a08391faf674382c" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from high to low. The rank (or index) is 0-based, which means that the member with the highest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Возвращает ранг &lt;code&gt;member&lt;/code&gt; в отсортированном наборе, хранящемся в &lt;code&gt;key&lt;/code&gt; , с оценками, упорядоченными от большего к меньшему. Ранг (или индекс) отсчитывается от 0, что означает, что член с наивысшим баллом имеет ранг &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04ac6b8e04ac2d5fa91a42abbe270ab24969dcf8" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from low to high. The rank (or index) is 0-based, which means that the member with the lowest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Возвращает ранг &lt;code&gt;member&lt;/code&gt; в отсортированном наборе, хранящемся в &lt;code&gt;key&lt;/code&gt; , с оценками, упорядоченными от меньшего к большему. Ранг (или индекс) отсчитывается от 0, что означает, что член с наименьшей оценкой имеет ранг &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dac65708cc841972517b49f4a323aba557dd7743" translate="yes" xml:space="preserve">
          <source>Returns the remaining time to live of a key that has a timeout. This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.</source>
          <target state="translated">Возвращает оставшееся время жизни ключа с тайм-аутом.Эта функция самопроверки позволяет клиенту Redis проверять,сколько секунд данный ключ будет продолжать оставаться частью набора данных.</target>
        </trans-unit>
        <trans-unit id="bdaf416765952fb3c543f080075ad7115471f130" translate="yes" xml:space="preserve">
          <source>Returns the score of &lt;code&gt;member&lt;/code&gt; in the sorted set at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает оценку &lt;code&gt;member&lt;/code&gt; в отсортированном наборе по &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0525192497ba351f01f7c69505a721186043f122" translate="yes" xml:space="preserve">
          <source>Returns the set cardinality (number of elements) of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает установленную мощность (количество элементов) набора, хранящегося в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="538e8ccb043255bf1866a8c948a35b08642708eb" translate="yes" xml:space="preserve">
          <source>Returns the sorted set cardinality (number of elements) of the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает количество элементов отсортированного набора (количество элементов) отсортированного набора, хранящегося в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aed5ad61cf2dae51ecb526ffeb96e8ae6f66dd61" translate="yes" xml:space="preserve">
          <source>Returns the specified elements of the list stored at &lt;code&gt;key&lt;/code&gt;. The offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, with &lt;code&gt;0&lt;/code&gt; being the first element of the list (the head of the list), &lt;code&gt;1&lt;/code&gt; being the next element and so on.</source>
          <target state="translated">Возвращает указанные элементы списка, хранящегося в &lt;code&gt;key&lt;/code&gt; . Смещения &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;stop&lt;/code&gt; - это индексы, отсчитываемые от нуля, где &lt;code&gt;0&lt;/code&gt; - это первый элемент списка (заголовок списка), &lt;code&gt;1&lt;/code&gt; - следующий элемент и так далее.</target>
        </trans-unit>
        <trans-unit id="165e254b16f95c82b554bb625de96b2c2d45635e" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the highest to the lowest score. Descending lexicographical order is used for elements with equal score.</source>
          <target state="translated">Возвращает указанный диапазон элементов в отсортированном наборе, хранящемся в &lt;code&gt;key&lt;/code&gt; . Элементы считаются упорядоченными от самого высокого до самого низкого балла. Лексикографический порядок по убыванию используется для элементов с равным количеством баллов.</target>
        </trans-unit>
        <trans-unit id="c5f3848ec567b8c9da3f19a86ff736fd69145ae8" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the lowest to the highest score. Lexicographical order is used for elements with equal score.</source>
          <target state="translated">Возвращает указанный диапазон элементов в отсортированном наборе, хранящемся в &lt;code&gt;key&lt;/code&gt; . Элементы считаются упорядоченными от наименьшего к наибольшему количеству баллов. Лексикографический порядок используется для элементов с равным количеством баллов.</target>
        </trans-unit>
        <trans-unit id="d28b315a7a61b9bf04b21fccdd6ae5bd4f8eb130" translate="yes" xml:space="preserve">
          <source>Returns the string length of the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;. If the &lt;code&gt;key&lt;/code&gt; or the &lt;code&gt;field&lt;/code&gt; do not exist, 0 is returned.</source>
          <target state="translated">Возвращает длину строки значения, связанного с &lt;code&gt;field&lt;/code&gt; в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; или &lt;code&gt;field&lt;/code&gt; не существуют, возвращается 0.</target>
        </trans-unit>
        <trans-unit id="ffb4e3b3a6a5708cfdef83bd04363741160ed0a4" translate="yes" xml:space="preserve">
          <source>Returns the string representation of the type of the value stored at &lt;code&gt;key&lt;/code&gt;. The different types that can be returned are: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;zset&lt;/code&gt; and &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">Возвращает строковое представление типа значения, хранящегося в &lt;code&gt;key&lt;/code&gt; . Могут быть возвращены различные типы: &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;zset&lt;/code&gt; и &lt;code&gt;hash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a246620818088ec9a16f70b9fb4ae809aad9ad2" translate="yes" xml:space="preserve">
          <source>Returns the substring of the string value stored at &lt;code&gt;key&lt;/code&gt;, determined by the offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; (both are inclusive). Negative offsets can be used in order to provide an offset starting from the end of the string. So -1 means the last character, -2 the penultimate and so forth.</source>
          <target state="translated">Возвращает подстроку строкового значения, хранящегося в &lt;code&gt;key&lt;/code&gt; , определяемого смещениями &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;end&lt;/code&gt; (оба включены). Отрицательные смещения могут использоваться для обеспечения смещения, начиная с конца строки. Итак, -1 означает последний символ, -2 - предпоследний и так далее.</target>
        </trans-unit>
        <trans-unit id="ff8cb8f9712a465de8610b460278556869c01387" translate="yes" xml:space="preserve">
          <source>Returns the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает значение, связанное с &lt;code&gt;field&lt;/code&gt; в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e8fea73a6efe9b1e714890adedb119e477e5b94" translate="yes" xml:space="preserve">
          <source>Returns the values associated with the specified &lt;code&gt;fields&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращает значения, связанные с указанными &lt;code&gt;fields&lt;/code&gt; в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a3f6c24ab0b5bf50119e41442adccdd069520b2" translate="yes" xml:space="preserve">
          <source>Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value &lt;code&gt;nil&lt;/code&gt; is returned. Because of this, the operation never fails.</source>
          <target state="translated">Возвращает значения всех указанных ключей. Для каждого ключа, который не содержит строковое значение или не существует, возвращается специальное значение &lt;code&gt;nil&lt;/code&gt; . Благодаря этому операция никогда не заканчивается неудачей.</target>
        </trans-unit>
        <trans-unit id="33fe03995fd835515d8b0c378391e0d80d6d96a2" translate="yes" xml:space="preserve">
          <source>Running the bitmap incrementally using the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;&lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; optional parameters, accumulating the results client-side, and optionally caching the result into a key.</source>
          <target state="translated">&lt;a href=&quot;bitcount&quot;&gt;Постепенный &lt;/a&gt;&lt;em&gt;запуск&lt;/em&gt; растрового изображения с использованием необязательных параметров BITCOUNT &lt;em&gt;start&lt;/em&gt; и &lt;em&gt;end&lt;/em&gt; , накопление результатов на стороне клиента и необязательное кэширование результата в ключ.</target>
        </trans-unit>
        <trans-unit id="afc896d0c818d9d81d1502addeeed94d978515cb" translate="yes" xml:space="preserve">
          <source>SADD</source>
          <target state="translated">SADD</target>
        </trans-unit>
        <trans-unit id="afe4d83e232611365cc3a02706eeee448267b671" translate="yes" xml:space="preserve">
          <source>SADD  key member [member ...]   Add one or more members to a set</source>
          <target state="translated">Член ключа SADD [член ...]Добавить одного или нескольких членов в набор.</target>
        </trans-unit>
        <trans-unit id="508156a39b09ccfe61cc81d984e9317e5e0d8eec" translate="yes" xml:space="preserve">
          <source>SAVE</source>
          <target state="translated">SAVE</target>
        </trans-unit>
        <trans-unit id="a806788f2be230df4e533ace9d23ff41f5ebd919" translate="yes" xml:space="preserve">
          <source>SAVE   Synchronously save the dataset to disk</source>
          <target state="translated">SAVE Синхронно сохранять набор данных на диск</target>
        </trans-unit>
        <trans-unit id="65b4fd3a026ef6fa00d5747035f289ef54695f24" translate="yes" xml:space="preserve">
          <source>SAVE and NOSAVE modifiers</source>
          <target state="translated">модификаторы SAVE и NOSAVE</target>
        </trans-unit>
        <trans-unit id="c5a19955ea5dab3fd18ab68f367f98693df1b60b" translate="yes" xml:space="preserve">
          <source>SCAN</source>
          <target state="translated">SCAN</target>
        </trans-unit>
        <trans-unit id="f6a353aff0f0da25a0e7f7c1d96621ee0a75fe99" translate="yes" xml:space="preserve">
          <source>SCAN  cursor [MATCH pattern] [COUNT count]   Incrementally iterate the keys space</source>
          <target state="translated">Курсор SCAN [Шаблон сравнения][Количество СОЕДИНЕНИЙ]Интенсивно перемещайте пробелы клавиш.</target>
        </trans-unit>
        <trans-unit id="f904e681db7d6de1d40ec70145524cd0367d1bf0" translate="yes" xml:space="preserve">
          <source>SCAN basic usage</source>
          <target state="translated">базовое использование SCAN</target>
        </trans-unit>
        <trans-unit id="aa3b23325236e95772d7cd2d8a5db2f2530e669f" translate="yes" xml:space="preserve">
          <source>SCAN is a cursor based iterator. This means that at every call of the command, the server returns an updated cursor that the user needs to use as the cursor argument in the next call.</source>
          <target state="translated">SCAN-это итератор на основе курсора.Это означает,что при каждом вызове команды сервер возвращает обновленный курсор,который пользователь должен использовать в качестве аргумента курсора при следующем вызове.</target>
        </trans-unit>
        <trans-unit id="0431790b7b638b530f089a6638b4b046bf245d05" translate="yes" xml:space="preserve">
          <source>SCARD</source>
          <target state="translated">SCARD</target>
        </trans-unit>
        <trans-unit id="45b0af77625a8e40fbd9c79a72bf85a01a682a2e" translate="yes" xml:space="preserve">
          <source>SCARD  key   Get the number of members in a set</source>
          <target state="translated">Ключ SCARD Получить количество членов в наборе.</target>
        </trans-unit>
        <trans-unit id="46ab5a918078b88865c34d46d45763f78a5cc2a8" translate="yes" xml:space="preserve">
          <source>SCRIPT</source>
          <target state="translated">SCRIPT</target>
        </trans-unit>
        <trans-unit id="942ec0d4567f537a05d81b40e79ed670c8098df1" translate="yes" xml:space="preserve">
          <source>SCRIPT DEBUG  YES|SYNC|NO   Set the debug mode for executed scripts.</source>
          <target state="translated">SCRIPT DEBUG YES|SYNC|NO Установите отладочный режим для выполняемых скриптов.</target>
        </trans-unit>
        <trans-unit id="d4f0300810cbd56a02078e94b26444e04a369df1" translate="yes" xml:space="preserve">
          <source>SCRIPT EXISTS  sha1 [sha1 ...]   Check existence of scripts in the script cache.</source>
          <target state="translated">SCRIPT EXISTS sha1 [sha1 ...]Проверка существования скриптов в кэше скриптов.</target>
        </trans-unit>
        <trans-unit id="155351693709972a944322985f623357a60203d8" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH</source>
          <target state="translated">КРИПТОВЫЙ ФЛУШ</target>
        </trans-unit>
        <trans-unit id="ff5ac14542c8a5c4ff717c937c92483157332c48" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH   Remove all the scripts from the script cache.</source>
          <target state="translated">SCRIPT FLUSH Удалить все сценарии из кэша сценариев.</target>
        </trans-unit>
        <trans-unit id="5e2a68acdd358effce354e479fe828441291386c" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL</source>
          <target state="translated">СКРИПТ-КИЛЛ</target>
        </trans-unit>
        <trans-unit id="898216faf82d0e8094a40fff1a1d11316572b3a1" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL   Kill the script currently in execution.</source>
          <target state="translated">SCRIPT KILL Убейте выполняемый в данный момент скрипт.</target>
        </trans-unit>
        <trans-unit id="bf00a0ed4afe21cec9ac5006aa471a2c75ce80dd" translate="yes" xml:space="preserve">
          <source>SCRIPT LOAD  script   Load the specified Lua script into the script cache.</source>
          <target state="translated">Сценарий SCRIPT LOAD Загрузите указанный скрипт Lua в кэш скриптов.</target>
        </trans-unit>
        <trans-unit id="605e7c9dd422426230eae60c02acc7d7a5705884" translate="yes" xml:space="preserve">
          <source>SDIFF</source>
          <target state="translated">SDIFF</target>
        </trans-unit>
        <trans-unit id="18d8e0e316b86cf9a259f83877f9d4536e919048" translate="yes" xml:space="preserve">
          <source>SDIFF  key [key ...]   Subtract multiple sets</source>
          <target state="translated">SDIFF клавиша [клавиша ...]Вычитание нескольких наборов</target>
        </trans-unit>
        <trans-unit id="144b2bd3509fd63bb1b369b8c7665713eb587bd9" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE</source>
          <target state="translated">SDIFFSTORE</target>
        </trans-unit>
        <trans-unit id="de1820fefd3db78a9062bc31ca0bace599879b7b" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE  destination key [key ...]   Subtract multiple sets and store the resulting set in a key</source>
          <target state="translated">SDIFFSTORE целевая клавиша [клавиша ...]Вычитание нескольких наборов и сохранение полученного набора в клавише</target>
        </trans-unit>
        <trans-unit id="a4942c26d0735947d8a22a2fbe2735a12e381808" translate="yes" xml:space="preserve">
          <source>SELECT</source>
          <target state="translated">SELECT</target>
        </trans-unit>
        <trans-unit id="f439068c5eb4482362ce42c7382665b32a13512a" translate="yes" xml:space="preserve">
          <source>SELECT  index   Change the selected database for the current connection</source>
          <target state="translated">SELECT-индекс Изменение выбранной базы данных для текущего соединения</target>
        </trans-unit>
        <trans-unit id="55c5d81017a30edf1e47ba1b78c377a5e5ebfd50" translate="yes" xml:space="preserve">
          <source>SET</source>
          <target state="translated">SET</target>
        </trans-unit>
        <trans-unit id="91a720b839d692fc7a7e17565ac1e4963650fe98" translate="yes" xml:space="preserve">
          <source>SET  key value [expiration EX seconds|PX milliseconds] [NX|XX]   Set the string value of a key</source>
          <target state="translated">SET ключевое значение [истечение EX seconds|PX миллисекунд][NX|XX]Установите значение строки ключа.</target>
        </trans-unit>
        <trans-unit id="7df70cb863a3d3a5e4a199b5d8ef3c9851ce87bf" translate="yes" xml:space="preserve">
          <source>SETBIT</source>
          <target state="translated">SETBIT</target>
        </trans-unit>
        <trans-unit id="b66f69a03f672489d4ae1d69a757435c5b63bd51" translate="yes" xml:space="preserve">
          <source>SETBIT  key offset value   Sets or clears the bit at offset in the string value stored at key</source>
          <target state="translated">SETBIT-значение смещения ключа Устанавливает или очищает бит при смещении в строке значение,сохраненное в ключе</target>
        </trans-unit>
        <trans-unit id="c92872db8021ac60dd456ca7447fb52919f32143" translate="yes" xml:space="preserve">
          <source>SETEX</source>
          <target state="translated">SETEX</target>
        </trans-unit>
        <trans-unit id="0b5df1d3ddffe0fdbb568accc5d3c3dac5121afc" translate="yes" xml:space="preserve">
          <source>SETEX  key seconds value   Set the value and expiration of a key</source>
          <target state="translated">Значение параметра SETEX key seconds Установите значение и срок годности ключа.</target>
        </trans-unit>
        <trans-unit id="1ace6531f1c27b916c1368f17e1a7ae87aa79f97" translate="yes" xml:space="preserve">
          <source>SETNX</source>
          <target state="translated">SETNX</target>
        </trans-unit>
        <trans-unit id="a50f293fa49f962b5d82c0bb86c82df413a498b7" translate="yes" xml:space="preserve">
          <source>SETNX  key value   Set the value of a key, only if the key does not exist</source>
          <target state="translated">Значение клавиши SETNX Установите значение клавиши,только если клавиша не существует.</target>
        </trans-unit>
        <trans-unit id="c1d82383232438676e2182b69bf2797640b1fcd2" translate="yes" xml:space="preserve">
          <source>SETRANGE</source>
          <target state="translated">SETRANGE</target>
        </trans-unit>
        <trans-unit id="a2132f99e69e7919051651c2b4fc7de24734eba2" translate="yes" xml:space="preserve">
          <source>SETRANGE  key offset value   Overwrite part of a string at key starting at the specified offset</source>
          <target state="translated">SETRANGE значение смещения ключа Перезапись части строки при ключе,начинающемся с заданного смещения</target>
        </trans-unit>
        <trans-unit id="ec493147ec1b78adab002626ee80cc23772aded8" translate="yes" xml:space="preserve">
          <source>SHUTDOWN</source>
          <target state="translated">SHUTDOWN</target>
        </trans-unit>
        <trans-unit id="606e1ec5d1ea13b283de4e59cd16289518254c6c" translate="yes" xml:space="preserve">
          <source>SHUTDOWN  [NOSAVE|SAVE]   Synchronously save the dataset to disk and then shut down the server</source>
          <target state="translated">SHUTDOWN [NOSAVE|SAVE]Синхронно сохраните набор данных на диск,а затем выключите сервер.</target>
        </trans-unit>
        <trans-unit id="c340be94a16bd060ccd24ece053ed10ff4cfb1a2" translate="yes" xml:space="preserve">
          <source>SINTER</source>
          <target state="translated">SINTER</target>
        </trans-unit>
        <trans-unit id="acc6f9a5a6867145ccd5835b170277c3127f8f60" translate="yes" xml:space="preserve">
          <source>SINTER  key [key ...]   Intersect multiple sets</source>
          <target state="translated">Клавиша SINTER [клавиша ...]Пересекает несколько наборов.</target>
        </trans-unit>
        <trans-unit id="ae286ac2efddc7ffc6de81fb4eef82083c5d0d0a" translate="yes" xml:space="preserve">
          <source>SINTERSTORE</source>
          <target state="translated">SINTERSTORE</target>
        </trans-unit>
        <trans-unit id="3cc889bdb24445318099b6bfa98a849204bc5321" translate="yes" xml:space="preserve">
          <source>SINTERSTORE  destination key [key ...]   Intersect multiple sets and store the resulting set in a key</source>
          <target state="translated">SINTERSTORE целевая клавиша [клавиша ...]Пересечение нескольких наборов и сохранение результирующего набора в клавишу</target>
        </trans-unit>
        <trans-unit id="8074903f43c428dec41033b139437bb9d7e46e61" translate="yes" xml:space="preserve">
          <source>SISMEMBER</source>
          <target state="translated">SISMEMBER</target>
        </trans-unit>
        <trans-unit id="2613d73d648b1f6845f55faac8664acb5e2e9af6" translate="yes" xml:space="preserve">
          <source>SISMEMBER  key member   Determine if a given value is a member of a set</source>
          <target state="translated">Ключевой член СИСМЕМБЕР Определить,является ли заданное значение членом набора</target>
        </trans-unit>
        <trans-unit id="bb3731aa645af4f77072e934700ff033a81e173b" translate="yes" xml:space="preserve">
          <source>SLAVEOF</source>
          <target state="translated">SLAVEOF</target>
        </trans-unit>
        <trans-unit id="9bb4401fd3b09a14ad63da1fc4e0ebcc9c0ee189" translate="yes" xml:space="preserve">
          <source>SLAVEOF  host port   Make the server a replica of another instance, or promote it as master. Deprecated starting with Redis 5. Use REPLICAOF instead.</source>
          <target state="translated">SLAVEOF порт хоста Сделать сервер копией другого экземпляра,или продвинуть его в качестве мастера.Исключено,начиная с Redis 5.Вместо этого используйте REPLICAOF.</target>
        </trans-unit>
        <trans-unit id="4078b703021998b0c963d9636d85d96b1ddfa618" translate="yes" xml:space="preserve">
          <source>SLOWLOG</source>
          <target state="translated">SLOWLOG</target>
        </trans-unit>
        <trans-unit id="acfcd934ccfd2203f5ccc3e824371c24109642b8" translate="yes" xml:space="preserve">
          <source>SLOWLOG  subcommand [argument]   Manages the Redis slow queries log</source>
          <target state="translated">Подкоманда SLOWLOG [аргумент]Управляет журналом медленных запросов Redis.</target>
        </trans-unit>
        <trans-unit id="e6687e28d8b75312f0ea51bc9520b394ec2a7a63" translate="yes" xml:space="preserve">
          <source>SMEMBERS</source>
          <target state="translated">SMEMBERS</target>
        </trans-unit>
        <trans-unit id="fe66421f332187f83010e275c4b51042858f5234" translate="yes" xml:space="preserve">
          <source>SMEMBERS  key   Get all the members in a set</source>
          <target state="translated">Клавиша SMEMBERS Получить все члены в набор</target>
        </trans-unit>
        <trans-unit id="20f84dbd21a3d84899dade0a24ef5c6978f0403e" translate="yes" xml:space="preserve">
          <source>SMOVE</source>
          <target state="translated">SMOVE</target>
        </trans-unit>
        <trans-unit id="1f7888e464279456fc99ea1259b436e9ad0d4f64" translate="yes" xml:space="preserve">
          <source>SMOVE  source destination member   Move a member from one set to another</source>
          <target state="translated">SMOVE член-получатель источника Перемещение члена из одного набора в другой</target>
        </trans-unit>
        <trans-unit id="2434fe1de87e4949f51786cc87dd6a83c095a422" translate="yes" xml:space="preserve">
          <source>SORT</source>
          <target state="translated">SORT</target>
        </trans-unit>
        <trans-unit id="8e248ec645f54a08b3eb01462adb200f94f15d79" translate="yes" xml:space="preserve">
          <source>SORT  key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]   Sort the elements in a list, set or sorted set</source>
          <target state="translated">Клавиша SORT [BY pattern][LIMIT offset count][GET pattern [GET pattern ...]].[ASC|DESC][ALPHA][STORE destination]Сортировка элементов в списке,установка или сортировка множества.</target>
        </trans-unit>
        <trans-unit id="757f5e1ed1192585c3e7deb4986d7e204a0c8613" translate="yes" xml:space="preserve">
          <source>SPOP</source>
          <target state="translated">SPOP</target>
        </trans-unit>
        <trans-unit id="a1bcd919a884989656266471e065ce0ed9f3b014" translate="yes" xml:space="preserve">
          <source>SPOP  key [count]   Remove and return one or multiple random members from a set</source>
          <target state="translated">Клавиша SPOP [считать]Удаление и возврат одного или нескольких случайных членов из набора</target>
        </trans-unit>
        <trans-unit id="fa889adf02f632d165c3f2d12d9b5ec8d781cbb2" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER</source>
          <target state="translated">SRANDMEMBER</target>
        </trans-unit>
        <trans-unit id="a3aa05de6787d8cb6b5fb2eeb41ce24756a254c7" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER  key [count]   Get one or multiple random members from a set</source>
          <target state="translated">Клавиша SRANDMEMBER [считать]Получить один или несколько случайных членов из набора</target>
        </trans-unit>
        <trans-unit id="a25d27e5f9def5c1d9e1a790c413156760a00937" translate="yes" xml:space="preserve">
          <source>SREM</source>
          <target state="translated">SREM</target>
        </trans-unit>
        <trans-unit id="68363946a4081440ca501f29c43f5fbe4f7eefc4" translate="yes" xml:space="preserve">
          <source>SREM  key member [member ...]   Remove one or more members from a set</source>
          <target state="translated">Ключевой член ППСР [член ...]Исключить одного или нескольких членов из набора.</target>
        </trans-unit>
        <trans-unit id="39f084973b61a7bea28e4e94336a3c5a0bf9fee7" translate="yes" xml:space="preserve">
          <source>SSCAN</source>
          <target state="translated">SSCAN</target>
        </trans-unit>
        <trans-unit id="9c2bba696b7b86cd88c82a287899370d9f0e3bb5" translate="yes" xml:space="preserve">
          <source>SSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate Set elements</source>
          <target state="translated">Курсор клавиши SSCAN [Шаблон сравнения][Количество СОЕДИНЕНИЙ]Интенсивная итерация Элементы набора</target>
        </trans-unit>
        <trans-unit id="c89c4cb21a1d403bb307b502f69a87f9e3b3a8ab" translate="yes" xml:space="preserve">
          <source>STRLEN</source>
          <target state="translated">STRLEN</target>
        </trans-unit>
        <trans-unit id="ba1403b52701f08d29eb084587b5d84ec8dde893" translate="yes" xml:space="preserve">
          <source>STRLEN  key   Get the length of the value stored in a key</source>
          <target state="translated">Клавиша STRLEN Получить длину значения,сохраненного в клавише.</target>
        </trans-unit>
        <trans-unit id="43a6e12318adbbee03f06872c109322b0f558e29" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE</source>
          <target state="translated">SUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="47236795c3b9acd1da0f66ecb88ffdd913189ac5" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE  channel [channel ...]   Listen for messages published to the given channels</source>
          <target state="translated">SUBSCRIBE-канал [канал ...]Прослушивание сообщений,опубликованных по данным каналам.</target>
        </trans-unit>
        <trans-unit id="a9a4bd3707fb7f204fddf46673a38114093dbb82" translate="yes" xml:space="preserve">
          <source>SUNION</source>
          <target state="translated">SUNION</target>
        </trans-unit>
        <trans-unit id="5b757c33f2f9e74b674645b6ccda3d80138ff877" translate="yes" xml:space="preserve">
          <source>SUNION  key [key ...]   Add multiple sets</source>
          <target state="translated">Клавиша SUNION [клавиша ...]Добавить несколько наборов</target>
        </trans-unit>
        <trans-unit id="48b1035f133322c326cae720a6ee6ad1108226dc" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE</source>
          <target state="translated">SUNIONSTORE</target>
        </trans-unit>
        <trans-unit id="be4a84a92460ba7a99f970a1bd856700c5285869" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE  destination key [key ...]   Add multiple sets and store the resulting set in a key</source>
          <target state="translated">SUNIONSTORE целевая клавиша [клавиша ...]Добавьте несколько наборов и сохраните полученный набор в виде клавиши.</target>
        </trans-unit>
        <trans-unit id="52e8b5aa51a1b6c9b46c6f4abe8b613e777665e4" translate="yes" xml:space="preserve">
          <source>SWAPDB</source>
          <target state="translated">SWAPDB</target>
        </trans-unit>
        <trans-unit id="b86537c7b961d4302819caedcc63376c729b2e03" translate="yes" xml:space="preserve">
          <source>SWAPDB  index index   Swaps two Redis databases</source>
          <target state="translated">SWAPDB индексный индекс свопы две базы данных Redis</target>
        </trans-unit>
        <trans-unit id="2f8d236566d2393cd3a112e7190d8837c8004cc2" translate="yes" xml:space="preserve">
          <source>SYNC</source>
          <target state="translated">SYNC</target>
        </trans-unit>
        <trans-unit id="7dade54cfe46a1450fe32e252c2fe2557e402641" translate="yes" xml:space="preserve">
          <source>SYNC   Internal command used for replication</source>
          <target state="translated">SYNC Внутренняя команда,используемая для репликации</target>
        </trans-unit>
        <trans-unit id="b54491fb2810da81b1ac818eeb380198be74decd" translate="yes" xml:space="preserve">
          <source>Same result format as &lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt; except you can specify which commands get returned.</source>
          <target state="translated">Тот же формат результата, что и &lt;a href=&quot;command&quot;&gt;COMMAND,&lt;/a&gt; за исключением того, что вы можете указать, какие команды будут возвращены.</target>
        </trans-unit>
        <trans-unit id="1cc201c6f067fb6b6182b441f2b6dc0f4b71649b" translate="yes" xml:space="preserve">
          <source>Sample Output (new version, includes IDs)</source>
          <target state="translated">Вывод образца (новая версия,включает в себя идентификаторы)</target>
        </trans-unit>
        <trans-unit id="fb0cb1b1aa0fcb98cea480e75b0d7dffc839cef1" translate="yes" xml:space="preserve">
          <source>Sample Output (old version)</source>
          <target state="translated">Вывод образца (старая версия)</target>
        </trans-unit>
        <trans-unit id="7a614be0679e1660abb7ab566a46118d4e5207f9" translate="yes" xml:space="preserve">
          <source>Sandbox and maximum execution time</source>
          <target state="translated">Песочница и максимальное время исполнения</target>
        </trans-unit>
        <trans-unit id="444bd4af75b503112dd46c6982e0bae0a08cf7c2" translate="yes" xml:space="preserve">
          <source>Save the DB in background. The OK code is immediately returned. Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits. A client may be able to check if the operation succeeded using the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; command.</source>
          <target state="translated">Сохраните БД в фоновом режиме. Код ОК немедленно возвращается. Redis разветвляется, родитель продолжает обслуживать клиентов, потомок сохраняет БД на диск, а затем завершает работу. Клиент может проверить &lt;a href=&quot;lastsave&quot;&gt;успешность&lt;/a&gt; операции с помощью команды LASTSAVE .</target>
        </trans-unit>
        <trans-unit id="6e73e4e94939b275e189527f28b962ac1035dc5b" translate="yes" xml:space="preserve">
          <source>Scan guarantees</source>
          <target state="translated">Гарантии сканирования</target>
        </trans-unit>
        <trans-unit id="983987071368a426b6b0e610cd5b5142cb273380" translate="yes" xml:space="preserve">
          <source>Script cache semantics</source>
          <target state="translated">семантика кэша сценария</target>
        </trans-unit>
        <trans-unit id="7522becbe814d8b8cbc378f8930c8ca68bb2b8b5" translate="yes" xml:space="preserve">
          <source>Scripting</source>
          <target state="translated">Scripting</target>
        </trans-unit>
        <trans-unit id="745fe7d4baa466214b942befb3f50f3311c89d23" translate="yes" xml:space="preserve">
          <source>Scripts are also subject to a maximum execution time (five seconds by default). This default timeout is huge since a script should usually run in under a millisecond. The limit is mostly to handle accidental infinite loops created during development.</source>
          <target state="translated">На скрипты также распространяется максимальное время выполнения (по умолчанию пять секунд).Этот стандартный таймаут огромен,так как скрипт обычно должен выполняться менее чем за миллисекунду.Ограничением в основном является обработка случайных бесконечных циклов,создаваемых во время разработки.</target>
        </trans-unit>
        <trans-unit id="aef3e907fc9586fb823b51b6f43074de8b409561" translate="yes" xml:space="preserve">
          <source>Scripts as pure functions</source>
          <target state="translated">Скрипты как чистые функции</target>
        </trans-unit>
        <trans-unit id="18ec3225e4d3fe66e7449672a6973e4c283e8bfa" translate="yes" xml:space="preserve">
          <source>Scripts should never try to access the external system, like the file system or any other system call. A script should only operate on Redis data and passed arguments.</source>
          <target state="translated">Скрипты никогда не должны пытаться получить доступ к внешней системе,например,к файловой системе или любому другому системному вызову.Скрипт должен работать только с данными Redis и переданными аргументами.</target>
        </trans-unit>
        <trans-unit id="96faa0a78d5b1890951d8f5b8b1cde571bd90423" translate="yes" xml:space="preserve">
          <source>Second replica</source>
          <target state="translated">Вторая реплика</target>
        </trans-unit>
        <trans-unit id="b5a6bb51bed42ec84477a8c64f567145dc6b3f5b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; for documentation.</source>
          <target state="translated">См. &lt;a href=&quot;flushall&quot;&gt;Документацию в FLUSHALL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82b75cc42f6596f8de98cea0e684609b487d2473" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; for extra information on increment/decrement operations.</source>
          <target state="translated">См. &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; для получения дополнительной информации об операциях увеличения / уменьшения.</target>
        </trans-unit>
        <trans-unit id="107b4f4ca6c2e49d71158688712e821a1f6afcf3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; for more information.</source>
          <target state="translated">См. &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="54208184c8545cb10751d54f17912e96124fdcce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">См. &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; для документации &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7350f489b2f884299284e290b37d7bb050416da" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">См. &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; для документации &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23e07b46cb9a86395d17dec6e25da38c0a253bd8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">См. &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; для документации &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf5419ddb7be58d105f864a1bb383d4d274d8979" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; when you need the elements ordered from highest to lowest score (and descending lexicographical order for elements with equal score).</source>
          <target state="translated">См. &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE,&lt;/a&gt; если вам нужны элементы, упорядоченные от наивысшего к наименьшему баллу (и нисходящий лексикографический порядок для элементов с одинаковым баллом).</target>
        </trans-unit>
        <trans-unit id="a4157bb7f9bac5025b0c70053cd9e97522de9f5f" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; command that returns the same information with milliseconds resolution (Only available in Redis 2.6 or greater).</source>
          <target state="translated">См. Также команду &lt;a href=&quot;pttl&quot;&gt;PTTL,&lt;/a&gt; которая возвращает ту же информацию с разрешением в миллисекунды (доступно только в Redis 2.6 или выше).</target>
        </trans-unit>
        <trans-unit id="3f65c6fd246f3e1cbd884a1abc8369fa9e3fec12" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being that it pops elements from the tail of a list instead of popping from the head.</source>
          <target state="translated">См. Точную семантику в &lt;a href=&quot;blpop&quot;&gt;документации&lt;/a&gt; по BLPOP , поскольку &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; идентичен &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; с той лишь разницей, что он выталкивает элементы из хвоста списка, а не из начала.</target>
        </trans-unit>
        <trans-unit id="98f2a156aa61e815ac476620027b033818a3853f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being the data structure being popped from.</source>
          <target state="translated">См. Точную семантику в &lt;a href=&quot;blpop&quot;&gt;документации&lt;/a&gt; по BLPOP , поскольку &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; идентичен &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; с той лишь разницей, что структура данных извлекается из.</target>
        </trans-unit>
        <trans-unit id="682db2e97701526e3ecf1f9201b3297eab6f9ec7" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; is identical to &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; with the only difference being that it pops members with the highest scores instead of popping the ones with the lowest scores.</source>
          <target state="translated">См. &lt;a href=&quot;bzpopmin&quot;&gt;Документацию BZPOPMIN&lt;/a&gt; для получения точной семантики, поскольку &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; идентичен &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; с той лишь разницей, что он выталкивает элементы с наивысшими оценками вместо того, чтобы выталкивать те, которые имеют самые низкие оценки.</target>
        </trans-unit>
        <trans-unit id="58bc20fb0dd298ffb8cf41a50998826b6c62ee0f" translate="yes" xml:space="preserve">
          <source>See the article called &quot;&lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Fast easy realtime metrics using Redis bitmaps&lt;/a&gt;&quot; for a interesting use cases.</source>
          <target state="translated">См. Статью &amp;laquo; &lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Быстрые и простые метрики в реальном времени с использованием растровых изображений Redis&lt;/a&gt; &amp;raquo;, где описаны интересные варианты использования.</target>
        </trans-unit>
        <trans-unit id="2b55d9f15b0ea2d72611a684c74d755e0354f5c5" translate="yes" xml:space="preserve">
          <source>Select the Redis logical database having the specified zero-based numeric index. New connections always use the database 0.</source>
          <target state="translated">Выберите логическую базу данных Redis с указанным нулевым цифровым индексом.Новые соединения всегда используют БД 0.</target>
        </trans-unit>
        <trans-unit id="19899928b5f8951aa558a826d2465808d72a01a5" translate="yes" xml:space="preserve">
          <source>Selective replication of commands</source>
          <target state="translated">Селективная репликация команд</target>
        </trans-unit>
        <trans-unit id="49cedc3ef8c6db0043eba553132d30f3fe261b2a" translate="yes" xml:space="preserve">
          <source>Sentinel output</source>
          <target state="translated">Часовой выход</target>
        </trans-unit>
        <trans-unit id="23e75937982f844ac2efdda93d0cf6e15629e1a7" translate="yes" xml:space="preserve">
          <source>Serialization format</source>
          <target state="translated">формат сериализации</target>
        </trans-unit>
        <trans-unit id="7af4afd659e0dc29f7d2d75a3f48646f5eb4ec0b" translate="yes" xml:space="preserve">
          <source>Serialize the value stored at key in a Redis-specific format and return it to the user. The returned value can be synthesized back into a Redis key using the &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command.</source>
          <target state="translated">Сериализуйте значение, хранящееся в ключе, в формате, специфичном для Redis, и верните его пользователю. Возвращаемое значение можно синтезировать обратно в ключ Redis с помощью команды &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="c0ae85ee6d7ed57f6a577247b126ae67f64df433" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold string &lt;code&gt;value&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist. In that case, it is equal to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. When &lt;code&gt;key&lt;/code&gt; already holds a value, no operation is performed. &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; is short for &quot;&lt;strong&gt;SET&lt;/strong&gt; if &lt;strong&gt;N&lt;/strong&gt;ot e&lt;strong&gt;X&lt;/strong&gt;ists&quot;.</source>
          <target state="translated">Установите &lt;code&gt;key&lt;/code&gt; для хранения строкового &lt;code&gt;value&lt;/code&gt; если &lt;code&gt;key&lt;/code&gt; не существует. В этом случае он равен &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; . Когда &lt;code&gt;key&lt;/code&gt; уже содержит значение, операция не выполняется. &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; является аббревиатурой &amp;laquo; &lt;strong&gt;SET&lt;/strong&gt; , если &lt;strong&gt;N&lt;/strong&gt; ВЗ е &lt;strong&gt;X&lt;/strong&gt; сты&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="68ffd036a56e1e5a5a24f70d86f4819eb308fad6" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt; and set &lt;code&gt;key&lt;/code&gt; to timeout after a given number of seconds. This command is equivalent to executing the following commands:</source>
          <target state="translated">Установите &lt;code&gt;key&lt;/code&gt; для удержания строкового &lt;code&gt;value&lt;/code&gt; и установите для &lt;code&gt;key&lt;/code&gt; ожидания по истечении заданного количества секунд. Эта команда эквивалентна выполнению следующих команд:</target>
        </trans-unit>
        <trans-unit id="e17569ffaef1d28acdfd66d09de8af3c0b06dd1a" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; already holds a value, it is overwritten, regardless of its type. Any previous time to live associated with the key is discarded on successful &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation.</source>
          <target state="translated">Установите &lt;code&gt;key&lt;/code&gt; для хранения строкового &lt;code&gt;value&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; уже содержит значение, оно перезаписывается независимо от его типа. Любое предыдущее время жизни, связанное с ключом, сбрасывается при успешной операции &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f4c1e8e25a5de08761510d1ae33392ed98c3afb" translate="yes" xml:space="preserve">
          <source>Set a timeout on &lt;code&gt;key&lt;/code&gt;. After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is often said to be &lt;em&gt;volatile&lt;/em&gt; in Redis terminology.</source>
          <target state="translated">Установите таймаут на &lt;code&gt;key&lt;/code&gt; . По истечении таймаута ключ будет автоматически удален. В терминологии Redis ключ с соответствующим таймаутом часто называют &lt;em&gt;изменчивым&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="eaec93cdacc6eb6c55472f85e73e6fb3ad082dbe" translate="yes" xml:space="preserve">
          <source>Set the consumer group &lt;em&gt;last delivered ID&lt;/em&gt; to something else.</source>
          <target state="translated">Установите другой &lt;em&gt;идентификатор&lt;/em&gt; группы потребителей, &lt;em&gt;доставленный последней&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5d89ad31b7de012f12a03f34f4620f730e4db31a" translate="yes" xml:space="preserve">
          <source>Set the debug mode for subsequent scripts executed with &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;. Redis includes a complete Lua debugger, codename LDB, that can be used to make the task of writing complex scripts much simpler. In debug mode Redis acts as a remote debugging server and a client, such as &lt;code&gt;redis-cli&lt;/code&gt;, can execute scripts step by step, set breakpoints, inspect variables and more - for additional information about LDB refer to the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Lua debugger&lt;/a&gt; page.</source>
          <target state="translated">Установите режим отладки для последующих скриптов, выполняемых с &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; . Redis включает в себя полный отладчик Lua под кодовым именем LDB, который можно использовать, чтобы значительно упростить задачу написания сложных сценариев. В режиме отладки Redis действует как сервер удаленной отладки, а клиент, такой как &lt;code&gt;redis-cli&lt;/code&gt; , может выполнять сценарии шаг за шагом, устанавливать точки останова, проверять переменные и многое другое - для получения дополнительной информации о LDB обратитесь к странице &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;отладчика Redis Lua&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6550b71f96cbf89e715fc6e575e8db9958a3525f" translate="yes" xml:space="preserve">
          <source>Set the destination node slot to &lt;em&gt;importing&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Установите слот узла назначения в состояние &lt;em&gt;импорта&lt;/em&gt; с помощью &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84c2dc8e1aa43a852766a49a5d96696d6e7e9329" translate="yes" xml:space="preserve">
          <source>Set the source node slot to &lt;em&gt;migrating&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Установите слот исходного узла в состояние &lt;em&gt;миграции&lt;/em&gt; с помощью &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ab262f44dfc9e1ee8adf98c1aa64de34434fa83" translate="yes" xml:space="preserve">
          <source>Sets</source>
          <target state="translated">Sets</target>
        </trans-unit>
        <trans-unit id="d9264103cd2db8160e2072438f28377ce6a9fc7b" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, only if &lt;code&gt;field&lt;/code&gt; does not yet exist. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists, this operation has no effect.</source>
          <target state="translated">Устанавливает &lt;code&gt;field&lt;/code&gt; в хэше, хранящемся под &lt;code&gt;key&lt;/code&gt; в &lt;code&gt;value&lt;/code&gt; , только если &lt;code&gt;field&lt;/code&gt; еще не существует. Если &lt;code&gt;key&lt;/code&gt; не существует, создается новый ключ, содержащий хеш. Если &lt;code&gt;field&lt;/code&gt; уже существует, эта операция не действует.</target>
        </trans-unit>
        <trans-unit id="4067fd3c70d6275dbeb4b012c5dce8cf613a429a" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists in the hash, it is overwritten.</source>
          <target state="translated">Устанавливает &lt;code&gt;field&lt;/code&gt; в хэше, хранящемся под &lt;code&gt;key&lt;/code&gt; к &lt;code&gt;value&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; не существует, создается новый ключ, содержащий хеш. Если &lt;code&gt;field&lt;/code&gt; уже существует в хэше, оно перезаписывается.</target>
        </trans-unit>
        <trans-unit id="e0c3c8b5846a6b7343db97e53a136456e18a31e2" translate="yes" xml:space="preserve">
          <source>Sets can be encoded as &lt;code&gt;intset&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;intset&lt;/code&gt; is a special encoding used for small sets composed solely of integers.</source>
          <target state="translated">Наборы могут быть закодированы как &lt;code&gt;intset&lt;/code&gt; или &lt;code&gt;hashtable&lt;/code&gt; . &lt;code&gt;intset&lt;/code&gt; это специальное кодирование , используемое для небольших наборов , состоящих исключительно из целых чисел.</target>
        </trans-unit>
        <trans-unit id="e2de8a522a3c6c1fa9f2cb3110ab55a427778354" translate="yes" xml:space="preserve">
          <source>Sets or clears the bit at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">Устанавливает или очищает бит по &lt;em&gt;смещению&lt;/em&gt; в строковом значении, хранящемся в &lt;em&gt;ключе&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e97dcc6f663f896d57a6785f5e028d865ad0719f" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; replaces existing values with new values, just as regular &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. See &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; if you don't want to overwrite existing values.</source>
          <target state="translated">Устанавливает для заданных ключей соответствующие значения. &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; заменяет существующие значения новыми значениями, как и обычный &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; . См. &lt;a href=&quot;msetnx&quot;&gt;MSETNX,&lt;/a&gt; если вы не хотите перезаписывать существующие значения.</target>
        </trans-unit>
        <trans-unit id="5a2c8ceb3bc610f26a67627aba4acc8339a9ce7d" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; will not perform any operation at all even if just a single key already exists.</source>
          <target state="translated">Устанавливает для заданных ключей соответствующие значения. &lt;a href=&quot;msetnx&quot;&gt;MSETNX вообще&lt;/a&gt; не будет выполнять никаких операций, даже если уже существует только один ключ.</target>
        </trans-unit>
        <trans-unit id="8750c7a418a307afb7502f752e1bd4c1264fa761" translate="yes" xml:space="preserve">
          <source>Sets the list element at &lt;code&gt;index&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. For more information on the &lt;code&gt;index&lt;/code&gt; argument, see &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;.</source>
          <target state="translated">Устанавливает элемент списка по &lt;code&gt;index&lt;/code&gt; в &lt;code&gt;value&lt;/code&gt; . Дополнительные сведения об аргументе &lt;code&gt;index&lt;/code&gt; см . В разделе &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3acb8a6c67905faa893fe92726100c83a3b40b2e" translate="yes" xml:space="preserve">
          <source>Sets the specified fields to their respective values in the hash stored at &lt;code&gt;key&lt;/code&gt;. This command overwrites any specified fields already existing in the hash. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created.</source>
          <target state="translated">Устанавливает для указанных полей соответствующие значения в хэше, хранящемся в &lt;code&gt;key&lt;/code&gt; . Эта команда перезаписывает любые указанные поля, уже существующие в хэше. Если &lt;code&gt;key&lt;/code&gt; не существует, создается новый ключ, содержащий хеш.</target>
        </trans-unit>
        <trans-unit id="66e4a6395d06dd6c9ac9889a54defa5d69368f6e" translate="yes" xml:space="preserve">
          <source>Similarly to get just the last element added into the stream it is enough to send:</source>
          <target state="translated">Аналогично тому,чтобы получить только последний элемент,добавленный в поток,достаточно отправить:</target>
        </trans-unit>
        <trans-unit id="e66ca1aceaf1d95b66f61ef999386ba4322050ac" translate="yes" xml:space="preserve">
          <source>Simple string reply</source>
          <target state="translated">Простой строковый ответ</target>
        </trans-unit>
        <trans-unit id="d1d2334a81971315130c4fe2db94eeb5d843a482" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; and &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; have a &lt;code&gt;STORE&lt;/code&gt; and &lt;code&gt;STOREDIST&lt;/code&gt; option they are technically flagged as writing commands in the Redis command table. For this reason read-only replicas will flag them, and Redis Cluster replicas will redirect them to the master instance even if the connection is in read only mode (See the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command of Redis Cluster).</source>
          <target state="translated">Поскольку &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; и &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; имеют опции &lt;code&gt;STORE&lt;/code&gt; и &lt;code&gt;STOREDIST&lt;/code&gt; , они технически помечены как записывающие команды в таблице команд Redis. По этой причине реплики, доступные только для чтения, &lt;a href=&quot;readonly&quot;&gt;помечают&lt;/a&gt; их, а реплики Redis Cluster перенаправляют их на главный экземпляр, даже если соединение находится в режиме только для чтения (см. Команду READONLY для Redis Cluster).</target>
        </trans-unit>
        <trans-unit id="97d9bd95aec04226ad20ff34e75e5087d27999bb" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; returns the number of replicas reached both in case of failure and success, the client should check that the returned value is equal or greater to the replication level it demanded.</source>
          <target state="translated">Поскольку &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; возвращает количество реплик, достигнутых как в случае сбоя, так и в случае успеха, клиент должен проверить, что возвращаемое значение равно или больше требуемого уровня репликации.</target>
        </trans-unit>
        <trans-unit id="d91e505ea765c9a82be96ae5534dfec641b36446" translate="yes" xml:space="preserve">
          <source>Since Redis 2.4 the AOF rewrite is automatically triggered by Redis, however the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; command can be used to trigger a rewrite at any time.</source>
          <target state="translated">Начиная с Redis 2.4, перезапись AOF автоматически запускается Redis, однако команду &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; можно использовать для запуска перезаписи в любое время.</target>
        </trans-unit>
        <trans-unit id="fea1afb4200834342d36841c2047774edeed20c3" translate="yes" xml:space="preserve">
          <source>Since Redis 2.6 the expire error is from 0 to 1 milliseconds.</source>
          <target state="translated">Так как Redis 2.6 ошибка истечения срока действия составляет от 0 до 1 миллисекунды.</target>
        </trans-unit>
        <trans-unit id="c0dcf1f129fbdd5b581db58c1a230256a6836c37" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 it is possible to specify multiple keys instead of a single one. In such a case, it returns the total number of keys existing. Note that returning 1 or 0 for a single key is just a special case of the variadic usage, so the command is completely backward compatible.</source>
          <target state="translated">Начиная с версии 3.0.3 в Redis можно указывать несколько ключей вместо одного.В этом случае возвращается общее количество существующих ключей.Обратите внимание,что возврат 1 или 0 для одного ключа является лишь частным случаем разновидного использования,поэтому команда полностью обратно совместима.</target>
        </trans-unit>
        <trans-unit id="f8bcf2ebedfce566d24835d3a2aba17bb7c2d1ca" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 the command accepts a variable number of keys and the return value is generalized:</source>
          <target state="translated">Так как в Redis 3.0.3 команда принимает переменное количество ключей,а возвращаемое значение является обобщенным:</target>
        </trans-unit>
        <trans-unit id="e151485b203362c942ed95e59fd38510a0f0ba0d" translate="yes" xml:space="preserve">
          <source>Since Redis 3.2.10 / 4.0.0, this command also prevents keys to be evicted or expired during the time clients are paused. This way the dataset is guaranteed to be static not just from the point of view of clients not being able to write, but also from the point of view of internal operations.</source>
          <target state="translated">Начиная с версии 3.2.10/4.0.0,эта команда также предотвращает вытеснение или истечение срока действия ключей во время приостановки работы клиентов.Таким образом,набор данных гарантированно будет статичным не только с точки зрения невозможности записи,но и с точки зрения внутренних операций.</target>
        </trans-unit>
        <trans-unit id="b23d8947d72fa1ab05d11117a996f014677a635b" translate="yes" xml:space="preserve">
          <source>Since in the second call the returned cursor is 0, the server signaled to the caller that the iteration finished, and the collection was completely explored. Starting an iteration with a cursor value of 0, and calling &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; until the returned cursor is 0 again is called a &lt;strong&gt;full iteration&lt;/strong&gt;.</source>
          <target state="translated">Поскольку во втором вызове возвращенный курсор равен 0, сервер сигнализировал вызывающему, что итерация завершена, и коллекция была полностью исследована. Запуск итерации со значением курсора 0 и вызов &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; до тех пор, пока возвращенный курсор снова не станет 0, называется &lt;strong&gt;полной итерацией&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5ff6f2c9633e20e1d4f2fc7a23a6109e8917c9ab" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;increment&lt;/code&gt; argument is signed, both increment and decrement operations can be performed:</source>
          <target state="translated">Поскольку аргумент &lt;code&gt;increment&lt;/code&gt; подписан, могут выполняться операции как увеличения, так и уменьшения:</target>
        </trans-unit>
        <trans-unit id="37a6aaafe1e5adca5e6fbd58e615c9ceed7c328a" translate="yes" xml:space="preserve">
          <source>Since the currently selected database is a property of the connection, clients should track the currently selected database and re-select it on reconnection. While there is no command in order to query the selected database in the current connection, the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; output shows, for each client, the currently selected database.</source>
          <target state="translated">Поскольку текущая выбранная база данных является свойством соединения, клиенты должны отслеживать текущую выбранную базу данных и повторно выбирать ее при повторном подключении. Хотя нет команды для запроса выбранной базы данных в текущем соединении, выходные данные &lt;a href=&quot;client-list&quot;&gt;СПИСОК КЛИЕНТОВ&lt;/a&gt; показывают для каждого клиента текущую выбранную базу данных.</target>
        </trans-unit>
        <trans-unit id="52b5e60090730a6d250177de9e20295f9eac7ba4" translate="yes" xml:space="preserve">
          <source>Since the introduction of partial resynchronization with replicas (PSYNC feature) Redis replicas asynchronously ping their master with the offset they already processed in the replication stream. This is used in multiple ways:</source>
          <target state="translated">С момента введения частичной ресинхронизации с репликами (функция PSYNC)реплики ресинхронизируются асинхронно пингом своего мастера со смещением,которое они уже обработали в потоке репликации.Это используется несколькими способами:</target>
        </trans-unit>
        <trans-unit id="22f6371320dc02af91620e9a2e69ac86d721aec2" translate="yes" xml:space="preserve">
          <source>Since there is no state server side, but the full state is captured by the cursor, the caller is free to terminate an iteration half-way without signaling this to the server in any way. An infinite number of iterations can be started and never terminated without any issue.</source>
          <target state="translated">Так как нет государственной стороны сервера,но полное состояние перехватывается курсором,вызывающий абонент может завершить итерацию на полпути,не сообщая об этом серверу ни в коем случае.Бесконечное количество итераций может быть запущено и никогда не завершено без каких-либо проблем.</target>
        </trans-unit>
        <trans-unit id="262e696e012026f3d4f6a8415b02d5a7c46227f9" translate="yes" xml:space="preserve">
          <source>Since these commands allow for incremental iteration, returning only a small number of elements per call, they can be used in production without the downside of commands like &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; or &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; that may block the server for a long time (even several seconds) when called against big collections of keys or elements.</source>
          <target state="translated">Поскольку эти команды допускают инкрементную итерацию, возвращая только небольшое количество элементов за вызов, их можно использовать в производственной &lt;a href=&quot;smembers&quot;&gt;среде без обратной&lt;/a&gt; стороны таких команд, как &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; или SMEMBERS, которые могут блокировать сервер на долгое время (даже несколько секунд) при вызове большие коллекции ключей или элементов.</target>
        </trans-unit>
        <trans-unit id="3c0c8d4b217b1b3c149a8290667da3e389e7ef26" translate="yes" xml:space="preserve">
          <source>Since this involves approximations, in order to avoid C is set to, like, 0.998 instead of 1, we just modify the above algorithm to make sure the last score is 1 (left as an exercise for the reader...).</source>
          <target state="translated">Так как это включает в себя аппроксимации,для того,чтобы избежать C установлено значение 0.998 вместо 1,мы просто модифицируем вышеприведенный алгоритм,чтобы убедиться,что последняя оценка равна 1 (слева в качестве упражнения для читателя...).</target>
        </trans-unit>
        <trans-unit id="7872f5590df64a34d5d83302b83736d78de377e5" translate="yes" xml:space="preserve">
          <source>Since version 2.1.6, &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; can be exclusive, following the syntax of &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">Начиная с версии 2.1.6, &lt;code&gt;min&lt;/code&gt; и &lt;code&gt;max&lt;/code&gt; могут быть исключительными, следуя синтаксису &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c1d2abc7675af0239fa910c466960e644589788" translate="yes" xml:space="preserve">
          <source>Single number: 3894</source>
          <target state="translated">Единый номер:3894</target>
        </trans-unit>
        <trans-unit id="f4a53209e61b36ab81faa5f943fba8e855032018" translate="yes" xml:space="preserve">
          <source>Skip sorting the elements</source>
          <target state="translated">Пропустить сортировку элементов</target>
        </trans-unit>
        <trans-unit id="8eab09bbd450823e91103eb2aaa19c7c3697409f" translate="yes" xml:space="preserve">
          <source>So for example the command &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; will return each item in the following way:</source>
          <target state="translated">Так, например, команда &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; вернет каждый элемент следующим образом:</target>
        </trans-unit>
        <trans-unit id="76d0f19de574ac1304a0b3b169f72caa92244d72" translate="yes" xml:space="preserve">
          <source>So for instance, to get all the elements from the higher ID to the lower ID one could use:</source>
          <target state="translated">Так,например,чтобы получить все элементы с более высокого ID на более низкий ID,можно было бы использовать:</target>
        </trans-unit>
        <trans-unit id="605cfa3fd340ae3e5e756672779740b80a689628" translate="yes" xml:space="preserve">
          <source>So in order for a given node to accept another one into the list of nodes composing a Redis Cluster, there are only two ways:</source>
          <target state="translated">Таким образом,для того,чтобы данный узел принял другой в список узлов,составляющих кластер Redis,есть только два способа:</target>
        </trans-unit>
        <trans-unit id="2350b72b46e64aeb370c2cbfa4c601de95c3d620" translate="yes" xml:space="preserve">
          <source>So we start with a list of keys, and later continue with all the associated IDs, representing &lt;em&gt;the last ID we received for that stream&lt;/em&gt;, so that the call will serve us only greater IDs from the same stream.</source>
          <target state="translated">Итак, мы начинаем со списка ключей, а затем продолжаем со всеми связанными идентификаторами, представляющими &lt;em&gt;последний идентификатор, который мы получили для этого потока&lt;/em&gt; , так что вызов будет обслуживать нам только большие идентификаторы из того же потока.</target>
        </trans-unit>
        <trans-unit id="46ddca2244f21f2b27c1eb6025f1e694d4b8bea0" translate="yes" xml:space="preserve">
          <source>So what the command really does is:</source>
          <target state="translated">Итак,что на самом деле делает команда:</target>
        </trans-unit>
        <trans-unit id="f434d4f52b4b99882f1b83c63bcdd004df128d69" translate="yes" xml:space="preserve">
          <source>So, if we link node A with node B via &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;, and B with C, A and C will find their ways to handshake and create a link.</source>
          <target state="translated">Итак, если мы свяжем узел A с узлом B через &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; , а B с C, A и C найдут свои способы рукопожатия и создания ссылки.</target>
        </trans-unit>
        <trans-unit id="60790236df4f5916ea98a7288f81aafe33a99ab5" translate="yes" xml:space="preserve">
          <source>So, using &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt;, when a new cluster is created, we can assign a different progressive configuration epoch to each node before joining the cluster together.</source>
          <target state="translated">Итак, с помощью &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt; , когда создается новый кластер, мы можем назначить разные эпохи прогрессивной конфигурации каждому узлу перед объединением кластера.</target>
        </trans-unit>
        <trans-unit id="173217936882f8d5719c8defa86bf0d23eac51fe" translate="yes" xml:space="preserve">
          <source>Some Redis commands have no predetermined key locations. For those commands, flag &lt;code&gt;movablekeys&lt;/code&gt; is added to the command flags &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;. Your Redis Cluster client needs to parse commands marked &lt;code&gt;movablekeys&lt;/code&gt; to locate all relevant key positions.</source>
          <target state="translated">Некоторые команды Redis не имеют заранее определенного расположения клавиш. Для этих команд флаг &lt;code&gt;movablekeys&lt;/code&gt; добавлен в &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;ответ массива&lt;/a&gt; флагов команды . Вашему клиенту Redis Cluster необходимо проанализировать команды, помеченные как &lt;code&gt;movablekeys&lt;/code&gt; , чтобы найти все соответствующие ключевые позиции.</target>
        </trans-unit>
        <trans-unit id="ddceed7fe40007b57317ba7df983076bcd185123" translate="yes" xml:space="preserve">
          <source>Some consumer A reads a message via &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; from a stream, in the context of that consumer group.</source>
          <target state="translated">Некоторый потребитель A читает сообщение через &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; из потока в контексте этой группы потребителей.</target>
        </trans-unit>
        <trans-unit id="28d440075fc880e5ff5b66c8a65009bc3be5acfb" translate="yes" xml:space="preserve">
          <source>Sometimes it can be useful for clients to completely disable replies from the Redis server. For example when the client sends fire and forget commands or performs a mass loading of data, or in caching contexts where new data is streamed constantly. In such contexts to use server time and bandwidth in order to send back replies to clients, which are going to be ignored, is considered wasteful.</source>
          <target state="translated">Иногда клиентам может быть полезно полностью отключить ответы с сервера Redis.Например,когда клиент посылает пожар и забывает команды или выполняет массовую загрузку данных,или в контекстах кэширования,когда новые данные передаются постоянно.В таких контекстах использование времени и полосы пропускания сервера для обратной отправки клиентам ответов,которые будут игнорироваться,считается расточительным.</target>
        </trans-unit>
        <trans-unit id="43292f17e4e5fce7b6e4920a4500928789cc3b9d" translate="yes" xml:space="preserve">
          <source>Sometimes you want to sort elements using external keys as weights to compare instead of comparing the actual elements in the list, set or sorted set. Let's say the list &lt;code&gt;mylist&lt;/code&gt; contains the elements &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; representing unique IDs of objects stored in &lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;. When these objects have associated weights stored in &lt;code&gt;weight_1&lt;/code&gt;, &lt;code&gt;weight_2&lt;/code&gt; and &lt;code&gt;weight_3&lt;/code&gt;, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; can be instructed to use these weights to sort &lt;code&gt;mylist&lt;/code&gt; with the following statement:</source>
          <target state="translated">Иногда вы хотите отсортировать элементы, используя внешние ключи в качестве весов для сравнения, вместо сравнения фактических элементов в списке, наборе или отсортированном наборе. Допустим, список &lt;code&gt;mylist&lt;/code&gt; содержит элементы &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; и &lt;code&gt;3&lt;/code&gt; , представляющие уникальные идентификаторы объектов, хранящихся в &lt;code&gt;object_1&lt;/code&gt; , &lt;code&gt;object_2&lt;/code&gt; и &lt;code&gt;object_3&lt;/code&gt; . Когда эти объекты имеют связанные веса, хранящиеся в &lt;code&gt;weight_1&lt;/code&gt; , &lt;code&gt;weight_2&lt;/code&gt; и &lt;code&gt;weight_3&lt;/code&gt; , &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; можно указать использовать эти веса для сортировки &lt;code&gt;mylist&lt;/code&gt; с помощью следующего оператора:</target>
        </trans-unit>
        <trans-unit id="b2397d818d7562914c5b062b54f97e833db314f2" translate="yes" xml:space="preserve">
          <source>Sorted Sets</source>
          <target state="translated">Сортированные наборы</target>
        </trans-unit>
        <trans-unit id="25ab5e6a0d5f2c9c6bc25d348c156dc61d5c8552" translate="yes" xml:space="preserve">
          <source>Sorted Sets can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;skiplist&lt;/code&gt; format. As for the List type small sorted sets can be specially encoded using &lt;code&gt;ziplist&lt;/code&gt;, while the &lt;code&gt;skiplist&lt;/code&gt; encoding is the one that works with sorted sets of any size.</source>
          <target state="translated">Сортированные наборы могут быть закодированы в &lt;code&gt;ziplist&lt;/code&gt; или &lt;code&gt;skiplist&lt;/code&gt; . Что касается типа списка, то небольшие отсортированные наборы могут быть специально закодированы с помощью &lt;code&gt;ziplist&lt;/code&gt; , а кодировка &lt;code&gt;skiplist&lt;/code&gt; - это та, которая работает с отсортированными наборами любого размера.</target>
        </trans-unit>
        <trans-unit id="86e387fe2a33fb39f76cfff98ea344b952f84a62" translate="yes" xml:space="preserve">
          <source>Sorted sets 101</source>
          <target state="translated">Сортированные наборы 101</target>
        </trans-unit>
        <trans-unit id="785f83ba9125723b72d2c573196ef8beabb345a8" translate="yes" xml:space="preserve">
          <source>Sorted sets are sorted by their score in an ascending way. The same element only exists a single time, no repeated elements are permitted. The score can be modified both by &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; that will update the element score, and as a side effect, its position on the sorted set, and by &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt; that can be used in order to update the score relatively to its previous value.</source>
          <target state="translated">Отсортированные наборы отсортированы по количеству очков в порядке возрастания. Один и тот же элемент существует только один раз, повторение элементов не допускается. Оценка может быть изменена как с помощью &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; , который обновит оценку элемента, так и в качестве побочного эффекта, его позиции в отсортированном наборе, а также с помощью &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY,&lt;/a&gt; который может использоваться для обновления оценки относительно ее предыдущего значения.</target>
        </trans-unit>
        <trans-unit id="2f2a07b6f7677455f1b32d657bbc8366bfa48bf3" translate="yes" xml:space="preserve">
          <source>Sorting by external keys</source>
          <target state="translated">Сортировка по внешним ключам</target>
        </trans-unit>
        <trans-unit id="614fb399b6728ae041f21780ab6202d98e11c79a" translate="yes" xml:space="preserve">
          <source>Special conditions not allowing the command execution</source>
          <target state="translated">Специальные условия,не допускающие выполнения команды</target>
        </trans-unit>
        <trans-unit id="0869a917cb9ab140bb00f5d52e7332ad6727fd9a" translate="yes" xml:space="preserve">
          <source>Special slot entries</source>
          <target state="translated">Специальные записи слотов</target>
        </trans-unit>
        <trans-unit id="549c2b56d95e908566338d2fd5914a21fd08d936" translate="yes" xml:space="preserve">
          <source>Specifically if a given write is transferred to one or more replicas, it is more likely (but not guaranteed) that if the master fails, we'll be able to promote, during a failover, a replica that received the write: both Sentinel and Redis Cluster will do a best-effort attempt to promote the best replica among the set of available replicas.</source>
          <target state="translated">В частности,если заданная запись переносится на одну или более копий,более вероятно (но не гарантированно),что в случае сбоя мастера,мы сможем продвигать,во время обхода отказа,копии,получившие запись:и Sentinel,и Redis Cluster сделают лучшую попытку продвинуть лучшую копию среди множества доступных реплик.</target>
        </trans-unit>
        <trans-unit id="d526406a65071e1fec15bd4174751e7a5bc387d7" translate="yes" xml:space="preserve">
          <source>Specifically this is what Redis does 10 times per second:</source>
          <target state="translated">В частности,это то,что Рэдис делает 10 раз в секунду:</target>
        </trans-unit>
        <trans-unit id="37ec7d989573caff7ef9f45953dba8d022709000" translate="yes" xml:space="preserve">
          <source>Specification of the behavior when count is passed</source>
          <target state="translated">Спецификация поведения при подсчете</target>
        </trans-unit>
        <trans-unit id="14c30af049c8842dbcbd1159d5db60d5f0981029" translate="yes" xml:space="preserve">
          <source>Specifying a Stream ID as an argument</source>
          <target state="translated">Указание идентификатора потока в качестве аргумента</target>
        </trans-unit>
        <trans-unit id="1544a5bc78a2aee56854818668d14afd235ec6c9" translate="yes" xml:space="preserve">
          <source>Start slot range</source>
          <target state="translated">Диапазон стартовых слотов</target>
        </trans-unit>
        <trans-unit id="ee455845986f290115764586b0c8b62db6794d99" translate="yes" xml:space="preserve">
          <source>Starting from Redis version 2.6, when called with the additional &lt;code&gt;count&lt;/code&gt; argument, return an array of &lt;code&gt;count&lt;/code&gt;&lt;strong&gt;distinct elements&lt;/strong&gt; if &lt;code&gt;count&lt;/code&gt; is positive. If called with a negative &lt;code&gt;count&lt;/code&gt; the behavior changes and the command is allowed to return the &lt;strong&gt;same element multiple times&lt;/strong&gt;. In this case the number of returned elements is the absolute value of the specified &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">Начиная с Redis версии 2.6, при вызове с дополнительным &lt;code&gt;count&lt;/code&gt; аргументов, возвращает массив &lt;code&gt;count&lt;/code&gt; &lt;strong&gt;различных элементов&lt;/strong&gt; , если &lt;code&gt;count&lt;/code&gt; положителен. Если вызывается с отрицательным &lt;code&gt;count&lt;/code&gt; поведение меняется, и команде разрешается возвращать один и тот &lt;strong&gt;же элемент несколько раз&lt;/strong&gt; . В этом случае количество возвращаемых элементов является абсолютным значением указанного &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83f9c28598d952311fc09fa54e334ed57a68832b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.6.12 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; supports a set of options that modify its behavior:</source>
          <target state="translated">Начиная с Redis 2.6.12 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; поддерживает набор параметров, изменяющих его поведение:</target>
        </trans-unit>
        <trans-unit id="f154b597ac1178d82fc4c50afc3e83d654688468" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.8 the return value in case of error changed:</source>
          <target state="translated">Начиная с регистратора Redis 2.8 возвращаемое значение при ошибке изменяется:</target>
        </trans-unit>
        <trans-unit id="cb9c10a639cbbf2b71b38cd0e777ffb915ed4e8b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.0.6 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; supports a new bulk-migration mode that uses pipelining in order to migrate multiple keys between instances without incurring in the round trip time latency and other overheads that there are when moving each key with a single &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; call.</source>
          <target state="translated">Начиная с Redis 3.0.6, &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; поддерживает новый режим массовой миграции, который использует конвейерную обработку для переноса нескольких ключей между экземплярами без задержки времени &lt;a href=&quot;migrate&quot;&gt;приема-передачи&lt;/a&gt; и других накладных расходов, которые возникают при перемещении каждого ключа с помощью одного вызова MIGRATE .</target>
        </trans-unit>
        <trans-unit id="6578980d36f8246047edd57af78a6f9934454cea" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, Redis has support for native Lua debugging. The Redis Lua debugger is a remote debugger consisting of a server, which is Redis itself, and a client, which is by default &lt;code&gt;redis-cli&lt;/code&gt;.</source>
          <target state="translated">Начиная с Redis 3.2, Redis поддерживает встроенную отладку Lua. Отладчик Redis Lua - это удаленный отладчик, состоящий из сервера, которым является сам Redis, и клиента, которым по умолчанию является &lt;code&gt;redis-cli&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b01b9bd2a097f98e87d6033b411073bab6691f7" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, it is possible to select an alternative replication method. Instead of replication whole scripts, we can just replicate single write commands generated by the script. We call this &lt;strong&gt;script effects replication&lt;/strong&gt;.</source>
          <target state="translated">Начиная с Redis 3.2, есть возможность выбрать альтернативный метод репликации. Вместо репликации целых сценариев мы можем просто реплицировать отдельные команды записи, созданные сценарием. Мы называем этот &lt;strong&gt;сценарий репликацией эффектов&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1ffd355623442762e32037427cffdb34a18e3984" translate="yes" xml:space="preserve">
          <source>Step 4 does not technically need to use &lt;code&gt;SETSLOT&lt;/code&gt; in the nodes not involved in the resharding, since the configuration will eventually propagate itself, however it is a good idea to do so in order to stop nodes from pointing to the wrong node for the hash slot moved as soon as possible, resulting in less redirections to find the right node.</source>
          <target state="translated">На шаге 4 технически нет необходимости использовать &lt;code&gt;SETSLOT&lt;/code&gt; на узлах, не участвующих в перешардинге, поскольку конфигурация в конечном итоге будет распространяться сама, однако это хорошая идея, чтобы не дать узлам указывать на неправильный узел для хэш-слота. перемещен как можно скорее, что приведет к меньшему количеству перенаправлений для поиска нужного узла.</target>
        </trans-unit>
        <trans-unit id="f75b76768d708a29fc0fb9becaf181931853bd99" translate="yes" xml:space="preserve">
          <source>Step Count</source>
          <target state="translated">Счетчик шагов</target>
        </trans-unit>
        <trans-unit id="f7fa846d5511789adfec64aa9b8751f7351a0ca5" translate="yes" xml:space="preserve">
          <source>Stop all the clients.</source>
          <target state="translated">Остановите всех клиентов.</target>
        </trans-unit>
        <trans-unit id="6cb759f69a54fcb63d47af649e368c12075f71be" translate="yes" xml:space="preserve">
          <source>Storing the result of a SORT operation</source>
          <target state="translated">Хранение результата операции SORT</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="61c2b2148d7f362f23210527dbc1bd6b0437b131" translate="yes" xml:space="preserve">
          <source>Stream IDs are composed of two parts, a Unix millisecond time stamp and a sequence number for entries inserted in the same millisecond. It is possible to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; specifying just the first part of the ID, the millisecond time, like in the following example:</source>
          <target state="translated">Идентификаторы потока состоят из двух частей: отметки времени миллисекунды Unix и порядкового номера для записей, вставленных в одну и ту же миллисекунду. Можно использовать &lt;a href=&quot;xrange&quot;&gt;XRANGE,&lt;/a&gt; указав только первую часть идентификатора, миллисекунду, как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="f7e700aeb9d8c3a456c6730300f1abde75268288" translate="yes" xml:space="preserve">
          <source>Streams are not auto-deleted once they have no entries inside (for instance after an &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; call), because the stream may have consumer groups associated with it.</source>
          <target state="translated">Потоки не удаляются автоматически, если внутри них нет записей (например, после вызова &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; ), поскольку с потоком могут быть связаны группы потребителей.</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="48c2711e04347f7b6d1ddd6b4a79296a8d2830ea" translate="yes" xml:space="preserve">
          <source>Strings are compared as binary array of bytes. Because of how the ASCII character set is specified, this means that usually this also have the effect of comparing normal ASCII characters in an obvious dictionary way. However this is not true if non plain ASCII strings are used (for example utf8 strings).</source>
          <target state="translated">Строки сравниваются как двоичный массив байт.Из-за того,как указан набор ASCII-символов,это означает,что обычно это также влияет на сравнение обычных ASCII-символов в очевидном словарном смысле.Однако это не так,если используются не простые ASCII-символы (например,строки utf8).</target>
        </trans-unit>
        <trans-unit id="2593368d27635cc5293b7e53f7145a56dff05dd8" translate="yes" xml:space="preserve">
          <source>Strings can be encoded as &lt;code&gt;raw&lt;/code&gt; (normal string encoding) or &lt;code&gt;int&lt;/code&gt; (strings representing integers in a 64 bit signed interval are encoded in this way in order to save space).</source>
          <target state="translated">Строки могут быть закодированы как &lt;code&gt;raw&lt;/code&gt; (нормальная кодировка строк) или &lt;code&gt;int&lt;/code&gt; (строки, представляющие целые числа в 64-битном интервале со знаком, кодируются таким образом для экономии места).</target>
        </trans-unit>
        <trans-unit id="d5294ece475c0dd1b0e5c4f6f621c1e0c0bf7039" translate="yes" xml:space="preserve">
          <source>Strings with a similar prefix are nearby, but the contrary is not true, it is possible that strings with different prefixes are nearby too.</source>
          <target state="translated">Строки с похожим префиксом находятся поблизости,но это не так,возможно,что строки с разными префиксами тоже находятся поблизости.</target>
        </trans-unit>
        <trans-unit id="3f9d46e5fb83a7700b4c788a03b12a80a7e61e08" translate="yes" xml:space="preserve">
          <source>Subcommand &lt;code&gt;encoding&lt;/code&gt; returns a bulk reply.</source>
          <target state="translated">&lt;code&gt;encoding&lt;/code&gt; подкоманды возвращает массовый ответ.</target>
        </trans-unit>
        <trans-unit id="03e52fefcd721e1070e1756817dc5fb3908630a4" translate="yes" xml:space="preserve">
          <source>Subcommands &lt;code&gt;refcount&lt;/code&gt; and &lt;code&gt;idletime&lt;/code&gt; return integers.</source>
          <target state="translated">Подкоманды &lt;code&gt;refcount&lt;/code&gt; и &lt;code&gt;idletime&lt;/code&gt; возвращают целые числа.</target>
        </trans-unit>
        <trans-unit id="9cdf88a718c3f491225fa1cc2fd76602c7208ad1" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the given patterns.</source>
          <target state="translated">Подписывает клиента на данные шаблоны.</target>
        </trans-unit>
        <trans-unit id="481c5cf231fde7f8730860922d6f3194fc5f2170" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the specified channels.</source>
          <target state="translated">Подписывает клиента на указанные каналы.</target>
        </trans-unit>
        <trans-unit id="4a47fd9934d349f948abbf361726590ff096c6b8" translate="yes" xml:space="preserve">
          <source>Summary form of XPENDING</source>
          <target state="translated">Краткая форма XPENDING</target>
        </trans-unit>
        <trans-unit id="dfe7ee6f8d575326187ecdb8ea7e6fb7cbf4ec35" translate="yes" xml:space="preserve">
          <source>Supported glob-style patterns:</source>
          <target state="translated">Поддерживаемые узоры в стиле глобуса:</target>
        </trans-unit>
        <trans-unit id="ced890cac00d712740bdc4d39c1db48f7483c499" translate="yes" xml:space="preserve">
          <source>Supported subcommands and integer types</source>
          <target state="translated">Поддерживаемые подкоманды и целочисленные типы</target>
        </trans-unit>
        <trans-unit id="b8398e47e81dab008569a234703960eb8bab2f11" translate="yes" xml:space="preserve">
          <source>TAKEOVER option: manual failover without cluster consensus</source>
          <target state="translated">Опция TAKEOVER:ручное преодоление отказа без достижения консенсуса по кластерам</target>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="8696f7a4c64b4516c2d96434e8b7824957a37d2a" translate="yes" xml:space="preserve">
          <source>TIME   Return the current server time</source>
          <target state="translated">ВРЕМЯ Возврат текущего времени сервера</target>
        </trans-unit>
        <trans-unit id="c701f5f92060225c236ac0e6b3051e03bb0ad061" translate="yes" xml:space="preserve">
          <source>TOUCH</source>
          <target state="translated">TOUCH</target>
        </trans-unit>
        <trans-unit id="ad5ae533c502772151a704d28a2bece0e0f4ca1b" translate="yes" xml:space="preserve">
          <source>TOUCH  key [key ...]   Alters the last access time of a key(s). Returns the number of existing keys specified.</source>
          <target state="translated">TOUCH ключ [ключ ...]Изменяет последнее время доступа к ключу(ам).Возвращает указанное количество существующих ключей.</target>
        </trans-unit>
        <trans-unit id="878260dfb888c3312c119e6db2253c2aa207ae98" translate="yes" xml:space="preserve">
          <source>TTL</source>
          <target state="translated">TTL</target>
        </trans-unit>
        <trans-unit id="8ef7742bd419d3406904eb9723c6ce85d49c0f81" translate="yes" xml:space="preserve">
          <source>TTL  key   Get the time to live for a key</source>
          <target state="translated">TTL ключ Получить время жить для ключа</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="7d0cfb250d49bba162e019907ea71cfcab32d9f4" translate="yes" xml:space="preserve">
          <source>TYPE  key   Determine the type stored at key</source>
          <target state="translated">Клавиша TYPE Определите тип,сохраненный в клавиатуре.</target>
        </trans-unit>
        <trans-unit id="5bbc08d2de04a7034dc9edbe2e20759367a5f82f" translate="yes" xml:space="preserve">
          <source>Taking a separated key that is incremented every time the bitmap is modified. This can be very efficient and atomic using a small Redis Lua script.</source>
          <target state="translated">Взятие отдельного ключа,который инкрементируется каждый раз при изменении растровой карты.Это может быть очень эффективно и атомарно при использовании небольшого скрипта Redis Lua.</target>
        </trans-unit>
        <trans-unit id="8b5d4fb8b75675d300f4de7425675abc3149473f" translate="yes" xml:space="preserve">
          <source>Terminating iterations in the middle</source>
          <target state="translated">Прекращение итераций в середине</target>
        </trans-unit>
        <trans-unit id="8a78f0cb0822107a63b906522f8970fb02d3906a" translate="yes" xml:space="preserve">
          <source>Test 20 random keys from the set of keys with an associated expire.</source>
          <target state="translated">Проверьте 20 случайных ключей из набора ключей с ассоциированным истечением срока годности.</target>
        </trans-unit>
        <trans-unit id="0c0c5f66ed89ad8b7f73f25128b137a4d67fcbb8" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; and the analogous &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; commands, you can use Redis strings as a linear array with O(1) random access. This is a very fast and efficient storage in many real world use cases.</source>
          <target state="translated">Благодаря &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; и аналогичным командам &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; вы можете использовать строки Redis как линейный массив с произвольным доступом O (1). Это очень быстрое и эффективное хранилище во многих реальных случаях использования.</target>
        </trans-unit>
        <trans-unit id="733be8ce43bb740e68f58527c40732d288c9eb0b" translate="yes" xml:space="preserve">
          <source>That said, &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; can be used, and was historically used, as a locking primitive. For example, to acquire the lock of the key &lt;code&gt;foo&lt;/code&gt;, the client could try the following:</source>
          <target state="translated">Тем не менее, &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; может использоваться и исторически использовался как блокирующий примитив. Например, чтобы получить блокировку ключа &lt;code&gt;foo&lt;/code&gt; , клиент может попробовать следующее:</target>
        </trans-unit>
        <trans-unit id="77d6d135447dbf512e1ae2af8102405447c9f874" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; command can be used to create a very compact representation of a list of fixed-size samples, usually referred as &lt;em&gt;time series&lt;/em&gt;. Every time a new sample arrives we can store it using the command</source>
          <target state="translated">&lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; команда может быть использована для создания очень компактного представления списка образцов фиксированного размера, обычно называют &lt;em&gt;время серии&lt;/em&gt; . Каждый раз, когда приходит новый образец, мы можем сохранить его, используя команду</target>
        </trans-unit>
        <trans-unit id="af3680004f1f3af89a74cfdd597524f1d5b57aa0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; command supports four bitwise operations: &lt;strong&gt;AND&lt;/strong&gt;, &lt;strong&gt;OR&lt;/strong&gt;, &lt;strong&gt;XOR&lt;/strong&gt; and &lt;strong&gt;NOT&lt;/strong&gt;, thus the valid forms to call the command are:</source>
          <target state="translated">Команда &lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; поддерживает четыре побитовых операции: &lt;strong&gt;AND&lt;/strong&gt; , &lt;strong&gt;OR&lt;/strong&gt; , &lt;strong&gt;XOR&lt;/strong&gt; и &lt;strong&gt;NOT&lt;/strong&gt; , поэтому допустимые формы для вызова команды:</target>
        </trans-unit>
        <trans-unit id="4dd66d959585425a19858f722e901be8748f987c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt; returns the name of the current connection as set by &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;. Since every new connection starts without an associated name, if no name was assigned a null bulk reply is returned.</source>
          <target state="translated">&lt;a href=&quot;client-getname&quot;&gt;КЛИЕНТ GetName&lt;/a&gt; возвращает имя текущего соединения , как установлено &lt;a href=&quot;client-setname&quot;&gt;КЛИЕНТА SetName&lt;/a&gt; . Поскольку каждое новое соединение начинается без связанного имени, если имя не было назначено, возвращается нулевой массовый ответ.</target>
        </trans-unit>
        <trans-unit id="77571e239b6c4924e5ae8625b133ece1b2fb165b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; command closes a given client connection. Up to Redis 2.8.11 it was possible to close a connection only by client address, using the following form:</source>
          <target state="translated">Команда &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; закрывает заданное клиентское соединение. До Redis 2.8.11 можно было закрыть соединение только по адресу клиента, используя следующую форму:</target>
        </trans-unit>
        <trans-unit id="c0d7e72efd1901513aa26d76fc6efa880b0ffcd7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command returns information and statistics about the client connections server in a mostly human readable format.</source>
          <target state="translated">Команда &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; возвращает информацию и статистику о сервере клиентских подключений в удобочитаемом формате.</target>
        </trans-unit>
        <trans-unit id="99ea497bab9ec2eb991df932e164aeadc0d98009" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-reply&quot;&gt;CLIENT REPLY&lt;/a&gt; command controls whether the server will reply the client's commands. The following modes are available:</source>
          <target state="translated">Команда &lt;a href=&quot;client-reply&quot;&gt;CLIENT REPLY&lt;/a&gt; определяет, будет ли сервер отвечать на команды клиента. Доступны следующие режимы:</target>
        </trans-unit>
        <trans-unit id="66ef05bc81ce96b58454a695580464830edc9445" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; command assigns a name to the current connection.</source>
          <target state="translated">Команда &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; присваивает имя текущему соединению.</target>
        </trans-unit>
        <trans-unit id="29ca3ac0a9d2f6b99b3b3cfed122170d73c27a26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; command is an important piece used by Redis Cluster in order to migrate all the keys contained in one hash slot from one node to another. This is how the migration is orchestrated, with the help of other commands as well. We'll call the node that has the current ownership of the hash slot the &lt;code&gt;source&lt;/code&gt; node, and the node where we want to migrate the &lt;code&gt;destination&lt;/code&gt; node.</source>
          <target state="translated">Команда &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; - важная часть, используемая Redis Cluster для переноса всех ключей, содержащихся в одном хэш-слоте, с одного узла на другой. Таким образом осуществляется миграция с помощью других команд. Мы назовем узел, который в настоящее время владеет хэш-слотом, &lt;code&gt;source&lt;/code&gt; узлом, а узел, на который мы хотим перенести узел &lt;code&gt;destination&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9969254dbf9ad62d16ce54578a579c12bed90714" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; command is used to read the configuration parameters of a running Redis server. Not all the configuration parameters are supported in Redis 2.4, while Redis 2.6 can read the whole configuration of a server using this command.</source>
          <target state="translated">Команда &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; используется для чтения параметров конфигурации работающего сервера Redis. Не все параметры конфигурации поддерживаются в Redis 2.4, в то время как Redis 2.6 может прочитать всю конфигурацию сервера с помощью этой команды.</target>
        </trans-unit>
        <trans-unit id="b44e010365af8a822e0e64c895b3b9356396e69b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITE&lt;/a&gt; command rewrites the &lt;code&gt;redis.conf&lt;/code&gt; file the server was started with, applying the minimal changes needed to make it reflect the configuration currently used by the server, which may be different compared to the original one because of the use of the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command.</source>
          <target state="translated">Команда &lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITE&lt;/a&gt; перезаписывает файл &lt;code&gt;redis.conf&lt;/code&gt; , с которого был запущен сервер, применяя минимальные изменения, необходимые для того, чтобы он отражал текущую конфигурацию, используемую сервером, которая может отличаться от исходной из-за использования &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; команда.</target>
        </trans-unit>
        <trans-unit id="a94ff0d50f7b4db45f039a4dafafa3f4c9259a89" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command is used in order to reconfigure the server at run time without the need to restart Redis. You can change both trivial parameters or switch from one to another persistence option using this command.</source>
          <target state="translated">Команда &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; используется для перенастройки сервера во время выполнения без необходимости перезапуска Redis. Вы можете изменить оба тривиальных параметра или переключиться с одного параметра сохранения на другой с помощью этой команды.</target>
        </trans-unit>
        <trans-unit id="166c68e394d8ab06f1a3bb76f56f32a612a6683d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command forces you to send the script body again and again. Redis does not need to recompile the script every time as it uses an internal caching mechanism, however paying the cost of the additional bandwidth may not be optimal in many contexts.</source>
          <target state="translated">Команда &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; заставляет вас снова и снова отправлять тело скрипта. Redis не нужно перекомпилировать скрипт каждый раз, так как он использует внутренний механизм кэширования, однако оплата дополнительной полосы пропускания может быть неоптимальной во многих контекстах.</target>
        </trans-unit>
        <trans-unit id="bd6411fae08a91e9b321232ed876a3d9070cad9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; family of commands is able to associate an expire to a given key, at the cost of some additional memory used by the key. When a key has an expire set, Redis will make sure to remove the key when the specified amount of time elapsed.</source>
          <target state="translated">&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; семейство команд может связать истекают к данному ключу, за счет некоторой дополнительной памяти , используемой ключом. Если для ключа установлен срок действия, Redis обязательно удалит ключ по истечении указанного времени.</target>
        </trans-unit>
        <trans-unit id="ae44c019fde6841c16a68c04d38047f2e0f60739" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command returns information and statistics about the server in a format that is simple to parse by computers and easy to read by humans.</source>
          <target state="translated">Команда &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; возвращает информацию и статистику о сервере в формате, который легко анализируется компьютерами и легко читается людьми.</target>
        </trans-unit>
        <trans-unit id="34c3a5fba12b1ed2508a72f81c29ed6c56b41d88" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt; command reports about different memory-related issues that the Redis server experiences, and advises about possible remedies.</source>
          <target state="translated">Команда &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt; сообщает о различных проблемах, связанных с памятью, с которыми сталкивается сервер Redis, и дает советы о возможных решениях.</target>
        </trans-unit>
        <trans-unit id="09f518db007c555b3fc51849cb715d5f37978149" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-help&quot;&gt;MEMORY HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="translated">Команда &lt;a href=&quot;memory-help&quot;&gt;MEMORY HELP&lt;/a&gt; возвращает полезный текст, описывающий различные подкоманды.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
