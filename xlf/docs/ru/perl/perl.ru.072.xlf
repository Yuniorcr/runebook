<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="745e9758fddddfd17b1f8070f37c73b6ef6dd2f4" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt; , a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="translated">При использовании с &lt;code&gt;Z&lt;/code&gt; , A &lt;code&gt;*&lt;/code&gt; в качестве счетчика повторов гарантированно добавить завершающий нулевой байт, так что результирующая строка всегда один байт длиннее , чем длина байта самого элемента.</target>
        </trans-unit>
        <trans-unit id="3e309ae810b7ba69caf1b083747a6f0e33a6ad11" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt;, a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501ee2b6d5b82410bf49c6ef557d5b8111f9b9e9" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; .</source>
          <target state="translated">При использовании с методами класса проблема еще хуже. Поскольку Perl позволяет записывать имена подпрограмм как голые слова, Perl должен угадывать, является ли голое слово после метода именем класса или именем подпрограммы. Другими словами, Perl может разрешить синтаксис как &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt; &lt;b&gt;или как &lt;/b&gt; &lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4f8a19419e9cae531fd00a5faf3b4b95c08f01c" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87eff678443c76527dd2ab6f92ce339964a9f84" translate="yes" xml:space="preserve">
          <source>When used with command line options:</source>
          <target state="translated">При использовании с опциями командной строки:</target>
        </trans-unit>
        <trans-unit id="034d2956d3ab35d5d0a3009bf9f647819ce96d9f" translate="yes" xml:space="preserve">
          <source>When userelocatableinc is true, this variable holds the location that make install should copy the perl binary to, with all the run-time relocatable paths calculated from this at install time. When used, it is initialized to the original value of binexp, and then binexp is set to</source>
          <target state="translated">Если userelocatableinc правда,эта переменная содержит место,куда должна быть скопирована программа установки,в которую должны быть скопированы бинарные файлы perl,а также все пути,которые могут быть перемещены во время выполнения программы,вычисленные из них во время установки.При использовании она инициализируется до исходного значения binexp,а затем binexp устанавливается в следующее состояние</target>
        </trans-unit>
        <trans-unit id="52d8c19f5d99981fe4c4d2fcb09c34b0b19ca9a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; on a &lt;code&gt;()&lt;/code&gt; group, this affects all types inside the group that accept byte-order modifiers, including all subgroups. It is silently ignored for all other types. You are not allowed to override the byte-order within a group that already has a byte-order modifier suffix.</source>
          <target state="translated">При использовании &lt;code&gt;&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;&lt;/code&gt; в группе &lt;code&gt;()&lt;/code&gt; это влияет на все типы внутри группы, которые принимают модификаторы порядка байтов, включая все подгруппы. Для всех остальных типов он молча игнорируется. Вам не разрешено переопределять порядок байтов в группе, которая уже имеет суффикс модификатора порядка байтов.</target>
        </trans-unit>
        <trans-unit id="834a7e8ec8b7da2f955444b22e5081d5fee5d139" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; , etc.</source>
          <target state="translated">При использовании &lt;code&gt;Exporter&lt;/code&gt; со стандартными &lt;code&gt;strict&lt;/code&gt; и &lt;code&gt;warnings&lt;/code&gt; прагмах, то &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; ключевое слово необходимо , чтобы объявить переменные пакета &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; и т.д.</target>
        </trans-unit>
        <trans-unit id="ff82b6a088bd3949701c2e9690b32b71bbe25933" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;our&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt;, &lt;code&gt;@EXPORT&lt;/code&gt;, &lt;code&gt;@ISA&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098b7ca0910242ebfe289953bb787b86df641163" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="translated">При использовании &lt;code&gt;IPC::Open3&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , если вы указываете строку в качестве аргумента &lt;code&gt;command&lt;/code&gt; , предполагается, что она соответствующим образом экранирована. Вы можете использовать константу &lt;code&gt;QUOTE&lt;/code&gt; в качестве переносимого символа кавычек (см. Выше). Однако, если вы предоставляете ссылку на массив, применяются особые правила:</target>
        </trans-unit>
        <trans-unit id="d2f0399c3e8df8b441dc7a3e6752ac0ac539b907" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac72f6ccde75b586d99f93dce2fef690fbdd778e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt; , if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="translated">При использовании &lt;code&gt;IPC::Run&lt;/code&gt; , если вы указываете строку в качестве аргумента &lt;code&gt;command&lt;/code&gt; , строка будет разделена на пробелы, чтобы определить отдельные элементы вашей команды. Хотя обычно это просто &amp;laquo;Делай то, что ты имеешь в виду&amp;raquo;, это может сломаться, если у вас есть файлы или команды с пробелами в них.</target>
        </trans-unit>
        <trans-unit id="cb299ab15bb95a67fd9da59509a66d398c459654" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd114611c2ad871f0c8eb7b6bb0b00563bb8b3c" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Perl_langinfo&lt;/code&gt; on systems that don't have a native &lt;code&gt;nl_langinfo()&lt;/code&gt;, you must</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887f4ef11aea133bd95f7e158dd018aa1d9071b1" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; , or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="translated">При использовании &lt;code&gt;autodie&lt;/code&gt; или &lt;code&gt;Fatal&lt;/code&gt; с пользовательскими подпрограммами объявление этих подпрограмм должно появиться перед первым использованием &lt;code&gt;Fatal&lt;/code&gt; или &lt;code&gt;autodie&lt;/code&gt; , либо они были экспортированы из модуля. Попытка использовать &lt;code&gt;Fatal&lt;/code&gt; или &lt;code&gt;autodie&lt;/code&gt; для других пользовательских подпрограмм приведет к ошибке времени компиляции.</target>
        </trans-unit>
        <trans-unit id="d38b1b6fe53eaefb297f9d879236a334c99468e3" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt;, or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ea0745997af7ee70fec196994401476b7830212" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt; , objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt; .</source>
          <target state="translated">При использовании &lt;code&gt;fd_retrieve&lt;/code&gt; объекты извлекаются последовательно, один объект (т.е. одно рекурсивное дерево) на связанный &lt;code&gt;store_fd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12e3df8bd541ba3c998025aaa4430e3500847d06" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt;, objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d48fc5105eb38ba5d5e3af6a3868bf8d76aac7" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt; ) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt; .</source>
          <target state="translated">При использовании GCC эта запись указывает, что MakeMaker должен сначала искать &lt;code&gt;libgl.a&lt;/code&gt; (а затем &lt;code&gt;gl.a&lt;/code&gt; ) во всех местах, указанных в &lt;code&gt;$Config{libpth}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c8cc8b7dc989aa2e0c54fa773dd36d96d318229" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt;) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c3fbdf4905ed574790e43ad2b1e958281ade4d" translate="yes" xml:space="preserve">
          <source>When using Module::Build, this will usually be:</source>
          <target state="translated">При использовании Module::Build это обычно так и будет:</target>
        </trans-unit>
        <trans-unit id="04e10d3b847f5d46ec45809bdc9654ea510527e6" translate="yes" xml:space="preserve">
          <source>When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly important to not put commas between the constants.</source>
          <target state="translated">При использовании PUSHCOLOR,POPCOLOR и LOCALCOLOR особенно важно не ставить запятую между константами.</target>
        </trans-unit>
        <trans-unit id="0fcdfebaed2e26ac7b40fe2bc2a6520f86b06a73" translate="yes" xml:space="preserve">
          <source>When using Term::ReadLine, you can turn ornaments on so that your input stands out against the output from CPAN.pm.</source>
          <target state="translated">При использовании Term::ReadLine,вы можете включить орнаменты так,чтобы ваш вход выделялся на фоне выхода из CPAN.pm.</target>
        </trans-unit>
        <trans-unit id="3bb24a915046f34ce04a56f60336d0fb58d6c025" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; for file paths.</source>
          <target state="translated">При использовании синтаксиса Unix или MSDOS это имитирует функцию оболочки &lt;code&gt;dirname(1)&lt;/code&gt; которая немного отличается от того, как работает &lt;code&gt;fileparse()&lt;/code&gt; . Он возвращает все, кроме последнего уровня пути к файлу, даже если последний уровень явно является каталогом. Фактически, он возвращает не часть каталога, а просто путь на один уровень выше, действуя как &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; для путей к файлам.</target>
        </trans-unit>
        <trans-unit id="83acdc7454980247f70cca18686669a6056893a4" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;chop()&lt;/code&gt; for file paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd36b103bb843eb67404d1ba086bba3444a9a91a" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt; ).</source>
          <target state="translated">При использовании компилятора, отличного от GCC, в указанной выше записи будет выполняться поиск &lt;code&gt;gl.lib&lt;/code&gt; (за которым следует &lt;code&gt;libgl.lib&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c33d34fd00e0ffeecdde05351cb8111bf653102c" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a204d7a3df2c41a83e110893f714e673583621f8" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="translated">При использовании пользовательского движка, который не поддерживает конструкцию &lt;code&gt;(?:)&lt;/code&gt; для встроенных модификаторов, вероятно, лучше всего использовать &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringify для предоставленного шаблона, обратите внимание, что это создаст нежелательные шаблоны в таких случаях, как:</target>
        </trans-unit>
        <trans-unit id="5336937191442d7debf67f5b96f41e967c4d55af" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;qr//&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa29772ff0d1046f60f263e930495cc6300916c4" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt; , in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="translated">При использовании подписи аргументы по-прежнему доступны в специальной переменной массива &lt;code&gt;@_&lt;/code&gt; в дополнение к лексическим переменным подписи. Есть разница между двумя способами доступа к аргументам: &lt;code&gt;@_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e523513d7b0658b27eb8124687617b728e5c9ac2" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt;, in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551ef8173c29847114a58bb1f60332f351498c93" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt; ), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="translated">При использовании любой из этих подпрограмм (кроме &lt;code&gt;call_argv&lt;/code&gt; ) программист должен управлять стеком Perl. К ним относятся следующие макросы и функции:</target>
        </trans-unit>
        <trans-unit id="b91da188fa3782ad027e51e622e75b65bd3a446d" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt;), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83deb7885e7123190175e707dccaec554d080b8" translate="yes" xml:space="preserve">
          <source>When using look-ahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="translated">При использовании обманчивых утверждений и отрицаний,все это может стать еще более хитрым.Представьте,что вам хотелось бы найти последовательность нецифр,за которой не следует &quot;123&quot;.Вы можете попробовать написать это как</target>
        </trans-unit>
        <trans-unit id="8056637c2c9cbcfa303f8f1dbc6790e418dcb403" translate="yes" xml:space="preserve">
          <source>When using lookahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f069b81fc03a5abd7bd819f6288faad34de8014e" translate="yes" xml:space="preserve">
          <source>When using non-blocking mode, the caller must repeatedly check for writeability on the filehandle (for instance using &lt;code&gt;select&lt;/code&gt; or &lt;code&gt;IO::Poll&lt;/code&gt;). Each time the filehandle is ready to write, the &lt;code&gt;connect&lt;/code&gt; method must be called, with no arguments. Note that some operating systems, most notably &lt;code&gt;MSWin32&lt;/code&gt; do not report a &lt;code&gt;connect()&lt;/code&gt; failure using write-ready; so you must also &lt;code&gt;select()&lt;/code&gt; for exceptional status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104bb1d18df407b49f695cf681f4f8244f6c16f3" translate="yes" xml:space="preserve">
          <source>When using perl on OS/390 please keep in mind that the EBCDIC and ASCII character sets are different. See perlebcdic.pod for more on such character set issues. Perl builtin functions that may behave differently under EBCDIC are also mentioned in the perlport.pod document.</source>
          <target state="translated">При использовании perl на OS/390,пожалуйста,имейте в виду,что наборы символов EBCDIC и ASCII отличаются.Подробнее о таких проблемах с наборами символов смотрите perlebcdic.pod.Встроенные функции Perl,которые могут вести себя по-разному в EBCDIC,также упомянуты в документе perlport.pod.</target>
        </trans-unit>
        <trans-unit id="1ef7e739e319a736386db6464491dd098d4f2bf1" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; . A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt; . (Don't judge me.)</source>
          <target state="translated">При использовании perldoc в режиме &lt;code&gt;-m&lt;/code&gt; (исходный код модуля отображения) &lt;code&gt;perldoc&lt;/code&gt; попытается использовать пейджер, установленный в &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; . Полезной настройкой для этой команды является ваш любимый редактор, например &lt;code&gt;/usr/bin/nano&lt;/code&gt; . (Не судите меня.)</target>
        </trans-unit>
        <trans-unit id="ca44e9fc9c83d8e97acbec5970188d530099b61d" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt;. A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt;. (Don't judge me.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3d08e19ee9978bf8615d5e1fb391a30ff5fc30" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, and the dotted ip string will be returned instead of just the host. If the optional $host argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than syn.</source>
          <target state="translated">При использовании протокола &quot;syn&quot; используйте этот метод для определения доступности удаленного хоста.Предполагается,что этот метод будет вызываться столько раз,сколько было вызвано функцией ping().Каждый вызов возвращает хост (как передается в ping()),который вернулся с TCP ACK.Порядок,в котором возвращаются хосты,может не совпадать с порядком,в котором они были поставлены в очередь SYN с помощью метода ping().Если таймаут достигнут до получения TCP ACK,или если удаленный хост не прослушивает порт,на котором была сделана попытка,то TCP-соединение не будет установлено и ack()вернётся undef.В контексте списка будет возвращен хост,время ack и пунктирная ip-строка,а не только хост.Если указан необязательный аргумент $host,то возвращаемое значение будет относиться только к этому хосту.Этот вызов просто ничего не делает,если вы используете какой-либо протокол,кроме syn.</target>
        </trans-unit>
        <trans-unit id="420afa8aef5868ada909527b4d0cf95eed4c31dc" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, the dotted ip string, and the port number will be returned instead of just the host. If the optional &lt;code&gt;$host&lt;/code&gt; argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than &quot;syn&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8669a447d2a5338b38de691880feda228a223459" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;+&lt;/code&gt; prototype, your function must check that the argument is of an acceptable type.</source>
          <target state="translated">При использовании прототипа &lt;code&gt;+&lt;/code&gt; ваша функция должна проверить, имеет ли аргумент допустимый тип.</target>
        </trans-unit>
        <trans-unit id="665e3521b5bde08e89b6fb412400db5ea3876686" translate="yes" xml:space="preserve">
          <source>When using the Borland compiler, the second item is returned as &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt;, and MakeMaker takes care of moving the &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; to the correct place in the linker command line.</source>
          <target state="translated">При использовании компилятора Borland второй элемент возвращается как &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt; , а MakeMaker заботится о перемещении &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; в нужное место в командной строке компоновщика.</target>
        </trans-unit>
        <trans-unit id="182973d530ef056d12686b9b768cbe121c56d846" translate="yes" xml:space="preserve">
          <source>When using the GUI version of SAM, click on the Kernel Configuration icon, then the Configurable Parameters icon. Scroll down and select the maxdsiz line. From the Actions menu, select the Modify Configurable Parameter item. Insert the new formula into the Formula/Value box. Then follow the instructions to rebuild your kernel and reboot your system.</source>
          <target state="translated">При использовании GUI-версии SAM нажмите на значок &quot;Конфигурация ядра&quot;,затем на значок &quot;Настраиваемые параметры&quot;.Прокрутите вниз и выберите строку Maxdsiz.В меню Actions (Действия)выберите пункт Modify Configurable Parameter (Изменить конфигурируемые параметры).Вставьте новую формулу в поле Формула/Ценность.Затем следуйте инструкциям по перестройке ядра и перезагрузке системы.</target>
        </trans-unit>
        <trans-unit id="7f3f457ad81c7a19053f3621a5ae319fe9cb4521" translate="yes" xml:space="preserve">
          <source>When using the Visual C compiler, the second item is returned as &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt;.</source>
          <target state="translated">При использовании компилятора Visual C второй элемент возвращается как &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa76c289706bb600b3c9b3e3777d7935b3662cb5" translate="yes" xml:space="preserve">
          <source>When using the constants, if you don't want to have to remember to add the &lt;code&gt;, RESET&lt;/code&gt; at the end of each print line, you can set $Term::ANSIColor::AUTORESET to a true value. Then, the display mode will automatically be reset if there is no comma after the constant. In other words, with that variable set:</source>
          <target state="translated">При использовании констант, если вы не хотите помнить о добавлении &lt;code&gt;, RESET&lt;/code&gt; в конце каждой строки печати, вы можете установить для $ Term :: ANSIColor :: AUTORESET истинное значение. Затем режим отображения будет автоматически сброшен, если после константы нет запятой. Другими словами, с этим набором переменных:</target>
        </trans-unit>
        <trans-unit id="a51c1c8c0eb3074d9df3759b3281e7508c8091a5" translate="yes" xml:space="preserve">
          <source>When using this compiler to build Perl, you should make sure that the flag -Aa is added to the cpprun and cppstdin variables in the config.sh file (though see the section on 64-bit perl below). If you are using a recent version of the Perl distribution, these flags are set automatically.</source>
          <target state="translated">При использовании данного компилятора для сборки Perl необходимо убедиться,что в файле config.sh в переменные cpprun и cppstdin добавлен флаг -Aa (хотя смотрите ниже раздел о 64-битном perl).Если вы используете последнюю версию дистрибутива Perl,то эти флаги устанавливаются автоматически.</target>
        </trans-unit>
        <trans-unit id="a190d4d20525775f69d139675c3dc51cef5fb8f2" translate="yes" xml:space="preserve">
          <source>When using tools like &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; that can generate the &lt;code&gt;provides&lt;/code&gt; mapping for your distribution automatically, make sure you examine what it generates to make sure it makes sense - indexers will usually trust the &lt;code&gt;provides&lt;/code&gt; field if it's present, rather than scanning through the distribution files themselves to figure out packages and versions. This is a good thing, because it means you can use the &lt;code&gt;provides&lt;/code&gt; field to tell the indexers precisely what you want indexed about your distribution, rather than relying on them to essentially guess what you want indexed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d278a4b7e876e4a2527267176d89369b93fdace" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">При проверке существующей строки дайджеста вы должны использовать дайджест в качестве соли (например, &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). СОЛЬ, использованная для создания дайджеста, отображается как часть дайджеста. Это гарантирует, что crypt () будет хешировать новую строку с той же солью, что и дайджест. Это позволяет вашему коду работать со стандартной &lt;a href=&quot;crypt&quot;&gt;криптой&lt;/a&gt; и с более экзотическими реализациями. Другими словами, ничего не предполагайте ни о самой возвращаемой строке, ни о том, сколько байтов SALT может иметь значение.</target>
        </trans-unit>
        <trans-unit id="1154d04d428d0c152c2ffba2d49aad6c93079515" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">При проверке существующей строки дайджеста вы должны использовать дайджест в качестве соли (например, &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). СОЛЬ, использованная для создания дайджеста, отображается как часть дайджеста. Это гарантирует, что crypt () будет хешировать новую строку с той же солью, что и дайджест. Это позволяет вашему коду работать со стандартной &lt;a href=&quot;#crypt&quot;&gt;криптой&lt;/a&gt; и с более экзотическими реализациями. Другими словами, ничего не предполагайте ни о самой возвращаемой строке, ни о том, сколько байтов SALT может иметь значение.</target>
        </trans-unit>
        <trans-unit id="213bdf210d4174fda29ca99ffa2edc52c2a2b3fb" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;crypt($plain, $digest) eq $digest&lt;/code&gt;). The SALT used to create the digest is visible as part of the digest. This ensures &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ffe4a395b717a174f8af1eb199172f9bf8e1018" translate="yes" xml:space="preserve">
          <source>When we bless something, we are not blessing the variable which contains a reference to that thing, nor are we blessing the reference that the variable stores; we are blessing the thing that the variable refers to (sometimes known as the</source>
          <target state="translated">Когда мы что-то благословляем,мы не благословляем переменную,содержащую ссылку на эту вещь,и не благословляем ссылку,которую эта переменная хранит;мы благословляем вещь,на которую эта переменная ссылается (иногда известную как</target>
        </trans-unit>
        <trans-unit id="7f1d89cf9a7bec3f0e241604b9f6d2928198590e" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="translated">Когда мы вызываем &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; для переменной, мы фактически благословляем базовую структуру данных, на которую ссылается переменная. Мы не благословляем ни саму ссылку, ни переменную, содержащую эту ссылку. Вот почему второй вызов &lt;code&gt;blessed( $bar )&lt;/code&gt; возвращает false. В этот момент &lt;code&gt;$bar&lt;/code&gt; больше не хранит ссылку на объект.</target>
        </trans-unit>
        <trans-unit id="6555170698fd78a17d09b080573745f1fb3e931d" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;bless&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c70879bf53ea832ca0790a74069f648240179f77" translate="yes" xml:space="preserve">
          <source>When we make a method call, Perl arranges for the method's &lt;b&gt;invocant&lt;/b&gt; to be passed as the first argument. &lt;b&gt;Invocant&lt;/b&gt; is a fancy name for the thing on the left side of the arrow. The invocant can either be a class name or an object. We can also pass additional arguments to the method:</source>
          <target state="translated">Когда мы вызываем метод, Perl &lt;b&gt;принимает меры&lt;/b&gt; для &lt;b&gt;передачи вызывающего&lt;/b&gt; метода в качестве первого аргумента. &lt;b&gt;Invocant&lt;/b&gt; - это причудливое название для предмета слева от стрелки. Вызывающим может быть имя класса или объект. Мы также можем передать методу дополнительные аргументы:</target>
        </trans-unit>
        <trans-unit id="8e5660d78c1c3767afae15f24a83c561307c4b20" translate="yes" xml:space="preserve">
          <source>When we say &quot;Mac OS&quot; below, we mean Mac OS 7, 8, and 9, and</source>
          <target state="translated">Когда мы говорим &quot;Mac OS&quot; ниже,мы имеем в виду Mac OS 7,8 и 9,и</target>
        </trans-unit>
        <trans-unit id="32e492af43a84b7607b727f8ffe43ea47c5296c8" translate="yes" xml:space="preserve">
          <source>When we want to place values to be returned to the caller onto the stack, we use the series of macros that begin with &quot;XPUSH&quot;. There are five different versions, for placing integers, unsigned integers, doubles, strings, and Perl scalars on the stack. In our example, we placed a Perl scalar onto the stack. (In fact this is the only macro which can be used to return multiple values.)</source>
          <target state="translated">Когда мы хотим поместить возвращаемые вызывающему абоненту значения в стек,мы используем серию макросов,которые начинаются с &quot;XPUSH&quot;.Существует пять различных версий,для размещения целых чисел,беззнаковых целых чисел,дубликатов,строк и Perl-скаляров на стеке.В нашем примере мы поместили Perl-скаляр на стек.(На самом деле это единственный макрос,который может быть использован для возврата множественных значений).</target>
        </trans-unit>
        <trans-unit id="5c32617504af087d7eaf74d60f9f81f18d15e5a1" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt; . This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="translated">Когда встречаются слова, длина которых превышает &lt;code&gt;$columns&lt;/code&gt; , они разбиваются. &lt;code&gt;wrap()&lt;/code&gt; добавляет &lt;code&gt;&quot;\n&quot;&lt;/code&gt; в столбец &lt;code&gt;$columns&lt;/code&gt; . Это поведение можно изменить, установив для &lt;code&gt;$huge&lt;/code&gt; значение 'die' или 'overflow'. Если установлено значение 'die', большие слова будут вызывать вызов &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; . Если установлено значение &amp;laquo;переполнение&amp;raquo;, большие слова останутся нетронутыми.</target>
        </trans-unit>
        <trans-unit id="5ebaaddfa0e00536f0f1b77f056696aff48f065e" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt;. This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;die()&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a8fd5862d63d0243193e3a0106e35c7816b525" translate="yes" xml:space="preserve">
          <source>When writing a DBM filter it is</source>
          <target state="translated">При написании DBM-фильтра это</target>
        </trans-unit>
        <trans-unit id="6e29ef5da6dd2ada1107f66b4d19daef44972a34" translate="yes" xml:space="preserve">
          <source>When writing a Perl extension for general consumption, one should expect that the extension will be used with versions of Perl different from the version available on your machine. Since you are reading this document, the version of Perl on your machine is probably 5.005 or later, but the users of your extension may have more ancient versions.</source>
          <target state="translated">При написании расширения Perl для общего потребления следует ожидать,что это расширение будет использоваться с версиями Perl,отличными от версии,доступной на вашей машине.Поскольку вы читаете этот документ,версия Perl на вашей машине,вероятно,5.005 или более поздняя,но у пользователей вашего расширения могут быть более древние версии.</target>
        </trans-unit>
        <trans-unit id="b339c5d874b742d033a9c15bc59a2eb32b3fde03" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt; , unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt; .</source>
          <target state="translated">При записи символа UV в строку UTF-8 &lt;b&gt;всегда&lt;/b&gt; используйте &lt;code&gt;uvchr_to_utf8&lt;/code&gt; , если только &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; в этом случае вы можете использовать &lt;code&gt;*s = uv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ffec04c54d59e59616907c7e9e4db0144cb75f4" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt;, unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f50a991a4544cc3b4a29ac32fb9e95a158b8cf9" translate="yes" xml:space="preserve">
          <source>When writing a gzip file this interface will</source>
          <target state="translated">При записи gzip-файла этот интерфейс будет</target>
        </trans-unit>
        <trans-unit id="bb628954db56a328fb9c77ac1ab1c6c9e5566f04" translate="yes" xml:space="preserve">
          <source>When writing to a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before writing to the file.</source>
          <target state="translated">При записи в файл или дескриптор файла установите &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; перед записью в файл.</target>
        </trans-unit>
        <trans-unit id="b83d473ca051f901386a9b5075ab3cc8642b96d1" translate="yes" xml:space="preserve">
          <source>When you</source>
          <target state="translated">Когда ты</target>
        </trans-unit>
        <trans-unit id="2677cbf7ed31e30ff85aaafd2211c14bcf4260ba" translate="yes" xml:space="preserve">
          <source>When you are content with suspects list, you can now</source>
          <target state="translated">Когда вы довольны списком подозреваемых,вы можете теперь</target>
        </trans-unit>
        <trans-unit id="2f2f89e3cbdda44107d5b7350f0150202920760d" translate="yes" xml:space="preserve">
          <source>When you are done, the XS-module install process will have added information to your &quot;perllocal&quot; information telling that the perl binary has been replaced, and what module was installed. You can view this information at any time by using the command:</source>
          <target state="translated">Когда вы закончите,процесс установки XS-модуля добавит в вашу &quot;perllocal&quot; информацию о том,что бинарник perl был заменён,и какой модуль был установлен.Вы можете просмотреть эту информацию в любое время с помощью команды:</target>
        </trans-unit>
        <trans-unit id="b326342faabbb3f551d027918413fb764e7ae496" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself (if you feel masochistic enough) from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c482f23205d9f8b77692de807395bf57f9f55a5" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself (if you feel masochistic enough) from the sources (available from e.g. &lt;a href=&quot;https://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081b49cdc45047c15c231503ee57d721c9ac98ea" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="translated">Если вы собираетесь использовать компилятор GNU C (gcc), но у вас еще нет gcc, вы можете либо собрать его самостоятельно из источников (доступных, например, по &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;адресу http://gcc.gnu.org/mirrors.html&lt;/a&gt; ) или загрузите предварительно созданный двоичный файл из центра портирования HP по адресу &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; или из DSPP (вы должны быть участником) по адресу &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http : //h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801? ciid = 2a08725cc2f02110725cc2f02110275d6e10RCRD &amp;amp; jumpid = reg_r100_r1002_usen&lt;/a&gt; , так как часто доступны несколько версий пакета, так как список пакетов от.</target>
        </trans-unit>
        <trans-unit id="1e1fba30b9427287c1016e2b2ee037287889c225" translate="yes" xml:space="preserve">
          <source>When you are manually creating a UCM file, you should copy ascii.ucm or an existing encoding which is close to yours, rather than write your own from scratch.</source>
          <target state="translated">Когда вы вручную создаете UCM файл,вы должны скопировать ascii.ucm или существующую кодировку,которая близка к вашей,вместо того,чтобы писать свою собственную с нуля.</target>
        </trans-unit>
        <trans-unit id="4780d196081ec9146c3e56c719b52c3ce1654983" translate="yes" xml:space="preserve">
          <source>When you are satisfied with the results of tests, install the build C libraries for extensions:</source>
          <target state="translated">Когда вы будете удовлетворены результатами тестов,установите библиотеки сборки C для расширений:</target>
        </trans-unit>
        <trans-unit id="a59f72a1e66eb8909341fcc7e63f4b0c726287dd" translate="yes" xml:space="preserve">
          <source>When you are sure that only a few subdirectories lead to failures, you may want to add &lt;code&gt;-j4&lt;/code&gt; option to &lt;code&gt;make&lt;/code&gt; to speed up skipping subdirectories with already finished build.</source>
          <target state="translated">Если вы уверены , что только несколько подкаталогов привести к сбоям, вы можете добавить &lt;code&gt;-j4&lt;/code&gt; вариант &lt;code&gt;make&lt;/code&gt; , чтобы ускорить пропуск подкаталогов с уже готовой сборкой.</target>
        </trans-unit>
        <trans-unit id="7b2f8e90d6f4d4294f6e2dcda859cd96193b4ae7" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;icmp&quot; protocol, this call permit to change the message type to 'echo' or 'timestamp' (only for IPv4, see RFC 792).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0610c400691e07d6b5c5967ea7cb5f197bdd7da" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="translated">Когда вы используете &amp;laquo;потоковый&amp;raquo; протокол, этот вызов предварительно открывает TCP-сокет. Это необходимо только в том случае, если вы хотите указать другой тайм-аут при создании соединения или удалить накладные расходы на установление соединения из первого эхо-запроса. Если вы не вызываете &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; , соединение автоматически открывается при первом вызове &lt;code&gt;ping()&lt;/code&gt; . Этот вызов просто ничего не делает, если вы используете какой-либо протокол, кроме потока.</target>
        </trans-unit>
        <trans-unit id="53d7ace59a255ce0dee603a0e82c9350ed60c845" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;open()&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19030bdd1652e63fb5fe9a91af20f3234d06d23f" translate="yes" xml:space="preserve">
          <source>When you assign a list of scalars to an array, all previous values in that array are wiped out and the number of elements in the array will now be equal to the number of elements in the right-hand list -- the list from which assignment was made. The array will automatically resize itself to precisely accommodate each element in the right-hand list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9fd269eddc721c08a06a789973e8783627db576" translate="yes" xml:space="preserve">
          <source>When you build modules, tell Perl where to install the modules.</source>
          <target state="translated">Когда вы собираете модули,скажите Perl,где установить модули.</target>
        </trans-unit>
        <trans-unit id="d2efe854f0b34964ee2879b9748bb899c2079d18" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt; :</source>
          <target state="translated">Когда вы вызываете &lt;code&gt;bar&lt;/code&gt; с аргументами, вы видите, что &lt;code&gt;foo&lt;/code&gt; имеет то же &lt;code&gt;@_&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c91152667ee3ebf07dbc40066530c9ec19f3697d" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835f87385a105654b52b3b81d31156a333d91b09" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;open&lt;/code&gt; this way, Perl invokes the given command directly, bypassing the shell. As such, the shell won't try to interpret any special characters within the command's argument list, which might overwise have unwanted effects. This can make for safer, less error-prone &lt;code&gt;open&lt;/code&gt; calls, useful in cases such as passing in variables as arguments, or even just referring to filenames with spaces in them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685020a1713f908c5ec69a7f573fc741004b77c1" translate="yes" xml:space="preserve">
          <source>When you call Perl's &lt;code&gt;open&lt;/code&gt; to set a Perl file handle [like &lt;code&gt;STDOUT&lt;/code&gt;], Perl calls C's &lt;code&gt;fopen&lt;/code&gt; to set a stdio &lt;code&gt;FILE *&lt;/code&gt;. C's &lt;code&gt;fopen&lt;/code&gt; calls something like Unix's &lt;code&gt;open&lt;/code&gt;, that is, Win32's &lt;code&gt;_sopen&lt;/code&gt;, to get an integer file descriptor [where 0 is for &lt;code&gt;STDIN&lt;/code&gt;, 1 for &lt;code&gt;STDOUT&lt;/code&gt;, etc.]. Win32's &lt;code&gt;_sopen&lt;/code&gt; calls &lt;code&gt;CreateFile&lt;/code&gt; to set a &lt;code&gt;HANDLE&lt;/code&gt;, a Win32 native file handle. So every Perl file handle [like &lt;code&gt;STDOUT&lt;/code&gt;] has an integer file descriptor associated with it that you can get via &lt;code&gt;fileno&lt;/code&gt;. And, under Win32, every file descriptor has a Win32 native file handle associated with it. &lt;code&gt;FdGetOsFHandle&lt;/code&gt; lets you get access to that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e313737a6b3963a3bf8908006a0a820d6e4555f" translate="yes" xml:space="preserve">
          <source>When you call a fully qualified method name like &lt;code&gt;File::save&lt;/code&gt;, the method resolution search for the &lt;code&gt;save&lt;/code&gt; method starts in the &lt;code&gt;File&lt;/code&gt; class, skipping any &lt;code&gt;save&lt;/code&gt; method the &lt;code&gt;File::MP3&lt;/code&gt; class may have defined. It still searches the &lt;code&gt;File&lt;/code&gt; class's parents if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010f5217ea46f708fe21b0efa65632329708b27e" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; , the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; , the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt; .</source>
          <target state="translated">Когда вы вызываете метод, то, что находится слева от стрелки, передается в качестве первого аргумента метода. Это означает, что когда мы вызываем &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; , метод &lt;code&gt;new()&lt;/code&gt; получает строку &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; качестве своего первого аргумента. Когда мы вызываем &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; , переменная &lt;code&gt;$fred&lt;/code&gt; передается как первый аргумент для &lt;code&gt;speak()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fae81431a82ed2b7245ab26b577216b20acfee24" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt;, the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt;, the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210c4bda966e8ba5f3d3dd89593f4b86c57dc0ef" translate="yes" xml:space="preserve">
          <source>When you call the &lt;code&gt;tie&lt;/code&gt; function to bind an associative array to this package, you may specify as an optional argument the symbol table in which you wish to create and delete symbols. If the argument is the string 'GLOBAL', then the global symbol table is used; any other string causes the local symbol table to be used. Note that this argument does not affect attempts to read symbols; if a symbol with the specified name exists in the local symbol table, it is always returned in preference to a symbol by the same name in the global symbol table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ac7d5348373bdb94113353aa9433d2aa26a56e" translate="yes" xml:space="preserve">
          <source>When you change a &lt;b&gt;value&lt;/b&gt; as it is being copied. [From French &amp;ldquo;in passing&amp;rdquo;, as in the exotic pawn-capturing maneuver in chess.]</source>
          <target state="translated">Когда вы изменяете &lt;b&gt;значение&lt;/b&gt; в процессе его копирования. [От французского &amp;laquo;попутно&amp;raquo;, как в экзотическом маневре с захватом пешки в шахматах.]</target>
        </trans-unit>
        <trans-unit id="f19e6c82fbc2b2542cdae76f95f1a0c2e0deb19b" translate="yes" xml:space="preserve">
          <source>When you chop() a mathemagical object it is promoted to a string and its mathemagical properties are lost. The same can happen with other operations as well.</source>
          <target state="translated">При chop()математическом объекте он переходит в строку и его математические свойства теряются.То же самое может произойти и с другими операциями.</target>
        </trans-unit>
        <trans-unit id="ffb591449d98f90fa2f19a8fc5d8c220dd517b21" translate="yes" xml:space="preserve">
          <source>When you combine legacy data and Unicode, the legacy data needs to be upgraded to Unicode. Normally the legacy data is assumed to be ISO 8859-1 (or EBCDIC, if applicable).</source>
          <target state="translated">При объединении устаревших данных и Юникода,устаревшие данные необходимо обновить до Юникода.Обычно считается,что устаревшие данные соответствуют стандарту ISO 8859-1 (или EBCDIC,если применимо).</target>
        </trans-unit>
        <trans-unit id="177eeefc399a73cfd5bfb70b98c9df5de8601114" translate="yes" xml:space="preserve">
          <source>When you create a map, you SHOULD make your mappings round-trip safe. That is, &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq
$data&lt;/code&gt; stands for all characters that are marked as &lt;code&gt;|0&lt;/code&gt;. Here is how to make sure:</source>
          <target state="translated">Когда вы создаете карту, вы ДОЛЖНЫ сделать ваши сопоставления безопасными. То есть &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq $data&lt;/code&gt; обозначает все символы, помеченные как &lt;code&gt;|0&lt;/code&gt; . Вот как в этом убедиться:</target>
        </trans-unit>
        <trans-unit id="bb9cd7b8a4ff60818aa2eb01184f94103173f0c2" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt; .</source>
          <target state="translated">Когда вы объявляете константу, такую ​​как &lt;code&gt;PI&lt;/code&gt; , используя метод, показанный выше, каждая машина, на которой запускается ваш скрипт, может иметь столько цифр точности, сколько она может использовать. Кроме того, вашу программу будет легче читать, с большей вероятностью будет поддерживаться (и правильно обслуживаться) и гораздо меньше шансов отправить космический зонд не на ту планету, потому что никто не заметил одно уравнение, в котором вы написали &lt;code&gt;3.14195&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e2b5a1dcab630574856b807ba52f00dea975f20" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ad5430f738cd6a6ba4f6afa7a8297067c10fdd" translate="yes" xml:space="preserve">
          <source>When you decode(=?</source>
          <target state="translated">Когда вы декодируете(=?</target>
        </trans-unit>
        <trans-unit id="1f9cd5bf8b9a9dc5c6c543459671e6a174da6ded" translate="yes" xml:space="preserve">
          <source>When you decode, &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; is inserted for a malformed character, where</source>
          <target state="translated">Когда вы декодируете, &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; вставляется для искаженного символа, где</target>
        </trans-unit>
        <trans-unit id="3c3e41e00e97aaa41946f9404604a3e16daeabbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8903ce8817b2306a386e9e7bf122e6808d15508e" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b2a9b37643890f116ac0184e9ac142f63cbe26" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3fe5c47178db8be10e4d3c50152806e0a7dfbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="translated">Когда вы выполняете $ parser-&amp;gt; get_token для объекта &lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; , вы можете получить объект этого класса.</target>
        </trans-unit>
        <trans-unit id="fdee2ab8e3f283c88595afe8fae4920b1af2e43f" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="translated">Когда вы выполняете $ parser-&amp;gt; get_token для &lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; , вы можете получить объект этого класса.</target>
        </trans-unit>
        <trans-unit id="e49f09f58c9d01d7e0d1ab18e02275ef3d85f650" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="translated">Когда вы выполняете $ parser-&amp;gt; get_token для &lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; , вы должны получить объект подкласса Pod :: Simple :: PullParserToken.</target>
        </trans-unit>
        <trans-unit id="e5d10bb84f2ae2965aec52096372e0823e1ccc9f" translate="yes" xml:space="preserve">
          <source>When you do an open() and specify extra PerlIO layers to be deployed, the layers you specify are &quot;pushed&quot; on top of the already existing default stack. One way to see it is that &quot;operating system is on the left&quot; and &quot;Perl is on the right&quot;.</source>
          <target state="translated">Когда вы делаете open()и указываете дополнительные слои PerlIO,которые должны быть развернуты,слои,которые вы указываете,&quot;толкаются&quot; поверх уже существующего стека по умолчанию.Один из способов увидеть это-&quot;операционная система слева&quot; и &quot;Perl справа&quot;.</target>
        </trans-unit>
        <trans-unit id="deae100a89ba77dc88cb549c116cc2863e7500d7" translate="yes" xml:space="preserve">
          <source>When you do so, make sure you leave at least &lt;b&gt;U0000&lt;/b&gt; to &lt;b&gt;U0020&lt;/b&gt; as is, unless your environment is EBCDIC.</source>
          <target state="translated">Когда вы это сделаете, убедитесь, что вы оставили по крайней мере от &lt;b&gt;U0000&lt;/b&gt; до &lt;b&gt;U0020&lt;/b&gt; как есть, если ваша среда не EBCDIC.</target>
        </trans-unit>
        <trans-unit id="5f9d98bf0fca35661c7810840d0018afb1d2ce55" translate="yes" xml:space="preserve">
          <source>When you do this, you replace ordinary Perl ops with custom ops by creating ops with the type &lt;code&gt;OP_CUSTOM&lt;/code&gt; and the &lt;code&gt;op_ppaddr&lt;/code&gt; of your own PP function. This should be defined in XS code, and should look like the PP ops in &lt;code&gt;pp_*.c&lt;/code&gt;. You are responsible for ensuring that your op takes the appropriate number of values from the stack, and you are responsible for adding stack marks if necessary.</source>
          <target state="translated">Когда вы это делаете, вы заменяете обычные &lt;code&gt;OP_CUSTOM&lt;/code&gt; &lt;code&gt;op_ppaddr&lt;/code&gt; на собственные операции, создавая операции с типом OP_CUSTOM и op_ppaddr вашей собственной функции PP. Это должно быть определено в XS код, и должен выглядеть ПП опы &lt;code&gt;pp_*.c&lt;/code&gt; . Вы несете ответственность за то, чтобы ваш оператор взял соответствующее количество значений из стека, и вы несете ответственность за добавление меток стека, если это необходимо.</target>
        </trans-unit>
        <trans-unit id="f0737e549db78c3f56b6cebadc591bd894132914" translate="yes" xml:space="preserve">
          <source>When you encode, it just encodes UTF-8 string with</source>
          <target state="translated">Когда вы кодируете,он просто кодирует UTF-8 строку с помощью</target>
        </trans-unit>
        <trans-unit id="2cb93abd34cd25594e79f391f2b423cc436f1f2e" translate="yes" xml:space="preserve">
          <source>When you execute this script, Perl creates a source stream for the file. Before the parser processes any of the lines from the file, the source stream looks like this:</source>
          <target state="translated">При выполнении этого скрипта Perl создает исходный поток для файла.Перед тем,как синтаксический анализатор обработает какую-либо строку из файла,исходный поток выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="c978bab6e05df288a1696970dbd630fd132c029f" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;Data::Dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542d61dee2b7e163e5110ea366ba8573d821b115" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="translated">Когда вам надоест писать нестандартную печать для ваших структур данных, вы можете взглянуть на стандартные &lt;a href=&quot;dumpvalue&quot;&gt;модули Dumpvalue&lt;/a&gt; или &lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt; . Первый - это то, что использует отладчик Perl, а второй генерирует анализируемый код Perl. Например:</target>
        </trans-unit>
        <trans-unit id="18b18f51c5b3a1ef29698b4db45e17c63b163a2a" translate="yes" xml:space="preserve">
          <source>When you have Module::Build installed and a module comes with both a Makefile.PL and a Build.PL, which shall have precedence?</source>
          <target state="translated">Когда у вас установлен Module::Build и модуль поставляется как с Makefile.PL,так и с Build.PL,что должно иметь приоритет?</target>
        </trans-unit>
        <trans-unit id="90be52d2f2a07a95a09a611578f9d43f7cd9edea" translate="yes" xml:space="preserve">
          <source>When you have Term::ANSIColor installed, you can turn on colorized output to have some visual differences between normal CPAN.pm output, warnings, debugging output, and the output of the modules being installed. Set your favorite colors after some experimenting with the Term::ANSIColor module.</source>
          <target state="translated">Когда у вас установлен Term::ANSIColor,вы можете включить цветной вывод,чтобы иметь некоторые визуальные различия между обычным выводом CPAN.pm,предупреждениями,отладочным выводом и выводом устанавливаемых модулей.Установите ваши любимые цвета после некоторых экспериментов с модулем Term::ANSIColor.</target>
        </trans-unit>
        <trans-unit id="805d35dab8fe4274cb0dab9ee72a05d301e431cf" translate="yes" xml:space="preserve">
          <source>When you have a &lt;code&gt;$normalized&lt;/code&gt; string and an &lt;code&gt;$unnormalized&lt;/code&gt; string following it, a simple concatenation is wrong:</source>
          <target state="translated">Когда у вас есть &lt;code&gt;$normalized&lt;/code&gt; строка &lt;code&gt;$unnormalized&lt;/code&gt; следующая за ней ненормализованная строка, простое объединение неверно:</target>
        </trans-unit>
        <trans-unit id="5fc33624ab4cb034a50a1d77e4381e870301d931" translate="yes" xml:space="preserve">
          <source>When you have a duplicate entry, mark either one with '|1' or '|3'.</source>
          <target state="translated">Когда у вас есть дубликат записи,отметьте его '|1' или '|3'.</target>
        </trans-unit>
        <trans-unit id="c0776eaeac3f4218a7b8598aad81420ef0246911" translate="yes" xml:space="preserve">
          <source>When you list the arguments to the XSUB in the .xs file, that tells &lt;b&gt;xsubpp&lt;/b&gt; which argument corresponds to which of the argument stack (i.e., the first one listed is the first argument, and so on). You invite disaster if you do not list them in the same order as the function expects them.</source>
          <target state="translated">Когда вы перечисляете аргументы для XSUB в файле .xs, это сообщает &lt;b&gt;xsubpp,&lt;/b&gt; какой аргумент соответствует какому из стека аргументов (т. &lt;b&gt;Е.&lt;/b&gt; Первый из перечисленных аргументов является первым аргументом и т. Д.). Вы приглашаете к катастрофе, если не перечисляете их в том же порядке, в каком их ожидает функция.</target>
        </trans-unit>
        <trans-unit id="4fe7c5d2090255d1c2f0cf1a507f4b889f93bbfd" translate="yes" xml:space="preserve">
          <source>When you make a script executable, in order to make it usable as a command, the system will pass switches to perl from the script's #! line. Perl checks that any command line switches given to a setuid (or setgid) script actually match the ones set on the #! line. Some Unix and Unix-like environments impose a one-switch limit on the #! line, so you may need to use something like &lt;code&gt;-wU&lt;/code&gt; instead of &lt;code&gt;-w -U&lt;/code&gt; under such systems. (This issue should arise only in Unix or Unix-like environments that support #! and setuid or setgid scripts.)</source>
          <target state="translated">Когда вы создаете исполняемый файл сценария, чтобы его можно было использовать в качестве команды, система передаст переключатели на perl из сценария #! линия. Perl проверяет, что любые параметры командной строки, заданные для сценария setuid (или setgid), действительно соответствуют параметрам, установленным в #! линия. Некоторые Unix и Unix-подобные среды накладывают ограничение в один переключатель на #! строка, поэтому вам может потребоваться использовать что-то вроде &lt;code&gt;-wU&lt;/code&gt; вместо &lt;code&gt;-w -U&lt;/code&gt; в таких системах. (Эта проблема должна возникать только в Unix или Unix-подобных средах, которые поддерживают сценарии #! И setuid или setgid.)</target>
        </trans-unit>
        <trans-unit id="66b392aea5e0dde426270cd749894810ea22ea80" translate="yes" xml:space="preserve">
          <source>When you obtain a context object it is made specifically for your tool and any tools nested within. If you pass a context around you run the risk of polluting other tools with incorrect context information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95cff40ad5c3e10b014358530a3857e4311a17f" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;).</source>
          <target state="translated">Когда вы переопределяете встроенный, ваша замена должна согласовываться (если возможно) со встроенным собственным синтаксисом. Добиться этого можно с помощью подходящего прототипа. Чтобы получить прототип переопределяемого встроенного модуля, используйте функцию &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; с аргументом &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (см. &lt;a href=&quot;functions/prototype&quot;&gt;Прототип&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="403deb8cf132584282b80991028fcc8f4fae8ae6" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;prototype&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;perlfunc#prototype&quot;&gt;&quot;prototype&quot; in perlfunc&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde2c695557d23e73e52834a17ed471dd59562aa" translate="yes" xml:space="preserve">
          <source>When you replace this variable, it is considered a good practice to store the possibly previously installed hook and that you recall it inside your own.</source>
          <target state="translated">Когда вы заменяете эту переменную,считается хорошей практикой хранить,возможно,ранее установленный крюк,и что вы помните его внутри своего собственного.</target>
        </trans-unit>
        <trans-unit id="582bd31e20cc087ebfe2ecd8d499eadfcfa005d7" translate="yes" xml:space="preserve">
          <source>When you run Makefile.PL, it makes a Makefile. That's the whole point of MakeMaker. The Makefile.PL is a simple program which loads ExtUtils::MakeMaker and runs the WriteMakefile() function to generate a Makefile.</source>
          <target state="translated">Когда вы запускаете Makefile.PL,он делает Makefile.В этом весь смысл MakeMaker.Makefile.PL-это простая программа,которая загружает ExtUtils::MakeMaker и запускает функцию WriteMakefile()для генерации Makefile.</target>
        </trans-unit>
        <trans-unit id="b579e440e9d1d7b9d0889bfe36abfaf0be29b72d" translate="yes" xml:space="preserve">
          <source>When you run a Perl script, something else is running the script for you, and that something else may output error messages. The script might emit its own warnings and error messages. Most of the time you cannot tell who said what.</source>
          <target state="translated">Когда вы запускаете Perl скрипт,что-то другое запускает скрипт для вас,и что-то другое может выдать сообщения об ошибках.Сценарий может выдавать свои собственные предупреждения и сообщения об ошибках.В большинстве случаев вы не можете сказать,кто что сказал.</target>
        </trans-unit>
        <trans-unit id="b459c97000689bfb2a9636d9e9707ca71827210e" translate="yes" xml:space="preserve">
          <source>When you run this program, you should get something back that looks like this:</source>
          <target state="translated">Когда вы запустите эту программу,вы должны получить что-то,что выглядит так:</target>
        </trans-unit>
        <trans-unit id="a4188abf09b28b37cfb9f20a3ac1868d9c6a543c" translate="yes" xml:space="preserve">
          <source>When you say &quot;make test&quot;, Perl uses the</source>
          <target state="translated">Когда вы говорите &quot;сделать тест&quot;,Перл использует</target>
        </trans-unit>
        <trans-unit id="76a6e68fd11c4b70b5a87d525381faf69633be4b" translate="yes" xml:space="preserve">
          <source>When you say &lt;code&gt;make test&lt;/code&gt; it will run with taint mode on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7919c60f354343e7a5369000b965c8d2d0632381" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt; . Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="translated">Когда вы видите &lt;code&gt;charset=gb2312&lt;/code&gt; в сообщениях электронной почты и на веб-страницах, они действительно имеют в виду &lt;code&gt;euc-cn&lt;/code&gt; . Чтобы исправить это, &lt;code&gt;gb2312&lt;/code&gt; имеет псевдоним &lt;code&gt;euc-cn&lt;/code&gt; . Используйте &lt;code&gt;gb2312-raw&lt;/code&gt; , когда действительно имеете в виду.</target>
        </trans-unit>
        <trans-unit id="8c4e1c3fce7decd6f02607f653534397608ae09a" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt;. Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17139aebb0fce79faa8dece070270ecb6b39cc8b" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; on mails and web pages, they really mean &quot;cp949&quot; encodings. To fix that, the following aliases are set;</source>
          <target state="translated">Когда вы видите &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; в сообщениях электронной почты и на веб-страницах, они действительно имеют в виду кодировки &quot;cp949&quot;. Чтобы исправить это, устанавливаются следующие псевдонимы;</target>
        </trans-unit>
        <trans-unit id="bed16d4ef44043e0ee787c3f181832f24be03ea6" translate="yes" xml:space="preserve">
          <source>When you speak one language and the computer thinks you&amp;rsquo;re speaking another. You&amp;rsquo;ll see odd translations when you send UTF‑8, for instance, but the computer thinks you sent Latin-1, showing all sorts of weird characters instead. The term is written 「文字化け」in Japanese and means &amp;ldquo;character rot&amp;rdquo;, an apt description. Pronounced [&lt;code&gt;modʑibake&lt;/code&gt; ] in standard &lt;b&gt;IPA&lt;/b&gt; phonetics, or approximately &amp;ldquo;moh-jee-bah-keh&amp;rdquo;.</source>
          <target state="translated">Когда вы говорите на одном языке, а компьютер думает, что вы говорите на другом. Вы увидите странные переводы, например, при отправке UTF ‑ 8, но компьютер думает, что вы отправили Latin-1, вместо этого показывая всевозможные странные символы. Этот термин пишется на японском 文字 化 け 」и означает&amp;laquo; гниль характера &amp;raquo;, подходящее описание. Произносится [ &lt;code&gt;modʑibake&lt;/code&gt; ] в стандартной фонетике &lt;b&gt;IPA&lt;/b&gt; , или приблизительно &amp;laquo;мо-джи-ба-кех&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7ef09f89e47adf28a99fbbb7052a436221dbcca0" translate="yes" xml:space="preserve">
          <source>When you speak one language and the computer thinks you&amp;rsquo;re speaking another. You&amp;rsquo;ll see odd translations when you send UTF‑8, for instance, but the computer thinks you sent Latin-1, showing all sorts of weird characters instead. The term is written 「文字化け」in Japanese and means &amp;ldquo;character rot&amp;rdquo;, an apt description. Pronounced [&lt;code&gt;modʑibake&lt;/code&gt;] in standard &lt;b&gt;IPA&lt;/b&gt; phonetics, or approximately &amp;ldquo;moh-jee-bah-keh&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="665a5769943788c4623d27cfed3bae7f7e133317" translate="yes" xml:space="preserve">
          <source>When you specify arguments to routines in the .xs file, you are really passing three pieces of information for each argument listed. The first piece is the order of that argument relative to the others (first, second, etc). The second is the type of argument, and consists of the type declaration of the argument (e.g., int, char*, etc). The third piece is the calling convention for the argument in the call to the library function.</source>
          <target state="translated">Когда вы указываете аргументы в подпрограмме в файле .xs,вы действительно передаете три части информации для каждого из перечисленных аргументов.Первая часть-это порядок следования этого аргумента по отношению к другим (первый,второй и т.д.).Второй-это тип аргумента и состоит из объявления типа аргумента (например,int,char*и т.д.).Третья часть-вызывающая конвенция для аргумента при вызове библиотечной функции.</target>
        </trans-unit>
        <trans-unit id="92bc744ea7824ccea4eeb23e82728fbc4ddab899" translate="yes" xml:space="preserve">
          <source>When you supply a separate display name it becomes possible to run a test more than once; the display name is effectively the alias by which the test is known inside the harness. The harness doesn't care if it runs the same test more than once when each invocation uses a different name.</source>
          <target state="translated">При вводе отдельного отображаемого имени становится возможным проводить тест несколько раз;отображаемое имя фактически является псевдонимом,по которому тест известен внутри жгута.Если один и тот же тест будет выполняться несколько раз,то жгут не будет заботиться о том,чтобы он выполнялся несколько раз при каждом вызове под разным именем.</target>
        </trans-unit>
        <trans-unit id="f5d8e81bcb99e99cbe008b301dbaa4156e030e10" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to lock the file, &lt;code&gt;Tie::File&lt;/code&gt; assumes that the read cache is no longer trustworthy, because another process might have modified the file since the last time it was read. Therefore, a successful call to &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; discards the contents of the read cache and the internal record offset table.</source>
          <target state="translated">Когда вы используете &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; для блокировки файла, &lt;code&gt;Tie::File&lt;/code&gt; предполагает, что кэш чтения больше не заслуживает доверия, потому что другой процесс мог изменить файл с момента последнего чтения. Следовательно, успешный вызов &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; отбрасывает содержимое кэша чтения и таблицы смещения внутренней записи.</target>
        </trans-unit>
        <trans-unit id="86d314b9ffee5484e299c428ac086a5864115f83" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;flock&lt;/code&gt; to lock the file, &lt;code&gt;Tie::File&lt;/code&gt; assumes that the read cache is no longer trustworthy, because another process might have modified the file since the last time it was read. Therefore, a successful call to &lt;code&gt;flock&lt;/code&gt; discards the contents of the read cache and the internal record offset table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1ea55b20ff67d97a482097e7d303cd94b1b34c" translate="yes" xml:space="preserve">
          <source>When you use Perl from C, your C program will--usually--allocate, &quot;run&quot;, and deallocate a</source>
          <target state="translated">Когда Вы используете Perl из C,Ваша программа на C будет...обычно...выделять,&quot;запускать&quot;,а также распределять</target>
        </trans-unit>
        <trans-unit id="5b4b7e46fe751c099868927c5d1568ad4f11af65" translate="yes" xml:space="preserve">
          <source>When you use the &lt;b&gt;-n&lt;/b&gt; and &lt;b&gt;-p&lt;/b&gt; switches to Perl, &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; work just as they do in &lt;b&gt;awk&lt;/b&gt;, as a degenerate case. Both &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; blocks are run when you use the &lt;b&gt;-c&lt;/b&gt; switch for a compile-only syntax check, although your main code is not.</source>
          <target state="translated">Когда вы используете переключатели &lt;b&gt;-n&lt;/b&gt; и &lt;b&gt;-p&lt;/b&gt; для Perl, &lt;code&gt;BEGIN&lt;/code&gt; и &lt;code&gt;END&lt;/code&gt; работают так же, как и в &lt;b&gt;awk&lt;/b&gt; , но в вырожденном случае. И &lt;code&gt;BEGIN&lt;/code&gt; и &lt;code&gt;CHECK&lt;/code&gt; блоки выполняются при использовании &lt;b&gt;-c&lt;/b&gt; переключателя для компиляции только проверки синтаксиса, хотя ваш основной код не является.</target>
        </trans-unit>
        <trans-unit id="6e7c5168dc3e4d09a86a5c07db61ae55b067c306" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or Perl's &lt;b&gt;-w&lt;/b&gt; command-line option, you may see warnings about useless uses of constants or functions in &quot;void context&quot;. Void context just means the value has been discarded, such as a statement containing only &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt;. It still counts as scalar context for functions that care whether or not they're being called in list context.</source>
          <target state="translated">При использовании &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; прагмы или Perl в &lt;b&gt;-w&lt;/b&gt; параметра командной строки, вы можете увидеть предупреждение о бесполезном использовании констант и функций в &amp;laquo;пустом контексте&amp;raquo;. Пустой контекст просто означает, что значение было отброшено, например, утверждение, содержащее только &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt; . Он по-прежнему считается скалярным контекстом для функций, которые заботятся о том, вызываются ли они в контексте списка.</target>
        </trans-unit>
        <trans-unit id="21a0f043d5bac1b816d417902a549ec51099c064" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;use warnings&lt;/code&gt; pragma or Perl's &lt;b&gt;-w&lt;/b&gt; command-line option, you may see warnings about useless uses of constants or functions in &quot;void context&quot;. Void context just means the value has been discarded, such as a statement containing only &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; or &lt;code&gt;getpwuid(0);&lt;/code&gt;. It still counts as scalar context for functions that care whether or not they're being called in list context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f561cbf428cfa38a570f079c8fe3f1e6c4934924" translate="yes" xml:space="preserve">
          <source>When you want to encode Unicode for mails and web pages, however, do not use UTF-7 unless you are sure your recipients and readers can handle it. Very few MUAs and WWW Browsers support these days (only Mozilla seems to support one). For general cases, use UTF-8 for message body and MIME-Header for header instead.</source>
          <target state="translated">Однако,когда вы хотите кодировать Unicode для писем и веб-страниц,не используйте UTF-7,если вы не уверены,что ваши получатели и читатели могут справиться с этим.Очень немногие MUA и WWW-браузеры поддерживают в наши дни (кажется,только Mozilla поддерживает один).Для общих случаев,используйте UTF-8 для тела сообщения и MIME-Header для заголовка.</target>
        </trans-unit>
        <trans-unit id="d1594b9a6f30c884e42aa7810e12c05455ffa364" translate="yes" xml:space="preserve">
          <source>When you want to write to a file, you first have to decide what to do about any existing contents of that file. You have two basic choices here: to preserve or to clobber.</source>
          <target state="translated">Когда вы хотите записать в файл,вам сначала нужно решить,что делать с любым существующим содержимым этого файла.Здесь у вас есть два основных варианта:сохранить или уничтожить.</target>
        </trans-unit>
        <trans-unit id="f729e16e6d70d308845c4e263f4f5d66444de2cc" translate="yes" xml:space="preserve">
          <source>When you're done with your filehandles, you should &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; them (though to be honest, Perl will clean up after you if you forget):</source>
          <target state="translated">Когда вы закончите со своими дескрипторами файлов, вы должны &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; их (хотя, честно говоря, Perl очистит после вас, если вы забудете):</target>
        </trans-unit>
        <trans-unit id="1488b5ce874430f2891cff85427abec3fe4ed92a" translate="yes" xml:space="preserve">
          <source>When you're done with your filehandles, you should &lt;code&gt;close()&lt;/code&gt; them (though to be honest, Perl will clean up after you if you forget):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f855bc56e9b2d1a2f4296535cb927b2c13c9dd7d" translate="yes" xml:space="preserve">
          <source>When you're using RETVAL to return an &lt;code&gt;SV *&lt;/code&gt; , there's some magic going on behind the scenes that should be mentioned. When you're manipulating the argument stack using the ST(x) macro, for example, you usually have to pay special attention to reference counts. (For more about reference counts, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.) To make your life easier, the typemap file automatically makes &lt;code&gt;RETVAL&lt;/code&gt; mortal when you're returning an &lt;code&gt;SV *&lt;/code&gt; . Thus, the following two XSUBs are more or less equivalent:</source>
          <target state="translated">Когда вы используете RETVAL для возврата &lt;code&gt;SV *&lt;/code&gt; , за кулисами творится некоторая магия, о которой следует упомянуть. Например, когда вы манипулируете стеком аргументов с помощью макроса ST (x), вам обычно нужно уделять особое внимание счетчику ссылок. (Для получения дополнительной информации о подсчете ссылок см. &lt;a href=&quot;perlguts&quot;&gt;Perlguts&lt;/a&gt; .) Чтобы облегчить вашу жизнь, файл typemap автоматически делает &lt;code&gt;RETVAL&lt;/code&gt; смертным, когда вы возвращаете &lt;code&gt;SV *&lt;/code&gt; . Таким образом, следующие два XSUB более или менее эквивалентны:</target>
        </trans-unit>
        <trans-unit id="aff47fe5db562b3d2dbc867dc1c147d97de9621a" translate="yes" xml:space="preserve">
          <source>When you're using RETVAL to return an &lt;code&gt;SV *&lt;/code&gt;, there's some magic going on behind the scenes that should be mentioned. When you're manipulating the argument stack using the ST(x) macro, for example, you usually have to pay special attention to reference counts. (For more about reference counts, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.) To make your life easier, the typemap file automatically makes &lt;code&gt;RETVAL&lt;/code&gt; mortal when you're returning an &lt;code&gt;SV *&lt;/code&gt;. Thus, the following two XSUBs are more or less equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5829efde6fb988f406fa62c8ae4c250e14e41e30" translate="yes" xml:space="preserve">
          <source>When you've found that there isn't a module available for what you're trying to do, and you've had to write the code yourself, consider packaging up the solution into a module and uploading it to CPAN so that others can benefit.</source>
          <target state="translated">Когда вы обнаружили,что нет модуля,доступного для того,что вы пытаетесь сделать,и вам пришлось писать код самому,подумайте о том,чтобы упаковать решение в модуль и загрузить его в CPAN,чтобы другие могли извлечь из этого пользу.</target>
        </trans-unit>
        <trans-unit id="6b113771452e06c12bd2750d8700f91d2cc72def" translate="yes" xml:space="preserve">
          <source>When you've got your name sorted out and you're sure that your module is wanted and not currently available, it's time to start coding.</source>
          <target state="translated">Когда вы разобрались со своим именем и уверены,что ваш модуль в розыске и недоступен в данный момент,пришло время начать кодирование.</target>
        </trans-unit>
        <trans-unit id="baa149e5f728be9fcf5c842fafa04ad779a77d18" translate="yes" xml:space="preserve">
          <source>When your child is done running tests, you must call &lt;code&gt;finalize&lt;/code&gt; to clean up and tell the parent your pass/fail status.</source>
          <target state="translated">Когда ваш ребенок &lt;code&gt;finalize&lt;/code&gt; выполнение тестов, вы должны вызвать finalize, чтобы очистить и сообщить родителю свой статус пройден / не пройден.</target>
        </trans-unit>
        <trans-unit id="701f121f0767fb048f9a1e9cdd7bcb29143a3d18" translate="yes" xml:space="preserve">
          <source>When your module encounters an error it should do one or more of:</source>
          <target state="translated">Когда ваш модуль сталкивается с ошибкой,он должен сделать одну или несколько ошибок:</target>
        </trans-unit>
        <trans-unit id="7d300f1dcd786450162ec26ef8c71857af330be4" translate="yes" xml:space="preserve">
          <source>When, &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; is enabled, this setting controls whether the permissions on files from the archive are used without modification of if they are filtered by removing any setid bits and applying the current umask.</source>
          <target state="translated">Когда &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; включен, этот параметр определяет, используются ли разрешения для файлов из архива без изменений или фильтруются ли они путем удаления любых битов setid и применения текущей маски umask.</target>
        </trans-unit>
        <trans-unit id="c7c9dae84175d878d430d8cca64e61d718171eab" translate="yes" xml:space="preserve">
          <source>When, however, you assign a list of scalars to another list of scalars, the results differ according to whether the left-hand list -- the list being assigned to -- has the same, more or fewer elements than the right-hand list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d830d827614f19bd45afae435d976e89279e08bd" translate="yes" xml:space="preserve">
          <source>Whenever JSON allows whitespace, C++-style one-line comments are additionally allowed. They are terminated by the first carriage-return or line-feed character, after which more white-space and comments are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042aae650b0c414ca1cd41812840fd2d72dec204" translate="yes" xml:space="preserve">
          <source>Whenever JSON allows whitespace, C-style multiple-line comments are additionally allowed. Everything between &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; is a comment, after which more white-space and comments are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a2ef40caf9ba8f64a09af2f45cf33737585968" translate="yes" xml:space="preserve">
          <source>Whenever JSON allows whitespace, shell-style comments are additionally allowed. They are terminated by the first carriage-return or line-feed character, after which more white-space and comments are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cabccb147592c137e487eb001cea479dffb70830" translate="yes" xml:space="preserve">
          <source>Whenever a Berkeley DB function returns data via one of its parameters, the equivalent &lt;b&gt;DB_File&lt;/b&gt; method does exactly the same.</source>
          <target state="translated">Когда функция Berkeley DB возвращает данные через один из своих параметров, эквивалентный метод &lt;b&gt;DB_File&lt;/b&gt; делает то же самое.</target>
        </trans-unit>
        <trans-unit id="6a800aba7242513688fb7365bc61881077cd8882" translate="yes" xml:space="preserve">
          <source>Whenever a Perl subroutine is called using one of the</source>
          <target state="translated">Всякий раз,когда вызывается подпрограмма Perl с помощью одной из подпрограмм</target>
        </trans-unit>
        <trans-unit id="6344d70f52ab5669e0f868bcc4766007019f0e1c" translate="yes" xml:space="preserve">
          <source>Whenever a reference is used as a field hash key, the object registry is checked and a new entry is made if necessary. The field hash is then added to the list of fields this reference has used.</source>
          <target state="translated">Всякий раз,когда ссылка используется в качестве хэш-ключа полей,проверяется реестр объектов и при необходимости вносится новая запись.Хэш-значение поля добавляется в список полей,используемых этой ссылкой.</target>
        </trans-unit>
        <trans-unit id="ac59cb12b90f854e158e9f7e8d962f434ede4764" translate="yes" xml:space="preserve">
          <source>Whenever control returns from the</source>
          <target state="translated">Всякий раз,когда управление возвращается с</target>
        </trans-unit>
        <trans-unit id="56847d63f6da95857482dd3497381b06019beb12" translate="yes" xml:space="preserve">
          <source>Whenever metadata consumers merge prerequisites, either from different phases or from &lt;code&gt;optional_features&lt;/code&gt;, they should merged in a way which preserves the intended semantics of the prerequisite structure. Generally, this means concatenating the version specifications using commas, as described in the &lt;a href=&quot;#Version-Ranges&quot;&gt;&quot;Version Ranges&quot;&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a47aafac8fca0c788807bc11f865583b9a79dd" translate="yes" xml:space="preserve">
          <source>Whenever possible, new features should be prototyped in a CPAN module before they will be considered for the core.</source>
          <target state="translated">Всегда,когда это возможно,новые возможности должны быть прототипированы в модуле CPAN,прежде чем они будут рассмотрены для ядра.</target>
        </trans-unit>
        <trans-unit id="a368a6c064c79ec6ec1d84f92fa7a58354e83dad" translate="yes" xml:space="preserve">
          <source>Whenever this is applied to a string which doesn't quite meet the pattern's expectations such as &lt;code&gt;&quot;abc  &quot;&lt;/code&gt; or &lt;code&gt;&quot;abc  def &quot;&lt;/code&gt; , the regex engine will backtrack, approximately once for each character in the string. But we know that there is no way around taking</source>
          <target state="translated">Всякий раз, когда это применяется к строке, которая не совсем соответствует ожиданиям шаблона, таким как &lt;code&gt;&quot;abc &quot;&lt;/code&gt; или &lt;code&gt;&quot;abc def &quot;&lt;/code&gt; , механизм регулярных выражений будет выполнять возврат примерно один раз для каждого символа в строке. Но мы знаем, что никуда не денешься</target>
        </trans-unit>
        <trans-unit id="ff79b096fb177b1f29c2b3cfee678fdb53ec5582" translate="yes" xml:space="preserve">
          <source>Whenever this is applied to a string which doesn't quite meet the pattern's expectations such as &lt;code&gt;&quot;abc &quot;&lt;/code&gt; or &lt;code&gt;&quot;abc def &quot;&lt;/code&gt;, the regexp engine will backtrack, approximately once for each character in the string. But we know that there is no way around taking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d972aca2274b3be6437814e7f18c3f8fdf56c12" translate="yes" xml:space="preserve">
          <source>Whenever you do I/O on a file in Perl, you do so through what in Perl is called a &lt;b&gt;filehandle&lt;/b&gt;. A filehandle is an internal name for an external file. It is the job of the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function to make the association between the internal name and the external name, and it is the job of the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; function to break that association.</source>
          <target state="translated">Всякий раз, когда вы выполняете ввод-вывод для файла в Perl, вы делаете это с помощью того, что в Perl называется &lt;b&gt;дескриптором файла&lt;/b&gt; . Дескриптор файла - это внутреннее имя внешнего файла. Задача функции &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; - установить связь между внутренним именем и внешним именем, а задача функции &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; - разорвать эту связь.</target>
        </trans-unit>
        <trans-unit id="2609a2feff469b602ec869a4ded1b4330334544b" translate="yes" xml:space="preserve">
          <source>Whenever you do I/O on a file in Perl, you do so through what in Perl is called a &lt;b&gt;filehandle&lt;/b&gt;. A filehandle is an internal name for an external file. It is the job of the &lt;code&gt;open&lt;/code&gt; function to make the association between the internal name and the external name, and it is the job of the &lt;code&gt;close&lt;/code&gt; function to break that association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7093ca3cc4a3c897e96991516ce1f4f0fcfd4e" translate="yes" xml:space="preserve">
          <source>Whenever you have more than one subprocess, you must be careful that each closes whichever half of any pipes created for interprocess communication it is not using. This is because any child process reading from the pipe and expecting an EOF will never receive it, and therefore never exit. A single process closing a pipe is not enough to close it; the last process with the pipe open must close it for it to read EOF.</source>
          <target state="translated">Всякий раз,когда у вас более одного подпроцесса,вы должны быть осторожны,чтобы каждый из них закрывал любую из половин каналов,созданных для межпроцессного взаимодействия,которые он не использует.Это происходит потому,что любой дочерний процесс,читающий из трубы и ожидающий EOF,никогда не получит его и,следовательно,никогда не выйдет.Одного процесса,закрывающего трубу,недостаточно,чтобы закрыть ее;последний процесс с открытой трубой должен закрыть ее,чтобы она могла считывать EOF.</target>
        </trans-unit>
        <trans-unit id="cd1ee0eb738b950d883ab6c08ca29be20ef06df7" translate="yes" xml:space="preserve">
          <source>Whenever you're communicating text with anything that is external to your perl process, like a database, a text file, a socket, or another program. Even if the thing you're communicating with is also written in Perl.</source>
          <target state="translated">Всякий раз,когда вы сообщаете текст с чем-либо,что является внешним по отношению к вашему perl процессу,например,с базой данных,текстовым файлом,сокетом или другой программой.Даже если то,с чем вы общаетесь,также написано на Perl.</target>
        </trans-unit>
        <trans-unit id="cc31f890f5831db8c47f9104a5fd72a40a9b958c" translate="yes" xml:space="preserve">
          <source>Whenever your encoded, binary string is used together with a text string, Perl will assume that your binary string was encoded with ISO-8859-1, also known as latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For example, if it was UTF-8, the individual bytes of multibyte characters are seen as separate characters, and then again converted to UTF-8. Such double encoding can be compared to double HTML encoding (&lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ), or double URI encoding (&lt;code&gt;%253E&lt;/code&gt; ).</source>
          <target state="translated">Всякий раз, когда ваша закодированная двоичная строка используется вместе с текстовой строкой, Perl будет считать, что ваша двоичная строка была закодирована с помощью ISO-8859-1, также известного как latin-1. Если это не latin-1, то ваши данные будут преобразованы неприятно. Например, если это был UTF-8, отдельные байты многобайтовых символов отображаются как отдельные символы, а затем снова преобразуются в UTF-8. Такое двойное кодирование можно сравнить с двойным кодированием HTML ( &lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ) или двойным кодированием URI ( &lt;code&gt;%253E&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b8d5a9055801b14712a33d32b68e49a7db91b2d3" translate="yes" xml:space="preserve">
          <source>Whenever your encoded, binary string is used together with a text string, Perl will assume that your binary string was encoded with ISO-8859-1, also known as latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For example, if it was UTF-8, the individual bytes of multibyte characters are seen as separate characters, and then again converted to UTF-8. Such double encoding can be compared to double HTML encoding (&lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt;), or double URI encoding (&lt;code&gt;%253E&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d629f115a3e97bf6ae620fc76d3801dd8ef401" translate="yes" xml:space="preserve">
          <source>Whenever your program accesses data or resources that can be accessed by other threads, you must take steps to coordinate access or risk data inconsistency and race conditions. Note that Perl will protect its internals from your race conditions, but it won't protect you from you.</source>
          <target state="translated">Всякий раз,когда ваша программа получает доступ к данным или ресурсам,которые могут быть доступны другим потокам,вы должны принимать меры по координации доступа или рисковать несовместимостью данных и условиями гонки.Обратите внимание,что Perl защитит свои внутренние компоненты от ваших расовых условий,но он не защитит вас от вас.</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="59d37a0123152108bee6e05a64e55d45d68bc028" translate="yes" xml:space="preserve">
          <source>Where $directory_count % 10 is 1 (&quot;%&quot; for modulo, remember), assuming $directory count is an integer, and except where $directory_count % 100 is 11, &quot;directories&quot; is forced to become grammatically singular, which means it gets the ending for the accusative singular... You begin to visualize the code it'd take to test for the problem so far,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb9b184246f9c47c2085ba5fb400e91c6332924c" translate="yes" xml:space="preserve">
          <source>Where 1 is the position of the first char in the string. Note that position can be 0, or larger than the actual length of the pattern, likewise length can be zero.</source>
          <target state="translated">Где 1-позиция первого графика в строке.Обратите внимание,что позиция может быть равна 0 или больше,чем фактическая длина детали,также длина может быть равна нулю.</target>
        </trans-unit>
        <trans-unit id="73e22419719a01d34b548da9ec30ecb83ae08c13" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's.</source>
          <target state="translated">Где &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; - двухбайтовые идентификаторы подполей.</target>
        </trans-unit>
        <trans-unit id="b9cb4e493b9dc9b7340611ceb99bc1cecceb2405" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's. The second byte of the ID cannot be 0, unless the &lt;code&gt;Strict&lt;/code&gt; option has been disabled.</source>
          <target state="translated">Где &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; - двухбайтовые идентификаторы подполей. Второй байт идентификатора не может быть 0, если не отключена опция &lt;code&gt;Strict&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77383c70462fa701aace92ef9b074251586e9457" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt;, &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a738c1e73fe6ddbf768fa126f517ebb72454b3e" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt;, &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's. The second byte of the ID cannot be 0, unless the &lt;code&gt;Strict&lt;/code&gt; option has been disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de8d3be1468ab688b0e6e35d8cea1268cae0caa0" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$r1&lt;/code&gt; can be a reference to any kind of data structure you'd like. It will be deeply copied. Because &lt;code&gt;dclone&lt;/code&gt; takes and returns references, you'd have to add extra punctuation if you had a hash of arrays that you wanted to copy.</source>
          <target state="translated">Где &lt;code&gt;$r1&lt;/code&gt; может быть ссылкой на любую структуру данных, которую вы хотите. Это будет глубоко скопировано. Поскольку &lt;code&gt;dclone&lt;/code&gt; принимает и возвращает ссылки, вам придется добавить дополнительную пунктуацию, если у вас есть хэш массивов, которые вы хотите скопировать.</target>
        </trans-unit>
        <trans-unit id="29126cbcaebf3032a0f200bdad16fd67b9d2ca9f" translate="yes" xml:space="preserve">
          <source>Where a &lt;b&gt;compiler&lt;/b&gt; remembers symbols. A program like Perl must somehow remember all the names of all the &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;filehandles&lt;/b&gt;, and &lt;b&gt;subroutines&lt;/b&gt; you&amp;rsquo;ve used. It does this by placing the names in a symbol table, which is implemented in Perl using a &lt;b&gt;hash table&lt;/b&gt;. There is a separate symbol table for each &lt;b&gt;package&lt;/b&gt; to give each package its own &lt;b&gt;namespace&lt;/b&gt;.</source>
          <target state="translated">Где &lt;b&gt;компилятор&lt;/b&gt; запоминает символы. Программа, подобная Perl, должна каким-то образом запоминать все имена всех используемых вами &lt;b&gt;переменных&lt;/b&gt; , &lt;b&gt;дескрипторов файлов&lt;/b&gt; и &lt;b&gt;подпрограмм&lt;/b&gt; . Он делает это, помещая имена в таблицу символов, которая реализована в Perl с использованием &lt;b&gt;хеш-таблицы&lt;/b&gt; . Для каждого &lt;b&gt;пакета&lt;/b&gt; существует отдельная таблица символов, чтобы дать каждому пакету свое собственное &lt;b&gt;пространство имен&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c27a5a0858ef6e994699b8e168fe5635708702fa" translate="yes" xml:space="preserve">
          <source>Where a layer opens or takes ownership of a file descriptor, that layer is responsible for getting the file descriptor's close-on-exec flag into the correct state. The flag should be clear for a file descriptor numbered less than or equal to &lt;code&gt;PL_maxsysfd&lt;/code&gt;, and set for any file descriptor numbered higher. For thread safety, when a layer opens a new file descriptor it should if possible open it with the close-on-exec flag initially set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841b8cfbd59c36bfe89c29e0da6a4675a6abce15" translate="yes" xml:space="preserve">
          <source>Where are modules installed?</source>
          <target state="translated">Где устанавливаются модули?</target>
        </trans-unit>
        <trans-unit id="77cc20dcc0c42287d0cc6c95ce660feb0b4c5aeb" translate="yes" xml:space="preserve">
          <source>Where can I buy a commercial version of Perl?</source>
          <target state="translated">Где я могу купить коммерческую версию Perl?</target>
        </trans-unit>
        <trans-unit id="08cf7f142b0ee15a977fe964d0ddcdb1002739ae" translate="yes" xml:space="preserve">
          <source>Where can I get Perl macros for vi?</source>
          <target state="translated">Где я могу достать макросы Perl для vi?</target>
        </trans-unit>
        <trans-unit id="406cbb0495a55956cb84611a8d86c9d721557519" translate="yes" xml:space="preserve">
          <source>Where can I get information on Perl?</source>
          <target state="translated">Где я могу получить информацию о Перле?</target>
        </trans-unit>
        <trans-unit id="c63d9dfa4f6d6dcfc8103ea7650db10cd8e27fea" translate="yes" xml:space="preserve">
          <source>Where can I get perl-mode or cperl-mode for emacs?</source>
          <target state="translated">Где я могу получить perl-режим или cperl-режим для emacs?</target>
        </trans-unit>
        <trans-unit id="b85fdb935a7a614522614b7feed541611e8d0a3e" translate="yes" xml:space="preserve">
          <source>Where can I get the latest libnet release</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f1c9d2159564047b740e7956f5640af04f1e3c" translate="yes" xml:space="preserve">
          <source>Where can I learn about CGI or Web programming in Perl?</source>
          <target state="translated">Где я могу узнать о CGI или веб-программировании на Perl?</target>
        </trans-unit>
        <trans-unit id="703366e9bd37f95d6d2b90762995773aff84d67e" translate="yes" xml:space="preserve">
          <source>Where can I learn about linking C with Perl?</source>
          <target state="translated">Где я могу узнать о связи C с Perl?</target>
        </trans-unit>
        <trans-unit id="ed8bfc60bd9d8b7923b8341ed07d83afc289bc35" translate="yes" xml:space="preserve">
          <source>Where can I learn about object-oriented Perl programming?</source>
          <target state="translated">Где можно узнать об объектно-ориентированном программировании на Perl?</target>
        </trans-unit>
        <trans-unit id="210221a52d88064b34135e9105ebfd5d49152b00" translate="yes" xml:space="preserve">
          <source>Where can I post questions?</source>
          <target state="translated">Где я могу разместить вопросы?</target>
        </trans-unit>
        <trans-unit id="34466094d5547ae836abe0422810851106c8e987" translate="yes" xml:space="preserve">
          <source>Where do I get the include files to do ioctl() or syscall()?</source>
          <target state="translated">Где я могу получить включаемые файлы для выполнения ioctl()или syscall()?</target>
        </trans-unit>
        <trans-unit id="ae774b74efc34a0e83321577caf18754079572a2" translate="yes" xml:space="preserve">
          <source>Where do I send bug reports?</source>
          <target state="translated">Куда посылать сообщения об ошибках?</target>
        </trans-unit>
        <trans-unit id="566e06889afcd4a7979069c8b0fd2da4dd9ed19e" translate="yes" xml:space="preserve">
          <source>Where file systems interfaces pass file names in and out of the program we also need care. The trend is for operating systems to use a fixed file encoding that don't actually depend on the locale; and this module determines the most appropriate encoding for file names. The &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module will know this encoding under the name &quot;locale_fs&quot;. For traditional Unix systems this will be an alias to the same encoding as &quot;locale&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93218aab454721cc4e38fe91ac1668248deeae63" translate="yes" xml:space="preserve">
          <source>Where is the implementation?</source>
          <target state="translated">Где реализация?</target>
        </trans-unit>
        <trans-unit id="8a78c0649556030e4985847b409471ca9ebd9274" translate="yes" xml:space="preserve">
          <source>Where people get into trouble is here:</source>
          <target state="translated">Там,где люди попадают в неприятности:</target>
        </trans-unit>
        <trans-unit id="f616a42d8ce8b58cf95a9bfc5e5383c6c84dc620" translate="yes" xml:space="preserve">
          <source>Where prereqs are concerned, if META_MERGE is used, prerequisites are merged with their counterpart &lt;code&gt;WriteMakefile()&lt;/code&gt; argument (PREREQ_PM is merged into {prereqs}{runtime}{requires}, BUILD_REQUIRES into &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; , CONFIGURE_REQUIRES into &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; , and TEST_REQUIRES into &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; . When prereqs are specified with META_ADD, the only prerequisites added to the file come from the metadata, not &lt;code&gt;WriteMakefile()&lt;/code&gt; arguments.</source>
          <target state="translated">Что касается предварительных требований, если используется META_MERGE, предварительные требования объединяются с их противоположным аргументом &lt;code&gt;WriteMakefile()&lt;/code&gt; (PREREQ_PM объединяется в {prereqs} {runtime} {requires}, BUILD_REQUIRES в &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; , CONFIGURE_REQUIRES в &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; и TEST_REQUIRES в &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; . Когда предварительные требования указываются с помощью META_ADD, единственные предварительные условия, добавляемые в файл, исходят из метаданных, а не аргументов &lt;code&gt;WriteMakefile()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9262bb4032137f4bd07b4f1a031c40996bf22f95" translate="yes" xml:space="preserve">
          <source>Where prereqs are concerned, if META_MERGE is used, prerequisites are merged with their counterpart &lt;code&gt;WriteMakefile()&lt;/code&gt; argument (PREREQ_PM is merged into {prereqs}{runtime}{requires}, BUILD_REQUIRES into &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt;, CONFIGURE_REQUIRES into &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt;, and TEST_REQUIRES into &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt;. When prereqs are specified with META_ADD, the only prerequisites added to the file come from the metadata, not &lt;code&gt;WriteMakefile()&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2578ad2cf7eb4212c4c2f76a99c66a64a699a6f4" translate="yes" xml:space="preserve">
          <source>Where the $way is a value from zero ($theta0, $phi0) to one ($theta1, $phi1). Note that antipodal points (where their distance is</source>
          <target state="translated">Где $way-это значение от нуля ($theta0,$phi0)до единицы ($theta1,$phi1).Обратите внимание,что антиподные точки (где их расстояние -</target>
        </trans-unit>
        <trans-unit id="fd6d6e78410be236f0ee8b2e37126d4a25f62f65" translate="yes" xml:space="preserve">
          <source>Where the 'DSLIP' characters have the following meanings:</source>
          <target state="translated">Где символы 'DSLIP' имеют следующие значения:</target>
        </trans-unit>
        <trans-unit id="843828ced3164063fc4c650d4b6af29aa8f9cb2c" translate="yes" xml:space="preserve">
          <source>Where the two must be separate, initially set the type to &lt;code&gt;CXt_NULL&lt;/code&gt; or &lt;code&gt;CXt_BLOCK&lt;/code&gt;, and later change it to &lt;code&gt;CXt_foo&lt;/code&gt; when doing the &lt;code&gt;cx_pushfoo&lt;/code&gt;. This is exactly what &lt;code&gt;pp_enteriter&lt;/code&gt; does, once it's determined which type of loop it's pushing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a57b05d69f49e2636c91eefc4c6774814129e12" translate="yes" xml:space="preserve">
          <source>Where there is only one operand (or only one operand with overloading) the checks in respect of the other operand above are skipped.</source>
          <target state="translated">При наличии только одного операнда (или только одного операнда с перегрузкой)проверки в отношении другого вышеуказанного операнда пропускаются.</target>
        </trans-unit>
        <trans-unit id="293c942f397777e729937e1824d906951d88e087" translate="yes" xml:space="preserve">
          <source>Where these steps occur in the actual execution of a perl program is determined by whether the pattern involves interpolating any string variables. If interpolation occurs, then compilation happens at run time. If it does not, then compilation is performed at compile time. (The &lt;code&gt;/o&lt;/code&gt; modifier changes this, as does &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; to a certain extent.) The engine doesn't really care that much.</source>
          <target state="translated">То, где эти шаги происходят при фактическом выполнении программы на Perl, определяется тем, включает ли шаблон интерполяцию каких-либо строковых переменных. Если происходит интерполяция, то компиляция происходит во время выполнения. Если нет, то компиляция выполняется во время компиляции. ( Модификатор &lt;code&gt;/o&lt;/code&gt; меняет это, как и &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; в некоторой степени.) Движку на самом деле все равно.</target>
        </trans-unit>
        <trans-unit id="eb41b8cee1215605643716ae7b75d6423a86bb03" translate="yes" xml:space="preserve">
          <source>Where these steps occur in the actual execution of a perl program is determined by whether the pattern involves interpolating any string variables. If interpolation occurs, then compilation happens at run time. If it does not, then compilation is performed at compile time. (The &lt;code&gt;/o&lt;/code&gt; modifier changes this, as does &lt;code&gt;qr//&lt;/code&gt; to a certain extent.) The engine doesn't really care that much.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca423190a1a1c785b9d576f8083e40dd5389585" translate="yes" xml:space="preserve">
          <source>Where to Find the Community</source>
          <target state="translated">Где найти сообщество</target>
        </trans-unit>
        <trans-unit id="536ef5aba264e8d2aec71ea10430b9efa22dfe0c" translate="yes" xml:space="preserve">
          <source>Where to find the perlfaq</source>
          <target state="translated">Где найти перлфак</target>
        </trans-unit>
        <trans-unit id="93683b8b8083dba6e071465301ae1d1c45028dec" translate="yes" xml:space="preserve">
          <source>Where to get this document</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4af9617f74f3fb16e775a0d165421fe00441bc1b" translate="yes" xml:space="preserve">
          <source>Where to start?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e10717c102dd0c9df4c18b5606b9aaf6912d10" translate="yes" xml:space="preserve">
          <source>Where you look to find a pointer to information somewhere else. (See &lt;b&gt;indirection&lt;/b&gt;.) References come in two flavors: &lt;b&gt;symbolic references&lt;/b&gt; and &lt;b&gt;hard references&lt;/b&gt;.</source>
          <target state="translated">Где искать указатель на информацию в другом месте. (См. &lt;b&gt;Косвенное&lt;/b&gt; обращение.) Ссылки бывают двух видов: &lt;b&gt;символические ссылки&lt;/b&gt; и &lt;b&gt;жесткие ссылки&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="500583f76e5e2a57eb1022812ab875f23db70975" translate="yes" xml:space="preserve">
          <source>Where's the catch? Padding is neither required before the first field &lt;code&gt;count&lt;/code&gt; , nor between this and the next field &lt;code&gt;glyph&lt;/code&gt; , so why can't we simply pack like this:</source>
          <target state="translated">Где подвох? Заполнение не требуется ни перед &lt;code&gt;count&lt;/code&gt; первого поля , ни между этим и следующим &lt;code&gt;glyph&lt;/code&gt; поля , так почему мы не можем просто упаковать его так:</target>
        </trans-unit>
        <trans-unit id="2bdd0a720834494322577f4ab7718daee200802f" translate="yes" xml:space="preserve">
          <source>Where's the catch? Padding is neither required before the first field &lt;code&gt;count&lt;/code&gt;, nor between this and the next field &lt;code&gt;glyph&lt;/code&gt;, so why can't we simply pack like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ff01499d11ce21062a9b96027ab58ee226aad3" translate="yes" xml:space="preserve">
          <source>Where,</source>
          <target state="translated">Where,</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="4d453f1163fdbba0e62b8cfe55db1c43bd938110" translate="yes" xml:space="preserve">
          <source>Whereas a QP decoder that works on both ASCII and EBCDIC platforms would look somewhat like the following:</source>
          <target state="translated">В то время как QP декодер,который работает как на ASCII,так и на EBCDIC платформах,выглядел бы несколько следующим образом:</target>
        </trans-unit>
        <trans-unit id="4c1007108b497a2f8b15b3dc9255f03fbd82a20c" translate="yes" xml:space="preserve">
          <source>Whereas here's how a Perl programmer more comfortable with the idiom might do it:</source>
          <target state="translated">В то время как вот как Perl программист,более комфортный с идиомой,может сделать это:</target>
        </trans-unit>
        <trans-unit id="5db7dff8fd1589f3c435af6d45d16e0816b2e9c4" translate="yes" xml:space="preserve">
          <source>Whereas if you comment out the two lines I said you might wish to, then it shows it to you this way instead:</source>
          <target state="translated">В то время как если вы прокомментируете две строки,которые я сказал,что вы можете захотеть,то это покажет вам это таким образом:</target>
        </trans-unit>
        <trans-unit id="ab440f8d11b8fd4e9e75cd6104ac553e6f04002a" translate="yes" xml:space="preserve">
          <source>Whereas other perl internal stacks store individual items all of the same type (usually SV pointers or integers), the items pushed to the save stack are formed of many different types, having multiple fields to them. For example, the &lt;code&gt;SAVEt_INT&lt;/code&gt; type needs to store both the address of the &lt;code&gt;int&lt;/code&gt; variable to restore, and the value to restore it to. This information could have been stored using fields of a &lt;code&gt;struct&lt;/code&gt;, but would have to be large enough to store three pointers in the largest case, which would waste a lot of space in most of the smaller cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa7a6da1ef7f2699440e362142ae5565af060786" translate="yes" xml:space="preserve">
          <source>Wherever a list of operators can be given you can use one or more opsets. See also Manipulating Opsets below.</source>
          <target state="translated">Где бы ни был дан список операторов,Вы можете использовать один или несколько наборов опций.См.также раздел Манипулирование опциями ниже.</target>
        </trans-unit>
        <trans-unit id="c457c17dce216494419135c71949242b8d09d0bb" translate="yes" xml:space="preserve">
          <source>Wherever possible, shareable images are preferred to object libraries, and object libraries to plain object files. In accordance with VMS naming conventions, ext() looks for files named</source>
          <target state="translated">Везде,где это возможно,разделяемые изображения предпочитаются объектными библиотеками,а объектные библиотеки-обычными объектными файлами.В соответствии с соглашениями об именовании VMS функция ext()ищет файлы с именами</target>
        </trans-unit>
        <trans-unit id="a5ce0b5c076605e513279f0c54d153294cc237e9" translate="yes" xml:space="preserve">
          <source>Whether PadnamePV is in UTF-8. Currently, this is always true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f21be64cee3c558562d0924a678b1007587a17" translate="yes" xml:space="preserve">
          <source>Whether PadnamePV is in UTF8. Currently, this is always true.</source>
          <target state="translated">Находится ли PadnamePV в UTF8.В настоящее время это всегда так.</target>
        </trans-unit>
        <trans-unit id="0971615da14029bdca88814940e8de90b6be5147" translate="yes" xml:space="preserve">
          <source>Whether a &quot;signaling&quot; NaN is in any way different from a &quot;quiet&quot; NaN, depends on the platform. Also note that the payload of the default NaN (no argument to nan()) is not necessarily zero, use &lt;code&gt;setpayload&lt;/code&gt; to explicitly set the payload. On some platforms like the 32-bit x86, (unless using the 80-bit long doubles) the signaling bit is not supported at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b3304921bf73755f27746fb53954b4a8c4de93" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is disabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;require_order&lt;/code&gt; is enabled.</source>
          <target state="translated">Допускается ли смешивание аргументов командной строки с параметрами. По умолчанию отключено, если не была установлена ​​переменная окружения POSIXLY_CORRECT, и в этом случае &lt;code&gt;require_order&lt;/code&gt; включен.</target>
        </trans-unit>
        <trans-unit id="faea90df33f36630a481da4cad34e4c79bf52fc5" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;permute&lt;/code&gt; is disabled. Note that &lt;code&gt;permute&lt;/code&gt; is the opposite of &lt;code&gt;require_order&lt;/code&gt; .</source>
          <target state="translated">Допускается ли смешивание аргументов командной строки с параметрами. По умолчанию включено, если не была установлена ​​переменная среды POSIXLY_CORRECT, и в этом случае &lt;code&gt;permute&lt;/code&gt; отключена. Обратите внимание, что &lt;code&gt;permute&lt;/code&gt; - это противоположность &lt;code&gt;require_order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7872b2f4a897e4a8ef1ea13c927afbc5f8e9bb5d" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;permute&lt;/code&gt; is disabled. Note that &lt;code&gt;permute&lt;/code&gt; is the opposite of &lt;code&gt;require_order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457d6cfb1888790c7832bd27b66465f0cdcbd754" translate="yes" xml:space="preserve">
          <source>Whether dtrace accepts -xnolibs. If available we call dtrace -h and dtrace -G with -xnolibs to allow dtrace to run in a jail on FreeBSD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf16a187d3ac8048da2c0a9f49f8874167f5a83b" translate="yes" xml:space="preserve">
          <source>Whether or not the op has been optimized by the peephole optimizer.</source>
          <target state="translated">Оптимизирована ли операция глазком оптимизатора или нет.</target>
        </trans-unit>
        <trans-unit id="99e430c2678f913bd7c7b93452d560622af7b626" translate="yes" xml:space="preserve">
          <source>Whether or not the test should output numbers. That is, this if true:</source>
          <target state="translated">Должен ли тест выдавать номера или нет.То есть,это если правда:</target>
        </trans-unit>
        <trans-unit id="5f8067023624d336e348da355a79650c3095a919" translate="yes" xml:space="preserve">
          <source>Whether or not to be verbose about what it is doing -- it will default to $Module::Load::Conditional::VERBOSE</source>
          <target state="translated">Будет ли он многословен в том,что делает-по умолчанию будет $Module::Load::Conditional::VERBOSE</target>
        </trans-unit>
        <trans-unit id="835c4d9838e01fba8d1ac35f378ff2857c3bbf2f" translate="yes" xml:space="preserve">
          <source>Whether sorting is stable by default is an accident of implementation that can change (and has changed) between Perl versions. If stability is important, be sure to say so with a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f7f78ec0e44e67b9396390cd1ee3bcf0e5e14e" translate="yes" xml:space="preserve">
          <source>Whether this entry belongs to an outer pad. Entries for which this is true are often referred to as 'fake'.</source>
          <target state="translated">принадлежит ли эта запись к внешней прокладке.Записи,для которых это правда,часто называют &quot;фальшивыми&quot;.</target>
        </trans-unit>
        <trans-unit id="6283322d116e1d51f7edcd1ec872a9eed355ceb1" translate="yes" xml:space="preserve">
          <source>Whether this is a &quot;state&quot; variable.</source>
          <target state="translated">Является ли это переменной &quot;состояние&quot;.</target>
        </trans-unit>
        <trans-unit id="e7034c09da28fdb3d58392534621cc03eebbd14d" translate="yes" xml:space="preserve">
          <source>Whether this is an &quot;our&quot; variable.</source>
          <target state="translated">Является ли это &quot;нашей&quot; переменной.</target>
        </trans-unit>
        <trans-unit id="c084cfe6eeb06cc1ff5160c3c990367fe4946569" translate="yes" xml:space="preserve">
          <source>Whether this type of partition is support under Win32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe93610e6b23e15b98198b34ad48105c383339a" translate="yes" xml:space="preserve">
          <source>Whether to abort printing if debugger signal flag is raised.</source>
          <target state="translated">Следует ли прервать печать,если флаг сигнала отладчика поднят.</target>
        </trans-unit>
        <trans-unit id="2985490d3101108f328098168c5a21b3bc3c5a70" translate="yes" xml:space="preserve">
          <source>Whether to add a table-of-contents at the top of each page (called an index for the sake of tradition).</source>
          <target state="translated">Следует ли добавлять оглавление в верхней части каждой страницы (так называемый указатель по традиции).</target>
        </trans-unit>
        <trans-unit id="3a911a7e2bce47416920de6f21016acd3029366b" translate="yes" xml:space="preserve">
          <source>Whether to anchor every definition &lt;code&gt;=item&lt;/code&gt; directive. This needs to be enabled if you want to be able to link to specific &lt;code&gt;=item&lt;/code&gt; directives, which are output as &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; elements. Disabled by default.</source>
          <target state="translated">Следует ли привязать каждую директиву definition &lt;code&gt;=item&lt;/code&gt; . Это необходимо включить, если вы хотите иметь возможность ссылаться на определенные директивы &lt;code&gt;=item&lt;/code&gt; , которые выводятся как элементы &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; . По умолчанию отключено.</target>
        </trans-unit>
        <trans-unit id="626413839d3d50a20deaaad85828e47d347f236c" translate="yes" xml:space="preserve">
          <source>Whether to call these extended grapheme clusters &quot;characters&quot; depends on your point of view. If you are a programmer, you probably would tend towards seeing each element in the sequences as one unit, or &quot;character&quot;. However from the user's point of view, the whole sequence could be seen as one &quot;character&quot; since that's probably what it looks like in the context of the user's language. In this document, we take the programmer's point of view: one &quot;character&quot; is one Unicode code point.</source>
          <target state="translated">Назвать ли эти расширенные графемные кластеры &quot;символами&quot; зависит от вашей точки зрения.Если вы программист,то вы,вероятно,склонны видеть каждый элемент в последовательности как единое целое,или как &quot;символ&quot;.Однако,с точки зрения пользователя,вся последовательность может рассматриваться как один &quot;символ&quot;,поскольку,вероятно,именно так она выглядит в контексте языка пользователя.В данном документе мы рассмотрим точку зрения программиста:один &quot;символ&quot;-это одна точка кода Юникода.</target>
        </trans-unit>
        <trans-unit id="ee66335b9db0c1d5103deb721dc40777dd212c3c" translate="yes" xml:space="preserve">
          <source>Whether to print chars with high bit set in binary or &quot;as is&quot;.</source>
          <target state="translated">Будь то печатать графики с высоким битовым набором в двоичном виде или &quot;как есть&quot;.</target>
        </trans-unit>
        <trans-unit id="238ca87137bc56748ce05a002a71d9a6db9c7ebe" translate="yes" xml:space="preserve">
          <source>Whether to print contents of globs.</source>
          <target state="translated">Печатать ли содержимое глобусов.</target>
        </trans-unit>
        <trans-unit id="d3a12643fc63beef0ef6ccef6dae848daa691587" translate="yes" xml:space="preserve">
          <source>Whether to try to find the subroutine name given the reference.</source>
          <target state="translated">Попробовать ли найти имя подпрограммы,указанное в ссылке.</target>
        </trans-unit>
        <trans-unit id="bfd0c6dfe7d4e4cba4e02f1a0ab33700dc1c327f" translate="yes" xml:space="preserve">
          <source>Whether to turn every =head1 directive into a link pointing to the top of the page (specifically, the opening body tag).</source>
          <target state="translated">Превращать ли каждую директиву =head1 в ссылку,указывающую на верхнюю часть страницы (а именно,открывающий тег тела).</target>
        </trans-unit>
        <trans-unit id="c12251b6a52be9785616abd5b79f50c9699026bb" translate="yes" xml:space="preserve">
          <source>Whether to update this partition information. This field is not used by &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt;. For &lt;code&gt;IOCTL_DISK_SET_DRIVE_LAYOUT&lt;/code&gt;, you must set this field to a true value for any partitions you wish to have changed, added, or deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26288162f4ab8ff9ae48923849befc89334a4a3" translate="yes" xml:space="preserve">
          <source>Whether to write the non-overloaded form of the stringify-overloaded objects.</source>
          <target state="translated">Записывать ли незагруженные формы строковых объектов.</target>
        </trans-unit>
        <trans-unit id="db40c6156e22d6cc6531821dd75bdcb0d45e3842" translate="yes" xml:space="preserve">
          <source>Whether various library calls are thread-safe is outside the control of Perl. Calls often suffering from not being thread-safe include: &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;, functions fetching user, group and network information (such as &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; and so on), &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt;. In general, calls that depend on some global external state.</source>
          <target state="translated">Perl не может контролировать потокобезопасные вызовы различных библиотек. Вызовы, часто страдающие от небезопасной &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; включают: &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; , gmtime () , функции , извлекающие информацию о пользователях, группах и сети (например, &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; и т. Д.), &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; . В общем, вызовы, которые зависят от некоторого глобального внешнего состояния.</target>
        </trans-unit>
        <trans-unit id="d56e1a6230da252ffdc8d6662ae566d3f6b5ee2f" translate="yes" xml:space="preserve">
          <source>Whether various library calls are thread-safe is outside the control of Perl. Calls often suffering from not being thread-safe include: &lt;code&gt;localtime()&lt;/code&gt;, &lt;code&gt;gmtime()&lt;/code&gt;, functions fetching user, group and network information (such as &lt;code&gt;getgrent()&lt;/code&gt;, &lt;code&gt;gethostent()&lt;/code&gt;, &lt;code&gt;getnetent()&lt;/code&gt; and so on), &lt;code&gt;readdir()&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt;, and &lt;code&gt;srand()&lt;/code&gt;. In general, calls that depend on some global external state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465a32753eace035273aaef17e2c639421b02dff" translate="yes" xml:space="preserve">
          <source>Whether we need to build an object file with the dtrace tool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201246e3611962dc1ed1a9edc779811bfcd3278b" translate="yes" xml:space="preserve">
          <source>Whether you are using NIS does not matter. Amazingly enough, the same bug also affects Solaris.</source>
          <target state="translated">Неважно,используете ли вы НИС.Удивительно,но та же самая ошибка затрагивает и Solaris.</target>
        </trans-unit>
        <trans-unit id="f8e039fc339d1036f86bd64ce844762f9417fe8b" translate="yes" xml:space="preserve">
          <source>Whether you use &lt;code&gt;perlbug&lt;/code&gt; or send the email manually, please make your Subject line informative. &quot;a bug&quot; is not informative. Neither is &quot;perl crashes&quot; nor is &quot;HELP!!!&quot;. These don't help. A compact description of what's wrong is fine.</source>
          <target state="translated">Независимо от того, используете ли вы &lt;code&gt;perlbug&lt;/code&gt; или отправляете электронное письмо вручную, сделайте вашу тему &amp;laquo;Тема&amp;raquo; информативной. &quot;баг&quot; не информативен. Ни &amp;laquo;Perl сбой&amp;raquo;, ни &amp;laquo;ПОМОЩЬ !!!&amp;raquo;. Это не помогает. Краткое описание того, что не так, - это нормально.</target>
        </trans-unit>
        <trans-unit id="0cde069a15e713b9fe4a9a6b7078fade7daf5170" translate="yes" xml:space="preserve">
          <source>Whew! That is all the rest of the characters and character classes.</source>
          <target state="translated">Ух ты! Это все остальные персонажи и классы персонажей.</target>
        </trans-unit>
        <trans-unit id="27e5de2ca1964d94a9ea629b708a58094f2d855e" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;Tie::Hash&quot;&gt;Tie::Hash&lt;/a&gt; operation is being performed from the Perl level on &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt;, if any:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56043e0fa27cef8d93950adbdc599597748f590d" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; operation is being performed from the Perl level on &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt; , if any:</source>
          <target state="translated">Какая операция &lt;a href=&quot;tie/hash&quot;&gt;Tie :: Hash&lt;/a&gt; выполняется с уровня Perl на &lt;code&gt;%+&lt;/code&gt; или &lt;code&gt;%+&lt;/code&gt; , если есть:</target>
        </trans-unit>
        <trans-unit id="babf69836d4addec6f5a5308cb5825c678eb405e" translate="yes" xml:space="preserve">
          <source>Which Perl blogs should I read?</source>
          <target state="translated">Какие блоги Perl я должен читать?</target>
        </trans-unit>
        <trans-unit id="54a12a94c6d59fab4aeefed76c9781df10879a85" translate="yes" xml:space="preserve">
          <source>Which YAML implementation would you prefer?</source>
          <target state="translated">Какую реализацию ЯМЛ вы предпочитаете?</target>
        </trans-unit>
        <trans-unit id="88e9358d41b432fbb58126174b7979a4235a746a" translate="yes" xml:space="preserve">
          <source>Which architecture dependent directory?</source>
          <target state="translated">Какой каталог зависит от архитектуры?</target>
        </trans-unit>
        <trans-unit id="b7506b68ee68fa595a60659e338ae77c9646b01d" translate="yes" xml:space="preserve">
          <source>Which character set modifier is in effect?</source>
          <target state="translated">Какой модификатор набора символов действует?</target>
        </trans-unit>
        <trans-unit id="ee9b43c6b4875ca7c0a8fea57558205fc2e727ab" translate="yes" xml:space="preserve">
          <source>Which commit added the first file to match this regex?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d004402710bbe1f74279bca91591607062854495" translate="yes" xml:space="preserve">
          <source>Which commit caused this example code to break?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd77891b19f04e8f4749d5465e616c7d548783ec" translate="yes" xml:space="preserve">
          <source>Which commit caused this example code to start working?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0816de4aeeb375a395f682785a672eb7143a573" translate="yes" xml:space="preserve">
          <source>Which commit removed the last file to match this regex?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6d9abe75ea380074d1386fb6bc4638c51ca405" translate="yes" xml:space="preserve">
          <source>Which is checked first, &lt;code&gt;nomethod&lt;/code&gt; or &lt;code&gt;fallback&lt;/code&gt; ? If the two operands of an operator are of different types and both overload the operator, which implementation is used? The following are the precedence rules:</source>
          <target state="translated">Который сначала проверяется, &lt;code&gt;nomethod&lt;/code&gt; или &lt;code&gt;fallback&lt;/code&gt; ? Если два операнда оператора относятся к разным типам и оба перегружают оператор, какая реализация используется? Ниже приведены правила приоритета:</target>
        </trans-unit>
        <trans-unit id="26892517e1a24be563151c63ed23ba887d7067cd" translate="yes" xml:space="preserve">
          <source>Which is checked first, &lt;code&gt;nomethod&lt;/code&gt; or &lt;code&gt;fallback&lt;/code&gt;? If the two operands of an operator are of different types and both overload the operator, which implementation is used? The following are the precedence rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db62588fd2906af96c2fa483b06db407a80424f" translate="yes" xml:space="preserve">
          <source>Which is effectively just:</source>
          <target state="translated">Что,по сути,справедливо:</target>
        </trans-unit>
        <trans-unit id="b3fbe5ee09cb06684cac7d1a3e427f0dd899daef" translate="yes" xml:space="preserve">
          <source>Which is what we might expect, the match finds the only &lt;code&gt;cat&lt;/code&gt; in the string and locks onto it. Consider, however, this regexp:</source>
          <target state="translated">Как и следовало ожидать, совпадение находит единственную &lt;code&gt;cat&lt;/code&gt; в строке и фиксируется на ней. Однако рассмотрим это регулярное выражение:</target>
        </trans-unit>
        <trans-unit id="b248b8b60b90917a66aeb94063d05f7d477a94bd" translate="yes" xml:space="preserve">
          <source>Which magazines have Perl content?</source>
          <target state="translated">Какие журналы имеют Perl содержание?</target>
        </trans-unit>
        <trans-unit id="786c2c13e1b48f509ddfa13fe457e7ade1e2d5c4" translate="yes" xml:space="preserve">
          <source>Which makes $richard and $dick the same variable, but leaves @richard and @dick as separate arrays. Tricky, eh?</source>
          <target state="translated">Что делает $richard и $dick одной и той же переменной,но оставляет @richard и @dick в виде отдельных массивов.Коварно,да?</target>
        </trans-unit>
        <trans-unit id="c62379639a4b05982ed9a5d227696146f851a074" translate="yes" xml:space="preserve">
          <source>Which of the various &lt;code&gt;*OP&lt;/code&gt; structures this op uses. This should be one of the &lt;code&gt;OA_*&lt;/code&gt; constants from</source>
          <target state="translated">Какую из различных структур &lt;code&gt;*OP&lt;/code&gt; использует эта операция. Это должна быть одна из констант &lt;code&gt;OA_*&lt;/code&gt; из</target>
        </trans-unit>
        <trans-unit id="a891db1882ed2a728a47d9d75117f36a4ff2a006" translate="yes" xml:space="preserve">
          <source>Which of these modifiers is in effect at any given point in a regular expression depends on a fairly complex set of interactions. These have been designed so that in general you don't have to worry about it, but this section gives the gory details. As explained below in &lt;a href=&quot;#Extended-Patterns&quot;&gt;&quot;Extended Patterns&quot;&lt;/a&gt; it is possible to explicitly specify modifiers that apply only to portions of a regular expression. The innermost always has priority over any outer ones, and one applying to the whole expression has priority over any of the default settings that are described in the remainder of this section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c28a2fc8be0459fa3248ceb80936f8aba82ccd2" translate="yes" xml:space="preserve">
          <source>Which of these modifiers is in effect at any given point in a regular expression depends on a fairly complex set of interactions. These have been designed so that in general you don't have to worry about it, but this section gives the gory details. As explained below in &lt;a href=&quot;#Extended-Patterns&quot;&gt;Extended Patterns&lt;/a&gt; it is possible to explicitly specify modifiers that apply only to portions of a regular expression. The innermost always has priority over any outer ones, and one applying to the whole expression has priority over any of the default settings that are described in the remainder of this section.</source>
          <target state="translated">Какой из этих модификаторов действует в любой момент регулярного выражения, зависит от довольно сложного набора взаимодействий. Они были разработаны таким образом, чтобы в целом вам не приходилось об этом беспокоиться, но в этом разделе приведены кровавые подробности. Как объясняется ниже в &lt;a href=&quot;#Extended-Patterns&quot;&gt;разделе &amp;laquo;Расширенные шаблоны&amp;raquo;,&lt;/a&gt; можно явно указать модификаторы, которые применяются только к частям регулярного выражения. Самое внутреннее всегда имеет приоритет над любыми внешними, а выражение, применяемое ко всему выражению, имеет приоритет над любыми настройками по умолчанию, которые описаны в оставшейся части этого раздела.</target>
        </trans-unit>
        <trans-unit id="3d81e570041b9ef8c3716fd625de2184bc9fcbe4" translate="yes" xml:space="preserve">
          <source>Which one you pick depends on which of these expressions better reflects the above specification of comments.</source>
          <target state="translated">Какое из этих выражений лучше отражает приведенную выше спецификацию комментариев,зависит от того,какое из них будет выбрано.</target>
        </trans-unit>
        <trans-unit id="79ee8492b912fab00990fc318850246c7ab7a4ba" translate="yes" xml:space="preserve">
          <source>Which perhaps unexpectedly yields:</source>
          <target state="translated">Который,возможно,неожиданно уступит:</target>
        </trans-unit>
        <trans-unit id="05c36e4547159a2f896e1c4c828cfe54c70d84ef" translate="yes" xml:space="preserve">
          <source>Which rules apply are determined as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3F&quot;&gt;&quot;Which character set modifier is in effect?&quot; in perlre&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e550746bad7dcee6b1162b28bf7aedac094cd1e" translate="yes" xml:space="preserve">
          <source>Which rules apply are determined as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;.</source>
          <target state="translated">Какие применяемые правила определяются, как описано в &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;разделе &amp;laquo;Какой модификатор набора символов действует? в перлре&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4ea6c1227777eb0d0611636fc0f0ce8660134f3" translate="yes" xml:space="preserve">
          <source>Which substring to check first.</source>
          <target state="translated">Какую подстроку проверить первой.</target>
        </trans-unit>
        <trans-unit id="627f14bbed51912496b6fb85cde41b9d90202d10" translate="yes" xml:space="preserve">
          <source>Which tar should I use on Windows?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f094ffb275753431ba594c04d0d66a718fa1eda" translate="yes" xml:space="preserve">
          <source>Which text formatter to use. Default is &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt;, or for very old Perl versions &lt;a href=&quot;Pod::PlainText&quot;&gt;Pod::PlainText&lt;/a&gt;. An alternative would be e.g. &lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b26c1ae972001db5809b34aeb5a2c0bda11feda" translate="yes" xml:space="preserve">
          <source>Which text formatter to use. Default is &lt;a href=&quot;pod/text&quot;&gt;Pod::Text&lt;/a&gt;, or for very old Perl versions &lt;a href=&quot;pod/plaintext&quot;&gt;Pod::PlainText&lt;/a&gt;. An alternative would be e.g. &lt;a href=&quot;pod/text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">Какой форматировщик текста использовать. По умолчанию используется &lt;a href=&quot;pod/text&quot;&gt;Pod :: Text&lt;/a&gt; или для очень старых версий Perl &lt;a href=&quot;pod/plaintext&quot;&gt;Pod :: PlainText&lt;/a&gt; . Альтернативой может быть, например, &lt;a href=&quot;pod/text/termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b8afbe233aaf49239a07d2a4536a6d9be415fc8" translate="yes" xml:space="preserve">
          <source>Which version of Perl should I use?</source>
          <target state="translated">Какую версию Perl мне использовать?</target>
        </trans-unit>
        <trans-unit id="ed3642f21edcd8b0db0bc9f8cee4ac46473a253a" translate="yes" xml:space="preserve">
          <source>Which version of perl do I need ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a93a6b75c99229f45ca5666bf0720d67cc2e24" translate="yes" xml:space="preserve">
          <source>Which version of perl should I use?</source>
          <target state="translated">Какую версию перла следует использовать?</target>
        </trans-unit>
        <trans-unit id="7631d79fe8017e212e81e096dcea8cb82517cdbf" translate="yes" xml:space="preserve">
          <source>Which web framework should I use?</source>
          <target state="translated">Какую веб-фреймворк следует использовать?</target>
        </trans-unit>
        <trans-unit id="ca95e2a8ef78e8e65dfe2ee661d1738206c25df7" translate="yes" xml:space="preserve">
          <source>Which will create the directory we need, and you can move on to the next step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd7ff93be76f4f655ab909493a6705c72660d9c" translate="yes" xml:space="preserve">
          <source>Which will print</source>
          <target state="translated">Который напечатает</target>
        </trans-unit>
        <trans-unit id="03d7614f12de55df0b888753d3fa1d0fb28069d7" translate="yes" xml:space="preserve">
          <source>Which would attempt to set breakpoints on lines 4 and 6 immediately after debugger initialization. Note that @DB::typeahead is not a supported interface and is subject to change in future releases.</source>
          <target state="translated">Который будет пытаться установить точки останова на 4-й и 6-й строках сразу после инициализации отладчика.Обратите внимание,что @DB::typeahead не является поддерживаемым интерфейсом и может быть изменен в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="c966532947a1e874f5fbb5570050ef3e1254690b" translate="yes" xml:space="preserve">
          <source>Which would generate a format looking something like this:</source>
          <target state="translated">Который создаст формат,похожий на этот:</target>
        </trans-unit>
        <trans-unit id="d885d5ead32cef5d0d07c15652290de0ab57655a" translate="yes" xml:space="preserve">
          <source>Which zip should I use on Windows for '[ndg]make zipdist'?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91c0db76a3c1130f40e63caacba5a278833ffb99" translate="yes" xml:space="preserve">
          <source>Which, in the degenerate case of using only ordinary arrays, gives you multidimensional arrays just like C's:</source>
          <target state="translated">Что,в вырожденном случае использования только обычных массивов,дает вам многомерные массивы,такие же,как и C:</target>
        </trans-unit>
        <trans-unit id="49233da44986d650dd0c62f9412171689ae74192" translate="yes" xml:space="preserve">
          <source>Whichever version is used, the actual methods are called in the same context (list, scalar, or void) as the original call via &lt;code&gt;EVERY&lt;/code&gt; , and return:</source>
          <target state="translated">Какая бы версия ни использовалась, фактические методы вызываются в том же контексте (список, скаляр или void), что и исходный вызов через &lt;code&gt;EVERY&lt;/code&gt; , и возвращают:</target>
        </trans-unit>
        <trans-unit id="07d57e57f3a8ced4fc446692cf92ed5425c3284f" translate="yes" xml:space="preserve">
          <source>Whichever version is used, the actual methods are called in the same context (list, scalar, or void) as the original call via &lt;code&gt;EVERY&lt;/code&gt;, and return:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed29deaf6c9f70efd08af26605d88141ad2586b" translate="yes" xml:space="preserve">
          <source>While $FORMAT_TOP_NAME contains the name of the current header format, there is no corresponding mechanism to automatically do the same thing for a footer. Not knowing how big a format is going to be until you evaluate it is one of the major problems. It's on the TODO list.</source>
          <target state="translated">Хотя $FORMAT_TOP_NAME содержит имя текущего формата заголовка,нет соответствующего механизма,который бы автоматически делал то же самое для нижнего колонтитула.Не зная,насколько большим будет формат,пока вы его не оцените,это является одной из основных проблем.Он есть в списке TODO.</target>
        </trans-unit>
        <trans-unit id="b0cd08c49ca70b961592a79d7ad5531909d37f26" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; provides integer-only arithmetic, there is no analogous mechanism to provide automatic rounding or truncation to a certain number of decimal places. For rounding to a certain number of digits, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; is usually the easiest route. See &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;.</source>
          <target state="translated">Хотя &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; обеспечивает арифметику только для целых чисел, не существует аналогичного механизма для обеспечения автоматического округления или усечения до определенного числа десятичных знаков. Для округления до определенного количества цифр &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; обычно самый простой путь. Смотрите &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01f836f2c1198b05b58549da2eae8767a49ca6a1" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;STORABLE_freeze&lt;/code&gt; and &lt;code&gt;STORABLE_thaw&lt;/code&gt; are useful for classes where each instance is independent, this mechanism has difficulty (or is incompatible) with objects that exist as common process-level or system-level resources, such as singleton objects, database pools, caches or memoized objects.</source>
          <target state="translated">Хотя &lt;code&gt;STORABLE_freeze&lt;/code&gt; и &lt;code&gt;STORABLE_thaw&lt;/code&gt; полезны для классов, где каждый экземпляр является независимым, этот механизм имеет трудности (или несовместим) с объектами, которые существуют как общие ресурсы уровня процесса или уровня системы, такие как одиночные объекты, пулы баз данных, кеши или мемоизированные объекты. .</target>
        </trans-unit>
        <trans-unit id="d9b242bc936842344ffd618aab5876b2850c2c1b" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;connect&lt;/code&gt; returns false, the value of &lt;code&gt;$!&lt;/code&gt; indicates whether it should be tried again (by being set to the value &lt;code&gt;EINPROGRESS&lt;/code&gt;, or &lt;code&gt;EWOULDBLOCK&lt;/code&gt; on MSWin32), or whether a permanent error has occurred (e.g. &lt;code&gt;ECONNREFUSED&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a9af13c711e35bbea687932bfa0e243bef5296" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;s///&lt;/code&gt; accepts the &lt;code&gt;/c&lt;/code&gt; flag, it has no effect beyond producing a warning if warnings are enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8eb5c19a610d348554e2fa519e5457ab307a063" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;use integer&lt;/code&gt; provides integer-only arithmetic, there is no analogous mechanism to provide automatic rounding or truncation to a certain number of decimal places. For rounding to a certain number of digits, &lt;code&gt;sprintf()&lt;/code&gt; or &lt;code&gt;printf()&lt;/code&gt; is usually the easiest route. See &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a400d769e405e7503768315d8de6e5c08fa4438" translate="yes" xml:space="preserve">
          <source>While B::Deparse goes to some lengths to try to figure out what your original program was doing, some parts of the language can still trip it up; it still fails even on some parts of Perl's own test suite. If you encounter a failure other than the most common ones described in the BUGS section below, you can help contribute to B::Deparse's ongoing development by submitting a bug report with a small example.</source>
          <target state="translated">В то время как B::Deparse идет на некоторые шаги,чтобы попытаться выяснить,что ваша оригинальная программа делала,некоторые части языка все еще могут его споткнуть;он все еще терпит неудачу даже на некоторых частях собственного тестового набора Perl.Если Вы столкнетесь с неудачей,отличной от наиболее распространённых,описанных в разделе BUGS ниже,Вы можете помочь внести свой вклад в B::Deparse,отправив отчёт об ошибке с небольшим примером.</target>
        </trans-unit>
        <trans-unit id="1fb4e05a5830c846a9dc5981bceec998799ac3ed" translate="yes" xml:space="preserve">
          <source>While BigInt has extensive handling of inf and NaN, certain quirks remain.</source>
          <target state="translated">В то время как BigInt имеет обширный опыт работы с Inf и NaN,некоторые причуды остаются.</target>
        </trans-unit>
        <trans-unit id="fd702ed1f93515e973caeb556144e84284909d1e" translate="yes" xml:space="preserve">
          <source>While C guarantees the ordering specified in the struct definition, between different platforms the definitions might differ</source>
          <target state="translated">В то время как С гарантирует порядок,указанный в определении структуры,между разными платформами определения могут различаться</target>
        </trans-unit>
        <trans-unit id="cc4691f27fe5f793a7b1a252b87e1f8adf7ae71b" translate="yes" xml:space="preserve">
          <source>While Dan Kogai retains the copyright as a maintainer, credit should go to all those involved. See AUTHORS for a list of those who submitted code to the project.</source>
          <target state="translated">В то время как Дан Когай сохраняет авторские права в качестве сопровождающего лица,все,кто в этом участвует,должны быть в этом заинтересованы.Список тех,кто предоставил исходные тексты для проекта,см.в AUTHORS.</target>
        </trans-unit>
        <trans-unit id="5c4e91143f9c9ac2ab71808110a8709426a9bc1f" translate="yes" xml:space="preserve">
          <source>While Google doesn't provide a native toolchain for Android, you can still get one from the Play Store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a13f1442da82f36b90f68d9debc0cec8f1fff2" translate="yes" xml:space="preserve">
          <source>While Math::BigInt has extensive handling of inf and NaN, certain quirks remain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79628255662d7502ebd0e9fa4c3c1aca53d77c4" translate="yes" xml:space="preserve">
          <source>While Perl attempts to keep the vaxc$errno value to be current, if errno is not EVMSERR, it may not be from the current operation.</source>
          <target state="translated">Perl пытается сохранить текущее значение vaxc$errno,но если errno не EVMSERR,то это может быть не из текущей операции.</target>
        </trans-unit>
        <trans-unit id="82ff355555ab6d2ce0a2840754c6edfffe9b0329" translate="yes" xml:space="preserve">
          <source>While Perl passes arguments to functions by reference, C passes arguments by value; to implement a C function which modifies data of one of the &quot;arguments&quot;, the actual argument of this C function would be a pointer to the data. Thus two C functions with declarations</source>
          <target state="translated">В то время как Perl передаёт аргументы в функции по ссылке,C передаёт аргументы по значению;для реализации функции C,которая модифицирует данные одного из &quot;аргументов&quot;,фактическим аргументом этой функции C будет указатель на данные.Таким образом,две функции Си с объявлениями</target>
        </trans-unit>
        <trans-unit id="c23f9c83568988309005d4ebe9f3a7a4c7b974ed" translate="yes" xml:space="preserve">
          <source>While System V IPC isn't so widely used as sockets, it still has some interesting uses. However, you cannot use SysV IPC or Berkeley mmap() to have a variable shared amongst several processes. That's because Perl would reallocate your string when you weren't wanting it to. You might look into the &lt;code&gt;IPC::Shareable&lt;/code&gt; or &lt;code&gt;threads::shared&lt;/code&gt; modules for that.</source>
          <target state="translated">Хотя System V IPC не так широко используется в качестве сокетов, у него все же есть некоторые интересные применения. Однако вы не можете использовать SysV IPC или Berkeley mmap (), чтобы переменная использовалась совместно несколькими процессами. Это потому, что Perl перераспределяет вашу строку, когда вы этого не хотите. Для этого вы можете изучить модули &lt;code&gt;IPC::Shareable&lt;/code&gt; или thread &lt;code&gt;threads::shared&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95ba383e6ad59d1d5877dab883127e0598dee045" translate="yes" xml:space="preserve">
          <source>While a nice extension, it's not portable. The Perl code does admittedly use them if available to gain some extra speed (essentially as a funky form of inlining), but you shouldn't.</source>
          <target state="translated">Хорошая пристройка,но она не портативная.Perl-код,по общему признанию,использует их,если они доступны,чтобы получить некоторую дополнительную скорость (по сути,как фанковая форма вставки),но вы не должны этого делать.</target>
        </trans-unit>
        <trans-unit id="98ac33662fa3d3f638b9cfcc69effe66a6af5d40" translate="yes" xml:space="preserve">
          <source>While a search is in progress, the progress object's &lt;code&gt;reach&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; methods are called like this:</source>
          <target state="translated">Во время поиска методы &lt;code&gt;reach&lt;/code&gt; и &lt;code&gt;done&lt;/code&gt; объекта progress вызываются следующим образом:</target>
        </trans-unit>
        <trans-unit id="5af2731519a4e72226e3efaa5ed68cb8f21ac8fa" translate="yes" xml:space="preserve">
          <source>While apparently a whole nuther program,</source>
          <target state="translated">В то время как,по-видимому,целая чокнутая программа,</target>
        </trans-unit>
        <trans-unit id="2192d44f9e946df5ee1f8628bb7cf84591b693e7" translate="yes" xml:space="preserve">
          <source>While building Perl some changes may be necessary to your Cygwin setup so that Perl builds cleanly. These changes are &lt;b&gt;not&lt;/b&gt; required for normal Perl usage.</source>
          <target state="translated">При сборке Perl могут потребоваться некоторые изменения в вашей настройке Cygwin, чтобы Perl собирался чисто. Эти изменения &lt;b&gt;не&lt;/b&gt; требуются для обычного использования Perl.</target>
        </trans-unit>
        <trans-unit id="917e67f81e56107e856d601af96f9ace961e9a9a" translate="yes" xml:space="preserve">
          <source>While checking, this module collects document properties, e.g. the nodes for hyperlinks (&lt;code&gt;=headX&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; ) and index entries (&lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ). POD translators can use this feature to syntax-check and get the nodes in a first pass before actually starting to convert. This is expensive in terms of execution time, but allows for very robust conversions.</source>
          <target state="translated">Во время проверки этот модуль собирает свойства документа, например, узлы для гиперссылок ( &lt;code&gt;=headX&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; ) и записи индекса ( &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ). Трансляторы POD могут использовать эту функцию для проверки синтаксиса и получения узлов в первом проходе перед фактическим началом преобразования. Это дорого с точки зрения времени выполнения, но обеспечивает очень надежные преобразования.</target>
        </trans-unit>
        <trans-unit id="0b363ec28aa87cd5d2d84a791b40d48ed17d175f" translate="yes" xml:space="preserve">
          <source>While checking, this module collects document properties, e.g. the nodes for hyperlinks (&lt;code&gt;=headX&lt;/code&gt;, &lt;code&gt;=item&lt;/code&gt;) and index entries (&lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt;). POD translators can use this feature to syntax-check and get the nodes in a first pass before actually starting to convert. This is expensive in terms of execution time, but allows for very robust conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba738010d28065fd95a055094f45e1d958083828" translate="yes" xml:space="preserve">
          <source>While civility is required, kindness is encouraged; if you have any doubt about whether you are being civil, simply ask yourself, &quot;Am I being kind?&quot; and aspire to that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c337ad00b019970748effb87047bdf42ffb16bea" translate="yes" xml:space="preserve">
          <source>While experts may argue about these idioms, a novice to Perl guts may prefer a way which is as little Perl-guts-specific as possible, meaning automatic conversion and automatic call generation, as in &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;&quot;Getting the fat out of XSUBs&quot;&lt;/a&gt;. This approach has the additional benefit of protecting the XSUB writer from future changes to the Perl API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6234d5fa2f6fac6ddbcf991bea921371b64250cc" translate="yes" xml:space="preserve">
          <source>While experts may argue about these idioms, a novice to Perl guts may prefer a way which is as little Perl-guts-specific as possible, meaning automatic conversion and automatic call generation, as in &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt;. This approach has the additional benefit of protecting the XSUB writer from future changes to the Perl API.</source>
          <target state="translated">Хотя эксперты могут спорить об этих идиомах, новичок в понимании Perl может предпочесть способ, который как можно меньше зависит от Perl-guts, что означает автоматическое преобразование и автоматическую генерацию вызовов, как в &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;случае с XSUB&lt;/a&gt; . Дополнительным преимуществом этого подхода является защита модуля записи XSUB от будущих изменений Perl API.</target>
        </trans-unit>
        <trans-unit id="601070e02f682375d5e25990b39de3389f3b8c49" translate="yes" xml:space="preserve">
          <source>While in principle the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; operator could be implemented via (and with the same rather severe limitations as) the CRTL &lt;code&gt;vfork()&lt;/code&gt; routine, and while some internal support to do just that is in place, the implementation has never been completed, making &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; currently unavailable. A true kernel &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; is expected in a future version of VMS, and the pseudo-fork based on interpreter threads may be available in a future version of Perl on VMS (see &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;). In the meantime, use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, backticks, or piped filehandles to create subprocesses.</source>
          <target state="translated">Хотя в принципе оператор &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; может быть реализован с помощью (и с теми же довольно серьезными ограничениями) подпрограммы CRTL &lt;code&gt;vfork()&lt;/code&gt; , и хотя имеется некоторая внутренняя поддержка для выполнения именно этого, реализация так и не была завершена, поэтому в настоящее время &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; недоступен. Настоящая &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; ядра () ожидается в будущей версии VMS, а псевдо-вилка, основанная на потоках интерпретатора, может быть доступна в будущей версии Perl на VMS (см. &lt;a href=&quot;perlfork&quot;&gt;Perlfork&lt;/a&gt; ). А пока используйте &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , обратные кавычки или указатели файлов по конвейеру для создания подпроцессов.</target>
        </trans-unit>
        <trans-unit id="99369babd08034c16995edf0279e157f7f0775da" translate="yes" xml:space="preserve">
          <source>While in principle the &lt;code&gt;fork&lt;/code&gt; operator could be implemented via (and with the same rather severe limitations as) the CRTL &lt;code&gt;vfork()&lt;/code&gt; routine, and while some internal support to do just that is in place, the implementation has never been completed, making &lt;code&gt;fork&lt;/code&gt; currently unavailable. A true kernel &lt;code&gt;fork()&lt;/code&gt; is expected in a future version of VMS, and the pseudo-fork based on interpreter threads may be available in a future version of Perl on VMS (see &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;). In the meantime, use &lt;code&gt;system&lt;/code&gt;, backticks, or piped filehandles to create subprocesses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a11b15d87bb1f9501075e6254f16292a57b123f0" translate="yes" xml:space="preserve">
          <source>While in this mode, Perl takes special precautions called</source>
          <target state="translated">В этом режиме Perl принимает специальные меры предосторожности,называемые</target>
        </trans-unit>
        <trans-unit id="177c27cbc619ded10f5ed086056984752bc53bbb" translate="yes" xml:space="preserve">
          <source>While it is common to see these two macros in pairs within an &lt;code&gt;ENTER&lt;/code&gt;/ &lt;code&gt;LEAVE&lt;/code&gt; pair, it is not necessary to match them. It is permitted to invoke &lt;code&gt;FREETMPS&lt;/code&gt; multiple times since the most recent &lt;code&gt;SAVETMPS&lt;/code&gt;; for example in a loop iterating over elements of a list. While you can invoke &lt;code&gt;SAVETMPS&lt;/code&gt; multiple times within a scope pair, it is unlikely to be useful. Subsequent invocations will move the temporaries floor further up, thus effectively trapping the existing temporaries to only be released at the end of the scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c260f0d64ec7ed3061fae8a4547b586a55f37c5" translate="yes" xml:space="preserve">
          <source>While it is permissible to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; a FileCache managed file, do not do so if you are calling &lt;code&gt;FileCache::cacheout&lt;/code&gt; from a package other than which it was imported, or with another module which overrides &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;. If you must, use &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; .</source>
          <target state="translated">Хотя разрешено &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; управляемый файл FileCache, не делайте этого, если вы вызываете &lt;code&gt;FileCache::cacheout&lt;/code&gt; из пакета, отличного от того, который он был импортирован, или с другим модулем, который переопределяет &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; . Если необходимо, используйте &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b707b74369a586a0cf2d7bbc0374b51314db5a7" translate="yes" xml:space="preserve">
          <source>While it is permissible to &lt;code&gt;close&lt;/code&gt; a FileCache managed file, do not do so if you are calling &lt;code&gt;FileCache::cacheout&lt;/code&gt; from a package other than which it was imported, or with another module which overrides &lt;code&gt;close&lt;/code&gt;. If you must, use &lt;code&gt;FileCache::cacheout_close&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a78b4c64649b65dd4cad30d6943b6a01e662f0" translate="yes" xml:space="preserve">
          <source>While it would be nice to make this the default behavior, that would almost certainly break a lot of code, so you must explicitly import these subs and use them instead of the default &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="959732eaecdd2fded6d5f4730815e7ecfbb3c6a3" translate="yes" xml:space="preserve">
          <source>While it's not necessary for documentation changes, new tests or trivial patches, it's often worth explaining how your change works. Even if it's clear to you today, it may not be clear to a porter next month or next year.</source>
          <target state="translated">Хотя это и не обязательно для внесения изменений в документацию,новых тестов или тривиальных патчей,часто стоит объяснять,как работает ваше изменение.Даже если это понятно вам сегодня,это может быть не понятно портье в следующем месяце или в следующем году.</target>
        </trans-unit>
        <trans-unit id="44568ef65eee77bd20a0348b5e9b725eb8d8f779" translate="yes" xml:space="preserve">
          <source>While it's possible to refer directly to these hash keys outside of the class, it's considered a best practice to wrap all access to the attribute with accessor methods.</source>
          <target state="translated">Хотя можно напрямую ссылаться на эти хэш-ключи вне класса,считается лучшей практикой обернуть весь доступ к атрибуту методами доступа.</target>
        </trans-unit>
        <trans-unit id="d0849418f5c8269f5aff84704c4d9acb674dcdcc" translate="yes" xml:space="preserve">
          <source>While it's true that Perl's regular expressions resemble the DFAs (deterministic finite automata) of the egrep(1) program, they are in fact implemented as NFAs (non-deterministic finite automata) to allow backtracking and backreferencing. And they aren't POSIX-style either, because those guarantee worst-case behavior for all cases. (It seems that some people prefer guarantees of consistency, even when what's guaranteed is slowness.) See the book &quot;Mastering Regular Expressions&quot; (from O'Reilly) by Jeffrey Friedl for all the details you could ever hope to know on these matters (a full citation appears in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;).</source>
          <target state="translated">Хотя это правда, что регулярные выражения Perl напоминают DFA (детерминированные конечные автоматы) программы egrep (1), на самом деле они реализованы как NFA (недетерминированные конечные автоматы), позволяющие выполнять обратный поиск и обратную ссылку. И они тоже не в стиле POSIX, потому что они гарантируют наихудшее поведение во всех случаях. (Кажется, что некоторые люди предпочитают гарантии согласованности, даже если гарантирована медленность.) См. Книгу Джеффри Фридла &amp;laquo;Освоение регулярных выражений&amp;raquo; (от О'Рейли), где приведены все подробности, которые вы могли когда-либо надеяться узнать по этим вопросам ( полная цитата находится в &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3329779b59b299850e8b68832610b0b339dc0b1f" translate="yes" xml:space="preserve">
          <source>While it's true that this documentation is somewhat subserious, if you use a program named</source>
          <target state="translated">Хотя это правда,что эта документация в некоторой степени подчинена,если вы используете программу с именем</target>
        </trans-unit>
        <trans-unit id="10a36fcf99a8e338089d469f203ab0168ce94e49" translate="yes" xml:space="preserve">
          <source>While literal lists and named arrays are often interchangeable, that's not the case for hashes. Just because you can subscript a list value like a normal array does not mean that you can subscript a list value as a hash. Likewise, hashes included as parts of other lists (including parameters lists and return lists from functions) always flatten out into key/value pairs. That's why it's good to use references sometimes.</source>
          <target state="translated">Хотя буквальные списки и именные массивы часто взаимозаменяемы,для хэшей это не так.То,что вы можете подписывать значение списка как обычный массив,не означает,что вы можете подписывать значение списка как хэш.Аналогично,хэши,включенные как части других списков (включая списки параметров и возвращаемые из функций списки)всегда разбиваются на пары ключ/значение.Поэтому иногда полезно использовать ссылки.</target>
        </trans-unit>
        <trans-unit id="eca6e56d146060aa14a3a670fa7ed2185164c9b5" translate="yes" xml:space="preserve">
          <source>While most important values in this file</source>
          <target state="translated">Хотя наиболее важные значения в этом файле</target>
        </trans-unit>
        <trans-unit id="8f9b053b8a7e4dedb3bcc2addb9bbd5ef56b5365" translate="yes" xml:space="preserve">
          <source>While no_index tells you what must be ignored when indexing, this spec holds no opinion on how you should get your initial candidate list of things to possibly index. For &quot;normal&quot; distributions you might consider simply indexing the contents of lib/, but there are many fascinating oddities on CPAN and many dists from the days when it was normal to put the main .pm file in the root of the distribution archive - so PAUSE currently indexes all .pm and .PL files that are not either (a) specifically excluded by no_index (b) in &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;xt&lt;/code&gt;, or &lt;code&gt;t&lt;/code&gt; directories, or common 'mistake' directories such as &lt;code&gt;perl5&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393059c305b4f9157627b86935072088d84089d3" translate="yes" xml:space="preserve">
          <source>While none of the built-in data types have any arbitrary size limits (apart from memory size), there are still a few arbitrary limits: a given variable name may not be longer than 251 characters. Line numbers displayed by diagnostics are internally stored as short integers, so they are limited to a maximum of 65535 (higher numbers usually being affected by wraparound).</source>
          <target state="translated">Хотя ни один из встроенных типов данных не имеет произвольных ограничений на размер (кроме размера памяти),все же существует несколько произвольных ограничений:имя заданной переменной не может быть длиннее 251 символа.Номера строк,отображаемые с помощью диагностики,внутренне хранятся в виде коротких целых чисел,поэтому они ограничены максимум 65535 (на более высокие числа обычно влияет обертка).</target>
        </trans-unit>
        <trans-unit id="b09324869be41d3f63ee219787db6a6f9e7b0b52" translate="yes" xml:space="preserve">
          <source>While not currently implemented, it is possible that in the future this function will convert only parts of the path to FILENAME to a short form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f300b76b4f41dcdc512a5b3661d8c1aa39ba74e" translate="yes" xml:space="preserve">
          <source>While not entirely limited to Unix-derived operating systems (e.g., WinSock on PCs provides socket support, as do some VMS libraries), you might not have sockets on your system, in which case this section probably isn't going to do you much good. With sockets, you can do both virtual circuits like TCP streams and datagrams like UDP packets. You may be able to do even more depending on your system.</source>
          <target state="translated">Хотя это и не ограничивается Unix-совместимыми операционными системами (например,WinSock на ПК обеспечивает поддержку сокетов,как и некоторые библиотеки VMS),у вас может не быть сокетов на вашей системе,и в этом случае этот раздел,вероятно,не принесет вам много пользы.С сокетами вы можете делать как виртуальные схемы,такие как TCP-потоки,так и датаграммы,такие как UDP-пакеты.Вы можете сделать еще больше в зависимости от вашей системы.</target>
        </trans-unit>
        <trans-unit id="6ad3cf3a478c4f24fb9ef9675cf14d8e5c5a06f1" translate="yes" xml:space="preserve">
          <source>While running Configure and when building, you are likely to get quite a few of these warnings:</source>
          <target state="translated">При запуске Configure и при сборке вы,скорее всего,получите довольно много таких предупреждений:</target>
        </trans-unit>
        <trans-unit id="9b58fa2736239282292bc4dda51122cd95ae2910" translate="yes" xml:space="preserve">
          <source>While short identifiers like &lt;code&gt;$gotit&lt;/code&gt; are probably ok, use underscores to separate words in longer identifiers. It is generally easier to read &lt;code&gt;$var_names_like_this&lt;/code&gt; than &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; , especially for non-native speakers of English. It's also a simple rule that works consistently with &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; .</source>
          <target state="translated">Хотя короткие идентификаторы, такие как &lt;code&gt;$gotit&lt;/code&gt; , вероятно, подходят, используйте подчеркивание для разделения слов в более длинных идентификаторах. Это , как правило , легче читать &lt;code&gt;$var_names_like_this&lt;/code&gt; чем &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; , особенно для не-носителей английского языка. Это также простое правило, которое последовательно работает с &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d9fa3ada3b6c731a34ad67160b19f8a88213b51" translate="yes" xml:space="preserve">
          <source>While short identifiers like &lt;code&gt;$gotit&lt;/code&gt; are probably ok, use underscores to separate words in longer identifiers. It is generally easier to read &lt;code&gt;$var_names_like_this&lt;/code&gt; than &lt;code&gt;$VarNamesLikeThis&lt;/code&gt;, especially for non-native speakers of English. It's also a simple rule that works consistently with &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3268e08a1d3bd058ed6f797f7794fd47fc37b4" translate="yes" xml:space="preserve">
          <source>While some developers find fatalizing some warnings to be a useful defensive programming technique, using &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; to fatalize all possible warning categories -- including custom ones -- is particularly risky. Therefore, the use of &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; is &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">Хотя некоторые разработчики считают фатализацию некоторых предупреждений полезной техникой защитного программирования, использование &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; для фатализации всех возможных категорий предупреждений, включая пользовательские, особенно рискованно. Поэтому использование &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; не &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;рекомендуется&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f10f744968048551bad6ee098cf44a11a372745" translate="yes" xml:space="preserve">
          <source>While still in that directory, type:</source>
          <target state="translated">Находясь в этом каталоге,напечатайте:</target>
        </trans-unit>
        <trans-unit id="42ffebb3bbe4e65d94b8f907df7dc389a8053ee0" translate="yes" xml:space="preserve">
          <source>While the GNU project includes Perl in its distributions, there's no such thing as &quot;GNU Perl&quot;. Perl is not produced nor maintained by the Free Software Foundation. Perl's licensing terms are also more open than GNU software's tend to be.</source>
          <target state="translated">Хотя проект GNU включает Perl в свои дистрибутивы,такого понятия,как &quot;GNU Perl&quot;,не существует.Perl не производится и не поддерживается Фондом свободного программного обеспечения.Условия лицензирования Perl также более открыты,чем обычно бывает в программах GNU.</target>
        </trans-unit>
        <trans-unit id="84896ae82951e28a26020293e6f0af332fef1cca" translate="yes" xml:space="preserve">
          <source>While the Unicode Standard defines two additional forms of casefolding, one for Turkic languages and one that never maps one character into multiple characters, these are not provided by the Perl core. However, the CPAN module &lt;a href=&quot;Unicode::Casing&quot;&gt;&lt;code&gt;Unicode::Casing&lt;/code&gt;&lt;/a&gt; may be used to provide an implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb3c100d2dfc2d28078ac3b93ee7e431111c075" translate="yes" xml:space="preserve">
          <source>While the Unicode Standard defines two additional forms of casefolding, one for Turkic languages and one that never maps one character into multiple characters, these are not provided by the Perl core; However, the CPAN module &lt;code&gt;Unicode::Casing&lt;/code&gt; may be used to provide an implementation.</source>
          <target state="translated">Хотя стандарт Unicode определяет две дополнительные формы сворачивания регистра, одну для тюркских языков и одну, которая никогда не отображает один символ в несколько символов, они не предусмотрены ядром Perl; Однако модуль &lt;code&gt;Unicode::Casing&lt;/code&gt; CPAN может использоваться для реализации.</target>
        </trans-unit>
        <trans-unit id="761ba2f6d0a7dac9fb4c5d145960b451d6d26420" translate="yes" xml:space="preserve">
          <source>While the key must be a string value (since that's a basic restriction that Perl places on hash keys), the value in the lexicon can currently be of several types: a defined scalar, scalarref, or coderef. The use of these is explained above, in the section 'The &quot;maketext&quot; Method', and Bracket Notation for strings is discussed in the next section.</source>
          <target state="translated">В то время как ключ должен быть строковым значением (поскольку это основное ограничение,которое Perl накладывает на хэш-ключи),значение в лексиконе на данный момент может быть нескольких типов:определенный скаляр,скаляр или кодовый.Использование этих типов описано выше,в разделе &quot;Метод &quot;maketext&quot;,а нотация в скобках для строк обсуждается в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="d08b05105bcedd2fb07dc0399888e4c9d241f3f1" translate="yes" xml:space="preserve">
          <source>While the list of arguments might work fine for one, two or even three arguments, any more arguments become hard for the module user to remember, and hard for the module author to manage. If you want to add a new parameter you will have to add it to the end of the list for backward compatibility, and this will probably make your list order unintuitive. Also, if many elements may be undefined you may see the following unattractive method calls:</source>
          <target state="translated">В то время как список аргументов может работать нормально для одного,двух или даже трех аргументов,любые другие аргументы становятся трудно запомнить пользователю модуля,а также трудно управляются автором модуля.Если вы хотите добавить новый параметр,вам придется добавить его в конец списка для обратной совместимости,и это,вероятно,сделает ваш список неинтуитивно понятным.Также,если многие элементы могут быть неопределенными,вы можете увидеть следующие непривлекательные вызовы методов:</target>
        </trans-unit>
        <trans-unit id="019950bbf16db8b6543648ebb335d2eaf049366f" translate="yes" xml:space="preserve">
          <source>While the mapping &quot;infin&quot; to the character &quot;\x{221E}&quot; will (hopefully) have been already handled by the Pod parser, the presence of the character in this file means that it's reasonably important enough to include in a formatter's table that maps from notable Unicode characters to the codes necessary for rendering them. So for a Unicode-to-*roff mapping, for example, this would merit the entry:</source>
          <target state="translated">В то время как отображение &quot;infin&quot; на символ &quot;\x{221E}&quot; (будем надеяться)уже было обработано парсером Pod,наличие символа в этом файле означает,что достаточно важно включить в таблицу форматировщиков,которые отображают от заметных символов Юникода до кодов,необходимых для их отображения.Так что,например,для отображения символов в формате Юникод-к-*рофф,это заслуживает записи:</target>
        </trans-unit>
        <trans-unit id="549c813f59b3276935336cbd28f55b4770622941" translate="yes" xml:space="preserve">
          <source>While the two classes may differ in many ways, when it comes to the &lt;code&gt;print_content()&lt;/code&gt; method, they are the same. This means that we can try to call the &lt;code&gt;print_content()&lt;/code&gt; method on an object of either class, and &lt;b&gt;we don't have to know what class the object belongs to!&lt;/b&gt;</source>
          <target state="translated">Хотя эти два класса могут отличаться по-разному, когда дело доходит до &lt;code&gt;print_content()&lt;/code&gt; , они одинаковы. Это означает, что мы можем попытаться вызвать метод &lt;code&gt;print_content()&lt;/code&gt; для объекта любого класса, и &lt;b&gt;нам не нужно знать, к какому классу принадлежит объект!&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="76ea82c5269a1424cf449fcf0bff6de44af4f6d8" translate="yes" xml:space="preserve">
          <source>While the word combination &lt;code&gt;character set&lt;/code&gt; has lost this meaning in MIME context since [RFC 2130], the &lt;code&gt;charset&lt;/code&gt; abbreviation has retained it. This is how [RFC 2277] and [RFC 2278] bless &lt;code&gt;charset&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b178eba62086e85a4d0b937f4f56029a87c5eae0" translate="yes" xml:space="preserve">
          <source>While there are Pod codes E&amp;lt;...&amp;gt; and Z&amp;lt;&amp;gt;, these</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f8c54acc4d9406822b250e87f501917fa0a683" translate="yes" xml:space="preserve">
          <source>While there are currently no architecture-specific extensions or modules distributed with perl, the following directories can be used to hold such files (replace the string VERSION by the appropriate version number):</source>
          <target state="translated">Хотя в настоящее время не существует расширений или модулей,специфичных для архитектуры и распространяемых с perl,для хранения таких файлов можно использовать следующие каталоги (замените строку VERSION на соответствующий номер версии):</target>
        </trans-unit>
        <trans-unit id="0c8516dbb58fd38e067d471797d458e282eb5b87" translate="yes" xml:space="preserve">
          <source>While these operations are not questions of life and death, they are needed for a lot of useful scripts. This forces &lt;code&gt;a.out&lt;/code&gt; -style compile of</source>
          <target state="translated">Хотя эти операции не являются вопросами жизни и смерти, они необходимы для множества полезных скриптов. Это заставляет компиляцию в стиле &lt;code&gt;a.out&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d2455a51c401e0d0b17f4da15388c28c0528ee2" translate="yes" xml:space="preserve">
          <source>While these operations are not questions of life and death, they are needed for a lot of useful scripts. This forces &lt;code&gt;a.out&lt;/code&gt;-style compile of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1849a634e96a61e2b3cdef3b11aa962d9aad4c39" translate="yes" xml:space="preserve">
          <source>While this actually can be done, it's much harder than you'd think. For example, this one-liner</source>
          <target state="translated">Хотя это действительно можно сделать,это намного сложнее,чем ты думаешь.Например,этот однослойный</target>
        </trans-unit>
        <trans-unit id="c8b72cb61463146c67f31be1d892fe7495f6bd9f" translate="yes" xml:space="preserve">
          <source>While this allows some (significant?) performance advantages, this makes life much harder for developers, since the above scheme makes it impossible for a DLL to be &quot;linked&quot; to a symbol in the</source>
          <target state="translated">Хотя это и дает некоторые (существенные?)преимущества в производительности,это значительно усложняет жизнь разработчикам,так как вышеуказанная схема делает невозможным &quot;привязку&quot; DLL к символу в</target>
        </trans-unit>
        <trans-unit id="5a4ded2cb5289b97c3775e062e86790bf5432277" translate="yes" xml:space="preserve">
          <source>While this class is currently implemented using the Class::Struct module to build a struct-like class, you shouldn't rely upon this.</source>
          <target state="translated">В то время как данный класс в настоящее время реализован с использованием модуля Class::Struct для построения структуроподобного класса,не стоит полагаться на это.</target>
        </trans-unit>
        <trans-unit id="e68b146940f9324cc2fc3ad49971a5aa379db2a9" translate="yes" xml:space="preserve">
          <source>While this compiles and runs happily, it probably won't do what's expected, namely it doesn't print &quot;Hello World\n&quot; at all; It will on the other hand do exactly what it was told to do, computers being a bit that way inclined. That is, it will print out a newline character, and you'll get what looks like a blank line. It looks like there's 2 variables when (because of the typo) there's really 3:</source>
          <target state="translated">Хотя он собирается и работает счастливо,он,вероятно,не будет делать то,что ожидается,а именно,он не печатает &quot;Hello World\n&quot; вообще;С другой стороны,он будет делать в точности то,что ему было сказано делать,компьютеры немного склонны к этому.То есть,он выведет символ новой строки,и вы получите то,что выглядит как пустая строка.Похоже,что есть 2 переменные,когда (из-за опечатки)их действительно 3:</target>
        </trans-unit>
        <trans-unit id="b959fa7d0d0730d45d9d80c8527dc6a6d9341163" translate="yes" xml:space="preserve">
          <source>While this currently exists in all three implementations perl itself does not use it.</source>
          <target state="translated">Хотя это в настоящее время существует во всех трех реализациях perl сам по себе не использует его.</target>
        </trans-unit>
        <trans-unit id="386467fc98e2754e0e58a98e1b2d3e8dc8fa8075" translate="yes" xml:space="preserve">
          <source>While this currently exists in both implementations, perl itself does not use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f084942a5c159bd226784a38fd066229baa22988" translate="yes" xml:space="preserve">
          <source>While this document is intended to be useful to all module authors, it is particularly aimed at authors who wish to publish their modules on CPAN.</source>
          <target state="translated">Хотя этот документ предназначен для всех авторов модулей,он особенно ориентирован на авторов,желающих опубликовать свои модули на CPAN.</target>
        </trans-unit>
        <trans-unit id="66c1c2ee830cc759765d36b85a240cf7d1bab82e" translate="yes" xml:space="preserve">
          <source>While this feature is most commonly used to explicitly call methods inherited from an ancestor class, there is no technical restriction that enforces this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1785d6466e3128c272757d8a3931f08ab9e01f53" translate="yes" xml:space="preserve">
          <source>While this is legal practice, it is certainly dubious, and downright fatal in at least one platform: for example VMS cc considers this a fatal error. One cause for people often making this mistake is that a &quot;naked char&quot; and therefore dereferencing a &quot;naked char pointer&quot; have an undefined signedness: it depends on the compiler and the flags of the compiler and the underlying platform whether the result is signed or unsigned. For this very same reason using a 'char' as an array index is bad.</source>
          <target state="translated">Хотя это юридическая практика,она,безусловно,сомнительна и фатальна,по крайней мере,на одной платформе:например,VMS cc считает это фатальной ошибкой.Одна из причин,по которой люди часто совершают эту ошибку,заключается в том,что &quot;голый char&quot; и,следовательно,разыменование &quot;голого указателя char&quot; имеет неопределенную подпись:это зависит от компилятора и флагов компилятора и лежащей в его основе платформы,является ли результат знаковым или беззнаковым.По этой же причине плохо использовать 'char' в качестве индекса массива.</target>
        </trans-unit>
        <trans-unit id="40200d6701039334e5e5bffbb6cca8ab91bc30ff" translate="yes" xml:space="preserve">
          <source>While this is true on the surface, it's much more efficient to process the file one line or record at a time because then you don't have to read the whole thing into memory at once. It also gives you finer control of the whole process, letting you kill off the child process early if you'd like.</source>
          <target state="translated">Хотя на первый взгляд это так,гораздо эффективнее обрабатывать файл по одной строке или запись за раз,потому что тогда вам не придется считывать все это в память сразу.Это также дает вам более тонкий контроль над всем процессом,позволяя вам убить дочерний процесс рано,если вы хотите.</target>
        </trans-unit>
        <trans-unit id="9790d6e959def47c7e50e558f607fe7ba4374a90" translate="yes" xml:space="preserve">
          <source>While this might be too cumbersome to implement in event-based Pod parsers, it is straightforward for parsers that return parse trees.</source>
          <target state="translated">Хотя это может быть слишком громоздко для реализации в парсерах Pod на основе событий,для парсеров,которые возвращают деревья для разбора,это просто.</target>
        </trans-unit>
        <trans-unit id="81aa0dd02571c7973cd68f4d9f805b1c67ff2c9c" translate="yes" xml:space="preserve">
          <source>While this might by accident work in some platform (where IV happens to be an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;), in general it cannot. IV might be something larger. Even worse the situation is with more specific types (defined by Perl's configuration step in</source>
          <target state="translated">Хотя это может случайно сработать на какой-то платформе (где IV является &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; ), в целом это невозможно. IV может быть чем-то большим. Еще хуже ситуация с более конкретными типами (определенными на этапе настройки Perl в</target>
        </trans-unit>
        <trans-unit id="7f1683bf56a3090bff1bb086f826f7e09370112c" translate="yes" xml:space="preserve">
          <source>While this might by accident work in some platform (where IV happens to be an &lt;code&gt;int&lt;/code&gt;), in general it cannot. IV might be something larger. Even worse the situation is with more specific types (defined by Perl's configuration step in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82be9c7a2de102e2677bf88ba7443091644097cd" translate="yes" xml:space="preserve">
          <source>While this works reasonably well for unidirectional communication, what about bidirectional communication? The most obvious approach doesn't work:</source>
          <target state="translated">В то время как для однонаправленной связи это работает достаточно хорошо,как насчет двунаправленной связи? Самый очевидный подход не работает:</target>
        </trans-unit>
        <trans-unit id="26ea84a69e787188d7dfd7dc7bac4a8b95950ee8" translate="yes" xml:space="preserve">
          <source>While threads bring a new set of useful tools, they also bring a number of pitfalls. One pitfall is the race condition:</source>
          <target state="translated">В то время как потоки приносят новый набор полезных инструментов,они также приносят ряд подводных камней.Один из них-состояние гонки:</target>
        </trans-unit>
        <trans-unit id="0369ef7f3a86c9ade18a8f113608ef11b27c9fcb" translate="yes" xml:space="preserve">
          <source>While thumbing through the &lt;a href=&quot;Date::ICal&quot;&gt;Date::ICal&lt;/a&gt; man page, I came across this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb55e176d75bb6afa2c9779e5d12c3767454404" translate="yes" xml:space="preserve">
          <source>While trying to read from his caller-id box, the notorious Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; , after much gnashing of teeth and fighting with &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, POSIX's &lt;code&gt;tcgetattr&lt;/code&gt; business, and various other functions that go bump in the night, finally came up with this:</source>
          <target state="translated">Пытаясь читать данные из своего ящика с идентификатором вызывающего абонента, пресловутый Джейми Завински &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; после долгого скрежета зубами и борьбы с &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;tcgetattr&lt;/code&gt; Business POSIX и различными другими функциями, которые не работают ночью, наконец придумал это:</target>
        </trans-unit>
        <trans-unit id="3d9a29cb2e71d84a90b207c5a091106e69ab3f88" translate="yes" xml:space="preserve">
          <source>While trying to read from his caller-id box, the notorious Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt;, after much gnashing of teeth and fighting with &lt;code&gt;sysread&lt;/code&gt;, &lt;code&gt;sysopen&lt;/code&gt;, POSIX's &lt;code&gt;tcgetattr&lt;/code&gt; business, and various other functions that go bump in the night, finally came up with this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d7592c228741a449aa83d6358c7b5dbac2c422e" translate="yes" xml:space="preserve">
          <source>While trying to resolve method call %s-&amp;gt;%s() can not locate package &quot;%s&quot; yet it is mentioned in @%s::ISA (perhaps you forgot to load &quot;%s&quot;?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffa8b7afc028fdbcdab4b6dea3d1eb48e0f55ad" translate="yes" xml:space="preserve">
          <source>While using the standard</source>
          <target state="translated">При использовании стандарта</target>
        </trans-unit>
        <trans-unit id="c059f6308f685a568f9b74b626f917b18a45a114" translate="yes" xml:space="preserve">
          <source>While version objects overload stringification, to portably convert &lt;code&gt;$^V&lt;/code&gt; into its string representation, use &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; conversion, which works for both v-strings or version objects:</source>
          <target state="translated">В то время как версия объекты перегрузки stringification, чтобы переносимый конвертировать &lt;code&gt;$^V&lt;/code&gt; в строковом представление, использование &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; &amp;laquo;s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; преобразование, который работает как для клиновых строк или версий объектов:</target>
        </trans-unit>
        <trans-unit id="7e7742e29582b552f48253992f05bd5349646ba9" translate="yes" xml:space="preserve">
          <source>While version objects overload stringification, to portably convert &lt;code&gt;$^V&lt;/code&gt; into its string representation, use &lt;code&gt;sprintf()&lt;/code&gt;'s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; conversion, which works for both v-strings or version objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5995cddc89ffbbaa6e8a0013934033bfcd3e1f" translate="yes" xml:space="preserve">
          <source>While versions earlier than 5.8.1 had threads they contain too many bugs to support.</source>
          <target state="translated">Хотя версии ранее 5.8.1 имели потоки,они содержат слишком много ошибок для поддержки.</target>
        </trans-unit>
        <trans-unit id="daa9a857c615b0eef13a54df6fdfd26532388959" translate="yes" xml:space="preserve">
          <source>While we normally think of patterns as being delimited with &lt;code&gt;/&lt;/code&gt; characters, they can be delimited by almost any character. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; describes this. For example, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; above uses braces as delimiters. Selecting another delimiter can avoid quoting the delimiter within the pattern:</source>
          <target state="translated">Хотя мы обычно думаем, что шаблоны разделены символами &lt;code&gt;/&lt;/code&gt; , их можно разделить практически любым символом. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; описывает это. Например, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; выше использует фигурные скобки в качестве разделителей. Выбор другого разделителя позволяет избежать использования разделителя внутри шаблона:</target>
        </trans-unit>
        <trans-unit id="39f1ea1d3e2074839c9819aaf86819467fb5bb22" translate="yes" xml:space="preserve">
          <source>While we normally think of patterns as being delimited with &lt;code&gt;/&lt;/code&gt; characters, they can be delimited by almost any character. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; describes this. For example, the &lt;code&gt;s///&lt;/code&gt; above uses braces as delimiters. Selecting another delimiter can avoid quoting the delimiter within the pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09af51d2e240602d6d93896cb9f587c7a82f4e64" translate="yes" xml:space="preserve">
          <source>While we strongly suggest you don't build your objects from scratch, you should know the term &lt;b&gt;bless&lt;/b&gt;. A &lt;b&gt;blessed&lt;/b&gt; data structure (aka &quot;a referent&quot;) is an object. We sometimes say that an object has been &quot;blessed into a class&quot;.</source>
          <target state="translated">Хотя мы настоятельно рекомендуем вам не создавать свои объекты с нуля, вам следует знать термин &amp;laquo; &lt;b&gt;благословение&amp;raquo;&lt;/b&gt; . &lt;b&gt;Благословлены&lt;/b&gt; структура данных ( так называемый &amp;laquo;референт&amp;raquo;) является объектом. Иногда мы говорим, что объект был &amp;laquo;благословлен в класс&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="562c113d1f1007e0a6502247b3772bac3c2d33a2" translate="yes" xml:space="preserve">
          <source>While we usually think of quotes as literal values, in Perl they function as operators, providing various kinds of interpolating and pattern matching capabilities. Perl provides customary quote characters for these behaviors, but also provides a way for you to choose your quote character for any of them. In the following table, a &lt;code&gt;{}&lt;/code&gt; represents any pair of delimiters you choose.</source>
          <target state="translated">Хотя мы обычно думаем о кавычках как о буквальных значениях, в Perl они функционируют как операторы, предоставляя различные виды интерполяции и возможности сопоставления с образцом. Perl предоставляет обычные символы кавычек для этого поведения, но также дает вам возможность выбрать символ кавычек для любого из них. В следующей таблице &lt;code&gt;{}&lt;/code&gt; представляет любую пару разделителей по вашему выбору.</target>
        </trans-unit>
        <trans-unit id="34200b2d58936bc37828d3e87d2eebbab2c0f898" translate="yes" xml:space="preserve">
          <source>While we're here, take a closer look at the '&lt;b&gt;x&lt;/b&gt;' command, it's really useful and will merrily dump out nested references, complete objects, partial objects - just about whatever you throw at it:</source>
          <target state="translated">Пока мы здесь, внимательно рассмотрим команду ' &lt;b&gt;x&lt;/b&gt; ', она действительно полезна и с удовольствием выгружает вложенные ссылки, полные объекты, частичные объекты - практически все, что вы на нее набросите:</target>
        </trans-unit>
        <trans-unit id="00e2fed4a06f99f6100461a2d8cbb333f4d09501" translate="yes" xml:space="preserve">
          <source>While you can mix double colons with singles quotes, the quotes must come after the colons: &lt;code&gt;$::::'foo&lt;/code&gt; and &lt;code&gt;$foo::'bar&lt;/code&gt; are legal, but &lt;code&gt;$::'::foo&lt;/code&gt; and &lt;code&gt;$foo'::bar&lt;/code&gt; are not.</source>
          <target state="translated">Хотя вы можете смешивать двойные двоеточия с одиночными кавычками, кавычки должны стоять после двоеточия: &lt;code&gt;$::::'foo&lt;/code&gt; и &lt;code&gt;$foo::'bar&lt;/code&gt; допустимы, но &lt;code&gt;$::'::foo&lt;/code&gt; и &lt;code&gt;$foo'::bar&lt;/code&gt; не.</target>
        </trans-unit>
        <trans-unit id="078d591b0ade8bcb579420345c7df7b2c236f00e" translate="yes" xml:space="preserve">
          <source>While you can use arbitrary unique IDs for lexicon keys (like &quot;_min_larger_max_error&quot;), it is often useful for if an entry's key is itself a valid value, like this example error message:</source>
          <target state="translated">Хотя для лексических ключей можно использовать произвольные уникальные идентификаторы (например,&quot;_min_larger_max_error&quot;),часто бывает полезно,если ключ записи сам по себе является допустимым значением,как,например,в данном примере сообщения об ошибке:</target>
        </trans-unit>
        <trans-unit id="59ac30a04c89545845f0a1e87ea492a8c9c597ff" translate="yes" xml:space="preserve">
          <source>While you're doing that, make really sure you haven't missed a module similar to the one you're about to write.</source>
          <target state="translated">Пока вы это делаете,убедитесь,что вы не пропустили модуль,похожий на тот,который вы собираетесь написать.</target>
        </trans-unit>
        <trans-unit id="95a6dc4463afddf0b399fee2185874a12ea0df02" translate="yes" xml:space="preserve">
          <source>While:</source>
          <target state="translated">While:</target>
        </trans-unit>
        <trans-unit id="c6568ae799534002dc040ff86ba3511a9bd4bd58" translate="yes" xml:space="preserve">
          <source>Whilst control is in the library, an error condition occurs. You have previously set up a Perl callback to handle this situation, so it will get executed. Once the callback has finished, control will drop back to Perl again. Here is what the flow of control will be like in that situation</source>
          <target state="translated">В то время как управление находится в библиотеке,возникает состояние ошибки.Вы предварительно настроили обратный вызов на Perl для обработки этой ситуации,так что он будет выполнен.После завершения обратного вызова элемент управления снова вернется на Perl.Вот как будет выглядеть поток управления в этой ситуации.</target>
        </trans-unit>
        <trans-unit id="80e9be96d98a6599b821f35e0fd1d6289ce559ee" translate="yes" xml:space="preserve">
          <source>White space, hyphens, and underscores ARE significant except for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="44c1e2cd5ccb90bd73774fc5e53e7773e341381c" translate="yes" xml:space="preserve">
          <source>Whitespace and IPC::Open3 / system()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82098c40334ef85fcca05587546e9cc28f23e2a9" translate="yes" xml:space="preserve">
          <source>Whitespace and IPC::Run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="974608074eb6dc3e2345e2aa4e42c412340d3d49" translate="yes" xml:space="preserve">
          <source>Whitespace and special characters in the filename argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b1deb6ad1643a6518bffe011e47a1bbf2cd01d" translate="yes" xml:space="preserve">
          <source>Whitespace does not delimit fileglobs.</source>
          <target state="translated">Пробельные символы не разделяют файловые глобусы.</target>
        </trans-unit>
        <trans-unit id="df7fa704cbceacef574fb86983159dfe4b06ae43" translate="yes" xml:space="preserve">
          <source>Whitespace in filenames is tolerated on most systems, but not all, and even on systems where it might be tolerated, some utilities might become confused by such whitespace.</source>
          <target state="translated">Пробельные символы в именах файлов допускаются на большинстве систем,но не на всех,и даже на системах,где они допускаются,некоторые утилиты могут быть запутаны такими пробелами.</target>
        </trans-unit>
        <trans-unit id="baf39f9fbe05bd8902b826d4b1716bd33c1e5022" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored.</source>
          <target state="translated">Уайтспейс игнорируется.</target>
        </trans-unit>
        <trans-unit id="5899e5ae54fc72cc82eec99924af8577c33c2cbc" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored. The alias value can be a single attribute or a space-separated list of attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09822d18c062da75d056f267dd113eb02444df2b" translate="yes" xml:space="preserve">
          <source>Whitespace is irrelevant:</source>
          <target state="translated">Уайтспейс не имеет значения:</target>
        </trans-unit>
        <trans-unit id="e6027b651e819925aa47dc4c27f8a2f557b14aae" translate="yes" xml:space="preserve">
          <source>Who Needs Complicated Data Structures?</source>
          <target state="translated">Кому нужны сложные структуры данных?</target>
        </trans-unit>
        <trans-unit id="ce404d98012c2a69e116523288638e2bddf0b8c2" translate="yes" xml:space="preserve">
          <source>Who supports Perl? Who develops it? Why is it free?</source>
          <target state="translated">Кто поддерживает Перла? Кто его разрабатывает? Почему он свободен?</target>
        </trans-unit>
        <trans-unit id="6272068bf74683d289db3b55d0ea826c2bd453e3" translate="yes" xml:space="preserve">
          <source>Who wrote it (use AUTHORS for multiple people). It's a good idea to include your current e-mail address (or some e-mail address to which bug reports should be sent) or some other contact information so that users have a way of contacting you. Remember that program documentation tends to roam the wild for far longer than you expect and pick a contact method that's likely to last.</source>
          <target state="translated">Кто его написал (используйте АВТОРЫ для нескольких человек).Хорошей идеей будет включить ваш текущий электронный адрес (или какой-нибудь электронный адрес,на который следует отправлять сообщения об ошибках)или какую-нибудь другую контактную информацию,чтобы у пользователей была возможность связаться с вами.Помните,что документация программы имеет тенденцию блуждать в дикой природе гораздо дольше,чем вы ожидаете,и выбирайте способ связи,который,скорее всего,продлится дольше.</target>
        </trans-unit>
        <trans-unit id="cf619e0d870f5f00d0e62715b2fa9d9354bf3093" translate="yes" xml:space="preserve">
          <source>Whoops! Looks like it's unimplemented. Assume you don't have the time to fix this. [11] Normally, you'd just comment out the test and put a note in a todo list somewhere. Instead, explicitly state &quot;this test will fail&quot; by wrapping it in a &lt;code&gt;TODO&lt;/code&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4357002b49a216cedec63d85f662f9560e6c2af" translate="yes" xml:space="preserve">
          <source>Whoops! You just put a tab and a formfeed into that filename! Remember that within double quoted strings (&quot;like\this&quot;), the backslash is an escape character. The full list of these is in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;&quot;Quote and Quote-like Operators&quot; in perlop&lt;/a&gt;. Unsurprisingly, you don't have a file called &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22ef207f555182408b6d1958c0f8d72d42ebbcf" translate="yes" xml:space="preserve">
          <source>Whoops! You just put a tab and a formfeed into that filename! Remember that within double quoted strings (&quot;like\this&quot;), the backslash is an escape character. The full list of these is in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;. Unsurprisingly, you don't have a file called &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</source>
          <target state="translated">Ой! Вы просто вставляете вкладку и канал в это имя файла! Помните, что в строках с двойными кавычками (&amp;laquo;как \ это&amp;raquo;) обратная косая черта является escape-символом. Полный их список находится в &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators в perlop&lt;/a&gt; . Неудивительно, что в вашей устаревшей файловой системе DOS нет файла с именем &amp;laquo;c: (tab) emp (formfeed) oo&amp;raquo; или &amp;laquo;c: (tab) emp (formfeed) oo.exe&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="4b60ac899852ccb4f23a0cc5a329b0dd058c1185" translate="yes" xml:space="preserve">
          <source>Whoops, a failure! [4] &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; helpfully lets us know on what line the failure occurred, but not much else. We were supposed to get 17, but we didn't. What did we get?? Dunno. You could re-run the test in the debugger or throw in some print statements to find out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0f41e4219d3445a18de71b89eb22ea90d39e82" translate="yes" xml:space="preserve">
          <source>Whoops. You should instead use this, which will fail if the file doesn't exist:</source>
          <target state="translated">Упс.Вместо этого следует использовать это,которое не будет работать,если файл не будет существовать:</target>
        </trans-unit>
        <trans-unit id="21e2caea4476d26af34541ca7c909c7ff2fa4a7f" translate="yes" xml:space="preserve">
          <source>Why</source>
          <target state="translated">Why</target>
        </trans-unit>
        <trans-unit id="9560992747d1a6605928cb6a17f56014fb292bd8" translate="yes" xml:space="preserve">
          <source>Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?</source>
          <target state="translated">Почему я получаю длинные десятичные цифры (например,19.9499999999999)вместо цифр,которые я должен получать (например,19.95)?</target>
        </trans-unit>
        <trans-unit id="dc84c992e3edcd39e94928310a7c42a03b0e34c8" translate="yes" xml:space="preserve">
          <source>Why aren't my random numbers random?</source>
          <target state="translated">Почему мои случайные числа не случайны?</target>
        </trans-unit>
        <trans-unit id="55451ebd45b1e100db71c6105ddc04433d37cb2f" translate="yes" xml:space="preserve">
          <source>Why can't I get the output of a command with system()?</source>
          <target state="translated">Почему я не могу получить результат команды с помощью system()?</target>
        </trans-unit>
        <trans-unit id="6283f33f8240aceff8b5bf7c89ea62586d7996ea" translate="yes" xml:space="preserve">
          <source>Why can't I just open(FH, &quot;&amp;gt;file.lock&quot;)?</source>
          <target state="translated">Почему я не могу просто открыть (FH, &quot;&amp;gt; file.lock&quot;)?</target>
        </trans-unit>
        <trans-unit id="45f36238b104ed9ce41136ab2cd5676c9546b754" translate="yes" xml:space="preserve">
          <source>Why can't I use &quot;C:\temp\foo&quot; in DOS paths? Why doesn't `C:\temp\foo.exe` work?</source>
          <target state="translated">Почему я не могу использовать &quot;C:\temp\foo&quot; в путях DOS? Почему не работает `C:\temp\foo.exe`?</target>
        </trans-unit>
        <trans-unit id="7cf9bf3687394740ded1b7a3b49b00f8b7f479e0" translate="yes" xml:space="preserve">
          <source>Why can't a method included in this same file be found?</source>
          <target state="translated">Почему нельзя найти метод,включенный в этот же файл?</target>
        </trans-unit>
        <trans-unit id="c1b368f947117e2802b241b52fd0f345164c6250" translate="yes" xml:space="preserve">
          <source>Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?</source>
          <target state="translated">Почему мой скрипт не может прочитать из STDIN после того,как я дал ему EOF (^D на Unix,^Z на MS-DOS)?</target>
        </trans-unit>
        <trans-unit id="12d1b0fba90164d9432c0961ee9c0f59f511f752" translate="yes" xml:space="preserve">
          <source>Why can't the part of an Email address after the @ be used as the hostname ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a35a43f2543633bf09ecfd8ed381f93a2e351c4" translate="yes" xml:space="preserve">
          <source>Why chimera build?</source>
          <target state="translated">Почему химеру строят?</target>
        </trans-unit>
        <trans-unit id="4ad29870738240c44cf5d008e9ef6e5a830b4811" translate="yes" xml:space="preserve">
          <source>Why did MakeMaker reinvent the build configuration wheel? Why not just use autoconf or automake or ppm or Ant or ...</source>
          <target state="translated">Почему MakeMaker заново изобрел колесо конфигурации сборки? Почему бы просто не использовать autoconf или automake,или ppm,или Ant,или ...</target>
        </trans-unit>
        <trans-unit id="9c94cf8ad35b8d40bcd1d8a24897df534e24a65c" translate="yes" xml:space="preserve">
          <source>Why do I get asked the same questions every time I start the shell?</source>
          <target state="translated">Почему мне задают одни и те же вопросы каждый раз,когда я начинаю оболочку?</target>
        </trans-unit>
        <trans-unit id="88d20a17cd64b1f5b322facdeee78dd428855e4f" translate="yes" xml:space="preserve">
          <source>Why do I get weird spaces when I print an array of lines?</source>
          <target state="translated">Почему я получаю странные пробелы,когда печатаю массив строк?</target>
        </trans-unit>
        <trans-unit id="22c242ee2f7e6a5499b05c8e9ef2302a328d950b" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use &amp;lt;*&amp;gt;?</source>
          <target state="translated">Почему я иногда получаю &amp;laquo;слишком длинный список аргументов&amp;raquo;, когда использую &amp;lt;*&amp;gt;?</target>
        </trans-unit>
        <trans-unit id="b24284283ebf1fc2287cf9d0bdc0093551feae63" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use ?</source>
          <target state="translated">Почему иногда я получаю &quot;Слишком длинный список аргументов&quot;,когда использую его?</target>
        </trans-unit>
        <trans-unit id="63e6abc6f1a440467925da9b75e53aa88bf445d6" translate="yes" xml:space="preserve">
          <source>Why do Perl operators have different precedence than C operators?</source>
          <target state="translated">Почему операторы Perl имеют иной приоритет,чем операторы C?</target>
        </trans-unit>
        <trans-unit id="ef2253bfbc8ad66388d03d0bb9e87b886d907b29" translate="yes" xml:space="preserve">
          <source>Why do regex character classes sometimes match only in the ASCII range?</source>
          <target state="translated">Почему регекс-классы символов иногда совпадают только в диапазоне ASCII?</target>
        </trans-unit>
        <trans-unit id="fe1dc5c347574cf3a08e8eebfbeb7750b39e6b8c" translate="yes" xml:space="preserve">
          <source>Why do setuid perl scripts complain about kernel problems?</source>
          <target state="translated">Почему скрипты setuid perl жалуются на проблемы с ядром?</target>
        </trans-unit>
        <trans-unit id="026df39820ea4af121bee1f807b65636d02b2c10" translate="yes" xml:space="preserve">
          <source>Why do some characters not uppercase or lowercase correctly?</source>
          <target state="translated">Почему некоторые символы неправильно написаны прописными или строчными буквами?</target>
        </trans-unit>
        <trans-unit id="c99d6ee81fb9e8a95f7bcc8c77d79b83dd80d118" translate="yes" xml:space="preserve">
          <source>Why do you want to do that? :-)</source>
          <target state="translated">Почему ты хочешь это сделать? :-)</target>
        </trans-unit>
        <trans-unit id="72bb63a51859ce8a03efe317ce769e0ebbe394ee" translate="yes" xml:space="preserve">
          <source>Why does Net::FTP not implement mput and mget methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f2d2fc2e6067abbcff0c6297133f00fea08094" translate="yes" xml:space="preserve">
          <source>Why does Net::SMTP not do DNS MX lookups ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd94a8382da48e70b41ef67567b746b186c9a0e6" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">Почему Perl позволяет мне удалять файлы только для чтения? Почему -i файлы защищены от взлома? Разве это не ошибка на Perl?</target>
        </trans-unit>
        <trans-unit id="cc878c7b17c2f51ef8a429a9375cb383410dd74c" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does &lt;code&gt;-i&lt;/code&gt; clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">Почему Perl позволяет мне удалять файлы, доступные только для чтения? Почему &lt;code&gt;-i&lt;/code&gt; сбивает защищенные файлы? Разве это не ошибка Perl?</target>
        </trans-unit>
        <trans-unit id="cab7997afd3e855e0bc949d3ba08b5a07d77bad2" translate="yes" xml:space="preserve">
          <source>Why does defined() return true on empty arrays and hashes?</source>
          <target state="translated">Почему функция defined()возвращает true на пустых массивах и хэшах?</target>
        </trans-unit>
        <trans-unit id="a9078f034de31f1b296232dfb6a8a4e24d9d3fe0" translate="yes" xml:space="preserve">
          <source>Why does passing a subroutine an undefined element in a hash create it?</source>
          <target state="translated">Почему передача подпрограммы неопределенного элемента в хэше создает ее?</target>
        </trans-unit>
        <trans-unit id="7586fa4c0b5fc90f209bbbf4172abb17863eb05e" translate="yes" xml:space="preserve">
          <source>Why does using $&amp;amp;, $`, or $' slow my program down?</source>
          <target state="translated">Почему использование $ &amp;amp;, $ `или $ 'замедляет мою программу?</target>
        </trans-unit>
        <trans-unit id="d0d6812625a87b8571932c2c534a16df1d30c46a" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = &amp;lt;$fh&amp;gt;;&quot; work right?</source>
          <target state="translated">Почему не &quot;my ($ foo) = &amp;lt;$ fh&amp;gt;;&quot; работать правильно?</target>
        </trans-unit>
        <trans-unit id="dce612b6a2414fd18ba042c0e4b6d8009b148ed5" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = ;&quot; work right?</source>
          <target state="translated">Почему &quot;my($foo)=;&quot; не работает правильно?</target>
        </trans-unit>
        <trans-unit id="5027566591e947a691e8c94cf6484817ceca1f52" translate="yes" xml:space="preserve">
          <source>Why doesn't &amp;amp; work the way I want it to?</source>
          <target state="translated">Почему &amp;amp; не работает так, как я хочу?</target>
        </trans-unit>
        <trans-unit id="4cf8f75bbab1ae3d6a9b3cc517f4738f093df66a" translate="yes" xml:space="preserve">
          <source>Why doesn't glob(&quot;*.*&quot;) get all the files?</source>
          <target state="translated">Почему Glob(&quot;*.*&quot;)не получает все файлы?</target>
        </trans-unit>
        <trans-unit id="2deaa0032d55ad3bbe4d463b92dc4d6876271de7" translate="yes" xml:space="preserve">
          <source>Why doesn't my sockets program work under System V (Solaris)? What does the error message &quot;Protocol not supported&quot; mean?</source>
          <target state="translated">Почему моя программа сокетов не работает в Системе V (Solaris)? Что означает сообщение об ошибке &quot;Протокол не поддерживается&quot;?</target>
        </trans-unit>
        <trans-unit id="94b7e3ba62840111acddb7ecbcec36ba2e7bc4b2" translate="yes" xml:space="preserve">
          <source>Why doesn't open() return an error when a pipe open fails?</source>
          <target state="translated">Почему функция open()не возвращает ошибку при неудачном открытии трубы?</target>
        </trans-unit>
        <trans-unit id="39d80c781157cb75a05623de25db34f558131470" translate="yes" xml:space="preserve">
          <source>Why don't Perl one-liners work on my DOS/Mac/VMS system?</source>
          <target state="translated">Почему Perl-однолинеры не работают на моей системе DOS/Mac/VMS?</target>
        </trans-unit>
        <trans-unit id="7efb6bacfd459d208d2e83d3ccd6f5a6e06b31a2" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;</source>
          <target state="translated">Почему бы мне не &amp;lt;</target>
        </trans-unit>
        <trans-unit id="d55b9cceedd9f6975831dcd97371f91faa17e9ba" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;&amp;lt;HERE documents work?</source>
          <target state="translated">Почему мои &amp;lt;&amp;lt; ЗДЕСЬ документы не работают?</target>
        </trans-unit>
        <trans-unit id="1b729d456f5e2de755ce9ca47664753dfbd6fc06" translate="yes" xml:space="preserve">
          <source>Why don't my tied hashes make the defined/exists distinction?</source>
          <target state="translated">Почему бы моим завязанным хешам не провести различие между определённым и существующим?</target>
        </trans-unit>
        <trans-unit id="ec879bc347cf004a28479d385b991508d06231e9" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with &lt;code&gt;\b&lt;/code&gt; work for me?</source>
          <target state="translated">Почему мне не подходит поиск по границе слов с &lt;code&gt;\b&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="123e5244abcc6475513e58c7be3baf1e624a09b7" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with \b work for me?</source>
          <target state="translated">Почему бы не поискать слова на сайте \b?</target>
        </trans-unit>
        <trans-unit id="aa0f337d4d9c4331ea81d21ad3497b56fec40614" translate="yes" xml:space="preserve">
          <source>Why dynamic linking?</source>
          <target state="translated">Почему динамическая связь?</target>
        </trans-unit>
        <trans-unit id="4dfd253727c4f99a421a3b97c6c33e70ca139825" translate="yes" xml:space="preserve">
          <source>Why is int() broken?</source>
          <target state="translated">Почему int()сломан?</target>
        </trans-unit>
        <trans-unit id="a9539bbca1f0e44580627232613c4e6433a9dda3" translate="yes" xml:space="preserve">
          <source>Why is there Perl source in my database?</source>
          <target state="translated">Почему в моей базе данных есть источник Perl?</target>
        </trans-unit>
        <trans-unit id="5376410df92e4e194b5ef26e3120b8356d39f687" translate="yes" xml:space="preserve">
          <source>Why isn't my octal data interpreted correctly?</source>
          <target state="translated">Почему мои восьмеричные данные не интерпретируются правильно?</target>
        </trans-unit>
        <trans-unit id="76e636f7e8860a670fadde05e6d7c8a9de0467dd" translate="yes" xml:space="preserve">
          <source>Why not just use &amp;lt;insert other build config tool here&amp;gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adf1b58b38027864f2d28cd98aeb834dee11ea7" translate="yes" xml:space="preserve">
          <source>Why strange names?</source>
          <target state="translated">Почему странные имена?</target>
        </trans-unit>
        <trans-unit id="d2f963c70a1ed1fc561f572fe023203fb76a83ae" translate="yes" xml:space="preserve">
          <source>Why the heck Encode API is different?</source>
          <target state="translated">Почему,черт возьми,API Encode отличается?</target>
        </trans-unit>
        <trans-unit id="2d967f841c57d824cac2c9266688fd2aa1c5db9c" translate="yes" xml:space="preserve">
          <source>Why use ppport.h?</source>
          <target state="translated">Зачем использовать ppport.h?</target>
        </trans-unit>
        <trans-unit id="df4212a2d988730cb90863e6978ac9cd91d10bdc" translate="yes" xml:space="preserve">
          <source>Why would you want a hash of lists? Let's take a simple example: You have a file of city and country names, like this:</source>
          <target state="translated">Зачем тебе гашиш списков? Давайте возьмем простой пример:У вас есть файл с названиями городов и стран,вот так:</target>
        </trans-unit>
        <trans-unit id="7f3771c096b7c324730a1a8a01295eb54a206ffa" translate="yes" xml:space="preserve">
          <source>Why, you may ask, would you need a chunk of memory containing some values in binary representation? One good reason is input and output accessing some file, a device, or a network connection, whereby this binary representation is either forced on you or will give you some benefit in processing. Another cause is passing data to some system call that is not available as a Perl function: &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; requires you to provide parameters stored in the way it happens in a C program. Even text processing (as shown in the next section) may be simplified with judicious usage of these two functions.</source>
          <target state="translated">Вы можете спросить, зачем вам нужен кусок памяти, содержащий некоторые значения в двоичном представлении? Одна из веских причин - ввод и вывод для доступа к какому-либо файлу, устройству или сетевому соединению, в результате чего это двоичное представление либо навязывается вам, либо дает вам некоторые преимущества при обработке. Другая причина - передача данных в некоторый системный вызов, который недоступен как функция Perl: &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; требует, чтобы вы предоставили параметры, хранящиеся так, как это происходит в программе на C. Даже обработка текста (как показано в следующем разделе) может быть упрощена при разумном использовании этих двух функций.</target>
        </trans-unit>
        <trans-unit id="6ab0396ba481d1f15a966e8a80a53c0fff8a6b1e" translate="yes" xml:space="preserve">
          <source>Why, you may ask, would you need a chunk of memory containing some values in binary representation? One good reason is input and output accessing some file, a device, or a network connection, whereby this binary representation is either forced on you or will give you some benefit in processing. Another cause is passing data to some system call that is not available as a Perl function: &lt;code&gt;syscall&lt;/code&gt; requires you to provide parameters stored in the way it happens in a C program. Even text processing (as shown in the next section) may be simplified with judicious usage of these two functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b95af46a7dc5483f3c0502e26f80b536b33809" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;can&lt;/code&gt; returns a coderef to mean &quot;yes it can (and the method is this...)&quot;, and then &lt;code&gt;ok&lt;/code&gt; sees a coderef and thinks you're passing a function that you want it to call and consider the truth of the result of! I.e., just like:</source>
          <target state="translated">Зачем? Потому что &lt;code&gt;can&lt;/code&gt; возвращает кодовую ссылку, означающую &amp;laquo;да, может (и метод такой ...)&amp;raquo;, а затем &lt;code&gt;ok&lt;/code&gt; видит кодовую ссылку и думает, что вы передаете функцию, которую хотите, чтобы она вызывала, и учитываете истинность результата. из! Т.е. просто так:</target>
        </trans-unit>
        <trans-unit id="c682a5bde8a3f0f1d13f9a9af66f849014ab6208" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;nasty_break()&lt;/code&gt; modifies &lt;code&gt;$\&lt;/code&gt; without localizing it first. The value you set in &lt;code&gt;nasty_break()&lt;/code&gt; is still there when you return. The fix is to add &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; so the value doesn't leak out of &lt;code&gt;nasty_break()&lt;/code&gt; :</source>
          <target state="translated">Зачем? Потому что &lt;code&gt;nasty_break()&lt;/code&gt; изменяет &lt;code&gt;$\&lt;/code&gt; без предварительной локализации. Значение, которое вы установили в &lt;code&gt;nasty_break()&lt;/code&gt; там, когда вы вернетесь. Исправление - добавить &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; чтобы значение не просачивалось из &lt;code&gt;nasty_break()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a6faa641a92e7908b2759e3d399e519a97396eeb" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;nasty_break()&lt;/code&gt; modifies &lt;code&gt;$\&lt;/code&gt; without localizing it first. The value you set in &lt;code&gt;nasty_break()&lt;/code&gt; is still there when you return. The fix is to add &lt;code&gt;local()&lt;/code&gt; so the value doesn't leak out of &lt;code&gt;nasty_break()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a097ba046d774750c25655e60293a973b6be9d" translate="yes" xml:space="preserve">
          <source>Wide character (U+%X) in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745ada6d8a512f870963c08fe697c0dd823de817" translate="yes" xml:space="preserve">
          <source>Wide character in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59af40d4a351e635fdbe369d7b681d20a590a23a" translate="yes" xml:space="preserve">
          <source>Wildcard expansion</source>
          <target state="translated">Расширение Wildcard</target>
        </trans-unit>
        <trans-unit id="47c9b4ee449bd8455aec29f4590e9aaa03c049f4" translate="yes" xml:space="preserve">
          <source>Wildcards in Property Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70477b387f14e0143de5873f3a9e791508ea1046" translate="yes" xml:space="preserve">
          <source>Will My Old Scripts Break?</source>
          <target state="translated">Мои старые сценарии сломаются?</target>
        </trans-unit>
        <trans-unit id="2873c6e6e5880b670c065bcdc4a78243fbadf06c" translate="yes" xml:space="preserve">
          <source>Will Sheppard &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2758b8d4c9377404295cf137b65b7a19678f3231" translate="yes" xml:space="preserve">
          <source>Will add a file to the in-memory archive, with name &lt;code&gt;$filename&lt;/code&gt; and content &lt;code&gt;$data&lt;/code&gt; . Specific properties can be set using &lt;code&gt;$opthashref&lt;/code&gt; . The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (On MacOS, the file's path and modification times are converted to Unix equivalents.)</source>
          <target state="translated">Добавит файл в архив в памяти с именем &lt;code&gt;$filename&lt;/code&gt; и содержимым &lt;code&gt;$data&lt;/code&gt; . Конкретные свойства можно установить с помощью &lt;code&gt;$opthashref&lt;/code&gt; . Поддерживается следующий список свойств: name, size, mtime (дата последнего изменения), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (В MacOS путь к файлу и время модификации конвертируются в эквиваленты Unix.)</target>
        </trans-unit>
        <trans-unit id="93e582e568148c77bec33609334f756f428deffa" translate="yes" xml:space="preserve">
          <source>Will add a file to the in-memory archive, with name &lt;code&gt;$filename&lt;/code&gt; and content &lt;code&gt;$data&lt;/code&gt;. Specific properties can be set using &lt;code&gt;$opthashref&lt;/code&gt;. The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (On MacOS, the file's path and modification times are converted to Unix equivalents.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af66cccfd8aea183b531eebc0a74a7e923052ebf" translate="yes" xml:space="preserve">
          <source>Will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. (See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.)</source>
          <target state="translated">Будет вызван, когда произойдет &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; . (См. &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;Раздел Развязка Gotcha&lt;/a&gt; ниже.)</target>
        </trans-unit>
        <trans-unit id="3135cfa6b9641d632048427137e9d839208222a7" translate="yes" xml:space="preserve">
          <source>Will be called when &lt;code&gt;untie&lt;/code&gt; happens. (See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c123e132f25bf178be9ea2aca72fafe2969081c" translate="yes" xml:space="preserve">
          <source>Will be loaded on demand and called automatically by BigInt.</source>
          <target state="translated">Будет загружен по требованию и автоматически вызван BigInt.</target>
        </trans-unit>
        <trans-unit id="a669aaf9a433f6903c152ca38a90c9c7cb258f3e" translate="yes" xml:space="preserve">
          <source>Will be prepended to each install path.</source>
          <target state="translated">Будет подготовлено к каждому установочному пути.</target>
        </trans-unit>
        <trans-unit id="4532ff2be2d0615be4c0aa19707d4e886e5a1789" translate="yes" xml:space="preserve">
          <source>Will be set to a uuid if uuid tagging was enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f18d29650d7b716edb7780278b512b0a8a59170" translate="yes" xml:space="preserve">
          <source>Will be used to modify the padding applied to string as described above.</source>
          <target state="translated">Будет использоваться для изменения набивки,применяемой к строке,как описано выше.</target>
        </trans-unit>
        <trans-unit id="4e827c2a869b099543f874a4407588358567998d" translate="yes" xml:space="preserve">
          <source>Will both leave the sentence as is. Normally, when accepting literal string input from the user, &lt;a href=&quot;#quotemeta-EXPR&quot;&gt;&lt;code&gt;quotemeta&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;\Q&lt;/code&gt; must be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a659ce6bd28efeb251560042f49a1924dca7c4a4" translate="yes" xml:space="preserve">
          <source>Will both leave the sentence as is. Normally, when accepting literal string input from the user, quotemeta() or &lt;code&gt;\Q&lt;/code&gt; must be used.</source>
          <target state="translated">Оба оставят предложение как есть. Обычно при приеме ввода буквальной строки от пользователя необходимо использовать quotemeta () или &lt;code&gt;\Q&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10fbb1ac2af71320cfd2110a94f422695cba5311" translate="yes" xml:space="preserve">
          <source>Will cause &lt;code&gt;$sentence&lt;/code&gt; to become &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; .</source>
          <target state="translated">Превратит &lt;code&gt;$sentence&lt;/code&gt; в &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10dc8768858451ca68c298fbc7a5ad46babe9c5d" translate="yes" xml:space="preserve">
          <source>Will cause &lt;code&gt;$sentence&lt;/code&gt; to become &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66fbedfbffb0f55bc116220f01908ca58f12e965" translate="yes" xml:space="preserve">
          <source>Will croak() if there is an error.</source>
          <target state="translated">Будет croak(),если произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="a89e6d7112dafb5b2ad3a46406c0ced36b7d13b7" translate="yes" xml:space="preserve">
          <source>Will die() if called on r-magic.</source>
          <target state="translated">Умрет,если вызовет r-magic.</target>
        </trans-unit>
        <trans-unit id="0768298b9a0627e90df27324883d97a236031b2a" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Handy for things like...</source>
          <target state="translated">Сбрасывает содержимое любых ссылок в формате,удобном для чтения человеком.Удобно для таких вещей,как...</target>
        </trans-unit>
        <trans-unit id="481a8de568a61f103c3af4da9f82b1f103a46712" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Usually you want to pass this into &lt;code&gt;note&lt;/code&gt; or &lt;code&gt;diag&lt;/code&gt; .</source>
          <target state="translated">Выгрузит содержимое любых ссылок в удобочитаемом формате. Обычно вы хотите передать это в &lt;code&gt;note&lt;/code&gt; или &lt;code&gt;diag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdc14d4349b2640a0197394413323e6c4dc94091" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Usually you want to pass this into &lt;code&gt;note&lt;/code&gt; or &lt;code&gt;diag&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f83221407c4472808dc0bb2139500f5229338d" translate="yes" xml:space="preserve">
          <source>Will force the generation of test code that uses the older &lt;code&gt;Test&lt;/code&gt; module.</source>
          <target state="translated">Заставит генерировать тестовый код, использующий старый &lt;code&gt;Test&lt;/code&gt; модуль.</target>
        </trans-unit>
        <trans-unit id="a329a554ce0cef11ca3198cc6cf9ba23c8d4f77f" translate="yes" xml:space="preserve">
          <source>Will incorrectly print</source>
          <target state="translated">Будет неправильно распечатана</target>
        </trans-unit>
        <trans-unit id="fe4d3313b3f93ee1361d2d67710393a85713398e" translate="yes" xml:space="preserve">
          <source>Will invoke a sub at the end of a (compile-time) scope. The sub is called once with no arguments. Can be called multiple times (even in the same &quot;compile-time&quot; scope) to install multiple subs. Subs are called in a &quot;first-in-last-out&quot;-order (FILO or &quot;stack&quot;-order).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c610d24bbac520a7e0e174e12fe1f23a3ae5f9e4" translate="yes" xml:space="preserve">
          <source>Will make sure that =head1 will become &amp;lt;h3&amp;gt; and =head2 will become &amp;lt;h4&amp;gt; etc...</source>
          <target state="translated">Убедитесь, что = head1 станет &amp;lt;h3&amp;gt;, а = head2 станет &amp;lt;h4&amp;gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="49024b4120de3dd67c62575e0a4eb5f193ed6c22" translate="yes" xml:space="preserve">
          <source>Will not cause &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; to re-read the directory stream. The entries already read before the &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; call will just be returned again from a cache buffer. (Win32)</source>
          <target state="translated">Не заставит &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; перечитать поток каталога. Записи, уже прочитанные до &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; будут просто снова возвращены из буфера кеша. (Win32)</target>
        </trans-unit>
        <trans-unit id="845d623fd40095b89ded11a672446e7d8d2933f3" translate="yes" xml:space="preserve">
          <source>Will not exceed this limit even if the string is not valid &quot;UTF-8&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7706e40a252d341368a094f13349cb965c7bcf44" translate="yes" xml:space="preserve">
          <source>Will not exceed those limits even if the string is not valid &quot;UTF-8&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4b57e33203662ee1ddac498725ec0cbd902da5" translate="yes" xml:space="preserve">
          <source>Will not work on platforms that do not support the &lt;code&gt;-k&lt;/code&gt; test for sticky bit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aff13c5ad9d691f5f29f20db0a92fc55a16499de" translate="yes" xml:space="preserve">
          <source>Will not work on platforms that do not support the C test for sticky bit.</source>
          <target state="translated">Не будет работать на платформах,которые не поддерживают тест C на липкий бит.</target>
        </trans-unit>
        <trans-unit id="19ad79cf64559535aa01bc2039517ce48ed1f305" translate="yes" xml:space="preserve">
          <source>Will output 2, not 1. This is particularly important if you intend to compile the definitions with the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator, and later interpolate them in another pattern.</source>
          <target state="translated">Будет выведено 2, а не 1. Это особенно важно, если вы собираетесь скомпилировать определения с помощью оператора &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; , а затем интерполировать их в другой шаблон.</target>
        </trans-unit>
        <trans-unit id="d7ba12340e687f11ed70710aaea6e46b38d77b8f" translate="yes" xml:space="preserve">
          <source>Will output 2, not 1. This is particularly important if you intend to compile the definitions with the &lt;code&gt;qr//&lt;/code&gt; operator, and later interpolate them in another pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10021ccb8e306fb831263dee40b8f7ca24084b5a" translate="yes" xml:space="preserve">
          <source>Will prevent the automatic use of INSTALL.SKIP as the install skip file.</source>
          <target state="translated">Предотвращает автоматическое использование INSTALL.SKIP в качестве файла пропуска установки.</target>
        </trans-unit>
        <trans-unit id="897aeeccb9736732e15f96f20d971e76dcd3a8ff" translate="yes" xml:space="preserve">
          <source>Will print &lt;code&gt;2&lt;/code&gt; , because &lt;code&gt;$string&lt;/code&gt; is upgraded as UTF-8. Without &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; , it will print &lt;code&gt;4&lt;/code&gt; instead, since &lt;code&gt;$string&lt;/code&gt; is three octets when interpreted as Latin-1.</source>
          <target state="translated">Напечатает &lt;code&gt;2&lt;/code&gt; , потому что &lt;code&gt;$string&lt;/code&gt; обновляется до UTF-8. Без &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; , вместо этого он напечатает &lt;code&gt;4&lt;/code&gt; , поскольку &lt;code&gt;$string&lt;/code&gt; составляет три октета при интерпретации как Latin-1.</target>
        </trans-unit>
        <trans-unit id="c7912cc2705e39fd55074c6583f91d53d1be3b82" translate="yes" xml:space="preserve">
          <source>Will print &lt;code&gt;2&lt;/code&gt;, because &lt;code&gt;$string&lt;/code&gt; is upgraded as UTF-8. Without &lt;code&gt;use encoding 'utf8';&lt;/code&gt;, it will print &lt;code&gt;4&lt;/code&gt; instead, since &lt;code&gt;$string&lt;/code&gt; is three octets when interpreted as Latin-1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceca318096ebec569ca5ded9c24fde055f72cece" translate="yes" xml:space="preserve">
          <source>Will print just the value of &lt;code&gt;$x&lt;/code&gt;, believing that &lt;code&gt;$y&lt;/code&gt; is a numerically- equivalent value. This bug does not affect &lt;code&gt;uniqstr()&lt;/code&gt;, which will correctly observe that the two values stringify to different strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f950740e9c08c94cdc9c22017e9c8d9e11964004" translate="yes" xml:space="preserve">
          <source>Will produce something like this:</source>
          <target state="translated">произведет что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="73c023c285973466729ee2bf21a0f578281a6002" translate="yes" xml:space="preserve">
          <source>Will return a list of two sockets created (read and write), or an empty list on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e73c78b5d339922fd7fb53696709fc79fcc290" translate="yes" xml:space="preserve">
          <source>Will use &lt;a href=&quot;TAP::Harness::Archive&quot;&gt;TAP::Harness::Archive&lt;/a&gt; as the harness class, and save the TAP to &lt;code&gt;file.tgz&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db8fa98164c98267f0158f423a3da70d388112fe" translate="yes" xml:space="preserve">
          <source>Will use &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP::Harness::Archive&lt;/a&gt; as the harness class, and save the TAP to &lt;code&gt;file.tgz&lt;/code&gt;</source>
          <target state="translated">Будет использовать &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP :: Harness :: Archive&lt;/a&gt; в качестве класса проводки и сохранить TAP в &lt;code&gt;file.tgz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b653c1a1342f29b6e1ca16ef44b1d14c98a11e3" translate="yes" xml:space="preserve">
          <source>Win32</source>
          <target state="translated">Win32</target>
        </trans-unit>
        <trans-unit id="193cb801459c22b68d471c2735c8916bade862e2" translate="yes" xml:space="preserve">
          <source>Win32 - Interfaces to some Win32 API Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fdadddae42eb18256ba3d6c7445968142a4fd2" translate="yes" xml:space="preserve">
          <source>Win32 CORE function stubs</source>
          <target state="translated">Функциональные шлейфы Win32 CORE</target>
        </trans-unit>
        <trans-unit id="0cab5c56f7d1ce7bc278eb6ee5c4a8575346a7ef" translate="yes" xml:space="preserve">
          <source>Win32 implementation</source>
          <target state="translated">внедрение Win32</target>
        </trans-unit>
        <trans-unit id="c331f9a552ce93a52bd3bbd4fbac9c58a662301b" translate="yes" xml:space="preserve">
          <source>Win32 support for Sys::Syslog</source>
          <target state="translated">Поддержка Win32 для Sys::Syslog</target>
        </trans-unit>
        <trans-unit id="263a800b140dc4fe3448979f4261e583bcee830e" translate="yes" xml:space="preserve">
          <source>Win32 users should use the real slash. If you really want to use backslashes, consider using Sarathy's File::DosGlob, which comes with the standard Perl distribution.</source>
          <target state="translated">Пользователи Win32 должны использовать реальную косую черту.Если вы действительно хотите использовать обратный слеш,подумайте об использовании Sarathy's File::DosGlob,который поставляется со стандартным дистрибутивом Perl.</target>
        </trans-unit>
        <trans-unit id="6d0e1038c340ca3cf2b59ac852b5f2ef7407e5c9" translate="yes" xml:space="preserve">
          <source>Win32::AbortSystemShutdown(MACHINE)</source>
          <target state="translated">Win32::AbortSystemShutdown(MACHINE)</target>
        </trans-unit>
        <trans-unit id="6f12fa420b1205100cabb4570f237b3d345d86ca" translate="yes" xml:space="preserve">
          <source>Win32::BuildNumber()</source>
          <target state="translated">Win32::BuildNumber()</target>
        </trans-unit>
        <trans-unit id="99f20893b3ea998d83c35a43b1ddcaefd97d6b9f" translate="yes" xml:space="preserve">
          <source>Win32::CopyFile(FROM, TO, OVERWRITE)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d269bfa64c0a58bda1986a24d2c54a63190e288a" translate="yes" xml:space="preserve">
          <source>Win32::CreateDirectory(DIRECTORY)</source>
          <target state="translated">Win32::CreateDirectory(DIRECTORY)</target>
        </trans-unit>
        <trans-unit id="7a7983d24568164c28a76c5bb077686f88dad153" translate="yes" xml:space="preserve">
          <source>Win32::CreateFile(FILE)</source>
          <target state="translated">Win32::CreateFile(FILE)</target>
        </trans-unit>
        <trans-unit id="fa7c1f0bbed5b785d5607e1311dcb11968fd8fe9" translate="yes" xml:space="preserve">
          <source>Win32::DomainName()</source>
          <target state="translated">Win32::DomainName()</target>
        </trans-unit>
        <trans-unit id="1c453bb935414d8146aa602c45dd5159dab45ade" translate="yes" xml:space="preserve">
          <source>Win32::ExpandEnvironmentStrings(STRING)</source>
          <target state="translated">Win32::ExpandEnvironmentStrings(STRING)</target>
        </trans-unit>
        <trans-unit id="88134ad369f40cbd5ed8e6414b571501a615d721" translate="yes" xml:space="preserve">
          <source>Win32::FormatMessage(ERRORCODE)</source>
          <target state="translated">Win32::FormatMessage(ERRORCODE)</target>
        </trans-unit>
        <trans-unit id="02c33521b3e0cfb9be57585db645c4568be060cf" translate="yes" xml:space="preserve">
          <source>Win32::FreeLibrary(HANDLE)</source>
          <target state="translated">Win32::FreeLibrary(HANDLE)</target>
        </trans-unit>
        <trans-unit id="ec6d95684a511580632674e1e5dce99eca02ed2c" translate="yes" xml:space="preserve">
          <source>Win32::FsType()</source>
          <target state="translated">Win32::FsType()</target>
        </trans-unit>
        <trans-unit id="fdfbfe52059c529a42a7f79b351a29683dd786d2" translate="yes" xml:space="preserve">
          <source>Win32::GUI</source>
          <target state="translated">Win32::GUI</target>
        </trans-unit>
        <trans-unit id="cc575cb0ebbd64ea43f9c9ccc56237b0705f9732" translate="yes" xml:space="preserve">
          <source>Win32::GetACP()</source>
          <target state="translated">Win32::GetACP()</target>
        </trans-unit>
        <trans-unit id="7798f250e449938fcf7dadf70c029ad54f636245" translate="yes" xml:space="preserve">
          <source>Win32::GetANSIPathName(FILENAME)</source>
          <target state="translated">Win32::GetANSIPathName(FILENAME)</target>
        </trans-unit>
        <trans-unit id="58ac17861a87852820b146e725b1e3c3e23cbe3e" translate="yes" xml:space="preserve">
          <source>Win32::GetArchName()</source>
          <target state="translated">Win32::GetArchName()</target>
        </trans-unit>
        <trans-unit id="3834fcd21d4e7fa28d350d64b78639660bbeb2c1" translate="yes" xml:space="preserve">
          <source>Win32::GetChipName()</source>
          <target state="translated">Win32::GetChipName()</target>
        </trans-unit>
        <trans-unit id="202596ea6840cbe9f281840b431aa41aec8424c4" translate="yes" xml:space="preserve">
          <source>Win32::GetConsoleCP()</source>
          <target state="translated">Win32::GetConsoleCP()</target>
        </trans-unit>
        <trans-unit id="8aaff4afc4c9f3d83ba6558614d36b7f40e38e33" translate="yes" xml:space="preserve">
          <source>Win32::GetConsoleOutputCP()</source>
          <target state="translated">Win32::GetConsoleOutputCP()</target>
        </trans-unit>
        <trans-unit id="ebc6f60b70df25fd8c32e53de9a7c9ba577f15ee" translate="yes" xml:space="preserve">
          <source>Win32::GetCurrentProcessId()</source>
          <target state="translated">Win32::GetCurrentProcessId()</target>
        </trans-unit>
        <trans-unit id="41cb4ff89334195c85ec80a4293eee0fe84b1c77" translate="yes" xml:space="preserve">
          <source>Win32::GetCurrentThreadId()</source>
          <target state="translated">Win32::GetCurrentThreadId()</target>
        </trans-unit>
        <trans-unit id="06fb2ae0e34c762652f91cc4b24d288d543148dd" translate="yes" xml:space="preserve">
          <source>Win32::GetCwd()</source>
          <target state="translated">Win32::GetCwd()</target>
        </trans-unit>
        <trans-unit id="424bc0808437c0c40f8b8eca83c71486de0c2ce3" translate="yes" xml:space="preserve">
          <source>Win32::GetFileVersion(FILENAME)</source>
          <target state="translated">Win32::GetFileVersion(FILENAME)</target>
        </trans-unit>
        <trans-unit id="bd89672cc22e170bdb15759f5b2c202ee866d3af" translate="yes" xml:space="preserve">
          <source>Win32::GetFolderPath(FOLDER [, CREATE])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7750debc5964ef700caa1d205774c5c516e86b5" translate="yes" xml:space="preserve">
          <source>Win32::GetFullPathName(FILENAME)</source>
          <target state="translated">Win32::GetFullPathName(FILENAME)</target>
        </trans-unit>
        <trans-unit id="1779b4a74c4e9c74750b4883d1c3a13e7f082821" translate="yes" xml:space="preserve">
          <source>Win32::GetLastError()</source>
          <target state="translated">Win32::GetLastError()</target>
        </trans-unit>
        <trans-unit id="c1d2be25cd4c6103e621d159ba09f9b5f7b7f66d" translate="yes" xml:space="preserve">
          <source>Win32::GetLongPathName(PATHNAME)</source>
          <target state="translated">Win32::GetLongPathName(PATHNAME)</target>
        </trans-unit>
        <trans-unit id="9a5b08237dd1d9c044b42e330417a8ee6c2fddc5" translate="yes" xml:space="preserve">
          <source>Win32::GetNextAvailDrive()</source>
          <target state="translated">Win32::GetNextAvailDrive()</target>
        </trans-unit>
        <trans-unit id="424731cf281e1dda51d3e9681cc85bb2740bbe76" translate="yes" xml:space="preserve">
          <source>Win32::GetOEMCP()</source>
          <target state="translated">Win32::GetOEMCP()</target>
        </trans-unit>
        <trans-unit id="1015f265e18dde79b1939bf46d05753e1cb1fc0a" translate="yes" xml:space="preserve">
          <source>Win32::GetOSDisplayName()</source>
          <target state="translated">Win32::GetOSDisplayName()</target>
        </trans-unit>
        <trans-unit id="e9e643f122af1698a8771b07d042a8eb421add6b" translate="yes" xml:space="preserve">
          <source>Win32::GetOSName()</source>
          <target state="translated">Win32::GetOSName()</target>
        </trans-unit>
        <trans-unit id="9ac415285a2a80e417f87a22967bf20ef2c63935" translate="yes" xml:space="preserve">
          <source>Win32::GetOSVersion()</source>
          <target state="translated">Win32::GetOSVersion()</target>
        </trans-unit>
        <trans-unit id="bbb14f64d25ca5875dac81a570aa2578d64fe870" translate="yes" xml:space="preserve">
          <source>Win32::GetProcAddress(INSTANCE, PROCNAME)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4519c40934e76bc7c24e8acfe3fe14ba43d63f" translate="yes" xml:space="preserve">
          <source>Win32::GetProductInfo(OSMAJOR, OSMINOR, SPMAJOR, SPMINOR)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="976bea2f0bcf19569dea7f3dcd696ad17b85b2c9" translate="yes" xml:space="preserve">
          <source>Win32::GetShortPathName(PATHNAME)</source>
          <target state="translated">Win32::GetShortPathName(PATHNAME)</target>
        </trans-unit>
        <trans-unit id="85686486692a83787d94a67516a3d3724180155d" translate="yes" xml:space="preserve">
          <source>Win32::GetSystemMetrics(INDEX)</source>
          <target state="translated">Win32::GetSystemMetrics(INDEX)</target>
        </trans-unit>
        <trans-unit id="da2531353eddaf6094a844bf9d9cb759ae2af1e8" translate="yes" xml:space="preserve">
          <source>Win32::GetTickCount()</source>
          <target state="translated">Win32::GetTickCount()</target>
        </trans-unit>
        <trans-unit id="ae35ac71f2f974fbd4820718cb015468050c4f6c" translate="yes" xml:space="preserve">
          <source>Win32::GuidGen()</source>
          <target state="translated">Win32::GuidGen()</target>
        </trans-unit>
        <trans-unit id="6c1bb229532a2f942fc09792beca570bb3feca1b" translate="yes" xml:space="preserve">
          <source>Win32::InitiateSystemShutdown</source>
          <target state="translated">Win32::InitiateSystemShutdown</target>
        </trans-unit>
        <trans-unit id="f9fa2b44699da87d011d8d62354503f774420ab1" translate="yes" xml:space="preserve">
          <source>Win32::IsAdminUser()</source>
          <target state="translated">Win32::IsAdminUser()</target>
        </trans-unit>
        <trans-unit id="fe185f7f6aa0888454156f6b1dd0647b97f1c985" translate="yes" xml:space="preserve">
          <source>Win32::IsWin95()</source>
          <target state="translated">Win32::IsWin95()</target>
        </trans-unit>
        <trans-unit id="1f8c102705f38e11ded9cb1693b6ba04ed8d2aac" translate="yes" xml:space="preserve">
          <source>Win32::IsWinNT()</source>
          <target state="translated">Win32::IsWinNT()</target>
        </trans-unit>
        <trans-unit id="75e8f5dee14a6d1c4d34f99cde2cd05959a202c6" translate="yes" xml:space="preserve">
          <source>Win32::LoadLibrary(LIBNAME)</source>
          <target state="translated">Win32::LoadLibrary(LIBNAME)</target>
        </trans-unit>
        <trans-unit id="33e6daf26026220d0161fea28893d1e652b68f17" translate="yes" xml:space="preserve">
          <source>Win32::LoginName()</source>
          <target state="translated">Win32::LoginName()</target>
        </trans-unit>
        <trans-unit id="b7203bf8251626a9d020ee5f4922ecd6ff013788" translate="yes" xml:space="preserve">
          <source>Win32::LookupAccountName(SYSTEM, ACCOUNT, DOMAIN, SID, SIDTYPE)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e02105130675ffb73c863f2651d7886f32ce699c" translate="yes" xml:space="preserve">
          <source>Win32::LookupAccountSID(SYSTEM, SID, ACCOUNT, DOMAIN, SIDTYPE)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b3757407e5968fe8497224d610a6b05e0fb867" translate="yes" xml:space="preserve">
          <source>Win32::MsgBox(MESSAGE [, FLAGS [, TITLE]])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c6c757d1a1e7f6e540ff3306434ee9703babbe" translate="yes" xml:space="preserve">
          <source>Win32::NodeName()</source>
          <target state="translated">Win32::NodeName()</target>
        </trans-unit>
        <trans-unit id="2712cf0c3d41deb65f7212a8f31b3f82a4ae6a9e" translate="yes" xml:space="preserve">
          <source>Win32::OutputDebugString(STRING)</source>
          <target state="translated">Win32::OutputDebugString(STRING)</target>
        </trans-unit>
        <trans-unit id="75ef631d3c7ea178f0c26bc47d12483cd8c3ea5d" translate="yes" xml:space="preserve">
          <source>Win32::RegisterServer(LIBRARYNAME)</source>
          <target state="translated">Win32::RegisterServer(LIBRARYNAME)</target>
        </trans-unit>
        <trans-unit id="ce0d098c41c01fd9b4d42374933b719c4874605c" translate="yes" xml:space="preserve">
          <source>Win32::SetChildShowWindow(SHOWWINDOW)</source>
          <target state="translated">Win32::SetChildShowWindow(SHOWWINDOW)</target>
        </trans-unit>
        <trans-unit id="6ec2ec156820380d471d8b8902107f69d0c48aac" translate="yes" xml:space="preserve">
          <source>Win32::SetConsoleCP(ID)</source>
          <target state="translated">Win32::SetConsoleCP(ID)</target>
        </trans-unit>
        <trans-unit id="d56fdac00362d0844cebe19c2fbea7797556a862" translate="yes" xml:space="preserve">
          <source>Win32::SetConsoleOutputCP(ID)</source>
          <target state="translated">Win32::SetConsoleOutputCP(ID)</target>
        </trans-unit>
        <trans-unit id="8ff2683659839e8f5dba46b5d4a8ac3aa4a62e14" translate="yes" xml:space="preserve">
          <source>Win32::SetCwd(NEWDIRECTORY)</source>
          <target state="translated">Win32::SetCwd(NEWDIRECTORY)</target>
        </trans-unit>
        <trans-unit id="721ad14df20038a886cdbbad6ec515e2dfd8ef41" translate="yes" xml:space="preserve">
          <source>Win32::SetLastError(ERROR)</source>
          <target state="translated">Win32::SetLastError(ERROR)</target>
        </trans-unit>
        <trans-unit id="70d34dd79a3d13ab005b5f95a3a341dc634b545c" translate="yes" xml:space="preserve">
          <source>Win32::Sleep(TIME)</source>
          <target state="translated">Win32::Sleep(TIME)</target>
        </trans-unit>
        <trans-unit id="0bd78719dddc468413b0b8cae64f7604c9b0760f" translate="yes" xml:space="preserve">
          <source>Win32::Spawn(COMMAND, ARGS, PID)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cf1f14b3a9fb47a3d099c943c81a86f3bab76e" translate="yes" xml:space="preserve">
          <source>Win32::UnregisterServer(LIBRARYNAME)</source>
          <target state="translated">Win32::UnregisterServer(LIBRARYNAME)</target>
        </trans-unit>
        <trans-unit id="aa21f521370d6a588509094452635266c4468ce9" translate="yes" xml:space="preserve">
          <source>Win32API::File</source>
          <target state="translated">Win32API::File</target>
        </trans-unit>
        <trans-unit id="88c0b190dbad57a17cc677f51fa9c1ba74db87d0" translate="yes" xml:space="preserve">
          <source>Win32API::File - Low-level access to Win32 system API calls for files/dirs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a0edd9f797c147e0eca61b93c9942a6aada686" translate="yes" xml:space="preserve">
          <source>Win32CORE</source>
          <target state="translated">Win32CORE</target>
        </trans-unit>
        <trans-unit id="674b29c781e27ee904b0a31e2bca19f160dacd50" translate="yes" xml:space="preserve">
          <source>Win32CORE - Win32 CORE function stubs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823301860ab873ab455e9a7adb1aa457e7019586" translate="yes" xml:space="preserve">
          <source>Win32CORE was created to provide on cygwin those Win32:: functions that for regular win32 builds were provided by default in perl. In cygwin perl releases prior to 5.8.6, this module was standalone and had to be explicitly used. In 5.8.6 and later, it was statically linked into cygwin perl so this would no longer be necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64d38eb25949cf47b772e208780c5548dc84962" translate="yes" xml:space="preserve">
          <source>Win95 and Win98 and WinME are collectively Win9x and Win32</source>
          <target state="translated">Win95 и Win98 и WinME-это вместе Win9x и Win32.</target>
        </trans-unit>
        <trans-unit id="ea8db18a138027d52bc49a4789f983c73ef0f94f" translate="yes" xml:space="preserve">
          <source>Win95/NT</source>
          <target state="translated">Win95/NT</target>
        </trans-unit>
        <trans-unit id="38d123584917edd3d65a1c41ab99a9088beb8b64" translate="yes" xml:space="preserve">
          <source>Win98 chokes on things like Encode if we set the max length to nmake's max of 2K. So we go for a more conservative value of 1K.</source>
          <target state="translated">Win98 подавится такими вещами,как Encode,если мы установим максимальную длину nmake в 2K.Таким образом,мы выбираем более консервативное значение 1K.</target>
        </trans-unit>
        <trans-unit id="7e7afec2ee076635c5bdb3c20b397b563733e6cf" translate="yes" xml:space="preserve">
          <source>Win9x and &lt;code&gt;d_eofnblk&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb6e2235a0d088883e2901a983ef0e7377f83c0" translate="yes" xml:space="preserve">
          <source>Win9x can not &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; an open file (although WinNT can).</source>
          <target state="translated">Win9x не может &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; открытый файл (хотя WinNT может).</target>
        </trans-unit>
        <trans-unit id="de40f5b5690a0bb23e1bf760363cb6a5e8443821" translate="yes" xml:space="preserve">
          <source>Win9x can not &lt;code&gt;rename()&lt;/code&gt; an open file (although WinNT can).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1865487f835d74c1a32dc51f7e3fd10d2bb1c87c" translate="yes" xml:space="preserve">
          <source>Win9x does not correctly report &lt;code&gt;EOF&lt;/code&gt; with a non-blocking read on a closed pipe. You will see the following messages:</source>
          <target state="translated">Win9x неправильно сообщает о &lt;code&gt;EOF&lt;/code&gt; с неблокирующим чтением по закрытому каналу. Вы увидите следующие сообщения:</target>
        </trans-unit>
        <trans-unit id="468c4f1d38914eeba7915aa856cfac9060a7a5fe" translate="yes" xml:space="preserve">
          <source>Win9x support was added in 5.6 (Benjamin Stuhl).</source>
          <target state="translated">В 5.6 добавлена поддержка Win9x (Benjamin Stuhl).</target>
        </trans-unit>
        <trans-unit id="38c0fc63bcb91fe3116f8590745de1626f0dd16a" translate="yes" xml:space="preserve">
          <source>WinDisk.exe</source>
          <target state="translated">WinDisk.exe</target>
        </trans-unit>
        <trans-unit id="c816e89ffa10335823ff2ffbfd171adf35cada45" translate="yes" xml:space="preserve">
          <source>WinError.h</source>
          <target state="translated">WinError.h</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="bf4f5bc6b10d099fc4024cb19c3bd9cf757e522e" translate="yes" xml:space="preserve">
          <source>Windows .NET Server supports the LLP64 data model on the Intel Itanium architecture.</source>
          <target state="translated">Windows .NET Server поддерживает модель данных LLP64 на архитектуре Intel Itanium.</target>
        </trans-unit>
        <trans-unit id="f6a28970a521e035e5e254c78ec61c1026703f9b" translate="yes" xml:space="preserve">
          <source>Windows 2000</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94cada20ad68e1ffe3678826da4a09dc6377e803" translate="yes" xml:space="preserve">
          <source>Windows 7</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca1d54534e769c83a6c85f5e6241a2523f2592c" translate="yes" xml:space="preserve">
          <source>Windows 95</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdae4500dcdb3f86e38c3347c9fe418dd6deff32" translate="yes" xml:space="preserve">
          <source>Windows 98</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6578fbd48a0229e823dac38105b1950bd25957b3" translate="yes" xml:space="preserve">
          <source>Windows Event Log, &lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&lt;/a&gt;</source>
          <target state="translated">Журнал событий Windows, &lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="103df21c74e8700ecbf0be7b47c35a5b830e8e97" translate="yes" xml:space="preserve">
          <source>Windows Event Log, &lt;a href=&quot;https://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08fe8b7597a09dd3a844091de7163268dfe54cc6" translate="yes" xml:space="preserve">
          <source>Windows ME</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83dc416748ad54d778d6b19e9f7fde1b7af83339" translate="yes" xml:space="preserve">
          <source>Windows NT4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d80809b5e98653b28bad4f8f5c33d52237b9226" translate="yes" xml:space="preserve">
          <source>Windows Server 2003</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2504575346cece1887f998d2d76408a38af5141e" translate="yes" xml:space="preserve">
          <source>Windows Server 2008</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc44c44b7a030798f3e511dc741ab9400f590ae" translate="yes" xml:space="preserve">
          <source>Windows Vista</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f20bccfe3512339ad2cea01fc1c7809e7d3d15" translate="yes" xml:space="preserve">
          <source>Windows XP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2af17044bb2c5164875672fc2938f1968ed3a3" translate="yes" xml:space="preserve">
          <source>Windows has basically 2 sets of APIs. A wide API (based on passing UTF-16 strings) and a byte based API based a character set called ANSI. The regular Perl interfaces to the OS currently only uses the ANSI APIs. Unfortunately ANSI is not a single character set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32384d85bc892c2cec1cd8f151b8007b98fa13ff" translate="yes" xml:space="preserve">
          <source>Windows is Win32.</source>
          <target state="translated">Windows-это Win32.</target>
        </trans-unit>
        <trans-unit id="15932d7727c0d0850847ee4a3aea588d05fd6a45" translate="yes" xml:space="preserve">
          <source>Windows is Windows telnet, Cygwin SSH is the OpenSSH implementation under Cygwin on Windows NT, and Mac Terminal is the Terminal application in Mac OS X. Where the entry is other than yes or no, that emulator displays the given attribute as something else instead. Note that on an aixterm, clear doesn't reset colors; you have to explicitly set the colors back to what you want. More entries in this table are welcome.</source>
          <target state="translated">Windows-это Windows telnet,Cygwin SSH-это реализация OpenSSH под Cygwin на Windows NT,а Mac Terminal-это терминальное приложение в Mac OS X.Там,где запись отличается от &quot;да&quot; или &quot;нет&quot;,этот эмулятор отображает данный атрибут как нечто другое.Обратите внимание,что в aixterm,clear не сбрасывает цвета;вы должны явно установить цвета обратно на то,что вы хотите.Приветствуются дополнительные записи в этой таблице.</target>
        </trans-unit>
        <trans-unit id="a8033e193c1409f4bd5db90d9880ca01290431d4" translate="yes" xml:space="preserve">
          <source>Windows systems also operate with another byte based character set. It's called the OEM code page. This is the encoding that the Console takes as input and output. It's common for the OEM code page to differ from the ANSI code page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3093bbeb765cee856b62debb98821ba39f27fcc6" translate="yes" xml:space="preserve">
          <source>Windows users who are using &lt;code&gt;nmake&lt;/code&gt; should note that due to a bug in &lt;code&gt;nmake&lt;/code&gt; , when specifying &lt;code&gt;TEST_FILES&lt;/code&gt; you must use back-slashes instead of forward-slashes.</source>
          <target state="translated">Пользователи Windows, использующие &lt;code&gt;nmake&lt;/code&gt; , должны помнить, что из-за ошибки в &lt;code&gt;nmake&lt;/code&gt; при указании &lt;code&gt;TEST_FILES&lt;/code&gt; вы должны использовать обратную косую черту вместо прямой.</target>
        </trans-unit>
        <trans-unit id="db6ab0003d513d80fd8056684fe349106fcdab74" translate="yes" xml:space="preserve">
          <source>Windows users who are using &lt;code&gt;nmake&lt;/code&gt; should note that due to a bug in &lt;code&gt;nmake&lt;/code&gt;, when specifying &lt;code&gt;TEST_FILES&lt;/code&gt; you must use back-slashes instead of forward-slashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968c4aaba72bd2883444cce7386789debafb547b" translate="yes" xml:space="preserve">
          <source>Windows-specific tests.</source>
          <target state="translated">Испытания для конкретных окон.</target>
        </trans-unit>
        <trans-unit id="52b2489ffd6eceb9bd13b6a8f90eac373db50b35" translate="yes" xml:space="preserve">
          <source>Wisconsin</source>
          <target state="translated">Wisconsin</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="a51957fd22adb3afd697fb8ab328d3922f130d4b" translate="yes" xml:space="preserve">
          <source>With $k chosen carefully, and likely to be a small number like 1 or 2. In theory the larger the bucket array the less chance of collision.</source>
          <target state="translated">С $k выбрали тщательно,и,вероятно,будет небольшое число,как 1 или 2.Теоретически,чем больше ковшовый массив,тем меньше вероятность столкновения.</target>
        </trans-unit>
        <trans-unit id="8a3fad0711b1021538f5283d00839025799b6dad" translate="yes" xml:space="preserve">
          <source>With 1 causes this module to use Time::HiRes module, allowing milliseconds to be returned by subsequent calls to ping().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6185bdea28758a42fc320398e067ab2654617d96" translate="yes" xml:space="preserve">
          <source>With 5005threads, you could also &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; a sub such that any calls to that sub from another thread would block until the lock was released.</source>
          <target state="translated">С помощью 5005threads вы также можете &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; подпрограмму так, чтобы любые вызовы этой подпрограммы из другого потока блокировались до тех пор, пока блокировка не будет снята.</target>
        </trans-unit>
        <trans-unit id="a8d11fe55a26fb99c192c4c169dd330b2ce5c5d6" translate="yes" xml:space="preserve">
          <source>With 5005threads, you could also &lt;code&gt;lock&lt;/code&gt; a sub such that any calls to that sub from another thread would block until the lock was released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c741524004c7f8613fe0df95f2304ad27bfaf6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;/a&lt;/code&gt; , one can write &lt;code&gt;\d&lt;/code&gt; with confidence that it will only match ASCII characters, and should the need arise to match beyond ASCII, you can instead use &lt;code&gt;\p{Digit}&lt;/code&gt; (or &lt;code&gt;\p{Word}&lt;/code&gt; for &lt;code&gt;\w&lt;/code&gt; ). There are similar &lt;code&gt;\p{...}&lt;/code&gt; constructs that can match beyond ASCII both white space (see &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;Whitespace in perlrecharclass&lt;/a&gt;), and Posix classes (see &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;). Thus, this modifier doesn't mean you can't use Unicode, it means that to get Unicode matching you must explicitly use a construct (&lt;code&gt;\p{}&lt;/code&gt; , &lt;code&gt;\P{}&lt;/code&gt; ) that signals Unicode.</source>
          <target state="translated">С помощью &lt;code&gt;/a&lt;/code&gt; можно записать &lt;code&gt;\d&lt;/code&gt; с уверенностью, что он будет соответствовать только символам ASCII, и если возникнет необходимость в сопоставлении за пределами ASCII, вы можете вместо этого использовать &lt;code&gt;\p{Digit}&lt;/code&gt; (или &lt;code&gt;\p{Word}&lt;/code&gt; для &lt;code&gt;\w&lt;/code&gt; ). Существуют похожие конструкции &lt;code&gt;\p{...}&lt;/code&gt; которые могут соответствовать за пределами ASCII как пробелам (см. &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;Пробелы в perlrecharclass&lt;/a&gt; ), так и классам Posix (см. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;Классы символов POSIX в perlrecharclass&lt;/a&gt; ). Таким образом, этот модификатор не означает, что вы не можете использовать Unicode, это означает, что для получения соответствия Unicode вы должны явно использовать конструкцию ( &lt;code&gt;\p{}&lt;/code&gt; , &lt;code&gt;\P{}&lt;/code&gt; ), которая сигнализирует о Unicode.</target>
        </trans-unit>
        <trans-unit id="d8c642a61a993b2822d327b2f6d2aa5b5cdb0c33" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;/a&lt;/code&gt;, one can write &lt;code&gt;\d&lt;/code&gt; with confidence that it will only match ASCII characters, and should the need arise to match beyond ASCII, you can instead use &lt;code&gt;\p{Digit}&lt;/code&gt; (or &lt;code&gt;\p{Word}&lt;/code&gt; for &lt;code&gt;\w&lt;/code&gt;). There are similar &lt;code&gt;\p{...}&lt;/code&gt; constructs that can match beyond ASCII both white space (see &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;&quot;Whitespace&quot; in perlrecharclass&lt;/a&gt;), and Posix classes (see &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;). Thus, this modifier doesn't mean you can't use Unicode, it means that to get Unicode matching you must explicitly use a construct (&lt;code&gt;\p{}&lt;/code&gt;, &lt;code&gt;\P{}&lt;/code&gt;) that signals Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5132b5fe6c695f29613169cf8ff9a2c949197d0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, you get around this by using a block and an expression where you would place the filehandle:</source>
          <target state="translated">С помощью &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; это можно обойти, используя блок и выражение, в которое вы поместите дескриптор файла:</target>
        </trans-unit>
        <trans-unit id="487baf6c93470e20c12688608403c20fbdb8e8f3" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;, both STDOUT and STDERR will go the same place as the script's STDOUT and STDERR, unless the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; command redirects them. Backticks and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; read &lt;b&gt;only&lt;/b&gt; the STDOUT of your command.</source>
          <target state="translated">При использовании &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; и STDOUT, и STDERR будут располагаться в том же месте, что и STDOUT и STDERR скрипта, если их не перенаправит команда &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; . Обратные кавычки и &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; читают &lt;b&gt;только&lt;/b&gt; STDOUT вашей команды.</target>
        </trans-unit>
        <trans-unit id="e6ba4c518cc989a85f1859e34fe5315e0670671f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Class::Tiny&lt;/code&gt; , all accessors are read-write. It generates a constructor for you, as well as the accessors you define.</source>
          <target state="translated">С &lt;code&gt;Class::Tiny&lt;/code&gt; все методы доступа доступны для чтения и записи. Он генерирует для вас конструктор, а также определяемые вами средства доступа.</target>
        </trans-unit>
        <trans-unit id="30133336b461bf131bf440d3b8937ae3c7286e54" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Class::Tiny&lt;/code&gt;, all accessors are read-write. It generates a constructor for you, as well as the accessors you define.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b55e3069c1cf271c20c8804a7b8c0dbfbb1f17" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ignore_case&lt;/code&gt; , option specifications for options that only differ in case, e.g., &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; , will be flagged as duplicates.</source>
          <target state="translated">С &lt;code&gt;ignore_case&lt;/code&gt; спецификации опций для опций, которые отличаются только регистром, например, &lt;code&gt;&quot;foo&quot;&lt;/code&gt; и &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; , будут помечены как повторяющиеся.</target>
        </trans-unit>
        <trans-unit id="912c5dbb25de4eb33c760222cb62f248afb75050" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ignore_case&lt;/code&gt;, option specifications for options that only differ in case, e.g., &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;Foo&quot;&lt;/code&gt;, will be flagged as duplicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fffc08f49ded4afbdfb2c00f9dcdbc7da340301" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;latin1&lt;/code&gt; (or &lt;code&gt;ascii&lt;/code&gt;) enabled, &lt;code&gt;encode&lt;/code&gt; will escape characters with ordinal values &amp;gt; 255 (&amp;gt; 127 with &lt;code&gt;ascii&lt;/code&gt;) and encode the remaining characters as specified by the &lt;code&gt;utf8&lt;/code&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee71de233ae712db3a62ad0a5f3c845bcb07690d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;pass_through&lt;/code&gt; anything that is unknown, ambiguous or supplied with an invalid option will not be flagged as an error. Instead the unknown option(s) will be passed to the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present, otherwise through to &lt;code&gt;@ARGV&lt;/code&gt; . This makes it possible to write wrapper scripts that process only part of the user supplied command line arguments, and pass the remaining options to some other program.</source>
          <target state="translated">С &lt;code&gt;pass_through&lt;/code&gt; все, что неизвестно, неоднозначно или снабжено недопустимой опцией, не будет помечено как ошибка. Вместо этого неизвестные параметры будут переданы в catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , если они есть, в противном случае - в &lt;code&gt;@ARGV&lt;/code&gt; . Это позволяет писать сценарии оболочки, которые обрабатывают только часть предоставленных пользователем аргументов командной строки и передают оставшиеся параметры какой-либо другой программе.</target>
        </trans-unit>
        <trans-unit id="f4663d47991fc6ad8f19a68b7dbd43ec5db93e1f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;pass_through&lt;/code&gt; anything that is unknown, ambiguous or supplied with an invalid option will not be flagged as an error. Instead the unknown option(s) will be passed to the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present, otherwise through to &lt;code&gt;@ARGV&lt;/code&gt;. This makes it possible to write wrapper scripts that process only part of the user supplied command line arguments, and pass the remaining options to some other program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21e85e4f08ba1ed663f7825a392d047ce118ae8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;printf&lt;/code&gt;, you get around this by using a block and an expression where you would place the filehandle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161b6ff35bc50314a49d188535255f199fcc9bb0" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;system()&lt;/code&gt;, both STDOUT and STDERR will go the same place as the script's STDOUT and STDERR, unless the &lt;code&gt;system()&lt;/code&gt; command redirects them. Backticks and &lt;code&gt;open()&lt;/code&gt; read &lt;b&gt;only&lt;/b&gt; the STDOUT of your command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb95ac886e1d528b24773e6c70b3ed1c1613335e" translate="yes" xml:space="preserve">
          <source>With EXPR, it returns some extra information that the debugger uses to print a stack trace. The value of EXPR indicates how many call frames to go back before the current one.</source>
          <target state="translated">С помощью EXPR он возвращает некоторую дополнительную информацию,которую отладчик использует для печати трассировки стека.Значение EXPR показывает,сколько кадров вызова нужно вернуть до текущего.</target>
        </trans-unit>
        <trans-unit id="a55096d08b5ad2fe54fd898185c93fb2c1c7dfdd" translate="yes" xml:space="preserve">
          <source>With Mac OS X 10.4 &quot;Tiger&quot; and newer, there is almost no performance penalty for non-prebound libraries. Earlier releases will suffer a greater load time than either the static library, or Apple's pre-bound dynamic library.</source>
          <target state="translated">В Mac OS X 10.4 &quot;Tiger&quot; и более новых версиях практически нет штрафов за неограниченное использование библиотек.Более ранние выпуски будут страдать от большей нагрузки,чем статические библиотеки или динамические библиотеки Apple.</target>
        </trans-unit>
        <trans-unit id="5f9d3d0136d8a2d2276cb1a4c4f0bb0c82be3696" translate="yes" xml:space="preserve">
          <source>With NTFS (and no CYGWIN=nontsec), there should be no problems even if perl was built on FAT.</source>
          <target state="translated">С NTFS (и без CYGWIN=nontsec)не должно быть проблем,даже если perl был построен на FAT.</target>
        </trans-unit>
        <trans-unit id="783aaaca75cc72bad41475003df821affc75b7c5" translate="yes" xml:space="preserve">
          <source>With OO style, you can break the message arbitrarily. This means that we are no longer limited to have space for the whole message in memory, i.e. we can handle messages of any size.</source>
          <target state="translated">В стиле OO,вы можете разбить сообщение произвольно.Это означает,что мы больше не ограничены местом в памяти для всего сообщения,т.е.можем обрабатывать сообщения любого размера.</target>
        </trans-unit>
        <trans-unit id="aa5707019a9c4f2624f176a48761ef4f1b3f5952" translate="yes" xml:space="preserve">
          <source>With Perl &amp;gt;= 5.6.2, you can also use a line like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1bf2f77022cd9fed463a5704b297d6ff88b00d5" translate="yes" xml:space="preserve">
          <source>With Perl 5.004 you can also use the TIEHANDLE interface to access compressed files just like ordinary files:</source>
          <target state="translated">С Perl 5.004 вы также можете использовать интерфейс TIEHANDLE для доступа к сжатым файлам,как к обычным файлам:</target>
        </trans-unit>
        <trans-unit id="9f110b40627d54799c1a5b4c023b449d3f05b59d" translate="yes" xml:space="preserve">
          <source>With Perl 5.10 and later, the smart match operator can give you the answer with the least amount of work:</source>
          <target state="translated">С помощью Perl 5.10 и более поздних версий &quot;умный&quot; оператор может дать Вам ответ с наименьшим объемом работы:</target>
        </trans-unit>
        <trans-unit id="4e55c608e124b42bf25bf02c154381796e1d9852" translate="yes" xml:space="preserve">
          <source>With a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7bad50138d4a906e034cdc8232445a6a34e8fb" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;, &lt;code&gt;charscript()&lt;/code&gt; returns the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca805fd21b2d73d6d3fa38629cb4d7c77aac2c21" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;&lt;code&gt;charblock()&lt;/code&gt; returns the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f458d9e5c6b401d23a0ff93a93cac73ffa40d782" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, &lt;code&gt;charscript()&lt;/code&gt; returns the</source>
          <target state="translated">С &lt;a href=&quot;#code-point-argument&quot;&gt;кодом точкой аргументом&lt;/a&gt; , &lt;code&gt;charscript()&lt;/code&gt; возвращает</target>
        </trans-unit>
        <trans-unit id="7cfd816e3af239ee8e3392fa5dd4b28e10c2cbf9" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;&lt;code&gt;charblock()&lt;/code&gt; returns the</source>
          <target state="translated">С &lt;a href=&quot;#code-point-argument&quot;&gt;аргументом кодовой точки &lt;/a&gt; &lt;code&gt;charblock()&lt;/code&gt; возвращает</target>
        </trans-unit>
        <trans-unit id="cc06a9c18caf674053e4b44b132356a1c540f757" translate="yes" xml:space="preserve">
          <source>With a little extra work, you can get all of the groups in angle brackets even if they are in other angle brackets too. Each time you get a balanced match, remove its outer delimiter (that's the one you just matched so don't match it again) and add it to a queue of strings to process. Keep doing that until you get no matches:</source>
          <target state="translated">С небольшой дополнительной работой вы можете получить все группы в угловых скобках,даже если они находятся в других угловых скобках.Каждый раз,когда вы получаете сбалансированное совпадение,удаляйте его внешний разделитель (это тот,который вы только что подобрали,так что не сравнивайте его снова)и добавляйте его в очередь строк для обработки.Продолжайте делать это до тех пор,пока не получите ни одного совпадения:</target>
        </trans-unit>
        <trans-unit id="a69059588956460f70f3f90c71a968d5af85c118" translate="yes" xml:space="preserve">
          <source>With a non-&lt;code&gt;DEBUGGING&lt;/code&gt; perl, the buckets starting from &lt;code&gt;128&lt;/code&gt; have a 4-byte overhead, and thus an 8192-long bucket may take up to 8188-byte allocations.</source>
          <target state="translated">При использовании perl без &lt;code&gt;DEBUGGING&lt;/code&gt; , начинающиеся со &lt;code&gt;128&lt;/code&gt; , имеют 4-байтовые накладные расходы, и, таким образом, сегмент длиной 8192 байта может занимать до 8188 байтов.</target>
        </trans-unit>
        <trans-unit id="3f782793180910fe0c252c5c5e6b40299dd75d89" translate="yes" xml:space="preserve">
          <source>With a slurpy parameter in the signature, there is no upper limit on how many arguments may be passed. A slurpy array parameter may be nameless just like a positional parameter, in which case its only effect is to turn off the argument limit that would otherwise apply:</source>
          <target state="translated">При использовании параметра slurpy в сигнатуре нет верхнего предела на то,сколько аргументов может быть передано.Параметр массива slurpy может быть безымянным так же,как и позиционный параметр,и в этом случае его единственный эффект-это отключение лимита аргументов,который в противном случае применялся бы:</target>
        </trans-unit>
        <trans-unit id="f9508f16c80ad6889c699daf40f43720b8251d92" translate="yes" xml:space="preserve">
          <source>With a technique called copy-on-write, the cost of copying with overload could be minimized or even completely avoided. A test implementation of COW did show performance gains for overloaded math, but introduced a performance loss due to a constant overhead for all other operations. So Math::BigInt does currently not COW.</source>
          <target state="translated">С помощью метода,называемого &quot;копирование на запись&quot;,стоимость копирования с перегрузкой может быть сведена к минимуму или даже полностью исключена.Тестовая реализация COW действительно показала прирост производительности при перегрузке математики,но ввела потерю производительности из-за постоянных накладных расходов на все остальные операции.Таким образом,математика::BigInt в настоящее время не COW.</target>
        </trans-unit>
        <trans-unit id="338611254651b6fbb00a03edfd8b2e0209a2413c" translate="yes" xml:space="preserve">
          <source>With a todo block, the tests inside are expected to fail. Test::More will run the tests normally, but print out special flags indicating they are &quot;todo&quot;. &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret failures as being ok. Should anything succeed, it will report it as an unexpected success. You then know the thing you had todo is done and can remove the TODO flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ebe6d7c43f224246d4ca3387c92f6cc94b15954" translate="yes" xml:space="preserve">
          <source>With a todo block, the tests inside are expected to fail. Test::More will run the tests normally, but print out special flags indicating they are &quot;todo&quot;. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret failures as being ok. Should anything succeed, it will report it as an unexpected success. You then know the thing you had todo is done and can remove the TODO flag.</source>
          <target state="translated">С блоком задач ожидается, что тесты внутри не пройдут. Test :: More будет запускать тесты в обычном режиме, но распечатывать специальные флаги, указывающие, что это &amp;laquo;todo&amp;raquo;. &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; интерпретирует отказы как нормальные. Если что-то удастся, он сообщит об этом как о неожиданном успехе. Затем вы знаете, что то, что вам нужно было сделать, выполнено и можете удалить флаг TODO.</target>
        </trans-unit>
        <trans-unit id="039f5d96db075baf2e35a9428955065fad856e3f" translate="yes" xml:space="preserve">
          <source>With all of the previous done, you're now ready to call Configure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be7163284f82da14a87936dad63fbf983833559" translate="yes" xml:space="preserve">
          <source>With all of the regexes above, if the regex matched anywhere in the string, it was considered a match. To specify</source>
          <target state="translated">При всех вышеперечисленных регексах,если регекс совпадал где-нибудь в строке,то считалось,что он совпадает.Чтобы указать</target>
        </trans-unit>
        <trans-unit id="a49675e374380fe043aff3a5f63d6512021ecfd9" translate="yes" xml:space="preserve">
          <source>With all of the regexps above, if the regexp matched anywhere in the string, it was considered a match. Sometimes, however, we'd like to specify</source>
          <target state="translated">При всех вышеперечисленных регеxps,если регеxp совпадал где-либо в строке,он считался совпадающим.Иногда,однако,нам хотелось бы указать.</target>
        </trans-unit>
        <trans-unit id="544d324c6a361c56f15aa84b4f308989bea67735" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">Используя &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , вы должны быть особенно внимательны, чтобы помнить, на что смотрят, когда:</target>
        </trans-unit>
        <trans-unit id="250cfbca6e5e22d4d573a90cd37797d2cb8d3ac5" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">Используя &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , вы должны быть особенно внимательны, чтобы помнить, на что смотрят, когда:</target>
        </trans-unit>
        <trans-unit id="8175ced4a0fd9d7cc491a3c946926864742f09d4" translate="yes" xml:space="preserve">
          <source>With an argument, can be used to generate a NaN with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28933cd0405c565c32304d3c729c7e6f31006ad2" translate="yes" xml:space="preserve">
          <source>With any of these, you can change file descriptors before the call:</source>
          <target state="translated">С помощью любого из них вы можете изменить дескрипторы файлов перед вызовом:</target>
        </trans-unit>
        <trans-unit id="944f492857a1db6c839174233fd1c02f59c056dd" translate="yes" xml:space="preserve">
          <source>With any version of Perl 5 you can use the basic OO interface:</source>
          <target state="translated">С любой версией Perl 5 вы можете использовать основной интерфейс OO:</target>
        </trans-unit>
        <trans-unit id="d9bf5579433ea6ddabc4d916f0dbd99e9c0f39ff" translate="yes" xml:space="preserve">
          <source>With argument force $ENCODING_... variables to set to the given value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaaac305ec8d42934372356813b4624fa49a8ffc" translate="yes" xml:space="preserve">
          <source>With argument sets the option. Without returns the option value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108bd0cf30895e3a18d32866a5ada0ba72c0b2d2" translate="yes" xml:space="preserve">
          <source>With bundling it is possible to set several single-character options at once. For example if &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="translated">При объединении можно установить сразу несколько односимвольных параметров. Например, если &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; - допустимые параметры,</target>
        </trans-unit>
        <trans-unit id="6a3391ab50835b72ad746f9bc70f0861004cbe03" translate="yes" xml:space="preserve">
          <source>With bundling it is possible to set several single-character options at once. For example if &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9c20d6876f103320c9d9424556b25f81d7af24" translate="yes" xml:space="preserve">
          <source>With earlier versions of Perl, you have to do a bit more work. If you are going to make this query many times over arbitrary string values, the fastest way is probably to invert the original array and maintain a hash whose keys are the first array's values:</source>
          <target state="translated">С более ранними версиями Perl,вы должны сделать немного больше работы.Если вы собираетесь сделать этот запрос много раз по произвольным строковым значениям,то,скорее всего,самым быстрым способом будет инвертирование исходного массива и поддержание хэша,ключи которого являются первыми значениями массива:</target>
        </trans-unit>
        <trans-unit id="089c9811008b67cdbb35efdae3d3f3034c15c2b2" translate="yes" xml:space="preserve">
          <source>With excerpts from Perl, and contributions and suggestions from Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus, Stephen McCamant, and David Landgren.</source>
          <target state="translated">С выдержками из Perl,а также материалами и предложениями от Рональда Дж.Кимбалла,Дэйва Митчелла,Доминика Данлопа,Марка Джейсона Домина,Стивена Маккаманта и Дэвида Лэндгрена.</target>
        </trans-unit>
        <trans-unit id="312cf396f9e4b4f5d83643b7fda95efc6c88ff9d" translate="yes" xml:space="preserve">
          <source>With hooks comes the ability to recurse back to the Storable engine. Indeed, hooks are regular Perl code, and Storable is convenient when it comes to serializing and deserializing things, so why not use it to handle the serialization string?</source>
          <target state="translated">С крючками приходит возможность вернуться обратно к двигателю Storable.Действительно,крючки-это обычный Perl-код,а Storable удобно использовать,когда дело доходит до сериализации и десериализации вещей,так почему бы не использовать его для работы со строкой сериализации?</target>
        </trans-unit>
        <trans-unit id="2092bcf7558e6632164a74cbb09d09cc7943a0d7" translate="yes" xml:space="preserve">
          <source>With lots of help and suggestions from Dean Roehrich, Malcolm Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant, and Gurusamy Sarathy.</source>
          <target state="translated">С большим количеством помощи и предложений от декана Рёриха,Малькольма Битти,Андреаса Кёнига,Пола Хадсона,Ильи Захаревича,Пола Маркеса,Нила Бауэрса,Мэтью Грина,Тима Банса,Человека-паука,Ульриха Пфайфера,Стивена Маккаманта и Гурусами Сарати.</target>
        </trans-unit>
        <trans-unit id="2f32ef7ca32db627a2acbe157dc6fb77e5ecddfd" translate="yes" xml:space="preserve">
          <source>With methods 2 and 3, Perl starts parsing the input file from the beginning, unless you've specified a &lt;a href=&quot;#-x&quot;&gt;&quot;-x&quot;&lt;/a&gt; switch, in which case it scans for the first line starting with &lt;code&gt;#!&lt;/code&gt; and containing the word &quot;perl&quot;, and starts there instead. This is useful for running a program embedded in a larger message. (In this case you would indicate the end of the program using the &lt;code&gt;__END__&lt;/code&gt; token.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2d0cebca8f8c753e2f714f5c39699038d3b25f" translate="yes" xml:space="preserve">
          <source>With methods 2 and 3, Perl starts parsing the input file from the beginning, unless you've specified a &lt;b&gt;-x&lt;/b&gt; switch, in which case it scans for the first line starting with &lt;code&gt;#!&lt;/code&gt; and containing the word &quot;perl&quot;, and starts there instead. This is useful for running a program embedded in a larger message. (In this case you would indicate the end of the program using the &lt;code&gt;__END__&lt;/code&gt; token.)</source>
          <target state="translated">В методах 2 и 3 Perl начинает синтаксический анализ входного файла с самого начала, если вы не указали переключатель &lt;b&gt;-x&lt;/b&gt; , и в этом случае он просматривает первую строку, начинающуюся с &lt;code&gt;#!&lt;/code&gt; и содержащий слово &quot;perl&quot;, и вместо этого начинается. Это полезно для запуска программы, встроенной в большое сообщение. (В этом случае вы должны указать конец программы с &lt;code&gt;__END__&lt;/code&gt; токена __END__ .)</target>
        </trans-unit>
        <trans-unit id="6316d5824ca52c312f770e770e783e4a6d5033d6" translate="yes" xml:space="preserve">
          <source>With mod_perl and the Apache::Registry module (distributed with mod_perl), httpd will run with an embedded Perl interpreter which pre-compiles your script and then executes it within the same address space without forking. The Apache extension also gives Perl access to the internal server API, so modules written in Perl can do just about anything a module written in C can. For more on mod_perl, see &lt;a href=&quot;http://perl.apache.org/&quot;&gt;http://perl.apache.org/&lt;/a&gt;</source>
          <target state="translated">С mod_perl и модулем Apache :: Registry (распространяется с mod_perl) httpd будет работать со встроенным интерпретатором Perl, который предварительно компилирует ваш скрипт, а затем выполняет его в том же адресном пространстве без разветвления. Расширение Apache также предоставляет Perl доступ к внутреннему API сервера, поэтому модули, написанные на Perl, могут делать практически все, что может модуль, написанный на C. Подробнее о mod_perl см. &lt;a href=&quot;http://perl.apache.org/&quot;&gt;Http://perl.apache.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d005d6fa4f38275ab653f946a0fd89499661e988" translate="yes" xml:space="preserve">
          <source>With mod_perl and the Apache::Registry module (distributed with mod_perl), httpd will run with an embedded Perl interpreter which pre-compiles your script and then executes it within the same address space without forking. The Apache extension also gives Perl access to the internal server API, so modules written in Perl can do just about anything a module written in C can. For more on mod_perl, see &lt;a href=&quot;https://perl.apache.org/&quot;&gt;http://perl.apache.org/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc2eb3f9b78400953fa9a4ff9c87b68e20c7b681" translate="yes" xml:space="preserve">
          <source>With much assistance regarding shared libraries from Marc Sabatella.</source>
          <target state="translated">С большой помощью в отношении общих библиотек от Марка Сабателлы.</target>
        </trans-unit>
        <trans-unit id="b462e2e8ccefffa9756bd47bbfa7c723db9b9b54" translate="yes" xml:space="preserve">
          <source>With negative offsets, it remembers its position from the end of the string when the target string is modified:</source>
          <target state="translated">При отрицательном смещении запоминает свою позицию с конца строки,когда изменяется целевая строка:</target>
        </trans-unit>
        <trans-unit id="00344cc849fc9376fff9de99085e79fa3cd552d0" translate="yes" xml:space="preserve">
          <source>With no MASK argument present, it returns the current operator mask of the compartment.</source>
          <target state="translated">При отсутствии аргумента MASK он возвращает текущую маску оператора помещения.</target>
        </trans-unit>
        <trans-unit id="a35650496b577c95afdac0e1ebb0191fd46fd2e0" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole array (whether or not the element was specified as &lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt; ).</source>
          <target state="translated">Без аргументов метод доступа возвращает ссылку на весь массив элемента (независимо от того, был ли элемент указан как &lt;code&gt;'@'&lt;/code&gt; или &lt;code&gt;'*@'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a8ef3568dccdeee73b65f3996dd1707e6feb3878" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole array (whether or not the element was specified as &lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4963e3a2e84181fb9a499ef49896fdab34cd7c" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole hash (whether or not the element was specified as &lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt; ).</source>
          <target state="translated">Без аргументов метод доступа возвращает ссылку на весь хэш элемента (независимо от того, был ли элемент указан как &lt;code&gt;'%'&lt;/code&gt; или &lt;code&gt;'*%'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="988bcaf50ce8ee9902f007f6fc6c2b44abddd67d" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole hash (whether or not the element was specified as &lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bae0e18d43bcb818e56d07261a055232eff0bf8" translate="yes" xml:space="preserve">
          <source>With no arguments (or using &lt;code&gt;threads::all&lt;/code&gt; ) and in a list context, returns a list of all non-joined, non-detached</source>
          <target state="translated">Без аргументов (или с использованием &lt;code&gt;threads::all&lt;/code&gt; ) и в контексте списка возвращает список всех несоединенных, несвязанных</target>
        </trans-unit>
        <trans-unit id="9a2c5169b8859351e115fccd32105029ad3b3e99" translate="yes" xml:space="preserve">
          <source>With no arguments (or using &lt;code&gt;threads::all&lt;/code&gt;) and in a list context, returns a list of all non-joined, non-detached</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18cf8c9e6afcd23474d7fb3a81386e0988d7bd68" translate="yes" xml:space="preserve">
          <source>With older versions of Perl, the &lt;a href=&quot;IO::String&quot;&gt;IO::String&lt;/a&gt; module provides similar functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4cfb999178855ab18f46ce9c518e1bd1ef50096" translate="yes" xml:space="preserve">
          <source>With older versions of Perl, the &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO::String&lt;/a&gt; module provides similar functionality.</source>
          <target state="translated">В более старых версиях Perl модуль &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO :: String&lt;/a&gt; предоставляет аналогичные функции.</target>
        </trans-unit>
        <trans-unit id="789c0f1114004fe97c889b4fd162dac50dbb4785" translate="yes" xml:space="preserve">
          <source>With one exception (below), if both strings look like numbers to Perl, the magic increment will not be applied, and the strings will be treated as numbers (more specifically, integers) instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c467eeeb4f15846c2e3c26d1b4d74776d4da75d4" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is a key specifying one element of the hash; the second argument, if present, is assigned to the hash element. If the element type is &lt;code&gt;'%'&lt;/code&gt; , the accessor returns the hash element value. If the element type is &lt;code&gt;'*%'&lt;/code&gt; , a reference to the hash element is returned.</source>
          <target state="translated">С одним или двумя аргументами первый аргумент - это ключ, определяющий один элемент хеша; второй аргумент, если он присутствует, присваивается хеш-элементу. Если тип элемента - &lt;code&gt;'%'&lt;/code&gt; , метод доступа возвращает значение хеш-элемента. Если тип элемента - &lt;code&gt;'*%'&lt;/code&gt; , возвращается ссылка на хэш-элемент.</target>
        </trans-unit>
        <trans-unit id="0bd4bcbdb7945f28a4390fecea625c7a59fd6d00" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is a key specifying one element of the hash; the second argument, if present, is assigned to the hash element. If the element type is &lt;code&gt;'%'&lt;/code&gt;, the accessor returns the hash element value. If the element type is &lt;code&gt;'*%'&lt;/code&gt;, a reference to the hash element is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="043fe821df73a58116e971eada4906da49321cca" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is an index specifying one element of the array; the second argument, if present, is assigned to the array element. If the element type is &lt;code&gt;'@'&lt;/code&gt; , the accessor returns the array element value. If the element type is &lt;code&gt;'*@'&lt;/code&gt; , a reference to the array element is returned.</source>
          <target state="translated">С одним или двумя аргументами первый аргумент - это индекс, определяющий один элемент массива; второй аргумент, если он присутствует, присваивается элементу массива. Если тип элемента - &lt;code&gt;'@'&lt;/code&gt; , метод доступа возвращает значение элемента массива. Если тип элемента - &lt;code&gt;'*@'&lt;/code&gt; , возвращается ссылка на элемент массива.</target>
        </trans-unit>
        <trans-unit id="eca88cd532fb52622336dc15fcd9f2fe4531eda4" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is an index specifying one element of the array; the second argument, if present, is assigned to the array element. If the element type is &lt;code&gt;'@'&lt;/code&gt;, the accessor returns the array element value. If the element type is &lt;code&gt;'*@'&lt;/code&gt;, a reference to the array element is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82587a9e3d9d950371c40dd7e06719bffb84440" translate="yes" xml:space="preserve">
          <source>With option -exec, walks tree in execute order, otherwise in basic order.</source>
          <target state="translated">С опцией -exec,ходит дерево в порядке выполнения,в противном случае в основном порядке.</target>
        </trans-unit>
        <trans-unit id="57d705a8d20354296c55ade02ce168e9aba3ea9c" translate="yes" xml:space="preserve">
          <source>With overloaded math, only the first two variants will result in a BigFloat:</source>
          <target state="translated">При перегруженной математике только первые два варианта приводят к BigFloat:</target>
        </trans-unit>
        <trans-unit id="04cbc8f37da7397c953eb4dca3b6f0e0eee0dac0" translate="yes" xml:space="preserve">
          <source>With overloaded operators, it is the first (dominating) operand that determines which method is called. Here are some examples showing what actually gets called in various cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b46b3274ff332d0d8381195e802b804512dbcd" translate="yes" xml:space="preserve">
          <source>With proper care you may mix package and my (or state) &lt;code&gt;$a&lt;/code&gt; and/or &lt;code&gt;$b&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d4085fcb09a164c92639ac09b2aa2b53f4f318" translate="yes" xml:space="preserve">
          <source>With respect to character matching, there are a few more points you need to know about. First of all, not all characters can be used &quot;as is&quot; in a match. Some characters, called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549d9ba8c522ce4226592827b058814ec17aafc9" translate="yes" xml:space="preserve">
          <source>With respect to character matching, there are a few more points you need to know about. First of all, not all characters can be used 'as is' in a match. Some characters, called</source>
          <target state="translated">Что касается совмещения символов,есть еще несколько пунктов,о которых вам нужно знать.Прежде всего,не все символы могут быть использованы в матче &quot;как есть&quot;.Некоторые символы,называемые</target>
        </trans-unit>
        <trans-unit id="f52704b066745f4539042b4ca42ac5911b1eae8e" translate="yes" xml:space="preserve">
          <source>With respect to files, one that has the proper permission bit set to let you access the file. With respect to computer programs, one that&amp;rsquo;s written well enough that someone has a chance of figuring out what it&amp;rsquo;s trying to do.</source>
          <target state="translated">Что касается файлов, то тот, у которого установлен правильный бит разрешения, позволяющий вам получить доступ к файлу. Что касается компьютерных программ, они написаны достаточно хорошо, чтобы кто-то мог понять, что они пытаются делать.</target>
        </trans-unit>
        <trans-unit id="3dc4eefad3d29ef780cb07bfc36df49d416959b4" translate="yes" xml:space="preserve">
          <source>With respect to loading &lt;code&gt;Exporter&lt;/code&gt; and inheriting, there are alternatives with the use of modules like &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt; .</source>
          <target state="translated">Что касается загрузки &lt;code&gt;Exporter&lt;/code&gt; и наследования, есть альтернативы с использованием таких модулей, как &lt;code&gt;base&lt;/code&gt; и &lt;code&gt;parent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ddfefdcb8919ff4ad4881cdfab3eb3ea6c93a49" translate="yes" xml:space="preserve">
          <source>With respect to loading &lt;code&gt;Exporter&lt;/code&gt; and inheriting, there are alternatives with the use of modules like &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64aab757411e3efe138dbb9f7787c6359c1eec8b" translate="yes" xml:space="preserve">
          <source>With some firewalls active mode does not work as the server cannot connect to your machine (because you are behind a firewall) and the firewall does not re-write the command. In this case you should set &lt;code&gt;ftp_ext_passive&lt;/code&gt; to a</source>
          <target state="translated">С некоторыми брандмауэрами активный режим не работает, поскольку сервер не может подключиться к вашей машине (потому что вы находитесь за брандмауэром), и брандмауэр не перезаписывает команду. В этом случае вы должны установить &lt;code&gt;ftp_ext_passive&lt;/code&gt; на</target>
        </trans-unit>
        <trans-unit id="39e7b288b06e2af98b83632e08ab80e03b9bf7c3" translate="yes" xml:space="preserve">
          <source>With source filters, you can store the text of your script compressed and use a source filter to uncompress it for Perl's parser:</source>
          <target state="translated">С помощью фильтров исходного кода вы можете хранить текст вашего скрипта в сжатом виде и использовать фильтр исходного кода,чтобы распаковать его для парсера Perl:</target>
        </trans-unit>
        <trans-unit id="f3d0833032fe049783c845044de2a75767e40f62" translate="yes" xml:space="preserve">
          <source>With support for &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; this may be circumvented - unless one of DLLs is started from</source>
          <target state="translated">Благодаря поддержке &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; это можно обойти - если одна из DLL не запущена из</target>
        </trans-unit>
        <trans-unit id="741296e189dd1627ab6af5dc824e2c81acff153a" translate="yes" xml:space="preserve">
          <source>With that trick MakeMaker will only read the first line and thus read the underscore, while the perl interpreter will evaluate the $VERSION and convert the string into a number. Later operations that treat $VERSION as a number will then be able to do so without provoking a warning about $VERSION not being a number.</source>
          <target state="translated">С помощью этого трюка MakeMaker прочитает только первую строку и,таким образом,прочитает подчеркивание,в то время как интерпретатор perl вычислит $VERSION и преобразует строку в число.Более поздние операции,которые рассматривают $VERSION как число,затем смогут сделать это без предупреждения о том,что $VERSION не является числом.</target>
        </trans-unit>
        <trans-unit id="fa542340f7199357b9ddb7d211923c323666ef12" translate="yes" xml:space="preserve">
          <source>With the &quot;tcp&quot; protocol the ping() method attempts to establish a connection to the remote host's echo port. If the connection is successfully established, the remote host is considered reachable. No data is actually echoed. This protocol does not require any special privileges but has higher overhead than the &quot;udp&quot; and &quot;icmp&quot; protocols.</source>
          <target state="translated">С помощью протокола &quot;tcp&quot; метод ping()пытается установить соединение с эхо-портом удаленного хоста.Если соединение успешно установлено,удаленный хост считается доступным.На самом деле эхо-сигнал не передается.Этот протокол не требует никаких специальных привилегий,но имеет более высокие накладные расходы,чем протоколы &quot;udp&quot; и &quot;icmp&quot;.</target>
        </trans-unit>
        <trans-unit id="0c9c2cd66698ade01d6241c0c3475076fe41182f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma you can use the &lt;code&gt;:locale&lt;/code&gt; layer</source>
          <target state="translated">С помощью &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma вы можете использовать слой &lt;code&gt;:locale&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4721b12184df4c626e83aff44b61b424dee2894" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. are immediately available for use in the replacement expression. With the global modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; will search and replace all occurrences of the regex in the string:</source>
          <target state="translated">С помощью оператора &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; сопоставленные переменные &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; и т. Д. Сразу становятся доступными для использования в выражении замены. С помощью глобального модификатора &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; будет искать и заменять все вхождения регулярного выражения в строке:</target>
        </trans-unit>
        <trans-unit id="a5f3ac7301bb1927406401553bc7979a7058d48f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma you can control the behaviour of the builtin &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">С помощью прагмы &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; вы можете управлять поведением встроенной функции &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed30d894507576a6aff023249124e00f485a0445" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;IN&lt;/code&gt; subpragma you can declare the default layers of input streams, and with the &lt;code&gt;OUT&lt;/code&gt; subpragma you can declare the default layers of output streams. With the &lt;code&gt;IO&lt;/code&gt; subpragma (may be omitted for &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;:locale&lt;/code&gt;, or &lt;code&gt;:encoding&lt;/code&gt;) you can control both input and output streams simultaneously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640e6849be58e830210cdb457742bd0e5d46239f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;IN&lt;/code&gt; subpragma you can declare the default layers of input streams, and with the &lt;code&gt;OUT&lt;/code&gt; subpragma you can declare the default layers of output streams. With the &lt;code&gt;IO&lt;/code&gt; subpragma you can control both input and output streams simultaneously.</source>
          <target state="translated">С помощью субпрагмы &lt;code&gt;IN&lt;/code&gt; вы можете объявить уровни входных потоков по умолчанию, а с помощью субпрагмы &lt;code&gt;OUT&lt;/code&gt; вы можете объявить уровни по умолчанию для выходных потоков. С помощью субпрагмы &lt;code&gt;IO&lt;/code&gt; вывода вы можете управлять как входными, так и выходными потоками одновременно.</target>
        </trans-unit>
        <trans-unit id="9a9bb48f29cda9ceed93d7949280d0a2ae7a947b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; logical name defined as &quot;ENABLE&quot;, setting &lt;code&gt;$?&lt;/code&gt; will cause the new value to be encoded into &lt;code&gt;$^E&lt;/code&gt; so that either the original parent or child exit status values 0 to 255 can be automatically recovered by C programs expecting _POSIX_EXIT behavior. If both a parent and a child exit value are non-zero, then it will be assumed that this is actually a VMS native status value to be passed through. The special value of 0xFFFF is almost a NOOP as it will cause the current native VMS status in the C library to become the current native Perl VMS status, and is handled this way as it is known to not be a valid native VMS status value. It is recommend that only values in the range of normal Unix parent or child status numbers, 0 to 255 are used.</source>
          <target state="translated">С логическим именем &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; , определенным как &quot;ENABLE&quot;, установка &lt;code&gt;$?&lt;/code&gt; приведет к тому, что новое значение будет закодировано в &lt;code&gt;$^E&lt;/code&gt; так что исходные родительские или дочерние значения статуса выхода от 0 до 255 могут быть автоматически восстановлены программами на C, ожидающими поведения _POSIX_EXIT. Если и родительское, и дочернее значение выхода не равны нулю, тогда предполагается, что это фактически значение собственного статуса VMS, которое нужно передать. Специальное значение 0xFFFF - это почти NOOP, поскольку оно приведет к тому, что текущий собственный статус VMS в библиотеке C станет текущим собственным статусом Perl VMS, и обрабатывается таким образом, поскольку известно, что оно не является допустимым значением статуса собственного VMS. Рекомендуется использовать только значения в диапазоне обычных номеров родительского или дочернего статуса Unix от 0 до 255.</target>
        </trans-unit>
        <trans-unit id="d83714fab9481b19a76857b0c66b38bb676d9244" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;open&lt;/code&gt; pragma you can use the &lt;code&gt;:locale&lt;/code&gt; layer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aef762dfae7dd14d56c63866d88c9f9105ac20d" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;s///&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. are immediately available for use in the replacement expression. With the global modifier, &lt;code&gt;s///g&lt;/code&gt; will search and replace all occurrences of the regex in the string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2822b5f3a724906c266471a5abc1878fe1a5daf9" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;sort&lt;/code&gt; pragma you can control the behaviour of the builtin &lt;code&gt;sort()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85c0b58283979a05b1d958cf7b8e77666b21187" translate="yes" xml:space="preserve">
          <source>With the C-style operators that would have been written like this:</source>
          <target state="translated">С операторами в стиле С,которые были бы написаны так:</target>
        </trans-unit>
        <trans-unit id="12231f536f1fde7f945e73b86c0bb0963f5133af" translate="yes" xml:space="preserve">
          <source>With the FCGI module (from CPAN) and the mod_fastcgi module (available from &lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/&lt;/a&gt; ) each of your Perl programs becomes a permanent CGI daemon process.</source>
          <target state="translated">С модулем FCGI (из CPAN) и модулем mod_fastcgi (доступным на &lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/&lt;/a&gt; ) каждая из ваших программ Perl становится постоянным процессом демона CGI.</target>
        </trans-unit>
        <trans-unit id="e9f0f761b750ef587b104ca22707f7d417110d25" translate="yes" xml:space="preserve">
          <source>With the MASK argument present, it sets the operator mask for the compartment (equivalent to calling the deny_only method).</source>
          <target state="translated">При наличии аргумента MASK он устанавливает маску оператора для отсека (эквивалент вызова метода deny_only).</target>
        </trans-unit>
        <trans-unit id="a26ddc37c924b20873cf0fb8deaac6c02f3c0643" translate="yes" xml:space="preserve">
          <source>With the _POSIX_EXIT macro set, the Unix exit value of zero is represented as a VMS native status of 1, and the Unix values from 2 to 255 are encoded by the equation:</source>
          <target state="translated">В наборе макросов _POSIX_EXIT выходное значение Unix равняется нулю,а значения Unix от 2 до 255 кодируются уравнением:</target>
        </trans-unit>
        <trans-unit id="ca23bf605fbab54b13a6b11fd9b026fcad525316" translate="yes" xml:space="preserve">
          <source>With the above regexp all content following (and including) any of the given &lt;code&gt;=head1&lt;/code&gt; headings will be shown. It is possible to restrict the output to particular subsections only, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b04e80858e882edcc84d0f324c4fa0f1bc41eaae" translate="yes" xml:space="preserve">
          <source>With the check_sigs parameter you can turn signature checking on and off. The default is off for now because the whole tool chain for the functionality is not yet considered mature by some. The author of CPAN.pm would recommend setting it to true most of the time and turning it off only if it turns out to be annoying.</source>
          <target state="translated">С помощью параметра check_sigs можно включать и выключать проверку сигнатур.По умолчанию на данный момент отключена,т.к.вся цепочка инструментов для функциональности некоторыми еще не считается зрелой.Автор CPAN.pm порекомендовал бы большую часть времени устанавливать ее в true и выключать только в том случае,если это окажется раздражающим.</target>
        </trans-unit>
        <trans-unit id="65d6f831578499e9dbe5b97d3e54d9d6970d12d6" translate="yes" xml:space="preserve">
          <source>With the completion of Example 4, we now have an easy way to simulate some real-life libraries whose interfaces may not be the cleanest in the world. We shall now continue with a discussion of the arguments passed to the &lt;b&gt;xsubpp&lt;/b&gt; compiler.</source>
          <target state="translated">После завершения примера 4 у нас теперь есть простой способ моделирования некоторых реальных библиотек, интерфейсы которых могут быть не самыми чистыми в мире. Теперь мы продолжим обсуждение аргументов, переданных компилятору &lt;b&gt;xsubpp&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="1f205214a6ba2cf07a234149bf2d1460c5296c50" translate="yes" xml:space="preserve">
          <source>With the creation of the &lt;code&gt;IO::Compress&lt;/code&gt; and &lt;code&gt;IO::Uncompress&lt;/code&gt; modules no new features are planned for &lt;code&gt;Compress::Zlib&lt;/code&gt; - the new modules do everything that &lt;code&gt;Compress::Zlib&lt;/code&gt; does and then some. Development on &lt;code&gt;Compress::Zlib&lt;/code&gt; will be limited to bug fixes only.</source>
          <target state="translated">С созданием модулей &lt;code&gt;IO::Compress&lt;/code&gt; и &lt;code&gt;IO::Uncompress&lt;/code&gt; никаких новых функций для &lt;code&gt;Compress::Zlib&lt;/code&gt; не планируется - новые модули делают все, что делает &lt;code&gt;Compress::Zlib&lt;/code&gt; , а затем и некоторые. Разработка &lt;code&gt;Compress::Zlib&lt;/code&gt; будет ограничена только исправлением ошибок.</target>
        </trans-unit>
        <trans-unit id="257b1120ebcd7fe1453a131da8ee68f42d2f7003" translate="yes" xml:space="preserve">
          <source>With the default setting of &lt;code&gt;$Storable::flags&lt;/code&gt; = 6, creating or destroying random objects, even renamed objects can be controlled by an attacker. See CVE-2015-1592 and its metasploit module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f3553b9522af30d1dac804157bedd65e6495d3" translate="yes" xml:space="preserve">
          <source>With the default setting the size is limited to 128MB. The -1 removes this limit. If the &quot;make test&quot; fails please change your /etc/security/limits as stated above.</source>
          <target state="translated">При настройке по умолчанию размер ограничен 128MB.Значение -1 снимает это ограничение.Если &quot;make test&quot; не удается,пожалуйста,измените /etc/security/limits,как указано выше.</target>
        </trans-unit>
        <trans-unit id="9b9699d8827c96371e7103bd01aa95e9549d18da" translate="yes" xml:space="preserve">
          <source>With the example above, you knew to look for &lt;code&gt;Perl_pp_add&lt;/code&gt; , but what if there were multiple calls to it all over the place, or you didn't know what the op was you were looking for?</source>
          <target state="translated">В приведенном выше примере вы знали, что нужно искать &lt;code&gt;Perl_pp_add&lt;/code&gt; , но что, если было несколько обращений к нему повсюду или вы не знали, какую операцию вы ищете?</target>
        </trans-unit>
        <trans-unit id="cfa6b797e8e5233002fffa69434e7ca138b4ff32" translate="yes" xml:space="preserve">
          <source>With the example above, you knew to look for &lt;code&gt;Perl_pp_add&lt;/code&gt;, but what if there were multiple calls to it all over the place, or you didn't know what the op was you were looking for?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65607d779f766d1b6b4828b7428d0ded3d690325" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 32-bit mode.</source>
          <target state="translated">С помощью следующих опций вы получаете Perl версию,которая проходит все тесты make в 32-битном режиме.</target>
        </trans-unit>
        <trans-unit id="a8358873bd6ba12b8e2a5bea80bf9adbb46e0a6e" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">С помощью следующих опций вы получаете Perl-версию,которая проходит все make тесты в 64-битном режиме.</target>
        </trans-unit>
        <trans-unit id="26bc1ab7fe70714950b9630e3ca1a3522b890186" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">С помощью следующих опций вы получаете потоковую Perl-версию,которая проходит все тесты make в 64-битном режиме.</target>
        </trans-unit>
        <trans-unit id="653ecd70c393a4f98976d6cf49198158a3d68bae" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in threaded 32-bit mode, which is the default configuration for the Perl builds that AIX ships with.</source>
          <target state="translated">Со следующими опциями вы получаете потоковую Perl версию,которая проходит все тесты в потоковом 32-битном режиме,что является конфигурацией по умолчанию для Perl сборок,которые AIX поставляется с.</target>
        </trans-unit>
        <trans-unit id="aeae9f602df12b1cbf706e0ffe90fc7d11fa8d65" translate="yes" xml:space="preserve">
          <source>With the help of Jarkko Hietaniemi the Configure system has been tweaked to run under abc-shell so the recommend build process is as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826dec98b275c7a952ab77d69c22223ec197d3b5" translate="yes" xml:space="preserve">
          <source>With the introduction of lexical warnings, mandatory warnings now become</source>
          <target state="translated">С введением лексических предупреждений,обязательные предупреждения теперь стали</target>
        </trans-unit>
        <trans-unit id="cb83c7552e22c7b5119774691db23c4fd72dba00" translate="yes" xml:space="preserve">
          <source>With the introduction of the</source>
          <target state="translated">С введением</target>
        </trans-unit>
        <trans-unit id="dd358809edabd87f2081065d37eb93940f155fac" translate="yes" xml:space="preserve">
          <source>With the lock released, process &quot;B&quot; can now continue. It also updates the database and unfortunately it too modifies the data that was in its initial buffer. Once that data gets flushed to disk it will overwrite some/all of the changes process &quot;A&quot; made to the database.</source>
          <target state="translated">При отпущенном замке процесс &quot;B&quot; теперь может продолжаться.Он также обновляет БД и,к сожалению,тоже модифицирует данные,которые были в его первоначальном буфере.Как только эти данные будут прошиты на диск,он перезапишет некоторые/все изменения процесса &quot;A&quot;,внесенные в БД.</target>
        </trans-unit>
        <trans-unit id="b4b71a45e3d179fe5db4257fdf8f0f1934140fcb" translate="yes" xml:space="preserve">
          <source>With the release 5.003_01 the dynamically loadable libraries should be rebuilt when a different version of Perl is compiled. In particular, DLLs (including</source>
          <target state="translated">С выходом 5.003_01 динамически загружаемые библиотеки должны быть перестроены при компиляции другой версии Perl.В частности,DLL (включая</target>
        </trans-unit>
        <trans-unit id="a313290bcf78e6ca63c8b821c60748978a4d212c" translate="yes" xml:space="preserve">
          <source>With this keyword present &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;&quot;The RETVAL Variable&quot;&lt;/a&gt; is created, and in the generated call to the subroutine this variable is assigned to, but the value of this variable is not going to be used in the auto-generated code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5325c34a4ae29cf34042f77f365e0b89df2159a0" translate="yes" xml:space="preserve">
          <source>With this keyword present &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt; is created, and in the generated call to the subroutine this variable is assigned to, but the value of this variable is not going to be used in the auto-generated code.</source>
          <target state="translated">При наличии этого ключевого слова &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;создается переменная RETVAL&lt;/a&gt; , и в сгенерированном вызове подпрограммы эта переменная назначается, но значение этой переменной не будет использоваться в автоматически сгенерированном коде.</target>
        </trans-unit>
        <trans-unit id="92fdd49156ba7199f10cc8d72686bcba30a111b6" translate="yes" xml:space="preserve">
          <source>With this method you can specify your own boolean values for decoding - on decode, JSON &lt;code&gt;false&lt;/code&gt; will be decoded as a copy of &lt;code&gt;$false&lt;/code&gt;, and JSON &lt;code&gt;true&lt;/code&gt; will be decoded as &lt;code&gt;$true&lt;/code&gt; (&quot;copy&quot; here is the same thing as assigning a value to another variable, i.e. &lt;code&gt;$copy = $false&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666c6c1292ea8eefe8526f26c75c36dbe91118ff" translate="yes" xml:space="preserve">
          <source>With this module, simply change all &lt;code&gt;use_ok&lt;/code&gt; in test scripts to &lt;code&gt;use ok&lt;/code&gt;, and they will be executed at &lt;code&gt;BEGIN&lt;/code&gt; time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153c87b7fb53ffdf16b2513e4ef9fbf84bb1453a" translate="yes" xml:space="preserve">
          <source>With this module, simply change all &lt;code&gt;use_ok&lt;/code&gt; in test scripts to &lt;code&gt;use ok&lt;/code&gt;, and they will be executed at &lt;code&gt;BEGIN&lt;/code&gt; time. The explicit space after &lt;code&gt;use&lt;/code&gt; makes it clear that this is a single compile-time action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7c25b6745f51eae37c62a2374f7ba131484e1b" translate="yes" xml:space="preserve">
          <source>With this option, the rendering of each statement (starting with the nextstate OP) will be preceded by the 1st line of source code that generates it. For example:</source>
          <target state="translated">При использовании этой опции,рендерингу каждого оператора (начиная с оператора nextstate OP)будет предшествовать 1-я строка исходного кода,которая его генерирует.Например:</target>
        </trans-unit>
        <trans-unit id="8f18c563efb0b7956e6e194500e98dba172fcbe5" translate="yes" xml:space="preserve">
          <source>With this syntax, the whitespace character(s) after the &quot;C&amp;lt;&amp;lt;&amp;lt;&quot; and before the &quot;&amp;gt;&amp;gt;&amp;gt;&quot; (or whatever letter) are</source>
          <target state="translated">В этом синтаксисе пробельные символы после &amp;laquo;C &amp;lt;&amp;lt;&amp;lt;&amp;raquo; и перед &amp;laquo;&amp;gt;&amp;gt;&amp;gt;&amp;raquo; (или любой другой буквой) являются</target>
        </trans-unit>
        <trans-unit id="9b739cdb3f9d5a8eac7c3872d89896d374a02d63" translate="yes" xml:space="preserve">
          <source>With this, &quot;somepackage&quot; will be required, then the stash is inspected, and each function is rendered.</source>
          <target state="translated">При этом потребуется &quot;какой-нибудь пакет&quot;,после чего тайник проверяется,и каждая функция выводится на экран.</target>
        </trans-unit>
        <trans-unit id="a5fec2f4d5db8c4f13f212d9ea51033367a444e6" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;charinrange()&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if its input code point maps to &lt;code&gt;$default&lt;/code&gt; . You can avoid this by omitting the &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement, and adding a line after the loop to handle the final element of the inversion map.</source>
          <target state="translated">При этом &lt;code&gt;charinrange()&lt;/code&gt; вернет &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если его входная кодовая точка соответствует &lt;code&gt;$default&lt;/code&gt; . Вы можете избежать этого, пропустив &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; оператор и добавив строку после цикла для обработки последнего элемента карты инверсии.</target>
        </trans-unit>
        <trans-unit id="1fa4ea5d2b0cc15e776882f8e7626028cc55d8d1" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;charinrange()&lt;/code&gt; will return &lt;code&gt;undef&lt;/code&gt; if its input code point maps to &lt;code&gt;$default&lt;/code&gt;. You can avoid this by omitting the &lt;code&gt;next&lt;/code&gt; statement, and adding a line after the loop to handle the final element of the inversion map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf65bbf1a94d413d2ba7d4e9b042fb1c11c5b955" translate="yes" xml:space="preserve">
          <source>With those two in hand, you should add</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dae05359217975cb78e41e5b34deca474650edf" translate="yes" xml:space="preserve">
          <source>With threads one must be careful to make sure they all have a chance to run to completion, assuming that is what you want.</source>
          <target state="translated">С нитями нужно быть осторожным,чтобы убедиться,что все они имеют шанс бежать до конца,предполагая,что это то,что вы хотите.</target>
        </trans-unit>
        <trans-unit id="caa257633e4cd0d103eaaa262d9da80593127c23" translate="yes" xml:space="preserve">
          <source>With todo tests, it's best to have the tests actually run. That way you'll know when they start passing. Sometimes this isn't possible. Often a failing test will cause the whole program to die or hang, even inside an &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; with and using &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;. In these extreme cases you have no choice but to skip over the broken tests entirely.</source>
          <target state="translated">В случае тестов todo лучше всего запускать тесты. Так вы узнаете, когда они начнут проходить. Иногда это невозможно. Часто неудачный тест приводит к тому, что вся программа умирает или зависает, даже внутри &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; с и с использованием &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; . В этих крайних случаях у вас нет другого выбора, кроме как полностью пропустить сломанные тесты.</target>
        </trans-unit>
        <trans-unit id="72faa2ea768ae70d5c7c6ca8ac92ad17c2ec51b0" translate="yes" xml:space="preserve">
          <source>With todo tests, it's best to have the tests actually run. That way you'll know when they start passing. Sometimes this isn't possible. Often a failing test will cause the whole program to die or hang, even inside an &lt;code&gt;eval BLOCK&lt;/code&gt; with and using &lt;code&gt;alarm&lt;/code&gt;. In these extreme cases you have no choice but to skip over the broken tests entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec0e094c2438c09cc3dbc2cdfeb2a697dd782dc5" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;(?[ ])&lt;/code&gt; , no literal characters are allowed unless they are within an inner pair of square brackets, like</source>
          <target state="translated">Внутри &lt;code&gt;(?[ ])&lt;/code&gt; Буквальные символы не допускаются, если они не находятся во внутренней паре квадратных скобок, например</target>
        </trans-unit>
        <trans-unit id="2c0a661c629aabc7b0ae903d13c19ad238648286" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;(?[ ])&lt;/code&gt;, no literal characters are allowed unless they are within an inner pair of square brackets, like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8425db1df10e66ba739a46b6d044fcd9cc27fd" translate="yes" xml:space="preserve">
          <source>Within Perl, you may use this directly:</source>
          <target state="translated">Внутри Perl,вы можете использовать это напрямую:</target>
        </trans-unit>
        <trans-unit id="34e265601157e7965a7e7bfdb3408a61baf139df" translate="yes" xml:space="preserve">
          <source>Within USS your /etc/profile or $HOME/.profile may limit your ulimit settings. Check that the following command returns reasonable values:</source>
          <target state="translated">Внутри USS ваш /etc/профиль или $HOME/.profile может ограничивать ваши настройки ulimit.Убедитесь,что следующая команда возвращает разумные значения:</target>
        </trans-unit>
        <trans-unit id="a1b6f4407e8eee6ed8eafbd79c8d18589c6adc10" translate="yes" xml:space="preserve">
          <source>Within []-length '%c' not allowed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ba20619ba09719c47471e336e4ab5403150666" translate="yes" xml:space="preserve">
          <source>Within a Pod block, there are &lt;b&gt;Pod paragraphs&lt;/b&gt;. A Pod paragraph consists of non-blank lines of text, separated by one or more blank lines.</source>
          <target state="translated">Внутри блока Pod есть &lt;b&gt;параграфы Pod&lt;/b&gt; . Абзац модуля состоит из непустых строк текста, разделенных одной или несколькими пустыми строками.</target>
        </trans-unit>
        <trans-unit id="e21031e24f9ec987f957a61688b27e62b9c110c1" translate="yes" xml:space="preserve">
          <source>Within a character class:</source>
          <target state="translated">В пределах класса персонажей:</target>
        </trans-unit>
        <trans-unit id="40c178236d58dee9559c7a2a4195e7fba2bd546e" translate="yes" xml:space="preserve">
          <source>Within a pattern, you may designate subpatterns for later reference by enclosing them in parentheses, and you may refer back to the</source>
          <target state="translated">Внутри шаблона можно обозначить подмаски для последующего использования,заключив их в круглые скобки,а также можно сослаться на</target>
        </trans-unit>
        <trans-unit id="0cfdb7962d912e72a66b4f3d5343b1e5e212ac27" translate="yes" xml:space="preserve">
          <source>Within a subroutine the array &lt;code&gt;@_&lt;/code&gt; contains the parameters passed to that subroutine. Inside a subroutine, &lt;code&gt;@_&lt;/code&gt; is the default array for the array operators &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Внутри подпрограммы массив &lt;code&gt;@_&lt;/code&gt; содержит параметры, переданные этой подпрограмме. Внутри подпрограммы &lt;code&gt;@_&lt;/code&gt; - это массив по умолчанию для операторов массива &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e22e0024e5aeb5956fe2008749d86a9a403a100c" translate="yes" xml:space="preserve">
          <source>Within a subroutine the array &lt;code&gt;@_&lt;/code&gt; contains the parameters passed to that subroutine. Inside a subroutine, &lt;code&gt;@_&lt;/code&gt; is the default array for the array operators &lt;code&gt;pop&lt;/code&gt; and &lt;code&gt;shift&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61eb6fb3f1061f743841ee282bbf0ef293486491" translate="yes" xml:space="preserve">
          <source>Within each function inside each Xsub, print to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab4fe9703eceeab90b6dcb41e63f66c50a795d5" translate="yes" xml:space="preserve">
          <source>Within search patterns (which also undergo double-quotish substitution) there is an unfortunate ambiguity: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; to be interpreted as &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is a character class for the regular expression) or as &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is the subscript to array @foo)? If @foo doesn't otherwise exist, then it's obviously a character class. If @foo exists, Perl takes a good guess about &lt;code&gt;[bar]&lt;/code&gt; , and is almost always right. If it does guess wrong, or if you're just plain paranoid, you can force the correct interpretation with curly braces as above.</source>
          <target state="translated">В шаблонах поиска (которые также заменяются двойными кавычками) есть досадная двусмысленность: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; следует интерпретировать как &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (где &lt;code&gt;[bar]&lt;/code&gt; - это класс символов для регулярное выражение) или как &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (где &lt;code&gt;[bar]&lt;/code&gt; - это индекс массива @foo)? Если @foo иначе не существует, то это, очевидно, класс символов. Если @foo существует, Perl хорошо догадывается о &lt;code&gt;[bar]&lt;/code&gt; и почти всегда прав. Если он ошибается, или если вы просто параноик, вы можете заставить правильную интерпретацию использовать фигурные скобки, как указано выше.</target>
        </trans-unit>
        <trans-unit id="7cb74f80aa6eb14f52d2f4452df6c30aa1982c05" translate="yes" xml:space="preserve">
          <source>Within search patterns (which also undergo double-quotish substitution) there is an unfortunate ambiguity: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; to be interpreted as &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is a character class for the regular expression) or as &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is the subscript to array @foo)? If @foo doesn't otherwise exist, then it's obviously a character class. If @foo exists, Perl takes a good guess about &lt;code&gt;[bar]&lt;/code&gt;, and is almost always right. If it does guess wrong, or if you're just plain paranoid, you can force the correct interpretation with curly braces as above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84dbb525d8c49a11b671ff1144decfba831a5a9" translate="yes" xml:space="preserve">
          <source>Within strings that are to be displayed in a fixed-length text field, each control character is substituted by a space. (But remember the special meaning of &lt;code&gt;\r&lt;/code&gt; when using fill mode.) This is done to avoid misalignment when control characters &quot;disappear&quot; on some output media.</source>
          <target state="translated">В строках, которые должны отображаться в текстовом поле фиксированной длины, каждый управляющий символ заменяется пробелом. (Но помните об особом значении &lt;code&gt;\r&lt;/code&gt; при использовании режима заполнения.) Это сделано, чтобы избежать перекоса, когда управляющие символы &amp;laquo;исчезают&amp;raquo; на некоторых носителях вывода.</target>
        </trans-unit>
        <trans-unit id="4456754ccf74e411d5ea49ec8792a5f2c7c3945a" translate="yes" xml:space="preserve">
          <source>Within that basic form, add the parts that you need to insert, change, or delete lines.</source>
          <target state="translated">Внутри этой базовой формы добавьте части,которые необходимо вставить,изменить или удалить строки.</target>
        </trans-unit>
        <trans-unit id="8cbc5afc548aa028061d92c2e27d708ba5cdc361" translate="yes" xml:space="preserve">
          <source>Within that module, create an &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine.</source>
          <target state="translated">В этом модуле создайте подпрограмму &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dff20e9d902ef01082006d18ff0c36d8795b519a" translate="yes" xml:space="preserve">
          <source>Within that module, create an &lt;code&gt;import&lt;/code&gt; subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c44a88f26bc68b39089193962c587ad7e818543" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine do a call to &lt;code&gt;filter_add&lt;/code&gt; , passing it either a subroutine reference.</source>
          <target state="translated">Внутри подпрограммы &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; вызовите &lt;code&gt;filter_add&lt;/code&gt; , передав ему ссылку на подпрограмму.</target>
        </trans-unit>
        <trans-unit id="5abecf0e7e2c92cb0f99df6a077dc9ac3a61e15b" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;import&lt;/code&gt; subroutine do a call to &lt;code&gt;filter_add&lt;/code&gt;, passing it either a subroutine reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ccfeaad3b7f2de2f94c5b7b2a2afe57c62216c" translate="yes" xml:space="preserve">
          <source>Within the alternative numbering group, group numbers start at the same position for each alternative. After the group, numbering continues with one higher than the maximum reached across all the alternatives.</source>
          <target state="translated">Внутри альтернативной группы нумерации номера групп начинаются с одной и той же позиции для каждой альтернативы.После группы нумерация продолжается на единицу выше максимального значения,достигнутого во всех альтернативных вариантах.</target>
        </trans-unit>
        <trans-unit id="bee307dd55ae8e02f4730b754c6aca4828fa5f41" translate="yes" xml:space="preserve">
          <source>Within the anonymous subroutine or block that is passed to &lt;code&gt;FILTER&lt;/code&gt; , process the contents of $_ to change the source code in the desired manner.</source>
          <target state="translated">Внутри анонимной подпрограммы или блока, переданного в &lt;code&gt;FILTER&lt;/code&gt; , обработайте содержимое $ _, чтобы изменить исходный код желаемым образом.</target>
        </trans-unit>
        <trans-unit id="f2c9c97c479e458c15e3c5d21939c42abe0d2569" translate="yes" xml:space="preserve">
          <source>Within the anonymous subroutine or block that is passed to &lt;code&gt;FILTER&lt;/code&gt;, process the contents of $_ to change the source code in the desired manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dffaf4183817eca592a98bbc21aa16f78f04d43" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;use feature 'unicode_strings'&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c20e56f1d9e34b6bd5de0acc2c9d7db7958c51" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;use feature 'unicode_strings' &lt;/a&gt;</source>
          <target state="translated">В рамках &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;использования функция unicode_strings&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f89e477d30d08ce7cdab550d7ebf952c865e297" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt;, all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cdd83d3707c192ff676dcfeb7f714897a412bb4" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;&lt;code&gt;use locale 'not_characters'&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;perllocale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt; and the current locale is a UTF-8 locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db5115b248b9b3a92796783fe0ad72c64d3ee250" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;use locale 'not_characters' &lt;/a&gt;, or &lt;a href=&quot;perllocale&quot;&gt;use locale &lt;/a&gt; and the current locale is a UTF-8 locale.</source>
          <target state="translated">В рамках &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;использования языковой стандарт not_characters&lt;/a&gt; или &lt;a href=&quot;perllocale&quot;&gt;используйте языковой стандарт,&lt;/a&gt; и текущий языковой стандарт является локалью UTF-8.</target>
        </trans-unit>
        <trans-unit id="4b75686c25d4349996112a3e43d160bed9377b64" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher</source>
          <target state="translated">В рамках &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; или выше</target>
        </trans-unit>
        <trans-unit id="921e8cdb506222d3c5cb715870308743278f73c9" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">В рамках области &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; все кодовые точки, отличные от ASCII Latin1, заключаются в кавычки, независимо от того, закодирована ли строка как UTF-8 или нет. Как упоминалось выше, языковой стандарт не влияет на цитирование символов диапазона ASCII. Это защищает от тех языков, в которых используются такие символы, как &lt;code&gt;&quot;|&quot;&lt;/code&gt; считаются символами слова.</target>
        </trans-unit>
        <trans-unit id="7f97b0baeb5c1f48ecb7c6036a913594c0cf832a" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt;</source>
          <target state="translated">В рамках &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c6da8dacdcff581b760f12d305142c260f19722" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">В рамках области &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; все кодовые точки, отличные от ASCII Latin1, заключаются в кавычки, независимо от того, закодирована ли строка как UTF-8 или нет. Как упоминалось выше, языковой стандарт не влияет на цитирование символов диапазона ASCII. Это защищает от тех языков, в которых используются такие символы, как &lt;code&gt;&quot;|&quot;&lt;/code&gt; считаются символами слова.</target>
        </trans-unit>
        <trans-unit id="9be64790ef4be673df7cd3468e821cd802e4c982" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;use 5.012&lt;/code&gt; or higher</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f08cf765adbbec5334990e6d1e73f436a06d62" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;use re 'strict'&lt;/code&gt; in a regular expression pattern, you included an unescaped &lt;code&gt;}&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt; which was interpreted literally. These two characters are sometimes metacharacters, and sometimes literals, depending on what precedes them in the pattern. This is unlike the similar &lt;code&gt;)&lt;/code&gt; which is always a metacharacter unless escaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872708d75ba2c62155c9282b19d1ffd74c4ecb87" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;use utf8&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93e8b9c84e9c172138891ffbac960fd8330a481" translate="yes" xml:space="preserve">
          <source>Within the subroutine reference, call &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; to &quot;prime&quot; $_ with source code data from the source file that will &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; your module. Check the status value returned to see if any source code was actually read in.</source>
          <target state="translated">В справочнике подпрограммы вызовите &lt;code&gt;filter_read&lt;/code&gt; или &lt;code&gt;filter_read_exact&lt;/code&gt; , чтобы &quot; заполнить &quot; $ _ данными исходного кода из исходного файла, который будет &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ваш модуль. Проверьте возвращаемое значение статуса, чтобы узнать, действительно ли был прочитан какой-либо исходный код.</target>
        </trans-unit>
        <trans-unit id="de9983c2f6aa6265b66999a54845fc283501a6b7" translate="yes" xml:space="preserve">
          <source>Within the subroutine reference, call &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; to &quot;prime&quot; $_ with source code data from the source file that will &lt;code&gt;use&lt;/code&gt; your module. Check the status value returned to see if any source code was actually read in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5ec220eb3f4bb73f8ef5f923e39ec8ab09a071" translate="yes" xml:space="preserve">
          <source>Within the while loop we call accept() and check to see if it returns a false value. This would normally indicate a system error needs to be reported. However, the introduction of safe signals (see &lt;a href=&quot;#Deferred-Signals-%28Safe-Signals%29&quot;&gt;&quot;Deferred Signals (Safe Signals)&quot;&lt;/a&gt; above) in Perl 5.8.0 means that accept() might also be interrupted when the process receives a signal. This typically happens when one of the forked subprocesses exits and notifies the parent process with a CHLD signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5dc8da9477105396ff0284ea2a7a7433b232a3" translate="yes" xml:space="preserve">
          <source>Within the while loop we call accept() and check to see if it returns a false value. This would normally indicate a system error needs to be reported. However, the introduction of safe signals (see &lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals)&lt;/a&gt; above) in Perl 5.8.0 means that accept() might also be interrupted when the process receives a signal. This typically happens when one of the forked subprocesses exits and notifies the parent process with a CHLD signal.</source>
          <target state="translated">В цикле while мы вызываем accept () и проверяем, возвращает ли он ложное значение. Обычно это означает, что необходимо сообщить о системной ошибке. Однако введение безопасных сигналов (см. &lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;Отложенные сигналы (Safe Signals)&lt;/a&gt; выше) в Perl 5.8.0 означает, что accept () также может быть прерван, когда процесс получает сигнал. Обычно это происходит, когда один из разветвленных подпроцессов завершает работу и уведомляет родительский процесс сигналом CHLD.</target>
        </trans-unit>
        <trans-unit id="17b7808b8c8156fa9926b089d73ad2021671fe67" translate="yes" xml:space="preserve">
          <source>Without Readline support you may see the symbols &quot;^[[A&quot;, &quot;^[[C&quot;, &quot;^[[B&quot;, &quot;^[[D&quot;&quot;, &quot;^H&quot;, ... when using the arrow keys and/or the backspace key.</source>
          <target state="translated">Без поддержки Readline вы можете видеть символы &quot;^[[A]&quot;,&quot;^[[C]&quot;,&quot;^[[B],&quot;^[[D]&quot;,&quot;^H&quot;,...при использовании клавиш со стрелками и/или клавиш с обратной связью.</target>
        </trans-unit>
        <trans-unit id="7a72072ff5468f365a1052f00033c60b07221002" translate="yes" xml:space="preserve">
          <source>Without additional configuration, GetOptions() will ignore the case of option names, and allow the options to be abbreviated to uniqueness.</source>
          <target state="translated">Без дополнительной конфигурации GetOptions()проигнорирует регистр имен опций и позволит сократить их до уникальности.</target>
        </trans-unit>
        <trans-unit id="6c913350e18f669953ddd82b1ef504eb99115e6c" translate="yes" xml:space="preserve">
          <source>Without any such configuration, or if Perl itself is built using the system's own IO, then write operations assume that the file handle accepts only</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298442b657e2392a0a1bf4ca9f3ba61c68419ef3" translate="yes" xml:space="preserve">
          <source>Without argument, it returns the currently used icmp protocol message type. By default, it returns 'echo'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5efb30492f1c199d1a2c0cf117a4ad4a638df64" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves a regular expression for simplifying the individual item strings once the list type has been determined. Usage: E.g. when converting to HTML, one might strip the leading number in an ordered list as &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; already prints numbers itself. This must have been set before by either specifying &lt;b&gt;-rx&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;rx()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">Без аргументов извлекает регулярное выражение для упрощения отдельных строк элементов после определения типа списка. Использование: например, при преобразовании в HTML можно удалить начальное число в упорядоченном списке, поскольку &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; уже сам печатает числа. Это должно было быть установлено ранее либо путем указания &lt;b&gt;-rx&lt;/b&gt; в &lt;b&gt;методе &lt;/b&gt;&lt;b&gt;new (),&lt;/b&gt; либо путем вызова метода &lt;b&gt;rx ()&lt;/b&gt; со скалярным аргументом.</target>
        </trans-unit>
        <trans-unit id="18657a3de0c78898530507337e291d8dba0f72cc" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the list tag, which can be any scalar. This must have been set before by either specifying &lt;b&gt;-tag&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;tag()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">Без аргументов извлекает информацию о теге списка, который может быть любым скаляром. Это должно было быть установлено ранее либо путем указания &lt;b&gt;-tag&lt;/b&gt; в &lt;b&gt;методе &lt;/b&gt;&lt;b&gt;new (),&lt;/b&gt; либо путем вызова метода &lt;b&gt;tag ()&lt;/b&gt; со скалярным аргументом.</target>
        </trans-unit>
        <trans-unit id="8ccc25a668b5326c657bc2f5c79197991b145ee7" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the parent holding this list, which is represented as an arbitrary scalar. This must have been set before by either specifying &lt;b&gt;-parent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;parent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">Без аргументов извлекает информацию о родителе, содержащем этот список, который представлен в виде произвольного скаляра. Это должно было быть установлено ранее либо путем указания &lt;b&gt;-parent&lt;/b&gt; в &lt;b&gt;методе &lt;/b&gt;&lt;b&gt;new (),&lt;/b&gt; либо путем вызова метода &lt;b&gt;parent ()&lt;/b&gt; со скалярным аргументом.</target>
        </trans-unit>
        <trans-unit id="c9f5dc6cba8c17ba8a8e789cb997502b75241827" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the array of the items in this list. The items may be represented by any scalar. If an argument has been given, it is pushed on the list of items.</source>
          <target state="translated">Без аргументов получает массив элементов этого списка.Элементы могут быть представлены любым скаляром.Если задан аргумент,то он вытесняется в список элементов.</target>
        </trans-unit>
        <trans-unit id="b13b7cf761d2e7e6717a0226cb08e73a66d55812" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the file name the list is in. This must have been set before by either specifying &lt;b&gt;-file&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;file()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">Без аргумента извлекает имя файла, в котором находится список. Это должно быть установлено ранее либо путем указания &lt;b&gt;-file&lt;/b&gt; в методе &lt;b&gt;new (),&lt;/b&gt; либо путем вызова метода &lt;b&gt;file ()&lt;/b&gt; со скалярным аргументом.</target>
        </trans-unit>
        <trans-unit id="1b1eba0344418f60cab2e73b154b51b8cc2fd939" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the indent level of the list as specified in &lt;code&gt;=over n&lt;/code&gt; . This must have been set before by either specifying &lt;b&gt;-indent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;indent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">Без аргумента извлекает уровень отступа списка, указанный в &lt;code&gt;=over n&lt;/code&gt; . Это должно было быть установлено ранее, указав &lt;b&gt;-indent&lt;/b&gt; в &lt;b&gt;методе &lt;/b&gt;&lt;b&gt;new ()&lt;/b&gt; или вызвав метод &lt;b&gt;indent ()&lt;/b&gt; со скалярным аргументом.</target>
        </trans-unit>
        <trans-unit id="c3a863e0f35dbdfaea66e845edf4708bb6d53918" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the line number where the list started. This must have been set before by either specifying &lt;b&gt;-start&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;start()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">Без аргумента извлекает номер строки, с которой начался список. Это должно было быть установлено ранее либо путем указания &lt;b&gt;-start&lt;/b&gt; в методе &lt;b&gt;new (),&lt;/b&gt; либо путем вызова метода &lt;b&gt;start ()&lt;/b&gt; со скалярным аргументом.</target>
        </trans-unit>
        <trans-unit id="914d0fa2ff8badbccd79dfd30e292a8ed73be0c1" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the list type, which can be an arbitrary value, e.g. &lt;code&gt;OL&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , ... when thinking the HTML way. This must have been set before by either specifying &lt;b&gt;-type&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;type()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">Без аргументов извлекает тип списка, который может быть произвольным значением, например &lt;code&gt;OL&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , ... при мышлении в формате HTML. Это должно было быть установлено ранее либо указанием &lt;b&gt;-type&lt;/b&gt; в методе &lt;b&gt;new (),&lt;/b&gt; либо путем вызова метода &lt;b&gt;type ()&lt;/b&gt; со скалярным аргументом.</target>
        </trans-unit>
        <trans-unit id="0c21aaff33380d9ba14cee3094239dfc4fb494ab" translate="yes" xml:space="preserve">
          <source>Without arguments libnetcfg displays the current configuration.</source>
          <target state="translated">Без аргументов libnetcfg отображает текущую конфигурацию.</target>
        </trans-unit>
        <trans-unit id="4decffda157c9d482865e95a2bef98fbdd07c180" translate="yes" xml:space="preserve">
          <source>Without autodie (and assuming BAREWORD is an open filehandle/dirhandle) this is a valid call to chdir. But under autodie, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; will behave like it had the prototype &quot;;$&quot; and thus BAREWORD will be a syntax error (under &quot;use strict&quot;. Without strict, it will interpreted as a filename).</source>
          <target state="translated">Без autodie (и при условии, что BAREWORD - это открытый дескриптор файла / dirhandle) это правильный вызов chdir. Но в autodie &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; будет вести себя так, как будто у него был прототип &quot;; $&quot;, и поэтому BAREWORD будет синтаксической ошибкой (в разделе &quot;use strict&quot;. Без strict он будет интерпретироваться как имя файла).</target>
        </trans-unit>
        <trans-unit id="4f60150307dd02c8b93f0a67955bd9770e2759c8" translate="yes" xml:space="preserve">
          <source>Without autodie (and assuming BAREWORD is an open filehandle/dirhandle) this is a valid call to chdir. But under autodie, &lt;code&gt;chdir&lt;/code&gt; will behave like it had the prototype &quot;;$&quot; and thus BAREWORD will be a syntax error (under &quot;use strict&quot;. Without strict, it will interpreted as a filename).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157dc325ab3004964dba8cb99f25c548e59c3ee6" translate="yes" xml:space="preserve">
          <source>Without binmode this happens to work but without binmode, print() fails instead of write().</source>
          <target state="translated">Без режима binmode это случается,но без режима binmode,print()выходит из строя вместо write().</target>
        </trans-unit>
        <trans-unit id="9fae572f92ad00688736431e8db34f7e13e97183" translate="yes" xml:space="preserve">
          <source>Without compiling a special Perl, there is no way to get the exact same behavior of any versions prior to Perl 5.18.0. The closest one can get is by setting PERL_PERTURB_KEYS to 0 and setting the PERL_HASH_SEED to a known value. We do not advise those settings for production use due to the above security considerations.</source>
          <target state="translated">Без компиляции специального Perl невозможно получить точно такое же поведение любых версий до Perl 5.18.0.Ближайший путь-установить значение PERL_PERTURB_KEYS равным 0 и значение PERL_HASH_SEED равным известному значению.Мы не рекомендуем эти настройки для использования в производстве в связи с вышеизложенными соображениями безопасности.</target>
        </trans-unit>
        <trans-unit id="40d89b93ede452cf3a3abe5db73cc3f6990cb465" translate="yes" xml:space="preserve">
          <source>Without sending mail to the address and seeing whether there's a human on the other end to answer you, you cannot fully answer part</source>
          <target state="translated">Не отправив почту на адрес и не увидев,есть ли на другом конце человек,который может вам ответить,вы не сможете полностью ответить на вопрос.</target>
        </trans-unit>
        <trans-unit id="9dc761ae6cda1ca106ca429a9b91481691a414c5" translate="yes" xml:space="preserve">
          <source>Without tests provided by the original author, how can anyone else changing perl in the future be sure that they haven't unwittingly broken the behaviour the patch implements? And without tests, how can the patch's author be confident that his/her hard work put into the patch won't be accidentally thrown away by someone in the future?</source>
          <target state="translated">Без тестов,предоставленных первоначальным автором,как кто-либо может быть уверен в том,что в будущем,изменив perl,он не случайно сломал поведение патч-инструментария? А без тестов,как автор патча может быть уверен,что его тяжелый труд,вложенный в патч,не будет случайно выброшен кем-то в будущем?</target>
        </trans-unit>
        <trans-unit id="c1443d621edad5afbf828f718460ec1c38b6ccbc" translate="yes" xml:space="preserve">
          <source>Without that empty line before the &quot;=head1&quot;, many translators wouldn't have recognized the &quot;=head1&quot; as starting a Pod block.</source>
          <target state="translated">Без этой пустой строки перед &quot;=head1&quot; многие переводчики не узнали бы &quot;=head1&quot; как стартующий блок Под.</target>
        </trans-unit>
        <trans-unit id="d67d28a004691a2df73ec622342b344f42349502" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; declaration, this code will not compile under the &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; pragma.</source>
          <target state="translated">Без &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; объявления $ AUTOLOAD этот код не будет компилироваться согласно директиве &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e556997c8bdf4cc597d6477622db2033d0112438" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;our $AUTOLOAD&lt;/code&gt; declaration, this code will not compile under the &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8106389e31f882e4de34e6fb1c8fa83f4529f426" translate="yes" xml:space="preserve">
          <source>Without the \ before the #, we'd have the start of a Makefile comment, and the macro would be incorrectly defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9862e56ba4382f4550c0a053a28a9edc67cb29a8" translate="yes" xml:space="preserve">
          <source>Without the \\ before the #, we'd have the start of a Makefile comment, and the macro would be incorrectly defined.</source>
          <target state="translated">Без \\ перед#мы бы начали комментарий Makefile,и макрос был бы неверно определен.</target>
        </trans-unit>
        <trans-unit id="c652adb6df9438fc28974e5263002f95713055c4" translate="yes" xml:space="preserve">
          <source>Without the all-critical &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declaration, putting UTF‑8 in your literals and identifiers won&amp;rsquo;t work right. If you used the standard preamble just given above, this already happened. If you did, you can do things like this:</source>
          <target state="translated">Без объявления &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; критически важного &lt;a href=&quot;functions/use&quot;&gt;использования использование&lt;/a&gt; UTF ‑ 8 в литералах и идентификаторах не будет работать правильно. Если вы использовали только что приведенную выше стандартную преамбулу, это уже произошло. Если да, то вы можете сделать следующее:</target>
        </trans-unit>
        <trans-unit id="022916bda3b0da7053428b82057c474802fe172c" translate="yes" xml:space="preserve">
          <source>Without the all-critical &lt;code&gt;use utf8&lt;/code&gt; declaration, putting UTF‑8 in your literals and identifiers won&amp;rsquo;t work right. If you used the standard preamble just given above, this already happened. If you did, you can do things like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a805f73e432af03c931e3e4ebc6e43febdbb1b0f" translate="yes" xml:space="preserve">
          <source>Without the braces, Perl would have looked for a $whospeak, a &lt;code&gt;$who::0&lt;/code&gt; , and a &lt;code&gt;$who's&lt;/code&gt; variable. The last two would be the $0 and the $s variables in the (presumably) non-existent package &lt;code&gt;who&lt;/code&gt; .</source>
          <target state="translated">Без фигурных скобок Perl искал бы переменные $ whospeak, &lt;code&gt;$who::0&lt;/code&gt; и &lt;code&gt;$who's&lt;/code&gt; . Последние две будут переменными $ 0 и $ s в (предположительно) несуществующем пакете &lt;code&gt;who&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b59ba0c86d5008d327ba4145261903f48586e59b" translate="yes" xml:space="preserve">
          <source>Without the braces, Perl would have looked for a $whospeak, a &lt;code&gt;$who::0&lt;/code&gt;, and a &lt;code&gt;$who's&lt;/code&gt; variable. The last two would be the $0 and the $s variables in the (presumably) non-existent package &lt;code&gt;who&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7119185642381b4835e616a2adfce6407060de" translate="yes" xml:space="preserve">
          <source>Without the file handle there is no straightforward way to map from the C callback to the Perl subroutine.</source>
          <target state="translated">Без файловой рукоятки нет простого способа отобразить карту от обратного вызова C к подпрограмме Perl.</target>
        </trans-unit>
        <trans-unit id="557fc723a913d1e3b2505b4094298be8eec2001a" translate="yes" xml:space="preserve">
          <source>Without the quotes Perl would convert the large number to a floating point constant at compile time and then hand the result to BigInt, which results in an truncated result or a NaN.</source>
          <target state="translated">Без кавычек Perl преобразовывал бы большое число в константу с плавающей точкой во время компиляции,а затем передавал бы результат в BigInt,что приводило бы к усеченному результату или NaN.</target>
        </trans-unit>
        <trans-unit id="cd8dcbc5d0ba46dab27a245d8542910769851151" translate="yes" xml:space="preserve">
          <source>Without the quotes Perl would convert the large number to a floating point constant at compile time and then hand the result to Math::BigInt, which results in an truncated result or a NaN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d0e0ada47acb90500aed8583377dc7e9485f05" translate="yes" xml:space="preserve">
          <source>Without this function call, threads that use the &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt; system function will not work properly, as all the locale-sensitive functions will look at the per-thread locale, and &lt;code&gt;setlocale&lt;/code&gt; will have no effect on this thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd1a191c5e0195ae68815f767eadf66793aed3f" translate="yes" xml:space="preserve">
          <source>Without this pragma, if strings operating under byte semantics and strings with Unicode character data are concatenated, the new string will be created by decoding the byte strings as</source>
          <target state="translated">Без этой прагмы,если строки,работающие по байтовой семантике,и строки с символьными данными Юникода будут скомкатированы,новая строка будет создана путем декодирования байтовых строк как</target>
        </trans-unit>
        <trans-unit id="4e3240128cc4ac6294817aa01c1437d4416b9150" translate="yes" xml:space="preserve">
          <source>Word characters</source>
          <target state="translated">Символы слов</target>
        </trans-unit>
        <trans-unit id="c1ab804bf377c2d02f25ebababbe5112fca26b12" translate="yes" xml:space="preserve">
          <source>Work Crew</source>
          <target state="translated">Рабочая бригада</target>
        </trans-unit>
        <trans-unit id="73f4875bffaeefb6bc4c9e5de5982f1c956b5814" translate="yes" xml:space="preserve">
          <source>Work around DCL's 255 character limit several times,and use VMS-style command line quoting in a few cases.</source>
          <target state="translated">Несколько раз обходите 255-символьный лимит DCL и в некоторых случаях используйте кавычки из командной строки в стиле VMS.</target>
        </trans-unit>
        <trans-unit id="beb03a8c30af39505328c268c1180c75604701a0" translate="yes" xml:space="preserve">
          <source>Work for the pumpking, work for Perl programmers, work for module authors, ... Perl is supposed to be easy.</source>
          <target state="translated">Работа для накачки,работа для программистов Perl,работа для авторов модулей,...Perl должен быть простым.</target>
        </trans-unit>
        <trans-unit id="91f920f3d44c34d2ff6c9dd9603498397730bf04" translate="yes" xml:space="preserve">
          <source>Worked by applying a role that wrapped &lt;code&gt;Test::Builder-&amp;gt;_print_comment&lt;/code&gt;. Fixed by adding an event filter that modifies the message instead when running under Test2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b837e4f0aacd9d9f6074d443ecd309cef87e661e" translate="yes" xml:space="preserve">
          <source>Working code is always preferred to pie-in-the-sky ideas. A patch to add a feature stands a much higher chance of making it to the language than does a random feature request, no matter how fervently argued the request might be. This ties into &quot;Will it be useful?&quot;, as the fact that someone took the time to make the patch demonstrates a strong desire for the feature.</source>
          <target state="translated">Рабочий код всегда предпочитается идеям &quot;пирога в небе&quot;.Заплатка для добавления функции имеет гораздо больше шансов попасть в язык,чем случайный запрос функции,независимо от того,насколько горячо он был аргументирован.Это связано с вопросом &quot;Будет ли это полезно?&quot;,поскольку тот факт,что кто-то потратил время на создание патча,свидетельствует о сильном желании использовать эту возможность.</target>
        </trans-unit>
        <trans-unit id="791f0cf1a4866efe09fa052199378fd87a29a636" translate="yes" xml:space="preserve">
          <source>Working with AVs</source>
          <target state="translated">Работа с аудио-видео оборудованием</target>
        </trans-unit>
        <trans-unit id="fcf77865e202a40f39e6dc4633dec2c1c8b8542a" translate="yes" xml:space="preserve">
          <source>Working with HVs</source>
          <target state="translated">Работа с ВГС</target>
        </trans-unit>
        <trans-unit id="9ba6b91bf263dc667dda1becd81a9fbef7358bbd" translate="yes" xml:space="preserve">
          <source>Working with Net::FTP</source>
          <target state="translated">Работа с сетью::FTP</target>
        </trans-unit>
        <trans-unit id="9522f5ef01714aab2e2d70111bf52346aa9851c3" translate="yes" xml:space="preserve">
          <source>Working with SVs</source>
          <target state="translated">Работа с SV</target>
        </trans-unit>
        <trans-unit id="acaa1f9e891f841e4f55280185da1c9a0bc87b80" translate="yes" xml:space="preserve">
          <source>Working with files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efe528e837c3e9dd842174c934d74e9c8e8af64" translate="yes" xml:space="preserve">
          <source>Works currently only for integers.</source>
          <target state="translated">В настоящее время работает только для целых чисел.</target>
        </trans-unit>
        <trans-unit id="c9cb7c59dae1a78441bca64b16b41d57dc70c3e5" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;like()&lt;/code&gt; , only it checks if $got &lt;b&gt;does not&lt;/b&gt; match the given pattern.</source>
          <target state="translated">Работает точно так же , как , &lt;code&gt;like()&lt;/code&gt; , только он проверяет $ GOT &lt;b&gt;не&lt;/b&gt; соответствует заданному шаблону.</target>
        </trans-unit>
        <trans-unit id="6ffef90261775bf1446d64de441c14b751512d3c" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;like()&lt;/code&gt;, only it checks if $got &lt;b&gt;does not&lt;/b&gt; match the given pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f0dce4381260fc309ade54b455e20a83cc12f0" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#index-STR%2CSUBSTR%2CPOSITION&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; except that it returns the position of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9232c0576386ef7db9a66e0f3312f80aa2ae0362" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">Работает так же, как &lt;a href=&quot;#localtime&quot;&gt;местное время,&lt;/a&gt; но возвращаемые значения локализованы для стандартного часового пояса Гринвича.</target>
        </trans-unit>
        <trans-unit id="9839a604fd52293ec52fedd95d5b5d8df3818c2c" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69a4f2f77bbe0fae40d114143aa5065b6ddabd02" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;cmp_ok()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d895f5ba3197e6e250fa353d94a31dc5531f0f" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">Работает так же, как &lt;a href=&quot;localtime&quot;&gt;местное время,&lt;/a&gt; но возвращаемые значения локализованы для стандартного часового пояса Гринвича.</target>
        </trans-unit>
        <trans-unit id="59edd54160d7f94a92175d3ce89e67babbe534fb" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;cmp_ok()&lt;/code&gt; .</source>
          <target state="translated">Работает так же , как &lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt; &amp;laquo;s &lt;code&gt;cmp_ok()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b054b39e72ec238653744e3a117cbf2b7bacaa18" translate="yes" xml:space="preserve">
          <source>Works just like index() except that it returns the position of the</source>
          <target state="translated">Работает так же,как и index(),за исключением того,что она возвращает позицию</target>
        </trans-unit>
        <trans-unit id="ff14a89d24955b4d292116a9dd09815095b69cb7" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_catpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_setpvf_mg&quot;&gt;&quot;sv_setpvf_mg&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62b7e0373549dae581f58b37784d19f9d489170e" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_catpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_setpvf_mg&lt;/code&gt; .</source>
          <target state="translated">Работает как &lt;code&gt;sv_catpvf&lt;/code&gt; , но копирует текст в SV вместо того, чтобы добавлять его. Не справляется с магией &amp;laquo;установки&amp;raquo;. См. &lt;code&gt;sv_setpvf_mg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c14d76b99d10ba25b831daac8203cd025304f5fc" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_vsetpvf_mg&quot;&gt;&quot;sv_vsetpvf_mg&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ccfff897978a36d025fbdd87f7f80f29da36e5" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; .</source>
          <target state="translated">Работает как &lt;code&gt;sv_vcatpvf&lt;/code&gt; , но копирует текст в SV вместо того, чтобы добавлять его. Не справляется с магией &amp;laquo;установки&amp;raquo;. См. &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce9ad1c2559537d328f2e9ae5ccf06d2341106d3" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvfn&lt;/code&gt; but copies the text into the SV instead of appending it.</source>
          <target state="translated">Работает как &lt;code&gt;sv_vcatpvfn&lt;/code&gt; , но копирует текст в SV вместо того, чтобы добавлять его.</target>
        </trans-unit>
        <trans-unit id="97569be8c378569cf569a2abd589e6182aac8aca" translate="yes" xml:space="preserve">
          <source>Works remotely similar to &lt;code&gt;filter_json_object&lt;/code&gt;, but is only called for JSON objects having a single key named &lt;code&gt;$key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28088b9057a774cbeb7647c942ba983be39b65a" translate="yes" xml:space="preserve">
          <source>Workshops</source>
          <target state="translated">Workshops</target>
        </trans-unit>
        <trans-unit id="aca31ad78f24eb8f34a6f1515e5ad96783f7a4c5" translate="yes" xml:space="preserve">
          <source>World Wide Web, HTML, HTTP, CGI, MIME</source>
          <target state="translated">Всемирная паутина,HTML,HTTP,CGI,MIME</target>
        </trans-unit>
        <trans-unit id="dc354627de17c28e4a463874cb49fb69cf80c2d0" translate="yes" xml:space="preserve">
          <source>Worse still, if you've got a language like Chinese or Japanese that has hundreds or thousands of characters, then you really can't fit them into a mere 256, so they had to forget about ASCII altogether, and build their own systems using pairs of numbers to refer to one character.</source>
          <target state="translated">Хуже того,если у вас есть такой язык,как китайский или японский,который имеет сотни или тысячи иероглифов,то вы действительно не можете поместить их всего в 256,поэтому им пришлось совсем забыть про ASCII,и построить свои системы,используя пары чисел,чтобы ссылаться на один иероглиф.</target>
        </trans-unit>
        <trans-unit id="c5bfba3d49e2ee674235e330da88197da31a7c79" translate="yes" xml:space="preserve">
          <source>Would print '1', because &lt;code&gt;$foo&lt;/code&gt; holds a reference to the</source>
          <target state="translated">Напечатал бы '1', потому что &lt;code&gt;$foo&lt;/code&gt; содержит ссылку на</target>
        </trans-unit>
        <trans-unit id="193007f64c59b1fb13236d0c41a89912a80da741" translate="yes" xml:space="preserve">
          <source>Would produce an event structure that does &lt;b&gt;not&lt;/b&gt; have the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb47f1ed4bc872fb3335bdefcb281f4424715abe" translate="yes" xml:space="preserve">
          <source>Would run bin/foobar.PL like this:</source>
          <target state="translated">Будет работать bin/foobar.PL вот так:</target>
        </trans-unit>
        <trans-unit id="ead2351e2ba0bd4c816a4c94cc5152ad666ddb3d" translate="yes" xml:space="preserve">
          <source>Wrapper around CPAN.pm without using any XS module</source>
          <target state="translated">Обернитесь вокруг CPAN.pm без использования какого-либо модуля XS</target>
        </trans-unit>
        <trans-unit id="84ac379977c898d123ab3b5be8e7d1ebcc793262" translate="yes" xml:space="preserve">
          <source>Wrapper around Config.pm</source>
          <target state="translated">Обертка вокруг Config.pm</target>
        </trans-unit>
        <trans-unit id="5e2ec9565586c686048d53d457fe37527f6aad30" translate="yes" xml:space="preserve">
          <source>Wrapper class for calling subs at end of scope</source>
          <target state="translated">Класс обертки для вызова подгрупп в конце области видимости</target>
        </trans-unit>
        <trans-unit id="49754b3431fd16ae1cf0d382c55b7fa7149dd942" translate="yes" xml:space="preserve">
          <source>Wrapping all die calls in a handler routine can be useful to see how, and from where, they're being called, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; has more information:</source>
          <target state="translated">Обертывание всех вызовов die в подпрограмме обработчика может быть полезно, чтобы увидеть, как и откуда они вызываются, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; имеет дополнительную информацию:</target>
        </trans-unit>
        <trans-unit id="c2c61b8accf065e529ff818a1a9f4549b7fc54ab" translate="yes" xml:space="preserve">
          <source>Wrapping with parenthesis allows the wildcard parts of the Input File Glob to be referenced by the second parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;#1.tgz&lt;/code&gt; , the</source>
          <target state="translated">Заключение в круглые скобки позволяет ссылаться на части с подстановочными знаками во &lt;code&gt;globmap&lt;/code&gt; файле Glob вторым параметром в globmap , &lt;code&gt;#1.tgz&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="17f822b6bdf6bec5271484d235680d74774f32cb" translate="yes" xml:space="preserve">
          <source>Wrapping with parenthesis allows the wildcard parts of the Input File Glob to be referenced by the second parameter to &lt;code&gt;globmap&lt;/code&gt;, &lt;code&gt;#1.tgz&lt;/code&gt;, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f5b426a0effa25adf0da16850506b6dbd0cdcc" translate="yes" xml:space="preserve">
          <source>Wraps any CODE references found within the arguments by replacing each with the result of calling &lt;a href=&quot;#wrap_code_ref&quot;&gt;&quot;wrap_code_ref&quot;&lt;/a&gt; on the CODE reference. Any ARRAY or HASH references in the arguments are inspected recursively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee0be976deb11b8b1d2de7c10091a2cf26d9d3d" translate="yes" xml:space="preserve">
          <source>Wraps any CODE references found within the arguments by replacing each with the result of calling &lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt; on the CODE reference. Any ARRAY or HASH references in the arguments are inspected recursively.</source>
          <target state="translated">Оборачивает любые ссылки CODE, найденные в аргументах, заменяя каждую на результат вызова &lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt; для ссылки CODE. Любые ссылки на ARRAY или HASH в аргументах проверяются рекурсивно.</target>
        </trans-unit>
        <trans-unit id="c3415b34e4326194b5c5e94f65779568f9ab9142" translate="yes" xml:space="preserve">
          <source>Wraps up an op tree with some additional ops so that at runtime a dynamic scope will be created. The original ops run in the new dynamic scope, and then, provided that they exit normally, the scope will be unwound. The additional ops used to create and unwind the dynamic scope will normally be an &lt;code&gt;enter&lt;/code&gt; /&lt;code&gt;leave&lt;/code&gt; pair, but a &lt;code&gt;scope&lt;/code&gt; op may be used instead if the ops are simple enough to not need the full dynamic scope structure.</source>
          <target state="translated">Завершает дерево операций некоторыми дополнительными операциями, чтобы во время выполнения была создана динамическая область видимости. Исходные операции выполняются в новой динамической области, а затем, при условии, что они завершаются нормально, область будет развернута. Дополнительные опсы , используемые для создания и размотать динамический объем, как правило , быть &lt;code&gt;enter&lt;/code&gt; / &lt;code&gt;leave&lt;/code&gt; пара, но &lt;code&gt;scope&lt;/code&gt; оп может быть использована вместо этого , если опов достаточно просто , чтобы не нуждаться в полные структурах динамической области видимости.</target>
        </trans-unit>
        <trans-unit id="2c03a1841c6b03c290cd48f7ec63334ea2671fbe" translate="yes" xml:space="preserve">
          <source>Wraps up an op tree with some additional ops so that at runtime a dynamic scope will be created. The original ops run in the new dynamic scope, and then, provided that they exit normally, the scope will be unwound. The additional ops used to create and unwind the dynamic scope will normally be an &lt;code&gt;enter&lt;/code&gt;/&lt;code&gt;leave&lt;/code&gt; pair, but a &lt;code&gt;scope&lt;/code&gt; op may be used instead if the ops are simple enough to not need the full dynamic scope structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a48932789d199bbed709777e2d743ca2bafdc6c" translate="yes" xml:space="preserve">
          <source>Write</source>
          <target state="translated">Write</target>
        </trans-unit>
        <trans-unit id="665e91485da7b1f4da854eb4a64d72b175917c29" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes of data from &lt;code&gt;BUFFER&lt;/code&gt; to the server, also performing any &amp;lt;CRLF&amp;gt; translation necessary. &lt;code&gt;TIMEOUT&lt;/code&gt; is optional, if not given, the timeout value from the command connection will be used.</source>
          <target state="translated">Записать &lt;code&gt;SIZE&lt;/code&gt; байт данных из &lt;code&gt;BUFFER&lt;/code&gt; на сервер, а также выполнить любую необходимую трансляцию &amp;lt;CRLF&amp;gt;. &lt;code&gt;TIMEOUT&lt;/code&gt; является необязательным, если он не указан, будет использоваться значение тайм-аута из командного соединения.</target>
        </trans-unit>
        <trans-unit id="9e9970521c52eb1a81f415505a29f59eba7d4c0c" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes to the shared memory segment at &lt;code&gt;POS&lt;/code&gt; . Returns true if successful, or false if there is an error. See &lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;.</source>
          <target state="translated">Запишите &lt;code&gt;SIZE&lt;/code&gt; байт в сегмент разделяемой памяти в &lt;code&gt;POS&lt;/code&gt; . Возвращает истину в случае успеха или ложь в случае ошибки. См. &lt;a href=&quot;../functions/shmwrite&quot;&gt;Shmwrite&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e52c0034fc1cfc407469f1ff131f1cb98c7f427d" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes to the shared memory segment at &lt;code&gt;POS&lt;/code&gt;. Returns true if successful, or false if there is an error. See &lt;a href=&quot;shmwrite&quot;&gt;shmwrite&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d6106f35288022310ffee038cda3aae849b282" translate="yes" xml:space="preserve">
          <source>Write MYMETA information to MYMETA.json and MYMETA.yml.</source>
          <target state="translated">Напишите информацию о MYMETA в MYMETA.json и MYMETA.yml.</target>
        </trans-unit>
        <trans-unit id="a9b6c91570493bdee3be6eef5a6b183ad756cdab" translate="yes" xml:space="preserve">
          <source>Write RFC 1950 files/buffers</source>
          <target state="translated">Записывайте файлы/буферы RFC 1950 года</target>
        </trans-unit>
        <trans-unit id="0909abf68380a212e21e5479f6396ce54f63b785" translate="yes" xml:space="preserve">
          <source>Write RFC 1951 files/buffers</source>
          <target state="translated">Напишите файлы/буферы RFC 1951 года</target>
        </trans-unit>
        <trans-unit id="0a1ef998109ed3777e0f667818ad2c1c3ea0b70e" translate="yes" xml:space="preserve">
          <source>Write RFC 1952 files/buffers</source>
          <target state="translated">Записывать файлы/буферы RFC 1952 года</target>
        </trans-unit>
        <trans-unit id="e52a7d8ae8bb89850d8b0bad0931a61da15a6992" translate="yes" xml:space="preserve">
          <source>Write YAMLish data</source>
          <target state="translated">Записывать данные YAMLish</target>
        </trans-unit>
        <trans-unit id="77878a047db48550e0d5361bfb44d185b930e978" translate="yes" xml:space="preserve">
          <source>Write a formatter as a Pod::Simple subclass</source>
          <target state="translated">Напишите форматер как Pod::Простой подкласс.</target>
        </trans-unit>
        <trans-unit id="bc54db5c1b3d5ac212fb800fdd56f965140da3e5" translate="yes" xml:space="preserve">
          <source>Write access via git</source>
          <target state="translated">Доступ к записи через git</target>
        </trans-unit>
        <trans-unit id="935636e37a0f4339394c64f63b5cea6433c1f963" translate="yes" xml:space="preserve">
          <source>Write an entry, whose name is equivalent to the file name provided to disk. Optionally takes a second parameter, which is the full native path (including filename) the entry will be written to.</source>
          <target state="translated">Запишите запись,имя которой эквивалентно имени файла,предоставленного на диск.Опционально принимает второй параметр,который является полным родным путем (включая имя файла),в который будет записываться запись.</target>
        </trans-unit>
        <trans-unit id="21bcad44913246d2e6442e5351456a0465facb2b" translate="yes" xml:space="preserve">
          <source>Write an event to the console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e129f1755e34449f3a6e6df186f50990274c50" translate="yes" xml:space="preserve">
          <source>Write behind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9db66c000d241fa8edccdd62e10c6678d855f50" translate="yes" xml:space="preserve">
          <source>Write bytes to a file or file-like device. Returns a true value if the operation was successful. For failure, returns a false value and sets &lt;code&gt;fileLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt; for the reason for the failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5769fe16b9b0cad42af9406c72e837bd0c18c816" translate="yes" xml:space="preserve">
          <source>Write bzip2 files/buffers</source>
          <target state="translated">Запись bzip2 файлов/буферов</target>
        </trans-unit>
        <trans-unit id="33c705dea45d707aeb4260372b955bd490cdccc3" translate="yes" xml:space="preserve">
          <source>Write check compare operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bafb7482744edca206da4c0baa12b4a11269c914" translate="yes" xml:space="preserve">
          <source>Write documentation in POD</source>
          <target state="translated">Пишите документацию в POD</target>
        </trans-unit>
        <trans-unit id="01995de03181a3f8adb7e727e73e6dc5e4e106c7" translate="yes" xml:space="preserve">
          <source>Write files whose names are equivalent to any of the names in &lt;code&gt;@filenames&lt;/code&gt; to disk, creating subdirectories as necessary. This might not work too well under VMS. Under MacPerl, the file's modification time will be converted to the MacOS zero of time, and appropriate conversions will be done to the path. However, the length of each element of the path is not inspected to see whether it's longer than MacOS currently allows (32 characters).</source>
          <target state="translated">Записывать на диск файлы, имена которых эквивалентны любому из имен в &lt;code&gt;@filenames&lt;/code&gt; , при необходимости создавая подкаталоги. Это может не очень хорошо работать под VMS. В MacPerl время модификации файла будет преобразовано в нулевое время MacOS, и соответствующие преобразования будут выполнены в путь. Однако длина каждого элемента пути не проверяется, чтобы узнать, длиннее ли она, чем позволяет MacOS в настоящее время (32 символа).</target>
        </trans-unit>
        <trans-unit id="cbcd4ec744f6a0cc7a8100b555d7a1173e6952f5" translate="yes" xml:space="preserve">
          <source>Write linker options files for dynamic extension</source>
          <target state="translated">Запись линкерных опций файлов для динамического расширения</target>
        </trans-unit>
        <trans-unit id="a3530b843bc763ce23299f2f7a8c7169f29e11c4" translate="yes" xml:space="preserve">
          <source>Write simple routines to do simple things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19494af103ef52570f65fb0c4441c4f5f25a19b7" translate="yes" xml:space="preserve">
          <source>Write some bytes to the scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391b1a9608423cb9c4d16a7886b9e07fab1acb00" translate="yes" xml:space="preserve">
          <source>Write tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af9a89203723d4a9c54482e7a2f891829a872e2c" translate="yes" xml:space="preserve">
          <source>Write the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f112fa7fb0b15b487e01a318607d918ca868eea9" translate="yes" xml:space="preserve">
          <source>Write the C code for miniperlmain.c and perlmain.c</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5fd755a4779cecce293a2a1e919899f32cdf21" translate="yes" xml:space="preserve">
          <source>Write the C code for perlmain.c</source>
          <target state="translated">Напишите код на C для perlmain.c</target>
        </trans-unit>
        <trans-unit id="0a8eff4063a82696c6af1e9ea9cf555d97a3ea2c" translate="yes" xml:space="preserve">
          <source>Write the in-memory archive to disk. The first argument can either be the name of a file or a reference to an already open filehandle (a GLOB reference).</source>
          <target state="translated">Запишите архив in-memory на диск.Первым аргументом может быть либо имя файла,либо ссылка на уже открытую файловую оболочку (GLOB-ссылка).</target>
        </trans-unit>
        <trans-unit id="af8f82dc202f24f05f3598bed445a87ed08771b7" translate="yes" xml:space="preserve">
          <source>Write the state to a file.</source>
          <target state="translated">Запишите состояние в файл.</target>
        </trans-unit>
        <trans-unit id="03e89de5415aa73b6bf8d4ce2e95f915540a35da" translate="yes" xml:space="preserve">
          <source>Write the typemap to a file. Optionally takes a &lt;code&gt;file&lt;/code&gt; argument. If given, the typemap will be written to the specified file. If not, the typemap is written to the currently stored file name (see &lt;a href=&quot;#file&quot;&gt;&quot;file&quot;&lt;/a&gt; above, this defaults to the file it was read from if any).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ea3036e84ed65b742580afd08f2cf97f36ee5c9" translate="yes" xml:space="preserve">
          <source>Write to a file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">Напишите в файл. При этом используются файловые дескрипторы, например, полученные при вызове &lt;code&gt;POSIX::open&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ddba3f84caaf1f7da5ab41258196ba4aa666d93" translate="yes" xml:space="preserve">
          <source>Write to a file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff8491fc63b40787a6bc354a1c28b21cd65c0f1" translate="yes" xml:space="preserve">
          <source>Write to modules@perl.org explaining what you did to contact the current maintainer. The PAUSE admins will also try to reach the maintainer.</source>
          <target state="translated">Пишите по адресу modules@perl.org,объясняя,что вы сделали,чтобы связаться с текущим мэйнтейнером.Администраторы PAUSE также попытаются связаться с сопровождающим.</target>
        </trans-unit>
        <trans-unit id="ec3b4c2700310731999e0d7e25df0c587f5a195d" translate="yes" xml:space="preserve">
          <source>Write zip files/buffers</source>
          <target state="translated">Записывайте zip-файлы/буферы</target>
        </trans-unit>
        <trans-unit id="08d9173120127debf58115903083c7548d3871d3" translate="yes" xml:space="preserve">
          <source>Write-only access to the data in the file.</source>
          <target state="translated">Доступ только для записи к данным в файле.</target>
        </trans-unit>
        <trans-unit id="14518d4671890ab2fd2dc1aa9e641777a8f1afbc" translate="yes" xml:space="preserve">
          <source>WriteConstants ATTRIBUTE =&amp;gt; VALUE [, ...]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94dee2fafe1d10d5ce6db659eb0c0fcb3d5842be" translate="yes" xml:space="preserve">
          <source>WriteFile</source>
          <target state="translated">WriteFile</target>
        </trans-unit>
        <trans-unit id="8a1db595bd4c07aab5da69c69b2b0b595010f3b7" translate="yes" xml:space="preserve">
          <source>WriteMakefile() now does some basic sanity checks on its parameters to protect against typos and malformatted values. This means some things which happened to work in the past will now throw warnings and possibly produce internal errors.</source>
          <target state="translated">WriteMakefile()теперь делает некоторые базовые проверки на вменяемость своих параметров для защиты от опечаток и некорректных значений.Это означает,что некоторые вещи,которые раньше работали,теперь будут бросать предупреждения и,возможно,приводить к внутренним ошибкам.</target>
        </trans-unit>
        <trans-unit id="97fe0c70bb91d9c9a985fa7a8dd506d2e586dde0" translate="yes" xml:space="preserve">
          <source>WriteMakefileSnippet</source>
          <target state="translated">WriteMakefileSnippet</target>
        </trans-unit>
        <trans-unit id="6e814e2d111b3599c2bf1ca192478a3ffbfc4053" translate="yes" xml:space="preserve">
          <source>WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [, ...]</source>
          <target state="translated">WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [, ...]</target>
        </trans-unit>
        <trans-unit id="7bdbf771b888449a861406dd116d15dd91371055" translate="yes" xml:space="preserve">
          <source>Writes SIZE bytes from STRING to a memory segment at ADDR starting at position POS. If STRING is too long, only SIZE bytes are used; if STRING is too short, nulls are written to fill out SIZE bytes. Returns true if successful, or false if there is an error.</source>
          <target state="translated">Записывает байты РАЗМЕР от STRING в сегмент памяти на ADDR,начиная с позиции POS.Если STRING слишком длинный,используются только байты РАЗМЕРА;если STRING слишком короткий,записываются нули для заполнения байтов РАЗМЕРА.Возвращает true в случае успеха или false в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="5d0ca93d68b5dc214818ef186a1bc3e2b3d7c8cd" translate="yes" xml:space="preserve">
          <source>Writes a file of C code and a file of XS code which you should &lt;code&gt;#include&lt;/code&gt; and &lt;code&gt;INCLUDE&lt;/code&gt; in the C and XS sections respectively of your module's XS code. You probably want to do this in your &lt;code&gt;Makefile.PL&lt;/code&gt; , so that you can easily edit the list of constants without touching the rest of your module. The attributes supported are</source>
          <target state="translated">Записывает файл кода C и файл кода XS, которые вы должны &lt;code&gt;#include&lt;/code&gt; и &lt;code&gt;INCLUDE&lt;/code&gt; в разделах C и XS соответственно кода XS вашего модуля. Вероятно, вы захотите сделать это в своем &lt;code&gt;Makefile.PL&lt;/code&gt; , чтобы вы могли легко редактировать список констант, не касаясь остальной части вашего модуля. Поддерживаемые атрибуты:</target>
        </trans-unit>
        <trans-unit id="e0245702e3fa0201a8eb501ac9938357e48b7d01" translate="yes" xml:space="preserve">
          <source>Writes a file of C code and a file of XS code which you should &lt;code&gt;#include&lt;/code&gt; and &lt;code&gt;INCLUDE&lt;/code&gt; in the C and XS sections respectively of your module's XS code. You probably want to do this in your &lt;code&gt;Makefile.PL&lt;/code&gt;, so that you can easily edit the list of constants without touching the rest of your module. The attributes supported are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e7628595fe05e976f01b228c1371b889b4fb1c" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;a href=&quot;#select-FILEHANDLE&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; function) may be set explicitly by assigning the name of the format to the &lt;a href=&quot;perlvar#%24~&quot;&gt;&lt;code&gt;$~&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68caf753088df284b27998c0bc22c79c995c9f8a" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">Записывает отформатированную запись (возможно, многострочную) в указанный FILEHANDLE, используя формат, связанный с этим файлом. По умолчанию формат файла имеет то же имя, что и дескриптор файла, но формат для текущего выходного канала (см. Функцию &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; ) можно задать явно, присвоив имя формата переменной &lt;code&gt;$~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c8b534fc59790f52bbc323708c6a448e4336f1e" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">Записывает отформатированную запись (возможно, многострочную) в указанный FILEHANDLE, используя формат, связанный с этим файлом. По умолчанию формат файла имеет то же имя, что и дескриптор файла, но формат для текущего выходного канала (см. Функцию &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; ) можно задать явно, присвоив имя формата переменной &lt;code&gt;$~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e8961057173b914aa902d24e81d3c55d00dde52" translate="yes" xml:space="preserve">
          <source>Writes all files in and below the current directory to your</source>
          <target state="translated">Записывает все файлы в и под текущей директорией в вашу</target>
        </trans-unit>
        <trans-unit id="1ff3060cc065fe5dcf829a42d2a8d401fd64f6d8" translate="yes" xml:space="preserve">
          <source>Writes an empty FORCE: target.</source>
          <target state="translated">Пишет пустой FORCE:цель.</target>
        </trans-unit>
        <trans-unit id="f5369d43b2f75bf65f1c9b2bf55177161b67ef85" translate="yes" xml:space="preserve">
          <source>Writes are permitted, i.e. opened as &quot;w&quot; or &quot;r+&quot; or &quot;a&quot;, etc.</source>
          <target state="translated">Запись разрешена,т.е.открыта как &quot;w&quot; или &quot;r+&quot; или &quot;a&quot; и т.д.</target>
        </trans-unit>
        <trans-unit id="bc03658e3c61d9705d37afb50e35b60738df57d4" translate="yes" xml:space="preserve">
          <source>Writes the contents of &lt;code&gt;$buffer&lt;/code&gt; to the compressed file. Returns the number of bytes actually written, or 0 on error.</source>
          <target state="translated">Записывает содержимое &lt;code&gt;$buffer&lt;/code&gt; в сжатый файл. Возвращает количество фактически записанных байтов или 0 в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="3b30b2d9d9b94819a1a73fa66ad9fdb3aaf93cb5" translate="yes" xml:space="preserve">
          <source>Writes the file META.yml (YAML encoded meta-data) and META.json (JSON encoded meta-data) about the module in the distdir. The format follows Module::Build's as closely as possible.</source>
          <target state="translated">Записывает файл META.yml (мета-данные в кодировке YAML)и META.json (мета-данные в кодировке JSON)о модуле в дистрибутиве.Формат следует за Module::Build's настолько близко,насколько это возможно.</target>
        </trans-unit>
        <trans-unit id="759cd7af683913d2e067b4f6ffe525a9a1d4a391" translate="yes" xml:space="preserve">
          <source>Writes the file SIGNATURE with &quot;cpansign -s&quot;.</source>
          <target state="translated">Записывает файл SIGNATURE с надписью &quot;cpansign -s&quot;.</target>
        </trans-unit>
        <trans-unit id="284cf58439290385abdec38ca7c004471227b097" translate="yes" xml:space="preserve">
          <source>Writes the output of</source>
          <target state="translated">Пишет на выходе из</target>
        </trans-unit>
        <trans-unit id="7576a6f2b013b505dded5e0784047fb79ad928e8" translate="yes" xml:space="preserve">
          <source>Writes to the &lt;code&gt;.c&lt;/code&gt; output file certain preprocessor directives and function headers needed in all such files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdd8d478482d63bc406cd41436757960d17780fb" translate="yes" xml:space="preserve">
          <source>Writing Accessors</source>
          <target state="translated">Аксессуары для письма</target>
        </trans-unit>
        <trans-unit id="1986c44b3bdced950b196d1c43f6cf37a6963d63" translate="yes" xml:space="preserve">
          <source>Writing Constructors</source>
          <target state="translated">Писатели-конструкторы</target>
        </trans-unit>
        <trans-unit id="2e43f89f29a3e136e02e547cac033fa128355bb0" translate="yes" xml:space="preserve">
          <source>Writing Perl on an EBCDIC platform is really no different than writing on an &lt;a href=&quot;#ASCII&quot;&gt;&quot;ASCII&quot;&lt;/a&gt; one, but with different underlying numbers, as we'll see shortly. You'll have to know something about those &lt;a href=&quot;#ASCII&quot;&gt;&quot;ASCII&quot;&lt;/a&gt; platforms because the documentation is biased and will frequently use example numbers that don't apply to EBCDIC. There are also very few CPAN modules that are written for EBCDIC and which don't work on ASCII; instead the vast majority of CPAN modules are written for ASCII, and some may happen to work on EBCDIC, while a few have been designed to portably work on both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0e44a3a37a4109877068f7584a4c6e490675d8" translate="yes" xml:space="preserve">
          <source>Writing Perl on an EBCDIC platform is really no different than writing on an &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; one, but with different underlying numbers, as we'll see shortly. You'll have to know something about those &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; platforms because the documentation is biased and will frequently use example numbers that don't apply to EBCDIC. There are also very few CPAN modules that are written for EBCDIC and which don't work on ASCII; instead the vast majority of CPAN modules are written for ASCII, and some may happen to work on EBCDIC, while a few have been designed to portably work on both.</source>
          <target state="translated">Написание Perl на платформе EBCDIC в действительности ничем не отличается от написания на платформе &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; , но с другими базовыми числами, как мы вскоре увидим. Вам нужно будет кое-что знать об этих платформах &lt;a href=&quot;#ASCII&quot;&gt;ASCII,&lt;/a&gt; потому что документация предвзята и часто будет использовать номера примеров, которые не относятся к EBCDIC. Также очень мало модулей CPAN, написанных для EBCDIC и не работающих с ASCII; вместо этого подавляющее большинство модулей CPAN написано для ASCII, и некоторые из них могут работать на EBCDIC, в то время как некоторые были разработаны для переносимой работы на обоих.</target>
        </trans-unit>
        <trans-unit id="b3e7a0572dc689213dcccc6f0ad9b2cbd894a46a" translate="yes" xml:space="preserve">
          <source>Writing Plugins</source>
          <target state="translated">Плагины для письма</target>
        </trans-unit>
        <trans-unit id="b23e7b02c4f050eb7a5f668109f71a414a28c33d" translate="yes" xml:space="preserve">
          <source>Writing Your Own Debugger</source>
          <target state="translated">Написание собственного отладчика.</target>
        </trans-unit>
        <trans-unit id="12d7ef5d9c4d923fdecfc0a2ba03562ba21e7e82" translate="yes" xml:space="preserve">
          <source>Writing a Filter</source>
          <target state="translated">Написание фильтра</target>
        </trans-unit>
        <trans-unit id="7f135a17864ace6ae98bf7a3b9d9b4e20dd72358" translate="yes" xml:space="preserve">
          <source>Writing a module with MakeMaker</source>
          <target state="translated">Написание модуля с MakeMaker</target>
        </trans-unit>
        <trans-unit id="f103eaa4bfb0cd111ad63870dfe99daf1dbfeefb" translate="yes" xml:space="preserve">
          <source>Writing a source filter as a separate executable works fine, but a small performance penalty is incurred. For example, if you execute the small example above, a separate subprocess will be created to run the Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; command. Each use of the filter requires its own subprocess. If creating subprocesses is expensive on your system, you might want to consider one of the other options for creating source filters.</source>
          <target state="translated">Написание исходного фильтра как отдельного исполняемого файла работает нормально, но влечет за собой небольшое снижение производительности. Например, если вы выполните небольшой пример выше, будет создан отдельный подпроцесс для запуска команды Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; . Для каждого использования фильтра требуется собственный подпроцесс. Если создание подпроцессов в вашей системе обходится дорого, вы можете рассмотреть один из других вариантов создания фильтров источника.</target>
        </trans-unit>
        <trans-unit id="42340678aabb28dd8e04eb2e84c897c77707c165" translate="yes" xml:space="preserve">
          <source>Writing a source filter as a separate executable works fine, but a small performance penalty is incurred. For example, if you execute the small example above, a separate subprocess will be created to run the Unix &lt;code&gt;tr&lt;/code&gt; command. Each use of the filter requires its own subprocess. If creating subprocesses is expensive on your system, you might want to consider one of the other options for creating source filters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e224913e88be93885651c47ecb1638090afee7fe" translate="yes" xml:space="preserve">
          <source>Writing all these print statements rapidly gets tedious. Fortunately, there's &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt;. It has one function, &lt;code&gt;ok()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc88b791ccf860fd9df472625687a215e4594f7f" translate="yes" xml:space="preserve">
          <source>Writing backticks in your program sends a clear message to the readers of your code that you wanted to collect the output of the command. Why send a clear message that isn't true?</source>
          <target state="translated">Написание обратных ссылок в вашей программе посылает четкий сигнал читателям вашего кода о том,что вы хотели получить результат команды.Зачем посылать четкое сообщение,которое не является правдой?</target>
        </trans-unit>
        <trans-unit id="a44149bd1f420e38e67feec9febfbe47dcef5694" translate="yes" xml:space="preserve">
          <source>Writing good test scripts</source>
          <target state="translated">Написание хороших тестовых сценариев</target>
        </trans-unit>
        <trans-unit id="0d1216f3de5359a11d177bd450454690960a8410" translate="yes" xml:space="preserve">
          <source>Writing subroutines</source>
          <target state="translated">Подпрограммы написания</target>
        </trans-unit>
        <trans-unit id="a553ca3bc37b04388da0cff3bc379f04cee8df42" translate="yes" xml:space="preserve">
          <source>Writing subroutines is easy:</source>
          <target state="translated">Написать подпрограммы легко:</target>
        </trans-unit>
        <trans-unit id="c828d0e28e2f569743446e2de56ca66e456c09b7" translate="yes" xml:space="preserve">
          <source>Writing the patch</source>
          <target state="translated">Написание заплаты</target>
        </trans-unit>
        <trans-unit id="5c10b682e330dccc302170e80493f9eb65449a91" translate="yes" xml:space="preserve">
          <source>Writing the short option first is recommended because it's easier to read. The long option is long enough to draw the eye to it anyway and the short option can otherwise get lost in visual noise.</source>
          <target state="translated">Рекомендуется сначала написать короткий вариант,потому что он легче читается.Длинный вариант в любом случае достаточно длинный,чтобы привлечь к нему внимание,а короткий вариант в противном случае может потеряться в зрительном шуме.</target>
        </trans-unit>
        <trans-unit id="1b1d022be94ce5d1101d118c8c80cf3364019b48" translate="yes" xml:space="preserve">
          <source>Writing typemap Entries</source>
          <target state="translated">Написание печатной карты Записи</target>
        </trans-unit>
        <trans-unit id="1292edaa487b14cb74f82d4343628858075e0756" translate="yes" xml:space="preserve">
          <source>Wrong: the Storable engine creates an empty one for you. If you know Eiffel, you can view &lt;code&gt;STORABLE_thaw&lt;/code&gt; as an alternate creation routine.</source>
          <target state="translated">Неправильно: движок Storable создает для вас пустой. Если вы знаете Eiffel, вы можете рассматривать &lt;code&gt;STORABLE_thaw&lt;/code&gt; как альтернативную процедуру создания.</target>
        </trans-unit>
        <trans-unit id="efb99bcd657604ed5888480f20557abaea6afd06" translate="yes" xml:space="preserve">
          <source>Wx</source>
          <target state="translated">Wx</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="af3f0530ce3709877b0c716af9417386f334acd7" translate="yes" xml:space="preserve">
          <source>X [vars]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a98d9bf0f92217c5e8d8919ec41748402162fa" translate="yes" xml:space="preserve">
          <source>XCPT_CATCH</source>
          <target state="translated">XCPT_CATCH</target>
        </trans-unit>
        <trans-unit id="0bbce50dfafd43d2aea26e0a316ecb5bb2789444" translate="yes" xml:space="preserve">
          <source>XCPT_RETHROW</source>
          <target state="translated">XCPT_RETHROW</target>
        </trans-unit>
        <trans-unit id="1c8ec453fa062fcc4d8beb21dfeb7f00e0044e3e" translate="yes" xml:space="preserve">
          <source>XCPT_TRY_END</source>
          <target state="translated">XCPT_TRY_END</target>
        </trans-unit>
        <trans-unit id="62c03b6a034496de09dbf74c72c47fb4b194a801" translate="yes" xml:space="preserve">
          <source>XCPT_TRY_START</source>
          <target state="translated">XCPT_TRY_START</target>
        </trans-unit>
        <trans-unit id="42573a00146341106bb0f06ab931a0b8e20775e3" translate="yes" xml:space="preserve">
          <source>XEmacs</source>
          <target state="translated">XEmacs</target>
        </trans-unit>
        <trans-unit id="c0aa9ef764d832b80428d756a731a94251b0e3a1" translate="yes" xml:space="preserve">
          <source>XML</source>
          <target state="translated">XML</target>
        </trans-unit>
        <trans-unit id="494019465f27565c960f3085abca99be390bd01b" translate="yes" xml:space="preserve">
          <source>XML charref mode (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5fc108bfdd5d96d6f99a6eac89c9af874db7d8" translate="yes" xml:space="preserve">
          <source>XPG operability often implies the presence of an</source>
          <target state="translated">Эксплуатационная пригодность XPG часто подразумевает наличие</target>
        </trans-unit>
        <trans-unit id="0f082b9799dcb8475e7d6fcb04a5adfa774635d5" translate="yes" xml:space="preserve">
          <source>XPUSH args AND set RETVAL AND assign return value to array</source>
          <target state="translated">XPUSH аргументирует И устанавливает RETVAL И присваивает возвращаемое значение массиву</target>
        </trans-unit>
        <trans-unit id="6e96c8ba90434c3991abef6b482029bbb705d617" translate="yes" xml:space="preserve">
          <source>XPUSHi</source>
          <target state="translated">XPUSHi</target>
        </trans-unit>
        <trans-unit id="a45f993c8bc95467cd94eca181fdf46437f5427b" translate="yes" xml:space="preserve">
          <source>XPUSHmortal</source>
          <target state="translated">XPUSHmortal</target>
        </trans-unit>
        <trans-unit id="b231a036815021c5444d064b7fcc1c528ade03e8" translate="yes" xml:space="preserve">
          <source>XPUSHn</source>
          <target state="translated">XPUSHn</target>
        </trans-unit>
        <trans-unit id="f47cdabf2ef1edeef2bd1fb53b6f18747c332149" translate="yes" xml:space="preserve">
          <source>XPUSHp</source>
          <target state="translated">XPUSHp</target>
        </trans-unit>
        <trans-unit id="1dab76d5986d1df120c308434288452972f88fb7" translate="yes" xml:space="preserve">
          <source>XPUSHs</source>
          <target state="translated">XPUSHs</target>
        </trans-unit>
        <trans-unit id="f596fc77ff9e6f6918218a1843202b6b44412bbc" translate="yes" xml:space="preserve">
          <source>XPUSHu</source>
          <target state="translated">XPUSHu</target>
        </trans-unit>
        <trans-unit id="bdb1d0d2760db0ae33b02dff5258e945e708b990" translate="yes" xml:space="preserve">
          <source>XS</source>
          <target state="translated">XS</target>
        </trans-unit>
        <trans-unit id="92bd1887109d3a53eb97d00630c2016c2f9abe52" translate="yes" xml:space="preserve">
          <source>XS VERSION</source>
          <target state="translated">XS ВЕРСИЯ</target>
        </trans-unit>
        <trans-unit id="f150c9e4da4e74cdaf804a24288dd2d36c2aab56" translate="yes" xml:space="preserve">
          <source>XS code added by Greg Bacon &amp;lt;</source>
          <target state="translated">Код XS добавлен Грегом Бэконом &amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cf142c571c2183260c4664ac183845da5980944" translate="yes" xml:space="preserve">
          <source>XS code can usually be made to work with any platform, but dependent libraries, header files, etc., might not be readily available or portable, or the XS code itself might be platform-specific, just as Perl code might be. If the libraries and headers are portable, then it is normally reasonable to make sure the XS code is portable, too.</source>
          <target state="translated">Код XS обычно можно заставить работать с любой платформой,но зависимые библиотеки,заголовочные файлы и т.д.могут быть не всегда доступны или переносимы,либо сам код XS может быть специфичен для любой платформы,точно так же,как и Perl-код.Если библиотеки и заголовки переносятся,то обычно разумно удостовериться,что код XS тоже переносится.</target>
        </trans-unit>
        <trans-unit id="292d659c22a7eedddefa474cf1aa726bcee0908b" translate="yes" xml:space="preserve">
          <source>XS code for using native C functions borrowed from &lt;code&gt;&lt;a href=&quot;Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt;, written by Marcus Harnisch &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8ccd1927a425f4cd71fc5858f4ce61be503a94" translate="yes" xml:space="preserve">
          <source>XS code for using native C functions borrowed from &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt;, written by Marcus Harnisch &amp;lt;</source>
          <target state="translated">Код XS для использования собственных функций C, заимствованных из &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt; , написанный Маркусом Харнишем &amp;lt;</target>
        </trans-unit>
        <trans-unit id="fe30568ef2d4c300e100572dbcce63bef5e87790" translate="yes" xml:space="preserve">
          <source>XS code has full access to system calls including C library functions. It thus has the capability of interfering with things that the Perl core or other modules have set up, such as signal handlers or file handles. It could mess with the memory, or any number of harmful things. Don't.</source>
          <target state="translated">Код XS имеет полный доступ к системным вызовам,включая функции библиотеки C.Таким образом,он имеет возможность вмешиваться в то,что установлено ядром Perl или другими модулями,такими как обработчики сигналов или файловые дескрипторы.Он может вмешиваться в память или в любое количество вредных вещей.Не надо.</target>
        </trans-unit>
        <trans-unit id="33d48b61f9e9a038a7aea1ef00483763c58f6eff" translate="yes" xml:space="preserve">
          <source>XS code is probably better using &quot;typemap&quot; if it expects FILE * arguments. The standard typemap will be adjusted to comprehend any changes in this area.</source>
          <target state="translated">Код XS,вероятно,лучше использовать &quot;typemap&quot;,если он ожидает аргументы FILE *.Стандартная карта типов будет скорректирована для понимания любых изменений в этой области.</target>
        </trans-unit>
        <trans-unit id="89e8c193e223b649f3d44b4194d19ce56bb23e01" translate="yes" xml:space="preserve">
          <source>XS code is very sensitive to the module version number and will complain if the version number in your Perl module doesn't match. If you change your module's version # without rerunning Makefile.PL the old version number will remain in the Makefile, causing the XS code to be built with the wrong number.</source>
          <target state="translated">Код XS очень чувствителен к номеру версии модуля и будет жаловаться,если номер версии в вашем модуле Perl не совпадает.Если вы измените версию модуля#без повторного запуска Makefile.PL,старый номер версии останется в Makefile,в результате чего XS-код будет собран с неправильным номером.</target>
        </trans-unit>
        <trans-unit id="9966dea2f0bef9d06ac3bd55d265441a4061b99f" translate="yes" xml:space="preserve">
          <source>XS code or C-language libraries called from it that use the system &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt; function (except on Windows) likely will not work from a multi-threaded application without changes. See &lt;a href=&quot;perlxs#Locale-aware-XS-code&quot;&gt;&quot;Locale-aware XS code&quot; in perlxs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def563b19b3d7a04b960dc4d401ac89d52a4e717" translate="yes" xml:space="preserve">
          <source>XS is an interface description file format used to create an extension interface between Perl and C code (or a C library) which one wishes to use with Perl. The XS interface is combined with the library to create a new library which can then be either dynamically loaded or statically linked into perl. The XS interface description is written in the XS language and is the core component of the Perl extension interface.</source>
          <target state="translated">XS-это формат файла описания интерфейса,используемый для создания интерфейса расширения между Perl и C-кодом (или C-библиотекой),который желательно использовать с Perl.Интерфейс XS комбинируется с библиотекой для создания новой библиотеки,которая затем может быть либо динамически загружена,либо статически скомпонована с perl.Описание интерфейса XS написано на языке XS и является основным компонентом интерфейса расширения Perl.</target>
        </trans-unit>
        <trans-unit id="c1322757203b80e7b2662642555746c59f625860" translate="yes" xml:space="preserve">
          <source>XS modules for all categories but &lt;code&gt;LC_NUMERIC&lt;/code&gt; get the underlying locale, and hence any C library functions they call will use that underlying locale. For more discussion, see &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;&quot;CAVEATS&quot; in perlxs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6e0da0571ab8b6cd13332fb1b92e13ef69723c3" translate="yes" xml:space="preserve">
          <source>XS modules for all categories but &lt;code&gt;LC_NUMERIC&lt;/code&gt; get the underlying locale, and hence any C library functions they call will use that underlying locale. For more discussion, see &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;CAVEATS in perlxs&lt;/a&gt;.</source>
          <target state="translated">Модули XS для всех категорий, кроме &lt;code&gt;LC_NUMERIC&lt;/code&gt; , получают базовый языковой стандарт, и, следовательно, любые функции библиотеки C, которые они вызывают, будут использовать этот базовый языковой стандарт. Для получения дополнительной информации см. &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;ПРЕДОСТЕРЕЖЕНИЯ в perlxs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cde8f9f4aa7dc1d35b0c98fee87c3ff3dfbc220c" translate="yes" xml:space="preserve">
          <source>XS-type modules do require re-linking the perl binary, because part of an XS module is written in &quot;C&quot;, and has to be linked together with the perl binary to be executed. This is required because perl under DJGPP is built with the &quot;static link&quot; option, due to the lack of &quot;dynamic linking&quot; in the DJGPP environment.</source>
          <target state="translated">Модули типа XS требуют перекомпоновки двоичного файла perl,потому что часть модуля XS написана на &quot;C&quot;,и должна быть скомпонована с исполняемым двоичным файлом perl.Это необходимо,так как perl в DJGPP собирается с опцией &quot;статическое соединение&quot;,из-за отсутствия &quot;динамического соединения&quot; в среде DJGPP.</target>
        </trans-unit>
        <trans-unit id="ec2988beaa8676362d1ed3ab16467d9b855facea" translate="yes" xml:space="preserve">
          <source>XS::APItest</source>
          <target state="translated">XS::APItest</target>
        </trans-unit>
        <trans-unit id="f864391a1885990bb3986e5bb9cdfe1529118689" translate="yes" xml:space="preserve">
          <source>XS::APItest - Test the perl C API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77965b88f2916dfa7ea799a1ecde83c5bade894f" translate="yes" xml:space="preserve">
          <source>XS::Typemap</source>
          <target state="translated">XS::Typemap</target>
        </trans-unit>
        <trans-unit id="1e9618266eb67d10623f9d27874dc8f7655ade73" translate="yes" xml:space="preserve">
          <source>XS::Typemap - module to test the XS typemaps distributed with perl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb06f137479712fdf29157a9f339063d581a30d" translate="yes" xml:space="preserve">
          <source>XSBUILD</source>
          <target state="translated">XSBUILD</target>
        </trans-unit>
        <trans-unit id="69f57ba624b38c0aa8389aea0ffe9fd217df0165" translate="yes" xml:space="preserve">
          <source>XSLoader</source>
          <target state="translated">XSLoader</target>
        </trans-unit>
        <trans-unit id="afd8fa1c6f48c528375edb581b5cfae64284c5a7" translate="yes" xml:space="preserve">
          <source>XSLoader - Dynamically load C libraries into Perl code</source>
          <target state="translated">XSLoader-Динамически загружать библиотеки C в Perl-код</target>
        </trans-unit>
        <trans-unit id="beb5f03415996a22eb7162d79a1cf0e450db5ba8" translate="yes" xml:space="preserve">
          <source>XSMULTI</source>
          <target state="translated">XSMULTI</target>
        </trans-unit>
        <trans-unit id="0921a161e9b005cd558f520ad84c3711a9234802" translate="yes" xml:space="preserve">
          <source>XSOPT</source>
          <target state="translated">XSOPT</target>
        </trans-unit>
        <trans-unit id="92e8e6dd254dabeb8537af4197e956a328b3ea2d" translate="yes" xml:space="preserve">
          <source>XSPROTOARG</source>
          <target state="translated">XSPROTOARG</target>
        </trans-unit>
        <trans-unit id="870a57e9b71b2a4c7d8b5d7661446dadbdc3d78c" translate="yes" xml:space="preserve">
          <source>XSRETURN</source>
          <target state="translated">XSRETURN</target>
        </trans-unit>
        <trans-unit id="4412705ffd15db1cc81dd4e97115e4240eed7c02" translate="yes" xml:space="preserve">
          <source>XSRETURN_EMPTY</source>
          <target state="translated">XSRETURN_EMPTY</target>
        </trans-unit>
        <trans-unit id="7516ad5d6afe7eff2028827f9d3ce25b91d747e1" translate="yes" xml:space="preserve">
          <source>XSRETURN_IV</source>
          <target state="translated">XSRETURN_IV</target>
        </trans-unit>
        <trans-unit id="7e5a22d1a7883f884227641cdf52bde57c7c0cd5" translate="yes" xml:space="preserve">
          <source>XSRETURN_NO</source>
          <target state="translated">XSRETURN_NO</target>
        </trans-unit>
        <trans-unit id="a72df091bba7b8d6d0f9b76040485b4a1059b320" translate="yes" xml:space="preserve">
          <source>XSRETURN_NV</source>
          <target state="translated">XSRETURN_NV</target>
        </trans-unit>
        <trans-unit id="c9bd2b450336e9a3992bddc7c7b4a884bb908613" translate="yes" xml:space="preserve">
          <source>XSRETURN_PV</source>
          <target state="translated">XSRETURN_PV</target>
        </trans-unit>
        <trans-unit id="31bb0caf5acf67711f8b48a53013782fa24d0e5c" translate="yes" xml:space="preserve">
          <source>XSRETURN_UNDEF</source>
          <target state="translated">XSRETURN_UNDEF</target>
        </trans-unit>
        <trans-unit id="75dd44c03d403bbc60a246b9a6263dd12586d022" translate="yes" xml:space="preserve">
          <source>XSRETURN_UV</source>
          <target state="translated">XSRETURN_UV</target>
        </trans-unit>
        <trans-unit id="6940b196422b14c137e4603100533585c01d3873" translate="yes" xml:space="preserve">
          <source>XSRETURN_YES</source>
          <target state="translated">XSRETURN_YES</target>
        </trans-unit>
        <trans-unit id="0071e55f0de2d741b86408cbdd221e6b71588408" translate="yes" xml:space="preserve">
          <source>XST_mIV</source>
          <target state="translated">XST_mIV</target>
        </trans-unit>
        <trans-unit id="8746b00346bb95fd6d7203847b95eace0e227af2" translate="yes" xml:space="preserve">
          <source>XST_mNO</source>
          <target state="translated">XST_mNO</target>
        </trans-unit>
        <trans-unit id="18b7e60b2312b4cdf84185a38f3105ba024df44d" translate="yes" xml:space="preserve">
          <source>XST_mNV</source>
          <target state="translated">XST_mNV</target>
        </trans-unit>
        <trans-unit id="f5704ef0a40693c861b7a0f79e6acb2f0a79e526" translate="yes" xml:space="preserve">
          <source>XST_mPV</source>
          <target state="translated">XST_mPV</target>
        </trans-unit>
        <trans-unit id="b30947135a6d0dc9cd094f1f5c672b0d8df27a87" translate="yes" xml:space="preserve">
          <source>XST_mUNDEF</source>
          <target state="translated">XST_mUNDEF</target>
        </trans-unit>
        <trans-unit id="c4c00149e31a863f36a4eccec4b30bed628c9d7b" translate="yes" xml:space="preserve">
          <source>XST_mUV</source>
          <target state="translated">XST_mUV</target>
        </trans-unit>
        <trans-unit id="850783c2d3d2b8cee3448cdaf150b58812cdd570" translate="yes" xml:space="preserve">
          <source>XST_mYES</source>
          <target state="translated">XST_mYES</target>
        </trans-unit>
        <trans-unit id="ddfc93741501a0abefa88da99d97e36deaed4cbc" translate="yes" xml:space="preserve">
          <source>XSUB</source>
          <target state="translated">XSUB</target>
        </trans-unit>
        <trans-unit id="4579138c9695c3de09b5142af11ef81d8446e749" translate="yes" xml:space="preserve">
          <source>XSUB.h</source>
          <target state="translated">XSUB.h</target>
        </trans-unit>
        <trans-unit id="df024d96e0c6354fb4e32675dd41d60e15bc6f98" translate="yes" xml:space="preserve">
          <source>XSUBANY</source>
          <target state="translated">XSUBANY</target>
        </trans-unit>
        <trans-unit id="4df5cfe3d83127b158a7d5a161b5570785b675ad" translate="yes" xml:space="preserve">
          <source>XSUBs and the Argument Stack</source>
          <target state="translated">XSUB и стопка аргументов</target>
        </trans-unit>
        <trans-unit id="638efca4cf9c7b80e03f195d87e0ea4d39d29c81" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to avoid automatic conversion of Perl function arguments to C function arguments. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details. Some people prefer manual conversion by inspecting &lt;code&gt;ST(i)&lt;/code&gt; even in the cases when automatic conversion will do, arguing that this makes the logic of an XSUB call clearer. Compare with &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;&quot;Getting the fat out of XSUBs&quot;&lt;/a&gt; for a similar tradeoff of a complete separation of &quot;Perl glue&quot; and &quot;workhorse&quot; parts of an XSUB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5999991ea7d60b38c8ca1802a3aa2e3198b825" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to avoid automatic conversion of Perl function arguments to C function arguments. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details. Some people prefer manual conversion by inspecting &lt;code&gt;ST(i)&lt;/code&gt; even in the cases when automatic conversion will do, arguing that this makes the logic of an XSUB call clearer. Compare with &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt; for a similar tradeoff of a complete separation of &quot;Perl glue&quot; and &quot;workhorse&quot; parts of an XSUB.</source>
          <target state="translated">XSUB также могут избегать автоматического преобразования аргументов функции Perl в аргументы функции C. См. Подробности в &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; . Некоторые люди предпочитают ручное преобразование путем проверки &lt;code&gt;ST(i)&lt;/code&gt; даже в тех случаях, когда подойдет автоматическое преобразование, утверждая, что это упрощает логику вызова XSUB. Сравните с &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;&amp;laquo;Полностью избавиться от XSUB&amp;raquo;&lt;/a&gt; для аналогичного компромисса с полным разделением &amp;laquo;клея Perl&amp;raquo; и &amp;laquo;рабочей лошадки&amp;raquo; XSUB.</target>
        </trans-unit>
        <trans-unit id="54080bcfea2adf5c913b064ead22f355c2ce0033" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to return lists, not just scalars. This must be done by manipulating stack values ST(0), ST(1), etc, in a subtly different way. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details.</source>
          <target state="translated">XSUB также могут возвращать списки, а не только скаляры. Это необходимо сделать, немного изменив значения стека ST (0), ST (1) и т. Д. См. Подробности в &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88b3157d6a7563b7eeae312db4f170271aab7d57" translate="yes" xml:space="preserve">
          <source>XSUBs can have variable-length parameter lists by specifying an ellipsis &lt;code&gt;(...)&lt;/code&gt; in the parameter list. This use of the ellipsis is similar to that found in ANSI C. The programmer is able to determine the number of arguments passed to the XSUB by examining the &lt;code&gt;items&lt;/code&gt; variable which the &lt;b&gt;xsubpp&lt;/b&gt; compiler supplies for all XSUBs. By using this mechanism one can create an XSUB which accepts a list of parameters of unknown length.</source>
          <target state="translated">XSUB могут иметь списки параметров переменной длины, если в списке параметров указать многоточие &lt;code&gt;(...)&lt;/code&gt; . Это использование многоточия аналогично тому, что используется в ANSI C. Программист может определить количество аргументов, переданных в XSUB, исследуя переменную &lt;code&gt;items&lt;/code&gt; , которую компилятор &lt;b&gt;xsubpp&lt;/b&gt; предоставляет для всех XSUB. Используя этот механизм, можно создать XSUB, который принимает список параметров неизвестной длины.</target>
        </trans-unit>
        <trans-unit id="3be2c3082f6ee5ac4e24cba3fef031d150316f00" translate="yes" xml:space="preserve">
          <source>XSUBs do not have a &lt;code&gt;CvPADLIST&lt;/code&gt;. &lt;code&gt;dXSTARG&lt;/code&gt; fetches values from &lt;code&gt;PL_curpad&lt;/code&gt;, but that is really the callers pad (a slot of which is allocated by every entersub). Do not get or set &lt;code&gt;CvPADLIST&lt;/code&gt; if a CV is an XSUB (as determined by &lt;code&gt;CvISXSUB()&lt;/code&gt;), &lt;code&gt;CvPADLIST&lt;/code&gt; slot is reused for a different internal purpose in XSUBs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2e0ddc3d17d87460a2a8a983be1c97c83b73d1" translate="yes" xml:space="preserve">
          <source>XSUBs do not have a CvPADLIST. dXSTARG fetches values from PL_curpad, but that is really the callers pad (a slot of which is allocated by every entersub). Do not get or set CvPADLIST if a CV is an XSUB (as determined by &lt;code&gt;CvISXSUB()&lt;/code&gt; ), CvPADLIST slot is reused for a different internal purpose in XSUBs.</source>
          <target state="translated">XSUB не имеют CvPADLIST. dXSTARG извлекает значения из PL_curpad, но на самом деле это панель вызывающих абонентов (слот которой выделяется каждым входом). Не получать и не устанавливать CvPADLIST, если CV является XSUB (как определено &lt;code&gt;CvISXSUB()&lt;/code&gt; ), слот CvPADLIST повторно используется для другой внутренней цели в XSUB.</target>
        </trans-unit>
        <trans-unit id="6daf3f5f97a3cf191b47d0b650ffb497515d3ee1" translate="yes" xml:space="preserve">
          <source>XSUBs refer to their stack arguments with the macro &lt;b&gt;ST(x)&lt;/b&gt;, where</source>
          <target state="translated">XSUB ссылаются на свои аргументы стека с помощью макроса &lt;b&gt;ST (x)&lt;/b&gt; , где</target>
        </trans-unit>
        <trans-unit id="b948898c3205f86da22df7bb2aa8e0fc31385f66" translate="yes" xml:space="preserve">
          <source>XS_APIVERSION_BOOTCHECK</source>
          <target state="translated">XS_APIVERSION_BOOTCHECK</target>
        </trans-unit>
        <trans-unit id="45e92c706e14fc42e8a65549cfb504f51b80720e" translate="yes" xml:space="preserve">
          <source>XS_DEFINE_VERSION: -D line to set the xs version when compiling.</source>
          <target state="translated">XS_DEFINE_VERSION:-D строка для установки версии xs при компиляции.</target>
        </trans-unit>
        <trans-unit id="c079612ab9bf6b165676a675aeaa6f541c733506" translate="yes" xml:space="preserve">
          <source>XS_EXTERNAL</source>
          <target state="translated">XS_EXTERNAL</target>
        </trans-unit>
        <trans-unit id="b36c9e63716f92004705d5a5880b339795a114b1" translate="yes" xml:space="preserve">
          <source>XS_FH</source>
          <target state="translated">XS_FH</target>
        </trans-unit>
        <trans-unit id="0b91e170805a05f3fc3b4f1fe3e1c801a51a5cd9" translate="yes" xml:space="preserve">
          <source>XS_FILE</source>
          <target state="translated">XS_FILE</target>
        </trans-unit>
        <trans-unit id="5a72d7eb1d508bb628564c702b5adf9c962f07c6" translate="yes" xml:space="preserve">
          <source>XS_INTERNAL</source>
          <target state="translated">XS_INTERNAL</target>
        </trans-unit>
        <trans-unit id="c30e58ff83929eb55292bc3f56bfb117c5d6b82f" translate="yes" xml:space="preserve">
          <source>XS_SUBNAME</source>
          <target state="translated">XS_SUBNAME</target>
        </trans-unit>
        <trans-unit id="c3c54470969e9570024cbdc019515c6664650a72" translate="yes" xml:space="preserve">
          <source>XS_VERSION</source>
          <target state="translated">XS_VERSION</target>
        </trans-unit>
        <trans-unit id="f6c7bf9f42bb6c2a25e194ec60219f0a8150edce" translate="yes" xml:space="preserve">
          <source>XS_VERSION: version in your .xs file. Defaults to $(VERSION)</source>
          <target state="translated">XS_VERSION:версия в вашем файле .xs.По умолчанию $(VERSION).</target>
        </trans-unit>
        <trans-unit id="849ccfe7e642de7c6c2afec3b38bc17a103cbe71" translate="yes" xml:space="preserve">
          <source>XS_VERSION_BOOTCHECK</source>
          <target state="translated">XS_VERSION_BOOTCHECK</target>
        </trans-unit>
        <trans-unit id="53fccca1190b204bd667ec9d6791fd3b9d14df6c" translate="yes" xml:space="preserve">
          <source>XS_VERSION_MACRO: which macro represents the XS version.</source>
          <target state="translated">XS_VERSION_MACRO:какой макрос представляет версию XS.</target>
        </trans-unit>
        <trans-unit id="c3b618e9ce8bc3b3691008b5df681815a883cb69" translate="yes" xml:space="preserve">
          <source>XS_constant PACKAGE, TYPES, XS_SUBNAME, C_SUBNAME</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20026dc165c030fe3a5d9609a6e61ab26210cbc1" translate="yes" xml:space="preserve">
          <source>XX</source>
          <target state="translated">XX</target>
        </trans-unit>
        <trans-unit id="a9674b19f8c56f785c91a555d0a144522bb318e6" translate="yes" xml:space="preserve">
          <source>XXX</source>
          <target state="translated">XXX</target>
        </trans-unit>
        <trans-unit id="efc0ac66700effcf3b5c6d5cfb0d3ed1e5da5cc1" translate="yes" xml:space="preserve">
          <source>XXX DAPM it would make more sense to make the arg a PADOFFSET void SAVEPADSV(PADOFFSET po)</source>
          <target state="translated">XXX DAPM было бы более разумно сделать аргумент PADOFFSET пустым SAVEPADSV(PADOFFSET po)</target>
        </trans-unit>
        <trans-unit id="0a8c3822391bb958edc27b75e5a6c90f50363bce" translate="yes" xml:space="preserve">
          <source>XXX.</source>
          <target state="translated">XXX.</target>
        </trans-unit>
        <trans-unit id="759d5f762181a933d7c0ff7fd8096838ff6b5ec3" translate="yes" xml:space="preserve">
          <source>XXX: Needs more docs.</source>
          <target state="translated">ХХХ:Нужно больше докторов.</target>
        </trans-unit>
        <trans-unit id="e3a8809017dd76bd26557a5b923ab2ae16c0cdb3" translate="yes" xml:space="preserve">
          <source>XXXX</source>
          <target state="translated">XXXX</target>
        </trans-unit>
        <trans-unit id="034f1965ccdbdf9e642feeb9858da5096b6d1a9a" translate="yes" xml:space="preserve">
          <source>XY</source>
          <target state="translated">XY</target>
        </trans-unit>
        <trans-unit id="1ed31ab8e3d4874b1d94827212eca5617d49d812" translate="yes" xml:space="preserve">
          <source>XopDISABLE</source>
          <target state="translated">XopDISABLE</target>
        </trans-unit>
        <trans-unit id="fdee56cbf2dd3729d372ee9ddd71eeb3c584e3a0" translate="yes" xml:space="preserve">
          <source>XopENABLE</source>
          <target state="translated">XopENABLE</target>
        </trans-unit>
        <trans-unit id="d452a85c41b2e0aa7a38834ff3a3b101c7d4ac6f" translate="yes" xml:space="preserve">
          <source>XopENTRY</source>
          <target state="translated">XopENTRY</target>
        </trans-unit>
        <trans-unit id="12a6abfec4959cd21c68fcfdd5a310b6940a1038" translate="yes" xml:space="preserve">
          <source>XopENTRYCUSTOM</source>
          <target state="translated">XopENTRYCUSTOM</target>
        </trans-unit>
        <trans-unit id="f6bc06eec4d13090054285af25a6e8fdfa5cb801" translate="yes" xml:space="preserve">
          <source>XopENTRY_set</source>
          <target state="translated">XopENTRY_set</target>
        </trans-unit>
        <trans-unit id="b37b621154ed9fa599925b4a3aa2dcee68ee7486" translate="yes" xml:space="preserve">
          <source>XopFLAGS</source>
          <target state="translated">XopFLAGS</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="ffbcb202b09db426bae56cf2ffb88f18594f2258" translate="yes" xml:space="preserve">
          <source>YAML</source>
          <target state="translated">YAML</target>
        </trans-unit>
        <trans-unit id="50bc04e009ed4a61bc2c2e4c00258238b3cec732" translate="yes" xml:space="preserve">
          <source>YAML result token.</source>
          <target state="translated">жетон результата ЯМЛ.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
