<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="dbd5594c7134763067cde3b54f3bfaeaa68b552a" translate="yes" xml:space="preserve">
          <source>If the child process follows the convention of C programs compiled with the _POSIX_EXIT macro set, the status value will contain the actual value of 0 to 255 returned by that program on a normal exit.</source>
          <target state="translated">Если дочерний процесс следует условию программ на языке С,скомпилированных с набором макросов _POSIX_EXIT,то значение статуса будет содержать фактическое значение от 0 до 255,возвращаемое этой программой при нормальном выходе.</target>
        </trans-unit>
        <trans-unit id="ba30380d4c3fff1189949a912a23e2f3c323237f" translate="yes" xml:space="preserve">
          <source>If the class shown in &lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;&lt;/a&gt; were placed in the MyClass.pm module, then the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a2359effbd1215640880aada1292b5fa0877c9a" translate="yes" xml:space="preserve">
          <source>If the class shown in &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; were placed in the MyClass.pm module, then the following code:</source>
          <target state="translated">Если класс, показанный в &lt;a href=&quot;#SYNOPSIS&quot;&gt;СИНОПСИСЕ,&lt;/a&gt; был помещен в модуль MyClass.pm, то следующий код:</target>
        </trans-unit>
        <trans-unit id="2f9ec72ad3a19d5c4b84af5eba887a50b7eef9b5" translate="yes" xml:space="preserve">
          <source>If the client asks for &quot;fr&quot;, that will look up successfully in %greetings, to the value &quot;Bonjour&quot;. And if the client asks for &quot;i-mingo&quot;, that will look up successfully in %greetings, to the value &quot;Hau'&quot;.</source>
          <target state="translated">Если клиент попросит &quot;fr&quot;,что будет успешно искать в %greetings,к значению &quot;Bonjour&quot;.А если клиент попросит &quot;i-mingo&quot;,что будет успешно искать в %greetings,к значению &quot;Hau'&quot;.</target>
        </trans-unit>
        <trans-unit id="1e012fb4a0052bc107066983e24cd424b0582af0" translate="yes" xml:space="preserve">
          <source>If the code point is unassigned, this returns the block it would belong to if it were assigned. (If the Unicode version being used is so early as to not have blocks, all code points are considered to be in &lt;code&gt;No_Block&lt;/code&gt; .)</source>
          <target state="translated">Если кодовая точка не назначена, возвращается блок, которому она принадлежала бы, если бы была назначена. (Если используемая версия Unicode настолько ранняя, что не имеет блоков, все кодовые точки считаются находящимися в &lt;code&gt;No_Block&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="318dcf1cce3429cb8c9fd8f8fb72e309dc55b11b" translate="yes" xml:space="preserve">
          <source>If the code point is unassigned, this returns the block it would belong to if it were assigned. (If the Unicode version being used is so early as to not have blocks, all code points are considered to be in &lt;code&gt;No_Block&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46675f67eada0291c64ffce7fc8980b9b58c2b77" translate="yes" xml:space="preserve">
          <source>If the code to be executed doesn't vary, you may use the eval-BLOCK form to trap run-time errors without incurring the penalty of recompiling each time. The error, if any, is still returned in &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced2db748e9e7079888c75fca8f7175caebcea61" translate="yes" xml:space="preserve">
          <source>If the code to be executed doesn't vary, you may use the eval-BLOCK form to trap run-time errors without incurring the penalty of recompiling each time. The error, if any, is still returned in &lt;code&gt;$@&lt;/code&gt; . Examples:</source>
          <target state="translated">Если код, который нужно выполнить, не меняется, вы можете использовать форму eval-BLOCK для перехвата ошибок времени выполнения, не подвергаясь каждый раз повторной компиляции. Ошибка, если таковая имеется, по-прежнему возвращается в &lt;code&gt;$@&lt;/code&gt; . Примеры:</target>
        </trans-unit>
        <trans-unit id="2bd498c74c7384947431c9fbfc4c96437164ae53" translate="yes" xml:space="preserve">
          <source>If the code to execute had been passed in as a string, &lt;code&gt;'$line = &amp;lt;STDIN&amp;gt;'&lt;/code&gt; , there would have been no way for the hypothetical timeout() function to access the lexical variable $line back in its caller's scope.</source>
          <target state="translated">Если бы код для выполнения был передан в виде строки &lt;code&gt;'$line = &amp;lt;STDIN&amp;gt;'&lt;/code&gt; , у гипотетической функции timeout () не было бы возможности получить доступ к лексической переменной $ line обратно в область действия вызывающего объекта.</target>
        </trans-unit>
        <trans-unit id="c1827c22ec543702fffafe0a0fe1de8c30879660" translate="yes" xml:space="preserve">
          <source>If the code to execute had been passed in as a string, &lt;code&gt;'$line = &amp;lt;STDIN&amp;gt;'&lt;/code&gt;, there would have been no way for the hypothetical timeout() function to access the lexical variable $line back in its caller's scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68179989040030e944377fc50f5fa69dee822170" translate="yes" xml:space="preserve">
          <source>If the command works, you can move to the next step, but beware: &lt;b&gt;You'll have to remove the directory from the device once you are done! Unlike &lt;i&gt;/mnt/asec&lt;/i&gt;, &lt;i&gt;/data/local/tmp&lt;/i&gt; may not get automatically garbage collected once you shut off the phone&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c340c9bb0fb834396be0e28dd3dddd81bf15437" translate="yes" xml:space="preserve">
          <source>If the condition expression of a &lt;code&gt;while&lt;/code&gt; statement is based on any of a group of iterative expression types then it gets some magic treatment. The affected iterative expression types are &lt;a href=&quot;perlfunc#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt;&lt;/a&gt; input operator, &lt;a href=&quot;perlfunc#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#glob-EXPR&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&lt;code&gt;&amp;lt;PATTERN&amp;gt;&lt;/code&gt;&lt;/a&gt; globbing operator, and &lt;a href=&quot;perlfunc#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt;. If the condition expression is one of these expression types, then the value yielded by the iterative operator will be implicitly assigned to &lt;code&gt;$_&lt;/code&gt;. If the condition expression is one of these expression types or an explicit assignment of one of them to a scalar, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5dcda0eb63d695c2273d9f58a5b27fc7e844c60" translate="yes" xml:space="preserve">
          <source>If the configurations variable &lt;code&gt;build_dir_reuse&lt;/code&gt; is set to a true value, then CPAN.pm reads the collected YAML files. If the stored signature matches the currently running perl, the stored state is loaded into memory such that persistence between sessions is effectively established.</source>
          <target state="translated">Если для переменной конфигурации &lt;code&gt;build_dir_reuse&lt;/code&gt; задано истинное значение, то CPAN.pm читает собранные файлы YAML. Если сохраненная подпись совпадает с текущим запущенным perl, сохраненное состояние загружается в память, так что сохраняется постоянство между сеансами.</target>
        </trans-unit>
        <trans-unit id="a91d44bc473043f072a494275450d9c876250d17" translate="yes" xml:space="preserve">
          <source>If the connection is via a firewall then the &lt;code&gt;authorize&lt;/code&gt; method will be called with no arguments.</source>
          <target state="translated">Если соединение осуществляется через брандмауэр, то метод &lt;code&gt;authorize&lt;/code&gt; будет вызываться без аргументов.</target>
        </trans-unit>
        <trans-unit id="880ff18ec98ddcf514d383275dae13c355bbcadf" translate="yes" xml:space="preserve">
          <source>If the construct is a here-doc, the ending delimiter is a line that has a terminating string as the content. Therefore &lt;code&gt;&amp;lt;&amp;lt;EOF&lt;/code&gt; is terminated by &lt;code&gt;EOF&lt;/code&gt; immediately followed by &lt;code&gt;&quot;\n&quot;&lt;/code&gt; and starting from the first column of the terminating line. When searching for the terminating line of a here-doc, nothing is skipped. In other words, lines after the here-doc syntax are compared with the terminating string line by line.</source>
          <target state="translated">Если конструкция представляет собой документ-документ, конечный разделитель - это строка, содержащая завершающую строку в качестве содержимого. Поэтому &lt;code&gt;&amp;lt;&amp;lt;EOF&lt;/code&gt; завершается символом &lt;code&gt;EOF&lt;/code&gt; , за которым сразу следует &lt;code&gt;&quot;\n&quot;&lt;/code&gt; начиная с первого столбца завершающей строки. При поиске завершающей строки документа здесь ничего не пропускается. Другими словами, строки после синтаксиса here-doc сравниваются с завершающей строкой построчно.</target>
        </trans-unit>
        <trans-unit id="e1f5405c8fb7cef756ea27523f26d6d391697258" translate="yes" xml:space="preserve">
          <source>If the constructor fails undef will be returned and an error message will be in $@</source>
          <target state="translated">Если конструктор откажет undef,то будет возвращено сообщение об ошибке в $@@</target>
        </trans-unit>
        <trans-unit id="fd68f60bc1a46c89ed70417ef132417733df0aab" translate="yes" xml:space="preserve">
          <source>If the constructor fails, it will set &lt;code&gt;$@&lt;/code&gt; to an appropriate error message; this may be from &lt;code&gt;$!&lt;/code&gt; or it may be some other string; not every failure necessarily has an associated &lt;code&gt;errno&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03d6a855f28c1f0fcb373d36da3e2b752b1b618" translate="yes" xml:space="preserve">
          <source>If the constructor is only passed a single argument, it is assumed to be a &lt;code&gt;Peer&lt;/code&gt; specification.</source>
          <target state="translated">Если конструктору передается только один аргумент, предполагается, что это спецификация &lt;code&gt;Peer&lt;/code&gt; узла.</target>
        </trans-unit>
        <trans-unit id="59d6c514d80580b526f459658680b5bcb3039600" translate="yes" xml:space="preserve">
          <source>If the constructor is only passed a single argument, it is assumed to be a &lt;code&gt;PeerAddr&lt;/code&gt; specification.</source>
          <target state="translated">Если конструктору передается только один аргумент, предполагается, что это спецификация &lt;code&gt;PeerAddr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="253c66bbe032a626b97c6e706376db98b636ddae" translate="yes" xml:space="preserve">
          <source>If the constructor is passed a defined but false value for the &lt;code&gt;Blocking&lt;/code&gt; argument then the socket is put into non-blocking mode. When in non-blocking mode, the socket will not be set up by the time the constructor returns, because the underlying &lt;code&gt;connect(2)&lt;/code&gt; syscall would otherwise have to block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c1d4da7e238174b01de906293d93c6822b7ffed" translate="yes" xml:space="preserve">
          <source>If the count doesn't impress your friends, then the code might. :-)</source>
          <target state="translated">Если граф не впечатлит твоих друзей,то код может.:-)</target>
        </trans-unit>
        <trans-unit id="e2812a31f32729d7d8acbab2252b618f1597089e" translate="yes" xml:space="preserve">
          <source>If the current directory is not writable, file is created using modified &lt;code&gt;tmpnam&lt;/code&gt; , so there may be a race condition.</source>
          <target state="translated">Если текущий каталог недоступен для записи, файл создается с использованием модифицированного &lt;code&gt;tmpnam&lt;/code&gt; , поэтому может быть состояние гонки.</target>
        </trans-unit>
        <trans-unit id="58341845d1b46d579ba494b307ff64132940c287" translate="yes" xml:space="preserve">
          <source>If the current directory is not writable, file is created using modified &lt;code&gt;tmpnam&lt;/code&gt;, so there may be a race condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494e23aba89eecf5e12f5237686e230eddf4cf1f" translate="yes" xml:space="preserve">
          <source>If the current tests are considered &quot;TODO&quot; it will return the reason, if any. This reason can come from a &lt;code&gt;$TODO&lt;/code&gt; variable or the last call to &lt;code&gt;todo_start()&lt;/code&gt; .</source>
          <target state="translated">Если текущие тесты считаются &amp;laquo;TODO&amp;raquo;, он вернет причину, если таковая имеется. Причина может исходить из переменной &lt;code&gt;$TODO&lt;/code&gt; или последнего вызова &lt;code&gt;todo_start()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33c537a42d68a9fab37456220c53df0c1404714b" translate="yes" xml:space="preserve">
          <source>If the current tests are considered &quot;TODO&quot; it will return the reason, if any. This reason can come from a &lt;code&gt;$TODO&lt;/code&gt; variable or the last call to &lt;code&gt;todo_start()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07a75af0e09b32f52321893f3368ffdcf3680ce" translate="yes" xml:space="preserve">
          <source>If the data the &lt;code&gt;info&lt;/code&gt; facet needs to convey can be represented as a table then the data may be placed in this attribute in a more raw form for better display. The data must also be represented in the &lt;code&gt;details&lt;/code&gt; attribute for renderers which do not support rendering tables directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc2b173d8d4940a748b9c83e49e0862799d41a0" translate="yes" xml:space="preserve">
          <source>If the debugging output of &lt;code&gt;-D&lt;/code&gt; doesn't help you, it's time to step through perl's execution with a source-level debugger.</source>
          <target state="translated">Если отладочные данные &lt;code&gt;-D&lt;/code&gt; вам не помогают, пора пошагово выполнить выполнение perl с помощью отладчика исходного уровня.</target>
        </trans-unit>
        <trans-unit id="e01dfde61dfe31eebc6c4d98caf34437480ee91e" translate="yes" xml:space="preserve">
          <source>If the default collation sequence is used, and the BASE is less than or equal to 36, the letter case in STR is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9b61b179e59a5faa76c718b44a80bf30b29231" translate="yes" xml:space="preserve">
          <source>If the deferred-write buffer isn't yet full, but the total size of the buffer and the read cache would exceed the &lt;code&gt;memory&lt;/code&gt; limit, the oldest records will be expired from the read cache until the total size is under the limit.</source>
          <target state="translated">Если буфер отложенной записи еще не заполнен, но общий размер буфера и кеша чтения превысит предел &lt;code&gt;memory&lt;/code&gt; , самые старые записи будут удалены из кэша чтения до тех пор, пока общий размер не станет ниже ограничения.</target>
        </trans-unit>
        <trans-unit id="2d787ba93d433e8611c0010f5b5125e21c2fae5b" translate="yes" xml:space="preserve">
          <source>If the delimiter chosen is a single quote, no interpolation is done on either the</source>
          <target state="translated">Если выбранный разделитель является единственной кавычкой,то интерполяция не выполняется ни на одной из кавычек</target>
        </trans-unit>
        <trans-unit id="938284088206ea35ed759b0277c2738a57db55da" translate="yes" xml:space="preserve">
          <source>If the delimiter chosen is a single quote, no variable interpolation is done on either the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd691ad27529116a3a5593dc1f80d4b01d408999" translate="yes" xml:space="preserve">
          <source>If the destination (second argument) already exists and is a directory, and the source (first argument) is not a filehandle, then the source file will be copied into the directory specified by the destination, using the same base name as the source file. It's a failure to have a filehandle as the source when the destination is a directory.</source>
          <target state="translated">Если назначение (второй аргумент)уже существует и является каталогом,а исходный файл (первый аргумент)не является файловой рукояткой,то исходный файл будет скопирован в каталог,указанный назначением,с тем же базовым именем,что и исходный файл.Это неспособность иметь файловую папку в качестве источника,когда целевой каталог является каталогом.</target>
        </trans-unit>
        <trans-unit id="bf967ef029273cc2d212ca164cc9a8a6a20b4430" translate="yes" xml:space="preserve">
          <source>If the element type does not start with a &lt;code&gt;'*'&lt;/code&gt; , the accessor returns the element value (after assignment). If the element type starts with a &lt;code&gt;'*'&lt;/code&gt; , a reference to the element itself is returned.</source>
          <target state="translated">Если тип элемента не начинается с &lt;code&gt;'*'&lt;/code&gt; , метод доступа возвращает значение элемента (после присвоения). Если тип элемента начинается с &lt;code&gt;'*'&lt;/code&gt; , возвращается ссылка на сам элемент.</target>
        </trans-unit>
        <trans-unit id="087f6b4ba4b4848e4cef927f8a6659e4cd63651c" translate="yes" xml:space="preserve">
          <source>If the element type does not start with a &lt;code&gt;'*'&lt;/code&gt;, the accessor returns the element value (after assignment). If the element type starts with a &lt;code&gt;'*'&lt;/code&gt;, a reference to the element itself is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e23930732591461e14ec21d8b1f90dcd530ad74" translate="yes" xml:space="preserve">
          <source>If the element type is &lt;code&gt;'$'&lt;/code&gt; , the value of the element (after assignment) is returned. If the element type is &lt;code&gt;'*$'&lt;/code&gt; , a reference to the element is returned.</source>
          <target state="translated">Если тип элемента - &lt;code&gt;'$'&lt;/code&gt; , возвращается значение элемента (после присвоения). Если тип элемента - &lt;code&gt;'*$'&lt;/code&gt; , возвращается ссылка на элемент.</target>
        </trans-unit>
        <trans-unit id="416316907f2cce96ccc209eeb130ba72299c8e3b" translate="yes" xml:space="preserve">
          <source>If the element type is &lt;code&gt;'$'&lt;/code&gt;, the value of the element (after assignment) is returned. If the element type is &lt;code&gt;'*$'&lt;/code&gt;, a reference to the element is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bac597df37b35f3a7dd05dd8ec187e68ab2f23b" translate="yes" xml:space="preserve">
          <source>If the empty regex &lt;code&gt;//&lt;/code&gt; is used, the string is split into individual characters. If the regex has groupings, then the list produced contains the matched substrings from the groupings as well:</source>
          <target state="translated">Если используется пустое регулярное выражение &lt;code&gt;//&lt;/code&gt; , строка разбивается на отдельные символы. Если в регулярном выражении есть группировки, то созданный список также содержит совпадающие подстроки из групп:</target>
        </trans-unit>
        <trans-unit id="8e04e07bd20c824f00e23be10a97b35d7d8bdaf8" translate="yes" xml:space="preserve">
          <source>If the empty regexp &lt;code&gt;//&lt;/code&gt; is used, the regexp always matches and the string is split into individual characters. If the regexp has groupings, then the resulting list contains the matched substrings from the groupings as well. For instance,</source>
          <target state="translated">Если используется пустое регулярное выражение &lt;code&gt;//&lt;/code&gt; , регулярное выражение всегда совпадает, и строка разбивается на отдельные символы. Если в регулярном выражении есть группировки, то результирующий список также будет содержать совпавшие подстроки из группировок. Например,</target>
        </trans-unit>
        <trans-unit id="9160efcd7b61ecdb5eab89bb5f1048b8690bd897" translate="yes" xml:space="preserve">
          <source>If the entereval op is permitted then the code can use eval &quot;...&quot; to 'hide' code which might use denied ops. This is not a major problem since when the code tries to execute the eval it will fail because the opmask is still in effect. However this technique would allow clever, and possibly harmful, code to 'probe' the boundaries of what is possible.</source>
          <target state="translated">Если опция entereval разрешена,то код может использовать eval &quot;...&quot; для &quot;скрытия&quot; кода,который может использовать запрещенные опции.Это не является серьезной проблемой,так как когда код попытается выполнить eval,он не справится,так как оптическая маска все еще в действии.Однако эта методика позволит умному и,возможно,вредному коду 'прощупать' границы возможного.</target>
        </trans-unit>
        <trans-unit id="a6dd91d8fc44e261add22f788040f3b0d9653b9a" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code&gt;PERL_TEST_HARNESS_DUMP_TAP&lt;/code&gt; is defined it should name a directory into which a copy of the raw TAP for each test will be written. TAP is written to files named for each test. Subdirectories will be created as needed.</source>
          <target state="translated">Если переменная среды &lt;code&gt;PERL_TEST_HARNESS_DUMP_TAP&lt;/code&gt; определена, она должна указать имя каталога, в который будет записана копия необработанного TAP для каждого теста. TAP записывается в файлы, названные для каждого теста. Подкаталоги будут созданы по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="1677cef1b7d08b33d16cc5ab5e637dae11805c4b" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code&gt;SSL_CERT_FILE&lt;/code&gt; is present, HTTP::Tiny will try to find a CA certificate file in that location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e9e60a253e04ba9480e07ca8d4f04ff80b74d6" translate="yes" xml:space="preserve">
          <source>If the event is a final subtest event, this should contain the subtest ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d65844b53fa3e967e642960ca12717bb316d545" translate="yes" xml:space="preserve">
          <source>If the event is inside a subtest this should have the subtest ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e66c1c6198ecf06cc2142e9e5e1dd957bf8c18d" translate="yes" xml:space="preserve">
          <source>If the executable called by system()/exec()/pipe-open()/&lt;code&gt;``&lt;/code&gt; is a script with the &quot;magic&quot; &lt;code&gt;#!&lt;/code&gt; line or &lt;code&gt;extproc&lt;/code&gt; line which specifies shell;</source>
          <target state="translated">Если исполняемый файл, вызываемый system () / exec () / pipe-open () / &lt;code&gt;``&lt;/code&gt; , является сценарием с &quot;волшебным&quot; &lt;code&gt;#!&lt;/code&gt; line или &lt;code&gt;extproc&lt;/code&gt; строка, определяющая оболочку;</target>
        </trans-unit>
        <trans-unit id="2a754fbd5a5705920e61152dd8c6911b9ca9d965" translate="yes" xml:space="preserve">
          <source>If the executable called by system()/exec()/pipe-open()/&lt;code&gt;``&lt;/code&gt; is a script without &quot;magic&quot; line, and &lt;code&gt;$ENV{EXECSHELL}&lt;/code&gt; is set to shell;</source>
          <target state="translated">Если исполняемый файл, вызываемый system () / exec () / pipe-open () / &lt;code&gt;``&lt;/code&gt; является сценарием без &quot;волшебной&quot; строки, а для &lt;code&gt;$ENV{EXECSHELL}&lt;/code&gt; установлено значение оболочки;</target>
        </trans-unit>
        <trans-unit id="6143c4a0521be912f40be9869aedf7b75cf3c5aa" translate="yes" xml:space="preserve">
          <source>If the executable called by system()/exec()/pipe-open()/&lt;code&gt;``&lt;/code&gt; is not found (is not this remark obsolete?);</source>
          <target state="translated">Если исполняемый файл, вызываемый system () / exec () / pipe-open () / &lt;code&gt;``&lt;/code&gt; , не найден (разве это замечание не устарело?);</target>
        </trans-unit>
        <trans-unit id="50b9d8b532d25e89b151dc2833716077761d9468" translate="yes" xml:space="preserve">
          <source>If the exit status used is less than 2, then output is printed on &lt;code&gt;STDOUT&lt;/code&gt; . Otherwise output is printed on &lt;code&gt;STDERR&lt;/code&gt; .</source>
          <target state="translated">Если используемый статус выхода меньше 2, то вывод выводится на &lt;code&gt;STDOUT&lt;/code&gt; . В противном случае вывод печатается на &lt;code&gt;STDERR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6254e53f84fb9e366ade9a7d71888f7244075a2" translate="yes" xml:space="preserve">
          <source>If the exit status used is less than 2, then output is printed on &lt;code&gt;STDOUT&lt;/code&gt;. Otherwise output is printed on &lt;code&gt;STDERR&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f5e0e5ea6330c7048648eb2edf1ad4ccc05a55" translate="yes" xml:space="preserve">
          <source>If the experimental &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; . This indicates that the caller is expecting numeric behaviour. The fourth argument will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, as that position (&lt;code&gt;$_[3]&lt;/code&gt; ) is reserved for use by &lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;.</source>
          <target state="translated">Если экспериментальная &amp;laquo;побитовая&amp;raquo; функция включена (см. &lt;a href=&quot;feature&quot;&gt;Функцию&lt;/a&gt; ), пятый аргумент ИСТИНА передается подпрограммам, обрабатывающим &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; и &lt;code&gt;~&lt;/code&gt; . Это указывает на то, что вызывающий ожидает числовое поведение. Четвертым аргументом будет &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , поскольку эта позиция ( &lt;code&gt;$_[3]&lt;/code&gt; ) зарезервирована для использования &lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d70ab84f3a316c00496bd0dced7b93acc9fa6af" translate="yes" xml:space="preserve">
          <source>If the experimental &quot;bitwise&quot; feature is enabled via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'bitwise'&lt;/code&gt; , then this operator always treats its operand as numbers. This feature produces a warning unless you also use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
'experimental::bitwise'&lt;/code&gt; .</source>
          <target state="translated">Если экспериментальная &amp;laquo;побитовая&amp;raquo; функция включена через &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'bitwise'&lt;/code&gt; , то этот оператор всегда обрабатывает свой операнд как числа. Эта функция выдаст предупреждение , если вы также не использовать без &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::bitwise'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="429f3423b67c7b1e2fda19e3e61bde6079c26d75" translate="yes" xml:space="preserve">
          <source>If the experimental &quot;bitwise&quot; feature is enabled via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'bitwise'&lt;/code&gt; , then unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; always treats its argument as a number, and an alternate form of the operator, &lt;code&gt;&quot;~.&quot;&lt;/code&gt; , always treats its argument as a string. So &lt;code&gt;~0&lt;/code&gt; and &lt;code&gt;~&quot;0&quot;&lt;/code&gt; will both give 2**32-1 on 32-bit platforms, whereas &lt;code&gt;~.0&lt;/code&gt; and &lt;code&gt;~.&quot;0&quot;&lt;/code&gt; will both yield &lt;code&gt;&quot;\xff&quot;&lt;/code&gt; . This feature produces a warning unless you use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::bitwise'&lt;/code&gt; .</source>
          <target state="translated">Если функция экспериментальной &amp;laquo;побитовая&amp;raquo; включена с помощью &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'bitwise'&lt;/code&gt; , то одноместный &lt;code&gt;&quot;~&quot;&lt;/code&gt; всегда рассматривает свой аргумент как номер, и альтернативный вид оператора, &lt;code&gt;&quot;~.&quot;&lt;/code&gt; . , всегда рассматривает свой аргумент как строку. Таким образом, &lt;code&gt;~0&lt;/code&gt; и &lt;code&gt;~&quot;0&quot;&lt;/code&gt; будут давать 2 ** 32-1 на 32-битных платформах, тогда как &lt;code&gt;~.0&lt;/code&gt; и &lt;code&gt;~.&quot;0&quot;&lt;/code&gt; будут давать &lt;code&gt;&quot;\xff&quot;&lt;/code&gt; . Эта функция выдаст предупреждение , если не использовать без &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::bitwise'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc923038f738e51827c6486386f676bb16b7db9f" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a label name, its scope will be resolved dynamically. This allows for computed &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c964489535901a948a3b23073f9b9bb3c0a3e6" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a label name, its scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">Если выражение оценивается как имя метки, его область видимости будет разрешена динамически. Это позволяет вычислять &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; для FORTRAN, но не обязательно рекомендуется, если вы оптимизируете для удобства сопровождения:</target>
        </trans-unit>
        <trans-unit id="c0c3c70b730f0e2950f8179af548175b3c6ef32a" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a label name, its scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">Если выражение оценивается как имя метки, его область видимости будет разрешена динамически. Это позволяет вычислять &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; для FORTRAN, но не обязательно рекомендуется, если вы оптимизируете для удобства сопровождения:</target>
        </trans-unit>
        <trans-unit id="3a5f344d7e209018f81b3bb395e41710ea76000e" translate="yes" xml:space="preserve">
          <source>If the extension doesn't contain a &lt;code&gt;*&lt;/code&gt; , then it is appended to the end of the current filename as a suffix. If the extension does contain one or more &lt;code&gt;*&lt;/code&gt; characters, then each &lt;code&gt;*&lt;/code&gt; is replaced with the current filename. In Perl terms, you could think of this as:</source>
          <target state="translated">Если расширение не содержит &lt;code&gt;*&lt;/code&gt; , оно добавляется в конец текущего имени файла как суффикс. Если расширение действительно содержит один или несколько символов &lt;code&gt;*&lt;/code&gt; , то каждый &lt;code&gt;*&lt;/code&gt; заменяется текущим именем файла. В терминах Perl это можно представить как:</target>
        </trans-unit>
        <trans-unit id="de01c14a7209a45c44123f6710c3fc14dda93261" translate="yes" xml:space="preserve">
          <source>If the extension doesn't contain a &lt;code&gt;*&lt;/code&gt;, then it is appended to the end of the current filename as a suffix. If the extension does contain one or more &lt;code&gt;*&lt;/code&gt; characters, then each &lt;code&gt;*&lt;/code&gt; is replaced with the current filename. In Perl terms, you could think of this as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912122ed04813ef6afa69c21de9ff5d7b9578a1b" translate="yes" xml:space="preserve">
          <source>If the extension links to a library that it builds, set this to the name of the library (see SDBM_File)</source>
          <target state="translated">Если расширение ссылается на библиотеку,которую оно собирает,установите это в имя библиотеки (см.SDBM_File)</target>
        </trans-unit>
        <trans-unit id="d3a643174ddd0d9876c30f4ff9ae6dc788ca282c" translate="yes" xml:space="preserve">
          <source>If the extension might need extra libraries, they should be included here. The extension Makefile.PL will take care of checking whether the libraries actually exist and how they should be loaded. The extra libraries should be specified in the form -lm -lposix, etc, just as on the cc command line. By default, the Makefile.PL will search through the library path determined by Configure. That path can be augmented by including arguments of the form &lt;b&gt;-L/another/library/path&lt;/b&gt; in the extra-libraries argument.</source>
          <target state="translated">Если для расширения могут потребоваться дополнительные библиотеки, их следует включить сюда. Расширение Makefile.PL позаботится о том, чтобы проверить, существуют ли библиотеки на самом деле и как они должны быть загружены. Дополнительные библиотеки должны быть указаны в форме -lm -lposix и т. Д., Как и в командной строке cc. По умолчанию Makefile.PL будет искать путь к библиотеке, определенный с помощью Configure. Этот путь можно расширить, включив аргументы формы &lt;b&gt;-L / another / library / path&lt;/b&gt; в аргумент дополнительных библиотек.</target>
        </trans-unit>
        <trans-unit id="effa256cfcef0cdd6582a1503da6bdf1fb1d1f9e" translate="yes" xml:space="preserve">
          <source>If the external</source>
          <target state="translated">Если внешний</target>
        </trans-unit>
        <trans-unit id="2e204c469081d0ce7742a3d71bcaeedaf9240cda" translate="yes" xml:space="preserve">
          <source>If the extractor fails to match (in the case of a regex extractor), or returns an empty list or an undefined value (in the case of a subroutine extractor), it is assumed to have failed to extract. If none of the extractor subroutines succeeds, then one character is extracted from the start of the text and the extraction subroutines reapplied. Characters which are thus removed are accumulated and eventually become the next field (unless the fourth argument is true, in which case they are discarded).</source>
          <target state="translated">Если извлекающее устройство не соответствует (в случае регрессивного извлекающего устройства),или возвращает пустой список или неопределенное значение (в случае подпрограммного извлекающего устройства),предполагается,что извлечение не удалось.Если ни одна из подпрограмм извлечения не удается,то один символ извлекается из начала текста,а подпрограммы извлечения применяются повторно.Символы,которые таким образом удаляются,накапливаются и в конце концов становятся следующим полем (если только четвертый аргумент не верен,в этом случае они отбрасываются).</target>
        </trans-unit>
        <trans-unit id="17d2c98a680d0b983c00126ba7fbf7037583b89d" translate="yes" xml:space="preserve">
          <source>If the extractor is a hash reference, it must contain exactly one element. The value of that element is one of the above extractor types (subroutine reference, regular expression, or string). The key of that element is the name of a class into which the successful return value of the extractor will be blessed.</source>
          <target state="translated">Если экстрактор является ссылкой на хэш,то он должен содержать ровно один элемент.Значение этого элемента является одним из вышеперечисленных типов экстрактора (подпрограммная ссылка,регулярное выражение или строка).Ключом к этому элементу является имя класса,в который будет благословлено успешное возвращение значения экстрактора.</target>
        </trans-unit>
        <trans-unit id="a2187e610c6c9ce986c9ab2bc434fe210c96d6c7" translate="yes" xml:space="preserve">
          <source>If the extractor is a precompiled regular expression or a string, it is matched against the text in a scalar context with a leading '\G' and the gc modifiers enabled. The extracted value is either $1 if that variable is defined after the match, or else the complete match (i.e. $&amp;amp;).</source>
          <target state="translated">Если экстрактор является предварительно скомпилированным регулярным выражением или строкой, он сопоставляется с текстом в скалярном контексте с ведущим '\ G' и включенными модификаторами gc. Извлеченное значение - либо $ 1, если эта переменная определена после совпадения, либо полное совпадение (например, $ &amp;amp;).</target>
        </trans-unit>
        <trans-unit id="8efec72894ea829331e728164da92723ccc10f46" translate="yes" xml:space="preserve">
          <source>If the extractor is a subroutine it is called in a list context and is expected to return a list of a single element, namely the extracted text. It may optionally also return two further arguments: a string representing the text left after extraction (like $' for a pattern match), and a string representing any prefix skipped before the extraction (like $` in a pattern match). Note that this is designed to facilitate the use of other Text::Balanced subroutines with &lt;code&gt;extract_multiple&lt;/code&gt; . Note too that the value returned by an extractor subroutine need not bear any relationship to the corresponding substring of the original text (see examples below).</source>
          <target state="translated">Если экстрактор является подпрограммой, он вызывается в контексте списка и, как ожидается, вернет список из одного элемента, а именно извлеченного текста. При желании он также может возвращать два дополнительных аргумента: строку, представляющую текст, оставшийся после извлечения (например, $ 'для сопоставления с шаблоном), и строку, представляющую любой префикс, пропущенный перед извлечением (например, $ `в сопоставлении с образцом). Обратите внимание, что это предназначено для облегчения использования других подпрограмм Text :: Balanced с &lt;code&gt;extract_multiple&lt;/code&gt; . Также обратите внимание, что значение, возвращаемое подпрограммой экстрактора, не обязательно должно иметь какое-либо отношение к соответствующей подстроке исходного текста (см. Примеры ниже).</target>
        </trans-unit>
        <trans-unit id="91257d19dbe73c3f0115d0e82b54c986793ce4ee" translate="yes" xml:space="preserve">
          <source>If the extractor is a subroutine it is called in a list context and is expected to return a list of a single element, namely the extracted text. It may optionally also return two further arguments: a string representing the text left after extraction (like $' for a pattern match), and a string representing any prefix skipped before the extraction (like $` in a pattern match). Note that this is designed to facilitate the use of other Text::Balanced subroutines with &lt;code&gt;extract_multiple&lt;/code&gt;. Note too that the value returned by an extractor subroutine need not bear any relationship to the corresponding substring of the original text (see examples below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a385fcb5d8ca5cfa07426e73b4f41df3b2f355d3" translate="yes" xml:space="preserve">
          <source>If the field contains a numeric value it will be displayed in hex. Zip stored most numbers in little-endian format - the value displayed will have the little-endian encoding removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12045367f64a99179f5690e61487afbfd5fe1436" translate="yes" xml:space="preserve">
          <source>If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then it is skipped before processing, and the content of the file is also decoded appropriately starting from perl 5.8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0b45c8a0563151ba3b588e7383417bdd5f8a3d" translate="yes" xml:space="preserve">
          <source>If the file does not exist, &lt;code&gt;cpan&lt;/code&gt; dies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4293d2972da49b7deee5cbac8e57e93be999a13" translate="yes" xml:space="preserve">
          <source>If the file is a symlink, the file it's pointing to</source>
          <target state="translated">Если файл является сим-ссылкой,то файл,на который он указывает.</target>
        </trans-unit>
        <trans-unit id="1260f14708b5c4f0e969b3d9b19ac87d75cb1573" translate="yes" xml:space="preserve">
          <source>If the file is pulled in by &lt;code&gt;perl_parse()&lt;/code&gt; , compiled into a newly constructed interpreter, and subsequently cleaned out with &lt;code&gt;perl_destruct()&lt;/code&gt; afterwards, you're shielded from most namespace troubles.</source>
          <target state="translated">Если файл извлекается с помощью &lt;code&gt;perl_parse()&lt;/code&gt; , компилируется во вновь созданный интерпретатор и впоследствии очищается с помощью &lt;code&gt;perl_destruct()&lt;/code&gt; , вы защищены от большинства проблем с пространством имен.</target>
        </trans-unit>
        <trans-unit id="12e4d1ea92f7af34b6047df7fcc8abb443c9f062" translate="yes" xml:space="preserve">
          <source>If the file is pulled in by &lt;code&gt;perl_parse()&lt;/code&gt;, compiled into a newly constructed interpreter, and subsequently cleaned out with &lt;code&gt;perl_destruct()&lt;/code&gt; afterwards, you're shielded from most namespace troubles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0047e959707fe337b2aa331e4b4d29cbdd3ddf49" translate="yes" xml:space="preserve">
          <source>If the file named by FILENAME does not exist and the &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; call creates it (typically because MODE includes the &lt;code&gt;O_CREAT&lt;/code&gt; flag), then the value of PERMS specifies the permissions of the newly created file. If you omit the PERMS argument to &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt;, Perl uses the octal value &lt;code&gt;0666&lt;/code&gt;. These permission values need to be in octal, and are modified by your process's current &lt;a href=&quot;#umask-EXPR&quot;&gt;&lt;code&gt;umask&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972b095c8cf0635710238db90318d20a5a12c4b1" translate="yes" xml:space="preserve">
          <source>If the file named by FILENAME does not exist and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call creates it (typically because MODE includes the &lt;code&gt;O_CREAT&lt;/code&gt; flag), then the value of PERMS specifies the permissions of the newly created file. If you omit the PERMS argument to &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, Perl uses the octal value &lt;code&gt;0666&lt;/code&gt; . These permission values need to be in octal, and are modified by your process's current &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если файл, названный FILENAME, не существует и вызов &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; создает его (обычно потому, что MODE включает флаг &lt;code&gt;O_CREAT&lt;/code&gt; ), тогда значение PERMS определяет разрешения для вновь созданного файла. Если вы опустите аргумент PERMS для &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; , Perl будет использовать восьмеричное значение &lt;code&gt;0666&lt;/code&gt; . Эти значения разрешений должны быть восьмеричными и изменяются текущей &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; вашего процесса .</target>
        </trans-unit>
        <trans-unit id="8aa66e9311c9629d0b8c20e950c88829b4d37f7e" translate="yes" xml:space="preserve">
          <source>If the file named by FILENAME does not exist and the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call creates it (typically because MODE includes the &lt;code&gt;O_CREAT&lt;/code&gt; flag), then the value of PERMS specifies the permissions of the newly created file. If you omit the PERMS argument to &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, Perl uses the octal value &lt;code&gt;0666&lt;/code&gt; . These permission values need to be in octal, and are modified by your process's current &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если файл, названный FILENAME, не существует и вызов &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; создает его (обычно потому, что MODE включает флаг &lt;code&gt;O_CREAT&lt;/code&gt; ), тогда значение PERMS определяет разрешения для вновь созданного файла. Если вы опустите аргумент PERMS для &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; , Perl будет использовать восьмеричное значение &lt;code&gt;0666&lt;/code&gt; . Эти значения разрешений должны быть восьмеричными и изменяются текущей &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; вашего процесса .</target>
        </trans-unit>
        <trans-unit id="afca59eeb0296a7f173f43e8587c0ce7c2de1f87" translate="yes" xml:space="preserve">
          <source>If the file specification is already in a valid VMS syntax, it will be passed through unchanged, except that the UTF-8 flag will be cleared since VMS format file specifications are never in UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20f26d4d2cfe896fd9be41e5561303708778051" translate="yes" xml:space="preserve">
          <source>If the file that contains the module begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then it is skipped before processing, and the content of the file is also decoded appropriately starting from perl 5.8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9e946eeefcb8ca3ed866d0a22b192157304573" translate="yes" xml:space="preserve">
          <source>If the file to be opened contains binary data instead of text characters, then the &lt;code&gt;MODE&lt;/code&gt; argument to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is a little different. Instead of specifying the encoding, you tell Perl that your data are in raw bytes.</source>
          <target state="translated">Если открываемый файл содержит двоичные данные вместо текстовых символов, то аргумент &lt;code&gt;MODE&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; немного отличается. Вместо указания кодировки вы сообщаете Perl, что ваши данные находятся в необработанных байтах.</target>
        </trans-unit>
        <trans-unit id="b62027d4bfba52954180b6ef864f354108e4a798" translate="yes" xml:space="preserve">
          <source>If the file to be opened contains binary data instead of text characters, then the &lt;code&gt;MODE&lt;/code&gt; argument to &lt;code&gt;open&lt;/code&gt; is a little different. Instead of specifying the encoding, you tell Perl that your data are in raw bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7727f14d3896e4199132a911f1277a6913be80" translate="yes" xml:space="preserve">
          <source>If the file was loaded via a hook (e.g. a subroutine reference, see &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for a description of these hooks), this hook is by default inserted into &lt;code&gt;%INC&lt;/code&gt; in place of a filename. Note, however, that the hook may have set the &lt;code&gt;%INC&lt;/code&gt; entry by itself to provide some more specific info.</source>
          <target state="translated">Если файл был загружен через ловушку (например, ссылку на подпрограмму, описание этих ловушек см. В &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; ), эта ловушка по умолчанию вставляется в &lt;code&gt;%INC&lt;/code&gt; вместо имени файла. Обратите внимание, однако, что ловушка могла сама установить запись &lt;code&gt;%INC&lt;/code&gt; , чтобы предоставить некоторую более конкретную информацию.</target>
        </trans-unit>
        <trans-unit id="cf52c06965f9e5fc28f2b729df47caf3473ff123" translate="yes" xml:space="preserve">
          <source>If the file was loaded via a hook (e.g. a subroutine reference, see &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt; for a description of these hooks), this hook is by default inserted into &lt;code&gt;%INC&lt;/code&gt; in place of a filename. Note, however, that the hook may have set the &lt;code&gt;%INC&lt;/code&gt; entry by itself to provide some more specific info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbada7e6f993214c7ee778a69597cde7ab2c7bef" translate="yes" xml:space="preserve">
          <source>If the file was modified and the server response includes a properly formatted &lt;code&gt;Last-Modified&lt;/code&gt; header, the file modification time will be updated accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1055d8f3bf09e356a8ac90a312ee4c58ffecab8f" translate="yes" xml:space="preserve">
          <source>If the filehandle came from a piped open, &lt;a href=&quot;#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; returns false if one of the other syscalls involved fails or if its program exits with non-zero status. If the only problem was that the program exited non-zero, &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; will be set to &lt;code&gt;0&lt;/code&gt;. Closing a pipe also waits for the process executing on the pipe to exit--in case you wish to look at the output of the pipe afterwards--and implicitly puts the exit status value of that command into &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt;&lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e74503c754d78c3ba0f9051478f8b0d722c72c1" translate="yes" xml:space="preserve">
          <source>If the filehandle came from a piped open, &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; returns false if one of the other syscalls involved fails or if its program exits with non-zero status. If the only problem was that the program exited non-zero, &lt;code&gt;$!&lt;/code&gt; will be set to &lt;code&gt;0&lt;/code&gt; . Closing a pipe also waits for the process executing on the pipe to exit--in case you wish to look at the output of the pipe afterwards--and implicitly puts the exit status value of that command into &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</source>
          <target state="translated">Если дескриптор файла произошел от открытого по конвейеру, &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; возвращает false, если один из других задействованных системных вызовов завершился неудачно или его программа завершилась с ненулевым статусом. Если бы единственная проблема заключалась в том, что программа вышла ненулевым образом, &lt;code&gt;$!&lt;/code&gt; будет установлено на &lt;code&gt;0&lt;/code&gt; . Закрытие канала также ожидает завершения процесса, выполняющегося в канале - на случай, если вы хотите впоследствии посмотреть на вывод канала - и неявно помещает значение статуса выхода этой команды в &lt;code&gt;$?&lt;/code&gt; и &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a275dda5ca271e5742fe50c27b80a1dea7fadc2a" translate="yes" xml:space="preserve">
          <source>If the filehandle came from a piped open, &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; returns false if one of the other syscalls involved fails or if its program exits with non-zero status. If the only problem was that the program exited non-zero, &lt;code&gt;$!&lt;/code&gt; will be set to &lt;code&gt;0&lt;/code&gt; . Closing a pipe also waits for the process executing on the pipe to exit--in case you wish to look at the output of the pipe afterwards--and implicitly puts the exit status value of that command into &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</source>
          <target state="translated">Если дескриптор файла произошел от открытого по конвейеру, &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; возвращает false, если один из других задействованных системных вызовов завершился неудачно или его программа завершилась с ненулевым статусом. Если бы единственная проблема заключалась в том, что программа вышла ненулевым образом, &lt;code&gt;$!&lt;/code&gt; будет установлено на &lt;code&gt;0&lt;/code&gt; . Закрытие канала также ожидает завершения процесса, выполняющегося в канале - на случай, если вы хотите впоследствии посмотреть на вывод канала - и неявно помещает значение статуса выхода этой команды в &lt;code&gt;$?&lt;/code&gt; и &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fc5e1415bd14e8d1ec6ad1e512653e073ea2d16" translate="yes" xml:space="preserve">
          <source>If the filename supplied contains directory separators (and so is an absolute or relative pathname), and if that file is not found, platforms that append file extensions will do so and try to look for the file with those extensions added, one by one.</source>
          <target state="translated">Если поставляемый файл содержит разделители каталогов (а также абсолютный или относительный каталог),и если этот файл не найден,платформы,которые добавляют расширения файлов,будут делать это и пытаться найти файл с добавленными расширениями,один за другим.</target>
        </trans-unit>
        <trans-unit id="8b638dc989817125971a607e8fa00529b2b307c1" translate="yes" xml:space="preserve">
          <source>If the final value specified is not in the sequence that the magical increment would produce, the sequence goes until the next value would be longer than the final value specified.</source>
          <target state="translated">Если указанное конечное значение не находится в последовательности,которую создал бы магический прирост,то последовательность идет до тех пор,пока следующее значение не будет длиннее указанного конечного значения.</target>
        </trans-unit>
        <trans-unit id="a33c6e16dc7645806ca8dcd82f881fedaded9d02" translate="yes" xml:space="preserve">
          <source>If the final value specified is not in the sequence that the magical increment would produce, the sequence goes until the next value would be longer than the final value specified. If the length of the final string is shorter than the first, the empty list is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f8e1e30b780f6553cc08550f9370ae0ed9b97a" translate="yes" xml:space="preserve">
          <source>If the first argument is a reference to an array, the pseudo-hash will be created with keys from that array. If a second argument is supplied, it must also be a reference to an array whose elements will be used as the values. If the second array contains less elements than the first, the trailing elements of the pseudo-hash will not be initialized. This makes it particularly useful for creating a pseudo-hash from subroutine arguments:</source>
          <target state="translated">Если первым аргументом является ссылка на массив,то будет создан псевдо-хэш с ключами из этого массива.Если поставляется второй аргумент,то это также должна быть ссылка на массив,элементы которого будут использоваться в качестве значений.Если второй массив содержит меньше элементов,чем первый,то трейлинговые элементы псевдо-хэша инициализироваться не будут.Это делает его особенно полезным для создания псевдо-хэша из подпрограммных аргументов:</target>
        </trans-unit>
        <trans-unit id="9f235f80bacbd6f2376896bcd2071e6b6ed89634" translate="yes" xml:space="preserve">
          <source>If the first argument is an empty string &quot;&quot; or is a volume name, i.e. matches the pattern /^[^:]+:/, the resulting path is &lt;b&gt;absolute&lt;/b&gt;.</source>
          <target state="translated">Если первым аргументом является пустая строка &amp;laquo;&amp;raquo; или имя тома, т.е. соответствует шаблону / ^ [^:] +: /, результирующий путь является &lt;b&gt;абсолютным&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="89aa8ef2f6a6df7b419aa16ffe18ced8031ac672" translate="yes" xml:space="preserve">
          <source>If the first character after the &lt;b&gt;-M&lt;/b&gt; or &lt;b&gt;-m&lt;/b&gt; is a dash (&lt;b&gt;-&lt;/b&gt;) then the 'use' is replaced with 'no'.</source>
          <target state="translated">Если первым символом после &lt;b&gt;-M&lt;/b&gt; или &lt;b&gt;-m&lt;/b&gt; является дефис ( &lt;b&gt;-&lt;/b&gt; ), то &amp;laquo;использование&amp;raquo; заменяется на &amp;laquo;нет&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d6369cd957319ca2b8d2442c19d6fcbc6b24183a" translate="yes" xml:space="preserve">
          <source>If the first character after the &lt;b&gt;-M&lt;/b&gt; or &lt;b&gt;-m&lt;/b&gt; is a dash (&lt;b&gt;-&lt;/b&gt;) then the 'use' is replaced with 'no'. This makes no difference for &lt;b&gt;-m&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781d0d29a2affd4018c32ec572f1b116a7081027" translate="yes" xml:space="preserve">
          <source>If the first chars of a Perl script are &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; , this line is treated as &lt;code&gt;#!&lt;/code&gt; -line, thus all the switches on this line are processed (twice if script was started via cmd.exe). See &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;DESCRIPTION in perlrun&lt;/a&gt;.</source>
          <target state="translated">Если первые символы сценария Perl - &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; , эта строка обрабатывается как &lt;code&gt;#!&lt;/code&gt; -line, таким образом, все переключатели в этой строке обрабатываются (дважды, если скрипт был запущен через cmd.exe). Смотрите &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;ОПИСАНИЕ в perlrun&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="581c684b617d92750c5f38a91fda2e5d76163206" translate="yes" xml:space="preserve">
          <source>If the first chars of a Perl script are &lt;code&gt;&quot;extproc &quot;&lt;/code&gt;, this line is treated as &lt;code&gt;#!&lt;/code&gt;-line, thus all the switches on this line are processed (twice if script was started via cmd.exe). See &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;&quot;DESCRIPTION&quot; in perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f46518f452342a5c022fec8e53026c8608f2e02a" translate="yes" xml:space="preserve">
          <source>If the first digit following the backslash is a 0, it's an octal escape.</source>
          <target state="translated">Если первая цифра после обратного слеша равна 0,то это восьмеричный побег.</target>
        </trans-unit>
        <trans-unit id="5675bafb3dc48482ba4a4f320234c0b4d704c9a0" translate="yes" xml:space="preserve">
          <source>If the first element of the return value (&lt;code&gt;success&lt;/code&gt; ) was 0, then some error occurred. This second element is the error message the command you requested exited with, if available. This is generally a pretty printed value of &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$@&lt;/code&gt; . See &lt;code&gt;perldoc perlvar&lt;/code&gt; for details on what they can contain. If the error was a timeout, the &lt;code&gt;error message&lt;/code&gt; will be prefixed with the string &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt; , the timeout class.</source>
          <target state="translated">Если первый элемент возвращаемого значения ( &lt;code&gt;success&lt;/code&gt; ) был 0, то произошла ошибка. Этот второй элемент представляет собой сообщение об ошибке, которое запрошенная команда завершила, если доступно. Обычно это красивое печатное значение &lt;code&gt;$?&lt;/code&gt; или &lt;code&gt;$@&lt;/code&gt; . См. &lt;code&gt;perldoc perlvar&lt;/code&gt; для подробностей о том, что они могут содержать. Если ошибка была тайм-аутом, к &lt;code&gt;error message&lt;/code&gt; будет добавлен префикс &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt; , класс тайм-аута.</target>
        </trans-unit>
        <trans-unit id="638a2f7fa728eb482819629ddfdf65e5299a089f" translate="yes" xml:space="preserve">
          <source>If the first element of the return value (&lt;code&gt;success&lt;/code&gt;) was 0, then some error occurred. This second element is the error message the command you requested exited with, if available. This is generally a pretty printed value of &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$@&lt;/code&gt;. See &lt;code&gt;perldoc perlvar&lt;/code&gt; for details on what they can contain. If the error was a timeout, the &lt;code&gt;error message&lt;/code&gt; will be prefixed with the string &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt;, the timeout class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a57fb9b1830952d24356efef9c0744590e7e139" translate="yes" xml:space="preserve">
          <source>If the first item in a bracket group is &quot;*&quot;, it's taken as shorthand for the so commonly called &quot;quant&quot; method. Similarly, if the first item in a bracket group is &quot;#&quot;, it's taken to be shorthand for &quot;numf&quot;.</source>
          <target state="translated">Если первый пункт в группе скобок-&quot;*&quot;,то он принимается как сокращение для так называемого &quot;квантового&quot; метода.Аналогично,если первый пункт в группе скобок-&quot;#&quot;,он принимается как сокращение от &quot;numf&quot;.</target>
        </trans-unit>
        <trans-unit id="1953104edb77654c33631a60ba8219310b08e426" translate="yes" xml:space="preserve">
          <source>If the first item in a bracket group is the empty-string, or &quot;_*&quot; or &quot;_</source>
          <target state="translated">Если первым пунктом в группе скобок является пустая строка,или &quot;_*&quot;,или &quot;___&quot;,или &quot;___&quot;.</target>
        </trans-unit>
        <trans-unit id="bf6e94a3fad4e68b50306c3295f243e0a73b5811" translate="yes" xml:space="preserve">
          <source>If the first item in a bracket group looks like a method name, then that group is interpreted like this:</source>
          <target state="translated">Если первый элемент в группе скобок выглядит как имя метода,то эта группа интерпретируется следующим образом:</target>
        </trans-unit>
        <trans-unit id="ccf14e3215a8aeb1aa87eb4f44052cead882fc98" translate="yes" xml:space="preserve">
          <source>If the first operand has a &quot;nomethod&quot; method then use that.</source>
          <target state="translated">Если первый операнд имеет метод &quot;нометода&quot;,то используйте его.</target>
        </trans-unit>
        <trans-unit id="a0dadbb13895f7c7975effc9602b93ea5e861379" translate="yes" xml:space="preserve">
          <source>If the first operand has declared a subroutine to overload the operator then use that implementation.</source>
          <target state="translated">Если первый операнд объявил подпрограмму,перегружающую оператор,то используйте эту реализацию.</target>
        </trans-unit>
        <trans-unit id="f7ca747166805083d1be553c7e78c86f97bd5b0c" translate="yes" xml:space="preserve">
          <source>If the flag &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; is passed, no warnings are generated, and hence no AV is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63722d831a3c09d59c00e59b75ba5f74f6230f38" translate="yes" xml:space="preserve">
          <source>If the flag is present in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; will delete whitespace from the start of the subject string before it's operated on. What is considered whitespace depends on if the subject is a UTF-8 string and if the &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; flag is set.</source>
          <target state="translated">Если флаг присутствует в &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; удалит пробелы в начале строки темы перед тем, как с ней работать. То, что считается пробелом, зависит от того, является ли тема строкой UTF-8 и установлен ли флаг &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69393e8c9a9ff1f7ad6c1d1075c45161dd52ff73" translate="yes" xml:space="preserve">
          <source>If the flag is present in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt;&lt;code&gt;split&lt;/code&gt; will delete whitespace from the start of the subject string before it's operated on. What is considered whitespace depends on if the subject is a UTF-8 string and if the &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; flag is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc08ae29def75bcb01866771948171d3f78fd50" translate="yes" xml:space="preserve">
          <source>If the function is used across several files, but intended only for Perl's internal use (and this should be the common case), do not export it to the public API. See the discussion about</source>
          <target state="translated">Если функция используется в нескольких файлах,но предназначена только для внутреннего использования Perl (а это должно быть обычным делом),не экспортируйте ее в публичный API.См.обсуждение</target>
        </trans-unit>
        <trans-unit id="0cd096b932efa03a9f98d53e47997c47f5475a48" translate="yes" xml:space="preserve">
          <source>If the function is used only inside one source code file, make it static. See the discussion about</source>
          <target state="translated">Если функция используется только внутри одного файла с исходным кодом,сделайте ее статической.См.обсуждение о</target>
        </trans-unit>
        <trans-unit id="56833441b11ff81d3798d0015a0f9476e6600637" translate="yes" xml:space="preserve">
          <source>If the function wants to handle the keyword, it first must parse anything following the keyword that is part of the syntax introduced by the keyword. See &lt;a href=&quot;#Lexer-interface&quot;&gt;&quot;Lexer interface&quot;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d809f75a0fec341370456ffe5542097322b23570" translate="yes" xml:space="preserve">
          <source>If the function wants to handle the keyword, it first must parse anything following the keyword that is part of the syntax introduced by the keyword. See &lt;a href=&quot;#Lexer-interface&quot;&gt;Lexer interface&lt;/a&gt; for details.</source>
          <target state="translated">Если функция хочет обработать ключевое слово, она сначала должна проанализировать все, что следует за ключевым словом, что является частью синтаксиса, введенного этим ключевым словом. См. Подробности в &lt;a href=&quot;#Lexer-interface&quot;&gt;интерфейсе Lexer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4257aa9162577acd082afc2803cd5eba4d35b6a8" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;DESTROY&lt;/b&gt; then the C++ &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; function will be called and &lt;code&gt;THIS&lt;/code&gt; will be given as its parameter. The generated C++ code for</source>
          <target state="translated">Если имя функции &lt;b&gt;DESTROY,&lt;/b&gt; то будет вызвана функция &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; C ++ , и &lt;code&gt;THIS&lt;/code&gt; будет передан в качестве ее параметра. Сгенерированный код C ++ для</target>
        </trans-unit>
        <trans-unit id="2d5573b215565d0881940be9d2690435373f68b6" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;DESTROY&lt;/b&gt; then the C++ &lt;code&gt;delete&lt;/code&gt; function will be called and &lt;code&gt;THIS&lt;/code&gt; will be given as its parameter. The generated C++ code for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9d5afefb1f72725e3effbcde85fc42f858949b" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;new&lt;/b&gt; then the C++ &lt;code&gt;new&lt;/code&gt; function will be called to create a dynamic C++ object. The XSUB will expect the class name, which will be kept in a variable called &lt;code&gt;CLASS&lt;/code&gt; , to be given as the first argument.</source>
          <target state="translated">Если имя функции &lt;b&gt;новое,&lt;/b&gt; то будет вызвана &lt;code&gt;new&lt;/code&gt; функция C ++ для создания динамического объекта C ++. XSUB ожидает, что имя класса, которое будет храниться в переменной &lt;code&gt;CLASS&lt;/code&gt; , будет указано в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="55694f31aaf01067ff0315ab3ecdf0ed7ab87a27" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;new&lt;/b&gt; then the C++ &lt;code&gt;new&lt;/code&gt; function will be called to create a dynamic C++ object. The XSUB will expect the class name, which will be kept in a variable called &lt;code&gt;CLASS&lt;/code&gt;, to be given as the first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b71bbee27e0cc31a2af0019a27b599b4619d0d9" translate="yes" xml:space="preserve">
          <source>If the generated module were architecture-specific, you could replace &lt;code&gt;$(INST_LIB)&lt;/code&gt; above with &lt;code&gt;$(INST_ARCHLIB)&lt;/code&gt;, although if you locate modules under</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf92d6194fe17b6faa691c083e3aa66b73fd41bc" translate="yes" xml:space="preserve">
          <source>If the given file is a Storable image return a hash describing it. If the file is readable, but not a Storable image return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. If the file does not exist or is unreadable then croak.</source>
          <target state="translated">Если данный файл является сохраняемым изображением, верните хэш, описывающий его. Если файл доступен для чтения, но не является сохраняемым изображением, верните &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Если файл не существует или не читается, то квакните.</target>
        </trans-unit>
        <trans-unit id="1e8a49ab1a01520f2d7d29b472d08d17beed998e" translate="yes" xml:space="preserve">
          <source>If the given file is a Storable image return a hash describing it. If the file is readable, but not a Storable image return &lt;code&gt;undef&lt;/code&gt;. If the file does not exist or is unreadable then croak.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5f5dfa299a465aa9a0110ad7326e956c843743" translate="yes" xml:space="preserve">
          <source>If the given string is in FCD (&quot;Fast C or D&quot; form; cf. UTN #5), it returns the string without modification; otherwise it returns an FCD string.</source>
          <target state="translated">Если данная строка находится в форме FCD (&quot;Fast C или D&quot;;ср.UTN #5),то она возвращает строку без модификаций,в противном случае-строку FCD.</target>
        </trans-unit>
        <trans-unit id="12d092a8012a2b0bc17122d5b49e40f14ceca06d" translate="yes" xml:space="preserve">
          <source>If the global variable $KEEP_ALL is true, the file or directory will not be removed.</source>
          <target state="translated">Если глобальная переменная $KEEP_ALL равна true,то файл или каталог не будет удален.</target>
        </trans-unit>
        <trans-unit id="cc1c6dee6d24dc894200423540415887a91afb83" translate="yes" xml:space="preserve">
          <source>If the groupings in a regex are nested, &lt;code&gt;$1&lt;/code&gt; gets the group with the leftmost opening parenthesis, &lt;code&gt;$2&lt;/code&gt; the next opening parenthesis, etc. For example, here is a complex regex and the matching variables indicated below it:</source>
          <target state="translated">Если группировки в регулярном выражении являются вложенными, &lt;code&gt;$1&lt;/code&gt; получает группу с крайней левой открывающей круглой скобкой, &lt;code&gt;$2&lt;/code&gt; - следующей открывающей круглой скобкой и т. Д. Например, вот сложное регулярное выражение и соответствующие переменные, указанные под ним:</target>
        </trans-unit>
        <trans-unit id="9d3242285e88212205a68d263609b12616c56fc8" translate="yes" xml:space="preserve">
          <source>If the groupings in a regexp are nested, &lt;code&gt;$1&lt;/code&gt; gets the group with the leftmost opening parenthesis, &lt;code&gt;$2&lt;/code&gt; the next opening parenthesis,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b41f5fdfcf62fc4686ef889212a3544a4d2078" translate="yes" xml:space="preserve">
          <source>If the groupings in a regexp are nested, &lt;code&gt;$1&lt;/code&gt; gets the group with the leftmost opening parenthesis, &lt;code&gt;$2&lt;/code&gt; the next opening parenthesis, etc. Here is a regexp with nested groups:</source>
          <target state="translated">Если группировки в регулярном выражении вложены, &lt;code&gt;$1&lt;/code&gt; получает группу с самой левой открывающей скобкой, &lt;code&gt;$2&lt;/code&gt; - следующей открывающей скобкой и т. Д. Вот регулярное выражение с вложенными группами:</target>
        </trans-unit>
        <trans-unit id="ccea903e5c5ba097dd604b81034d2fccf458d781" translate="yes" xml:space="preserve">
          <source>If the gunzip program encounters a file containing multiple gzip files concatenated together it will automatically uncompress them all. The example below illustrates this behaviour</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7672fac594e6a7dd98d2bae0c51d24e5065e39e4" translate="yes" xml:space="preserve">
          <source>If the gzip FEXTRA header field is present it must conform to the sub-field structure as defined in RFC 1952.</source>
          <target state="translated">Если присутствует поле заголовка gzip FEXTRA,оно должно соответствовать структуре подполей,определенной в RFC 1952.</target>
        </trans-unit>
        <trans-unit id="948511a86fa3a757ed333c1057a05dc236b1ed7b" translate="yes" xml:space="preserve">
          <source>If the gzip header contains a comment field (FCOMMENT) it consists solely of ISO 8859-1 characters plus line-feed.</source>
          <target state="translated">Если заголовок gzip содержит поле комментария (FCOMMENT),то оно состоит исключительно из символов ISO 8859-1 плюс строчный поток.</target>
        </trans-unit>
        <trans-unit id="309f2d92f5e86ee4880748347a713d797525d1c3" translate="yes" xml:space="preserve">
          <source>If the gzip header contains a name field (FNAME) it consists solely of ISO 8859-1 characters.</source>
          <target state="translated">Если заголовок gzip содержит поле имени (FNAME),то оно состоит исключительно из символов ISO 8859-1.</target>
        </trans-unit>
        <trans-unit id="5ae4fed28b97ca4227cf5c00d60d4d6f2110ce60" translate="yes" xml:space="preserve">
          <source>If the hash is tied dispatches through to the SCALAR tied method, otherwise if the hash contains no keys returns 0, otherwise returns a mortal sv containing a string specifying the number of used buckets, followed by a slash, followed by the number of available buckets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76da98a8a76e4650e3f026f7c68c78b99cc6936b" translate="yes" xml:space="preserve">
          <source>If the hash is very large, you might not want to create a long list of keys. To save some memory, you can grab one key-value pair at a time using &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt;, which returns a pair you haven't seen yet:</source>
          <target state="translated">Если хэш очень большой, возможно, вы не захотите создавать длинный список ключей. Чтобы сэкономить память, вы можете захватить по одной паре ключ-значение за раз, используя &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; , который возвращает пару, которую вы еще не видели:</target>
        </trans-unit>
        <trans-unit id="80cd0158384418c000a070c2edb04e7bd8c177a8" translate="yes" xml:space="preserve">
          <source>If the hash is very large, you might not want to create a long list of keys. To save some memory, you can grab one key-value pair at a time using &lt;code&gt;each()&lt;/code&gt;, which returns a pair you haven't seen yet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb896d2cffead7d5fc78c0ddc9c3c52939333bc" translate="yes" xml:space="preserve">
          <source>If the hint provided is a subroutine, then &lt;code&gt;autodie&lt;/code&gt; will pass the complete return value to that subroutine. If the hint is any other value, then &lt;code&gt;autodie&lt;/code&gt; will smart-match against the value provided. In Perl 5.8.x there is no smart-match operator, and as such only subroutine hints are supported in these versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d353d642decb66a3abbcefcf79e58c99b0ba1e9" translate="yes" xml:space="preserve">
          <source>If the hook is an array reference, its first element must be a subroutine reference. This subroutine is called as above, but the first parameter is the array reference. This lets you indirectly pass arguments to the subroutine.</source>
          <target state="translated">Если крюк является ссылкой на массив,то его первым элементом должна быть ссылка на подпрограмму.Эта подпрограмма вызывается,как описано выше,но первым параметром является ссылка на массив.Это позволяет косвенно передавать аргументы в подпрограмму.</target>
        </trans-unit>
        <trans-unit id="75efff7a12e92261036612262090b64712859893" translate="yes" xml:space="preserve">
          <source>If the hook is an object, it must provide an &lt;code&gt;INC&lt;/code&gt; method that will be called as above, the first parameter being the object itself. (Note that you must fully qualify the sub's name, as unqualified &lt;code&gt;INC&lt;/code&gt; is always forced into package &lt;code&gt;main&lt;/code&gt;.) Here is a typical code layout:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="089781c4ed94b59afd45ade73f63dd3ae0adcf17" translate="yes" xml:space="preserve">
          <source>If the hook is an object, it must provide an INC method that will be called as above, the first parameter being the object itself. (Note that you must fully qualify the sub's name, as unqualified &lt;code&gt;INC&lt;/code&gt; is always forced into package &lt;code&gt;main&lt;/code&gt; .) Here is a typical code layout:</source>
          <target state="translated">Если ловушка является объектом, она должна предоставлять метод INC, который будет вызываться, как указано выше, причем первым параметром является сам объект. (Обратите внимание, что вы должны полностью указать имя подпрограммы, поскольку неквалифицированный &lt;code&gt;INC&lt;/code&gt; всегда принудительно помещается в &lt;code&gt;main&lt;/code&gt; пакета .) Вот типичный макет кода:</target>
        </trans-unit>
        <trans-unit id="dc5ac6730609a596bd949c3bb5ec01a23d4ffce0" translate="yes" xml:space="preserve">
          <source>If the initial value specified isn't part of a magical increment sequence (that is, a non-empty string matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; ), only the initial value will be returned. So the following will only return an alpha:</source>
          <target state="translated">Если указанное начальное значение не является частью магической последовательности приращения (то есть непустой строки, соответствующей &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; ), только начальное значение будет быть возвращенным. Таким образом, следующее будет возвращать только альфа:</target>
        </trans-unit>
        <trans-unit id="f20e6769b4c4dc9b5fc71b6e41306b51022683e2" translate="yes" xml:space="preserve">
          <source>If the initial value specified isn't part of a magical increment sequence (that is, a non-empty string matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt;), only the initial value will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1ecd771a78ded6bdca0c84c4a8624d300c4df7" translate="yes" xml:space="preserve">
          <source>If the initialization begins with &lt;code&gt;=&lt;/code&gt; , then it is output in the declaration for the input variable, replacing the initialization supplied by the typemap. If the initialization begins with &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; , then it is performed after all of the input variables have been declared. In the &lt;code&gt;;&lt;/code&gt; case the initialization normally supplied by the typemap is not performed. For the &lt;code&gt;+&lt;/code&gt; case, the declaration for the variable will include the initialization from the typemap. A global variable, &lt;code&gt;%v&lt;/code&gt; , is available for the truly rare case where information from one initialization is needed in another initialization.</source>
          <target state="translated">Если инициализация начинается с &lt;code&gt;=&lt;/code&gt; , то она выводится в объявлении для входной переменной, заменяя инициализацию, предоставленную картой типов. Если инициализация начинается с &lt;code&gt;;&lt;/code&gt; или &lt;code&gt;+&lt;/code&gt; , то выполняется после объявления всех входных переменных. В &lt;code&gt;;&lt;/code&gt; в случае, если инициализация, обычно предоставляемая картой типов, не выполняется. Для случая &lt;code&gt;+&lt;/code&gt; объявление переменной будет включать инициализацию из карты типов. Глобальная переменная &lt;code&gt;%v&lt;/code&gt; доступна для действительно редких случаев, когда информация из одной инициализации требуется при другой инициализации.</target>
        </trans-unit>
        <trans-unit id="ef3d32f84fa869f08148860d3a1b874f45f05bbf" translate="yes" xml:space="preserve">
          <source>If the initialization begins with &lt;code&gt;=&lt;/code&gt;, then it is output in the declaration for the input variable, replacing the initialization supplied by the typemap. If the initialization begins with &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;, then it is performed after all of the input variables have been declared. In the &lt;code&gt;;&lt;/code&gt; case the initialization normally supplied by the typemap is not performed. For the &lt;code&gt;+&lt;/code&gt; case, the declaration for the variable will include the initialization from the typemap. A global variable, &lt;code&gt;%v&lt;/code&gt;, is available for the truly rare case where information from one initialization is needed in another initialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a641a3d375c74024ce1445924cf66af681f41ebd" translate="yes" xml:space="preserve">
          <source>If the input code point's name has more than one synonym, they are returned joined into a single comma-separated string.</source>
          <target state="translated">Если имя точки входного кода имеет более одного синонима,то они возвращаются объединенными в единую строку,разделенную запятыми.</target>
        </trans-unit>
        <trans-unit id="9e071ed158601437a7fd928632778e71dc9740aa" translate="yes" xml:space="preserve">
          <source>If the input file/buffer contains multiple compressed data streams, this option will uncompress the whole lot as a single data stream.</source>
          <target state="translated">Если входной файл/буфер содержит несколько сжатых потоков данных,то эта опция распаковывает весь лот как один поток данных.</target>
        </trans-unit>
        <trans-unit id="3c582e01c3ed1134227361002db4abc5ef87f0a6" translate="yes" xml:space="preserve">
          <source>If the input is a buffer, &lt;code&gt;trailingData&lt;/code&gt; will return everything from the end of the compressed data stream to the end of the buffer.</source>
          <target state="translated">Если входом является буфер, &lt;code&gt;trailingData&lt;/code&gt; вернет все от конца потока сжатых данных до конца буфера.</target>
        </trans-unit>
        <trans-unit id="646ddea5cc7fe42fca7b5f673b48b7968e951a94" translate="yes" xml:space="preserve">
          <source>If the input is a filehandle, &lt;code&gt;trailingData&lt;/code&gt; will return the data that is left in the filehandle input buffer once the end of the compressed data stream has been reached. You can then use the filehandle to read the rest of the input file.</source>
          <target state="translated">Если входом является дескриптор файла, &lt;code&gt;trailingData&lt;/code&gt; вернет данные, которые остались во входном буфере дескриптора файла, как только будет достигнут конец потока сжатых данных. Затем вы можете использовать дескриптор файла для чтения остальной части входного файла.</target>
        </trans-unit>
        <trans-unit id="68ffb2242fbe49d90e0f353510f536b7c97b26ff" translate="yes" xml:space="preserve">
          <source>If the input is a gzip (RFC 1952) data stream, the following will be checked:</source>
          <target state="translated">Если вход является gzip (RFC 1952)потоком данных,будет проверено следующее:</target>
        </trans-unit>
        <trans-unit id="fbb62e9bad07668939b33bd6b3f35cbd2a29221c" translate="yes" xml:space="preserve">
          <source>If the input is an RFC 1950 data stream, the following will be checked:</source>
          <target state="translated">Если входной сигнал является потоком данных RFC 1950,будет проверено следующее:</target>
        </trans-unit>
        <trans-unit id="681895bf526e306295ee60c6f4d01df1e2e0e233" translate="yes" xml:space="preserve">
          <source>If the input is being interpreted as UTF-8 and a UTF-8 encoding error is encountered, an exception is generated.</source>
          <target state="translated">Если вход интерпретируется как UTF-8 и возникает ошибка кодирования UTF-8,генерируется исключение.</target>
        </trans-unit>
        <trans-unit id="3c3ba700c41877fa613cc375e9afc8a49773890d" translate="yes" xml:space="preserve">
          <source>If the input is unknown &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned in scalar context; an empty-list in list context. If the input is known, the number of elements in the list is returned if called in scalar context.</source>
          <target state="translated">Если вход неизвестен, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; возвращается в скалярном контексте; пустой список в контексте списка. Если входные данные известны, количество элементов в списке возвращается при вызове в скалярном контексте.</target>
        </trans-unit>
        <trans-unit id="a3761d436a5408df215f967b2c72bd018ebcc47f" translate="yes" xml:space="preserve">
          <source>If the input is unknown &lt;code&gt;undef&lt;/code&gt; is returned in scalar context; an empty-list in list context. If the input is known, the number of elements in the list is returned if called in scalar context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45a90c97d69c88324a18a4a975329202a110a46" translate="yes" xml:space="preserve">
          <source>If the input string is longer than needed, extra characters are ignored.</source>
          <target state="translated">Если входная строка длиннее,чем необходимо,лишние символы игнорируются.</target>
        </trans-unit>
        <trans-unit id="daec947152f5e00d64f719376318858935b663a6" translate="yes" xml:space="preserve">
          <source>If the input string is longer than needed, remaining characters are ignored.</source>
          <target state="translated">Если входная строка длиннее,чем необходимо,оставшиеся символы игнорируются.</target>
        </trans-unit>
        <trans-unit id="1a191161ccbd661c7961516bab02ad1f7aadb16a" translate="yes" xml:space="preserve">
          <source>If the interdependence of your &lt;code&gt;BOOT:&lt;/code&gt; section and Perl code is more complicated than this (e.g., the &lt;code&gt;BOOT:&lt;/code&gt; section makes calls to Perl functions which make calls to XSUBs with prototypes), get rid of the &lt;code&gt;BOOT:&lt;/code&gt; section altogether. Replace it with a function &lt;code&gt;onBOOT()&lt;/code&gt; , and call it like this:</source>
          <target state="translated">Если взаимозависимость раздела &lt;code&gt;BOOT:&lt;/code&gt; и кода Perl более сложна, чем эта (например, раздел &lt;code&gt;BOOT:&lt;/code&gt; вызывает функции Perl, которые вызывают XSUB с прототипами), полностью избавьтесь от раздела &lt;code&gt;BOOT:&lt;/code&gt; . Замените его функцией &lt;code&gt;onBOOT()&lt;/code&gt; и назовите так:</target>
        </trans-unit>
        <trans-unit id="baa35ea6f799cdc2c58744681c4a0f8490276128" translate="yes" xml:space="preserve">
          <source>If the interdependence of your &lt;code&gt;BOOT:&lt;/code&gt; section and Perl code is more complicated than this (e.g., the &lt;code&gt;BOOT:&lt;/code&gt; section makes calls to Perl functions which make calls to XSUBs with prototypes), get rid of the &lt;code&gt;BOOT:&lt;/code&gt; section altogether. Replace it with a function &lt;code&gt;onBOOT()&lt;/code&gt;, and call it like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2909f2e071daf0b882a5795cb2264aafaf8e4b0b" translate="yes" xml:space="preserve">
          <source>If the interpreter's &lt;code&gt;PL_exit_flags&lt;/code&gt; word has the &lt;code&gt;PERL_EXIT_DESTRUCT_END&lt;/code&gt; flag set, then this function will execute code in &lt;code&gt;END&lt;/code&gt; blocks before performing the rest of destruction. If it is desired to make any use of the interpreter between &lt;a href=&quot;#perl_parse&quot;&gt;&quot;perl_parse&quot;&lt;/a&gt; and &lt;a href=&quot;#perl_destruct&quot;&gt;&quot;perl_destruct&quot;&lt;/a&gt; other than just calling &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;&lt;/a&gt;, then this flag should be set early on. This matters if &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;&lt;/a&gt; will not be called, or if anything else will be done in addition to calling &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4475a90b24f7b1ba4a7b6ea113603191eff994" translate="yes" xml:space="preserve">
          <source>If the kernel set-id script feature isn't disabled, then any set-id script provides an exploitable vulnerability. Perl can't avoid being exploitable, but will point out vulnerable scripts where it can. If Perl detects that it is being applied to a set-id script then it will complain loudly that your set-id script is insecure, and won't run it. When Perl complains, you need to remove the set-id bit from the script to eliminate the vulnerability. Refusing to run the script doesn't in itself close the vulnerability; it is just Perl's way of encouraging you to do this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4a966e522ce068cba366c74c39330ba735c481" translate="yes" xml:space="preserve">
          <source>If the key does not exist the method returns 1.</source>
          <target state="translated">Если ключ не существует,метод возвращает 1.</target>
        </trans-unit>
        <trans-unit id="f85edef10f25d12c44c4dedc4c6946807ec9d900" translate="yes" xml:space="preserve">
          <source>If the label equals '-', then Concise will treat the bit as a raw bit and not try to display it symbolically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f74ad7c032adb69e8741c3ce089dbedf2af387c8" translate="yes" xml:space="preserve">
          <source>If the language handle has a &quot;fail&quot; attribute whose value is a coderef, then $lh-&amp;gt;maketext(</source>
          <target state="translated">Если дескриптор языка имеет атрибут &amp;laquo;fail&amp;raquo;, значение которого является coderef, тогда $ lh-&amp;gt; maketext (</target>
        </trans-unit>
        <trans-unit id="74b0a2c233bae54a5a0a22d4c6904ecf217ffcc9" translate="yes" xml:space="preserve">
          <source>If the language handle has no &quot;fail&quot; attribute, maketext will simply throw an exception (i.e., it calls &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, mentioning the</source>
          <target state="translated">Если язык ручка не имеет &amp;laquo;глючить&amp;raquo; атрибут, maketext будет просто выбросить исключение (то есть, он вызывает &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , упоминая</target>
        </trans-unit>
        <trans-unit id="ed178838d46c1e8b7a50a0bfb02973479dc8e58f" translate="yes" xml:space="preserve">
          <source>If the language handle has no &quot;fail&quot; attribute, maketext will simply throw an exception (i.e., it calls &lt;code&gt;die&lt;/code&gt;, mentioning the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c30b1f2ee79d6c9f16717998b6ca5cb7a43494" translate="yes" xml:space="preserve">
          <source>If the last definition is removed, then the DOS device name is also deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f576169bf47c87f2f0af12c0e2e1a4146c280c" translate="yes" xml:space="preserve">
          <source>If the last element of LIST does not end in a newline, the current script line number and input line number (if any) are also printed, and a newline is supplied. Note that the &quot;input line number&quot; (also known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to be currently in effect, and is also available as the special variable &lt;code&gt;$.&lt;/code&gt; . See &lt;a href=&quot;../perlvar#%24%2f&quot;&gt;$/ in perlvar&lt;/a&gt; and &lt;a href=&quot;../perlvar#%24.&quot;&gt;$. in perlvar&lt;/a&gt;.</source>
          <target state="translated">Если последний элемент LIST не заканчивается новой строкой, текущий номер строки сценария и номер строки ввода (если есть) также печатаются, и предоставляется новая строка. Обратите внимание, что &amp;laquo;номер строки ввода&amp;raquo; (также известный как &amp;laquo;кусок&amp;raquo;) зависит от того, какое понятие &amp;laquo;строка&amp;raquo; действует в настоящее время, и также доступен как специальная переменная &lt;code&gt;$.&lt;/code&gt; . Смотрите &lt;a href=&quot;../perlvar#%24%2f&quot;&gt;$ / в perlvar&lt;/a&gt; и &lt;a href=&quot;../perlvar#%24.&quot;&gt;$. в перлварь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ddf8780e7e7d9b3df1dc954871c1e6b0c532c31" translate="yes" xml:space="preserve">
          <source>If the last element of LIST does not end in a newline, the current script line number and input line number (if any) are also printed, and a newline is supplied. Note that the &quot;input line number&quot; (also known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to be currently in effect, and is also available as the special variable &lt;code&gt;$.&lt;/code&gt; . See &lt;a href=&quot;perlvar#%24%2f&quot;&gt;$/ in perlvar&lt;/a&gt; and &lt;a href=&quot;perlvar#%24.&quot;&gt;$. in perlvar&lt;/a&gt;.</source>
          <target state="translated">Если последний элемент LIST не заканчивается новой строкой, текущий номер строки сценария и номер строки ввода (если есть) также печатаются, и предоставляется новая строка. Обратите внимание, что &amp;laquo;номер строки ввода&amp;raquo; (также известный как &amp;laquo;кусок&amp;raquo;) зависит от того, какое понятие &amp;laquo;строка&amp;raquo; действует в настоящее время, и также доступен как специальная переменная &lt;code&gt;$.&lt;/code&gt; . Смотрите &lt;a href=&quot;perlvar#%24%2f&quot;&gt;$ / в perlvar&lt;/a&gt; и &lt;a href=&quot;perlvar#%24.&quot;&gt;$. в перлварь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65ccdf7ae6afe2d083d0de8afca0765301ad5a3c" translate="yes" xml:space="preserve">
          <source>If the left hand side is neither a package name nor an object, then the method call will cause an error, but see the section on &lt;a href=&quot;#Method-Call-Variations&quot;&gt;&quot;Method Call Variations&quot;&lt;/a&gt; for more nuances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90835049bf9dceb2b3128f6e0da3805c87bc497" translate="yes" xml:space="preserve">
          <source>If the left hand side is neither a package name nor an object, then the method call will cause an error, but see the section on &lt;a href=&quot;#Method-Call-Variations&quot;&gt;Method Call Variations&lt;/a&gt; for more nuances.</source>
          <target state="translated">Если левая часть не является ни именем пакета, ни объектом, то вызов метода вызовет ошибку, но дополнительные нюансы см. В разделе &amp;laquo; &lt;a href=&quot;#Method-Call-Variations&quot;&gt;Варианты вызова метода&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37bacecd2332508665ec81733fbdffa749ac5bfa" translate="yes" xml:space="preserve">
          <source>If the length of the input string is not even, it behaves as if padded by a null character at the end. Similarly, &quot;extra&quot; nybbles are ignored during unpacking.</source>
          <target state="translated">Если длина входной строки не равномерна,то она ведет себя так,как будто в ее конце присутствует нулевой символ.Аналогично,&quot;лишние&quot; узлы игнорируются при распаковке.</target>
        </trans-unit>
        <trans-unit id="88b7864a27a0577ffff54b7d555aea0617e9d505" translate="yes" xml:space="preserve">
          <source>If the length of the input string is not evenly divisible by 8, the remainder is packed as if the input string were padded by null characters at the end. Similarly during unpacking, &quot;extra&quot; bits are ignored.</source>
          <target state="translated">Если длина входной строки не делится равномерно на 8,то оставшаяся часть упаковывается так,как если бы входная строка была заполнена нулевыми символами в конце.Аналогично при распаковке игнорируются &quot;лишние&quot; биты.</target>
        </trans-unit>
        <trans-unit id="a2e67d3ea522ed96fe7a9c8431714f7f3d0ba5c5" translate="yes" xml:space="preserve">
          <source>If the library happens to be in a location not in &lt;code&gt;$Config{libpth}&lt;/code&gt; , you need:</source>
          <target state="translated">Если библиотека находится в месте, &lt;code&gt;$Config{libpth}&lt;/code&gt; , вам необходимо:</target>
        </trans-unit>
        <trans-unit id="c256d5d027a4accdcc167669a7812e5bf777ccbe" translate="yes" xml:space="preserve">
          <source>If the library happens to be in a location not in &lt;code&gt;$Config{libpth}&lt;/code&gt;, you need:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96118a855a2f1b2515701521249ef16334052e1f" translate="yes" xml:space="preserve">
          <source>If the line number is &lt;code&gt;.&lt;/code&gt;, sets a breakpoint on the current line:</source>
          <target state="translated">Если номер строки &lt;code&gt;.&lt;/code&gt; , устанавливает точку останова на текущей строке:</target>
        </trans-unit>
        <trans-unit id="94650250941df693d5a68b4ac245a935f3b9c2e5" translate="yes" xml:space="preserve">
          <source>If the list moderators tell you that you are not being civil, carefully consider how your words have appeared before responding in any way. Were they kind? You may protest, but repeated protest in the face of a repeatedly reaffirmed decision is not acceptable. Repeatedly protesting about the moderators' decisions regarding a third party is also unacceptable, as is continuing to initiate off-list contact with the moderators about their decisions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93c03970a56584f9fb61994432bc17cb7db5f12" translate="yes" xml:space="preserve">
          <source>If the list moderators tell you that you are not being civil, carefully consider how your words have appeared before responding in any way. You may protest, but repeated protest in the face of a repeatedly reaffirmed decision is not acceptable.</source>
          <target state="translated">Если модераторы списка скажут вам,что вы не вежливы,тщательно обдумайте,как ваши слова появились,прежде чем ответить каким-либо образом.Вы можете протестовать,но повторный протест перед лицом неоднократно подтвержденного решения не приемлем.</target>
        </trans-unit>
        <trans-unit id="e0a9f58b026642b9c9e8e7bb8deab3007d5236f6" translate="yes" xml:space="preserve">
          <source>If the locale from the user's environment is desired, there should be no need for XS code to set the locale except for &lt;code&gt;LC_NUMERIC&lt;/code&gt; , as perl has already set it up. XS code should avoid changing the locale, as it can adversely affect other, unrelated, code and may not be thread safe. However, some alien libraries that may be called do set it, such as &lt;code&gt;Gtk&lt;/code&gt; . This can cause problems for the perl core and other modules. Starting in v5.20.1, calling the function &lt;a href=&quot;perlapi#sync_locale&quot;&gt;sync_locale()&lt;/a&gt; from XS should be sufficient to avoid most of these problems. Prior to this, you need a pure Perl statement that does this:</source>
          <target state="translated">Если требуется языковой стандарт из пользовательской среды, в коде XS не должно быть необходимости устанавливать языковой стандарт, за исключением &lt;code&gt;LC_NUMERIC&lt;/code&gt; , поскольку perl уже установил его. Код XS должен избегать изменения локали, поскольку это может отрицательно повлиять на другой, не связанный с ним код и может быть небезопасным для потоков. Однако некоторые инопланетные библиотеки, которые могут быть вызваны, устанавливают его, например &lt;code&gt;Gtk&lt;/code&gt; . Это может вызвать проблемы для ядра Perl и других модулей. Начиная с v5.20.1, вызова функции &lt;a href=&quot;perlapi#sync_locale&quot;&gt;sync_locale ()&lt;/a&gt; из XS должно быть достаточно, чтобы избежать большинства этих проблем. До этого вам понадобится чистый оператор Perl, который сделает это:</target>
        </trans-unit>
        <trans-unit id="29cc247eadfeb453e1955bad0bbc5ed23022a753" translate="yes" xml:space="preserve">
          <source>If the locale from the user's environment is desired, there should be no need for XS code to set the locale except for &lt;code&gt;LC_NUMERIC&lt;/code&gt;, as perl has already set the others up. XS code should avoid changing the locale, as it can adversely affect other, unrelated, code and may not be thread-safe. To minimize problems, the macros &lt;a href=&quot;perlapi#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;&quot;STORE_LC_NUMERIC_SET_TO_NEEDED&quot; in perlapi&lt;/a&gt;, &lt;a href=&quot;perlapi#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot; in perlapi&lt;/a&gt;, and &lt;a href=&quot;perlapi#RESTORE_LC_NUMERIC&quot;&gt;&quot;RESTORE_LC_NUMERIC&quot; in perlapi&lt;/a&gt; should be used to affect any needed change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4664ee573739492d5623b9369f8faea69d271aa1" translate="yes" xml:space="preserve">
          <source>If the main thread exits while there are detached threads which are still running, then Perl's global destruction phase is not executed because otherwise certain global structures that control the operation of threads and that are allocated in the main thread's memory may get destroyed before the detached thread is destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823e97e3e713d61f96695c0b7d66500ba0535b81" translate="yes" xml:space="preserve">
          <source>If the make process encounters trouble with either compilation or linking then try setting the _C89_CCMODE to 1. Assuming sh is your login shell then run:</source>
          <target state="translated">Если в процессе make возникли проблемы с компиляцией или линковкой,попробуйте установить значение _C89_CCMODE равным 1.Предположим,что sh-это оболочка для входа в систему,после чего запустите ее:</target>
        </trans-unit>
        <trans-unit id="fa7d8db26880e3b2b83f69006312ed2e5013aabf" translate="yes" xml:space="preserve">
          <source>If the member name in the zip archive is not valid UTF-8 when this optionn is true, the script will die with an error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0119f182d57e85f55c259aad67e5507f5a71d506" translate="yes" xml:space="preserve">
          <source>If the method is called in scalar context, then it will try to extract exactly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae0fed8c834da6c72af01b4cce727e6b5ec751e" translate="yes" xml:space="preserve">
          <source>If the module &lt;code&gt;Module&lt;/code&gt; is already loaded, then the declaration</source>
          <target state="translated">Если модуль &lt;code&gt;Module&lt;/code&gt; уже загружен, то объявление</target>
        </trans-unit>
        <trans-unit id="1b3cd9a44d834ecaba373518cdced67ef6882e1c" translate="yes" xml:space="preserve">
          <source>If the module &lt;code&gt;Module&lt;/code&gt; is not loaded yet, then the above declaration declares functions func1() and func2() in the current package. When these functions are called, they load the package &lt;code&gt;Module&lt;/code&gt; if needed, and substitute themselves with the correct definitions.</source>
          <target state="translated">Если модуль &lt;code&gt;Module&lt;/code&gt; еще не загружен, то в приведенном выше объявлении объявляются функции func1 () и func2 () в текущем пакете. Когда эти функции вызываются, они загружают пакет &lt;code&gt;Module&lt;/code&gt; , если это необходимо, и заменяют себя правильными определениями.</target>
        </trans-unit>
        <trans-unit id="aa83e5ba98e2e00acddd7117050d321e4e9d54d9" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, &lt;code&gt;mark_as_loaded&lt;/code&gt; will carp about this and tell you from where the &lt;code&gt;PACKAGE&lt;/code&gt; has been loaded already.</source>
          <target state="translated">Если модуль уже загружен, &lt;code&gt;mark_as_loaded&lt;/code&gt; придирается к этому и сообщит вам, откуда &lt;code&gt;PACKAGE&lt;/code&gt; уже был загружен.</target>
        </trans-unit>
        <trans-unit id="e1cec740a866f3242f2245723f611d8e6a35a17e" translate="yes" xml:space="preserve">
          <source>If the module is already unloaded, &lt;code&gt;mark_as_unloaded&lt;/code&gt; will carp about this and tell you the &lt;code&gt;PACKAGE&lt;/code&gt; has been unloaded already.</source>
          <target state="translated">Если модуль уже выгружен, &lt;code&gt;mark_as_unloaded&lt;/code&gt; придирается к этому и сообщит вам, что &lt;code&gt;PACKAGE&lt;/code&gt; уже выгружен.</target>
        </trans-unit>
        <trans-unit id="55dd2ee6ad71be855cc8cea6dc45014e0de598b9" translate="yes" xml:space="preserve">
          <source>If the module is needed inside the</source>
          <target state="translated">Если модуль необходим внутри</target>
        </trans-unit>
        <trans-unit id="fab3a0f11307492451a39d88e9be980974dcb4d2" translate="yes" xml:space="preserve">
          <source>If the module will only be used inside a thread, you can try loading the module from inside the thread entry point function using &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; if needed):</source>
          <target state="translated">Если модуль будет использоваться только внутри потока, вы можете попробовать загрузить модуль изнутри функции точки входа потока, используя &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; (и &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; , если необходимо):</target>
        </trans-unit>
        <trans-unit id="b3aa735bc422b148dd84e6d085642a87f49e47ba" translate="yes" xml:space="preserve">
          <source>If the module will only be used inside a thread, you can try loading the module from inside the thread entry point function using &lt;code&gt;require&lt;/code&gt; (and &lt;code&gt;import&lt;/code&gt; if needed):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3b3934908dc77b79dcbb0b789e5b838d36463c" translate="yes" xml:space="preserve">
          <source>If the name is given in UTF-8, set this to &lt;code&gt;HVhek_UTF8&lt;/code&gt; . The value is passed direct as the parameter</source>
          <target state="translated">Если имя дано в UTF-8, установите для него значение &lt;code&gt;HVhek_UTF8&lt;/code&gt; . Значение передается напрямую как параметр</target>
        </trans-unit>
        <trans-unit id="873d55d8a257eaf7386c02b0cf4a9016781f6d23" translate="yes" xml:space="preserve">
          <source>If the name is given in UTF-8, set this to &lt;code&gt;HVhek_UTF8&lt;/code&gt;. The value is passed direct as the parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ddfa3306f944720376a989f9d5fd87c400eb47" translate="yes" xml:space="preserve">
          <source>If the name is omitted, format &quot;STDOUT&quot; is defined. A single &quot;.&quot; in column 1 is used to terminate a format. FORMLIST consists of a sequence of lines, each of which may be one of three types:</source>
          <target state="translated">Если имя опущено,определяется формат &quot;STDOUT&quot;.Одиночный &quot;...&quot; в колонке 1 используется для завершения формата.FORMLIST состоит из последовательности строк,каждая из которых может быть одного из трех типов:</target>
        </trans-unit>
        <trans-unit id="0def4cf3757d0553a2341afef733c2c0849f1052" translate="yes" xml:space="preserve">
          <source>If the name is unknown, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned (or an empty list in list context). Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt; &quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . This function does not recognize those in the input, returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. Nor are they included in the output as possible synonyms.</source>
          <target state="translated">Если имя неизвестно, возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (или пустой список в контексте списка). Обратите внимание, что Perl обычно распознает имена свойств в регулярных выражениях с необязательным &lt;code&gt;&quot;Is_&lt;/code&gt; &amp;raquo; (с подчеркиванием или без него), например &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . Эта функция не распознает входящие значения, возвращая &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Они также не включены в вывод как возможные синонимы.</target>
        </trans-unit>
        <trans-unit id="88548ac66c76967c7a6bd845c8445fe8da2c6437" translate="yes" xml:space="preserve">
          <source>If the name is unknown, &lt;code&gt;undef&lt;/code&gt; is returned (or an empty list in list context). Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt;&quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt;. This function does not recognize those in the input, returning &lt;code&gt;undef&lt;/code&gt;. Nor are they included in the output as possible synonyms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a79bb3cadb8f975e939ef18071a526a4b5d3363e" translate="yes" xml:space="preserve">
          <source>If the named parameter &lt;code&gt;config_override&lt;/code&gt; is specified, it should be a reference to a hash which contains all information usually found in &lt;code&gt;%Config::Config&lt;/code&gt; . For example, you can obtain the configuration information for a separate perl installation and pass that in.</source>
          <target state="translated">Если указан именованный параметр &lt;code&gt;config_override&lt;/code&gt; , он должен быть ссылкой на хэш, который содержит всю информацию, обычно находящуюся в &lt;code&gt;%Config::Config&lt;/code&gt; . Например, вы можете получить информацию о конфигурации для отдельной установки Perl и передать ее.</target>
        </trans-unit>
        <trans-unit id="455e39c93d939d0a811460c9e6eb8b61291c4896" translate="yes" xml:space="preserve">
          <source>If the named parameter &lt;code&gt;config_override&lt;/code&gt; is specified, it should be a reference to a hash which contains all information usually found in &lt;code&gt;%Config::Config&lt;/code&gt;. For example, you can obtain the configuration information for a separate perl installation and pass that in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3ef5746e8cd5bab310439aa50dba89f545a584" translate="yes" xml:space="preserve">
          <source>If the named parameter &lt;code&gt;skip_cwd&lt;/code&gt; is true, the current directory &lt;code&gt;.&lt;/code&gt; will be stripped from &lt;code&gt;@INC&lt;/code&gt; before searching for .packlists. This keeps ExtUtils::Installed from finding modules installed in other perls that happen to be located below the current directory.</source>
          <target state="translated">Если именованный параметр &lt;code&gt;skip_cwd&lt;/code&gt; равен true, текущий каталог &lt;code&gt;.&lt;/code&gt; будут удалены из &lt;code&gt;@INC&lt;/code&gt; перед поиском .packlists. Это не позволяет ExtUtils :: Installed найти модули, установленные в других perl, которые оказались ниже текущего каталога.</target>
        </trans-unit>
        <trans-unit id="7f6facbdb87684a56df7a20a0d54e6b8073b8eb9" translate="yes" xml:space="preserve">
          <source>If the new version of the C library is ABI-compatible (that's Application Binary Interface compatible) with the version you're upgrading from, and if the shared library version didn't change, no re-compilation should be necessary.</source>
          <target state="translated">Если новая версия библиотеки Си является ABI-совместимой (это бинарный интерфейс приложения)с той версией,с которой вы обновляете,и если версия разделяемой библиотеки не изменилась,повторная компиляция не требуется.</target>
        </trans-unit>
        <trans-unit id="3f6451aaf2bf86188eece8b63b5bab6c7257462f" translate="yes" xml:space="preserve">
          <source>If the next character is in (or extends into) the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if</source>
          <target state="translated">Если следующий символ находится в следующем фрагменте вводимого текста (или расширяется в него),то будет прочитан следующий фрагмент.Обычно текущий фрагмент отбрасывается одновременно,но если</target>
        </trans-unit>
        <trans-unit id="1f73682ad19692885d11822d4f6d7cb69031b04a" translate="yes" xml:space="preserve">
          <source>If the next character is in (or extends into) the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; bit set, then the current chunk will not be discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a6672795e23362230912b4b8b4e28fb661f0a19" translate="yes" xml:space="preserve">
          <source>If the number consists of digits only, JSON::PP will try to represent it as an integer value. If that fails, it will try to represent it as a numeric (floating point) value if that is possible without loss of precision. Otherwise it will preserve the number as a string value (in which case you lose roundtripping ability, as the JSON number will be re-encoded to a JSON string).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf7862ebb65f1805f38240d9ec3614885b02e6ad" translate="yes" xml:space="preserve">
          <source>If the number following the backslash is N (in decimal), and Perl already has seen N capture groups, Perl considers this a backreference. Otherwise, it considers it an octal escape. If N has more than three digits, Perl takes only the first three for the octal escape; the rest are matched as is.</source>
          <target state="translated">Если число,следующее за обратной косой чертой,равно N (в десятичном значении),и Perl уже видел N групп захвата,Perl считает это обратной ссылкой.В противном случае,он считает это восьмеричным бегством.Если N имеет более трех цифр,Perl берет только первые три для восьмеричного бегства;остальные совпадают как есть.</target>
        </trans-unit>
        <trans-unit id="fad0df49da49393094ec039045da70fce50b5429" translate="yes" xml:space="preserve">
          <source>If the number of data bytes ($bytes) is given, that many data bytes are included in the ping packet sent to the remote host. The number of data bytes is ignored if the protocol is &quot;tcp&quot;. The minimum (and default) number of data bytes is 1 if the protocol is &quot;udp&quot; and 0 otherwise. The maximum number of data bytes that can be specified is 1024.</source>
          <target state="translated">Если задано количество байт данных ($байт),то это количество байт данных включается в пакет ping,посылаемый удаленному хосту.Количество байт данных игнорируется,если протокол &quot;tcp&quot;.Минимальное (и по умолчанию)количество байт данных равно 1,если протокол &quot;udp&quot;,и 0 в противном случае.Максимальное задаваемое количество байтов данных-1024.</target>
        </trans-unit>
        <trans-unit id="173b84764a7ba838f6e1039dc98cb544515aa621" translate="yes" xml:space="preserve">
          <source>If the number of data bytes (&lt;code&gt;bytes&lt;/code&gt;) is given, that many data bytes are included in the ping packet sent to the remote host. The number of data bytes is ignored if the protocol is &quot;tcp&quot;. The minimum (and default) number of data bytes is 1 if the protocol is &quot;udp&quot; and 0 otherwise. The maximum number of data bytes that can be specified is 65535, but staying below the MTU (1472 bytes for ICMP) is recommended. Many small devices cannot deal with fragmented ICMP packets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea88b95c30f8557b60611e6fa0d52e56ecf8669" translate="yes" xml:space="preserve">
          <source>If the number of partitions on the disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34b4bc1598422e778b8ed9662906c7efb975344" translate="yes" xml:space="preserve">
          <source>If the number of scalars in the left-hand list is greater than that in the left-hand list, the &quot;missing&quot; scalars will become undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c7831330bbfcd31669c32d53f7a76b28d963cd" translate="yes" xml:space="preserve">
          <source>If the number of scalars in the left-hand list is less than that in the right-hand list, the &quot;extra&quot; scalars in the right-hand list will simply not be assigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf726231b3d599cdbe46b108046dbf7815381c4c" translate="yes" xml:space="preserve">
          <source>If the object has been passed to a child process during a fork, the file will be deleted when the object goes out of scope in the parent.</source>
          <target state="translated">Если объект был передан дочернему процессу во время работы развилки,файл будет удален,когда объект выйдет из-под контроля родительского процесса.</target>
        </trans-unit>
        <trans-unit id="39e52d92c6b313ed3349d0401be82f80d273536a" translate="yes" xml:space="preserve">
          <source>If the only casing for a code point is locale-dependent, then the returned hash will not have any of the base keys, like &lt;code&gt;code&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , etc., but will contain only locale keys.</source>
          <target state="translated">Если единственный регистр для кодовой точки зависит от языкового стандарта, то возвращаемый хэш не будет иметь никаких базовых ключей, таких как &lt;code&gt;code&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; и т. Д., Но будет содержать только ключи языкового стандарта.</target>
        </trans-unit>
        <trans-unit id="4285420e25852376bd4b42fe10dbce58fa32d6ad" translate="yes" xml:space="preserve">
          <source>If the only casing for a code point is locale-dependent, then the returned hash will not have any of the base keys, like &lt;code&gt;code&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, etc., but will contain only locale keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17fa159e601e547a6489ad99ba45fba36084dad4" translate="yes" xml:space="preserve">
          <source>If the only comparison needed is whether an installed module is of a sufficiently high version, a direct test may be done using the string form of &lt;code&gt;eval&lt;/code&gt; and the &lt;code&gt;use&lt;/code&gt; function. For example, for module &lt;code&gt;$mod&lt;/code&gt; and version prerequisite &lt;code&gt;$prereq&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51d5a9ae61f6c29388fc414c6297a691764547b" translate="yes" xml:space="preserve">
          <source>If the operand is a reference to a blessed object, then the name of the class into which the referent is blessed will be returned. &lt;code&gt;ref&lt;/code&gt; doesn't care what the physical type of the referent is; blessing takes precedence over such concerns. Beware that exact comparison of &lt;code&gt;ref&lt;/code&gt; results against a class name doesn't perform a class membership test: a class's members also include objects blessed into subclasses, for which &lt;code&gt;ref&lt;/code&gt; will return the name of the subclass. Also beware that class names can clash with the built-in type names (described below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7623f1bb883be3a3b5a21de5d5644725c26daefe" translate="yes" xml:space="preserve">
          <source>If the operand is a reference to an unblessed object, then the return value indicates the type of object. If the unblessed referent is not a scalar, then the return value will be one of the strings &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt;, &lt;code&gt;CODE&lt;/code&gt;, &lt;code&gt;FORMAT&lt;/code&gt;, or &lt;code&gt;IO&lt;/code&gt;, indicating only which kind of object it is. If the unblessed referent is a scalar, then the return value will be one of the strings &lt;code&gt;SCALAR&lt;/code&gt;, &lt;code&gt;VSTRING&lt;/code&gt;, &lt;code&gt;REF&lt;/code&gt;, &lt;code&gt;GLOB&lt;/code&gt;, &lt;code&gt;LVALUE&lt;/code&gt;, or &lt;code&gt;REGEXP&lt;/code&gt;, depending on the kind of value the scalar currently has. But note that &lt;code&gt;qr//&lt;/code&gt; scalars are created already blessed, so &lt;code&gt;ref qr/.../&lt;/code&gt; will likely return &lt;code&gt;Regexp&lt;/code&gt;. Beware that these built-in type names can also be used as class names, so &lt;code&gt;ref&lt;/code&gt; returning one of these names doesn't unambiguously indicate that the referent is of the kind to which the name refers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa1ec170d0d4fcfcfbbdd9dd518a1d70b552ce0" translate="yes" xml:space="preserve">
          <source>If the operand is not a reference, then the empty string will be returned. An empty string will only be returned in this situation. &lt;code&gt;ref&lt;/code&gt; is often useful to just test whether a value is a reference, which can be done by comparing the result to the empty string. It is a common mistake to use the result of &lt;code&gt;ref&lt;/code&gt; directly as a truth value: this goes wrong because &lt;code&gt;0&lt;/code&gt; (which is false) can be returned for a reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="addcad10a864d1cffc4846608d394fea1feac09a" translate="yes" xml:space="preserve">
          <source>If the operands to a binary bitwise op are strings of different sizes, &lt;b&gt;|&lt;/b&gt; and &lt;b&gt;^&lt;/b&gt; ops act as though the shorter operand had additional zero bits on the right, while the &lt;b&gt;&amp;amp;&lt;/b&gt; op acts as though the longer operand were truncated to the length of the shorter. The granularity for such extension or truncation is one or more bytes.</source>
          <target state="translated">Если операнды двоичной поразрядной операции являются строками разного размера, &lt;b&gt;| &lt;/b&gt;и &lt;b&gt;^&lt;/b&gt; ops действуют так, как если бы более короткий операнд имел дополнительные нулевые биты справа, в то время как &lt;b&gt;&amp;amp;&lt;/b&gt; op действует так, как если бы более длинный операнд был усечен до длины более короткого. Гранулярность такого расширения или усечения составляет один или несколько байтов.</target>
        </trans-unit>
        <trans-unit id="c7870bd3c024159f240305b7047279e21ad1fe56" translate="yes" xml:space="preserve">
          <source>If the operating system supports it (for example BSD derived systems), the filehandle will be opened with O_EXLOCK (open with exclusive file lock). This can sometimes cause problems if the intention is to pass the filename to another system that expects to take an exclusive lock itself (such as DBD::SQLite) whilst ensuring that the tempfile is not reused. In this situation the &quot;EXLOCK&quot; option can be passed to tempfile. By default EXLOCK will be true (this retains compatibility with earlier releases).</source>
          <target state="translated">Если операционная система его поддерживает (например,производные системы BSD),то файловый менеджер будет открыт с помощью O_EXLOCK (открывается с эксклюзивной блокировкой файлов).Иногда это может вызвать проблемы,если намерение состоит в том,чтобы передать имя файла другой системе,которая рассчитывает взять эксклюзивную блокировку сама (например,DBD::SQLite),при этом гарантируя,что временный файл не будет использован повторно.В этой ситуации в temp-файл может быть передан параметр &quot;EXLOCK&quot;.По умолчанию EXLOCK будет верна (это сохраняет совместимость с более ранними версиями).</target>
        </trans-unit>
        <trans-unit id="e19b7bb4d69a3c985ce8931960025916d3561c3a" translate="yes" xml:space="preserve">
          <source>If the operation being timed out is system() or qx(), this technique is liable to generate zombies. If this matters to you, you'll need to do your own fork() and exec(), and kill the errant child process.</source>
          <target state="translated">Если выполняемая операция имеет тайм-аут-system()или qx(),то эта техника может генерировать зомби.Если это имеет значение для вас,вам нужно будет сделать свою собственную fork()и exec(),и убить заблудший дочерний процесс.</target>
        </trans-unit>
        <trans-unit id="05f4a71ea34fe9d7ddbd210db5290a2dfa223838" translate="yes" xml:space="preserve">
          <source>If the operation shown is &quot;ToFold&quot;, it means that case-insensitive matching in a regular expression was done on the code point.</source>
          <target state="translated">Если показанная операция &quot;ToFold&quot;,то это означает,что над точкой кода было произведено нечувствительное к регистру совпадение в регулярном выражении.</target>
        </trans-unit>
        <trans-unit id="3ba42937f598291497eafce66d29e91aabe688c5" translate="yes" xml:space="preserve">
          <source>If the optimization can not be applied, this returns undef. If it can be applied, this method returns a hash reference containing the following information:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a982ec5add551174c87d54c0c75cad924249147a" translate="yes" xml:space="preserve">
          <source>If the option destination is a reference to a hash, the option will take, as value, strings of the form</source>
          <target state="translated">Если назначение опции является ссылкой на хэш,опция будет принимать в качестве значения строки формы</target>
        </trans-unit>
        <trans-unit id="ab8a370e734c2b7f25ad3475fabaef52fd095ddb" translate="yes" xml:space="preserve">
          <source>If the option is provided, and &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; is NOT set, then a value of '0' implies &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; and any other value implies &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt; .</source>
          <target state="translated">Если опция предоставляется, а &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; НЕ установлен, то значение &amp;laquo;0&amp;raquo; подразумевает &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; , а любое другое значение подразумевает &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d707532b21b034988218d78dc5dd2089b91f3ef" translate="yes" xml:space="preserve">
          <source>If the option is provided, and &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; is NOT set, then a value of '0' implies &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; and any other value implies &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb774833de734f7b65efa56e3c7c5f53234542f8" translate="yes" xml:space="preserve">
          <source>If the option is set to false, the output buffer in the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method will be truncated before uncompressed data is written to it.</source>
          <target state="translated">Если для параметра установлено значение false, выходной буфер в методе &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; будет усечен перед записью в него несжатых данных.</target>
        </trans-unit>
        <trans-unit id="a7e5a140437039036cbeabf084c8f96c887a93f7" translate="yes" xml:space="preserve">
          <source>If the option is set to true, uncompressed data will be appended to the output buffer by the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method.</source>
          <target state="translated">Если для параметра установлено значение true, несжатые данные будут добавлены в выходной буфер методом &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c22c2720bbc793b56d2bdb2031cd852762e79aba" translate="yes" xml:space="preserve">
          <source>If the option is set to true, uncompressed data will be appended to the output buffer in the &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; and &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; methods.</source>
          <target state="translated">Если для параметра установлено значение true, несжатые данные будут добавлены в выходной буфер методами &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; и &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="943c28148863687139f9e45e03407da89d7e13fa" translate="yes" xml:space="preserve">
          <source>If the option value is required, Getopt::Long will take the command line argument that follows the option and assign this to the option variable. If, however, the option value is specified as optional, this will only be done if that value does not look like a valid command line option itself.</source>
          <target state="translated">Если требуется значение опции,то Getopt::Long примет аргумент командной строки,следующий за опцией,и присвоит его переменной опции.Однако,если значение опции указано как необязательное,это будет сделано только в том случае,если это значение не выглядит как действительная опция командной строки.</target>
        </trans-unit>
        <trans-unit id="8b25fc0c82dd37f9c4b9d7996e6e001cd8c1c22e" translate="yes" xml:space="preserve">
          <source>If the order of &lt;code&gt;sv_setiv&lt;/code&gt; and &lt;code&gt;sv_setpv&lt;/code&gt; had been reversed, then the macro &lt;code&gt;SvPOK_on&lt;/code&gt; would need to be called instead of &lt;code&gt;SvIOK_on&lt;/code&gt; .</source>
          <target state="translated">Если бы порядок &lt;code&gt;sv_setiv&lt;/code&gt; и &lt;code&gt;sv_setpv&lt;/code&gt; был изменен на противоположный, то &lt;code&gt;SvPOK_on&lt;/code&gt; нужно было бы &lt;code&gt;SvIOK_on&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2507fa462b26287b008669ac5e4307de24ce4d06" translate="yes" xml:space="preserve">
          <source>If the order of &lt;code&gt;sv_setiv&lt;/code&gt; and &lt;code&gt;sv_setpv&lt;/code&gt; had been reversed, then the macro &lt;code&gt;SvPOK_on&lt;/code&gt; would need to be called instead of &lt;code&gt;SvIOK_on&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b0f391156a0e1896106ec41b93d3c42cc8fd48b" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; already contains a value (typically from a previous eval) that value is reused after appending &lt;code&gt;&quot;\t...propagated&quot;&lt;/code&gt; . This is useful for propagating exceptions:</source>
          <target state="translated">Если вывод пуст и &lt;code&gt;$@&lt;/code&gt; уже содержит значение (обычно из предыдущего eval), это значение используется повторно после добавления &lt;code&gt;&quot;\t...propagated&quot;&lt;/code&gt; . Это полезно для распространения исключений:</target>
        </trans-unit>
        <trans-unit id="25d81dad12165191ac2a4d2f3e667fda9ababd8e" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; already contains a value (typically from a previous eval) that value is used after appending &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; to &lt;code&gt;$@&lt;/code&gt; . This is useful for staying almost, but not entirely similar to &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если вывод пуст и &lt;code&gt;$@&lt;/code&gt; уже содержит значение (обычно из предыдущего eval), это значение используется после добавления &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; к &lt;code&gt;$@&lt;/code&gt; . Это полезно, чтобы оставаться почти, но не совсем похожим на &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65e420bc5858eb45a1dddd4a10cb455bd1ce4cc1" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; already contains a value (typically from a previous eval) that value is used after appending &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; to &lt;code&gt;$@&lt;/code&gt; . This is useful for staying almost, but not entirely similar to &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если вывод пуст и &lt;code&gt;$@&lt;/code&gt; уже содержит значение (обычно из предыдущего eval), это значение используется после добавления &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; к &lt;code&gt;$@&lt;/code&gt; . Это полезно, чтобы оставаться почти, но не совсем похожим на &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cfa46357b1516decacabae244126181d8b80b21" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; contains an object reference that has a &lt;code&gt;PROPAGATE&lt;/code&gt; method, that method will be called with additional file and line number parameters. The return value replaces the value in &lt;code&gt;$@&lt;/code&gt; ; i.e., as if &lt;code&gt;$@ = &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; were called.</source>
          <target state="translated">Если вывод пуст и &lt;code&gt;$@&lt;/code&gt; содержит ссылку на объект, имеющую метод &lt;code&gt;PROPAGATE&lt;/code&gt; , этот метод будет вызываться с дополнительными параметрами номера файла и строки. Возвращаемое значение заменяет значение в &lt;code&gt;$@&lt;/code&gt; ; т.е. как если бы &lt;code&gt;$@ = &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; были названы.</target>
        </trans-unit>
        <trans-unit id="a97492155e7589378bb301645dfa7c34b680ef04" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; contains an object reference that has a &lt;code&gt;PROPAGATE&lt;/code&gt; method, that method will be called with additional file and line number parameters. The return value replaces the value in &lt;code&gt;$@&lt;/code&gt; ; i.e., as if &lt;code&gt;$@ = &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; were called.</source>
          <target state="translated">Если вывод пуст и &lt;code&gt;$@&lt;/code&gt; содержит ссылку на объект, имеющую метод &lt;code&gt;PROPAGATE&lt;/code&gt; , этот метод будет вызываться с дополнительными параметрами номера файла и строки. Возвращаемое значение заменяет значение в &lt;code&gt;$@&lt;/code&gt; ; т.е. как если бы &lt;code&gt;$@ = &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; были названы.</target>
        </trans-unit>
        <trans-unit id="4e71a254b15b38644afabad82376b2bb1e4f7fab" translate="yes" xml:space="preserve">
          <source>If the output of the &lt;code&gt;h h&lt;/code&gt; command (or any command, for that matter) scrolls past your screen, precede the command with a leading pipe symbol so that it's run through your pager, as in</source>
          <target state="translated">Если вывод команды &lt;code&gt;h h&lt;/code&gt; (или любой другой команды, если на то пошло) прокручивается за пределы вашего экрана, поставьте перед командой начальный символ вертикальной черты, чтобы она проходила через ваш пейджер, как в</target>
        </trans-unit>
        <trans-unit id="f7911c6fed712fb085afb893540153d04c3ba2b2" translate="yes" xml:space="preserve">
          <source>If the package has a mailing list, include a URL or subscription instructions here.</source>
          <target state="translated">Если пакет имеет список рассылки,включите сюда URL-адрес или инструкции по подписке.</target>
        </trans-unit>
        <trans-unit id="2bd5efd382acc87571dd747451ad45f157dd85d7" translate="yes" xml:space="preserve">
          <source>If the package has a web site, include a URL here.</source>
          <target state="translated">Если в пакете есть веб-сайт,укажите здесь URL.</target>
        </trans-unit>
        <trans-unit id="128d72462f8fdf7586cd07b73dc9169d6e753911" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, &lt;code&gt;U+FFFE&lt;/code&gt; has a minimal primary weight. The comparison between &lt;code&gt;&quot;$a1\x{FFFE}$a2&quot;&lt;/code&gt; and &lt;code&gt;&quot;$b1\x{FFFE}$b2&quot;&lt;/code&gt; first compares &lt;code&gt;$a1&lt;/code&gt; and &lt;code&gt;$b1&lt;/code&gt; at level 1, and then &lt;code&gt;$a2&lt;/code&gt; and &lt;code&gt;$b2&lt;/code&gt; at level 1, as followed.</source>
          <target state="translated">Если значение параметра истинно, &lt;code&gt;U+FFFE&lt;/code&gt; имеет минимальный первичный вес. При сравнении &lt;code&gt;&quot;$a1\x{FFFE}$a2&quot;&lt;/code&gt; и &lt;code&gt;&quot;$b1\x{FFFE}$b2&quot;&lt;/code&gt; сначала сравниваются &lt;code&gt;$a1&lt;/code&gt; и &lt;code&gt;$b1&lt;/code&gt; на уровне 1, а затем &lt;code&gt;$a2&lt;/code&gt; и &lt;code&gt;$b2&lt;/code&gt; на уровне 1, как показано ниже. .</target>
        </trans-unit>
        <trans-unit id="c1bc1d540aa212d81d3c27835031fe5adbb0eee1" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, &lt;code&gt;U+FFFF&lt;/code&gt; has a highest primary weight. When a boolean of &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; and &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; is true, it is expected that &lt;code&gt;$str&lt;/code&gt; begins with &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , or another primary equivalent. &lt;code&gt;$str&lt;/code&gt; may be &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; , &lt;code&gt;&quot;abc012&quot;&lt;/code&gt; , but should not include &lt;code&gt;U+FFFF&lt;/code&gt; such as &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt; .</source>
          <target state="translated">Если значение параметра истинно, &lt;code&gt;U+FFFF&lt;/code&gt; имеет наивысший первичный вес. Когда логическое значение &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; и &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; истинно, ожидается, что &lt;code&gt;$str&lt;/code&gt; начинается с &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , или другой основной эквивалент. &lt;code&gt;$str&lt;/code&gt; может быть &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; , &lt;code&gt;&quot;abc012&quot;&lt;/code&gt; , но не должно включать &lt;code&gt;U+FFFF&lt;/code&gt; , например &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd592631134dd93dfb6509b2405e1e6bdddd05d2" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, &lt;code&gt;U+FFFF&lt;/code&gt; has a highest primary weight. When a boolean of &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; and &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; is true, it is expected that &lt;code&gt;$str&lt;/code&gt; begins with &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, or another primary equivalent. &lt;code&gt;$str&lt;/code&gt; may be &lt;code&gt;&quot;abcd&quot;&lt;/code&gt;, &lt;code&gt;&quot;abc012&quot;&lt;/code&gt;, but should not include &lt;code&gt;U+FFFF&lt;/code&gt; such as &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2379a678967ce11b206cce9256eec402c626744e" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, a final, tie-breaking level is used. If no difference of weights is found after the comparison through all the level specified by &lt;code&gt;level&lt;/code&gt; , the comparison with code points will be performed. For the tie-breaking comparison, the sort key has code points of the original string appended. Completely ignorable characters are not ignored.</source>
          <target state="translated">Если для параметра установлено значение &amp;laquo;Истина&amp;raquo;, используется последний уровень разрешения конфликтов. Если после сравнения по всему уровню, заданному &lt;code&gt;level&lt;/code&gt; , разница весов не обнаружена , будет выполнено сравнение с кодовыми точками. Для сравнения с разрывом связей к ключу сортировки добавлены кодовые точки исходной строки. Совершенно игнорируемые персонажи не игнорируются.</target>
        </trans-unit>
        <trans-unit id="cf3801fdcc987b0c168aed25eff11116ed2d9d13" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, a final, tie-breaking level is used. If no difference of weights is found after the comparison through all the level specified by &lt;code&gt;level&lt;/code&gt;, the comparison with code points will be performed. For the tie-breaking comparison, the sort key has code points of the original string appended. Completely ignorable characters are not ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d70ed0cf4279c5cf91d7d6890341737c51d4df" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, accents (and other primary ignorable characters) are ignored, even though cases are taken into account.</source>
          <target state="translated">Если параметр становится верным,то акценты (и другие первичные незнакомые символы)игнорируются,даже если учитываются случаи.</target>
        </trans-unit>
        <trans-unit id="3ffce08d047eaee75c853cd8ab3be63e13efe5a7" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, for a contraction with three or more characters (here nicknamed &quot;long contraction&quot;), initial substrings will be handled. For example, a contraction ABC, where A is a starter, and B and C are non-starters (character with non-zero combining character class), will be detected even if there is not AB as a contraction.</source>
          <target state="translated">Если параметр становится истинным,то для сокращения с тремя или более символами (здесь прозвище &quot;длинное сокращение&quot;)будут обрабатываться исходные подстроки.Например,сокращение ABC,где A является стартером,а B и C не являются стартерами (символ с ненулевым комбинационным классом символов),будет обнаружено даже в том случае,если в качестве сокращения отсутствует AB.</target>
        </trans-unit>
        <trans-unit id="6196ed90d85a5642d1f2bff307d9850731d3ee76" translate="yes" xml:space="preserve">
          <source>If the parameters to the INCLUDE: keyword are followed by a pipe (&lt;code&gt;|&lt;/code&gt;) then the compiler will interpret the parameters as a command. This feature is mildly deprecated in favour of the &lt;code&gt;INCLUDE_COMMAND:&lt;/code&gt; directive, as documented below.</source>
          <target state="translated">Если после параметров ключевого слова INCLUDE: стоит вертикальная черта ( &lt;code&gt;|&lt;/code&gt; ), то компилятор интерпретирует параметры как команду. Эта функция слегка устарела в пользу директивы &lt;code&gt;INCLUDE_COMMAND:&lt;/code&gt; , как описано ниже.</target>
        </trans-unit>
        <trans-unit id="60984150a4a273c37051fdd1024089806a686df1" translate="yes" xml:space="preserve">
          <source>If the parent process is killed (either using Perl's kill() builtin, or using some external means) all the pseudo-processes are killed as well, and the whole process exits.</source>
          <target state="translated">Если убить родительский процесс (либо с помощью Perl's kill()builtin,либо с помощью некоторых внешних средств),то будут убиты и все псевдо-процессы,и весь процесс выйдет из игры.</target>
        </trans-unit>
        <trans-unit id="aa64f5b5dc3063c1ec88bf3714d6a78f8885563e" translate="yes" xml:space="preserve">
          <source>If the pattern contains embedded code, such as</source>
          <target state="translated">Если шаблон содержит встроенный код,например</target>
        </trans-unit>
        <trans-unit id="c8e637c05d0476b3ff64dcc72c39f7a79e3a588a" translate="yes" xml:space="preserve">
          <source>If the pattern contains its delimiter within it, that delimiter must be escaped. Prefixing it with a backslash (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400ab285c2500104132be9cd3fcc1a752df8a4f5" translate="yes" xml:space="preserve">
          <source>If the pattern does not match any pathname, then bsd_glob() returns a list consisting of only the pattern. If &lt;code&gt;GLOB_QUOTE&lt;/code&gt; is set, its effect is present in the pattern returned.</source>
          <target state="translated">Если шаблон не соответствует ни одному пути, то bsd_glob () возвращает список, состоящий только из шаблона. Если &lt;code&gt;GLOB_QUOTE&lt;/code&gt; установлен, его эффект присутствует в возвращаемом шаблоне.</target>
        </trans-unit>
        <trans-unit id="6adde583f90fd2399e3928b4e6217841c09c97fb" translate="yes" xml:space="preserve">
          <source>If the pattern may match only at a handful of places, with &lt;code&gt;TYPE&lt;/code&gt; being &lt;code&gt;SBOL&lt;/code&gt; , &lt;code&gt;MBOL&lt;/code&gt; , or &lt;code&gt;GPOS&lt;/code&gt; . See the table below.</source>
          <target state="translated">Если шаблон может совпадать только в нескольких местах, где &lt;code&gt;TYPE&lt;/code&gt; является &lt;code&gt;SBOL&lt;/code&gt; , &lt;code&gt;MBOL&lt;/code&gt; или &lt;code&gt;GPOS&lt;/code&gt; . См. Таблицу ниже.</target>
        </trans-unit>
        <trans-unit id="40469f0b5b6e999f3b3f0091f7983d3535304a67" translate="yes" xml:space="preserve">
          <source>If the pattern may match only at a handful of places, with &lt;code&gt;TYPE&lt;/code&gt; being &lt;code&gt;SBOL&lt;/code&gt;, &lt;code&gt;MBOL&lt;/code&gt;, or &lt;code&gt;GPOS&lt;/code&gt;. See the table below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0ce5cbb841f39a51912df72d9768f6a6a5fae33" translate="yes" xml:space="preserve">
          <source>If the pattern was used as follows</source>
          <target state="translated">Если бы шаблон использовался следующим образом</target>
        </trans-unit>
        <trans-unit id="2dd05fadef47c4bd45462fdfaa94e04afc77ad22" translate="yes" xml:space="preserve">
          <source>If the performance in such cases is unacceptable, you may defer the actual writing, and then have it done all at once. The following loop will perform much better for large files:</source>
          <target state="translated">Если исполнение в таких случаях неприемлемо,вы можете отложить фактическое написание,а затем сделать все это сразу.Следующий цикл будет работать гораздо лучше для больших файлов:</target>
        </trans-unit>
        <trans-unit id="956656b1b2d0c77e2fbe4d0d92677dc48070a8ed" translate="yes" xml:space="preserve">
          <source>If the platform is MS-DOS like and normally does CRLF to &quot;\n&quot; translation for text files then the default layers are :</source>
          <target state="translated">Если платформа MS-DOS нравится и обычно выполняет перевод CRLF на &quot;\n&quot; для текстовых файлов,то слоями по умолчанию являются :</target>
        </trans-unit>
        <trans-unit id="5f1c5a6b0ba8f7ba98047b8fb60cfdcca7e45034" translate="yes" xml:space="preserve">
          <source>If the platform is MS-DOS like and normally does CRLF to &quot;\n&quot; translation for text files then the default layers are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee788dad0c5b1cd15e2fa5ddb122d4f9bd910af" translate="yes" xml:space="preserve">
          <source>If the platform supports the &lt;code&gt;langinfo(CODESET)&lt;/code&gt; interface, the codeset returned is used as the default encoding for the open pragma.</source>
          <target state="translated">Если платформа поддерживает интерфейс &lt;code&gt;langinfo(CODESET)&lt;/code&gt; , возвращаемый набор кодов используется в качестве кодировки по умолчанию для открытой директивы.</target>
        </trans-unit>
        <trans-unit id="e029b7bfe44b40ce79cdafd38dd9f57646af8f39" translate="yes" xml:space="preserve">
          <source>If the program exits without all threads having either been joined or detached, then a warning will be issued.</source>
          <target state="translated">Если при выходе из программы все потоки не были ни присоединены,ни отсоединены,то будет выдано предупреждение.</target>
        </trans-unit>
        <trans-unit id="68122aab68b9511758161a833aab14bd7cf8f3f4" translate="yes" xml:space="preserve">
          <source>If the program exits without all threads having either been joined or detached, then this warning will be issued.</source>
          <target state="translated">Если при выходе из программы все потоки не были ни присоединены,ни отсоединены,то выдается данное предупреждение.</target>
        </trans-unit>
        <trans-unit id="3f05e0c9adcc7343a41a8d24201ee4c19ce64a54" translate="yes" xml:space="preserve">
          <source>If the program has been given to perl via the switches &lt;code&gt;-e&lt;/code&gt; or &lt;code&gt;-E&lt;/code&gt; , &lt;code&gt;$0&lt;/code&gt; will contain the string &lt;code&gt;&quot;-e&quot;&lt;/code&gt; .</source>
          <target state="translated">Если программа была передана Perl с помощью ключей &lt;code&gt;-e&lt;/code&gt; или &lt;code&gt;-E&lt;/code&gt; , &lt;code&gt;$0&lt;/code&gt; будет содержать строку &lt;code&gt;&quot;-e&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b296afa5e8ade3ba3ac78a9d465e171ac5067f8" translate="yes" xml:space="preserve">
          <source>If the program has been given to perl via the switches &lt;code&gt;-e&lt;/code&gt; or &lt;code&gt;-E&lt;/code&gt;, &lt;code&gt;$0&lt;/code&gt; will contain the string &lt;code&gt;&quot;-e&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187d3c3b9917db708f6b4997f1f577493d56ad38" translate="yes" xml:space="preserve">
          <source>If the program is syntactically correct, it is executed. If the program runs off the end without hitting an exit() or die() operator, an implicit &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt; is provided to indicate successful completion.</source>
          <target state="translated">Если программа синтаксически верна, она выполняется. Если программа запускается с конца без нажатия на оператор exit () или die (), предоставляется неявный &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt; , указывающий на успешное завершение.</target>
        </trans-unit>
        <trans-unit id="c7da837d3689d8811d08d5a2ade1a1a152e04568" translate="yes" xml:space="preserve">
          <source>If the program is syntactically correct, it is executed. If the program runs off the end without hitting an exit() or die() operator, an implicit &lt;code&gt;exit(0)&lt;/code&gt; is provided to indicate successful completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf82d5604429bbfe1cb41298b645fa1f014e9ae" translate="yes" xml:space="preserve">
          <source>If the property doesn't have such a restricted set, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если для свойства нет такого ограниченного набора, возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f561839327dfb379f3ced83b14775ceeeefed09a" translate="yes" xml:space="preserve">
          <source>If the property doesn't have such a restricted set, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f736ee647a4d5e1589838b72f5b05af7545714ad" translate="yes" xml:space="preserve">
          <source>If the property name is unknown, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt; &quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . This function does not recognize those in the property parameter, returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если имя свойства неизвестно, возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что Perl обычно распознает имена свойств в регулярных выражениях с дополнительным &lt;code&gt;&quot;Is_&lt;/code&gt; &amp;raquo; (с подчеркиванием или без него), например &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . Эта функция не распознает те, что указаны в параметре свойства, возвращая &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8e6c1687e04cb1c576cc3de9ba670b370bee76a" translate="yes" xml:space="preserve">
          <source>If the property name is unknown, &lt;code&gt;undef&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt;&quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt;. This function does not recognize those in the property parameter, returning &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afaf0816b79f3c9b4d1b468e6b1d9a01691cd781" translate="yes" xml:space="preserve">
          <source>If the protocol is set to &quot;tcp&quot;, this method may be called any number of times, and each call to the ping() method (below) will use the most recent $local_addr. If the protocol is &quot;icmp&quot; or &quot;udp&quot;, then bind() must be called at most once per object, and (if it is called at all) must be called before the first call to ping() for that object.</source>
          <target state="translated">Если протокол установлен в &quot;tcp&quot;,то этот метод может быть вызван любое количество раз,и при каждом вызове метода ping()(см.ниже)будет использоваться самый последний $local_addr.Если протокол &quot;icmp&quot; или &quot;udp&quot;,то bind()должна вызываться максимум один раз для каждого объекта и (если вызывается вообще)должна вызываться перед первым вызовом ping()для этого объекта.</target>
        </trans-unit>
        <trans-unit id="bd278d79ed04376a1ab23bc38f3813d0d8a95858" translate="yes" xml:space="preserve">
          <source>If the prototypes are enabled, you can disable it locally for a given XSUB as in the following example:</source>
          <target state="translated">Если прототипы включены,вы можете отключить его локально для данного XSUB,как показано в следующем примере:</target>
        </trans-unit>
        <trans-unit id="22222d2992db775cc93f4e6df7a745c81e01a6be" translate="yes" xml:space="preserve">
          <source>If the referenced object has been blessed into a package, then that package name is returned instead. But don't use that, as it's now considered &quot;bad practice&quot;. For one reason, an object could be using a class called &lt;code&gt;Regexp&lt;/code&gt; or &lt;code&gt;IO&lt;/code&gt; , or even &lt;code&gt;HASH&lt;/code&gt; . Also, &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; doesn't take into account subclasses, like &lt;code&gt;isa&lt;/code&gt; does.</source>
          <target state="translated">Если указанный объект был добавлен в пакет, вместо этого возвращается это имя пакета. Но не используйте это, так как теперь это считается &amp;laquo;плохой практикой&amp;raquo;. По одной причине, объект мог использовать класс под названием &lt;code&gt;Regexp&lt;/code&gt; или &lt;code&gt;IO&lt;/code&gt; , даже &lt;code&gt;HASH&lt;/code&gt; . Кроме того, &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; не учитывает подклассы, как это делает &lt;code&gt;isa&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf268542a8929b7e398cc1536659093d140d5216" translate="yes" xml:space="preserve">
          <source>If the referenced object has been blessed into a package, then that package name is returned instead. But don't use that, as it's now considered &quot;bad practice&quot;. For one reason, an object could be using a class called &lt;code&gt;Regexp&lt;/code&gt; or &lt;code&gt;IO&lt;/code&gt; , or even &lt;code&gt;HASH&lt;/code&gt; . Also, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; doesn't take into account subclasses, like &lt;code&gt;isa&lt;/code&gt; does.</source>
          <target state="translated">Если указанный объект был добавлен в пакет, вместо этого возвращается это имя пакета. Но не используйте это, так как теперь это считается &amp;laquo;плохой практикой&amp;raquo;. По одной причине, объект мог использовать класс под названием &lt;code&gt;Regexp&lt;/code&gt; или &lt;code&gt;IO&lt;/code&gt; , даже &lt;code&gt;HASH&lt;/code&gt; . Кроме того, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; не учитывает подклассы, как это делает &lt;code&gt;isa&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09e68bc71ae659a158de263698e821903752a759" translate="yes" xml:space="preserve">
          <source>If the referred library is an archive library, then it is treated as a simple collection of .o modules (all of which must contain PIC). These modules are then linked into the shared library.</source>
          <target state="translated">Если упомянутая библиотека является архивной,то она рассматривается как простая коллекция .o модулей (все они должны содержать PIC).Эти модули затем связываются в общую библиотеку.</target>
        </trans-unit>
        <trans-unit id="487c69f3c32cf6208263be856047bd1120b5cb11" translate="yes" xml:space="preserve">
          <source>If the regex engine was entered, the output may look like this:</source>
          <target state="translated">Если был введен регрессивный двигатель,то выходной сигнал может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="4071da6362bfae97335d6ccd04527e0675ca1ecf" translate="yes" xml:space="preserve">
          <source>If the remote server sends data a byte at time, and you need that data immediately without waiting for a newline (which might not happen), you may wish to replace the &lt;code&gt;while&lt;/code&gt; loop in the parent with the following:</source>
          <target state="translated">Если удаленный сервер отправляет данные байт во время, и вам необходимо , чтобы данные сразу , не дожидаясь новой строки (которая не может произойти), вы можете заменить &lt;code&gt;while&lt;/code&gt; цикл в родительском со следующими:</target>
        </trans-unit>
        <trans-unit id="78e886a06c0d6c64ae06980c39f4979b0d06c657" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;*&lt;/code&gt; , the offset is relative to the start of the packed string.</source>
          <target state="translated">Если счетчик повторов &lt;code&gt;*&lt;/code&gt; , смещение отсчитывается относительно начала упакованной строки.</target>
        </trans-unit>
        <trans-unit id="0c6d8ab738d17a47ddcc7210024698f2d723ba66" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;*&lt;/code&gt;, the offset is relative to the start of the packed string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71535d2706781140ebf79d95c5c1eb0328f89697" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;0&lt;/code&gt; , it's relative to the current position.</source>
          <target state="translated">Если счетчик повторов равен &lt;code&gt;0&lt;/code&gt; , он относительно текущей позиции.</target>
        </trans-unit>
        <trans-unit id="8bb595e18165255d40d28696ced7cb987361acca" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;0&lt;/code&gt;, it's relative to the current position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adddd684b7b4b320c5c6cd3d4e144f8d42b00be2" translate="yes" xml:space="preserve">
          <source>If the requested class doesn't yet exist, this function will still succeed, and return &lt;code&gt;[ $classname ]&lt;/code&gt;</source>
          <target state="translated">Если запрошенный класс еще не существует, эта функция все равно завершится успешно и вернет &lt;code&gt;[ $classname ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3c8df40676c5ef413c4d428cc8bce1edd4a74be" translate="yes" xml:space="preserve">
          <source>If the required version is older than Perl 5.10, the &quot;:default&quot; feature bundle is automatically loaded instead.</source>
          <target state="translated">Если требуемая версия старше,чем Perl 5.10,вместо нее автоматически загружается набор функций &quot;:default&quot;.</target>
        </trans-unit>
        <trans-unit id="d407bfa98e92001cef51aaea080c36419318c881" translate="yes" xml:space="preserve">
          <source>If the result is a fraction, it is converted into a floating point number to the accuracy of your platform.</source>
          <target state="translated">Если результат является дробью,то он преобразуется в число с плавающей точкой в точности вашей платформы.</target>
        </trans-unit>
        <trans-unit id="a0f32bf4dd5015a300ddb6707d47fae5eba9e46c" translate="yes" xml:space="preserve">
          <source>If the result is multiple script names, they are returned joined into a single comma-separated string.</source>
          <target state="translated">Если в результате получается несколько имен скриптов,то они возвращаются объединенными в одну строку,разделенную запятыми.</target>
        </trans-unit>
        <trans-unit id="45ec7fbff805996e6714524f94283d541160e6c3" translate="yes" xml:space="preserve">
          <source>If the return type of the XSUB includes &lt;code&gt;static&lt;/code&gt; , the method is considered to be a static method. It will call the C++ function using the class::method() syntax. If the method is not static the function will be called using the THIS-&amp;gt;method() syntax.</source>
          <target state="translated">Если тип возвращаемого значения XSUB включает &lt;code&gt;static&lt;/code&gt; , метод считается статическим. Он вызовет функцию C ++ с использованием синтаксиса class :: method (). Если метод не статический, функция будет вызываться с использованием синтаксиса THIS-&amp;gt; method ().</target>
        </trans-unit>
        <trans-unit id="b467c0c1883d9fa2c1ada74a10e9d69505846ac1" translate="yes" xml:space="preserve">
          <source>If the return type of the XSUB includes &lt;code&gt;static&lt;/code&gt;, the method is considered to be a static method. It will call the C++ function using the class::method() syntax. If the method is not static the function will be called using the THIS-&amp;gt;method() syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b11488412f3e860557eb1891af20655d0de0fe4" translate="yes" xml:space="preserve">
          <source>If the return value of reval() is (or contains) any code reference, those code references are wrapped to be themselves executed always in the compartment. See &lt;a href=&quot;#wrap_code_refs_within&quot;&gt;&quot;wrap_code_refs_within&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ff7ce638cb043eea1113e455241d4090a0ba15" translate="yes" xml:space="preserve">
          <source>If the return value of reval() is (or contains) any code reference, those code references are wrapped to be themselves executed always in the compartment. See &lt;a href=&quot;#wrap_code_refs_within&quot;&gt;wrap_code_refs_within&lt;/a&gt;.</source>
          <target state="translated">Если возвращаемое значение reval () представляет собой (или содержит) какую-либо ссылку на код, эти ссылки кода помещаются в оболочку, чтобы сами всегда выполняться в отсеке. См. &lt;a href=&quot;#wrap_code_refs_within&quot;&gt;Wrap_code_refs_within&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b5b2e1517f57a24f52793e2d523bf3e3916b624" translate="yes" xml:space="preserve">
          <source>If the revision (previously &quot;tracking version&quot;) number of UCA is given, behavior of that revision is emulated on collating. If omitted, the return value of &lt;code&gt;UCA_Version()&lt;/code&gt; is used.</source>
          <target state="translated">Если указан номер ревизии (ранее &amp;laquo;отслеживаемая версия&amp;raquo;) UCA, поведение этой ревизии эмулируется при сопоставлении. Если не указано, используется возвращаемое значение &lt;code&gt;UCA_Version()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a7a3bfd506eaa3a5969fb39449cbd90048c5cd5" translate="yes" xml:space="preserve">
          <source>If the right argument is an expression rather than a search pattern, substitution, or transliteration, it is interpreted as a search pattern at run time. Note that this means that its contents will be interpolated twice, so</source>
          <target state="translated">Если правильным аргументом является выражение,а не шаблон поиска,подстановка или транслитерация,то он интерпретируется как шаблон поиска во время выполнения.Обратите внимание,что это означает,что его содержимое будет дважды интерполировано,поэтому</target>
        </trans-unit>
        <trans-unit id="397d47eee4fc1ac1405170a336868a5dec199f77" translate="yes" xml:space="preserve">
          <source>If the same C type is used in several different contexts which require different translations, &lt;code&gt;typedef&lt;/code&gt; several new types mapped to this C type, and create separate</source>
          <target state="translated">Если один и тот же тип C используется в нескольких разных контекстах, требующих разных переводов, &lt;code&gt;typedef&lt;/code&gt; несколько новых типов, сопоставленных с этим типом C, и создайте отдельные</target>
        </trans-unit>
        <trans-unit id="456756c29fcce7da570891f767727aa9e1c8ea70" translate="yes" xml:space="preserve">
          <source>If the same character (or a sequence of characters) exists in the collation element table through &lt;code&gt;table&lt;/code&gt; , mapping to collation elements is overridden. If it does not exist, the mapping is defined additionally.</source>
          <target state="translated">Если такой же символ (или последовательность символов) существует в таблице элементов сопоставления через &lt;code&gt;table&lt;/code&gt; , сопоставление с элементами сопоставления переопределяется. Если его нет, отображение определяется дополнительно.</target>
        </trans-unit>
        <trans-unit id="e4dde7b413bfb31794120513bb19ebe90728fd10" translate="yes" xml:space="preserve">
          <source>If the same character (or a sequence of characters) exists in the collation element table through &lt;code&gt;table&lt;/code&gt;, mapping to collation elements is overridden. If it does not exist, the mapping is defined additionally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="250b229660b09d1a93cecb0077c43fdb021bc44f" translate="yes" xml:space="preserve">
          <source>If the scalar contains a number the raw SV will be leaner.</source>
          <target state="translated">Если скаляр содержит число,то сырое SV будет беднее.</target>
        </trans-unit>
        <trans-unit id="129cba7aa8d1059953f619ec45963493064daafb" translate="yes" xml:space="preserve">
          <source>If the scalar from the previous example had an extra reference:</source>
          <target state="translated">Если скаляр из предыдущего примера имел дополнительную ссылку:</target>
        </trans-unit>
        <trans-unit id="942a6cfe1787a0e79c2fbf6e9025269b48593e53" translate="yes" xml:space="preserve">
          <source>If the script says that your package is incomplete, and asks whether to continue, just answer with Y (this can only happen if you don't use long filenames or forget to issue &quot;set FNCASE=y&quot; first).</source>
          <target state="translated">Если скрипт говорит,что ваш пакет неполный,и спрашивает,продолжать ли его,просто ответьте Y (это может произойти только в том случае,если вы не используете длинные имена файлов или забыли сначала выдать &quot;set FNCASE=y&quot;).</target>
        </trans-unit>
        <trans-unit id="1ebc636a0a5f78fe0991b4d30678c7a47413c67b" translate="yes" xml:space="preserve">
          <source>If the second argument to a piped &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; contains shell metacharacters, perl &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;s, then &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;s a shell to decode the metacharacters and eventually run the desired program. If the program couldn't be run, it's the shell that gets the message, not Perl. All your Perl program can find out is whether the shell itself could be successfully started. You can still capture the shell's STDERR and check it for error messages. See &lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3f&quot;&gt;How can I capture STDERR from an external command?&lt;/a&gt; elsewhere in this document, or use the &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt; module.</source>
          <target state="translated">Если второй аргумент конвейерной функции &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; содержит метасимволы оболочки, perl &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; s, затем &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; sa shell для декодирования метасимволов и, в конечном итоге, запуска желаемой программы. Если программа не может быть запущена, сообщение получает оболочка, а не Perl. Все, что ваша программа на Perl может узнать, это то, можно ли успешно запустить оболочку. Вы все еще можете захватить STDERR оболочки и проверить его на наличие сообщений об ошибках. См. &lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3f&quot;&gt;Как захватить STDERR с помощью внешней команды?&lt;/a&gt; в другом месте в этом документе или используйте модуль &lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c86f791ed05e6400ffb0303d6157f674dcf38a9" translate="yes" xml:space="preserve">
          <source>If the second argument to a piped &lt;code&gt;open()&lt;/code&gt; contains shell metacharacters, perl &lt;code&gt;fork()&lt;/code&gt;s, then &lt;code&gt;exec()&lt;/code&gt;s a shell to decode the metacharacters and eventually run the desired program. If the program couldn't be run, it's the shell that gets the message, not Perl. All your Perl program can find out is whether the shell itself could be successfully started. You can still capture the shell's STDERR and check it for error messages. See &lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3F&quot;&gt;&quot;How can I capture STDERR from an external command?&quot;&lt;/a&gt; elsewhere in this document, or use the &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a485d6980d01df96f56ec659ef159a6f3e30c7c" translate="yes" xml:space="preserve">
          <source>If the second operand has a &quot;nomethod&quot; method then use that.</source>
          <target state="translated">Если второй операнд имеет метод &quot;нометода&quot;,то используйте его.</target>
        </trans-unit>
        <trans-unit id="d89fc930c903cfb2489602dfe78fa395aab16a02" translate="yes" xml:space="preserve">
          <source>If the second parameter (a boolean) is omitted or false, the decomposition is canonical decomposition; if the second parameter (a boolean) is true, the decomposition is compatibility decomposition.</source>
          <target state="translated">Если второй параметр (булевый)опущен или ложный,то декомпозиция является канонической;если второй параметр (булевый)верен,то декомпозиция является декомпозицией совместимости.</target>
        </trans-unit>
        <trans-unit id="cdc3a4f8b493e77f4b46b059968dc0b38f7409ec" translate="yes" xml:space="preserve">
          <source>If the selected element is outside the string, the value 0 is returned. If an element off the end of the string is written to, Perl will first extend the string with sufficiently many zero bytes. It is an error to try to write off the beginning of the string (i.e., negative OFFSET).</source>
          <target state="translated">Если выбранный элемент находится вне строки,возвращается значение 0.Если элемент,находящийся вне конца строки,записан,то Perl сначала расширит строку на достаточное количество нулевых байт.Ошибкой является попытка списания начала строки (т.е.отрицательный OFFSET).</target>
        </trans-unit>
        <trans-unit id="a0efffe8f3cec0c66bc0076cfbf0d0f016059fa0" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will block until either the semaphore's count is greater than or equal to the amount you're &lt;code&gt;down&lt;/code&gt;ing the semaphore's count by, or until the timeout is reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08309d3b072967d3ab275a7c77649be9b9f2f474" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will block until such time as the semaphore's count is greater than or equal to the amount you're &lt;code&gt;down&lt;/code&gt; ing the semaphore's count by.</source>
          <target state="translated">Если счетчик семафора упадет ниже нуля, этот метод будет блокироваться до тех пор, пока счетчик семафора не станет больше или равен величине, на которую вы &lt;code&gt;down&lt;/code&gt; счетчик семафора.</target>
        </trans-unit>
        <trans-unit id="083a8e90721e210cc119c4e7060a13485c79131e" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will block until such time as the semaphore's count is greater than or equal to the amount you're &lt;code&gt;down&lt;/code&gt;ing the semaphore's count by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49cf6efaba2d8b062462556a6172122cd62a7391" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will return</source>
          <target state="translated">Если количество семафоров упадет ниже нуля,этот метод вернет</target>
        </trans-unit>
        <trans-unit id="43da8fe1e0dfe354dcb09a89c8401b1d0438aefd" translate="yes" xml:space="preserve">
          <source>If the sequence contains a single code point which is unassigned to a character in the version of Unicode being used, the function will return TRUE, and the script will be &lt;code&gt;SCX_Unknown&lt;/code&gt;. Any other combination of unassigned code points in the input sequence will result in the function treating the input as not being a script run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecadb78dff58886929648354bb050576d1075181" translate="yes" xml:space="preserve">
          <source>If the sequence is empty, TRUE is returned, but &lt;code&gt;*ret_script&lt;/code&gt; (if asked for) will be &lt;code&gt;SCX_INVALID&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feaf413a0792a40fde39688dd7794f1b79d23f9d" translate="yes" xml:space="preserve">
          <source>If the shareable image isn't in any of these places, you'll need to define a logical name</source>
          <target state="translated">Если разделяемое изображение не находится ни в одном из этих мест,вам нужно будет определить логическое имя</target>
        </trans-unit>
        <trans-unit id="34b3b705ebfb832784afae8421a8cf44e644e9c0" translate="yes" xml:space="preserve">
          <source>If the socket is in a connected state, the peer address is returned. If the socket is not in a connected state, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d77daa474d5b520bbe270f2db415132f8e51945" translate="yes" xml:space="preserve">
          <source>If the socket is in a connected state, the peer address is returned. If the socket is not in a connected state, undef is returned.</source>
          <target state="translated">Если сокет находится в подключенном состоянии,то возвращается одноранговый адрес.Если сокет не находится в состоянии подключения,возвращается адрес undef.</target>
        </trans-unit>
        <trans-unit id="bc839afaf75ab77ac378c573dd37cfe67fada222" translate="yes" xml:space="preserve">
          <source>If the source number can be represented in the target form, that representation is used.</source>
          <target state="translated">Если исходный номер может быть представлен в целевой форме,то используется это представление.</target>
        </trans-unit>
        <trans-unit id="ad2456e62439e41ca828e4d7a559faef86d9a12f" translate="yes" xml:space="preserve">
          <source>If the source number is between two numbers representable in the target form, a representation of one of these numbers is used. (</source>
          <target state="translated">Если исходный номер находится между двумя числами,представленными в целевой форме,то используется представление одного из этих номеров.(</target>
        </trans-unit>
        <trans-unit id="5807a3edb0534ce60ac2857df2fbffa4467c6e15" translate="yes" xml:space="preserve">
          <source>If the source number is outside of the limits representable in the target form, a representation of the closest limit is used. (</source>
          <target state="translated">Если номер источника находится вне пределов,представляемых в целевой форме,то используется представление о ближайшем пределе.(</target>
        </trans-unit>
        <trans-unit id="a2b6fc7f507aeb4c29a8733766d6c6136c45fda9" translate="yes" xml:space="preserve">
          <source>If the special input filename &quot;&quot;, &quot;-&quot; or &quot;&amp;lt;&amp;amp;STDIN&quot; is given then the STDIN filehandle is used for input (and no open or close is performed). If no input filename is specified then &quot;-&quot; is implied. Filehandle references, or objects that support the regular IO operations (like &lt;code&gt;&amp;lt;$fh&amp;gt;&lt;/code&gt; or &lt;code&gt;$fh-&amp;lt;Egt&lt;/code&gt;getline&amp;gt;) are also accepted; the handles must already be opened.</source>
          <target state="translated">Если задано специальное имя файла ввода &amp;laquo;&amp;raquo;, &amp;laquo;-&amp;raquo; или &amp;laquo;&amp;lt;&amp;amp; STDIN&amp;raquo;, то для ввода используется дескриптор файла STDIN (и ни открытие, ни закрытие не выполняется). Если имя входного файла не указано, подразумевается &amp;laquo;-&amp;raquo;. Ссылки на дескрипторы файлов или объекты, поддерживающие обычные операции ввода-вывода (например, &lt;code&gt;&amp;lt;$fh&amp;gt;&lt;/code&gt; или &lt;code&gt;$fh-&amp;lt;Egt&lt;/code&gt; getline&amp;gt;), также принимаются; ручки уже должны быть открыты.</target>
        </trans-unit>
        <trans-unit id="3247f1e5568a45232c218d52498138f8657c71b9" translate="yes" xml:space="preserve">
          <source>If the specification of the class was not completely valid, the message indicates that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec8f0307ac0cd29be9e31e20412d0003c85f12a" translate="yes" xml:space="preserve">
          <source>If the standard options aren't enough, you may want to subclass Pod::Simple::XHMTL. These are the most likely candidates for methods you'll want to override when subclassing.</source>
          <target state="translated">Если стандартных опций недостаточно,вы можете использовать подкласс Pod::Simple::XHMTL.Это наиболее вероятные кандидатуры для методов,которые вы захотите переопределить при подклассификации.</target>
        </trans-unit>
        <trans-unit id="c57481fa08ceb2f9368092d11351ebd6c6865947" translate="yes" xml:space="preserve">
          <source>If the string can not be interpreted, NaN is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc03084e4b347434da04ee646a45ae6dc9795b98" translate="yes" xml:space="preserve">
          <source>If the string exception does not end in a newline, the current script line number and input line number (if any) and a newline are appended to it. Note that the &quot;input line number&quot; (also known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to be currently in effect, and is also available as the special variable &lt;a href=&quot;perlvar#%24.&quot;&gt;&lt;code&gt;$.&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&quot;$/&quot; in perlvar&lt;/a&gt; and &lt;a href=&quot;perlvar#%24.&quot;&gt;&quot;$.&quot; in perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61afcdbf0b63afa329f8dddf52dc441cb7c93f4b" translate="yes" xml:space="preserve">
          <source>If the string happens to be encoded as UTF-8 internally (and thus has the UTF8 flag set), &lt;a href=&quot;#vec-EXPR%2COFFSET%2CBITS&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt; tries to convert it to use a one-byte-per-character internal representation. However, if the string contains characters with values of 256 or higher, a fatal error will occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c4f5fed91805150d0fb1f5cc265445f3719afe" translate="yes" xml:space="preserve">
          <source>If the string happens to be encoded as UTF-8 internally (and thus has the UTF8 flag set), this is ignored by &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, and it operates on the internal byte string, not the conceptual character string, even if you only have characters with values less than 256.</source>
          <target state="translated">Если строка внутренне закодирована как UTF-8 (и, таким образом, имеет установленный флаг UTF8), &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; игнорирует это и работает с внутренней байтовой строкой, а не с концептуальной символьной строкой, даже если у вас есть только символы с значения меньше 256.</target>
        </trans-unit>
        <trans-unit id="e46f7dff46b6e909ca2a4c0f1cd989e3474f6367" translate="yes" xml:space="preserve">
          <source>If the string happens to be encoded as UTF-8 internally (and thus has the UTF8 flag set), this is ignored by &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, and it operates on the internal byte string, not the conceptual character string, even if you only have characters with values less than 256.</source>
          <target state="translated">Если строка внутренне закодирована как UTF-8 (и, таким образом, имеет установленный флаг UTF8), &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; игнорирует это и работает с внутренней байтовой строкой, а не с концептуальной символьной строкой, даже если у вас есть только символы с значения меньше 256.</target>
        </trans-unit>
        <trans-unit id="7652f3d26c3d783ee2b0cdbd7edb6550d6506acc" translate="yes" xml:space="preserve">
          <source>If the string has a &quot;0b&quot; prefix, it is interpreted as a binary number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ff0fdfcd38431066beb5169d3e97b3f28b4513" translate="yes" xml:space="preserve">
          <source>If the string has a &quot;0x&quot; prefix, it is interpreted as a hexadecimal number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556906a3727707516e15ba62fe70b3006b4bd52d" translate="yes" xml:space="preserve">
          <source>If the string is just one character in length, the Unicode numeric value is returned if it has one, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise. Note that this need not be a whole number. &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt; , for example returns -0.5.</source>
          <target state="translated">Если длина строки составляет всего один символ, возвращается числовое значение Unicode, если оно есть, или &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в противном случае. Обратите внимание, что это не обязательно целое число. &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt; , например, возвращает -0,5.</target>
        </trans-unit>
        <trans-unit id="4fce93c48f5e7099a349c6ef5a41848fb5f748c7" translate="yes" xml:space="preserve">
          <source>If the string is just one character in length, the Unicode numeric value is returned if it has one, or &lt;code&gt;undef&lt;/code&gt; otherwise. If the optional scalar ref is passed, it would be set to 1 if the return is valid; or 0 if the return is &lt;code&gt;undef&lt;/code&gt;. Note that the numeric value returned need not be a whole number. &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt;, for example returns -0.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c98175c6574b582a8455429e44a48ac7e74d895" translate="yes" xml:space="preserve">
          <source>If the string is more than one character, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned unless all its characters are decimal digits (that is, they would match &lt;code&gt;\d+&lt;/code&gt; ), from the same script. For example if you have an ASCII '0' and a Bengali '3', mixed together, they aren't considered a valid number, and &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned. A further restriction is that the digits all have to be of the same form. A half-width digit mixed with a full-width one will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. The Arabic script has two sets of digits; &lt;code&gt;num&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; unless all the digits in the string come from the same set.</source>
          <target state="translated">Если строка состоит из более чем одного символа, возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если все ее символы не являются десятичными цифрами (то есть они соответствуют &lt;code&gt;\d+&lt;/code&gt; ) из того же сценария. Например, если у вас есть ASCII &amp;laquo;0&amp;raquo; и бенгальский &amp;laquo;3&amp;raquo;, смешанные вместе, они не считаются допустимым числом, и возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Еще одно ограничение - все цифры должны иметь одинаковую форму. Цифра половинной ширины, смешанная с цифрой полной ширины, вернет &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Арабский шрифт состоит из двух наборов цифр; &lt;code&gt;num&lt;/code&gt; вернет &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если все цифры в строке не принадлежат одному и тому же набору.</target>
        </trans-unit>
        <trans-unit id="38c89008b47ecbaadc076b7aa2f24f0e7c6c9985" translate="yes" xml:space="preserve">
          <source>If the string is more than one character, &lt;code&gt;undef&lt;/code&gt; is returned unless all its characters are decimal digits (that is, they would match &lt;code&gt;\d+&lt;/code&gt;), from the same script. For example if you have an ASCII '0' and a Bengali '3', mixed together, they aren't considered a valid number, and &lt;code&gt;undef&lt;/code&gt; is returned. A further restriction is that the digits all have to be of the same form. A half-width digit mixed with a full-width one will return &lt;code&gt;undef&lt;/code&gt;. The Arabic script has two sets of digits; &lt;code&gt;num&lt;/code&gt; will return &lt;code&gt;undef&lt;/code&gt; unless all the digits in the string come from the same set. In all cases, the optional scalar ref parameter is set to how long any valid initial substring of digits is; hence it will be set to the entire string length if the main return value is not &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc51a016846748fdbc037c08fcea8e548c16fe0" translate="yes" xml:space="preserve">
          <source>If the string used for the filename and/or comment is not valid UTF-8 when this option is true, the script will die with a &quot;wide character&quot; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc54c0830b9373d2798de2bf5260229a62e838a3" translate="yes" xml:space="preserve">
          <source>If the subroutine has one of a few special names, such as &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. Execution of the subroutine will likely be a no-op, unless &lt;code&gt;sv&lt;/code&gt; was a tied array or the caller modified the subroutine in some interesting way before it was executed. In the case of &lt;code&gt;BEGIN&lt;/code&gt;, the treatment is buggy: the sub will be executed when only half built, and may be deleted prematurely, possibly causing a crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1db3945f60801d9fe74fe01151fa3c625ba2ad" translate="yes" xml:space="preserve">
          <source>If the subroutine has one of a few special names, such as &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. In the case of &lt;code&gt;BEGIN&lt;/code&gt;, the subroutine will be executed and the reference to it disposed of before this function returns, and also before its prototype is set. If a &lt;code&gt;BEGIN&lt;/code&gt; subroutine would not be sufficiently constructed by this function to be ready for execution then the caller must prevent this happening by giving the subroutine a different name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb58246d15f13a6f8775c588f89be7261648c55a" translate="yes" xml:space="preserve">
          <source>If the subroutine has one of a few special names, such as &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. In the case of &lt;code&gt;BEGIN&lt;/code&gt;, the subroutine will be executed and the reference to it disposed of before this function returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c4922eb5c062cef768c57176fb78d4965487a5" translate="yes" xml:space="preserve">
          <source>If the subroutine is an XSUB, the elements to be compared are pushed on to the stack, the way arguments are usually passed to XSUBs. $a and $b are not set.</source>
          <target state="translated">Если подпрограмма является XSUB,то сравниваемые элементы выталкиваются в стек,а аргументы обычно передаются в XSUB.$a и $b не устанавливаются.</target>
        </trans-unit>
        <trans-unit id="1afca0c8662d7dc27c024fcc727c62d11480ea99" translate="yes" xml:space="preserve">
          <source>If the subroutine is an XSUB, the elements to be compared are pushed on to the stack, the way arguments are usually passed to XSUBs. &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="976151f66fa723fd3131374feb62ee8e2fa9f3b7" translate="yes" xml:space="preserve">
          <source>If the subroutine needs to signal an error, it should call die() with the desired error message as its argument. GetOptions() will catch the die(), issue the error message, and record that an error result must be returned upon completion.</source>
          <target state="translated">Если подпрограмма должна сигнализировать об ошибке,она должна вызвать функцию die()с желаемым сообщением об ошибке в качестве аргумента.GetOptions()перехватит функцию die(),выдаст сообщение об ошибке и запишет,что результат ошибки должен быть возвращен по завершению.</target>
        </trans-unit>
        <trans-unit id="40540ec0b48601a220c70ec78c454bb0e1f51c33" translate="yes" xml:space="preserve">
          <source>If the subroutine returns a scalar with a newline or a filehandle, it will be interpreted as raw TAP or as a TAP stream, respectively.</source>
          <target state="translated">Если подпрограмма возвращает скаляр с новой строкой или файловым хэндлом,то он будет интерпретирован как сырой TAP или как TAP-поток,соответственно.</target>
        </trans-unit>
        <trans-unit id="ca613cca9ddf94b18fd3a6da5979f02e2a0a3fcf" translate="yes" xml:space="preserve">
          <source>If the subroutine's prototype is &lt;code&gt;($$)&lt;/code&gt; , the elements to be compared are passed by reference in &lt;code&gt;@_&lt;/code&gt; , as for a normal subroutine. This is slower than unprototyped subroutines, where the elements to be compared are passed into the subroutine as the package global variables $a and $b (see example below). Note that in the latter case, it is usually highly counter-productive to declare $a and $b as lexicals.</source>
          <target state="translated">Если прототип подпрограммы &lt;code&gt;($$)&lt;/code&gt; , сравниваемые элементы передаются по ссылке в &lt;code&gt;@_&lt;/code&gt; , как для обычной подпрограммы. Это медленнее, чем подпрограммы без прототипов, где сравниваемые элементы передаются в подпрограмму как глобальные переменные пакета $ a и $ b (см. Пример ниже). Обратите внимание, что в последнем случае объявление $ a и $ b лексическими числами обычно крайне непродуктивно.</target>
        </trans-unit>
        <trans-unit id="84b98f5d60037882d103faaf29e539e20c444828" translate="yes" xml:space="preserve">
          <source>If the subroutine's prototype is &lt;code&gt;($$)&lt;/code&gt;, the elements to be compared are passed by reference in &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt;, as for a normal subroutine. This is slower than unprototyped subroutines, where the elements to be compared are passed into the subroutine as the package global variables &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; (see example below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8a697c5090fd8ce94c13b5cefb41955f99b010" translate="yes" xml:space="preserve">
          <source>If the sv already is UTF-8 (or if it is not POK), or if the encoding is not a reference, nothing is done to the sv. If the encoding is not an &lt;code&gt;Encode::XS&lt;/code&gt; Encoding object, bad things will happen. (See</source>
          <target state="translated">Если sv уже является UTF-8 (или если это не POK), или если кодировка не является ссылкой, с sv ничего не делается. Если кодировка не является объектом &lt;code&gt;Encode::XS&lt;/code&gt; Encoding, могут произойти неприятности. (Видеть</target>
        </trans-unit>
        <trans-unit id="25e6d11786b2dfdb0f52678b6850a3dff8731c46" translate="yes" xml:space="preserve">
          <source>If the sv is the target of a weak reference then it returns the back references structure associated with the sv; otherwise return NULL.</source>
          <target state="translated">Если sv является целью слабой ссылки,то возвращается структура обратных ссылок,связанная с sv;в противном случае возвращается NULL.</target>
        </trans-unit>
        <trans-unit id="82b0821b14cc4cbb805ab8ac00aa5900da22e409" translate="yes" xml:space="preserve">
          <source>If the symbol &lt;code&gt;:void&lt;/code&gt; appears in the import list, then functions named later in that import list raise an exception only when these are called in void context--that is, when their return values are ignored. For example</source>
          <target state="translated">Если в списке импорта появляется символ &lt;code&gt;:void&lt;/code&gt; , то функции, названные позже в этом списке импорта, вызывают исключение только тогда, когда они вызываются в контексте void, то есть когда их возвращаемые значения игнорируются. Например</target>
        </trans-unit>
        <trans-unit id="50cf7df5061941de64a11ddf12781ae7a8f3290f" translate="yes" xml:space="preserve">
          <source>If the system Perl is compiled in has thread-safe variants of such calls, they will be used. Beyond that, Perl is at the mercy of the thread-safety or -unsafety of the calls. Please consult your C library call documentation.</source>
          <target state="translated">Если система,в которой Perl скомпилирован,имеет потокобезопасные варианты таких вызовов,то они будут использоваться.Кроме того,Perl находится во власти потокобезопасных или -небезопасных вызовов.Обратитесь к документации по вызовам библиотеки C.</target>
        </trans-unit>
        <trans-unit id="d5b1234bec481f7f0fb540471e8867994b10762a" translate="yes" xml:space="preserve">
          <source>If the target machine is little-endian, we could write:</source>
          <target state="translated">Если целевая машина маленькая,мы могли бы написать:</target>
        </trans-unit>
        <trans-unit id="4756e731e627a9969d09a902907c109ca92f4013" translate="yes" xml:space="preserve">
          <source>If the template is not specified, a template is always automatically generated. This temporary file is placed in tmpdir() (&lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt;) unless a directory is specified explicitly with the DIR option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff635540edd5aea28a885e06a80c5c6844ba7c11" translate="yes" xml:space="preserve">
          <source>If the template is not specified, a template is always automatically generated. This temporary file is placed in tmpdir() (L&amp;lt;:spec&amp;gt;) unless a directory is specified explicitly with the DIR option.</source>
          <target state="translated">Если шаблон не указан, всегда автоматически создается шаблон. Этот временный файл помещается в tmpdir () (L &amp;lt;: spec&amp;gt;), если каталог не указан явно с параметром DIR.</target>
        </trans-unit>
        <trans-unit id="593ec0746d963b28de5ba2cf0799b3f4777c63c7" translate="yes" xml:space="preserve">
          <source>If the temporary file can not be created undef is returned. Currently this command will probably not work when the temporary directory is on an NFS file system.</source>
          <target state="translated">Если временный файл не может быть создан,возвращается undef.В настоящее время эта команда,вероятно,не будет работать,когда временный каталог находится на файловой системе NFS.</target>
        </trans-unit>
        <trans-unit id="326e7cf804954bda3811121b38cb7c631e7575fe" translate="yes" xml:space="preserve">
          <source>If the terminating string is quoted, the type of quotes used determine the treatment of the text.</source>
          <target state="translated">В случае кавычки завершающей строки,тип используемых кавычек определяет обработку текста.</target>
        </trans-unit>
        <trans-unit id="957eb5ae659823f7ba1c0183ec0ac873de8b4109" translate="yes" xml:space="preserve">
          <source>If the test is unplanned, this method will always return false. See &lt;code&gt;is_unplanned&lt;/code&gt; .</source>
          <target state="translated">Если тест незапланированный, этот метод всегда будет возвращать false. См. &lt;code&gt;is_unplanned&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20d3ba6a3f24850f51b5f59f10528892b52a140e" translate="yes" xml:space="preserve">
          <source>If the test is unplanned, this method will always return false. See &lt;code&gt;is_unplanned&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bfabe273698ccd033cf292d0d277e005ca02c57" translate="yes" xml:space="preserve">
          <source>If the tests fail &lt;code&gt;prove&lt;/code&gt; will exit with non-zero status.</source>
          <target state="translated">Если тесты не пройдут, функция &amp;laquo; &lt;code&gt;prove&lt;/code&gt; завершится с ненулевым статусом.</target>
        </trans-unit>
        <trans-unit id="269c79628ff3b9a7faad565d0d36f6d320d9b282" translate="yes" xml:space="preserve">
          <source>If the text of the L&amp;lt;&amp;gt; escape is entirely enclosed in double quotes, it's interpreted as a link to a section for backward compatibility.</source>
          <target state="translated">Если текст escape-символа L &amp;lt;&amp;gt; полностью заключен в двойные кавычки, он интерпретируется как ссылка на раздел для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="f92e03b607dab58b8f2f2e3c224ccb0a3fc3ca6c" translate="yes" xml:space="preserve">
          <source>If the text of the error message starts with an exclamation mark &lt;code&gt;!&lt;/code&gt; it is interpreted specially by GetOptions(). There is currently one special command implemented: &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die(&quot;!FINISH&quot;)&lt;/a&gt;&lt;/code&gt; will cause GetOptions() to stop processing options, as if it encountered a double dash &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">Если текст сообщения об ошибке начинается с восклицательного знака &lt;code&gt;!&lt;/code&gt; он специально интерпретируется GetOptions (). В настоящее время реализована одна специальная команда: &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die(&quot;!FINISH&quot;)&lt;/a&gt;&lt;/code&gt; заставит GetOptions () прекратить обработку параметров, как если бы он встретил двойной дефис &lt;code&gt;--&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d332109bf38a18b83347b1abe4af5018dfcf4a0" translate="yes" xml:space="preserve">
          <source>If the text of the error message starts with an exclamation mark &lt;code&gt;!&lt;/code&gt; it is interpreted specially by GetOptions(). There is currently one special command implemented: &lt;code&gt;die(&quot;!FINISH&quot;)&lt;/code&gt; will cause GetOptions() to stop processing options, as if it encountered a double dash &lt;code&gt;--&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a21a0dcb36b1ce3d43912ccebce5a460b97864" translate="yes" xml:space="preserve">
          <source>If the third argument is</source>
          <target state="translated">Если третий аргумент</target>
        </trans-unit>
        <trans-unit id="b232866b6ad063c73d4ad37ea476edb565d6de63" translate="yes" xml:space="preserve">
          <source>If the third argument,</source>
          <target state="translated">Если третий аргумент,</target>
        </trans-unit>
        <trans-unit id="66bf0740d3ced4e3ce4166e93bb8bdf81549240a" translate="yes" xml:space="preserve">
          <source>If the thread being &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;ed &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;d, the error it died with will be returned at this time. If you don't want the thread performing the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; to die as well, you should either wrap the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or use the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; thread method instead of &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если нить существо &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; эд &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; д, ошибка он умер с будет возвращено в это время. Если вы не хотите, чтобы поток, выполняющий &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; , тоже умирал, вы должны либо заключить &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , либо использовать метод потока &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; вместо &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a5af2f1be44751c2177059f4e6af4dd499466cc" translate="yes" xml:space="preserve">
          <source>If the thread being &lt;code&gt;join&lt;/code&gt;ed &lt;code&gt;die&lt;/code&gt;d, the error it died with will be returned at this time. If you don't want the thread performing the &lt;code&gt;join&lt;/code&gt; to die as well, you should either wrap the &lt;code&gt;join&lt;/code&gt; in an &lt;code&gt;eval&lt;/code&gt; or use the &lt;code&gt;eval&lt;/code&gt; thread method instead of &lt;code&gt;join&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2279b2f8b74fd7d772a6ba18eb3177b3a248c49d" translate="yes" xml:space="preserve">
          <source>If the timeout is reached, this method will return</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd970acc5e28ee89d2e82334dde273c65bae5b7" translate="yes" xml:space="preserve">
          <source>If the title can't be found, then get_short_title returns empty-string (&quot;&quot;).</source>
          <target state="translated">Если заголовок не может быть найден,то get_short_title возвращает пустую строку (&quot;&quot;).</target>
        </trans-unit>
        <trans-unit id="697a489e14d5b870ec5510bd4b458c67ab45bad8" translate="yes" xml:space="preserve">
          <source>If the typeglob &lt;code&gt;gv&lt;/code&gt; can be expressed more succinctly, by having something other than a real GV in its place in the stash, replace it with the optimised form. Basic requirements for this are that &lt;code&gt;gv&lt;/code&gt; is a real typeglob, is sufficiently ordinary, and is only referenced from its package. This function is meant to be used when a GV has been looked up in part to see what was there, causing upgrading, but based on what was found it turns out that the real GV isn't required after all.</source>
          <target state="translated">Если typeglob &lt;code&gt;gv&lt;/code&gt; можно выразить более кратко, имея на своем месте в тайнике нечто иное, чем реальный GV, замените его оптимизированной формой. Основные требования для этого заключаются в том, что &lt;code&gt;gv&lt;/code&gt; является реальным typeglob, достаточно обычным и на него ссылаются только из своего пакета. Эта функция предназначена для использования, когда GV частично просматривается, чтобы увидеть, что там было, что вызывает обновление, но на основании того, что было обнаружено, оказывается, что реальный GV в конце концов не требуется.</target>
        </trans-unit>
        <trans-unit id="7e317e256420ab2a48b2f7e7b312c3d9f416e521" translate="yes" xml:space="preserve">
          <source>If the underlying &lt;code&gt;IO::Handle&lt;/code&gt; is closed, or if there are any read or write failures, the file handle will be forced closed, and &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Connection closed&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt; ). The _set_status_closed() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">Если базовый &lt;code&gt;IO::Handle&lt;/code&gt; закрыт, или если есть какие-либо ошибки чтения или записи, дескриптор файла будет принудительно закрыт, и &lt;code&gt;code()&lt;/code&gt; вернет &quot;421&quot; (временный сбой соединения), а &lt;code&gt;message()&lt;/code&gt; вернет &quot;[ $ pkg] Соединение закрыто &quot;(где $ pkg - это имя класса, унаследовавшего от &lt;code&gt;Net::Cmd&lt;/code&gt; ). Метод _set_status_closed () можно переопределить, чтобы установить другое сообщение (путем вызова set_status ()) или иным образом перехватить эту ошибку.</target>
        </trans-unit>
        <trans-unit id="1e77ce40e4dd7efc2c043a17aee5d821a48fe672" translate="yes" xml:space="preserve">
          <source>If the underlying &lt;code&gt;IO::Handle&lt;/code&gt; is closed, or if there are any read or write failures, the file handle will be forced closed, and &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Connection closed&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt;). The _set_status_closed() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc3b2cf894256f273b0349af8d5d688d0cdcb39" translate="yes" xml:space="preserve">
          <source>If the user builds a shared</source>
          <target state="translated">Если пользователь создает общий</target>
        </trans-unit>
        <trans-unit id="32324af5745fb70c85007da7a27faa556a189cfd" translate="yes" xml:space="preserve">
          <source>If the user didn't specify anything, it's interpreted as having used the &lt;code&gt;please&lt;/code&gt; tag. It's up to you to make this useful.</source>
          <target state="translated">Если пользователь ничего не указал, это интерпретируется как использование тега &lt;code&gt;please&lt;/code&gt; . Как сделать это полезным - решать вам.</target>
        </trans-unit>
        <trans-unit id="cd074d1ec9315994a5770ffd227be188d8ea3674" translate="yes" xml:space="preserve">
          <source>If the user does not have HTML::Lint installed, the whole block of code</source>
          <target state="translated">Если у пользователя не установлен HTML::Lint,то весь блок кода</target>
        </trans-unit>
        <trans-unit id="b39c8811f479889c6eabed43038bf7a333557852" translate="yes" xml:space="preserve">
          <source>If the user has superuser privileges, and is not working on AFS or relatives, then the defaults for INSTALLPRIVLIB, INSTALLARCHLIB, INSTALLSCRIPT, etc. will be appropriate, and this incantation will be the best:</source>
          <target state="translated">Если пользователь имеет привилегии суперпользователя и не работает с AFS или родственниками,то по умолчанию будут подходящими значения для УСТАНОВКИ,УСТАНОВКИ,УСТАНОВКИ и т.д.,и это заклинание будет лучшим:</target>
        </trans-unit>
        <trans-unit id="3d9745c4616cab220c27715466f7a222d8b72268" translate="yes" xml:space="preserve">
          <source>If the value</source>
          <target state="translated">Если значение</target>
        </trans-unit>
        <trans-unit id="1676523b419ae746e43ad6553d2687aea42c504e" translate="yes" xml:space="preserve">
          <source>If the value doesn't match the 'make' program you want to use, edit Config.pm to fix it.</source>
          <target state="translated">Если значение не соответствует программе 'make',которую Вы хотите использовать,отредактируйте Config.pm,чтобы исправить это.</target>
        </trans-unit>
        <trans-unit id="9aa86f4743abc7079a416abc9073771271ff4394" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to</source>
          <target state="translated">Если значение &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; , оно возвращается как UV, флаги вывода очищены, и в него ничего не записывается.</target>
        </trans-unit>
        <trans-unit id="69db17f26df78ff9935057c8c72522c8171dedc4" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to &lt;code&gt;*result&lt;/code&gt;. If the value is &amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt;, &lt;code&gt;grok_bin&lt;/code&gt; returns &lt;code&gt;UV_MAX&lt;/code&gt;, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes an approximation of the correct value into &lt;code&gt;*result&lt;/code&gt; (which is an NV; or the approximation is discarded if &lt;code&gt;result&lt;/code&gt; is NULL).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33edf1191e45f2f7c173468860c56b9c68eec7c" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to &lt;code&gt;*result&lt;/code&gt;. If the value is &amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt;, &lt;code&gt;grok_hex&lt;/code&gt; returns &lt;code&gt;UV_MAX&lt;/code&gt;, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes an approximation of the correct value into &lt;code&gt;*result&lt;/code&gt; (which is an NV; or the approximation is discarded if &lt;code&gt;result&lt;/code&gt; is NULL).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11949fed265c94f0f9f0cc1d3c0a3164a55a86d5" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to &lt;code&gt;*result&lt;/code&gt;. If the value is &amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt;, &lt;code&gt;grok_oct&lt;/code&gt; returns &lt;code&gt;UV_MAX&lt;/code&gt;, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes an approximation of the correct value into &lt;code&gt;*result&lt;/code&gt; (which is an NV; or the approximation is discarded if &lt;code&gt;result&lt;/code&gt; is NULL).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd15952acdcd265d4f18a816b3be548c37a82d83" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= UV_MAX it is returned as a UV, the output flags are clear, and nothing is written to</source>
          <target state="translated">Если значение &amp;lt;= UV_MAX, оно возвращается как UV, флаги вывода очищены, и в него ничего не записывается.</target>
        </trans-unit>
        <trans-unit id="c10d8690679793d91d603d7249997075229bffed" translate="yes" xml:space="preserve">
          <source>If the value is a coderef, we return &amp;amp;$value($lh, ...parameters...).</source>
          <target state="translated">Если значение является ссылкой на код, мы возвращаем &amp;amp; $ value ($ lh, ... параметры ...).</target>
        </trans-unit>
        <trans-unit id="ef50a320b2209faad43a3f8213d92ea4b618e424" translate="yes" xml:space="preserve">
          <source>If the value is a scalarref, the scalar is dereferenced and returned (and any parameters are ignored).</source>
          <target state="translated">Если значение является скаляром,то скаляр разыменовывается и возвращается (при этом любые параметры игнорируются).</target>
        </trans-unit>
        <trans-unit id="6f950a468109b8d39520112d3f58effdc56407fc" translate="yes" xml:space="preserve">
          <source>If the value is a string that</source>
          <target state="translated">Если значение является строкой,которая</target>
        </trans-unit>
        <trans-unit id="034aa5dfb1d3fc388ace8815e3c3af316b7fe0f0" translate="yes" xml:space="preserve">
          <source>If the value is true, then the appropriate pragma is assumed to be in the ambient scope, otherwise not.</source>
          <target state="translated">Если значение верно,то считается,что соответствующая прагма относится к окружающей среде,в противном случае-нет.</target>
        </trans-unit>
        <trans-unit id="c4b0ded1a1deef22b5fab46f3c6efeda2921b5b8" translate="yes" xml:space="preserve">
          <source>If the value of</source>
          <target state="translated">Если значение</target>
        </trans-unit>
        <trans-unit id="3679a65190bd3883b712c84ff2c3ed51da02c8c9" translate="yes" xml:space="preserve">
          <source>If the value of the number can fit in a UV, it is returned in &lt;code&gt;*valuep&lt;/code&gt;. &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; will be set to indicate that &lt;code&gt;*valuep&lt;/code&gt; is valid, &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; will never be set unless &lt;code&gt;*valuep&lt;/code&gt; is valid, but &lt;code&gt;*valuep&lt;/code&gt; may have been assigned to during processing even though &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; is not set on return. If &lt;code&gt;valuep&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; will be set for the same cases as when &lt;code&gt;valuep&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt;, but no actual assignment (or SEGV) will occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3799e4ea2da2d340ca2beed8a5872250c216eb41" translate="yes" xml:space="preserve">
          <source>If the value of the number can fit in a UV, it is returned in the *valuep IS_NUMBER_IN_UV will be set to indicate that *valuep is valid, IS_NUMBER_IN_UV will never be set unless *valuep is valid, but *valuep may have been assigned to during processing even though IS_NUMBER_IN_UV is not set on return. If valuep is NULL, IS_NUMBER_IN_UV will be set for the same cases as when valuep is non-NULL, but no actual assignment (or SEGV) will occur.</source>
          <target state="translated">Если значение числа может поместиться в UV,оно возвращается в *valuep IS_NUMBER_IN_UV будет установлено,чтобы показать,что *valuep является действительным,IS_NUMBER_IN_UV никогда не будет установлено,если *valuep не является действительным,но *valuep,возможно,было назначено во время обработки,даже если IS_NUMBER_IN_UV не установлено при возврате.Если значение NULL,IS_NUMBER_IN_UV будет установлено для тех же случаев,что и если значение не NULL,но фактическое присвоение (или SEGV)не произойдет.</target>
        </trans-unit>
        <trans-unit id="d417792987cefdc8fbbad820c7047930346b40c5" translate="yes" xml:space="preserve">
          <source>If the value to pack is too long, the result is truncated. If it's too long and an explicit count is provided, &lt;code&gt;Z&lt;/code&gt; packs only &lt;code&gt;$count-1&lt;/code&gt; bytes, followed by a null byte. Thus &lt;code&gt;Z&lt;/code&gt; always packs a trailing null, except when the count is 0.</source>
          <target state="translated">Если значение для упаковки слишком велико, результат обрезается. Если он слишком длинный и указан явный счетчик, &lt;code&gt;Z&lt;/code&gt; упаковывает только байтов &lt;code&gt;$count-1&lt;/code&gt; , за которыми следует нулевой байт. Таким образом, &lt;code&gt;Z&lt;/code&gt; всегда упаковывает завершающий ноль, кроме случаев, когда счетчик равен 0.</target>
        </trans-unit>
        <trans-unit id="2b18faee7915986e7efaa1de04f931c2b8c71f1c" translate="yes" xml:space="preserve">
          <source>If the values are all small integers, you could use a simple indexed array. This kind of an array will take up less space:</source>
          <target state="translated">Если все значения являются маленькими целыми числами,то можно использовать простой индексированный массив.Такой массив займет меньше места:</target>
        </trans-unit>
        <trans-unit id="5cc9e16e91b4a8896cd9faaa5f9549cbc7085c8f" translate="yes" xml:space="preserve">
          <source>If the values in question are integers instead of strings, you can save quite a lot of space by using bit strings instead:</source>
          <target state="translated">Если рассматриваемые значения являются целыми числами,а не строками,то можно сэкономить довольно много места,используя вместо них битовые строки:</target>
        </trans-unit>
        <trans-unit id="82319500e10e873dfa0526d703945d89b55231f8" translate="yes" xml:space="preserve">
          <source>If the values of &lt;code&gt;$mod&lt;/code&gt; and &lt;code&gt;$prereq&lt;/code&gt; have not been scrubbed, however, this presents security implications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e7da39372f108fea1077e432f6f8a5490ef1c9" translate="yes" xml:space="preserve">
          <source>If the variable is locked by another thread, the &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; call will block until it's available. &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; is recursive, so multiple calls to &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; are safe--the variable will remain locked until the outermost lock on the variable goes out of scope.</source>
          <target state="translated">Если переменная заблокирована другим потоком, вызов &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; будет заблокирован, пока он не станет доступным. &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; является рекурсивным, поэтому множественные вызовы &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; безопасны - переменная будет оставаться заблокированной до тех пор, пока внешняя блокировка переменной не выйдет за пределы области видимости.</target>
        </trans-unit>
        <trans-unit id="d43da14411193cb05153c9413f27d1e7c410d9b1" translate="yes" xml:space="preserve">
          <source>If the variable is locked by another thread, the &lt;code&gt;lock&lt;/code&gt; call will block until it's available. &lt;code&gt;lock&lt;/code&gt; is recursive, so multiple calls to &lt;code&gt;lock&lt;/code&gt; are safe--the variable will remain locked until the outermost lock on the variable goes out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a274850c71686d34e3baa803737f0dedda24d3" translate="yes" xml:space="preserve">
          <source>If the variable is not set, or if the head of space-separated list is empty, the best available package is loaded.</source>
          <target state="translated">Если переменная не установлена,или если заголовок разделенного пробелами списка пуст,загружается лучший доступный пакет.</target>
        </trans-unit>
        <trans-unit id="332df1267de6f0a87c793832b4c5597a101a667d" translate="yes" xml:space="preserve">
          <source>If the warning comes from other than I/O, this diagnostic probably indicates that incorrect results are being obtained. You should examine your code to determine how a wide character is getting to an operation that doesn't handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b83d018cb7a8db8be65fb54c56d8b5b7e8cb24" translate="yes" xml:space="preserve">
          <source>If the warnings category, &lt;code&gt;$category&lt;/code&gt; , has been set to &quot;FATAL&quot; in the calling module then die. Otherwise return.</source>
          <target state="translated">Если категория предупреждений, &lt;code&gt;$category&lt;/code&gt; , была установлена ​​в &quot;FATAL&quot; в вызывающем модуле, тогда умри. В противном случае вернитесь.</target>
        </trans-unit>
        <trans-unit id="834ab1c45a3f45ffae4b5d0f33ce4babb0604bab" translate="yes" xml:space="preserve">
          <source>If the warnings category, &lt;code&gt;$category&lt;/code&gt;, has been set to &quot;FATAL&quot; in the calling module then die. Otherwise return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5e41570d4b0ba06d69d1ed0ddaa70c09dffea4d" translate="yes" xml:space="preserve">
          <source>If the whole program is Unicode (signified by using 8-bit &lt;b&gt;U&lt;/b&gt;nicode &lt;b&gt;T&lt;/b&gt;ransformation &lt;b&gt;F&lt;/b&gt;ormat), then all literal strings within it must be Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de09cf9a89a26f0cb448619847689ec2527d3db" translate="yes" xml:space="preserve">
          <source>If the whole program is Unicode (signified by using 8-bit &lt;b&gt;U&lt;/b&gt;nicode &lt;b&gt;T&lt;/b&gt;ransformation &lt;b&gt;F&lt;/b&gt;ormat), then all strings within it must be Unicode.</source>
          <target state="translated">Если вся программа Unicode (обозначается с помощью 8-битного &lt;b&gt;U&lt;/b&gt; nicode &lt;b&gt;T&lt;/b&gt; ransformation &lt;b&gt;F&lt;/b&gt; Ormat), то все строки внутри него должны быть Unicode.</target>
        </trans-unit>
        <trans-unit id="9cdf7f58b72ea89ccbb496e2eb6b9b4bc7fadaa5" translate="yes" xml:space="preserve">
          <source>If the word &lt;code&gt;while&lt;/code&gt; is replaced by the word &lt;code&gt;until&lt;/code&gt; , the sense of the test is reversed, but the conditional is still tested before the first iteration.</source>
          <target state="translated">Если слово &lt;code&gt;while&lt;/code&gt; заменяется словом &lt;code&gt;until&lt;/code&gt; , смысл теста меняется на противоположный, но условие все равно проверяется перед первой итерацией.</target>
        </trans-unit>
        <trans-unit id="bb24c8d0dff7253263fabb1012737a1c5185daa5" translate="yes" xml:space="preserve">
          <source>If the word &lt;code&gt;while&lt;/code&gt; is replaced by the word &lt;code&gt;until&lt;/code&gt;, the sense of the test is reversed, but the conditional is still tested before the first iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10166029e96e7fe67231308fbe3c16515584c847" translate="yes" xml:space="preserve">
          <source>If there are additional casing rules that apply only in certain locales, an additional key for each will be defined in the returned hash. Each such key will be its locale name, defined as a 2-letter ISO 3166 country code, possibly followed by a &quot;_&quot; and a 2-letter ISO language code (possibly followed by a &quot;_&quot; and a variant code). You can find the lists of all possible locales, see &lt;a href=&quot;../locale/country&quot;&gt;Locale::Country&lt;/a&gt; and &lt;a href=&quot;../locale/language&quot;&gt;Locale::Language&lt;/a&gt;. (In Unicode 6.0, the only locales returned by this function are &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;az&lt;/code&gt; .)</source>
          <target state="translated">Если есть дополнительные правила регистра, которые применяются только в определенных языковых стандартах, дополнительный ключ для каждого будет определен в возвращаемом хэше. Каждый такой ключ будет его названием локали, определенным как двухбуквенный код страны ISO 3166, за которым, возможно, следует &amp;laquo;_&amp;raquo; и двухбуквенный код языка ISO (возможно, за которым следует &amp;laquo;_&amp;raquo; и код варианта). Вы можете найти списки всех возможных локалей, см. &lt;a href=&quot;../locale/country&quot;&gt;Locale :: Country&lt;/a&gt; и &lt;a href=&quot;../locale/language&quot;&gt;Locale :: Language&lt;/a&gt; . (В Unicode 6.0 единственными языковыми стандартами, возвращаемыми этой функцией, являются &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;az&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="c9b92a1c0c95f09069f2ada78514b6761e600855" translate="yes" xml:space="preserve">
          <source>If there are additional casing rules that apply only in certain locales, an additional key for each will be defined in the returned hash. Each such key will be its locale name, defined as a 2-letter ISO 3166 country code, possibly followed by a &quot;_&quot; and a 2-letter ISO language code (possibly followed by a &quot;_&quot; and a variant code). You can find the lists of all possible locales, see &lt;a href=&quot;Locale::Country&quot;&gt;Locale::Country&lt;/a&gt; and &lt;a href=&quot;Locale::Language&quot;&gt;Locale::Language&lt;/a&gt;. (In Unicode 6.0, the only locales returned by this function are &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;tr&lt;/code&gt;, and &lt;code&gt;az&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10187abc55d0802b4b3951872dffe3ad9dfa823c" translate="yes" xml:space="preserve">
          <source>If there are fewer than &lt;code&gt;$count&lt;/code&gt; items in the list then the function will return once all of them have been randomly selected; effectively the function behaves similarly to &lt;a href=&quot;#shuffle&quot;&gt;&quot;shuffle&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91a8fd751937bd233ccdf982bb8140e1a1456b2" translate="yes" xml:space="preserve">
          <source>If there are more pack codes or if the repeat count of a field or a group is larger than what the remainder of the input string allows, the result is not well defined: the repeat count may be decreased, or &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; may produce empty strings or zeros, or it may raise an exception. If the input string is longer than one described by the TEMPLATE, the remainder of that input string is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c264a98231858c182cc8e558543c798b7c30e957" translate="yes" xml:space="preserve">
          <source>If there are more pack codes or if the repeat count of a field or a group is larger than what the remainder of the input string allows, the result is not well defined: the repeat count may be decreased, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; may produce empty strings or zeros, or it may raise an exception. If the input string is longer than one described by the TEMPLATE, the remainder of that input string is ignored.</source>
          <target state="translated">Если имеется больше кодов пакетов или если количество повторов поля или группы больше, чем позволяет оставшаяся часть входной строки, результат не определен должным образом: количество повторов может быть уменьшено, или &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; может привести к пустому строки или нули, или это может вызвать исключение. Если входная строка длиннее, чем описанная в ШАБЛОНЕ, оставшаяся часть этой входной строки игнорируется.</target>
        </trans-unit>
        <trans-unit id="b76f7ceb246d4c2d7fabcbfce30f4b0cda04fc65" translate="yes" xml:space="preserve">
          <source>If there are more pack codes or if the repeat count of a field or a group is larger than what the remainder of the input string allows, the result is not well defined: the repeat count may be decreased, or &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; may produce empty strings or zeros, or it may raise an exception. If the input string is longer than one described by the TEMPLATE, the remainder of that input string is ignored.</source>
          <target state="translated">Если имеется больше кодов пакетов или если количество повторов поля или группы больше, чем позволяет оставшаяся часть входной строки, результат не определен должным образом: количество повторов может быть уменьшено, или &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; может привести к пустому строки или нули, или это может вызвать исключение. Если входная строка длиннее, чем описанная в ШАБЛОНЕ, оставшаяся часть этой входной строки игнорируется.</target>
        </trans-unit>
        <trans-unit id="68b83d3193021444c248ae823551b36481a4afcb" translate="yes" xml:space="preserve">
          <source>If there are multiple threads running, &lt;a href=&quot;#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; on a filehandle from a piped open returns true without waiting for the child process to terminate, if the filehandle is still open in another thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf8ae3d8fd9e42e9aba417d2727a1cef25f1654d" translate="yes" xml:space="preserve">
          <source>If there are multiple threads running, &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on a filehandle from a piped open returns true without waiting for the child process to terminate, if the filehandle is still open in another thread.</source>
          <target state="translated">Если выполняется несколько потоков, &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; для дескриптора файла из конвейерного open возвращает true, не дожидаясь завершения дочернего процесса, если дескриптор файла все еще открыт в другом потоке.</target>
        </trans-unit>
        <trans-unit id="2d703ea78c6bd312ccc4d4536374984caf742a2c" translate="yes" xml:space="preserve">
          <source>If there are multiple threads running, &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on a filehandle from a piped open returns true without waiting for the child process to terminate, if the filehandle is still open in another thread.</source>
          <target state="translated">Если выполняется несколько потоков, &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; для дескриптора файла из конвейерного open возвращает true, не дожидаясь завершения дочернего процесса, если дескриптор файла все еще открыт в другом потоке.</target>
        </trans-unit>
        <trans-unit id="b367c7608072c7b2e27d64beb7fdc3ebcfc5757e" translate="yes" xml:space="preserve">
          <source>If there are no case mappings for the &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;, or if all three possible mappings (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ca3b8e4b7d3fd6327a3431ba332cb4654544b7" translate="yes" xml:space="preserve">
          <source>If there are no case mappings for the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, or if all three possible mappings (</source>
          <target state="translated">Если нет сопоставлений регистра для &lt;a href=&quot;#code-point-argument&quot;&gt;аргумента кодовой точки&lt;/a&gt; или если все три возможных сопоставления (</target>
        </trans-unit>
        <trans-unit id="4d288bab40c0346d55a3c0eb77940eab7a6641ad" translate="yes" xml:space="preserve">
          <source>If there are no shell metacharacters in the argument of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, Perl runs the command directly, without using the shell, and can correctly report whether the command started.</source>
          <target state="translated">Если в аргументе &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; нет метасимволов оболочки , Perl запускает команду напрямую, без использования оболочки, и может правильно сообщить, запущена ли команда.</target>
        </trans-unit>
        <trans-unit id="07b923cdb7f2db79984c43279c6e1908fa7560e3" translate="yes" xml:space="preserve">
          <source>If there are no shell metacharacters in the argument of &lt;code&gt;open()&lt;/code&gt;, Perl runs the command directly, without using the shell, and can correctly report whether the command started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b3c9dc933e2482f8eba281e591135e3899389e" translate="yes" xml:space="preserve">
          <source>If there are no threads blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the variable, the signal is discarded.</source>
          <target state="translated">Если в &lt;code&gt;cond_wait&lt;/code&gt; для переменной нет потоков, заблокированных , сигнал отбрасывается.</target>
        </trans-unit>
        <trans-unit id="dcf5c5ee7e0424ea7ada5c7826f4b90fdb2a116c" translate="yes" xml:space="preserve">
          <source>If there are no threads blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the variable, the signal is discarded. By always locking before signaling, you can (with care), avoid signaling before another thread has entered cond_wait().</source>
          <target state="translated">Если в &lt;code&gt;cond_wait&lt;/code&gt; переменной нет потоков, заблокированных , сигнал игнорируется . Всегда блокируя перед сигнализацией, вы можете (осторожно) избежать сигнализации до того, как другой поток войдет в cond_wait ().</target>
        </trans-unit>
        <trans-unit id="a5de19948908467a5a983001d47b7d9a0689b746" translate="yes" xml:space="preserve">
          <source>If there are no valid digits between the braces, the generated character is the NULL character (&lt;code&gt;\x{00}&lt;/code&gt; ). However, an explicit empty brace (&lt;code&gt;\x{}&lt;/code&gt; ) will not cause a warning (currently).</source>
          <target state="translated">Если между фигурными скобками нет действительных цифр, сгенерированный символ является символом NULL ( &lt;code&gt;\x{00}&lt;/code&gt; ). Однако явная пустая скобка ( &lt;code&gt;\x{}&lt;/code&gt; ) не вызовет предупреждения (в настоящее время).</target>
        </trans-unit>
        <trans-unit id="954b2d334088acf7ff9ea75b92d63622f7bf51c0" translate="yes" xml:space="preserve">
          <source>If there are no valid digits between the braces, the generated character is the NULL character (&lt;code&gt;\x{00}&lt;/code&gt;). However, an explicit empty brace (&lt;code&gt;\x{}&lt;/code&gt;) will not cause a warning (currently).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b342c6d59112da790e47e12118a22cde8dbcaf22" translate="yes" xml:space="preserve">
          <source>If there are only a few field hashes to declare, it is simplest to</source>
          <target state="translated">Если нужно объявить только несколько хэшей полей,то проще всего</target>
        </trans-unit>
        <trans-unit id="ae8e9a2c571cd018342d9c2118caec048fd77da4" translate="yes" xml:space="preserve">
          <source>If there are only three arguments and the third argument is a hash reference, the keys of that hash can have values &lt;code&gt;dict&lt;/code&gt; , &lt;code&gt;fold&lt;/code&gt; , and &lt;code&gt;comp&lt;/code&gt; or &lt;code&gt;xfrm&lt;/code&gt; (see below), and their corresponding values will be used as the parameters.</source>
          <target state="translated">Если есть только три аргумента, а третий аргумент является ссылкой на хэш, ключи этого хеша могут иметь значения &lt;code&gt;dict&lt;/code&gt; , &lt;code&gt;fold&lt;/code&gt; и &lt;code&gt;comp&lt;/code&gt; или &lt;code&gt;xfrm&lt;/code&gt; (см. Ниже), и их соответствующие значения будут использоваться в качестве параметров.</target>
        </trans-unit>
        <trans-unit id="e81956a0441efe3f26746423f2c17c9cee5f29f4" translate="yes" xml:space="preserve">
          <source>If there are only three arguments and the third argument is a hash reference, the keys of that hash can have values &lt;code&gt;dict&lt;/code&gt;, &lt;code&gt;fold&lt;/code&gt;, and &lt;code&gt;comp&lt;/code&gt; or &lt;code&gt;xfrm&lt;/code&gt; (see below), and their corresponding values will be used as the parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e86b013905dd12651149e8ec83c3ae6cf6c6b73" translate="yes" xml:space="preserve">
          <source>If there are two modules using &lt;code&gt;FindBin&lt;/code&gt; from different directories under the same interpreter, this won't work. Since &lt;code&gt;FindBin&lt;/code&gt; uses a &lt;code&gt;BEGIN&lt;/code&gt; block, it'll be executed only once, and only the first caller will get it right. This is a problem under mod_perl and other persistent Perl environments, where you shouldn't use this module. Which also means that you should avoid using &lt;code&gt;FindBin&lt;/code&gt; in modules that you plan to put on CPAN. To make sure that &lt;code&gt;FindBin&lt;/code&gt; will work is to call the &lt;code&gt;again&lt;/code&gt; function:</source>
          <target state="translated">Если есть два модуля, использующих &lt;code&gt;FindBin&lt;/code&gt; из разных каталогов в одном интерпретаторе, это не сработает. Поскольку &lt;code&gt;FindBin&lt;/code&gt; использует блок &lt;code&gt;BEGIN&lt;/code&gt; , он будет выполнен только один раз, и только первый вызывающий получит его правильно. Это проблема в mod_perl и других постоянных средах Perl, где вам не следует использовать этот модуль. Это также означает, что вам следует избегать использования &lt;code&gt;FindBin&lt;/code&gt; в модулях, которые вы планируете разместить на CPAN. Чтобы убедиться, что &lt;code&gt;FindBin&lt;/code&gt; работает, нужно вызвать функцию &lt;code&gt;again&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fcc3c3e2760c5e396f33222005be848fc9fe18e0" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK, it is always executed just before the conditional is about to be evaluated again. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">Если есть &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK, он всегда выполняется непосредственно перед тем, как условие будет снова вычислено. Таким образом, его можно использовать для увеличения переменной цикла, даже если цикл был продолжен с помощью &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; оператора.</target>
        </trans-unit>
        <trans-unit id="47225f2cbf093a41e464bfd235d898451ab3fec3" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;continue&lt;/code&gt; BLOCK, it is always executed just before the conditional is about to be evaluated again. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;next&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b36be5061281671022cf399b379651681b1d4d0" translate="yes" xml:space="preserve">
          <source>If there is a case folding for that code point, a reference to a hash with the following fields is returned:</source>
          <target state="translated">Если для этой кодовой точки имеется сгибание регистра,то возвращается ссылка на хэш со следующими полями:</target>
        </trans-unit>
        <trans-unit id="791dad5bf77a3c7753599734b55d1d951806d6b3" translate="yes" xml:space="preserve">
          <source>If there is a possibility of malformed input, use instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6424bf8b1f44f30e366f5038ca9bafadec447990" translate="yes" xml:space="preserve">
          <source>If there is a read or write timeout &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Timeout&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt; ). The _set_status_timeout() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">Если есть тайм-аут чтения или записи, &lt;code&gt;code()&lt;/code&gt; вернет &amp;laquo;421&amp;raquo; (временный сбой соединения), а &lt;code&gt;message()&lt;/code&gt; вернет &amp;laquo;[$ pkg] Timeout&amp;raquo; (где $ pkg - это имя класса, унаследовавшего от &lt;code&gt;Net::Cmd&lt;/code&gt; ). Метод _set_status_timeout () можно переопределить, чтобы установить другое сообщение (путем вызова set_status ()) или иным образом перехватить эту ошибку.</target>
        </trans-unit>
        <trans-unit id="5c5ddbe053c3383dcb2da814550e984622b561fa" translate="yes" xml:space="preserve">
          <source>If there is a read or write timeout &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Timeout&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt;). The _set_status_timeout() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a08eec9ef05dccf9a00729a1af45acee83fa1a4" translate="yes" xml:space="preserve">
          <source>If there is a syntax error or runtime error, or a &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; statement is executed, &lt;code&gt;eval&lt;/code&gt; returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; in scalar context, or an empty list in list context, and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is set to the error message. (Prior to 5.16, a bug caused &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; to be returned in list context for syntax errors, but not for runtime errors.) If there was no error, &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is set to the empty string. A control flow operator like &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt; can bypass the setting of &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;. Beware that using &lt;code&gt;eval&lt;/code&gt; neither silences Perl from printing warnings to STDERR, nor does it stuff the text of warning messages into &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;. To do either of those, you have to use the &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{__WARN__}&lt;/code&gt;&lt;/a&gt; facility, or turn off warnings inside the BLOCK or EXPR using &lt;code&gt;no warnings 'all'&lt;/code&gt;. See &lt;a href=&quot;#warn-LIST&quot;&gt;&lt;code&gt;warn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;, and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11aba41a92baa1006f7ccfb764892fd564d365da" translate="yes" xml:space="preserve">
          <source>If there is a syntax error or runtime error, or a &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; statement is executed, &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context or an empty list in list context, and &lt;code&gt;$@&lt;/code&gt; is set to the error message. (Prior to 5.16, a bug caused &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to be returned in list context for syntax errors, but not for runtime errors.) If there was no error, &lt;code&gt;$@&lt;/code&gt; is set to the empty string. A control flow operator like &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; can bypass the setting of &lt;code&gt;$@&lt;/code&gt; . Beware that using &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; neither silences Perl from printing warnings to STDERR, nor does it stuff the text of warning messages into &lt;code&gt;$@&lt;/code&gt; . To do either of those, you have to use the &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; facility, or turn off warnings inside the BLOCK or EXPR using &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; . See &lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;, &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt;, and &lt;a href=&quot;../warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">Если есть синтаксическая ошибка или ошибка времени выполнения, или выполняется инструкция &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в скалярном контексте или пустой список в контексте списка, а &lt;code&gt;$@&lt;/code&gt; устанавливается в сообщение об ошибке. (До 5.16 ошибка приводила к тому, что &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; возвращался в контексте списка для синтаксических ошибок, но не для ошибок времени выполнения.) Если ошибки не было, &lt;code&gt;$@&lt;/code&gt; устанавливается в пустую строку. Оператор потока управления, такой как &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; , может обойти настройку &lt;code&gt;$@&lt;/code&gt; . Помните, что использование &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; не запрещает Perl выводить предупреждения в STDERR и не помещает текст предупреждений в &lt;code&gt;$@&lt;/code&gt; . Чтобы выполнить одно из этих действий, вы должны использовать средство &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; или отключить предупреждения внутри BLOCK или EXPR, используя &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; &lt;a href=&quot;no&quot;&gt;без&lt;/a&gt; предупреждений . См. &lt;a href=&quot;warn&quot;&gt;Предупреждение&lt;/a&gt; , &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt; и &lt;a href=&quot;../warnings&quot;&gt;предупреждения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebacccba519ce29c0edb6165a1d7c06041545422" translate="yes" xml:space="preserve">
          <source>If there is a syntax error or runtime error, or a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; statement is executed, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context or an empty list in list context, and &lt;code&gt;$@&lt;/code&gt; is set to the error message. (Prior to 5.16, a bug caused &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to be returned in list context for syntax errors, but not for runtime errors.) If there was no error, &lt;code&gt;$@&lt;/code&gt; is set to the empty string. A control flow operator like &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; can bypass the setting of &lt;code&gt;$@&lt;/code&gt; . Beware that using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; neither silences Perl from printing warnings to STDERR, nor does it stuff the text of warning messages into &lt;code&gt;$@&lt;/code&gt; . To do either of those, you have to use the &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; facility, or turn off warnings inside the BLOCK or EXPR using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; . See &lt;a href=&quot;#warn&quot;&gt;warn&lt;/a&gt;, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;, and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">Если есть синтаксическая ошибка или ошибка времени выполнения, или выполняется инструкция &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в скалярном контексте или пустой список в контексте списка, а &lt;code&gt;$@&lt;/code&gt; устанавливается в сообщение об ошибке. (До 5.16 ошибка приводила к тому, что &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; возвращался в контексте списка для синтаксических ошибок, но не для ошибок времени выполнения.) Если ошибки не было, &lt;code&gt;$@&lt;/code&gt; устанавливается в пустую строку. Оператор потока управления, такой как &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; , может обойти настройку &lt;code&gt;$@&lt;/code&gt; . Помните, что использование &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; не запрещает Perl выводить предупреждения в STDERR и не помещает текст предупреждений в &lt;code&gt;$@&lt;/code&gt; . Чтобы выполнить одно из этих действий, вы должны использовать средство &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; или отключить предупреждения внутри BLOCK или EXPR, используя &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;без&lt;/a&gt; предупреждений . См. &lt;a href=&quot;#warn&quot;&gt;Предупреждение&lt;/a&gt; , &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; и &lt;a href=&quot;warnings&quot;&gt;предупреждения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0363f8d22dbc9b336b291dea3342e0d06c042240" translate="yes" xml:space="preserve">
          <source>If there is already a subroutine of the specified name, then the new sub will either replace the existing one in the glob or be merged with the existing one. A warning may be generated about redefinition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f502d2c87f9e6854805c11486fbe0df87ab65e99" translate="yes" xml:space="preserve">
          <source>If there is already a subroutine of the specified name, then the new sub will replace the existing one in the glob. A warning may be generated about the redefinition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b62d67db30c0ed8a724a981f3cdb26a57d7bac9" translate="yes" xml:space="preserve">
          <source>If there is already a subroutine of the specified name, then the new sub will replace the existing one in the glob. A warning may be generated about the redefinition. If the old subroutine was &lt;code&gt;CvCONST&lt;/code&gt; then the decision about whether to warn is influenced by an expectation about whether the new subroutine will become a constant of similar value. That expectation is determined by &lt;code&gt;const_svp&lt;/code&gt;. (Note that the call to this function doesn't make the new subroutine &lt;code&gt;CvCONST&lt;/code&gt; in any case; that is left to the caller.) If &lt;code&gt;const_svp&lt;/code&gt; is null then it indicates that the new subroutine will not become a constant. If &lt;code&gt;const_svp&lt;/code&gt; is non-null then it indicates that the new subroutine will become a constant, and it points to an &lt;code&gt;SV*&lt;/code&gt; that provides the constant value that the subroutine will have.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5466934b0ce09952bbdf7a873d8e98baf5e63870" translate="yes" xml:space="preserve">
          <source>If there is an error then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">В случае ошибки возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b85ca592364b34a60190d51f6450258a4cd0c81b" translate="yes" xml:space="preserve">
          <source>If there is an error then &lt;code&gt;undef&lt;/code&gt; will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467d2ed550f37bc1b9fda912fd43e11ff12b4118" translate="yes" xml:space="preserve">
          <source>If there is any question about whether a given patch might merit inclusion in a maint release, then it almost certainly should not be included.</source>
          <target state="translated">Если возникает вопрос о том,заслуживает ли данный патч включения в релиз maint,то почти наверняка его не следует включать.</target>
        </trans-unit>
        <trans-unit id="ca419a7d4011e71c524719322dfff4afd6d50991" translate="yes" xml:space="preserve">
          <source>If there is more than one argument in LIST, this calls &lt;a href=&quot;http://man.he.net/man3/execvp&quot;&gt;execvp(3)&lt;/a&gt; with the arguments in LIST. If there is only one element in LIST, the argument is checked for shell metacharacters, and if there are any, the entire argument is passed to the system's command shell for parsing (this is &lt;code&gt;/bin/sh -c&lt;/code&gt; on Unix platforms, but varies on other platforms). If there are no shell metacharacters in the argument, it is split into words and passed directly to &lt;code&gt;execvp&lt;/code&gt;, which is more efficient. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f8376c45472eeb9e97a43b3d977d663509a5686" translate="yes" xml:space="preserve">
          <source>If there is more than one argument in LIST, this calls execvp(3) with the arguments in LIST. If there is only one element in LIST, the argument is checked for shell metacharacters, and if there are any, the entire argument is passed to the system's command shell for parsing (this is &lt;code&gt;/bin/sh -c&lt;/code&gt; on Unix platforms, but varies on other platforms). If there are no shell metacharacters in the argument, it is split into words and passed directly to &lt;code&gt;execvp&lt;/code&gt; , which is more efficient. Examples:</source>
          <target state="translated">Если в LIST более одного аргумента, это вызывает execvp (3) с аргументами из LIST. Если в LIST есть только один элемент, аргумент проверяется на наличие метасимволов оболочки, и если они есть, весь аргумент передается в командную оболочку системы для анализа (это &lt;code&gt;/bin/sh -c&lt;/code&gt; на платформах Unix, но варьируется на других платформах). Если в аргументе нет метасимволов оболочки, он разбивается на слова и передается непосредственно в &lt;code&gt;execvp&lt;/code&gt; , что более эффективно. Примеры:</target>
        </trans-unit>
        <trans-unit id="2594b97a91aa3fa79863d35058be1a8172ac679a" translate="yes" xml:space="preserve">
          <source>If there is no</source>
          <target state="translated">Если нет</target>
        </trans-unit>
        <trans-unit id="836d7eec1f71c6b6f4181b3811b03cbac0e80430" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;\E&lt;/code&gt; , case is converted until the end of the string. The regexps &lt;code&gt;\L\u$word&lt;/code&gt; or &lt;code&gt;\u\L$word&lt;/code&gt; convert the first character of &lt;code&gt;$word&lt;/code&gt; to uppercase and the rest of the characters to lowercase.</source>
          <target state="translated">Если &lt;code&gt;\E&lt;/code&gt; , регистр преобразуется до конца строки. Регулярные выражения &lt;code&gt;\L\u$word&lt;/code&gt; или &lt;code&gt;\u\L$word&lt;/code&gt; преобразуют первый символ &lt;code&gt;$word&lt;/code&gt; в верхний регистр, а остальные символы в нижний регистр.</target>
        </trans-unit>
        <trans-unit id="f1b2b91591fb1955a250148f5d6f9f32438d8436" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;\E&lt;/code&gt;, case is converted until the end of the string. The regexps &lt;code&gt;\L\u$word&lt;/code&gt; or &lt;code&gt;\u\L$word&lt;/code&gt; convert the first character of &lt;code&gt;$word&lt;/code&gt; to uppercase and the rest of the characters to lowercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c73d7b3af9d178254858949bc270c269c6e2e60d" translate="yes" xml:space="preserve">
          <source>If there is no INSTALL.SKIP file in the make directory then this value can be used to provide a default.</source>
          <target state="translated">Если в директории make нет файла INSTALL.SKIP,то это значение может быть использовано для предоставления значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3610af61096f12f4c9e6f52b35a24b772a2c16bd" translate="yes" xml:space="preserve">
          <source>If there is no Pod in the given document, then the event structure will be this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="349639462c1781c6c7203933948097f1b032dbf1" translate="yes" xml:space="preserve">
          <source>If there is no case folding for the input code point, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если для входной кодовой точки нет сворачивания регистра, возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fb296c4463c79fc259188fecb37636b958c8768" translate="yes" xml:space="preserve">
          <source>If there is no case folding for the input code point, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a8d9cc6cec6caebf969b32884584509dabbda2" translate="yes" xml:space="preserve">
          <source>If there is no corresponding capture group defined, then it is a fatal error. Recursing deeper than 50 times without consuming any input string will also result in a fatal error. The maximum depth is compiled into perl, so changing it requires a custom build.</source>
          <target state="translated">Если соответствующая группа захвата не определена,то это является фатальной ошибкой.Повторение более 50 раз глубже,не потребляя ни одной входной строки,также приведет к фатальной ошибке.Максимальная глубина скомпилирована в perl,поэтому ее изменение требует пользовательской сборки.</target>
        </trans-unit>
        <trans-unit id="9a6e24a6b319d54eae6772ce7d4930464be16411" translate="yes" xml:space="preserve">
          <source>If there is no corresponding capture group defined, then it is a fatal error. Recursing deeply without consuming any input string will also result in a fatal error. The depth at which that happens is compiled into perl, so it can be changed with a custom build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28265c4ced5473656451fd65ecb5d6a73bdd1b4e" translate="yes" xml:space="preserve">
          <source>If there is no description, its the same as the parameter to WriteMakefile() documented in &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c7947682ddf8ce5897cbba5d096660017802ec" translate="yes" xml:space="preserve">
          <source>If there is no description, its the same as the parameter to WriteMakefile() documented in ExtUtils::MakeMaker.</source>
          <target state="translated">Если нет описания,то оно совпадает с параметром WriteMakefile(),документированным в ExtUtils::MakeMaker.</target>
        </trans-unit>
        <trans-unit id="9a08244ff3de5da70abd74d4f48bc9a98bd5fd63" translate="yes" xml:space="preserve">
          <source>If there is no error, then the method returns the value of the last expression evaluated, or a return statement may be used, just as with subroutines and &lt;b&gt;eval()&lt;/b&gt;. The context (list or scalar) is determined by the caller as usual.</source>
          <target state="translated">Если ошибки нет, то метод возвращает значение последнего вычисленного выражения, или можно использовать оператор return, как и в случае с подпрограммами и &lt;b&gt;eval ()&lt;/b&gt; . Контекст (список или скаляр) определяется вызывающей стороной, как обычно.</target>
        </trans-unit>
        <trans-unit id="9fcf9881e5055fcb38df136c867429f9722c1a7e" translate="yes" xml:space="preserve">
          <source>If there is no global precision or accuracy set, &lt;b&gt;and&lt;/b&gt; the operation in question was not called with a requested precision or accuracy, &lt;b&gt;and&lt;/b&gt; the input $x has no accuracy or precision set, then a fallback parameter will be used. For historical reasons, it is called &lt;code&gt;div_scale&lt;/code&gt; and can be accessed via:</source>
          <target state="translated">Если не задана глобальная точность или точность, &lt;b&gt;и&lt;/b&gt; рассматриваемая операция не была вызвана с запрошенной точностью или точностью, &lt;b&gt;и&lt;/b&gt; вход $ x не имеет точности или точности, то будет использоваться резервный параметр. По историческим причинам он называется &lt;code&gt;div_scale&lt;/code&gt; и доступен через:</target>
        </trans-unit>
        <trans-unit id="bbd1fd130f18a572d29a93b5834a0fdb0347ebb7" translate="yes" xml:space="preserve">
          <source>If there is no interactivity then you may still want to look at using something like &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fmodule%2fTemplate&quot;&gt;Template Toolkit&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::TemplateToolkit&quot;&gt;Plack::Middleware::TemplateToolkit&lt;/a&gt; so maintenance of your HTML files (and other assets) is easier.</source>
          <target state="translated">Если интерактивности нет, вы все равно можете использовать что-то вроде &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fmodule%2fTemplate&quot;&gt;Template Toolkit&lt;/a&gt; или &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::TemplateToolkit&quot;&gt;Plack :: Middleware :: TemplateToolkit,&lt;/a&gt; чтобы упростить обслуживание ваших HTML-файлов (и других ресурсов).</target>
        </trans-unit>
        <trans-unit id="a299e842222c6ed90a64aa41cd2a789a3c361e2f" translate="yes" xml:space="preserve">
          <source>If there is no interactivity then you may still want to look at using something like &lt;a href=&quot;https://metacpan.org/module/Template&quot;&gt;Template Toolkit&lt;/a&gt; or &lt;a href=&quot;Plack::Middleware::TemplateToolkit&quot;&gt;Plack::Middleware::TemplateToolkit&lt;/a&gt; so maintenance of your HTML files (and other assets) is easier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dd8956e9b63cae584008cf6c1bbe7cd26c8c5c5" translate="yes" xml:space="preserve">
          <source>If there is no matching entry found and there is no default defined, or no .netrc file is found, then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если соответствующая запись не найдена и не определено значение по умолчанию, или файл .netrc не найден, возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6537a61412be05c76bbd6dbb9043f0a60ac95b9" translate="yes" xml:space="preserve">
          <source>If there is no matching entry found and there is no default defined, or no .netrc file is found, then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6dfba39c8f615f2c8441ca5b61296e07f9cf19" translate="yes" xml:space="preserve">
          <source>If there is no top hub, and you do not ask to leave IPC and formatter undef, then a new formatter will be created, and the IPC instance from &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40165726268e187e7ad5a226c93cb70fb5e7ae2c" translate="yes" xml:space="preserve">
          <source>If there is only one argument and it is a reference to an array then the array is assumed to contain a list of key-value pairs specifying the options. In this case the option &quot;from_to&quot; is mandatory. This style means that you do not have to supply a cryptic list of arguments and can use a self documenting argument list that is easier to understand.</source>
          <target state="translated">Если есть только один аргумент и это ссылка на массив,то предполагается,что массив содержит список пар ключ-значение с указанием опций.В этом случае опция &quot;from_to&quot; является обязательной.Этот стиль означает,что вам не нужно предоставлять зашифрованный список аргументов,и вы можете использовать более понятный для понимания самостоятельно документируемый список аргументов.</target>
        </trans-unit>
        <trans-unit id="663e6f7ad7626839945e055f61dd00fa139292d7" translate="yes" xml:space="preserve">
          <source>If there was an error authenticating the user then</source>
          <target state="translated">Если произошла ошибка аутентификации пользователя,то</target>
        </trans-unit>
        <trans-unit id="c4805e4afe7a0ccfe45caa54514a077972082082" translate="yes" xml:space="preserve">
          <source>If there's already an entry in &lt;code&gt;%table&lt;/code&gt; for the current &lt;code&gt;$country&lt;/code&gt; , then nothing is different. Line 6 will locate the value in &lt;code&gt;$table{$country}&lt;/code&gt; , which is a reference to an array, and push &lt;code&gt;$city&lt;/code&gt; into the array. But what does it do when &lt;code&gt;$country&lt;/code&gt; holds a key, say &lt;code&gt;Greece&lt;/code&gt; , that is not yet in &lt;code&gt;%table&lt;/code&gt; ?</source>
          <target state="translated">Если в &lt;code&gt;%table&lt;/code&gt; уже есть запись для текущей &lt;code&gt;$country&lt;/code&gt; , то ничего не изменилось. Строка 6 найдет значение в &lt;code&gt;$table{$country}&lt;/code&gt; , которое является ссылкой на массив, и поместит &lt;code&gt;$city&lt;/code&gt; в массив. Но что он делает, когда &lt;code&gt;$country&lt;/code&gt; имеет ключ, скажем, &lt;code&gt;Greece&lt;/code&gt; , которого еще нет в &lt;code&gt;%table&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="9e3670f66abc27b9c0c1a9a3a64b0edd5b7f7779" translate="yes" xml:space="preserve">
          <source>If there's already an entry in &lt;code&gt;%table&lt;/code&gt; for the current &lt;code&gt;$country&lt;/code&gt;, then nothing is different. Line 6 will locate the value in &lt;code&gt;$table{$country}&lt;/code&gt;, which is a reference to an array, and push &lt;code&gt;$city&lt;/code&gt; into the array. But what does it do when &lt;code&gt;$country&lt;/code&gt; holds a key, say &lt;code&gt;Greece&lt;/code&gt;, that is not yet in &lt;code&gt;%table&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79b95fc8b6f0bdad9a42663607fbb6bbfce24c2" translate="yes" xml:space="preserve">
          <source>If there's no &lt;code&gt;\w&lt;/code&gt; in &lt;code&gt;s1&lt;/code&gt; nor in &lt;code&gt;s2&lt;/code&gt; , why does their concatenation have one?</source>
          <target state="translated">Если нет &lt;code&gt;\w&lt;/code&gt; ни в &lt;code&gt;s1&lt;/code&gt; , ни в &lt;code&gt;s2&lt;/code&gt; , почему у их конкатенации он есть?</target>
        </trans-unit>
        <trans-unit id="f998e73c18ed98eef0579d8f9950627eae9eb668" translate="yes" xml:space="preserve">
          <source>If there's no &lt;code&gt;\w&lt;/code&gt; in &lt;code&gt;s1&lt;/code&gt; nor in &lt;code&gt;s2&lt;/code&gt;, why does their concatenation have one?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e887683b17f434ea92edf8b372be7bfa0a590185" translate="yes" xml:space="preserve">
          <source>If there's no handle_unknown_option, then we just warn, and then increment the error counter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d867e0a4fd4a8ea827c16a08b87197c9c461d55" translate="yes" xml:space="preserve">
          <source>If these dependent libraries are not listed at shared library creation time, you will get fatal &quot;Unresolved symbol&quot; errors at run time when the library is loaded.</source>
          <target state="translated">Если эти зависимые библиотеки не перечислены во время создания общей библиотеки,вы получите фатальные ошибки &quot;Unresolved symbol&quot; во время выполнения,когда библиотека будет загружена.</target>
        </trans-unit>
        <trans-unit id="66c4d2d6f3874b5b92940f178682f9bbdd8c1db5" translate="yes" xml:space="preserve">
          <source>If these operators are not explicitly overloaded then they work in the normal way, yielding the underlying scalar, array, or whatever stores the object data (or the appropriate error message if the dereference operator doesn't match it). Defining a catch-all &lt;code&gt;'nomethod'&lt;/code&gt; (see &lt;a href=&quot;#nomethod&quot;&gt;below&lt;/a&gt;) makes no difference to this as the catch-all function will not be called to implement a missing dereference operator.</source>
          <target state="translated">Если эти операторы явно не перегружены, они работают обычным образом, давая базовый скаляр, массив или что-то еще, что хранит данные объекта (или соответствующее сообщение об ошибке, если оператор разыменования не соответствует ему). Определение &lt;code&gt;'nomethod'&lt;/code&gt; (см. &lt;a href=&quot;#nomethod&quot;&gt;Ниже&lt;/a&gt; ) не имеет никакого значения, поскольку универсальная функция не будет вызываться для реализации отсутствующего оператора разыменования.</target>
        </trans-unit>
        <trans-unit id="e7e81ed1aafee87e39f3bf4df7400134171b1b47" translate="yes" xml:space="preserve">
          <source>If these were ordinary paragraphs, the Pod parser would try to expand the &quot;E&amp;lt;/em&amp;gt;&quot; (in the first paragraph) as a formatting code, just like &quot;E&amp;lt;lt&amp;gt;&quot; or &quot;E&amp;lt;eacute&amp;gt;&quot;. But since this is in a &quot;=begin</source>
          <target state="translated">Если бы это были обычные абзацы, синтаксический анализатор Pod попытался бы развернуть &amp;laquo;E &amp;lt;/em&amp;gt;&amp;raquo; (в первом абзаце) как код форматирования, как &amp;laquo;E &amp;lt;lt&amp;gt;&amp;raquo; или &amp;laquo;E &amp;lt;eacute&amp;gt;&amp;raquo;. Но поскольку это находится в &quot;= begin</target>
        </trans-unit>
        <trans-unit id="fc6b5f11ab146ad9637defe5808c195788361c30" translate="yes" xml:space="preserve">
          <source>If these weren't meant to be POSIX classes, this warning message is spurious, and can be suppressed by reordering things, such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4135dfc8a9407c20cefc1359ee43028a8d9e9a77" translate="yes" xml:space="preserve">
          <source>If they are not composable, it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если они несовместимы, возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a6c7139e709a41aafbcb832650d6f1102386857" translate="yes" xml:space="preserve">
          <source>If they are not composable, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7928853cb29cf0ed7b6549f627a68e66710a9993" translate="yes" xml:space="preserve">
          <source>If they wanted to clobber something, they might say:</source>
          <target state="translated">Если бы они хотели что-нибудь засорить,они могли бы сказать:</target>
        </trans-unit>
        <trans-unit id="005637a170229ceb4ce45f18dce99b88396f9f92" translate="yes" xml:space="preserve">
          <source>If things aren't broken, upgrading perl may break them (or at least issue new warnings).</source>
          <target state="translated">Если вещи не сломаны,обновление perl может их сломать (или,по крайней мере,выдать новые предупреждения).</target>
        </trans-unit>
        <trans-unit id="f401b770207b3e95d6e44d96ff6ad2d9bf229b05" translate="yes" xml:space="preserve">
          <source>If this attribute is set to true, the parser will not ignore empty &lt;code&gt;=over&lt;/code&gt;/&lt;code&gt;=back&lt;/code&gt; blocks. The type of &lt;code&gt;=over&lt;/code&gt; will be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af3184843a959ec8cbcadf6df48b4b495b6b3f78" translate="yes" xml:space="preserve">
          <source>If this behaviour is not desirable, the &lt;code&gt;error&lt;/code&gt; attribute may be used to hold a reference to a variable, which will be used to store the diagnostics. The variable is made a reference to an array of hash references. Each hash contain a single key/value pair where the key is the name of the file, and the value is the error message (including the contents of &lt;code&gt;$!&lt;/code&gt; when appropriate). If a general error is encountered the diagnostic key will be empty.</source>
          <target state="translated">Если такое поведение нежелательно, атрибут &lt;code&gt;error&lt;/code&gt; может использоваться для хранения ссылки на переменную, которая будет использоваться для хранения диагностики. Переменная делает ссылку на массив хеш-ссылок. Каждый хэш содержит одну пару ключ / значение, где ключ - это имя файла, а значение - это сообщение об ошибке (включая содержимое &lt;code&gt;$!&lt;/code&gt; При необходимости). При обнаружении общей ошибки диагностический ключ будет пустым.</target>
        </trans-unit>
        <trans-unit id="b9e80a2a00d7763bcb33166ac12286d96be2d204" translate="yes" xml:space="preserve">
          <source>If this bit is set and a file [but not a directory] named &lt;code&gt;$sNewName&lt;/code&gt; already exists, then it will be replaced by &lt;code&gt;$sOldName&lt;/code&gt;. If this bit is not set then &lt;code&gt;MoveFileEx&lt;/code&gt; will fail rather than replace an existing &lt;code&gt;$sNewName&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa9fb1ea3eae474e9c243073b7277960fe7cd8b7" translate="yes" xml:space="preserve">
          <source>If this bit is set, then calls to &lt;code&gt;CloseHandle&lt;/code&gt; against this handle will be ignored, leaving the handle open and usable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0ba2e4466abc8ea8b16e3596960ca402d75037" translate="yes" xml:space="preserve">
          <source>If this bit is set, then children of this process who inherit handles [that is, processes created by calls to the Win32 &lt;code&gt;CreateProcess&lt;/code&gt; API with the &lt;code&gt;bInheritHandles&lt;/code&gt; parameter specified as &lt;code&gt;TRUE&lt;/code&gt;], will inherit this particular object handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfffc413c869bcf00848584ef88629d0cba8d4b7" translate="yes" xml:space="preserve">
          <source>If this command lists any paths that don't exist on your system, then you may need to move the appropriate libraries to these locations, or create symbolic links, aliases, or shortcuts appropriately. &lt;code&gt;@INC&lt;/code&gt; is also printed as part of the output of</source>
          <target state="translated">Если эта команда перечисляет любые пути, которые не существуют в вашей системе, вам может потребоваться переместить соответствующие библиотеки в эти места или создать символические ссылки, псевдонимы или ярлыки соответствующим образом. &lt;code&gt;@INC&lt;/code&gt; также печатается как часть вывода</target>
        </trans-unit>
        <trans-unit id="4975023e8ced451b521e66f7c64344d22c9935aa" translate="yes" xml:space="preserve">
          <source>If this directory is exactly the same as the prefix which was compiled into</source>
          <target state="translated">Если этот каталог точно совпадает с префиксом,который был скомпилирован в</target>
        </trans-unit>
        <trans-unit id="285c8028480f1bd9da414482302791b2b2e5917d" translate="yes" xml:space="preserve">
          <source>If this displays any &lt;code&gt;D&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; symbols (or possibly &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; ), you have non-const data. The symbols the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; removed are as follows: &lt;code&gt;Tt&lt;/code&gt; are</source>
          <target state="translated">Если здесь отображаются какие- либо символы &lt;code&gt;D&lt;/code&gt; или &lt;code&gt;d&lt;/code&gt; (или, возможно, &lt;code&gt;C&lt;/code&gt; или &lt;code&gt;c&lt;/code&gt; ), у вас неконстантные данные. Символы, удаленные с помощью &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; , следующие: &lt;code&gt;Tt&lt;/code&gt; are</target>
        </trans-unit>
        <trans-unit id="e00722416b7c55f26c8b791511437fbf3bd5fa48" translate="yes" xml:space="preserve">
          <source>If this displays any &lt;code&gt;D&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; symbols (or possibly &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt;), you have non-const data. The symbols the &lt;code&gt;grep&lt;/code&gt; removed are as follows: &lt;code&gt;Tt&lt;/code&gt; are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4abdac7aa391382bc2754c2374cb867d27e05580" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to a true value, all of the functions defined by this module (color(), colored(), and all of the constants not previously used in the program) will not output any escape sequences and instead will just return the empty string or pass through the original text as appropriate. This is intended to support easy use of scripts using this module on platforms that don't support ANSI escape sequences.</source>
          <target state="translated">Если эта переменная окружения установлена в значение true,то все функции,определенные этим модулем (color(),color(),и все константы,ранее не использовавшиеся в программе),не будут выводить никаких экранирующих последовательностей,а вместо этого будут просто возвращать пустую строку или передавать по исходному тексту по мере необходимости.Это предназначено для поддержки простого использования скриптов,использующих данный модуль,на платформах,которые не поддерживают ANSI экранирующие последовательности.</target>
        </trans-unit>
        <trans-unit id="38f035ce9a9a2458333cab9abdbe9a0ca164bacc" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to a true value, all of the functions defined by this module (color(), colored(), and all of the constants) will not output any escape sequences and instead will just return the empty string or pass through the original text as appropriate. This is intended to support easy use of scripts using this module on platforms that don't support ANSI escape sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18c65b6596250b7fc84f994b0860dfb64443933" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to any value, it suppresses generation of escape sequences the same as if ANSI_COLORS_DISABLED is set to a true value. This implements the &lt;a href=&quot;https://no-color.org/&quot;&gt;https://no-color.org/&lt;/a&gt; informal standard. Programs that want to enable color despite NO_COLOR being set will need to unset that environment variable before any constant or function provided by this module is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876cbaf8d98a55944949f12e34d25c434a20bad7" translate="yes" xml:space="preserve">
          <source>If this environment variable is true then normal install processes will always overwrite older identical files during the install process.</source>
          <target state="translated">Если эта переменная окружения верна,то обычные процессы установки всегда будут перезаписывать старые идентичные файлы в процессе установки.</target>
        </trans-unit>
        <trans-unit id="e053edd732d7c1c9c9166271bdb64b8b374b5d23" translate="yes" xml:space="preserve">
          <source>If this event is nested inside of other events, this should be the depth of nesting. (This is mainly for subtests)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b941d4f353a594151f4f0a38deaca7c7d4a4d4" translate="yes" xml:space="preserve">
          <source>If this feature is enabled (which is the default under a &lt;code&gt;use 5.16&lt;/code&gt; or higher declaration), EXPR is considered to be in the same encoding as the surrounding program. Thus if &lt;a href=&quot;utf8&quot;&gt;&lt;code&gt;use utf8&lt;/code&gt;&lt;/a&gt; is in effect, the string will be treated as being UTF-8 encoded. Otherwise, the string is considered to be a sequence of independent bytes. Bytes that correspond to ASCII-range code points will have their normal meanings for operators in the string. The treatment of the other bytes depends on if the &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;'unicode_strings&quot;&lt;/code&gt; feature&lt;/a&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7eb5123560aed4a2756b83ae3d2c52a26a17f8b" translate="yes" xml:space="preserve">
          <source>If this field is omitted, it defaults to 1 (true).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07fe5d03fc19f605909f122565e563658cd995e6" translate="yes" xml:space="preserve">
          <source>If this field is zero then &lt;code&gt;PerlIO_pushed&lt;/code&gt; does not malloc anything and assumes layer's Pushed function will do any required layer stack manipulation - used to avoid malloc/free overhead for dummy layers. If the field is non-zero it must be at least the size of &lt;code&gt;PerlIOl&lt;/code&gt; , &lt;code&gt;PerlIO_pushed&lt;/code&gt; will allocate memory for the layer's data structures and link new layer onto the stream's stack. (If the layer's Pushed method returns an error indication the layer is popped again.)</source>
          <target state="translated">Если это поле равно нулю, то &lt;code&gt;PerlIO_pushed&lt;/code&gt; ничего не выполняет malloc и предполагает, что функция Pushing будет выполнять любые необходимые манипуляции со стеком слоев - используемые для предотвращения накладных расходов malloc / free для фиктивных слоев. Если поле не равно нулю, оно должно быть не меньше &lt;code&gt;PerlIOl&lt;/code&gt; , &lt;code&gt;PerlIO_pushed&lt;/code&gt; выделит память для структур данных уровня и свяжет новый уровень со стеком потока. (Если метод слоя Pushing возвращает сообщение об ошибке, слой снова открывается.)</target>
        </trans-unit>
        <trans-unit id="a5a45df8d66f9a394f3a4c96ed9c17f127fd5118" translate="yes" xml:space="preserve">
          <source>If this field is zero then &lt;code&gt;PerlIO_pushed&lt;/code&gt; does not malloc anything and assumes layer's Pushed function will do any required layer stack manipulation - used to avoid malloc/free overhead for dummy layers. If the field is non-zero it must be at least the size of &lt;code&gt;PerlIOl&lt;/code&gt;, &lt;code&gt;PerlIO_pushed&lt;/code&gt; will allocate memory for the layer's data structures and link new layer onto the stream's stack. (If the layer's Pushed method returns an error indication the layer is popped again.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eff879286b0f884c3e6b0dc473e05a91d80d4a8" translate="yes" xml:space="preserve">
          <source>If this function is being sourced in from a separate file via &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, then this is probably just fine. If it's all in the main program, you'll need to arrange for the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; to be executed early, either by putting the whole block above your main program, or more likely, placing merely a &lt;code&gt;BEGIN&lt;/code&gt; code block around it to make sure it gets executed before your program starts to run:</source>
          <target state="translated">Если эта функция получена из отдельного файла с помощью &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , то, вероятно, это нормально. Если это все в основной программе, вам необходимо организовать выполнение &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; на раннем этапе, либо поместив весь блок над основной программой, либо, что более вероятно, просто поместив вокруг него просто &lt;code&gt;BEGIN&lt;/code&gt; кода BEGIN, чтобы убедиться, что он выполняется перед запуском вашей программы:</target>
        </trans-unit>
        <trans-unit id="3b08fb8fb677146606e9cfcd0ad7806affc639d2" translate="yes" xml:space="preserve">
          <source>If this function is being sourced in from a separate file via &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt;, then this is probably just fine. If it's all in the main program, you'll need to arrange for the &lt;code&gt;my&lt;/code&gt; to be executed early, either by putting the whole block above your main program, or more likely, placing merely a &lt;code&gt;BEGIN&lt;/code&gt; code block around it to make sure it gets executed before your program starts to run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5121e7b7256f6d0ab378dc9bff9a8c6dad43577" translate="yes" xml:space="preserve">
          <source>If this happens to you, there's not much you can do except switch to use a different locale or use &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; to translate from the locale into UTF-8; if that's impracticable, you have been warned that some things may break.</source>
          <target state="translated">Если это произойдет с вами, вы ничего не можете сделать, кроме как переключиться на использование другого языкового стандарта или использовать &lt;a href=&quot;encode&quot;&gt;кодирование&lt;/a&gt; для перевода из языкового стандарта в UTF-8; если это невозможно, вас предупредили, что некоторые вещи могут сломаться.</target>
        </trans-unit>
        <trans-unit id="faa64c33180aaefa8582782daf214d7a2f4780a7" translate="yes" xml:space="preserve">
          <source>If this interior sequence is nested inside of another interior sequence, then the outer/parent sequence that contains it is returned. Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если эта внутренняя последовательность вложена в другую внутреннюю последовательность, то возвращается содержащая ее внешняя / родительская последовательность. В противном случае возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf7d995797b0338af1d03b9d03a8511323aeb269" translate="yes" xml:space="preserve">
          <source>If this is a TODO test and an 'ok' line, this method returns true. Otherwise, it will always return false (regardless of passing status on non-todo tests).</source>
          <target state="translated">Если это тест TODO и строка 'ok',то этот метод возвращает true.В противном случае,он всегда будет возвращать false (независимо от прохождения статуса на non-todo тестах).</target>
        </trans-unit>
        <trans-unit id="604eb865cff5427575c78b447eb628e9c645992c" translate="yes" xml:space="preserve">
          <source>If this is a simple scalar then it will be treated as a boolean for the 'buffered' setting. If this is a hash reference then it will be used as a parameters hash. The param hash will be used for hub construction (with the specified keys removed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7666722db0ac2cfa26e5cabc574e02e68556877" translate="yes" xml:space="preserve">
          <source>If this is being called as &lt;code&gt;re::regname&lt;/code&gt; , &lt;code&gt;re::regnames&lt;/code&gt; or &lt;code&gt;re::regnames_count&lt;/code&gt; , if any. The first two will be combined with &lt;code&gt;RXapif_ONE&lt;/code&gt; or &lt;code&gt;RXapif_ALL&lt;/code&gt; .</source>
          <target state="translated">Если это вызывается как &lt;code&gt;re::regname&lt;/code&gt; , &lt;code&gt;re::regnames&lt;/code&gt; или &lt;code&gt;re::regnames_count&lt;/code&gt; , если есть. Первые два будут объединены с &lt;code&gt;RXapif_ONE&lt;/code&gt; или &lt;code&gt;RXapif_ALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79a068f47ba129d0ff77349a01057b9518f8fbed" translate="yes" xml:space="preserve">
          <source>If this is being called as &lt;code&gt;re::regname&lt;/code&gt;, &lt;code&gt;re::regnames&lt;/code&gt; or &lt;code&gt;re::regnames_count&lt;/code&gt;, if any. The first two will be combined with &lt;code&gt;RXapif_ONE&lt;/code&gt; or &lt;code&gt;RXapif_ALL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9edbce2664bb4f91955d900ea95b27deaa6b5a4b" translate="yes" xml:space="preserve">
          <source>If this is in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; it will be passed to &lt;code&gt;Perl_fbm_instr&lt;/code&gt; by &lt;code&gt;pp_split&lt;/code&gt; which will treat the subject string as a multi-line string.</source>
          <target state="translated">Если он находится в &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; , он будет передан &lt;code&gt;Perl_fbm_instr&lt;/code&gt; с помощью &lt;code&gt;pp_split&lt;/code&gt; , который будет рассматривать строку темы как многострочную строку.</target>
        </trans-unit>
        <trans-unit id="3e0c042153cf9f6ff54247584b15672ab611a4af" translate="yes" xml:space="preserve">
          <source>If this is negative, and amounts to &lt;code&gt;HEf_SVKEY&lt;/code&gt; , it indicates the entry holds an &lt;code&gt;SV*&lt;/code&gt; key. Otherwise, holds the actual length of the key. Can be assigned to. The &lt;code&gt;HePV()&lt;/code&gt; macro is usually preferable for finding key lengths.</source>
          <target state="translated">Если это отрицательное значение и составляет &lt;code&gt;HEf_SVKEY&lt;/code&gt; , это означает, что запись содержит ключ &lt;code&gt;SV*&lt;/code&gt; . В противном случае содержит фактическую длину ключа. Может быть назначен. &lt;code&gt;HePV()&lt;/code&gt; макро, как правило , предпочтительнее для нахождения длины ключа.</target>
        </trans-unit>
        <trans-unit id="f90d0f4d493e8df7c15bcc83bca70a42ffcdb6df" translate="yes" xml:space="preserve">
          <source>If this is negative, and amounts to &lt;code&gt;HEf_SVKEY&lt;/code&gt;, it indicates the entry holds an &lt;code&gt;SV*&lt;/code&gt; key. Otherwise, holds the actual length of the key. Can be assigned to. The &lt;code&gt;HePV()&lt;/code&gt; macro is usually preferable for finding key lengths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddda819aeefa94d361f2fc0677ccc065e6c33f4f" translate="yes" xml:space="preserve">
          <source>If this is starting to sound scarier than it's worth, relax. Perl has some features to help you avoid its most common pitfalls. The best way to avoid getting confused is to start every program like this:</source>
          <target state="translated">Если это начинает звучать страшнее,чем стоит,расслабься.Perl имеет некоторые особенности,чтобы помочь вам избежать его наиболее распространенных подводных камней.Лучший способ избежать путаницы-запустить каждую программу таким образом:</target>
        </trans-unit>
        <trans-unit id="c2cd7396387cdb373b2dd32a6d21ffa39a9fbdd0" translate="yes" xml:space="preserve">
          <source>If this is true, none of that will be done.</source>
          <target state="translated">Если это правда,ничего из этого не будет сделано.</target>
        </trans-unit>
        <trans-unit id="998c59b2484753d1482d0ff9ba7497a84e80fcd4" translate="yes" xml:space="preserve">
          <source>If this is what you intended then you can silence the warning by using &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/${\}/&lt;/a&gt;&lt;/code&gt; (for example: &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo${\}s+bar/&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если это именно то, что вы намеревались сделать, вы можете отключить предупреждение, используя &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/${\}/&lt;/a&gt;&lt;/code&gt; (например: &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo${\}s+bar/&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="44c23df76d34643bd06f7fcbfd01951d86e6affe" translate="yes" xml:space="preserve">
          <source>If this is what you intended then you can silence the warning by using &lt;code&gt;m/${\}/&lt;/code&gt; (for example: &lt;code&gt;m/foo${\}s+bar/&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f4b7328771b0d9e19ff0a7ce5f9c13e4b36300" translate="yes" xml:space="preserve">
          <source>If this is your first use of Sys::Syslog, you must read the doc.</source>
          <target state="translated">Если это ваше первое использование Sys::Syslog,вы должны прочитать документ.</target>
        </trans-unit>
        <trans-unit id="51d2478f45a9802ed436c7d6c5c2a5bb72aeb395" translate="yes" xml:space="preserve">
          <source>If this optimization is applicable, &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; will emit a &lt;code&gt;dXSTARG;&lt;/code&gt; definition at the start of the generated XSUB code, and type (see below) dependent code to set &lt;code&gt;TARG&lt;/code&gt; and push it on the stack at the end of the generated XSUB code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51861420a23f19227e776c6bc3a38fdcea309df1" translate="yes" xml:space="preserve">
          <source>If this option is not present, the value stored in XFL field will be determined by the setting of the &lt;code&gt;Level&lt;/code&gt; option.</source>
          <target state="translated">Если этот параметр отсутствует, значение, хранящееся в поле XFL, будет определяться настройкой параметра &amp;laquo; &lt;code&gt;Level&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="415323d14a6e182890345d78f7ae3f3149cdff1f" translate="yes" xml:space="preserve">
          <source>If this option is set and the input file/buffer is not compressed data, the module will allow reading of it anyway.</source>
          <target state="translated">Если эта опция установлена и входной файл/буфер не сжат,то модуль все равно разрешит его чтение.</target>
        </trans-unit>
        <trans-unit id="805aae725ba9def01f764562edc887adcbc46d85" translate="yes" xml:space="preserve">
          <source>If this option is set, Pod::Man will instead output UTF-8. If your *roff implementation can handle it, this is the best output format to use and avoids corruption of documents containing non-ASCII characters. However, be warned that *roff source with literal UTF-8 characters is not supported by many implementations and may even result in segfaults and other bad behavior.</source>
          <target state="translated">Если эта опция установлена,то Pod::Man вместо этого выведет UTF-8.Если ваша *roff реализация может справиться с этим,то это лучший формат вывода для использования и позволяет избежать повреждения документов,содержащих не-ASCII символы.Однако,следует предупредить,что *roff-источник с буквальными символами UTF-8 не поддерживается многими реализациями и может даже привести к сегментации и другому плохому поведению.</target>
        </trans-unit>
        <trans-unit id="9276827e0a43ce0cd98e803156d215d94a1cfced" translate="yes" xml:space="preserve">
          <source>If this paragraph is a command paragraph, then this method will return the name of the command (</source>
          <target state="translated">Если этот параграф является параграфом команды,то этот метод вернет имя команды (</target>
        </trans-unit>
        <trans-unit id="bcc44b3b4b66c03b7a2464f3e737f50efd9dbf21" translate="yes" xml:space="preserve">
          <source>If this paragraph is a command paragraph, then this method will return the prefix used to denote the command (which should be the string &quot;=&quot; or &quot;==&quot;).</source>
          <target state="translated">Если этот параграф является параграфом команды,то этот метод вернет префикс,используемый для обозначения команды (которым должна быть строка &quot;=&quot; или &quot;==&quot;).</target>
        </trans-unit>
        <trans-unit id="97d5af9792754821d43f791eb7a3e99d0e1078a4" translate="yes" xml:space="preserve">
          <source>If this paragraph is a command paragraph, then this method will return the text used to separate the command name from the rest of the paragraph (if any).</source>
          <target state="translated">Если этот параграф является параграфом команды,то этот метод вернет текст,используемый для отделения имени команды от остальной части параграфа (если таковой имеется).</target>
        </trans-unit>
        <trans-unit id="b75f187e2f383fe73ad62fc9d325ab173aba9b5e" translate="yes" xml:space="preserve">
          <source>If this parameter is not used, certain error conditions may raise a fatal error that will cause the program to halt, unless trapped in an &lt;code&gt;eval&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f4b76081f3628eb70be0fbee8dbf0d6e9f3ca4" translate="yes" xml:space="preserve">
          <source>If this parameter is not used, certain error conditions may raise a fatal error that will cause the program will halt, unless trapped in an &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block.</source>
          <target state="translated">Если этот параметр не используется, определенные условия ошибки могут вызвать фатальную ошибку, которая приведет к остановке программы, если только она не попала в блок &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d2fb08e29fba6225fdf1f445f37f2366e459721" translate="yes" xml:space="preserve">
          <source>If this regexp matches, &lt;code&gt;$1&lt;/code&gt; contains a string starting with &lt;code&gt;'ab'&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; is either set to &lt;code&gt;'cd'&lt;/code&gt; or &lt;code&gt;'ef'&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; equals either &lt;code&gt;'gi'&lt;/code&gt; or &lt;code&gt;'j'&lt;/code&gt; , and &lt;code&gt;$4&lt;/code&gt; is either set to &lt;code&gt;'gi'&lt;/code&gt; , just like &lt;code&gt;$3&lt;/code&gt; , or it remains undefined.</source>
          <target state="translated">Если это регулярное выражение совпадает, &lt;code&gt;$1&lt;/code&gt; содержит строку, начинающуюся с &lt;code&gt;'ab'&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; либо имеет значение &lt;code&gt;'cd'&lt;/code&gt; , либо &lt;code&gt;'ef'&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; равно либо &lt;code&gt;'gi'&lt;/code&gt; , либо &lt;code&gt;'j'&lt;/code&gt; , а &lt;code&gt;$4&lt;/code&gt; либо равно &lt;code&gt;'gi'&lt;/code&gt; , просто как &lt;code&gt;$3&lt;/code&gt; , или он остается неопределенным.</target>
        </trans-unit>
        <trans-unit id="1b5fa9692a7ddbf5956b5114988e2959b2c5e493" translate="yes" xml:space="preserve">
          <source>If this regexp matches, &lt;code&gt;$1&lt;/code&gt; contains a string starting with &lt;code&gt;'ab'&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; is either set to &lt;code&gt;'cd'&lt;/code&gt; or &lt;code&gt;'ef'&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt; equals either &lt;code&gt;'gi'&lt;/code&gt; or &lt;code&gt;'j'&lt;/code&gt;, and &lt;code&gt;$4&lt;/code&gt; is either set to &lt;code&gt;'gi'&lt;/code&gt;, just like &lt;code&gt;$3&lt;/code&gt;, or it remains undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf2f5a008449abe516d485f423f30c756bf9374" translate="yes" xml:space="preserve">
          <source>If this seems like a lot, then feel free to inherit from merely the standard Tie::StdHash module for most of your methods, redefining only the interesting ones. See &lt;a href=&quot;Tie::Hash&quot;&gt;Tie::Hash&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f92dc123bfc535dc7925652fedf35a2b5f0876" translate="yes" xml:space="preserve">
          <source>If this seems like a lot, then feel free to inherit from merely the standard Tie::StdHash module for most of your methods, redefining only the interesting ones. See &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; for details.</source>
          <target state="translated">Если это кажется большим, то не стесняйтесь наследовать от стандартного модуля Tie :: StdHash для большинства ваших методов, переопределяя только самые интересные. Подробнее см. &lt;a href=&quot;tie/hash&quot;&gt;Tie :: Hash&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c67ef6ff224aaeb335a4c34ee8f8573b58ab3fc4" translate="yes" xml:space="preserve">
          <source>If this still doesn't work, look into the &lt;code&gt;clearerr&lt;/code&gt; method from &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;, which resets the error and end-of-file states on the handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f60efe640d39524c6e11c22deb74b1e7bd6e48" translate="yes" xml:space="preserve">
          <source>If this still doesn't work, look into the &lt;code&gt;clearerr&lt;/code&gt; method from &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;, which resets the error and end-of-file states on the handle.</source>
          <target state="translated">Если это по-прежнему не работает, &lt;code&gt;clearerr&lt;/code&gt; метод clearrr из &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt; , который сбрасывает состояние ошибки и конца файла для дескриптора.</target>
        </trans-unit>
        <trans-unit id="5f660c829995c0ccf8574939955dcb34cbb1fbc2" translate="yes" xml:space="preserve">
          <source>If this template key is true, enforces that if this key is provided by user input, its value is &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;. This just means that the user is not allowed to pass &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as a value for this key and is equivalent to: allow =&amp;gt; sub { defined $_[0] &amp;amp;&amp;amp; OTHER TESTS }</source>
          <target state="translated">Если этот ключ шаблона истинен, принудительно определяет, что, если этот ключ предоставляется пользовательским вводом, его значение &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; . Это просто означает, что пользователю не разрешено передавать &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в качестве значения для этого ключа, что эквивалентно: allow =&amp;gt; sub {defined $ _ [0] &amp;amp;&amp;amp; OTHER TESTS}</target>
        </trans-unit>
        <trans-unit id="e156c85e449c1c19860e80cb4d0bda5ed5967f61" translate="yes" xml:space="preserve">
          <source>If this template key is true, enforces that if this key is provided by user input, its value is &lt;code&gt;defined&lt;/code&gt;. This just means that the user is not allowed to pass &lt;code&gt;undef&lt;/code&gt; as a value for this key and is equivalent to: allow =&amp;gt; sub { defined $_[0] &amp;amp;&amp;amp; OTHER TESTS }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76bbabb48932b2f041b390c777de07be84c85182" translate="yes" xml:space="preserve">
          <source>If this value is defined but false then such an operation has ocurred, but should not impact later operations.</source>
          <target state="translated">Если это значение определено,но ложно,то такая операция зашла в тупик,но не должна влиять на последующие операции.</target>
        </trans-unit>
        <trans-unit id="cc6a20a1fa0fe02624d3822b74f6ca89396c5ee4" translate="yes" xml:space="preserve">
          <source>If this variable is set to a true value, then &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; on Windows will not try to open the file. This means that the link count cannot be determined and file attributes may be out of date if additional hardlinks to the file exist. On the other hand, not opening the file is considerably faster, especially for files on network drives.</source>
          <target state="translated">Если для этой переменной установлено истинное значение, то &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; в Windows не будет пытаться открыть файл. Это означает, что количество ссылок не может быть определено, а атрибуты файла могут быть устаревшими, если существуют дополнительные жесткие ссылки на файл. С другой стороны, не открыть файл значительно быстрее, особенно для файлов на сетевых дисках.</target>
        </trans-unit>
        <trans-unit id="bea7dc99d361b98967fbf94336d0529e85ea5d0f" translate="yes" xml:space="preserve">
          <source>If this variable is set to a true value, then &lt;code&gt;stat()&lt;/code&gt; on Windows will not try to open the file. This means that the link count cannot be determined and file attributes may be out of date if additional hardlinks to the file exist. On the other hand, not opening the file is considerably faster, especially for files on network drives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e9d7214894094637d48b5893992a1d4deebf1e" translate="yes" xml:space="preserve">
          <source>If this variable is true then such an operation has occurred and anything depending on this module cannot proceed until a reboot has occurred.</source>
          <target state="translated">Если эта переменная верна,то такая операция произошла,и все,что зависит от этого модуля,не может продолжаться до тех пор,пока не произойдет перезагрузка.</target>
        </trans-unit>
        <trans-unit id="0523b9c70c7c9e8111746aca12afc08517491534" translate="yes" xml:space="preserve">
          <source>If this warning does come from I/O, the easiest way to quiet it is simply to add the &lt;code&gt;:utf8&lt;/code&gt; layer,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c3e520fc9953b8c23b0cb154effeffba4245f7" translate="yes" xml:space="preserve">
          <source>If three (or more) arguments are specified, the open mode (including optional encoding) in the second argument are distinct from the filename in the third. If MODE is &lt;code&gt;&amp;lt;&lt;/code&gt; or nothing, the file is opened for input. If MODE is &lt;code&gt;&amp;gt;&lt;/code&gt;, the file is opened for output, with existing files first being truncated (&quot;clobbered&quot;) and nonexisting files newly created. If MODE is &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , the file is opened for appending, again being created if necessary.</source>
          <target state="translated">Если указано три (или более) аргумента, открытый режим (включая необязательную кодировку) во втором аргументе отличается от имени файла в третьем. Если MODE равен &lt;code&gt;&amp;lt;&lt;/code&gt; или ничего, файл открывается для ввода. Если MODE &lt;code&gt;&amp;gt;&lt;/code&gt; , файл открывается для вывода, при этом существующие файлы сначала усекаются (&quot;затираются&quot;), а несуществующие файлы создаются заново. Если MODE &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , файл открывается для добавления, при необходимости он создается снова.</target>
        </trans-unit>
        <trans-unit id="977c9556940f8be99675602713d0721d1fa68782" translate="yes" xml:space="preserve">
          <source>If trailing data is present immediately after the zip archive and the &lt;code&gt;Transparent&lt;/code&gt; option is enabled, this method will consider that trailing data to be another member of the zip archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e10a47d1100af2f4e741fa10c714b1d6eb83c05" translate="yes" xml:space="preserve">
          <source>If true (the default value), we autogenerate a JavaScript in the output directory, and set our HTML files to use it. Currently, the JavaScript is used only to get the browser to remember what stylesheet it prefers. TODO: continue</source>
          <target state="translated">Если значение установлено в true (значение по умолчанию),мы автоматически генерируем JavaScript в выходной директории и устанавливаем наши HTML-файлы для его использования.В настоящее время JavaScript используется только для того,чтобы браузер запомнил,какую таблицу стилей он предпочитает.TODO:продолжить</target>
        </trans-unit>
        <trans-unit id="634c500cd04e5d0b913158c1c6e9ccddc0f9bc06" translate="yes" xml:space="preserve">
          <source>If true (the default value), we autogenerate some CSS files in the output directory, and set our HTML files to use those. TODO: continue</source>
          <target state="translated">Если переменная имеет значение true (значение по умолчанию),мы автоматически генерируем некоторые CSS-файлы в выходном каталоге и устанавливаем для них HTML-файлы.TODO:продолжить</target>
        </trans-unit>
        <trans-unit id="ed672b2b381b7d94345040cc4eb4667fc3d97c8b" translate="yes" xml:space="preserve">
          <source>If true and a code reference, will be called with the symbolic link name and the directory it lives in as arguments. Otherwise, if true and warnings are on, warning &quot;symbolic_link_name is a dangling symbolic link\n&quot; will be issued. If false, the dangling symbolic link will be silently ignored.</source>
          <target state="translated">Если значение true и ссылка на код,то будет вызвана с символическим именем ссылки и каталогом,в котором она живет в качестве аргументов.В противном случае,если true и предупреждения включены,будет выдано предупреждение &quot;symbolic_link_name is a dangling symbolic link\n&quot;.Если false,то висящая символическая ссылка будет молча игнорироваться.</target>
        </trans-unit>
        <trans-unit id="93e6a2b3c3a0187d609e46522f3b6f893e49aa02" translate="yes" xml:space="preserve">
          <source>If true is returned, those arguments &lt;b&gt;should&lt;/b&gt; in theory be processed with &lt;code&gt;quadmath_snprintf()&lt;/code&gt;, but in case there is more than one such format specifier (see &lt;a href=&quot;#quadmath_format_valid&quot;&gt;&quot;quadmath_format_valid&quot;&lt;/a&gt;), and if there is anything else beyond that one (even just a single byte), they &lt;b&gt;cannot&lt;/b&gt; be processed because &lt;code&gt;quadmath_snprintf()&lt;/code&gt; is very strict, accepting only one format spec, and nothing else. In this case, the code should probably fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3fdfd0a40c103a2211bdac354013485a8b6be3" translate="yes" xml:space="preserve">
          <source>If true is returned, those arguments &lt;b&gt;should&lt;/b&gt; in theory be processed with quadmath_snprintf(), but in case there is more than one such format specifier (see &lt;a href=&quot;#quadmath_format_single&quot;&gt;quadmath_format_single&lt;/a&gt;), and if there is anything else beyond that one (even just a single byte), they &lt;b&gt;cannot&lt;/b&gt; be processed because quadmath_snprintf() is very strict, accepting only one format spec, and nothing else. In this case, the code should probably fail.</source>
          <target state="translated">Если верно возвращается, эти аргументы &lt;b&gt;должны&lt;/b&gt; быть теоретически обработаны с quadmath_snprintf (), но в случае , если есть более чем один такой формат спецификатора (см &lt;a href=&quot;#quadmath_format_single&quot;&gt;quadmath_format_single&lt;/a&gt; ), и если есть что - нибудь еще за что один (даже только один байт), они &lt;b&gt;не могут&lt;/b&gt; быть обработаны, потому что quadmath_snprintf () очень строгий, принимает только одну спецификацию формата и ничего больше. В этом случае код, вероятно, выйдет из строя.</target>
        </trans-unit>
        <trans-unit id="0653af7b3995880e12e86c1b6df46b2abdc8adcd" translate="yes" xml:space="preserve">
          <source>If true then &lt;code&gt;Configure&lt;/code&gt; will check each hostname given that it exists</source>
          <target state="translated">Если true, то &lt;code&gt;Configure&lt;/code&gt; проверит каждое имя хоста, учитывая, что оно существует.</target>
        </trans-unit>
        <trans-unit id="5e192827bd7624c2eefa078600e9250f2fd8d099" translate="yes" xml:space="preserve">
          <source>If true then &lt;code&gt;make test&lt;/code&gt; may attempt to connect to hosts given in the configuration.</source>
          <target state="translated">Если true, &lt;code&gt;make test&lt;/code&gt; может попытаться подключиться к хостам, указанным в конфигурации.</target>
        </trans-unit>
        <trans-unit id="0dfb0e1e33130859f2e7e4109870d6a5dff7d085" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;TAP::Harness&lt;/code&gt; will output the verbose results of running its tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd986bfa48b8d9de9607995da53c20f474abed0" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;Test::Harness&lt;/code&gt; will output the verbose results of running its tests. Setting &lt;code&gt;$Test::Harness::verbose&lt;/code&gt; will override this, or you can use the &lt;code&gt;-v&lt;/code&gt; switch in the</source>
          <target state="translated">Если true, &lt;code&gt;Test::Harness&lt;/code&gt; выведет подробные результаты выполнения своих тестов. Установка &lt;code&gt;$Test::Harness::verbose&lt;/code&gt; переопределит это, или вы можете использовать переключатель &lt;code&gt;-v&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="44529fee5d3eb44416500710e8dc9bea67c57ded" translate="yes" xml:space="preserve">
          <source>If true, STDERR and STDOUT are the same filehandle. This may cause breakage if STDERR contains anything resembling TAP format, but does allow exact synchronization.</source>
          <target state="translated">Если переменная имеет значение true,то STDERR и STDOUT-это одна и та же файловая ручка.Это может привести к поломке,если STDERR содержит что-либо,похожее на формат TAP,но допускает точную синхронизацию.</target>
        </trans-unit>
        <trans-unit id="fe1c5580c4e77a7f54f6b42fc274494bf3ad60b5" translate="yes" xml:space="preserve">
          <source>If true, make install will be verbose</source>
          <target state="translated">Если верно,то make install будет многословным.</target>
        </trans-unit>
        <trans-unit id="a169cfeed98e3c1eafec522650538e080de52944" translate="yes" xml:space="preserve">
          <source>If true, set the &lt;code&gt;SO_BROADCAST&lt;/code&gt; sockopt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e14d9f9dc273a75bb28fef309ebf7b650f85381" translate="yes" xml:space="preserve">
          <source>If true, set the &lt;code&gt;SO_REUSEADDR&lt;/code&gt; sockopt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e89fb240c4dc14ea640fd2d16ea6df8791107ad3" translate="yes" xml:space="preserve">
          <source>If true, set the &lt;code&gt;SO_REUSEPORT&lt;/code&gt; sockopt (not all OSes implement this sockopt)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab1cddffad75299c410b1e954057e9efb6fb3e2" translate="yes" xml:space="preserve">
          <source>If true, uses proxy subs. See &lt;a href=&quot;ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils::Constant::ProxySubs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb2c5a318ef60df6e780dd24e4ef173dd23b6b3c" translate="yes" xml:space="preserve">
          <source>If true, uses proxy subs. See &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils::Constant::ProxySubs&lt;/a&gt;.</source>
          <target state="translated">Если true, используются прокси-серверы. См. &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils :: Constant :: ProxySubs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33b670decc24a56dd9e5e0101143f31051cabe4b" translate="yes" xml:space="preserve">
          <source>If two arrays smartmatch each other, then they are deep copies of each others' values, as this example reports:</source>
          <target state="translated">Если два массива смарт-массива подходят друг другу,то они являются глубокими копиями значений друг друга,как показано в данном примере:</target>
        </trans-unit>
        <trans-unit id="acee3e1d7871c445b42f87ba144a405a067cf53f" translate="yes" xml:space="preserve">
          <source>If two characters here and next (as code points) are composable (including Hangul Jamo/Syllables and Composition Exclusions), it returns the code point of the composite.</source>
          <target state="translated">Если два символа здесь и далее (в качестве точек кода)являются композитными (в том числе хамо-хамо/силлиблы и исключения из композита),то возвращается точка кода композита.</target>
        </trans-unit>
        <trans-unit id="5cba0eaa180ef04fc5494ba487a038ca330cd204" translate="yes" xml:space="preserve">
          <source>If type is non-Unix (see &lt;a href=&quot;#fileparse_set_fstype&quot;&gt;&quot;fileparse_set_fstype&quot;&lt;/a&gt;) then the pattern matching for suffix removal is performed case-insensitively, since those systems are not case-sensitive when opening existing files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42360b0ce037c1aa50c01166917adec5fecc2590" translate="yes" xml:space="preserve">
          <source>If type is non-Unix (see &lt;a href=&quot;#fileparse_set_fstype&quot;&gt;fileparse_set_fstype&lt;/a&gt;) then the pattern matching for suffix removal is performed case-insensitively, since those systems are not case-sensitive when opening existing files.</source>
          <target state="translated">Если тип не-Unix (см. &lt;a href=&quot;#fileparse_set_fstype&quot;&gt;Fileparse_set_fstype&lt;/a&gt; ), то сопоставление с образцом для удаления суффикса выполняется без учета регистра, так как эти системы не чувствительны к регистру при открытии существующих файлов.</target>
        </trans-unit>
        <trans-unit id="2fd48f2e17e1f717f9f154bd3292076827285d01" translate="yes" xml:space="preserve">
          <source>If umask(2) is not implemented on your system and you are trying to restrict access for</source>
          <target state="translated">Если umask(2)не реализована в вашей системе,и вы пытаетесь ограничить доступ для</target>
        </trans-unit>
        <trans-unit id="67a1f447b6ee3db12f569b14d8d5a13cc81a620d" translate="yes" xml:space="preserve">
          <source>If unsafe signals is in effect, then signal handling is not thread-safe, and the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; signalling method cannot be used.</source>
          <target state="translated">Если действуют небезопасные сигналы, то обработка сигналов не является потокобезопасной, и метод сигнализации &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; использовать нельзя.</target>
        </trans-unit>
        <trans-unit id="70663a96a9c0a32a9a2fde13b31bf56729b3885e" translate="yes" xml:space="preserve">
          <source>If upgrading is in effect, returns PI, rounded to N digits with the current rounding mode:</source>
          <target state="translated">Если обновление вступило в силу,возвращает ПИ,округленный до N цифр с текущим режимом округления:</target>
        </trans-unit>
        <trans-unit id="6635daa00264b763872dbf741802de705f31e8f0" translate="yes" xml:space="preserve">
          <source>If used with -v &amp;lt;version&amp;gt; then all utilities released with that version of perl are listed, and any utility programs named on the command line are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d763c9ab9f9ca920e89e5e82fe0a4c19ddec98c7" translate="yes" xml:space="preserve">
          <source>If used with a single argument in a scalar context, returns the string consisting of the code points of the named sequence, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no named sequence by that name exists. If used with a single argument in a list context, it returns the list of the ordinals of the code points.</source>
          <target state="translated">Если используется с одним аргументом в скалярном контексте, возвращает строку, состоящую из кодовых точек именованной последовательности, или &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если именованной последовательности с таким именем не существует. Если используется с одним аргументом в контексте списка, он возвращает список порядковых номеров кодовых точек.</target>
        </trans-unit>
        <trans-unit id="da57dfd2566c5bbbb36939e6a816eb57d92a5102" translate="yes" xml:space="preserve">
          <source>If used with a single argument in a scalar context, returns the string consisting of the code points of the named sequence, or &lt;code&gt;undef&lt;/code&gt; if no named sequence by that name exists. If used with a single argument in a list context, it returns the list of the ordinals of the code points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beaceddc3b74ab2a5e89e9e5517463a3fd4ed9e1" translate="yes" xml:space="preserve">
          <source>If used with no arguments in a list context, it returns a hash with the names of all the named sequences as the keys and their sequences as strings as the values. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list depending on the context.</source>
          <target state="translated">Если используется без аргументов в контексте списка, он возвращает хеш с именами всех именованных последовательностей в качестве ключей и их последовательностей в виде строк в качестве значений. В противном случае он возвращает &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; или пустой список в зависимости от контекста.</target>
        </trans-unit>
        <trans-unit id="0407b6cc8a060a9f5a98513aa0ab0a70e400908b" translate="yes" xml:space="preserve">
          <source>If used with no arguments in a list context, it returns a hash with the names of all the named sequences as the keys and their sequences as strings as the values. Otherwise, it returns &lt;code&gt;undef&lt;/code&gt; or an empty list depending on the context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ccd67205017380c2547c8a9567b9cb20e04c0c" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; on a Unicode string (which</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcae58a7d75cf50d08d76e85d4556f2e6099dd18" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;https://metacpan.org/pod/BerkeleyDB&quot;&gt;BerkeleyDB&lt;/a&gt; isn't an option, there are a number of modules available on CPAN that can be used to implement locking. Each one implements locking differently and has different goals in mind. It is therefore worth knowing the difference, so that you can pick the right one for your application. Here are the three locking wrappers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1f504c6467cdb5b94820cfba3df9e446f6d20a" translate="yes" xml:space="preserve">
          <source>If using &lt;b&gt;BerkeleyDB&lt;/b&gt; isn't an option, there are a number of modules available on CPAN that can be used to implement locking. Each one implements locking differently and has different goals in mind. It is therefore worth knowing the difference, so that you can pick the right one for your application. Here are the three locking wrappers:</source>
          <target state="translated">Если использование &lt;b&gt;BerkeleyDB&lt;/b&gt; невозможно, на CPAN есть несколько модулей, которые можно использовать для реализации блокировки. Каждый из них реализует блокировку по-своему и преследует разные цели. Поэтому стоит знать разницу, чтобы выбрать подходящий для своего приложения. Вот три блокирующих оболочки:</target>
        </trans-unit>
        <trans-unit id="b0d8dee3f60efc11f28b77ac32acb4a0d6da837c" translate="yes" xml:space="preserve">
          <source>If using a Perl file as a source, optional switches may be passed which will be used when invoking the perl executable.</source>
          <target state="translated">При использовании Perl-файла в качестве источника могут передаваться необязательные переключатели,которые будут использоваться при вызове исполняемого файла perl.</target>
        </trans-unit>
        <trans-unit id="a612abcdba4adc1d68486aebb4d51b768494dc19" translate="yes" xml:space="preserve">
          <source>If using adb, a &quot;basic&quot; Configure line will look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c2e41b4856cbf4192df9fdfdae8eb4debbc3b0" translate="yes" xml:space="preserve">
          <source>If using crypt() on a Unicode string (which</source>
          <target state="translated">При использовании функции crypt()на строке Юникода (которая</target>
        </trans-unit>
        <trans-unit id="45cfcf2e0c855940dc64008801ae135f972cfd74" translate="yes" xml:space="preserve">
          <source>If using ftp remember to transfer the distribution in binary format.</source>
          <target state="translated">При использовании ftp не забудьте перенести дистрибутив в двоичном формате.</target>
        </trans-unit>
        <trans-unit id="b6fa09de90b513e62acb77e553ed8a67bf3a34b1" translate="yes" xml:space="preserve">
          <source>If using gcc, you can add the &lt;code&gt;-std=c89&lt;/code&gt; option which will hopefully catch most of these unportabilities. (However it might also catch incompatibilities in your system's header files.)</source>
          <target state="translated">Если вы используете gcc, вы можете добавить параметр &lt;code&gt;-std=c89&lt;/code&gt; , который, будем надеяться, уловит большую часть этих непереносимости. (Однако он также может обнаружить несовместимость в файлах заголовков вашей системы.)</target>
        </trans-unit>
        <trans-unit id="fae0365130c2e3d1490dd7527e14992a1ddb3fda" translate="yes" xml:space="preserve">
          <source>If using ssh, it's not too different -- we just change targetrun to ssh, and pass in targetuser and targetport. It ends up looking like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="664754e120bf0080d8c4c2636edd9c4d43e0b86a" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; pragma without an explicit encoding name, the PERL_ENCODING environment variable is consulted for an encoding name.</source>
          <target state="translated">Если вы используете директиву &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; без явного имени кодировки, переменная среды PERL_ENCODING запрашивается для имени кодировки.</target>
        </trans-unit>
        <trans-unit id="47d8d46dc66c1660b89d6816f6548597b112a1d7" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;gcc -Wall&lt;/code&gt; note that not all the possible warnings (like &lt;code&gt;-Wuninitialized&lt;/code&gt;) are given unless you also compile with &lt;code&gt;-O&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfca052b74a8f394827d7f4faa9fd4f5bf5109bf" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;gcc -Wall&lt;/code&gt; note that not all the possible warnings (like &lt;code&gt;-Wunitialized&lt;/code&gt; ) are given unless you also compile with &lt;code&gt;-O&lt;/code&gt; .</source>
          <target state="translated">Если вы используете &lt;code&gt;gcc -Wall&lt;/code&gt; , обратите внимание, что не все возможные предупреждения (например, &lt;code&gt;-Wunitialized&lt;/code&gt; ) выдаются, если вы также не скомпилируете с &lt;code&gt;-O&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa9480a44177272fde2828188fac358cc2184e4c" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;use encoding&lt;/code&gt; pragma without an explicit encoding name, the PERL_ENCODING environment variable is consulted for an encoding name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49dda8790f1c37a11e446613192c2ff1c5642e05" translate="yes" xml:space="preserve">
          <source>If using the VC IDE, to build use for example the File-&amp;gt;Open Workspace-&amp;gt; C:\Symbian\8.0a\S60_2nd_FP2\epoc32\build\symbian\perl\perl\wins\perl.dsw The emulator binaries will appear in the same directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f25526e76efefdb9a4ff18e831107d545ddc34" translate="yes" xml:space="preserve">
          <source>If using the VC IDE, you will a lot of warnings in the beginning of the build because a lot of headers mentioned by the source cannot be found, but this is not serious since those headers are not used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f6a03b7ab2b25638142acde2118920ba4f7593" translate="yes" xml:space="preserve">
          <source>If we add a &lt;code&gt;(*PRUNE)&lt;/code&gt; before the count like the following</source>
          <target state="translated">Если мы добавим &lt;code&gt;(*PRUNE)&lt;/code&gt; перед счетчиком, как показано ниже</target>
        </trans-unit>
        <trans-unit id="f49196da102bf295b3091d7157018af8c9071a57" translate="yes" xml:space="preserve">
          <source>If we call a method on a &lt;code&gt;Child&lt;/code&gt; object and that method is not defined in the &lt;code&gt;Child&lt;/code&gt; class, Perl will look for that method in the &lt;code&gt;Parent&lt;/code&gt; class and then, if necessary, in the &lt;code&gt;Grandparent&lt;/code&gt; class.</source>
          <target state="translated">Если мы вызываем метод для объекта &lt;code&gt;Child&lt;/code&gt; , а этот метод не определен в классе &lt;code&gt;Child&lt;/code&gt; , Perl будет искать этот метод в классе &lt;code&gt;Parent&lt;/code&gt; , а затем, если необходимо, в классе &lt;code&gt;Grandparent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef968fd799fd1b1033f77f3853f27266c25aff48" translate="yes" xml:space="preserve">
          <source>If we can tell that there is no valid start point then we don't bother running the interpreter at all. Likewise, if we know from the analysis phase that we cannot detect a short-cut to the start position, we go straight to the interpreter.</source>
          <target state="translated">Если мы можем сказать,что нет действительной стартовой точки,то мы вообще не беспокоимся о запуске интерпретатора.Точно так же,если на этапе анализа мы знаем,что не можем обнаружить короткое замыкание на стартовую позицию,то мы идём прямо к интерпретатору.</target>
        </trans-unit>
        <trans-unit id="ee8cb3b419bcafdec86df4116638973be94d94a5" translate="yes" xml:space="preserve">
          <source>If we could reliably use `goto &amp;amp;` on core builtins, we wouldn't need this subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd027f23ebc9bafdd0ef83ac988a2e8f6205abb" translate="yes" xml:space="preserve">
          <source>If we encrypt this with &lt;code&gt;mkrot13&lt;/code&gt; :</source>
          <target state="translated">Если мы &lt;code&gt;mkrot13&lt;/code&gt; это с помощью mkrot13 :</target>
        </trans-unit>
        <trans-unit id="b2db7414804acef79a0ead64758e1284fbf24a9c" translate="yes" xml:space="preserve">
          <source>If we encrypt this with &lt;code&gt;mkrot13&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b742d69e435d1dc4ae57558eae468b9e3038bfd1" translate="yes" xml:space="preserve">
          <source>If we have a string which needs to be modified, while a regex will almost always be much more flexible, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, an oft underused tool, can still be a useful. One scenario might be replace all vowels with another character. The regex solution might look like this:</source>
          <target state="translated">Если у нас есть строка, которую нужно изменить, а регулярное выражение почти всегда будет гораздо более гибким, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; , часто недоиспользуемый инструмент, все равно может быть полезным. В одном сценарии все гласные могут быть заменены другим символом. Решение с регулярным выражением может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="d8dec03047abaaa8042a15b74ce655789698f5d5" translate="yes" xml:space="preserve">
          <source>If we have a string which needs to be modified, while a regex will almost always be much more flexible, &lt;code&gt;tr&lt;/code&gt;, an oft underused tool, can still be a useful. One scenario might be replace all vowels with another character. The regex solution might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e855f5e5eecc49e2e1826c2e605b2358ee8b64" translate="yes" xml:space="preserve">
          <source>If we look at any of the C code generated by any of the examples except example 1, you will notice a number of references to ST(n), where n is usually 0. &quot;ST&quot; is actually a macro that points to the n'th argument on the argument stack. ST(0) is thus the first argument on the stack and therefore the first argument passed to the XSUB, ST(1) is the second argument, and so on.</source>
          <target state="translated">Если мы посмотрим на любой код на Си,сгенерированный любым из примеров,кроме примера 1,то мы заметим ряд ссылок на ST(n),где n обычно равно 0.&quot;ST&quot;-это на самом деле макрос,указывающий на n-ой аргумент в стеке аргументов.ST(0),таким образом,является первым аргументом на стеке,и поэтому первый аргумент,переданный в XSUB,ST(1)-это второй аргумент,и так далее.</target>
        </trans-unit>
        <trans-unit id="b4b727c2115d816f7a5edf98b373babd311821be" translate="yes" xml:space="preserve">
          <source>If we replace the &lt;code&gt; (?{local $c = $c + 1;})&lt;/code&gt; with &lt;code&gt; (?{$c = $c + 1;})&lt;/code&gt;, the variable changes are</source>
          <target state="translated">Если мы заменим &lt;code&gt; (?{local $c = $c + 1;})&lt;/code&gt; на &lt;code&gt; (?{$c = $c + 1;})&lt;/code&gt; , переменные изменятся</target>
        </trans-unit>
        <trans-unit id="6b22701c7de1c1b18f83a3da253320877e6db57e" translate="yes" xml:space="preserve">
          <source>If we want to call the function in scalar context, we have to do a bit more work. We can really have any code we like inside the braces, so we simply have to end with the scalar reference, although how you do that is up to you, and you can use code inside the braces. Note that the use of parens creates a list context, so we need &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; to force the scalar context on the function:</source>
          <target state="translated">Если мы хотим вызвать функцию в скалярном контексте, нам нужно проделать немного больше работы. У нас действительно может быть любой код, который нам нравится, внутри фигурных скобок, поэтому нам просто нужно закончить скалярной ссылкой, хотя как вы это делаете, зависит от вас, и вы можете использовать код внутри фигурных скобок. Обратите внимание, что использование скобок создает контекст списка, поэтому нам нужен &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; для принудительного использования скалярного контекста в функции:</target>
        </trans-unit>
        <trans-unit id="b2ecb0d182e5a6aa3494d3aa82a88c04143a9745" translate="yes" xml:space="preserve">
          <source>If we want to call the function in scalar context, we have to do a bit more work. We can really have any code we like inside the braces, so we simply have to end with the scalar reference, although how you do that is up to you, and you can use code inside the braces. Note that the use of parens creates a list context, so we need &lt;code&gt;scalar&lt;/code&gt; to force the scalar context on the function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa4af82f261a5bfccad859728bbc5e698f2ad5a" translate="yes" xml:space="preserve">
          <source>If we want to sort by the hash value instead, we use the hash key to look it up. We still get out a list of keys, but this time they are ordered by their value.</source>
          <target state="translated">Если вместо этого мы хотим отсортировать по значению хэша,мы используем ключ хэша для его поиска.Мы все еще получаем список ключей,но на этот раз они упорядочены по их значению.</target>
        </trans-unit>
        <trans-unit id="1a0a23be20e0afdc53dc3805694c934e04c1d63f" translate="yes" xml:space="preserve">
          <source>If we wanted to include the mp3's title in the greeting, we could override the method:</source>
          <target state="translated">Если бы мы хотели включить заголовок mp3 в приветствие,мы могли бы отменить этот метод:</target>
        </trans-unit>
        <trans-unit id="215abf71d62aea6c4bacd7ab63842ca42cbc8d09" translate="yes" xml:space="preserve">
          <source>If we were interested in performance, not in code compactness, in the success branch we would not use &lt;code&gt;XPUSHs&lt;/code&gt; macros, but &lt;code&gt;PUSHs&lt;/code&gt; macros, and would pre-extend the stack before pushing the return values:</source>
          <target state="translated">Если бы нас интересовала производительность, а не компактность кода, в ветви успеха мы бы не использовали макросы &lt;code&gt;XPUSHs&lt;/code&gt; , а макросы &lt;code&gt;PUSHs&lt;/code&gt; , и предварительно расширили бы стек перед отправкой возвращаемых значений:</target>
        </trans-unit>
        <trans-unit id="65993e20767895a57d8f797f997352ddbf9ddad7" translate="yes" xml:space="preserve">
          <source>If we've done things right, you'll probably want to write a new source, rather than sub-classing this (see &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; for that).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed55ede23a733b9689b8f241805b425f9dc0c341" translate="yes" xml:space="preserve">
          <source>If we've done things right, you'll probably want to write a new source, rather than sub-classing this (see &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; for that).</source>
          <target state="translated">Если мы все сделали правильно, вы, вероятно, захотите написать новый источник, а не подклассифицировать его (для этого см. &lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="433a6e7876c97a91d0108a2079322b6917a252c6" translate="yes" xml:space="preserve">
          <source>If what the angle brackets contain is a simple scalar variable (for example, &lt;code&gt;$foo&lt;/code&gt; ), then that variable contains the name of the filehandle to input from, or its typeglob, or a reference to the same. For example:</source>
          <target state="translated">Если в угловых скобках содержится простая скалярная переменная (например, &lt;code&gt;$foo&lt;/code&gt; ), то эта переменная содержит имя дескриптора файла, из которого нужно вводить данные, или его typeglob, или ссылку на него. Например:</target>
        </trans-unit>
        <trans-unit id="6838a6ca305b32b023903f5887f6858a0601c74f" translate="yes" xml:space="preserve">
          <source>If what the angle brackets contain is a simple scalar variable (for example, &lt;code&gt;$foo&lt;/code&gt;), then that variable contains the name of the filehandle to input from, or its typeglob, or a reference to the same. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b51d046d4f4e47130f90dab13b7fc186caff6e3" translate="yes" xml:space="preserve">
          <source>If what's within the angle brackets is neither a filehandle nor a simple scalar variable containing a filehandle name, typeglob, or typeglob reference, it is interpreted as a filename pattern to be globbed, and either a list of filenames or the next filename in the list is returned, depending on context. This distinction is determined on syntactic grounds alone. That means &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; is always a &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; from an indirect handle, but &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; is always a &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt;. That's because &lt;code&gt;$x&lt;/code&gt; is a simple scalar variable, but &lt;code&gt;$hash{key}&lt;/code&gt; is not--it's a hash element. Even &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; (note the extra space) is treated as &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;$x &quot;)&lt;/code&gt; , not &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline($x)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если то, что находится в угловых скобках, не является ни дескриптором файла, ни простой скалярной переменной, содержащей имя дескриптора файла, typeglob или ссылку typeglob, это интерпретируется как шаблон имени файла, который должен быть глобализирован, и либо список имен файлов, либо следующее имя файла в списке возвращается в зависимости от контекста. Это различие определяется только на синтаксических основаниях. Это означает, что &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; всегда является &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; из косвенного дескриптора, но &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; всегда является &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; . Это потому, что &lt;code&gt;$x&lt;/code&gt; - простая скалярная переменная, а &lt;code&gt;$hash{key}&lt;/code&gt; - нет - это хеш-элемент. Даже &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; (обратите внимание на лишний пробел) рассматривается как &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;$x &quot;)&lt;/code&gt; ,не &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline($x)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6919e586a25966a42d5d004843760749c92f077" translate="yes" xml:space="preserve">
          <source>If what's within the angle brackets is neither a filehandle nor a simple scalar variable containing a filehandle name, typeglob, or typeglob reference, it is interpreted as a filename pattern to be globbed, and either a list of filenames or the next filename in the list is returned, depending on context. This distinction is determined on syntactic grounds alone. That means &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; is always a &lt;code&gt;readline()&lt;/code&gt; from an indirect handle, but &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; is always a &lt;code&gt;glob()&lt;/code&gt;. That's because &lt;code&gt;$x&lt;/code&gt; is a simple scalar variable, but &lt;code&gt;$hash{key}&lt;/code&gt; is not--it's a hash element. Even &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; (note the extra space) is treated as &lt;code&gt;glob(&quot;$x &quot;)&lt;/code&gt;, not &lt;code&gt;readline($x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b842d8a427447b55d56f0f86ffb1407d7bbf70b" translate="yes" xml:space="preserve">
          <source>If whitespace is mostly irrelevant, how does one include space characters in an extended regexp? The answer is to backslash it &lt;code&gt;'\ '&lt;/code&gt; or put it in a character class &lt;code&gt;[ ]&lt;/code&gt; . The same thing goes for pound signs: use &lt;code&gt;\#&lt;/code&gt; or &lt;code&gt;[#]&lt;/code&gt;. For instance, Perl allows a space between the sign and the mantissa or integer, and we could add this to our regexp as follows:</source>
          <target state="translated">Если пробелы в основном не имеют значения, как включить пробелы в расширенное регулярное выражение? Ответ - поставить обратную косую черту &lt;code&gt;'\ '&lt;/code&gt; или поместить в класс символов &lt;code&gt;[ ]&lt;/code&gt; . То же самое и со знаками фунта: используйте &lt;code&gt;\#&lt;/code&gt; или &lt;code&gt;[#]&lt;/code&gt; . Например, Perl допускает пробел между знаком и мантиссой или целым числом, и мы могли бы добавить это в наше регулярное выражение следующим образом:</target>
        </trans-unit>
        <trans-unit id="5ea95fa4866be380e5de6f53e01cf2830a2660fd" translate="yes" xml:space="preserve">
          <source>If whitespace is mostly irrelevant, how does one include space characters in an extended regexp? The answer is to backslash it &lt;code&gt;'\ '&lt;/code&gt; or put it in a character class &lt;code&gt;[ ]&lt;/code&gt;. The same thing goes for pound signs: use &lt;code&gt;\#&lt;/code&gt; or &lt;code&gt;[#]&lt;/code&gt;. For instance, Perl allows a space between the sign and the mantissa or integer, and we could add this to our regexp as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6171e2e12a8c60c3485d29916f7ac5529de6161" translate="yes" xml:space="preserve">
          <source>If writing a plugin is not enough, you can write your own test harness; one of the motives for the 3.00 rewrite of Test::Harness was to make it easier to subclass and extend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ac523288e8907db49cd44aeec42c46983d54f41" translate="yes" xml:space="preserve">
          <source>If you</source>
          <target state="translated">Если вы</target>
        </trans-unit>
        <trans-unit id="a97a499d1638eac60812016983597e71f2e68467" translate="yes" xml:space="preserve">
          <source>If you &quot;mmap&quot; the file with the File::Map module from CPAN, you can virtually load the entire file into a string without actually storing it in memory:</source>
          <target state="translated">Если вы &quot;mmap&quot; файл с модулем File::Map из CPAN,вы можете практически загрузить весь файл в строку,не сохраняя его в памяти:</target>
        </trans-unit>
        <trans-unit id="bbc7d708aba8a01827e46990051f630f335a2e71" translate="yes" xml:space="preserve">
          <source>If you &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; without ever waiting on your children, you will accumulate zombies. On some systems, you can avoid this by setting &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{CHLD}&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt;. See also &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more examples of forking and reaping moribund children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9fdf3b9fc81571db27bb02cd29a8e0b53b10cc5" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; without ever waiting on your children, you will accumulate zombies. On some systems, you can avoid this by setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . See also &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for more examples of forking and reaping moribund children.</source>
          <target state="translated">Если вы будете &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; даже не дожидаясь своих детей, у вас накопятся зомби. В некоторых системах этого можно избежать, установив для &lt;code&gt;$SIG{CHLD}&lt;/code&gt; значение &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . Также смотрите &lt;a href=&quot;../perlipc&quot;&gt;perlipc,&lt;/a&gt; где вы найдете больше примеров раздвоения и пожинания умирающих детей.</target>
        </trans-unit>
        <trans-unit id="3342529f369584d116691354aca02d8a637cdc3f" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; without ever waiting on your children, you will accumulate zombies. On some systems, you can avoid this by setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . See also &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more examples of forking and reaping moribund children.</source>
          <target state="translated">Если вы будете &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; даже не дожидаясь своих детей, у вас накопятся зомби. В некоторых системах этого можно избежать, установив для &lt;code&gt;$SIG{CHLD}&lt;/code&gt; значение &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . Также смотрите &lt;a href=&quot;perlipc&quot;&gt;perlipc,&lt;/a&gt; где вы найдете больше примеров раздвоения и пожинания умирающих детей.</target>
        </trans-unit>
        <trans-unit id="bb90d14b290d4320ac5634dcbc5bece03b18182e" translate="yes" xml:space="preserve">
          <source>If you actually need to be able to get a real reference back from each hash entry, you can use the Tie::RefHash module, which does the required work for you.</source>
          <target state="translated">Если вам действительно нужно иметь возможность получить реальную ссылку обратно с каждой записи хэша,вы можете использовать модуль Tie::RefHash,который делает необходимую работу за вас.</target>
        </trans-unit>
        <trans-unit id="0863c378529bcaaf05a08fbe7b9d62fcdd40f533" translate="yes" xml:space="preserve">
          <source>If you actually want to bless into the stringified version of the reference supplied, you need to stringify it yourself, for example by:</source>
          <target state="translated">Если вы действительно хотите получить благословение в строковой версии поставляемой ссылки,вам нужно самому строчить ее,например,с помощью:</target>
        </trans-unit>
        <trans-unit id="7632fd79ddaeaed4fd83611844af65a8558ccb38" translate="yes" xml:space="preserve">
          <source>If you actually want to pack Unicode codepoints, use the &lt;code&gt;&quot;U&quot;&lt;/code&gt; format instead.</source>
          <target state="translated">Если вы действительно хотите упаковать кодовые точки Unicode, используйте вместо этого формат &lt;code&gt;&quot;U&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30a06cdba55cf94e2b0d8887615268f65da700c2" translate="yes" xml:space="preserve">
          <source>If you add the &lt;code&gt;stringify&lt;/code&gt; import option to your &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; declaration, then using a threads object in a string or a string context (e.g., as a hash key) will cause its ID to be used as the value:</source>
          <target state="translated">Если вы добавите параметр импорта &lt;code&gt;stringify&lt;/code&gt; в свое объявление &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; , то использование объекта потоков в строке или строковом контексте (например, в качестве хеш-ключа) приведет к тому, что его идентификатор будет использоваться в качестве значения:</target>
        </trans-unit>
        <trans-unit id="30adb136bf842fc19188bd6258e57dee7ddb8e9f" translate="yes" xml:space="preserve">
          <source>If you add the &lt;code&gt;stringify&lt;/code&gt; import option to your &lt;code&gt;use threads&lt;/code&gt; declaration, then using a threads object in a string or a string context (e.g., as a hash key) will cause its ID to be used as the value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24defde4aa2bffa14e170e2d3b5990c2b9ad5b66" translate="yes" xml:space="preserve">
          <source>If you already have a Perl repository, you should ensure that you're on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f0b688e7f7db776b8a41a0294b1be395b96046" translate="yes" xml:space="preserve">
          <source>If you already have the data in memory or if you want to keep your code simple, you can use one of the sv_cat*() variants, such as sv_catpvn(). If you want to insert anywhere in the string you can use sv_insert() or sv_insert_flags().</source>
          <target state="translated">Если у вас уже есть данные в памяти или если вы хотите,чтобы ваш код был простым,вы можете использовать один из вариантов sv_cat*(),например,sv_catpvn().Если вы хотите вставить что-либо в строку,вы можете использовать sv_insert()или sv_insert_flags().</target>
        </trans-unit>
        <trans-unit id="d0e6e027d69f3e21d5d8d4eaafdf5a18b7a271a0" translate="yes" xml:space="preserve">
          <source>If you also specify the &lt;code&gt;save&lt;/code&gt; option newly passing tests will be excluded from subsequent runs.</source>
          <target state="translated">Если вы также укажете параметр &lt;code&gt;save&lt;/code&gt; новые пройденные тесты будут исключены из последующих запусков.</target>
        </trans-unit>
        <trans-unit id="f2315b4f443374dc91536026901e2322007448a6" translate="yes" xml:space="preserve">
          <source>If you alter your @_ arguments in a subroutine (such as with &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;), the stack backtrace will not show the original values.</source>
          <target state="translated">Если вы измените аргументы @_ в подпрограмме (например, с помощью &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; ), трассировка стека не покажет исходные значения.</target>
        </trans-unit>
        <trans-unit id="87b7e2c0f9e7bf47de8a9bd321c66e6de23241e4" translate="yes" xml:space="preserve">
          <source>If you alter your @_ arguments in a subroutine (such as with &lt;code&gt;shift&lt;/code&gt; or &lt;code&gt;pop&lt;/code&gt;), the stack backtrace will not show the original values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5bf3485b53b1f2fcb4fdcf6bb2cccc1e74cefad" translate="yes" xml:space="preserve">
          <source>If you are a committer to Perl and you think the patch is good, you can then merge it into blead then push it out to the main repository:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcce70763746b8ab89abce0fda8214efc82356bb" translate="yes" xml:space="preserve">
          <source>If you are accustomed to using perl from various command-line shells found in UNIX environments, you will be less than pleased with what Windows offers by way of a command shell.</source>
          <target state="translated">Если вы привыкли использовать perl из различных оболочек командной строки,встречающихся в UNIX средах,вы будете менее чем довольны тем,что Windows предлагает в виде командной оболочки.</target>
        </trans-unit>
        <trans-unit id="75851b1a6055f8c9601d27bb8e4f2638f62e5f5e" translate="yes" xml:space="preserve">
          <source>If you are advanced enough with building C code, here is a suggestion to speed up building perl, and the later &lt;code&gt;make test&lt;/code&gt; . Try to keep your PATH enviromental variable with the least number of folders possible (remember to keep your C compiler's folders there). &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; or &lt;code&gt;C:\WINNT\system32&lt;/code&gt; depending on your OS version should be first folder in PATH, since &quot;cmd.exe&quot; is the most commonly launched program during the build and later testing.</source>
          <target state="translated">Если вы достаточно продвинуты в создании кода C, вот предложение по ускорению сборки Perl и более поздний &lt;code&gt;make test&lt;/code&gt; . Постарайтесь сохранить переменную окружения PATH с наименьшим возможным количеством папок (не забудьте сохранить там папки компилятора C). &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; или &lt;code&gt;C:\WINNT\system32&lt;/code&gt; зависимости от версии вашей ОС, должен быть первой папкой в ​​PATH, поскольку &amp;laquo;cmd.exe&amp;raquo; - это наиболее часто запускаемая программа во время сборки и последующего тестирования.</target>
        </trans-unit>
        <trans-unit id="04da8dab27ca1a90f04cb94a9ccc32581630ed82" translate="yes" xml:space="preserve">
          <source>If you are advanced enough with building C code, here is a suggestion to speed up building perl, and the later &lt;code&gt;make test&lt;/code&gt;. Try to keep your PATH environmental variable with the least number of folders possible (remember to keep your C compiler's folders there). &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; or &lt;code&gt;C:\WINNT\system32&lt;/code&gt; depending on your OS version should be first folder in PATH, since &quot;cmd.exe&quot; is the most commonly launched program during the build and later testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6e47c6af55350e3bd275924a9467fa5be92cb6" translate="yes" xml:space="preserve">
          <source>If you are author of a package and wonder if your $VERSION can be parsed, please try the above method.</source>
          <target state="translated">Если вы являетесь автором пакета и задаетесь вопросом,можно ли разобрать ваш $VERSION,пожалуйста,попробуйте вышеприведенный метод.</target>
        </trans-unit>
        <trans-unit id="e9341f5fe0aca50dc1a438efa6a2a0829ec331a7" translate="yes" xml:space="preserve">
          <source>If you are building Perl from source, the Perl test suite file</source>
          <target state="translated">Если вы собираете Perl из исходников,то файл набора тестов Perl</target>
        </trans-unit>
        <trans-unit id="fd709122178ec9749d3b052901d53a7e7c059f96" translate="yes" xml:space="preserve">
          <source>If you are calling &lt;b&gt;pod2usage()&lt;/b&gt; from a module and want to display that module's POD, you can use this:</source>
          <target state="translated">Если вы вызываете &lt;b&gt;pod2usage ()&lt;/b&gt; из модуля и хотите отобразить POD этого модуля, вы можете использовать это:</target>
        </trans-unit>
        <trans-unit id="f5b3eed9ee23b3eafd899b21c185d1c6a6521682" translate="yes" xml:space="preserve">
          <source>If you are careful, it is possible to mix API calls with the tied hash/array interface in the same piece of code. Although only a few of the methods used to implement the tied interface currently make use of the cursor, you should always assume that the cursor has been changed any time the tied hash/array interface is used. As an example, this code will probably not do what you expect:</source>
          <target state="translated">Если быть внимательным,то можно смешивать вызовы API с привязанным хэш-массивом интерфейса в одном куске кода.Хотя в настоящее время только несколько методов,используемых для реализации связанного интерфейса,используют курсор,вы всегда должны предполагать,что курсор был изменен при использовании связанного интерфейса хэша/массива.В качестве примера,этот код,скорее всего,не будет делать то,что вы ожидаете:</target>
        </trans-unit>
        <trans-unit id="f310b0eef5419b5aba99dec1af26f1763cc1c050" translate="yes" xml:space="preserve">
          <source>If you are certain that you want a different tool to use the same context you may pass it a snapshot. &lt;code&gt;$ctx-&amp;gt;snapshot&lt;/code&gt; will give you a shallow clone of the context that is safe to pass around or store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e316a557a29cf6095279d19d99c5e2d5b583af0" translate="yes" xml:space="preserve">
          <source>If you are certain that you want to save the context for later, you can use a snapshot. &lt;code&gt;$ctx-&amp;gt;snapshot&lt;/code&gt; will give you a shallow clone of the context that is safe to pass around or store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46443ee64846124969f99d9a251a1b5c33defa28" translate="yes" xml:space="preserve">
          <source>If you are coming here because code of yours is being adversely affected by someone's use of this variable, you can usually work around it by doing this:</source>
          <target state="translated">Если вы пришли сюда из-за того,что на ваш код отрицательно влияет чье-то использование этой переменной,обычно вы можете работать с ней,делая это:</target>
        </trans-unit>
        <trans-unit id="580a992ac4c85198002e3da1ab0af0114ef2843d" translate="yes" xml:space="preserve">
          <source>If you are compiling Perl on a remotely-mounted NFS filesystem, the test io/fs.t may fail on test #18. This appears to be a bug in HP-UX and no fix is currently available.</source>
          <target state="translated">Если вы компилируете Perl на удаленной файловой системе NFS,то тест io/fs.t может не сработать на тесте #18.Похоже,что это ошибка в HP-UX,и на данный момент исправление недоступно.</target>
        </trans-unit>
        <trans-unit id="3b33c19354a1a90e2387b434d12153c90f20f627" translate="yes" xml:space="preserve">
          <source>If you are compiling in PASE, then &quot;make install&quot; is the only thing you will need to do.</source>
          <target state="translated">Если вы компилируете в PASE,то &quot;make install&quot;-это единственное,что вам нужно будет сделать.</target>
        </trans-unit>
        <trans-unit id="81413ae9ed04e602e1a5e2aa34f9a9228c164afc" translate="yes" xml:space="preserve">
          <source>If you are compiling on AIX, simply do a &quot;make install&quot; on the AIX box. Once the install finishes, tar up the /QOpenSys/perl directory. Transfer the tarball to the OS/400 using FTP with the following commands:</source>
          <target state="translated">Если вы компилируете на AIX,просто сделайте &quot;make install&quot; на AIX box.Как только установка завершится,установите метку в каталоге /QOpenSys/perl.Перенесите tarball в OS/400,используя FTP со следующими командами:</target>
        </trans-unit>
        <trans-unit id="633f40501c71cc3d9b9dd021b947e0958a8636a6" translate="yes" xml:space="preserve">
          <source>If you are confident that all byte-strings will be in a specific encoding like UTF-8,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c32dcfc58ac17c09099d20bc9bc3a8e41bba8b" translate="yes" xml:space="preserve">
          <source>If you are content with the test result, just &quot;make install&quot;</source>
          <target state="translated">Если вы довольны результатами теста,просто &quot;сделайте установку&quot;.</target>
        </trans-unit>
        <trans-unit id="aa6a61423fd16b04dc17486be56b73db7a8c3506" translate="yes" xml:space="preserve">
          <source>If you are creating a PerlIO layer, you may want to be lazy, in other words, implement only the methods that interest you. The other methods you can either replace with the &quot;blank&quot; methods</source>
          <target state="translated">Если вы создаете слой PerlIO,вы можете захотеть лениться,другими словами,реализовать только те методы,которые вас интересуют.Другие методы вы можете заменить на &quot;пустые&quot;.</target>
        </trans-unit>
        <trans-unit id="602ef84230a9a9bbabefd6f60652a28db56ddfcd" translate="yes" xml:space="preserve">
          <source>If you are creating a Zip file using the one-shot interface, and any of the input files is greater than 4Gig, a zip64 complaint zip file will be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b2de75d9b2a463fc1f9325a0ae503a9f6861718" translate="yes" xml:space="preserve">
          <source>If you are developing a suite of related modules/classes it's good practice to use nested classes with a common prefix as this will avoid namespace clashes. For example: Xyz::Control, Xyz::View, Xyz::Model etc. Use the modules in this list as a naming guide.</source>
          <target state="translated">Если вы разрабатываете набор связанных модулей/классов,то хорошая практика-использовать вложенные классы с общим префиксом,так как это позволит избежать столкновений пространств имен.Например:Xyz::Control,Xyz::View,Xyz::Model и т.д.Используйте модули из этого списка в качестве руководства по именованию.</target>
        </trans-unit>
        <trans-unit id="cf3f54058ec5c3861eafa70f589fb5c16feca4d3" translate="yes" xml:space="preserve">
          <source>If you are doing a blocking &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread()&lt;/a&gt;&lt;/code&gt;, you'll have to arrange for an alarm handler to provide a timeout (see &lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;). If you have a non-blocking open, you'll likely have a non-blocking read, which means you may have to use a 4-arg &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; to determine whether I/O is ready on that device (see &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;.</source>
          <target state="translated">Если вы выполняете блокирующее &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread()&lt;/a&gt;&lt;/code&gt; , вам необходимо настроить обработчик аварийных сигналов, чтобы обеспечить тайм-аут (см . Аварийный&lt;a href=&quot;functions/alarm&quot;&gt; сигнал&lt;/a&gt; ). Если у вас есть неблокирующее открытие, у вас, вероятно, будет неблокирующее чтение, что означает, что вам, возможно, придется использовать 4-аргументный &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; чтобы определить, готов ли ввод-вывод на этом устройстве (см. &lt;a href=&quot;functions/select&quot;&gt;Select&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3262a8838df2cab768e5f0aeb8b39d02c8c5bb9" translate="yes" xml:space="preserve">
          <source>If you are doing a blocking &lt;code&gt;read()&lt;/code&gt; or &lt;code&gt;sysread()&lt;/code&gt;, you'll have to arrange for an alarm handler to provide a timeout (see &lt;a href=&quot;perlfunc#alarm&quot;&gt;&quot;alarm&quot; in perlfunc&lt;/a&gt;). If you have a non-blocking open, you'll likely have a non-blocking read, which means you may have to use a 4-arg &lt;code&gt;select()&lt;/code&gt; to determine whether I/O is ready on that device (see &lt;a href=&quot;perlfunc#select&quot;&gt;&quot;select&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec0d9c19ee9bcc3793bd395f6bcc7da295d90db4" translate="yes" xml:space="preserve">
          <source>If you are doing something complex, such as moving through many pages and forms or a web site, you can use &lt;a href=&quot;WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt;. See its documentation for all the details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27eb5f2751e7b3c976fa3693eb1b047c9ea468b5" translate="yes" xml:space="preserve">
          <source>If you are doing something complex, such as moving through many pages and forms or a web site, you can use &lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt;. See its documentation for all the details.</source>
          <target state="translated">Если вы делаете что-то сложное, например перемещаетесь по множеству страниц и форм или веб-сайту, вы можете использовать &lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW :: Mechanize&lt;/a&gt; . См. Его документацию для получения всех подробностей.</target>
        </trans-unit>
        <trans-unit id="1a9b4d7923308acf7ee68c13a2cd11f90f3c70ce" translate="yes" xml:space="preserve">
          <source>If you are experiencing variable suicide, that &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; in the subroutine doesn't pick up a fresh copy of the &lt;code&gt;$f&lt;/code&gt; whose value is &lt;code&gt;'foo'&lt;/code&gt; . The output shows that inside the subroutine the value of &lt;code&gt;$f&lt;/code&gt; leaks through when it shouldn't, as in this output:</source>
          <target state="translated">Если вы переживаете самоубийство переменной, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; в подпрограмме не берет новую копию &lt;code&gt;$f&lt;/code&gt; , значение которой равно &lt;code&gt;'foo'&lt;/code&gt; . Выходные данные показывают, что внутри подпрограммы значение &lt;code&gt;$f&lt;/code&gt; просачивается, хотя этого не должно быть, как в этом выходе:</target>
        </trans-unit>
        <trans-unit id="90ffffc1c986cd8a0326c90c4ba333b4ce6ffe43" translate="yes" xml:space="preserve">
          <source>If you are experiencing variable suicide, that &lt;code&gt;my $f&lt;/code&gt; in the subroutine doesn't pick up a fresh copy of the &lt;code&gt;$f&lt;/code&gt; whose value is &lt;code&gt;'foo'&lt;/code&gt;. The output shows that inside the subroutine the value of &lt;code&gt;$f&lt;/code&gt; leaks through when it shouldn't, as in this output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbeae6d94c0568a9909c55582ce46133df1b3000" translate="yes" xml:space="preserve">
          <source>If you are familiar with the</source>
          <target state="translated">Если вы знакомы с</target>
        </trans-unit>
        <trans-unit id="09b5540260d1429f031cae6d4fea34d1c0219ed0" translate="yes" xml:space="preserve">
          <source>If you are forking many processes in parallel that are all creating temporary files, you may need to reset the random number seed using srand(EXPR) in each child else all the children will attempt to walk through the same set of random file names and may well cause themselves to give up if they exceed the number of retry attempts.</source>
          <target state="translated">Если параллельно с этим процессом вы выковыриваете много процессов,которые создают временные файлы,вам может потребоваться сброс посылки случайных чисел с помощью srand(EXPR)в каждом дочернем процессе,все дочерние процессы будут пытаться пройти через один и тот же набор случайных имён файлов и вполне могут заставить себя сдаться,если они превысят количество повторных попыток.</target>
        </trans-unit>
        <trans-unit id="79eaecd3ef824520bc14f0a6f551bc580fb007f0" translate="yes" xml:space="preserve">
          <source>If you are going to convert the script to a module you can use the opportunity to redesign the interface. The guidelines for module creation above include many of the issues you should consider.</source>
          <target state="translated">Если вы собираетесь преобразовать скрипт в модуль,вы можете воспользоваться возможностью перепроектировать интерфейс.Руководство по созданию модуля,приведенное выше,включает в себя многие из вопросов,которые вам следует рассмотреть.</target>
        </trans-unit>
        <trans-unit id="37c8864889db08a398c2a1fd61fb5557dd86b1b1" translate="yes" xml:space="preserve">
          <source>If you are going to put something onto the Perl stack, you need to know where to put it. This is the purpose of the macro &lt;code&gt;dSP&lt;/code&gt; --it declares and initializes a</source>
          <target state="translated">Если вы собираетесь поместить что-то в стек Perl, вам нужно знать, куда это поместить. Это цель макроса &lt;code&gt;dSP&lt;/code&gt; - он объявляет и инициализирует</target>
        </trans-unit>
        <trans-unit id="537495a37e599c942d74bd5d8aca0155b4da8202" translate="yes" xml:space="preserve">
          <source>If you are going to put something onto the Perl stack, you need to know where to put it. This is the purpose of the macro &lt;code&gt;dSP&lt;/code&gt;--it declares and initializes a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf3f133791811ca9201975358ebf1e226d3c50a" translate="yes" xml:space="preserve">
          <source>If you are going to use the HP DCE package, the library used for threading is /usr/lib/libcma.sl, but there have been multiple updates of that library over time. Perl will build with the first version, but it will not pass the test suite. Older Oracle versions might be a compelling reason not to update that library, otherwise please find a newer version in one of the following patches: PHSS_19739, PHSS_20608, or PHSS_23672</source>
          <target state="translated">Если вы собираетесь использовать пакет HP DCE,то библиотека,используемая для выполнения потоков-это /usr/lib/libcma.sl,но со временем эта библиотека неоднократно обновлялась.Perl будет собираться с первой версией,но не пройдет тестового набора.Более старые версии Oracle могут быть веской причиной не обновлять эту библиотеку,в противном случае,пожалуйста,найдите более новую версию в одном из следующих патчей:PHSS_19739,PHSS_20608 или PHSS_23672</target>
        </trans-unit>
        <trans-unit id="330882464199f1a0851acc4b79e3a966cdc91c15" translate="yes" xml:space="preserve">
          <source>If you are going to use this method you have to be aware of a possible memory leak which can arise under very specific circumstances. To explain these circumstances you need to know a bit about the flow of control between Perl and the callback routine.</source>
          <target state="translated">Если вы собираетесь использовать этот метод,вы должны знать о возможной утечке памяти,которая может произойти при очень специфических обстоятельствах.Чтобы объяснить эти обстоятельства,вы должны знать немного о потоке контроля между Perl и обратным вызовом.</target>
        </trans-unit>
        <trans-unit id="91073f8278c247bf05c5742a59e2d0906bf12cbd" translate="yes" xml:space="preserve">
          <source>If you are going to write a platform specific MM package, please try to limit the necessary overrides to primitive methods, and if it is not possible to do so, let's work out how to achieve that gain.</source>
          <target state="translated">Если вы собираетесь писать пакет ММ для конкретной платформы,постарайтесь ограничить необходимые переопределения примитивными методами,а если это невозможно,то давайте придумаем,как достичь этого выигрыша.</target>
        </trans-unit>
        <trans-unit id="3470649433d76902fec9be392ea404a581213006" translate="yes" xml:space="preserve">
          <source>If you are having trouble with square brackets then consider switching your rlogin or telnet client. Try to avoid older 3270 emulators and ISHELL for working with Perl on USS.</source>
          <target state="translated">Если у вас возникли проблемы с квадратными скобками,то подумайте о переключении вашего rlogin или telnet клиента.Постарайтесь избегать старых 3270 эмуляторов и ISHELL для работы с Perl на USS.</target>
        </trans-unit>
        <trans-unit id="fb193e3267912e83638916e973e0dcc8b120aead" translate="yes" xml:space="preserve">
          <source>If you are in any doubt about the license situation, contact either the Berkeley DB authors or the author of DB_File. See &lt;a href=&quot;#AUTHOR&quot;&gt;&quot;AUTHOR&quot;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be777d0c50e7b77da7283f3ff8a7e540b7f7344c" translate="yes" xml:space="preserve">
          <source>If you are in any doubt about the license situation, contact either the Berkeley DB authors or the author of DB_File. See &lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt; for details.</source>
          <target state="translated">Если у вас есть какие-либо сомнения относительно ситуации с лицензией, свяжитесь либо с авторами Berkeley DB, либо с автором DB_File. Подробнее см. &lt;a href=&quot;#AUTHOR&quot;&gt;АВТОР&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99320978b9537887ebc85e1dfd4bdf0910cbc812" translate="yes" xml:space="preserve">
          <source>If you are in doubt which package contains a file you are missing, try to find an installation that has that file. Then do a</source>
          <target state="translated">Если вы сомневаетесь,в каком пакете содержится файл,который вам не хватает,попробуйте найти установку,в которой есть этот файл.Затем сделайте</target>
        </trans-unit>
        <trans-unit id="92276bc0e44e1b658a5288e18f73cfbd284b63bb" translate="yes" xml:space="preserve">
          <source>If you are intending to manipulate bitstrings, be certain that you're supplying bitstrings: If an operand is a number, that will imply a &lt;b&gt;numeric&lt;/b&gt; bitwise operation. You may explicitly show which type of operation you intend by using &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;0+&lt;/code&gt; , as in the examples below.</source>
          <target state="translated">Если вы намереваетесь манипулировать строками битов, убедитесь, что вы предоставляете строки битов: если операнд является числом, это будет означать &lt;b&gt;числовую&lt;/b&gt; побитовую операцию. Вы можете явно указать, какой тип операции вы намереваетесь, используя &lt;code&gt;&quot;&quot;&lt;/code&gt; или &lt;code&gt;0+&lt;/code&gt; , как в примерах ниже.</target>
        </trans-unit>
        <trans-unit id="2877e8cae4b72c189b80caef94210456b80f06da" translate="yes" xml:space="preserve">
          <source>If you are intending to manipulate bitstrings, be certain that you're supplying bitstrings: If an operand is a number, that will imply a &lt;b&gt;numeric&lt;/b&gt; bitwise operation. You may explicitly show which type of operation you intend by using &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;0+&lt;/code&gt;, as in the examples below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e74d8ccd8d67f221dc38d69397982438ef8887" translate="yes" xml:space="preserve">
          <source>If you are interested in the guts underlying these systems, check out &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">Если вас интересует внутренняя часть этих систем, попробуйте &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f81bce975381ffe867c89af365021d38913e30eb" translate="yes" xml:space="preserve">
          <source>If you are interested in the z/OS (formerly known as OS/390) and POSIX-BC (BS2000) ports of Perl then see the perl-mvs mailing list. To subscribe, send an empty message to perl-mvs-subscribe@perl.org.</source>
          <target state="translated">Если вас интересуют порты z/OS (ранее известные как OS/390)и POSIX-BC (BS2000)на Perl,посмотрите список рассылки perl-mvs.Чтобы подписаться,отправьте пустое сообщение на perl-mvs-subscribe@perl.org.</target>
        </trans-unit>
        <trans-unit id="81e9b341887276c07ed78e971fe73fb2fe685324" translate="yes" xml:space="preserve">
          <source>If you are interested in writing new tools you should take a look at &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b06deb07c89c9dfd8a2b96ce84d618599bef3b" translate="yes" xml:space="preserve">
          <source>If you are interested in writing tests using new tools then you should look at &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;. &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt; is a separate cpan distribution that contains many tools implemented on Test2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d9bbb97bd39f15f79a0ad6f3bd53d77bb54ef1" translate="yes" xml:space="preserve">
          <source>If you are looking for a &quot;bar&quot; that isn't preceded by a &quot;foo&quot;, &lt;code&gt;/(?!foo)bar/&lt;/code&gt; will not do what you want. That's because the &lt;code&gt;(?!foo)&lt;/code&gt; is just saying that the next thing cannot be &quot;foo&quot;--and it's not, it's a &quot;bar&quot;, so &quot;foobar&quot; will match. Use look-behind instead (see below).</source>
          <target state="translated">Если вы ищете &amp;laquo;bar&amp;raquo;, которому не предшествует &amp;laquo;foo&amp;raquo;, &lt;code&gt;/(?!foo)bar/&lt;/code&gt; не будет делать то, что вы хотите. Это потому, что &lt;code&gt;(?!foo)&lt;/code&gt; просто говорит, что следующее не может быть &amp;laquo;foo&amp;raquo; - и это не так, это &amp;laquo;bar&amp;raquo;, поэтому &amp;laquo;foobar&amp;raquo; будет соответствовать. Вместо этого используйте ретроспективный просмотр (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="f7b2a50928124f0618a8144a8e1baa9cc8e568eb" translate="yes" xml:space="preserve">
          <source>If you are looking for a &quot;bar&quot; that isn't preceded by a &quot;foo&quot;, &lt;code&gt;/(?!foo)bar/&lt;/code&gt; will not do what you want. That's because the &lt;code&gt;(?!foo)&lt;/code&gt; is just saying that the next thing cannot be &quot;foo&quot;--and it's not, it's a &quot;bar&quot;, so &quot;foobar&quot; will match. Use lookbehind instead (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc60d35f80efdd879c9aa94cc9f2ee7ad195384c" translate="yes" xml:space="preserve">
          <source>If you are looking for a class that does everything for you that you don't define yourself, use the &lt;code&gt;Tie::StdScalar&lt;/code&gt; class, not the &lt;code&gt;Tie::Scalar&lt;/code&gt; one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20427718038bfba8c53137f8646eb9abfc2ff46" translate="yes" xml:space="preserve">
          <source>If you are looking for a class that does everything for you you don't define yourself, use the &lt;code&gt;Tie::StdScalar&lt;/code&gt; class, not the &lt;code&gt;Tie::Scalar&lt;/code&gt; one.</source>
          <target state="translated">Если вы ищете класс, который делает все, что вы не определяете сами, используйте класс &lt;code&gt;Tie::StdScalar&lt;/code&gt; , а не &lt;code&gt;Tie::Scalar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7787fb3feb00a627232c8ef4ce3954c9d7deed73" translate="yes" xml:space="preserve">
          <source>If you are looking for a table of contents to the Perl library modules documentation, see the &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt; page.</source>
          <target state="translated">Если вы ищете оглавление документации по модулям библиотеки Perl, см. &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;Страницу perltoc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40f5e81161933568c426f178117fbe0b2c9f0084" translate="yes" xml:space="preserve">
          <source>If you are looking for a table of contents to the Perl library modules documentation, see the &lt;a href=&quot;perltoc&quot;&gt;perltoc&lt;/a&gt; page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fac826063cfc00ef4ae02f7626b0848d723ad5d" translate="yes" xml:space="preserve">
          <source>If you are looking for an example, I recommend that you look at the simple example in the Memoize::Expire documentation, or at the code for Memoize::Expire itself.</source>
          <target state="translated">Если вы ищете пример,я рекомендую вам посмотреть на простой пример в документации Memoize::Expire,или на код для Memoize::Expire.</target>
        </trans-unit>
        <trans-unit id="01bb70148d15624f6da074182f77ad2f0eee86c6" translate="yes" xml:space="preserve">
          <source>If you are looking for helpers with &lt;code&gt;is&lt;/code&gt;, &lt;code&gt;like&lt;/code&gt;, and others, see &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33652a525614ae7d89321a43fb11331d7e5b6fa" translate="yes" xml:space="preserve">
          <source>If you are making use of the Perl stack pointer in your code you must always refresh the local copy using SPAGAIN whenever you make use of the</source>
          <target state="translated">Если вы используете указатель стека Perl в вашем коде,вы всегда должны обновлять локальную копию,используя SPAGAIN,всякий раз,когда вы используете</target>
        </trans-unit>
        <trans-unit id="31bb9506f4ff23e6db70b0b08455755a7de18605" translate="yes" xml:space="preserve">
          <source>If you are not using threads, forking, or IPC then the only difference between a &lt;code&gt;filter&lt;/code&gt; and a &lt;code&gt;pre_filter&lt;/code&gt; is that &lt;code&gt;pre_filter&lt;/code&gt; subs run first. When you are using threads, forking, or IPC, pre_filters happen to events before they are sent to their destination proc/thread, ordinary filters happen only in the destination hub/thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0468c5bae6319f4655b5720508b9d190b598ea2a" translate="yes" xml:space="preserve">
          <source>If you are on a Unix-like system, you might be able to get away with a system call where you put an &lt;code&gt;&amp;amp;&lt;/code&gt; on the end of the command:</source>
          <target state="translated">Если вы работаете в Unix-подобной системе, вам, возможно, удастся обойтись без системного вызова, в котором вы поставите &lt;code&gt;&amp;amp;&lt;/code&gt; в конце команды:</target>
        </trans-unit>
        <trans-unit id="74fb92ccab7935bd1e0cc2c8300a7bef29eb75de" translate="yes" xml:space="preserve">
          <source>If you are on a non-UNIX platform &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;, as some features may be unimplemented or work differently.</source>
          <target state="translated">Если вы используете &lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perlport&quot;&gt;perlport на&lt;/a&gt; платформе, &lt;b&gt;отличной от &lt;/b&gt;UNIX , некоторые функции могут быть нереализованы или работать по-другому.</target>
        </trans-unit>
        <trans-unit id="5f59ff52a71652ecb89231c85ecae2ce17688eb9" translate="yes" xml:space="preserve">
          <source>If you are on a system that correctly implements &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; and you use the example appending code from &quot;perldoc -f flock&quot; everything will be OK even if the OS you are on doesn't implement append mode correctly (if such a system exists). So if you are happy to restrict yourself to OSs that implement &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; (and that's not really much of a restriction) then that is what you should do.</source>
          <target state="translated">Если вы работаете в системе, которая правильно реализует &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; , и вы используете пример кода добавления из &amp;laquo;perldoc -f flock&amp;raquo;, все будет в порядке, даже если ОС, в которой вы работаете, не реализует режим добавления правильно (если такая система существует). Так что, если вы счастливы ограничить себя ОС, которые реализуют &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; (и это не является серьезным ограничением), то вам следует поступить именно так.</target>
        </trans-unit>
        <trans-unit id="775ac36d1065d528736d6584503c5960de9afca8" translate="yes" xml:space="preserve">
          <source>If you are on a system that correctly implements &lt;code&gt;flock&lt;/code&gt; and you use the example appending code from &quot;perldoc -f flock&quot; everything will be OK even if the OS you are on doesn't implement append mode correctly (if such a system exists). So if you are happy to restrict yourself to OSs that implement &lt;code&gt;flock&lt;/code&gt; (and that's not really much of a restriction) then that is what you should do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d7fa3e38420fc843370b116c9be081ea5603e0" translate="yes" xml:space="preserve">
          <source>If you are only exporting function names it is recommended to omit the ampersand, as the implementation is faster this way.</source>
          <target state="translated">Если вы экспортируете только имена функций,то рекомендуется опустить амперсанд,так как таким образом реализация будет быстрее.</target>
        </trans-unit>
        <trans-unit id="2de91fd61e5dabce87e62b432c1af2d2e0384486" translate="yes" xml:space="preserve">
          <source>If you are overriding any of these methods in your Makefile.PL (in the MY class), please report that to the makemaker mailing list. We are trying to minimize the necessary method overrides and switch to data driven Makefile.PLs wherever possible. In the long run less methods will be overridable via the MY class.</source>
          <target state="translated">Если вы переопределили любой из этих методов в Makefile.PL (в классе MY),пожалуйста,сообщите об этом в список рассылки Makefile.PL.Мы пытаемся минимизировать необходимые переопределения методов и по возможности переключаться на Makefile.PLs,ориентированный на данные.В долгосрочной перспективе меньшее количество методов будет переопределяться через класс MY.</target>
        </trans-unit>
        <trans-unit id="25095e5b9b6ab11015f95ba50809b8be1a58758d" translate="yes" xml:space="preserve">
          <source>If you are particularly interested in customizing this module's output even more, see the source and/or write to me.</source>
          <target state="translated">Если вас особенно интересует настройка вывода этого модуля,посмотрите источник и/или напишите мне.</target>
        </trans-unit>
        <trans-unit id="d40865e3f4f814dc75edbc20fbc8762037c6c824" translate="yes" xml:space="preserve">
          <source>If you are printing IVs, UVs, or NVS instead of the stdio(3) style formatting codes like &lt;code&gt;%d&lt;/code&gt; , &lt;code&gt;%ld&lt;/code&gt; , &lt;code&gt;%f&lt;/code&gt; , you should use the following macros for portability</source>
          <target state="translated">Если вы печатаете IV, UV или NVS вместо кодов форматирования стиля stdio (3), таких как &lt;code&gt;%d&lt;/code&gt; , &lt;code&gt;%ld&lt;/code&gt; , &lt;code&gt;%f&lt;/code&gt; , вы должны использовать следующие макросы для переносимости</target>
        </trans-unit>
        <trans-unit id="367b87e5b6a685cdb2627b032e60c907e2607076" translate="yes" xml:space="preserve">
          <source>If you are printing IVs, UVs, or NVS instead of the stdio(3) style formatting codes like &lt;code&gt;%d&lt;/code&gt;, &lt;code&gt;%ld&lt;/code&gt;, &lt;code&gt;%f&lt;/code&gt;, you should use the following macros for portability</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da5a3aba0348fe8e8ae52d62d3e9bfb01a53b73" translate="yes" xml:space="preserve">
          <source>If you are printing addresses of pointers, use %p or UVxf combined with PTR2UV().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b082a380f246d61dd682cd511f2ea77809e32735" translate="yes" xml:space="preserve">
          <source>If you are printing addresses of pointers, use UVxf combined with PTR2UV(), do not use %lx or %p.</source>
          <target state="translated">Если вы печатаете адреса указателей,используйте UVxf в сочетании с PTR2UV(),не используйте %lx или %p.</target>
        </trans-unit>
        <trans-unit id="b6f4ed221243b9dde4f0f2cc29b067e485bbf822" translate="yes" xml:space="preserve">
          <source>If you are reading this documentation, looking for a replacement for the &lt;code&gt;FileHandle&lt;/code&gt; package, then I suggest you read the documentation for &lt;code&gt;IO::File&lt;/code&gt; too.</source>
          <target state="translated">Если вы читаете эту документацию и ищете замену для пакета &lt;code&gt;FileHandle&lt;/code&gt; , то я предлагаю вам также прочитать документацию для &lt;code&gt;IO::File&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c40246fed4e0a31f96c46a72d0a85e56bbe29c3" translate="yes" xml:space="preserve">
          <source>If you are reading this in the future then it's possible that the state of the art has changed. We recommend you start by reading the perlootut document in the latest stable release of Perl, rather than this version.</source>
          <target state="translated">Если вы читаете это в будущем,то возможно,что состояние искусства изменилось.Мы рекомендуем Вам начать с чтения документа perlootut в последнем стабильном выпуске Perl,а не в этой версии.</target>
        </trans-unit>
        <trans-unit id="d0add6c557074aa94dbce442362b0e5da76c5396" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Bzip2 can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Если вы используете Perl 5.005 или выше, объект &lt;code&gt;$z&lt;/code&gt; , возвращаемый из IO :: Compress :: Bzip2, можно использовать точно так же, как дескриптор &lt;a href=&quot;../file&quot;&gt;файла IO :: File&lt;/a&gt; . Это означает, что все обычные операции с выходным файлом могут выполняться с помощью &lt;code&gt;$z&lt;/code&gt; . Например, для записи в сжатый файл / буфер вы можете использовать любую из этих форм</target>
        </trans-unit>
        <trans-unit id="b7e4df4e4f27db0bf9a46e2a1941e85758d61068" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Deflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Если вы используете Perl 5.005 или выше, объект &lt;code&gt;$z&lt;/code&gt; , возвращенный из IO :: Compress :: Deflate, можно использовать точно так же, как дескриптор &lt;a href=&quot;../file&quot;&gt;файла IO :: File&lt;/a&gt; . Это означает, что все обычные операции с выходным файлом могут выполняться с помощью &lt;code&gt;$z&lt;/code&gt; . Например, для записи в сжатый файл / буфер вы можете использовать любую из этих форм</target>
        </trans-unit>
        <trans-unit id="41e65ffc69fed189ecd525fba0988f92db4e7035" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Gzip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Если вы используете Perl 5.005 или выше, объект &lt;code&gt;$z&lt;/code&gt; , возвращаемый из IO :: Compress :: Gzip, можно использовать точно так же, как дескриптор &lt;a href=&quot;../file&quot;&gt;файла IO :: File&lt;/a&gt; . Это означает, что все обычные операции с выходным файлом могут выполняться с помощью &lt;code&gt;$z&lt;/code&gt; . Например, для записи в сжатый файл / буфер вы можете использовать любую из этих форм</target>
        </trans-unit>
        <trans-unit id="c6b6ef257ae9881b6bd3fd8eaa22b1a4c05c99ca" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::RawDeflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Если вы используете Perl 5.005 или выше, объект &lt;code&gt;$z&lt;/code&gt; , возвращенный из IO :: Compress :: RawDeflate, можно использовать точно так же, как дескриптор &lt;a href=&quot;../file&quot;&gt;файла IO :: File&lt;/a&gt; . Это означает, что все обычные операции с выходным файлом могут выполняться с помощью &lt;code&gt;$z&lt;/code&gt; . Например, для записи в сжатый файл / буфер вы можете использовать любую из этих форм</target>
        </trans-unit>
        <trans-unit id="3c423a94c7fc5cb61812044d70c6c094354f683a" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Zip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Если вы используете Perl 5.005 или выше, объект &lt;code&gt;$z&lt;/code&gt; , возвращенный из IO :: Compress :: Zip, можно использовать точно так же, как дескриптор &lt;a href=&quot;../file&quot;&gt;файла IO :: File&lt;/a&gt; . Это означает, что все обычные операции с выходным файлом могут выполняться с помощью &lt;code&gt;$z&lt;/code&gt; . Например, для записи в сжатый файл / буфер вы можете использовать любую из этих форм</target>
        </trans-unit>
        <trans-unit id="5fea5722273a1695c99b2d6f3f73bb1257cd24c3" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::AnyInflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Если вы используете Perl 5.005 или выше, объект &lt;code&gt;$z&lt;/code&gt; , возвращенный из IO :: Uncompress :: AnyInflate, можно использовать точно так же, как &lt;a href=&quot;../file&quot;&gt;файловый&lt;/a&gt; дескриптор IO :: File . Это означает, что все обычные операции с входным файлом могут выполняться с помощью &lt;code&gt;$z&lt;/code&gt; . Например, чтобы прочитать строку из сжатого файла / буфера, вы можете использовать любую из этих форм</target>
        </trans-unit>
        <trans-unit id="b2972d5cdbb1eb98b989631b3ded397e40e59e75" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::AnyUncompress can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Если вы используете Perl 5.005 или выше, объект &lt;code&gt;$z&lt;/code&gt; , возвращенный из IO :: Uncompress :: AnyUncompress, можно использовать точно так же, как &lt;a href=&quot;../file&quot;&gt;файловый&lt;/a&gt; дескриптор IO :: File . Это означает, что все обычные операции с входным файлом могут выполняться с помощью &lt;code&gt;$z&lt;/code&gt; . Например, чтобы прочитать строку из сжатого файла / буфера, вы можете использовать любую из этих форм</target>
        </trans-unit>
        <trans-unit id="18aa1921698d337e93a7e4edaa2b66e95de457bf" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Bunzip2 can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Если вы используете Perl 5.005 или выше, объект &lt;code&gt;$z&lt;/code&gt; , возвращенный из IO :: Uncompress :: Bunzip2, можно использовать точно так же, как дескриптор &lt;a href=&quot;../file&quot;&gt;файла IO :: File&lt;/a&gt; . Это означает, что все обычные операции с входным файлом могут выполняться с помощью &lt;code&gt;$z&lt;/code&gt; . Например, чтобы прочитать строку из сжатого файла / буфера, вы можете использовать любую из этих форм</target>
        </trans-unit>
        <trans-unit id="f86eb994b5def7f39f87b382b570ded31372309e" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Gunzip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Если вы используете Perl 5.005 или выше, объект &lt;code&gt;$z&lt;/code&gt; , возвращенный из IO :: Uncompress :: Gunzip, можно использовать точно так же, как дескриптор &lt;a href=&quot;../file&quot;&gt;файла IO :: File&lt;/a&gt; . Это означает, что все обычные операции с входным файлом могут выполняться с помощью &lt;code&gt;$z&lt;/code&gt; . Например, чтобы прочитать строку из сжатого файла / буфера, вы можете использовать любую из этих форм</target>
        </trans-unit>
        <trans-unit id="05ab40d4db9fa577fb79380b48870abe52f5c6be" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Inflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Если вы используете Perl 5.005 или выше, объект &lt;code&gt;$z&lt;/code&gt; , возвращенный из IO :: Uncompress :: Inflate, можно использовать точно так же, как дескриптор &lt;a href=&quot;../file&quot;&gt;файла IO :: File&lt;/a&gt; . Это означает, что все обычные операции с входным файлом могут выполняться с помощью &lt;code&gt;$z&lt;/code&gt; . Например, чтобы прочитать строку из сжатого файла / буфера, вы можете использовать любую из этих форм</target>
        </trans-unit>
        <trans-unit id="d70a4ecbd7bb1c964123dba102fe8a49b561cb00" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::RawInflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Если вы используете Perl 5.005 или выше, объект &lt;code&gt;$z&lt;/code&gt; , возвращенный из IO :: Uncompress :: RawInflate, можно использовать точно так же, как &lt;a href=&quot;../file&quot;&gt;файловый&lt;/a&gt; дескриптор IO :: File . Это означает, что все обычные операции с входным файлом могут выполняться с помощью &lt;code&gt;$z&lt;/code&gt; . Например, чтобы прочитать строку из сжатого файла / буфера, вы можете использовать любую из этих форм</target>
        </trans-unit>
        <trans-unit id="3608890b582bffd465c544ac9e831ad2b06501a0" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Unzip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Если вы используете Perl 5.005 или выше, объект &lt;code&gt;$z&lt;/code&gt; , возвращенный из IO :: Uncompress :: Unzip, можно использовать точно так же, как дескриптор &lt;a href=&quot;../file&quot;&gt;файла IO :: File&lt;/a&gt; . Это означает, что все обычные операции с входным файлом могут выполняться с помощью &lt;code&gt;$z&lt;/code&gt; . Например, чтобы прочитать строку из сжатого файла / буфера, вы можете использовать любую из этих форм</target>
        </trans-unit>
        <trans-unit id="c3f55f8a5aa9143947c1b03103f8fcb1230f8026" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Bzip2 can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c943ecc09f7906641ce0c8c9195f36b53b0da84" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Deflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d2de3cb6af8e02dfa388bc8385e1f9fef63232" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Gzip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f19394fb5dae0da1468d85a7077d6de961381d1" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::RawDeflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8705529210f30abadfa2690a88a8e55709062caf" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Zip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8dcbb9c89b754c497d19b04a16a87cbcd0b450" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::AnyInflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc295bba8742677124dc7e9dbafd6bdce18ea43" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::AnyUncompress can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04020399fea242c9c0dc69403e3ea87fc90e780" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Bunzip2 can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8386c862fdf7a36268d1e2d11759b36cc61a052" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Gunzip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e228b2a0d2a2705757b5a03c01b16b81052402f0" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Inflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="250328bb572e14771a91f743881702e8168f7ce1" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::RawInflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7ddace8a1bf7c76549d07abf22fa8e8e550364" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Unzip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f53b731da5c3618fcf6d87c9434da7f9ed2f65" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.6.0 or better, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma allows fine control of what warnings are produced. See &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; for more details.</source>
          <target state="translated">Если вы работаете в Perl 5.6.0 или лучше, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; Прагма позволяет точно контролировать то , что производится предупреждение. Смотрите &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="e3a447e1361d79aaa9ee74688b52a31d693ae7e5" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.6.0 or better, the &lt;code&gt;use warnings&lt;/code&gt; pragma allows fine control of what warnings are produced. See &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8514c8e63d77882efdff2789324ce75a2c20f4" translate="yes" xml:space="preserve">
          <source>If you are running VOS Release 14.4.1 or later, you can obtain a pre-compiled, supported copy of perl by purchasing the GNU Tools product from Stratus Technologies.</source>
          <target state="translated">Если вы используете версию VOS 14.4.1 или более позднюю,вы можете получить предварительно скомпилированную и поддерживаемую копию perl,купив продукт GNU Tools у компании Stratus Technologies.</target>
        </trans-unit>
        <trans-unit id="90113b08f2e5803b4f4fa9119cc6038c86b7bb42" translate="yes" xml:space="preserve">
          <source>If you are running a Unix derivative this value defaults to</source>
          <target state="translated">Если вы используете производную Unix,то это значение по умолчанию равно</target>
        </trans-unit>
        <trans-unit id="9cc43bdd9e8f39cf93edce0474ecd12686e0c219" translate="yes" xml:space="preserve">
          <source>If you are running experiments with embedding perl as a library into other applications, you might find MakeMaker is not sufficient. You'd better have a look at &lt;a href=&quot;ExtUtils::Embed&quot;&gt;ExtUtils::Embed&lt;/a&gt; which is a collection of utilities for embedding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae421a254aed7ffd059cb6be52110578a85cd308" translate="yes" xml:space="preserve">
          <source>If you are running experiments with embedding perl as a library into other applications, you might find MakeMaker is not sufficient. You'd better have a look at ExtUtils::Embed which is a collection of utilities for embedding.</source>
          <target state="translated">Если вы проводите эксперименты с встраиванием perl в качестве библиотеки в другие приложения,вы можете обнаружить,что MakeMaker не достаточен.Вам лучше взглянуть на ExtUtils::Embed-коллекцию утилит для встраивания.</target>
        </trans-unit>
        <trans-unit id="743cbf656ee357233b7747fd85635a26f54ae749" translate="yes" xml:space="preserve">
          <source>If you are running the tests from a emacs shell window, you may see failures in op/stat.t. Run &quot;dmake test-notty&quot; in that case.</source>
          <target state="translated">Если вы запускаете тесты из окна оболочки emacs,вы можете увидеть сбои в op/stat.t.Запустите &quot;dmake test-notty&quot; в этом случае.</target>
        </trans-unit>
        <trans-unit id="eb661707e45d0fa6207ff65030fca0e35ac953eb" translate="yes" xml:space="preserve">
          <source>If you are running under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; (and if you aren't, why in the world aren't you?), you'll have to add some declarations to make it happy:</source>
          <target state="translated">Если вы работаете с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; (а если нет, то почему, черт возьми, не так?), Вам придется добавить несколько объявлений, чтобы сделать это счастливым:</target>
        </trans-unit>
        <trans-unit id="0cc4f2e6ac843fbaf8224a05183a7220196cd15a" translate="yes" xml:space="preserve">
          <source>If you are running under &lt;code&gt;use strict&lt;/code&gt; (and if you aren't, why in the world aren't you?), you'll have to add some declarations to make it happy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767de91007776d2ff4bd67fc3c5e04ab7cebdfa3" translate="yes" xml:space="preserve">
          <source>If you are seeing spaces between the elements of your array when you print the array, you are probably interpolating the array in double quotes:</source>
          <target state="translated">Если вы видите пробелы между элементами массива,когда вы печатаете массив,вы,вероятно,интерполируете массив в двойных кавычках:</target>
        </trans-unit>
        <trans-unit id="094ee1dd3418e11cdcfc777d87840149f066679d" translate="yes" xml:space="preserve">
          <source>If you are stuck with older Perls, you can do Unicode with the &lt;a href=&quot;Unicode::String&quot;&gt;Unicode::String&lt;/a&gt; module, and character conversions using the &lt;a href=&quot;Unicode::Map8&quot;&gt;Unicode::Map8&lt;/a&gt; and &lt;a href=&quot;Unicode::Map&quot;&gt;Unicode::Map&lt;/a&gt; modules. If you are using Japanese encodings, you might try using the jperl 5.005_03.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16bb00dc57c212c5f89aeced92e2138d70407e36" translate="yes" xml:space="preserve">
          <source>If you are stuck with older Perls, you can do Unicode with the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::String&quot;&gt;Unicode::String&lt;/a&gt; module, and character conversions using the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map8&quot;&gt;Unicode::Map8&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map&quot;&gt;Unicode::Map&lt;/a&gt; modules. If you are using Japanese encodings, you might try using the jperl 5.005_03.</source>
          <target state="translated">Если вы застряли в старых версиях Perls, вы можете использовать Unicode с модулем &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::String&quot;&gt;Unicode :: String&lt;/a&gt; и преобразовывать символы с помощью модулей &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map8&quot;&gt;Unicode :: Map8&lt;/a&gt; и &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map&quot;&gt;Unicode :: Map&lt;/a&gt; . Если вы используете японскую кодировку, вы можете попробовать использовать jperl 5.005_03.</target>
        </trans-unit>
        <trans-unit id="a4539f5703f218245f234df49c0b9e75bd10857f" translate="yes" xml:space="preserve">
          <source>If you are submitting a code patch there are several things that you can do to help the Perl 5 Porters accept your patch.</source>
          <target state="translated">Если вы отправляете кодовый патч,есть несколько вещей,которые вы можете сделать,чтобы помочь Perl 5 Porters принять ваш патч.</target>
        </trans-unit>
        <trans-unit id="9d2ae6978c448ceee8a44a91cddc4545fb9e5c5e" translate="yes" xml:space="preserve">
          <source>If you are targetting an ARM device -- which currently includes the vast majority of phones and tablets -- you'll want to pass -Dcc=arm-unknown-nto-qnx8.0.0eabi-gcc to Configure. Alternatively, if you are targetting an x86 device, or using the simulator provided with the NDK, you should specify -Dcc=ntox86-gcc instead.</source>
          <target state="translated">Если вы нацеливаетесь на ARM-устройство --которое в настоящее время включает в себя подавляющее большинство телефонов и планшетов --вам нужно будет передать -Dcc=arm-unknown-nto-qnx8.0.0eabi-gcc для конфигурирования.В качестве альтернативы,если вы нацеливаетесь на устройство x86 или используете симулятор,поставляемый вместе с NDK,вам следует указать -Dcc=ntox86-gcc.</target>
        </trans-unit>
        <trans-unit id="562b5f2e0c42aed49d34015bad0780eaae56e849" translate="yes" xml:space="preserve">
          <source>If you are targetting x86 Android, you will have to change &lt;code&gt;$TARGETARCH-gcc&lt;/code&gt; to &lt;code&gt;i686-linux-android-gcc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81847f52511bd6e6f2d950ba6b028d46d7fda4c" translate="yes" xml:space="preserve">
          <source>If you are testing locales (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), there are helper functions in</source>
          <target state="translated">Если вы тестируете локали (см. &lt;a href=&quot;perllocale&quot;&gt;Perllocale&lt;/a&gt; ), в</target>
        </trans-unit>
        <trans-unit id="638d5e69c0134925bf444f9f37d95ff5346d9353" translate="yes" xml:space="preserve">
          <source>If you are testing only once, the standard module &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt; exports the function &lt;code&gt;any&lt;/code&gt; for this purpose. It works by stopping once it finds the element. It's written in C for speed, and its Perl equivalent looks like this subroutine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1005d40b52c8fba9456ef2a3b1ec6cff90f7233f" translate="yes" xml:space="preserve">
          <source>If you are testing only once, the standard module &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; exports the function &lt;code&gt;first&lt;/code&gt; for this purpose. It works by stopping once it finds the element. It's written in C for speed, and its Perl equivalent looks like this subroutine:</source>
          <target state="translated">Если вы тестируете только один раз, стандартный модуль &lt;a href=&quot;list/util&quot;&gt;List :: Util &lt;/a&gt; &lt;code&gt;first&lt;/code&gt; экспортирует функцию для этой цели. Он работает, останавливаясь, как только находит элемент. Он написан на C для скорости, а его эквивалент в Perl выглядит так:</target>
        </trans-unit>
        <trans-unit id="ee2ce6dbafcb9d4d548485293c0456fbed2a8877" translate="yes" xml:space="preserve">
          <source>If you are trying to use this instead of &lt;a href=&quot;#write-FILEHANDLE&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; to capture the output, you may find it easier to open a filehandle to a scalar (&lt;code&gt;open my $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt;) and write to that instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf3c25ab12fb420d9fdf6ea0144e15dc43f0fe2" translate="yes" xml:space="preserve">
          <source>If you are trying to use this instead of &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; to capture the output, you may find it easier to open a filehandle to a scalar (&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ) and write to that instead.</source>
          <target state="translated">Если вы пытаетесь использовать это вместо &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; для захвата вывода, вам может быть проще открыть дескриптор файла для скаляра ( &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ) и вместо этого записать в него.</target>
        </trans-unit>
        <trans-unit id="87f126d580b9d17eb9520e5adc6ebcd7b64cbce8" translate="yes" xml:space="preserve">
          <source>If you are trying to use this instead of &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; to capture the output, you may find it easier to open a filehandle to a scalar (&lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ) and write to that instead.</source>
          <target state="translated">Если вы пытаетесь использовать это вместо &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; для захвата вывода, вам может быть проще открыть дескриптор файла для скаляра ( &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ) и вместо этого записать в него.</target>
        </trans-unit>
        <trans-unit id="f0601abe3b8fe05fc06de5499fb9941a40db6bc0" translate="yes" xml:space="preserve">
          <source>If you are unable to send your report using &lt;b&gt;perlbug&lt;/b&gt; (most likely because your system doesn't have a way to send mail that perlbug recognizes), you may be able to use this tool to compose your report and save it to a file which you can then send to &lt;b&gt;perlbug@perl.org&lt;/b&gt; using your regular mail client.</source>
          <target state="translated">Если вы не можете отправить отчет с помощью &lt;b&gt;perlbug&lt;/b&gt; (скорее всего, из-за того, что ваша система не имеет возможности отправлять почту, которую распознает perlbug), вы можете использовать этот инструмент для составления отчета и сохранения его в файл, который вы затем можно отправить на &lt;b&gt;perlbug@perl.org&lt;/b&gt; с помощью обычного почтового клиента.</target>
        </trans-unit>
        <trans-unit id="dd788f693f0912cff62f6c5004a3304201e94790" translate="yes" xml:space="preserve">
          <source>If you are used to working with a version of Perl prior to the introduction of lexically scoped warnings, or have code that uses both lexical warnings and &lt;code&gt;$^W&lt;/code&gt; , this section will describe how they interact.</source>
          <target state="translated">Если вы привыкли работать с версией Perl до введения предупреждений с лексической областью видимости или имеете код, который использует как лексические предупреждения, так и &lt;code&gt;$^W&lt;/code&gt; , в этом разделе будет описано, как они взаимодействуют.</target>
        </trans-unit>
        <trans-unit id="d4b0bb469edf0650ec3f65bb5c7e77e909873d27" translate="yes" xml:space="preserve">
          <source>If you are used to working with a version of Perl prior to the introduction of lexically scoped warnings, or have code that uses both lexical warnings and &lt;code&gt;$^W&lt;/code&gt;, this section will describe how they interact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e74829ea9d71b80a5466e72595b5d826dd1692" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt; or one of its subclasses, you can call the &lt;code&gt;autoflush&lt;/code&gt; method to change the settings of the filehandle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c883172a7bd8c24338f9dd7a287c030969e4c2" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt; or one of its subclasses, you can call the &lt;code&gt;autoflush&lt;/code&gt; method to change the settings of the filehandle:</source>
          <target state="translated">Если вы используете &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt; или один из его подклассов, вы можете вызвать метод &lt;code&gt;autoflush&lt;/code&gt; , чтобы изменить настройки дескриптора файла:</target>
        </trans-unit>
        <trans-unit id="66ca3a901cfd38d2b33b77415f58b3c173825a91" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;HePV&lt;/code&gt; to get values to pass to &lt;code&gt;newSVpvn()&lt;/code&gt; to create a new SV, you should consider using &lt;code&gt;newSVhek(HeKEY_hek(he))&lt;/code&gt; as it is more efficient.</source>
          <target state="translated">Если вы используете &lt;code&gt;HePV&lt;/code&gt; для передачи значений в &lt;code&gt;newSVpvn()&lt;/code&gt; для создания нового SV, вам следует рассмотреть возможность использования &lt;code&gt;newSVhek(HeKEY_hek(he))&lt;/code&gt; поскольку это более эффективно.</target>
        </trans-unit>
        <trans-unit id="987d668924ef21e965c8815374cd5ece61317689" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;nanosleep&lt;/code&gt; for something else than mixing sleeping with signals, give some thought to whether Perl is the tool you should be using for work requiring nanosecond accuracies.</source>
          <target state="translated">Если вы используете &lt;code&gt;nanosleep&lt;/code&gt; для чего-то другого, кроме смешивания сна с сигналами, подумайте , является ли Perl тем инструментом, который вы должны использовать для работы, требующей наносекундной точности.</target>
        </trans-unit>
        <trans-unit id="ef7387a4fe9a4611da9e256c7be19f5e356ca6ea" translate="yes" xml:space="preserve">
          <source>If you are using ACLs, there is a pragma called &lt;a href=&quot;filetest&quot;&gt;&lt;code&gt;filetest&lt;/code&gt;&lt;/a&gt; that may produce more accurate results than the bare &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; mode bits. When under &lt;code&gt;use filetest 'access'&lt;/code&gt;, the above-mentioned filetests test whether the permission can(not) be granted using the &lt;a href=&quot;http://man.he.net/man2/access&quot;&gt;access(2)&lt;/a&gt; family of system calls. Also note that the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;-X&lt;/code&gt; tests may under this pragma return true even if there are no execute permission bits set (nor any extra execute permission ACLs). This strangeness is due to the underlying system calls' definitions. Note also that, due to the implementation of &lt;code&gt;use filetest 'access'&lt;/code&gt;, the &lt;code&gt;_&lt;/code&gt; special filehandle won't cache the results of the file tests when this pragma is in effect. Read the documentation for the &lt;a href=&quot;filetest&quot;&gt;&lt;code&gt;filetest&lt;/code&gt;&lt;/a&gt; pragma for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a45f762f42b66675541c22b88f50402f53057c" translate="yes" xml:space="preserve">
          <source>If you are using ACLs, there is a pragma called &lt;code&gt;filetest&lt;/code&gt; that may produce more accurate results than the bare stat() mode bits. When under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; the above-mentioned filetests test whether the permission can(not) be granted using the access(2) family of system calls. Also note that the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; may under this pragma return true even if there are no execute permission bits set (nor any extra execute permission ACLs). This strangeness is due to the underlying system calls' definitions. Note also that, due to the implementation of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; , the &lt;code&gt;_&lt;/code&gt; special filehandle won't cache the results of the file tests when this pragma is in effect. Read the documentation for the &lt;code&gt;filetest&lt;/code&gt; pragma for more information.</source>
          <target state="translated">Если вы используете списки управления &lt;code&gt;filetest&lt;/code&gt; , существует прагма filetest, которая может дать более точные результаты, чем биты в режиме stat (). При &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; вышеупомянутые filetests проверяют, можно ли предоставить разрешение с использованием семейства системных вызовов access (2). Также обратите внимание, что &lt;code&gt;-x&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; могут в соответствии с этой прагмой возвращать истину, даже если не установлены биты разрешения на выполнение (или какие-либо дополнительные ACL разрешения на выполнение). Эта странность связана с определениями основных системных вызовов. Следует также отметить , что в связи с осуществлением &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; , то &lt;code&gt;_&lt;/code&gt; специальный дескриптор файла не будет кэшировать результаты файловых тестов, когда действует эта прагма. Прочтите документацию к &lt;code&gt;filetest&lt;/code&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="536f259afd4833a386595561631d799b0872387d" translate="yes" xml:space="preserve">
          <source>If you are using ACLs, there is a pragma called &lt;code&gt;filetest&lt;/code&gt; that may produce more accurate results than the bare stat() mode bits. When under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; the above-mentioned filetests test whether the permission can(not) be granted using the access(2) family of system calls. Also note that the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; may under this pragma return true even if there are no execute permission bits set (nor any extra execute permission ACLs). This strangeness is due to the underlying system calls' definitions. Note also that, due to the implementation of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; , the &lt;code&gt;_&lt;/code&gt; special filehandle won't cache the results of the file tests when this pragma is in effect. Read the documentation for the &lt;code&gt;filetest&lt;/code&gt; pragma for more information.</source>
          <target state="translated">Если вы используете списки управления &lt;code&gt;filetest&lt;/code&gt; , существует прагма filetest, которая может дать более точные результаты, чем биты в режиме stat (). При &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; вышеупомянутые filetests проверяют, можно ли предоставить разрешение с использованием семейства системных вызовов access (2). Также обратите внимание, что &lt;code&gt;-x&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; могут в соответствии с этой прагмой возвращать истину, даже если не установлены биты разрешения на выполнение (или какие-либо дополнительные ACL разрешения на выполнение). Эта странность связана с определениями основных системных вызовов. Следует также отметить , что в связи с осуществлением &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; , то &lt;code&gt;_&lt;/code&gt; специальный дескриптор файла не будет кэшировать результаты файловых тестов, когда действует эта прагма. Прочтите документацию к &lt;code&gt;filetest&lt;/code&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="4cb0cc5912b1065f25576985628bc261176328a3" translate="yes" xml:space="preserve">
          <source>If you are using MacOS, the same concerns apply. MacPerl (for Classic environments) comes with a simple editor. Popular external editors are BBEdit ( &lt;a href=&quot;http://www.barebones.com/products/bbedit/&quot;&gt;http://www.barebones.com/products/bbedit/&lt;/a&gt; ) or Alpha ( &lt;a href=&quot;http://www.his.com/~jguyer/Alpha/Alpha8.html&quot;&gt;http://www.his.com/~jguyer/Alpha/Alpha8.html&lt;/a&gt; ). MacOS X users can use Unix editors as well.</source>
          <target state="translated">Если вы используете MacOS, возникают те же проблемы. MacPerl (для классических сред) поставляется с простым редактором. Популярными внешними редакторами являются BBEdit ( &lt;a href=&quot;http://www.barebones.com/products/bbedit/&quot;&gt;http://www.barebones.com/products/bbedit/&lt;/a&gt; ) или Alpha ( &lt;a href=&quot;http://www.his.com/~jguyer/Alpha/Alpha8.html&quot;&gt;http://www.his.com/~jguyer/Alpha/Alpha8.html&lt;/a&gt; ). Пользователи MacOS X также могут использовать редакторы Unix.</target>
        </trans-unit>
        <trans-unit id="6089a0839b7337d6b244906202548f79ff85a178" translate="yes" xml:space="preserve">
          <source>If you are using Plack (which most frameworks do), then &lt;a href=&quot;Plack::Middleware::Rewrite&quot;&gt;Plack::Middleware::Rewrite&lt;/a&gt; is worth looking at if you are migrating from Apache or have URL's you want to always redirect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4548a312b12b5507979ee1df1e5c700b717005" translate="yes" xml:space="preserve">
          <source>If you are using Plack (which most frameworks do), then &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Rewrite&quot;&gt;Plack::Middleware::Rewrite&lt;/a&gt; is worth looking at if you are migrating from Apache or have URL's you want to always redirect.</source>
          <target state="translated">Если вы используете Plack (что используется в большинстве фреймворков), то &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Rewrite&quot;&gt;стоит обратить внимание на Plack :: Middleware :: Rewrite,&lt;/a&gt; если вы переходите с Apache или имеете URL-адреса, которые вы хотите всегда перенаправлять.</target>
        </trans-unit>
        <trans-unit id="88dc2855988852eaabc5467d99d4705c5f78e44c" translate="yes" xml:space="preserve">
          <source>If you are using Term::ANSIColor in a console command, consider supporting the CLICOLOR standard. See &lt;a href=&quot;#Supporting-CLICOLOR&quot;&gt;&quot;Supporting CLICOLOR&quot;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b08c775dc3592188f9dd4afa0190ccbb806664" translate="yes" xml:space="preserve">
          <source>If you are using Windows, you can use any editor that lets you work with plain text, such as NotePad or WordPad. Word processors, such as Microsoft Word or WordPerfect, typically do not work since they insert all sorts of behind-the-scenes information, although some allow you to save files as &quot;Text Only&quot;. You can also download text editors designed specifically for programming, such as Textpad ( &lt;a href=&quot;http://www.textpad.com/&quot;&gt;http://www.textpad.com/&lt;/a&gt; ) and UltraEdit ( &lt;a href=&quot;http://www.ultraedit.com/&quot;&gt;http://www.ultraedit.com/&lt;/a&gt; ), among others.</source>
          <target state="translated">Если вы используете Windows, вы можете использовать любой редактор, позволяющий работать с обычным текстом, например Блокнот или WordPad. Текстовые процессоры, такие как Microsoft Word или WordPerfect, обычно не работают, поскольку они вставляют всевозможную скрытую информацию, хотя некоторые позволяют сохранять файлы как &amp;laquo;Только текст&amp;raquo;. Вы также можете загрузить текстовые редакторы, разработанные специально для программирования, такие как Textpad ( &lt;a href=&quot;http://www.textpad.com/&quot;&gt;http://www.textpad.com/&lt;/a&gt; ) и UltraEdit ( &lt;a href=&quot;http://www.ultraedit.com/&quot;&gt;http://www.ultraedit.com/&lt;/a&gt; ) и другие.</target>
        </trans-unit>
        <trans-unit id="6e650787f6167c83d416119f9b787ce543fc56ec" translate="yes" xml:space="preserve">
          <source>If you are using Windows, you can use any editor that lets you work with plain text, such as NotePad or WordPad. Word processors, such as Microsoft Word or WordPerfect, typically do not work since they insert all sorts of behind-the-scenes information, although some allow you to save files as &quot;Text Only&quot;. You can also download text editors designed specifically for programming, such as Textpad ( &lt;a href=&quot;https://www.textpad.com/&quot;&gt;http://www.textpad.com/&lt;/a&gt; ) and UltraEdit ( &lt;a href=&quot;http://www.ultraedit.com/&quot;&gt;http://www.ultraedit.com/&lt;/a&gt; ), among others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42b14c31c340803d7d1a8907e87c3b623cebca0d" translate="yes" xml:space="preserve">
          <source>If you are using a SOCKS firewall, you will need to compile perl and link it with the SOCKS library. This is what is normally called a 'socksified' perl. With this executable you will be able to connect to servers outside the firewall as if it were not there.</source>
          <target state="translated">Если Вы используете брандмауэр SOCKS,Вам необходимо скомпилировать perl и связать его с библиотекой SOCKS.Это то,что обычно называется 'socksified' perl.С помощью этого исполняемого файла вы сможете подключаться к серверам за пределами брандмауэра так,как будто его там нет.</target>
        </trans-unit>
        <trans-unit id="52dddb8880620f072f3a58161e2e257e19923fa6" translate="yes" xml:space="preserve">
          <source>If you are using a module which returns something special on failure, then you can manually create hints for each of the desired subroutines. Once the hints are specified, they are available for all files and modules loaded thereafter, thus you can move this work into a module and it will still work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c561106308348f3755c72923d0a263a80ca5d3" translate="yes" xml:space="preserve">
          <source>If you are using a regex here, you have to use the quotes as shown or it won't work. Also note that regex handling is tricky even for the experienced. Use this feature with caution.</source>
          <target state="translated">Если вы используете здесь регекс,вы должны использовать котировки,как показано на рисунке,иначе это не сработает.Также обратите внимание,что работа с регексами сложна даже для опытных.Используйте эту функцию с осторожностью.</target>
        </trans-unit>
        <trans-unit id="5a12a925a69a2c6041232d382cd6683ae36d2da6" translate="yes" xml:space="preserve">
          <source>If you are using a version of Perl earlier than 5.004_57, the tied array interface is quite limited. In the example script above &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; or determining the array length will not work with a tied array.</source>
          <target state="translated">Если вы используете версию Perl более раннюю, чем 5.004_57, интерфейс связанных массивов весьма ограничен. В приведенном выше примере сценария &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; или определение длины массива не будут работать с привязанным массивом.</target>
        </trans-unit>
        <trans-unit id="5e370f11050262a4d86dce72f35bfab79335c669" translate="yes" xml:space="preserve">
          <source>If you are using a version of Perl earlier than 5.004_57, the tied array interface is quite limited. In the example script above &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;shift&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt; or determining the array length will not work with a tied array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02abd4a44d56e10cd1bbe5fedc62225b1b539860" translate="yes" xml:space="preserve">
          <source>If you are using any code that requires the execution of the global destruction phase for clean up (e.g., removing temp files), then do not use detached threads, but rather join all threads before exiting the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360a39abe6795afd63327f3e470a092ad595cbfe" translate="yes" xml:space="preserve">
          <source>If you are using cpan-mac, just drop the folder on the &lt;b&gt;installme&lt;/b&gt; droplet, and use the module.</source>
          <target state="translated">Если вы используете CPAN-макинтош, просто перенесите папку на &lt;b&gt;installme&lt;/b&gt; капельке, и использовать модуль.</target>
        </trans-unit>
        <trans-unit id="1fc1c37b5a3d2067860bd9ba4aa2038972693c34" translate="yes" xml:space="preserve">
          <source>If you are using gcc, just</source>
          <target state="translated">Если ты используешь gcc,просто</target>
        </trans-unit>
        <trans-unit id="8fd5d7695f8aa3649f7196f528604d5d3ae20e06" translate="yes" xml:space="preserve">
          <source>If you are using gcc, you would need to use -mcpu=v9 -m64 instead. This option is not yet supported as of gcc 2.95.2; from install/SPECIFIC in that release:</source>
          <target state="translated">Если вы используете gcc,то вместо него нужно использовать -mcpu=v9 -m64.Эта опция пока не поддерживается начиная с версии gcc 2.95.2;из install/SPECIFIC в этом выпуске:</target>
        </trans-unit>
        <trans-unit id="43b374ff761647040bfef238a2f344855f86b957" translate="yes" xml:space="preserve">
          <source>If you are using locale purely for its characteristics related to things like its numeric and time formatting (and not &lt;code&gt;LC_CTYPE&lt;/code&gt; ), consider using a restricted form of the locale pragma (see &lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma in perllocale&lt;/a&gt;) like &quot;&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; &quot;.</source>
          <target state="translated">Если вы используете языковой стандарт исключительно из-за его характеристик, связанных с такими вещами, как числовое форматирование и формат времени (а не &lt;code&gt;LC_CTYPE&lt;/code&gt; ), рассмотрите возможность использования ограниченной формы &lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;прагмы&lt;/a&gt; locale (см . Использование прагмы locale в perllocale ), например &amp;laquo; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="3f4713ad5807b5f7826ec2dd53e64e4312c481e4" translate="yes" xml:space="preserve">
          <source>If you are using locale purely for its characteristics related to things like its numeric and time formatting (and not &lt;code&gt;LC_CTYPE&lt;/code&gt;), consider using a restricted form of the locale pragma (see &lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;&quot;The &quot;use locale&quot; pragma&quot; in perllocale&lt;/a&gt;) like &quot;&lt;code&gt;use locale ':not_characters'&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf7e18738b21f2b01d05483723778a511f7e8e06" translate="yes" xml:space="preserve">
          <source>If you are using the 'make' directly, it is the GNU make from the SDKs, and it will invoke the right make commands for the Windows emulator build and the Arm target builds ('thumb' by default) as necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c7cadf9ebf06d221687f1101781684817f90c8" translate="yes" xml:space="preserve">
          <source>If you are using the DB_RECNO interface and you intend making use of &lt;code&gt;bval&lt;/code&gt; , you should check out &lt;a href=&quot;#The-'bval'-Option&quot;&gt;The 'bval' Option&lt;/a&gt;.</source>
          <target state="translated">Если вы используете интерфейс DB_RECNO и намереваетесь использовать &lt;code&gt;bval&lt;/code&gt; , вам следует проверить опцию &lt;a href=&quot;#The-'bval'-Option&quot;&gt;&amp;laquo;bval&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f6185500a12d4aa7861d0d23b58da2516585e5a" translate="yes" xml:space="preserve">
          <source>If you are using the DB_RECNO interface and you intend making use of &lt;code&gt;bval&lt;/code&gt;, you should check out &lt;a href=&quot;#The-%27bval%27-Option&quot;&gt;&quot;The 'bval' Option&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e34b95c988ef9ff5f011e4473a6842bbc8f305e" translate="yes" xml:space="preserve">
          <source>If you are using the Visual C compiler, you can get the C runtime's command line wildcard expansion built into perl binary. The resulting binary will always expand unquoted command lines, which may not be what you want if you use a shell that does that for you. The expansion done is also somewhat less powerful than the approach suggested above.</source>
          <target state="translated">Если вы используете компилятор Visual C,вы можете получить подстановочный символ командной строки C,встроенный в бинарный файл perl.Полученный двоичный файл всегда будет расширять командные строки без кавычек,что может быть не совсем то,что вам нужно,если вы используете оболочку,которая делает это за вас.Расширение,сделанное,также несколько менее мощное,чем подход,предложенный выше.</target>
        </trans-unit>
        <trans-unit id="7d685e73a12ad96dde7946d5ecb4aacf9b0497e1" translate="yes" xml:space="preserve">
          <source>If you are using the constant interface, be sure to include this code before you use any color constants (such as at the very top of your script), since this environment variable is only honored the first time a color constant is seen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b64d320b887e6639115cc4ac113f85e3f1804107" translate="yes" xml:space="preserve">
          <source>If you are using this in non-legacy code you may need to reconsider the course of your life, maybe a hermitage would suite you?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a368c00c8ef926e64658830003081d5eb361bb8d" translate="yes" xml:space="preserve">
          <source>If you are using zlib 1.2.0 or older, &lt;code&gt;zlibCompileFlags&lt;/code&gt; will return 0.</source>
          <target state="translated">Если вы используете zlib 1.2.0 или старше, &lt;code&gt;zlibCompileFlags&lt;/code&gt; вернет 0.</target>
        </trans-unit>
        <trans-unit id="9d19a794a39cad7420e5c34d0bb89a7b77ddba40" translate="yes" xml:space="preserve">
          <source>If you are willing to accept all the defaults run Configure with &lt;b&gt;-de&lt;/b&gt;. However, several useful customizations are available.</source>
          <target state="translated">Если вы готовы принять все значения по умолчанию, запустите Configure с &lt;b&gt;-de&lt;/b&gt; . Однако доступно несколько полезных настроек.</target>
        </trans-unit>
        <trans-unit id="fd5b1c2924a349d7291d8ad147e3c28043609419" translate="yes" xml:space="preserve">
          <source>If you are working with a git clone of the Perl repository, you will want to create a branch for your changes. This will make creating a proper patch much simpler. See the &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">Если вы работаете с git-клоном репозитория Perl, вам нужно создать ветку для ваших изменений. Это значительно упростит создание правильного патча. Подробнее о том, как это сделать, см. В &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3a5c5d66921962ee5d2f131da55a853da5b0930" translate="yes" xml:space="preserve">
          <source>If you are working with data you know to be valid, you can speed your code up by using the &quot;nocheck&quot; variants, &lt;code&gt;timelocal_nocheck()&lt;/code&gt; and &lt;code&gt;timegm_nocheck()&lt;/code&gt; . These variants must be explicitly imported.</source>
          <target state="translated">Если вы работаете с данными, которые, как вам известно, достоверны, вы можете ускорить свой код, используя варианты &amp;laquo;без проверки&amp;raquo;, &lt;code&gt;timelocal_nocheck()&lt;/code&gt; и &lt;code&gt;timegm_nocheck()&lt;/code&gt; . Эти варианты должны быть явно импортированы.</target>
        </trans-unit>
        <trans-unit id="44340ebb8cf0e2382c2ca3711523d41bd143a85f" translate="yes" xml:space="preserve">
          <source>If you are working with data you know to be valid, you can speed your code up by using the &quot;nocheck&quot; variants, &lt;code&gt;timelocal_nocheck()&lt;/code&gt; and &lt;code&gt;timegm_nocheck()&lt;/code&gt;. These variants must be explicitly imported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9fdba02c2ad23e42f49d14ef3350c451024e80f" translate="yes" xml:space="preserve">
          <source>If you are writing a module to expand an already existing set of modules, please coordinate with the author of the package. It helps if you follow the same naming scheme and module interaction scheme as the original author.</source>
          <target state="translated">Если вы пишете модуль для расширения уже существующего набора модулей,пожалуйста,согласуйте это с автором пакета.Это поможет,если вы будете следовать той же схеме именования и взаимодействия модулей,что и оригинальный автор.</target>
        </trans-unit>
        <trans-unit id="1cd2c8d5447831e253b224430edc3070841bc27c" translate="yes" xml:space="preserve">
          <source>If you are writing a package that &lt;code&gt;AUTOLOAD&lt;/code&gt; s, consider forcing an &lt;code&gt;AUTOLOAD&lt;/code&gt; for any constants explicitly imported by other packages or which are usually used when your package is &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d.</source>
          <target state="translated">Если вы пишете пакет, в котором используется &lt;code&gt;AUTOLOAD&lt;/code&gt; , рассмотрите возможность принудительного выполнения &lt;code&gt;AUTOLOAD&lt;/code&gt; для любых констант, явно импортированных другими пакетами или которые обычно используются, когда ваш пакет &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; d.</target>
        </trans-unit>
        <trans-unit id="008854f6c49a92df108a1a38fd8f1f0c1b757eb6" translate="yes" xml:space="preserve">
          <source>If you are writing a package that &lt;code&gt;AUTOLOAD&lt;/code&gt;s, consider forcing an &lt;code&gt;AUTOLOAD&lt;/code&gt; for any constants explicitly imported by other packages or which are usually used when your package is &lt;code&gt;use&lt;/code&gt;d.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5966f6f48bbef92de0797373659162ca479de0d" translate="yes" xml:space="preserve">
          <source>If you are writing new code, your first port of call should be one of the new &lt;code&gt;IO::Compress&lt;/code&gt; or &lt;code&gt;IO::Uncompress&lt;/code&gt; modules.</source>
          <target state="translated">Если вы пишете новый код, вашим первым портом вызова должен быть один из новых модулей &lt;code&gt;IO::Compress&lt;/code&gt; или &lt;code&gt;IO::Uncompress&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d5955743a0fa060d529640f937e917d974a0fd9" translate="yes" xml:space="preserve">
          <source>If you ask for nothing in particular, you'll be asking for &lt;code&gt;less
'please'&lt;/code&gt; .</source>
          <target state="translated">Если вы не просите ничего особенного, вы будете просить &lt;code&gt;less 'please'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8027e6b734038f8b5eea431be412179b0c1aa993" translate="yes" xml:space="preserve">
          <source>If you ask for nothing in particular, you'll be asking for &lt;code&gt;less 'please'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d232183f686226b9e4d9f0a9749bb4ab75350724" translate="yes" xml:space="preserve">
          <source>If you ask it to unmemoize a function that was never memoized, it croaks.</source>
          <target state="translated">Если вы попросите его снять пленку с функции,которая никогда не была запомнена,он скрипит.</target>
        </trans-unit>
        <trans-unit id="5ac398bf0535c0d2bb95ebfd6fd6655ce0bd6b20" translate="yes" xml:space="preserve">
          <source>If you ask to override your chdir() built-in function,</source>
          <target state="translated">Если вы попросите переопределить вашу встроенную функцию chdir(),</target>
        </trans-unit>
        <trans-unit id="aae82346550e5f30641b00cfb651b5e652048f2e" translate="yes" xml:space="preserve">
          <source>If you attempt to compile Perl with (POSIX) threads on an 11.X system and also link in the GDBM library, then Perl will immediately core dump when it starts up. The only workaround at this point is to relink the GDBM library under 11.X, then relink it into Perl.</source>
          <target state="translated">Если вы попытаетесь скомпилировать Perl с (POSIX)потоками на системе 11.X,а также скомпилировать его в библиотеке GDBM,то при запуске Perl сразу же выдаст дамп ядра.Единственное обходное решение на данном этапе-перекомпилировать библиотеку GDBM под 11.X,а затем перекомпилировать ее в Perl.</target>
        </trans-unit>
        <trans-unit id="372756b443de4017a28427029bf0d506d7081a2a" translate="yes" xml:space="preserve">
          <source>If you believe the scalar comes back as UTF-8, you will most likely want the UTF8 flag restored:</source>
          <target state="translated">Если вы считаете,что скаляр возвращается в виде UTF-8,то,скорее всего,вы захотите восстановить флаг UTF8:</target>
        </trans-unit>
        <trans-unit id="1489e0cb25a613554ca1fb1509eb4766e09aaf06" translate="yes" xml:space="preserve">
          <source>If you believe you have found a security vulnerability in Perl, please email perl5-security-report@perl.org with details. This points to a closed subscription, unarchived mailing list. Please only use this address for security issues in the Perl core, not for modules independently distributed on CPAN.</source>
          <target state="translated">Если вы считаете,что нашли уязвимость в Perl,пожалуйста,напишите по адресу perl5-security-report@perl.org с подробной информацией.Это указывает на закрытую подписку,неархивированный список рассылки.Пожалуйста,используйте этот адрес только для вопросов безопасности в ядре Perl,а не для модулей,независимо распространяемых на CPAN.</target>
        </trans-unit>
        <trans-unit id="74dfa21f751ce3fabe2deb1f0f641c590253ad7e" translate="yes" xml:space="preserve">
          <source>If you believe you have found a security vulnerability in Perl, please email the details to perl5-security-report@perl.org. This creates a new Request Tracker ticket in a special queue which isn't initially publicly accessible. The email will also be copied to a closed subscription unarchived mailing list which includes all the core committers, who will be able to help assess the impact of issues, figure out a resolution, and help co-ordinate the release of patches to mitigate or fix the problem across all platforms on which Perl is supported. Please only use this address for security issues in the Perl core, not for modules independently distributed on CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2508e4352c00aad2e5cda3b21b798f7f8735a139" translate="yes" xml:space="preserve">
          <source>If you build with Visual C++ 2013 then three tests currently may fail with Daylight Saving Time related problems:</source>
          <target state="translated">Если вы строите с Visual C++2013,то три теста в настоящее время могут не работать с проблемами,связанными с летним временем:</target>
        </trans-unit>
        <trans-unit id="a29ad197e59c85308f30e04c723a79c6188595db" translate="yes" xml:space="preserve">
          <source>If you build with Visual C++ 2015 or later then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc747a2308602b12226c600429d56710358ba8a4" translate="yes" xml:space="preserve">
          <source>If you build with certain versions (e.g. 4.8.1) of gcc from www.mingw.org then</source>
          <target state="translated">Если вы собираете с определенными версиями (например,4.8.1)gcc с сайта www.mingw.org,тогда</target>
        </trans-unit>
        <trans-unit id="5d082c0ec07ad4429dea09b4d3b6034a0edf4cf9" translate="yes" xml:space="preserve">
          <source>If you built perl with dynamic loading capability then that would also be the way to build XS based extensions. However, if you built perl with the default static linking you can still build XS based extensions for OS/390 but you will need to follow the instructions in ExtUtils::MakeMaker for building statically linked perl binaries. In the simplest configurations building a static perl + XS extension boils down to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fccb9cfffea038156e1e9bf29f1e74a06b7c692d" translate="yes" xml:space="preserve">
          <source>If you built perl with dynamic loading capability then that would also be the way to build xs based extensions. However, if you built perl with the default static linking you can still build xs based extensions for OS/390 but you will need to follow the instructions in ExtUtils::MakeMaker for building statically linked perl binaries. In the simplest configurations building a static perl + xs extension boils down to:</source>
          <target state="translated">Если вы построили perl с возможностью динамической загрузки,то это также будет способ сборки расширений на основе xs.Однако,если вы собрали perl со статической связью по умолчанию,вы все еще можете собирать расширения на основе xs для OS/390,но вам нужно будет следовать инструкциям в ExtUtils::MakeMaker для сборки статически связанных двоичных файлов perl.В простейших конфигурациях сборка статических расширений perl+xs сводится к следующему:</target>
        </trans-unit>
        <trans-unit id="b4bbe3ec8c3dbb9079b54edeba88cab20e6c6b9a" translate="yes" xml:space="preserve">
          <source>If you call $lh-&amp;gt;maketext(</source>
          <target state="translated">Если вы вызовете $ lh-&amp;gt; maketext (</target>
        </trans-unit>
        <trans-unit id="b2b245ecec2ba731bc1217986ab8fe3ce3832fb6" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;plan()&lt;/code&gt; , don't call any of the other methods below.</source>
          <target state="translated">Если вы вызываете &lt;code&gt;plan()&lt;/code&gt; , не вызывайте никакие другие методы ниже.</target>
        </trans-unit>
        <trans-unit id="1fcdeca5cd1457b673de047212c964254182c124" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;plan()&lt;/code&gt;, don't call any of the other methods below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f29b01f558f5cc8e37b47ab816256a32df3eb207" translate="yes" xml:space="preserve">
          <source>If you call a method that doesn't exist in a class, Perl will throw an error. However, if that class or any of its parent classes defines an &lt;code&gt;AUTOLOAD&lt;/code&gt; method, that &lt;code&gt;AUTOLOAD&lt;/code&gt; method is called instead.</source>
          <target state="translated">Если вы вызовете метод, которого нет в классе, Perl выдаст ошибку. Однако, если этот класс или любой из его родительских классов определяет &lt;code&gt;AUTOLOAD&lt;/code&gt; метод, который &lt;code&gt;AUTOLOAD&lt;/code&gt; метод вызывается вместо.</target>
        </trans-unit>
        <trans-unit id="945646515b442a128e465225a1d325a7ca2f3625" translate="yes" xml:space="preserve">
          <source>If you call a subroutine that is undefined, you would ordinarily get an immediate, fatal error complaining that the subroutine doesn't exist. (Likewise for subroutines being used as methods, when the method doesn't exist in any base class of the class's package.) However, if an &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is defined in the package or packages used to locate the original subroutine, then that &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is called with the arguments that would have been passed to the original subroutine. The fully qualified name of the original subroutine magically appears in the global $AUTOLOAD variable of the same package as the &lt;code&gt;AUTOLOAD&lt;/code&gt; routine. The name is not passed as an ordinary argument because, er, well, just because, that's why. (As an exception, a method call to a nonexistent &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;unimport&lt;/code&gt; method is just skipped instead. Also, if the AUTOLOAD subroutine is an XSUB, there are other ways to retrieve the subroutine name. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;Autoloading with XSUBs in perlguts&lt;/a&gt; for details.)</source>
          <target state="translated">Если вы вызываете подпрограмму, которая не определена, вы обычно получаете немедленную фатальную ошибку с жалобой на то, что подпрограмма не существует. (Аналогично для подпрограмм, используемых в качестве методов, когда метод не существует ни в одном базовом классе пакета класса.) Однако, если подпрограмма &lt;code&gt;AUTOLOAD&lt;/code&gt; определена в пакете или пакетах, используемых для поиска исходной подпрограммы, то эта подпрограмма &lt;code&gt;AUTOLOAD&lt;/code&gt; вызывается с аргументами, которые были бы переданы исходной подпрограмме. Полное имя исходной подпрограммы волшебным образом появляется в глобальной переменной $ AUTOLOAD того же пакета, что и &lt;code&gt;AUTOLOAD&lt;/code&gt; .рутина. Имя не передается как обычный аргумент, потому что, ну, просто потому, вот почему. ( В качестве исключения, метода вызова несуществующего &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;unimport&lt;/code&gt; методы просто пропускаются вместо этого. Кроме того , если подпрограмма AUTOLOAD является XSUB, есть и другие способы , чтобы получить имя подпрограммы. См &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;Автозагрузка с XSUBs в perlguts&lt;/a&gt; для подробной информации).</target>
        </trans-unit>
        <trans-unit id="ae93390d7689eae59da77f05524628edc8a8e772" translate="yes" xml:space="preserve">
          <source>If you call a subroutine that is undefined, you would ordinarily get an immediate, fatal error complaining that the subroutine doesn't exist. (Likewise for subroutines being used as methods, when the method doesn't exist in any base class of the class's package.) However, if an &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is defined in the package or packages used to locate the original subroutine, then that &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is called with the arguments that would have been passed to the original subroutine. The fully qualified name of the original subroutine magically appears in the global $AUTOLOAD variable of the same package as the &lt;code&gt;AUTOLOAD&lt;/code&gt; routine. The name is not passed as an ordinary argument because, er, well, just because, that's why. (As an exception, a method call to a nonexistent &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;unimport&lt;/code&gt; method is just skipped instead. Also, if the AUTOLOAD subroutine is an XSUB, there are other ways to retrieve the subroutine name. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;&quot;Autoloading with XSUBs&quot; in perlguts&lt;/a&gt; for details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a71cdebace5c6abb01b81af0b4383d9f3787c035" translate="yes" xml:space="preserve">
          <source>If you can arrange for everyone to deal with this through references, it's cleaner code, although not so nice to look at. Here's a function that takes two array references as arguments, returning the two array elements in order of how many elements they have in them:</source>
          <target state="translated">Если вы можете устроить так,чтобы каждый справился с этим через ссылки,то это более чистый код,хотя и не очень приятно на него смотреть.Вот функция,которая принимает в качестве аргументов две ссылки на массив,возвращая два элемента массива в порядке их количества:</target>
        </trans-unit>
        <trans-unit id="3cb0b0acb5a45f37eacb24751a1ec1aefb74d989" translate="yes" xml:space="preserve">
          <source>If you can avoid it, don't, or if you can use a templating system, such as &lt;a href=&quot;Text::Template&quot;&gt;Text::Template&lt;/a&gt; or &lt;a href=&quot;template&quot;&gt;Template&lt;/a&gt; Toolkit, do that instead. You might even be able to get the job done with &lt;code&gt;sprintf&lt;/code&gt; or &lt;code&gt;printf&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b6ce07b51bd0ae187fbd5346ee2bf854f2bb10" translate="yes" xml:space="preserve">
          <source>If you can avoid it, don't, or if you can use a templating system, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text::Template&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Template&quot;&gt;Template&lt;/a&gt; Toolkit, do that instead. You might even be able to get the job done with &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Если вы можете этого избежать, не делайте этого или если вы можете использовать систему шаблонов, такую ​​как &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text :: Template&lt;/a&gt; или &lt;a href=&quot;http://search.cpan.org/perldoc/Template&quot;&gt;Template&lt;/a&gt; Toolkit, сделайте это вместо этого. Возможно, вы даже сможете выполнить работу с помощью &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f9556f6832194ce02eb38bf13ea3951955c6d164" translate="yes" xml:space="preserve">
          <source>If you can do these things, you've started on the long road to Perl porting. Thanks for wanting to help make Perl better - and happy hacking!</source>
          <target state="translated">Если ты можешь делать такие вещи,ты начал долгий путь к портированию Перла.Спасибо за желание помочь сделать Perl лучше-и счастливого взлома!</target>
        </trans-unit>
        <trans-unit id="4e5e8e457d8aab789523193251b0cae471debcb4" translate="yes" xml:space="preserve">
          <source>If you can go through your firewall with e.g. lynx, presumably with a command such as</source>
          <target state="translated">Если Вы можете пройти через брандмауэр,например,с помощью рыси,предположительно,с помощью такой команды как</target>
        </trans-unit>
        <trans-unit id="22d913b1c7a6af16ecff397b87485204b5a8ebbc" translate="yes" xml:space="preserve">
          <source>If you can not reach the author for some reason contact the PAUSE admins at modules@perl.org who may be able to help, but each case is treated separately.</source>
          <target state="translated">Если по каким-либо причинам вы не можете связаться с автором,свяжитесь с администраторами PAUSE по адресу modules@perl.org,которые могут помочь,но каждый случай рассматривается отдельно.</target>
        </trans-unit>
        <trans-unit id="e0ff87acae1d2fe61dfcf4190a982955e52a9134" translate="yes" xml:space="preserve">
          <source>If you can't configure &lt;code&gt;TAP::Harness&lt;/code&gt; to do exactly what you want, and writing a plugin isn't an option, consider extending it. It is designed to be (mostly) easy to subclass, though the cases when sub-classing is necessary should be few and far between.</source>
          <target state="translated">Если вы не можете настроить &lt;code&gt;TAP::Harness&lt;/code&gt; чтобы он делал именно то, что вы хотите, и написание плагина не вариант, подумайте о его расширении. Он разработан, чтобы (в основном) легко подклассифицировать, хотя случаев, когда подклассы необходимы, должно быть немного и они встречаются редко.</target>
        </trans-unit>
        <trans-unit id="700d8f92e3038752feec96509274cbd7256d79dc" translate="yes" xml:space="preserve">
          <source>If you can't configure &lt;code&gt;TAP::Harness&lt;/code&gt; to do what you want, and you can't find an existing plugin, consider writing one.</source>
          <target state="translated">Если вы не можете настроить &lt;code&gt;TAP::Harness&lt;/code&gt; для выполнения того, что хотите, и не можете найти существующий плагин, подумайте о его написании.</target>
        </trans-unit>
        <trans-unit id="aab6be6829c9bde3ac67ace0b1b8f3a83861108b" translate="yes" xml:space="preserve">
          <source>If you can't use &lt;a href=&quot;File::Copy&quot;&gt;File::Copy&lt;/a&gt;, you'll have to do the work yourself: open the original file, open the destination file, then print to the destination file as you read the original. You also have to remember to copy the permissions, owner, and group to the new file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcd365c3753fb0814dbbf4b5f1da5978fabe2e0" translate="yes" xml:space="preserve">
          <source>If you can't use &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt;, you'll have to do the work yourself: open the original file, open the destination file, then print to the destination file as you read the original. You also have to remember to copy the permissions, owner, and group to the new file.</source>
          <target state="translated">Если вы не можете использовать &lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt; , вам придется выполнить эту работу самостоятельно: открыть исходный файл, открыть целевой файл, а затем распечатать в целевой файл, когда вы читаете оригинал. Вы также должны не забыть скопировать разрешения, владельца и группу в новый файл.</target>
        </trans-unit>
        <trans-unit id="2431416836e7be159e91db05fdcbf62b13f365c1" translate="yes" xml:space="preserve">
          <source>If you cannot achieve the desired Makefile behaviour by specifying attributes you may define private subroutines in the Makefile.PL. Each subroutine returns the text it wishes to have written to the Makefile. To override a section of the Makefile you can either say:</source>
          <target state="translated">Если вы не можете добиться желаемого поведения Makefile путем указания атрибутов,вы можете определить приватные подпрограммы в Makefile.PL.Каждая подпрограмма возвращает Makefile текст,который она хочет написать.Чтобы переопределить раздел Makefile,вы можете сказать то же самое:</target>
        </trans-unit>
        <trans-unit id="069db45c3cccee54b16dacbbc26ce2a59fc37a49" translate="yes" xml:space="preserve">
          <source>If you cannot upgrade your Perl to 5.8.0 or later, you can still do some Unicode processing by using the modules &lt;code&gt;Unicode::String&lt;/code&gt; , &lt;code&gt;Unicode::Map8&lt;/code&gt; , and &lt;code&gt;Unicode::Map&lt;/code&gt; , available from CPAN. If you have the GNU recode installed, you can also use the Perl front-end &lt;code&gt;Convert::Recode&lt;/code&gt; for character conversions.</source>
          <target state="translated">Если вы не можете обновить Perl до версии 5.8.0 или более поздней, вы все равно можете выполнить некоторую обработку Unicode с помощью модулей &lt;code&gt;Unicode::String&lt;/code&gt; , &lt;code&gt;Unicode::Map8&lt;/code&gt; и &lt;code&gt;Unicode::Map&lt;/code&gt; , доступных на CPAN. Если у вас установлен GNU recode, вы также можете использовать Perl-интерфейс &lt;code&gt;Convert::Recode&lt;/code&gt; для преобразования символов.</target>
        </trans-unit>
        <trans-unit id="675032f69b34d194dcc7017e3c4c3044e3fbd01f" translate="yes" xml:space="preserve">
          <source>If you cannot upgrade your Perl to 5.8.0 or later, you can still do some Unicode processing by using the modules &lt;code&gt;Unicode::String&lt;/code&gt;, &lt;code&gt;Unicode::Map8&lt;/code&gt;, and &lt;code&gt;Unicode::Map&lt;/code&gt;, available from CPAN. If you have the GNU recode installed, you can also use the Perl front-end &lt;code&gt;Convert::Recode&lt;/code&gt; for character conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d66bfc35fac26ccfc5a2fc8cf1cd9923cd9f43b" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt;, you can make your own loop to do the same thing. Once you find the element, you stop the loop with last.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f06f83624114fcf502e132fac57a686e4d7a4ee" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt;, you can make your own loop to do the same thing. Once you find the element, you stop the loop with last.</source>
          <target state="translated">Если вы не можете использовать &lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt; , вы можете создать свой собственный цикл, чтобы сделать то же самое. Как только вы найдете элемент, вы остановите цикл с помощью last.</target>
        </trans-unit>
        <trans-unit id="83e89259781d3b7bf972995b7c8dc74ef7aacff4" translate="yes" xml:space="preserve">
          <source>If you cannot use the git protocol for firewall reasons, you can also clone via http, though this is much slower:</source>
          <target state="translated">Если вы не можете использовать git-протокол по причинам брандмауэра,вы также можете клонировать через http,хотя это гораздо медленнее:</target>
        </trans-unit>
        <trans-unit id="b117af02a8ee1b3faa8a2a2959074d94964f1bce" translate="yes" xml:space="preserve">
          <source>If you cannot use the git protocol for firewall reasons, you can also clone via http:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="794395d65809aff375720f1da63fe61351840429" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;$pattern&lt;/code&gt; after the first substitution happens, Perl will ignore it. If you don't want any substitutions at all, use the special delimiter &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Если вы измените &lt;code&gt;$pattern&lt;/code&gt; после первой замены, Perl проигнорирует это. Если вам совсем не нужны замены, используйте специальный разделитель &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5a64e176836406787422c8fb3c6947be0def6d35" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;$pattern&lt;/code&gt; after the first substitution happens, Perl will ignore it. If you don't want any substitutions at all, use the special delimiter &lt;code&gt;m''&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca560012b71cc8dce8e6a03ec54196daca3d350" translate="yes" xml:space="preserve">
          <source>If you check &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;, you'll see that several of the ways to call open() should do the trick. For example:</source>
          <target state="translated">Если вы отметите &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; , вы увидите, что несколько способов вызвать open () должны помочь. Например:</target>
        </trans-unit>
        <trans-unit id="65c2b7d80f9113d02d83f4af5a6da477cccfeb58" translate="yes" xml:space="preserve">
          <source>If you check &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;, you'll see that several of the ways to call open() should do the trick. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4dedfaceb9670f08b0798c739b80203032d536c" translate="yes" xml:space="preserve">
          <source>If you chomp a list, each element is chomped, and the total number of characters removed is returned.</source>
          <target state="translated">Если вы расплющиваете список,то каждый элемент расплющивается,и возвращается общее количество удаленных символов.</target>
        </trans-unit>
        <trans-unit id="716512a060dd3d5999bac2b4045e2b9123dc9b1b" translate="yes" xml:space="preserve">
          <source>If you choose XL C/C++ V11 you need the April 2010 PTF (or newer) installed otherwise you will not get a working Perl version.</source>
          <target state="translated">Если вы выберете XL C/C++V11,то вам необходимо установить PTF апреля 2010 (или более новую),иначе вы не получите рабочую Perl версию.</target>
        </trans-unit>
        <trans-unit id="c10052f207d29ada4465d2d73fcdfabf3621a0b6" translate="yes" xml:space="preserve">
          <source>If you choose XL C/C++ V9 you need APAR IZ35785 installed otherwise the integrated SDBM_File do not compile correctly due to an optimization bug. You can circumvent this problem by adding -qipa to the optimization flags (-Doptimize='-O -qipa'). The PTF for APAR IZ35785 which solves this problem is available from IBM (April 2009 PTF for XL C/C++ Enterprise Edition for AIX, V9.0).</source>
          <target state="translated">Если вы выберете XL C/C++V9,вам необходимо установить APAR IZ35785,иначе встроенный SDBM_File не скомпилируется корректно из-за ошибки оптимизации.Вы можете обойти эту проблему,добавив -qipa к флагам оптимизации (-Doptimize='-O -qipa').PTF для APAR IZ35785,который решает эту проблему,доступен в IBM (апрель 2009 PTF для XL C/C++Enterprise Edition для AIX,V9.0).</target>
        </trans-unit>
        <trans-unit id="fb54bcde599a5f03b31c1ac1b1fac745b31dc5b8" translate="yes" xml:space="preserve">
          <source>If you choose for the PTH package, use swinstall to install pth in the default location (/opt/pth), and then make symbolic links to the libraries from /usr/lib</source>
          <target state="translated">Если вы выберете пакет PTH,используйте swinstall,чтобы установить pth в месте по умолчанию (/opt/pth),а затем сделайте символические ссылки на библиотеки из /usr/lib.</target>
        </trans-unit>
        <trans-unit id="5ca7b309ef65dd317303754f8c4a5fd3689e4197" translate="yes" xml:space="preserve">
          <source>If you choose gcc to compile 64-bit Perl then you need to add the following option:</source>
          <target state="translated">Если вы выберете gcc для компиляции 64-битного Perl,то необходимо добавить следующую опцию:</target>
        </trans-unit>
        <trans-unit id="043ebe155c68a02fa99782ad455e116e9535a4e8" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;a href=&quot;#chop-VARIABLE&quot;&gt;&lt;code&gt;chop&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875c1fe2de9773e7e9366d0703f2a602deb9c197" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если вы разрежете список, каждый элемент будет разрезан. Возвращается только значение последнего &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03160d33f05c1b78628995f8692e16c5933ebe05" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если вы разрежете список, каждый элемент будет разрезан. Возвращается только значение последнего &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="caf1e734b10683713e7d496bb52630f5b34525d0" translate="yes" xml:space="preserve">
          <source>If you compile and run</source>
          <target state="translated">Если вы скомпилируете и запустите</target>
        </trans-unit>
        <trans-unit id="4359b9f0177138527f6b61e374c639bb3caf7642" translate="yes" xml:space="preserve">
          <source>If you completely hide the short forms of the Perl public API, add -DPERL_NO_SHORT_NAMES to the compilation flags. This means that for example instead of writing</source>
          <target state="translated">Если вы полностью скрываете короткие формы публичного Perl API,добавьте -DPERL_NO_SHORT_NAMES к флагам компиляции.Это означает,что,например,вместо того,чтобы писать</target>
        </trans-unit>
        <trans-unit id="2026c5f1b05bc468fd9f9b21ddfe279181855850" translate="yes" xml:space="preserve">
          <source>If you constrain the portion of &lt;code&gt;pv&lt;/code&gt; that is looked at by this function (by passing a non-NULL &lt;code&gt;endptr&lt;/code&gt;), and if the intial bytes of that portion form a valid value, it will return TRUE, setting &lt;code&gt;*endptr&lt;/code&gt; to the byte following the final digit of the value. But if there is no constraint at what's looked at, all of &lt;code&gt;pv&lt;/code&gt; must be valid in order for TRUE to be returned. &lt;code&gt;*endptr&lt;/code&gt; is unchanged from its value on input if FALSE is returned;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e117fe20aeb505e6fb3bd26d20ee9983d45c623" translate="yes" xml:space="preserve">
          <source>If you consult &lt;code&gt;perldoc -f &lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you will see that &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; will behave differently when given a bareword or a string.</source>
          <target state="translated">Если вы проконсультируетесь с &lt;code&gt;perldoc -f &lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , вы увидите, что &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; будет вести себя по-разному при задании простого слова или строки.</target>
        </trans-unit>
        <trans-unit id="675f3fe6a1b5c4eacc7781347f628b31f87a96c1" translate="yes" xml:space="preserve">
          <source>If you consult &lt;code&gt;perldoc -f require&lt;/code&gt; you will see that &lt;code&gt;require&lt;/code&gt; will behave differently when given a bareword or a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e933e27b4b6affb17bacc2be8545945df23e47f1" translate="yes" xml:space="preserve">
          <source>If you create interpreters in one thread and then proceed to call them in another, you need to make sure perl's own Thread Local Storage (TLS) slot is initialized correctly in each of those threads.</source>
          <target state="translated">Если вы создаете интерпретаторы в одном потоке,а затем продолжаете вызывать их в другом,вам необходимо убедиться,что собственный слот Perl Thread Local Storage (TLS)корректно инициализирован в каждом из этих потоков.</target>
        </trans-unit>
        <trans-unit id="4e50c2bd9e835a3a7f1961b7856f6dac61424cbe" translate="yes" xml:space="preserve">
          <source>If you decide to ignore this advice and use the GNU versions anyway, then be sure that they are relatively recent. Versions newer than 2.7 are apparently new enough. Older versions may have trouble with dynamic loading.</source>
          <target state="translated">Если вы все равно решите проигнорировать этот совет и воспользоваться версиями GNU,то убедитесь,что они относительно недавние.Версии,более новые,чем 2.7,по-видимому,достаточно новые.Старые версии могут иметь проблемы с динамической загрузкой.</target>
        </trans-unit>
        <trans-unit id="ff55c7f7dfadd85537843d3b167612c0ffcaee31" translate="yes" xml:space="preserve">
          <source>If you decide to use a different version of the zlib library, you need to be aware of the following issues</source>
          <target state="translated">Если вы решили использовать другую версию библиотеки zlib,вы должны быть осведомлены о следующих вопросах</target>
        </trans-unit>
        <trans-unit id="dea32ebc2834b73dcbf2cbd2fdecffa9453ead2d" translate="yes" xml:space="preserve">
          <source>If you decide to use gcc, make sure your installation is recent and complete, and be sure to read the Perl INSTALL file for more gcc-specific details.</source>
          <target state="translated">Если вы решили использовать gcc,убедитесь,что ваша установка завершена,и обязательно прочитайте файл Perl INSTALL для получения более подробной информации о gcc.</target>
        </trans-unit>
        <trans-unit id="275ebe9364d1067d763d9e8ee83a9ef9cef15d89" translate="yes" xml:space="preserve">
          <source>If you decide to use gcc, make sure your installation is recent and complete, and be sure to read the Perl INSTALL file for more gcc-specific details. Please report any hoops you had to jump through to the development team.</source>
          <target state="translated">Если вы решили использовать gcc,убедитесь,что ваша установка завершена,и обязательно прочитайте файл Perl INSTALL для получения более подробной информации о gcc.Пожалуйста,сообщите обо всех обручах,через которые вам пришлось пройти,команде разработчиков.</target>
        </trans-unit>
        <trans-unit id="129ecc12b1557dd3798539452dbf9b9ea8476c0d" translate="yes" xml:space="preserve">
          <source>If you define an &lt;code&gt;AUTOLOAD&lt;/code&gt; in your class, then Perl will call your &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the &lt;code&gt;DESTROY&lt;/code&gt; method. You can prevent this by defining an empty &lt;code&gt;DESTROY&lt;/code&gt; , like we did in the autoloading example. You can also check the value of &lt;code&gt;$AUTOLOAD&lt;/code&gt; and return without doing anything when called to handle &lt;code&gt;DESTROY&lt;/code&gt; .</source>
          <target state="translated">Если вы определите &lt;code&gt;AUTOLOAD&lt;/code&gt; в своем классе, Perl вызовет ваш &lt;code&gt;AUTOLOAD&lt;/code&gt; для обработки метода &lt;code&gt;DESTROY&lt;/code&gt; . Вы можете предотвратить это, указав пустой &lt;code&gt;DESTROY&lt;/code&gt; , как мы сделали в примере с автозагрузкой. Вы также можете проверить значение &lt;code&gt;$AUTOLOAD&lt;/code&gt; и вернуться без каких-либо действий при вызове для обработки &lt;code&gt;DESTROY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="498a8ce676b34793704f21213180e13370975cc0" translate="yes" xml:space="preserve">
          <source>If you define an &lt;code&gt;AUTOLOAD&lt;/code&gt; in your class, then Perl will call your &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the &lt;code&gt;DESTROY&lt;/code&gt; method. You can prevent this by defining an empty &lt;code&gt;DESTROY&lt;/code&gt;, like we did in the autoloading example. You can also check the value of &lt;code&gt;$AUTOLOAD&lt;/code&gt; and return without doing anything when called to handle &lt;code&gt;DESTROY&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94eb8ac68c4fb558c46d1ee64b3833ca570000ed" translate="yes" xml:space="preserve">
          <source>If you define more than one name for the code point, it is indeterminate which one will be returned.</source>
          <target state="translated">Если задать более одного имени для точки кода,то будет неопределено,какое из них будет возвращено.</target>
        </trans-unit>
        <trans-unit id="49322aadfdd4f7ccdbc478f7d31a6ef35c74c780" translate="yes" xml:space="preserve">
          <source>If you desire complete control over SSL connections, the &lt;code&gt;SSL_options&lt;/code&gt; attribute lets you provide a hash reference that will be passed through to &lt;code&gt;IO::Socket::SSL::start_SSL()&lt;/code&gt;, overriding any options set by HTTP::Tiny. For example, to provide your own trusted CA file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b2ed76508ea6501a561cd368f25fd856dfc7e2" translate="yes" xml:space="preserve">
          <source>If you develop any useful expiration managers that you think should be distributed with Memoize, please let me know.</source>
          <target state="translated">Если вы разрабатываете какие-либо полезные менеджеры истечения срока действия,которые,по вашему мнению,должны распространяться с Memoize,пожалуйста,дайте мне знать.</target>
        </trans-unit>
        <trans-unit id="2101fa1f88298b0b195dfaac7732fd2635cea835" translate="yes" xml:space="preserve">
          <source>If you didn't mean to use a Unicode property, escape the &lt;code&gt;\p&lt;/code&gt;, either by &lt;code&gt;\\p&lt;/code&gt; (just the &lt;code&gt;\p&lt;/code&gt;) or by &lt;code&gt;\Q\p&lt;/code&gt; (the rest of the string, or until &lt;code&gt;\E&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf4a8657eebfe97ba9c4e743bd983d09e5edaa6" translate="yes" xml:space="preserve">
          <source>If you didn't use &lt;code&gt;openlog()&lt;/code&gt; before using &lt;code&gt;syslog()&lt;/code&gt; , &lt;code&gt;syslog()&lt;/code&gt; will try to guess the &lt;code&gt;$ident&lt;/code&gt; by extracting the shortest prefix of &lt;code&gt;$format&lt;/code&gt; that ends in a &lt;code&gt;&quot;:&quot;&lt;/code&gt; .</source>
          <target state="translated">Если вы не использовали &lt;code&gt;openlog()&lt;/code&gt; до использования &lt;code&gt;syslog()&lt;/code&gt; , &lt;code&gt;syslog()&lt;/code&gt; попытается угадать &lt;code&gt;$ident&lt;/code&gt; , извлекая самый короткий префикс &lt;code&gt;$format&lt;/code&gt; который заканчивается на &lt;code&gt;&quot;:&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2758eb43b68115ce83395ea254e99fa90136500" translate="yes" xml:space="preserve">
          <source>If you didn't use &lt;code&gt;openlog()&lt;/code&gt; before using &lt;code&gt;syslog()&lt;/code&gt;, &lt;code&gt;syslog()&lt;/code&gt; will try to guess the &lt;code&gt;$ident&lt;/code&gt; by extracting the shortest prefix of &lt;code&gt;$format&lt;/code&gt; that ends in a &lt;code&gt;&quot;:&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ed1961687b0abd10e165d61c48cda9ac3ae785" translate="yes" xml:space="preserve">
          <source>If you discover some glitches, move directories of problematic modules to a different location; if these modules are non-XS modules, you may just ignore them - they are already installed; the remaining, XS, modules you need to install manually one by one.</source>
          <target state="translated">Если вы обнаружите некоторые глюки,переместите каталоги проблемных модулей в другое место;если эти модули не XS,вы можете просто проигнорировать их-они уже установлены;остальные,XS,модули нужно установить вручную по одному.</target>
        </trans-unit>
        <trans-unit id="43d56dedc7192e637755e1fdcd48fbf68cbff70a" translate="yes" xml:space="preserve">
          <source>If you do</source>
          <target state="translated">Если ты это сделаешь</target>
        </trans-unit>
        <trans-unit id="cb8667358646593d3b3e540e94dd3bddc5a68445" translate="yes" xml:space="preserve">
          <source>If you do need to sort non-alphabetically for whatever reasons, you can give a code reference (or a subroutine name) to &lt;code&gt;sort_by&lt;/code&gt;, then the argument will be passed to Perl's &lt;code&gt;sort&lt;/code&gt; built-in function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f303cdfeba4ec1c04b3ea76ad07c019d7ba1217e" translate="yes" xml:space="preserve">
          <source>If you do not do this, then tools you call that also check for a context will notice that the context they grabbed was created at the same stack depth, which will trigger protective measures that warn you and destroy the existing context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ef7e6c621828b29eab79e96b5fb6269cd00a77" translate="yes" xml:space="preserve">
          <source>If you do not enter the shell, shell commands are available both as methods (&lt;code&gt;CPAN::Shell-&amp;gt;install(...)&lt;/code&gt; ) and as functions in the calling package (&lt;code&gt;install(...)&lt;/code&gt; ). Before calling low-level commands, it makes sense to initialize components of CPAN you need, e.g.:</source>
          <target state="translated">Если вы не входите в оболочку, команды оболочки доступны как как методы ( &lt;code&gt;CPAN::Shell-&amp;gt;install(...)&lt;/code&gt; ), так и как функции в вызывающем пакете ( &lt;code&gt;install(...)&lt;/code&gt; ). Перед вызовом низкоуровневых команд имеет смысл инициализировать необходимые вам компоненты CPAN, например:</target>
        </trans-unit>
        <trans-unit id="bc816a9fd08d7a00464780adbf72cc89737d7fde" translate="yes" xml:space="preserve">
          <source>If you do not have</source>
          <target state="translated">Если у вас нет</target>
        </trans-unit>
        <trans-unit id="69ced298dbf1c87fefd1662253cccc2e7a8bde7d" translate="yes" xml:space="preserve">
          <source>If you do not have a copy of the GNU General Public License write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</source>
          <target state="translated">Если у вас нет копии Стандартной общественной лицензии GNU,напишите по адресу:675 Mass Ave,Cambridge,MA 02139,USA.</target>
        </trans-unit>
        <trans-unit id="ca85e836f91816edbc4e15e9107effedf45973f0" translate="yes" xml:space="preserve">
          <source>If you do not have that module, you can do the same thing with &lt;a href=&quot;File::Find&quot;&gt;File::Find&lt;/a&gt; which is part of the standard library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c124bac0783d0b5dcccc34a0dbf3566f426f11" translate="yes" xml:space="preserve">
          <source>If you do not have that module, you can do the same thing with &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt; which is part of the standard library:</source>
          <target state="translated">Если у вас нет этого модуля, вы можете сделать то же самое с &lt;a href=&quot;file/find&quot;&gt;File :: Find,&lt;/a&gt; который является частью стандартной библиотеки:</target>
        </trans-unit>
        <trans-unit id="05c2496743b48fe9b410f73d7328bfcdc228baa8" translate="yes" xml:space="preserve">
          <source>If you do not have the SDK installed you must at least have abc-shell installed or some other suitable sh port. This is required to run external commands and should be available as 'sh' in your path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd07d5a5c26be6eca98f51764342db5783f35fa8" translate="yes" xml:space="preserve">
          <source>If you do not know what shell you have, consult your local helpdesk or the equivalent.</source>
          <target state="translated">Если вы не знаете,какая оболочка у вас есть,обратитесь в местную службу поддержки или эквивалентную службу.</target>
        </trans-unit>
        <trans-unit id="7e4c6cc6957c31110bb18e19744ff8957469df93" translate="yes" xml:space="preserve">
          <source>If you do not override this then the default implementation will attempt to generate facets from the legacy API. This generation is limited only to what the legacy API can provide. It is recommended that you override this method and write out explicit facet data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de6e3279f2bd155e7f8bf6759e637927cce20be" translate="yes" xml:space="preserve">
          <source>If you do not set this flag then it is</source>
          <target state="translated">Если вы не установите этот флаг,то это будет</target>
        </trans-unit>
        <trans-unit id="926a166805dd3b0aef3dd1d472d192955fb1ec52" translate="yes" xml:space="preserve">
          <source>If you do not specify a package name, the variable is created in the current package.</source>
          <target state="translated">Если вы не указываете имя пакета,переменная создается в текущем пакете.</target>
        </trans-unit>
        <trans-unit id="eb887a9c7d54012c86e6e1c5e9df47c38a1fd9a7" translate="yes" xml:space="preserve">
          <source>If you do not want to actually create a full blown version object, but would still like to verify that a given string meets the criteria to be parsed as a version, there are two helper functions that can be employed directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec84ed1a6f6d8da6377929662414a47b27976a2" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6ac2382b8b465b26d1901487c44646a3e50e04" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">Если вы не хотите вызывать метод &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; пакета (например, чтобы предотвратить изменение пространства имен), явно укажите пустой список:</target>
        </trans-unit>
        <trans-unit id="ea10c1ff3a243c28f284c149e22c1d185c65b318" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">Если вы не хотите вызывать метод &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; пакета (например, чтобы предотвратить изменение пространства имен), явно укажите пустой список:</target>
        </trans-unit>
        <trans-unit id="8470234c0d68b289fd8da0f074a387fae1ae490f" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">Если вы не хотите использовать эти значения по умолчанию, их можно переопределить, явно &lt;code&gt;TextFlag&lt;/code&gt; параметры &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , TextFlag , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; и &lt;code&gt;exTime&lt;/code&gt; или установив параметр &lt;code&gt;Minimal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f15a287c32e6f66173e359fbddfbe362d18b693a" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">Если вы не хотите использовать эти значения по умолчанию, их можно переопределить, явно установив параметры &amp;laquo; &lt;code&gt;Name&lt;/code&gt; и &amp;laquo; &lt;code&gt;Time&lt;/code&gt; или установив параметр &amp;laquo; &lt;code&gt;Minimal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de7aec51016dff43e0ecf45d764d0cccf666e711" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;Time&lt;/code&gt;, &lt;code&gt;TextFlag&lt;/code&gt;, &lt;code&gt;ExtAttr&lt;/code&gt;, &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c647e4788bb29e5dcf3d258b1e0dc34c9ef54f62" translate="yes" xml:space="preserve">
          <source>If you do not wish this to happen, you should provide an array reference, where all parts of your command are already separated out. Note however, if there are extra or spurious whitespaces in these parts, the parser or underlying code may not interpret it correctly, and cause an error.</source>
          <target state="translated">Если вы не хотите,чтобы это произошло,вы должны предоставить ссылку на массив,где все части вашей команды уже отделены друг от друга.Однако обратите внимание,что если в этих частях есть лишние или поддельные белые пространства,то парсер или лежащий в его основе код могут неправильно интерпретировать его и привести к ошибке.</target>
        </trans-unit>
        <trans-unit id="459db29c5c8a7302439a70851525c81616dcc865" translate="yes" xml:space="preserve">
          <source>If you do not wish to install the &lt;a href=&quot;Module::Starter&quot;&gt;Module::Starter&lt;/a&gt; package from CPAN,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f09ee5e6b9af0c82c4326addc62e789f8443f5c" translate="yes" xml:space="preserve">
          <source>If you do not wish to install the &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module::Starter&lt;/a&gt; package from CPAN,</source>
          <target state="translated">Если вы не хотите устанавливать пакет &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module :: Starter&lt;/a&gt; из CPAN,</target>
        </trans-unit>
        <trans-unit id="484cd976813c85d85881ff70f66c34600b720c15" translate="yes" xml:space="preserve">
          <source>If you do set &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 0, you may notice an improvement in speed at the risk of not recursing into subdirectories if a filesystem doesn't populate &lt;code&gt;nlink&lt;/code&gt; as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0549310bae0dd74950be604da632c91876f7d8c0" translate="yes" xml:space="preserve">
          <source>If you do set &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 1, you will notice slow-downs.</source>
          <target state="translated">Если вы установите для &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; значение 1, вы заметите замедление.</target>
        </trans-unit>
        <trans-unit id="feef0b7ae2868ad2a4e1f83d30c63fb0d93e6be4" translate="yes" xml:space="preserve">
          <source>If you do this in a binary operator, you will actually change one of the strings that came into the operator, and, while it shouldn't be noticeable by the end user, it can cause problems in deficient code.</source>
          <target state="translated">Если Вы сделаете это в двоичном операторе,то на самом деле Вы измените одну из строк,которая попала в оператор,и,хотя она не должна быть заметна конечному пользователю,это может привести к проблемам в неполноценном коде.</target>
        </trans-unit>
        <trans-unit id="32f0578310d415019b09f619288e373d3b705f8d" translate="yes" xml:space="preserve">
          <source>If you do want this subroutine to be a closure that reflects future changes to the variable that it closes over, add an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите, чтобы эта подпрограмма была закрытием, отражающим будущие изменения переменной, которую она закрывает, добавьте явный &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="38c006c4445fbc760bcc20774ff0c404fc351e3b" translate="yes" xml:space="preserve">
          <source>If you do want this subroutine to be a closure that reflects future changes to the variable that it closes over, add an explicit &lt;code&gt;return&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7553259d39face4afb80ca316b04630713e25671" translate="yes" xml:space="preserve">
          <source>If you do want to work with large integers like under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; , try &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint;&lt;/code&gt; :</source>
          <target state="translated">Если вы хотите работать с большими целыми числами, например, при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; попробуйте &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b1975a786e24a8553b122ca84ecd2c75458bf60c" translate="yes" xml:space="preserve">
          <source>If you do want to work with large integers like under &lt;code&gt;use integer;&lt;/code&gt;, try &lt;code&gt;use bigint;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226407ccd685c51b95b1d8b7151f227bb1d0575c" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to be included in the AUTHORS file, just let us know. Otherwise we will take your submission of a patch as permission to credit you in the AUTHORS file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a338314884729930813df6e4dec44b70118fce2d" translate="yes" xml:space="preserve">
          <source>If you don't ask for any feature, you get the list of features that the user requested you to be nice to. This has the nice side effect that if you don't respect anything in particular then you can just ask for it and use it like a boolean.</source>
          <target state="translated">Если вы не попросите ни об одной функции,вы получите список функций,которые пользователь просил вас использовать вежливо.Это имеет приятный побочный эффект,что если вы не уважаете ничего конкретного,то вы можете просто попросить об этом и использовать его как булевую.</target>
        </trans-unit>
        <trans-unit id="d5b6d156d7cf6f2a797778536a48c223724f9360" translate="yes" xml:space="preserve">
          <source>If you don't care about the order of the elements, you could just create the hash then extract the keys. It's not important how you create that hash: just that you use &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; to get the unique elements.</source>
          <target state="translated">Если вас не волнует порядок элементов, вы можете просто создать хеш, а затем извлечь ключи. Неважно, как вы создаете этот хеш: просто вы используете &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; для получения уникальных элементов.</target>
        </trans-unit>
        <trans-unit id="6ab466d2383fda10b330c50a2b963d3911043a02" translate="yes" xml:space="preserve">
          <source>If you don't care about the order of the elements, you could just create the hash then extract the keys. It's not important how you create that hash: just that you use &lt;code&gt;keys&lt;/code&gt; to get the unique elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21625178e6b6545fac5abe6f5027d91ef293d91" translate="yes" xml:space="preserve">
          <source>If you don't care about where digits and underscore sort to, you can do something like this</source>
          <target state="translated">Если тебя не волнует,куда деваются цифры и подчёркивания,ты можешь сделать что-то вроде этого.</target>
        </trans-unit>
        <trans-unit id="f92e493c5048826b06ef70fc4669cac080dfe915" translate="yes" xml:space="preserve">
          <source>If you don't care that one hash overwrites keys and values from the other, you could just use a hash slice to add one hash to another. In this case, values from &lt;code&gt;%hash2&lt;/code&gt; replace values from &lt;code&gt;%hash1&lt;/code&gt; when they have keys in common:</source>
          <target state="translated">Если вам все равно, что один хэш перезаписывает ключи и значения другого, вы можете просто использовать хеш-срез, чтобы добавить один хеш к другому. В этом случае значения из &lt;code&gt;%hash2&lt;/code&gt; заменяют значения из &lt;code&gt;%hash1&lt;/code&gt; если у них есть общие ключи:</target>
        </trans-unit>
        <trans-unit id="c43d001ee345c63043409156142b64f915867634" translate="yes" xml:space="preserve">
          <source>If you don't get a paragraph or two of expanded discussion, it might not be perl's message.</source>
          <target state="translated">Если вы не получите параграф или два расширенных обсуждения,это может быть не сообщение perl.</target>
        </trans-unit>
        <trans-unit id="7a12cb113cb2e2457200764dfd73d419fb8973d7" translate="yes" xml:space="preserve">
          <source>If you don't have File::Stream, you have to do a little more work.</source>
          <target state="translated">Если у вас нет File::Stream,вы должны сделать немного больше работы.</target>
        </trans-unit>
        <trans-unit id="ea4a8fbdbdee9b250414a6cc40a6c3e590cef92d" translate="yes" xml:space="preserve">
          <source>If you don't have data written with specific configuration of perl described above, then you do not and should not do anything. Don't set the flag - not only will Storable on an identically configured perl refuse to load them, but Storable a differently configured perl will load them believing them to be correct for it, and then may well fail or crash part way through reading them.</source>
          <target state="translated">Если у вас нет данных,написанных с определенной конфигурацией perl,описанной выше,то вы ничего не делаете и не должны делать.Не устанавливайте флаг-Storable на одинаково сконфигурированном perl не только откажется их загружать,но и загрузит Storable на другом perl,полагая,что они корректны,и тогда вполне может произойти сбой или падение отчасти из-за чтения.</target>
        </trans-unit>
        <trans-unit id="670ababa1b4eae15ad2ad8b23b062bc17283021f" translate="yes" xml:space="preserve">
          <source>If you don't have the safe version of set-id scripts, all is not lost. Sometimes this kernel &quot;feature&quot; can be disabled, so that the kernel either doesn't run set-id scripts with the set-id or doesn't run them at all. Either way avoids the exploitability of the race condition, but doesn't help in actually running scripts set-id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34e9607e58d64a63d5aabb3955bab5ec740de09" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; to trap the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36289d77701a121889713d6277f544f12a871bb4" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; to trap the error.</source>
          <target state="translated">Если у вас нет доступа на запись в файл DBM, вы можете только читать хеш-переменные, но не устанавливать их. Если вы хотите проверить, можете ли вы писать, либо используйте файловые тесты, либо попробуйте установить фиктивную запись хэша внутри &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , чтобы перехватить ошибку.</target>
        </trans-unit>
        <trans-unit id="bdbbd37031df2f33535ed6549b499d32ea9aa9e5" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; to trap the error.</source>
          <target state="translated">Если у вас нет доступа на запись в файл DBM, вы можете только читать хеш-переменные, но не устанавливать их. Если вы хотите проверить, можете ли вы писать, либо используйте файловые тесты, либо попробуйте установить фиктивную запись хэша внутри &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , чтобы перехватить ошибку.</target>
        </trans-unit>
        <trans-unit id="8f4b767528b9f98c2858aad05fc8520eae2c1d33" translate="yes" xml:space="preserve">
          <source>If you don't import any of these functions, assume a &lt;code&gt;&amp;amp;I18N::LangTags::&lt;/code&gt; in front of all the function names in the following examples.</source>
          <target state="translated">Если вы не импортируете ни одну из этих функций, предположите, что &lt;code&gt;&amp;amp;I18N::LangTags::&lt;/code&gt; перед всеми именами функций в следующих примерах.</target>
        </trans-unit>
        <trans-unit id="107952179f7076da25aad77d14c209ced7df48df" translate="yes" xml:space="preserve">
          <source>If you don't know how many tests you're going to run, you can issue the plan when you're done running tests.</source>
          <target state="translated">Если вы не знаете,сколько тестов вы собираетесь запустить,вы можете выпустить план,когда закончите выполнять тесты.</target>
        </trans-unit>
        <trans-unit id="739739cb456280bdf258e73ad5d6021f89fcc54e" translate="yes" xml:space="preserve">
          <source>If you don't know if a string contains YAML or JSON, this method will use &lt;a href=&quot;Parse::CPAN::Meta&quot;&gt;Parse::CPAN::Meta&lt;/a&gt; to guess. In other respects it is identical to &lt;code&gt;load_file()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="209c65929fc8bcea028a0c96cf1f684c89334602" translate="yes" xml:space="preserve">
          <source>If you don't know what license to use, dual licensing under the GPL and Artistic licenses (the same as Perl itself) is a good idea. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;.</source>
          <target state="translated">Если вы не знаете, какую лицензию использовать, хорошей идеей будет двойное лицензирование под GPL и Artistic (как и сам Perl). Смотрите &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt; и &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed23e5a70f4d9c445aa4d9a13f1bd7f582002fa9" translate="yes" xml:space="preserve">
          <source>If you don't know what license to use, dual licensing under the GPL and Artistic licenses (the same as Perl itself) is a good idea. See &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlgpl&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlartistic&quot;&gt;perlartistic&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0afa056a783c1ff17e6396cee6d067cb1e22c33a" translate="yes" xml:space="preserve">
          <source>If you don't know whether a string contains YAML or JSON data, this method will use some heuristics and guess. If it can't tell, it assumes YAML.</source>
          <target state="translated">Если вы не знаете,содержит ли строка данные YAML или JSON,то этот метод использует некоторую эвристику и угадывает.Если он не может сказать,он предполагает YAML.</target>
        </trans-unit>
        <trans-unit id="d34593d2a30bd46dc846ad60717c333d071ef181" translate="yes" xml:space="preserve">
          <source>If you don't mind shelling out, the &lt;code&gt;wc&lt;/code&gt; command is usually the fastest, even with the extra interprocess overhead. Ensure that you have an untainted filename though:</source>
          <target state="translated">Если вы не возражаете против обстрела, команда &lt;code&gt;wc&lt;/code&gt; обычно самая быстрая, даже с дополнительными накладными расходами между процессами. Убедитесь, что у вас есть незапятнанное имя файла:</target>
        </trans-unit>
        <trans-unit id="ab42639abd5abd9367c12d1d0ad1d1482fb0d4b6" translate="yes" xml:space="preserve">
          <source>If you don't need the existing content of the SV, you can avoid some copying with:</source>
          <target state="translated">Если вам не нужно существующее содержимое SV,вы можете избежать некоторого копирования:</target>
        </trans-unit>
        <trans-unit id="bd9e10a2452b68c075fcb32cabd703d0209267ed" translate="yes" xml:space="preserve">
          <source>If you don't need to know the name of the file, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in place of the file name. In Perl 5.8 or later, the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function creates an anonymous temporary file:</source>
          <target state="translated">Если вам не нужно знать имя файла, вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; с &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; вместо имени файла. В Perl 5.8 или новее функция &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; создает анонимный временный файл:</target>
        </trans-unit>
        <trans-unit id="22928fef3e84c8263a53f0cfc23f1b5d448491ff" translate="yes" xml:space="preserve">
          <source>If you don't need to know the name of the file, you can use &lt;code&gt;open()&lt;/code&gt; with &lt;code&gt;undef&lt;/code&gt; in place of the file name. In Perl 5.8 or later, the &lt;code&gt;open()&lt;/code&gt; function creates an anonymous temporary file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b260604ab4c441d85ae092e22c063810eb4d30c0" translate="yes" xml:space="preserve">
          <source>If you don't provide an exact inverse transformation, you will find that code like this will not behave as you expect.</source>
          <target state="translated">Если вы не предоставите точное обратное преобразование,вы обнаружите,что подобный код будет вести себя не так,как вы ожидаете.</target>
        </trans-unit>
        <trans-unit id="da9f240e2e4669201b3520ed7f3f5a0edd014292" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">Если вы действительно не хотите выполнять первый аргумент, но хотите солгать программе, которую вы выполняете, о ее собственном имени, вы можете указать программу, которую вы действительно хотите запустить, как &amp;laquo;косвенный объект&amp;raquo; (без запятой) в перед СПИСОК, как в &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (Это всегда приводит к интерпретации списка LIST как многозначного списка, даже если в списке есть только один скаляр.) Пример:</target>
        </trans-unit>
        <trans-unit id="90475a6e4998e8131a7d71a411d5204a133b0a81" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">Если вы действительно не хотите выполнять первый аргумент, но хотите солгать программе, которую вы выполняете, о ее собственном имени, вы можете указать программу, которую вы действительно хотите запустить, как &amp;laquo;косвенный объект&amp;raquo; (без запятой) в перед СПИСОК, как в &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (Это всегда приводит к интерпретации списка LIST как многозначного списка, даже если в списке есть только один скаляр.) Пример:</target>
        </trans-unit>
        <trans-unit id="418ff649fbe756afaa4bfbbd2264a36cfbe884b8" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;exec PROGRAM LIST&lt;/code&gt;. (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b9da8187ce4c2f915ec1ca4c659113a1fb93a3" translate="yes" xml:space="preserve">
          <source>If you don't run the full test suite, at least &lt;code&gt;make test_porting&lt;/code&gt;. This will run basic sanity checks. To see which sanity checks, have a look in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d09c87ff03423122d55e0fe04c7fdafafae320f" translate="yes" xml:space="preserve">
          <source>If you don't see an error message, you have the module. (If you do see an error message, it's still possible you have the module, but that it's not in your path, which you can display with &lt;code&gt;perl -e
&quot;print qq(@INC)&quot;&lt;/code&gt; .) For the remainder of this document, we'll assume that you really honestly truly lack an installed module, but have found it on the CPAN.</source>
          <target state="translated">Если вы не видите сообщение об ошибке, у вас есть модуль. (Если вы видите сообщение об ошибке, возможно, у вас есть модуль, но он не находится на вашем пути, который вы можете отобразить с помощью &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt; .) В оставшейся части этого документа, мы предположим, что вам действительно действительно не хватает установленного модуля, но вы нашли его на CPAN.</target>
        </trans-unit>
        <trans-unit id="eb0d75079c24e83da6fecb7132e9b60520bba455" translate="yes" xml:space="preserve">
          <source>If you don't see an error message, you have the module. (If you do see an error message, it's still possible you have the module, but that it's not in your path, which you can display with &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt;.) For the remainder of this document, we'll assume that you really honestly truly lack an installed module, but have found it on the CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22a71969f2b2e317963f5563c127a63079459334" translate="yes" xml:space="preserve">
          <source>If you don't specify a &lt;code&gt;dw_size&lt;/code&gt; , it defaults to the entire memory limit.</source>
          <target state="translated">Если вы не укажете &lt;code&gt;dw_size&lt;/code&gt; , по умолчанию будет использоваться весь лимит памяти.</target>
        </trans-unit>
        <trans-unit id="a1d09f5237198c8d539c87c541eb6e6b72285d75" translate="yes" xml:space="preserve">
          <source>If you don't specify a &lt;code&gt;dw_size&lt;/code&gt;, it defaults to the entire memory limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680f0cec0c96fdd6b5789593128bcc203ccf616d" translate="yes" xml:space="preserve">
          <source>If you don't specify a plan, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; expects to see &lt;code&gt;done_testing()&lt;/code&gt; before your program exits. It will warn you if you forget it. You can give &lt;code&gt;done_testing()&lt;/code&gt; an optional number of tests you expected to run, and if the number ran differs, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; will give you another kind of warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d559d6056536d78595c17d437dfe78484f93f47a" translate="yes" xml:space="preserve">
          <source>If you don't understand this question, just press ENTER.</source>
          <target state="translated">Если вы не понимаете этого вопроса,просто нажмите ENTER.</target>
        </trans-unit>
        <trans-unit id="e1a9da1b5f8c61c5b3d264532c0386f7656b5414" translate="yes" xml:space="preserve">
          <source>If you don't want &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; to change your original variable you can use the non-destructive substitute modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;. This changes the behavior so that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; returns the final substituted string (instead of the number of substitutions):</source>
          <target state="translated">Если вы не хотите, чтобы &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; изменяла исходную переменную, вы можете использовать модификатор неразрушающей замены, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; . Это изменяет поведение так, что &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; возвращает окончательную заменяемую строку (вместо количества замен):</target>
        </trans-unit>
        <trans-unit id="b16ffc6d1bac1378ef5d03cf556d21c8b3e4f33f" translate="yes" xml:space="preserve">
          <source>If you don't want &lt;code&gt;s///&lt;/code&gt; to change your original variable you can use the non-destructive substitute modifier, &lt;code&gt;s///r&lt;/code&gt;. This changes the behavior so that &lt;code&gt;s///r&lt;/code&gt; returns the final substituted string (instead of the number of substitutions):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b63f96d379f7a46f61c3872f0a57972ef07d6947" translate="yes" xml:space="preserve">
          <source>If you don't want any output should all modules be up to date, parse the output of above command for the regular expression &lt;code&gt;/modules are up to date/&lt;/code&gt; and decide to mail the output only if it doesn't match.</source>
          <target state="translated">Если вам не нужен какой-либо вывод, если все модули обновлены, проанализируйте вывод вышеуказанной команды на предмет регулярного выражения &lt;code&gt;/modules are up to date/&lt;/code&gt; и решите отправить вывод по почте, только если он не совпадает.</target>
        </trans-unit>
        <trans-unit id="717adb67f10193acb40c16a22305c4dc8ba0e791" translate="yes" xml:space="preserve">
          <source>If you don't want to create a new hash, you can still use this looping technique; just change the &lt;code&gt;%new_hash&lt;/code&gt; to &lt;code&gt;%hash1&lt;/code&gt; .</source>
          <target state="translated">Если вы не хотите создавать новый хэш, вы все равно можете использовать эту технику цикла; просто измените &lt;code&gt;%new_hash&lt;/code&gt; на &lt;code&gt;%hash1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="611b9b2078bc455fea7df0c75d337a1c6b770290" translate="yes" xml:space="preserve">
          <source>If you don't want to create a new hash, you can still use this looping technique; just change the &lt;code&gt;%new_hash&lt;/code&gt; to &lt;code&gt;%hash1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5861b9dcca59001a7ac94c68a3d243558acaf640" translate="yes" xml:space="preserve">
          <source>If you don't want to install the compiled Perl in AIX into /QOpenSys (for packaging it before copying it to PASE), you can use a Configure parameter: -Dinstallprefix=/tmp/QOpenSys/perl. This will cause the &quot;make install&quot; to install everything into that directory, while the installed files still think they are (will be) in /QOpenSys/perl.</source>
          <target state="translated">Если вы не хотите устанавливать скомпилированный Perl в AIX в /QOpenSys (для упаковки перед копированием в PASE),вы можете использовать параметр Configure:-Dinstallprefix=/tmp/QOpenSys/perl.Это приведет к тому,что &quot;make install&quot; установит все в этот каталог,в то время как установленные файлы все еще будут думать,что они (будут)в /QOpenSys/perl.</target>
        </trans-unit>
        <trans-unit id="ebe8a5460a3cd2a89a4ca3fccf1f4c546c9647e5" translate="yes" xml:space="preserve">
          <source>If you don't want to keep the defaults for the INSTALL* macros, MakeMaker helps you to minimize the typing needed: the usual relationship between INSTALLPRIVLIB and INSTALLARCHLIB is determined by Configure at perl compilation time. MakeMaker supports the user who sets INSTALLPRIVLIB. If INSTALLPRIVLIB is set, but INSTALLARCHLIB not, then MakeMaker defaults the latter to be the same subdirectory of INSTALLPRIVLIB as Configure decided for the counterparts in %Config, otherwise it defaults to INSTALLPRIVLIB. The same relationship holds for INSTALLSITELIB and INSTALLSITEARCH.</source>
          <target state="translated">Если вы не хотите сохранять настройки по умолчанию для макросов INSTALL*,MakeMaker поможет вам свести к минимуму необходимость набора текста:обычное соотношение между INSTALLPRIVLIB и INSTALLARCHLIB определяется с помощью функции Configure at perl compilation time (Настройка на время компиляции perl).MakeMaker поддерживает пользователя,который устанавливает INSTALLPRIVLIB.Если ИНСТАЛЛПРИВЛИБ установлен,а ИНСТАЛЛАРХЛИБ нет,то по умолчанию MakeMaker устанавливает для последней подкаталог ИНСТАЛПРИВЛИБ тот же подкаталог,что и для остальных подкаталогов в %Config,в противном случае по умолчанию он устанавливает для ИНСТАЛЛПРИВЛИБ.То же самое относится к ИНСТАЛЛЬНОЙ и ИНСТАЛЛИРУЮЩЕЙ директориям.</target>
        </trans-unit>
        <trans-unit id="5f0e1c4bb41a9dbee49413981e4f4536890ac2a6" translate="yes" xml:space="preserve">
          <source>If you don't want to modify your source code, but still have on-the-fly warnings, do this:</source>
          <target state="translated">Если вы не хотите изменять свой исходный код,но все еще имеете предупреждения &quot;на лету&quot;,сделайте это:</target>
        </trans-unit>
        <trans-unit id="883af52a64cbec821f8f52f9cf06fce4facdd6ad" translate="yes" xml:space="preserve">
          <source>If you don't want to use the objects, you may import the &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method into your namespace as a regular function called &lt;code&gt;stat_cando&lt;/code&gt; . This takes an arrayref containing the return values of &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; as its first argument, and interprets it for you.</source>
          <target state="translated">Если вы не хотите использовать объекты, вы можете импортировать метод &lt;code&gt;-&amp;gt;cando&lt;/code&gt; в свое пространство имен как обычную функцию &lt;code&gt;stat_cando&lt;/code&gt; . Он принимает в качестве первого аргумента ссылку на массив, содержащую возвращаемые значения &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; , и интерпретирует его за вас.</target>
        </trans-unit>
        <trans-unit id="75651ef23090da325a0156abcf83a5415a24e8bd" translate="yes" xml:space="preserve">
          <source>If you don't want to use the objects, you may import the &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method into your namespace as a regular function called &lt;code&gt;stat_cando&lt;/code&gt;. This takes an arrayref containing the return values of &lt;code&gt;stat&lt;/code&gt; or &lt;code&gt;lstat&lt;/code&gt; as its first argument, and interprets it for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca8817e625d3ffbecabec4b725646c93f6f8e36" translate="yes" xml:space="preserve">
          <source>If you don't wish to do this, set this variable to &lt;code&gt;false&lt;/code&gt; . Understand then that version comparisons are not possible, and Module::Load::Conditional can not tell you what module version you have installed. This may be desirable from a security or performance point of view. Note that &lt;code&gt;$FIND_VERSION&lt;/code&gt; code runs safely under &lt;code&gt;taint mode&lt;/code&gt; .</source>
          <target state="translated">Если вы не хотите этого делать, установите для этой переменной значение &lt;code&gt;false&lt;/code&gt; . Тогда поймите, что сравнение версий невозможно, и Module :: Load :: Conditional не может сказать вам, какую версию модуля вы установили. Это может быть желательно с точки зрения безопасности или производительности. Обратите внимание, что код &lt;code&gt;$FIND_VERSION&lt;/code&gt; безопасно работает в &lt;code&gt;taint mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de94190185ca2f3465ff49971ba654614381737e" translate="yes" xml:space="preserve">
          <source>If you don't wish to do this, set this variable to &lt;code&gt;false&lt;/code&gt;. Understand then that version comparisons are not possible, and Module::Load::Conditional can not tell you what module version you have installed. This may be desirable from a security or performance point of view. Note that &lt;code&gt;$FIND_VERSION&lt;/code&gt; code runs safely under &lt;code&gt;taint mode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1341f2f78549b1827b1d11fb4b0cc0463ec09d6c" translate="yes" xml:space="preserve">
          <source>If you don't, you may experience strange build errors.</source>
          <target state="translated">Если вы этого не сделаете,то можете столкнуться со странными ошибками при сборке.</target>
        </trans-unit>
        <trans-unit id="dae8c74471266a8218d010f2ece1eeec7e339df7" translate="yes" xml:space="preserve">
          <source>If you edit</source>
          <target state="translated">Если вы редактируете</target>
        </trans-unit>
        <trans-unit id="2fb01cc36906ab2ae202731906c27291970214ff" translate="yes" xml:space="preserve">
          <source>If you either have Perl 5.8.0 or later installed, or if you have Scalar-List-Utils 1.03 or later installed, you can say:</source>
          <target state="translated">Если у вас установлен Perl 5.8.0 или более поздняя версия,или если у вас установлен Scalar-List-Utils 1.03 или более поздняя версия,то вы можете сказать,что у вас установлен Perl 5.8.0 или более поздняя версия:</target>
        </trans-unit>
        <trans-unit id="09872666932a845e43c465fbd124a59438a49096" translate="yes" xml:space="preserve">
          <source>If you evaluate a hash in scalar context, it returns a false value if the hash is empty. If there are any key/value pairs, it returns a true value. A more precise definition is version dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b892a658ce0764f4b064036e5d8f58bd78f5e370" translate="yes" xml:space="preserve">
          <source>If you evaluate a hash in scalar context, it returns false if the hash is empty. If there are any key/value pairs, it returns true; more precisely, the value returned is a string consisting of the number of used buckets and the number of allocated buckets, separated by a slash. This is pretty much useful only to find out whether Perl's internal hashing algorithm is performing poorly on your data set. For example, you stick 10,000 things in a hash, but evaluating %HASH in scalar context reveals &lt;code&gt;&quot;1/16&quot;&lt;/code&gt; , which means only one out of sixteen buckets has been touched, and presumably contains all 10,000 of your items. This isn't supposed to happen. If a tied hash is evaluated in scalar context, the &lt;code&gt;SCALAR&lt;/code&gt; method is called (with a fallback to &lt;code&gt;FIRSTKEY&lt;/code&gt; ).</source>
          <target state="translated">Если вы оцениваете хэш в скалярном контексте, он возвращает false, если хеш пуст. Если есть какие-либо пары ключ / значение, он возвращает true; точнее, возвращаемое значение представляет собой строку, состоящую из количества использованных сегментов и количества выделенных сегментов, разделенных косой чертой. Это в значительной степени полезно только для того, чтобы выяснить, плохо ли работает внутренний алгоритм хеширования Perl с вашим набором данных. Например, вы вставляете 10 000 вещей в хэш, но оценка% HASH в скалярном контексте показывает &lt;code&gt;&quot;1/16&quot;&lt;/code&gt; , что означает, что затронута только одна из шестнадцати корзин, и предположительно содержит все 10 000 ваших элементов. Этого не должно быть. Если связанный хеш оценивается в скалярном контексте, &lt;code&gt;SCALAR&lt;/code&gt; метод SCALAR (с &lt;code&gt;FIRSTKEY&lt;/code&gt; к FIRSTKEY ).</target>
        </trans-unit>
        <trans-unit id="8b7212a78497ddedc16438e486691b2144fe7186" translate="yes" xml:space="preserve">
          <source>If you evaluate an array in scalar context, it returns the length of the array. (Note that this is not true of lists, which return the last value, like the C comma operator, nor of built-in functions, which return whatever they feel like returning.) The following is always true:</source>
          <target state="translated">Если вы оцениваете массив в скалярном контексте,то он возвращает длину массива.(Обратите внимание,что это не относится ни к спискам,которые возвращают последнее значение,как оператор C запятая,ни к встроенным функциям,которые возвращают все,что они хотят вернуть).Следующее всегда верно:</target>
        </trans-unit>
        <trans-unit id="ae75f4b9e5f451131a1e22cec2a555eb5370ed40" translate="yes" xml:space="preserve">
          <source>If you ever see a string that looks like this, you'll know you printed out a reference by mistake.</source>
          <target state="translated">Если вы когда-нибудь увидите строку,которая выглядит так,вы будете знать,что распечатали ссылку по ошибке.</target>
        </trans-unit>
        <trans-unit id="d2eae54bf1fbe9ae68c160098f500a78269b550c" translate="yes" xml:space="preserve">
          <source>If you execute the &lt;code&gt;T&lt;/code&gt; command from inside an active &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, the backtrace will contain both a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; frame and an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; frame.</source>
          <target state="translated">Если вы выполните команду &lt;code&gt;T&lt;/code&gt; из активного оператора &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , трассировка будет содержать как &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; кадр, так и кадр &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="091b3761ddd88c9d0dd9f58cc16fae998cfc428e" translate="yes" xml:space="preserve">
          <source>If you execute the &lt;code&gt;T&lt;/code&gt; command from inside an active &lt;code&gt;use&lt;/code&gt; statement, the backtrace will contain both a &lt;code&gt;require&lt;/code&gt; frame and an &lt;code&gt;eval&lt;/code&gt; frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5fd5107f38bc928d4af20adedacdcf1cb44e019" translate="yes" xml:space="preserve">
          <source>If you expect characters to get to your device when you &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; them, you'll want to autoflush that filehandle. You can use &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;$|&lt;/code&gt; variable to control autoflushing (see</source>
          <target state="translated">Если вы ожидаете, что символы попадут на ваше устройство, когда вы их &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; , вам нужно будет автоматически очистить этот дескриптор файла. Вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;$|&lt;/code&gt; переменная для управления автоматической промывкой (см.</target>
        </trans-unit>
        <trans-unit id="13366f7fd030f27f570c375099dc54189f595b15" translate="yes" xml:space="preserve">
          <source>If you expect characters to get to your device when you &lt;code&gt;print()&lt;/code&gt; them, you'll want to autoflush that filehandle. You can use &lt;code&gt;select()&lt;/code&gt; and the &lt;code&gt;$|&lt;/code&gt; variable to control autoflushing (see &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&quot;$|&quot; in perlvar&lt;/a&gt; and &lt;a href=&quot;perlfunc#select&quot;&gt;&quot;select&quot; in perlfunc&lt;/a&gt;, or &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt;, &quot;How do I flush/unbuffer an output filehandle? Why must I do this?&quot;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b65a4bc3927cbd6d7618d76eb545351eb5d8a945" translate="yes" xml:space="preserve">
          <source>If you expect to use both read and write operations on the device, you'll have to open it for update (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for details). You may wish to open it without running the risk of blocking by using &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module (part of the standard perl distribution). See &lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt; for more on this approach.</source>
          <target state="translated">Если вы планируете использовать на устройстве операции чтения и записи, вам придется открыть его для обновления ( подробности см. В разделе &amp;laquo; &lt;a href=&quot;functions/open&quot;&gt;Открыть&amp;raquo;&lt;/a&gt; ). Вы можете открыть его без риска блокировки, используя &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; из модуля &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; (часть стандартного дистрибутива perl). См. &lt;a href=&quot;functions/sysopen&quot;&gt;Sysopen,&lt;/a&gt; чтобы узнать больше об этом подходе.</target>
        </trans-unit>
        <trans-unit id="0c9408c9e8ecf3bf3ccb1ff9f6037ecd31cab34f" translate="yes" xml:space="preserve">
          <source>If you expect to use both read and write operations on the device, you'll have to open it for update (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; for details). You may wish to open it without running the risk of blocking by using &lt;code&gt;sysopen()&lt;/code&gt; and &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module (part of the standard perl distribution). See &lt;a href=&quot;perlfunc#sysopen&quot;&gt;&quot;sysopen&quot; in perlfunc&lt;/a&gt; for more on this approach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="086943bc39b9078514791bccbde5ea2eddf63045" translate="yes" xml:space="preserve">
          <source>If you fail more than 254 tests, it will be reported as 254.</source>
          <target state="translated">Если вы провалите более 254 тестов,это будет сообщено как 254.</target>
        </trans-unit>
        <trans-unit id="cba05a1f1e542bc35030ada7de3e6bf8ced79b98" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt; . Note that you will then need &lt;code&gt;IO::String&lt;/code&gt; installed to support writing stringified archives.</source>
          <target state="translated">Если вы сильно хотите его отключить, установите для этой переменной значение &lt;code&gt;false&lt;/code&gt; . Обратите внимание, что вам потребуется установить &lt;code&gt;IO::String&lt;/code&gt; для поддержки записи строковых архивов.</target>
        </trans-unit>
        <trans-unit id="0eb03812b9a06455d8a297e6d6e18c05b28becbc" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt; . Note that you will then need &lt;code&gt;perlio&lt;/code&gt; support from your perl to be able to write stringified archives.</source>
          <target state="translated">Если вы сильно хотите его отключить, установите для этой переменной значение &lt;code&gt;false&lt;/code&gt; . Обратите внимание, что тогда вам понадобится поддержка &lt;code&gt;perlio&lt;/code&gt; из вашего Perl, чтобы иметь возможность писать строковые архивы.</target>
        </trans-unit>
        <trans-unit id="3a8a7ec77511b20c4509af066f4a3c986692847a" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt;. Note that you will then need &lt;code&gt;IO::String&lt;/code&gt; installed to support writing stringified archives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdfe08a0cfcd839078102e8b91b9b69bb63aa64b" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt;. Note that you will then need &lt;code&gt;perlio&lt;/code&gt; support from your perl to be able to write stringified archives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b50f7e3c982f4c5e423c530952e3d4ee9e5c5f1" translate="yes" xml:space="preserve">
          <source>If you feel the urge to write Perl modules, &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; will give you good advice.</source>
          <target state="translated">Если вы чувствуете &lt;a href=&quot;perlnewmod&quot;&gt;потребность&lt;/a&gt; писать модули Perl, perlnewmod даст вам хороший совет.</target>
        </trans-unit>
        <trans-unit id="5e8118a36fba749a624194d24477115572a55b8e" translate="yes" xml:space="preserve">
          <source>If you feel you need to use one of these functions, first send email to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;perl5-porters@perl.org&lt;/a&gt;. It may be that there is a good reason for the function not being documented, and it should be removed from this list; or it may just be that no one has gotten around to documenting it. In the latter case, you will be asked to submit a patch to document the function. Once your patch is accepted, it will indicate that the interface is stable (unless it is explicitly marked otherwise) and usable by you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ab4e553b43f57ec6c364e3642fd9276b76ed300" translate="yes" xml:space="preserve">
          <source>If you fill comfortable with</source>
          <target state="translated">Если вы заполните удобный для вас</target>
        </trans-unit>
        <trans-unit id="d37bfff208b4893c857f8a0e5567752243d86aa9" translate="yes" xml:space="preserve">
          <source>If you find any bugs, &lt;code&gt;Devel::PPPort&lt;/code&gt; doesn't seem to build on your system, or any of its tests fail, please file an issue here: &lt;a href=&quot;https://github.com/mhx/Devel-PPPort/issues/&quot;&gt;https://github.com/mhx/Devel-PPPort/issues/&lt;/a&gt;</source>
          <target state="translated">Если вы обнаружите какие-либо ошибки, &lt;code&gt;Devel::PPPort&lt;/code&gt; , похоже, не работает в вашей системе, или какой-либо из его тестов завершился неудачно, сообщите о проблеме здесь: &lt;a href=&quot;https://github.com/mhx/Devel-PPPort/issues/&quot;&gt;https://github.com/mhx/Devel-PPPort/issues/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55c31040a6a87b03d0eac44bd1c63f05031e2f01" translate="yes" xml:space="preserve">
          <source>If you find any bugs, &lt;code&gt;Devel::PPPort&lt;/code&gt; doesn't seem to build on your system, or any of its tests fail, please send a bug report to &lt;a href=&quot;https://github.com/Dual-Life/Devel-PPPort/issues/new&quot;&gt;https://github.com/Dual-Life/Devel-PPPort/issues/new&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f336ce8c57722e9cc0dd1c79931ced850c7378d" translate="yes" xml:space="preserve">
          <source>If you find any other limitations or bugs then let me know.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6e534aca61d370cf38f89adc29a8e3c3accf6a" translate="yes" xml:space="preserve">
          <source>If you find bugs in perl, you can report them to &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ef4696f943b05c3aef9d5f207bfe62cada2927" translate="yes" xml:space="preserve">
          <source>If you find bugs in perl, you can run &lt;code&gt;perlbug&lt;/code&gt; to create a bug report (you may have to send it manually if &lt;code&gt;perlbug&lt;/code&gt; cannot find a mailer on your system).</source>
          <target state="translated">Если вы обнаружите ошибки в perl, вы можете запустить &lt;code&gt;perlbug&lt;/code&gt; , чтобы создать отчет об ошибке (вам может потребоваться отправить его вручную, если &lt;code&gt;perlbug&lt;/code&gt; не может найти почтовую программу в вашей системе).</target>
        </trans-unit>
        <trans-unit id="549be5a33ff1eaf5b330339ea140d5f50a8a508b" translate="yes" xml:space="preserve">
          <source>If you find bugs or if it does not work at all on your device, send mail to the address below. Please report the details of your device (processor, ceversion, devicetype (hpc/palm/pocket)) and the date of the downloaded files.</source>
          <target state="translated">Если вы обнаружили ошибку или если она вообще не работает на вашем устройстве,отправьте письмо по адресу,указанному ниже.Пожалуйста,сообщите подробности о вашем устройстве (процессор,eversion,devicetype (hpc/palm/pocket))и дату загрузки файлов.</target>
        </trans-unit>
        <trans-unit id="ce181ab3a1836691a411c40b59cfd6c2a33af266" translate="yes" xml:space="preserve">
          <source>If you find instances of this in the Perl distribution itself, please let us know, so we can try to work around them.</source>
          <target state="translated">Если вы найдете примеры этого в самом дистрибутиве Perl,пожалуйста,сообщите нам об этом,чтобы мы могли попробовать поработать над ними.</target>
        </trans-unit>
        <trans-unit id="a35b038d2558b01a66b6ce215ee08874b540cf15" translate="yes" xml:space="preserve">
          <source>If you find that you do need to update the system Perl, one issue worth keeping in mind is the question of static vs. dynamic libraries. If you upgrade using the default static libperl, you will find that the dynamic libperl supplied by Apple will not be deleted. If both libraries are present when an application that links against libperl is built, ld will link against the dynamic library by default. So, if you need to replace Apple's dynamic libperl with a static libperl, you need to be sure to delete the older dynamic library after you've installed the update.</source>
          <target state="translated">Если вы обнаружили,что вам действительно необходимо обновить систему Perl,то одна из проблем,о которой стоит помнить,это вопрос статических и динамических библиотек.Если вы обновите систему,используя статическую libperl по умолчанию,вы обнаружите,что динамическая libperl,поставляемая Apple,не будет удалена.Если обе библиотеки присутствуют при сборке приложения,линкующего против libperl,то по умолчанию ld будет линковать против динамической библиотеки.Поэтому,если вам нужно заменить динамическую libperl от Apple на статическую libperl,вам нужно убедиться,что старая динамическая библиотека удалена после установки обновления.</target>
        </trans-unit>
        <trans-unit id="8facfef28f917f827b51a8dc9cc5203934df7f46" translate="yes" xml:space="preserve">
          <source>If you find that you need to speed up a specific part of a Perl application (not something you often need) you may want to use C, but you can access this from your Perl code with &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;.</source>
          <target state="translated">Если вы обнаружите, что вам нужно ускорить определенную часть приложения Perl (а это не то, что вам часто нужно), вы можете использовать C, но вы можете получить к нему доступ из своего кода Perl с помощью &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d6f2d3762fd66cb49c45a26180601ab0ecbaf26" translate="yes" xml:space="preserve">
          <source>If you find the Calc module to slow, try to install any of the replacement modules and see if they help you.</source>
          <target state="translated">Если вы обнаружили,что модуль Calc работает медленно,попробуйте установить любой из заменяющих модулей и посмотрите,не помогут ли они вам.</target>
        </trans-unit>
        <trans-unit id="9507dd44f0fdbd974fde8543eaceef56a9bf59da" translate="yes" xml:space="preserve">
          <source>If you find the implementation document unclear or not sufficient, look at the existing PerlIO layer implementations, which include:</source>
          <target state="translated">Если вы обнаружите,что документ о реализации неясен или недостаточен,посмотрите на существующие реализации уровня PerlIO,которые включают в себя:</target>
        </trans-unit>
        <trans-unit id="bb1a29c843961bd016421afc69613b486ab41b5a" translate="yes" xml:space="preserve">
          <source>If you find this module useful, please consider rating it on the CPAN Ratings service at &lt;a href=&quot;http://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie&lt;/a&gt; .</source>
          <target state="translated">Если вы найдете этот модуль полезным, оцените его в службе рейтингов CPAN по адресу &lt;a href=&quot;http://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d0991b7062cd068d03525a35a6b09de37c1af1a" translate="yes" xml:space="preserve">
          <source>If you find this module useful, please consider rating it on the CPAN Ratings service at &lt;a href=&quot;https://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8307a7110288b02faca83e75adb216a84beaca75" translate="yes" xml:space="preserve">
          <source>If you find you need to provide custom functionality (as you would have using &lt;a href=&quot;Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;), you're in luck: &lt;code&gt;TAP::Parser&lt;/code&gt; and friends are designed to be easily plugged-into and/or subclassed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5afed98244534d5e7bd9f07d6f953a138ea4f8e9" translate="yes" xml:space="preserve">
          <source>If you find you need to provide custom functionality (as you would have using &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;), you're in luck: &lt;code&gt;TAP::Parser&lt;/code&gt; and friends are designed to be easily plugged-into and/or subclassed.</source>
          <target state="translated">Если вы обнаружите, что вам нужно предоставить настраиваемые функции (как если бы вы использовали &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test :: Harness :: Straps&lt;/a&gt; ), вам повезло: &lt;code&gt;TAP::Parser&lt;/code&gt; и его друзья разработаны так, чтобы их можно было легко подключить и / или создать подклассы.</target>
        </trans-unit>
        <trans-unit id="e0f3870d3b01febf6f7490ea91b0d476cdafaf0c" translate="yes" xml:space="preserve">
          <source>If you find you really need to use your own iterator factory you can still do so without sub-classing &lt;code&gt;TAP::Parser&lt;/code&gt; by setting &lt;a href=&quot;#iterator_factory_class&quot;&gt;&quot;iterator_factory_class&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eaae25128643ba9a8e9cd9fd035b84dc1c8a6c4" translate="yes" xml:space="preserve">
          <source>If you find you really need to use your own iterator factory you can still do so without sub-classing &lt;code&gt;TAP::Parser&lt;/code&gt; by setting &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt;.</source>
          <target state="translated">Если вы обнаружите, что вам действительно нужно использовать свою собственную фабрику итераторов, вы все равно можете сделать это без подкласса &lt;code&gt;TAP::Parser&lt;/code&gt; , установив &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef253d4b5355af7bdf0e5249c9becef0fb63f08e" translate="yes" xml:space="preserve">
          <source>If you for some reason (such as binary backward compatibility) really need to use perl's malloc, you can rebuild perl from the sources and Configure the build with</source>
          <target state="translated">Если вам по каким-то причинам (например,бинарная обратная совместимость)действительно нужно использовать perl's malloc,вы можете пересобрать perl из исходных текстов и настроить сборку с помощью команды</target>
        </trans-unit>
        <trans-unit id="a38ea3094c2349d48a8464c8b2ede590e7cc8393" translate="yes" xml:space="preserve">
          <source>If you forget &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , high bytes will be misunderstood as separate characters, and nothing will work right.</source>
          <target state="translated">Если вы забудете &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , старшие байты будут неправильно поняты как отдельные символы, и ничего не будет работать правильно.</target>
        </trans-unit>
        <trans-unit id="1c95ef6991d8327e95ef74bf4e7dd1e20f49af62" translate="yes" xml:space="preserve">
          <source>If you forget &lt;code&gt;use utf8&lt;/code&gt;, high bytes will be misunderstood as separate characters, and nothing will work right.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c73cb5a6222b98080e0788ac4c8f896039ff111" translate="yes" xml:space="preserve">
          <source>If you forget to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you'll miss out entirely on the helpful diagnostic message:</source>
          <target state="translated">Если вы забудете &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , вы полностью упустите полезное диагностическое сообщение:</target>
        </trans-unit>
        <trans-unit id="f4036448bea62235f8e0ea98c0684157616bfe9e" translate="yes" xml:space="preserve">
          <source>If you forget to &lt;code&gt;use warnings&lt;/code&gt;, you'll miss out entirely on the helpful diagnostic message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4db242421a858aa14b9bcaa4e5f3862b8a23c5" translate="yes" xml:space="preserve">
          <source>If you get a core dump (or equivalent), you may use a debugger (&lt;b&gt;dbx&lt;/b&gt;, &lt;b&gt;gdb&lt;/b&gt;, etc) to produce a stack trace to include in the bug report.</source>
          <target state="translated">Если вы получили дамп ядра (или эквивалент), вы можете использовать отладчик ( &lt;b&gt;dbx&lt;/b&gt; , &lt;b&gt;gdb&lt;/b&gt; и т. Д.), Чтобы создать трассировку стека для включения в отчет об ошибке.</target>
        </trans-unit>
        <trans-unit id="722060cb13bfb62427a93bad15761822b6a7686d" translate="yes" xml:space="preserve">
          <source>If you get a message like &quot;perl: command not found&quot;, perl is not in your PATH, which might also mean that the location of perl is not where you expect it so you need to adjust your shebang line.</source>
          <target state="translated">Если вы получаете сообщение типа &quot;команда perl:не найдена&quot;,то perl не находится в вашем PATH,что также может означать,что местоположение perl не там,где вы ожидаете,поэтому вам нужно настроить вашу линию shebang.</target>
        </trans-unit>
        <trans-unit id="6bc5836fc16b720e6dc1a4fbf9bbeb14813f0dae" translate="yes" xml:space="preserve">
          <source>If you get an error like</source>
          <target state="translated">Если вы получите такую ошибку,как</target>
        </trans-unit>
        <trans-unit id="e71cc5ed2d43a688912302c22a7a0e3e08b5d7b1" translate="yes" xml:space="preserve">
          <source>If you get an error message</source>
          <target state="translated">Если вы получите сообщение об ошибке</target>
        </trans-unit>
        <trans-unit id="8b6135f8eeab8f4ac6ffe0b88df52abad52ae3b4" translate="yes" xml:space="preserve">
          <source>If you get complaints about so_locations then search in the file hints/irix_6.sh for &quot;lddflags&quot; and do the suggested adjustments. (David Billinghurst &amp;lt;David.Billinghurst@riotinto.com.au&amp;gt;)</source>
          <target state="translated">Если вы получаете жалобы на so_locations, поищите в файле hints / irix_6.sh &quot;lddflags&quot; и внесите предложенные корректировки. (Дэвид Биллингхерст &amp;lt;David.Billinghurst@riotinto.com.au&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="0d74278837310505aa97f12b787c58f0bb90e74c" translate="yes" xml:space="preserve">
          <source>If you get lots of errors of the form</source>
          <target state="translated">Если вы получите много ошибок в форме</target>
        </trans-unit>
        <trans-unit id="0e2cd49639ef6344568879d541e1a269a34ede3d" translate="yes" xml:space="preserve">
          <source>If you get the error</source>
          <target state="translated">Если вы получите ошибку</target>
        </trans-unit>
        <trans-unit id="39b025fcc6f0d1c529cf233b24ac57e017d8f611" translate="yes" xml:space="preserve">
          <source>If you get this message on SunOS or Solaris, and you're using gcc, it's probably the GNU as or GNU ld problem in the previous item &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;&quot;GNU as and GNU ld&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91993b40c91822c3454671d4c8a24b32c3e646ba" translate="yes" xml:space="preserve">
          <source>If you get this message on SunOS or Solaris, and you're using gcc, it's probably the GNU as or GNU ld problem in the previous item &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as and GNU ld&lt;/a&gt;.</source>
          <target state="translated">Если вы получаете это сообщение в SunOS или Solaris и используете gcc, вероятно, это проблема GNU as или GNU ld из предыдущего пункта. &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as и GNU ld&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36f4dbd793640e550ca076d30024d627de795ab8" translate="yes" xml:space="preserve">
          <source>If you get tired of being subject to your platform's native integers, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; pragma neatly sidesteps the issue altogether:</source>
          <target state="translated">Если вы устали подчиняться родным целым числам вашей платформы, прагма &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; аккуратно решит эту проблему:</target>
        </trans-unit>
        <trans-unit id="69ba4fd6db8745c64a8a60725ff36af2b0505794" translate="yes" xml:space="preserve">
          <source>If you get tired of being subject to your platform's native integers, the &lt;code&gt;use bigint&lt;/code&gt; pragma neatly sidesteps the issue altogether:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28e8a38182dc716f4c7bb3a2e2a63a098694e97" translate="yes" xml:space="preserve">
          <source>If you get tired of constantly saying &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $lh-&amp;gt;maketext&lt;/code&gt; , consider making a functional wrapper for it, like so:</source>
          <target state="translated">Если вы устали постоянно &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $lh-&amp;gt;maketext&lt;/code&gt; &lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $ lh-&amp;gt; maketext , подумайте о создании для него функциональной оболочки, например:</target>
        </trans-unit>
        <trans-unit id="f2e5f31a627306a3c5068e17e18a085ffc1169d9" translate="yes" xml:space="preserve">
          <source>If you get tired of constantly saying &lt;code&gt;print $lh-&amp;gt;maketext&lt;/code&gt;, consider making a functional wrapper for it, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="572c0959177d510f33c38a6508a8f796163c8877" translate="yes" xml:space="preserve">
          <source>If you get tired of remembering which element of the return list contains which return value, by-name interfaces are provided in standard modules: &lt;a href=&quot;File::stat&quot;&gt;&lt;code&gt;File::stat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::hostent&quot;&gt;&lt;code&gt;Net::hostent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::netent&quot;&gt;&lt;code&gt;Net::netent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::protoent&quot;&gt;&lt;code&gt;Net::protoent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::servent&quot;&gt;&lt;code&gt;Net::servent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Time::gmtime&quot;&gt;&lt;code&gt;Time::gmtime&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Time::localtime&quot;&gt;&lt;code&gt;Time::localtime&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;User::grent&quot;&gt;&lt;code&gt;User::grent&lt;/code&gt;&lt;/a&gt;. These override the normal built-ins, supplying versions that return objects with the appropriate names for each field. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693c393f75e992e3003bea94747936126a6b0327" translate="yes" xml:space="preserve">
          <source>If you get tired of remembering which element of the return list contains which return value, by-name interfaces are provided in standard modules: &lt;code&gt;File::stat&lt;/code&gt; , &lt;code&gt;Net::hostent&lt;/code&gt; , &lt;code&gt;Net::netent&lt;/code&gt; , &lt;code&gt;Net::protoent&lt;/code&gt; , &lt;code&gt;Net::servent&lt;/code&gt; , &lt;code&gt;Time::gmtime&lt;/code&gt; , &lt;code&gt;Time::localtime&lt;/code&gt; , and &lt;code&gt;User::grent&lt;/code&gt; . These override the normal built-ins, supplying versions that return objects with the appropriate names for each field. For example:</source>
          <target state="translated">Если вы устали вспоминать, какой элемент списка возврата содержит какое возвращаемое значение, интерфейсы по имени предоставляются в стандартных модулях: &lt;code&gt;File::stat&lt;/code&gt; , &lt;code&gt;Net::hostent&lt;/code&gt; , &lt;code&gt;Net::netent&lt;/code&gt; , &lt;code&gt;Net::protoent&lt;/code&gt; , &lt;code&gt;Net::servent&lt;/code&gt; , &lt;code&gt;Time::gmtime&lt;/code&gt; , &lt;code&gt;Time::localtime&lt;/code&gt; и &lt;code&gt;User::grent&lt;/code&gt; . Они отменяют обычные встроенные функции, предоставляя версии, возвращающие объекты с соответствующими именами для каждого поля. Например:</target>
        </trans-unit>
        <trans-unit id="b8e0fc194ad5e5c2cd16a3f242684fe425f3428b" translate="yes" xml:space="preserve">
          <source>If you get used to writing odd things like these:</source>
          <target state="translated">Если ты привыкнешь писать странные вещи вроде этих:</target>
        </trans-unit>
        <trans-unit id="0cd15dd92a142244892a9be7434b98670ff15dc6" translate="yes" xml:space="preserve">
          <source>If you had &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %Foo::Bar::QUUX&lt;/code&gt; to check whether such a package variable exists then that's never really been reliable, and isn't a good way to enquire about the features of a package, or whether it's loaded, etc.</source>
          <target state="translated">Если вы &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %Foo::Bar::QUUX&lt;/code&gt; чтобы проверить, существует ли такая переменная пакета, тогда это никогда не было действительно надежным и не было хорошим способом узнать о функциях пакета, о том, загружен ли он и т. Д.</target>
        </trans-unit>
        <trans-unit id="3a8d785689c76bcc85c3a87585c7936ee4bbbc6c" translate="yes" xml:space="preserve">
          <source>If you had &lt;code&gt;defined %Foo::Bar::QUUX&lt;/code&gt; to check whether such a package variable exists then that's never really been reliable, and isn't a good way to enquire about the features of a package, or whether it's loaded, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef8417488b5df9f33f3d1b38e3847657756981c" translate="yes" xml:space="preserve">
          <source>If you had to get a variable through, you could do this:</source>
          <target state="translated">Если бы тебе нужно было пропустить переменную,ты мог бы это сделать:</target>
        </trans-unit>
        <trans-unit id="67b4946ef744afdd9a1b21f685b5b8e140afa4b4" translate="yes" xml:space="preserve">
          <source>If you have</source>
          <target state="translated">Если у вас есть</target>
        </trans-unit>
        <trans-unit id="5887bd3238a6e02f0034680e74b35124b3f3183f" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;File::Stream&quot;&gt;File::Stream&lt;/a&gt;, this is easy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aebe0c8d3505d2fdad4a2b644054c80705f47533" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module installed from CPAN, you can use it to fetch the width and height in characters and in pixels:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ebbe151437cc5de6b126287c5035e996e85c741" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;http://search.cpan.org/perldoc/File::Stream&quot;&gt;File::Stream&lt;/a&gt;, this is easy.</source>
          <target state="translated">Если у вас есть &lt;a href=&quot;http://search.cpan.org/perldoc/File::Stream&quot;&gt;File :: Stream&lt;/a&gt; , это просто.</target>
        </trans-unit>
        <trans-unit id="8477c0614e083a37a8e560c57638a0b5f36ef52b" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module installed from CPAN, you can use it to fetch the width and height in characters and in pixels:</source>
          <target state="translated">Если у вас установлен модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt; из CPAN, вы можете использовать его для получения ширины и высоты в символах и пикселях:</target>
        </trans-unit>
        <trans-unit id="7230ece2e031d91cec5a13b629b5ff58c45c8753" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;IPC::Run&lt;/code&gt; installed, and the variable &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; is set to true (See the &lt;a href=&quot;#Global-Variables&quot;&gt;&quot;Global Variables&quot;&lt;/a&gt; section) use that to execute the command. You will have the full output available in buffers, interactive commands are sure to work and you are guaranteed to have your verbosity settings honored cleanly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240e14e2dd47b4fb473147b6d297b2d7726b59cc" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;IPC::Run&lt;/code&gt; installed, and the variable &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; is set to true (See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section) use that to execute the command. You will have the full output available in buffers, interactive commands are sure to work and you are guaranteed to have your verbosity settings honored cleanly.</source>
          <target state="translated">Если у вас установлен &lt;code&gt;IPC::Run&lt;/code&gt; , а для переменной &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; установлено значение true (см. Раздел &amp;laquo; &lt;a href=&quot;#Global-Variables&quot;&gt;Глобальные переменные&lt;/a&gt; &amp;raquo;), используйте это для выполнения команды. У вас будет полный вывод, доступный в буферах, интерактивные команды обязательно будут работать, и вам гарантированно будут соблюдены ваши настройки детализации.</target>
        </trans-unit>
        <trans-unit id="b8acd2601ad065393113859c8a7e3855297ce5ac" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;man&lt;/code&gt; installed on your system, and you installed perl manpages, use something like this:</source>
          <target state="translated">Если у вас есть &lt;code&gt;man&lt;/code&gt; , установленные в вашей системе, и вы установили перл, использование Справочника что - то вроде этого:</target>
        </trans-unit>
        <trans-unit id="d6036be6bd4d2a23f70dfe8c9f989a5911198ccc" translate="yes" xml:space="preserve">
          <source>If you have Perl 5.10 or later, and you just want to store a value against the reference for lookup later, you can use the core Hash::Util::Fieldhash module. This will also handle renaming the keys if you use multiple threads (which causes all variables to be reallocated at new addresses, changing their stringification), and garbage-collecting the entries when the referenced variable goes out of scope.</source>
          <target state="translated">Если у вас есть Perl 5.10 или более поздняя версия,и вы просто хотите сохранить значение по ссылке для последующего поиска,вы можете использовать основной модуль Hash::Util::Fieldhash.Он также будет обрабатывать переименование ключей,если вы используете несколько потоков (что приводит к тому,что все переменные перераспределяются по новым адресам,изменяя их строковую спецификацию),и сбор мусора,когда ссылка на переменную выходит за пределы области видимости.</target>
        </trans-unit>
        <trans-unit id="1ff5e330b4023d9ffe19df36972bfcc73814fd9b" translate="yes" xml:space="preserve">
          <source>If you have Perl 5.10 or later, this is almost trivial. You just smart match against an array of regular expression objects:</source>
          <target state="translated">Если у вас есть Perl 5.10 или более поздняя версия,это почти тривиально.Вы просто умно сравниваете с массивом объектов регулярных выражений:</target>
        </trans-unit>
        <trans-unit id="f112acda35554c21f927d9597b0b2023538c4e09" translate="yes" xml:space="preserve">
          <source>If you have Perl v5.16 or v5.18 and can't upgrade, you can use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe696e9056ea562cb89c9b2f102390c60db24f0" translate="yes" xml:space="preserve">
          <source>If you have Perl v5.16, the problems mentioned above go away if you use the &lt;code&gt;:not_characters&lt;/code&gt; parameter to the locale pragma (except for vendor bugs in the non-character portions). If you don't have v5.16, and you</source>
          <target state="translated">Если у вас Perl v5.16, проблемы, упомянутые выше, исчезнут, если вы используете параметр &lt;code&gt;:not_characters&lt;/code&gt; в прагме locale (за исключением ошибок поставщика в несимвольных частях). Если у вас нет v5.16, и вы</target>
        </trans-unit>
        <trans-unit id="6642f62c4bfdebf5e62452d5d72c26f1bd89b8ec" translate="yes" xml:space="preserve">
          <source>If you have YAML.pm (or some other YAML module configured in &lt;code&gt;yaml_module&lt;/code&gt; ) installed, CPAN.pm collects a few statistical data about recent downloads. You can view the statistics with the &lt;code&gt;hosts&lt;/code&gt; command or inspect them directly by looking into the &lt;code&gt;FTPstats.yml&lt;/code&gt; file in your &lt;code&gt;cpan_home&lt;/code&gt; directory.</source>
          <target state="translated">Если у вас установлен YAML.pm (или какой-либо другой модуль YAML, настроенный в &lt;code&gt;yaml_module&lt;/code&gt; ), CPAN.pm собирает некоторые статистические данные о последних загрузках. Вы можете просмотреть статистику с помощью команды &lt;code&gt;hosts&lt;/code&gt; или проверить ее напрямую, просмотрев файл &lt;code&gt;FTPstats.yml&lt;/code&gt; в каталоге &lt;code&gt;cpan_home&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="225c354ad980b0b7bb691380c5b2f0d3c2643a5a" translate="yes" xml:space="preserve">
          <source>If you have a ReadLine module installed, you can hit TAB at any point of the commandline and &lt;code&gt;o conf&lt;/code&gt; will offer you completion for the built-in subcommands and/or config variable names.</source>
          <target state="translated">Если у вас установлен модуль ReadLine, вы можете нажать TAB в любой точке командной строки, и &lt;code&gt;o conf&lt;/code&gt; предложит вам завершение для встроенных подкоманд и / или имен переменных конфигурации.</target>
        </trans-unit>
        <trans-unit id="86d2e902132f610059a158729cf105aa2e1d4e91" translate="yes" xml:space="preserve">
          <source>If you have a buffer allocated with Newx() and want to set that as the SV's value, you can use sv_usepvn_flags(). That has some requirements if you want to avoid perl re-allocating the buffer to fit the trailing NUL:</source>
          <target state="translated">Если у вас есть буфер,выделенный функцией Newx(),и вы хотите установить его в качестве значения SV,вы можете использовать функцию sv_usepvn_flags().Это имеет некоторые требования,если вы хотите избежать perl переопределения буфера для соответствия трейлинговому NUL:</target>
        </trans-unit>
        <trans-unit id="28b93e0d6dcdb9743374e046e2c50f7ec24b530d" translate="yes" xml:space="preserve">
          <source>If you have a burning desire to tell the world about your release, post an announcement to the moderated &lt;code&gt;comp.lang.perl.announce&lt;/code&gt; newsgroup.</source>
          <target state="translated">Если у вас есть горячее желание рассказать миру о своем выпуске, опубликуйте объявление в модерируемой группе новостей &lt;code&gt;comp.lang.perl.announce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ed22a427a030ed732816620f86f5c52ec466566" translate="yes" xml:space="preserve">
          <source>If you have a command-line program that does the job, you can call it in backticks to capture whatever it outputs so you can use it later:</source>
          <target state="translated">Если у вас есть программа командной строки,которая выполняет эту работу,вы можете вызывать ее на черных метках,чтобы захватить все,что она выдает,чтобы позже использовать ее:</target>
        </trans-unit>
        <trans-unit id="aabc7446c5d3e0c2ebc9233bf601a7899d673f9d" translate="yes" xml:space="preserve">
          <source>If you have a commit bit, please see &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; for more details on using git.</source>
          <target state="translated">Если у вас есть бит фиксации, см. &lt;a href=&quot;perlgit&quot;&gt;Perlgit&lt;/a&gt; для получения дополнительных сведений об использовании git.</target>
        </trans-unit>
        <trans-unit id="392daf22cd236f28ba9ceee336856176b759059d" translate="yes" xml:space="preserve">
          <source>If you have a complicated function needed to pull out the part you want to sort on, then don't do it inside the sort function. Pull it out first, because the sort BLOCK can be called many times for the same element. Here's an example of how to pull out the first word after the first number on each item, and then sort those words case-insensitively.</source>
          <target state="translated">Если у вас есть сложная функция,необходимая для извлечения детали,которую вы хотите отсортировать,то не делайте этого внутри функции сортировки.Вытяните его первым,потому что сортировка BLOCK может быть вызвана много раз для одного и того же элемента.Вот пример того,как вытащить первое слово после первого числа на каждом элементе,а затем сортировать эти слова без учета регистра.</target>
        </trans-unit>
        <trans-unit id="b0e6b3bda8c96c33f56e6b729af6c8286cbfdc17" translate="yes" xml:space="preserve">
          <source>If you have a legacy encoding, you can use the &lt;code&gt;:encoding(...)&lt;/code&gt; tag.</source>
          <target state="translated">Если у вас устаревшая кодировка, вы можете использовать тег &lt;code&gt;:encoding(...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01656c2b4f7ea5f69bae8d5caaac9ea48410bb3e" translate="yes" xml:space="preserve">
          <source>If you have a library that provides an API, you can make any component of it available as just another Perl function or variable using a Perl extension written in C or C++ and dynamically linked into your main perl interpreter. You can also go the other direction, and write your main program in C or C++, and then link in some Perl code on the fly, to create a powerful application. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">Если у вас есть библиотека, предоставляющая API, вы можете сделать любой ее компонент доступным как просто другую функцию или переменную Perl, используя расширение Perl, написанное на C или C ++ и динамически связанное с вашим основным интерпретатором Perl. Вы также можете пойти в другом направлении и написать свою основную программу на C или C ++, а затем &amp;laquo;на лету&amp;raquo; связать некоторый код Perl, чтобы создать мощное приложение. См. &lt;a href=&quot;perlembed&quot;&gt;Perlembed&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51f9e3f6122598346b767c490154d73f3d45b4f6" translate="yes" xml:space="preserve">
          <source>If you have a list of tests (or URLs, or anything else you want to test) in a file, you can add them to your tests by using a '-':</source>
          <target state="translated">Если у вас есть список тестов (или URL,или что-нибудь еще,что вы хотите проверить)в файле,вы можете добавить их в свои тесты,используя '-':</target>
        </trans-unit>
        <trans-unit id="a1add680b7e930dc8542127166a2c6922328bade" translate="yes" xml:space="preserve">
          <source>If you have a local mirror of CPAN and can access all files with &quot;file:&quot; URLs, then you only need a perl later than perl5.003 to run this module. Otherwise Net::FTP is strongly recommended. LWP may be required for non-UNIX systems, or if your nearest CPAN site is associated with a URL that is not &lt;code&gt;ftp:&lt;/code&gt; .</source>
          <target state="translated">Если у вас есть локальное зеркало CPAN и вы можете получить доступ ко всем файлам с URL-адресами &quot;file:&quot;, то для запуска этого модуля вам понадобится только Perl более поздняя, ​​чем perl5.003. В противном случае настоятельно рекомендуется использовать Net :: FTP. LWP может потребоваться для систем, отличных от UNIX, или если ваш ближайший сайт CPAN связан с URL-адресом, который не является &lt;code&gt;ftp:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc89a24f0e796df127e886da4fce9233949042a4" translate="yes" xml:space="preserve">
          <source>If you have a module that uses a decimal $VERSION (floating point), and you do not intend to ever change that, this module is not for you. There is nothing that version.pm gains you over a simple $VERSION assignment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d0404e38c1a8f4fe7f4884e84970ffe1a562e8" translate="yes" xml:space="preserve">
          <source>If you have a question you'd like to see added to the FAQ (whether or not you have the answer) please either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6b091f1c2f3916b6f982ec5d76127aba417742" translate="yes" xml:space="preserve">
          <source>If you have a question you'd like to see added to the FAQ (whether or not you have the answer) please send it to makemaker@perl.org.</source>
          <target state="translated">Если у вас есть вопрос,который вы хотели бы видеть добавленным в FAQ (независимо от того,есть ли у вас ответ),пожалуйста,отправьте его по адресу makemaker@perl.org.</target>
        </trans-unit>
        <trans-unit id="883ef441e28a9d839f80a61f11348168ebf17cd9" translate="yes" xml:space="preserve">
          <source>If you have a raw sequence of bytes that you know should be interpreted via a particular encoding, you can use &lt;code&gt;Encode&lt;/code&gt; :</source>
          <target state="translated">Если у вас есть необработанная последовательность байтов, которую, как вы знаете, следует интерпретировать с помощью определенной кодировки, вы можете использовать &lt;code&gt;Encode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5b4a02619440b043ea55b1e3e613964a4f9957c4" translate="yes" xml:space="preserve">
          <source>If you have a raw sequence of bytes that you know should be interpreted via a particular encoding, you can use &lt;code&gt;Encode&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4977b6a1b7796edc98abe66364bdbf5af8c6caa8" translate="yes" xml:space="preserve">
          <source>If you have a really hairy regular expression, use the &lt;code&gt;/x&lt;/code&gt; modifier and put in some whitespace to make it look a little less like line noise. Don't use slash as a delimiter when your regexp has slashes or backslashes.</source>
          <target state="translated">Если у вас действительно сложное регулярное выражение, используйте модификатор &lt;code&gt;/x&lt;/code&gt; и вставьте немного пробелов, чтобы оно выглядело менее похожим на линейный шум. Не используйте косую черту в качестве разделителя, если в вашем регулярном выражении есть косая черта или обратная косая черта.</target>
        </trans-unit>
        <trans-unit id="df35f05fcbbff85a11dabd04bca96051a29d5068" translate="yes" xml:space="preserve">
          <source>If you have a really hairy regular expression, use the &lt;code&gt;/x&lt;/code&gt; or &lt;code&gt;/xx&lt;/code&gt; modifiers and put in some whitespace to make it look a little less like line noise. Don't use slash as a delimiter when your regexp has slashes or backslashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4670adaa2657eda2badbded5180916956105a77" translate="yes" xml:space="preserve">
          <source>If you have a sequence of bytes you &lt;b&gt;know&lt;/b&gt; is valid UTF-8, but Perl doesn't know it yet, you can make Perl a believer, too:</source>
          <target state="translated">Если у вас есть последовательность байтов, которая, как вы &lt;b&gt;знаете,&lt;/b&gt; является допустимой UTF-8, но Perl ее еще не знает, вы также можете сделать Perl верующим:</target>
        </trans-unit>
        <trans-unit id="9756e7acda84539ead2e5f85f560f283b75aed93" translate="yes" xml:space="preserve">
          <source>If you have a single string that you want to check for &quot;equality in locale&quot; against several others, you might think you could gain a little efficiency by using &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; in conjunction with &lt;code&gt;eq&lt;/code&gt; :</source>
          <target state="translated">Если у вас есть одна строка, которую вы хотите проверить на &amp;laquo;равенство в локали&amp;raquo; с несколькими другими, вы можете подумать, что можете немного повысить эффективность, используя &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; в сочетании с &lt;code&gt;eq&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f95d4b51e2c5877925e6bfc513dc2300a8f4721e" translate="yes" xml:space="preserve">
          <source>If you have a single string that you want to check for &quot;equality in locale&quot; against several others, you might think you could gain a little efficiency by using &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; in conjunction with &lt;code&gt;eq&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f645dc4bb8034c3799b831d6996356797ca7be48" translate="yes" xml:space="preserve">
          <source>If you have a small patch to submit, please submit it via perlbug. You can also send email directly to perlbug@perl.org. Please note that messages sent to perlbug may be held in a moderation queue, so you won't receive a response immediately.</source>
          <target state="translated">Если у вас есть небольшой патч,пожалуйста,отправьте его через perlbug.Вы также можете отправить его непосредственно по электронной почте по адресу perlbug@perl.org.Пожалуйста,обратите внимание,что сообщения,отправленные perlbug,могут находиться в очереди модерации,поэтому вы не получите ответа сразу же.</target>
        </trans-unit>
        <trans-unit id="6b5776918dce21a614ab7d2b6b104a983a49243a" translate="yes" xml:space="preserve">
          <source>If you have a small patch to submit, please submit it via the GitHub Pull Request workflow. You may also send patches to the p5p list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42845d8c8c875f89de9dd2d1b7586e0d3ad16bc8" translate="yes" xml:space="preserve">
          <source>If you have a specific romanization scheme in mind, use the specific module:</source>
          <target state="translated">Если вы имеете в виду конкретную схему романтизации,используйте конкретный модуль:</target>
        </trans-unit>
        <trans-unit id="fb355db0f3f4b40524a1c3ff445d923be623d546" translate="yes" xml:space="preserve">
          <source>If you have a working &lt;code&gt;DynaLoader&lt;/code&gt; then there is rarely any need to statically link in any other extensions.</source>
          <target state="translated">Если у вас есть работающий &lt;code&gt;DynaLoader&lt;/code&gt; , то редко возникает необходимость в статической компоновке любых других расширений.</target>
        </trans-unit>
        <trans-unit id="fd5f81af8a4a7363d6132316fb90657fc9d4e232" translate="yes" xml:space="preserve">
          <source>If you have a zip file that contains multiple members and want to read a specific member from the file, say &lt;code&gt;&quot;data1&quot;&lt;/code&gt; , use the &lt;code&gt;Name&lt;/code&gt; option</source>
          <target state="translated">Если у вас есть почтовый файл , который содержит несколько членов и хотят , чтобы прочитать элемент конкретного из файла, скажем , &lt;code&gt;&quot;data1&quot;&lt;/code&gt; , используйте &lt;code&gt;Name&lt;/code&gt; опцию</target>
        </trans-unit>
        <trans-unit id="6052cdbbf6fcaf2baac87ba7e1b86897c2e18ac9" translate="yes" xml:space="preserve">
          <source>If you have a zip file that contains multiple members and want to read a specific member from the file, say &lt;code&gt;&quot;data1&quot;&lt;/code&gt;, use the &lt;code&gt;Name&lt;/code&gt; option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e60773a7086adcadd9997f1e4e60bf13f42c27" translate="yes" xml:space="preserve">
          <source>If you have an FTP proxy firewall (&lt;b&gt;NOT&lt;/b&gt; an HTTP or SOCKS firewall) then this value should be set to the firewall hostname. If your firewall does not listen to port 21, then this value should be set to &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; (eg &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; )</source>
          <target state="translated">Если у вас есть брандмауэр FTP-прокси ( &lt;b&gt;НЕ&lt;/b&gt; брандмауэр HTTP или SOCKS), тогда в этом значении должно быть указано имя хоста брандмауэра. Если ваш брандмауэр не прослушивает порт 21, тогда это значение должно быть установлено на &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; (например, &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3ebb071202346598d9545555072b8cd9d0e64671" translate="yes" xml:space="preserve">
          <source>If you have an FTP proxy firewall (&lt;b&gt;NOT&lt;/b&gt; an HTTP or SOCKS firewall) then this value should be set to the firewall hostname. If your firewall does not listen to port 21, then this value should be set to &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; (eg &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a37d9c6262b12c7aa2b49bfbcebb4a375757d2e" translate="yes" xml:space="preserve">
          <source>If you have an SV and want to know what kind of data Perl thinks is stored in it, you can use the following macros to check the type of SV you have.</source>
          <target state="translated">Если у вас есть SV и вы хотите знать,какие данные,по мнению Perl,хранятся в нем,вы можете использовать следующие макросы для проверки типа SV,который у вас есть.</target>
        </trans-unit>
        <trans-unit id="2bc4f67186bf30ca57f017f1cea8612b943dd146" translate="yes" xml:space="preserve">
          <source>If you have an array of &lt;code&gt;@string&lt;/code&gt; that should be concatenated and then normalized, you can do like this:</source>
          <target state="translated">Если у вас есть массив &lt;code&gt;@string&lt;/code&gt; , который нужно объединить , а затем нормализовать, вы можете сделать следующее:</target>
        </trans-unit>
        <trans-unit id="403ab04dd713d2cfe6f16d5487fb0193f691f18c" translate="yes" xml:space="preserve">
          <source>If you have an empty directory, you can use Perl's built-in &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt;. If the directory is not empty (so, no files or subdirectories), you either have to empty it yourself (a lot of work) or use a module to help you.</source>
          <target state="translated">Если у вас пустой каталог, вы можете использовать встроенный в Perl &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; . Если каталог не пустой (то есть нет файлов или подкаталогов), вам придется либо очистить его самостоятельно (много работы), либо использовать модуль, который вам поможет.</target>
        </trans-unit>
        <trans-unit id="e617c76fa41bca088e2fe925791d55bef7f3208c" translate="yes" xml:space="preserve">
          <source>If you have an empty directory, you can use Perl's built-in &lt;code&gt;rmdir&lt;/code&gt;. If the directory is not empty (so, with files or subdirectories), you either have to empty it yourself (a lot of work) or use a module to help you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6898ea8c69aa4a0ff2b81092a3457a58f7bdc010" translate="yes" xml:space="preserve">
          <source>If you have an existing inside-out class, simply making all hashes field hashes with no other change should make no difference. Through the calls to &lt;code&gt;refaddr&lt;/code&gt; or equivalent, the field hashes never get to see a reference and work like normal hashes. Your DESTROY (and CLONE) methods are still needed.</source>
          <target state="translated">Если у вас есть существующий класс наизнанку, простое создание хэшей всех полей без каких-либо других изменений не должно иметь никакого значения. Посредством вызовов &lt;code&gt;refaddr&lt;/code&gt; или аналогичного хэши полей никогда не видят ссылку и работают как обычные хэши. Ваши методы DESTROY (и CLONE) по-прежнему необходимы.</target>
        </trans-unit>
        <trans-unit id="03fcf475306c60d974596613b76c03a9f344e66a" translate="yes" xml:space="preserve">
          <source>If you have an older version of Perl, the &lt;code&gt;$^W&lt;/code&gt; variable (documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;) controls runtime warnings for a block:</source>
          <target state="translated">Если у вас более старая версия Perl, переменная &lt;code&gt;$^W&lt;/code&gt; (задокументированная в &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; ) управляет предупреждениями во время выполнения для блока:</target>
        </trans-unit>
        <trans-unit id="55ec04844d40449455953b5a185c6050647bf370" translate="yes" xml:space="preserve">
          <source>If you have any other characters you need to escape, please install the &lt;code&gt;URI::Escape&lt;/code&gt; module from CPAN, and pre-encode your URI before passing it to &lt;code&gt;File::Fetch&lt;/code&gt; . You can read about the details of URIs and URI encoding here:</source>
          <target state="translated">Если у вас есть другие символы, которые нужно экранировать, установите модуль &lt;code&gt;URI::Escape&lt;/code&gt; из CPAN и предварительно закодируйте свой URI перед его передачей в &lt;code&gt;File::Fetch&lt;/code&gt; . Вы можете прочитать о деталях URI и кодировки URI здесь:</target>
        </trans-unit>
        <trans-unit id="b3a311e2f3de5d8bd7b59c7e63cc0db7c3de9dbd" translate="yes" xml:space="preserve">
          <source>If you have any other characters you need to escape, please install the &lt;code&gt;URI::Escape&lt;/code&gt; module from CPAN, and pre-encode your URI before passing it to &lt;code&gt;File::Fetch&lt;/code&gt;. You can read about the details of URIs and URI encoding here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baafc393e6c194ed8ae0aabf8fee882236c21df9" translate="yes" xml:space="preserve">
          <source>If you have any suggested changes for this page, let me know. Please don't send me mail asking for help on how to install your modules. There are too many modules, and too few Orwants, for me to be able to answer or even acknowledge all your questions. Contact the module author instead, ask someone familiar with Perl on your operating system, or if all else fails, file a ticket at &lt;a href=&quot;https://rt.cpan.org/&quot;&gt;https://rt.cpan.org/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ef038a12de814aa0cdf806e88e5a326fdaf2d5" translate="yes" xml:space="preserve">
          <source>If you have any suggested changes for this page, let me know. Please don't send me mail asking for help on how to install your modules. There are too many modules, and too few Orwants, for me to be able to answer or even acknowledge all your questions. Contact the module author instead, or post to comp.lang.perl.modules, or ask someone familiar with Perl on your operating system.</source>
          <target state="translated">Если у вас есть какие-нибудь предложенные изменения для этой страницы,дайте мне знать.Пожалуйста,не присылайте мне письма с просьбой о помощи в установке ваших модулей.Слишком много модулей и слишком мало Orwants,чтобы я мог ответить или даже подтвердить все ваши вопросы.Вместо этого свяжитесь с автором модуля,или отправьте сообщение по адресу comp.lang.perl.modules,или спросите кого-нибудь,кто знаком с Perl в вашей операционной системе.</target>
        </trans-unit>
        <trans-unit id="e2545920681caa56966e901dca47f4688bdb95ac" translate="yes" xml:space="preserve">
          <source>If you have built this module with zlib &amp;gt;= 1.2.0, the &lt;code&gt;$eof&lt;/code&gt; parameter is ignored. You can still set it if you want, but it won't be used behind the scenes.</source>
          <target state="translated">Если вы создали этот модуль с zlib&amp;gt; = 1.2.0, параметр &lt;code&gt;$eof&lt;/code&gt; игнорируется. Вы все равно можете установить его, если хотите, но он не будет использоваться за кадром.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
