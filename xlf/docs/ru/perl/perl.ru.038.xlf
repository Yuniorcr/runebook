<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="b39e88e61083334da27e22ac3304f5322910c7a2" translate="yes" xml:space="preserve">
          <source>Single-letter properties match all characters in any of the two-letter sub-properties starting with the same letter. &lt;code&gt;LC&lt;/code&gt; and &lt;code&gt;L&amp;amp;&lt;/code&gt; are special: both are aliases for the set consisting of everything matched by &lt;code&gt;Ll&lt;/code&gt; , &lt;code&gt;Lu&lt;/code&gt; , and &lt;code&gt;Lt&lt;/code&gt; .</source>
          <target state="translated">Однобуквенные свойства соответствуют всем символам в любом из двухбуквенных дополнительных свойств, начинающихся с той же буквы. &lt;code&gt;LC&lt;/code&gt; и &lt;code&gt;L&amp;amp;&lt;/code&gt; специальные: оба являются псевдонимами для множества , состоящее из всего найденного &lt;code&gt;Ll&lt;/code&gt; , &lt;code&gt;Lu&lt;/code&gt; , и &lt;code&gt;Lt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47784ae534e76f07f938e74b6b49c2e04c524d60" translate="yes" xml:space="preserve">
          <source>Single-step flag. Will be true if the API will stop at the next statement.</source>
          <target state="translated">Одношаговый флаг.Будет верен,если API остановится на следующем утверждении.</target>
        </trans-unit>
        <trans-unit id="3fd72cbf421902beaf4893343701c7e9f292181e" translate="yes" xml:space="preserve">
          <source>Sinograms like &amp;ldquo;東京&amp;rdquo; come back with character names of &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; and &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt; , because their &amp;ldquo;names&amp;rdquo; vary. The CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; module has a large database for decoding these (and a whole lot more), provided you know how to understand its output.</source>
          <target state="translated">Синограммы вроде &amp;laquo;東京&amp;raquo; возвращаются с именами символов &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; и &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt; , потому что их &amp;laquo;имена&amp;raquo; различаются. Модуль CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; имеет большую базу данных для их декодирования (и многого другого), если вы знаете, как понимать его вывод.</target>
        </trans-unit>
        <trans-unit id="28e8fd907b0e11131190209772e747eaed820c59" translate="yes" xml:space="preserve">
          <source>Site-specific perl extensions and modules can be installed in one of two places. Put architecture-independent files into:</source>
          <target state="translated">В одном из двух мест могут быть установлены perl-расширения и модули для конкретного места.Вставляйте файлы,не зависящие от архитектуры:</target>
        </trans-unit>
        <trans-unit id="00832815e260edfba2e83c2f4b5a6a35db1c2d1c" translate="yes" xml:space="preserve">
          <source>Six such conversions are possible:</source>
          <target state="translated">Шесть таких преобразований возможны:</target>
        </trans-unit>
        <trans-unit id="43701334f4b3da3fdeb3363278217ac0f215873d" translate="yes" xml:space="preserve">
          <source>Size of the function table. This is compared against the value PerlIO code &quot;knows&quot; as a compatibility check. Future versions</source>
          <target state="translated">Размер таблицы функций.Для проверки совместимости сравнивается со значением PerlIO-кода &quot;знает&quot;.Будущие версии</target>
        </trans-unit>
        <trans-unit id="936d52e1c615ea7024397f6ff1aeb7c89ebd5bad" translate="yes" xml:space="preserve">
          <source>Size, Endianness, and BOM</source>
          <target state="translated">Размер,Эндианнесс и БОМ.</target>
        </trans-unit>
        <trans-unit id="0ec62bfb6670c34f50ed4190d4e6017dc34d76d5" translate="yes" xml:space="preserve">
          <source>Skip a package when throwing autodie exceptions</source>
          <target state="translated">Пропустить пакет при бросании исключений автообмена</target>
        </trans-unit>
        <trans-unit id="57a18bbc33fb3b107b0f37ec04073b6f8f1aa7be" translate="yes" xml:space="preserve">
          <source>Skip sub-char mapping should there be no code point.</source>
          <target state="translated">Пропустите подзарядное отображение,если нет кодовой точки.</target>
        </trans-unit>
        <trans-unit id="fa22bcdeb4f395bdc09dc2fd5b11b93a885994fb" translate="yes" xml:space="preserve">
          <source>Skip the real Pod formatting, and just show the raw Pod source (&lt;b&gt;U&lt;/b&gt;nformatted)</source>
          <target state="translated">Пропустить реальный Pod форматирование и просто показать необработанный источник Pod ( &lt;b&gt;U&lt;/b&gt; nformatted)</target>
        </trans-unit>
        <trans-unit id="3e59adfb26a9113df0d5c476d39a18d0087952f5" translate="yes" xml:space="preserve">
          <source>Skip this section if the XSUB functions are supposed to be called from other modules only; read it only if you call your XSUBs from the code in your module, or have a &lt;code&gt;BOOT:&lt;/code&gt; section in your XS file (see &lt;a href=&quot;perlxs#The-BOOT%3a-Keyword&quot;&gt;The BOOT: Keyword in perlxs&lt;/a&gt;). What is described here is equally applicable to the &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; interface.</source>
          <target state="translated">Пропустите этот раздел, если предполагается, что функции XSUB вызываются только из других модулей; прочтите его, только если вы вызываете свои XSUB из кода в своем модуле или имеете раздел &lt;code&gt;BOOT:&lt;/code&gt; в вашем XS файле (см &lt;a href=&quot;perlxs#The-BOOT%3a-Keyword&quot;&gt;. Ключевое слово BOOT: в perlxs&lt;/a&gt; ). То, что здесь описано, в равной степени применимо к интерфейсу &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="54ab6781ff6514e41583039acc42db3e0f3c9201" translate="yes" xml:space="preserve">
          <source>Skips all the tests, using the given &lt;code&gt;$reason&lt;/code&gt; . Exits immediately with 0.</source>
          <target state="translated">Пропускает все тесты, используя указанную &lt;code&gt;$reason&lt;/code&gt; . Немедленный выход с 0.</target>
        </trans-unit>
        <trans-unit id="563adc0d862d00d2bcc7549833d1039985aead2a" translate="yes" xml:space="preserve">
          <source>Skips the current test, reporting &lt;code&gt;$why&lt;/code&gt; .</source>
          <target state="translated">Пропускает текущий тест с сообщением &lt;code&gt;$why&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca1ac1071abc2c48fe8c683c23437c17bcd0e5ba" translate="yes" xml:space="preserve">
          <source>Skips to the next compressed data stream in the input file/buffer. If a new compressed data stream is found, the eof marker will be cleared and &lt;code&gt;$.&lt;/code&gt; will be reset to 0.</source>
          <target state="translated">Переход к следующему потоку сжатых данных во входном файле / буфере. Если будет обнаружен новый поток сжатых данных, маркер eof будет очищен и &lt;code&gt;$.&lt;/code&gt; будет сброшен на 0.</target>
        </trans-unit>
        <trans-unit id="e59d0602eb0550fd0dbf5d82907d6271ae4af6ea" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of microseconds (millionths of a second) specified. Returns the number of microseconds actually slept. Can sleep for more than one second, unlike the &lt;code&gt;usleep&lt;/code&gt; system call. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">Спит на указанное количество микросекунд (миллионных долей секунды). Возвращает количество фактически спящих микросекунд. Может спать более одной секунды, в отличие от системного вызова &lt;code&gt;usleep&lt;/code&gt; . Может также спать в течение нуля секунд, что часто работает как</target>
        </trans-unit>
        <trans-unit id="a7c111ccc19a7463efac9caa48bfd176015106c5" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of nanoseconds (1e9ths of a second) specified. Returns the number of nanoseconds actually slept (accurate only to microseconds, the nearest thousand of them). Can sleep for more than one second. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">Спит указанное количество наносекунд (1e9 секунды).Возвращает количество фактически проспавших наносекунд (с точностью до микросекунд,ближайшая тысяча).Может спать более одной секунды.Может также спать в течение нуля секунд,который часто работает как</target>
        </trans-unit>
        <trans-unit id="858360f4742bec3dbad2b4b1586f95ca8cfce48d" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of nanoseconds (1e9ths of a second) specified. Returns the number of nanoseconds actually slept. The $which is the &quot;clock id&quot;, as with clock_gettime() and clock_getres(). The flags default to zero but &lt;code&gt;TIMER_ABSTIME&lt;/code&gt; can specified (must be exported explicitly) which means that &lt;code&gt;$nanoseconds&lt;/code&gt; is not a time interval (as is the default) but instead an absolute time. Can sleep for more than one second. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">Спит на указанное количество наносекунд (1e9ths). Возвращает количество фактически спящих наносекунд. $, Который является &amp;laquo;идентификатором часов&amp;raquo;, как и в случае с clock_gettime () и clock_getres (). По умолчанию флаги равны нулю, но можно указать &lt;code&gt;TIMER_ABSTIME&lt;/code&gt; (должен быть экспортирован явно), что означает, что &lt;code&gt;$nanoseconds&lt;/code&gt; - это не временной интервал (как по умолчанию), а абсолютное время. Может спать более одной секунды. Может также спать в течение нуля секунд, что часто работает как</target>
        </trans-unit>
        <trans-unit id="bfc9358c36664745e87042ffeea926ba49acc8f0" translate="yes" xml:space="preserve">
          <source>Sleeps for the specified amount of seconds. Returns the number of seconds actually slept (a floating point value). This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; below.</source>
          <target state="translated">Спит указанное количество секунд. Возвращает количество секунд, в течение которых фактически спал (значение с плавающей запятой). Эта функция может быть импортирована, что приведет к хорошей замене &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; предоставляемого perl, см. &lt;a href=&quot;#EXAMPLES&quot;&gt;ПРИМЕРЫ&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="a455933ba1827ec6d2d6cea6cb61c05bd3954351" translate="yes" xml:space="preserve">
          <source>Slices</source>
          <target state="translated">Slices</target>
        </trans-unit>
        <trans-unit id="de97696f04df2d455746fc0459c7a0334ac08b94" translate="yes" xml:space="preserve">
          <source>Slices in scalar context return the last item of the slice.</source>
          <target state="translated">Фрагменты в скалярном контексте возвращают последний элемент фрагмента.</target>
        </trans-unit>
        <trans-unit id="fade4867f2281855741bb2fdfae6ec6bfe669774" translate="yes" xml:space="preserve">
          <source>Slicing operations and parentheses cause the right-hand side to be evaluated in list context:</source>
          <target state="translated">Операции разрезания и круглые скобки приводят к тому,что правая сторона будет оцениваться в контексте списка:</target>
        </trans-unit>
        <trans-unit id="71625e10c96350176b8faecaf24d1d897cf6efce" translate="yes" xml:space="preserve">
          <source>Slightly modified by Arthur Bergman to fit the new thread model/module.</source>
          <target state="translated">Слегка модифицирована Артуром Бергманом под новую модель/модуль резьбы.</target>
        </trans-unit>
        <trans-unit id="c05c92e1201b3c7a99b14a3196c426c41067b9ce" translate="yes" xml:space="preserve">
          <source>Smartmatch Operator</source>
          <target state="translated">Smartmatch Operator</target>
        </trans-unit>
        <trans-unit id="e4adce585ab904a3b57996c9eacd1526a8856e59" translate="yes" xml:space="preserve">
          <source>Smartmatching of Objects</source>
          <target state="translated">Умное сопоставление объектов</target>
        </trans-unit>
        <trans-unit id="fcef3abf224b18a1a9539b5cd1a74a21f40eb21d" translate="yes" xml:space="preserve">
          <source>Smartmatching one hash against another reports whether both contain the same keys, no more and no less. This could be used to see whether two records have the same field names, without caring what values those fields might have. For example:</source>
          <target state="translated">Сопоставление одного хэша с другими отчетами о том,содержат ли оба одинаковые ключи,не больше и не меньше.Это может быть использовано для того,чтобы увидеть,имеют ли две записи одни и те же имена полей,не заботясь о том,какие значения могут иметь эти поля.Например:</target>
        </trans-unit>
        <trans-unit id="4460e52ce30ee2f7dab472f65e7bc2c1c88dffad" translate="yes" xml:space="preserve">
          <source>So I got smart: I decided to be lazy and let the C compiler parse the C, which would spit out debugger stabs for me to read. These were much easier to parse. It's still not a pretty program, but at least it's more robust.</source>
          <target state="translated">Так что я поумнел:решил лениться и позволить компилятору Си разобрать Си,который выплюнул бы отладочные удары,чтобы я мог читать.Их было намного проще разбирать.Это все еще не очень красивая программа,но,по крайней мере,более надежная.</target>
        </trans-unit>
        <trans-unit id="a1f5ce193c65cebf4de4614792ca39a016541f36" translate="yes" xml:space="preserve">
          <source>So a typical call to check would look like this:</source>
          <target state="translated">Так что типичный звонок для проверки будет выглядеть вот так:</target>
        </trans-unit>
        <trans-unit id="32bf3b4ebf1dd24fdccf516f7c267bd10f4fed6f" translate="yes" xml:space="preserve">
          <source>So assuming the database created above, we can use &lt;code&gt;get_dup&lt;/code&gt; like this:</source>
          <target state="translated">Предполагая, что база данных создана выше, мы можем использовать &lt;code&gt;get_dup&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="9531481e3958e36f87e15fe09a502608d674e17a" translate="yes" xml:space="preserve">
          <source>So called because of a similar construct in &lt;b&gt;shells&lt;/b&gt; that pretends that the &lt;b&gt;lines&lt;/b&gt; following the &lt;b&gt;command&lt;/b&gt; are a separate &lt;b&gt;file&lt;/b&gt; to be fed to the command, up to some terminating string. In Perl, however, it&amp;rsquo;s just a fancy form of quoting.</source>
          <target state="translated">Вызывается так из-за аналогичной конструкции в &lt;b&gt;оболочках,&lt;/b&gt; которая делает вид, что &lt;b&gt;строки,&lt;/b&gt; следующие за &lt;b&gt;командой,&lt;/b&gt; представляют собой отдельный &lt;b&gt;файл,&lt;/b&gt; передаваемый команде, вплоть до некоторой завершающей строки. В Perl, однако, это просто причудливая форма цитирования.</target>
        </trans-unit>
        <trans-unit id="93e9a6ece24ada54b55dc7612c9389e7a638c36b" translate="yes" xml:space="preserve">
          <source>So each subroutine is born with an array of scratchpads (of length 1). On each entry to the subroutine it is checked that the current depth of the recursion is not more than the length of this array, and if it is, new scratchpad is created and pushed into the array.</source>
          <target state="translated">Поэтому каждая подпрограмма рождается с массивом скрэтчпадов (длиной 1).При каждом входе в подпрограмму проверяется,что текущая глубина рекурсии не больше длины этого массива,и если она есть,то создается новая скрэтчпад и заталкивается в массив.</target>
        </trans-unit>
        <trans-unit id="bfd2a2cfe6e08c35c8f0019242b9920756d8258f" translate="yes" xml:space="preserve">
          <source>So far so good. But suppose the way you're implementing this is:</source>
          <target state="translated">Пока все хорошо.Но представь,что ты это реализуешь:</target>
        </trans-unit>
        <trans-unit id="99d938c6031e3ad535ec502cea56c5d218d4389a" translate="yes" xml:space="preserve">
          <source>So far so good. Those of you who have been paying attention will have spotted that the tied object hasn't been used so far. So lets add an extra method to the Remember class to allow comments to be included in the file; say, something like this:</source>
          <target state="translated">Пока все хорошо.Те из вас,кто обращал внимание,заметили,что завязанный предмет до сих пор не использовался.Так что давайте добавим дополнительный метод в класс Remember,чтобы можно было включать комментарии в файл;скажем,что-нибудь вроде этого:</target>
        </trans-unit>
        <trans-unit id="438b9b4e31229df657e054c261ee9d298ca8b103" translate="yes" xml:space="preserve">
          <source>So far we've merely tried to find and list the experimental features and infer their inception, versions, etc. There's a lot of speculation here.</source>
          <target state="translated">До сих пор мы просто пытались найти и перечислить экспериментальные возможности и сделать вывод об их возникновении,версиях и т.д.Здесь много домыслов.</target>
        </trans-unit>
        <trans-unit id="10bc3a4c124b48037408d12298d27779d339f321" translate="yes" xml:space="preserve">
          <source>So far, so good. With the knowledge above you can already perform searches with just about any literal string regexp you can dream up. Here is a</source>
          <target state="translated">Пока все хорошо.С помощью вышеприведенных знаний вы уже можете осуществлять поиск с помощью практически любого буквального регэкспресса строки,о котором можно только мечтать.Вот</target>
        </trans-unit>
        <trans-unit id="8af65d96d3224572aaaeff6426ae992e0bd5b192" translate="yes" xml:space="preserve">
          <source>So far, we're using just the normal list return mechanism. What happens if you want to pass or return a hash? Well, if you're using only one of them, or you don't mind them concatenating, then the normal calling convention is ok, although a little expensive.</source>
          <target state="translated">Пока мы используем обычный механизм возврата списков.Что случится,если вы хотите пропустить или вернуть гашиш? Ну,если вы используете только один из них,или вы не возражаете против их конкатенации,то обычное соглашение по вызову нормально,хотя и немного дорогое.</target>
        </trans-unit>
        <trans-unit id="6a1a83e9f4437f40c54f1506b859ac7294d0d128" translate="yes" xml:space="preserve">
          <source>So far, we've seen literals used as templates. If the list of pack items doesn't have fixed length, an expression constructing the template is required (whenever, for some reason, &lt;code&gt;()*&lt;/code&gt; cannot be used). Here's an example: To store named string values in a way that can be conveniently parsed by a C program, we create a sequence of names and null terminated ASCII strings, with &lt;code&gt;=&lt;/code&gt; between the name and the value, followed by an additional delimiting null byte. Here's how:</source>
          <target state="translated">До сих пор мы видели литералы, используемые в качестве шаблонов. Если список элементов пакета не имеет фиксированной длины, требуется выражение, составляющее шаблон (всякий раз, когда по какой-либо причине нельзя использовать &lt;code&gt;()*&lt;/code&gt; ). Вот пример: для хранения именованных строковых значений способом, который может быть удобно проанализирован программой C, мы создаем последовательность имен и строк ASCII с завершающим нулем, с &lt;code&gt;=&lt;/code&gt; между именем и значением, за которым следует дополнительный ограничивающий нулевой байт. . Вот как:</target>
        </trans-unit>
        <trans-unit id="7a5692420708108a4d7ad47094be88b57cf9bf66" translate="yes" xml:space="preserve">
          <source>So for English (with Bracket Notation) &lt;code&gt;&quot;...[quant,_1,file]...&quot;&lt;/code&gt; is fine (for 0 it returns &quot;0 files&quot;, for 1 it returns &quot;1 file&quot;, and for more it returns &quot;2 files&quot;, etc.)</source>
          <target state="translated">Таким образом, для английского языка (с обозначением скобок) &lt;code&gt;&quot;...[quant,_1,file]...&quot;&lt;/code&gt; подходит (для 0 возвращается &quot;0 файлов&quot;, для 1 возвращается &quot;1 файл&quot;, а для большего количества возвращается &quot; 2 файла &amp;raquo;и др.)</target>
        </trans-unit>
        <trans-unit id="8477c048b776b6250b8d3a6b206bd8a95a79a9ff" translate="yes" xml:space="preserve">
          <source>So for example, instead of using:</source>
          <target state="translated">Так,например,вместо того,чтобы использовать:</target>
        </trans-unit>
        <trans-unit id="23a15c81788a2c5aff56ccaef77af7e0b8ce44eb" translate="yes" xml:space="preserve">
          <source>So given the diagram above, Perl will search &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt; , and finally &lt;code&gt;MaternalGrandparent&lt;/code&gt; . This may be a problem because now we're looking in &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;</source>
          <target state="translated">Итак, учитывая приведенную выше диаграмму, Perl будет искать &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt; и, наконец, &lt;code&gt;MaternalGrandparent&lt;/code&gt; . Это может быть проблемой, потому что теперь мы ищем &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91f4e47cc018c4b1c4ca9fc78408994ad8035bd1" translate="yes" xml:space="preserve">
          <source>So here is the bottom line--if you are sure that control will revert back to the enclosing Perl scope fairly quickly after the end of your callback, then it isn't absolutely necessary to dispose explicitly of any temporaries you may have created. Mind you, if you are at all uncertain about what to do, it doesn't do any harm to tidy up anyway.</source>
          <target state="translated">Итак,вот в чем суть-если вы уверены,что управление вернется обратно в прилагаемый диапазон Perl довольно быстро после окончания вашего обратного вызова,то не обязательно явно распоряжаться какими-либо временными объектами,которые вы,возможно,создали.Имейте в виду,что если вы вообще не уверены в том,что делать,это не причинит никакого вреда,чтобы привести в порядок в любом случае.</target>
        </trans-unit>
        <trans-unit id="4443d502fbd614fe670f624b7a8d6e87d74c5b32" translate="yes" xml:space="preserve">
          <source>So hopefully you've now got a few ideas about what's good to modularise. Let's now see how it's done.</source>
          <target state="translated">Так что,надеюсь,теперь у тебя есть несколько идей о том,что хорошо для модуляризации.А теперь посмотрим,как это делается.</target>
        </trans-unit>
        <trans-unit id="6d3a27421600e7d4abecd702bd20845b8466123d" translate="yes" xml:space="preserve">
          <source>So how do I use a proxy with File::Fetch?</source>
          <target state="translated">Как использовать прокси-сервер с File::Fetch?</target>
        </trans-unit>
        <trans-unit id="9d00ee45ac1982b7db0dbf721dd3e3787ed6d62f" translate="yes" xml:space="preserve">
          <source>So how do you use a source filter in a Perl script? Above, I said that a source filter is just a special kind of module. Like all Perl modules, a source filter is invoked with a use statement.</source>
          <target state="translated">Так как же использовать фильтр исходных текстов в Perl-скрипте? Выше я сказал,что фильтр исходных текстов-это просто специальный вид модуля.Как и все модули на Perl,фильтр исходного текста вызывается с оператором use.</target>
        </trans-unit>
        <trans-unit id="6cca2cb75a50d0827a566440232066af85d09fbe" translate="yes" xml:space="preserve">
          <source>So how does it work?</source>
          <target state="translated">Так как это работает?</target>
        </trans-unit>
        <trans-unit id="9612f816ae3d1d599129006ddc23ec570699e275" translate="yes" xml:space="preserve">
          <source>So if you take for example the shell command</source>
          <target state="translated">Так что если взять,например,команду оболочки</target>
        </trans-unit>
        <trans-unit id="557e6fd5bed4c1d07e89cc778dd5ffa04e712afb" translate="yes" xml:space="preserve">
          <source>So if you want to check the validity of the encoding, surround the expression with &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; block as follows;</source>
          <target state="translated">Поэтому, если вы хотите проверить правильность кодировки, заключите выражение в блок &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; следующим образом;</target>
        </trans-unit>
        <trans-unit id="d7e30a7ebf49e6593b8da91cf7504894e9cfa473" translate="yes" xml:space="preserve">
          <source>So if you were to supply a new, complete, top-level source file to add to Perl, you should conform to this peculiar practice by yourself selecting an appropriate quotation from Tolkien, retaining the original spelling and punctuation and using the same format the rest of the quotes are in. Indirect and oblique is just fine; remember, it's a metaphor, so being meta is, after all, what it's for.</source>
          <target state="translated">Таким образом,если вы должны предоставить новый,полный,высокоуровневый исходный файл для добавления на Perl,вы должны соответствовать этой специфической практике,самостоятельно выбрав соответствующую цитату из Толкиена,сохранив оригинальное написание и пунктуацию и используя тот же формат,в котором находятся остальные цитаты.Косвенный и косой-это просто прекрасно,помните,что это метафора,так что мета-это,в конце концов,то,для чего она нужна.</target>
        </trans-unit>
        <trans-unit id="02bb4252af15d73e7777da1a95cce444353d918a" translate="yes" xml:space="preserve">
          <source>So if you're working with Unicode data, consult the documentation of every module you're using if there are any issues with Unicode data exchange. If the documentation does not talk about Unicode at all, suspect the worst and probably look at the source to learn how the module is implemented. Modules written completely in Perl shouldn't cause problems. Modules that directly or indirectly access code written in other programming languages are at risk.</source>
          <target state="translated">Поэтому,если вы работаете с данными Юникода,проконсультируйтесь с документацией каждого модуля,который вы используете,если у вас возникли проблемы с обменом данными в Юникоде.Если в документации вообще не говорится о Юникоде,заподозрите худшее и,возможно,посмотрите на исходные тексты,чтобы узнать,как реализуется модуль.Модули,полностью написанные на Perl,не должны вызывать проблем.Модули,которые прямо или косвенно обращаются к коду,написанному на других языках программирования,находятся под угрозой.</target>
        </trans-unit>
        <trans-unit id="e319523cadbb2780f0ef0af26ce5a7a559c73594" translate="yes" xml:space="preserve">
          <source>So in VMS its pm_to_blib.ts.</source>
          <target state="translated">Так что в VMS его pm_to_blib.ts.</target>
        </trans-unit>
        <trans-unit id="3bce9b15392a6c8658669f57b4a2decac3558eb6" translate="yes" xml:space="preserve">
          <source>So instead you'll want to do something like this:</source>
          <target state="translated">Так что вместо этого ты захочешь сделать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="6161c23b3048d528f32556aeffc6deb23d6328c9" translate="yes" xml:space="preserve">
          <source>So it is round-trip safe for \xF9\xF9. But if the line above is upside down, here is what happens.</source>
          <target state="translated">Так что для \xF9\xF9 это безопасно для поездок туда и обратно.Но если линия выше перевернута,вот что произойдет.</target>
        </trans-unit>
        <trans-unit id="c06ae4675003e825258b16549181d9f72cc7560a" translate="yes" xml:space="preserve">
          <source>So it's clearer and best to use the compound form when specifying blocks. And be sure that is what you really really want to do. In most cases scripts are what you want instead.</source>
          <target state="translated">Так что при задании блоков лучше всего использовать составную форму.И будьте уверены,что это то,чего вы действительно хотите.В большинстве случаев сценарии-это то,что вы хотите.</target>
        </trans-unit>
        <trans-unit id="3007e0313fdaf4be553a40db748fe3ab3979d2d6" translate="yes" xml:space="preserve">
          <source>So just remember always to use the array or hash constructors with &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt; , and you'll be fine, although it's not always optimally efficient.</source>
          <target state="translated">Так что не забывайте всегда использовать конструкторы массивов или хешей с &lt;code&gt;[]&lt;/code&gt; или &lt;code&gt;{}&lt;/code&gt; , и все будет в порядке, хотя это не всегда оптимально эффективно.</target>
        </trans-unit>
        <trans-unit id="28f6b3059bd71a14d4d6430ebaa792ae77f9b5ae" translate="yes" xml:space="preserve">
          <source>So much for textual data. Let's get onto the meaty stuff that &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; are best at: handling binary formats for numbers. There is, of course, not just one binary format - life would be too simple - but Perl will do all the finicky labor for you.</source>
          <target state="translated">Вот и все о текстовых данных. Давайте &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; содержательным вещам, которые лучше всего подходят для &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; и распаковки : обработка двоичных форматов чисел. Конечно, существует не только один двоичный формат - жизнь была бы слишком простой - но Perl сделает за вас всю сложную работу.</target>
        </trans-unit>
        <trans-unit id="19e5670a7ba385b708ff4bcfadcd36a0825afece" translate="yes" xml:space="preserve">
          <source>So now this code would be written:</source>
          <target state="translated">Так что теперь этот код будет написан:</target>
        </trans-unit>
        <trans-unit id="7ec657e348cc94be548b290696e0a818e7f982d5" translate="yes" xml:space="preserve">
          <source>So now you have a file ending in .tar.gz (or, less often, .zip). You know there's a tasty module inside. There are four steps you must now take:</source>
          <target state="translated">Итак,теперь у вас есть файл,заканчивающийся на .tar.gz (или,реже,.zip).Вы знаете,что внутри есть вкусный модуль.Теперь вы должны сделать четыре шага:</target>
        </trans-unit>
        <trans-unit id="9f7f09ef2fcd4d20ffdab1795e6c221c8b2cdf50" translate="yes" xml:space="preserve">
          <source>So please select carefully what library you want to use.</source>
          <target state="translated">Поэтому,пожалуйста,внимательно выбирайте,какую библиотеку вы хотите использовать.</target>
        </trans-unit>
        <trans-unit id="fc4d504736579a86ac1ba1abd47d391cec08a768" translate="yes" xml:space="preserve">
          <source>So put in parentheses to say what you really mean.</source>
          <target state="translated">Так что поставь в скобки,чтобы сказать,что ты на самом деле имеешь в виду.</target>
        </trans-unit>
        <trans-unit id="291a379872204cd90f4de2f2a608af9f0d7dabed" translate="yes" xml:space="preserve">
          <source>So specifically, autoloaded functions cannot see package lexicals (this applies to both the &lt;b&gt;SelfLoader&lt;/b&gt; and the Autoloader). The &lt;code&gt;vars&lt;/code&gt; pragma provides an alternative to defining package-level globals that will be visible to autoloaded routines. See the documentation on &lt;b&gt;vars&lt;/b&gt; in the pragma section of &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">В частности, автозагрузочные функции не могут видеть лексику пакетов (это относится как к &lt;b&gt;SelfLoader, так&lt;/b&gt; и к Autoloader). &lt;code&gt;vars&lt;/code&gt; Прагмы является альтернативой определения глобал уровня пакета , которые будут видны автозагружаемыми рутины. См. Документацию по &lt;b&gt;варам&lt;/b&gt; в разделе &lt;a href=&quot;perlmod&quot;&gt;директив perlmod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="178e0296c43b2c22ca3149a0d363aa4b6a82de7c" translate="yes" xml:space="preserve">
          <source>So that's how we consume and produce fixed-width data. Let's recap what we've seen of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; so far:</source>
          <target state="translated">Вот как мы потребляем и производим данные фиксированной ширины. Давайте резюмировать то , что мы видели &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; до сих пор:</target>
        </trans-unit>
        <trans-unit id="da5a5de8356ec781cae3674738f4fa4085230f11" translate="yes" xml:space="preserve">
          <source>So the Perl interface would look like this</source>
          <target state="translated">Значит,интерфейс Perl будет выглядеть так.</target>
        </trans-unit>
        <trans-unit id="eb361df349469f52fd13dc7f637fd6d3f4002c01" translate="yes" xml:space="preserve">
          <source>So the Perl subroutine would look like this:</source>
          <target state="translated">Чтобы подпрограмма &quot;Перл&quot; выглядела вот так:</target>
        </trans-unit>
        <trans-unit id="f9e5e29abec6c42a24502ee051f01eb881622a3a" translate="yes" xml:space="preserve">
          <source>So the exit codes are...</source>
          <target state="translated">Значит,коды выхода...</target>
        </trans-unit>
        <trans-unit id="ecdcbf5b6eec0983bdba576e908b1b991d7bdaa0" translate="yes" xml:space="preserve">
          <source>So the methods &lt;code&gt;PrintID&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; can be invoked like this:</source>
          <target state="translated">Итак, методы &lt;code&gt;PrintID&lt;/code&gt; и &lt;code&gt;Display&lt;/code&gt; можно вызывать следующим образом:</target>
        </trans-unit>
        <trans-unit id="050bc5740a1b6bb30a161c3c46fabef260c75737" translate="yes" xml:space="preserve">
          <source>So this:</source>
          <target state="translated">Итак,это:</target>
        </trans-unit>
        <trans-unit id="65f64a88a88a2a42947aa812e415dc968ce4fc3b" translate="yes" xml:space="preserve">
          <source>So to repeat always use SvOK() to check whether an sv is defined.</source>
          <target state="translated">Поэтому,чтобы повторить всегда используйте SvOK()для проверки,определен ли sv.</target>
        </trans-unit>
        <trans-unit id="ec007077340f2b45239679ca4cc61f38315a3433" translate="yes" xml:space="preserve">
          <source>So what happened to dTHR?</source>
          <target state="translated">Так что случилось с ДТПЧ?</target>
        </trans-unit>
        <trans-unit id="dd71b3066f2c37ca89d49c13416a448baf2ad1f1" translate="yes" xml:space="preserve">
          <source>So what has this got to do with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;? Well, if you want to compose a Unicode string (that is internally encoded as UTF-8), you can do so by using template code &lt;code&gt;U&lt;/code&gt; . As an example, let's produce the Euro currency symbol (code number 0x20AC):</source>
          <target state="translated">Так при чем здесь &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ? Ну, если вы хотите , чтобы составить строку Unicode (то есть внутренне зашифрованная UTF-8), вы можете сделать это, используя шаблон код &lt;code&gt;U&lt;/code&gt; . В качестве примера создадим символ валюты евро (кодовый номер 0x20AC):</target>
        </trans-unit>
        <trans-unit id="76db05e5ac37110bc4537d598a8e57f24d0e7d58" translate="yes" xml:space="preserve">
          <source>So what is the big problem? Well, if you are expecting Perl to tidy up those temporaries for you, you might be in for a long wait. For Perl to dispose of your temporaries, control must drop back to the enclosing scope at some stage. In the event driven scenario that may never happen. This means that, as time goes on, your program will create more and more temporaries, none of which will ever be freed. As each of these temporaries consumes some memory your program will eventually consume all the available memory in your system--kapow!</source>
          <target state="translated">Так в чем проблема? Ну,если ты ожидаешь,что Перл уберёт для тебя эти временники,то тебе придётся долго ждать.Для того,чтобы Perl распорядился вашими временами,на каком-то этапе контроль должен вернуться к закрывающему прибору.В событии,которое может никогда не произойти.Это означает,что с течением времени ваша программа будет создавать всё больше и больше времен,ни одно из которых никогда не будет освобождено.По мере того,как каждый из этих временных периодов потребляет некоторую память,ваша программа в конечном счете будет потреблять всю доступную память в вашей системе-kapow!</target>
        </trans-unit>
        <trans-unit id="49dd0c06fd8f279176f457e7dd90bd0af2090341" translate="yes" xml:space="preserve">
          <source>So what's new?</source>
          <target state="translated">Так что нового?</target>
        </trans-unit>
        <trans-unit id="8be287051544a93972a5fe33ce5f2eed6334bad0" translate="yes" xml:space="preserve">
          <source>So when the output is a filehandle it will carry out a seek to the eof before writing any compressed data. If the output is a filename, it will be opened for appending. If the output is a buffer, all compressed data will be appended to the existing buffer.</source>
          <target state="translated">Таким образом,когда на выходе находится файловый менеджер,он будет осуществлять поиск в eof перед записью любых сжатых данных.Если вывод является именем файла,он будет открыт для добавления.Если выходной файл является буфером,то все сжатые данные будут добавлены в существующий буфер.</target>
        </trans-unit>
        <trans-unit id="2b16151fbc25d8d9908507f5cf41dca81006fcb5" translate="yes" xml:space="preserve">
          <source>So when the output is a filehandle it will carry out a seek to the eof before writing any uncompressed data. If the output is a filename, it will be opened for appending. If the output is a buffer, all uncompressed data will be appended to the existing buffer.</source>
          <target state="translated">Таким образом,когда на выходе находится файловый менеджер,он будет осуществлять поиск в eof перед записью любых несжатых данных.Если вывод является именем файла,он будет открыт для добавления.Если выходной файл является буфером,то все несжатые данные будут добавлены в существующий буфер.</target>
        </trans-unit>
        <trans-unit id="faf320f95dede4954f64d637d17b4ef0ec2ac56b" translate="yes" xml:space="preserve">
          <source>So when we parse &lt;code&gt;/foo/&lt;/code&gt; we see something like the following table. The left shows what is being parsed, and the number indicates where the next regop would go. The stuff on the right is the trace output of the graph. The names are chosen to be short to make it less dense on the screen. 'tsdy' is a special form of &lt;code&gt;regtail()&lt;/code&gt; which does some extra analysis.</source>
          <target state="translated">Итак, когда мы разбираем &lt;code&gt;/foo/&lt;/code&gt; мы видим что-то вроде следующей таблицы. Слева показано, что анализируется, а число указывает, куда пойдет следующий regop. Справа - результат трассировки графика. Имена выбраны короткими, чтобы изображение на экране было менее плотным. tsdy - это особая форма &lt;code&gt;regtail()&lt;/code&gt; которая выполняет дополнительный анализ.</target>
        </trans-unit>
        <trans-unit id="4ca42b2545bb9f74c7dfcf26ad336456861738d0" translate="yes" xml:space="preserve">
          <source>So why is UNINST=1 not the default?</source>
          <target state="translated">Так почему же UNINST=1 не по умолчанию?</target>
        </trans-unit>
        <trans-unit id="5764d39b6b45dd4fdf0407e6dadfbf8730c1c2c3" translate="yes" xml:space="preserve">
          <source>So why use these? They produce better diagnostics on failure. &lt;code&gt;ok()&lt;/code&gt; cannot know what you are testing for (beyond the name), but &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; know what the test was and why it failed. For example this test:</source>
          <target state="translated">Так зачем их использовать? Они обеспечивают лучшую диагностику неисправности. &lt;code&gt;ok()&lt;/code&gt; не может знать, что вы тестируете (помимо имени), но &lt;code&gt;is()&lt;/code&gt; и &lt;code&gt;isnt()&lt;/code&gt; знают, что это был за тест и почему он не удался. Например этот тест:</target>
        </trans-unit>
        <trans-unit id="0723871c8efb4af11337b70788bc11e5f341de34" translate="yes" xml:space="preserve">
          <source>So why would you ever want to use a Unix domain socket instead of a simpler named pipe? Because a named pipe doesn't give you sessions. You can't tell one process's data from another's. With socket programming, you get a separate session for each client; that's why accept() takes two arguments.</source>
          <target state="translated">Так зачем же вам понадобилось использовать доменное гнездо Unix вместо более простой именной трубы? Потому что именованная труба не дает вам сеансов.Вы не можете отличить данные одного процесса от данных другого.При программировании сокетов вы получаете отдельный сеанс для каждого клиента;вот почему accept()принимает два аргумента.</target>
        </trans-unit>
        <trans-unit id="907dfd8f705f1e1d725ffd018f44b3318d9e84e1" translate="yes" xml:space="preserve">
          <source>So you can figure out what went wrong without rerunning the test.</source>
          <target state="translated">Так что ты можешь выяснить,что пошло не так,не повторив тест.</target>
        </trans-unit>
        <trans-unit id="85a109f19c85f2e155b7bae45252c43e85217d92" translate="yes" xml:space="preserve">
          <source>So you should instead try this;</source>
          <target state="translated">Так что вместо этого тебе стоит попробовать это;</target>
        </trans-unit>
        <trans-unit id="99368e21d7e985fc9382de7cbad3270d6b572550" translate="yes" xml:space="preserve">
          <source>So you want to know what &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; actually does?</source>
          <target state="translated">Итак, вы хотите знать, что на самом деле делает &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="d98457d69f47757522cf080b8cba6d90757ec58b" translate="yes" xml:space="preserve">
          <source>So, beside calls like</source>
          <target state="translated">Итак,кроме звонков вроде</target>
        </trans-unit>
        <trans-unit id="8b676466aa2043751e164c60e8f768fad4f2409b" translate="yes" xml:space="preserve">
          <source>So, for classes and subclasses to have inheritance correctly work with autoloading, you need to ensure stubs are loaded.</source>
          <target state="translated">Таким образом,для того,чтобы классы и подклассы,имеющие наследование,корректно работали с автозагрузкой,необходимо обеспечить загрузку шлейфов.</target>
        </trans-unit>
        <trans-unit id="3fdc850c88acfeea0034b4d0a5ecf1cbe8955116" translate="yes" xml:space="preserve">
          <source>So, for example, &quot;wb9&quot; means open for writing with the maximum compression using the default strategy and &quot;wb4R&quot; means open for writing with compression level 4 and run-length encoding.</source>
          <target state="translated">Так,например,&quot;wb9&quot; означает открытый для записи с максимальным сжатием,используя стратегию по умолчанию,а &quot;wb4R&quot; означает открытый для записи с 4-м уровнем сжатия и кодировкой длины прогона.</target>
        </trans-unit>
        <trans-unit id="98d3c65256a4087c70ab29c5923eefef7208b53e" translate="yes" xml:space="preserve">
          <source>So, for instance, to pack 20302 to a signed 16 bit integer in your computer's representation you write</source>
          <target state="translated">Так,например,чтобы упаковать 20302 в подписанное 16-битное целое число в представлении вашего компьютера,вы пишете</target>
        </trans-unit>
        <trans-unit id="5a026df42e6a15ca497ded704c00f477c0e8e518" translate="yes" xml:space="preserve">
          <source>So, if you see two terms with an &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; , between them, you can turn them into a single expression. When you do this, you execute the code in the block on the next line: if you see &lt;code&gt;=&lt;/code&gt; , you'll do the code in line 2. If you see &lt;code&gt;+&lt;/code&gt; , you'll do the code in line 4. It's this code which contributes to the op tree.</source>
          <target state="translated">Итак, если вы видите два термина со знаком &lt;code&gt;=&lt;/code&gt; или &lt;code&gt;+&lt;/code&gt; между ними, вы можете превратить их в одно выражение. Когда вы это сделаете, вы выполните код в блоке в следующей строке: если вы видите &lt;code&gt;=&lt;/code&gt; , вы выполните код в строке 2. Если вы видите &lt;code&gt;+&lt;/code&gt; , вы выполните код в строке 4. Это этот код. который вносит вклад в дерево операций.</target>
        </trans-unit>
        <trans-unit id="f012b7bad59a01daf6da8ed100b9c040ae573c55" translate="yes" xml:space="preserve">
          <source>So, if you want to collect memory info in a cycle, you may call</source>
          <target state="translated">Итак,если вы хотите собрать информацию о памяти в цикле,вы можете позвонить</target>
        </trans-unit>
        <trans-unit id="f33ef09895b9595e58c40994534996d41b9b84f6" translate="yes" xml:space="preserve">
          <source>So, in general, &quot;state&quot; subroutines are faster. But &quot;my&quot; subs are necessary if you want to create closures:</source>
          <target state="translated">Итак,в общем,подпрограммы &quot;состояние&quot; быстрее.Но &quot;мои&quot; подпрограммы необходимы,если вы хотите создать замыкания:</target>
        </trans-unit>
        <trans-unit id="b92446e0fc5150a550f9b239a78e7589775be2a5" translate="yes" xml:space="preserve">
          <source>So, let's say you want to add a custom element called 'foo'. In your subclass's &lt;code&gt;new&lt;/code&gt; method, after calling &lt;code&gt;SUPER::new&lt;/code&gt; you'd call:</source>
          <target state="translated">Итак, допустим, вы хотите добавить настраиваемый элемент под названием &amp;laquo;foo&amp;raquo;. В &lt;code&gt;new&lt;/code&gt; методе вашего подкласса после вызова &lt;code&gt;SUPER::new&lt;/code&gt; вы должны вызвать:</target>
        </trans-unit>
        <trans-unit id="04546d861006181e7076b52be007eeaf163f592b" translate="yes" xml:space="preserve">
          <source>So, rather than having to say:</source>
          <target state="translated">Так что,вместо того,чтобы говорить:</target>
        </trans-unit>
        <trans-unit id="ce7cf438ffd137d4b9ae434030e4dd1bac347bb0" translate="yes" xml:space="preserve">
          <source>So, saying &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; performs the &quot;and&quot; operation on numbers (yielding &lt;code&gt;3&lt;/code&gt; ). Saying &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; performs the &quot;and&quot; operation on strings (yielding &lt;code&gt;&quot;1&quot;&lt;/code&gt; ).</source>
          <target state="translated">Итак, выражение &amp;laquo; &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; выполняет операцию &amp;laquo;и&amp;raquo; над числами (что дает &lt;code&gt;3&lt;/code&gt; ). Произнесение &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; выполняет операцию &amp;laquo;и&amp;raquo; над строками (в результате получается &lt;code&gt;&quot;1&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4a687b4464c81c65ad71b0b242c9a17889c06be5" translate="yes" xml:space="preserve">
          <source>So, sometimes you might want to use symbolic references to manipulate the symbol table directly. This doesn't matter for formats, handles, and subroutines, because they are always global--you can't use my() on them. For scalars, arrays, and hashes, though--and usually for subroutines-- you probably only want to use hard references.</source>
          <target state="translated">Поэтому иногда вам может понадобиться использовать символьные ссылки для прямого манипулирования таблицей символов.Это не имеет значения для форматов,дескрипторов и подпрограмм,потому что они всегда глобальны-вы не можете использовать мою()на них.Для скаляров,массивов и хэшей,хотя...и обычно для подпрограмм...вы,вероятно,хотите использовать только жесткие ссылки.</target>
        </trans-unit>
        <trans-unit id="8b62c1a83484ac0f80542a2de9bd04874ec15952" translate="yes" xml:space="preserve">
          <source>So, the following examples will now work all as expected:</source>
          <target state="translated">Итак,следующие примеры теперь будут работать,как и ожидалось:</target>
        </trans-unit>
        <trans-unit id="b83b5043b490e39d23dba00f7ce754a2ed020ba9" translate="yes" xml:space="preserve">
          <source>So, the following line:</source>
          <target state="translated">Итак,следующая строчка:</target>
        </trans-unit>
        <trans-unit id="e43264c4b337b0feb1da1b34ab4669d9bfde22ae" translate="yes" xml:space="preserve">
          <source>So, the following two statements do the same thing:</source>
          <target state="translated">Итак,следующие два заявления делают то же самое:</target>
        </trans-unit>
        <trans-unit id="0f5b24deb12867f441d62aa11cf38e02b6693a70" translate="yes" xml:space="preserve">
          <source>So, the string of Martian &quot;I am CVSGXX!&quot; uses 12 bytes to encode the nine characters 'I', ' ', 'a', 'm', ' ', 'CV', 'SG', 'XX', '!'.</source>
          <target state="translated">Итак,строка марсианского &quot;I am CVSGXX!&quot; использует 12 байт для кодирования девяти символов 'I','','a','m','','CV','SG','XX',''!'.</target>
        </trans-unit>
        <trans-unit id="666f233dad00e2e027af2bcddbc736103b174459" translate="yes" xml:space="preserve">
          <source>So, what's the big problem with that? It looks right, doesn't it? After all, I just told you that you need an array of references, so by golly, you've made me one!</source>
          <target state="translated">Так в чем же проблема? Выглядит правильно,не так ли? В конце концов,я только что сказал тебе,что тебе нужна масса ссылок,так что,чёрт возьми,ты сделал мне одну!</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="93c6a1f183694628e37ced41591147bfc0da1908" translate="yes" xml:space="preserve">
          <source>Socket</source>
          <target state="translated">Socket</target>
        </trans-unit>
        <trans-unit id="1a669dbe9f824af2034872bc98a2b6823a4c09af" translate="yes" xml:space="preserve">
          <source>Socket option level constant for setsockopt() and getsockopt().</source>
          <target state="translated">Константа уровня опции сокета для setsockopt()и getockopt().</target>
        </trans-unit>
        <trans-unit id="e89a311c363b4ef4dc4be93eaeb6560498486275" translate="yes" xml:space="preserve">
          <source>Socket option name constants for IPv4 socket options at the &lt;code&gt;IPPROTO_IP&lt;/code&gt; level.</source>
          <target state="translated">Константы имени параметра сокета для параметров сокета IPv4 на уровне &lt;code&gt;IPPROTO_IP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d741b5bebfd867658e744ca3a901afeae953cecf" translate="yes" xml:space="preserve">
          <source>Socket option name constants for IPv6 socket options at the &lt;code&gt;IPPROTO_IPV6&lt;/code&gt; level.</source>
          <target state="translated">Константы имени параметра сокета для параметров сокета IPv6 на уровне &lt;code&gt;IPPROTO_IPV6&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bea3c52b1b205afb6610aaf669b9a46fdff261d" translate="yes" xml:space="preserve">
          <source>Socket option name constants for TCP socket options at the &lt;code&gt;IPPROTO_TCP&lt;/code&gt; level.</source>
          <target state="translated">Константы имени параметра сокета для параметров сокета TCP на уровне &lt;code&gt;IPPROTO_TCP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8943cecdeb64eeb6c75caac188d81a6e580de3c7" translate="yes" xml:space="preserve">
          <source>Socket option name constants for setsockopt() and getsockopt() at the &lt;code&gt;SOL_SOCKET&lt;/code&gt; level.</source>
          <target state="translated">Константы имени параметра сокета для setsockopt () и getsockopt () на уровне &lt;code&gt;SOL_SOCKET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a16f3d4e350888989be5c310a53b83649d06948" translate="yes" xml:space="preserve">
          <source>Socket option value constants for &lt;code&gt;IP_TOS&lt;/code&gt; socket option.</source>
          <target state="translated">Константы значения &lt;code&gt;IP_TOS&lt;/code&gt; сокета для параметра сокета IP_TOS .</target>
        </trans-unit>
        <trans-unit id="734337896e45cc2ebeff48479a66b46bdd05ddb4" translate="yes" xml:space="preserve">
          <source>Socket type constants to use as the second argument to socket(), or the value of the &lt;code&gt;SO_TYPE&lt;/code&gt; socket option.</source>
          <target state="translated">Константы типа сокета для использования в качестве второго аргумента функции socket () или значения &lt;code&gt;SO_TYPE&lt;/code&gt; сокета SO_TYPE .</target>
        </trans-unit>
        <trans-unit id="5bedda872ecdb70c2a2d140ada477f5b294eb6f0" translate="yes" xml:space="preserve">
          <source>Socket.</source>
          <target state="translated">Socket.</target>
        </trans-unit>
        <trans-unit id="ebe92a08483968e414740930bf0a0a08483ad931" translate="yes" xml:space="preserve">
          <source>Socket.a</source>
          <target state="translated">Socket.a</target>
        </trans-unit>
        <trans-unit id="848572346180cfeef643ccd7fddcc1762d26f13a" translate="yes" xml:space="preserve">
          <source>Sockets: Client/Server Communication</source>
          <target state="translated">Розетки:Связь между клиентом и сервером</target>
        </trans-unit>
        <trans-unit id="bbfadcc007c702d16ecd0e6f6d3baeefff3d72aa" translate="yes" xml:space="preserve">
          <source>Solaris 10 documentation on syslog, &lt;a href=&quot;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&quot;&gt;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&lt;/a&gt;</source>
          <target state="translated">Документация Solaris 10 по syslog, &lt;a href=&quot;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&quot;&gt;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98fa552d1b28be69cf1da96419b8a90307162871" translate="yes" xml:space="preserve">
          <source>Solaris 7 and above will run in either 32 bit or 64 bit mode on SPARC CPUs, via a reboot. You can build 64 bit apps whilst running 32 bit mode and vice-versa. 32 bit apps will run under Solaris running in either 32 or 64 bit mode. 64 bit apps require Solaris to be running 64 bit mode.</source>
          <target state="translated">Solaris 7 и выше будет работать либо в 32-битном,либо в 64-битном режиме на процессорах SPARC,путем перезагрузки.Вы можете создавать 64-битные приложения,работая в 32-битном режиме и наоборот.32-битные приложения будут работать в Solaris в 32 или 64-битном режиме.64-битные приложения требуют,чтобы Solaris работал в 64-битном режиме.</target>
        </trans-unit>
        <trans-unit id="6ef2766b707c501497b46c746afec2754f6fc860" translate="yes" xml:space="preserve">
          <source>Solaris Version Numbers.</source>
          <target state="translated">Solaris Version Numbers.</target>
        </trans-unit>
        <trans-unit id="cc61dfb91810e5a0313350199a1b65c0af136cfa" translate="yes" xml:space="preserve">
          <source>Solaris global loading added by Nick Ing-Simmons with design/coding assistance from Tim Bunce, January 1996.</source>
          <target state="translated">Глобальная загрузка Solaris добавлена Ником Инг-Симмонсом с помощью дизайна/кодирования Тима Банса,январь 1996.</target>
        </trans-unit>
        <trans-unit id="708154fc528413c51483abd6933e68d503e36bdc" translate="yes" xml:space="preserve">
          <source>Solaris may include two versions of perl, e.g. Solaris 9 includes both 5.005_03 and 5.6.1. This is to provide stability across Solaris releases, in cases where a later perl version has incompatibilities with the version included in the preceding Solaris release. The default perl version will always be the most recent, and in general the old version will only be retained for one Solaris release. Note also that the default perl will NOT be configured to search for modules in the older version, again due to compatibility/stability concerns. As a consequence if you upgrade Solaris, you will have to rebuild/reinstall any additional CPAN modules that you installed for the previous Solaris version. See the CPAN manpage under 'autobundle' for a quick way of doing this.</source>
          <target state="translated">Solaris может включать две версии perl,например,Solaris 9 включает как 5.005_03,так и 5.6.1.Это необходимо для обеспечения стабильности во всех релизах Solaris в тех случаях,когда более поздняя версия perl несовместима с версией,включенной в предыдущий релиз Solaris.Перловая версия по умолчанию всегда будет самой последней,и,как правило,старая версия будет сохранена только в одном выпуске Solaris.Обратите также внимание,что perl по умолчанию НЕ будет настроен на поиск модулей в более старой версии,опять же по соображениям совместимости/стабильности.Как следствие,если вы обновите Solaris,вам придется пересобрать/переустановить все дополнительные модули CPAN,которые были установлены для предыдущей версии Solaris.Быстрый способ сделать это можно найти в меню CPAN в разделе &quot;Автоотборка&quot;.</target>
        </trans-unit>
        <trans-unit id="4bfa1cd2c976e4c546cb366d1dac1622384583a6" translate="yes" xml:space="preserve">
          <source>Solaris provides some BSD-compatibility functions in /usr/ucblib/libucb.a. Perl will not build and run correctly if linked against -lucb since it contains routines that are incompatible with the standard Solaris libc. Normally this is not a problem since the solaris hints file prevents Configure from even looking in /usr/ucblib for libraries, and also explicitly omits -lucb.</source>
          <target state="translated">Solaris предоставляет некоторые функции совместимости с BSD в файле /usr/ucblib/libucb.a.Perl не будет собираться и запускаться корректно,если он связан с -lucb,так как содержит подпрограммы,несовместимые со стандартной библиотекой Solaris libc.Обычно это не является проблемой,так как файл подсказок от Solaris не позволяет программе Configure даже искать в /usr/ucblib библиотеки,а также явно пропускает -lucb.</target>
        </trans-unit>
        <trans-unit id="d0c3f51965773ced91efb778a3671a3477592fd4" translate="yes" xml:space="preserve">
          <source>Solaris ships with a range of Solaris-specific modules. If you choose to install your own version of perl you will find the source of many of these modules is available on CPAN under the Sun::Solaris:: namespace.</source>
          <target state="translated">Корабли Solaris с рядом специфических модулей Solaris.Если вы решите установить свою собственную версию perl,вы найдете источник многих из этих модулей в CPAN под именем Sun::Solaris::.</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="05b004a92e5eda3ec6e47516b582fc25b61b35b9" translate="yes" xml:space="preserve">
          <source>Solutions</source>
          <target state="translated">Solutions</target>
        </trans-unit>
        <trans-unit id="00b2aad45d07b70e1b7eefea74316913901b6e42" translate="yes" xml:space="preserve">
          <source>Some</source>
          <target state="translated">Some</target>
        </trans-unit>
        <trans-unit id="5f679f54e4d0cf2197954f773a392f8d165d2696" translate="yes" xml:space="preserve">
          <source>Some (minor) parts copyright 2009 Adam Kennedy.</source>
          <target state="translated">Некоторые (незначительные)части авторского права 2009 Адам Кеннеди.</target>
        </trans-unit>
        <trans-unit id="3a644bfc8b4acacc1b56f8b5a49f0fbd16c47364" translate="yes" xml:space="preserve">
          <source>Some *nix programs use fork() a lot; with the mostly useful flavors of perl for OS/2 (there are several built simultaneously) this is supported; but some flavors do not support this (e.g., when Perl is called from inside REXX). Using fork() after</source>
          <target state="translated">Некоторые *nix-программы много используют fork();с наиболее полезными вкусами perl для OS/2 (есть несколько сборок одновременно)это поддерживается;но некоторые вкусы этого не поддерживают (например,когда Perl вызывается изнутри REXX).Использование fork()после</target>
        </trans-unit>
        <trans-unit id="6a808c47f9491da438c1507c81067e0d0ad1d610" translate="yes" xml:space="preserve">
          <source>Some / became \ in pdksh.</source>
          <target state="translated">Некоторые/стал \ в pdksh.</target>
        </trans-unit>
        <trans-unit id="2ced2108dbb21d847b539e5bf8d6eae4e6952b9e" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;/&lt;/code&gt; became &lt;code&gt;\&lt;/code&gt; in pdksh.</source>
          <target state="translated">Какой-то &lt;code&gt;/&lt;/code&gt; стал &lt;code&gt;\&lt;/code&gt; в пдкш.</target>
        </trans-unit>
        <trans-unit id="aee5f872bb2cc36da4c3ed1ff4e14aea96b6faa3" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;Win*&lt;/code&gt; entry points also overload a &quot;meaningful&quot; return value with the error indicator; having a 0 return value indicates an error. Yet some other &lt;code&gt;Win*&lt;/code&gt; entry points overload things even more, and 0 return value may mean a successful call returning a valid value 0, as well as an error condition; in the case of a 0 return value one should call WinGetLastError() API to distinguish a successful call from a failing one.</source>
          <target state="translated">Некоторые точки входа &lt;code&gt;Win*&lt;/code&gt; также перегружают &quot;значимое&quot; возвращаемое значение индикатором ошибки; возвращаемое значение 0 указывает на ошибку. Однако некоторые другие точки входа &lt;code&gt;Win*&lt;/code&gt; еще больше перегружают ситуацию, и возвращаемое значение 0 может означать успешный вызов, возвращающий действительное значение 0, а также состояние ошибки; в случае возвращаемого значения 0 следует вызвать API WinGetLastError (), чтобы отличить успешный вызов от неудачного.</target>
        </trans-unit>
        <trans-unit id="7d77130c6b6fd9352c737bed1bb1dcb935bd9ca9" translate="yes" xml:space="preserve">
          <source>Some DLLs are only present in some versions of OS/2, or in some configurations of OS/2. Some exported entry points are present only in DLLs shipped with some versions of OS/2. If these DLLs and entry points were linked directly for a Perl executable/DLL or from a Perl extensions, this binary would work only with the specified versions/setups. Even if these entry points were not needed, the</source>
          <target state="translated">Некоторые DLL присутствуют только в некоторых версиях OS/2 или в некоторых конфигурациях OS/2.Некоторые экспортированные точки входа присутствуют только в DLL,поставляемых с некоторыми версиями OS/2.Если бы эти DLL и точки входа были напрямую связаны с исполняемым файлом/ДЛЛ или с расширением Perl,то этот двоичный файл работал бы только с указанными версиями/настройками.Даже если бы эти точки входа не были нужны,то</target>
        </trans-unit>
        <trans-unit id="14adc2a370c74e9f0b7a6eb136961fb44f4e9d5e" translate="yes" xml:space="preserve">
          <source>Some IBM EBCDIC character sets may be known by character code set identification numbers (CCSID numbers) or code page numbers.</source>
          <target state="translated">Некоторые наборы символов IBM EBCDIC могут быть известны по идентификационным номерам наборов символов (CCSID-номера)или номерам кодовых страниц.</target>
        </trans-unit>
        <trans-unit id="20970d609d169c267b614af470114dc6b026c453" translate="yes" xml:space="preserve">
          <source>Some Irix cc versions, e.g. 7.3.1.1m (try cc -version) have been known to have issues (coredumps) when compiling perl.c. If you've used -OPT:fast_io=ON and this happens, try removing it. If that fails, or you didn't use that, then try adjusting other optimization options (-LNO, -INLINE, -O3 to -O2, etcetera). The compiler bug has been reported to SGI. (Allen Smith &amp;lt;easmith@beatrice.rutgers.edu&amp;gt;)</source>
          <target state="translated">Известно, что некоторые версии Irix cc, например 7.3.1.1m (попробуйте cc -version), имеют проблемы (coredump) при компиляции perl.c. Если вы использовали -OPT: fast_io = ON и это случилось, попробуйте удалить его. Если это не помогло или вы не использовали это, попробуйте настроить другие параметры оптимизации (-LNO, -INLINE, -O3 на -O2 и т. Д.). Об ошибке компилятора было сообщено в SGI. (Аллен Смит &amp;lt;easmith@beatrice.rutgers.edu&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="e270800f9e2c9ef58198c6c9f8463f63bac86a3b" translate="yes" xml:space="preserve">
          <source>Some Linux platforms have a maximum stack size. Setting too large of a stack size will cause thread creation to fail.</source>
          <target state="translated">Некоторые платформы Linux имеют максимальный размер стека.Установка слишком большого размера стека приведет к неудачному созданию потока.</target>
        </trans-unit>
        <trans-unit id="bad9f67e1f3cb77c4fe9db59234d0c5d6bb841b2" translate="yes" xml:space="preserve">
          <source>Some OSes do not need these in which case leave it blank.</source>
          <target state="translated">Некоторым операционным системам они не нужны,в этом случае оставьте их пустыми.</target>
        </trans-unit>
        <trans-unit id="69e7c8fdafb5d76df4c8f736ecf437657f4dc150" translate="yes" xml:space="preserve">
          <source>Some Pod formatters output to formats that implement non-breaking spaces as an individual character (which I'll call &quot;NBSP&quot;), and others output to formats that implement non-breaking spaces just as spaces wrapped in a &quot;don't break this across lines&quot; code. Note that at the level of Pod, both sorts of codes can occur: Pod can contain a NBSP character (whether as a literal, or as a &quot;E&amp;lt;160&amp;gt;&quot; or &quot;E&amp;lt;nbsp&amp;gt;&quot; code); and Pod can contain &quot;S&amp;lt;foo I&amp;lt;bar&amp;gt; baz&amp;gt;&quot; codes, where &quot;mere spaces&quot; (character 32) in such codes are taken to represent non-breaking spaces. Pod parsers should consider supporting the optional parsing of &quot;S&amp;lt;foo I&amp;lt;bar&amp;gt; baz&amp;gt;&quot; as if it were &quot;foo</source>
          <target state="translated">Некоторые средства форматирования Pod выводят в форматы, которые реализуют неразрывные пробелы как отдельный символ (который я назову &quot;NBSP&quot;), а другие - в форматы, которые реализуют неразрывные пробелы, точно так же, как пробелы, заключенные в &quot;не нарушайте это через строки &quot;кода. Обратите внимание, что на уровне Pod могут встречаться оба вида кодов: Pod может содержать символ NBSP (либо как буквальный, либо как код &amp;laquo;E &amp;lt;160&amp;gt;&amp;raquo; или &amp;laquo;E &amp;lt;nbsp&amp;gt;&amp;raquo;); и Pod может содержать коды &amp;laquo;S &amp;lt;foo I &amp;lt;bar&amp;gt; baz&amp;gt;&amp;raquo;, где &amp;laquo;простые пробелы&amp;raquo; (символ 32) в таких кодах используются для обозначения неразрывных пробелов. Парсерам Pod следует рассмотреть возможность поддержки необязательного анализа &quot;S &amp;lt;foo I &amp;lt;bar&amp;gt; baz&amp;gt;&quot;, как если бы это был &quot;foo</target>
        </trans-unit>
        <trans-unit id="f04294d93d5e63f6eed93e1148616595ef1487e2" translate="yes" xml:space="preserve">
          <source>Some Sys-V based systems, notably Solaris 2.X, redefined some of the standard socket constants. Since these were constant across all architectures, they were often hardwired into perl code. The proper way to deal with this is to &quot;use Socket&quot; to get the correct values.</source>
          <target state="translated">Некоторые системы на базе Sys-V,в частности Solaris 2.X,переопределили некоторые стандартные константы сокетов.Так как они были постоянными во всех архитектурах,они часто были жестко соединены в код на perl.Правильным способом решения этой проблемы является &quot;использование сокета&quot; для получения правильных значений.</target>
        </trans-unit>
        <trans-unit id="a5a0c5f6bf86975f2c301ba492652230f705bf5a" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; ; and there are only a few dozen possible General Categories.</source>
          <target state="translated">Некоторые свойства Unicode имеют ограниченный набор допустимых значений. Например, все двоичные свойства ограничены только &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; ; а возможных общих категорий всего несколько десятков.</target>
        </trans-unit>
        <trans-unit id="9e6eb6762559c642717c0b35b0e9407b4ea3c431" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; ; and there are only a few dozen possible General Categories. Use &lt;code&gt;prop_values&lt;/code&gt; to find out if a given property is one such, and if so, to get a list of the values:</source>
          <target state="translated">Некоторые свойства Unicode имеют ограниченный набор допустимых значений. Например, все двоичные свойства ограничены только &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; ; а возможных общих категорий всего несколько десятков. Используйте &lt;code&gt;prop_values&lt;/code&gt; , чтобы узнать, является ли данное свойство одним из таких, и если да, чтобы получить список значений:</target>
        </trans-unit>
        <trans-unit id="abd2e23e9cee0c22d7103f4f9a78d73d761dd3aa" translate="yes" xml:space="preserve">
          <source>Some approximate operating system names and their &lt;code&gt;$^O&lt;/code&gt; values in the &quot;OTHER&quot; category include:</source>
          <target state="translated">Некоторые приблизительные названия операционных систем и их значения &lt;code&gt;$^O&lt;/code&gt; в категории &amp;laquo;ДРУГОЕ&amp;raquo; включают:</target>
        </trans-unit>
        <trans-unit id="fc63731ea34f43c4af1c4ec405f7ea69ef1d9704" translate="yes" xml:space="preserve">
          <source>Some authors have strange characters in their names.</source>
          <target state="translated">У некоторых авторов в имени есть странные символы.</target>
        </trans-unit>
        <trans-unit id="6877eb2746dbad4bb0e9e27d968022bfea3412f0" translate="yes" xml:space="preserve">
          <source>Some background on thread implementations from the operating system viewpoint. There are three basic categories of threads: user-mode threads, kernel threads, and multiprocessor kernel threads.</source>
          <target state="translated">Некоторая подоплека реализации потоков с точки зрения операционной системы.Существует три основные категории потоков:потоки пользовательского режима,потоки ядра и многопроцессорные потоки ядра.</target>
        </trans-unit>
        <trans-unit id="fc0d6a626635ac5ae4291cc3487e50efd6ae5a14" translate="yes" xml:space="preserve">
          <source>Some bits may be relevant at compile-time only, some at run-time only. This is a new mechanism and the details may change. See also &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;.</source>
          <target state="translated">Некоторые биты могут иметь значение только во время компиляции, некоторые - только во время выполнения. Это новый механизм, и детали могут измениться. См. Также &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd8e9b1766f0e1e6eaaded7abc870a37e4571ff0" translate="yes" xml:space="preserve">
          <source>Some brief examples:</source>
          <target state="translated">Несколько кратких примеров:</target>
        </trans-unit>
        <trans-unit id="61327002f5b3861abd79c62e144ccb79536f4f22" translate="yes" xml:space="preserve">
          <source>Some builtins (e.g. &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt;) has a call signature that cannot completely be representated with a Perl prototype. This means that some valid Perl code will be invalid under autodie. As an example:</source>
          <target state="translated">Некоторые встроенные команды (например, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; ) имеют сигнатуру вызова, которую нельзя полностью представить с помощью прототипа Perl. Это означает, что какой-то действующий код Perl будет недействителен при автозаполнении. Например:</target>
        </trans-unit>
        <trans-unit id="21eaccc7842c81c4d4f8ac981ea6b511271286ba" translate="yes" xml:space="preserve">
          <source>Some calls simply aren't available, real or emulated, on every platform.</source>
          <target state="translated">Некоторые звонки просто недоступны,реальные или эмулированные,на каждой платформе.</target>
        </trans-unit>
        <trans-unit id="7144ad6e6fa073f902e93d5905df49ebac937d92" translate="yes" xml:space="preserve">
          <source>Some code points also have abbreviated names, such as &quot;LF&quot; or &quot;NL&quot;. &lt;code&gt;viacode&lt;/code&gt; never returns these.</source>
          <target state="translated">Некоторые кодовые точки также имеют сокращенные имена, такие как &amp;laquo;LF&amp;raquo; или &amp;laquo;NL&amp;raquo;. &lt;code&gt;viacode&lt;/code&gt; никогда их не возвращает.</target>
        </trans-unit>
        <trans-unit id="73ac6d49c092929d2ed08d514c7b1beb64ede02a" translate="yes" xml:space="preserve">
          <source>Some code taken from &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Catch&quot;&gt;Test::Catch&lt;/a&gt;, written by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;. Hence, those parts Copyright Micheal G Schwern 2001. Used and distributed with permission.</source>
          <target state="translated">Некоторый код взят из &lt;a href=&quot;../more&quot;&gt;Test :: More&lt;/a&gt; и &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Catch&quot;&gt;Test :: Catch&lt;/a&gt; , написанный Майклом Шверном &amp;lt;schwern@pobox.com&amp;gt;. Следовательно, эти части Copyright Micheal G Schwern 2001. Используется и распространяется с разрешения.</target>
        </trans-unit>
        <trans-unit id="a1339e50839100723841e8e48747e9f9a1f5bed3" translate="yes" xml:space="preserve">
          <source>Some constants and functions are exported by default by this module; but for backward-compatibility any recently-added symbols are not exported by default and must be requested explicitly. When an import list is provided to the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; line, the default exports are not automatically imported. It is therefore best practice to always to explicitly list all the symbols required.</source>
          <target state="translated">Некоторые константы и функции по умолчанию экспортируются этим модулем; но для обратной совместимости любые недавно добавленные символы не экспортируются по умолчанию и должны запрашиваться явно. Когда список импорта предоставляется в строке &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; , экспорт по умолчанию не импортируется автоматически. Поэтому рекомендуется всегда явно перечислять все необходимые символы.</target>
        </trans-unit>
        <trans-unit id="078dd465c32a4795a8e3e38bd49c7d92d32009a8" translate="yes" xml:space="preserve">
          <source>Some constants don't print correctly either with or without &lt;b&gt;-d&lt;/b&gt;. For instance, neither B::Deparse nor Data::Dumper know how to print dual-valued scalars correctly, as in:</source>
          <target state="translated">Некоторые константы не печатаются правильно ни с &lt;b&gt;-d,&lt;/b&gt; ни без него . Например, ни B :: Deparse, ни Data :: Dumper не знают, как правильно печатать двузначные скаляры, как в:</target>
        </trans-unit>
        <trans-unit id="0e689eba4cf9a38a4acdff5d45d4adaf1f020711" translate="yes" xml:space="preserve">
          <source>Some contexts allow 2 or even 1 digit, but any usage without exactly three digits, the first being a zero, may give unintended results. (For example, in a regular expression it may be confused with a backreference; see &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;Octal escapes in perlrebackslash&lt;/a&gt;.) Starting in Perl 5.14, you may use &lt;code&gt;\o{}&lt;/code&gt; instead, which avoids all these problems. Otherwise, it is best to use this construct only for ordinals &lt;code&gt;\077&lt;/code&gt; and below, remembering to pad to the left with zeros to make three digits. For larger ordinals, either use &lt;code&gt;\o{}&lt;/code&gt; , or convert to something else, such as to hex and use &lt;code&gt;\N{U+}&lt;/code&gt; (which is portable between platforms with different character sets) or &lt;code&gt;\x{}&lt;/code&gt; instead.</source>
          <target state="translated">Некоторые контексты позволяют использовать 2 или даже 1 цифру, но любое использование без ровно трех цифр, первая из которых - ноль, может дать непредвиденные результаты. (Например, в регулярном выражении его можно спутать с &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;обратной ссылкой&lt;/a&gt; ; см. Octal escape-последовательности в perlrebackslash .) Начиная с Perl 5.14, вы можете вместо этого использовать &lt;code&gt;\o{}&lt;/code&gt; , что позволяет избежать всех этих проблем. В противном случае лучше всего использовать эту конструкцию только для порядковых номеров &lt;code&gt;\077&lt;/code&gt; и ниже, не забывая заполнять слева нулями, чтобы получить три цифры. Для более крупных порядковых номеров используйте &lt;code&gt;\o{}&lt;/code&gt; или конвертируйте в другое, например в шестнадцатеричное, и используйте вместо него &lt;code&gt;\N{U+}&lt;/code&gt; (который переносится между платформами с разными наборами символов) или &lt;code&gt;\x{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17469d7643e0741d1ada43cbcada6ad7b4213174" translate="yes" xml:space="preserve">
          <source>Some cool command line examples to impress the Python crowd ;)</source>
          <target state="translated">Несколько классных примеров из командной строки,чтобы произвести впечатление на толпу Python ;)</target>
        </trans-unit>
        <trans-unit id="4f597c06196db5dfae23debf5b526fce9cd25685" translate="yes" xml:space="preserve">
          <source>Some cool command line examples to impress the Python crowd ;) You might want to compare them to the results under -Mbignum or -Mbigrat:</source>
          <target state="translated">Несколько классных примеров из командной строки,чтобы произвести впечатление на толпу Python ;)Возможно,вы захотите сравнить их с результатами в -Mbignum или -Mbigrat:</target>
        </trans-unit>
        <trans-unit id="c6746b978d2a5bd75b46a34b757950222f7e2d87" translate="yes" xml:space="preserve">
          <source>Some database drivers for DBI can also automatically encode and decode, but that is sometimes limited to the UTF-8 encoding.</source>
          <target state="translated">Некоторые драйверы баз данных для DBI также могут автоматически кодировать и декодировать,но иногда это ограничивается кодировкой UTF-8.</target>
        </trans-unit>
        <trans-unit id="20c968c59a29a0ad6a0ddbad176bb82749120644" translate="yes" xml:space="preserve">
          <source>Some devices will be expecting a &quot;\r&quot; at the end of each line rather than a &quot;\n&quot;. In some ports of perl, &quot;\r&quot; and &quot;\n&quot; are different from their usual (Unix) ASCII values of &quot;\015&quot; and &quot;\012&quot;. You may have to give the numeric values you want directly, using octal (&quot;\015&quot;), hex (&quot;0x0D&quot;), or as a control-character specification (&quot;\cM&quot;).</source>
          <target state="translated">Некоторые устройства будут ожидать в конце каждой строки &quot;\r&quot;,а не &quot;\n&quot;.В некоторых портах perl,&quot;\r&quot; и &quot;\n&quot; отличаются от своих обычных (Unix)ASCII-значений &quot;\015&quot; и &quot;\012&quot;.Вам может потребоваться указать нужные вам числовые значения напрямую,используя восьмеричное (&quot;\015&quot;),шестнадцатеричное (&quot;0x0D&quot;),или в качестве спецификации управляющего символа (&quot;\cM&quot;).</target>
        </trans-unit>
        <trans-unit id="b15270299f74ddedc9cb2a27cec0a8d56d430a18" translate="yes" xml:space="preserve">
          <source>Some digits that &lt;code&gt;\d&lt;/code&gt; matches look like some of the [0-9] ones, but have different values. For example, BENGALI DIGIT FOUR (U+09EA) looks very much like an ASCII DIGIT EIGHT (U+0038). An application that is expecting only the ASCII digits might be misled, or if the match is &lt;code&gt;\d+&lt;/code&gt; , the matched string might contain a mixture of digits from different writing systems that look like they signify a number different than they actually do. &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num() in Unicode::UCD&lt;/a&gt; can be used to safely calculate the value, returning &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the input string contains such a mixture.</source>
          <target state="translated">Некоторые цифры, которым соответствует &lt;code&gt;\d&lt;/code&gt; выглядят как цифры [0-9], но имеют разные значения. Например, BENGALI DIGIT FOUR (U + 09EA) очень похоже на ASCII DIGIT EIGHT (U + 0038). Приложение, которое ожидает только цифры ASCII, может быть введено в заблуждение, или, если совпадение равно &lt;code&gt;\d+&lt;/code&gt; , соответствующая строка может содержать смесь цифр из разных систем записи, которые выглядят так, как будто они обозначают число, отличное от того, что есть на самом деле. &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num () в Unicode :: UCD&lt;/a&gt; можно использовать для безопасного вычисления значения, возвращая &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если входная строка содержит такую ​​смесь.</target>
        </trans-unit>
        <trans-unit id="eb6208f023afd54f9f4acc30a7d493bf14dc6378" translate="yes" xml:space="preserve">
          <source>Some distributions may fail some tests, but you may want to install them anyway (as above, or via &lt;code&gt;force install&lt;/code&gt; command of &lt;code&gt;CPAN.pm&lt;/code&gt; shell-mode).</source>
          <target state="translated">Некоторые дистрибутивы могут не пройти некоторые тесты, но вы все равно можете их установить (как указано выше или с помощью команды &lt;code&gt;force install&lt;/code&gt; в &lt;code&gt;CPAN.pm&lt;/code&gt; оболочки CPAN.pm ).</target>
        </trans-unit>
        <trans-unit id="673083d85e2bc8b38798cec75fcc0568d074003d" translate="yes" xml:space="preserve">
          <source>Some distributions may need to link to libraries or other third-party code and their build and installation sequences may be more complicated. Check any</source>
          <target state="translated">Некоторые дистрибутивы могут нуждаться в ссылках на библиотеки или другой сторонний код,а их последовательность сборки и установки может быть более сложной.Проверьте любой</target>
        </trans-unit>
        <trans-unit id="e14b5226c1b3194a20df87855367bd2962c1e595" translate="yes" xml:space="preserve">
          <source>Some documentation is not available as man pages, so if a cross-reference is not found by man, try it with &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;. Perldoc can also take you directly to documentation for functions (with the &lt;b&gt;-f&lt;/b&gt; switch). See &lt;code&gt;perldoc --help&lt;/code&gt; (or &lt;code&gt;perldoc perldoc&lt;/code&gt; or &lt;code&gt;man perldoc&lt;/code&gt; ) for other helpful options &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; has to offer.</source>
          <target state="translated">Некоторая документация недоступна в виде страниц руководства, поэтому, если человек не нашел перекрестной ссылки, попробуйте ее с помощью &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; . Perldoc также может перенаправить вас прямо к документации по функциям (с ключом &lt;b&gt;-f&lt;/b&gt; ). См. &lt;code&gt;perldoc --help&lt;/code&gt; (или &lt;code&gt;perldoc perldoc&lt;/code&gt; или &lt;code&gt;man perldoc&lt;/code&gt; ) для получения информации о других полезных опциях, &lt;a href=&quot;perldoc&quot;&gt;которые&lt;/a&gt; может предложить perldoc .</target>
        </trans-unit>
        <trans-unit id="24f338e775f9d8f25e87916116198ed5fdfd8fac" translate="yes" xml:space="preserve">
          <source>Some earlier versions of this module had docs with some confusing typos in the description of &lt;code&gt;skip(...)&lt;/code&gt; .</source>
          <target state="translated">В некоторых более ранних версиях этого модуля была документация с некоторыми сбивающими с толку опечатками в описании &lt;code&gt;skip(...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d5fff71fc694b06c17e66dad87b134506e2302b" translate="yes" xml:space="preserve">
          <source>Some essentially obsolete locales that aren't supersets of ASCII, mainly those in ISO 646 or other 7-bit locales, such as ASMO 449, can also have problems, depending on what portions of the ASCII character set get changed by the locale and are also used by the program. The warning message lists the determinable conflicting characters.</source>
          <target state="translated">Некоторые по сути устаревшие локали,не являющиеся суперсетями ASCII,в основном те,что в ISO 646 или других 7-битных локалях,таких как ASMO 449,также могут иметь проблемы,в зависимости от того,какие части набора символов ASCII изменяются локалью и также используются программой.Предупреждающее сообщение содержит список определяемых конфликтующих символов.</target>
        </trans-unit>
        <trans-unit id="e8b38cbb77fcb476bf8e2983ccfda5ed33f46a79" translate="yes" xml:space="preserve">
          <source>Some example section specifications follow.</source>
          <target state="translated">Ниже приведены некоторые примеры спецификаций разделов.</target>
        </trans-unit>
        <trans-unit id="6e29ae8ec1bfc30435ce56e5aeb3c20b82d6940f" translate="yes" xml:space="preserve">
          <source>Some examples of lists include:</source>
          <target state="translated">Некоторые примеры списков включают в себя:</target>
        </trans-unit>
        <trans-unit id="ae84b84bf5612613743104cf4d1d3f624e770f5d" translate="yes" xml:space="preserve">
          <source>Some examples of syntactically invalid attribute lists (with annotation):</source>
          <target state="translated">Некоторые примеры синтаксически неправильных списков атрибутов (с аннотацией):</target>
        </trans-unit>
        <trans-unit id="9c0e82c6c1b276d5dbb162e62c1346aa697136e3" translate="yes" xml:space="preserve">
          <source>Some examples of syntactically valid attribute lists:</source>
          <target state="translated">Некоторые примеры синтаксически корректных списков атрибутов:</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">Несколько примеров:</target>
        </trans-unit>
        <trans-unit id="75d23fa0c37e5a03812b09ef6b9c46fbb0fa3389" translate="yes" xml:space="preserve">
          <source>Some extensions provide filters on data entry/exit points, such as &lt;code&gt;DB_File::filter_store_key&lt;/code&gt; and family. Look out for such filters in the documentation of your extensions; they can make the transition to Unicode data much easier.</source>
          <target state="translated">Некоторые расширения предоставляют фильтры по точкам ввода / вывода данных, например &lt;code&gt;DB_File::filter_store_key&lt;/code&gt; и family. Обратите внимание на такие фильтры в документации к вашим расширениям; они могут значительно упростить переход к данным Unicode.</target>
        </trans-unit>
        <trans-unit id="1ba2d8223f5d5832c6d62c8b546d87c608dd84fc" translate="yes" xml:space="preserve">
          <source>Some extensions, like DB_File and Compress::Zlib use/require prebuilt libraries for the perl extensions/modules to work. If these libraries are built using the default configuration, it might happen that you run into an error like &quot;invalid loader fixup&quot; during load phase. HP is aware of this problem. Search the HP-UX cxx-dev forums for discussions about the subject. The short answer is that &lt;b&gt;everything&lt;/b&gt; (all libraries, everything) must be compiled with &lt;code&gt;+z&lt;/code&gt; or &lt;code&gt;+Z&lt;/code&gt; to be PIC (position independent code). (For gcc, that would be &lt;code&gt;-fpic&lt;/code&gt; or &lt;code&gt;-fPIC&lt;/code&gt; ). In HP-UX 11.00 or newer the linker error message should tell the name of the offending object file.</source>
          <target state="translated">Некоторые расширения, такие как DB_File и Compress :: Zlib, используют / требуют предварительно построенных библиотек для работы расширений / модулей perl. Если эти библиотеки построены с использованием конфигурации по умолчанию, может случиться так, что вы столкнетесь с ошибкой, такой как &amp;laquo;неверное исправление загрузчика&amp;raquo; на этапе загрузки. HP знает об этой проблеме. Поищите на форумах HP-UX cxx-dev обсуждение этой темы. Короткий ответ: &lt;b&gt;все&lt;/b&gt; (все библиотеки, все) должно быть скомпилировано с помощью &lt;code&gt;+z&lt;/code&gt; или &lt;code&gt;+Z&lt;/code&gt; , чтобы быть PIC (позиционно-независимым кодом). (Для gcc это будет &lt;code&gt;-fpic&lt;/code&gt; или &lt;code&gt;-fPIC&lt;/code&gt; ). В HP-UX 11.00 или новее в сообщении об ошибке компоновщика должно быть указано имя объектного файла, вызывающего нарушение.</target>
        </trans-unit>
        <trans-unit id="4b7fd53f722062eada03c99c5c0131726fe7cb4c" translate="yes" xml:space="preserve">
          <source>Some features of Storable can lead to security vulnerabilities if you accept Storable documents from untrusted sources. Most obviously, the optional (off by default) CODE reference serialization feature allows transfer of code to the deserializing process. Furthermore, any serialized object will cause Storable to helpfully load the module corresponding to the class of the object in the deserializing module. For manipulated module names, this can load almost arbitrary code. Finally, the deserialized object's destructors will be invoked when the objects get destroyed in the deserializing process. Maliciously crafted Storable documents may put such objects in the value of a hash key that is overridden by another key/value pair in the same hash, thus causing immediate destructor execution.</source>
          <target state="translated">Некоторые функции Storable могут привести к уязвимостям безопасности,если вы принимаете документы Storable из недоверенных источников.Очевидно,что опциональная (по умолчанию выключенная)функция CODE сериализации ссылок позволяет перенести код на процесс десериализации.Более того,любой сериализованный объект заставит Storable удобно загрузить модуль,соответствующий классу объекта в модуле десериализации.Для манипулирования именами модулей это может привести к загрузке практически произвольного кода.Наконец,деструкторы десериализованного объекта будут вызваны,когда объекты будут уничтожены в процессе десериализации.Злоумышленно созданные документы Storable могут поместить такие объекты в значение хэш-ключа,который переопределяется другой парой ключ/значение в том же хэше,вызывая тем самым немедленное выполнение деструктора.</target>
        </trans-unit>
        <trans-unit id="410f15ec6c766d4ad924aef6bed79d8486d14679" translate="yes" xml:space="preserve">
          <source>Some folks are surprised that &lt;code&gt;make distclean&lt;/code&gt; does not delete everything not listed in their MANIFEST (thus making a clean distribution) but only tells them what they need to delete. This is done because it is considered too dangerous. While developing your module you might write a new file, not add it to the MANIFEST, then run a &lt;code&gt;distclean&lt;/code&gt; and be sad because your new work was deleted.</source>
          <target state="translated">Некоторые удивляются, что &lt;code&gt;make distclean&lt;/code&gt; не удаляет все, что не указано в их МАНИФЕСТЕ (таким образом, создавая чистый дистрибутив), а только сообщает им, что им нужно удалить. Это сделано потому, что это считается слишком опасным. При разработке модуля вы можете написать новый файл, а не добавлять его в &lt;code&gt;distclean&lt;/code&gt; а затем запустить distclean и расстроиться , потому что ваша новая работа была удалена.</target>
        </trans-unit>
        <trans-unit id="278e93ddc6a44b33edbb2aa1b1e3252bdefc68ee" translate="yes" xml:space="preserve">
          <source>Some folks would prefer full alphanumeric prototypes. Alphanumerics have been intentionally left out of prototypes for the express purpose of someday in the future adding named, formal parameters. The current mechanism's main goal is to let module writers provide better diagnostics for module users. Larry feels the notation quite understandable to Perl programmers, and that it will not intrude greatly upon the meat of the module, nor make it harder to read. The line noise is visually encapsulated into a small pill that's easy to swallow.</source>
          <target state="translated">Некоторые предпочитают полные буквенно-цифровые прототипы.Буквенно-цифровые прототипы были намеренно оставлены без прототипов для того,чтобы когда-нибудь в будущем добавить именованные,формальные параметры.Основная цель текущего механизма-позволить авторам модулей обеспечить лучшую диагностику для пользователей модуля.Ларри чувствует,что нотация вполне понятна программистам на Perl,и что она не будет сильно мешать работе модуля,и не сделает ее более сложной для чтения.Шум линии визуально заключен в маленькую таблетку,которую легко проглотить.</target>
        </trans-unit>
        <trans-unit id="97b6babea6d7a1882a7f9edff1a7d1c57e6e6a28" translate="yes" xml:space="preserve">
          <source>Some format names that formatters currently are known to accept include &quot;roff&quot;, &quot;man&quot;, &quot;latex&quot;, &quot;tex&quot;, &quot;text&quot;, and &quot;html&quot;. (Some formatters will treat some of these as synonyms.)</source>
          <target state="translated">Некоторые имена форматов,которые форматоры в настоящее время принимают,включают &quot;roff&quot;,&quot;man&quot;,&quot;latex&quot;,&quot;tex&quot;,&quot;text&quot; и &quot;html&quot;.(Некоторые форматоры будут рассматривать некоторые из них как синонимы).</target>
        </trans-unit>
        <trans-unit id="bae9c58f7596d57c13463eeb374970b17faa09ff" translate="yes" xml:space="preserve">
          <source>Some frequently seen examples:</source>
          <target state="translated">Некоторые часто встречающиеся примеры:</target>
        </trans-unit>
        <trans-unit id="5f63fbe742ecc7df05393f6e705a1b34f98dd874" translate="yes" xml:space="preserve">
          <source>Some functions are provided to simplify customization.</source>
          <target state="translated">Некоторые функции предоставляются для упрощения настройки.</target>
        </trans-unit>
        <trans-unit id="37fca23bc4f77bc45e835fb641ab69a99facbd7e" translate="yes" xml:space="preserve">
          <source>Some functions are slower when working on UTF-8 encoded strings than on byte encoded strings. All functions that need to hop over characters such as &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, or matching regular expressions can work &lt;b&gt;much&lt;/b&gt; faster when the underlying data are byte-encoded.</source>
          <target state="translated">Некоторые функции работают медленнее при работе со строками в кодировке UTF-8, чем со строками в байтовой кодировке. Все функции, которым необходимо перескакивать через символы, такие как &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; , или соответствующие регулярные выражения, могут работать &lt;b&gt;намного&lt;/b&gt; быстрее, если базовые данные закодированы в байтах.</target>
        </trans-unit>
        <trans-unit id="83116620b210d6b01d6ea586806a731e05a2beb8" translate="yes" xml:space="preserve">
          <source>Some functions available based on the version of VMS. (VMS)</source>
          <target state="translated">Некоторые функции доступны на основе версии VMS.(ЗИС)</target>
        </trans-unit>
        <trans-unit id="851bf3122418d781546b0c8256e17049b7be4c91" translate="yes" xml:space="preserve">
          <source>Some languages work directly with the memory addresses of values, but this can be like playing with fire. Perl provides a set of asbestos gloves for handling all memory management. The closest to an address operator in Perl is the backslash operator, but it gives you a &lt;b&gt;hard reference&lt;/b&gt;, which is much safer than a memory address.</source>
          <target state="translated">Некоторые языки работают напрямую с адресами памяти значений, но это может быть похоже на игру с огнем. Perl предоставляет набор асбестовых перчаток для управления всей памятью. Наиболее близким к оператору адреса в Perl является оператор обратной косой черты, но он дает вам &lt;b&gt;жесткую ссылку&lt;/b&gt; , которая намного безопаснее, чем адрес памяти.</target>
        </trans-unit>
        <trans-unit id="f2704cdd835e2ffc2151c5b3e73d345acc2100f0" translate="yes" xml:space="preserve">
          <source>Some locales have special sorting rules.</source>
          <target state="translated">В некоторых местах есть специальные правила сортировки.</target>
        </trans-unit>
        <trans-unit id="4cbad0bcc8b3efd678863ec66e302790409bbb20" translate="yes" xml:space="preserve">
          <source>Some methods take slightly different arguments to those defined in &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; in attempt to make the interface more flexible. These are</source>
          <target state="translated">Некоторые методы принимают аргументы, немного отличающиеся от аргументов, определенных в &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc,&lt;/a&gt; чтобы сделать интерфейс более гибким. Эти</target>
        </trans-unit>
        <trans-unit id="4d5ca2cd44839d0147fa7ed895887914f1a8f96d" translate="yes" xml:space="preserve">
          <source>Some modules have an event loop, waiting for user-input. It is highly unlikely that two such modules would work adequately together in a single Perl application.</source>
          <target state="translated">Некоторые модули имеют цикл обработки событий,ожидающий пользовательского ввода.Весьма маловероятно,что два таких модуля будут адекватно работать вместе в одном Perl-приложении.</target>
        </trans-unit>
        <trans-unit id="99aeed54cc1e7c695f296661c28f743d9f582de7" translate="yes" xml:space="preserve">
          <source>Some modules have validation for particular types of input, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business::CreditCard&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email::Valid&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Validate::IP&quot;&gt;Data::Validate::IP&lt;/a&gt;.</source>
          <target state="translated">Некоторые модули имеют проверку для определенных типов ввода, таких как &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business :: ISBN&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business :: CreditCard&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email :: Valid&lt;/a&gt; и &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Validate::IP&quot;&gt;Data :: Validate :: IP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8896acdebb142a8bf319a25d0ebc467b0372d0f5" translate="yes" xml:space="preserve">
          <source>Some modules live both in the &lt;b&gt;Standard Library&lt;/b&gt; and on &lt;b&gt;CPAN&lt;/b&gt;. These modules might be developed on two tracks as people modify either version. The trend currently is to untangle these situations.</source>
          <target state="translated">Некоторые модули находятся как в &lt;b&gt;стандартной библиотеке, так&lt;/b&gt; и на &lt;b&gt;CPAN&lt;/b&gt; . Эти модули могут быть разработаны по двум направлениям, поскольку люди изменяют любую версию. В настоящее время существует тенденция распутывать эти ситуации.</target>
        </trans-unit>
        <trans-unit id="2536c5611f03605401087c295c560b8c0a55966f" translate="yes" xml:space="preserve">
          <source>Some modules might have special reporting requirements, such as a Github or Google Code tracking system, so you should check the module documentation too.</source>
          <target state="translated">Некоторые модули могут иметь специальные требования к отчетности,например,система отслеживания Github или Google Code,поэтому вам также следует проверить документацию по модулю.</target>
        </trans-unit>
        <trans-unit id="9d3dcbb265761ea263567338345aa34c90c2eea2" translate="yes" xml:space="preserve">
          <source>Some modules, mainly extensions, provide their own AUTOLOAD subroutines. They typically need to check for some special cases (such as constants) and then fallback to &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD for the rest.</source>
          <target state="translated">Некоторые модули, в основном расширения, предоставляют свои собственные подпрограммы AUTOLOAD. Обычно им необходимо проверить некоторые особые случаи (такие как константы), а затем вернуться к &lt;b&gt;AUTOLOAD&lt;/b&gt; AutoLoader для остальных.</target>
        </trans-unit>
        <trans-unit id="2c12ec8767768e2405ac12fa9dd3e5b3e02eaa4d" translate="yes" xml:space="preserve">
          <source>Some names known to &lt;code&gt;\N{...}&lt;/code&gt; refer to a sequence of multiple characters, instead of the usual single character. When one of these is included in the class, the entire sequence is matched. For example,</source>
          <target state="translated">Некоторые имена, известные для &lt;code&gt;\N{...}&lt;/code&gt; относятся к последовательности из нескольких символов вместо обычного одиночного символа. Когда один из них включен в класс, сопоставляется вся последовательность. Например,</target>
        </trans-unit>
        <trans-unit id="86874fce71a4882d328a8877cd2a4fc52a6a4fe2" translate="yes" xml:space="preserve">
          <source>Some networking library functions like gethostbyname() are known to have their own implementations of timeouts which may conflict with your timeouts. If you have problems with such functions, try using the POSIX sigaction() function, which bypasses Perl safe signals. Be warned that this does subject you to possible memory corruption, as described above.</source>
          <target state="translated">Некоторые функции сетевой библиотеки,такие как gethostbyname(),как известно,имеют свои собственные реализации таймаутов,которые могут конфликтовать с вашими таймаутами.Если у вас возникли проблемы с такими функциями,попробуйте использовать POSIX функцию sigaction(),которая обходит безопасные сигналы Perl.Предупреждаем,что это может привести к повреждению памяти,как описано выше.</target>
        </trans-unit>
        <trans-unit id="0ce6014b84ac6fe075f649ff6034ad219b7b909a" translate="yes" xml:space="preserve">
          <source>Some non-Perl implementations of the Age property may change its meaning to be the same as the Perl &lt;code&gt;Present_In&lt;/code&gt; property; just be aware of that.</source>
          <target state="translated">Некоторые реализации свойства Age, не относящиеся к Perl, могут изменить его значение на то же, что и свойство Perl &lt;code&gt;Present_In&lt;/code&gt; ; просто помните об этом.</target>
        </trans-unit>
        <trans-unit id="020d12e0872ef168546404b52284bd6940ecd187" translate="yes" xml:space="preserve">
          <source>Some non-numeric HTML entity name, such as &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; , meaning the same thing as &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; in HTML -- i.e., a lowercase e with an acute (/-shaped) accent.</source>
          <target state="translated">Некоторое нечисловое имя объекта HTML, например &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; , означающее то же самое, что &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; в HTML - строчная буква e с острым ударением (в форме /).</target>
        </trans-unit>
        <trans-unit id="742d524f056fc75f1015c7da11070249cb40a21b" translate="yes" xml:space="preserve">
          <source>Some notes about ftp archives: Please use a long descriptive file name that includes the version number. Most incoming directories will not be readable/listable, i.e., you won't be able to see your file after uploading it. Remember to send your email notification message as soon as possible after uploading else your file may get deleted automatically. Allow time for the file to be processed and/or check the file has been processed before announcing its location.</source>
          <target state="translated">Несколько заметок о ftp-архивах:Пожалуйста,используйте длинное описательное имя файла,включающее номер версии.Большинство входящих каталогов не будут доступны для чтения/лицензирования,т.е.Вы не сможете увидеть свой файл после его загрузки.Не забудьте отправить уведомление по электронной почте как можно скорее после загрузки,иначе Ваш файл может быть удален автоматически.Разрешите время для обработки файла и/или проверьте,был ли файл обработан,прежде чем объявлять о его местоположении.</target>
        </trans-unit>
        <trans-unit id="cc5039f425d422cec80636f2fe25c7aa8c335808" translate="yes" xml:space="preserve">
          <source>Some of the books we've listed appear almost ancient in internet scale, but we've included those books because they still describe the current way of doing things. Not everything in Perl changes every day. Many of the beginner-level books, too, go over basic features and techniques that are still valid today. In general though, we try to limit this list to books published in the past five years.</source>
          <target state="translated">Некоторые из книг,которые мы перечислили,кажутся почти древними в интернет-масштабе,но мы включили эти книги,потому что они до сих пор описывают современный порядок вещей.Не все в Перле меняется каждый день.Многие из книг начального уровня тоже перечисляют основные функции и приемы,которые действуют и по сей день.В целом,однако,мы стараемся ограничить этот список книгами,опубликованными за последние пять лет.</target>
        </trans-unit>
        <trans-unit id="ec6365cb89577ea447484ee46de59521b7dffa94" translate="yes" xml:space="preserve">
          <source>Some of the built-in functions do not act exactly as documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, and a few are not implemented at all. To avoid surprises, particularly if you have had prior exposure to Perl in other operating environments or if you intend to write code that will be portable to other environments, see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for a reasonably definitive list of these differences.</source>
          <target state="translated">Некоторые из встроенных функций работают не так, как &lt;a href=&quot;perlfunc&quot;&gt;описано&lt;/a&gt; в perlfunc , а некоторые вообще не реализованы. Чтобы избежать сюрпризов, особенно если вы ранее знакомы с Perl в других операционных средах или если вы намереваетесь написать код, который будет переноситься в другие среды, см. &lt;a href=&quot;perlport&quot;&gt;Perlport&lt;/a&gt; для получения достаточно точного списка этих различий.</target>
        </trans-unit>
        <trans-unit id="0c8239353496c2009cfe543c3292467ce35311ef" translate="yes" xml:space="preserve">
          <source>Some of the configuration files in /etc used by the networking APIs are either missing or have the wrong names. In particular, make sure that there's either an /etc/resolv.conf or an /etc/hosts, so that gethostbyname() works, and make sure that the file /etc/proto has been renamed to /etc/protocol (NOT /etc/protocols, as used by other Unix systems). You may have to look for things like HOSTNAME and DOMAINORIGIN in the &quot;//'SYS1.TCPPARMS(TCPDATA)'&quot; PDS member in order to properly set up your /etc networking files.</source>
          <target state="translated">Некоторые из конфигурационных файлов в /etc,используемых сетевыми API,либо отсутствуют,либо имеют неправильные имена.В частности,убедитесь,что существует либо /etc/resolv.conf,либо /etc/hosts,так что gethostbyname()работает,и убедитесь,что файл /etc/proto был переименован в /etc/protocol (NOT /etc/protocols,как используется другими Unix-системами).Возможно,Вам придется искать такие вещи,как HOSTNAME и DOMAINORIGIN в &quot;//'SYS1.TCPPARMS(TCPDATA)'&quot;.Член PDS для правильной настройки сетевых файлов /etc.</target>
        </trans-unit>
        <trans-unit id="c4c6dd767013c78841ab05e0e012ebcc93f26f14" translate="yes" xml:space="preserve">
          <source>Some of the examples later in &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; use the &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; module from CPAN. The reason you might choose &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; over the perl built-in functions is that it works with numbers of ANY size, that it is optimized for speed on some operations, and for at least some programmers the notation might be familiar.</source>
          <target state="translated">В некоторых примерах, приведенных ниже в &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4,&lt;/a&gt; используется модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt; из CPAN. Причина, по которой вы можете выбрать &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt; вместо встроенных функций perl, заключается в том, что он работает с числами ЛЮБОГО размера, оптимизирован для скорости выполнения некоторых операций и, по крайней мере, некоторым программистам эта нотация может быть знакома.</target>
        </trans-unit>
        <trans-unit id="b1b52c56fd19edbbc0804a6b9841658fb64d4030" translate="yes" xml:space="preserve">
          <source>Some of the functionality of the debugging code can be achieved using XS modules.</source>
          <target state="translated">Часть функциональности отладочного кода может быть реализована с помощью модулей XS.</target>
        </trans-unit>
        <trans-unit id="129d9d1e78c142ea547ff6b028cde8ebd0aadf7f" translate="yes" xml:space="preserve">
          <source>Some of the functions are called with a</source>
          <target state="translated">Некоторые из функций вызываются с помощью</target>
        </trans-unit>
        <trans-unit id="43704b45451eba3bea984abb31f94004f6ecfd41" translate="yes" xml:space="preserve">
          <source>Some of the highlights of &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;:</source>
          <target state="translated">Некоторые из основных моментов &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c35b9e6be7b3bf5bc03040d536fb7da8f901aae2" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from the &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; class. See &lt;a href=&quot;ftp/dataconn&quot;&gt;Net::FTP::dataconn&lt;/a&gt; for more details.</source>
          <target state="translated">Некоторые из методов, определенных в &lt;code&gt;Net::FTP&lt;/code&gt; возвращают объект, который будет производным от класса &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; . См. &lt;a href=&quot;ftp/dataconn&quot;&gt;Net :: FTP :: dataconn&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="085f62b2598cb482a6875006e876358d6d804f21" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from this class. The dataconn class itself is derived from the &lt;code&gt;IO::Socket::INET&lt;/code&gt; class, so any normal IO operations can be performed. However the following methods are defined in the dataconn class and IO should be performed using these.</source>
          <target state="translated">Некоторые из методов, определенных в &lt;code&gt;Net::FTP&lt;/code&gt; возвращают объект, производный от этого класса. Сам класс dataconn является производным от класса &lt;code&gt;IO::Socket::INET&lt;/code&gt; , поэтому могут выполняться любые обычные операции ввода-вывода. Однако следующие методы определены в классе dataconn, и ввод-вывод должен выполняться с их помощью.</target>
        </trans-unit>
        <trans-unit id="312d5ef79ec3abd87646ed6a59f9c68ae862462d" translate="yes" xml:space="preserve">
          <source>Some of the most common mistakes:</source>
          <target state="translated">Некоторые из самых распространенных ошибок:</target>
        </trans-unit>
        <trans-unit id="5796d9bed54a4c270451442098ed19f9f0088003" translate="yes" xml:space="preserve">
          <source>Some of the most common values are &lt;code&gt;O_RDONLY&lt;/code&gt; for opening the file in read-only mode, &lt;code&gt;O_WRONLY&lt;/code&gt; for opening the file in write-only mode, and &lt;code&gt;O_RDWR&lt;/code&gt; for opening the file in read-write mode.</source>
          <target state="translated">Некоторые из наиболее распространенных значений: &lt;code&gt;O_RDONLY&lt;/code&gt; для открытия файла в режиме только для чтения, &lt;code&gt;O_WRONLY&lt;/code&gt; для открытия файла в режиме только для записи и &lt;code&gt;O_RDWR&lt;/code&gt; для открытия файла в режиме чтения-записи.</target>
        </trans-unit>
        <trans-unit id="d5f4367d2cd66fe5bca2400a4df459be12cf9924" translate="yes" xml:space="preserve">
          <source>Some of the parser default template files in /samples are needed in /etc. In particular be sure that you at least copy /samples/yyparse.c to /etc before running Perl's Configure. This step ensures successful extraction of EBCDIC versions of parser files such as perly.c and perly.h. This has to be done before running Configure the first time. If you failed to do so then the easiest way to re-Configure Perl is to delete your misconfigured build root and re-extract the source from the tar ball. Then you must ensure that /etc/yyparse.c is properly in place before attempting to re-run Configure.</source>
          <target state="translated">Некоторые из шаблонных файлов по умолчанию парсера в /samples необходимы в /etc.В частности,убедитесь,что вы по крайней мере скопировали /samples/yyparse.c в /etc перед запуском Perl's Configure.Этот шаг обеспечит успешное извлечение EBCDIC версий парсерных файлов,таких как perly.c и perly.h.Это должно быть сделано перед первым запуском Configure.Если вы этого не сделали,то самым простым способом повторной настройки Perl является удаление неправильно настроенного корня сборки и повторное извлечение исходного текста из tar-шарика.Затем вы должны убедиться,что /etc/yyparse.c находится на месте,прежде чем пытаться выполнить повторную настройку.</target>
        </trans-unit>
        <trans-unit id="83c0811a95d044951ce0ba50edb2e9cd1f45c8cb" translate="yes" xml:space="preserve">
          <source>Some of the reported info, such as hex addresses, is not particularly valuable. Other information would be more useful for the typical programmer, such as line-numbers, pad-slot reuses, etc.. Given this, -newlex is not a particularly good flag-name.</source>
          <target state="translated">Некоторая сообщенная информация,такая как шестнадцатеричные адреса,не представляет особой ценности.Другая информация была бы более полезной для типичного программиста,например,номера строк,повторное использование пэд-слота и т.д..Учитывая это,-newlex не является особенно хорошим флагманским именем.</target>
        </trans-unit>
        <trans-unit id="2cdf99bdb0c6c762dab8d358da246b612330e8fa" translate="yes" xml:space="preserve">
          <source>Some of these are also deprecated. You can exclude these from your compiled Perl by adding this option to Configure: &lt;code&gt;-Accflags='-DNO_MATHOMS'&lt;/code&gt;</source>
          <target state="translated">Некоторые из них также устарели. Вы можете исключить их из вашего скомпилированного Perl, добавив эту опцию в Configure: &lt;code&gt;-Accflags='-DNO_MATHOMS'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d94da1d47f6dfef189dc9a92fab735da2e9c93d7" translate="yes" xml:space="preserve">
          <source>Some of these books are available as free downloads.</source>
          <target state="translated">Некоторые из этих книг доступны для бесплатного скачивания.</target>
        </trans-unit>
        <trans-unit id="55b425b2a6fe515905b997d3820e2d955eabc2cf" translate="yes" xml:space="preserve">
          <source>Some of these functions also combine dynaloading semantic with the error-propagation semantic discussed above.</source>
          <target state="translated">Некоторые из этих функций также сочетают диналозирующий семантик с рассмотренным выше семантиком с раскладкой ошибок.</target>
        </trans-unit>
        <trans-unit id="7a3b090758880601b5c97fb9b694e1e73a3369bc" translate="yes" xml:space="preserve">
          <source>Some of these methods might be of interest to general users, as well as of interest to formatter-writers.</source>
          <target state="translated">Некоторые из этих методов могут представлять интерес для обычных пользователей,а также для писателей-форматоров.</target>
        </trans-unit>
        <trans-unit id="80eb2a0ac01474685656b9eca0e98318c5698b3f" translate="yes" xml:space="preserve">
          <source>Some of these pseudo-modules import semantics into the current block scope (like &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;integer&lt;/code&gt; , unlike ordinary modules, which import symbols into the current package (which are effective through the end of the file).</source>
          <target state="translated">Некоторые из этих псевдомодулей импортируют семантику в текущую область видимости блока (например, &lt;code&gt;strict&lt;/code&gt; или &lt;code&gt;integer&lt;/code&gt; , в отличие от обычных модулей, которые импортируют символы в текущий пакет (которые действуют до конца файла).</target>
        </trans-unit>
        <trans-unit id="8fc82daea8e525be9f1657205fd39cc94c0720ec" translate="yes" xml:space="preserve">
          <source>Some of these specific cases are shown as examples in other answers in this section of the perlfaq.</source>
          <target state="translated">Некоторые из этих конкретных случаев показаны в качестве примеров в других ответах в этом разделе perlfaq.</target>
        </trans-unit>
        <trans-unit id="7ac7dfacde52b03cada88bb1c11d6be2449d545b" translate="yes" xml:space="preserve">
          <source>Some of this may be confusing. Here's a handy reference to the ASCII CR and LF characters. You can print it out and stick it in your wallet.</source>
          <target state="translated">Кое-что из этого может сбить с толку.Вот удобная ссылка на ASCII CR и LF символы.Вы можете распечатать его и засунуть в бумажник.</target>
        </trans-unit>
        <trans-unit id="9436ec9fafb3dbaf8b6e8266e0c7a558118556b8" translate="yes" xml:space="preserve">
          <source>Some older Pod translators require paragraphs (including command paragraphs like &quot;=head2 Functions&quot;) to be separated by</source>
          <target state="translated">Некоторые старые переводчики Pod требуют,чтобы параграфы (включая параграфы команд типа &quot;=head2 Functions&quot;)были разделены следующим образом</target>
        </trans-unit>
        <trans-unit id="530312ef21d84b684c5534cd434fe4d79ac602e0" translate="yes" xml:space="preserve">
          <source>Some older versions of Berkeley DB had problems with fixed length records using the RECNO file format. This problem has been fixed since version 1.85 of Berkeley DB.</source>
          <target state="translated">Некоторые старые версии Berkeley DB имели проблемы с записями фиксированной длины с использованием формата файлов RECNO.Эта проблема была исправлена начиная с версии 1.85 Berkeley DB.</target>
        </trans-unit>
        <trans-unit id="4c2cd6192ba71ba66f15fbdbb416f6e8ad76580e" translate="yes" xml:space="preserve">
          <source>Some operating systems don't ship the CORE directory with their base perl install. To solve the problem, you likely need to install a perl development package such as perl-devel (CentOS, Fedora and other Redhat systems) or perl (Ubuntu and other Debian systems).</source>
          <target state="translated">Некоторые операционные системы не поставляют каталог CORE с их базовой установкой perl.Чтобы решить эту проблему,вам,скорее всего,потребуется установить пакет разработки на perl,такой как perl-devel (CentOS,Fedora и другие системы Redhat)или perl (Ubuntu и другие системы Debian).</target>
        </trans-unit>
        <trans-unit id="a0bcdb116909bbaf782dcc8531648c8104b0144b" translate="yes" xml:space="preserve">
          <source>Some operating systems have bugs in the kernel that make setuid scripts inherently insecure. Perl gives you a number of options (described in &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) to work around such systems.</source>
          <target state="translated">В некоторых операционных системах есть ошибки в ядре, которые делают сценарии setuid небезопасными. Perl дает вам несколько вариантов (описанных в &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; ) для обхода таких систем.</target>
        </trans-unit>
        <trans-unit id="2250e1a4559063fcac9cec7cc104374f3f26f7ef" translate="yes" xml:space="preserve">
          <source>Some operating systems may perform &lt;code&gt;IO::File::new()&lt;/code&gt; or &lt;code&gt;IO::File::open()&lt;/code&gt; on a directory without errors. This behavior is not portable and not suggested for use. Using &lt;code&gt;&lt;a href=&quot;../functions/opendir&quot;&gt;opendir()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;IO::Dir&lt;/code&gt; are suggested instead.</source>
          <target state="translated">Некоторые операционные системы могут выполнять &lt;code&gt;IO::File::new()&lt;/code&gt; или &lt;code&gt;IO::File::open()&lt;/code&gt; в каталоге без ошибок. Такое поведение не переносимо и не рекомендуется для использования. &lt;code&gt;&lt;a href=&quot;../functions/opendir&quot;&gt;opendir()&lt;/a&gt;&lt;/code&gt; использовать opendir () и &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;IO::Dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39015af4e836c35f8e25b30fad81d0e5afdfce43" translate="yes" xml:space="preserve">
          <source>Some operations may be slower for small numbers, but are significantly faster for big numbers. Other operations are now constant (O(1), like &lt;code&gt;bneg()&lt;/code&gt; , &lt;code&gt;babs()&lt;/code&gt; etc), instead of O(N) and thus nearly always take much less time. These optimizations were done on purpose.</source>
          <target state="translated">Некоторые операции могут быть медленнее для небольших чисел, но значительно быстрее для больших чисел. Другие операции теперь являются постоянными (O (1), например &lt;code&gt;bneg()&lt;/code&gt; , &lt;code&gt;babs()&lt;/code&gt; т.д.), а не O (N), и поэтому почти всегда занимают гораздо меньше времени. Эти оптимизации были сделаны специально.</target>
        </trans-unit>
        <trans-unit id="03ecacb543bf1cb170543843116f3f4c7e881ad8" translate="yes" xml:space="preserve">
          <source>Some other (not completely debugged) situations when FP flags change include some video drivers (?), and some operations related to creation of the windows. People who code &lt;b&gt;OpenGL&lt;/b&gt; may have more experience on this.</source>
          <target state="translated">К другим (не полностью отлаженным) ситуациям смены флагов FP относятся некоторые видеодрайверы (?) И некоторые операции, связанные с созданием окон. Люди, которые программируют &lt;b&gt;OpenGL,&lt;/b&gt; могут иметь в этом больше опыта.</target>
        </trans-unit>
        <trans-unit id="377fbf88a15d635b8d6d486abdf4ac17224b10a7" translate="yes" xml:space="preserve">
          <source>Some other IO modules don't belong to the perl core but can be loaded as well if they have been installed from CPAN. You can discover which ones exist by searching for &quot;^IO::&quot; on &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt;.</source>
          <target state="translated">Некоторые другие модули ввода-вывода не принадлежат ядру Perl, но также могут быть загружены, если они были установлены из CPAN. Вы можете узнать, какие из них существуют, выполнив поиск по запросу &amp;laquo;^ IO ::&amp;raquo; на &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7424cd4ab88fb33b2270b2db7bbe8e04cad5739e" translate="yes" xml:space="preserve">
          <source>Some output formats that do allow rendering &quot;L&amp;lt;...&amp;gt;&quot; codes as hypertext, might not allow the link-text to be formatted; in that case, formatters will have to just ignore that formatting.</source>
          <target state="translated">Некоторые форматы вывода, которые позволяют отображать коды &amp;laquo;L &amp;lt;...&amp;gt;&amp;raquo; в виде гипертекста, могут не допускать форматирования текста ссылки; в этом случае форматировщикам придется просто игнорировать это форматирование.</target>
        </trans-unit>
        <trans-unit id="e1a79a974eeb026992ad7b1bb5fab50968d6932c" translate="yes" xml:space="preserve">
          <source>Some passes discussed below are performed concurrently, but because their results are the same, we consider them individually. For different quoting constructs, Perl performs different numbers of passes, from one to four, but these passes are always performed in the same order.</source>
          <target state="translated">Некоторые из рассмотренных ниже пассов выполняются одновременно,но поскольку их результаты одинаковы,мы рассматриваем их индивидуально.Для различных конструкций цитирования Perl выполняет разное количество проходов,от одного до четырех,но эти проходы всегда выполняются в одном и том же порядке.</target>
        </trans-unit>
        <trans-unit id="7ae8fed66b51985370778e2e29c81e03a37d1f13" translate="yes" xml:space="preserve">
          <source>Some people get too used to writing things like:</source>
          <target state="translated">Некоторые люди слишком привыкают писать такие вещи,как..:</target>
        </trans-unit>
        <trans-unit id="970ff42e05d0088fd549cac2a995425a1e1eba68" translate="yes" xml:space="preserve">
          <source>Some people have reported encountering &quot;Out of memory!&quot; errors while trying to build Perl using GNU make binaries. If you encounter such trouble then try to download the source code kit and build GNU make from source to eliminate any such trouble. You might also find GNU make (as well as Perl and Apache) in the red-piece/book &quot;Open Source Software for OS/390 UNIX&quot;, SG24-5944-00 from IBM.</source>
          <target state="translated">Некоторые люди сообщали о том,что при попытке собрать Perl с помощью GNU они сталкивались с ошибками &quot;Out of memory!&quot;,делая двоичные файлы.Если вы столкнулись с такой проблемой,попробуйте загрузить комплект исходных текстов и собрать GNU make из исходных текстов,чтобы устранить любую такую проблему.Вы можете также найти GNU make (а также Perl и Apache)в красной части/книге &quot;Open Source Software for OS/390 UNIX&quot;,SG24-5944-00 от IBM.</target>
        </trans-unit>
        <trans-unit id="98c7c01703d39bcc6345fdf8d617292db8f23d37" translate="yes" xml:space="preserve">
          <source>Some people may be inclined to include an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in the above XSUB, rather than letting control fall through to the end. In those situations &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; should be used, instead. This will ensure that the XSUB stack is properly adjusted. Consult &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for other &lt;code&gt;XSRETURN&lt;/code&gt; macros.</source>
          <target state="translated">Некоторые люди могут быть склонны включить явный &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; в приведенный выше XSUB, вместо того, чтобы позволить контролю провалиться до конца. В таких ситуациях следует использовать &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; . Это обеспечит правильную настройку стека XSUB. Проконсультируйтесь с &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; по &lt;code&gt;XSRETURN&lt;/code&gt; других макросов XSRETURN .</target>
        </trans-unit>
        <trans-unit id="6b055a6a001cadf9ec7b3e638f2bc15cb8ed85e4" translate="yes" xml:space="preserve">
          <source>Some people may wish to outlaw barewords entirely. If you say</source>
          <target state="translated">Некоторые люди,возможно,захотят полностью запретить голые слова.Если вы скажете</target>
        </trans-unit>
        <trans-unit id="bae38a7d38c5d89eb67db6e4b702e604142997e5" translate="yes" xml:space="preserve">
          <source>Some people mistakenly regard this as a security problem. If your program does insecure things, and relies on people not knowing how to exploit those insecurities, it is not secure. It is often possible for someone to determine the insecure things and exploit them without viewing the source. Security through obscurity, the name for hiding your bugs instead of fixing them, is little security indeed.</source>
          <target state="translated">Некоторые люди ошибочно считают это проблемой безопасности.Если ваша программа делает небезопасные вещи и полагается на людей,не знающих,как использовать эти небезопасные вещи,то она небезопасна.Часто кто-то может определить незащищенные вещи и использовать их,не просматривая источник.Безопасность через неясность-название для сокрытия ваших ошибок вместо их исправления-на самом деле мало защищена.</target>
        </trans-unit>
        <trans-unit id="df10001a5e994bd1a3232bcb5d3f173424f0cd78" translate="yes" xml:space="preserve">
          <source>Some people need this and some people avoid it. For Perl, it&amp;rsquo;s an old way to say &lt;b&gt;I/O layer&lt;/b&gt;.</source>
          <target state="translated">Некоторым людям это нужно, а некоторым избегают. Для Perl это старый способ &lt;b&gt;обозначить уровень ввода-вывода&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="37ecbcdb1f8127ee6539d97d23e8c04d2e848681" translate="yes" xml:space="preserve">
          <source>Some people regard this as a security problem. If your program does insecure things and relies on people not knowing how to exploit those insecurities, it is not secure. It is often possible for someone to determine the insecure things and exploit them without viewing the source. Security through obscurity, the name for hiding your bugs instead of fixing them, is little security indeed.</source>
          <target state="translated">Некоторые считают это проблемой безопасности.Если ваша программа делает небезопасные вещи и полагается на людей,не знающих,как использовать эти небезопасные вещи,то она небезопасна.Часто кто-то может определить незащищенные вещи и использовать их,не просматривая источник.Безопасность через неясность-название для сокрытия ваших ошибок вместо их исправления-на самом деле мало защищена.</target>
        </trans-unit>
        <trans-unit id="646207c2365abd1daf6b5c56b0451ba2ee5e82de" translate="yes" xml:space="preserve">
          <source>Some platforms (Win32, AIX, VMS, OS/2, to name a few) require any function that is part of the public API (the shared Perl library) to be explicitly marked as exported. See the discussion about</source>
          <target state="translated">Некоторые платформы (Win32,AIX,VMS,OS/2,и т.д.)требуют,чтобы любая функция,являющаяся частью публичного API (разделяемая библиотека Perl),была явно помечена как экспортируемая.См.обсуждение о</target>
        </trans-unit>
        <trans-unit id="29e0751f43cf70fa1b809101e7e4735cf3d63955" translate="yes" xml:space="preserve">
          <source>Some platforms can't delete or rename files held open by the system, this limitation may also apply to changing filesystem metainformation like file permissions or owners. Remember to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; files when you are done with them. Don't &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt; an open file. Don't &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; a file already tied or opened; &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; it first.</source>
          <target state="translated">Некоторые платформы не могут удалять или переименовывать файлы, открытые системой, это ограничение может также применяться к изменению метаинформации файловой системы, например прав доступа к файлам или владельцев. Не забудьте &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; файлы, когда закончите с ними. Не &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; и не &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt; открытый файл. Не &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; и не &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; уже связанный или открытый файл; сначала &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; его.</target>
        </trans-unit>
        <trans-unit id="da26b78199e00ef73fdfb4bbe53a1032367ab8a7" translate="yes" xml:space="preserve">
          <source>Some platforms have a minimum thread stack size. Trying to set the stack size below this value will result in a warning, and the minimum stack size will be used.</source>
          <target state="translated">Некоторые платформы имеют минимальный размер стека потоков.Попытка установить размер стека ниже этого значения приведет к появлению предупреждения,и будет использован минимальный размер стека.</target>
        </trans-unit>
        <trans-unit id="bcf43713051466cf97d586bae0917d51d61ca30f" translate="yes" xml:space="preserve">
          <source>Some platforms have a minimum thread stack size. Trying to set the stack size below this value will result in the above warning, and the stack size will be set to the minimum.</source>
          <target state="translated">Некоторые платформы имеют минимальный размер стека потоков.Попытка установить размер стека ниже этого значения приведет к появлению приведенного выше предупреждения,а размер стека будет установлен на минимальный.</target>
        </trans-unit>
        <trans-unit id="a11c8787b6044982e680d4ae9bfff407819b6d1c" translate="yes" xml:space="preserve">
          <source>Some platforms have other categories, dealing with such things as measurement units and paper sizes. None of these are used directly by Perl, but outside operations that Perl interacts with may use these. See &lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;Not within the scope of use locale&lt;/a&gt; below.</source>
          <target state="translated">На некоторых платформах есть другие категории, касающиеся таких вещей, как единицы измерения и размеры бумаги. Ни один из них не используется непосредственно Perl, но внешние операции, с которыми Perl взаимодействует, могут их использовать. См. Раздел &amp;laquo; &lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;Локаль вне области использования&amp;raquo;&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="27d67098e269de48eafdad3480b3920c43ba2cb7" translate="yes" xml:space="preserve">
          <source>Some points to note:</source>
          <target state="translated">Следует отметить некоторые моменты:</target>
        </trans-unit>
        <trans-unit id="4d3653fc867e65c669e5c29b359dbebb9253c5c0" translate="yes" xml:space="preserve">
          <source>Some possible reasons: your inheritance is getting confused, you've misspelled the method name, or the object is of the wrong type. Check out &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for details about any of the above cases. You may also use &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;($object)&lt;/code&gt; to find out the class &lt;code&gt;$object&lt;/code&gt; was blessed into.</source>
          <target state="translated">Некоторые возможные причины: ваше наследование сбивается, вы неправильно написали имя метода или объект неправильного типа. Ознакомьтесь с &lt;a href=&quot;perlootut&quot;&gt;perlootut,&lt;/a&gt; чтобы узнать подробности о любом из вышеуказанных случаев. Вы также можете использовать &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;($object)&lt;/code&gt; чтобы узнать, в какой класс &lt;code&gt;$object&lt;/code&gt; был благословлен.</target>
        </trans-unit>
        <trans-unit id="7b61ffed7b1a69179adefb6f5756bdb1cb79574b" translate="yes" xml:space="preserve">
          <source>Some pragmas are lexically scoped--typically those that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable. Others affect the current package instead, like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; , which allow you to predeclare a variables or subroutines within a particular</source>
          <target state="translated">Некоторые прагмы имеют лексическую область видимости - обычно те, которые влияют на переменную подсказок &lt;code&gt;$^H&lt;/code&gt; Другие влияют на текущий пакет вместо этого, как &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; , которые позволяют predeclare переменных или подпрограмм в рамках конкретного</target>
        </trans-unit>
        <trans-unit id="ca977f551e014badc60a278bfe97ad872b1a03f5" translate="yes" xml:space="preserve">
          <source>Some problem (forget which ;-)</source>
          <target state="translated">Какая-то проблема (забудьте какая ;-)</target>
        </trans-unit>
        <trans-unit id="747d0cb3f2eb2365d2dd72ee766a74de28620e7d" translate="yes" xml:space="preserve">
          <source>Some problems are associated with using temporary files that reside on NFS file systems and it is recommended that a local filesystem is used whenever possible. Some of the security tests will most probably fail when the temp file is not local. Additionally, be aware that the performance of I/O operations over NFS will not be as good as for a local disk.</source>
          <target state="translated">Некоторые проблемы связаны с использованием временных файлов,которые находятся на файловых системах NFS,и рекомендуется по возможности использовать локальную файловую систему.Некоторые тесты безопасности,скорее всего,будут неудачными,когда временный файл не является локальным.Кроме того,имейте в виду,что производительность операций ввода/вывода через NFS будет не так хороша,как для локального диска.</target>
        </trans-unit>
        <trans-unit id="82690c6e6b8e4e473e3f2745d7358e432662fc95" translate="yes" xml:space="preserve">
          <source>Some processors may find that the &lt;code&gt;S&amp;lt;...&amp;gt;&lt;/code&gt; code is easiest to implement by replacing each space in the parse tree under the content of the S, with an NBSP. But note: the replacement should apply</source>
          <target state="translated">Некоторые процессоры могут обнаружить, что код &lt;code&gt;S&amp;lt;...&amp;gt;&lt;/code&gt; проще всего реализовать, заменив каждое пространство в дереве синтаксического анализа под содержимым S на NBSP. Но обратите внимание: замена должна применяться</target>
        </trans-unit>
        <trans-unit id="229ed6abc320881bbd15c4ddf8619bff82e22293" translate="yes" xml:space="preserve">
          <source>Some programmers choose to use an explicit conversion so as to leave nothing to doubt:</source>
          <target state="translated">Некоторые программисты предпочитают использовать явное преобразование,чтобы не оставлять никаких сомнений:</target>
        </trans-unit>
        <trans-unit id="76cff92347a8a5dd33b0b88b52afc87676bbe1d1" translate="yes" xml:space="preserve">
          <source>Some programmers may prefer to think of filehandles as objects with methods, preferring to write the last example as:</source>
          <target state="translated">Некоторые программисты могут предпочесть думать о файловых дескрипторах как об объектах с методами,предпочитая записать последний пример как:</target>
        </trans-unit>
        <trans-unit id="9293db7d23e9765c2433258535b9e48d3fd5d563" translate="yes" xml:space="preserve">
          <source>Some properties are considered obsolete by Unicode, but still available. There are several varieties of obsolescence:</source>
          <target state="translated">Некоторые свойства считаются устаревшими по Юникоду,но все еще доступны.Существует несколько разновидностей устаревания:</target>
        </trans-unit>
        <trans-unit id="8e185e2d007b85b8d377436c39a0c68b4b4f4ab1" translate="yes" xml:space="preserve">
          <source>Some rare applications will need to create more than one interpreter during a session. Such an application might sporadically decide to release any resources associated with the interpreter.</source>
          <target state="translated">Некоторые редкие приложения должны будут создавать более одного переводчика во время сеанса.Такое приложение может время от времени принимать решение об освобождении любых ресурсов,связанных с переводчиком.</target>
        </trans-unit>
        <trans-unit id="7c5ce3e6e9260f74f3afe8318024d986a7fd16de" translate="yes" xml:space="preserve">
          <source>Some regular expressions use identical subpatterns in several places. Starting with Perl 5.10, it is possible to define named subpatterns in a section of the pattern so that they can be called up by name anywhere in the pattern. This syntactic pattern for this definition group is &lt;code&gt;(?(DEFINE)(?&amp;lt;name&amp;gt;pattern)...)&lt;/code&gt;. An insertion of a named pattern is written as &lt;code&gt;(?&amp;amp;name)&lt;/code&gt;.</source>
          <target state="translated">Некоторые регулярные выражения используют одинаковые подшаблоны в нескольких местах. Начиная с Perl 5.10, можно определить именованные подшаблоны в разделе шаблона, чтобы их можно было вызывать по имени в любом месте шаблона. Этот синтаксический шаблон для этой группы определений - &lt;code&gt;(?(DEFINE)(?&amp;lt;name&amp;gt;pattern)...)&lt;/code&gt; . Вставка именованного шаблона записывается как &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58899e8b736f7c4726449bcec0f3b25df5fc7632" translate="yes" xml:space="preserve">
          <source>Some routines (&lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; ) return true or false, while others (&lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) return either undef, &amp;lt;0, 0 or &amp;gt;0 and are suited for sort.</source>
          <target state="translated">Некоторые процедуры ( &lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; ) возвращают true или false, в то время как другие ( &lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) возвращают undef, &amp;lt;0, 0 или&amp;gt; 0 и подходят для сортировки.</target>
        </trans-unit>
        <trans-unit id="834cc437cec84afae22c004e80ee3d6149cb6f55" translate="yes" xml:space="preserve">
          <source>Some routines (&lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; , etc.) return true or false, while others (&lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) return either undef (if NaN is involved), &amp;lt;0, 0 or &amp;gt;0 and are suited for sort.</source>
          <target state="translated">Некоторые подпрограммы ( &lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; и т. Д.) Возвращают true или false, в то время как другие ( &lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) возвращают либо undef (если задействовано NaN. ), &amp;lt;0, 0 или&amp;gt; 0 и подходят для сортировки.</target>
        </trans-unit>
        <trans-unit id="b07ef2379b9c2b49ab7fe4b04878c3104f0be76f" translate="yes" xml:space="preserve">
          <source>Some scalar variables contain more than one type of scalar data. For example, the variable &lt;code&gt;$!&lt;/code&gt; contains either the numeric value of &lt;code&gt;errno&lt;/code&gt; or its string equivalent from either &lt;code&gt;strerror&lt;/code&gt; or &lt;code&gt;sys_errlist[]&lt;/code&gt; .</source>
          <target state="translated">Некоторые скалярные переменные содержат более одного типа скалярных данных. Например, переменная &lt;code&gt;$!&lt;/code&gt; содержит либо числовое значение &lt;code&gt;errno&lt;/code&gt; , либо его строковый эквивалент из &lt;code&gt;strerror&lt;/code&gt; или &lt;code&gt;sys_errlist[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b802bf6a4f1848df9acbe46a4e2a4fe02ad51578" translate="yes" xml:space="preserve">
          <source>Some scripts, usually identified with a *.PL extension, are self-configuring and are able to correctly create their own shebang path from config information located in Plan 9 Perl. These you won't need to be worried about.</source>
          <target state="translated">Некоторые скрипты,обычно идентифицируемые с расширением *.PL,являются самонастраивающимися и могут корректно создавать свой собственный путь к ней из конфигурационной информации,находящейся в Plan 9 Perl.О них вам не нужно будет беспокоиться.</target>
        </trans-unit>
        <trans-unit id="0de1611bc5300339bfc467a34c6fb8f9747fd7ed" translate="yes" xml:space="preserve">
          <source>Some servers are configured to only work in passive mode. If you have one of these you can force &lt;code&gt;Net::FTP&lt;/code&gt; to always transfer in passive mode; when not going via a firewall, by setting &lt;code&gt;ftp_int_passive&lt;/code&gt; to a</source>
          <target state="translated">Некоторые серверы настроены на работу только в пассивном режиме. Если у вас есть один из них, вы можете заставить &lt;code&gt;Net::FTP&lt;/code&gt; всегда передавать данные в пассивном режиме; если вы не используете брандмауэр, установив &lt;code&gt;ftp_int_passive&lt;/code&gt; на</target>
        </trans-unit>
        <trans-unit id="ebc3655c5b01cc226f09d2ace7c8e5f430f35ebd" translate="yes" xml:space="preserve">
          <source>Some servers do not understand this command, but issuing it and ignoring the response is harmless.</source>
          <target state="translated">Некоторые серверы не понимают эту команду,но выдача ее и игнорирование ответа безвредны.</target>
        </trans-unit>
        <trans-unit id="c3d7fb888727f4ae5ed3bb068213cd5f194d2bf2" translate="yes" xml:space="preserve">
          <source>Some signals can be neither trapped nor ignored, such as the KILL and STOP (but not the TSTP) signals. Note that ignoring signals makes them disappear. If you only want them blocked temporarily without them getting lost you'll have to use POSIX' sigprocmask.</source>
          <target state="translated">Некоторые сигналы не могут быть ни захвачены,ни проигнорированы,например,сигналы KILL и STOP (но не TSTP).Обратите внимание,что игнорирование сигналов заставляет их исчезнуть.Если вы хотите,чтобы они только временно блокировались,не теряясь,вам придется использовать sigprocmask POSIX.</target>
        </trans-unit>
        <trans-unit id="2bcba60d06f3c08a852e1ccedb100d4bd2f6af23" translate="yes" xml:space="preserve">
          <source>Some simple style guidelines</source>
          <target state="translated">Некоторые простые рекомендации по стилю</target>
        </trans-unit>
        <trans-unit id="0a3063c3a46746b861b03ccbf2777db3ca544d44" translate="yes" xml:space="preserve">
          <source>Some simple tricks for determining if you are running on an EBCDIC platform could include any of the following (perhaps all):</source>
          <target state="translated">Некоторые простые трюки для определения,работаете ли вы на платформе EBCDIC,могут включать в себя любое из следующих (возможно,все):</target>
        </trans-unit>
        <trans-unit id="038ab8e08e45dcac2b1a2ba44edc5e7ade978952" translate="yes" xml:space="preserve">
          <source>Some source filters use the &lt;code&gt;DATA&lt;/code&gt; handle to read the calling program. When using these source filters you cannot rely on this handle, nor expect any particular kind of behavior when operating on it. Filters based on Filter::Util::Call (and therefore Filter::Simple) do not alter the &lt;code&gt;DATA&lt;/code&gt; filehandle.</source>
          <target state="translated">Некоторые исходные фильтры используют дескриптор &lt;code&gt;DATA&lt;/code&gt; для чтения вызывающей программы. При использовании этих исходных фильтров вы не можете полагаться на этот дескриптор или ожидать какого-либо конкретного поведения при работе с ним. Фильтры на основе Filter :: Util :: Call (и, следовательно, Filter :: Simple) не изменяют дескриптор файла &lt;code&gt;DATA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b3ebd295e43b2c81df8bd4b9c3baef266ee5f66" translate="yes" xml:space="preserve">
          <source>Some switches do care if they are processed twice, for instance combinations of &lt;b&gt;-l&lt;/b&gt; and &lt;b&gt;-0&lt;/b&gt;. Either put all the switches after the 32-character boundary (if applicable), or replace the use of &lt;b&gt;-0&lt;/b&gt;</source>
          <target state="translated">Некоторые переключатели заботятся о том, обрабатываются ли они дважды, например, комбинации &lt;b&gt;-l&lt;/b&gt; и &lt;b&gt;-0&lt;/b&gt; . Либо поместите все переключатели после границы из 32 символов (если применимо), либо замените использование &lt;b&gt;-0&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c346e3627bcf4ba52fad903600add2510035afb4" translate="yes" xml:space="preserve">
          <source>Some systems defined &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; in terms of &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;, in which a call to &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; is essentially:</source>
          <target state="translated">Некоторые системы определяют &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; в терминах &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; , в которой вызов &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; по существу:</target>
        </trans-unit>
        <trans-unit id="6fc6b04b810684b6c41fe63810499cab8b09c739" translate="yes" xml:space="preserve">
          <source>Some systems defined &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; in terms of &lt;code&gt;&lt;a href=&quot;socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;, in which a call to &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; is essentially:</source>
          <target state="translated">Некоторые системы определяют &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; в терминах &lt;code&gt;&lt;a href=&quot;socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; , в которой вызов &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; по существу:</target>
        </trans-unit>
        <trans-unit id="ec2cddcb7714cb3145808dbf1959d4cf532d708d" translate="yes" xml:space="preserve">
          <source>Some systems have APIs but not implementations: for example QNX and Haiku have the interval timer APIs but not the functionality.</source>
          <target state="translated">Некоторые системы имеют API,но не реализации:например QNX и Haiku имеют API интервального таймера,но не функциональность.</target>
        </trans-unit>
        <trans-unit id="f1b5dcc57517fdbe334dfa953d44b8287e96b48c" translate="yes" xml:space="preserve">
          <source>Some systems may have even weirder byte orders such as</source>
          <target state="translated">Некоторые системы могут иметь еще более странные порядки байтов,такие как</target>
        </trans-unit>
        <trans-unit id="6223cb44b81823af78522ece7689e7171de5236a" translate="yes" xml:space="preserve">
          <source>Some systems use CONFORMING TO to note conformance to relevant standards and MT-LEVEL to note safeness for use in threaded programs or signal handlers. These headings are primarily useful when documenting parts of a C library.</source>
          <target state="translated">Некоторые системы используют КОНФОРМИНГ,чтобы отметить соответствие соответствующим стандартам и MT-LEVEL,чтобы отметить безопасность для использования в резьбовых программах или обработчиках сигналов.Эти заголовки в первую очередь полезны при документировании частей Си-библиотеки.</target>
        </trans-unit>
        <trans-unit id="b5f78f639815d7596cee6bf607be57c18273af36" translate="yes" xml:space="preserve">
          <source>Some test failures may occur if you use a command shell other than the native &quot;cmd.exe&quot;, or if you are building from a path that contains spaces. So don't do that.</source>
          <target state="translated">Некоторые ошибки теста могут возникнуть,если вы используете командную оболочку,отличную от родной &quot;cmd.exe&quot;,или если вы строите из пути,содержащего пробелы.Так что не делайте этого.</target>
        </trans-unit>
        <trans-unit id="ec70ba84fc671de1bea2095d64f0ecee13115e62" translate="yes" xml:space="preserve">
          <source>Some tests are known to fail:</source>
          <target state="translated">Некоторые тесты,как известно,провалились:</target>
        </trans-unit>
        <trans-unit id="75d98556687379d0793051b330180895e416a427" translate="yes" xml:space="preserve">
          <source>Some tests may complain under known circumstances.</source>
          <target state="translated">Некоторые тесты могут жаловаться при известных обстоятельствах.</target>
        </trans-unit>
        <trans-unit id="c1340d9e04d7bf928c677a3bd6e8e8121f7021a3" translate="yes" xml:space="preserve">
          <source>Some tests may generate extra messages similar to</source>
          <target state="translated">Некоторые тесты могут генерировать дополнительные сообщения,похожие на</target>
        </trans-unit>
        <trans-unit id="81c36c454152688ffa8f0d5944c5eae241cf584a" translate="yes" xml:space="preserve">
          <source>Some tests will be skipped because they need the fork() function:</source>
          <target state="translated">Некоторые тесты будут пропущены,так как им нужна функция fork():</target>
        </trans-unit>
        <trans-unit id="ae4dfb05b376af0b4aa8499ceeb5ad1587cfc612" translate="yes" xml:space="preserve">
          <source>Some things might not work as you expect them. Below is documented what is known to be troublesome:</source>
          <target state="translated">Некоторые вещи могут работать не так,как вы ожидаете.Ниже задокументировано то,что,как известно,причиняет беспокойство:</target>
        </trans-unit>
        <trans-unit id="c22086010db6828bca64b97b121f052c5aaeaeec" translate="yes" xml:space="preserve">
          <source>Some time ago I had reports it does not work. Nowadays it is checked in the Perl test suite, so grep</source>
          <target state="translated">Некоторое время назад у меня были сообщения,что это не работает.Сейчас он проверяется в тестовом наборе Perl,так что grep...</target>
        </trans-unit>
        <trans-unit id="729fe9bb5c1721be7b9c47b47d38d0043a1d5be9" translate="yes" xml:space="preserve">
          <source>Some types of lvalues can be localized as well: hash and array elements and slices, conditionals (provided that their result is always localizable), and symbolic references. As for simple variables, this creates new, dynamically scoped values.</source>
          <target state="translated">Также могут быть локализованы некоторые типы значений:хэш-элементы и срезы массива,условные (при условии,что их результат всегда локализуем)и символические ссылки.Что касается простых переменных,то при этом создаются новые,динамически просматриваемые значения.</target>
        </trans-unit>
        <trans-unit id="36c279e82d37aef763f2dc425df33d302f2edc2c" translate="yes" xml:space="preserve">
          <source>Some unusual systems, such as VMS, require special filename handling in order to deal with symbolic names for files (i.e., VMS's Logical Names).</source>
          <target state="translated">Некоторые необычные системы,такие как VMS,требуют специальной обработки имен файлов для работы с символическими именами файлов (например,Логические имена VMS).</target>
        </trans-unit>
        <trans-unit id="6a39214b093577878080cd0246589b3e208ffeb5" translate="yes" xml:space="preserve">
          <source>Some user's however may feel that the above &quot;economy of expression&quot; is not particularly readable nor consistent and may instead choose to do something more like the following:</source>
          <target state="translated">Однако некоторые пользователи могут почувствовать,что вышеприведенная &quot;экономия выражения&quot; не является особенно читабельной и непротиворечивой,и вместо этого могут выбрать что-то более похожее на следующее:</target>
        </trans-unit>
        <trans-unit id="1ad295080cd8e985d193a33706aa64c82df7132f" translate="yes" xml:space="preserve">
          <source>Some users have expressed that they think this whole mechanism of having a &quot;fail&quot; attribute at all, seems a rather pointless complication. But I want Locale::Maketext to be usable for software projects of</source>
          <target state="translated">Некоторые пользователи высказывают мнение,что весь этот механизм,имеющий атрибут &quot;fail&quot; вообще,кажется довольно бессмысленным усложнением.Но я хочу,чтобы Locale::Maketext был пригоден для использования в программном проекте</target>
        </trans-unit>
        <trans-unit id="7ab6d61e44a0f4b38225b697b64d41eb4c216b63" translate="yes" xml:space="preserve">
          <source>Some users may wish to encourage the use of lexically scoped variables. As an aid to catching implicit uses to package variables, which are always global, if you say</source>
          <target state="translated">Некоторые пользователи,возможно,пожелают поощрить использование лексически описанных переменных.В качестве подспорья в перехвате неявного использования для пакетов переменных,которые всегда являются глобальными,если вы говорите</target>
        </trans-unit>
        <trans-unit id="020ce1178f605ac1782ec8459fa4fa7fd0cf745e" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;DB_File&lt;/code&gt; won't let you store data under a key of length 0. That means that if you have a function &lt;code&gt;f&lt;/code&gt; which you memoized and the cache is in a &lt;code&gt;DB_File&lt;/code&gt; database, then the value of &lt;code&gt;f()&lt;/code&gt; (&lt;code&gt;f&lt;/code&gt; called with no arguments) will not be memoized. If this is a big problem, you can supply a normalizer function that prepends &lt;code&gt;&quot;x&quot;&lt;/code&gt; to every key.</source>
          <target state="translated">Некоторые версии &lt;code&gt;DB_File&lt;/code&gt; не позволяют хранить данные с ключом длины 0. Это означает, что если у вас есть функция &lt;code&gt;f&lt;/code&gt; , которую вы запомнили, а кеш находится в &lt;code&gt;DB_File&lt;/code&gt; данных DB_File , тогда значение &lt;code&gt;f()&lt;/code&gt; ( &lt;code&gt;f&lt;/code&gt; вызывается с без аргументов) мемоизироваться не будет. Если это большая проблема, вы можете предоставить функцию нормализатора, которая добавляет &lt;code&gt;&quot;x&quot;&lt;/code&gt; к каждой клавише.</target>
        </trans-unit>
        <trans-unit id="8bb4498f94e563a623dff663cd55b4fc862752c4" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;make&lt;/code&gt; set the variable &lt;code&gt;MAKE&lt;/code&gt; . Others do not. This variable contains the string to be included in</source>
          <target state="translated">Некоторые версии &lt;code&gt;make&lt;/code&gt; устанавливают переменную &lt;code&gt;MAKE&lt;/code&gt; . У других нет. Эта переменная содержит строку, которая должна быть включена в</target>
        </trans-unit>
        <trans-unit id="954f7aeec06323e12a6983f37a0846eca84625d3" translate="yes" xml:space="preserve">
          <source>Some versions of flock() can't lock files over a network (e.g. on NFS file systems), so you'd need to force the use of fcntl(2) when you build Perl. But even this is dubious at best. See the flock entry of &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and the</source>
          <target state="translated">Некоторые версии flock () не могут блокировать файлы по сети (например, в файловых системах NFS), поэтому вам нужно принудительно использовать fcntl (2) при сборке Perl. Но даже это в лучшем случае сомнительно. См. &lt;a href=&quot;perlfunc&quot;&gt;Статью perlfunc&lt;/a&gt; и</target>
        </trans-unit>
        <trans-unit id="d311518a6bb3b8613076ce871f73cf8cb1a1e05f" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is one reason why this function is deprecated. The other is that only in extremely limited circumstances should the Unicode versus native code point be of any interest to you. See &lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;utf8_to_uvuni_buf&lt;/a&gt; for alternatives.</source>
          <target state="translated">Некоторые, но не все, дефекты UTF-8 обнаруживаются, и на самом деле некоторые искаженные вводимые данные могут вызвать чтение за пределами конца входного буфера, что является одной из причин, по которой эта функция устарела. Во-вторых, сравнение Unicode и нативного кода может представлять для вас интерес только в крайне ограниченных случаях. &lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;Альтернативы&lt;/a&gt; см. В utf8_to_uvuni_buf .</target>
        </trans-unit>
        <trans-unit id="2fc9641c97ef26419e8b09582d42e0230f643449" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is why this function is deprecated. Use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; instead.</source>
          <target state="translated">Некоторые, но не все, дефекты UTF-8 обнаруживаются, и на самом деле некоторые искаженные входные данные могут вызвать чтение за пределами конца входного буфера, поэтому эта функция устарела. &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;Вместо&lt;/a&gt; этого используйте utf8_to_uvchr_buf .</target>
        </trans-unit>
        <trans-unit id="d5b99daee126bc167396885e5a173ca7e1b5727f" translate="yes" xml:space="preserve">
          <source>Some, such as &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; aren't provided because the concept does not exist within Plan 9. Others, such as some of the socket-related functions, simply haven't been written yet. Many in the latter category may be supported in the future.</source>
          <target state="translated">Некоторые из них, такие как &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; , не предоставляются, потому что в Plan 9 нет этой концепции. Другие, например, некоторые функции, связанные с сокетами, просто еще не написаны. Многие из последней категории могут получить поддержку в будущем.</target>
        </trans-unit>
        <trans-unit id="6b529d1f2a1daeac288a5dc3e3f1ad071820c7a2" translate="yes" xml:space="preserve">
          <source>Some/Module.pm</source>
          <target state="translated">Some/Module.pm</target>
        </trans-unit>
        <trans-unit id="75f6f0269318d3e6d862e35e227cdb78f8aa0076" translate="yes" xml:space="preserve">
          <source>Someone like Larry, or one of his peculiar friends. Also refers to the strange prefixes that Perl requires as noun markers on its variables.</source>
          <target state="translated">Кто-то вроде Ларри или одного из его необычных друзей.Также относится к странным префиксам,которые Perl требует в качестве существительных маркеров на своих переменных.</target>
        </trans-unit>
        <trans-unit id="4645c18015bf5520c386fecd9f2627c0f851f491" translate="yes" xml:space="preserve">
          <source>Someone who &amp;ldquo;carries&amp;rdquo; software from one &lt;b&gt;platform&lt;/b&gt; to another. Porting programs written in platform-dependent languages such as C can be difficult work, but porting programs like Perl is very much worth the agony.</source>
          <target state="translated">Тот, кто &amp;laquo;переносит&amp;raquo; программное обеспечение с одной &lt;b&gt;платформы&lt;/b&gt; на другую. Перенос программ, написанных на платформенно-зависимых языках, таких как C, может быть сложной задачей, но перенос программ, таких как Perl, стоит мучений.</target>
        </trans-unit>
        <trans-unit id="81901ca358030c454d79961747b435397961631e" translate="yes" xml:space="preserve">
          <source>Someone who breaks security on computer systems. A cracker may be a true &lt;b&gt;hacker&lt;/b&gt; or only a &lt;b&gt;script kiddie&lt;/b&gt;.</source>
          <target state="translated">Кто-то, кто взламывает безопасность компьютерных систем. Взломщик может быть настоящим &lt;b&gt;хакером&lt;/b&gt; или просто &lt;b&gt;скрипачом&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="1964ccb6039dfc22b78b8e0d35db2a914eb047cc" translate="yes" xml:space="preserve">
          <source>Someone who is brilliantly persistent in solving technical problems, whether these involve golfing, fighting orcs, or programming. Hacker is a neutral term, morally speaking. Good hackers are not to be confused with evil &lt;b&gt;crackers&lt;/b&gt; or clueless &lt;b&gt;script kiddies&lt;/b&gt;. If you confuse them, we will presume that you are either evil or clueless.</source>
          <target state="translated">Тот, кто блестяще настойчив в решении технических проблем, будь то игра в гольф, борьба с орками или программирование. Хакер - нейтральный термин с моральной точки зрения. Не следует путать хороших хакеров со злыми &lt;b&gt;взломщиками&lt;/b&gt; или невежественными &lt;b&gt;скрипачами&lt;/b&gt; . Если вы их запутаете, мы будем считать, что вы злой или невежественный.</target>
        </trans-unit>
        <trans-unit id="a06bdcd2151c9efce6b287181e34780a4956856f" translate="yes" xml:space="preserve">
          <source>Something &amp;ldquo;iffy&amp;rdquo;. See &lt;b&gt;Boolean context&lt;/b&gt;.</source>
          <target state="translated">Что-то &amp;laquo;ненадежное&amp;raquo;. См. &lt;b&gt;Логический контекст&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="e155f24963deb993057b4c0bc7a9a37afd51cb22" translate="yes" xml:space="preserve">
          <source>Something extra that happens when you evaluate an &lt;b&gt;expression&lt;/b&gt;. Nowadays it can refer to almost anything. For example, evaluating a simple assignment statement typically has the &amp;ldquo;side effect&amp;rdquo; of assigning a value to a variable. (And you thought assigning the value was your primary intent in the first place!) Likewise, assigning a value to the special variable &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) has the side effect of forcing a flush after every &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; on the currently selected filehandle.</source>
          <target state="translated">Что-то дополнительное, что происходит, когда вы оцениваете &lt;b&gt;выражение&lt;/b&gt; . В настоящее время это может относиться практически ко всему. Например, оценка простого оператора присваивания обычно имеет &amp;laquo;побочный эффект&amp;raquo; присвоения значения переменной. (И вы думали, что присвоение значения было вашим основным намерением!) Аналогичным образом, присвоение значения специальной переменной &lt;code&gt;$|&lt;/code&gt; ( &lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) имеет побочный эффект принудительного сброса после каждой &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; для текущего выбранного дескриптора файла.</target>
        </trans-unit>
        <trans-unit id="783e080adee89f0dfad650da0b7f44d322697c43" translate="yes" xml:space="preserve">
          <source>Something is rotten in the state of the program. An attributed subroutine ceased to exist between the point it was declared and the point at which its attribute handler(s) would have been called.</source>
          <target state="translated">Что-то прогнило в состоянии программы.Приписываемая подпрограмма перестает существовать между точкой,в которой она была объявлена,и точкой,в которой был бы вызван обработчик(и)ее атрибута.</target>
        </trans-unit>
        <trans-unit id="9119b80c4db3125e0e5d3f36b18c5029258c49c9" translate="yes" xml:space="preserve">
          <source>Something is still amiss: consider the loop variable $cnt of the script. It was a number, not an object. We cannot make this value of type &lt;code&gt;symbolic&lt;/code&gt; , since then the loop will not terminate.</source>
          <target state="translated">Что-то еще не так: рассмотрите переменную цикла $ cnt скрипта. Это было число, а не объект. Мы не можем сделать это значение типа &lt;code&gt;symbolic&lt;/code&gt; , так как тогда цикл не завершится.</target>
        </trans-unit>
        <trans-unit id="b420f56b3a25fc6071dc9a2a0d9e492a4d5a4fac" translate="yes" xml:space="preserve">
          <source>Something like &lt;code&gt;&quot;-DHAVE_UNISTD_H&quot;&lt;/code&gt;</source>
          <target state="translated">Что-то вроде &lt;code&gt;&quot;-DHAVE_UNISTD_H&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2229723dcea531af53507e7f80155b0032f61e90" translate="yes" xml:space="preserve">
          <source>Something not owned by anybody. Perl is copyrighted and is thus</source>
          <target state="translated">Что-то,что никому не принадлежит.Perl защищен авторским правом и,таким образом.</target>
        </trans-unit>
        <trans-unit id="63320e06b401dd030b4898741e99304253f96385" translate="yes" xml:space="preserve">
          <source>Something of a hack but it prevents a lot of code duplication between MM_* variants.</source>
          <target state="translated">Что-то вроде взлома,но это предотвращает большое дублирование кода между вариантами MM_*.</target>
        </trans-unit>
        <trans-unit id="bbccb8a40149fe00b8fef910fa55b43eced89db6" translate="yes" xml:space="preserve">
          <source>Something similar to the offset hack is performed on AVs to enable efficient shifting and splicing off the beginning of the array; while &lt;code&gt;AvARRAY&lt;/code&gt; points to the first element in the array that is visible from Perl, &lt;code&gt;AvALLOC&lt;/code&gt; points to the real start of the C array. These are usually the same, but a &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; operation can be carried out by increasing &lt;code&gt;AvARRAY&lt;/code&gt; by one and decreasing &lt;code&gt;AvFILL&lt;/code&gt; and &lt;code&gt;AvMAX&lt;/code&gt; . Again, the location of the real start of the C array only comes into play when freeing the array. See &lt;code&gt;av_shift&lt;/code&gt; in</source>
          <target state="translated">Что-то похожее на взлом смещения выполняется на AV, чтобы обеспечить эффективное смещение и сращивание начала массива; в то время как &lt;code&gt;AvARRAY&lt;/code&gt; указывает на первый элемент в массиве, видимый из Perl, &lt;code&gt;AvALLOC&lt;/code&gt; указывает на реальное начало массива C. Обычно это одно и то же, но операцию &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; можно выполнить, увеличив &lt;code&gt;AvARRAY&lt;/code&gt; на единицу и уменьшив &lt;code&gt;AvFILL&lt;/code&gt; и &lt;code&gt;AvMAX&lt;/code&gt; . Опять же, местоположение реального начала массива C вступает в игру только при освобождении массива. См. &lt;code&gt;av_shift&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="4332fef1f22d39fca98466a0536a5b2d1aaa44ee" translate="yes" xml:space="preserve">
          <source>Something that tells your program what sort of variable you&amp;rsquo;d like. Perl doesn&amp;rsquo;t require you to declare variables, but you can use &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; to denote that you want something other than the default.</source>
          <target state="translated">Что-то, что сообщает вашей программе, какой тип переменной вам нужен. Perl не требует, чтобы вы объявляли переменные, но вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; , чтобы указать, что вы хотите что-то иное, кроме значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="7ad3b77572daa04075d4890e62387b4b824f1955" translate="yes" xml:space="preserve">
          <source>Something to exclude, prefixed by &lt;code&gt;&quot;-&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">Что-то для исключения с префиксом &lt;code&gt;&quot;-&quot;&lt;/code&gt; : существующее свойство символа (с префиксом &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) или полностью определенное (включая имя пакета) определяемое пользователем свойство символа, чтобы представить все символы в этом свойстве; две шестнадцатеричные кодовые точки для диапазона; или один шестнадцатеричный код.</target>
        </trans-unit>
        <trans-unit id="2f7458ff984e1016174a3ccc404733830b1557d4" translate="yes" xml:space="preserve">
          <source>Something to include, prefixed by &lt;code&gt;&quot;+&quot;&lt;/code&gt; : a built-in character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">Что-то для включения с префиксом &lt;code&gt;&quot;+&quot;&lt;/code&gt; : встроенное свойство символа (с префиксом &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) или полностью определенное (включая имя пакета) свойство символа, определяемое пользователем, для представления всех символов в этом свойстве; две шестнадцатеричные кодовые точки для диапазона; или один шестнадцатеричный код.</target>
        </trans-unit>
        <trans-unit id="691cfd6a9c9ef44b73a6c3b1fc2fc7e231422dbe" translate="yes" xml:space="preserve">
          <source>Something to intersect with, prefixed by &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, for all the characters except the characters in the property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">Что-то, с чем нужно пересекаться, с префиксом &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; : существующее свойство символа (с префиксом &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) или полностью определенное (включая имя пакета) определяемое пользователем свойство символа для всех символов, кроме символов в свойстве; две шестнадцатеричные кодовые точки для диапазона; или один шестнадцатеричный код.</target>
        </trans-unit>
        <trans-unit id="6131959027de2eb65107afa87755cfdbae0af220" translate="yes" xml:space="preserve">
          <source>Something to negate, prefixed &lt;code&gt;&quot;!&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">Что-то отрицательное, с префиксом &lt;code&gt;&quot;!&quot;&lt;/code&gt; : существующее свойство символа (с префиксом &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) или полностью определенное (включая имя пакета) свойство символа, определяемое пользователем, для представления всех символов в этом свойстве; две шестнадцатеричные кодовые точки для диапазона; или один шестнадцатеричный код.</target>
        </trans-unit>
        <trans-unit id="b29b35d3b7e27c5736fa04a9d5a9779f7c0d02b4" translate="yes" xml:space="preserve">
          <source>Something we&amp;rsquo;d call a &lt;b&gt;metacharacter&lt;/b&gt; except that it&amp;rsquo;s a sequence of more than one character. Generally, the first character in the sequence must be a true metacharacter to get the other characters in the metasymbol to misbehave along with it.</source>
          <target state="translated">То, что мы бы назвали &lt;b&gt;метасимволом,&lt;/b&gt; за исключением того, что это последовательность из более чем одного символа. Как правило, первый символ в последовательности должен быть истинным метасимволом, чтобы другие символы в метасимволе плохо себя вели вместе с ним.</target>
        </trans-unit>
        <trans-unit id="0939ed03ca5713b7d596d517d3a21d567b42a063" translate="yes" xml:space="preserve">
          <source>Something went horribly wrong-- the number of microseconds that cannot become negative just became negative. Maybe your compiler is broken?</source>
          <target state="translated">Что-то пошло не так-количество микросекунд,которое не может стать отрицательным,просто стало отрицательным.Может,ваш компилятор сломался?</target>
        </trans-unit>
        <trans-unit id="c59ba282daa2ae9441382d6bdd1d5cbb102eba6e" translate="yes" xml:space="preserve">
          <source>Something you can see from anywhere, usually used of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; that are visible everywhere in your program. In Perl, only certain special variables are truly global&amp;mdash;most variables (and all subroutines) exist only in the current &lt;b&gt;package&lt;/b&gt;. Global variables can be declared with &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;. See &amp;ldquo;Global Declarations&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="translated">Что-то, что вы можете увидеть откуда угодно, обычно это &lt;b&gt;переменные&lt;/b&gt; и &lt;b&gt;подпрограммы&lt;/b&gt; , которые видны повсюду в вашей программе. В Perl только некоторые специальные переменные являются действительно глобальными - большинство переменных (и все подпрограммы) существуют только в текущем &lt;b&gt;пакете&lt;/b&gt; . Глобальные переменные могут быть объявлены с помощью &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; . См. &amp;laquo;Глобальные декларации&amp;raquo; в главе 4 Camel &amp;laquo;Заявления и декларации&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="07e88fa4cc64647b2e3278d50a97cb8b0618c720" translate="yes" xml:space="preserve">
          <source>Something you do for someone else to make them happy, like giving them the time of day (or of their life). On some machines, well-known services are listed by the &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Что-то, что вы делаете для кого-то, чтобы сделать его счастливым, например, давая ему время суток (или время его жизни). На некоторых машинах известные службы перечислены функцией &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="457be77433ae10862116d65ca361c913afdc2edf" translate="yes" xml:space="preserve">
          <source>Sometimes (see &lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;When Unicode Does Not Happen&lt;/a&gt; or &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;) there are situations where you simply need to force a byte string into UTF-8, or vice versa. The standard module &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; can be used for this, or the low-level calls &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::upgrade($bytestring) &lt;/a&gt; and &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::downgrade($utf8string[, FAIL_OK]) &lt;/a&gt;.</source>
          <target state="translated">Иногда (см. &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;Раздел &amp;laquo; &lt;/a&gt;&lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;Когда Unicode не происходит&amp;raquo;&lt;/a&gt; или &amp;laquo;Ошибка Unicode&amp;raquo; ) возникают ситуации, когда вам просто нужно принудительно преобразовать строку байтов в UTF-8 или наоборот. Для этого можно использовать стандартный модуль &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; или низкоуровневые вызовы &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: upgrade ($ bytestring)&lt;/a&gt; и &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: downgrade ($ utf8string [, FAIL_OK])&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c72f071a765fd3018bc7af5d49df36cbd9aae7b" translate="yes" xml:space="preserve">
          <source>Sometimes greed is not good. At times, we would like quantifiers to match a</source>
          <target state="translated">Иногда жадность-это плохо.Иногда нам хотелось бы,чтобы квантификаторы соответствовали</target>
        </trans-unit>
        <trans-unit id="0aa27e840004256e29009bb974e009bb34e90abf" translate="yes" xml:space="preserve">
          <source>Sometimes instead of zeroing the allocated heap by using Newxz() you should consider &quot;poisoning&quot; the data. This means writing a bit pattern into it that should be illegal as pointers (and floating point numbers), and also hopefully surprising enough as integers, so that any code attempting to use the data without forethought will break sooner rather than later. Poisoning can be done using the Poison() macros, which have similar arguments to Zero():</source>
          <target state="translated">Иногда вместо обнуления выделенной кучи с помощью Newxz()следует подумать об &quot;отравлении&quot; данных.Это означает записать в него битовую закономерность,которая должна быть запрещена в качестве указателей (и чисел с плавающей точкой),а также,надеюсь,достаточно удивительна в качестве целых чисел,так что любой код,пытающийся бездумно использовать данные,рано или поздно разобьется.Отравление можно сделать с помощью макросов Poison(),которые имеют аргументы,аналогичные Zero():</target>
        </trans-unit>
        <trans-unit id="cae5675054ecaa30b3d68d273e86faefe7bf19e0" translate="yes" xml:space="preserve">
          <source>Sometimes it is advantageous to construct a pattern from the</source>
          <target state="translated">Иногда бывает выгодно построить шаблон из</target>
        </trans-unit>
        <trans-unit id="fa5de12a356ae81ac7e15fb6c4fdf4f42322289c" translate="yes" xml:space="preserve">
          <source>Sometimes it may be necessary to make more than one pass over the input files. If this is the case you have several options. You can make the first pass using &lt;b&gt;Pod::Parser&lt;/b&gt; and override your methods to store the intermediate results in memory somewhere for the &lt;b&gt;end_pod()&lt;/b&gt; method to process. You could use &lt;b&gt;Pod::Parser&lt;/b&gt; for several passes with an appropriate state variable to control the operation for each pass. If your input source can't be reset to start at the beginning, you can store it in some other structure as a string or an array and have that structure implement a &lt;b&gt;getline()&lt;/b&gt; method (which is all that &lt;b&gt;parse_from_filehandle()&lt;/b&gt; uses to read input).</source>
          <target state="translated">Иногда может потребоваться выполнить более одного прохода по входным файлам. В этом случае у вас есть несколько вариантов. Вы можете сделать первый проход, используя &lt;b&gt;Pod :: Parser,&lt;/b&gt; и переопределить свои методы для сохранения промежуточных результатов где-нибудь в памяти для &lt;b&gt;обработки&lt;/b&gt; методом &lt;b&gt;end_pod ()&lt;/b&gt; . Вы можете использовать &lt;b&gt;Pod :: Parser&lt;/b&gt; для нескольких проходов с соответствующей переменной состояния для управления операцией на каждом проходе. Если ваш источник ввода не может быть сброшен, чтобы начать с самого начала, вы можете сохранить его в какой-либо другой структуре как строку или массив и заставить эту структуру реализовать метод &lt;b&gt;getline ()&lt;/b&gt; (который является всем, что &lt;b&gt;parse_from_filehandle ()&lt;/b&gt; использует для чтения ввод).</target>
        </trans-unit>
        <trans-unit id="f6006f7823a5727b8006f191fa888a2e039ea099" translate="yes" xml:space="preserve">
          <source>Sometimes minimal matching can help a lot. Imagine you'd like to match everything between &quot;foo&quot; and &quot;bar&quot;. Initially, you write something like this:</source>
          <target state="translated">Иногда минимальное соответствие может очень помочь.Представьте,что вы хотели бы сопоставить все между &quot;фу&quot; и &quot;бар&quot;.Изначально вы пишете что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="7e0fb1495abd7611e5570cce2cb4d1976ffa0113" translate="yes" xml:space="preserve">
          <source>Sometimes older versions of the module you're installing live in other directories in @INC. Because Perl loads the first version of a module it finds, not the newest, you might accidentally get one of these older versions even after installing a brand new version. To delete</source>
          <target state="translated">Иногда старые версии модуля,который вы устанавливаете,живут в других каталогах в @INC.Так как Perl загружает первую версию модуля,который он находит,а не самую новую,вы можете случайно получить одну из этих старых версий даже после установки совершенно новой версии.Чтобы удалить</target>
        </trans-unit>
        <trans-unit id="eb753520a2d796d4f761ee04ddf336bdbe0915a3" translate="yes" xml:space="preserve">
          <source>Sometimes ops are executed within an inner runops loop, such as tie, sort or overload code. In this case, something like</source>
          <target state="translated">Иногда операторы выполняются во внутреннем цикле runops,например,в цикле связывания,сортировки или кода перегрузки.В этом случае,что-то вроде</target>
        </trans-unit>
        <trans-unit id="147ec757892c0aed445b0fb45a48e27c978e8a0c" translate="yes" xml:space="preserve">
          <source>Sometimes running a test under certain conditions will cause the test script to die. A certain function or method isn't implemented (such as &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; on MacOS), some resource isn't available (like a net connection) or a module isn't available. In these cases it's necessary to skip tests, or declare that they are supposed to fail but will work in the future (a todo test).</source>
          <target state="translated">Иногда выполнение теста при определенных условиях приводит к зависанию тестового сценария. Определенная функция или метод не реализованы (например, &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; в MacOS), некоторые ресурсы недоступны (например, сетевое соединение) или модуль недоступен. В этих случаях необходимо пропустить тесты или объявить, что они не пройдут, но будут работать в будущем (тест todo).</target>
        </trans-unit>
        <trans-unit id="14a525fd22c2b653fcabe0c32c53b3975d5455dc" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::Builder test counter is incremented without it printing any test output, for example, when &lt;code&gt;current_test()&lt;/code&gt; is changed. In these cases, Test::Builder doesn't know the result of the test, so its type is 'unknown'. These details for these tests are filled in. They are considered ok, but the name and actual_ok is left &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Иногда счетчик теста Test :: Builder увеличивается без вывода каких-либо результатов теста, например, при изменении &lt;code&gt;current_test()&lt;/code&gt; . В этих случаях Test :: Builder не знает результата теста, поэтому его тип &amp;laquo;неизвестен&amp;raquo;. Эти данные для этих тестов заполнены. Они считаются нормальными, но name и actual_ok оставлены &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c117b85f5735958c8ac918f5819ede8cc1b0ef4" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::More interface isn't quite enough. Fortunately, Test::More is built on top of &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; which provides a single, unified backend for any test library to use. This means two test libraries which both use &amp;lt;Test::Builder&amp;gt; &lt;b&gt;can&lt;/b&gt; be used together in the same program&amp;gt;.</source>
          <target state="translated">Иногда интерфейса Test :: More недостаточно. К счастью, Test :: More построен на основе &lt;a href=&quot;builder&quot;&gt;Test :: Builder,&lt;/a&gt; который предоставляет единый унифицированный бэкэнд для использования любой тестовой библиотекой. Это означает, что две тестовые библиотеки, которые обе используют &amp;lt;Test :: Builder&amp;gt;, &lt;b&gt;могут&lt;/b&gt; использоваться вместе в одной программе&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="ff0436b0b7df1e2c343b73c639e499fd807b68f3" translate="yes" xml:space="preserve">
          <source>Sometimes there is some confusion about where &lt;code&gt;todo()&lt;/code&gt; should be looking for the &lt;code&gt;$TODO&lt;/code&gt; variable. If you want to be sure, tell it explicitly what $pack to use.</source>
          <target state="translated">Иногда возникает некоторая путаница в том, где &lt;code&gt;todo()&lt;/code&gt; должна искать переменную &lt;code&gt;$TODO&lt;/code&gt; . Если вы хотите быть уверенным, укажите явно, какой пакет $ использовать.</target>
        </trans-unit>
        <trans-unit id="399765aa05845ba02b6fea1a15de4bf746fb4a9e" translate="yes" xml:space="preserve">
          <source>Sometimes we would like our regexp to be able to match different possible words or character strings. This is accomplished by using the</source>
          <target state="translated">Иногда нам хотелось бы,чтобы наш регэксперт мог сопоставлять различные возможные слова или строки символов.Это достигается с помощью</target>
        </trans-unit>
        <trans-unit id="c45fdfd630d6939174042d52a2669877eec8162b" translate="yes" xml:space="preserve">
          <source>Sometimes you don't want to pass the value of an array to a subroutine but rather the name of it, so that the subroutine can modify the global copy of it rather than working with a local copy. In perl you can refer to all objects of a particular name by prefixing the name with a star: &lt;code&gt;*foo&lt;/code&gt; . This is often known as a &quot;typeglob&quot;, because the star on the front can be thought of as a wildcard match for all the funny prefix characters on variables and subroutines and such.</source>
          <target state="translated">Иногда вы хотите передавать подпрограмме не значение массива, а его имя, чтобы подпрограмма могла изменять его глобальную копию, а не работать с локальной копией. В Perl вы можете ссылаться на все объекты с определенным именем, поставив перед именем звездочку: &lt;code&gt;*foo&lt;/code&gt; . Это часто называют &amp;laquo;typeglob&amp;raquo;, потому что звезду на лицевой стороне можно рассматривать как совпадение с подстановочными знаками для всех забавных префиксных символов в переменных, подпрограммах и т.п.</target>
        </trans-unit>
        <trans-unit id="3dc7c2918cdb381ad384c3d9167215ff71a8a0da" translate="yes" xml:space="preserve">
          <source>Sometimes you have to store undefined values in AVs or HVs. Although this may be a rare case, it can be tricky. That's because you're used to using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; if you need an undefined SV.</source>
          <target state="translated">Иногда вам нужно хранить неопределенные значения в AV или HV. Хотя это может быть редким случаем, это может быть сложно. Это потому, что вы привыкли использовать &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; если вам нужен неопределенный SV.</target>
        </trans-unit>
        <trans-unit id="ce5b78669327a1c5203b6d6638f97e91e235e173" translate="yes" xml:space="preserve">
          <source>Sometimes you just want to say that the tests have passed. Usually the case is you've got some complicated condition that is difficult to wedge into an &lt;code&gt;ok()&lt;/code&gt; . In this case, you can simply use &lt;code&gt;pass()&lt;/code&gt; (to declare the test ok) or fail (for not ok). They are synonyms for &lt;code&gt;ok(1)&lt;/code&gt; and &lt;code&gt;ok(0)&lt;/code&gt; .</source>
          <target state="translated">Иногда просто хочется сказать, что тесты прошли. Обычно дело в том, что у вас есть какое-то сложное условие, которое трудно вставить в &lt;code&gt;ok()&lt;/code&gt; . В этом случае вы можете просто использовать &lt;code&gt;pass()&lt;/code&gt; (чтобы объявить тест в порядке) или fail (если не в порядке). Это синонимы &lt;code&gt;ok(1)&lt;/code&gt; и &lt;code&gt;ok(0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99ad657b111885cfb86229225ce3dd7e07ab7571" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to truncate an already-existing file. This can be done using the &lt;code&gt;O_TRUNC&lt;/code&gt; flag. The behavior of &lt;code&gt;O_TRUNC&lt;/code&gt; with &lt;code&gt;O_RDONLY&lt;/code&gt; is undefined.</source>
          <target state="translated">Иногда вам может потребоваться обрезать уже существующий файл. Это можно сделать с помощью флага &lt;code&gt;O_TRUNC&lt;/code&gt; . Поведение &lt;code&gt;O_TRUNC&lt;/code&gt; с &lt;code&gt;O_RDONLY&lt;/code&gt; не определено.</target>
        </trans-unit>
        <trans-unit id="d108e62bce7d546642fdcfcda3e786d8361305f7" translate="yes" xml:space="preserve">
          <source>Sometimes you may wish to leave the processes run by CPAN alone without caring about them. Because the Makefile.PL or the Build.PL sometimes contains question you're expected to answer, you can set a timer that will kill a 'perl Makefile.PL' process after the specified time in seconds.</source>
          <target state="translated">Иногда Вы можете захотеть оставить процессы,выполняемые CPAN,в покое,не заботясь о них.Так как Makefile.PL или Build.PL иногда содержит вопрос,на который вы должны ответить,вы можете установить таймер,который убьет процесс 'perl Makefile.PL' по истечении заданного времени в секундах.</target>
        </trans-unit>
        <trans-unit id="c00f6f509d151b6fb1ea7605fa661bc15fbf5303" translate="yes" xml:space="preserve">
          <source>Sometimes you might really need to know the byte length of a string instead of the character length. For that use either the &lt;code&gt;Encode::encode_utf8()&lt;/code&gt; function or the &lt;code&gt;bytes&lt;/code&gt; pragma and the &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">Иногда вам действительно может понадобиться узнать длину строки в байтах, а не длину символа. Для этого используйте либо функцию &lt;code&gt;Encode::encode_utf8()&lt;/code&gt; либо директиву &lt;code&gt;bytes&lt;/code&gt; и функцию &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="69ca48a72c9601cef59e5c67d6f3681c75e3b061" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to build a statically linked perl although your system supports dynamic loading. In this case you may explicitly set the linktype with the invocation of the Makefile.PL or make:</source>
          <target state="translated">Иногда вам может понадобиться построить статически подключенный perl,хотя ваша система поддерживает динамическую загрузку.В этом случае вы можете явно задать тип ссылки с помощью вызова Makefile.PL или make:</target>
        </trans-unit>
        <trans-unit id="d30402c312d3b94f0c6f02a6509532f4e38398dd" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to display Perl scalars containing Unicode as simple ASCII (or EBCDIC) text. The following subroutine converts its argument so that Unicode characters with code points greater than 255 are displayed as &lt;code&gt;\x{...}&lt;/code&gt; , control characters (like &lt;code&gt;\n&lt;/code&gt; ) are displayed as &lt;code&gt;\x..&lt;/code&gt; , and the rest of the characters as themselves:</source>
          <target state="translated">Иногда вам может потребоваться отобразить скаляры Perl, содержащие Unicode, как простой текст ASCII (или EBCDIC). Следующая подпрограмма преобразует свой аргумент так, что символы Unicode с кодовыми точками больше 255 отображаются как &lt;code&gt;\x{...}&lt;/code&gt; , управляющие символы (например, &lt;code&gt;\n&lt;/code&gt; ) отображаются как &lt;code&gt;\x..&lt;/code&gt; , а остальные символы как сами себя :</target>
        </trans-unit>
        <trans-unit id="93cab2a917ae8f995aa91a73cd34dbac7106cc0f" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to provide some extra methods or subroutines to assist in making the interface between Perl and your extension simpler or easier to understand. These routines should live in the .pm file. Whether they are automatically loaded when the extension itself is loaded or only loaded when called depends on where in the .pm file the subroutine definition is placed. You can also consult &lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt; for an alternate way to store and load your extra subroutines.</source>
          <target state="translated">Иногда вы можете захотеть предоставить некоторые дополнительные методы или подпрограммы, чтобы упростить или облегчить понимание интерфейса между Perl и вашим расширением. Эти процедуры должны находиться в файле .pm. Загружаются ли они автоматически при загрузке самого расширения или загружаются только при вызове, зависит от того, где в файле .pm помещается определение подпрограммы. Вы также можете обратиться к &lt;a href=&quot;autoloader&quot;&gt;AutoLoader,&lt;/a&gt; чтобы узнать об альтернативном способе хранения и загрузки дополнительных подпрограмм.</target>
        </trans-unit>
        <trans-unit id="d50f25bb7791c3200f165a11a2621c66fc26aa1f" translate="yes" xml:space="preserve">
          <source>Sometimes you need to have two and more XS files in the same package. One way to go is to put them into separate directories, but sometimes this is not the most suitable solution. The following technique allows you to put two (and more) XS files in the same directory.</source>
          <target state="translated">Иногда вам нужно иметь два и более XS-файлов в одном пакете.Один из способов-поместить их в отдельные каталоги,но иногда это не самое подходящее решение.Следующая техника позволяет поместить два (и более)XS-файла в одну директорию.</target>
        </trans-unit>
        <trans-unit id="d84ae75a88af76cd17f4e95ee970d0624fc53ec5" translate="yes" xml:space="preserve">
          <source>Sometimes you need to invoke the same subroutine repeatedly. This usually happens with a function that acts on a list of values, such as Perl's built-in sort(). You can pass a comparison function to sort(), which will then be invoked for every pair of values that needs to be compared. The first() and reduce() functions from &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; follow a similar pattern.</source>
          <target state="translated">Иногда вам нужно повторно вызывать одну и ту же подпрограмму. Обычно это происходит с функцией, которая работает со списком значений, например с встроенной функцией sort () в Perl. Вы можете передать функцию сравнения в sort (), которая затем будет вызываться для каждой пары значений, которые необходимо сравнить. Функции first () и reduce () из &lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt; следуют аналогичному шаблону.</target>
        </trans-unit>
        <trans-unit id="74631c8a306d075a7cfb9919a67e89afd99fe44c" translate="yes" xml:space="preserve">
          <source>Sometimes you really don't know how many tests were run, or it's too difficult to calculate. In which case you can leave off $number_of_tests_run.</source>
          <target state="translated">Иногда вы действительно не знаете,сколько тестов было проведено,или это слишком сложно подсчитать.В этом случае можно оставить $number_of_tests_run.</target>
        </trans-unit>
        <trans-unit id="85a6426e0300f2135b305a518e04a9c8bcb36f5b" translate="yes" xml:space="preserve">
          <source>Sometimes you should change the positions of the constant and the variable. For example, let's say you wanted to test which of many answers you were given, but in a case-insensitive way that also allows abbreviations. You can use the following technique if the strings all start with different characters or if you want to arrange the matches so that one takes precedence over another, as &lt;code&gt;&quot;SEND&quot;&lt;/code&gt; has precedence over &lt;code&gt;&quot;STOP&quot;&lt;/code&gt; here:</source>
          <target state="translated">Иногда вам следует изменить положение константы и переменной. Например, предположим, что вы хотите проверить, какой из многих ответов вам был дан, но без учета регистра, что также позволяет использовать сокращения. Вы можете использовать следующую технику, если все строки начинаются с разных символов или если вы хотите расположить совпадения так, чтобы одно имело приоритет над другим, поскольку &lt;code&gt;&quot;SEND&quot;&lt;/code&gt; имеет приоритет над &lt;code&gt;&quot;STOP&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e295d93f5cf54bf6ebaedc8fedd1af1c66b62ba7" translate="yes" xml:space="preserve">
          <source>Sometimes you want to combine the best of hashes and arrays. For example, the command line:</source>
          <target state="translated">Иногда хочется совместить лучшее из хэшей и массивов.Например,командную строку:</target>
        </trans-unit>
        <trans-unit id="eb405d6eff8a4115aee698cb0c98540a6a3fb25a" translate="yes" xml:space="preserve">
          <source>Sometimes you want to test if a module, or a list of modules, can successfully load. For example, you'll often want a first test which simply loads all the modules in the distribution to make sure they work before going on to do more complicated testing.</source>
          <target state="translated">Иногда необходимо проверить,может ли модуль или список модулей успешно загрузиться.Например,часто возникает необходимость в первом тесте,который просто загружает все модули в дистрибутиве,чтобы убедиться,что они работают,прежде чем приступать к более сложному тестированию.</target>
        </trans-unit>
        <trans-unit id="ddf8f669e0c9325d3a3aabdd507e3c59589ddd67" translate="yes" xml:space="preserve">
          <source>Sometimes, for example when there are a lot of options, having a separate variable for each of them can be cumbersome. GetOptions() supports, as an alternative mechanism, storing options values in a hash.</source>
          <target state="translated">Иногда,например,когда вариантов много,наличие отдельной переменной для каждого из них может быть громоздким.GetOptions()в качестве альтернативного механизма поддерживает хранение значений опций в хэше.</target>
        </trans-unit>
        <trans-unit id="02fbdd8083e416b0e9b5fb808fb524ba8afb9c15" translate="yes" xml:space="preserve">
          <source>Sometimes, however, linked lists can be useful in situations where you want to &quot;shard&quot; an array so you have many small arrays instead of a single big array. You can keep arrays longer than Perl's largest array index, lock smaller arrays separately in threaded programs, reallocate less memory, or quickly insert elements in the middle of the chain.</source>
          <target state="translated">Иногда,однако,связанные списки могут быть полезны в ситуациях,когда вы хотите &quot;измельчить&quot; массив,так что у вас есть много маленьких массивов вместо одного большого массива.Вы можете хранить массивы дольше,чем самый большой индекс массива Perl,отдельно блокировать меньшие массивы в потоковых программах,перераспределять меньше памяти или быстро вставлять элементы в середину цепочки.</target>
        </trans-unit>
        <trans-unit id="97c577b8a14d559ea222f726e98e3c5c96ca2ea7" translate="yes" xml:space="preserve">
          <source>Sometimes, it can be necessary or useful to make sure that a certain function is fully loaded by AutoLoader. This is the case, for example, when you need to wrap a function to inject debugging code. It is also helpful to force early loading of code before forking to make use of copy-on-write as much as possible.</source>
          <target state="translated">Иногда бывает необходимо или полезно убедиться,что определенная функция полностью загружена автозагрузчиком.Это происходит,например,когда необходимо обернуть функцию для впрыскивания отладочного кода.Также полезно форсировать раннюю загрузку кода до форкинга,чтобы максимально использовать копирование на запись.</target>
        </trans-unit>
        <trans-unit id="c69c69258cfab486eea48fb3f2e535b94c5ff785" translate="yes" xml:space="preserve">
          <source>Sometimes, when the extension does not convert data but just stores and retrieves it, you will be able to use the otherwise dangerous &lt;a href=&quot;encode#_utf8_on&quot;&gt;Encode::_utf8_on() &lt;/a&gt; function. Let's say the popular &lt;code&gt;Foo::Bar&lt;/code&gt; extension, written in C, provides a &lt;code&gt;param&lt;/code&gt; method that lets you store and retrieve data according to these prototypes:</source>
          <target state="translated">Иногда, когда расширение не преобразует данные, а просто сохраняет и извлекает их, вы можете использовать опасную функцию &lt;a href=&quot;encode#_utf8_on&quot;&gt;Encode :: _ utf8_on ()&lt;/a&gt; . Скажем, популярное расширение &lt;code&gt;Foo::Bar&lt;/code&gt; , написанное на C, предоставляет метод &lt;code&gt;param&lt;/code&gt; , который позволяет сохранять и извлекать данные в соответствии с этими прототипами:</target>
        </trans-unit>
        <trans-unit id="915dac0cd6a2dc4688c56bcdae8cb3044da9ebd2" translate="yes" xml:space="preserve">
          <source>Sometimes, you might not wish to extract a complete archive, just the files that are relevant to you, based on some criteria.</source>
          <target state="translated">Иногда,основываясь на некоторых критериях,вы можете не захотеть распаковывать полный архив,а только те файлы,которые вам подходят.</target>
        </trans-unit>
        <trans-unit id="7d2c8f1aa042b04053bafd03d4559b130a601b41" translate="yes" xml:space="preserve">
          <source>Sort an array, with various options.</source>
          <target state="translated">Сортировка массива,с различными опциями.</target>
        </trans-unit>
        <trans-unit id="f11b2d382bb4d1812bd22f06feccfbd16f64c011" translate="yes" xml:space="preserve">
          <source>Sort an array. Here is an example:</source>
          <target state="translated">Сортируй массив.Вот пример:</target>
        </trans-unit>
        <trans-unit id="4d31f4a6a4ae686389ba0f01ad7435ce3ff7f965" translate="yes" xml:space="preserve">
          <source>Sort speed and memory use impacts</source>
          <target state="translated">Сортировка скорости и использования памяти воздействия</target>
        </trans-unit>
        <trans-unit id="e86fa3b469953cdb9c0cfc2f27adce6dc70ff6d4" translate="yes" xml:space="preserve">
          <source>Sort your map in Unicode order.</source>
          <target state="translated">Отсортируйте карту в порядке Юникода.</target>
        </trans-unit>
        <trans-unit id="ba790800e4b9f3d3512c898b0e6088f4dbb30c87" translate="yes" xml:space="preserve">
          <source>Sorting - the quicksort algorithm used in Perls before 5.8.0 to implement the sort() function is very easy to trick into misbehaving so that it consumes a lot of time. Starting from Perl 5.8.0 a different sorting algorithm, mergesort, is used by default. Mergesort cannot misbehave on any input.</source>
          <target state="translated">Сортировка-алгоритм сортировки quicksort,использовавшийся в Perls до 5.8.0 для реализации функции sort(),очень легко обмануть в неправильное поведение,так что это отнимает много времени.Начиная с Perl 5.8.0 по умолчанию используется другой алгоритм сортировки-слияние.Слияние не может приводить к неправильному поведению ни на одном из входных данных.</target>
        </trans-unit>
        <trans-unit id="88a6e89fe9499560d5c7c4f0eba879f0797fcbdf" translate="yes" xml:space="preserve">
          <source>Sorts a list of strings.</source>
          <target state="translated">Сортирует список строк.</target>
        </trans-unit>
        <trans-unit id="89989e7858233b758069d9e36e356e32ea1f4ab9" translate="yes" xml:space="preserve">
          <source>Sounds an awful lot like a process, doesn't it? Well, it should. Threads are one of the pieces of a process. Every process has at least one thread and, up until now, every process running Perl had only one thread. With 5.8, though, you can create extra threads. We're going to show you how, when, and why.</source>
          <target state="translated">Звучит ужасно похоже на процесс,не так ли? Ну,так и должно быть.Нитки-одна из частей процесса.Каждый процесс имеет по крайней мере одну нить,и до сих пор каждый процесс,запущенный Perl,имел только одну нить.Однако,с помощью 5.8 можно создавать дополнительные нити.Мы покажем вам,как,когда и почему.</target>
        </trans-unit>
        <trans-unit id="7b37110e5b01350732eac4676af2611966b9ccef" translate="yes" xml:space="preserve">
          <source>Source Code</source>
          <target state="translated">Исходный код</target>
        </trans-unit>
        <trans-unit id="f0a8c7951e6c30a3c63c9dfb78486cbdf3df91af" translate="yes" xml:space="preserve">
          <source>Source Documentation</source>
          <target state="translated">Исходная документация</target>
        </trans-unit>
        <trans-unit id="c29ede2e39eca25683627a84bf1a76ac20119bd7" translate="yes" xml:space="preserve">
          <source>Source Filters</source>
          <target state="translated">Фильтры источника</target>
        </trans-unit>
        <trans-unit id="ade8f2661e9afaab2f2ac27ea8394747efc3b4bf" translate="yes" xml:space="preserve">
          <source>Source Handler</source>
          <target state="translated">обработчик источника</target>
        </trans-unit>
        <trans-unit id="862ba12e5a4342d2fb92f862ee8e26706e1ba4d8" translate="yes" xml:space="preserve">
          <source>Source code locations, even if available, can often be missing or misleading if the compiler has e.g. inlined code. Optimizer can make matching the source code and the object code quite challenging.</source>
          <target state="translated">Расположение исходного кода,даже если оно доступно,часто может отсутствовать или вводить в заблуждение,если у компилятора есть,например,inlined-код.Оптимизатор может сделать совмещение исходного и объектного кода довольно сложным.</target>
        </trans-unit>
        <trans-unit id="b0272509bdb0dc4d43ea57d6e30f085a388335e1" translate="yes" xml:space="preserve">
          <source>Source documentation is created by putting POD comments into the C source, like this:</source>
          <target state="translated">Исходная документация создается путем добавления POD-комментариев в исходные тексты на C,как это сделано:</target>
        </trans-unit>
        <trans-unit id="4e42a4c9cdabac1017a64b490d8e6fd830b2d27a" translate="yes" xml:space="preserve">
          <source>Source filtering is an immensely powerful feature of recent versions of Perl. It allows one to extend the language itself (e.g. the Switch module), to simplify the language (e.g. Language::Pythonesque), or to completely recast the language (e.g. Lingua::Romana::Perligata). Effectively, it allows one to use the full power of Perl as its own, recursively applied, macro language.</source>
          <target state="translated">Фильтрация источников является чрезвычайно мощной функцией последних версий Perl.Она позволяет расширить сам язык (например,модуль Switch),упростить язык (например,Language::Pythonesque)или полностью переделать язык (например,Lingua::Romana::Perligata).По сути,это позволяет использовать всю мощь Perl в качестве собственного,рекурсивно применяемого макроязыка.</target>
        </trans-unit>
        <trans-unit id="83fa9e2aac616eaf300f336da8ba4cb15a670bf8" translate="yes" xml:space="preserve">
          <source>Source filters activated within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; leak out into whichever</source>
          <target state="translated">Исходные фильтры, активированные в &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , просачиваются в любую</target>
        </trans-unit>
        <trans-unit id="23c4984b5ea778bfe1a620b2921096dd64ef1a0a" translate="yes" xml:space="preserve">
          <source>Source filters only work on the string level, thus are highly limited in its ability to change source code on the fly. It cannot detect comments, quoted strings, heredocs, it is no replacement for a real parser. The only stable usage for source filters are encryption, compression, or the byteloader, to translate binary code back to source code.</source>
          <target state="translated">Фильтры исходных текстов работают только на уровне строк,поэтому их возможность изменять исходный код &quot;на лету&quot; крайне ограничена.Он не может обнаружить комментарии,цитируемые строки,heredocs,он не является заменой реальному парсеру.Единственное стабильное использование для фильтров исходного кода-это шифрование,сжатие или байтзайдер для преобразования двоичного кода обратно в исходный.</target>
        </trans-unit>
        <trans-unit id="6cf561fd42e8003d80556309fdb07a79bace6a7b" translate="yes" xml:space="preserve">
          <source>Source of the ISO 639-2 codes.</source>
          <target state="translated">Источник кодов ИСО 639-2.</target>
        </trans-unit>
        <trans-unit id="178db77b6a3b9b6df2ef880ae7bdafacae37b3c6" translate="yes" xml:space="preserve">
          <source>Source of the ISO 639-5 codes.</source>
          <target state="translated">Источник кодов ИСО 639-5.</target>
        </trans-unit>
        <trans-unit id="b69498a9aee25a26e6f9b5b4bc9ecc63222abc92" translate="yes" xml:space="preserve">
          <source>SourceHandler</source>
          <target state="translated">SourceHandler</target>
        </trans-unit>
        <trans-unit id="8644212c6ba60e5d4b37bed3eca56024c125205f" translate="yes" xml:space="preserve">
          <source>SourceHandlers</source>
          <target state="translated">SourceHandlers</target>
        </trans-unit>
        <trans-unit id="2eb56be3c2d93cdab0c52e677e3167dfddb30ac5" translate="yes" xml:space="preserve">
          <source>Sources</source>
          <target state="translated">Sources</target>
        </trans-unit>
        <trans-unit id="0933c3d8de99d538b1745c97c9ac4e0808ab779e" translate="yes" xml:space="preserve">
          <source>Sources of further information</source>
          <target state="translated">Источники дополнительной информации</target>
        </trans-unit>
        <trans-unit id="b1ffb4c07982ffdd1d32da2ad256d5f400cca0af" translate="yes" xml:space="preserve">
          <source>South America</source>
          <target state="translated">Южная Америка</target>
        </trans-unit>
        <trans-unit id="f082fd9f31b253e1bc875b4f98b8b4196b3c96c9" translate="yes" xml:space="preserve">
          <source>Space after each comma.</source>
          <target state="translated">Пространство после каждой запятой.</target>
        </trans-unit>
        <trans-unit id="b842d2b9fb013f376f25c0749d5ad88cdb3e09d2" translate="yes" xml:space="preserve">
          <source>Space after last parenthesis matching on current line.</source>
          <target state="translated">Пробел после последнего совмещения скобок на текущей строке.</target>
        </trans-unit>
        <trans-unit id="155b83258e151629b360ae86e49e0abf46f96413" translate="yes" xml:space="preserve">
          <source>Space around a &quot;complex&quot; subscript (inside brackets).</source>
          <target state="translated">Пространство вокруг &quot;сложного&quot; абонемента (внутри скобок).</target>
        </trans-unit>
        <trans-unit id="3f9d9d7fddff18fb290d25d4e2d47eb10b024565" translate="yes" xml:space="preserve">
          <source>Space around most operators.</source>
          <target state="translated">Пространство вокруг большинства операторов.</target>
        </trans-unit>
        <trans-unit id="01ea9b6b043a2469906ded26f3a48de8eaf9e6e3" translate="yes" xml:space="preserve">
          <source>Space before the opening curly of a multi-line BLOCK.</source>
          <target state="translated">Пространство перед открытием вьющегося многострочного BLOCK.</target>
        </trans-unit>
        <trans-unit id="1109418eced3ecb23f96484aec5504c863ea2053" translate="yes" xml:space="preserve">
          <source>Spaces in the argument delimit distinct patterns, so &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('*.exe *.dll')&lt;/code&gt; globs all filenames that end in &lt;code&gt;.exe&lt;/code&gt; or &lt;code&gt;.dll&lt;/code&gt;. If you want to put in literal spaces in the glob pattern, you can escape them with either double quotes, or backslashes. e.g. &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/Program\ Files/*/*.dll')&lt;/code&gt; . The argument is tokenized using &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt; , so see &lt;a href=&quot;../text/parsewords&quot;&gt;Text::ParseWords&lt;/a&gt; for details of the quoting rules used.</source>
          <target state="translated">Пробелы в аргументе разделяют отдельные шаблоны, поэтому &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('*.exe *.dll')&lt;/code&gt; объединяет все имена файлов, которые заканчиваются на &lt;code&gt;.exe&lt;/code&gt; или &lt;code&gt;.dll&lt;/code&gt; . Если вы хотите поставить буквальные пробелы в шаблоне глобуса, вы можете экранировать их двойными кавычками или обратной косой чертой. например, &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/Program\ Files/*/*.dll')&lt;/code&gt; . Аргумент токенизируется с помощью &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt; , поэтому см. &lt;a href=&quot;../text/parsewords&quot;&gt;Text :: ParseWords&lt;/a&gt; для получения подробной информации об используемых правилах цитирования.</target>
        </trans-unit>
        <trans-unit id="39b253a2d834caa9ad3a83fa215c9eabff3effb2" translate="yes" xml:space="preserve">
          <source>Speaking of debugging, there are several pragmas available to control and debug regexps in Perl. We have already encountered one pragma in the previous section, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval';&lt;/code&gt; , that allows variable interpolation and code expressions to coexist in a regexp. The other pragmas are</source>
          <target state="translated">Говоря об отладке, есть несколько прагм, доступных для управления и отладки регулярных выражений в Perl. Мы уже встречали одну прагму в предыдущем разделе, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval';&lt;/code&gt; , что позволяет интерполяции переменных и кодовым выражениям сосуществовать в регулярном выражении. Другие прагмы</target>
        </trans-unit>
        <trans-unit id="5cdd144975003eba8959b061eba84041ab9e203b" translate="yes" xml:space="preserve">
          <source>Speaking of the build directory. Do I have to clean it up myself?</source>
          <target state="translated">Кстати,о каталоге сборки.Мне что,самому его убирать?</target>
        </trans-unit>
        <trans-unit id="cf16c389cb12320d4c2b7cc5db763c0d5676df4a" translate="yes" xml:space="preserve">
          <source>Speaking of things like &lt;code&gt;@{$AoA[$i]}&lt;/code&gt; , the following are actually the same thing:</source>
          <target state="translated">Говоря о таких вещах, как &lt;code&gt;@{$AoA[$i]}&lt;/code&gt; , на самом деле это одно и то же:</target>
        </trans-unit>
        <trans-unit id="735223734da1211964b616a8067d85971e38faaf" translate="yes" xml:space="preserve">
          <source>Special &lt;code&gt;make test&lt;/code&gt; targets</source>
          <target state="translated">Мишени для &lt;code&gt;make test&lt;/code&gt; специальных марок</target>
        </trans-unit>
        <trans-unit id="fdfdc56af4901b065f0b9e0022efafcd50dad6b5" translate="yes" xml:space="preserve">
          <source>Special Backtracking Control Verbs</source>
          <target state="translated">Специальные глаголы управления обратным движением</target>
        </trans-unit>
        <trans-unit id="59f265692e8532f3f9f4cf8098a358d626fbb2eb" translate="yes" xml:space="preserve">
          <source>Special Cases</source>
          <target state="translated">Специальные случаи</target>
        </trans-unit>
        <trans-unit id="c09831be5235393e990f8ebc035a5453fef09355" translate="yes" xml:space="preserve">
          <source>Special Characters Inside a Bracketed Character Class</source>
          <target state="translated">Специальные символы Внутри класса символов в квадратных скобках</target>
        </trans-unit>
        <trans-unit id="076a0893de022e884b65708a98aa1abe56ee52c6" translate="yes" xml:space="preserve">
          <source>Special Keys for &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt;</source>
          <target state="translated">Специальные клавиши для &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1bc7b98edc6763e9d6c0abf8b4fa80886e2046f" translate="yes" xml:space="preserve">
          <source>Special Keys for use overload</source>
          <target state="translated">Специальные ключи для использования при перегрузке</target>
        </trans-unit>
        <trans-unit id="749ad8df41c6024cc71b56ff395f77ccf401c88e" translate="yes" xml:space="preserve">
          <source>Special Literals</source>
          <target state="translated">Специальные буквы</target>
        </trans-unit>
        <trans-unit id="d4cb1cbcc64290386b7c11a130ff81a51320cc9f" translate="yes" xml:space="preserve">
          <source>Special Patterns</source>
          <target state="translated">Специальные модели</target>
        </trans-unit>
        <trans-unit id="f4d1e4b7e421f179bd6711768af6fd760a8db942" translate="yes" xml:space="preserve">
          <source>Special Topics</source>
          <target state="translated">Специальные темы</target>
        </trans-unit>
        <trans-unit id="93e61da05b321c91a757c91aeb83a231cf936002" translate="yes" xml:space="preserve">
          <source>Special behaviors for OS X</source>
          <target state="translated">Специальное поведение для OS X</target>
        </trans-unit>
        <trans-unit id="e0e39ed69d2c670390ee8a8802b8ef63f9291065" translate="yes" xml:space="preserve">
          <source>Special floating point: infinity (Inf) and not-a-number (NaN)</source>
          <target state="translated">Специальная плавающая запятая:бесконечность (Inf)и не-число (NaN)</target>
        </trans-unit>
        <trans-unit id="ca393fa33bfec26b8152f3f8b37c3b963f3cd851" translate="yes" xml:space="preserve">
          <source>Special make test targets</source>
          <target state="translated">Специальные цели тестирования</target>
        </trans-unit>
        <trans-unit id="3bc242af481a6d0584675ca62d67c528336abb44" translate="yes" xml:space="preserve">
          <source>Special note should be made of the return values for a few properties:</source>
          <target state="translated">Следует обратить особое внимание на возвращаемые значения для нескольких свойств:</target>
        </trans-unit>
        <trans-unit id="b129e56f9be43046b321c79a90495916b0276970" translate="yes" xml:space="preserve">
          <source>Special package variables when using &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;, see &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;. Because of this specialness &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; don't need to be declared (using &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt;) even when using the &lt;code&gt;strict 'vars'&lt;/code&gt; pragma. Don't lexicalize them with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $b&lt;/code&gt; if you want to be able to use them in the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; comparison block or function.</source>
          <target state="translated">Специальные переменные пакета при использовании &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; , см. &lt;a href=&quot;functions/sort&quot;&gt;Sort&lt;/a&gt; . Из-за этой особенности &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; не нужно объявлять (с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt; ) даже при использовании &lt;code&gt;strict 'vars'&lt;/code&gt; . Не лексизируйте их с помощью &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $a&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $b&lt;/code&gt; если вы хотите использовать их в блоке или функции сравнения &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c400e57824d764b6a1f1b8ed067b982b5491dad3" translate="yes" xml:space="preserve">
          <source>Special regop that is used by &lt;code&gt;re_intuit_start()&lt;/code&gt; to check if a pattern can match at a certain position. For instance if the regex engine knows that the pattern must start with a 'Z' then it can scan the string until it finds one and then launch the regex engine from there. The routine that handles this is called &lt;code&gt;find_by_class()&lt;/code&gt; . Sometimes this field points at a regop embedded in the program, and sometimes it points at an independent synthetic regop that has been constructed by the optimiser.</source>
          <target state="translated">Специальный regop, который используется &lt;code&gt;re_intuit_start()&lt;/code&gt; чтобы проверить, может ли шаблон совпадать в определенной позиции. Например, если механизм регулярных выражений знает, что шаблон должен начинаться с буквы &amp;laquo;Z&amp;raquo;, он может сканировать строку, пока не найдет ее, а затем запустить оттуда механизм регулярных выражений. Подпрограмма, которая обрабатывает это, называется &lt;code&gt;find_by_class()&lt;/code&gt; . Иногда это поле указывает на регистр, встроенный в программу, а иногда - на независимый синтетический регистр, созданный оптимизатором.</target>
        </trans-unit>
        <trans-unit id="d7c69507b8821a1ac319bfe089337d432b752233" translate="yes" xml:space="preserve">
          <source>Special thanks to Craig Berry and Peter Prymmer (for VMS portability help), Randy Kobes (for Win32 portability help), Clinton Pierce and Autrijus Tang (for heroic eleventh-hour Win32 testing above and beyond the call of duty), Michael G Schwern (for testing advice), and the rest of the CPAN testers (for testing generally).</source>
          <target state="translated">Особая благодарность Крейгу Берри и Питеру Прайммеру (за помощь в портативности VMS),Рэнди Кобесу (за помощь в портативности Win32),Клинтону Пирсу и Аустриюсу Тангу (за героическое одиннадцатичасовое тестирование Win32 сверх и сверх обязанности),Михаэлю Г.Шверну (за совет по тестированию),а также остальным CPAN-тестерам (за тестирование в целом).</target>
        </trans-unit>
        <trans-unit id="5543458d832e80fa74fffef1fb3a6e0c964fd937" translate="yes" xml:space="preserve">
          <source>Special thanks to Jarkko Hietaniemi, the 5.8.0 pumpking, for including this module in the core and for his patient and helpful guidance during the integration process.</source>
          <target state="translated">Особая благодарность Jarkko Hietaniemi,насос 5.8.0,за включение этого модуля в ядро,а также за его пациента и полезное руководство в процессе интеграции.</target>
        </trans-unit>
        <trans-unit id="bdc349ae3de267bae2e06e8394305bd25b3d697e" translate="yes" xml:space="preserve">
          <source>Special thanks to Tels for suggesting several speed and memory optimizations.</source>
          <target state="translated">Особая благодарность Tels за предложение нескольких оптимизаций скорости и памяти.</target>
        </trans-unit>
        <trans-unit id="58c72ff51f409e740d18b159d1db36db70f1453a" translate="yes" xml:space="preserve">
          <source>Special thanks to the following people who assisted in the creation of the document.</source>
          <target state="translated">Особая благодарность выражается следующим лицам,оказавшим содействие в создании документа.</target>
        </trans-unit>
        <trans-unit id="b9982eff3f0e28f25e92903f06ecf866a5e7dab5" translate="yes" xml:space="preserve">
          <source>Special variables that have side effects when you access them or assign to them. For example, in Perl, changing elements of the &lt;code&gt;%ENV&lt;/code&gt; array also changes the corresponding environment variables that subprocesses will use. Reading the &lt;code&gt;$!&lt;/code&gt; variable gives you the current system error number or message.</source>
          <target state="translated">Специальные переменные, которые имеют побочные эффекты при обращении к ним или назначении им. Например, в Perl изменение элементов массива &lt;code&gt;%ENV&lt;/code&gt; также изменяет соответствующие переменные среды, которые будут использовать подпроцессы. Читая &lt;code&gt;$!&lt;/code&gt; переменная дает вам номер текущей системной ошибки или сообщение.</target>
        </trans-unit>
        <trans-unit id="100bcda8aa4f874878478525651d3bbff5ff7492" translate="yes" xml:space="preserve">
          <source>Specialised Import Lists</source>
          <target state="translated">Специализированные импортные списки</target>
        </trans-unit>
        <trans-unit id="7b09828591f2a4848f0494348259138540610a11" translate="yes" xml:space="preserve">
          <source>Specific (mis)features of OS/2 port</source>
          <target state="translated">Конкретные (неправильные)особенности порта OS/2</target>
        </trans-unit>
        <trans-unit id="f1dec8c277f6ad361d73048827b65d45acdb1217" translate="yes" xml:space="preserve">
          <source>Specific features of the Cygwin port</source>
          <target state="translated">Особенности порта Cygwin</target>
        </trans-unit>
        <trans-unit id="686482526f9ca64e951de751df199a7ac0b21959" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Gives the directory part of the location for</source>
          <target state="translated">Специально для EMX-порта.Дает директорную часть местоположения для</target>
        </trans-unit>
        <trans-unit id="8719eacadd757c4d532ec01e84ca717f26242d45" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Should have the form</source>
          <target state="translated">Специально для EMX-порта.Должен иметь форму</target>
        </trans-unit>
        <trans-unit id="57a0519d586edded6d90f93d7b49b9ce56048c1e" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Since</source>
          <target state="translated">Специально для EMX-порта.С</target>
        </trans-unit>
        <trans-unit id="17684874cc7718b5fa207627bf38a956b3362a43" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Used as storage place for temporary files.</source>
          <target state="translated">Специально для EMX-порта.Используется как место хранения временных файлов.</target>
        </trans-unit>
        <trans-unit id="8ee5fb071a0f4fc5995dbb8fab061746ab818f7e" translate="yes" xml:space="preserve">
          <source>Specifically, we read pathnames one at a time from the input array, and store the results in an output array (results) in the same order. If statfs fails, the element pushed onto the return array is the value of errno after the failure. If statfs succeeds, though, the value pushed onto the return array is a reference to a hash containing some of the information in the statfs structure.</source>
          <target state="translated">В частности,из входного массива по очереди читаем патнамы,а результаты сохраняем в выходном массиве (результаты)в том же порядке.Если statfs не удается,то элемент,нажимаемый на возвращаемый массив,является значением errno после сбоя.Однако в случае успеха statfs,значение,вынесенное в массив возврата,является ссылкой на хэш,содержащий некоторую информацию в структуре statfs.</target>
        </trans-unit>
        <trans-unit id="eda3fdece3884b319c275582d4e0949e974b3c68" translate="yes" xml:space="preserve">
          <source>Specifically: Turning on this option will disable the heuristics for seeing only files with Perl-like extensions, omitting subdirectories that are numeric but do</source>
          <target state="translated">А именно:Включение этой опции отключит эвристику для просмотра только файлов с Perl--подобными расширениями,пропустив подкаталоги,которые являются числовыми,но не имеют значения</target>
        </trans-unit>
        <trans-unit id="ed81a4faa05daf1c1be51b7b8fa82d019bf30684" translate="yes" xml:space="preserve">
          <source>Specification for CPAN distribution metadata</source>
          <target state="translated">Спецификация метаданных распределения CPAN</target>
        </trans-unit>
        <trans-unit id="73a4072f8995fd4faf63509594cc45d51dcda62a" translate="yes" xml:space="preserve">
          <source>Specified line by line via &lt;b&gt;-e&lt;/b&gt; or &lt;b&gt;-E&lt;/b&gt; switches on the command line.</source>
          <target state="translated">Указывается построчно с помощью переключателей &lt;b&gt;-e&lt;/b&gt; или &lt;b&gt;-E&lt;/b&gt; в командной строке.</target>
        </trans-unit>
        <trans-unit id="acc937be340e9018f067e36d4fbe600f0ca7a48d" translate="yes" xml:space="preserve">
          <source>Specifies a TAP::Harness subclass to be used in place of TAP::Harness.</source>
          <target state="translated">Указание подкласса TAP::Harness,который будет использоваться вместо TAP::Harness.</target>
        </trans-unit>
        <trans-unit id="2ccb38b1ea1946cfb54e7b524ba85568b166e308" translate="yes" xml:space="preserve">
          <source>Specifies a name to be used for the extension, e.g., -n RPC::DCE</source>
          <target state="translated">Указывает имя,которое будет использоваться для расширения,например,-n RPC::DCE</target>
        </trans-unit>
        <trans-unit id="fb10437a9b9ee94fe2ef27d29d4fd6290157541f" translate="yes" xml:space="preserve">
          <source>Specifies an encoding to store lexicon entries, instead of utf8-strings. If set to &lt;code&gt;locale&lt;/code&gt; , the encoding from the current locale setting is used. Implies a true value for &lt;code&gt;Decode&lt;/code&gt; .</source>
          <target state="translated">Задает кодировку для хранения словарных статей вместо строк utf8. Если установлен &lt;code&gt;locale&lt;/code&gt; , используется кодировка из текущего языкового стандарта. Подразумевает истинное значение для &lt;code&gt;Decode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5288f1281b330410c08afae34819d7cfc53b87f4" translate="yes" xml:space="preserve">
          <source>Specifies any additional arguments to pass to the compiler. Should be given as a list reference containing the arguments individually, or if this is not possible, as a string containing all the arguments together.</source>
          <target state="translated">Указание любых дополнительных аргументов для передачи компилятору.Должна быть дана как ссылка на список,содержащий аргументы по отдельности,или,если это невозможно,как строка,содержащая все аргументы вместе.</target>
        </trans-unit>
        <trans-unit id="8c0fc5c465acc07c545f1645a7b4737064b57885" translate="yes" xml:space="preserve">
          <source>Specifies any additional directories in which to search for header files. May be given as a string indicating a single directory, or as a list reference indicating multiple directories.</source>
          <target state="translated">Указание дополнительных каталогов для поиска заголовочных файлов.Может быть задано в виде строки,указывающей на один каталог,или в виде ссылки на список,указывающий на несколько каталогов.</target>
        </trans-unit>
        <trans-unit id="df5f877cdfce163f364b76c3bfab4e6c5095d6d8" translate="yes" xml:space="preserve">
          <source>Specifies file structure for file to be transferred.</source>
          <target state="translated">Определяет структуру файла для передачи.</target>
        </trans-unit>
        <trans-unit id="087e5ef636ea46b335e961f7299045a135d4c08f" translate="yes" xml:space="preserve">
          <source>Specifies how much effort bzip2 should take before resorting to a slower fallback compression algorithm.</source>
          <target state="translated">Указывает,сколько усилий должен приложить bzip2,прежде чем прибегнуть к более медленному алгоритму обратного сжатия.</target>
        </trans-unit>
        <trans-unit id="98ed6b009cf98007a6f6d9bd7e33d610c98ad8ec" translate="yes" xml:space="preserve">
          <source>Specifies one or more directories to search for the input file if it was not supplied with an absolute path. Each directory path in the given list should be separated by a ':' on Unix (';' on MSWin32 and DOS).</source>
          <target state="translated">Указание одного или нескольких каталогов для поиска входного файла,если он не поставляется с абсолютным путем.Каждый путь к каталогу в данном списке должен быть разделен знаком ':' на Unix (';' на MSWin32 и DOS).</target>
        </trans-unit>
        <trans-unit id="1b9774b42720c2ff28dbc21e628ebcd3703ef058" translate="yes" xml:space="preserve">
          <source>Specifies that the source file is a C++ source file and sets appropriate compiler flags</source>
          <target state="translated">Указывает,что исходный файл является C++исходным файлом,и устанавливает соответствующие флаги компилятора.</target>
        </trans-unit>
        <trans-unit id="752f5b793296a2436f0f638671fc26add2789004" translate="yes" xml:space="preserve">
          <source>Specifies that this distribution shall not be processed at all.</source>
          <target state="translated">Указывает,что это распределение вообще не должно обрабатываться.</target>
        </trans-unit>
        <trans-unit id="27c19b2359d6f4ac0335e1401df42879661c8cd1" translate="yes" xml:space="preserve">
          <source>Specifies the directory to use for the temporary directory. The temporary directory name is derived from an internal template.</source>
          <target state="translated">Указание каталога для использования во временном каталоге.Имя временного каталога берется из внутреннего шаблона.</target>
        </trans-unit>
        <trans-unit id="69c1bcd4ebd70c8615309d5b9b715199cd57859f" translate="yes" xml:space="preserve">
          <source>Specifies the encoding you are converting from. Unlike &lt;b&gt;iconv&lt;/b&gt;, this option can be omitted. In such cases, the current locale is used.</source>
          <target state="translated">Задает кодировку, из которой выполняется преобразование. В отличие от &lt;b&gt;iconv&lt;/b&gt; , этот параметр можно не указывать. В таких случаях используется текущий языковой стандарт.</target>
        </trans-unit>
        <trans-unit id="b6aabb58f01ed0bc266ebcb530fd5e3060867e4c" translate="yes" xml:space="preserve">
          <source>Specifies the encoding you are converting to. Unlike &lt;b&gt;iconv&lt;/b&gt;, this option can be omitted. In such cases, the current locale is used.</source>
          <target state="translated">Задает кодировку, в которую вы конвертируете. В отличие от &lt;b&gt;iconv&lt;/b&gt; , этот параметр можно не указывать. В таких случаях используется текущий языковой стандарт.</target>
        </trans-unit>
        <trans-unit id="bc14cf57cc1d526c9df38cf39a2a5e11891e51ad" translate="yes" xml:space="preserve">
          <source>Specifies the extension of the module's loadable object. For example:</source>
          <target state="translated">Задает расширение загружаемого объекта модуля.Например:</target>
        </trans-unit>
        <trans-unit id="62350db256aee74b2119a37a32d38d1a559bd3c6" translate="yes" xml:space="preserve">
          <source>Specifies the method or subroutine to use when printing error messages about POD syntax. The supplied method/subroutine</source>
          <target state="translated">Указывает метод или подпрограмму для использования при печати сообщений об ошибках синтаксиса POD.Поставляемый метод/подпрограмма</target>
        </trans-unit>
        <trans-unit id="8490adfe21694bc6560acb4c4b017183f5259a5a" translate="yes" xml:space="preserve">
          <source>Specifies the name of the Perl module that will be created by linking. On platforms that need to do prelinking (Win32, OS/2, etc.) this is a required parameter.</source>
          <target state="translated">Указывает имя модуля Perl,который будет создан путем линковки.На платформах,которые должны делать предварительную линковку (Win32,OS/2 и т.д.)это обязательный параметр.</target>
        </trans-unit>
        <trans-unit id="f6fab30529e40665f8d0178ef7752b76fb583aec" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output executable file to create. Otherwise the &lt;code&gt;exe_file()&lt;/code&gt; method will be consulted, passing it the name of the first entry in &lt;code&gt;objects&lt;/code&gt; .</source>
          <target state="translated">Задает имя создаваемого выходного исполняемого файла. В противном случае будет &lt;code&gt;exe_file()&lt;/code&gt; метод exe_file () , передавая ему имя первой записи в &lt;code&gt;objects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="712c7b0a7198fb19bf2fcbbf1b68671ab3789d42" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output file to create. Otherwise the &lt;code&gt;object_file()&lt;/code&gt; method will be consulted, passing it the name of the &lt;code&gt;source&lt;/code&gt; file.</source>
          <target state="translated">Задает имя создаваемого выходного файла. В противном случае будет &lt;code&gt;object_file()&lt;/code&gt; метод object_file () , передавая ему имя &lt;code&gt;source&lt;/code&gt; файла.</target>
        </trans-unit>
        <trans-unit id="0ea5fb9dc13c7dfd946c4f0ec1f502d959136293" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output file to generate. If no file is specified, output will be written to standard output.</source>
          <target state="translated">Указывает имя генерируемого выходного файла.Если файл не указан,вывод будет записан в стандартный выходной файл.</target>
        </trans-unit>
        <trans-unit id="95eb37279bd4905df986dc0709bc7910f0b3037c" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output library file to create. Otherwise the &lt;code&gt;lib_file()&lt;/code&gt; method will be consulted, passing it the name of the first entry in &lt;code&gt;objects&lt;/code&gt; .</source>
          <target state="translated">Задает имя создаваемого файла выходной библиотеки. В противном случае будет использоваться метод &lt;code&gt;lib_file()&lt;/code&gt; , передавая ему имя первой записи в &lt;code&gt;objects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fc8b469ff5b98736322a31c19a8ffad03de9557" translate="yes" xml:space="preserve">
          <source>Specifies the string that will be prefixed to every line of the output. Empty string by default.</source>
          <target state="translated">Определяет строку,которая будет префиксом к каждой строке вывода.Пустая строка по умолчанию.</target>
        </trans-unit>
        <trans-unit id="969aa343df55e9a403d592d5b7e666d694e7c272" translate="yes" xml:space="preserve">
          <source>Specifies transfer mode (stream, block or compressed) for file to be transferred.</source>
          <target state="translated">Определяет режим передачи (поток,блок или сжатие)для передаваемого файла.</target>
        </trans-unit>
        <trans-unit id="9e50a3555457e006ff9201a0e994fbe18d143981" translate="yes" xml:space="preserve">
          <source>Specify Perl version requirements with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Укажите требования к версии Perl с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a389cd0788a594b00d81ac38b0d5b58f982bb23" translate="yes" xml:space="preserve">
          <source>Specify a collation strength of level 1 to ignore case and diacritics, only looking at the basic character.</source>
          <target state="translated">Укажите силу сопоставления 1-го уровня,чтобы игнорировать регистр и диакритические знаки,глядя только на основного персонажа.</target>
        </trans-unit>
        <trans-unit id="fd9decfe42c6333527f5da43637561403cd51753" translate="yes" xml:space="preserve">
          <source>Specify a prefix which should be removed from the Perl function names, e.g., -p sec_rgy_ This sets up the XS &lt;b&gt;PREFIX&lt;/b&gt; keyword and removes the prefix from functions that are autoloaded via the &lt;code&gt;constant()&lt;/code&gt; mechanism.</source>
          <target state="translated">Укажите префикс, который следует удалить из имен функций Perl, например, -p sec_gery_. Это устанавливает ключевое слово XS &lt;b&gt;PREFIX&lt;/b&gt; и удаляет префикс из функций, которые автоматически загружаются с помощью механизма &lt;code&gt;constant()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c37cb69f6acc79919a59db7bb047596246ded37" translate="yes" xml:space="preserve">
          <source>Specify a section to include in the output. See &lt;a href=&quot;pod/parser#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS in Pod::Parser&lt;/a&gt; for the format to use for</source>
          <target state="translated">Укажите раздел, который нужно включить в вывод. См. &lt;a href=&quot;pod/parser#SECTION-SPECIFICATIONS&quot;&gt;СПЕЦИФИКАЦИИ РАЗДЕЛА в Pod :: Parser,&lt;/a&gt; чтобы узнать о формате, который будет использоваться для</target>
        </trans-unit>
        <trans-unit id="c842e0100e27043e97262bc2a56a8695e0228b4b" translate="yes" xml:space="preserve">
          <source>Specify a version number for this extension. This version number is added to the templates. The default is 0.01, or 0.00_01 if &lt;code&gt;-B&lt;/code&gt; is specified. The version specified should be numeric.</source>
          <target state="translated">Укажите номер версии для этого расширения. Этот номер версии добавлен в шаблоны. По умолчанию 0,01 или 0,00_01, если указан &lt;code&gt;-B&lt;/code&gt; . Указанная версия должна быть числовой.</target>
        </trans-unit>
        <trans-unit id="e7f58f2c2dcff1260c061c4b22f076c9afef1f52" translate="yes" xml:space="preserve">
          <source>Specify content is binary</source>
          <target state="translated">Укажите содержание является двоичным</target>
        </trans-unit>
        <trans-unit id="196ff6b62a23b7ba506c7490495c47cea5d35955" translate="yes" xml:space="preserve">
          <source>Specify in seconds how long to run the command before it is killed with SIG_KILL (9), which effectively terminates it and all of its children (direct or indirect).</source>
          <target state="translated">Укажите в секундах,сколько времени нужно для выполнения команды перед ее уничтожением с помощью SIG_KILL (9),которая эффективно уничтожает ее и всех ее дочерних элементов (прямых или косвенных).</target>
        </trans-unit>
        <trans-unit id="e42f9f14e720a274b615a5fad1a17e292745c606" translate="yes" xml:space="preserve">
          <source>Specify pre-requisites in Makefile.PL or Build.PL</source>
          <target state="translated">Укажите предварительные требования в Makefile.PL или Build.PL.</target>
        </trans-unit>
        <trans-unit id="1a3e3b8941c020b4dead165334a6a7f6f39e0c5c" translate="yes" xml:space="preserve">
          <source>Specify replacement for groff</source>
          <target state="translated">Укажите замену для гроффа</target>
        </trans-unit>
        <trans-unit id="82792121ccf914c52ccf31c689a51331bdf9896b" translate="yes" xml:space="preserve">
          <source>Specify some text that will be passed into the &lt;code&gt;STDIN&lt;/code&gt; of the executed program.</source>
          <target state="translated">Укажите текст, который будет передан в &lt;code&gt;STDIN&lt;/code&gt; исполняемой программы.</target>
        </trans-unit>
        <trans-unit id="e4f8120097eb5801ad49966dad7112d6c8bcad54" translate="yes" xml:space="preserve">
          <source>Specify stream encoding. This is the normal way to deal with encoded text, not by calling low-level functions.</source>
          <target state="translated">Укажите кодировку потока.Это обычный способ работы с кодированным текстом,а не вызов низкоуровневых функций.</target>
        </trans-unit>
        <trans-unit id="8473cee86e4b03ee43a6c19c0f0dc45619e13394" translate="yes" xml:space="preserve">
          <source>Specify the HTML file to create. Output goes to STDOUT if no outfile is specified.</source>
          <target state="translated">Укажите создаваемый HTML-файл.Выводится STDOUT,если исходный файл не указан.</target>
        </trans-unit>
        <trans-unit id="2deadb9e68c32c96f8a837b13d5dc23a9778d417" translate="yes" xml:space="preserve">
          <source>Specify the URL of a cascading style sheet. Also disables all HTML/CSS &lt;code&gt;style&lt;/code&gt; attributes that are output by default (to avoid conflicts).</source>
          <target state="translated">Укажите URL-адрес каскадной таблицы стилей. Также отключает все атрибуты &lt;code&gt;style&lt;/code&gt; HTML / CSS , которые выводятся по умолчанию (во избежание конфликтов).</target>
        </trans-unit>
        <trans-unit id="4aa99f54409387b7146f47653777c920418ff10b" translate="yes" xml:space="preserve">
          <source>Specify the URL of cascading style sheet to link from resulting HTML file. Default is none style sheet.</source>
          <target state="translated">Укажите URL каскадной таблицы стилей для ссылки из полученного HTML-файла.По умолчанию нет таблицы стилей.</target>
        </trans-unit>
        <trans-unit id="9afcf7f83edb719a030bfbfd6d7f5c91cf7f8d6b" translate="yes" xml:space="preserve">
          <source>Specify the base directory for finding library pods.</source>
          <target state="translated">Укажите базовый каталог для поиска стручков библиотек.</target>
        </trans-unit>
        <trans-unit id="44291a4ec495223a1da4f1839ae4e831f5a3c791" translate="yes" xml:space="preserve">
          <source>Specify the base directory for finding library pods. Default is the current working directory.</source>
          <target state="translated">Укажите базовый каталог для поиска стручков библиотек.По умолчанию это текущая рабочая директория.</target>
        </trans-unit>
        <trans-unit id="bc5534a64aa32340e65ed43e45968b60d705f9fc" translate="yes" xml:space="preserve">
          <source>Specify the internal type that the constant() mechanism uses for macros. The default is IV (signed integer). Currently all macros found during the header scanning process will be assumed to have this type. Future versions of &lt;code&gt;h2xs&lt;/code&gt; may gain the ability to make educated guesses.</source>
          <target state="translated">Укажите внутренний тип, который механизм constant () использует для макросов. Значение по умолчанию - IV (целое число со знаком). В настоящее время предполагается, что все макросы, обнаруженные в процессе сканирования заголовка, имеют этот тип. Будущие версии &lt;code&gt;h2xs&lt;/code&gt; могут получить способность делать обоснованные предположения.</target>
        </trans-unit>
        <trans-unit id="a20b2619004bea1e14f0e7f2949d240b1952dd51" translate="yes" xml:space="preserve">
          <source>Specify the number of 100K blocks bzip2 uses during compression.</source>
          <target state="translated">Укажите количество блоков по 100К,используемых bzip2 во время сжатия.</target>
        </trans-unit>
        <trans-unit id="1d869ecbc9c626d4a96da51d8e392c8fcdb22cdc" translate="yes" xml:space="preserve">
          <source>Specify the pod file to convert. Input is taken from STDIN if no infile is specified.</source>
          <target state="translated">Укажите файл под,который нужно конвертировать.Ввод берется из STDIN,если файл не указан.</target>
        </trans-unit>
        <trans-unit id="2bed91a5a620b4aae10dcfd8cbca6e35a0ef51dd" translate="yes" xml:space="preserve">
          <source>Specify the targets for testing.</source>
          <target state="translated">Укажите цели для тестирования.</target>
        </trans-unit>
        <trans-unit id="21bb885000d067ff7c549508e4dd3407f52920a2" translate="yes" xml:space="preserve">
          <source>Specify the title of the resulting HTML file.</source>
          <target state="translated">Укажите название полученного HTML-файла.</target>
        </trans-unit>
        <trans-unit id="46f23c724776424563c656a058b3155bcce7e71b" translate="yes" xml:space="preserve">
          <source>Specify version requirements for other Perl modules in the pre-requisites in your Makefile.PL or Build.PL.</source>
          <target state="translated">Укажите требования к версии для других Perl-модулей в предварительных требованиях в Makefile.PL или Build.PL.</target>
        </trans-unit>
        <trans-unit id="8bd129aeb5d58a2d4cd81a32d015c916c4dfff29" translate="yes" xml:space="preserve">
          <source>Specify which directory is used for storing cache. Default directory is the current working directory.</source>
          <target state="translated">Укажите,какой каталог используется для хранения кэша.Каталог по умолчанию-текущий рабочий каталог.</target>
        </trans-unit>
        <trans-unit id="c06413cd34d05ffad8b760e0ccbb2a8039560c0e" translate="yes" xml:space="preserve">
          <source>Specify which subdirectories of the podroot contain pod files whose HTML converted forms can be linked to in cross references.</source>
          <target state="translated">Укажите,в каких подкаталогах подрута содержатся файлы под,на которые можно ссылаться в перекрестных ссылках на HTML преобразованные формы.</target>
        </trans-unit>
        <trans-unit id="4ed9289cec9db507a9bd1e2cf8a443192d39f482" translate="yes" xml:space="preserve">
          <source>Specify which subdirectories of the podroot contain pod files whose HTML converted forms can be linked-to in cross-references.</source>
          <target state="translated">Укажите,в каких подкаталогах podroot находятся файлы pod,на которые в перекрестных ссылках можно ссылаться в форме,преобразованной в HTML.</target>
        </trans-unit>
        <trans-unit id="cda870361643b1e3b5ceca1a143c1054b6477609" translate="yes" xml:space="preserve">
          <source>Specifying VERSION as a literal of the form v5.6.1 should generally be avoided, because it leads to misleading error messages under earlier versions of Perl (that is, prior to 5.6.0) that do not support this syntax. The equivalent numeric version should be used instead.</source>
          <target state="translated">Как правило,следует избегать указания VERSION как литерала формы v5.6.1,так как это приводит к вводящим в заблуждение сообщениям об ошибках в более ранних версиях Perl (т.е.до 5.6.0),которые не поддерживают этот синтаксис.Вместо этого следует использовать эквивалентную цифровую версию.</target>
        </trans-unit>
        <trans-unit id="4cc4c6ab0a0e40b55ad8e487edeab38628dd47f2" translate="yes" xml:space="preserve">
          <source>Specifying VERSION as a literal of the form v5.6.1 should generally be avoided, because it leads to misleading error messages under earlier versions of Perl that do not support this syntax. The equivalent numeric version should be used instead.</source>
          <target state="translated">Как правило,следует избегать указания VERSION как литерала формы v5.6.1,так как это приводит к вводящим в заблуждение сообщениям об ошибках в более ранних версиях Perl,которые не поддерживают этот синтаксис.Вместо этого следует использовать эквивалентную цифровую версию.</target>
        </trans-unit>
        <trans-unit id="105a66a84ae1308320a2e6185af2d7c0f4640974" translate="yes" xml:space="preserve">
          <source>Specifying Values</source>
          <target state="translated">Указание значений</target>
        </trans-unit>
        <trans-unit id="6ddacaf845437713514dee82096d8d2996a0782a" translate="yes" xml:space="preserve">
          <source>Specifying a compatibility version higher than the version of perl you are using to run h2xs will have no effect. If unspecified h2xs will default to compatibility with the version of perl you are using to run h2xs.</source>
          <target state="translated">Указание версии совместимости выше версии perl,которую вы используете для запуска h2xs,не будет иметь никакого эффекта.Если неуказанные h2xs будут по умолчанию совместимы с версией perl,которую вы используете для запуска h2xs.</target>
        </trans-unit>
        <trans-unit id="b9ac38be3885e820db907e52feea151509c97c14" translate="yes" xml:space="preserve">
          <source>Specifying a negative flag after the caret is an error, as the flag is redundant.</source>
          <target state="translated">Указание отрицательного флага после каретты является ошибкой,так как флаг является избыточным.</target>
        </trans-unit>
        <trans-unit id="fcb93594508dd14f6f183606eef58af67f897bab" translate="yes" xml:space="preserve">
          <source>Specifying a negative index position greater than the number of items in the queue adds the list to the head of the queue.</source>
          <target state="translated">Указание отрицательной позиции индекса больше,чем количество элементов в очереди добавляет список в заголовок очереди.</target>
        </trans-unit>
        <trans-unit id="90e80e764794a3f53d9bd22d3f4959b3c3e8e8c0" translate="yes" xml:space="preserve">
          <source>Specifying an index position greater than the number of items in the queue just adds the list to the end.</source>
          <target state="translated">Указание позиции индекса,превышающей количество элементов в очереди,просто добавляет список в конец.</target>
        </trans-unit>
        <trans-unit id="9c224eb1496ab5698ab91d2a22838e04eaf02d0d" translate="yes" xml:space="preserve">
          <source>Specifying an index position greater than the number of items in the queue results in &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list being returned.</source>
          <target state="translated">Если указать позицию индекса, превышающую количество элементов в очереди , возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; или пустой список.</target>
        </trans-unit>
        <trans-unit id="8b369061e994be9b95b9b52fd041d04e9eccbbae" translate="yes" xml:space="preserve">
          <source>Specifying sub-versions such as the &lt;code&gt;0&lt;/code&gt; in &lt;code&gt;5.14.0&lt;/code&gt; in feature bundles has no effect. Feature bundles are guaranteed to be the same for all sub-versions.</source>
          <target state="translated">Указание &lt;code&gt;5.14.0&lt;/code&gt; таких как &lt;code&gt;0&lt;/code&gt; в 5.14.0, в пакетах функций не имеет никакого эффекта. Пакеты функций гарантированно будут одинаковыми для всех подверсий.</target>
        </trans-unit>
        <trans-unit id="79a6f96c957e7feef1314dc46564cc00f5833bc6" translate="yes" xml:space="preserve">
          <source>Specifying the &quot;udp&quot; protocol causes the ping() method to send a udp packet to the remote host's echo port. If the echoed packet is received from the remote host and the received packet contains the same data as the packet that was sent, the remote host is considered reachable. This protocol does not require any special privileges. It should be borne in mind that, for a udp ping, a host will be reported as unreachable if it is not running the appropriate echo service. For Unix-like systems see</source>
          <target state="translated">Указание протокола &quot;udp&quot; приводит к тому,что метод ping()посылает udp-пакет на эхо-порт удаленного хоста.Если эхо-пакет получен от удаленного хоста и полученный пакет содержит те же данные,что и пакет,который был отправлен,то удаленный хост считается доступным.Этот протокол не требует никаких специальных привилегий.Следует помнить,что для udp ping,хост будет считаться недоступным,если он не запустил соответствующую эхо-службу.Для Unix-подобных систем см.</target>
        </trans-unit>
        <trans-unit id="2819720e6a0b64709090cd36c99161c9c51d2535" translate="yes" xml:space="preserve">
          <source>Specifying the G_DISCARD flag with</source>
          <target state="translated">Указание флага G_DISCARD с помощью кнопки</target>
        </trans-unit>
        <trans-unit id="2d2cb022bc3d26bd1407c4aa787d5e46e1ad4c3b" translate="yes" xml:space="preserve">
          <source>Speed</source>
          <target state="translated">Speed</target>
        </trans-unit>
        <trans-unit id="40e5809be52d66c56af4f3807fbc74465fe77f2b" translate="yes" xml:space="preserve">
          <source>Spherical coordinates,</source>
          <target state="translated">Сферические координаты,</target>
        </trans-unit>
        <trans-unit id="0bce309883c4786c8f96950f6206dff26186fc2b" translate="yes" xml:space="preserve">
          <source>Split a directory specification into the components.</source>
          <target state="translated">Разделите спецификацию каталога на компоненты.</target>
        </trans-unit>
        <trans-unit id="0e9eed69886886b90fb3afa01fba40f13ff4d0a7" translate="yes" xml:space="preserve">
          <source>Split a package for autoloading</source>
          <target state="translated">Разделите пакет для автозагрузки</target>
        </trans-unit>
        <trans-unit id="0a230284c2746978c6d208e00f352e0d6fb5d918" translate="yes" xml:space="preserve">
          <source>Split out from Safe module version 1, named opcode tags and other changes added by Tim Bunce.</source>
          <target state="translated">Отделите от Safe модуля версию 1,названные опкодовые теги и другие изменения,добавленные Тимом Бансом.</target>
        </trans-unit>
        <trans-unit id="273ddbe310d23df41c94915a842b407f242c4749" translate="yes" xml:space="preserve">
          <source>Splits a path in to volume, directory, and filename portions. On systems with no concept of volume, returns '' for volume.</source>
          <target state="translated">Разделяет путь на части тома,каталога и имени файла.На системах без понятия тома возвращает '' для тома.</target>
        </trans-unit>
        <trans-unit id="334895ed21abe595a625b2f1658f99e01bbe8d40" translate="yes" xml:space="preserve">
          <source>Splits a path into volume, directory, and filename portions.</source>
          <target state="translated">Разбивает путь на части тома,каталога и имени файла.</target>
        </trans-unit>
        <trans-unit id="9683042273a4ecd00e523d0bde1551fc4f8c1380" translate="yes" xml:space="preserve">
          <source>Splits a path into volume, directory, and filename portions. Assumes that the last file is a path unless the path ends in '\\', '\\.', '\\..' or $no_file is true. On Win32 this means that $no_file true makes this return ( $volume, $path, '' ).</source>
          <target state="translated">Разбивает путь на части тома,каталога и имени файла.Предположительно,последний файл-это путь,если он не заканчивается на '\\','\\.','\\...' или $no_file is true.На Win32 это означает,что $no_file true возвращает это значение($ volume,$path,'').</target>
        </trans-unit>
        <trans-unit id="86fed3cc24e2d19645e7064b9a14b47a5f182fe6" translate="yes" xml:space="preserve">
          <source>Splits a path into volume, directory, and filename portions. On systems with no concept of volume, returns '' for volume.</source>
          <target state="translated">Разбивает путь на части тома,каталога и имени файла.На системах без понятия тома возвращает '' для тома.</target>
        </trans-unit>
        <trans-unit id="5d39c4c6b066b235387ae82c04d47c7856f6398b" translate="yes" xml:space="preserve">
          <source>Splits the string EXPR into a list of strings and returns the list in list context, or the size of the list in scalar context.</source>
          <target state="translated">Разделяет строку EXPR на список строк и возвращает список в контексте списка,или размер списка в контексте скаляра.</target>
        </trans-unit>
        <trans-unit id="250f996321b0ccf8a0a091d8ad8d1f0defcbee6b" translate="yes" xml:space="preserve">
          <source>Splitting up a program text into &lt;b&gt;tokens&lt;/b&gt;. Also known as &amp;ldquo;lexing&amp;rdquo;, in which case you get &amp;ldquo;lexemes&amp;rdquo; instead of tokens.</source>
          <target state="translated">Разбиение текста программы на &lt;b&gt;токены&lt;/b&gt; . Также известен как &amp;laquo;лексирование&amp;raquo;, и в этом случае вы получаете &amp;laquo;лексемы&amp;raquo; вместо токенов.</target>
        </trans-unit>
        <trans-unit id="785ca9526809c90e3417966be7d5844fd2a0c5c8" translate="yes" xml:space="preserve">
          <source>Stability</source>
          <target state="translated">Stability</target>
        </trans-unit>
        <trans-unit id="699cbcfa1d2de31b511ffab2c2a0ef9730993e7e" translate="yes" xml:space="preserve">
          <source>Stable CPAN modules</source>
          <target state="translated">Стабильные CPAN модули</target>
        </trans-unit>
        <trans-unit id="0c37e4671699616f1b661a8adda9cc25f7e7c380" translate="yes" xml:space="preserve">
          <source>Stable modules should maintain backwards compatibility</source>
          <target state="translated">Стабильные модули должны поддерживать обратную совместимость</target>
        </trans-unit>
        <trans-unit id="e59f32f5132f95bd8522cf0423d93b2b074371e3" translate="yes" xml:space="preserve">
          <source>Stack Manipulation Macros</source>
          <target state="translated">Макросы манипулирования стеком</target>
        </trans-unit>
        <trans-unit id="d3f19bccf79868f3c579b95c4b4aa5c3173cdfc2" translate="yes" xml:space="preserve">
          <source>Stack Overflow is a free question-and-answer site for programmers. It's not focussed solely on Perl, but it does have an active group of users who do their best to help people with their Perl programming questions.</source>
          <target state="translated">Stack Overflow-бесплатный сайт вопросов и ответов для программистов.Он не сфокусирован исключительно на Perl,но у него есть активная группа пользователей,которые делают все возможное,чтобы помочь людям с их вопросами по программированию на Perl.</target>
        </trans-unit>
        <trans-unit id="79c0915aad1c8e4662635799d017c78213056099" translate="yes" xml:space="preserve">
          <source>Stack Trace formatting</source>
          <target state="translated">Форматирование трассировки стека</target>
        </trans-unit>
        <trans-unit id="c32c5432806926c51af3a6d722094d1b8498ee67" translate="yes" xml:space="preserve">
          <source>Stack marker variable for the XSUB. See &lt;code&gt;dMARK&lt;/code&gt; .</source>
          <target state="translated">Переменная маркера стека для XSUB. См. &lt;code&gt;dMARK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abb5c52ccc52723cd1612e07bb13d70407d8e476" translate="yes" xml:space="preserve">
          <source>Stack pointer. This is usually handled by &lt;code&gt;xsubpp&lt;/code&gt; . See &lt;code&gt;dSP&lt;/code&gt; and &lt;code&gt;SPAGAIN&lt;/code&gt; .</source>
          <target state="translated">Указатель стека. Обычно этим занимается &lt;code&gt;xsubpp&lt;/code&gt; . Смотрите &lt;code&gt;dSP&lt;/code&gt; и &lt;code&gt;SPAGAIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7eeeffb91b556017b0569617dac90bb982af82c6" translate="yes" xml:space="preserve">
          <source>Stack size discussion: &lt;a href=&quot;http://www.perlmonks.org/?node_id=532956&quot;&gt;http://www.perlmonks.org/?node_id=532956&lt;/a&gt;</source>
          <target state="translated">Обсуждение размера стека: &lt;a href=&quot;http://www.perlmonks.org/?node_id=532956&quot;&gt;http://www.perlmonks.org/?node_id=532956&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5972ab200f32099d27f68650121e9738cdd0e0dc" translate="yes" xml:space="preserve">
          <source>Standard Exports</source>
          <target state="translated">Стандартный экспорт</target>
        </trans-unit>
        <trans-unit id="615e5b98a32ea52bb60f7df7a2666749db3e59ab" translate="yes" xml:space="preserve">
          <source>Standard I/O functions via VMS extensions</source>
          <target state="translated">Стандартные функции ввода/вывода через расширения ЗИС</target>
        </trans-unit>
        <trans-unit id="fbc014247a90e3e9471cd43027f6ed1dd5022323" translate="yes" xml:space="preserve">
          <source>Standard Modules</source>
          <target state="translated">Стандартные модули</target>
        </trans-unit>
        <trans-unit id="fcb1fc559ce28778664dae993a8bd3c9c1e13c04" translate="yes" xml:space="preserve">
          <source>Standard codes for country identification</source>
          <target state="translated">Стандартные коды для идентификации страны</target>
        </trans-unit>
        <trans-unit id="60f2260734e540712fc0b3a84eed77018b10ca66" translate="yes" xml:space="preserve">
          <source>Standard codes for currency identification</source>
          <target state="translated">Стандартные коды для идентификации валюты</target>
        </trans-unit>
        <trans-unit id="b5deda2e5280ead9cecc60bbf30d177abf9ec4ea" translate="yes" xml:space="preserve">
          <source>Standard codes for language extension identification</source>
          <target state="translated">Стандартные коды для идентификации расширения языка</target>
        </trans-unit>
        <trans-unit id="f2ee3631bc2f34f1c73413a9d2061ce03c5ab44f" translate="yes" xml:space="preserve">
          <source>Standard codes for language identification</source>
          <target state="translated">Стандартные коды для языковой идентификации</target>
        </trans-unit>
        <trans-unit id="10a16afeaf36afe90baa03b4e90894540cc06be0" translate="yes" xml:space="preserve">
          <source>Standard codes for language variation identification</source>
          <target state="translated">Стандартные коды для идентификации языковых вариаций</target>
        </trans-unit>
        <trans-unit id="b1589d1520251236f9eb362681e4874ce8c5e9ee" translate="yes" xml:space="preserve">
          <source>Standard codes for script identification</source>
          <target state="translated">Стандартные коды для скриптовой идентификации</target>
        </trans-unit>
        <trans-unit id="5d6d11511a070bcf17fa4eb2391ebf6e7a493c05" translate="yes" xml:space="preserve">
          <source>Standard modules with VMS-specific differences</source>
          <target state="translated">Стандартные модули со специфическими для VMS различиями</target>
        </trans-unit>
        <trans-unit id="de92c20ac3781f514b3f3e2c2c6d7cf3cd1b6af8" translate="yes" xml:space="preserve">
          <source>Standard, bundled modules are all expected to behave in a well-defined manner with respect to namespace pollution because they use the Exporter module. See their own documentation for details.</source>
          <target state="translated">Ожидается,что все стандартные модули в комплекте будут вести себя четко определенным образом в отношении загрязнения пространства имён,поскольку они используют модуль Exporter.Подробности см.в их собственной документации.</target>
        </trans-unit>
        <trans-unit id="8e0bc2ae4e7dee6efa427af24dac0f51946576f0" translate="yes" xml:space="preserve">
          <source>StandardizedVariants.txt</source>
          <target state="translated">StandardizedVariants.txt</target>
        </trans-unit>
        <trans-unit id="07142f93c49bc59a674f3cf54cfc45c16742e4f3" translate="yes" xml:space="preserve">
          <source>Stands for &amp;ldquo;Database Management&amp;rdquo; routines, a set of routines that emulate an &lt;b&gt;associative array&lt;/b&gt; using disk files. The routines use a dynamic hashing scheme to locate any entry with only two disk accesses. DBM files allow a Perl program to keep a persistent &lt;b&gt;hash&lt;/b&gt; across multiple invocations. You can &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; your hash variables to various DBM implementations.</source>
          <target state="translated">Обозначает процедуры &amp;laquo;Управление базой данных&amp;raquo;, набор процедур, которые имитируют &lt;b&gt;ассоциативный массив&lt;/b&gt; с использованием файлов на диске. Подпрограммы используют схему динамического хеширования, чтобы найти любую запись, имеющую только два доступа к диску. Файлы DBM позволяют программе Perl сохранять постоянный &lt;b&gt;хэш при&lt;/b&gt; нескольких вызовах. Вы можете &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; свои хеш-переменные с различными реализациями DBM.</target>
        </trans-unit>
        <trans-unit id="32e3debe4cf1141c3184e11a9dc572fab1423447" translate="yes" xml:space="preserve">
          <source>Start position and no-match optimisations</source>
          <target state="translated">Оптимизация стартового положения и отсутствие несоответствий</target>
        </trans-unit>
        <trans-unit id="db76cc0f3f883ec9a2ed91694d94f4588b9f7245" translate="yes" xml:space="preserve">
          <source>Start up an interval timer: after a certain time, a signal ($which) arrives, and more signals may keep arriving at certain intervals. To disable an &quot;itimer&quot;, use &lt;code&gt;$floating_seconds&lt;/code&gt; of zero. If the &lt;code&gt;$interval_floating_seconds&lt;/code&gt; is set to zero (or unspecified), the timer is disabled &lt;b&gt;after&lt;/b&gt; the next delivered signal.</source>
          <target state="translated">Запустите интервальный таймер: через определенное время поступает сигнал ($ which), и через определенные интервалы может поступать больше сигналов. Чтобы отключить &amp;laquo;itimer&amp;raquo;, используйте нулевое значение &lt;code&gt;$floating_seconds&lt;/code&gt; float_seconds . Если &lt;code&gt;$interval_floating_seconds&lt;/code&gt; установлен в ноль (или не указан), таймер отключается &lt;b&gt;после&lt;/b&gt; следующего доставленного сигнала.</target>
        </trans-unit>
        <trans-unit id="bf54d336f01982c7f36b58a5973054d7f918d05e" translate="yes" xml:space="preserve">
          <source>Start with a dummy run of h2xs:</source>
          <target state="translated">Начните с манекена из h2xs:</target>
        </trans-unit>
        <trans-unit id="8d112be587c3b58ec2b08ad08b5f28537f049d9b" translate="yes" xml:space="preserve">
          <source>Start with single-step on.</source>
          <target state="translated">Начни с одного шага.</target>
        </trans-unit>
        <trans-unit id="8332767a94ccaf8b2674f5e407c13b8594261e03" translate="yes" xml:space="preserve">
          <source>Start with the first letter in the string 'a'.</source>
          <target state="translated">Начните с первой буквы в строке 'a'.</target>
        </trans-unit>
        <trans-unit id="be46870dc50c93db69a63c772d7b331eea2b204f" translate="yes" xml:space="preserve">
          <source>Start with the first letter in the string 't'.</source>
          <target state="translated">Начните с первой буквы в строке 't'.</target>
        </trans-unit>
        <trans-unit id="e5189aa41c41bf90fef351656e01e6473fbaf249" translate="yes" xml:space="preserve">
          <source>Start your Perl program</source>
          <target state="translated">Запустите программу Perl</target>
        </trans-unit>
        <trans-unit id="9f05ee38f1d8c4b639d2c05f6f7cb39a8f63ba62" translate="yes" xml:space="preserve">
          <source>Start-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Старт-токены из Под::Простые::PullParser</target>
        </trans-unit>
        <trans-unit id="bba3dd50f7eb62963e78abd741a6ecb84d7e0e92" translate="yes" xml:space="preserve">
          <source>Starting From Scratch</source>
          <target state="translated">Начиная с царапин</target>
        </trans-unit>
        <trans-unit id="d9722acfd050423d2f793d245909513d9f792a51" translate="yes" xml:space="preserve">
          <source>Starting OS/2 (and DOS) programs under Perl</source>
          <target state="translated">Запуск программ OS/2 (и DOS)под Perl</target>
        </trans-unit>
        <trans-unit id="6a454cb163d40a3be765256333ed856099e340c6" translate="yes" xml:space="preserve">
          <source>Starting Perl in the VMS debugger may change the program execution profile in a way that such problems are not reproduced.</source>
          <target state="translated">Запуск Perl в отладчике VMS может изменить профиль выполнения программы таким образом,что подобные проблемы не будут воспроизведены.</target>
        </trans-unit>
        <trans-unit id="61b2b3d56b228f00035d9baf98e67307d761a53f" translate="yes" xml:space="preserve">
          <source>Starting Perl programs under AmigaOS</source>
          <target state="translated">Запуск программ на Perl под AmigaOS</target>
        </trans-unit>
        <trans-unit id="c712909317e062b2443119b81f61884099ac7f3f" translate="yes" xml:space="preserve">
          <source>Starting Perl programs under OS/2 (and DOS and...)</source>
          <target state="translated">Запуск программ на Perl под OS/2 (и DOS и...).</target>
        </trans-unit>
        <trans-unit id="653f89b4c2f41c0d0134c806e923d3709fc205d1" translate="yes" xml:space="preserve">
          <source>Starting from IO::Zlib version 1.02, IO::Zlib can also use an external</source>
          <target state="translated">Начиная с IO::Zlib версии 1.02,IO::Zlib также может использовать внешний</target>
        </trans-unit>
        <trans-unit id="a508a2e273548a63bb5c0b07719e420fe300b9fd" translate="yes" xml:space="preserve">
          <source>Starting from OS/400 V5R2 the IBM Visual Age compiler is supported on OS/400 PASE, so it is possible to build Perl natively on OS/400. The easier way, however, is to compile in AIX, as just described.</source>
          <target state="translated">Начиная с OS/400 V5R2 компилятор IBM Visual Age поддерживается на OS/400 PASE,поэтому можно собирать Perl нативно на OS/400.Проще,однако,скомпилировать в AIX,как только что было описано.</target>
        </trans-unit>
        <trans-unit id="5e473385f5209d49f3d6236a23d69b61072e12c5" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.10.1 (well, 5.10.0, but it didn't work right), you can say</source>
          <target state="translated">Начиная с Perl 5.10.1 (ну,5.10.0,но это не сработало правильно),можно сказать.</target>
        </trans-unit>
        <trans-unit id="213483245e12096ac5558b413cc608887022de0d" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.6 Perl has had some level of multibyte character support. Perl 5.8 or later is recommended. Supported multibyte character repertoires include Unicode, and legacy encodings through the Encode module. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;, &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;, and &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">Начиная с Perl 5.6 Perl имеет некоторый уровень поддержки многобайтовых символов. Рекомендуется Perl 5.8 или новее. Поддерживаемые репертуары многобайтовых символов включают Unicode и устаревшие кодировки через модуль Encode. См. &lt;a href=&quot;perluniintro&quot;&gt;Perluniintro&lt;/a&gt; , &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; и &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3401e5a549f724e4569e770d48d8137b822e30b" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.7.2 (and consequently 5.8.x / 5.10.x / 5.12.x) and AIX 4.3 or newer Perl uses the AIX native dynamic loading interface in the so called runtime linking mode instead of the emulated interface that was used in Perl releases 5.6.1 and earlier or, for AIX releases 4.2 and earlier. This change does break backward compatibility with compiled modules from earlier Perl releases. The change was made to make Perl more compliant with other applications like Apache/mod_perl which are using the AIX native interface. This change also enables the use of C++ code with static constructors and destructors in Perl extensions, which was not possible using the emulated interface.</source>
          <target state="translated">Начиная с версии Perl 5.7.2 (и,следовательно,5.8.x/5.10.x/5.12.x)и AIX 4.3 или более новой версии Perl использует собственный интерфейс динамической загрузки AIX в так называемом режиме runtime link вместо эмулированного интерфейса,который использовался в версии Perl 5.6.1 и более ранних версиях или,для версии AIX 4.2 и более ранних версиях.Это изменение нарушает обратную совместимость с скомпилированными модулями из более ранних версий Perl.Изменение было сделано для того,чтобы сделать Perl более совместимым с другими приложениями,такими как Apache/mod_perl,использующими родной интерфейс AIX.Это изменение также позволяет использовать C++код со статическими конструкторами и деструкторами в расширениях Perl,что было невозможно при использовании эмулируемого интерфейса.</target>
        </trans-unit>
        <trans-unit id="25d510ae8cee14025ed8b7521c9e7b4803c6e585" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8 Filter::Util::Call (the core part of the Source Filters distribution) is part of the standard Perl distribution. Also included is a friendlier interface called Filter::Simple, by Damian Conway.</source>
          <target state="translated">Начиная с версии Perl 5.8 Фильтр::Util::Call (основная часть распределения Фильтров-источников)является частью стандартного распределения Perl.Также в него включен более дружественный интерфейс,называемый Filter::Simple,по Дэмиану Конвей.</target>
        </trans-unit>
        <trans-unit id="84131be03444ffa9bfcdc4607ace523b2b4abf69" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8 you can use the standard module Encode to translate from EBCDIC to Latin-1 code points. Encode knows about more EBCDIC character sets than Perl can currently be compiled to run on.</source>
          <target state="translated">Начиная с версии Perl 5.8 вы можете использовать стандартный модуль Encode для перевода с EBCDIC на латиницу-1 кодовых точек.Encode знает о большем количестве наборов символов EBCDIC,чем Perl,который в настоящее время может быть скомпилирован для работы на нем.</target>
        </trans-unit>
        <trans-unit id="b494835e5e76badb9fdcdcf6ee9b4a757213c9dc" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8, a source filter module, &lt;code&gt;Switch&lt;/code&gt; , can also be used to get switch and case. Its use is now discouraged, because it's not fully compatible with the native switch of Perl 5.10, and because, as it's implemented as a source filter, it doesn't always work as intended when complex syntax is involved.</source>
          <target state="translated">Начиная с Perl 5.8, для получения переключателя и корпуса также можно использовать модуль фильтра источника &lt;code&gt;Switch&lt;/code&gt; . Его использование сейчас не рекомендуется, потому что он не полностью совместим со встроенным переключателем Perl 5.10 и потому, что, поскольку он реализован как фильтр источника, он не всегда работает должным образом при использовании сложного синтаксиса.</target>
        </trans-unit>
        <trans-unit id="a6f4302390c39dc69e8bb4ae56d84681737deb52" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8, in C/C++ level Perl knows how to wrap system/library interfaces that have thread-aware versions (e.g. getpwent_r()) into frontend macros (e.g. getpwent()) that correctly handle the multithreaded interaction with the Perl interpreter. This will happen transparently, the only thing you need to do is to instantiate a Perl interpreter.</source>
          <target state="translated">Начиная с версии Perl 5.8,на уровне Си/Си++Perl знает,как обернуть системные/библиотечные интерфейсы,которые имеют потоковые версии (например,getpwent_r())во внешние макросы (например,getpwent()),которые корректно обрабатывают многопотоковое взаимодействие с интерпретатором Perl.Это будет происходить прозрачно,единственное,что вам нужно сделать-это инстанцировать интерпретатор Perl.</target>
        </trans-unit>
        <trans-unit id="d0ecdc5671ad43a21bb3ba4b49951928dc27fb67" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8.1 different runs of Perl will have different ordering of hash keys. The change was done for greater security, see &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt;. This means that different runs of Perl will have different Data::Dumper outputs if the data contains hashes. If you need to have identical Data::Dumper outputs from different runs of Perl, use the environment variable PERL_HASH_SEED, see &lt;a href=&quot;../perlrun#PERL_HASH_SEED&quot;&gt;PERL_HASH_SEED in perlrun&lt;/a&gt;. Using this restores the old (platform-specific) ordering: an even prettier solution might be to use the &lt;code&gt;Sortkeys&lt;/code&gt; filter of Data::Dumper.</source>
          <target state="translated">Начиная с Perl 5.8.1, разные версии Perl будут иметь разный порядок хэш-ключей. Изменение было сделано для большей безопасности, см. &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Атаки на алгоритмическую сложность в perlsec&lt;/a&gt; . Это означает, что разные прогоны Perl будут иметь разные выходные данные Data :: Dumper, если данные содержат хэши. Если вам нужно иметь одинаковые выходные данные Data :: Dumper из разных запусков Perl, используйте переменную среды PERL_HASH_SEED, см. &lt;a href=&quot;../perlrun#PERL_HASH_SEED&quot;&gt;PERL_HASH_SEED в perlrun&lt;/a&gt; . Это восстанавливает старый (зависящий от платформы) порядок: еще более красивым решением может быть использование фильтра &lt;code&gt;Sortkeys&lt;/code&gt; для Data :: Dumper.</target>
        </trans-unit>
        <trans-unit id="54b73ef5c7c43845a94f049a96a2982af7951ff5" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.9.4 the following extra flags are added:</source>
          <target state="translated">Начиная с версии Perl 5.9.4 добавляются следующие дополнительные флаги:</target>
        </trans-unit>
        <trans-unit id="d0f3b9a37d935e7c453cae03a9fc889658a8b375" translate="yes" xml:space="preserve">
          <source>Starting from Perl v5.6.0, Perl has had the capacity to handle Unicode natively. Perl v5.8.0, however, is the first recommended release for serious Unicode work. The maintenance release 5.6.1 fixed many of the problems of the initial Unicode implementation, but for example regular expressions still do not work with Unicode in 5.6.1. Perl v5.14.0 is the first release where Unicode support is (almost) seamlessly integrable without some gotchas (the exception being some differences in &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;, and that is fixed starting in Perl 5.16.0). To enable this seamless support, you should &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (which is automatically selected if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher). See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. (5.14 also fixes a number of bugs and departures from the Unicode standard.)</source>
          <target state="translated">Начиная с Perl v5.6.0, Perl имеет возможность обрабатывать Unicode изначально. Perl v5.8.0, однако, является первым рекомендуемым выпуском для серьезной работы с Unicode. В служебном выпуске 5.6.1 исправлены многие проблемы первоначальной реализации Unicode, но, например, регулярные выражения по-прежнему не работают с Unicode в 5.6.1. Perl v5.14.0 - это первый выпуск, в котором поддержка Unicode (почти) легко интегрируется без каких-либо ошибок (за исключением некоторых различий в &lt;a href=&quot;functions/quotemeta&quot;&gt;кавычках&lt;/a&gt; , и это исправлено, начиная с Perl 5.16.0). Чтобы включить эту бесшовную поддержку, вы должны &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (которая автоматически выбирается, если вы &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; или выше). См. &lt;a href=&quot;feature&quot;&gt;Особенность&lt;/a&gt;. (5.14 также исправляет ряд ошибок и отклонений от стандарта Unicode.)</target>
        </trans-unit>
        <trans-unit id="416a20fa36c19a41cf13089d9b7e6cda76a07463" translate="yes" xml:space="preserve">
          <source>Starting from perl 5.7.1 perl uses the Solaris malloc, since the perl malloc breaks when dealing with more than 2GB of memory, and the Solaris malloc also seems to be faster.</source>
          <target state="translated">Начиная с perl 5.7.1 perl используется Solaris malloc,так как при работе с более чем 2 ГБ памяти,perl malloc ломается,а Solaris malloc,похоже,также работает быстрее.</target>
        </trans-unit>
        <trans-unit id="e6f60ae2145b9aa31e782db73fe39a61dbb6b373" translate="yes" xml:space="preserve">
          <source>Starting from the beginning of the input string, each 8-tuple of characters is converted to 1 character of output. With format &lt;code&gt;b&lt;/code&gt; , the first character of the 8-tuple determines the least-significant bit of a character; with format &lt;code&gt;B&lt;/code&gt; , it determines the most-significant bit of a character.</source>
          <target state="translated">Начиная с начала входной строки, каждый кортеж из 8 символов преобразуется в 1 символ вывода. В формате &lt;code&gt;b&lt;/code&gt; первый символ кортежа из 8 определяет младший бит символа; с форматом &lt;code&gt;B&lt;/code&gt; он определяет самый старший бит символа.</target>
        </trans-unit>
        <trans-unit id="bca54402551e7931f104cb3acd73bb3d87fc7a43" translate="yes" xml:space="preserve">
          <source>Starting from the beginning of the template to pack(), each pair of characters is converted to 1 character of output. With format &lt;code&gt;h&lt;/code&gt; , the first character of the pair determines the least-significant nybble of the output character; with format &lt;code&gt;H&lt;/code&gt; , it determines the most-significant nybble.</source>
          <target state="translated">Начиная с начала шаблона до pack (), каждая пара символов преобразуется в 1 символ вывода. В формате &lt;code&gt;h&lt;/code&gt; первый символ пары определяет младший младший байт выходного символа; в формате &lt;code&gt;H&lt;/code&gt; определяет наиболее значимый ниббл.</target>
        </trans-unit>
        <trans-unit id="e0719e57793beb804762734f954a0430e8236ad0" translate="yes" xml:space="preserve">
          <source>Starting from the top, this says &lt;code&gt;$b&lt;/code&gt; is an SV. The scalar is an IV, which is capable of holding an integer or reference value. It has the &lt;code&gt;ROK&lt;/code&gt; flag set, meaning it is a reference (rather than an integer or string). Notice that Dump follows the reference and shows us what &lt;code&gt;$b&lt;/code&gt; was referencing. We see the same &lt;code&gt;$a&lt;/code&gt; that we found in the previous example.</source>
          <target state="translated">Начиная сверху, это говорит о том, что &lt;code&gt;$b&lt;/code&gt; - SV. Скаляр - это IV, который может содержать целое или ссылочное значение. У него установлен флаг &lt;code&gt;ROK&lt;/code&gt; , что означает, что это ссылка (а не целое число или строка). Обратите внимание, что Dump следует по ссылке и показывает нам, на что ссылается &lt;code&gt;$b&lt;/code&gt; . Мы видим тот же &lt;code&gt;$a&lt;/code&gt; который мы нашли в предыдущем примере.</target>
        </trans-unit>
        <trans-unit id="0542c0de06c1b01762ccd40a6fe67b90b3556cde" translate="yes" xml:space="preserve">
          <source>Starting from version 5.8, Perl uses a builtin translation layer for text-mode files. This replaces the efficient well-tested EMX layer by some code which should be best characterized as a &quot;quick hack&quot;.</source>
          <target state="translated">Начиная с версии 5.8,Perl использует встроенный слой перевода для текстовых файлов.Он заменяет эффективный,хорошо проверенный слой EMX на некоторый код,который лучше всего характеризовать как &quot;быстрый взлом&quot;.</target>
        </trans-unit>
        <trans-unit id="ac77222ae2e654fdac46266902dcc915cb8e811b" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.12.0, &lt;code&gt;\N&lt;/code&gt; also can have an additional meaning (only) in patterns, namely to match a non-newline character. (This is short for &lt;code&gt;[^\n]&lt;/code&gt;, and like &lt;code&gt;.&lt;/code&gt; but is not affected by the &lt;code&gt;/s&lt;/code&gt; regex modifier.)</source>
          <target state="translated">Начиная с Perl 5.12.0, &lt;code&gt;\N&lt;/code&gt; также может иметь дополнительное значение (только) в шаблонах, а именно совпадение с символом, отличным от новой строки. (Это сокращение для &lt;code&gt;[^\n]&lt;/code&gt; , и , как и &lt;code&gt;.&lt;/code&gt; , Но не влияет на &lt;code&gt;/s&lt;/code&gt; регулярным выражением модификатором.)</target>
        </trans-unit>
        <trans-unit id="2859a2d886c0e9aec6c1de9465ceff2207dfb72a" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14 (and partially in Perl 5.12), just put a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; near the beginning of your program. Within its lexical scope you shouldn't have this problem. It also is automatically enabled under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature ':5.12'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or using &lt;code&gt;-E&lt;/code&gt; on the command line for Perl 5.12 or higher.</source>
          <target state="translated">Начиная с Perl 5.14 (и частично с Perl 5.12), просто поместите функцию &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; в начало вашей программы. В пределах его лексической области у вас не должно быть этой проблемы. Он также автоматически включается при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature ':5.12'&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; или с помощью &lt;code&gt;-E&lt;/code&gt; в командной строке для Perl 5.12 или выше.</target>
        </trans-unit>
        <trans-unit id="a8902a856b5fd88514da38f6d1ea437cef45dc91" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14, a &lt;code&gt;&quot;^&quot;&lt;/code&gt; (caret or circumflex accent) immediately after the &lt;code&gt;&quot;?&quot;&lt;/code&gt; is a shorthand equivalent to &lt;code&gt;d-imsx&lt;/code&gt; . Any positive flags (except &lt;code&gt;&quot;d&quot;&lt;/code&gt; ) may follow the caret, so</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&quot;^&quot;&lt;/code&gt; (знак вставки или циркумфлекс) сразу после &lt;code&gt;&quot;?&quot;&lt;/code&gt; является сокращенным эквивалентом &lt;code&gt;d-imsx&lt;/code&gt; . Любые положительные флаги (кроме &lt;code&gt;&quot;d&quot;&lt;/code&gt; ) могут следовать за кареткой, поэтому</target>
        </trans-unit>
        <trans-unit id="dd982f589d8e87c6c46ce3117db1a952a4a3a29e" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14, a &lt;code&gt;&quot;^&quot;&lt;/code&gt; (caret or circumflex accent) immediately after the &lt;code&gt;&quot;?&quot;&lt;/code&gt; is a shorthand equivalent to &lt;code&gt;d-imsx&lt;/code&gt; . Flags (except &lt;code&gt;&quot;d&quot;&lt;/code&gt; ) may follow the caret to override it. But a minus sign is not legal with it.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&quot;^&quot;&lt;/code&gt; (знак вставки или циркумфлекс) сразу после &lt;code&gt;&quot;?&quot;&lt;/code&gt; является сокращенным эквивалентом &lt;code&gt;d-imsx&lt;/code&gt; . Флаги (кроме &lt;code&gt;&quot;d&quot;&lt;/code&gt; ) могут следовать за кареткой, чтобы переопределить ее. Но знак минус с ним недопустим.</target>
        </trans-unit>
        <trans-unit id="f8764da9a2d4e197710fd50d36bbe6c6ef6a3ac9" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14.0, regular expressions compiled within the scope of &lt;code&gt;unicode_strings&lt;/code&gt; use Unicode rules even when executed or compiled into larger regular expressions outside the scope.</source>
          <target state="translated">Начиная с Perl 5.14.0, регулярные выражения, скомпилированные в рамках &lt;code&gt;unicode_strings&lt;/code&gt; , используют правила Unicode, даже когда выполняются или скомпилированы в более крупные регулярные выражения за пределами области видимости.</target>
        </trans-unit>
        <trans-unit id="69cd047e088fdbefa20b4fff4c70feeb8034d880" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.16.0, consistent quoting rules are used within the scope of &lt;code&gt;unicode_strings&lt;/code&gt; , as described in &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;. Prior to that, or outside its scope, no code points above 127 are quoted in UTF-8 encoded strings, but in byte encoded strings, code points between 128-255 are always quoted.</source>
          <target state="translated">Начиная с Perl 5.16.0, совместимые со ссылкой правила используются в рамках &lt;code&gt;unicode_strings&lt;/code&gt; , как описано в &lt;a href=&quot;functions/quotemeta&quot;&gt;QuoteMeta&lt;/a&gt; . До этого или за пределами его области в строках с кодировкой UTF-8 не указывались кодовые точки выше 127, но в строках с байтовой кодировкой всегда указывались кодовые точки между 128&amp;ndash;255.</target>
        </trans-unit>
        <trans-unit id="4f8e157579b8bab3ccd61e698c935bfec29a8f08" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.20, a hash slice operation with the % symbol is a variant of slice operation returning a list of key/value pairs rather than just values:</source>
          <target state="translated">Начиная с версии Perl 5.20,операция хэш-фрагмента с символом % является вариантом операции фрагментации,возвращающим список пар ключ/значение,а не только значения:</target>
        </trans-unit>
        <trans-unit id="013197011e87f7e0633670e8b800c1024b759400" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16 in a very limited way, and more generally in v5.22, you can restrict which category or categories are enabled by this particular instance of the pragma by adding parameters to it. For example,</source>
          <target state="translated">Начиная с версии Perl v5.16 в очень ограниченном виде,и в более общем плане в версии v5.22,вы можете ограничить,какие категории или категории включены в данном конкретном примере прагмы,добавив в него параметры.Например,</target>
        </trans-unit>
        <trans-unit id="d7be757a62548668bef82e6fa7932eb10efddb3b" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16, Perl adopted a Unicode-defined strategy for quoting non-ASCII characters; the quoting of ASCII characters is unchanged.</source>
          <target state="translated">Начиная с версии Perl v5.16,в Perl принята стратегия цитирования символов,не относящихся к ASCII;цитирование символов ASCII не изменяется.</target>
        </trans-unit>
        <trans-unit id="a75aca801899de40f1e5f4fc3d561cb6af7bcdc4" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16, any occurrence of &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; sequences in a double-quotish string automatically loads this module with arguments &lt;code&gt;:full&lt;/code&gt; and &lt;code&gt;:short&lt;/code&gt; (described below) if it hasn't already been loaded with different arguments, in order to compile the named Unicode character into position in the string. Prior to v5.16, an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; was required to enable this usage. (However, prior to v5.16, the form &lt;code&gt;&quot;use
charnames ();&quot;&lt;/code&gt; did not enable &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt;.)</source>
          <target state="translated">Начиная с Perl v5.16, любое вхождение последовательностей &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; в строку, &lt;i&gt;заключенную&lt;/i&gt; в двойные кавычки, автоматически загружает этот модуль с аргументами &lt;code&gt;:full&lt;/code&gt; и &lt;code&gt;:short&lt;/code&gt; (описано ниже), если он еще не был загружен с другими аргументами, в чтобы скомпилировать именованный символ Unicode в позицию в строке. До версии 5.16 для включения этого использования требовалось явное &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; . (Однако до версии 5.16 форма &lt;code&gt;&quot;use charnames ();&quot;&lt;/code&gt; не &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; \ N { &lt;i&gt;CHARNAME&lt;/i&gt; } .)</target>
        </trans-unit>
        <trans-unit id="bc88b853a6a300ebebd43ce48839b53ca6b33945" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.20, UTF-8 locales are supported in Perl, except for &lt;code&gt;LC_COLLATE&lt;/code&gt; (use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; instead). If you have Perl v5.16 or v5.18 and can't upgrade, you can use</source>
          <target state="translated">Начиная с Perl v5.20, в Perl поддерживаются локали UTF-8, за исключением &lt;code&gt;LC_COLLATE&lt;/code&gt; ( вместо этого используйте &lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collate&lt;/a&gt; ). Если у вас установлен Perl v5.16 или v5.18 и вы не можете выполнить обновление, вы можете использовать</target>
        </trans-unit>
        <trans-unit id="24c20bca7982b6c0163573088c845daca9bc60e3" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.22, this applies to ranges in bracketed character classes. If you say, for example, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+20}-\N{U+7F}]/&lt;/a&gt;&lt;/code&gt;, it means the characters &lt;code&gt;\N{U+20}&lt;/code&gt; , &lt;code&gt;\N{U+21}&lt;/code&gt; , ..., &lt;code&gt;\N{U+7F}&lt;/code&gt; . This range is all the printable characters that the ASCII character set contains.</source>
          <target state="translated">Начиная с Perl v5.22, это применяется к диапазонам в классах символов в квадратных скобках. Если вы скажете, например, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+20}-\N{U+7F}]/&lt;/a&gt;&lt;/code&gt; , это означает символы &lt;code&gt;\N{U+20}&lt;/code&gt; , &lt;code&gt;\N{U+21}&lt;/code&gt; , .. ., &lt;code&gt;\N{U+7F}&lt;/code&gt; . Этот диапазон - все печатаемые символы, содержащиеся в наборе символов ASCII.</target>
        </trans-unit>
        <trans-unit id="b23b660058cb3ee939b11052749bad9b7526e31f" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.22, this is trivially changeable to work portably on both ASCII and EBCDIC platforms.</source>
          <target state="translated">Начиная с версии Perl v5.22,она тривиально меняется для работы в портативном режиме как на ASCII,так и на EBCDIC платформах.</target>
        </trans-unit>
        <trans-unit id="0e38118c6920f78946e8d31e17cb36ad4ee8bf0e" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.8.6 (&lt;code&gt;Encode&lt;/code&gt; version 2.0.1),</source>
          <target state="translated">Начиная с Perl v5.8.6 ( &lt;code&gt;Encode&lt;/code&gt; версия 2.0.1),</target>
        </trans-unit>
        <trans-unit id="474e1944b6ecbc8a507bc2e01a2a550b04aa62eb" translate="yes" xml:space="preserve">
          <source>Starting in Unicode 6.1 and Perl v5.16, Unicode defines many abbreviations and names that were formerly Perl extensions, and some additional ones that Perl did not previously accept. The list is getting too long to reproduce here, but you can get the complete list from the Unicode web site: &lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&lt;/a&gt;.</source>
          <target state="translated">Начиная с Unicode 6.1 и Perl v5.16, Unicode определяет множество сокращений и имен, которые ранее были расширениями Perl, а также некоторые дополнительные, которые Perl ранее не принимал. Список становится слишком длинным, чтобы воспроизвести его здесь, но вы можете получить полный список на веб-сайте Unicode: &lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="818df47ef2f0fcf2a87de97f12babb967ed1fcfb" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl supports UTF-8 locales for &lt;code&gt;LC_CTYPE&lt;/code&gt; , but otherwise Perl only supports single-byte locales, such as the ISO 8859 series. This means that wide character locales, for example for Asian languages, are not well-supported. (If the platform has the capability for Perl to detect such a locale, starting in Perl v5.22, &lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;Perl will warn, default enabled&lt;/a&gt;, using the &lt;code&gt;locale&lt;/code&gt; warning category, whenever such a locale is switched into.) The UTF-8 locale support is actually a superset of POSIX locales, because it is really full Unicode behavior as if no &lt;code&gt;LC_CTYPE&lt;/code&gt; locale were in effect at all (except for tainting; see &lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt;). POSIX locales, even UTF-8 ones, are lacking certain concepts in Unicode, such as the idea that changing the case of a character could expand to be more than one character. Perl in a UTF-8 locale, will give you that expansion. Prior to v5.20, Perl treated a UTF-8 locale on some platforms like an ISO 8859-1 one, with some restrictions, and on other platforms more like the &quot;C&quot; locale. For releases v5.16 and v5.18, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters&lt;/code&gt; could be used as a workaround for this (see &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;).</source>
          <target state="translated">Начиная с v5.20, Perl поддерживает локали UTF-8 для &lt;code&gt;LC_CTYPE&lt;/code&gt; , но в остальном Perl поддерживает только однобайтовые локали, такие как серия ISO 8859. Это означает, что языковые стандарты для широких символов, например для азиатских языков, не поддерживаются должным образом. (Если платформа имеет возможность для Perl обнаруживать такую ​​локаль, начиная с Perl v5.22, &lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;Perl будет предупреждать, по умолчанию включен&lt;/a&gt; , используя категорию предупреждения &lt;code&gt;locale&lt;/code&gt; , всякий раз, когда такая локаль переключается на такой языковой стандарт.) Поддержка локали UTF-8 на самом деле является надмножеством локалей POSIX, потому что это действительно полное поведение Unicode, как если бы локаль &lt;code&gt;LC_CTYPE&lt;/code&gt; вообще не действовала (за исключением заражения; см. &lt;a href=&quot;#SECURITY&quot;&gt;БЕЗОПАСНОСТЬ&lt;/a&gt;). В локали POSIX, даже в UTF-8, отсутствуют определенные концепции Unicode, такие как идея о том, что изменение регистра символа может расширяться до более чем одного символа. Perl в локали UTF-8 предоставит вам такое расширение. До версии 5.20 Perl обрабатывал локаль UTF-8 на некоторых платформах, например, ISO 8859-1, с некоторыми ограничениями, а на других платформах больше походило на локаль &quot;C&quot;. Для выпусков v5.16 и v5.18 в качестве обходного пути можно &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters&lt;/code&gt; (см. &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode и UTF-8&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7c0b3fbd50ff716e496a38d1dbfc0634c6a5772b" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl uses full Unicode rules if the locale is UTF-8. Otherwise, there is a deficiency in this scheme, which is that case changes that cross the 255/256 boundary are not well-defined. For example, the lower case of LATIN CAPITAL LETTER SHARP S (U+1E9E) in Unicode rules is U+00DF (on ASCII platforms). But under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (prior to v5.20 or not a UTF-8 locale), the lower case of U+1E9E is itself, because 0xDF may not be LATIN SMALL LETTER SHARP S in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is. Perl returns a result that is above 255 (almost always the input character unchanged, for all instances (and there aren't many) where the 255/256 boundary would otherwise be crossed; and starting in v5.22, it raises a &lt;a href=&quot;perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;locale&lt;/a&gt; warning.</source>
          <target state="translated">Начиная с версии 5.20, Perl использует полные правила Unicode, если языковой стандарт - UTF-8. В противном случае в этой схеме есть недостаток, заключающийся в том, что изменения случая, пересекающие границу 255/256, не являются четко определенными. Например, строчная латинская прописная буква SHARP S (U + 1E9E) в правилах Unicode - это U + 00DF (на платформах ASCII). Но при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (до версии 5.20 или не является локалью UTF-8), нижний регистр U + 1E9E является самим собой, потому что 0xDF может не быть LATIN SMALL LETTER SHARP S в текущей локали, и Perl не имеет возможности узнать, является ли этот символ даже существует в локали, не говоря уже о том, какой это код. Perl возвращает результат, превышающий 255 (почти всегда входной символ неизменен, для всех экземпляров (а их немного), где граница 255/256 в противном случае была бы пересечена; и начиная с v5.22, он вызывает предупреждение &lt;a href=&quot;perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;локали&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf1eee1ccf148c85a77132cb28b023038cea490f" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl uses full Unicode rules if the locale is UTF-8. Otherwise, there is a deficiency in this scheme, which is that case changes that cross the 255/256 boundary are not well-defined. For example, the lower case of LATIN CAPITAL LETTER SHARP S (U+1E9E) in Unicode rules is U+00DF (on ASCII platforms). But under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (prior to v5.20 or not a UTF-8 locale), the lower case of U+1E9E is itself, because 0xDF may not be LATIN SMALL LETTER SHARP S in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is. Perl returns a result that is above 255 (almost always the input character unchanged, for all instances (and there aren't many) where the 255/256 boundary would otherwise be crossed; and starting in v5.22, it raises a &lt;a href=&quot;../perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;locale&lt;/a&gt; warning.</source>
          <target state="translated">Начиная с версии 5.20, Perl использует полные правила Unicode, если языковой стандарт - UTF-8. В противном случае в этой схеме есть недостаток, заключающийся в том, что изменения случая, пересекающие границу 255/256, не являются четко определенными. Например, строчная латинская прописная буква SHARP S (U + 1E9E) в правилах Unicode - это U + 00DF (на платформах ASCII). Но при &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (до версии 5.20 или не является локалью UTF-8), нижний регистр U + 1E9E является самим собой, потому что 0xDF может не быть LATIN SMALL LETTER SHARP S в текущей локали, и Perl не имеет возможности узнать, является ли этот символ даже существует в локали, не говоря уже о том, какой это код. Perl возвращает результат, превышающий 255 (почти всегда входной символ неизменен, для всех экземпляров (а их немного), где граница 255/256 в противном случае была бы пересечена; и начиная с v5.22, он вызывает предупреждение &lt;a href=&quot;../perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;локали&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c762f587a88d06d3ee0d5c6c5c66f9e2aa3c2b6" translate="yes" xml:space="preserve">
          <source>Starting in v5.22, Perl will by default warn when switching into a locale that redefines any ASCII printable character (plus &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt; ) into a different class than expected. This is likely to happen on modern locales only on EBCDIC platforms, where, for example, a CCSID 0037 locale on a CCSID 1047 machine moves &lt;code&gt;&quot;[&quot;&lt;/code&gt; , but it can happen on ASCII platforms with the ISO 646 and other 7-bit locales that are essentially obsolete. Things may still work, depending on what features of Perl are used by the program. For example, in the example from above where &lt;code&gt;&quot;|&quot;&lt;/code&gt; becomes a &lt;code&gt;\w&lt;/code&gt; , and there are no regular expressions where this matters, the program may still work properly. The warning lists all the characters that it can determine could be adversely affected.</source>
          <target state="translated">Начиная с v5.22, Perl по умолчанию будет предупреждать при переключении на локаль, которая переопределяет любой печатный символ ASCII (плюс &lt;code&gt;\t&lt;/code&gt; и &lt;code&gt;\n&lt;/code&gt; ) в другой класс, чем ожидалось. Это, вероятно, произойдет в современных локали только на платформах EBCDIC, где, например, локаль CCSID 0037 на машине CCSID 1047 перемещается &lt;code&gt;&quot;[&quot;&lt;/code&gt; , но это может произойти на платформах ASCII с ISO 646 и другими 7-битными языковыми стандартами, которые по существу устарели. Все может по-прежнему работать, в зависимости от того, какие функции Perl используются программой. Например, в приведенном выше примере, где &lt;code&gt;&quot;|&quot;&lt;/code&gt; становится &lt;code&gt;\w&lt;/code&gt; , и нет регулярных выражений, где это имеет значение, программа может работать правильно. В предупреждении перечислены все символы, которые, по его мнению, могут быть повреждены.</target>
        </trans-unit>
        <trans-unit id="30ce7d231c27d2be8f1b1d8928ca5c39bf4aed51" translate="yes" xml:space="preserve">
          <source>Starting in v5.22, you can use Unicode code points as the end points of regular expression pattern character ranges, and the range will include all Unicode code points that lie between those end points, inclusive.</source>
          <target state="translated">Начиная с версии v5.22,в качестве конечных точек диапазонов символов регулярного выражения можно использовать точки кода Юникода,а диапазон будет включать все точки кода Юникода,лежащие между этими конечными точками,включительно.</target>
        </trans-unit>
        <trans-unit id="3cd5e5803935bbb6537a6c17faa83c7fdd9ffba0" translate="yes" xml:space="preserve">
          <source>Starting in v5.8.6, the encoding name may be &lt;code&gt;:locale&lt;/code&gt; . This means that the encoding is taken from the current locale, and not hard-coded by the pragma. Since a script really can only be encoded in exactly one encoding, this option is dangerous. It makes sense only if the script itself is written in ASCII, and all the possible locales that will be in use when the script is executed are supersets of ASCII. That means that the script itself doesn't get changed, but the I/O handles have the specified encoding added, and the operations like &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; use that encoding.</source>
          <target state="translated">Начиная с v5.8.6, имя кодировки может быть &lt;code&gt;:locale&lt;/code&gt; . Это означает, что кодировка берется из текущей локали, а не жестко запрограммирована директивой pragma. Поскольку сценарий действительно может быть закодирован только в одной кодировке, этот вариант опасен. Это имеет смысл только в том случае, если сам сценарий написан в ASCII, и все возможные локали, которые будут использоваться при выполнении сценария, являются надмножествами ASCII. Это означает, что сам скрипт не изменяется, но к дескрипторам ввода-вывода добавлена ​​указанная кодировка, и такие операции, как &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , используют эту кодировку.</target>
        </trans-unit>
        <trans-unit id="f8eb72d81f87d6a7a0f9e91198c8aa2adc48dbed" translate="yes" xml:space="preserve">
          <source>Starting in version 5.21.2, perls built with the experimental define &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; add an extra boolean flag for each op, &lt;code&gt;op_moresib&lt;/code&gt; . When not set, this indicates that this is the last op in an &lt;code&gt;OpSIBLING&lt;/code&gt; chain. This frees up the &lt;code&gt;op_sibling&lt;/code&gt; field on the last sibling to point back to the parent op. Under this build, that field is also renamed &lt;code&gt;op_sibparent&lt;/code&gt; to reflect its joint role. The macro &lt;code&gt;OpSIBLING(o)&lt;/code&gt; wraps this special behaviour, and always returns NULL on the last sibling. With this build the &lt;code&gt;op_parent(o)&lt;/code&gt; function can be used to find the parent of any op. Thus for forward compatibility, you should always use the &lt;code&gt;OpSIBLING(o)&lt;/code&gt; macro rather than accessing &lt;code&gt;op_sibling&lt;/code&gt; directly.</source>
          <target state="translated">Начиная с версии 5.21.2, perls, созданный с помощью экспериментального определения &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; , добавляет дополнительный логический флаг для каждой операции &lt;code&gt;op_moresib&lt;/code&gt; . Если не установлен, это означает, что это последняя &lt;code&gt;OpSIBLING&lt;/code&gt; цепочке OpSIBLING . Это освобождает поле &lt;code&gt;op_sibling&lt;/code&gt; на последнем брате, чтобы указать обратно на родительскую операцию. В этой сборке это поле также переименовано в &lt;code&gt;op_sibparent&lt;/code&gt; , чтобы отразить его совместную роль. Макрос &lt;code&gt;OpSIBLING(o)&lt;/code&gt; завершает это специальное поведение и всегда возвращает NULL для последнего родственника. В этой сборке &lt;code&gt;op_parent(o)&lt;/code&gt; можно использовать для поиска родителя любого op. Таким образом, для прямой совместимости вы всегда должны использовать &lt;code&gt;OpSIBLING(o)&lt;/code&gt; макрос вместо &lt;code&gt;op_sibling&lt;/code&gt; доступа к op_sibling .</target>
        </trans-unit>
        <trans-unit id="6641cb9032ef109574e28893d667801fcaa3e2c6" translate="yes" xml:space="preserve">
          <source>Starting with 2.10, the special module name &lt;code&gt;Unicode&lt;/code&gt; refers to the version of the Unicode Character Database bundled with Perl.</source>
          <target state="translated">Начиная с 2.10, специальное имя модуля &lt;code&gt;Unicode&lt;/code&gt; относится к версии базы данных символов Unicode, поставляемой вместе с Perl.</target>
        </trans-unit>
        <trans-unit id="aca846c8be32988d259af2e704c9972784ca9b87" translate="yes" xml:space="preserve">
          <source>Starting with AutoLoader 5.73, you can call the &lt;code&gt;AutoLoader::autoload_sub&lt;/code&gt; function with the fully-qualified name of the function to load from its</source>
          <target state="translated">Начиная с AutoLoader 5.73, вы можете вызывать функцию &lt;code&gt;AutoLoader::autoload_sub&lt;/code&gt; с полным именем функции, загружаемой из ее</target>
        </trans-unit>
        <trans-unit id="fe6dc30d7e458c682ee2ffab73f38deab13b705d" translate="yes" xml:space="preserve">
          <source>Starting with ExtUtils::ParseXS version 3.13_01 (comes with perl 5.16 and better), it is rather easy to share typemap code between multiple CPAN distributions. The general idea is to share it as a module that offers a certain API and have the dependent modules declare that as a built-time requirement and import the typemap into the XS. An example of such a typemap-sharing module on CPAN is &lt;code&gt;ExtUtils::Typemaps::Basic&lt;/code&gt; . Two steps to getting that module's typemaps available in your code:</source>
          <target state="translated">Начиная с ExtUtils :: ParseXS версии 3.13_01 (поставляется с Perl 5.16 и выше), довольно легко обмениваться кодом карты типов между несколькими дистрибутивами CPAN. Общая идея состоит в том, чтобы поделиться им как модулем, который предлагает определенный API, и чтобы зависимые модули объявляли это как требование встроенного времени и импортируют карту типов в XS. Примером такого модуля совместного использования карт типов в CPAN является &lt;code&gt;ExtUtils::Typemaps::Basic&lt;/code&gt; . Два шага, чтобы получить доступ к типам этого модуля в вашем коде:</target>
        </trans-unit>
        <trans-unit id="f9212af4220a7c7e6998749dd4723a25f0d7eab4" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.10, &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; and &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; are part of the standard distribution, so you might think that you could do something like this:</source>
          <target state="translated">Начиная с Perl 5.10, &lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt; и &lt;a href=&quot;time/seconds&quot;&gt;Time :: Seconds&lt;/a&gt; являются частью стандартного дистрибутива, поэтому вы можете подумать, что можете сделать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="97eea9254558fb3fd8f17c44c41b369b3648d850" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.10.0, integer and floating-point formats, along with the &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats and &lt;code&gt;()&lt;/code&gt; groups, may all be followed by the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; endianness modifiers to respectively enforce big- or little-endian byte-order. These modifiers are especially useful given how &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; , and &lt;code&gt;V&lt;/code&gt; don't cover signed integers, 64-bit integers, or floating-point values.</source>
          <target state="translated">Начиная с Perl 5.10.0, целочисленные форматы и форматы с плавающей запятой, а также форматы &lt;code&gt;p&lt;/code&gt; и &lt;code&gt;P&lt;/code&gt; и группы &lt;code&gt;()&lt;/code&gt; могут сопровождаться модификаторами &lt;code&gt;&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;&lt;/code&gt; endianness, соответственно, для обеспечения порядка байтов с прямым или обратным порядком байтов. Эти модификаторы особенно полезны, учитывая, что &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; и &lt;code&gt;V&lt;/code&gt; не охватывают целые числа со знаком, 64-битные целые числа или значения с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="2ee36782903bc57420ba5e155b45524572f22583" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.12, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; can handle dates past 03:14:08 January 19, 2038, when a 32-bit based time would overflow. You still might get a warning on a 32-bit &lt;code&gt;perl&lt;/code&gt; :</source>
          <target state="translated">Начиная с Perl 5.12, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; могут обрабатывать даты после 03:14:08 19 января 2038 г., когда 32-битное время будет переполняться. Вы все равно можете получить предупреждение на 32-битном &lt;code&gt;perl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3547c4def41d12fec193f972e11bcb976215d4c4" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.12, an additional integer parameter will be passed. It will be zero if &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; is called without parameter; &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; is given a filehandle as a parameter, e.g. &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(FH)&lt;/a&gt;&lt;/code&gt;; and &lt;code&gt;2&lt;/code&gt; in the very special case that the tied filehandle is &lt;code&gt;ARGV&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; is called with an empty parameter list, e.g. &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Начиная с Perl 5.12, будет передаваться дополнительный целочисленный параметр. Он будет равен нулю, если &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; вызывается без параметра; &lt;code&gt;1&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; задан дескриптор файла в качестве параметра, например &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(FH)&lt;/a&gt;&lt;/code&gt; ; и &lt;code&gt;2&lt;/code&gt; в очень частном случае, когда связанный дескриптор файла - это &lt;code&gt;ARGV&lt;/code&gt; , а &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; вызывается с пустым списком параметров, например &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3385173ff54b55e840ed45e4ab6e0da31d97fba8" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14 a parent will not wait() automatically for any child that has been signalled with &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('TERM', ...)&lt;/code&gt; to avoid a deadlock in case the child is blocking on I/O and never receives the signal.</source>
          <target state="translated">Начиная с Perl 5.14, родительский элемент не будет автоматически ждать () для любого дочернего элемента, о котором было сообщено с помощью &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('TERM', ...)&lt;/code&gt; чтобы избежать тупиковой ситуации в случае, если дочерний элемент блокирует ввод-вывод и никогда не получает сигнал.</target>
        </trans-unit>
        <trans-unit id="90de3712cf0c49e19f3e9d37735c0e97d4b521ae" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; может принимать скалярный EXPR, который должен содержать ссылку на неблаженный хэш или массив. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; считается экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="818e24d28a7aaf2cbc1a6702710734a070d06698" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; может принимать скалярный EXPR, который должен содержать ссылку на неблаженный хэш или массив. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; считается экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="72fa5cd516760576150d0418affb48e1abda4a5b" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must contain a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; могут принимать скалярное выражение EXPR, которое должно содержать ссылку на неблаженный хэш или массив. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; считается в высшей степени экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="e2b92aff600824b9c22651f1e75f3d65c35db8ae" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; может принимать скалярное выражение EXPR, которое должно содержать ссылку на массив без благословения. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; считается в высшей степени экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="07bb8994fa6804d1b79f779661eabab22fa4d596" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; может принимать скалярное выражение EXPR, которое должно содержать ссылку на массив без благословения. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; считается в высшей степени экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="10642e156a8402673021a377c62441722a9d8a63" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; может принимать скалярное выражение EXPR, которое должно содержать ссылку на массив без благословения. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; считается в высшей степени экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="5169411fd5bf69d929b67dfac03c2c64e43db230" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; can take scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; может принимать скалярный EXPR, который должен содержать ссылку на массив, не получивший разрешения. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; считается в высшей степени экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="7439a015aa95224d62eb3bbca9a133f540e69f0f" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; может принимать скалярное выражение EXPR, которое должно содержать ссылку на массив без благословения. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; считается в высшей степени экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="23e76a783b752b5dc19b6f3c4b3d934de488d5e6" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; могут принимать скалярное выражение EXPR, которое должно содержать ссылку на неблаженный хэш или массив. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; считается в высшей степени экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="47398b3574f050221d9d55302c39ea94e67781b9" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must contain a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; могут принимать скалярное выражение EXPR, которое должно содержать ссылку на неблаженный хэш или массив. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; считается в высшей степени экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="fac0b7eb35a23345be196afebeca8562c183fce3" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; может принимать скалярное выражение EXPR, которое должно содержать ссылку на массив без благословения. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; считается в высшей степени экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="427fc5d0e35cec380d803ece997f22ba459e7c3c" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; может принимать скалярное выражение EXPR, которое должно содержать ссылку на массив без благословения. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; считается в высшей степени экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="a0a12ea19c52c77b676bcf9fb786b8629096b3dc" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; может принимать скалярное выражение EXPR, которое должно содержать ссылку на массив без благословения. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; считается в высшей степени экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="a3217cf42c0331e4a0cfa6eb7dd493042a8c7e44" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; can take scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; может принимать скалярный EXPR, который должен содержать ссылку на массив, не получивший разрешения. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; считается в высшей степени экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="d0f153998e2fa782a330b974d3d6a495fc8735ee" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; может принимать скалярное выражение EXPR, которое должно содержать ссылку на массив без благословения. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; считается в высшей степени экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="e3eb26fa45077fda36157e3c2cd25a74327fbf5e" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Начиная с Perl 5.14, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; могут принимать скалярное выражение EXPR, которое должно содержать ссылку на неблаженный хэш или массив. Аргумент будет автоматически разыменован. Этот аспект &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; считается в высшей степени экспериментальным. Точное поведение может измениться в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="84114b43a4e1c51016947fa39587027a5c42b337" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.16, you can embed typemaps into your XS code instead of or in addition to typemaps in a separate file. Multiple such embedded typemaps will be processed in order of appearance in the XS code and like local typemap files take precedence over the default typemap, the embedded typemaps may overwrite previous definitions of TYPEMAP, INPUT, and OUTPUT stanzas. The syntax for embedded typemaps is</source>
          <target state="translated">Начиная с версии Perl 5.16,вы можете встраивать карты типов в код XS вместо или в дополнение к картам типов в отдельном файле.Многочисленные такие встроенные карты типов будут обработаны в порядке появления в коде XS,и,как и локальные файлы карты типов имеют приоритет над картой типов по умолчанию,встроенные карты типов могут перезаписывать предыдущие определения TYPEMAP,INPUT и OUTPUT-стенз.Синтаксис для встроенных типовых карт таков.</target>
        </trans-unit>
        <trans-unit id="ead2268f227644c92e6fae21c9b2bbc1c3977d01" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.8, a macro framework has been defined to allow static data to be safely stored in XS modules that will be accessed from a multi-threaded Perl.</source>
          <target state="translated">Начиная с Perl 5.8,был определен макрофреймворк,позволяющий безопасно хранить статические данные в модулях XS,доступ к которым будет осуществляться с многопоточного Perl.</target>
        </trans-unit>
        <trans-unit id="83f897274d9417a81431b1cfc87771e6f6b3c937" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.8.1 strict is strict about its restrictions: if unknown restrictions are used, the strict pragma will abort with</source>
          <target state="translated">Начиная с версии Perl 5.8.1,строгие ограничения:если используются неизвестные ограничения,то строгая прагма прерывается с помощью</target>
        </trans-unit>
        <trans-unit id="4c86c42abf281eff02c433a98ecba5908f6fea66" translate="yes" xml:space="preserve">
          <source>Starting with Solaris 8, perl5.00503 (or higher) is supplied with the operating system, so you might not even need to build a newer version of perl at all. The Sun-supplied version is installed in /usr/perl5 with</source>
          <target state="translated">Начиная с Solaris 8,perl5.00503 (или выше)поставляется в комплекте с операционной системой,так что,возможно,вам даже не понадобится собирать более новую версию perl вообще.Версия,поставляемая в комплекте с Sun,устанавливается в /usr/perl5 с</target>
        </trans-unit>
        <trans-unit id="070cbbea94d8e9dec2f41e08f125528dd6a6e9b2" translate="yes" xml:space="preserve">
          <source>Starting with Tiger (Mac OS X 10.4), Apple shipped broken locale files for the eu_ES locale (Basque-Spain). In previous releases of Perl, this resulted in failures in the</source>
          <target state="translated">Начиная с Tiger (Mac OS X 10.4),Apple поставляла сломанные файлы локали eu_ES (Basque-Spain).В предыдущих релизах Perl это приводило к сбоям в работе с</target>
        </trans-unit>
        <trans-unit id="0811928afaca739fa817229f5f4a0d0397bc7c2a" translate="yes" xml:space="preserve">
          <source>Starting with release 1.23_03, Scalar-List-Util is &lt;b&gt;always&lt;/b&gt; using the XS implementation, but for backwards compatibility, we still ship the &lt;code&gt;List::Util::XS&lt;/code&gt; module which just loads &lt;code&gt;List::Util&lt;/code&gt; .</source>
          <target state="translated">Начиная с версии 1.23_03, Scalar-List-Util &lt;b&gt;всегда&lt;/b&gt; использует реализацию XS, но для обратной совместимости мы по-прежнему поставляем модуль &lt;code&gt;List::Util::XS&lt;/code&gt; который просто загружает &lt;code&gt;List::Util&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f31afb43ed5a01839f8ddc750e5dd35f48c3a6c" translate="yes" xml:space="preserve">
          <source>Starting with this section, we will be discussing Perl's set of</source>
          <target state="translated">Начиная с этого раздела,мы будем обсуждать набор Perl's</target>
        </trans-unit>
        <trans-unit id="8ef231992030ec09e2d04d1b4b88e1196c802a84" translate="yes" xml:space="preserve">
          <source>Starting with version 2.x, Berkeley DB has internal support for locking. The companion module to this one, &lt;b&gt;BerkeleyDB&lt;/b&gt;, provides an interface to this locking functionality. If you are serious about locking Berkeley DB databases, I strongly recommend using &lt;b&gt;BerkeleyDB&lt;/b&gt;.</source>
          <target state="translated">Начиная с версии 2.x, Berkeley DB имеет внутреннюю поддержку блокировки. Дополнительный модуль к этому, &lt;b&gt;BerkeleyDB&lt;/b&gt; , предоставляет интерфейс для этой функции блокировки. Если вы серьезно относитесь к блокировке баз данных Berkeley DB, я настоятельно рекомендую использовать &lt;b&gt;BerkeleyDB&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="6f6299a2f62ed0797f2e4ca75150d013801fc49f" translate="yes" xml:space="preserve">
          <source>Starts a try block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">Запускает блок попытки. См. Раздел &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Обработка исключений в perlguts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79ce33706ca0540aaf9d8ed291d64bf45fad0cd4" translate="yes" xml:space="preserve">
          <source>Startup</source>
          <target state="translated">Startup</target>
        </trans-unit>
        <trans-unit id="6991439e4716de488447c6e2c2f9b1970b90a8e3" translate="yes" xml:space="preserve">
          <source>Stashes and Globs</source>
          <target state="translated">Тайники и глобусы</target>
        </trans-unit>
        <trans-unit id="acf91ec4328cf0ba3defd8522962fa33e41a1740" translate="yes" xml:space="preserve">
          <source>State storage for the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">Хранилище состояний для команды &lt;code&gt;prove&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed2cb72d0aaac69d6842c67515cf3bf802a6b33a" translate="yes" xml:space="preserve">
          <source>Statement Modifiers</source>
          <target state="translated">Поправки к отчету</target>
        </trans-unit>
        <trans-unit id="1ddbc09b1ca4e7855762d5787c6c0d7a3595a8af" translate="yes" xml:space="preserve">
          <source>Static Linking of a new Perl Binary</source>
          <target state="translated">Статическая связь нового двоичного Perl.</target>
        </trans-unit>
        <trans-unit id="3c5f15db40f98d51818ecdf0034d37509667528b" translate="yes" xml:space="preserve">
          <source>Static functions might not be visible for the backtrace.</source>
          <target state="translated">Статические функции могут быть не видны для обратной связи.</target>
        </trans-unit>
        <trans-unit id="8f8ab9355e9f77bfc04d09779d25ce6944605b91" translate="yes" xml:space="preserve">
          <source>Statistics about downloads are truncated by size and period simultaneously.</source>
          <target state="translated">Статистика по скачиванию усечена по размеру и периоду одновременно.</target>
        </trans-unit>
        <trans-unit id="5610cd01f9a3d6080e798d67334a100aa1573c90" translate="yes" xml:space="preserve">
          <source>Status 1 overrides status 2. If you want unambiguous results, call &lt;b&gt;podchecker&lt;/b&gt; with one single argument only.</source>
          <target state="translated">Статус 1 имеет приоритет над статусом 2. Если вы хотите получить однозначные результаты, вызовите &lt;b&gt;podchecker только&lt;/b&gt; с одним аргументом.</target>
        </trans-unit>
        <trans-unit id="187236d960db5eb4ad8363cf8f2f9b1ddb6ac5e1" translate="yes" xml:space="preserve">
          <source>Stdio class buffering options.</source>
          <target state="translated">Опции буферизации Stdio класса.</target>
        </trans-unit>
        <trans-unit id="60a9d23beb62cbe40cee43c7f38898ee6c1f97c7" translate="yes" xml:space="preserve">
          <source>Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;</source>
          <target state="translated">Штеффен Мюллер &amp;lt;smueller@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c982c59dd847ba297d8467bd252ba58dd872a85c" translate="yes" xml:space="preserve">
          <source>Steffen Mueller, &amp;lt;smueller@cpan.org&amp;gt;</source>
          <target state="translated">Штеффен Мюллер, &amp;lt;smueller@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="67aeabbbe7f975f118f5118824dfb5a83bb31c11" translate="yes" xml:space="preserve">
          <source>Step-by-step: Distributing your module</source>
          <target state="translated">Шаг за шагом:Распространение вашего модуля</target>
        </trans-unit>
        <trans-unit id="1a565c4552b2edcc3b1a58d76fe5018ccb0e6a32" translate="yes" xml:space="preserve">
          <source>Step-by-step: Making the module</source>
          <target state="translated">Шаг за шагом:Создание модуля</target>
        </trans-unit>
        <trans-unit id="481a4d002beceae3935eab8245f4c76879540359" translate="yes" xml:space="preserve">
          <source>Step-by-step: Preparing the ground</source>
          <target state="translated">Шаг за шагом:Подготовка почвы</target>
        </trans-unit>
        <trans-unit id="80427e23cbb5abd94ca5e55445014873b52c64b8" translate="yes" xml:space="preserve">
          <source>Stephen McCamant &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;, based on an earlier version by Malcolm Beattie &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;, with contributions from Gisle Aas, James Duncan, Albert Dvornik, Robin Houston, Dave Mitchell, Hugo van der Sanden, Gurusamy Sarathy, Nick Ing-Simmons, and Rafael Garcia-Suarez.</source>
          <target state="translated">Стивен МакКамант &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;, основанный на более ранней версии Малкольма Битти &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;, при участии Жизл Аас, Джеймса Дункана, Альберта Дворника, Робина Хьюстона, Дэйва Митчелла, Хуго ван дер Санден, Гурусами Сарати, Ник Инг-Симмонс и Рафаэль Гарсиа-Суарес.</target>
        </trans-unit>
        <trans-unit id="6a244b340bceacb4b7643a7f28401322b0f43369" translate="yes" xml:space="preserve">
          <source>Stephen McCamant, &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;.</source>
          <target state="translated">Стивен Маккамант, &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="406bdac466755debe16970475ad1ba98d0b486e3" translate="yes" xml:space="preserve">
          <source>Stepping through code</source>
          <target state="translated">Пошаговый просмотр кода</target>
        </trans-unit>
        <trans-unit id="f13a1be70942b94ceb5c4947f5cad9efec256df0" translate="yes" xml:space="preserve">
          <source>Steps through the program a line at a time, without descending into functions.</source>
          <target state="translated">Проходит через программу по строке за раз,не опускаясь в функции.</target>
        </trans-unit>
        <trans-unit id="67e08e5dee051e0626b0f262d208037e870d3ac2" translate="yes" xml:space="preserve">
          <source>Steps through the program a line at a time.</source>
          <target state="translated">Проходит через программу по очереди.</target>
        </trans-unit>
        <trans-unit id="f18c11d1612cf243a4188b75a5a32a4030b759d2" translate="yes" xml:space="preserve">
          <source>Steve Hay &amp;lt;</source>
          <target state="translated">Стив Хэй &amp;lt;</target>
        </trans-unit>
        <trans-unit id="9d16db78589f14f29e83bbd762e7ffb3c9579828" translate="yes" xml:space="preserve">
          <source>Steve Lembark goes through the details in his YAPC::NA 2009 talk &quot;Perly Linked Lists&quot; ( &lt;a href=&quot;http://www.slideshare.net/lembark/perly-linked-lists&quot;&gt;http://www.slideshare.net/lembark/perly-linked-lists&lt;/a&gt; ), although you can just use his &lt;a href=&quot;http://search.cpan.org/perldoc/LinkedList::Single&quot;&gt;LinkedList::Single&lt;/a&gt; module.</source>
          <target state="translated">Стив Лембарк подробно рассматривает детали в своем выступлении на YAPC :: NA 2009 &amp;laquo;Perly Linked Lists&amp;raquo; ( &lt;a href=&quot;http://www.slideshare.net/lembark/perly-linked-lists&quot;&gt;http://www.slideshare.net/lembark/perly-linked-lists&lt;/a&gt; ), хотя вы можете просто использовать его модуль &lt;a href=&quot;http://search.cpan.org/perldoc/LinkedList::Single&quot;&gt;LinkedList :: Single&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09652192134371fdefcd293d5003ff83e32ed6ed" translate="yes" xml:space="preserve">
          <source>Steve Peters &amp;lt;steve@fisharerojo.org&amp;gt;</source>
          <target state="translated">Стив Питерс &amp;lt;steve@fisharerojo.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7d6ea163d8063bfc57b0256f3178b768eac364c1" translate="yes" xml:space="preserve">
          <source>Steve Purkis</source>
          <target state="translated">Стив Пёркис</target>
        </trans-unit>
        <trans-unit id="9efb7766602083380f01f9cadb6f278fbfabf5e5" translate="yes" xml:space="preserve">
          <source>Steve Purkis &amp;lt;spurkis@cpan.org&amp;gt;</source>
          <target state="translated">Стив Пуркис &amp;lt;spurkis@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2200943829d703ee08a178c2eb1eee2c0a806988" translate="yes" xml:space="preserve">
          <source>Steve Purkis.</source>
          <target state="translated">Стив Пёркис.</target>
        </trans-unit>
        <trans-unit id="270c172269bbb0672801106f89223f66575337c6" translate="yes" xml:space="preserve">
          <source>Steven McDougall &amp;lt;swmcd@world.std.com&amp;gt; for his help and patience with re-writing this manpage.</source>
          <target state="translated">Стивену Макдугаллу &amp;lt;swmcd@world.std.com&amp;gt; за его помощь и терпение при переписывании этой справочной страницы.</target>
        </trans-unit>
        <trans-unit id="3a70ee5e8fb61558310f5b5e31b73a3d007c0de0" translate="yes" xml:space="preserve">
          <source>Still another problem is that this approach can lead to two code points meaning the same character. Thus in a Greek locale, both U+03A7 and U+00D7 are GREEK CAPITAL LETTER CHI.</source>
          <target state="translated">Еще одна проблема заключается в том,что такой подход может привести к двум точкам кода,означающим один и тот же символ.Таким образом,в греческой локали и U+03A7,и U+00D7 являются GREEK CAPITAL LETTER CHI.</target>
        </trans-unit>
        <trans-unit id="72bc7a84f86b7c98bba879166a64bc5b045625fd" translate="yes" xml:space="preserve">
          <source>Stops running tests as &quot;TODO&quot; tests. This method is fatal if called without a preceding &lt;code&gt;todo_start&lt;/code&gt; method call.</source>
          <target state="translated">Прекращает выполнение тестов как тестов TODO. Этот метод является фатальным, если вызывается без предшествующего &lt;code&gt;todo_start&lt;/code&gt; метода todo_start .</target>
        </trans-unit>
        <trans-unit id="45b0f8b6273dfd6e7997a4038c99b48d40e17dae" translate="yes" xml:space="preserve">
          <source>Storable</source>
          <target state="translated">Storable</target>
        </trans-unit>
        <trans-unit id="46f9f6e335231e1456d3ba18bd5a505213eb74c6" translate="yes" xml:space="preserve">
          <source>Storable - persistence for Perl data structures</source>
          <target state="translated">Хранение-стойкость для структур данных Perl</target>
        </trans-unit>
        <trans-unit id="1630856d50b3ec9af87960aa33400ccd3dc094bd" translate="yes" xml:space="preserve">
          <source>Storable has now been changed to write out and read in a file header with information about the size of integers. It's impossible to detect whether an old file being read in was written with 32 or 64 bit integers (they have the same header) so it's impossible to automatically switch to a correct backwards compatibility mode. Hence this Storable defaults to the new, correct behaviour.</source>
          <target state="translated">Теперь Storable изменена на запись и чтение в заголовке файла с информацией о размере целых чисел.Невозможно определить,был ли старый читаемый файл записан с 32 или 64-битными целыми числами (они имеют один и тот же заголовок),поэтому невозможно автоматически переключиться в правильный режим обратной совместимости.Следовательно,по умолчанию Storable устанавливает новое,корректное поведение.</target>
        </trans-unit>
        <trans-unit id="714a2ccbafbac0389af167e01df326cf6b8a78ff" translate="yes" xml:space="preserve">
          <source>Storable magic</source>
          <target state="translated">Хранимое волшебство</target>
        </trans-unit>
        <trans-unit id="7182df5560db2bb6b5167976e453bb5798e3130f" translate="yes" xml:space="preserve">
          <source>Storable provides you with a &lt;code&gt;dclone&lt;/code&gt; interface which does not create that intermediary scalar but instead freezes the structure in some internal memory space and then immediately thaws it out.</source>
          <target state="translated">Storable предоставляет вам интерфейс &lt;code&gt;dclone&lt;/code&gt; , который не создает этот промежуточный скаляр, а вместо этого замораживает структуру в некотором пространстве внутренней памяти, а затем немедленно размораживает ее.</target>
        </trans-unit>
        <trans-unit id="70fb12ce1748ed7f4a137be836ce41aa365bbd68" translate="yes" xml:space="preserve">
          <source>Storable uses the &quot;exception&quot; paradigm, in that it does not try to workaround failures: if something bad happens, an exception is generated from the caller's perspective (see &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; and &lt;code&gt;croak()&lt;/code&gt; ). Use eval {} to trap those exceptions.</source>
          <target state="translated">Storable использует парадигму &amp;laquo;исключения&amp;raquo; в том смысле, что он не пытается обходить сбои: если происходит что-то плохое, с точки зрения вызывающего генерируется исключение (см. &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; and &lt;code&gt;croak()&lt;/code&gt; ). Используйте eval {}, чтобы перехватить эти исключения.</target>
        </trans-unit>
        <trans-unit id="531ca0b8b45f41c9f0b1aa246372790831675baa" translate="yes" xml:space="preserve">
          <source>Storable was written by Raphael Manfredi</source>
          <target state="translated">Storable был написан Рафаэлем Манфреди.</target>
        </trans-unit>
        <trans-unit id="b7e864254e3dece2f3614748bd8acc66ad85caaa" translate="yes" xml:space="preserve">
          <source>Storable writes a file header which contains the sizes of various C language types for the C compiler that built Storable (when not writing in network order), and will refuse to load files written by a Storable not on the same (or compatible) architecture. This check and a check on machine byteorder is needed because the size of various fields in the file are given by the sizes of the C language types, and so files written on different architectures are incompatible. This is done for increased speed. (When writing in network order, all fields are written out as standard lengths, which allows full interworking, but takes longer to read and write)</source>
          <target state="translated">Storable записывает заголовок файла,который содержит размеры различных типов языка Си для компилятора C,построившего Storable (когда запись производится не в сетевом порядке),и откажется загружать файлы,написанные Storable не на той же (или совместимой)архитектуре.Эта проверка и проверка на машинном байтранжере нужна,так как размер различных полей в файле задается размерами языковых типов Си,и поэтому файлы,написанные на разных архитектурах,несовместимы.Это делается для большей скорости.(При записи в сетевом порядке все поля записываются в виде стандартных длин,что позволяет полностью взаимодействовать,но требует больше времени на чтение и запись).</target>
        </trans-unit>
        <trans-unit id="4150d3a5cc43231c993765dececd1a150bb52a3d" translate="yes" xml:space="preserve">
          <source>Store Memoized data in Storable database</source>
          <target state="translated">Хранение запоминаемых данных в базе данных Storable</target>
        </trans-unit>
        <trans-unit id="92a651d3dc16aed75ba857e2f774b7e083ba7965" translate="yes" xml:space="preserve">
          <source>Store and re-use state information about distributions between CPAN.pm sessions?</source>
          <target state="translated">Хранить и повторно использовать информацию о состоянии распределения между сессиями CPAN.pm?</target>
        </trans-unit>
        <trans-unit id="2c71530924851d1b8827aef4994b16eb515c4e61" translate="yes" xml:space="preserve">
          <source>Store data</source>
          <target state="translated">Дата хранения</target>
        </trans-unit>
        <trans-unit id="b25c722ad4f1fce5bbbe8fc35b0030d7d69ef919" translate="yes" xml:space="preserve">
          <source>Store datum</source>
          <target state="translated">Хранить данные</target>
        </trans-unit>
        <trans-unit id="8f37eea7a30e3775bbbbb580f43dfdd3bec41576" translate="yes" xml:space="preserve">
          <source>Store the results of a test.</source>
          <target state="translated">Хранить результаты теста.</target>
        </trans-unit>
        <trans-unit id="389cd56c2ab90c83d09e93be1e21e43d82460448" translate="yes" xml:space="preserve">
          <source>Stores &lt;code&gt;$value&lt;/code&gt; in the gzip OS header field. A number between 0 and 255 is valid.</source>
          <target state="translated">Сохраняет &lt;code&gt;$value&lt;/code&gt; в поле заголовка ОС gzip. Допустимое число от 0 до 255.</target>
        </trans-unit>
        <trans-unit id="b39d714bdc1e95f53f0e2222e4e3c3755001f302" translate="yes" xml:space="preserve">
          <source>Stores &lt;code&gt;val&lt;/code&gt; in a hash. The hash key is specified as &lt;code&gt;key&lt;/code&gt; . The &lt;code&gt;hash&lt;/code&gt; parameter is the precomputed hash value; if it is zero then Perl will compute it. The return value is the new hash entry so created. It will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise the contents of the return value can be accessed using the &lt;code&gt;He?&lt;/code&gt; macros described here. Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful hv_store_ent takes ownership of one reference to &lt;code&gt;val&lt;/code&gt; . This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, hv_store will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. Note that hv_store_ent only reads the &lt;code&gt;key&lt;/code&gt; ; unlike &lt;code&gt;val&lt;/code&gt; it does not take ownership of it, so maintaining the correct reference count on &lt;code&gt;key&lt;/code&gt; is entirely the caller's responsibility. hv_store is not implemented as a call to hv_store_ent, and does not create a temporary SV for the key, so if your key data is not already in SV form then use hv_store in preference to hv_store_ent.</source>
          <target state="translated">Сохраняет &lt;code&gt;val&lt;/code&gt; в хэше. Хэш-ключ указан как &lt;code&gt;key&lt;/code&gt; . Параметр &lt;code&gt;hash&lt;/code&gt; - это предварительно вычисленное значение хеш-функции; если он равен нулю, Perl вычислит его. Возвращаемое значение - это созданная таким образом новая запись хэша. Он будет NULL, если операция завершилась неудачно или значение не нужно было фактически хранить в хэше (как в случае связанных хешей). В противном случае к содержимому возвращаемого значения можно будет получить доступ с помощью &lt;code&gt;He?&lt;/code&gt; макросы описаны здесь. Обратите внимание, что вызывающая сторона отвечает за соответствующее увеличение счетчика ссылок &lt;code&gt;val&lt;/code&gt; перед вызовом и уменьшение его, если функция вернула NULL. Фактически успешный hv_store_ent становится владельцем одной ссылки на &lt;code&gt;val&lt;/code&gt; . Обычно это то, что вы хотите; вновь созданный SV имеет счетчик ссылок, равный единице, поэтому, если весь ваш код создает SV, а затем сохраняет их в хэше, hv_store будет владеть единственной ссылкой на новый SV, и вашему коду не нужно делать что-либо еще для прибраться. Обратите внимание, что hv_store_ent только читает &lt;code&gt;key&lt;/code&gt; ; в отличие от &lt;code&gt;val&lt;/code&gt; , он не получает права собственности на него, поэтому поддержание правильного счетчика ссылок на &lt;code&gt;key&lt;/code&gt; полностью является обязанностью вызывающего объекта. hv_store не реализован как вызов hv_store_ent и не создает временный SV для ключа, поэтому, если ваши данные ключа еще не находятся в форме SV, используйте hv_store вместо hv_store_ent.</target>
        </trans-unit>
        <trans-unit id="7e853791e7f610503cb4ac62aa2d38d07104bcbf" translate="yes" xml:space="preserve">
          <source>Stores a value, associated with a key, in the cop hints hash</source>
          <target state="translated">Хранит значение,связанное с ключом,в хэше подсказок копа.</target>
        </trans-unit>
        <trans-unit id="5e0142d462eb02b96cf9082ac295203e85636940" translate="yes" xml:space="preserve">
          <source>Stores all unambiguous truncations of each element of LIST as keys in the associative array referenced by &lt;code&gt;$hashref&lt;/code&gt; . The values are the original list elements.</source>
          <target state="translated">Сохраняет все однозначные усечения каждого элемента LIST в качестве ключей в ассоциативном массиве, на который ссылается &lt;code&gt;$hashref&lt;/code&gt; . Значения являются исходными элементами списка.</target>
        </trans-unit>
        <trans-unit id="4236561c990b7cd479ccb52f08cd5fac9306b818" translate="yes" xml:space="preserve">
          <source>Stores an SV in a hash. The hash key is specified as &lt;code&gt;key&lt;/code&gt; and the absolute value of &lt;code&gt;klen&lt;/code&gt; is the length of the key. If &lt;code&gt;klen&lt;/code&gt; is negative the key is assumed to be in UTF-8-encoded Unicode. The &lt;code&gt;hash&lt;/code&gt; parameter is the precomputed hash value; if it is zero then Perl will compute it.</source>
          <target state="translated">Хранит SV в хэше. Хэш-ключ указан как &lt;code&gt;key&lt;/code&gt; а абсолютное значение &lt;code&gt;klen&lt;/code&gt; - это длина ключа. Если &lt;code&gt;klen&lt;/code&gt; отрицательный, предполагается, что ключ находится в кодировке UTF-8 Unicode. Параметр &lt;code&gt;hash&lt;/code&gt; - это предварительно вычисленное значение хеш-функции; если он равен нулю, Perl вычислит его.</target>
        </trans-unit>
        <trans-unit id="d6c29a0065e8b044a53af0ddb9dc3214fa041cf5" translate="yes" xml:space="preserve">
          <source>Stores an SV in an array. The array index is specified as &lt;code&gt;key&lt;/code&gt; . The return value will be NULL if the operation failed or if the value did not need to be actually stored within the array (as in the case of tied arrays). Otherwise, it can be dereferenced to get the &lt;code&gt;SV*&lt;/code&gt; that was stored there (= &lt;code&gt;val&lt;/code&gt; )).</source>
          <target state="translated">Сохраняет SV в массиве. Индекс массива указан как &lt;code&gt;key&lt;/code&gt; . Возвращаемое значение будет NULL, если операция завершилась неудачно или значение не нужно было фактически хранить в массиве (как в случае связанных массивов). В противном случае его можно разыменовать, чтобы получить сохраненный там &lt;code&gt;SV*&lt;/code&gt; (= &lt;code&gt;val&lt;/code&gt; )).</target>
        </trans-unit>
        <trans-unit id="7401a972574f8c1665c02fe0802590c81677bf55" translate="yes" xml:space="preserve">
          <source>Stores an alias to a variable in a hash instead of copying the value.</source>
          <target state="translated">Хранит псевдоним в переменной в хэше вместо копирования значения.</target>
        </trans-unit>
        <trans-unit id="9f6711f9c55cd1025cf538a50470266deb723a43" translate="yes" xml:space="preserve">
          <source>Stores results for later output, all together.</source>
          <target state="translated">Сохраняет результаты для последующего вывода,все вместе.</target>
        </trans-unit>
        <trans-unit id="ced5e829ffc1318c3116b905b84107c1f3b72848" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$comment&lt;/code&gt; in the COMMENT field in the gzip header. By default, no comment field is written to the gzip file.</source>
          <target state="translated">Сохраняет содержимое &lt;code&gt;$comment&lt;/code&gt; в поле COMMENT в заголовке gzip. По умолчанию в файл gzip не записывается поле для комментариев.</target>
        </trans-unit>
        <trans-unit id="26843a54a3aa3332ec1baa3fb76f8c537a96c327" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$comment&lt;/code&gt; in the Central File Header of the zip file.</source>
          <target state="translated">Сохраняет содержимое &lt;code&gt;$comment&lt;/code&gt; в центральном заголовке файла zip-архива.</target>
        </trans-unit>
        <trans-unit id="f6d27852fc3f996b193528d04367b82db064d418" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$comment&lt;/code&gt; in the End of Central Directory record of the zip file.</source>
          <target state="translated">Сохраняет содержимое &lt;code&gt;$comment&lt;/code&gt; в записи &amp;laquo;Конец центрального каталога&amp;raquo; zip-файла.</target>
        </trans-unit>
        <trans-unit id="24042b8640feee28c4f2a0aafea788776423cdd1" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$string&lt;/code&gt; in the gzip NAME header field. If &lt;code&gt;Name&lt;/code&gt; is not specified, no gzip NAME field will be created.</source>
          <target state="translated">Сохраняет содержимое &lt;code&gt;$string&lt;/code&gt; в поле заголовка gzip NAME. Если &lt;code&gt;Name&lt;/code&gt; не указано, поле ИМЯ gzip не будет создано.</target>
        </trans-unit>
        <trans-unit id="1023c335a52babfe2f8c4a04c4f2766471fa8387" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$string&lt;/code&gt; in the zip filename header field.</source>
          <target state="translated">Сохраняет содержимое &lt;code&gt;$string&lt;/code&gt; в поле заголовка файла zip-архива.</target>
        </trans-unit>
        <trans-unit id="51541d8a3d93b2d48a376cb2252ed37ed72421ab" translate="yes" xml:space="preserve">
          <source>Stores the key/value pair in the database.</source>
          <target state="translated">Хранит пару ключ/значение в базе данных.</target>
        </trans-unit>
        <trans-unit id="ab093d23324af52293488a603b3cc3854b181a9e" translate="yes" xml:space="preserve">
          <source>Stores the pad name (which may be null) at the given index, freeing any existing pad name in that slot.</source>
          <target state="translated">Хранит имя колодки (которое может быть нулевым)в данном индексе,освобождая любое существующее имя колодки в этом слоте.</target>
        </trans-unit>
        <trans-unit id="9d70a29a0f92ba96f998b27b0c51d6b21ce2123e" translate="yes" xml:space="preserve">
          <source>Stores the string &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringifies to. The Perl engine for example stores &lt;code&gt;(?^:eek)&lt;/code&gt; in the case of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/eek/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сохраняет строку &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; преобразуется в. Например, движок Perl сохраняет &lt;code&gt;(?^:eek)&lt;/code&gt; в случае &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/eek/&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30082107d90ca21e79e8350f2001678a7dc4b25b" translate="yes" xml:space="preserve">
          <source>Storing data canonically that contains large hashes can be significantly slower than storing the same data normally, as temporary arrays to hold the keys for each hash have to be allocated, populated, sorted and freed. Some tests have shown a halving of the speed of storing -- the exact penalty will depend on the complexity of your data. There is no slowdown on retrieval.</source>
          <target state="translated">Хранение данных канонически,содержащих большие хэши,может быть значительно медленнее,чем хранение тех же данных обычно,так как временные массивы для хранения ключей для каждого хэша должны быть распределены,заполнены,отсортированы и освобождены.Некоторые тесты показали снижение скорости хранения вдвое-точное наказание будет зависеть от сложности ваших данных.Замедления при извлечении нет.</target>
        </trans-unit>
        <trans-unit id="2ccce2de5e8ad98636ec0480f8c1e95cb4123766" translate="yes" xml:space="preserve">
          <source>Storing numbers</source>
          <target state="translated">Хранение номеров</target>
        </trans-unit>
        <trans-unit id="408286a7232f91f660936da7835bac0e8863fd20" translate="yes" xml:space="preserve">
          <source>Storing options values in a hash</source>
          <target state="translated">Хранение значений опционов в хэше</target>
        </trans-unit>
        <trans-unit id="5ca11c09231ed950fa4ac2095c30a18383eebf81" translate="yes" xml:space="preserve">
          <source>Storing pre-compiled regexps in an array &lt;code&gt;@compiled&lt;/code&gt; allows us to simply loop through the regexps without any recompilation, thus gaining flexibility without sacrificing speed.</source>
          <target state="translated">Сохранение предварительно скомпилированных регулярных выражений в массиве &lt;code&gt;@compiled&lt;/code&gt; позволяет нам просто перебирать регулярные выражения без какой-либо перекомпиляции, что обеспечивает гибкость без ущерба для скорости.</target>
        </trans-unit>
        <trans-unit id="3e08b2cdc880eca3b63a251507ea23ebf665def8" translate="yes" xml:space="preserve">
          <source>Straightaway we can see that the number of times each line has been called is identical to the &lt;code&gt;Devel::SmallProf&lt;/code&gt; output, and the sequence is only very slightly different based on the ordering of the amount of time each line took to execute, &lt;code&gt;if ( $debug ) { &lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $message = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; , for example. The differences in the actual times recorded might be in the algorithm used internally, or it could be due to system resource limitations or contention.</source>
          <target state="translated">Сразу видно, что количество &lt;code&gt;Devel::SmallProf&lt;/code&gt; каждой строки идентично выводу Devel :: SmallProf , а последовательность лишь очень немного отличается в зависимости от порядка количества времени, которое потребовалось для выполнения каждой строки, &lt;code&gt;if ( $debug ) { &lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $message = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; , например. Различия в фактическом записанном времени могут быть связаны с внутренним алгоритмом, или это может быть связано с ограничениями ресурсов системы или конфликтом.</target>
        </trans-unit>
        <trans-unit id="cf5060e04f34c62382f4c8552c1d1cf9f000d47b" translate="yes" xml:space="preserve">
          <source>Strategies for Storing Callback Context Information</source>
          <target state="translated">Стратегии хранения обратного вызова Контекстная информация</target>
        </trans-unit>
        <trans-unit id="813265ea56803a78f3b7159d5fee7e20c7133600" translate="yes" xml:space="preserve">
          <source>Stratus Technologies on the web at &lt;a href=&quot;http://www.stratus.com&quot;&gt;http://www.stratus.com&lt;/a&gt;</source>
          <target state="translated">Stratus Technologies в Интернете по адресу &lt;a href=&quot;http://www.stratus.com&quot;&gt;http://www.stratus.com&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9e8d1a4aa1f448e22fd91f660943bf3fb47ccc9" translate="yes" xml:space="preserve">
          <source>Stratus VOS 15.1, &lt;a href=&quot;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&quot;&gt;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&lt;/a&gt;</source>
          <target state="translated">Stratus VOS 15.1, &lt;a href=&quot;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&quot;&gt;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6dac5050cc8d5226a232897b98c67a79066b8e3a" translate="yes" xml:space="preserve">
          <source>Stream TAP from a Perl executable</source>
          <target state="translated">Поток TAP из исполняемого файла на Perl</target>
        </trans-unit>
        <trans-unit id="411adcb2712346800a739adfeb9ade95333b1abf" translate="yes" xml:space="preserve">
          <source>Stream TAP from a text file.</source>
          <target state="translated">Поток TAP из текстового файла.</target>
        </trans-unit>
        <trans-unit id="5517c94f54c087e37e9e39887df00a0c39d682fc" translate="yes" xml:space="preserve">
          <source>Stream TAP from an IO::Handle or a GLOB.</source>
          <target state="translated">Поток TAP от IO::Handle или GLOB.</target>
        </trans-unit>
        <trans-unit id="044591cd59e9b7c9396655ff7bb64423112f9b95" translate="yes" xml:space="preserve">
          <source>Stream output from an executable TAP source</source>
          <target state="translated">Потоковый вывод от исполняемого источника TAP</target>
        </trans-unit>
        <trans-unit id="137d2933966619b13837102be962efe1a1067d69" translate="yes" xml:space="preserve">
          <source>Stream output from raw TAP in a scalar/array ref.</source>
          <target state="translated">Поток выходного сигнала от необработанного TAP в скаляре/массиве Ref.</target>
        </trans-unit>
        <trans-unit id="79d9a52c246461dc0594d29507cd94db89e5088f" translate="yes" xml:space="preserve">
          <source>Stricter rules help to find typos and other errors. Perhaps you didn't even intend a range here, if the &lt;code&gt;&quot;-&quot;&lt;/code&gt; was meant to be some other character, or should have been escaped (like &lt;code&gt;&quot;\-&quot;&lt;/code&gt; ). If you did intend a range, the one that was used is not portable between ASCII and EBCDIC platforms, and doesn't have an obvious meaning to a casual reader.</source>
          <target state="translated">Более строгие правила помогают находить опечатки и другие ошибки. Возможно, вы даже не предполагали здесь диапазон, если &lt;code&gt;&quot;-&quot;&lt;/code&gt; должен был быть каким-то другим символом или должен был быть экранирован (например, &lt;code&gt;&quot;\-&quot;&lt;/code&gt; ). Если вы намеревались использовать диапазон, то тот, который использовался, не переносится между платформами ASCII и EBCDIC и не имеет очевидного значения для обычного читателя.</target>
        </trans-unit>
        <trans-unit id="5eda0deef3d3835356e2633ac9dde47a16b13b5d" translate="yes" xml:space="preserve">
          <source>Stricter rules help to find typos and other errors. You included a range, and at least one of the end points is a decimal digit. Under the stricter rules, when this happens, both end points should be digits in the same group of 10 consecutive digits.</source>
          <target state="translated">Более строгие правила помогают находить опечатки и другие ошибки.Вы включили диапазон,и хотя бы одна из конечных точек является десятичной цифрой.По более строгим правилам,когда это происходит,обе конечные точки должны быть цифрами в одной группе из 10 последовательных цифр.</target>
        </trans-unit>
        <trans-unit id="0650e0c020aef4abbfbd4bda604f404ed598e991" translate="yes" xml:space="preserve">
          <source>Strictly speaking, a program that munches up another program and spits out yet another file containing the program in a &amp;ldquo;more executable&amp;rdquo; form, typically containing native machine instructions. The</source>
          <target state="translated">Строго говоря, программа, которая поглощает другую программу и выдает еще один файл, содержащий программу в &amp;laquo;более исполняемой&amp;raquo; форме, обычно содержащий машинные инструкции. В</target>
        </trans-unit>
        <trans-unit id="19287d999efabb7aed57bbe8e78bb9475aab4690" translate="yes" xml:space="preserve">
          <source>Strictly speaking, a program that reads a second program and does what the second program says directly without turning the program into a different form first, which is what &lt;b&gt;compilers&lt;/b&gt; do. Perl is not an interpreter by this definition, because it contains a kind of compiler that takes a program and turns it into a more executable form (&lt;b&gt;syntax trees&lt;/b&gt;) within the</source>
          <target state="translated">Строго говоря, программа, которая читает вторую программу и делает то, что вторая программа говорит напрямую, без преобразования сначала программы в другую форму, что и делают &lt;b&gt;компиляторы&lt;/b&gt; . Согласно этому определению Perl не является интерпретатором, потому что он содержит своего рода компилятор, который принимает программу и превращает ее в более исполняемую форму ( &lt;b&gt;синтаксические деревья&lt;/b&gt; ) в пределах</target>
        </trans-unit>
        <trans-unit id="a6fde2b9f7e959d871c8af08462a6492339f7057" translate="yes" xml:space="preserve">
          <source>Strictly speaking, nothing. Stylistically speaking, it's not a good way to write maintainable code. Perl has several operators for running external commands. Backticks are one; they collect the output from the command for use in your program. The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; function is another; it doesn't do this.</source>
          <target state="translated">Собственно говоря, ничего. С точки зрения стилистики, это плохой способ писать поддерживаемый код. В Perl есть несколько операторов для запуска внешних команд. Обратные кавычки - одно; они собирают вывод команды для использования в вашей программе. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; функция другой; он этого не делает.</target>
        </trans-unit>
        <trans-unit id="95ea50d3a212d751dc75823785ce8d3fc481176b" translate="yes" xml:space="preserve">
          <source>Strictly speaking, the year should be specified in a form consistent with &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, i.e. the offset from 1900. In order to make the interpretation of the year easier for humans, however, who are more accustomed to seeing years as two-digit or four-digit values, the following conventions are followed:</source>
          <target state="translated">Строго говоря, год следует указывать в форме, соответствующей &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; , т. Е. Смещению от 1900 года. Однако, чтобы облегчить интерпретацию года для людей, которые более привыкли рассматривать годы как двузначные или четырехзначные значения, соблюдаются следующие соглашения:</target>
        </trans-unit>
        <trans-unit id="5c4b8f90e8599772141d5d74184d3678eb652f81" translate="yes" xml:space="preserve">
          <source>Strictly, the shell&amp;rsquo;s &lt;code&gt;*&lt;/code&gt; character, which will match a &amp;ldquo;glob&amp;rdquo; of characters when you&amp;rsquo;re trying to generate a list of filenames. Loosely, the act of using globs and similar symbols to do pattern matching. See also &lt;b&gt;fileglob&lt;/b&gt; and &lt;b&gt;typeglob&lt;/b&gt;.</source>
          <target state="translated">Строго говоря, символ оболочки &lt;code&gt;*&lt;/code&gt; , который будет соответствовать &amp;laquo;группе&amp;raquo; символов, когда вы пытаетесь сгенерировать список имён файлов. Грубо говоря, использование глобусов и подобных символов для сопоставления с образцом. См. Также &lt;b&gt;fileglob&lt;/b&gt; и &lt;b&gt;typeglob&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="158127f06e6da3362607fa7cbbba756efc7019b1" translate="yes" xml:space="preserve">
          <source>Strictness and warnings</source>
          <target state="translated">Строгость и предупреждения</target>
        </trans-unit>
        <trans-unit id="516c0f4e3c92a494342e3cb25a961d2360643bc2" translate="yes" xml:space="preserve">
          <source>String &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;LC_NUMERIC&lt;/code&gt;</source>
          <target state="translated">String &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;LC_NUMERIC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="322644ec18f089375fd934ccac0ee29b7bf9401a" translate="yes" xml:space="preserve">
          <source>String Collation</source>
          <target state="translated">Строковая связь</target>
        </trans-unit>
        <trans-unit id="40837ec372cc75f0a51393ed930c1fe017719b97" translate="yes" xml:space="preserve">
          <source>String Equivalence</source>
          <target state="translated">Эквивалентность струн</target>
        </trans-unit>
        <trans-unit id="c0852fa4a49f9a7f054796351af22423733e0ae5" translate="yes" xml:space="preserve">
          <source>String Lengths</source>
          <target state="translated">Длины струн</target>
        </trans-unit>
        <trans-unit id="b231adac90ed5af6e5723df56d210bfd345958ac" translate="yes" xml:space="preserve">
          <source>String Processing, Language Text Processing, Parsing, and Searching</source>
          <target state="translated">Обработка строки,обработка текста языка,парсинг и поиск</target>
        </trans-unit>
        <trans-unit id="f618ca662dfcc3b16eb26b3a99e8a37d3fd5c229" translate="yes" xml:space="preserve">
          <source>String constants that would normally evaluate to 0 or 1 are warned about.</source>
          <target state="translated">Строковые константы,которые обычно оцениваются до 0 или 1,предупреждаются.</target>
        </trans-unit>
        <trans-unit id="6104084e70872a799af75c0c3b3e9c680e29b421" translate="yes" xml:space="preserve">
          <source>String conversion</source>
          <target state="translated">Преобразование струны</target>
        </trans-unit>
        <trans-unit id="597fe8909ca1928228ff982d52d105d13e058f8b" translate="yes" xml:space="preserve">
          <source>String eval and LC_NUMERIC</source>
          <target state="translated">Строковая оценка и LC_NUMERIC</target>
        </trans-unit>
        <trans-unit id="860dceea01893fc71bff8d83982d93e598606a4e" translate="yes" xml:space="preserve">
          <source>String handling functions, for the most part, continue to operate in terms of characters. &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, for example, returns the number of characters in a string, just as before. But that number no longer is necessarily the same as the number of bytes in the string (there may be more bytes than characters). The other such functions include &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rindex&quot;&gt;rindex()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функции обработки строк по большей части продолжают работать с символами. &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; , например, как и раньше, возвращает количество символов в строке. Но это число больше не обязательно совпадает с количеством байтов в строке (байтов может быть больше, чем символов). Другие такие функции включают &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/rindex&quot;&gt;rindex()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c329814ec2d3d4971e2511c74b3273f40003742e" translate="yes" xml:space="preserve">
          <source>String interpolation with case-mapping, as in, say, &lt;code&gt;$dest =
&quot;C:\U$name.$ext&quot;&lt;/code&gt; , may produce dangerous results if a bogus &lt;code&gt;LC_CTYPE&lt;/code&gt; case-mapping table is in effect.</source>
          <target state="translated">Строковая интерполяция с преобразованием регистра, например, &lt;code&gt;$dest = &quot;C:\U$name.$ext&quot;&lt;/code&gt; , может привести к опасным результатам, если действует фиктивная таблица преобразования регистра &lt;code&gt;LC_CTYPE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6780b9a46b265648d17e144b69c48ee74770992" translate="yes" xml:space="preserve">
          <source>String literals are usually delimited by either single or double quotes. They work much like quotes in the standard Unix shells: double-quoted string literals are subject to backslash and variable substitution; single-quoted strings are not (except for &lt;code&gt;\'&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt; ). The usual C-style backslash rules apply for making characters such as newline, tab, etc., as well as some more exotic forms. See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt; for a list.</source>
          <target state="translated">Строковые литералы обычно разделяются одинарными или двойными кавычками. Они работают так же, как кавычки в стандартных оболочках Unix: строковые литералы в двойных кавычках подвергаются обратной косой черте и замене переменных; Строки в одинарных кавычках - нет (кроме &lt;code&gt;\'&lt;/code&gt; и &lt;code&gt;\\&lt;/code&gt; ). Обычные правила обратной косой черты в стиле C применяются для создания символов, таких как новая строка, табуляция и т. Д., А также некоторых более экзотических форм. См &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote и Quote подобных операторов в perlop&lt;/a&gt; для списка.</target>
        </trans-unit>
        <trans-unit id="b011a78c96a9c16cf6436848fa3f565de97986a2" translate="yes" xml:space="preserve">
          <source>String of options to pass to xsubpp. This might include &lt;code&gt;-C++&lt;/code&gt; or &lt;code&gt;-extern&lt;/code&gt; . Do not include typemaps here; the TYPEMAP parameter exists for that purpose.</source>
          <target state="translated">Строка параметров для передачи в xsubpp. Это может включать &lt;code&gt;-C++&lt;/code&gt; или &lt;code&gt;-extern&lt;/code&gt; . Не включайте сюда карты типов; для этой цели существует параметр TYPEMAP.</target>
        </trans-unit>
        <trans-unit id="3fec62342425ec8f81ce629d9250491168e3f930" translate="yes" xml:space="preserve">
          <source>String overloaded objects are compared &lt;b&gt;as strings&lt;/b&gt; (or in &lt;code&gt;cmp_ok()&lt;/code&gt; 's case, strings or numbers as appropriate to the comparison op). This prevents Test::More from piercing an object's interface allowing better blackbox testing. So if a function starts returning overloaded objects instead of bare strings your tests won't notice the difference. This is good.</source>
          <target state="translated">Перегруженные строковые объекты сравниваются &lt;b&gt;как строки&lt;/b&gt; (или, в случае &lt;code&gt;cmp_ok()&lt;/code&gt; , строки или числа, в зависимости от операции сравнения). Это предотвращает проникновение Test :: More в интерфейс объекта, что позволяет улучшить тестирование черного ящика. Поэтому, если функция начинает возвращать перегруженные объекты вместо простых строк, ваши тесты не заметят разницы. Это хорошо.</target>
        </trans-unit>
        <trans-unit id="0f00ebea06538bbe227ded196b24216fa175546f" translate="yes" xml:space="preserve">
          <source>String that will be included in the compiler call command line between the arguments INC and OPTIMIZE.</source>
          <target state="translated">Строка,которая будет включена в командную строку вызова компилятора между аргументами INC и OPTIMIZE.</target>
        </trans-unit>
        <trans-unit id="6e526f1a740ace9291b3849106bb71fe9922d6d7" translate="yes" xml:space="preserve">
          <source>String to (long) integer translation. Returns the parsed number and the number of characters in the unparsed portion of the string. Truly POSIX-compliant systems set &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt; ) to indicate a translation error, so clear &lt;code&gt;$!&lt;/code&gt; before calling &lt;code&gt;strtol&lt;/code&gt; . However, non-POSIX systems may not check for overflow, and therefore will never set &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">Преобразование строки в (длинное) целое число. Возвращает проанализированное число и количество символов в не проанализированной части строки. Действительно POSIX-совместимые системы устанавливают &lt;code&gt;$!&lt;/code&gt; ( &lt;code&gt;$ERRNO&lt;/code&gt; ), чтобы указать на ошибку перевода, поэтому очистите &lt;code&gt;$!&lt;/code&gt; перед вызовом &lt;code&gt;strtol&lt;/code&gt; . Однако системы, не относящиеся к POSIX, могут не проверять переполнение и поэтому никогда не будут устанавливать &lt;code&gt;$!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8ad43047bd965bdc4d07f5ce2456ad0a02b96c7" translate="yes" xml:space="preserve">
          <source>String to double translation. Returns the parsed number and the number of characters in the unparsed portion of the string. Truly POSIX-compliant systems set &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt; ) to indicate a translation error, so clear &lt;code&gt;$!&lt;/code&gt; before calling &lt;code&gt;strtod&lt;/code&gt; . However, non-POSIX systems may not check for overflow, and therefore will never set &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">Строка для двойного перевода. Возвращает проанализированное число и количество символов в не проанализированной части строки. Действительно POSIX-совместимые системы устанавливают &lt;code&gt;$!&lt;/code&gt; ( &lt;code&gt;$ERRNO&lt;/code&gt; ), чтобы указать на ошибку перевода, поэтому очистите &lt;code&gt;$!&lt;/code&gt; перед вызовом &lt;code&gt;strtod&lt;/code&gt; . Однако системы, не относящиеся к POSIX, могут не проверять переполнение и поэтому никогда не будут устанавливать &lt;code&gt;$!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2abcfc7dcb04cc4aa0bcda4543317ca564702847" translate="yes" xml:space="preserve">
          <source>String to unsigned (long) integer translation. &lt;code&gt;strtoul()&lt;/code&gt; is identical to &lt;code&gt;strtol()&lt;/code&gt; except that &lt;code&gt;strtoul()&lt;/code&gt; only parses unsigned integers. See &lt;a href=&quot;#strtol&quot;&gt;strtol&lt;/a&gt; for details.</source>
          <target state="translated">Преобразование строки в беззнаковое (длинное) целое число. &lt;code&gt;strtoul()&lt;/code&gt; идентичен &lt;code&gt;strtol()&lt;/code&gt; за исключением того, что &lt;code&gt;strtoul()&lt;/code&gt; анализирует только целые числа без знака. Подробнее см. &lt;a href=&quot;#strtol&quot;&gt;Strtol&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ad6f48bf54709b2ba69a1fce32b7638601bfac7" translate="yes" xml:space="preserve">
          <source>String transformation. Returns the transformed string.</source>
          <target state="translated">Трансформация струн.Возвращает преобразованную строку.</target>
        </trans-unit>
        <trans-unit id="095d3b7d7b51ca9267c55a71d96ee740ce9ed714" translate="yes" xml:space="preserve">
          <source>String-To-Number Conversions</source>
          <target state="translated">Преобразование строк в числа</target>
        </trans-unit>
        <trans-unit id="89f0c9a299c3800ad98959c29c190d1bc9de23ac" translate="yes" xml:space="preserve">
          <source>String. An arbitrary sequence of characters. It is valid for the argument to start with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">Строка. Произвольная последовательность символов. Аргумент может начинаться с &lt;code&gt;-&lt;/code&gt; или &lt;code&gt;--&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fafc0f2cb3777e3c850edce9bbb0624fb76d8e93" translate="yes" xml:space="preserve">
          <source>Stringification also destroys arrays.</source>
          <target state="translated">Стрингование также уничтожает массивы.</target>
        </trans-unit>
        <trans-unit id="a96e53fa801a030d61d0b0afb131453e4a3a7511" translate="yes" xml:space="preserve">
          <source>Stringified perl data structures, suitable for both printing and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Строковые структуры данных Perl, подходящие как для печати, так и для &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bad8926562843b707945e86b277e1f637dc69d2" translate="yes" xml:space="preserve">
          <source>Stringify dumps the data inside the object.</source>
          <target state="translated">Строка сбрасывает данные внутри объекта.</target>
        </trans-unit>
        <trans-unit id="c5cca40b8e6ab951533c16fbbdd8e8eeb9f0e6f8" translate="yes" xml:space="preserve">
          <source>Strings created with &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; can also be manipulated with the logical operators &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt; . These operators will assume a bit vector operation is desired when both operands are strings. See &lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;Bitwise String Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Строками, созданными с помощью &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; , также можно управлять с помощью логических операторов &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; и &lt;code&gt;~&lt;/code&gt; . Эти операторы предполагают, что операция с битовым вектором желательна, когда оба операнда являются строками. См. Раздел &lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;Побитовые строковые операторы в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc0a2fc8d4082ea8e735316dde8d1811abffaf90" translate="yes" xml:space="preserve">
          <source>Strings created with &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; can also be manipulated with the logical operators &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt; . These operators will assume a bit vector operation is desired when both operands are strings. See &lt;a href=&quot;../perlop#Bitwise-String-Operators&quot;&gt;Bitwise String Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Строками, созданными с помощью &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; , также можно управлять с помощью логических операторов &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; и &lt;code&gt;~&lt;/code&gt; . Эти операторы предполагают, что операция с битовым вектором желательна, когда оба операнда являются строками. См. Раздел &lt;a href=&quot;../perlop#Bitwise-String-Operators&quot;&gt;Побитовые строковые операторы в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f7e8a6f87a8a42268a64c6a11af8887059d5680" translate="yes" xml:space="preserve">
          <source>Strings of multiple sub- and superscripts are not recognized as numbers. You can use either of the compatibility decompositions in Unicode::Normalize to change these into digits, and then call &lt;code&gt;num&lt;/code&gt; on the result.</source>
          <target state="translated">Строки, состоящие из нескольких нижних и верхних индексов, не распознаются как числа. Вы можете использовать любую из декомпозиций совместимости в Unicode :: Normalize, чтобы преобразовать их в цифры, а затем вызвать &lt;code&gt;num&lt;/code&gt; для результата.</target>
        </trans-unit>
        <trans-unit id="7aaa3eb6eac6d4efb6574a9ba9018939acd1f8cf" translate="yes" xml:space="preserve">
          <source>Strings--including hash keys--and regular expression patterns may contain characters that have ordinal values larger than 255.</source>
          <target state="translated">Строки-включая хэш-клавиши-и шаблоны регулярных выражений могут содержать символы с порядковыми значениями,превышающими 255.</target>
        </trans-unit>
        <trans-unit id="d6348b5c86af8ba2c83c3a187e28bfcf9f1d038b" translate="yes" xml:space="preserve">
          <source>Stripping Perl Binaries on Cygwin</source>
          <target state="translated">Стриптиз Perl Binaries на Cygwin</target>
        </trans-unit>
        <trans-unit id="f9141f854e0e233503d419a0cf18d9153715c039" translate="yes" xml:space="preserve">
          <source>Strongly object-oriented and fully-featured with a long development history and a large community and addon ecosystem. It is excellent for large and complex applications, where you have full control over the server.</source>
          <target state="translated">Сильно объектно-ориентированная и полнофункциональная,с длительной историей развития и большой экосистемой сообществ и аддонов.Отлично подходит для больших и сложных приложений,где у вас есть полный контроль над сервером.</target>
        </trans-unit>
        <trans-unit id="f23a884e110f1886cdc16e896ca93598233740f9" translate="yes" xml:space="preserve">
          <source>Structs are required to be aligned to the maximum alignment required by the fields - which for native types is for usually equivalent to sizeof() of the field</source>
          <target state="translated">Структуры должны быть выровнены до максимального выравнивания,требуемого полями-для нативных типов это обычно эквивалентно sizeof()поля</target>
        </trans-unit>
        <trans-unit id="eb761c94903285d6515bd20e9cd52538249ae83b" translate="yes" xml:space="preserve">
          <source>Structure of a Regexp Program</source>
          <target state="translated">Структура регэкспресс-программы</target>
        </trans-unit>
        <trans-unit id="cd40698b4bb94e939846994c9f9741e198f30bc1" translate="yes" xml:space="preserve">
          <source>Structured data retrieval of perl -V output</source>
          <target state="translated">Структурированное извлечение данных на выходе perl -V</target>
        </trans-unit>
        <trans-unit id="b8ce54f7f99cf2cca6626a2de77f397b8065d514" translate="yes" xml:space="preserve">
          <source>Stub that provides thread hook for perl_destruct when there are no threads.</source>
          <target state="translated">Петля,которая обеспечивает резьбовое соединение для perl_detruct при отсутствии резьбы.</target>
        </trans-unit>
        <trans-unit id="d8d7cb9c0bd0e5d2e8d74ffc3881bd4b4fc1400b" translate="yes" xml:space="preserve">
          <source>Stubs for Deleted Documents</source>
          <target state="translated">Клейма для удаленных документов</target>
        </trans-unit>
        <trans-unit id="4d7dabe926bb346f9396e40dca4282529b230cab" translate="yes" xml:space="preserve">
          <source>Stuff here is really low-priority to optimize, since it is far better to implement the operation in the low-level math library directly, possible even using a call to the native lib.</source>
          <target state="translated">Приоритет оптимизации здесь действительно низок,так как гораздо лучше реализовать операцию в низкоуровневой математической библиотеке напрямую,что возможно даже при использовании вызова родной библиотеки.</target>
        </trans-unit>
        <trans-unit id="2869e1f287c823d9d113fb739c0f867918c01e7c" translate="yes" xml:space="preserve">
          <source>Stuffit Expander</source>
          <target state="translated">Экспандер вещей</target>
        </trans-unit>
        <trans-unit id="99a0efc6cfd85d8ff2732a6718140f822cb90472" translate="yes" xml:space="preserve">
          <source>Style</source>
          <target state="translated">Style</target>
        </trans-unit>
        <trans-unit id="6f4fae33d407351a21e057015a8cfce97b1d1d2a" translate="yes" xml:space="preserve">
          <source>Subclass</source>
          <target state="translated">Subclass</target>
        </trans-unit>
        <trans-unit id="873c1d3b114c3c8ca9fa8263d71c270acec87256" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;parser/grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt; and customize your parser by setting the &lt;code&gt;grammar_class&lt;/code&gt; parameter. See &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; for more details.</source>
          <target state="translated">Подкласс &lt;a href=&quot;parser/grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt; и настройте свой парсер, установив параметр &lt;code&gt;grammar_class&lt;/code&gt; . Смотрите &lt;a href=&quot;#new&quot;&gt;новые&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="a88a43bb409ce5ce1ef29fd247b1a667d1a95af9" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; and register your new result type/class with the default &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt;.</source>
          <target state="translated">Подкласс &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; и зарегистрируйте новый тип / класс результата с помощью &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP :: Parser :: ResultFactory по умолчанию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9c1095f48c3aca9e5b044be2e9f7d4aebd28ac4" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt; itself and implement your own &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; creation logic. Then you'll need to customize the class used by your parser by setting the &lt;code&gt;result_factory_class&lt;/code&gt; parameter. See &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; for more details.</source>
          <target state="translated">Подкласс &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP :: Parser :: ResultFactory&lt;/a&gt; и реализует собственную логику создания &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; . Затем вам нужно будет настроить класс, используемый вашим парсером, установив параметр &lt;code&gt;result_factory_class&lt;/code&gt; . Смотрите &lt;a href=&quot;#new&quot;&gt;новые&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="e73f017d1b2756188610b88957a8f09f27806cab" translate="yes" xml:space="preserve">
          <source>Subclass implementations of this method may wish to invoke the &lt;b&gt;nested()&lt;/b&gt; method of &lt;code&gt;$pod_seq&lt;/code&gt; to see if it is nested inside some other interior-sequence (and if so, which kind).</source>
          <target state="translated">Подкласс реализация этого метода , возможно , пожелает вызвать &lt;b&gt;вложенный ()&lt;/b&gt; метод от &lt;code&gt;$pod_seq&lt;/code&gt; , чтобы увидеть , если он вложен в какой - либо другой внутренней последовательности (и если да, то какой вид).</target>
        </trans-unit>
        <trans-unit id="206092a8f1bccf21dc1a96fb2aecc7852ff2c2b3" translate="yes" xml:space="preserve">
          <source>Subclass off of ExtUtils::MM_Any</source>
          <target state="translated">Подкласс вне ExtUtils::MM_Any</target>
        </trans-unit>
        <trans-unit id="c726c3176746b961b1da7788108e104c74c302c2" translate="yes" xml:space="preserve">
          <source>Subclasses will add methods, and will also inherit these methods:</source>
          <target state="translated">Подклассы будут добавлять методы,а также наследуют эти методы:</target>
        </trans-unit>
        <trans-unit id="f3e2eeeafa90ba07510736c79555f75b3f2683f2" translate="yes" xml:space="preserve">
          <source>Subclassing Math::BigInt</source>
          <target state="translated">Математика подкласса:::Большой.</target>
        </trans-unit>
        <trans-unit id="7a1cf3add6a7e4a2dd149344bc26ee4f53a43b6c" translate="yes" xml:space="preserve">
          <source>Subject to include with the message. You will be prompted if you don't supply one on the command line.</source>
          <target state="translated">Тема для включения в сообщение.Вам будет предложено,если вы не предоставите его в командной строке.</target>
        </trans-unit>
        <trans-unit id="2dacf65959849884a011f36f76a04eebea94c5ea" translate="yes" xml:space="preserve">
          <source>Submit</source>
          <target state="translated">Submit</target>
        </trans-unit>
        <trans-unit id="403bc0e6094ca81cdc2ca6f64a247c639431d231" translate="yes" xml:space="preserve">
          <source>Submit all messages/phrases/etc. to translators.</source>
          <target state="translated">Отправляйте все сообщения/фразы/и т.д.переводчикам.</target>
        </trans-unit>
        <trans-unit id="740057b8189ca179a92f1c0babad5e8319eb10b8" translate="yes" xml:space="preserve">
          <source>Submitting patches</source>
          <target state="translated">Представление патчей</target>
        </trans-unit>
        <trans-unit id="76ef2c6312acb93997fc9533ac9d5fab3c547483" translate="yes" xml:space="preserve">
          <source>Subroutine Attributes</source>
          <target state="translated">Атрибуты подпрограммы</target>
        </trans-unit>
        <trans-unit id="e505b9988266048dcf61fcc7b04326e41ac00577" translate="yes" xml:space="preserve">
          <source>Subroutine References as Methods</source>
          <target state="translated">Подпрограмма Ссылки как методы</target>
        </trans-unit>
        <trans-unit id="e0c81de6298b00147539fb1fd776b06104ff3a1b" translate="yes" xml:space="preserve">
          <source>Subroutine Stubs</source>
          <target state="translated">Шлейфы подпрограммы</target>
        </trans-unit>
        <trans-unit id="ba2c6bab1119398dcc6fbf96d66f3ef433c36e56" translate="yes" xml:space="preserve">
          <source>Subroutine call to a named capture group. Equivalent to &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt;.</source>
          <target state="translated">Вызов подпрограммы к названной группе захвата. Эквивалентен &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2db8d18b231e5da42e906ca30c0b2a5d6ae6ff13" translate="yes" xml:space="preserve">
          <source>Subroutine calls and lookups of individual array elements arise often enough that it gets cumbersome to use method 2. As a form of syntactic sugar, the examples for method 2 may be written:</source>
          <target state="translated">Вызовы подпрограмм и поиск отдельных элементов массива происходят достаточно часто,что затрудняет использование метода 2.В качестве формы синтаксического сахара можно записать примеры для метода 2:</target>
        </trans-unit>
        <trans-unit id="2a4b563566baea0b906bb1fd2aafe77f5b8f15d9" translate="yes" xml:space="preserve">
          <source>Subroutine declarations and definitions may optionally have attribute lists associated with them. (Variable &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declarations also may, but see the warning below.) Perl handles these declarations by passing some information about the call site and the thing being declared along with the attribute list to this module. In particular, the first example above is equivalent to the following:</source>
          <target state="translated">Объявления и определения подпрограмм могут дополнительно иметь связанные с ними списки атрибутов. (Переменные &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; объявления тоже могут, но см. Предупреждение ниже.) Perl обрабатывает эти объявления, передавая некоторую информацию о сайте вызова и объявляемом объекте вместе со списком атрибутов в этот модуль. В частности, первый приведенный выше пример эквивалентен следующему:</target>
        </trans-unit>
        <trans-unit id="1033729ecd127028ccf3e2aa66d4fd8f486f7da3" translate="yes" xml:space="preserve">
          <source>Subroutine defined.</source>
          <target state="translated">Подпрограмма определена.</target>
        </trans-unit>
        <trans-unit id="d9339f9cd00dee3efa9f7f46ee1ed9f5d6e327f1" translate="yes" xml:space="preserve">
          <source>Subroutine definitions (and declarations, for that matter) need not necessarily be situated in the package whose symbol table they occupy. You can define a subroutine outside its package by explicitly qualifying the name of the subroutine:</source>
          <target state="translated">Подпрограммные определения (и,соответственно,декларации)не обязательно должны располагаться в пакете,таблицу символов которого они занимают.Вы можете определить подпрограмму вне пакета,явно уточнив имя подпрограммы:</target>
        </trans-unit>
        <trans-unit id="e9df428b17a930b0722f07795c93f287fd3afdec" translate="yes" xml:space="preserve">
          <source>Subroutine or method call.</source>
          <target state="translated">Подпрограмма или вызов метода.</target>
        </trans-unit>
        <trans-unit id="e848b12ba1771594d7f90740383f312abe841d15" translate="yes" xml:space="preserve">
          <source>Subroutine references are the simplest case. When the inclusion system walks through @INC and encounters a subroutine, this subroutine gets called with two parameters, the first a reference to itself, and the second the name of the file to be included (e.g., &quot;</source>
          <target state="translated">Ссылки на подпрограммы-самый простой случай.Когда система включения проходит через @INC и сталкивается с подпрограммой,эта подпрограмма вызывается с двумя параметрами,первый-ссылка на себя,а второй-имя файла,который должен быть включен (например,&quot;</target>
        </trans-unit>
        <trans-unit id="b392dcb7d8c01390614814ebacd1c58485fdcd21" translate="yes" xml:space="preserve">
          <source>Subroutines</source>
          <target state="translated">Subroutines</target>
        </trans-unit>
        <trans-unit id="3a9c9397dc48823cce2af70d8aec97a4fb827cbd" translate="yes" xml:space="preserve">
          <source>Subroutines can also return values:</source>
          <target state="translated">Подпрограммы также могут возвращать значения:</target>
        </trans-unit>
        <trans-unit id="7cbe2412d3dda1f0b9872899595b0870846f911a" translate="yes" xml:space="preserve">
          <source>Subroutines declarations can also be loaded up with the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement or both loaded and imported into your namespace with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details on this.</source>
          <target state="translated">Объявления подпрограмм также могут быть загружены с помощью оператора &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; или загружены и импортированы в ваше пространство имен с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; оператора use . См. Подробности в &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01b365b15ba275665842a040de4aa6dff221b841" translate="yes" xml:space="preserve">
          <source>Subroutines in multiple packages within the same file are supported - but you should note that this requires exporting the &lt;code&gt;SelfLoader::AUTOLOAD&lt;/code&gt; to every package which requires it. This is done automatically by the &lt;b&gt;SelfLoader&lt;/b&gt; when it first loads the subs into the cache, but you should really specify it in the initialization before the &lt;code&gt;__DATA__&lt;/code&gt; by putting a 'use SelfLoader' statement in each package.</source>
          <target state="translated">Подпрограммы в нескольких пакетах в одном файле поддерживаются, но вы должны заметить, что для этого требуется экспортировать &lt;code&gt;SelfLoader::AUTOLOAD&lt;/code&gt; в каждый пакет, который этого требует. Это выполняется автоматически &lt;b&gt;SelfLoader,&lt;/b&gt; когда он впервые загружает подпрограммы в кеш, но вы действительно должны указать это при инициализации перед &lt;code&gt;__DATA__&lt;/code&gt; , поместив оператор 'use SelfLoader' в каждый пакет.</target>
        </trans-unit>
        <trans-unit id="908bce63fd3bee1510a99f3549ad888c8938e948" translate="yes" xml:space="preserve">
          <source>Subroutines may be called recursively. If a subroutine is called using the &lt;code&gt;&amp;amp;&lt;/code&gt; form, the argument list is optional, and if omitted, no &lt;code&gt;@_&lt;/code&gt; array is set up for the subroutine: the &lt;code&gt;@_&lt;/code&gt; array at the time of the call is visible to subroutine instead. This is an efficiency mechanism that new users may wish to avoid.</source>
          <target state="translated">Подпрограммы могут вызываться рекурсивно. Если функция вызывается с использованием &lt;code&gt;&amp;amp;&lt;/code&gt; формы, список аргументов не является обязательным, и если опущено, &lt;code&gt;@_&lt;/code&gt; массив настроен на подпрограмму: &lt;code&gt;@_&lt;/code&gt; массив в момент вызова видна подпрограмма вместо этого. Это эффективный механизм, которого новые пользователи, возможно, захотят избежать.</target>
        </trans-unit>
        <trans-unit id="cda2b08c81beb1e8e27be40c69e142c7b306247c" translate="yes" xml:space="preserve">
          <source>Subroutines used with ExtUtils::ParseXS</source>
          <target state="translated">Подпрограммы,используемые с ExtUtils::ParseXS</target>
        </trans-unit>
        <trans-unit id="3f753412893b86e74de31ef62203854e630f7671" translate="yes" xml:space="preserve">
          <source>Subroutines whose names are in all upper case are reserved to the Perl core, as are modules whose names are in all lower case. A subroutine in all capitals is a loosely-held convention meaning it will be called indirectly by the run-time system itself, usually due to a triggered event. Subroutines whose name start with a left parenthesis are also reserved the same way. The following is a list of some subroutines that currently do special, pre-defined things.</source>
          <target state="translated">Подпрограммы,имена которых во всех верхних регистрах зарезервированы для ядра Perl,так же как и модули,имена которых во всех нижних регистрах.Подпрограмма во всех заглавных буквах-это свободно удерживаемая конвенция,означающая,что она будет вызвана косвенно самой системой исполнения,обычно из-за сработавшего события.Подпрограммы,имена которых начинаются с левой скобки,также зарезервированы таким же образом.Ниже приведен список некоторых подпрограмм,которые в настоящее время делают специальные,заранее определенные вещи.</target>
        </trans-unit>
        <trans-unit id="bd995cb059355e488a61a605eadaa870990fb34e" translate="yes" xml:space="preserve">
          <source>Subscribe to perl5-porters, follow the patches and try and understand them; don't be afraid to ask if there's a portion you're not clear on - who knows, you may unearth a bug in the patch...</source>
          <target state="translated">Подпишитесь на perl5-порталы,следуйте патчам и постарайтесь их понять;не бойтесь спросить,есть ли часть,которую вы не поняли-кто знает,вы можете раскопать жучок в патче...</target>
        </trans-unit>
        <trans-unit id="a9be04fdf20dd61cb8df7236630151f2b739230f" translate="yes" xml:space="preserve">
          <source>Subscribers to perl5-porters (the porters themselves) come in several flavours. Some are quiet curious lurkers, who rarely pitch in and instead watch the ongoing development to ensure they're forewarned of new changes or features in Perl. Some are representatives of vendors, who are there to make sure that Perl continues to compile and work on their platforms. Some patch any reported bug that they know how to fix, some are actively patching their pet area (threads, Win32, the regexp -engine), while others seem to do nothing but complain. In other words, it's your usual mix of technical people.</source>
          <target state="translated">Абоненты perl5-портов (сами носильщики)приходят в нескольких вариантах.Некоторые из них-тихие любопытные шпионы,которые редко вмешиваются и вместо этого следят за текущим развитием,чтобы быть уверенными в том,что их предупреждают о новых изменениях или особенностях Perl.Некоторые являются представителями вендоров,которые находятся там,чтобы убедиться,что Perl продолжает компилироваться и работать на их платформах.Некоторые патчи сообщают об ошибках,которые они умеют исправлять,некоторые активно патчуют свою домашнюю область (потоки,Win32,регэкспо-двигатель),в то время как другие,кажется,ничего не делают,кроме как жалуются.Другими словами,это ваш обычный микс технических специалистов.</target>
        </trans-unit>
        <trans-unit id="4ce7140689363704a8ba85b5261797d063cdadf8" translate="yes" xml:space="preserve">
          <source>Subscripts</source>
          <target state="translated">Subscripts</target>
        </trans-unit>
        <trans-unit id="972581919796c696d3887a640cd0abc4a9d6fe2f" translate="yes" xml:space="preserve">
          <source>Substitute &lt;code&gt;mmk&lt;/code&gt; for &lt;code&gt;mms&lt;/code&gt; above if you're using MMK.</source>
          <target state="translated">Замените &lt;code&gt;mmk&lt;/code&gt; на &lt;code&gt;mms&lt;/code&gt; выше, если вы используете MMK.</target>
        </trans-unit>
        <trans-unit id="014d5a9e6f1c5bae7a50cda20695fb756eee0cc0" translate="yes" xml:space="preserve">
          <source>Substitution of &lt;code&gt;BEGIN { add_100() }&lt;/code&gt; block with:</source>
          <target state="translated">Замена блока &lt;code&gt;BEGIN { add_100() }&lt;/code&gt; на:</target>
        </trans-unit>
        <trans-unit id="821f56dfe7408535081734d464b6578d0a9340e7" translate="yes" xml:space="preserve">
          <source>Substitution-specific modifiers described in</source>
          <target state="translated">Замещающие специфические модификаторы,описанные в</target>
        </trans-unit>
        <trans-unit id="a85608dfc0000ff615c1dec302e3be9c2df7837d" translate="yes" xml:space="preserve">
          <source>Substitutions are made with $col and $row in the output string with the following sprintf() line formats:</source>
          <target state="translated">Замена производится с помощью $col и $row в строке вывода со следующими форматами строк sprintf():</target>
        </trans-unit>
        <trans-unit id="e9a34939ee76bec97fd549a9a6b322c326e9dbba" translate="yes" xml:space="preserve">
          <source>Substring data about strings that must appear in the final match. This is currently only used internally by Perl's engine, but might be used in the future for all engines for optimisations.</source>
          <target state="translated">Подстрока данных о строках,которые должны появиться в финальном матче.В настоящее время они используются только внутри Perl-движка,но в будущем могут быть использованы для всех движков для оптимизации.</target>
        </trans-unit>
        <trans-unit id="3de3a6f2fafae521ea8d2aedc747771ba7ff68a0" translate="yes" xml:space="preserve">
          <source>Subtests were released in Test::More 0.94, which came with Perl 5.12.0. Subtests did not implicitly call &lt;code&gt;done_testing()&lt;/code&gt; until 0.96; the first Perl with that fix was Perl 5.14.0 with 0.98.</source>
          <target state="translated">Подтесты были выпущены в Test :: More 0.94, поставляемом с Perl 5.12.0. Подтесты не вызывали неявно &lt;code&gt;done_testing()&lt;/code&gt; до версии 0.96; первым Perl с этим исправлением был Perl 5.14.0 с 0.98.</target>
        </trans-unit>
        <trans-unit id="8a773e71238655167a41521fa50857f3f27293a6" translate="yes" xml:space="preserve">
          <source>Subtleties of this behavior may be platform-dependent and may change in the future.</source>
          <target state="translated">Тонкости такого поведения могут быть платформенно-зависимыми и могут измениться в будущем.</target>
        </trans-unit>
        <trans-unit id="ae5f61e523ef194692c08eae320b323a03f8bb9b" translate="yes" xml:space="preserve">
          <source>Subtract</source>
          <target state="translated">Subtract</target>
        </trans-unit>
        <trans-unit id="a1c757fe97bd3bdc11456c873d4a95f5772e2115" translate="yes" xml:space="preserve">
          <source>Success results contain:</source>
          <target state="translated">Результаты успеха содержат:</target>
        </trans-unit>
        <trans-unit id="f918892a0be28ec22ae2148c6c8b20e089383319" translate="yes" xml:space="preserve">
          <source>Successes</source>
          <target state="translated">Successes</target>
        </trans-unit>
        <trans-unit id="9f13946904481800a60a2508acdf81d63816cbc9" translate="yes" xml:space="preserve">
          <source>Successfully tested means that all &quot;make test&quot; runs finish with a result of 100% OK. All tests were conducted with -Duseshrplib set.</source>
          <target state="translated">Успешное тестирование означает,что все прогоны &quot;сделай тест&quot; заканчиваются с результатом 100% OK.Все тесты проводились с набором -Dushrplib.</target>
        </trans-unit>
        <trans-unit id="acd9d5af15f64c17e2970ba3b3a2889b142e6fb0" translate="yes" xml:space="preserve">
          <source>Such QP strings can be decoded with:</source>
          <target state="translated">Такие QP строки можно декодировать:</target>
        </trans-unit>
        <trans-unit id="9bd751ae4548def6edde9b711d0020609ff568b3" translate="yes" xml:space="preserve">
          <source>Such code no longer has the desired effect, for two reasons. Firstly, the use of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; means that the sorting algorithm is not changed until runtime, by which time it's too late to have any effect. Secondly, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; is also called at run-time, when in fact the compile-time value of &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; is the one that matters.</source>
          <target state="translated">Такой код больше не дает желаемого эффекта по двум причинам. Во-первых, использование &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; означает, что алгоритм сортировки не изменяется до времени выполнения, и к этому времени уже слишком поздно оказывать какое-либо влияние. Во-вторых, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; также вызывается во время выполнения, когда на самом деле значение &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; во время компиляции имеет значение.</target>
        </trans-unit>
        <trans-unit id="69ef159fceda5830f0aa82ac39ad009b226aeb52" translate="yes" xml:space="preserve">
          <source>Such combinations can include alternatives, leading to a problem of choice: if we match a regular expression &lt;code&gt;a|ab&lt;/code&gt; against &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , will it match substring &lt;code&gt;&quot;a&quot;&lt;/code&gt; or &lt;code&gt;&quot;ab&quot;&lt;/code&gt; ? One way to describe which substring is actually matched is the concept of backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;). However, this description is too low-level and makes you think in terms of a particular implementation.</source>
          <target state="translated">Такие комбинации могут включать альтернативы, что приводит к проблеме выбора: если мы сопоставим регулярное выражение &lt;code&gt;a|ab&lt;/code&gt; с &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , будет ли оно соответствовать подстроке &lt;code&gt;&quot;a&quot;&lt;/code&gt; или &lt;code&gt;&quot;ab&quot;&lt;/code&gt; ? Один из способов описать, какая подстрока действительно соответствует, - это концепция поиска с возвратом (см. &lt;a href=&quot;#Backtracking&quot;&gt;Отслеживание с возвратом&lt;/a&gt; ). Однако это описание слишком низкое и заставляет задуматься о конкретной реализации.</target>
        </trans-unit>
        <trans-unit id="54d1b0795c68a81e9549d343de87babe2d5446e2" translate="yes" xml:space="preserve">
          <source>Such commands are explained in the &quot;&lt;a href=&quot;#Formatting-Codes&quot;&gt;Formatting Codes&lt;/a&gt;&quot; section, below.</source>
          <target state="translated">Такие команды объясняются в разделе &amp;laquo; &lt;a href=&quot;#Formatting-Codes&quot;&gt;Коды форматирования&lt;/a&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="610620ff68fcfedc9e4625433127c1fd73d100c6" translate="yes" xml:space="preserve">
          <source>Such constructs are quite frequently used, both because older versions of Perl had no official &lt;code&gt;switch&lt;/code&gt; statement, and also because the new version described immediately below remains experimental and can sometimes be confusing.</source>
          <target state="translated">Такие конструкции используются довольно часто как потому, что в более старых версиях Perl не было официального оператора &lt;code&gt;switch&lt;/code&gt; , так и потому, что новая версия, описанная непосредственно ниже, остается экспериментальной и иногда может сбивать с толку.</target>
        </trans-unit>
        <trans-unit id="ea3348659ce40b97978cb89e7a2d2a3c12e7d561" translate="yes" xml:space="preserve">
          <source>Such dangers are not peculiar to the locale system: any aspect of an application's environment which may be modified maliciously presents similar challenges. Similarly, they are not specific to Perl: any programming language that allows you to write programs that take account of their environment exposes you to these issues.</source>
          <target state="translated">Такие опасности не свойственны локальной системе:любой аспект среды приложения,который может быть злонамеренно модифицирован,представляет схожие проблемы.Точно так же они не специфичны для Perl:любой язык программирования,позволяющий писать программы,учитывающие их окружение,подвергает вас этим проблемам.</target>
        </trans-unit>
        <trans-unit id="92e64e08c8f255e5e8a21829e9acd359d7cc7e25" translate="yes" xml:space="preserve">
          <source>Such literals are accepted by both &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; for doing a version check. Note that using the v-strings for IPv4 addresses is not portable unless you also use the inet_aton()/inet_ntoa() routines of the Socket package.</source>
          <target state="translated">Такие литералы принимаются как &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; для проверки версии. Обратите внимание, что использование v-строк для адресов IPv4 непереносимо, если вы также не используете подпрограммы inet_aton () / inet_ntoa () пакета Socket.</target>
        </trans-unit>
        <trans-unit id="c45d151cfb183e258e5e363109f24149b1db62ae" translate="yes" xml:space="preserve">
          <source>Such modules should</source>
          <target state="translated">Такие модули должны</target>
        </trans-unit>
        <trans-unit id="7aa5a2112d8e6f60d9221533518e8ad273984dab" translate="yes" xml:space="preserve">
          <source>Such things aside, you can see that a lot can be achieved with a modest amount of code.</source>
          <target state="translated">Если отбросить такие вещи в сторону,то можно заметить,что многого можно добиться с помощью скромного количества кода.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="625d4a750d30cd6f4ad0513fdf02b0a356847795" translate="yes" xml:space="preserve">
          <source>Summary Results</source>
          <target state="translated">Итоговые результаты</target>
        </trans-unit>
        <trans-unit id="64d8f92a0739a61061673d891b1afa8db3bbc87d" translate="yes" xml:space="preserve">
          <source>Summary methods</source>
          <target state="translated">Общие методы</target>
        </trans-unit>
        <trans-unit id="bbeaa09c87f3637cdf1095b67ab5a263e83c735c" translate="yes" xml:space="preserve">
          <source>Summary of Option Specifications</source>
          <target state="translated">Резюме спецификаций опций</target>
        </trans-unit>
        <trans-unit id="90bd8a629095e4d3e067b9ee655f4a7aef77fe44" translate="yes" xml:space="preserve">
          <source>Summary: &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; and installing the Developer Tools would be good.</source>
          <target state="translated">Резюме: &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; и установить Developer Tools было бы хорошо.</target>
        </trans-unit>
        <trans-unit id="fac6a1b8f230cdc10fcc15f1e97d9ef7d5b8d095" translate="yes" xml:space="preserve">
          <source>Summary: &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; and you need &lt;code&gt;-lbfd&lt;/code&gt; .</source>
          <target state="translated">Резюме: &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; и вам понадобится &lt;code&gt;-lbfd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d4dd97ceb3548f78756cbaa9fdb900f6de48597" translate="yes" xml:space="preserve">
          <source>Summing up, Perl numeric values can store only those numbers which have a finite decimal expansion or a &quot;short&quot; binary expansion.</source>
          <target state="translated">Суммируя,числовые значения на Perl могут хранить только те числа,которые имеют конечное десятичное или &quot;короткое&quot; двоичное разложение.</target>
        </trans-unit>
        <trans-unit id="6f2aaceda628f6be2c51aa728019480822a4776e" translate="yes" xml:space="preserve">
          <source>Sun Microsystems has released a port of their Sun Studio compilers for Linux. As of November 2005, only an alpha version has been released. Until a release of these compilers is made, support for compiling Perl with these compiler experimental.</source>
          <target state="translated">Sun Microsystems выпустила порт своих компиляторов Sun Studio для Linux.По состоянию на ноябрь 2005 года была выпущена только альфа-версия.Пока не будет выпущен релиз этих компиляторов,поддержка компиляции Perl с помощью этих компиляторов является экспериментальной.</target>
        </trans-unit>
        <trans-unit id="c878825d39958359a72cd8a76c4798d5c63452e1" translate="yes" xml:space="preserve">
          <source>Sun and GNU make</source>
          <target state="translated">Sun и GNU марка</target>
        </trans-unit>
        <trans-unit id="718d79465fef1629218681af768f2453685f48a1" translate="yes" xml:space="preserve">
          <source>Sun's C Compiler</source>
          <target state="translated">Солнечный компилятор С</target>
        </trans-unit>
        <trans-unit id="6195b0f6879010bbee2ff42c95d1331cc047feb8" translate="yes" xml:space="preserve">
          <source>SunOS 4.x</source>
          <target state="translated">SunOS 4.x</target>
        </trans-unit>
        <trans-unit id="e16d86479fe3fa44742384e85cda27574322cbc3" translate="yes" xml:space="preserve">
          <source>Supply a comparison function to sort() (described in &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;):</source>
          <target state="translated">Предоставьте функцию сравнения для sort () (описанную в &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="de415e5d5000869495451db35dc93df656397ea8" translate="yes" xml:space="preserve">
          <source>Supply a password. If this token is present, the auto-login process will supply the specified string if the remote server requires a password as part of the login process.</source>
          <target state="translated">Поставьте пароль.Если эта маркерная строка присутствует,то процесс автологина предоставит указанную строку,если удаленному серверу требуется пароль в рамках процесса входа в систему.</target>
        </trans-unit>
        <trans-unit id="2b5e575cc764d4329007cce80f84811dda7921d8" translate="yes" xml:space="preserve">
          <source>Supply an additional account password. If this token is present, the auto-login process will supply the specified string if the remote server requires an additional account password.</source>
          <target state="translated">Поставьте дополнительный пароль учетной записи.Если эта маркерная строка присутствует,то процесс автологина поставит указанную строку,если удаленному серверу требуется дополнительный пароль учетной записи.</target>
        </trans-unit>
        <trans-unit id="63bb1d0a1fc152b9571b2b05084b5b7573c0a7dc" translate="yes" xml:space="preserve">
          <source>Supply object methods for I/O handles</source>
          <target state="translated">Методы объекта поставки для ручек ввода/вывода</target>
        </trans-unit>
        <trans-unit id="e754d6f0995eab7526c2995e6dd29fc5213bbe9f" translate="yes" xml:space="preserve">
          <source>Supply object methods for directory handles</source>
          <target state="translated">Поставлять объектные методы для каталоговых дескрипторов</target>
        </trans-unit>
        <trans-unit id="9f22ffa5d56d4c5cfa232e27b220356c8959032d" translate="yes" xml:space="preserve">
          <source>Supply object methods for filehandles</source>
          <target state="translated">Объектные методы поставки для файловых ручек</target>
        </trans-unit>
        <trans-unit id="b2a77c0ef03836a7333e41ce4f0c7055106ac057" translate="yes" xml:space="preserve">
          <source>Supply object methods for pipes</source>
          <target state="translated">Объектные методы поставок для труб</target>
        </trans-unit>
        <trans-unit id="24f8675a681a3fcf0a19ce2f457ac46639a461cc" translate="yes" xml:space="preserve">
          <source>Supply seek based methods for I/O objects</source>
          <target state="translated">Методы поиска поставщиков для объектов ввода/вывода</target>
        </trans-unit>
        <trans-unit id="4577ee52f9d606e12ad2fa9f7ea83ec15081ff52" translate="yes" xml:space="preserve">
          <source>Supplying a count to the</source>
          <target state="translated">Полагая,что</target>
        </trans-unit>
        <trans-unit id="9256abeb61b0e9c2634b93f868b22e3b6be3e559" translate="yes" xml:space="preserve">
          <source>Support for 64-bit Windows added in 5.8 (ActiveState Corp).</source>
          <target state="translated">В 5.8 добавлена поддержка 64-битной Windows (ActiveState Corp).</target>
        </trans-unit>
        <trans-unit id="832ef41556695f42d002862c25aa7f6927ea5c9c" translate="yes" xml:space="preserve">
          <source>Support for 64-bit addressing is experimental: some aspects of Perl may be omitted or buggy. Note the messages output by</source>
          <target state="translated">Поддержка 64-битной адресации является экспериментальной:некоторые аспекты Perl могут быть опущены или содержать ошибки.Обратите внимание на сообщения,выводимые</target>
        </trans-unit>
        <trans-unit id="dfd649a90bcb497a90c270b395e1aca8e9f13d5a" translate="yes" xml:space="preserve">
          <source>Support for Inside-Out Classes</source>
          <target state="translated">Поддержка внутренних классов</target>
        </trans-unit>
        <trans-unit id="f74542dacfa191bd88d61863d9855931e106e4c3" translate="yes" xml:space="preserve">
          <source>Support for PERL_OBJECT was added in 5.005 (ActiveState Tool Corp).</source>
          <target state="translated">В 5.005 была добавлена поддержка PERL_OBJECT (ActiveState Tool Corp).</target>
        </trans-unit>
        <trans-unit id="4152d06f964d8c8500926a55fcc080decb5f3944" translate="yes" xml:space="preserve">
          <source>Support for code 3 (italic) is rare and therefore not mentioned in that table. It is not believed to be fully supported by any of the terminals listed, although it's displayed as green in the Linux console, but it is reportedly supported by urxvt.</source>
          <target state="translated">Поддержка кода 3 (курсив)встречается редко и поэтому не упоминается в этой таблице.Считается,что он не полностью поддерживается ни одним из перечисленных терминалов,хотя в консоли Linux он отображается зеленым цветом,но,как сообщается,поддерживается urxvt.</target>
        </trans-unit>
        <trans-unit id="d13a3104d38bfebd2d8edefc71bb43ed89c25719" translate="yes" xml:space="preserve">
          <source>Support for colors 16 through 256 (the &lt;code&gt;ansi&lt;/code&gt; , &lt;code&gt;rgb&lt;/code&gt; , and &lt;code&gt;grey&lt;/code&gt; colors), the &lt;code&gt;:constants256&lt;/code&gt; import tag, the coloralias() function, and support for the ANSI_COLORS_ALIASES environment variable were added in Term::ANSIColor 4.00, included in Perl 5.17.8.</source>
          <target state="translated">В Term :: ANSIColor 4.00, включенном в Perl 5.17, была добавлена поддержка цветов с 16 по 256 (цвета &lt;code&gt;ansi&lt;/code&gt; , &lt;code&gt;rgb&lt;/code&gt; и &lt;code&gt;grey&lt;/code&gt; ), тег импорта &lt;code&gt;:constants256&lt;/code&gt; , функция coloralias () и поддержка переменной среды ANSI_COLORS_ALIASES. 8.</target>
        </trans-unit>
        <trans-unit id="c9d79655477c957d3ded48d250eed51bd3ecf8ff" translate="yes" xml:space="preserve">
          <source>Support for colors 8 through 15 (the &lt;code&gt;bright_&lt;/code&gt; variants) was added in Term::ANSIColor 3.00, included in Perl 5.13.3.</source>
          <target state="translated">Поддержка цветов с 8 по 15 ( варианты &lt;code&gt;bright_&lt;/code&gt; ) была добавлена ​​в Term :: ANSIColor 3.00, включенном в Perl 5.13.3.</target>
        </trans-unit>
        <trans-unit id="3520e7db85802558bb1d2a5a7277d73d6dd7678b" translate="yes" xml:space="preserve">
          <source>Support for concurrent interpreters and the fork() emulation was implemented by ActiveState, with funding from Microsoft Corporation.</source>
          <target state="translated">Поддержка параллельных интерпретаторов и эмуляции fork()была реализована компанией ActiveState при финансовой поддержке корпорации Microsoft.</target>
        </trans-unit>
        <trans-unit id="46d9a08c8fe0a5fa65df6f50206b3d6f86276cea" translate="yes" xml:space="preserve">
          <source>Support for dark was added in Term::ANSIColor 1.08, included in Perl 5.8.4.</source>
          <target state="translated">В Term::ANSIColor 1.08 добавлена поддержка темного цвета,включенная в Perl 5.8.4.</target>
        </trans-unit>
        <trans-unit id="13c3f3679453dc21cf99ba9668b08821dc7c3536" translate="yes" xml:space="preserve">
          <source>Support for external gzip added by Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">Поддержка внешнего gzip добавлена ​​Яркко Хиетаниеми &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c1d15c06235a8f38ea6479c09486fef84b83b91c" translate="yes" xml:space="preserve">
          <source>Support for fork() emulation was added in 5.6 (ActiveState Tool Corp).</source>
          <target state="translated">Поддержка эмуляции fork()была добавлена в 5.6 (ActiveState Tool Corp).</target>
        </trans-unit>
        <trans-unit id="4da419edd1ac30a4a7b7cbe60b1ff8e03675397f" translate="yes" xml:space="preserve">
          <source>Support for globally overriding glob() (GSAR 3-JUN-98)</source>
          <target state="translated">Поддержка глобальной переопределяющей функции Glob()(GSAR 3-JUN-98)</target>
        </trans-unit>
        <trans-unit id="52d4e9ac29525e6d8e33903392c09e0782a71a40" translate="yes" xml:space="preserve">
          <source>Support for italic was added in Term::ANSIColor 3.02, included in Perl 5.17.1.</source>
          <target state="translated">Добавлена поддержка курсива в Term::ANSIColor 3.02,включенная в Perl 5.17.1.</target>
        </trans-unit>
        <trans-unit id="0fee3b6033badb5f9d6b2ad7b4bd90ed22c35a68" translate="yes" xml:space="preserve">
          <source>Support for swapping real and effective user and group IDs is incomplete. On WinNT Cygwin provides &lt;code&gt;setuid()&lt;/code&gt; , &lt;code&gt;seteuid()&lt;/code&gt; , &lt;code&gt;setgid()&lt;/code&gt; and &lt;code&gt;setegid()&lt;/code&gt; . However, additional Cygwin calls for manipulating WinNT access tokens and security contexts are required.</source>
          <target state="translated">Поддержка обмена реальных и эффективных идентификаторов пользователей и групп не завершена. В WinNT Cygwin предоставляет &lt;code&gt;setuid()&lt;/code&gt; , &lt;code&gt;seteuid()&lt;/code&gt; , &lt;code&gt;setgid()&lt;/code&gt; и &lt;code&gt;setegid()&lt;/code&gt; . Однако требуются дополнительные вызовы Cygwin для управления токенами доступа WinNT и контекстами безопасности.</target>
        </trans-unit>
        <trans-unit id="112d45f23a800f84de37770824448a89f7d793b8" translate="yes" xml:space="preserve">
          <source>Support for this module is provided via the datetime@perl.org email list. See &lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt; for more details.</source>
          <target state="translated">Поддержка этого модуля осуществляется через список адресов электронной почты datetime@perl.org. См. &lt;a href=&quot;http://lists.perl.org/&quot;&gt;Http://lists.perl.org/&lt;/a&gt; для получения более подробной информации.</target>
        </trans-unit>
        <trans-unit id="75b47c288b94e063b5e848ebb4c141831f2f842b" translate="yes" xml:space="preserve">
          <source>Support for threads extends beyond the code in this module (i.e.,</source>
          <target state="translated">Поддержка потоков выходит за рамки кода в данном модуле (т.е,</target>
        </trans-unit>
        <trans-unit id="4ebd54c9803d67645a6bec6e8a530fc77962d822" translate="yes" xml:space="preserve">
          <source>Supported Colors</source>
          <target state="translated">Поддерживаемые цвета</target>
        </trans-unit>
        <trans-unit id="a65b7f12a991185f44b505808bc867e90d749e20" translate="yes" xml:space="preserve">
          <source>Supported Compilers</source>
          <target state="translated">Поддерживаемые составители</target>
        </trans-unit>
        <trans-unit id="1a182e900ad0b28f084dbe30c2f1ab8dc81f123a" translate="yes" xml:space="preserve">
          <source>Supported Platforms</source>
          <target state="translated">Поддерживаемые платформы</target>
        </trans-unit>
        <trans-unit id="49b953a7424bb44dd08394b0aeda11553bb12089" translate="yes" xml:space="preserve">
          <source>Supported Platforms (Perl 5.8)</source>
          <target state="translated">Поддерживаемые платформы (Раздел 5.8)</target>
        </trans-unit>
        <trans-unit id="b1429d26115432e6f40c246dd70a7c60030a0632" translate="yes" xml:space="preserve">
          <source>Supported are: &lt;code&gt;build_requires_install_policy&lt;/code&gt; , &lt;code&gt;check_sigs&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;make_install_make_command&lt;/code&gt; , &lt;code&gt;prefer_installer&lt;/code&gt; , &lt;code&gt;test_report&lt;/code&gt; . Please report as a bug when you need another one supported.</source>
          <target state="translated">Поддерживаются: &lt;code&gt;build_requires_install_policy&lt;/code&gt; , &lt;code&gt;check_sigs&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;make_install_make_command&lt;/code&gt; , &lt;code&gt;prefer_installer&lt;/code&gt; , &lt;code&gt;test_report&lt;/code&gt; . Пожалуйста, сообщите об ошибке, если вам понадобится поддержка другого.</target>
        </trans-unit>
        <trans-unit id="fef4367afdb333ca61c98475adcf339702a0de4a" translate="yes" xml:space="preserve">
          <source>Supported arguments are the same as for C</source>
          <target state="translated">Поддерживаемые аргументы такие же,как и для C</target>
        </trans-unit>
        <trans-unit id="0aee30f240e3b0641c58b8ea19a5ce4e73c13514" translate="yes" xml:space="preserve">
          <source>Supported versions of Perl</source>
          <target state="translated">Поддерживаемые версии Perl</target>
        </trans-unit>
        <trans-unit id="4ab85bed1d3b1a215699ee5c1c8be8f331ffab56" translate="yes" xml:space="preserve">
          <source>Supports the same options as the C</source>
          <target state="translated">Поддерживает те же опции,что и C</target>
        </trans-unit>
        <trans-unit id="68a10bfa60258c2bbfe38e9f1a7ff60f4694f8f6" translate="yes" xml:space="preserve">
          <source>Suppose instead, that if no matching &quot;/endpara&quot; tag is found, the &quot;/para&quot; tag refers only to the immediately following paragraph:</source>
          <target state="translated">Предположим вместо этого,что если тег &quot;/endpara&quot; не найден,то тег &quot;/para&quot; относится только к непосредственному следующему параграфу:</target>
        </trans-unit>
        <trans-unit id="4a2e98ea3f847f379e1d62458409b455691002c8" translate="yes" xml:space="preserve">
          <source>Suppose that for some strange reason we need a wrapper around the standard C library function &lt;code&gt;fputs()&lt;/code&gt; . This is all we need:</source>
          <target state="translated">Предположим, что по какой-то странной причине нам нужна оболочка для стандартной библиотечной функции C &lt;code&gt;fputs()&lt;/code&gt; . Это все, что нам нужно:</target>
        </trans-unit>
        <trans-unit id="e9713a66e131c3277390fd2e0a638134463da779" translate="yes" xml:space="preserve">
          <source>Suppose that in the previous example functions pointers for multiply(), divide(), add(), subtract() are kept in a global C array &lt;code&gt;fp[]&lt;/code&gt; with offsets being &lt;code&gt;multiply_off&lt;/code&gt; , &lt;code&gt;divide_off&lt;/code&gt; , &lt;code&gt;add_off&lt;/code&gt; , &lt;code&gt;subtract_off&lt;/code&gt; . Then one can use</source>
          <target state="translated">Предположим, что в предыдущем примере указатели функций для multiply (), div (), add (), subtract () хранятся в глобальном C-массиве &lt;code&gt;fp[]&lt;/code&gt; со смещениями &lt;code&gt;multiply_off&lt;/code&gt; , &lt;code&gt;divide_off&lt;/code&gt; , &lt;code&gt;add_off&lt;/code&gt; , &lt;code&gt;subtract_off&lt;/code&gt; . Тогда можно использовать</target>
        </trans-unit>
        <trans-unit id="f6b728cf8454bb8ebd395d51ef450a37f61ee3df" translate="yes" xml:space="preserve">
          <source>Suppose that we want to enable a new RE escape-sequence &lt;code&gt;\Y|&lt;/code&gt; which matches at a boundary between whitespace characters and non-whitespace characters. Note that &lt;code&gt;(?=\S)(?&amp;lt;!\S)|(?!\S)(?&amp;lt;=\S)&lt;/code&gt; matches exactly at these positions, so we want to have each &lt;code&gt;\Y|&lt;/code&gt; in the place of the more complicated version. We can create a module &lt;code&gt;customre&lt;/code&gt; to do this:</source>
          <target state="translated">Предположим, что мы хотим включить новую escape-последовательность RE &lt;code&gt;\Y|&lt;/code&gt; который соответствует границе между пробельными символами и непробельными символами. Обратите внимание, что &lt;code&gt;(?=\S)(?&amp;lt;!\S)|(?!\S)(?&amp;lt;=\S)&lt;/code&gt; соответствует точно в этих позициях, поэтому мы хотим, чтобы каждый &lt;code&gt;\Y|&lt;/code&gt; вместо более сложной версии. Для этого мы можем создать модуль &lt;code&gt;customre&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5ab2eaff078de5c28b462a36a77339cffbb8f320" translate="yes" xml:space="preserve">
          <source>Suppose that you have some C files implementing some functionality, and the corresponding header files. How to create an extension which makes this functionality accessible in Perl? The example below assumes that the header files are</source>
          <target state="translated">Предположим,что у вас есть несколько C-файлов,реализующих некоторый функционал,и соответствующие заголовочные файлы.Как создать расширение,делающее эту функциональность доступной на Perl? В примере ниже предполагается,что заголовочные файлы-это</target>
        </trans-unit>
        <trans-unit id="e38ce69c0f981610bad14796ceb31eadf517ce86" translate="yes" xml:space="preserve">
          <source>Suppose you want to create an object which is accessible as both an array reference and a hash reference.</source>
          <target state="translated">Предположим,вы хотите создать объект,доступный как в виде ссылки на массив,так и в виде ссылки на хэш.</target>
        </trans-unit>
        <trans-unit id="abacd026fc80e9051241fe69f59c13539803bbd4" translate="yes" xml:space="preserve">
          <source>Suppose you want to match all of consecutive pairs of digits in a string like &quot;1122a44&quot; and stop matching when you encounter non-digits. You want to match &lt;code&gt;11&lt;/code&gt; and &lt;code&gt;22&lt;/code&gt; but the letter &amp;lt;a&amp;gt; shows up between &lt;code&gt;22&lt;/code&gt; and &lt;code&gt;44&lt;/code&gt; and you want to stop at &lt;code&gt;a&lt;/code&gt; . Simply matching pairs of digits skips over the &lt;code&gt;a&lt;/code&gt; and still matches &lt;code&gt;44&lt;/code&gt; .</source>
          <target state="translated">Предположим, вы хотите сопоставить все последовательные пары цифр в строке типа &amp;laquo;1122a44&amp;raquo; и прекратить сопоставление, когда вы встретите нецифровые символы. Вы хотите сопоставить &lt;code&gt;11&lt;/code&gt; и &lt;code&gt;22&lt;/code&gt; , но буква &amp;lt;a&amp;gt; появляется между &lt;code&gt;22&lt;/code&gt; и &lt;code&gt;44&lt;/code&gt; , и вы хотите остановиться на &lt;code&gt;a&lt;/code&gt; . Простое совпадение пар цифр пропускает &lt;code&gt;a&lt;/code&gt; и все равно соответствует &lt;code&gt;44&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99f46adab557fd8dab8b4b0b09a159b2654c69a5" translate="yes" xml:space="preserve">
          <source>Suppose you wanted to match only the allocated characters, not the raw block ranges: in other words, you want to remove the unassigned characters:</source>
          <target state="translated">Предположим,вы хотите сопоставить только выделенные символы,а не диапазоны необработанных блоков:другими словами,вы хотите удалить неназначенные символы:</target>
        </trans-unit>
        <trans-unit id="7282725934a73028b4873e419044ca1541b7ef81" translate="yes" xml:space="preserve">
          <source>Suppose your function looks like this:</source>
          <target state="translated">Предположим,твоя функция выглядит так:</target>
        </trans-unit>
        <trans-unit id="3cdc33b87c0a24861f5653d7a4749ecf4d10599b" translate="yes" xml:space="preserve">
          <source>Suppress statically defined functions from the profile.</source>
          <target state="translated">Подавление статически определенных функций из профиля.</target>
        </trans-unit>
        <trans-unit id="f000eea4b15966462d081470a0dbb8675e040042" translate="yes" xml:space="preserve">
          <source>Suppress the verbose descriptions in the profile.</source>
          <target state="translated">Подавите многословные описания в профиле.</target>
        </trans-unit>
        <trans-unit id="fe4ca7a4b62d0d93f13a11c00e6e1ef2ac15f93d" translate="yes" xml:space="preserve">
          <source>Suppressing Lines Where All Fields Are Void</source>
          <target state="translated">Подавление линий,где все поля пусты.</target>
        </trans-unit>
        <trans-unit id="f8a4d33a75006d37aaaa326a12ea28f45b06e609" translate="yes" xml:space="preserve">
          <source>Suppressing all output.</source>
          <target state="translated">Подавление всей мощности.</target>
        </trans-unit>
        <trans-unit id="4db0aec339465e45f71592f3d61d3b7d5519b564" translate="yes" xml:space="preserve">
          <source>Suppressing everything but the tests summary.</source>
          <target state="translated">Подавление всего,кроме результатов анализов.</target>
        </trans-unit>
        <trans-unit id="3118002fe0231bc240b745efda50a51f4811af55" translate="yes" xml:space="preserve">
          <source>Suppressing some test output (mostly failures while tests are running).</source>
          <target state="translated">Подавление некоторых тестовых выходных данных (в основном,сбоев во время выполнения тестов).</target>
        </trans-unit>
        <trans-unit id="aaf2f474284f3bb3469459a5f2e282c817445e0a" translate="yes" xml:space="preserve">
          <source>Surprisingly, the following dangerous-looking construct will actually work out fine:</source>
          <target state="translated">Удивительно,но следующие опасные конструкции на самом деле сработают:</target>
        </trans-unit>
        <trans-unit id="89de18d6062f8f62c80480423d64e1771fc8ce04" translate="yes" xml:space="preserve">
          <source>Surprisingly, the routines to be called are named &lt;code&gt;freeze&lt;/code&gt; and &lt;code&gt;thaw&lt;/code&gt; . If you wish to send out the frozen scalar to another machine, use &lt;code&gt;nfreeze&lt;/code&gt; instead to get a portable image.</source>
          <target state="translated">Удивительно, но вызываемые процедуры называются &lt;code&gt;freeze&lt;/code&gt; и &lt;code&gt;thaw&lt;/code&gt; . Если вы хотите отправить замороженный скаляр на другую машину, используйте вместо этого &lt;code&gt;nfreeze&lt;/code&gt; , чтобы получить переносимый образ.</target>
        </trans-unit>
        <trans-unit id="c6a047875b873f6d1d398e86dbb7108d34705540" translate="yes" xml:space="preserve">
          <source>Surrogate Pairs</source>
          <target state="translated">Суррогатные пары</target>
        </trans-unit>
        <trans-unit id="07a0eab00168ce9bedc809f5ad8c9eb56cbd1edb" translate="yes" xml:space="preserve">
          <source>Surrogate pairs were born when the Unicode Consortium finally admitted that 16 bits were not big enough to hold all the world's character repertoires. But they already made UCS-2 16-bit. What do we do?</source>
          <target state="translated">Суррогатные пары родились,когда консорциум &quot;Юникод&quot; наконец признал,что 16 бит недостаточно велики,чтобы вместить весь мировой репертуар персонажей.Но они уже сделали UCS-2 16-битным.Что же нам делать?</target>
        </trans-unit>
        <trans-unit id="1eaaa69a37b20a485ea6f0e51d7a77d119e19f29" translate="yes" xml:space="preserve">
          <source>Surrogates are code points set aside to encode the &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; range of Unicode code points in pairs of 16-bit units. The</source>
          <target state="translated">Суррогаты - это кодовые точки, выделенные для кодирования диапазона &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; кодовых точек Unicode парами из 16-битных единиц. В</target>
        </trans-unit>
        <trans-unit id="856dbe523b5bc18c3ac9b4ef67ed5a73d664d082" translate="yes" xml:space="preserve">
          <source>Surrogates have no meaning in Unicode outside their use in pairs to represent other code points. However, Perl allows them to be represented individually internally, for example by saying &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0xD801)&lt;/a&gt;&lt;/code&gt;, so that all code points, not just those valid for open interchange, are representable. Unicode does define semantics for them, such as their &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&quot;Cs&quot;&lt;/code&gt; . But because their use is somewhat dangerous, Perl will warn (using the warning category &lt;code&gt;&quot;surrogate&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if an attempt is made to do things like take the lower case of one, or match case-insensitively, or to output them. (But don't try this on Perls before 5.14.)</source>
          <target state="translated">Суррогаты не имеют значения в Юникоде, за исключением того, что они используются парами для представления других кодовых точек. Однако Perl позволяет представлять их индивидуально внутри, например, говоря &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0xD801)&lt;/a&gt;&lt;/code&gt; , так что все кодовые точки, а не только те, которые допустимы для открытого обмена, могут быть представлены. Unicode действительно определяет для них семантику, например, их &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; - &lt;code&gt;&quot;Cs&quot;&lt;/code&gt; . Но поскольку их использование несколько опасно, Perl будет предупреждать (используя категорию предупреждений &lt;code&gt;&quot;surrogate&quot;&lt;/code&gt; , которая является подкатегорией &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ), если будет предпринята попытка сделать что-то вроде взятия единицы в нижнем регистре или совпадения регистра -нечувствительно, или выводить их. (Но не пробуйте это на Perls до 5.14.)</target>
        </trans-unit>
        <trans-unit id="540da7a8cd172c1838160d487b9d7ef0924efc97" translate="yes" xml:space="preserve">
          <source>Suspicious Warnings on Cygwin</source>
          <target state="translated">Подозрительные предупреждения о Сигвине.</target>
        </trans-unit>
        <trans-unit id="1e1cd0c78512c809bc8f82ce5a88755a660fc1dd" translate="yes" xml:space="preserve">
          <source>SvIV()</source>
          <target state="translated">SvIV()</target>
        </trans-unit>
        <trans-unit id="dbc4878fd112ac06a09fc11cde47bb125aee2c3f" translate="yes" xml:space="preserve">
          <source>SvNV()</source>
          <target state="translated">SvNV()</target>
        </trans-unit>
        <trans-unit id="935c09deb58ecb63d6891adc1aabec93c4c8a5b7" translate="yes" xml:space="preserve">
          <source>SvPV()</source>
          <target state="translated">SvPV()</target>
        </trans-unit>
        <trans-unit id="d644182b7fecca2e84a27663743f7d7d1731110e" translate="yes" xml:space="preserve">
          <source>SvTHINKFIRST sometimes produces false positives. In those cases sv_force_normal does nothing.</source>
          <target state="translated">SvTHINKFIRST иногда производит ложные срабатывания.В этих случаях sv_force_normal ничего не делает.</target>
        </trans-unit>
        <trans-unit id="7d140830d04307683300b42c263a4bad9b2b05e6" translate="yes" xml:space="preserve">
          <source>Switch Statements</source>
          <target state="translated">Выписки о переключении</target>
        </trans-unit>
        <trans-unit id="8bd9a48c2b8a06497ad155d8fb2e22e3efb40ec2" translate="yes" xml:space="preserve">
          <source>Switch off optimizations.</source>
          <target state="translated">Выключите оптимизацию.</target>
        </trans-unit>
        <trans-unit id="3bb7fa365adb6d9413c8c9a8c7435723660691af" translate="yes" xml:space="preserve">
          <source>Switch to viewing a different file or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; statement. If</source>
          <target state="translated">Переключитесь на просмотр другого файла или оператора &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . Если</target>
        </trans-unit>
        <trans-unit id="941726dc5468b689bfb5334269ab159c8c5ac044" translate="yes" xml:space="preserve">
          <source>Switches On the &quot;#!&quot; Line</source>
          <target state="translated">Включает &quot;#!&quot; Линия</target>
        </trans-unit>
        <trans-unit id="22865b749e47c4f80690e8fbf02747aa53e87248" translate="yes" xml:space="preserve">
          <source>Switches include:</source>
          <target state="translated">Переключатели включают в себя:</target>
        </trans-unit>
        <trans-unit id="1a104dee1272b5ea48fa02cf2cd55d0cf5980bda" translate="yes" xml:space="preserve">
          <source>Switches which take an argument don't care whether there is a space between the switch and the argument. If unspecified switches are found on the command-line, the user will be warned that an unknown option was given.</source>
          <target state="translated">Переключатели,которые принимают аргумент,не заботятся о том,есть ли пробел между переключателем и аргументом.Если в командной строке будут найдены неуказанные переключатели,пользователь будет предупрежден о том,что была задана неизвестная опция.</target>
        </trans-unit>
        <trans-unit id="88a10266365bec895433e46eaf4bb0d9f4319fa6" translate="yes" xml:space="preserve">
          <source>Switching in a loop</source>
          <target state="translated">Переключение в контуре</target>
        </trans-unit>
        <trans-unit id="c4833a3fbcd559394f2c58d1f54c950e1415a542" translate="yes" xml:space="preserve">
          <source>Sx is an interface to the Athena widget set which comes with X, but again it appears not to be much used nowadays.</source>
          <target state="translated">Sx-это интерфейс к набору виджетов Athena,который поставляется с X,но опять же,кажется,что в настоящее время он мало используется.</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="6f23f00b2c5559251a269c3e95612a03f0fa5304" translate="yes" xml:space="preserve">
          <source>Symbol - manipulate Perl symbols and their names</source>
          <target state="translated">Символ-манипулируйте символами Perl и их названиями.</target>
        </trans-unit>
        <trans-unit id="e2434de5e406913ebf6a3ac33e80e10d4a315aea" translate="yes" xml:space="preserve">
          <source>Symbol Encodings</source>
          <target state="translated">Символ Кодировка</target>
        </trans-unit>
        <trans-unit id="d794fc2c3b0c30f40edbe0d808d2368ffeb21d98" translate="yes" xml:space="preserve">
          <source>Symbol Tables</source>
          <target state="translated">Символ Таблицы</target>
        </trans-unit>
        <trans-unit id="4b05d7078c77af4d667a4898e87b6c3188ae4b11" translate="yes" xml:space="preserve">
          <source>Symbolic Calculator</source>
          <target state="translated">Символический калькулятор</target>
        </trans-unit>
        <trans-unit id="37008620b710f26771f72ef684d0d762ce0c312d" translate="yes" xml:space="preserve">
          <source>Symbolic Links</source>
          <target state="translated">Символические ссылки</target>
        </trans-unit>
        <trans-unit id="d0a9fa28cc57e07ecbedf349e28f66a417dbd550" translate="yes" xml:space="preserve">
          <source>Symbolic Unary Operators</source>
          <target state="translated">Символические Унарные операторы</target>
        </trans-unit>
        <trans-unit id="c85b29041363945d0d38e6dd76ab2012cab61284" translate="yes" xml:space="preserve">
          <source>Symbolic links will be replicated in the destination directory. If &lt;b&gt;-l&lt;/b&gt; is not specified, then links are skipped over.</source>
          <target state="translated">Символические ссылки будут скопированы в целевой каталог. Если &lt;b&gt;-l&lt;/b&gt; не указан, ссылки пропускаются.</target>
        </trans-unit>
        <trans-unit id="5740fe00b50befc25ecdbfe2ce1dcb268f365ae5" translate="yes" xml:space="preserve">
          <source>Symbolic methods</source>
          <target state="translated">Символические методы</target>
        </trans-unit>
        <trans-unit id="2ed5a46b240bca78e1ebda87bbf53e151430ff41" translate="yes" xml:space="preserve">
          <source>Symbolic references</source>
          <target state="translated">Символические ссылки</target>
        </trans-unit>
        <trans-unit id="11ea83f8147883e582553aebb48729beba5bdaf1" translate="yes" xml:space="preserve">
          <source>Symbolic references are forbidden under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma. They are not true references and consequently are not reference-counted or garbage-collected.</source>
          <target state="translated">Символические ссылки запрещены в соответствии с директивой &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; . Они не являются истинными ссылками и, следовательно, не подлежат подсчету ссылок или сборке мусора.</target>
        </trans-unit>
        <trans-unit id="2a3d231a255923086dc7e82179bb6e9c216f886c" translate="yes" xml:space="preserve">
          <source>Symbolic references are names of variables or other objects, just as a symbolic link in a Unix filesystem contains merely the name of a file. The &lt;code&gt;*glob&lt;/code&gt; notation is something of a symbolic reference. (Symbolic references are sometimes called &quot;soft references&quot;, but please don't call them that; references are confusing enough without useless synonyms.)</source>
          <target state="translated">Символьные ссылки - это имена переменных или других объектов, точно так же, как символическая ссылка в файловой системе Unix содержит просто имя файла. &lt;code&gt;*glob&lt;/code&gt; обозначение нечто символической ссылки. (Символические ссылки иногда называют &amp;laquo;мягкими ссылками&amp;raquo;, но, пожалуйста, не называйте их так; ссылки достаточно запутывают без бесполезных синонимов.)</target>
        </trans-unit>
        <trans-unit id="7eb647835a30e5a1bbf74157fa14f494b596a5c9" translate="yes" xml:space="preserve">
          <source>Symbols representing the concepts &amp;ldquo;and&amp;rdquo;, &amp;ldquo;or&amp;rdquo;, &amp;ldquo;xor&amp;rdquo;, and &amp;ldquo;not&amp;rdquo;.</source>
          <target state="translated">Символы, представляющие понятия &amp;laquo;и&amp;raquo;, &amp;laquo;или&amp;raquo;, &amp;laquo;xor&amp;raquo; и &amp;laquo;не&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="bc32943d7841b88a1cf40309071785aab7d4e9d1" translate="yes" xml:space="preserve">
          <source>Synchronization and control</source>
          <target state="translated">Синхронизация и управление</target>
        </trans-unit>
        <trans-unit id="fd6877f381ee0675d5bd925a8ea887b401ae7a51" translate="yes" xml:space="preserve">
          <source>Synonymous options (like both the short and long forms) are separated by a comma and a space on the same &lt;code&gt;=item&lt;/code&gt; line, or optionally listed as their own item with a reference to the canonical name. For example, since &lt;b&gt;--section&lt;/b&gt; can also be written as &lt;b&gt;-s&lt;/b&gt;, the above would be:</source>
          <target state="translated">Синонимичные параметры (например, краткая и длинная формы) разделяются запятой и пробелом в одной строке &lt;code&gt;=item&lt;/code&gt; или, при необходимости, указываются как отдельный элемент со ссылкой на каноническое имя. Например, поскольку &lt;b&gt;--section&lt;/b&gt; также можно записать как &lt;b&gt;-s&lt;/b&gt; , приведенное выше будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="fcbf093f7bdc572a445b9a43606c7f7a83836b33" translate="yes" xml:space="preserve">
          <source>Synonyms for &lt;code&gt;recipient&lt;/code&gt; .</source>
          <target state="translated">Синонимы к &lt;code&gt;recipient&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="af5f0a5e089ff24df87876664a300fc1d94de87c" translate="yes" xml:space="preserve">
          <source>Synopsis:</source>
          <target state="translated">Synopsis:</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="e90738f5d4b2229f3a4c124484c36b1275df5262" translate="yes" xml:space="preserve">
          <source>Syntax for invoking shar, tar and zip differs from that for Unix.</source>
          <target state="translated">Синтаксис для вызова шар,смол и молнии отличается от синтаксиса для Unix.</target>
        </trans-unit>
        <trans-unit id="7d8c7607abfe852f9a6ad8648332314d9917e637" translate="yes" xml:space="preserve">
          <source>Syntax of Attribute Lists</source>
          <target state="translated">Синтаксис атрибутивных списков</target>
        </trans-unit>
        <trans-unit id="1de8dba368e7754dc199c99b017f5c51265ee8dc" translate="yes" xml:space="preserve">
          <source>Syntax:</source>
          <target state="translated">Syntax:</target>
        </trans-unit>
        <trans-unit id="0785d5c2121b7134c4af7c65680f001acb76a92c" translate="yes" xml:space="preserve">
          <source>Sys$Library</source>
          <target state="translated">Sys$Library</target>
        </trans-unit>
        <trans-unit id="65fb3d73b0b7d628e2887a67776fd305bc37b9e6" translate="yes" xml:space="preserve">
          <source>Sys$Share</source>
          <target state="translated">Sys$Share</target>
        </trans-unit>
        <trans-unit id="dbb39438e97d2bc740ddc791cb728708fa6deab2" translate="yes" xml:space="preserve">
          <source>Sys$System:</source>
          <target state="translated">Sys$System:</target>
        </trans-unit>
        <trans-unit id="48fee1621e8e0fbac3a51bb7b722933258b770f4" translate="yes" xml:space="preserve">
          <source>Sys::Hostname</source>
          <target state="translated">Sys::Hostname</target>
        </trans-unit>
        <trans-unit id="2e415aac42b72faad3c72367e40e8717dbc66b3c" translate="yes" xml:space="preserve">
          <source>Sys::Hostname - Try every conceivable way to get hostname</source>
          <target state="translated">Sys::Имя хоста-Попробуйте все возможные способы получить имя хоста.</target>
        </trans-unit>
        <trans-unit id="c1e878d92efc49a2e4d7c74bab56ecb4df79e136" translate="yes" xml:space="preserve">
          <source>Sys::Syslog</source>
          <target state="translated">Sys::Syslog</target>
        </trans-unit>
        <trans-unit id="d0e7c26b96f1913c444745d08172cdce4e0c92fa" translate="yes" xml:space="preserve">
          <source>Sys::Syslog - Perl interface to the UNIX syslog(3) calls</source>
          <target state="translated">Sys::Syslog-Perl интерфейс к вызовам UNIX syslog(3)</target>
        </trans-unit>
        <trans-unit id="e9c9e6fce8c27f1db38faca8727f60ffbd03b1df" translate="yes" xml:space="preserve">
          <source>SysV IPC</source>
          <target state="translated">SysV IPC</target>
        </trans-unit>
        <trans-unit id="b769fe98988d4570b7169913197897773fb46367" translate="yes" xml:space="preserve">
          <source>SysV Msg IPC object class</source>
          <target state="translated">SysV Msg объектный класс IPC</target>
        </trans-unit>
        <trans-unit id="1b5cd833684b7ef6a59dab44ff94b295bccc40b4" translate="yes" xml:space="preserve">
          <source>SysV Semaphore IPC object class</source>
          <target state="translated">SysV Semaphore IPC объектный класс</target>
        </trans-unit>
        <trans-unit id="71c44529ecac23b5c9809ec7a57f43fadf59d867" translate="yes" xml:space="preserve">
          <source>SysV Shared Memory IPC object class</source>
          <target state="translated">Объектный класс IPC общей памяти SysV</target>
        </trans-unit>
        <trans-unit id="e45e7e358eb9351a96a4b4d44c0db473a81b0bd0" translate="yes" xml:space="preserve">
          <source>Syscall returns whatever value returned by the system call it calls. If the system call fails, &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Note that some system calls</source>
          <target state="translated">Системный вызов возвращает любое значение, возвращаемое системным вызовом, который он вызывает. В случае сбоя системного вызова &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;-1&lt;/code&gt; и устанавливает &lt;code&gt;$!&lt;/code&gt; (эррно). Обратите внимание, что некоторые системные вызовы</target>
        </trans-unit>
        <trans-unit id="e0b761d47162708932873aa746a0b31a4af21afe" translate="yes" xml:space="preserve">
          <source>Syscall returns whatever value returned by the system call it calls. If the system call fails, &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Note that some system calls</source>
          <target state="translated">Системный вызов возвращает любое значение, возвращаемое системным вызовом, который он вызывает. В случае сбоя системного вызова &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;-1&lt;/code&gt; и устанавливает &lt;code&gt;$!&lt;/code&gt; (эррно). Обратите внимание, что некоторые системные вызовы</target>
        </trans-unit>
        <trans-unit id="53aa71666c5046c70bdb9cfa19d05f3e5e2dbe70" translate="yes" xml:space="preserve">
          <source>Syslogging with Perl</source>
          <target state="translated">Установление контактов с Перлом</target>
        </trans-unit>
        <trans-unit id="b9c23727af44d87276c73142b1bbc56acfa2ff99" translate="yes" xml:space="preserve">
          <source>Sysroot.U</source>
          <target state="translated">Sysroot.U</target>
        </trans-unit>
        <trans-unit id="286ad58c359f169cf560ed965ca49713b4161be5" translate="yes" xml:space="preserve">
          <source>System Interaction</source>
          <target state="translated">Взаимодействие с системой</target>
        </trans-unit>
        <trans-unit id="a5f5e2adb8b84a09a3496b92bfc8ae6f7818b5f8" translate="yes" xml:space="preserve">
          <source>System Resources</source>
          <target state="translated">Системные ресурсы</target>
        </trans-unit>
        <trans-unit id="12920688fafa23a0e3538825316e84488141b30c" translate="yes" xml:space="preserve">
          <source>System Specifics</source>
          <target state="translated">Системные особенности</target>
        </trans-unit>
        <trans-unit id="1c80f9799bbc3cebb5501e8db9a2d073ae25632e" translate="yes" xml:space="preserve">
          <source>System V IPC constants and system calls</source>
          <target state="translated">Системные V IPC константы и системные вызовы</target>
        </trans-unit>
        <trans-unit id="16956db37d0c77a530acbdbc4b5059785173084f" translate="yes" xml:space="preserve">
          <source>System calls accept either &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt; as the path separator. However, many command-line utilities of DOS vintage treat &lt;code&gt;/&lt;/code&gt; as the option prefix, so may get confused by filenames containing &lt;code&gt;/&lt;/code&gt;. Aside from calling any external programs, &lt;code&gt;/&lt;/code&gt; will work just fine, and probably better, as it is more consistent with popular usage, and avoids the problem of remembering what to backwhack and what not to.</source>
          <target state="translated">Системные вызовы принимают в качестве разделителя пути либо &lt;code&gt;/&lt;/code&gt; , либо &lt;code&gt;\&lt;/code&gt; . Однако многие утилиты командной строки DOS vintage рассматривают &lt;code&gt;/&lt;/code&gt; как префикс параметра, поэтому могут запутаться в именах файлов, содержащих &lt;code&gt;/&lt;/code&gt; . Помимо вызова каких-либо внешних программ, &lt;code&gt;/&lt;/code&gt; будет работать нормально и, вероятно, лучше, поскольку он более соответствует популярному использованию и позволяет избежать проблемы с запоминанием того, что нужно отбивать, а что нет.</target>
        </trans-unit>
        <trans-unit id="007271cb98a5608fe64c06188e43289d61f1c7bd" translate="yes" xml:space="preserve">
          <source>System calls return -1 on error (setting ERRNO with the reason) and (usually) 0 on success. If the return value is -1 this typemap returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. If the return value is not -1, this typemap translates a 0 (perl false) to &quot;0 but true&quot; (which is perl true) or returns the value itself, to indicate that the command succeeded.</source>
          <target state="translated">Системные вызовы возвращают -1 в случае ошибки (установка ERRNO с указанием причины) и (обычно) 0 в случае успеха. Если возвращаемое значение -1, эта карта типов возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Если возвращаемое значение не равно -1, эта карта типов переводит 0 (perl false) в &amp;laquo;0 but true&amp;raquo; (что perl true) или возвращает само значение, чтобы указать, что команда выполнена успешно.</target>
        </trans-unit>
        <trans-unit id="eb78d5fbb36025d1ade73acf0ec1dc017253b7c6" translate="yes" xml:space="preserve">
          <source>System calls such as link(), unlink(), rename(), etc. return nonzero for success, not 0. (system(), however, returns zero for success.)</source>
          <target state="translated">Системные вызовы,такие как link(),unlink(),rename()и т.д.возвращают ненулевое значение для успеха,а не 0.(system(),однако,возвращает ноль для успеха).</target>
        </trans-unit>
        <trans-unit id="a5bfc62972086e83c2f9e4d6647ba3081448737b" translate="yes" xml:space="preserve">
          <source>System errno constants</source>
          <target state="translated">Системные эррно-константы</target>
        </trans-unit>
        <trans-unit id="0464247110efd6dc873ab7d03699ac46391aa089" translate="yes" xml:space="preserve">
          <source>SystemV Interprocess Communications:</source>
          <target state="translated">Межпроцессные коммуникации SystemV:</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="9f94efb44fe911a9e20566c2b4f9e9743238c25c" translate="yes" xml:space="preserve">
          <source>TABLE OF CONTENTS</source>
          <target state="translated">ОГЛАВЛЕНИЕ</target>
        </trans-unit>
        <trans-unit id="3b4df05d703541d151d3e3628328bb8fd532308b" translate="yes" xml:space="preserve">
          <source>TAP GRAMMAR</source>
          <target state="translated">TAP GRAMMAR</target>
        </trans-unit>
        <trans-unit id="1920029d62435d8577df2572dd0096bfaff76178" translate="yes" xml:space="preserve">
          <source>TAP pragma token.</source>
          <target state="translated">TAP прагматический жетон.</target>
        </trans-unit>
        <trans-unit id="a6ad0c7cbda3b41f87bebc3eecd396afa503fee6" translate="yes" xml:space="preserve">
          <source>TAP syntax version token.</source>
          <target state="translated">Токен версии синтаксиса TAP.</target>
        </trans-unit>
        <trans-unit id="3876ffd2c762f78e88b10fd7b5ed6b67ff853ed5" translate="yes" xml:space="preserve">
          <source>TAP::Base</source>
          <target state="translated">TAP::Base</target>
        </trans-unit>
        <trans-unit id="393bbdfe5b0291f7582e0a00a859897a43f52662" translate="yes" xml:space="preserve">
          <source>TAP::Base - Base class that provides common functionality to &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and &lt;a href=&quot;harness&quot;&gt;TAP::Harness&lt;/a&gt;</source>
          <target state="translated">TAP :: Base - базовый класс, который обеспечивает общие функции для &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; и &lt;a href=&quot;harness&quot;&gt;TAP :: Harness&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="863c519a681845de61f18ccf2d91ed2bae4b3a87" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Base</source>
          <target state="translated">TAP::Formatter::Base</target>
        </trans-unit>
        <trans-unit id="2219301c0e6ab7a0cac653627940a66913b4e00c" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Base - Base class for harness output delegates</source>
          <target state="translated">СПД::Формат::База-Базовый класс для делегатов выхода жгута</target>
        </trans-unit>
        <trans-unit id="737a5324c5901c02f42ad717687b54b1dafd7c3b" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Color</source>
          <target state="translated">TAP::Formatter::Color</target>
        </trans-unit>
        <trans-unit id="83dc9a13e5e40b4cace713c5d42771d2b5bb47e0" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Color - Run Perl test scripts with color</source>
          <target state="translated">ТЭП::Формат::Цвет-запустить тестовые скрипты на Perl с цветом</target>
        </trans-unit>
        <trans-unit id="de057ff7c6b5e40851d3c50d32e9750e339c5926" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console</source>
          <target state="translated">TAP::Formatter::Console</target>
        </trans-unit>
        <trans-unit id="e5caa85b06270fe34451b375ee12674e638dd733" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console - Harness output delegate for default console output</source>
          <target state="translated">TAP::Формат::Консоль-делегат выхода Harness для вывода на консоль по умолчанию</target>
        </trans-unit>
        <trans-unit id="01b7c503e4f8a4af70b89b685b263fa99a7779a7" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::ParallelSession</source>
          <target state="translated">TAP::Formatter::Console::ParallelSession</target>
        </trans-unit>
        <trans-unit id="db7bd0c049621f91358c7128fbd5472680ec6d31" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::ParallelSession - Harness output delegate for parallel console output</source>
          <target state="translated">TAP::Формат::Консоль::ParallelSession-Делегат вывода Harness для параллельного консольного вывода</target>
        </trans-unit>
        <trans-unit id="e10aa0877a249858e704e343610555a15b6331f0" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::Session</source>
          <target state="translated">TAP::Formatter::Console::Session</target>
        </trans-unit>
        <trans-unit id="617e83a9b0bba0c6a87c6403d55512035b5d4331" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::Session - Harness output delegate for default console output</source>
          <target state="translated">TAP::Формат::Консоль::Сессия-делегат выхода Harness для вывода консоли по умолчанию</target>
        </trans-unit>
        <trans-unit id="ebcc51d604eabcfa523d96f91dc1b0eb51dccb7d" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File</source>
          <target state="translated">TAP::Formatter::File</target>
        </trans-unit>
        <trans-unit id="ce9e5131d6998f180ee6abe8bad4643f869cfb3d" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File - Harness output delegate for file output</source>
          <target state="translated">TAP::Формат::Файл-Делегирование вывода для вывода файла</target>
        </trans-unit>
        <trans-unit id="5a53ebb59dd4ba13f5939d6a9f81cddf3e1c6f45" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File::Session</source>
          <target state="translated">TAP::Formatter::File::Session</target>
        </trans-unit>
        <trans-unit id="360d8f026e4e5483612bf0275831836f9ffb249f" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File::Session - Harness output delegate for file output</source>
          <target state="translated">TAP::Формат::Файл::Сессия-делегат выхода Harness для вывода файла</target>
        </trans-unit>
        <trans-unit id="46af53bbf8c7eee3da8d825fcace74fe474d232b" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Session</source>
          <target state="translated">TAP::Formatter::Session</target>
        </trans-unit>
        <trans-unit id="c2df33c30bd450c40b146c186ea09c6cab11e56c" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Session - Abstract base class for harness output delegate</source>
          <target state="translated">СПД::Формат::Сессия-Абстрактный базовый класс для делегата выхода жгута</target>
        </trans-unit>
        <trans-unit id="93ebad31adfaf596a987126afe3d7a3f18d93c05" translate="yes" xml:space="preserve">
          <source>TAP::Harness</source>
          <target state="translated">TAP::Harness</target>
        </trans-unit>
        <trans-unit id="b7d5d266f7a8edc064e0b8c710521d51a2bc894a" translate="yes" xml:space="preserve">
          <source>TAP::Harness - Run test scripts with statistics</source>
          <target state="translated">TAP::Harness-запустить тестовые скрипты со статистикой</target>
        </trans-unit>
        <trans-unit id="7a70a46bfa38bc1216fe94cb04afcea34c7e8685" translate="yes" xml:space="preserve">
          <source>TAP::Object</source>
          <target state="translated">TAP::Object</target>
        </trans-unit>
        <trans-unit id="f09e3a92ac29a0ecd8a4f02097d67c9251bfb4fd" translate="yes" xml:space="preserve">
          <source>TAP::Object - Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">TAP :: Object - Базовый класс, который обеспечивает общие функции для всех модулей &lt;code&gt;TAP::*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73c55e213830c688e72c24e7e2dc38927a8f526e" translate="yes" xml:space="preserve">
          <source>TAP::Parser</source>
          <target state="translated">TAP::Parser</target>
        </trans-unit>
        <trans-unit id="2f07ed865105b4fe8e06f2ed0ef74d2249f0ce1b" translate="yes" xml:space="preserve">
          <source>TAP::Parser - Parse &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; output</source>
          <target state="translated">TAP :: Parser - Разобрать вывод &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a216f40bfe5d8c4e9f480503b3353a997f25d9e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Aggregator</source>
          <target state="translated">TAP::Parser::Aggregator</target>
        </trans-unit>
        <trans-unit id="29967243373ff3c2847efa03292cf1394ade91bf" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Aggregator - Aggregate TAP::Parser results</source>
          <target state="translated">TAP::Парсер::Агрегатор-Агрегировать результаты TAP::Парсер</target>
        </trans-unit>
        <trans-unit id="ea252a87adf45624e0915f082cf3a171691e2b87" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Grammar</source>
          <target state="translated">TAP::Parser::Grammar</target>
        </trans-unit>
        <trans-unit id="99d73c9149822b89f098465b0ef15b6e5e432ba4" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Grammar - A grammar for the Test Anything Protocol.</source>
          <target state="translated">TAP::Парсер::Грамматика-грамматика для протокола Test Anything.</target>
        </trans-unit>
        <trans-unit id="f66dcc18cf605bab72f282216bf437fafae85c73" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator</source>
          <target state="translated">TAP::Parser::Iterator</target>
        </trans-unit>
        <trans-unit id="d222e4542e0f93a9f4cabc8a65b724fcc86515cd" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator - Base class for TAP source iterators</source>
          <target state="translated">TAP::Parser::Iterator-Базовый класс для итераторов источника TAP</target>
        </trans-unit>
        <trans-unit id="599e631b6f320b3fc47ee504d90a3e175b821f4e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Array</source>
          <target state="translated">TAP::Parser::Iterator::Array</target>
        </trans-unit>
        <trans-unit id="8849b72265bccd1154b20c5bcfd79b6177e1d979" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Array - Iterator for array-based TAP sources</source>
          <target state="translated">TAP::Parser::Iterator::Array-Iterator для источников TAP на основе массива</target>
        </trans-unit>
        <trans-unit id="8afb640018f748c7abac8e508f78557fe8689509" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Process</source>
          <target state="translated">TAP::Parser::Iterator::Process</target>
        </trans-unit>
        <trans-unit id="ef61fd1ef2ee2ba4a706833aed0bb08fe84a24ba" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Process - Iterator for process-based TAP sources</source>
          <target state="translated">TAP::Парсер::Итератор::Процесс-Итератор для процессных TAP источников</target>
        </trans-unit>
        <trans-unit id="c97751b26f9e6df1ee3c0a7feabeda4e0d9102c3" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Stream</source>
          <target state="translated">TAP::Parser::Iterator::Stream</target>
        </trans-unit>
        <trans-unit id="be38f68275dc99a67c8ac1d8cfd48bb032de4d4a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Stream - Iterator for filehandle-based TAP sources</source>
          <target state="translated">TAP::Parser::Iterator::Stream-Iterator для TAP-источников,основанных на файловых дескрипторах</target>
        </trans-unit>
        <trans-unit id="d89bed7b6f6d5d165f751cac2ac0a13e2dd7f697" translate="yes" xml:space="preserve">
          <source>TAP::Parser::IteratorFactory</source>
          <target state="translated">TAP::Parser::IteratorFactory</target>
        </trans-unit>
        <trans-unit id="8d39f8677b4d63ea3260e5507a930c994a438d70" translate="yes" xml:space="preserve">
          <source>TAP::Parser::IteratorFactory - Figures out which SourceHandler objects to use for a given Source</source>
          <target state="translated">TAP::Parser::IteratorFactory-Выясняет,какие объекты SourceHandler использовать для данного источника.</target>
        </trans-unit>
        <trans-unit id="6f50fafc730902e3aa24fa13c0c429b89a2cc1ff" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Multiplexer</source>
          <target state="translated">TAP::Parser::Multiplexer</target>
        </trans-unit>
        <trans-unit id="2da48d5d830b8cd9138d15d18237febc28e0b498" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Multiplexer - Multiplex multiple TAP::Parsers</source>
          <target state="translated">TAP::Парсер::Мультиплексор-Мультиплексный мультиплексный мультиплексор TAP::Парсер</target>
        </trans-unit>
        <trans-unit id="3c077c3ce874909f47ae77cbcca2c04344198e5b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result</source>
          <target state="translated">TAP::Parser::Result</target>
        </trans-unit>
        <trans-unit id="a422082a9e255b156b40569483bd6f50f2d5a284" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result - Base class for TAP::Parser output objects</source>
          <target state="translated">TAP::Parser::Результат-Базовый класс для объектов вывода TAP::Parser</target>
        </trans-unit>
        <trans-unit id="03b8058105031bc1095218a7667a2ea1b2512b1e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Bailout</source>
          <target state="translated">TAP::Parser::Result::Bailout</target>
        </trans-unit>
        <trans-unit id="00f4b677e9dddb24581e9ed004b7470cf77a617e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Bailout - Bailout result token.</source>
          <target state="translated">TAP::Парсер::Результат::Спасение-маркер результата спасения.</target>
        </trans-unit>
        <trans-unit id="afba56eaac641feaac3daf9f840411e87ecf1e14" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Comment</source>
          <target state="translated">TAP::Parser::Result::Comment</target>
        </trans-unit>
        <trans-unit id="15ac19d49aebc2fdbf7a430ac512a0c55bc03548" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Comment - Comment result token.</source>
          <target state="translated">TAP::Парсер::Результат::Комментарий-Комментарий маркера результата.</target>
        </trans-unit>
        <trans-unit id="8028e0720d8ec37d7287bdb1bc7450078b0bf251" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Plan</source>
          <target state="translated">TAP::Parser::Result::Plan</target>
        </trans-unit>
        <trans-unit id="4383859286c921d76add9716628e055668e9e51d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Plan - Plan result token.</source>
          <target state="translated">TAP::Парсер::Результат::План-Запланировать маркер результата.</target>
        </trans-unit>
        <trans-unit id="f69e80305022a26d3e2f7acc2b0ed1b953372499" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Pragma</source>
          <target state="translated">TAP::Parser::Result::Pragma</target>
        </trans-unit>
        <trans-unit id="14e0c88ebea6563cf55ee8c08b3b9ed300f0d20c" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Pragma - TAP pragma token.</source>
          <target state="translated">TAP::Парсер::Результат::Прагма-TAP прагматический жетон.</target>
        </trans-unit>
        <trans-unit id="2c91344b1f933a9487eebefc220df8812b008445" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Test</source>
          <target state="translated">TAP::Parser::Result::Test</target>
        </trans-unit>
        <trans-unit id="edc9dae5ee4fae6dd91f0295f192573a8fb6a01a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Test - Test result token.</source>
          <target state="translated">TAP::Парсер::Результат::Тест-маркер результата теста.</target>
        </trans-unit>
        <trans-unit id="44c345b7d9dc9992b3e410debbb02b0d29d66e79" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Unknown</source>
          <target state="translated">TAP::Parser::Result::Unknown</target>
        </trans-unit>
        <trans-unit id="2943117d9510c588ee4451eb94edacf47000ab69" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Unknown - Unknown result token.</source>
          <target state="translated">TAP::Парсер::Результат::Неизвестно-Токен неизвестного результата.</target>
        </trans-unit>
        <trans-unit id="c6da177c03a14aa64f029674caca24adf3980051" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Version</source>
          <target state="translated">TAP::Parser::Result::Version</target>
        </trans-unit>
        <trans-unit id="57883e95518fac69c11831c9fff6d78815a22b85" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Version - TAP syntax version token.</source>
          <target state="translated">TAP::Parser::Результат::Версия-токен версии синтаксиса TAP.</target>
        </trans-unit>
        <trans-unit id="0f318e8c966222dedab8b0415294cae97d5f4f64" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::YAML</source>
          <target state="translated">TAP::Parser::Result::YAML</target>
        </trans-unit>
        <trans-unit id="68efbf9d5d727c77c2280206016668c939f6f897" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::YAML - YAML result token.</source>
          <target state="translated">TAP::Парсер::Результат::YAML-YAML маркер результата.</target>
        </trans-unit>
        <trans-unit id="1a3c6d732b12248b1b6d9e14cf320584eb0a7af0" translate="yes" xml:space="preserve">
          <source>TAP::Parser::ResultFactory</source>
          <target state="translated">TAP::Parser::ResultFactory</target>
        </trans-unit>
        <trans-unit id="4f51e316d0426f94634c75bc33e9099d8d304e39" translate="yes" xml:space="preserve">
          <source>TAP::Parser::ResultFactory - Factory for creating TAP::Parser output objects</source>
          <target state="translated">TAP::Парсер::РезультатФабрика-Фабрика для создания TAP::Объекты вывода парсера</target>
        </trans-unit>
        <trans-unit id="50d7a126914ae0138b7bdc512d9ccd5a5d77784d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler</source>
          <target state="translated">TAP::Parser::Scheduler</target>
        </trans-unit>
        <trans-unit id="6da57a5308e690ad2cdb39023741e3d016f8b96b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler - Schedule tests during parallel testing</source>
          <target state="translated">TAP::Парсер::Планировщик-Расписание тестов при параллельном тестировании</target>
        </trans-unit>
        <trans-unit id="81a373608790f502b94224968ea5fc04bfbb7622" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Job</source>
          <target state="translated">TAP::Parser::Scheduler::Job</target>
        </trans-unit>
        <trans-unit id="657d2fb895dc4c666b37510d12e2199629196955" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Job - A single testing job.</source>
          <target state="translated">TAP::Парсер::Планировщик::Работа-одно тестовое задание.</target>
        </trans-unit>
        <trans-unit id="5f18e879edab289da9e626ab0da6617557a360e9" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Spinner</source>
          <target state="translated">TAP::Parser::Scheduler::Spinner</target>
        </trans-unit>
        <trans-unit id="73c0394de64be963748b5ce71edfd4ac21a6b40d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Spinner - A no-op job.</source>
          <target state="translated">Планировщик::Спиннер-безработный.</target>
        </trans-unit>
        <trans-unit id="223a37f35fb2a759c5993cb7f97ef9683ee5bef9" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Source</source>
          <target state="translated">TAP::Parser::Source</target>
        </trans-unit>
        <trans-unit id="ba1432bca02f36d9b7eb2dec89d208a92989961b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Source - a TAP source &amp;amp; meta data about it</source>
          <target state="translated">TAP :: Parser :: Source - источник TAP и метаданные о нем</target>
        </trans-unit>
        <trans-unit id="f75366f8757d0c89dc67745e9e30ae921835fc92" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Reader</source>
          <target state="translated">TAP::Parser::YAMLish::Reader</target>
        </trans-unit>
        <trans-unit id="92a795f40e2bb73376fc045a4635f6fcf7d6a7de" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Reader - Read YAMLish data from iterator</source>
          <target state="translated">TAP::Парсер::YAMLish::Читатель-Чтение данных YAMLish из итератора</target>
        </trans-unit>
        <trans-unit id="08d78eef616ac71669e623449566134b1c6d4b77" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Writer</source>
          <target state="translated">TAP::Parser::YAMLish::Writer</target>
        </trans-unit>
        <trans-unit id="662f33223b14be1ce958a19abee31b207588ba54" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Writer - Write YAMLish data</source>
          <target state="translated">TAP::Парсер::YAMLish::Writer-Write YAMLish data</target>
        </trans-unit>
        <trans-unit id="20a7b118ffa37d6b7bbce47ab0257aa206e6a7b5" translate="yes" xml:space="preserve">
          <source>TBC: Remove the stringified coderef; while it provides a 'cookie' for each function rendered, the cookies used should be 1,2,3.. not a random hex-address. It also complicates string comparison of two different trees.</source>
          <target state="translated">TBC:Удалить строковую кодировку;хотя она и предоставляет &quot;куки&quot; для каждой отображаемой функции,используемые куки должны быть 1,2,3...а не случайным шестнадцатиричным адресом.Это также усложняет сравнение строк двух разных деревьев.</target>
        </trans-unit>
        <trans-unit id="75c76515695c04f9554f43d036ad1241bc04ca9e" translate="yes" xml:space="preserve">
          <source>TBC: a hookpoint (and an option to set it) for a user-supplied function to produce a banner appropriate for users needs. It's not ideal, because the rendering-state variables, which are a natural candidate for use in concise.t, are unavailable to the user.</source>
          <target state="translated">TBC:крюк-точка (и возможность ее установки)для предоставляемой пользователем функции для создания баннера,подходящего для нужд пользователя.Это не идеально,потому что переменные состояния рендеринга,которые являются естественным кандидатом для использования в сжатом виде,недоступны пользователю.</target>
        </trans-unit>
        <trans-unit id="ccb92559aac4354578ea22eca45f6544e0875e36" translate="yes" xml:space="preserve">
          <source>TCP Clients with IO::Socket</source>
          <target state="translated">TCP клиенты с IO::Socket</target>
        </trans-unit>
        <trans-unit id="90251fa6420d40cf40e1d413320c56543c05df3d" translate="yes" xml:space="preserve">
          <source>TCP Servers with IO::Socket</source>
          <target state="translated">TCP-серверы с IO::Socket</target>
        </trans-unit>
        <trans-unit id="5f3be0b4f564336745c1f56bb30fefa5d6b55f59" translate="yes" xml:space="preserve">
          <source>TCP32IP</source>
          <target state="translated">TCP32IP</target>
        </trans-unit>
        <trans-unit id="930107c72c67f45aa5652e4a9e00965774f7a294" translate="yes" xml:space="preserve">
          <source>TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ...</source>
          <target state="translated">TCP_CORK,TCP_KEEPALIVE,TCP_NODELAY,...</target>
        </trans-unit>
        <trans-unit id="f903b5ea6b01e57df921d11ccc31344fae1a17ad" translate="yes" xml:space="preserve">
          <source>TECHNICAL NOTES</source>
          <target state="translated">ТЕХНИЧЕСКИЕ АННОТАЦИИ</target>
        </trans-unit>
        <trans-unit id="b3db3af9a0e0243f28ed20fcc3b1d5d1faaafbb6" translate="yes" xml:space="preserve">
          <source>TERM</source>
          <target state="translated">TERM</target>
        </trans-unit>
        <trans-unit id="cfc996e2b0441d5f42e4bd8a622b4dd1b2f920a4" translate="yes" xml:space="preserve">
          <source>TERMCAP</source>
          <target state="translated">TERMCAP</target>
        </trans-unit>
        <trans-unit id="4baf6f46b36f22af80f6af8178fa1faa75a5a37d" translate="yes" xml:space="preserve">
          <source>TERMINOLOGY</source>
          <target state="translated">TERMINOLOGY</target>
        </trans-unit>
        <trans-unit id="201ab4b1fe261c4f44a8bfbbdafd62a7606acc46" translate="yes" xml:space="preserve">
          <source>TERMPATH</source>
          <target state="translated">TERMPATH</target>
        </trans-unit>
        <trans-unit id="feb84698a707a37aae3ea67dd9630a278a6ca8f5" translate="yes" xml:space="preserve">
          <source>TERTIARY METHODS</source>
          <target state="translated">ТРЕТИЧНЫЕ МЕТОДЫ</target>
        </trans-unit>
        <trans-unit id="16731ae62f4aed11f4e128609c52499c94df9c78" translate="yes" xml:space="preserve">
          <source>TEST ON CYGWIN</source>
          <target state="translated">ИСПЫТАНИЕ НА ЦИГВИНЕ</target>
        </trans-unit>
        <trans-unit id="e01006d91764e5a9b5b7e2fa6b5505255129d446" translate="yes" xml:space="preserve">
          <source>TEST STATUS</source>
          <target state="translated">КОНТРОЛЬНАЯ СТАТИСТИКА</target>
        </trans-unit>
        <trans-unit id="1aafa503ed48d02972e5772184ca513598703dbe" translate="yes" xml:space="preserve">
          <source>TEST TYPES</source>
          <target state="translated">ИСПЫТАТЕЛЬНЫЕ ТИПЫ</target>
        </trans-unit>
        <trans-unit id="cb73eb0155af5a3da3bb4a63646b40201ab650c4" translate="yes" xml:space="preserve">
          <source>TESTING</source>
          <target state="translated">TESTING</target>
        </trans-unit>
        <trans-unit id="942de0a9a9abe9fb219e796c9c0f10b53d3c6b67" translate="yes" xml:space="preserve">
          <source>TESTING FRAMEWORKS</source>
          <target state="translated">ИСПЫТАТЕЛЬНЫЕ СИСТЕМЫ</target>
        </trans-unit>
        <trans-unit id="04209ee7219637d26ee9cd4fa722493ca838116d" translate="yes" xml:space="preserve">
          <source>THANK YOU</source>
          <target state="translated">СПАСИБО</target>
        </trans-unit>
        <trans-unit id="ffa4516bffdd79480b0ffbea2e99e02675eb3752" translate="yes" xml:space="preserve">
          <source>THANKS</source>
          <target state="translated">THANKS</target>
        </trans-unit>
        <trans-unit id="506d81bed6d3b4fa9b202f8f107ea34d18c6fadf" translate="yes" xml:space="preserve">
          <source>THE .netrc FILE</source>
          <target state="translated">файл .netrc</target>
        </trans-unit>
        <trans-unit id="2462f7724da7788ea62fc114cce4eab4e3339b38" translate="yes" xml:space="preserve">
          <source>THE API INTERFACE</source>
          <target state="translated">API-ИНТЕРФЕЙС</target>
        </trans-unit>
        <trans-unit id="eb466ef85e05d613480bb98bc1553047a2722184" translate="yes" xml:space="preserve">
          <source>THE CALL_ FUNCTIONS</source>
          <target state="translated">ФУНКЦИИ CALL_</target>
        </trans-unit>
        <trans-unit id="db00699a00a64bd8eb4f11307ac364af2186b3b7" translate="yes" xml:space="preserve">
          <source>THE Math::BigInt API</source>
          <target state="translated">Математика::Большой API</target>
        </trans-unit>
        <trans-unit id="5bf87badf6e989985ca5cde31b10d699fd946122" translate="yes" xml:space="preserve">
          <source>THE PERL ENCODING API</source>
          <target state="translated">КОДИРОВКА API НА PERL</target>
        </trans-unit>
        <trans-unit id="2036c7632dcc8e78c342e25b215c2cd28f8d5b22" translate="yes" xml:space="preserve">
          <source>THE PERL MODULE LIBRARY</source>
          <target state="translated">БИБЛИОТЕКА МОДУЛЯ PERL</target>
        </trans-unit>
        <trans-unit id="a1c725e21d784bf655d9ab26a4cdce89326e975c" translate="yes" xml:space="preserve">
          <source>THE QUESTIONS</source>
          <target state="translated">ВОПРОСЫ.</target>
        </trans-unit>
        <trans-unit id="fb64ef2c36220a9cb84ef2e67b3a1343a0d67d4d" translate="yes" xml:space="preserve">
          <source>THE RULES OF SYS::SYSLOG</source>
          <target state="translated">ПРАВИЛА SYS::SYSLOG</target>
        </trans-unit>
        <trans-unit id="79e66f9682153b1fcc7f947e99f79c4de4e44b30" translate="yes" xml:space="preserve">
          <source>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</source>
          <target state="translated">ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ &quot;КАК ЕСТЬ&quot;,БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ,ЯВНЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ,ВКЛЮЧАЯ,НО НЕ ОГРАНИЧИВАЯСЬ ГАРАНТИЯМИ ТОВАРНОЙ ПРИГОДНОСТИ,ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ И НЕНАРУШЕНИЯ ПРАВ СОБСТВЕННОСТИ.НИ ПРИ КАКИХ ОБСТОЯТЕЛЬСТВАХ АВТОРЫ ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ ЗА ЛЮБЫЕ ПРЕТЕНЗИИ,УЩЕРБ ИЛИ ДРУГУЮ ОТВЕТСТВЕННОСТЬ,БУДЬ ТО В РАМКАХ КОНТРАКТА,ДЕЛИКТА ИЛИ ИНОГО,ВЫТЕКАЮЩИЕ ИЗ,ИЗ ИЛИ В СВЯЗИ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ ИЛИ ИСПОЛЬЗОВАНИЕМ ИЛИ ИНЫМИ СДЕЛКАМИ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ.</target>
        </trans-unit>
        <trans-unit id="6c98c15d2eefa5232f6a2b60310fc78bdae1017e" translate="yes" xml:space="preserve">
          <source>THE dataconn CLASS</source>
          <target state="translated">засекречивание данных</target>
        </trans-unit>
        <trans-unit id="472f09c67477280b91b7ae79efeb4fde13fbb523" translate="yes" xml:space="preserve">
          <source>THING</source>
          <target state="translated">THING</target>
        </trans-unit>
        <trans-unit id="2360380b4c35fa48f7e3a9f411a80f126b56989e" translate="yes" xml:space="preserve">
          <source>THINGS TO LOOK OUT FOR</source>
          <target state="translated">НА ЧТО НУЖНО ОБРАТИТЬ ВНИМАНИЕ</target>
        </trans-unit>
        <trans-unit id="584497c8a870243751bafe0429bbe1f5826e0915" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Instead, &lt;b&gt;Almost all code should use &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; or &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;&lt;/b&gt;.</source>
          <target state="translated">ДАННАЯ ФУНКЦИЯ ДОЛЖНА ИСПОЛЬЗОВАТЬСЯ ТОЛЬКО В ОЧЕНЬ СПЕЦИАЛИЗИРОВАННЫХ ОБСТОЯТЕЛЬСТВАХ. Вместо этого &lt;b&gt;почти весь код должен использовать &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; или &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="331b8f63effc7e7d25ea524ca1aa92004125d86f" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Most code should use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;() rather than call this directly.</source>
          <target state="translated">ЭТА ФУНКЦИЯ ДОЛЖНА ИСПОЛЬЗОВАТЬСЯ ТОЛЬКО В ОЧЕНЬ СПЕЦИАЛИЗИРОВАННЫХ ОБСТОЯТЕЛЬСТВАХ. Большая часть кода должна использовать &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; (), а не вызывать ее напрямую.</target>
        </trans-unit>
        <trans-unit id="897ebd5219f0c5caa208699bd4713ae3b784c6e0" translate="yes" xml:space="preserve">
          <source>THREAD CONTEXT</source>
          <target state="translated">ТРЁХСТОРОННИЙ КОНТРАКТ</target>
        </trans-unit>
        <trans-unit id="54e59b7bc3a2e96489d360a7b538367313e355dc" translate="yes" xml:space="preserve">
          <source>THREAD SIGNALLING</source>
          <target state="translated">РЕЗЬБОВАЯ СИГНАЛИЗАЦИЯ</target>
        </trans-unit>
        <trans-unit id="60b08b8acc7a625b8f0d9d41c7e2c28fbb134428" translate="yes" xml:space="preserve">
          <source>THREAD STACK SIZE</source>
          <target state="translated">РАЗМЕР ШТАБЕЛЯ РЕЗЬБЫ</target>
        </trans-unit>
        <trans-unit id="577fa2796ff34704e76d7424a53614775f345523" translate="yes" xml:space="preserve">
          <source>THREAD STATE</source>
          <target state="translated">ТРИДИЧЕСКОЕ ГОСУДАРСТВО</target>
        </trans-unit>
        <trans-unit id="bf2767662599be6d02741631f5d4e162d0241086" translate="yes" xml:space="preserve">
          <source>THREAD SUPPORT</source>
          <target state="translated">ТРЁХСТУПЕНЧАТАЯ ПОДДЕРЖКА</target>
        </trans-unit>
        <trans-unit id="f8c7150e13e8ea5e3603e546c189035146b726df" translate="yes" xml:space="preserve">
          <source>THREADS</source>
          <target state="translated">THREADS</target>
        </trans-unit>
        <trans-unit id="f266b9c4765272a11c0ed3c20127bf1d201638dd" translate="yes" xml:space="preserve">
          <source>TIEHANDLE by Sven Verdoolaege &amp;lt;</source>
          <target state="translated">TIEHANDLE от Свена Вердоолэге &amp;lt;</target>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="6c2529a2a2e078590190100f8e1c4972e8846bc5" translate="yes" xml:space="preserve">
          <source>TIME is</source>
          <target state="translated">ВРЕМЯ</target>
        </trans-unit>
        <trans-unit id="6409a515d9fc80e579966498117e7281bd8b98a0" translate="yes" xml:space="preserve">
          <source>TMP or TEMP</source>
          <target state="translated">TMP или TEMP</target>
        </trans-unit>
        <trans-unit id="47bd70df0e55aba216736b1db7710c6478ab9cbf" translate="yes" xml:space="preserve">
          <source>TO DO</source>
          <target state="translated">ДО</target>
        </trans-unit>
        <trans-unit id="f8953b7e0e4beba3861ba1d10ca937f8f20fdfee" translate="yes" xml:space="preserve">
          <source>TO DO (maybe)</source>
          <target state="translated">Сделать это (возможно)</target>
        </trans-unit>
        <trans-unit id="b698c11e84460ed5999bfeb5cbf25b865c238f3c" translate="yes" xml:space="preserve">
          <source>TODO</source>
          <target state="translated">TODO</target>
        </trans-unit>
        <trans-unit id="14081c923a6df4129e72afd1550fb67ed4989fb1" translate="yes" xml:space="preserve">
          <source>TODO all (most?) accessorized methods</source>
          <target state="translated">Все (большинство?)аксессуарные методы.</target>
        </trans-unit>
        <trans-unit id="bac7481b99347a289b8d37ae17bf40d2f44f1514" translate="yes" xml:space="preserve">
          <source>TODO tests are designed for maintaining an &lt;b&gt;executable TODO list&lt;/b&gt;. These tests are</source>
          <target state="translated">TODO-тесты предназначены для поддержки &lt;b&gt;исполняемого списка TODO&lt;/b&gt; . Эти тесты</target>
        </trans-unit>
        <trans-unit id="fd32d0b7a9d317be835f0befd340eb49cf589cff" translate="yes" xml:space="preserve">
          <source>TODO, see &lt;a href=&quot;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&quot;&gt;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&lt;/a&gt;</source>
          <target state="translated">TODO, см. &lt;a href=&quot;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&quot;&gt;Http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="643a0382045e00a908788587a0d4b6d602741dc9" translate="yes" xml:space="preserve">
          <source>TODO: An example or two of =extend, then point to Pod::Simple::Subclassing</source>
          <target state="translated">TODO:Пример или два из =extend,затем укажите на Pod::Simple::Subclassing</target>
        </trans-unit>
        <trans-unit id="b95da2f919c7ccb270ebcfb13598d7d2d8b6a01a" translate="yes" xml:space="preserve">
          <source>TODO: Document this</source>
          <target state="translated">ТДО:Задокументируйте это</target>
        </trans-unit>
        <trans-unit id="26dbb18df63ed25641cd65981a2bd8abf41c6420" translate="yes" xml:space="preserve">
          <source>TODO: Document those cases.</source>
          <target state="translated">Задокументируйте эти случаи.</target>
        </trans-unit>
        <trans-unit id="503edd260136cc51f7d583a68da986091421e06f" translate="yes" xml:space="preserve">
          <source>TODO: a corpus of sample Pod input and HTML output? Or common idioms?</source>
          <target state="translated">TODO:корпус примеров Pod-ввода и HTML-вывода? Или общие идиомы?</target>
        </trans-unit>
        <trans-unit id="767b9b1886f65db5d2c2efe4d311ec16282ddf3e" translate="yes" xml:space="preserve">
          <source>TOTAL RESULTS</source>
          <target state="translated">ИТОГО РЕЗУЛЬТАТЫ</target>
        </trans-unit>
        <trans-unit id="6168d5c87ca259972f2a01ffcfd10f094db6e548" translate="yes" xml:space="preserve">
          <source>TRANSFORMATION FORMATS</source>
          <target state="translated">ФОРМАТЫ ПРЕОБРАЗОВАНИЯ</target>
        </trans-unit>
        <trans-unit id="08e80e877114a02316e2a85c727dc2ec2e8d050b" translate="yes" xml:space="preserve">
          <source>TRANSLATIONS</source>
          <target state="translated">TRANSLATIONS</target>
        </trans-unit>
        <trans-unit id="881efc13a4ce5c9b7f10acdee48bdf35dab16bcd" translate="yes" xml:space="preserve">
          <source>TREE-BASED PARSING</source>
          <target state="translated">ДРЕВОВИДНЫЙ АНАЛИЗ</target>
        </trans-unit>
        <trans-unit id="55c5fdc09a5315c1ab2a4b0b8470a49a53936b60" translate="yes" xml:space="preserve">
          <source>TRIGONOMETRIC FUNCTIONS</source>
          <target state="translated">ТРИГОНОМЕТРИЧЕСКИЕ ФУНКЦИИ</target>
        </trans-unit>
        <trans-unit id="d814d3e7d55ad64b9a68fdab60bd5741a6c86453" translate="yes" xml:space="preserve">
          <source>TUTORIAL</source>
          <target state="translated">TUTORIAL</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="40ea9041285003e004a8f6fe2dd14ebb07961af2" translate="yes" xml:space="preserve">
          <source>TYPES</source>
          <target state="translated">TYPES</target>
        </trans-unit>
        <trans-unit id="3409e584f0822b2e9f6e17cf539649bef61e2695" translate="yes" xml:space="preserve">
          <source>T_OPAQUE supports input and output of simple types. T_OPAQUEPTR can be used to pass these bytes back into C if a pointer is acceptable.</source>
          <target state="translated">T_OPAQUE поддерживает ввод и вывод простых типов.T_OPAQUEPTR может использоваться для передачи этих байт обратно в C,если указатель является допустимым.</target>
        </trans-unit>
        <trans-unit id="2acdc87aba62301b1c46833bbb0d8a2ab24b5d4c" translate="yes" xml:space="preserve">
          <source>T_PACKEDARRAY is similar to T_PACKED. In fact, the &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) typemap is identical, but the &lt;code&gt;OUTPUT&lt;/code&gt; typemap passes an additional argument to the &lt;code&gt;XS_pack_$ntype&lt;/code&gt; function. This third parameter indicates the number of elements in the output so that the function can handle C arrays sanely. The variable needs to be declared by the user and must have the name &lt;code&gt;count_$ntype&lt;/code&gt; where &lt;code&gt;$ntype&lt;/code&gt; is the normalized C type name as explained above. The signature of the function would be for the example above and &lt;code&gt;foo_t **&lt;/code&gt; :</source>
          <target state="translated">T_PACKEDARRAY похож на T_PACKED. Фактически, карта типов &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) идентична, но карта типов &lt;code&gt;OUTPUT&lt;/code&gt; передает дополнительный аргумент функции &lt;code&gt;XS_pack_$ntype&lt;/code&gt; . Этот третий параметр указывает количество элементов в выводе, чтобы функция могла нормально обрабатывать массивы C. Переменная должна быть объявлена ​​пользователем и иметь имя &lt;code&gt;count_$ntype&lt;/code&gt; где &lt;code&gt;$ntype&lt;/code&gt; - это нормализованное имя типа C, как описано выше. Сигнатура функции будет для примера выше и &lt;code&gt;foo_t **&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f31b217f3c82ab68ac7452146830667f22ddb6a9" translate="yes" xml:space="preserve">
          <source>T_U_LONG is used for type &lt;code&gt;U32&lt;/code&gt; in the standard typemap.</source>
          <target state="translated">T_U_LONG используется для типа &lt;code&gt;U32&lt;/code&gt; в стандартной карте типов.</target>
        </trans-unit>
        <trans-unit id="067c0c90742a514deacd491758ccd4ba0e1d9275" translate="yes" xml:space="preserve">
          <source>T_U_SHORT is used for type &lt;code&gt;U16&lt;/code&gt; in the standard typemap.</source>
          <target state="translated">T_U_SHORT используется для типа &lt;code&gt;U16&lt;/code&gt; в стандартной карте типов.</target>
        </trans-unit>
        <trans-unit id="267d7ded4fb1f4fe830b757c69adcb120de3c36c" translate="yes" xml:space="preserve">
          <source>Table in hex, sorted in 1047 order</source>
          <target state="translated">Таблица в шестнадцатеричной форме,отсортированная в порядке 1047.</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">Содержание</target>
        </trans-unit>
        <trans-unit id="f6f2ebfa1ea92516cffdbcabbc226ad6201fc14f" translate="yes" xml:space="preserve">
          <source>Tag Handling Utility Functions</source>
          <target state="translated">Функции обработки меток утилита</target>
        </trans-unit>
        <trans-unit id="8a6299767c14d608575e773d7c250b1dd1bef09f" translate="yes" xml:space="preserve">
          <source>Tags and names for human languages</source>
          <target state="translated">Теги и имена для человеческих языков</target>
        </trans-unit>
        <trans-unit id="0caddaacf6ffdd3b4a1f2e6c28c9c60f84fe10e3" translate="yes" xml:space="preserve">
          <source>Tags for the Identification of Languages</source>
          <target state="translated">Метки для идентификации языков</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
