<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="883c9501bfde5d52c5604a1b12447c3d9a8fe23c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has the bit &lt;code&gt;RV2CVOPCV_MARK_EARLY&lt;/code&gt; set, then the handling of a GV reference is modified. If a GV was examined and its CV slot was found to be empty, then the &lt;code&gt;gv&lt;/code&gt; op has the &lt;code&gt;OPpEARLY_CV&lt;/code&gt; flag set. If the op is not optimised away, and the CV slot is later populated with a subroutine having a prototype, that flag eventually triggers the warning &quot;called too early to check prototype&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ba87252f4445bc6642c895685a2b0c13a4c9f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has the bit &lt;code&gt;RV2CVOPCV_RETURN_NAME_GV&lt;/code&gt; set, then instead of returning a pointer to the subroutine it returns a pointer to the GV giving the most appropriate name for the subroutine in this context. Normally this is just the &lt;code&gt;CvGV&lt;/code&gt; of the subroutine, but for an anonymous (&lt;code&gt;CvANON&lt;/code&gt;) subroutine that is referenced through a GV it will be the referencing GV. The resulting &lt;code&gt;GV*&lt;/code&gt; is cast to &lt;code&gt;CV*&lt;/code&gt; to be returned. A null pointer is returned as usual if there is no statically-determinable subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="242a2d0b6758ae9991c2578558a99b10e3dde258" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; in non-zero, it can be any combination of the &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; flags accepted by &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;, and with the same meanings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ac1f6f577ac784401bb8130dc871e9c34ad1b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is 0, any well-formed UTF-8, as extended by Perl, is accepted without restriction. If the final few bytes of the buffer do not form a complete code point, this will return TRUE anyway, provided that &lt;code&gt;&lt;a href=&quot;#is_utf8_valid_partial_char_flags&quot;&gt;&quot;is_utf8_valid_partial_char_flags&quot;&lt;/a&gt;&lt;/code&gt; returns TRUE for them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23848029d478b456b26bba2286d77574bebc75c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is 0, this behaves identically to &lt;code&gt;&lt;a href=&quot;#is_utf8_valid_partial_char&quot;&gt;&quot;is_utf8_valid_partial_char&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise &lt;code&gt;flags&lt;/code&gt; can be any combination of the &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; flags accepted by &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;. If there is any sequence of bytes that can complete the input partial character in such a way that a non-prohibited character is formed, the function returns TRUE; otherwise FALSE. Non character code points cannot be determined based on partial character input. But many of the other possible excluded types can be determined from just the first one or two bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7776c59483454fdc128e37c2b654f9e899314281" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is 0, this function accepts any code point from 0..&lt;code&gt;IV_MAX&lt;/code&gt; as input. &lt;code&gt;IV_MAX&lt;/code&gt; is typically 0x7FFF_FFFF in a 32-bit word.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e5eab05bd09c8fe9f56a01b844bac5e3765d28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is 0, this gives the same results as &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt;; if &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt;, this gives the same results as &lt;code&gt;&lt;a href=&quot;#isSTRICT_UTF8_CHAR&quot;&gt;&quot;isSTRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt;; and if &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&lt;/code&gt;, this gives the same results as &lt;code&gt;&lt;a href=&quot;#isC9_STRICT_UTF8_CHAR&quot;&gt;&quot;isC9_STRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise &lt;code&gt;flags&lt;/code&gt; may be any combination of the &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; flags understood by &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;, with the same meanings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01ee327fde250472c539a32455541306b4bc120" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is 0, this gives the same results as &lt;code&gt;&lt;a href=&quot;#is_utf8_string&quot;&gt;&quot;is_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;; if &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt;, this gives the same results as &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string&quot;&gt;&quot;is_strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;; and if &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&lt;/code&gt;, this gives the same results as &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string&quot;&gt;&quot;is_c9strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise &lt;code&gt;flags&lt;/code&gt; may be any combination of the &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; flags understood by &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;, with the same meanings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef48bc44bf4f8b7aeee22cccd386b0d4dcfb8f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;frame &amp;amp; 4&lt;/code&gt; , arguments to functions are printed, plus context and caller info. If &lt;code&gt;frame &amp;amp; 8&lt;/code&gt; , overloaded &lt;code&gt;stringify&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;d &lt;code&gt;FETCH&lt;/code&gt; is enabled on the printed arguments. If &lt;code&gt;frame
&amp;amp; 16&lt;/code&gt; , the return value from the subroutine is printed.</source>
          <target state="translated">Если &lt;code&gt;frame &amp;amp; 4&lt;/code&gt; , выводятся аргументы функций, а также контекст и информация о вызывающем. Если &lt;code&gt;frame &amp;amp; 8&lt;/code&gt; , для напечатанных аргументов включен перегруженный &lt;code&gt;stringify&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; d &lt;code&gt;FETCH&lt;/code&gt; . Если &lt;code&gt;frame &amp;amp; 16&lt;/code&gt; , печатается возвращаемое значение из подпрограммы.</target>
        </trans-unit>
        <trans-unit id="f6ef7c333faaf2cb26f8747450c37161f8d75370" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;frame &amp;amp; 4&lt;/code&gt;, arguments to functions are printed, plus context and caller info. If &lt;code&gt;frame &amp;amp; 8&lt;/code&gt;, overloaded &lt;code&gt;stringify&lt;/code&gt; and &lt;code&gt;tie&lt;/code&gt;d &lt;code&gt;FETCH&lt;/code&gt; is enabled on the printed arguments. If &lt;code&gt;frame &amp;amp; 16&lt;/code&gt;, the return value from the subroutine is printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54e3981c02655a1fab1a806eaa02120a0c9bfed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;function&lt;/code&gt; was the name of a function, then &lt;code&gt;memoize&lt;/code&gt; hides the old version and installs the new memoized version under the old name, so that &lt;code&gt;&amp;amp;function(...)&lt;/code&gt; actually invokes the memoized version.</source>
          <target state="translated">Если &lt;code&gt;function&lt;/code&gt; была именем функции, то &lt;code&gt;memoize&lt;/code&gt; скрывает старую версию и устанавливает новую мемоизированную версию под старым именем, так что &lt;code&gt;&amp;amp;function(...)&lt;/code&gt; фактически вызывает мемоизированную версию.</target>
        </trans-unit>
        <trans-unit id="4823580da2e2f493ed7ea495228a6fb43531c2a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;get_handle&lt;/code&gt; senses that it's running in program that was invoked as a CGI, then it tries to get language-tags out of the environment variable &quot;HTTP_ACCEPT_LANGUAGE&quot;, and it pretends that those were the languages passed as parameters to &lt;code&gt;get_handle&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;get_handle&lt;/code&gt; определяет, что он запущен в программе, которая была вызвана как CGI, тогда он пытается получить языковые теги из переменной среды &amp;laquo;HTTP_ACCEPT_LANGUAGE&amp;raquo; и делает вид, что это были языки, переданные в качестве параметров для &lt;code&gt;get_handle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8f1bd59bcb9836018bddcc2b5f32a734b99099" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;get_handle&lt;/code&gt; senses that it's running in program that was invoked as a CGI, then it tries to get language-tags out of the environment variable &quot;HTTP_ACCEPT_LANGUAGE&quot;, and it pretends that those were the languages passed as parameters to &lt;code&gt;get_handle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5501c614e6eee43f2f2b50112bdb8a824a2fea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a completely empty typeglob, it is deleted from the stash.</source>
          <target state="translated">Если &lt;code&gt;gv&lt;/code&gt; - полностью пустой typeglob, он удаляется из тайника.</target>
        </trans-unit>
        <trans-unit id="171c792393c3bd16ce8492fbf51df1d34df47fa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a typeglob containing only a sufficiently-ordinary constant sub, the typeglob is replaced with a scalar-reference placeholder that more compactly represents the same thing.</source>
          <target state="translated">Если &lt;code&gt;gv&lt;/code&gt; - это typeglob, содержащий только достаточно обычный константный sub, typeglob заменяется заполнителем скалярной ссылки, который более компактно представляет то же самое.</target>
        </trans-unit>
        <trans-unit id="91c336e511b07c506517b1f2fbdfac89a7b69625" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a typeglob whose subroutine entry is a constant sub eligible for inlining, or &lt;code&gt;gv&lt;/code&gt; is a placeholder reference that would be promoted to such a typeglob, then returns the value returned by the sub. Otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15863e2e3bcfe9bf34415295eb886e40c8b84a73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a typeglob whose subroutine entry is a constant sub eligible for inlining, or &lt;code&gt;gv&lt;/code&gt; is a placeholder reference that would be promoted to such a typeglob, then returns the value returned by the sub. Otherwise, returns NULL.</source>
          <target state="translated">Если &lt;code&gt;gv&lt;/code&gt; - это typeglob, запись подпрограммы которого является константой sub, подходящей для встраивания, или &lt;code&gt;gv&lt;/code&gt; - это ссылка-заполнитель, которая будет повышена до такого typeglob, то возвращает значение, возвращаемое подпрограммой. В противном случае возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="5b76926b7fe43456ac634077129deadebe6d1749" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignoreName&lt;/code&gt; or &lt;code&gt;undefName&lt;/code&gt; is used, character names should be specified as a comment (following &lt;code&gt;#&lt;/code&gt; ) on each line.</source>
          <target state="translated">Если используется &lt;code&gt;ignoreName&lt;/code&gt; или &lt;code&gt;undefName&lt;/code&gt; , имена символов должны быть указаны в виде комментария (после &lt;code&gt;#&lt;/code&gt; ) в каждой строке.</target>
        </trans-unit>
        <trans-unit id="c67ec45488470986d50d9732fc06ac7df6e89db8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignoreName&lt;/code&gt; or &lt;code&gt;undefName&lt;/code&gt; is used, character names should be specified as a comment (following &lt;code&gt;#&lt;/code&gt;) on each line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606bfb04b8810dddbc165299090455517c6f31d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is 0, it will be calculated using &lt;code&gt;strlen(s)&lt;/code&gt; , (which means if you use this option, that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; can't have embedded &lt;code&gt;NUL&lt;/code&gt; characters and has to have a terminating &lt;code&gt;NUL&lt;/code&gt; byte).</source>
          <target state="translated">Если &lt;code&gt;len&lt;/code&gt; является 0, то будет рассчитываться с использованием &lt;code&gt;strlen(s)&lt;/code&gt; , (что означает , если вы используете эту опцию, то &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; не может иметь встроенную &lt;code&gt;NUL&lt;/code&gt; символов и должен иметь завершающее &lt;code&gt;NUL&lt;/code&gt; байт).</target>
        </trans-unit>
        <trans-unit id="35a8aa529d970b1105047bbf5eb8254c1640c25a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is 0, it will be calculated using &lt;code&gt;strlen(s)&lt;/code&gt;, (which means if you use this option, that &lt;code&gt;s&lt;/code&gt; can't have embedded &lt;code&gt;NUL&lt;/code&gt; characters and has to have a terminating &lt;code&gt;NUL&lt;/code&gt; byte).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="564f6927aa67faeb8390b79eb296fc0609382f07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;list_archive()&lt;/code&gt; is passed an array reference as its third argument it returns a list of hash references containing the requested properties of each file. The following list of properties is supported: full_path, name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type.</source>
          <target state="translated">Если &lt;code&gt;list_archive()&lt;/code&gt; передается ссылка на массив в качестве третьего аргумента, он возвращает список хеш-ссылок, содержащих запрошенные свойства каждого файла. Поддерживается следующий список свойств: full_path, name, size, mtime (дата последнего изменения), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type.</target>
        </trans-unit>
        <trans-unit id="30b6892ba87f6c10d6419b32b55f7a86419b6ce9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;list_files()&lt;/code&gt; is passed an array reference as its first argument it returns a list of hash references containing the requested properties of each file. The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix.</source>
          <target state="translated">Если &lt;code&gt;list_files()&lt;/code&gt; передается ссылка на массив в качестве первого аргумента, он возвращает список хеш-ссылок, содержащий запрошенные свойства каждого файла. Поддерживается следующий список свойств: name, size, mtime (дата последнего изменения), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix.</target>
        </trans-unit>
        <trans-unit id="6b6ca16484970453642612331b9f95d68983da46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;make_path&lt;/code&gt; or &lt;code&gt;remove_tree&lt;/code&gt; encounter an error, a diagnostic message will be printed to &lt;code&gt;STDERR&lt;/code&gt; via &lt;code&gt;carp&lt;/code&gt; (for non-fatal errors), or via &lt;code&gt;croak&lt;/code&gt; (for fatal errors).</source>
          <target state="translated">Если &lt;code&gt;make_path&lt;/code&gt; или &lt;code&gt;remove_tree&lt;/code&gt; обнаруживают ошибку, диагностическое сообщение будет напечатано в &lt;code&gt;STDERR&lt;/code&gt; через &lt;code&gt;carp&lt;/code&gt; (для нефатальных ошибок) или через &lt;code&gt;croak&lt;/code&gt; (для фатальных ошибок).</target>
        </trans-unit>
        <trans-unit id="c1dea29744b11722e865e983de60cdb68d486715" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;make_path&lt;/code&gt; or &lt;code&gt;remove_tree&lt;/code&gt; encounters an error, a diagnostic message will be printed to &lt;code&gt;STDERR&lt;/code&gt; via &lt;code&gt;carp&lt;/code&gt; (for non-fatal errors) or via &lt;code&gt;croak&lt;/code&gt; (for fatal errors).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12005256b82b7dbf15e43b617aa6446b9ea3caa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;merge&lt;/code&gt; is true the harness will create parsers that merge STDOUT and STDERR together for any processes they start.</source>
          <target state="translated">Если &lt;code&gt;merge&lt;/code&gt; истинно, жгут создаст парсеры, которые объединяют STDOUT и STDERR вместе для любых процессов, которые они запускают.</target>
        </trans-unit>
        <trans-unit id="a65b7746a43b203ecde7cf3199ef2365227c5212" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is null then the subroutine will be anonymous, with its &lt;code&gt;CvGV&lt;/code&gt; referring to an &lt;code&gt;__ANON__&lt;/code&gt; glob. If &lt;code&gt;name&lt;/code&gt; is non-null then the subroutine will be named accordingly, referenced by the appropriate glob. &lt;code&gt;name&lt;/code&gt; is a string of length &lt;code&gt;len&lt;/code&gt; bytes giving a sigilless symbol name, in UTF-8 if &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SVf_UTF8&lt;/code&gt; bit set and in Latin-1 otherwise. The name may be either qualified or unqualified, with the stash defaulting in the same manner as for &lt;code&gt;gv_fetchpvn_flags&lt;/code&gt;. &lt;code&gt;flags&lt;/code&gt; may contain flag bits understood by &lt;code&gt;gv_fetchpvn_flags&lt;/code&gt; with the same meaning as they have there, such as &lt;code&gt;GV_ADDWARN&lt;/code&gt;. The symbol is always added to the stash if necessary, with &lt;code&gt;GV_ADDMULTI&lt;/code&gt; semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab07e7506173a92d684e99bcaa1a4031e98f0c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is null then the subroutine will be anonymous, with its &lt;code&gt;CvGV&lt;/code&gt; referring to an &lt;code&gt;__ANON__&lt;/code&gt; glob. If &lt;code&gt;name&lt;/code&gt; is non-null then the subroutine will be named accordingly, referenced by the appropriate glob. &lt;code&gt;name&lt;/code&gt; is a string of length &lt;code&gt;len&lt;/code&gt; bytes giving a sigilless symbol name, in UTF-8 if &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SVf_UTF8&lt;/code&gt; bit set and in Latin-1 otherwise. The name may be either qualified or unqualified. If the name is unqualified then it defaults to being in the stash specified by &lt;code&gt;stash&lt;/code&gt; if that is non-null, or to &lt;code&gt;PL_curstash&lt;/code&gt; if &lt;code&gt;stash&lt;/code&gt; is null. The symbol is always added to the stash if necessary, with &lt;code&gt;GV_ADDMULTI&lt;/code&gt; semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a417a1f8bba03650439d46556e6b5e2f42cdc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;namlen&lt;/code&gt; is greater than zero then a &lt;code&gt;savepvn&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;namlen&lt;/code&gt; больше нуля, тогда &lt;code&gt;savepvn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a5b4f60a5261a12c3ad5e79f21f3b4cceb3007ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new()&lt;/code&gt; is invoked with arguments and the &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; method fails for any reason, &lt;code&gt;new()&lt;/code&gt; returns undef.</source>
          <target state="translated">Если &lt;code&gt;new()&lt;/code&gt; вызывается с аргументами, а метод &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; не работает по какой-либо причине, &lt;code&gt;new()&lt;/code&gt; возвращает undef.</target>
        </trans-unit>
        <trans-unit id="7cef9a9221becdc1b22f8b33e94c433da6581c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new()&lt;/code&gt; is invoked with arguments and the &lt;code&gt;read()&lt;/code&gt; method fails for any reason, &lt;code&gt;new()&lt;/code&gt; returns undef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33de51c2b233ea7368e7ccccf568c1e624835ecc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;o&lt;/code&gt; is null, the state op is returned. Otherwise the state op is combined with &lt;code&gt;o&lt;/code&gt; into a &lt;code&gt;lineseq&lt;/code&gt; list op, which is returned. &lt;code&gt;o&lt;/code&gt; is consumed by this function and becomes part of the returned op tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c8f13fd0a4ec2abf65b26b0dde9b71cbc468dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;o_is_gv&lt;/code&gt; is false and &lt;code&gt;o&lt;/code&gt; is null, then the subroutine will be anonymous. If &lt;code&gt;o_is_gv&lt;/code&gt; is false and &lt;code&gt;o&lt;/code&gt; is non-null, then &lt;code&gt;o&lt;/code&gt; must point to a &lt;code&gt;const&lt;/code&gt; op, which will be consumed by this function, and its string value supplies a name for the subroutine. The name may be qualified or unqualified, and if it is unqualified then a default stash will be selected in some manner. If &lt;code&gt;o_is_gv&lt;/code&gt; is true, then &lt;code&gt;o&lt;/code&gt; doesn't point to an &lt;code&gt;OP&lt;/code&gt; at all, but is instead a cast pointer to a &lt;code&gt;GV&lt;/code&gt; by which the subroutine will be named.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf32c805e2ddc81931fd2560a08109645dce7e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optype&lt;/code&gt; is &lt;code&gt;OP_ANDASSIGN&lt;/code&gt;, &lt;code&gt;OP_ORASSIGN&lt;/code&gt;, or &lt;code&gt;OP_DORASSIGN&lt;/code&gt;, then a suitable conditional optree is constructed. If &lt;code&gt;optype&lt;/code&gt; is the opcode of a binary operator, such as &lt;code&gt;OP_BIT_OR&lt;/code&gt;, then an op is constructed that performs the binary operation and assigns the result to the left argument. Either way, if &lt;code&gt;optype&lt;/code&gt; is non-zero then &lt;code&gt;flags&lt;/code&gt; has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ecad3c0cc7408f92e26472fcb7141e48a993e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optype&lt;/code&gt; is zero, then a plain scalar or list assignment is constructed. Which type of assignment it is is automatically determined. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;, except that &lt;code&gt;OPf_KIDS&lt;/code&gt; will be set automatically, and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt;, except that the bit with value 1 or 2 is automatically set as required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b4ce4ab1caa8905ea03f71030c64a0c404abbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pass_through&lt;/code&gt; is also enabled, options processing will terminate at the first unrecognized option, or non-option, whichever comes first.</source>
          <target state="translated">Если &lt;code&gt;pass_through&lt;/code&gt; также включен, обработка параметров будет прекращена при первом нераспознанном параметре или при отсутствии параметра, в зависимости от того, что наступит раньше.</target>
        </trans-unit>
        <trans-unit id="9243fb188fd78661a99b6e8ffc13a07c0c193e45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pe1&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt; and the pointer it points to is not &lt;code&gt;NULL&lt;/code&gt;, that pointer is considered an end pointer to the position 1 byte past the maximum point in &lt;code&gt;s1&lt;/code&gt; beyond which scanning will not continue under any circumstances. (This routine assumes that UTF-8 encoded input strings are not malformed; malformed input can cause it to read past &lt;code&gt;pe1&lt;/code&gt;). This means that if both &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;pe1&lt;/code&gt; are specified, and &lt;code&gt;pe1&lt;/code&gt; is less than &lt;code&gt;s1&lt;/code&gt;+&lt;code&gt;l1&lt;/code&gt;, the match will never be successful because it can never get as far as its goal (and in fact is asserted against). Correspondingly for &lt;code&gt;pe2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c02b449190a1b90198a28e96aea10bbc105c7788" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pe1&lt;/code&gt; is non-NULL and the pointer it points to is not NULL, that pointer is considered an end pointer to the position 1 byte past the maximum point in &lt;code&gt;s1&lt;/code&gt; beyond which scanning will not continue under any circumstances. (This routine assumes that UTF-8 encoded input strings are not malformed; malformed input can cause it to read past &lt;code&gt;pe1&lt;/code&gt; ). This means that if both &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;pe1&lt;/code&gt; are specified, and &lt;code&gt;pe1&lt;/code&gt; is less than &lt;code&gt;s1&lt;/code&gt; +&lt;code&gt;l1&lt;/code&gt; , the match will never be successful because it can never get as far as its goal (and in fact is asserted against). Correspondingly for &lt;code&gt;pe2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;pe1&lt;/code&gt; не равно NULL и указатель, на который он указывает, не равен NULL, этот указатель считается конечным указателем на позицию на 1 байт после максимальной точки в &lt;code&gt;s1&lt;/code&gt; , после которой сканирование не будет продолжено ни при каких обстоятельствах. (В этой подпрограмме предполагается, что входные строки в кодировке UTF-8 не имеют неправильного формата; искаженный ввод может привести к тому, что они будут читать после &lt;code&gt;pe1&lt;/code&gt; ). Это означает, что если указаны как &lt;code&gt;l1&lt;/code&gt; ,так и &lt;code&gt;pe1&lt;/code&gt; , а &lt;code&gt;pe1&lt;/code&gt; меньше &lt;code&gt;s1&lt;/code&gt; + &lt;code&gt;l1&lt;/code&gt; , совпадение никогда не будет успешным, потому что оно никогда не сможет достичь своей цели (и фактически утверждается против). Соответственно для &lt;code&gt;pe2&lt;/code&gt; по &lt;code&gt;s2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5414852c94de9d937514c7b2ffd918737261abd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;permute&lt;/code&gt; is enabled, this means that</source>
          <target state="translated">Если &lt;code&gt;permute&lt;/code&gt; включена, это означает, что</target>
        </trans-unit>
        <trans-unit id="e47709e624b959c659a6f5424e397b7429bd08c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preprocess&lt;/code&gt; and/or &lt;code&gt;normalization&lt;/code&gt; is applied, the code points of the string after them (in NFD by default) are used.</source>
          <target state="translated">Если применяется &lt;code&gt;preprocess&lt;/code&gt; и / или &lt;code&gt;normalization&lt;/code&gt; , используются кодовые точки строки после них (в NFD по умолчанию).</target>
        </trans-unit>
        <trans-unit id="c7a3e0b813ddb5c552aec4199fd49e48847ff2c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prompt()&lt;/code&gt; detects that it is not running interactively and there is nothing on STDIN or if the PERL_MM_USE_DEFAULT environment variable is set to true, the $default will be used without prompting. This prevents automated processes from blocking on user input.</source>
          <target state="translated">Если &lt;code&gt;prompt()&lt;/code&gt; обнаруживает, что он не работает в интерактивном режиме и на STDIN ничего нет, или если для переменной среды PERL_MM_USE_DEFAULT установлено значение true, значение $ default будет использоваться без запроса. Это предотвращает блокировку автоматизированных процессов при вводе пользователем.</target>
        </trans-unit>
        <trans-unit id="9d8185228e8e06faca877b9d0926aab5904e951a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;require_order&lt;/code&gt; is enabled, options processing terminates when the first non-option is encountered.</source>
          <target state="translated">Если &lt;code&gt;require_order&lt;/code&gt; включен, обработка опций прекращается при обнаружении первой опции, не являющейся опцией.</target>
        </trans-unit>
        <trans-unit id="7ec89b0e13a7db5b1125011c45839f2c6cfb36ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;require_order&lt;/code&gt; is enabled, options processing will terminate at the first unrecognized option, or non-option, whichever comes first and all remaining arguments are passed to &lt;code&gt;@ARGV&lt;/code&gt; instead of the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present. However, if &lt;code&gt;permute&lt;/code&gt; is enabled instead, results can become confusing.</source>
          <target state="translated">Если &lt;code&gt;require_order&lt;/code&gt; включен, обработка параметров будет завершена при первом нераспознанном параметре или при отсутствии параметра, в зависимости от того, что наступит раньше, а все остальные аргументы передаются в &lt;code&gt;@ARGV&lt;/code&gt; вместо catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , если он присутствует. Однако, если вместо этого включена &lt;code&gt;permute&lt;/code&gt; , результаты могут быть запутанными.</target>
        </trans-unit>
        <trans-unit id="6e12b0dc8bb5978452519b2af8436776d186cd58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't &lt;code&gt;NULL&lt;/code&gt;) to -1. If those warnings are off, the computed value, if well-defined (or the Unicode REPLACEMENT CHARACTER if not), is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't &lt;code&gt;NULL&lt;/code&gt;) so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e07d4919d304923f37fe1dc7b33e0707c964ce0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot; in perlapi&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344a52db4b11baa26a523460842709ff1b386ede" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; doesn't point to NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot; in perlapi&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee7a15600127f4d0959a8f8bcd7fe929dc1bb55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't &lt;code&gt;NULL&lt;/code&gt;) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0fe2f6810522d3880f034d6ed2e0c1aaeec082" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_locale()&lt;/code&gt; fails for some reason (for example, an attempt to set to a locale unknown to the system), the locale for the category is not changed, and the function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;set_locale()&lt;/code&gt; по какой-либо причине завершается неудачно (например, при попытке установить языковой стандарт, неизвестный системе), языковой стандарт для категории не изменяется, и функция возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00fbad40868135a15b1b3119d64c803fbf76e3ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setlocale()&lt;/code&gt; fails for some reason (for example, an attempt to set to a locale unknown to the system), the locale for the category is not changed, and the function returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7def84ba14c7da181889f798540180404e1bc96d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setmagic&lt;/code&gt; is false then no set magic will be called on the new (empty) SV. This typically means that assignment will soon follow (e.g. &lt;code&gt;'local $x = $y'&lt;/code&gt;), and that will handle the magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1f3673ad86da277d3ff5d2cf4aee1d0694c871" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;split&lt;/code&gt; is invoked as &lt;code&gt;split ' '&lt;/code&gt; or with no arguments (which really means &lt;code&gt;split(' ', $_)&lt;/code&gt;, see &lt;a href=&quot;perlfunc#split&quot;&gt;split&lt;/a&gt;), Perl will set this flag. The regex engine can then check for it and set the SKIPWHITE and WHITE extflags. To do this, the Perl engine does:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3fb59ce22521f54bad3dad454399653c576366" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start_color&lt;/code&gt; is non-null then it will be inserted after the opening quote (if there is one) but before the escaped text. If &lt;code&gt;end_color&lt;/code&gt; is non-null then it will be inserted after the escaped text but before any quotes or ellipses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f49431f91057c4dbcea93169afee875e80cb6ef1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sv&lt;/code&gt; already is UTF-8 (or if it is not &lt;code&gt;POK&lt;/code&gt;), or if &lt;code&gt;encoding&lt;/code&gt; is not a reference, nothing is done to &lt;code&gt;sv&lt;/code&gt;. If &lt;code&gt;encoding&lt;/code&gt; is not an &lt;code&gt;Encode::XS&lt;/code&gt; Encoding object, bad things will happen. (See</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ffb889ba3672c819c8ebc2556d3ca7f2216415" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sv&lt;/code&gt; is not already magical, Perl uses the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro to convert &lt;code&gt;sv&lt;/code&gt; to type &lt;code&gt;SVt_PVMG&lt;/code&gt; . Perl then continues by adding new magic to the beginning of the linked list of magical features. Any prior entry of the same type of magic is deleted. Note that this can be overridden, and multiple instances of the same type of magic can be associated with an SV.</source>
          <target state="translated">Если &lt;code&gt;sv&lt;/code&gt; еще не волшебный, Perl использует макрос &lt;code&gt;SvUPGRADE&lt;/code&gt; для преобразования &lt;code&gt;sv&lt;/code&gt; в тип &lt;code&gt;SVt_PVMG&lt;/code&gt; . Затем Perl продолжает, добавляя новую магию в начало связанного списка магических функций. Любая предыдущая запись того же типа магии удаляется. Обратите внимание, что это можно переопределить, и несколько экземпляров одного и того же типа магии могут быть связаны с SV.</target>
        </trans-unit>
        <trans-unit id="4ab681f247e800a443c2ee4cb6d285861bd3cf7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sv&lt;/code&gt; is not already magical, Perl uses the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro to convert &lt;code&gt;sv&lt;/code&gt; to type &lt;code&gt;SVt_PVMG&lt;/code&gt;. Perl then continues by adding new magic to the beginning of the linked list of magical features. Any prior entry of the same type of magic is deleted. Note that this can be overridden, and multiple instances of the same type of magic can be associated with an SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc4779d92424b9ed1e872ef029dc61c2a85f827" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sv&lt;/code&gt; is the target of a weak reference then it returns the back references structure associated with the sv; otherwise return &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f965fbaf23253043bd3c46cbaac3045ccac1cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;system&lt;/code&gt; is specified as an argument to &lt;code&gt;autodie&lt;/code&gt;, then it uses &lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; to do the heavy lifting. See the description of that module for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b89db42e4e190758019494213d834ead62fc5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tgtsv&lt;/code&gt; is non-null then the string will be written into that SV (overwriting existing content) and it will be returned. If &lt;code&gt;tgtsv&lt;/code&gt; is a null pointer then the string will be written into a new mortal SV which will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c3008df77cfa39eeaefce991da14fbe22117ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u1&lt;/code&gt; is true, the string &lt;code&gt;s1&lt;/code&gt; is assumed to be in UTF-8-encoded Unicode; otherwise it is assumed to be in native 8-bit encoding. Correspondingly for &lt;code&gt;u2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;u1&lt;/code&gt; истинно, предполагается , что строка &lt;code&gt;s1&lt;/code&gt; находится в кодировке UTF-8 Unicode; в противном случае предполагается, что используется собственная 8-битная кодировка. Соответственно для &lt;code&gt;u2&lt;/code&gt; по &lt;code&gt;s2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5369cdc9e4df17df0fab9c265cc2a668b2d5adb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u1&lt;/code&gt; is true, the string &lt;code&gt;s1&lt;/code&gt; is assumed to be in UTF-8-encoded Unicode; otherwise it is assumed to be in native 8-bit encoding. Correspondingly for &lt;code&gt;u2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7ae9da7000e2b33b5ec7b9b74b0d3b4543ad4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;undef&lt;/code&gt; (not a string &lt;code&gt;&quot;undef&quot;&lt;/code&gt;) is passed explicitly as the value for this key, any normalization is not carried out (this may make tailoring easier if any normalization is not desired). Under &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt;, only contiguous contractions are resolved; e.g. even if &lt;code&gt;A-ring&lt;/code&gt; (and &lt;code&gt;A-ring-cedilla&lt;/code&gt;) is ordered after &lt;code&gt;Z&lt;/code&gt;, &lt;code&gt;A-cedilla-ring&lt;/code&gt; would be primary equal to &lt;code&gt;A&lt;/code&gt;. In this point, &lt;code&gt;(normalization =&amp;gt; undef, preprocess =&amp;gt; sub { NFD(shift) })&lt;/code&gt;&lt;b&gt;is not&lt;/b&gt; equivalent to &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1772452ed00715f0d1bcb6cc8461b97a45b8aa33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;undef&lt;/code&gt; is passed explicitly as the value for this key, no file is read (but you can define collation elements via &lt;code&gt;entry&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1540dc791175456aa90cb4fef436e0dad501ecf8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;undef&lt;/code&gt; is passed explicitly as the value for this key, weight for Hangul syllables is treated as undefined without decomposition into Hangul Jamo. But definition of weight for Hangul syllables in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a9ff2f9d0e73da828c40d03f80e90b35d67f88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use Devel::Peek&lt;/code&gt; directive has a &lt;code&gt;:opd=FLAGS&lt;/code&gt; argument, this switches on debugging of opcode dispatch. &lt;code&gt;FLAGS&lt;/code&gt; should be a combination of &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, and &lt;code&gt;P&lt;/code&gt; (see &lt;a href=&quot;perlrun#-Dletters&quot;&gt;&lt;b&gt;-D&lt;/b&gt; flags in perlrun&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e67b351362fc2288e4d85d1df0a7cb4397d6517" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use bytes&lt;/code&gt; is in effect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b63d1c4b73014a212e1adcb7458310fbabfcada8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use integer&lt;/code&gt; (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;) is in force then signed C integers are used (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055cb8f0eb7094e6bf1d58d9d0a382f3cec04e19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;utf8&lt;/code&gt; is disabled, then the result is also correctly encoded in those character sets (as both are proper subsets of Unicode, meaning that a Unicode string with all character values &amp;lt; 256 is the same thing as a ISO-8859-1 string, and a Unicode string with all character values &amp;lt; 128 is the same thing as an ASCII string in Perl).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b6b629aef61b3ce3a48a95ca6e7795616126f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;utf8&lt;/code&gt; is enabled, you still get a correct UTF-8-encoded string, regardless of these flags, just some more characters will be escaped using &lt;code&gt;\uXXXX&lt;/code&gt; then before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac03d59f846f562239a0cc40bb258a33efc729e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uv&lt;/code&gt; is a Unicode surrogate code point and &lt;code&gt;UNICODE_WARN_SURROGATE&lt;/code&gt; is set, the function will raise a warning, provided UTF8 warnings are enabled. If instead &lt;code&gt;UNICODE_DISALLOW_SURROGATE&lt;/code&gt; is set, the function will fail and return NULL. If both flags are set, the function will both warn and return NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb599464a46f537e87d3017df24f3e8e2283ffd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uv&lt;/code&gt; is a Unicode surrogate code point and UNICODE_WARN_SURROGATE is set, the function will raise a warning, provided UTF8 warnings are enabled. If instead UNICODE_DISALLOW_SURROGATE is set, the function will fail and return NULL. If both flags are set, the function will both warn and return NULL.</source>
          <target state="translated">Если &lt;code&gt;uv&lt;/code&gt; является суррогатным кодом Unicode и установлен UNICODE_WARN_SURROGATE, функция выдаст предупреждение при условии, что предупреждения UTF8 включены. Если вместо этого установлен UNICODE_DISALLOW_SURROGATE, функция завершится ошибкой и вернет NULL. Если установлены оба флага, функция выдаст предупреждение и вернет NULL.</target>
        </trans-unit>
        <trans-unit id="0c44318124964ccd942d87918bc5a4d0e5a866fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;val&lt;/code&gt; is true, do not print any errors/warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae30129230a55488ef814c14253472811e67904d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; in</source>
          <target state="translated">Если &lt;code&gt;value&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="02c3454635e56b23178636e2bb6aec32fcd96776" translate="yes" xml:space="preserve">
          <source>If @DynaLoader::dl_resolve_using contains &lt;code&gt;-L*&lt;/code&gt; or &lt;code&gt;-l*&lt;/code&gt; entries then Mkbootstrap will automatically add a dl_findfile() call to the generated &lt;code&gt;*.bs&lt;/code&gt; file.</source>
          <target state="translated">Если @DynaLoader :: dl_resolve_using содержит записи &lt;code&gt;-L*&lt;/code&gt; или &lt;code&gt;-l*&lt;/code&gt; то Mkbootstrap автоматически добавит вызов dl_findfile () в сгенерированный файл &lt;code&gt;*.bs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="203a87ac5779da1d943be09c716f0304a892b601" translate="yes" xml:space="preserve">
          <source>If @args is not given, an empty list will be used.</source>
          <target state="translated">Если @args не указан,будет использован пустой список.</target>
        </trans-unit>
        <trans-unit id="f3523d8b4dddaad91344458f88af994bb31e6c10" translate="yes" xml:space="preserve">
          <source>If @imports are given, they are passed through to the use. So this:</source>
          <target state="translated">Если даны @импорты,то они передаются в использование.Вот так:</target>
        </trans-unit>
        <trans-unit id="649b9ffd5b70f81915b08f4bc8291a1a2ce523f9" translate="yes" xml:space="preserve">
          <source>If @suffixes are given each element is a pattern (either a string or a &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) matched against the end of the $filename. The matching portion is removed and becomes the $suffix.</source>
          <target state="translated">Если заданы @suffixes, каждый элемент является шаблоном (либо строкой, либо &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ), сопоставленным с концом имени $ filename. Соответствующая часть удаляется и становится суффиксом $.</target>
        </trans-unit>
        <trans-unit id="352f4bf8960a2fcba781ac944722d04a3329314f" translate="yes" xml:space="preserve">
          <source>If @suffixes are given each element is a pattern (either a string or a &lt;code&gt;qr//&lt;/code&gt;) matched against the end of the $filename. The matching portion is removed and becomes the $suffix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4498a59b542ad3816d9e8760461f7daf1fdeee5" translate="yes" xml:space="preserve">
          <source>If ATTR includes aliases, those aliases will be expanded at definition time and their values will be used to define the new alias. This means that if you define an alias A in terms of another alias B, and then later redefine alias B, the value of alias A will not change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb13f58bf6ef66c743c6f31498345464e172f61" translate="yes" xml:space="preserve">
          <source>If ATTR is not specified, coloralias() returns the standard attribute or attributes to which ALIAS is aliased, if any, or undef if ALIAS does not exist. If it is aliased to multiple attributes, the return value will be a single string and the attributes will be separated by spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e062bfde8c040f50084c09a806e3edbdcdba4c2d" translate="yes" xml:space="preserve">
          <source>If ATTR is not specified, coloralias() returns the standard color name to which ALIAS is aliased, if any, or undef if ALIAS does not exist.</source>
          <target state="translated">Если ATTR не указан,coloralias()возвращает стандартное имя цвета,которому присвоен псевдоним ALIAS,если таковой имеется,или undef,если ALIAS не существует.</target>
        </trans-unit>
        <trans-unit id="f999d6f241c02db8ba7aa5052a43f699b6917b00" translate="yes" xml:space="preserve">
          <source>If ATTR is specified, coloralias() sets up an alias of ALIAS for the standard color ATTR. From that point forward, ALIAS can be passed into color(), colored(), and colorvalid() and will have the same meaning as ATTR. One possible use of this facility is to give more meaningful names to the 256-color RGB colors. Only alphanumerics, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt; , and &lt;code&gt;-&lt;/code&gt; are allowed in alias names.</source>
          <target state="translated">Если указан ATTR, coloralias () устанавливает псевдоним ALIAS для стандартного цвета ATTR. С этого момента ALIAS можно передавать в color (), colour () и colorvalid (), и они будут иметь то же значение, что и ATTR. Одно из возможных применений этого средства - дать более значимые имена 256-цветным цветам RGB. Только буквенно - цифровые, &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;_&lt;/code&gt; и &lt;code&gt;-&lt;/code&gt; разрешены в псевдонимах.</target>
        </trans-unit>
        <trans-unit id="ef24de7525ed9aebc1ebe9e4502b970287362ec8" translate="yes" xml:space="preserve">
          <source>If ATTR is specified, it is interpreted as a list of space-separated strings naming attributes or existing aliases. In this case, coloralias() sets up an alias of ALIAS for the set of attributes given by ATTR. From that point forward, ALIAS can be passed into color(), colored(), and colorvalid() and will have the same meaning as the sequence of attributes given in ATTR. One possible use of this facility is to give more meaningful names to the 256-color RGB colors. Only ASCII alphanumerics, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, and &lt;code&gt;-&lt;/code&gt; are allowed in alias names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5f4e8c9b9a52c1f24694fe0f51b01b3e6fce9d" translate="yes" xml:space="preserve">
          <source>If BASE is less than or equal to 94, and a collation sequence is not specified, the following default collation sequence is used. It contains of all the 94 printable ASCII characters except space/blank:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3759a11aeec37a7d745f2f4cdae15ec5d06a83ce" translate="yes" xml:space="preserve">
          <source>If BITS is 16 or more, bytes of the input string are grouped into chunks of size BITS/8, and each group is converted to a number as with &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; with big-endian formats &lt;code&gt;n&lt;/code&gt;/&lt;code&gt;N&lt;/code&gt; (and analogously for BITS==64). See &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed33ee3bf815a6c3c728d6a64deacab551214ad3" translate="yes" xml:space="preserve">
          <source>If BITS is 16 or more, bytes of the input string are grouped into chunks of size BITS/8, and each group is converted to a number as with pack()/unpack() with big-endian formats &lt;code&gt;n&lt;/code&gt; /&lt;code&gt;N&lt;/code&gt; (and analogously for BITS==64). See &lt;a href=&quot;#pack&quot;&gt;pack&lt;/a&gt; for details.</source>
          <target state="translated">Если BITS составляет 16 или более, байты входной строки группируются в фрагменты размером BITS / 8, и каждая группа преобразуется в число, как с pack () / unpack () с прямым порядком байтов &lt;code&gt;n&lt;/code&gt; / &lt;code&gt;N&lt;/code&gt; (и аналогично для BITS == 64). См. Подробности в &lt;a href=&quot;#pack&quot;&gt;пакете&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5890dee5bd815a9a6b870ab0d81456c70fdb6033" translate="yes" xml:space="preserve">
          <source>If BITS is 16 or more, bytes of the input string are grouped into chunks of size BITS/8, and each group is converted to a number as with pack()/unpack() with big-endian formats &lt;code&gt;n&lt;/code&gt; /&lt;code&gt;N&lt;/code&gt; (and analogously for BITS==64). See &lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt; for details.</source>
          <target state="translated">Если BITS составляет 16 или более, байты входной строки группируются в фрагменты размером BITS / 8, и каждая группа преобразуется в число, как с pack () / unpack () с прямым порядком байтов &lt;code&gt;n&lt;/code&gt; / &lt;code&gt;N&lt;/code&gt; (и аналогично для BITS == 64). См. Подробности в &lt;a href=&quot;pack&quot;&gt;пакете&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eafc581ec466397a85b26357c350bc4ac6773df9" translate="yes" xml:space="preserve">
          <source>If BITS is 8, &quot;elements&quot; coincide with bytes of the input string.</source>
          <target state="translated">Если BITS равен 8,то &quot;элементы&quot; совпадают с байтами входной строки.</target>
        </trans-unit>
        <trans-unit id="1e3d642ff4115aae3b45ab10f3f174f7b8799465" translate="yes" xml:space="preserve">
          <source>If BUILD_REQUIRES is not empty, it will be dumped as $BUILD_REQUIRES hashref.</source>
          <target state="translated">Если BUILD_REQUIRES не пустой,он будет выведен как хэш-функция $BUILD_REQUIRES.</target>
        </trans-unit>
        <trans-unit id="2f52aed81a4b81abc4bfb5eb234cabe8285fe520" translate="yes" xml:space="preserve">
          <source>If CHLD_IN begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; , then CHLD_IN will be closed in the parent, and the child will read from it directly. If CHLD_OUT or CHLD_ERR begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that filehandle. In both cases, there will be a dup(2) instead of a pipe(2) made.</source>
          <target state="translated">Если CHLD_IN начинается с &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; , тогда CHLD_IN будет закрыт в родительском элементе, и дочерний элемент будет читать из него напрямую. Если CHLD_OUT или CHLD_ERR начинается с &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; , тогда дочерний элемент будет отправлять вывод непосредственно в этот дескриптор файла. В обоих случаях вместо трубы (2) будет сделан дуп (2).</target>
        </trans-unit>
        <trans-unit id="7212fe99a84e995b8956769eedd21cc0b4318074" translate="yes" xml:space="preserve">
          <source>If Configure detects &lt;code&gt;mmap()&lt;/code&gt; functions this layer is provided (with &quot;perlio&quot; as a &quot;base&quot;) which does &quot;read&quot; operations by mmap()ing the file. Performance improvement is marginal on modern systems, so it is mainly there as a proof of concept. It is likely to be unbundled from the core at some point. The &quot;mmap&quot; layer is a reasonable model for a minimalist &quot;derived&quot; layer.</source>
          <target state="translated">Если Configure обнаруживает функции &lt;code&gt;mmap()&lt;/code&gt; этот уровень (с &amp;laquo;perlio&amp;raquo; в качестве &amp;laquo;основы&amp;raquo;), который выполняет операции &amp;laquo;чтения&amp;raquo; с помощью mmap () файла. Улучшение производительности в современных системах незначительно, поэтому оно в основном служит подтверждением концепции. Вероятно, в какой-то момент он будет отделен от ядра. Слой &amp;laquo;mmap&amp;raquo; является разумной моделью для минималистичного &amp;laquo;производного&amp;raquo; слоя.</target>
        </trans-unit>
        <trans-unit id="47e49834bb6e6d998b14887fad543f4fe5a1147b" translate="yes" xml:space="preserve">
          <source>If Configure detects this system has a signbit() that will work with our NVs, then we just use it via the #define in perl.h. Otherwise, fall back on this implementation. The main use of this function is catching -0.0.</source>
          <target state="translated">Если Configure обнаруживает,что эта система имеет signbit(),который будет работать с нашими NVs,то мы просто используем его через #define in perl.h.В противном случае,отступаем от этой реализации.Основное использование этой функции-перехват -0.0.</target>
        </trans-unit>
        <trans-unit id="14abe49a0e4ae66bc9fb22dcac00158a0e0ddd4d" translate="yes" xml:space="preserve">
          <source>If D calls an autoloaded method 'foo' which is defined in class A, then the method is loaded into class A, then executed. If C then calls method 'foo', and that method was reimplemented in class B, but set to be autoloaded, then the lookup mechanism never gets to the AUTOLOAD mechanism in B because it first finds the method already loaded in A, and so erroneously uses that. If the method foo had been stubbed in B, then the lookup mechanism would have found the stub, and correctly loaded and used the sub from B.</source>
          <target state="translated">Если D вызывает автозагруженный метод 'foo',который определен в классе A,то этот метод загружается в класс A,а затем выполняется.Если же C вызывает метод 'foo',и этот метод был переопределен в классе B,но установлен в автозагрузку,то механизм поиска никогда не попадает в механизм AUTOLOAD в B,так как он сначала находит метод,уже загруженный в A,и поэтому ошибочно использует его.Если бы метод foo был загружен в B,то механизм поиска нашел бы заглушку и правильно загрузил и использовал бы подлодку из B.</target>
        </trans-unit>
        <trans-unit id="91710ed7923201057d536dad32d2aa3d9a3bd35e" translate="yes" xml:space="preserve">
          <source>If DUCET is not installed, it is recommended to copy the file from &lt;a href=&quot;http://www.unicode.org/Public/UCA/latest/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/latest/allkeys.txt&lt;/a&gt; to &amp;lt;a place in @INC&amp;gt;/Unicode/Collate/allkeys.txt manually.</source>
          <target state="translated">Если DUCET не установлен, рекомендуется вручную скопировать файл из &lt;a href=&quot;http://www.unicode.org/Public/UCA/latest/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/latest/allkeys.txt&lt;/a&gt; в &amp;lt;a место в @INC&amp;gt; /Unicode/Collate/allkeys.txt. .</target>
        </trans-unit>
        <trans-unit id="16f5960189e018481d4424c6116d78e40717c6a6" translate="yes" xml:space="preserve">
          <source>If DUCET is not installed, it is recommended to copy the file from http://www.unicode.org/Public/UCA/latest/allkeys.txt to &amp;lt;a place in @INC&amp;gt;/Unicode/Collate/allkeys.txt manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ee7188cb79ae72f03905ea0c72ed0cf711430e" translate="yes" xml:space="preserve">
          <source>If EVENT_MASK is given, then, if EVENT_MASK is non-zero, IO is added to the list of file descriptors and the next call to poll will check for any event specified in EVENT_MASK. If EVENT_MASK is zero then IO will be removed from the list of file descriptors.</source>
          <target state="translated">Если EVENT_MASK задан,то,если EVENT_MASK ненулевой,то IO добавляется в список файловых дескрипторов и при следующем вызове опроса будет проверено любое событие,указанное в EVENT_MASK.Если EVENT_MASK равен нулю,то IO будет удалено из списка файловых дескрипторов.</target>
        </trans-unit>
        <trans-unit id="bd3d21a82a01626375b0a1ef9fd969a22666fce2" translate="yes" xml:space="preserve">
          <source>If EVENT_MASK is not given then the return value will be the current event mask value for IO.</source>
          <target state="translated">Если EVENT_MASK не задан,то возвращаемым значением будет текущее значение маски события для IO.</target>
        </trans-unit>
        <trans-unit id="24c1cc8102964c640118dc422f140e282d6a071d" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 &amp;amp;&amp;amp; EXPR2&lt;/code&gt; or &lt;code&gt;EXPR1 &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; EXPR2&lt;/code&gt; , the test is applied</source>
          <target state="translated">Если EXPR - это &lt;code&gt;EXPR1 &amp;amp;&amp;amp; EXPR2&lt;/code&gt; или &lt;code&gt;EXPR1 &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; EXPR2&lt;/code&gt; , тест применяется</target>
        </trans-unit>
        <trans-unit id="c34219724e950095cf8c95b322a2257c22c1fa96" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 &amp;amp;&amp;amp; EXPR2&lt;/code&gt; or &lt;code&gt;EXPR1 and EXPR2&lt;/code&gt;, the test is applied</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b0086c490eacc160b851838628c17c1a42195c" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 || EXPR2&lt;/code&gt; , &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; , or &lt;code&gt;EXPR1 &lt;a href=&quot;functions/or&quot;&gt;or&lt;/a&gt; EXPR2&lt;/code&gt; , the test is applied</source>
          <target state="translated">Если EXPR равен &lt;code&gt;EXPR1 || EXPR2&lt;/code&gt; , &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; или &lt;code&gt;EXPR1 &lt;a href=&quot;functions/or&quot;&gt;or&lt;/a&gt; EXPR2&lt;/code&gt; , тест применяется</target>
        </trans-unit>
        <trans-unit id="64f0ed02041dd1423cf4f2ba1123160eb703a531" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 || EXPR2&lt;/code&gt;, &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt;, or &lt;code&gt;EXPR1 or EXPR2&lt;/code&gt;, the test is applied</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872b533779048230ee59539b4fa97acddf5e7f67" translate="yes" xml:space="preserve">
          <source>If EXPR is a bareword, &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; assumes a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204a0454b1de60634e71646d68fb30fb2441fd3c" translate="yes" xml:space="preserve">
          <source>If EXPR is a bareword, the require assumes a &quot;</source>
          <target state="translated">Если EXPR является пустым словом,то требование предполагает наличие &quot;</target>
        </trans-unit>
        <trans-unit id="5f142acc4fb900bf97a751d8d7ecef7ff58633e0" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, &lt;a href=&quot;#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; uses the current time (as returned by &lt;a href=&quot;#time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9736cd87f1cff71e99f8827cbdbed7d4bb55c258" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; uses the current time (as returned by time(3)).</source>
          <target state="translated">Если EXPR опущен, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; использует текущее время (возвращаемое time (3)).</target>
        </trans-unit>
        <trans-unit id="6546ecbea2a684b1dddb3701f62d17cc4c008989" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; uses the current time (as returned by time(3)).</source>
          <target state="translated">Если EXPR опущен, &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; использует текущее время (возвращаемое time (3)).</target>
        </trans-unit>
        <trans-unit id="1a53ae320a45163e84b47c2cc6fa7f3f20a64bbd" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, stats &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0b8d50332776e14a75cf158fdbe3c24ae9c657" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, stats &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">Если EXPR опущен, статистика &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac7e9e53a5fc19d51bc46a87435c0e28a0433901" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, unpacks the &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; string. See &lt;a href=&quot;perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; for an introduction to this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="456f6be70dd618e1ee3287e7f4f8da001e29c2cb" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, unpacks the &lt;code&gt;$_&lt;/code&gt; string. See &lt;a href=&quot;../perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; for an introduction to this function.</source>
          <target state="translated">Если EXPR опущен, распаковывает строку &lt;code&gt;$_&lt;/code&gt; . См. &lt;a href=&quot;../perlpacktut&quot;&gt;Perlpacktut&lt;/a&gt; для введения в эту функцию.</target>
        </trans-unit>
        <trans-unit id="b61a1720b65aee85f5ca14d3364f5d86fb223f23" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, unpacks the &lt;code&gt;$_&lt;/code&gt; string. See &lt;a href=&quot;perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; for an introduction to this function.</source>
          <target state="translated">Если EXPR опущен, распаковывает строку &lt;code&gt;$_&lt;/code&gt; . См. &lt;a href=&quot;perlpacktut&quot;&gt;Perlpacktut&lt;/a&gt; для введения в эту функцию.</target>
        </trans-unit>
        <trans-unit id="26a60e10a6d0c75eb8213877c8d12c780af7f80d" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe2e417f8e1e00ae0478764fd05788fcd47c267" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;. To go the other way (produce a number in octal), use &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36eccdc92b1d6936c118cc354859012973685d8" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">Если EXPR опущен, используется &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1172cb3a4a7f1f2dfc6dcf55076a98d031996813" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; . To go the other way (produce a number in octal), use sprintf() or printf():</source>
          <target state="translated">Если EXPR опущен, используется &lt;code&gt;$_&lt;/code&gt; . Чтобы пойти другим путем (создать восьмеричное число), используйте sprintf () или printf ():</target>
        </trans-unit>
        <trans-unit id="0835de1ae9d548d447faabd3d40dd3e5da356962" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE -- the first argument in a call to &lt;code&gt;open&lt;/code&gt; -- is an undefined scalar variable (or array or hash element), a new filehandle is autovivified, meaning that the variable is assigned a reference to a newly allocated anonymous filehandle. Otherwise if FILEHANDLE is an expression, its value is the real filehandle. (This is considered a symbolic reference, so &lt;code&gt;use strict &quot;refs&quot;&lt;/code&gt; should</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488f2cec4909ee80d1ac152c113a7f5b407ac400" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is an undefined scalar variable (or array or hash element), a new filehandle is autovivified, meaning that the variable is assigned a reference to a newly allocated anonymous filehandle. Otherwise if FILEHANDLE is an expression, its value is the real filehandle. (This is considered a symbolic reference, so &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; should</source>
          <target state="translated">Если FILEHANDLE является неопределенной скалярной переменной (или массивом, или элементом хэша), новый дескриптор файла автоматически оживляется, что означает, что переменной назначается ссылка на вновь назначенный анонимный дескриптор файла. В противном случае, если FILEHANDLE является выражением, его значением является реальный дескриптор файла. (Это считается символической ссылкой, поэтому &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; должна</target>
        </trans-unit>
        <trans-unit id="7bf316535c25573b5c20cc7acfbdffbec7d384a1" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is an undefined scalar variable (or array or hash element), a new filehandle is autovivified, meaning that the variable is assigned a reference to a newly allocated anonymous filehandle. Otherwise if FILEHANDLE is an expression, its value is the real filehandle. (This is considered a symbolic reference, so &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; should</source>
          <target state="translated">Если FILEHANDLE является неопределенной скалярной переменной (или массивом, или элементом хэша), новый дескриптор файла автоматически оживляется, что означает, что переменной назначается ссылка на вновь назначенный анонимный дескриптор файла. В противном случае, если FILEHANDLE является выражением, его значением является реальный дескриптор файла. (Это считается символической ссылкой, поэтому &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; должна</target>
        </trans-unit>
        <trans-unit id="78b86feaadc89f11ca72025d1989c281686ea22c" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is unspecified, output goes to the current default output channel, which starts out as STDOUT but may be changed by the &lt;a href=&quot;#select-FILEHANDLE&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; operator. If the FILEHANDLE is an EXPR, then the expression is evaluated and the resulting string is used to look up the name of the FILEHANDLE at run time. For more on formats, see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7edd9359c1108403094d8175c9c20835e326b96f" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is unspecified, output goes to the current default output channel, which starts out as STDOUT but may be changed by the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; operator. If the FILEHANDLE is an EXPR, then the expression is evaluated and the resulting string is used to look up the name of the FILEHANDLE at run time. For more on formats, see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">Если FILEHANDLE не указан, вывод идет на текущий канал вывода по умолчанию, который начинается как STDOUT, но может быть изменен оператором &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; . Если FILEHANDLE - это EXPR, тогда выражение оценивается, и полученная строка используется для поиска имени FILEHANDLE во время выполнения. Подробнее о форматах см. &lt;a href=&quot;perlform&quot;&gt;Perlform&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64a3c2a915faecffdca2e95dc4489ca8da06212f" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is unspecified, output goes to the current default output channel, which starts out as STDOUT but may be changed by the &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; operator. If the FILEHANDLE is an EXPR, then the expression is evaluated and the resulting string is used to look up the name of the FILEHANDLE at run time. For more on formats, see &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">Если FILEHANDLE не указан, вывод идет на текущий канал вывода по умолчанию, который начинается как STDOUT, но может быть изменен оператором &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; . Если FILEHANDLE - это EXPR, тогда выражение оценивается, и полученная строка используется для поиска имени FILEHANDLE во время выполнения. Подробнее о форматах см. &lt;a href=&quot;../perlform&quot;&gt;Perlform&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7746cb09d04e425daae32ba450ffb46bfb9b6e05" translate="yes" xml:space="preserve">
          <source>If FILENAME doesn't exist on the filesystem, or if the filesystem doesn't support short ANSI filenames, then this function will translate the Unicode name into the system codepage using replacement characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42bee98ad679afc0b47a6a37b45d0b7a351045fa" translate="yes" xml:space="preserve">
          <source>If FUNCTION is a string starting with &lt;code&gt;CORE::&lt;/code&gt; , the rest is taken as a name for a Perl builtin. If the builtin's arguments cannot be adequately expressed by a prototype (such as &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;), prototype() returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, because the builtin does not really behave like a Perl function. Otherwise, the string describing the equivalent prototype is returned.</source>
          <target state="translated">Если FUNCTION - это строка, начинающаяся с &lt;code&gt;CORE::&lt;/code&gt; , остальное используется как имя встроенной Perl. Если аргументы встроенной функции не могут быть адекватно выражены прототипом (например, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ), prototype () возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , поскольку встроенная функция на самом деле не ведет себя как функция Perl. В противном случае возвращается строка, описывающая эквивалентный прототип.</target>
        </trans-unit>
        <trans-unit id="cae550505561d57b299b4a003dc8830ba8e1ee71" translate="yes" xml:space="preserve">
          <source>If FUNCTION is a string starting with &lt;code&gt;CORE::&lt;/code&gt; , the rest is taken as a name for a Perl builtin. If the builtin's arguments cannot be adequately expressed by a prototype (such as &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;), prototype() returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, because the builtin does not really behave like a Perl function. Otherwise, the string describing the equivalent prototype is returned.</source>
          <target state="translated">Если FUNCTION - это строка, начинающаяся с &lt;code&gt;CORE::&lt;/code&gt; , остальное используется как имя встроенной Perl. Если аргументы встроенной функции не могут быть адекватно выражены прототипом (например, &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ), prototype () возвращает &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , поскольку встроенная функция на самом деле не ведет себя как функция Perl. В противном случае возвращается строка, описывающая эквивалентный прототип.</target>
        </trans-unit>
        <trans-unit id="0166703daf5c496c4bec8f243a081750014163a4" translate="yes" xml:space="preserve">
          <source>If FUNCTION is a string starting with &lt;code&gt;CORE::&lt;/code&gt;, the rest is taken as a name for a Perl builtin. If the builtin's arguments cannot be adequately expressed by a prototype (such as &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;), &lt;a href=&quot;#prototype-FUNCTION&quot;&gt;&lt;code&gt;prototype&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, because the builtin does not really behave like a Perl function. Otherwise, the string describing the equivalent prototype is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc31873f684622a14f7af2ea2005b39a1781e830" translate="yes" xml:space="preserve">
          <source>If G_ARRAY is specified</source>
          <target state="translated">Если G_ARRAY указан</target>
        </trans-unit>
        <trans-unit id="abc56a2d0a54c75c4dee47cdfefa046b0f36c198" translate="yes" xml:space="preserve">
          <source>If G_DISCARD is specified, the return value will always be 0.</source>
          <target state="translated">Если задана G_DISCARD,возвращаемое значение всегда будет равно 0.</target>
        </trans-unit>
        <trans-unit id="61b15d293eca2c7db4238b66ac8714ddc363a1b1" translate="yes" xml:space="preserve">
          <source>If G_SCALAR is specified</source>
          <target state="translated">Если указан G_SCALAR</target>
        </trans-unit>
        <trans-unit id="5c71a194d71e5b8b3f592792b3f56c1d07d85df4" translate="yes" xml:space="preserve">
          <source>If I don't have My::TAP::Harness installed on @INC I need to provide the correct path to perl when I run prove:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd626ea4da9803c896a3f690bf6350bffa4a5047" translate="yes" xml:space="preserve">
          <source>If I don't see that &quot;Perl:&quot;, it's not from perl.</source>
          <target state="translated">Если я не вижу это &quot;Перл:&quot;,то это не от Перл.</target>
        </trans-unit>
        <trans-unit id="03be8548f702da2e594e410d893934eeb0d8222b" translate="yes" xml:space="preserve">
          <source>If I have failing tests in a test suite that consists of more than a handful of scripts and takes more than a few seconds to run it rapidly becomes tedious to run the whole test suite repeatedly as I track down the problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da15fab02b636d1da580f8c8673ab702a8e74b65" translate="yes" xml:space="preserve">
          <source>If I need a feature that prove doesn't provide I can easily write my own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605963fd1be7406e13c1ff42eab8cd0d74775641" translate="yes" xml:space="preserve">
          <source>If I need to reach even deeper into the internals of the harness I can replace the classes that TAP::Parser uses to execute test scripts and tokenise their output. Before running a test script TAP::Parser creates a grammar (TAP::Parser::Grammar) to decode the raw TAP into tokens, a result factory (TAP::Parser::ResultFactory) to turn the decoded TAP results into objects and, depending on whether it's running a test script or reading TAP from a file, scalar or array a source or an iterator (TAP::Parser::IteratorFactory).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985d558aa1f93c1b25225dff89cbd31a5a5a4d9a" translate="yes" xml:space="preserve">
          <source>If I save that as t/phptest.t the shebang line will ensure that it runs correctly along with all my other tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a5f2df715ea2336595f87758abbc0f6cdbf051" translate="yes" xml:space="preserve">
          <source>If I write a subclass of App::Prove I can customise any aspect of the test runner while inheriting all of prove's behaviour. Here's myprove:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74809ed417c3b37088be3b29e4f08e09fd27f388" translate="yes" xml:space="preserve">
          <source>If I'm running my tests in parallel there may also be a multiplexer (TAP::Parser::Multiplexer) - the component that allows multiple tests to run simultaneously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f881d9fe9fd9028d68d11b8271492af01bf7e3c" translate="yes" xml:space="preserve">
          <source>If ID is omitted, it defaults to &lt;code&gt;1&lt;/code&gt; . If a single character is given for ID, the numeric value of that character is used.</source>
          <target state="translated">Если идентификатор не указан, по умолчанию используется &lt;code&gt;1&lt;/code&gt; . Если для идентификатора указан один символ, используется числовое значение этого символа.</target>
        </trans-unit>
        <trans-unit id="3edb552ee59d2dff01961b99b98b93b199000e3c" translate="yes" xml:space="preserve">
          <source>If ID is omitted, it defaults to &lt;code&gt;1&lt;/code&gt;. If a single character is given for ID, the numeric value of that character is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b781e9bc0c2157f6dabdbd2804f21e2dc4d3a773" translate="yes" xml:space="preserve">
          <source>If KEY starts and ends with a slash, the string in between is treated as a regular expression and only keys matching this regexp are displayed</source>
          <target state="translated">Если KEY начинается и заканчивается косой чертой,то строка между ними обрабатывается как регулярное выражение,и отображаются только те клавиши,которые соответствуют этому регенерирующему выражению.</target>
        </trans-unit>
        <trans-unit id="97bf7fa576e4d2080ce6127c0f4cd5a7adce4cf1" translate="yes" xml:space="preserve">
          <source>If LAYER is omitted or specified as &lt;code&gt;:raw&lt;/code&gt; the filehandle is made suitable for passing binary data. This includes turning off possible CRLF translation and marking it as bytes (as opposed to Unicode characters). Note that, despite what may be implied in</source>
          <target state="translated">Если LAYER опущен или указан как &lt;code&gt;:raw&lt;/code&gt; , дескриптор файла становится пригодным для передачи двоичных данных. Это включает отключение возможной трансляции CRLF и пометку ее как байтов (в отличие от символов Unicode). Обратите внимание, что, несмотря на то, что может подразумеваться в</target>
        </trans-unit>
        <trans-unit id="283b8c8f4ffd49cdc5f923f3f2b2ef054e93376f" translate="yes" xml:space="preserve">
          <source>If LAYER is present it is a single string, but may contain multiple directives. The directives alter the behaviour of the filehandle. When LAYER is present, using binmode on a text file makes sense.</source>
          <target state="translated">Если LAYER присутствует,то это одна строка,но может содержать несколько директив.Директивы изменяют поведение файла.Если LAYER присутствует,использование binmode в текстовом файле имеет смысл.</target>
        </trans-unit>
        <trans-unit id="bc78056370f87ab6c8598a43f74f4b98bd9074c2" translate="yes" xml:space="preserve">
          <source>If LIMIT is negative, it is treated as if it were instead arbitrarily large; as many fields as possible are produced.</source>
          <target state="translated">Если LIMIT отрицательный,то к нему относятся как к произвольно большому количеству месторождений;добывается как можно больше месторождений.</target>
        </trans-unit>
        <trans-unit id="0394dbfeda7095aa516dcefff51b8b66aab7006b" translate="yes" xml:space="preserve">
          <source>If LIMIT is omitted (or, equivalently, zero), then it is usually treated as if it were instead negative but with the exception that trailing empty fields are stripped (empty leading fields are always preserved); if all fields are empty, then all fields are considered to be trailing (and are thus stripped in this case). Thus, the following:</source>
          <target state="translated">Если LIMIT опущен (или,эквивалентно,равен нулю),то он обычно считается отрицательным,но за исключением того,что пустые поля в трейлинге удаляются (пустые ведущие поля всегда сохраняются);если все поля пустые,то все поля считаются пустыми (и,таким образом,в данном случае удаляются).Таким образом,следующее:</target>
        </trans-unit>
        <trans-unit id="ec1ca6d6c3c8c30d74e46da0d1f8dfee1a937ce1" translate="yes" xml:space="preserve">
          <source>If LIMIT is specified and positive, it represents the maximum number of fields into which the EXPR may be split; in other words, LIMIT is one greater than the maximum number of times EXPR may be split. Thus, the LIMIT value &lt;code&gt;1&lt;/code&gt; means that EXPR may be split a maximum of zero times, producing a maximum of one field (namely, the entire value of EXPR). For instance:</source>
          <target state="translated">Если указано положительное значение LIMIT, оно представляет максимальное количество полей, на которые можно разбить EXPR; другими словами, LIMIT на единицу больше, чем максимальное количество раз, которое может быть разделено EXPR. Таким образом, значение LIMIT &lt;code&gt;1&lt;/code&gt; означает, что EXPR может быть разделен максимум ноль раз, создавая максимум одно поле (а именно, все значение EXPR). Например:</target>
        </trans-unit>
        <trans-unit id="a1e79f492508e7edc8814a0c2f8fb560a886956d" translate="yes" xml:space="preserve">
          <source>If LIST consists of the empty string, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; spawns an interactive DCL subprocess, in the same fashion as typing &lt;b&gt;SPAWN&lt;/b&gt; at the DCL prompt.</source>
          <target state="translated">Если LIST состоит из пустой строки, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; запускает интерактивный подпроцесс DCL таким же образом, как при вводе &lt;b&gt;SPAWN&lt;/b&gt; в приглашении DCL.</target>
        </trans-unit>
        <trans-unit id="d577e3a6f68cf3804f6d29aac95c4927c6f793ba" translate="yes" xml:space="preserve">
          <source>If LIST consists of the empty string, &lt;code&gt;system&lt;/code&gt; spawns an interactive DCL subprocess, in the same fashion as typing &lt;b&gt;SPAWN&lt;/b&gt; at the DCL prompt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2cae660b4a3baec9a67c4d2cf72f2806437ed21" translate="yes" xml:space="preserve">
          <source>If LIST is omitted, &lt;a href=&quot;#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af421f1352b89476d8e2fb680c100c5c55fb16a" translate="yes" xml:space="preserve">
          <source>If LIST is omitted, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">Если LIST опущен, для &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; используется &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15ba1dd13707a281770468c5a2f35927f1cf24ea" translate="yes" xml:space="preserve">
          <source>If LIST is omitted, &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">Если LIST опущен, для &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; используется &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4da7e6771ebdbb0d68b845baa0f1af30e2550323" translate="yes" xml:space="preserve">
          <source>If LIST was empty or made an empty string, and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; already contains an exception value (typically from a previous &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;), then that value is reused after appending &lt;code&gt;&quot;\t...propagated&quot;&lt;/code&gt;. This is useful for propagating exceptions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84674bcf3d3a118952a055d14ce31826e4bf5479" translate="yes" xml:space="preserve">
          <source>If LIST was empty or made an empty string, and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; contains an object reference that has a &lt;code&gt;PROPAGATE&lt;/code&gt; method, that method will be called with additional file and line number parameters. The return value replaces the value in &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;; i.e., as if &lt;code&gt;$@ = eval { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; were called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281f7b6eb5d507578f647b0d70c67bd5a086771f" translate="yes" xml:space="preserve">
          <source>If LIST was empty or made an empty string, and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is also empty, then the string &lt;code&gt;&quot;Died&quot;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6165dd99b5382a91584396109e05b591d171e0" translate="yes" xml:space="preserve">
          <source>If MODE is &lt;code&gt;&amp;lt;&lt;/code&gt;, the file is opened for input (read-only). If MODE is &lt;code&gt;&amp;gt;&lt;/code&gt;, the file is opened for output, with existing files first being truncated (&quot;clobbered&quot;) and nonexisting files newly created. If MODE is &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, the file is opened for appending, again being created if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ef4f93ed053708e4daa4192a3c5a507017945b" translate="yes" xml:space="preserve">
          <source>If MODE is &lt;code&gt;|-&lt;/code&gt;, then the filename is interpreted as a command to which output is to be piped, and if MODE is &lt;code&gt;-|&lt;/code&gt;, the filename is interpreted as a command that pipes output to us. In the two-argument (and one-argument) form, one should replace dash (&lt;code&gt;-&lt;/code&gt;) with the command. See &lt;a href=&quot;perlipc#Using-open%28%29-for-IPC&quot;&gt;&quot;Using open() for IPC&quot; in perlipc&lt;/a&gt; for more examples of this. (You are not allowed to &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; to a command that pipes both in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8725f581ae126bd53637cc6004bb31b10e046db" translate="yes" xml:space="preserve">
          <source>If Mac::Files could not be loaded, the empty string is returned.</source>
          <target state="translated">Если Mac::Files не удалось загрузить,возвращается пустая строка.</target>
        </trans-unit>
        <trans-unit id="9556835597cabed412f1a27672edf9d6d8a5a68b" translate="yes" xml:space="preserve">
          <source>If N is &amp;gt; 0, rounds to the Nth digit from the left. If N &amp;lt; 0, rounds to the Nth digit after the dot. Since BigInts are integers, the case N &amp;lt; 0 is a no-op for them.</source>
          <target state="translated">Если N&amp;gt; 0, выполняется округление до N-й цифры слева. Если N &amp;lt;0, округляется до N-й цифры после точки. Поскольку BigInts являются целыми числами, случай N &amp;lt;0 для них не работает.</target>
        </trans-unit>
        <trans-unit id="7bb11b5e3bbf2cecd073552e16a6087ed08e448b" translate="yes" xml:space="preserve">
          <source>If NUMBER is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809aa45c402e18c1090663e0bbd2fdac630054bb" translate="yes" xml:space="preserve">
          <source>If NUMBER is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">Если ЧИСЛО опущено, используется &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41978e4e598bdad208f30664c01c64d67097badb" translate="yes" xml:space="preserve">
          <source>If OFFSET and LENGTH specify a substring that is partly outside the string, only the part within the string is returned. If the substring is beyond either end of the string, &lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt;&lt;code&gt;substr&lt;/code&gt;&lt;/a&gt; returns the undefined value and produces a warning. When used as an lvalue, specifying a substring that is entirely outside the string raises an exception. Here's an example showing the behavior for boundary cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e18ed7b6aa1dfe2acf7667704a25f494c6c53b1" translate="yes" xml:space="preserve">
          <source>If OFFSET and LENGTH specify a substring that is partly outside the string, only the part within the string is returned. If the substring is beyond either end of the string, substr() returns the undefined value and produces a warning. When used as an lvalue, specifying a substring that is entirely outside the string raises an exception. Here's an example showing the behavior for boundary cases:</source>
          <target state="translated">Если OFFSET и LENGTH указывают подстроку,которая частично находится вне строки,возвращается только часть внутри строки.Если подстрока находится за пределами любого конца строки,substr()возвращает неопределенное значение и выдает предупреждение.При использовании в качестве l-значения указание подстроки,которая полностью находится за пределами строки,вызывает исключение.Вот пример,показывающий поведение для граничных случаев:</target>
        </trans-unit>
        <trans-unit id="805a2c8a87b8f6b59ee6ee34433c46d30a4b7687" translate="yes" xml:space="preserve">
          <source>If PATTERN is &lt;code&gt;/^/&lt;/code&gt; , then it is treated as if it used the &lt;a href=&quot;../perlreref#OPERATORS&quot;&gt;multiline modifier&lt;/a&gt; (&lt;code&gt;/^/m&lt;/code&gt; ), since it isn't much use otherwise.</source>
          <target state="translated">Если ШАБЛОН - &lt;code&gt;/^/&lt;/code&gt; , то он обрабатывается так, как если бы он использовал &lt;a href=&quot;../perlreref#OPERATORS&quot;&gt;многострочный модификатор&lt;/a&gt; ( &lt;code&gt;/^/m&lt;/code&gt; ), поскольку в противном случае он мало используется.</target>
        </trans-unit>
        <trans-unit id="f31e710fa5dc3bb0149beaea0c04322fd5b027e6" translate="yes" xml:space="preserve">
          <source>If PATTERN is &lt;code&gt;/^/&lt;/code&gt; , then it is treated as if it used the &lt;a href=&quot;perlreref#OPERATORS&quot;&gt;multiline modifier&lt;/a&gt; (&lt;code&gt;/^/m&lt;/code&gt; ), since it isn't much use otherwise.</source>
          <target state="translated">Если ШАБЛОН - &lt;code&gt;/^/&lt;/code&gt; , то он обрабатывается так, как если бы он использовал &lt;a href=&quot;perlreref#OPERATORS&quot;&gt;многострочный модификатор&lt;/a&gt; ( &lt;code&gt;/^/m&lt;/code&gt; ), поскольку в противном случае он мало используется.</target>
        </trans-unit>
        <trans-unit id="0d84847fbb60054df16b3ab82d500263906bc774" translate="yes" xml:space="preserve">
          <source>If PATTERN is &lt;code&gt;/^/&lt;/code&gt;, then it is treated as if it used the &lt;a href=&quot;perlreref#OPERATORS&quot;&gt;multiline modifier&lt;/a&gt; (&lt;code&gt;/^/m&lt;/code&gt;), since it isn't much use otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab2206e4a8b71981bc3526b21e6f961d2fc978f" translate="yes" xml:space="preserve">
          <source>If PATTERN matches the empty string, the EXPR is split at the match position (between characters). As an example, the following:</source>
          <target state="translated">Если PATTERN совпадает с пустой строкой,то EXPR разбивается на позицию совпадения (между символами).В качестве примера можно привести следующее:</target>
        </trans-unit>
        <trans-unit id="bf4c909b9fa78435a98bf6dd9ce2fb396fdd71cb" translate="yes" xml:space="preserve">
          <source>If PERL5LIB is not defined, &lt;a href=&quot;#PERLLIB&quot;&gt;&quot;PERLLIB&quot;&lt;/a&gt; is used. Directories are separated (like in PATH) by a colon on Unixish platforms and by a semicolon on Windows (the proper path separator being given by the command &lt;code&gt;perl -V:&lt;i&gt;path_sep&lt;/i&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b7e2477c70af9a1ce418a622d9557a0b72af87" translate="yes" xml:space="preserve">
          <source>If PERL5LIB is not defined, PERLLIB is used. Directories are separated (like in PATH) by a colon on Unixish platforms and by a semicolon on Windows (the proper path separator being given by the command &lt;code&gt;perl
-V:&lt;i&gt;path_sep&lt;/i&gt;&lt;/code&gt;).</source>
          <target state="translated">Если PERL5LIB не определен, используется PERLLIB. Каталоги разделяются (как в PATH) двоеточием на платформах Unixish и точкой с запятой в Windows (правильный разделитель пути задается командой &lt;code&gt;perl -V:&lt;i&gt;path_sep&lt;/i&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e3cb4284864a564ca2b51274a4f3fa62dd73a592" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_ALL is set then all input chars will be output using &lt;code&gt;\x01F1&lt;/code&gt; style escapes, otherwise if PERL_PV_ESCAPE_NONASCII is set, only non-ASCII chars will be escaped using this style; otherwise, only chars above 255 will be so escaped; other non printable chars will use octal or common escaped patterns like &lt;code&gt;\n&lt;/code&gt; . Otherwise, if PERL_PV_ESCAPE_NOBACKSLASH then all chars below 255 will be treated as printable and will be output as literals.</source>
          <target state="translated">Если установлен PERL_PV_ESCAPE_ALL, то все входные символы будут выводиться с использованием &lt;code&gt;\x01F1&lt;/code&gt; стиля \ x01F1 , в противном случае, если установлен PERL_PV_ESCAPE_NONASCII, с использованием этого стиля будут экранированы только символы, отличные от ASCII; иначе будут экранированы только символы выше 255; другие непечатаемые символы будут использовать восьмеричные или обычные экранированные шаблоны, такие как &lt;code&gt;\n&lt;/code&gt; . В противном случае, если PERL_PV_ESCAPE_NOBACKSLASH, тогда все символы ниже 255 будут обрабатываться как печатаемые и будут выводиться как литералы.</target>
        </trans-unit>
        <trans-unit id="03a5b31adb12c35d2862c64e653c8076e4f81a1b" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_FIRSTCHAR is set then only the first char of the string will be escaped, regardless of max. If the output is to be in hex, then it will be returned as a plain hex sequence. Thus the output will either be a single char, an octal escape sequence, a special escape like &lt;code&gt;\n&lt;/code&gt; or a hex value.</source>
          <target state="translated">Если PERL_PV_ESCAPE_FIRSTCHAR установлен, то только первый символ строки будет экранирован, независимо от max. Если вывод должен быть в шестнадцатеричном формате, он будет возвращен как обычная шестнадцатеричная последовательность. Таким образом, на выходе будет либо один символ, либо восьмеричная escape-последовательность, либо специальный escape- код, например &lt;code&gt;\n&lt;/code&gt; или шестнадцатеричное значение.</target>
        </trans-unit>
        <trans-unit id="4fd0e08a5001bbfc2db16575c706877131f99c11" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_RE is set then the escape char used will be a '%' and not a '\\'. This is because regexes very often contain backslashed sequences, whereas '%' is not a particularly common character in patterns.</source>
          <target state="translated">Если PERL_PV_ESCAPE_RE установлена,то используемый escape char будет '%',а не '\\'.Это связано с тем,что регексы очень часто содержат обратные последовательности,в то время как '%' не является особенно распространенным символом в шаблонах.</target>
        </trans-unit>
        <trans-unit id="c327fff20e1a2d0d479391141282091e826a55c6" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_UNI is set then the input string is treated as UTF-8 if PERL_PV_ESCAPE_UNI_DETECT is set then the input string is scanned using &lt;code&gt;is_utf8_string()&lt;/code&gt; to determine if it is UTF-8.</source>
          <target state="translated">Если установлен PERL_PV_ESCAPE_UNI, то входная строка обрабатывается как UTF-8, если PERL_PV_ESCAPE_UNI_DETECT установлен, тогда входная строка сканируется с помощью &lt;code&gt;is_utf8_string()&lt;/code&gt; чтобы определить, является ли она UTF-8.</target>
        </trans-unit>
        <trans-unit id="19515a44b91c296bde08fb195c3206ce5ee06393" translate="yes" xml:space="preserve">
          <source>If PID is a subprocess started by a piped &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;), &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; will wait for that subprocess, and return its final status value in &lt;code&gt;$?&lt;/code&gt; . If PID is a subprocess created in some other way (e.g. SPAWNed before Perl was invoked), &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; will simply check once per second whether the process has completed, and return when it has. (If PID specifies a process that isn't a subprocess of the current process, and you invoked Perl with the &lt;code&gt;-w&lt;/code&gt; switch, a warning will be issued.)</source>
          <target state="translated">Если PID - это подпроцесс, запущенный с помощью конвейерной функции &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; (см. &lt;a href=&quot;open&quot;&gt;Open&lt;/a&gt; ), &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; будет ждать этого подпроцесса и возвращать его окончательное значение статуса в &lt;code&gt;$?&lt;/code&gt; . Если PID - это подпроцесс, созданный каким-либо другим способом (например, SPAWNed перед вызовом Perl), &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; будет просто проверять один раз в секунду, завершился ли процесс, и возвращать, когда это произошло. (Если PID указывает процесс, который не является подпроцессом текущего процесса, и вы вызвали Perl с ключом &lt;code&gt;-w&lt;/code&gt; , будет выдано предупреждение.)</target>
        </trans-unit>
        <trans-unit id="e7c89908fc623a7d026e9fd9f90cd1799c25d8d3" translate="yes" xml:space="preserve">
          <source>If PID is a subprocess started by a piped &lt;code&gt;open()&lt;/code&gt; (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;), &lt;code&gt;waitpid&lt;/code&gt; will wait for that subprocess, and return its final status value in &lt;code&gt;$?&lt;/code&gt;. If PID is a subprocess created in some other way (e.g. SPAWNed before Perl was invoked), &lt;code&gt;waitpid&lt;/code&gt; will simply check once per second whether the process has completed, and return when it has. (If PID specifies a process that isn't a subprocess of the current process, and you invoked Perl with the &lt;code&gt;-w&lt;/code&gt; switch, a warning will be issued.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2833d231deee2ce7c48c3ef06baaabad2e5a0de9" translate="yes" xml:space="preserve">
          <source>If PPCODE: directive is not used, &lt;code&gt;void&lt;/code&gt; return value should be used only for subroutines which do not return a value,</source>
          <target state="translated">Если директива PPCODE: не используется, возвращаемое значение &lt;code&gt;void&lt;/code&gt; должно использоваться только для подпрограмм, которые не возвращают значение,</target>
        </trans-unit>
        <trans-unit id="c393beed824f2acf513d9860e129eb5ffe2baeec" translate="yes" xml:space="preserve">
          <source>If PadnameOUTER is set on the pad name, then that slot in the frame AV is a REFCNT'ed reference to a lexical from &quot;outside&quot;. Such entries are sometimes referred to as 'fake'. In this case, the name does not use 'low' and 'high' to store a cop_seq range, since it is in scope throughout. Instead 'high' stores some flags containing info about the real lexical (is it declared in an anon, and is it capable of being instantiated multiple times?), and for fake ANONs, 'low' contains the index within the parent's pad where the lexical's value is stored, to make cloning quicker.</source>
          <target state="translated">Если PadnameOUTER установлен на имени колодки,то этот слот в кадре AV является ссылкой REFCNT'ed на лексику &quot;снаружи&quot;.Такие записи иногда называют &quot;фальшивыми&quot;.В этом случае имя не использует 'low' и 'high' для хранения диапазона cop_seq,так как он находится в области видимости на всем протяжении.Вместо этого 'high' хранит некоторые флаги,содержащие информацию о реальном лексиконе (объявлен ли он в аноне и может ли он быть инстанцирован несколько раз?),а для поддельных ANON'ов,'low' содержит индекс в родительском блокноте,где хранится значение лексики,чтобы сделать клонирование более быстрым.</target>
        </trans-unit>
        <trans-unit id="40be3d27de878e5185ba9875f176a67d8334894d" translate="yes" xml:space="preserve">
          <source>If Perl cannot find the method in any of these classes, it will die with an error message.</source>
          <target state="translated">Если Perl не сможет найти метод ни в одном из этих классов,он умрет с сообщением об ошибке.</target>
        </trans-unit>
        <trans-unit id="ef114bcc0bbc93d31f879d70b2e23b29c28c176d" translate="yes" xml:space="preserve">
          <source>If Perl detects that there are problems with the locale collation order, it reverts to using non-locale collation rules for that locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a89c2d4d03a490ab54c26429553ad753f25a36f" translate="yes" xml:space="preserve">
          <source>If Perl finds that the found executable is of PM type when the current session is not, it will start the new process in a separate session of necessary type. Call via &lt;code&gt;OS2::Process&lt;/code&gt; to disable this magic.</source>
          <target state="translated">Если Perl обнаружит, что найденный исполняемый файл относится к типу PM, а текущий сеанс - нет, он запустит новый процесс в отдельном сеансе необходимого типа. Вызовите через &lt;code&gt;OS2::Process&lt;/code&gt; чтобы отключить эту магию.</target>
        </trans-unit>
        <trans-unit id="289a7b0542dd20aefdd9191d5f173083a238571f" translate="yes" xml:space="preserve">
          <source>If Perl has been compiled using Perl's malloc you can analyze Perl memory usage by setting $ENV{PERL_DEBUG_MSTATS}.</source>
          <target state="translated">Если Perl был скомпилирован с использованием Perl's malloc,вы можете проанализировать использование памяти Perl,установив $ENV{PERL_DEBUG_MSTATS}.</target>
        </trans-unit>
        <trans-unit id="230e2bfc79d0ba462c1beaf813fc67b45a5f8378" translate="yes" xml:space="preserve">
          <source>If Perl is not built to use PerlIO as its IO system then only the two pseudo-layers &lt;code&gt;:bytes&lt;/code&gt; and &lt;code&gt;:crlf&lt;/code&gt; are available.</source>
          <target state="translated">Если Perl не создан для использования PerlIO в качестве системы ввода-вывода, тогда доступны только два псевдо-уровня &lt;code&gt;:bytes&lt;/code&gt; и &lt;code&gt;:crlf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6264d3e40b3079f00ff5fcba981797a472b669d0" translate="yes" xml:space="preserve">
          <source>If Perl was not built with socket support, the system call version of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; is not available at all. If socket support is present, then the system call version of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; functions only for file descriptors attached to sockets. It will not provide information about regular files or pipes, since the CRTL &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; routine does not provide this functionality.</source>
          <target state="translated">Если Perl не был построен с поддержкой сокетов, версия системного вызова &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; будет вообще недоступна. Если поддержка сокетов присутствует, то версия системного вызова функций &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; только для файловых дескрипторов, прикрепленных к сокетам. Он не будет предоставлять информацию об обычных файлах или каналах, поскольку процедура &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; CRTL не предоставляет эту функциональность.</target>
        </trans-unit>
        <trans-unit id="35e051c99f37dfed774297cb967d8106c5e199d4" translate="yes" xml:space="preserve">
          <source>If Perl was not built with socket support, the system call version of &lt;code&gt;select&lt;/code&gt; is not available at all. If socket support is present, then the system call version of &lt;code&gt;select&lt;/code&gt; functions only for file descriptors attached to sockets. It will not provide information about regular files or pipes, since the CRTL &lt;code&gt;select()&lt;/code&gt; routine does not provide this functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a129f6da7edb3d3e9d992e64ee7ec5edc1382d" translate="yes" xml:space="preserve">
          <source>If Perldoc is running under MSWin and uses this class as a formatter, the output will be opened with</source>
          <target state="translated">Если Perldoc работает под MSWin и использует этот класс в качестве форматора,то вывод будет открыт с помощью параметра</target>
        </trans-unit>
        <trans-unit id="48a7e7d61da87b6e49574cb96f576ab3af92a97c" translate="yes" xml:space="preserve">
          <source>If Pod::Man is given the &lt;code&gt;utf8&lt;/code&gt; option, the encoding of its output file handle will be forced to UTF-8 if possible, overriding any existing encoding. This will be done even if the file handle is not created by Pod::Man and was passed in from outside. This maintains consistency regardless of PERL_UNICODE and other settings.</source>
          <target state="translated">Если для Pod :: Man задана опция &lt;code&gt;utf8&lt;/code&gt; , кодировка его дескриптора выходного файла будет принудительно установлена ​​в UTF-8, если это возможно, переопределив любую существующую кодировку. Это будет сделано, даже если дескриптор файла не был создан Pod :: Man, а был передан извне. Это поддерживает согласованность независимо от PERL_UNICODE и других настроек.</target>
        </trans-unit>
        <trans-unit id="89e668a66a16049973d228d4291fce70e3c9695a" translate="yes" xml:space="preserve">
          <source>If Pod::Man is unavailable, this function will warn and return undef.</source>
          <target state="translated">Если Pod::Man недоступен,эта функция предупредит и вернет undef.</target>
        </trans-unit>
        <trans-unit id="0b2424487d45dbfa5c1b518ecd9497b822e7398c" translate="yes" xml:space="preserve">
          <source>If Pod::Simple sends an event where the element name has a dash, period, or colon, the corresponding method name will have a underscore in its place. For example, &quot;foo.bar:baz&quot; becomes start_foo_bar_baz and end_foo_bar_baz.</source>
          <target state="translated">Если Pod::Simple посылает событие,в котором имя элемента имеет тире,периоде или двоеточие,то соответствующее имя метода будет иметь на своем месте подчеркивание.Например,&quot;foo.bar:baz&quot; становится start_foo_bar_baz и end_foo_bar_baz.</target>
        </trans-unit>
        <trans-unit id="9e0153ee2898f6429d842dbcd6c0696456ff28ca" translate="yes" xml:space="preserve">
          <source>If Pod::Text is given the &lt;code&gt;utf8&lt;/code&gt; option, the encoding of its output file handle will be forced to UTF-8 if possible, overriding any existing encoding. This will be done even if the file handle is not created by Pod::Text and was passed in from outside. This maintains consistency regardless of PERL_UNICODE and other settings.</source>
          <target state="translated">Если для Pod :: Text задана опция &lt;code&gt;utf8&lt;/code&gt; , кодировка его дескриптора выходного файла будет принудительно установлена ​​на UTF-8, если это возможно, переопределив любую существующую кодировку. Это будет сделано, даже если дескриптор файла не был создан Pod :: Text, а был передан извне. Это поддерживает согласованность независимо от PERL_UNICODE и других настроек.</target>
        </trans-unit>
        <trans-unit id="a28c6ae29cd39f20d43e841a87f74f6e887bacb7" translate="yes" xml:space="preserve">
          <source>If RXf_WHITE is set in addition to this flag, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; will behave like &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; &quot; &quot;&lt;/code&gt; under the Perl engine.</source>
          <target state="translated">Если RXf_WHITE установлен в дополнение к этому флагу, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; будет вести себя как &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; &quot; &quot;&lt;/code&gt; под движком Perl.</target>
        </trans-unit>
        <trans-unit id="cf4453d6aaace8cb227f665bb65347d32d2472e7" translate="yes" xml:space="preserve">
          <source>If RXf_WHITE is set in addition to this flag, &lt;code&gt;split&lt;/code&gt; will behave like &lt;code&gt;split &quot; &quot;&lt;/code&gt; under the Perl engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03dddb9eda0980e6158ca2dd506258dca11f657b" translate="yes" xml:space="preserve">
          <source>If SIGNAL is either the number 0 or the string &lt;code&gt;ZERO&lt;/code&gt; (or &lt;code&gt;SIGZERO&lt;/code&gt; ), no signal is sent to the process, but &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; checks whether it's</source>
          <target state="translated">Если SIGNAL - это либо число 0, либо строка &lt;code&gt;ZERO&lt;/code&gt; (или &lt;code&gt;SIGZERO&lt;/code&gt; ), сигнал процессу не отправляется, но &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; проверяет, действительно ли он</target>
        </trans-unit>
        <trans-unit id="a487625a13afee57a95232e398ffaae21162742b" translate="yes" xml:space="preserve">
          <source>If SIGNAL is either the number 0 or the string &lt;code&gt;ZERO&lt;/code&gt; (or &lt;code&gt;SIGZERO&lt;/code&gt; ), no signal is sent to the process, but &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; checks whether it's</source>
          <target state="translated">Если SIGNAL - это либо число 0, либо строка &lt;code&gt;ZERO&lt;/code&gt; (или &lt;code&gt;SIGZERO&lt;/code&gt; ), сигнал процессу не отправляется, но &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; проверяет, действительно ли он</target>
        </trans-unit>
        <trans-unit id="760e1ef9a0dd7acd780a886234880aed4a2bbd19" translate="yes" xml:space="preserve">
          <source>If SIGNAL is either the number 0 or the string &lt;code&gt;ZERO&lt;/code&gt; (or &lt;code&gt;SIGZERO&lt;/code&gt;), no signal is sent to the process, but &lt;a href=&quot;#kill-SIGNAL%2C-LIST&quot;&gt;&lt;code&gt;kill&lt;/code&gt;&lt;/a&gt; checks whether it's</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e68aad72417aeb3ce465d6bb5919f187ede4dff2" translate="yes" xml:space="preserve">
          <source>If SUBNAME or BLOCK is omitted, &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;s in standard string comparison order. If SUBNAME is specified, it gives the name of a subroutine that returns an integer less than, equal to, or greater than &lt;code&gt;0&lt;/code&gt;, depending on how the elements of the list are to be ordered. (The &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; operators are extremely useful in such routines.) SUBNAME may be a scalar variable name (unsubscripted), in which case the value provides the name of (or a reference to) the actual subroutine to use. In place of a SUBNAME, you can provide a BLOCK as an anonymous, in-line sort subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e4af5120e01452063bdba16ab4dbac8800d707" translate="yes" xml:space="preserve">
          <source>If SUBNAME or BLOCK is omitted, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;s in standard string comparison order. If SUBNAME is specified, it gives the name of a subroutine that returns an integer less than, equal to, or greater than &lt;code&gt;0&lt;/code&gt; , depending on how the elements of the list are to be ordered. (The &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; operators are extremely useful in such routines.) SUBNAME may be a scalar variable name (unsubscripted), in which case the value provides the name of (or a reference to) the actual subroutine to use. In place of a SUBNAME, you can provide a BLOCK as an anonymous, in-line sort subroutine.</source>
          <target state="translated">Если подимени или BLOCK опущен, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; S в стандартном порядке сравнения строк. Если указано SUBNAME, оно дает имя подпрограммы, которая возвращает целое число, меньшее, равное или большее &lt;code&gt;0&lt;/code&gt; , в зависимости от того, как должны быть упорядочены элементы списка. (Операторы &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; и &lt;code&gt;cmp&lt;/code&gt; чрезвычайно полезны в таких подпрограммах.) SUBNAME может быть именем скалярной переменной (без подписи), и в этом случае значение предоставляет имя (или ссылку) на действительную подпрограмму для использования. Вместо SUBNAME вы можете предоставить BLOCK в качестве анонимной подпрограммы встроенной сортировки.</target>
        </trans-unit>
        <trans-unit id="6247155ef0e0949eed5f5b9ad662fcdc5e0b1a55" translate="yes" xml:space="preserve">
          <source>If SUBNAME or BLOCK is omitted, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;s in standard string comparison order. If SUBNAME is specified, it gives the name of a subroutine that returns an integer less than, equal to, or greater than &lt;code&gt;0&lt;/code&gt; , depending on how the elements of the list are to be ordered. (The &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; operators are extremely useful in such routines.) SUBNAME may be a scalar variable name (unsubscripted), in which case the value provides the name of (or a reference to) the actual subroutine to use. In place of a SUBNAME, you can provide a BLOCK as an anonymous, in-line sort subroutine.</source>
          <target state="translated">Если подимени или BLOCK опущен, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; S в стандартном порядке сравнения строк. Если указано SUBNAME, оно дает имя подпрограммы, которая возвращает целое число, меньшее, равное или большее &lt;code&gt;0&lt;/code&gt; , в зависимости от того, как должны быть упорядочены элементы списка. (Операторы &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; и &lt;code&gt;cmp&lt;/code&gt; чрезвычайно полезны в таких подпрограммах.) SUBNAME может быть именем скалярной переменной (без подписи), и в этом случае значение предоставляет имя (или ссылку) на действительную подпрограмму для использования. Вместо SUBNAME вы можете предоставить BLOCK в качестве анонимной подпрограммы встроенной сортировки.</target>
        </trans-unit>
        <trans-unit id="e18998d6455bfefedf4a886cffa8b0ef65421368" translate="yes" xml:space="preserve">
          <source>If TEMPLATE requires more arguments than &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; is given, &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; assumes additional &lt;code&gt;&quot;&quot;&lt;/code&gt; arguments. If TEMPLATE requires fewer arguments than given, extra arguments are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a13dff4a6a23dd2b6f1693ccf60f7a4736231a4" translate="yes" xml:space="preserve">
          <source>If TEMPLATE requires more arguments than pack() is given, pack() assumes additional &lt;code&gt;&quot;&quot;&lt;/code&gt; arguments. If TEMPLATE requires fewer arguments than given, extra arguments are ignored.</source>
          <target state="translated">Если ШАБЛОН требует больше аргументов , чем пакет () дается, упаковка () принимает дополнительные &lt;code&gt;&quot;&quot;&lt;/code&gt; аргументы. Если для TEMPLATE требуется меньше аргументов, чем указано, дополнительные аргументы игнорируются.</target>
        </trans-unit>
        <trans-unit id="6967af7192ea24b7740b2426c675e802544ce8cd" translate="yes" xml:space="preserve">
          <source>If UTF-8 is not an option, it is recommended that one use a simple source filter, such as that provided by &lt;a href=&quot;Filter::Encoding&quot;&gt;Filter::Encoding&lt;/a&gt; on CPAN or this pragma's own &lt;code&gt;Filter&lt;/code&gt; option (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb29e6534b18adbdd32bd69eb254a626c55b85e" translate="yes" xml:space="preserve">
          <source>If UUID tagging is enabled (See &lt;a href=&quot;Test::API&quot;&gt;Test::API&lt;/a&gt;) then any event that has made its way through a hub will be tagged with a UUID. A newly created event will not yet be tagged in most cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de2a274592488096eee3c1b57b817384e167ac5" translate="yes" xml:space="preserve">
          <source>If UUID tagging is enabled (see &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt;) then the hub will have a UUID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71eeb63629102190a2491abe8e8c2cd018b18803" translate="yes" xml:space="preserve">
          <source>If Unix level &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;lseek&lt;/code&gt; is not appropriate for (say) sockets then the &quot;unix&quot; layer can be replaced (at open time or even dynamically) with a &quot;socket&quot; layer.</source>
          <target state="translated">Если уровень Unix для &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;lseek&lt;/code&gt; не подходит (скажем) для сокетов, то уровень &amp;laquo;unix&amp;raquo; можно заменить (во время открытия или даже динамически) на уровень &amp;laquo;сокетов&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="4ad97d1c9f2c86a7f96565662052eb1a286aaff7" translate="yes" xml:space="preserve">
          <source>If Unix level &lt;code&gt;read&lt;/code&gt;/&lt;code&gt;write&lt;/code&gt;/&lt;code&gt;lseek&lt;/code&gt; is not appropriate for (say) sockets then the &quot;unix&quot; layer can be replaced (at open time or even dynamically) with a &quot;socket&quot; layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45f1369b52ed08794c418037dc006ec04f43394" translate="yes" xml:space="preserve">
          <source>If VARIABLE is a hash, it chomps the hash's values, but not its keys, resetting the &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; iterator in the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc19b00b38eb533e11534d089e59dc6d18d7552" translate="yes" xml:space="preserve">
          <source>If VARIABLE is a hash, it chomps the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">Если VARIABLE является хешем, он перехватывает значения хеша, но не его ключи, сбрасывая &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; итератор в процессе.</target>
        </trans-unit>
        <trans-unit id="dafdb7a192ed4ebf56859ae04ece9ebbc7f84c1d" translate="yes" xml:space="preserve">
          <source>If VARIABLE is a hash, it chomps the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">Если VARIABLE является хешем, он перехватывает значения хеша, но не его ключи, сбрасывая &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; итератор в процессе.</target>
        </trans-unit>
        <trans-unit id="748a0699c69c26183bfd333929c05d94a8696f0e" translate="yes" xml:space="preserve">
          <source>If VERSION is provided, &lt;a href=&quot;#package-NAMESPACE&quot;&gt;&lt;code&gt;package&lt;/code&gt;&lt;/a&gt; sets the &lt;code&gt;$VERSION&lt;/code&gt; variable in the given namespace to a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object with the VERSION provided. VERSION must be a &quot;strict&quot; style version number as defined by the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module: a positive decimal number (integer or decimal-fraction) without exponentiation or else a dotted-decimal v-string with a leading 'v' character and at least three components. You should set &lt;code&gt;$VERSION&lt;/code&gt; only once per package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9c742cbb93e88b3095e1366a5e0ca8820689343" translate="yes" xml:space="preserve">
          <source>If VERSION is provided, &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; sets the &lt;code&gt;$VERSION&lt;/code&gt; variable in the given namespace to a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object with the VERSION provided. VERSION must be a &quot;strict&quot; style version number as defined by the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module: a positive decimal number (integer or decimal-fraction) without exponentiation or else a dotted-decimal v-string with a leading 'v' character and at least three components. You should set &lt;code&gt;$VERSION&lt;/code&gt; only once per package.</source>
          <target state="translated">Если предоставляется VERSION, &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; устанавливает переменную &lt;code&gt;$VERSION&lt;/code&gt; в данном пространстве имен для объекта &lt;a href=&quot;version&quot;&gt;версии&lt;/a&gt; с предоставленной VERSION. ВЕРСИЯ должна быть номером версии в &quot;строгом&quot; стиле, как определено модулем &lt;a href=&quot;version&quot;&gt;версии&lt;/a&gt; : положительное десятичное число (целое или десятичная дробь) без возведения в степень или десятичная строка с точками с начальным символом 'v' и не менее трех составные части. Вы должны установить &lt;code&gt;$VERSION&lt;/code&gt; только один раз для каждого пакета.</target>
        </trans-unit>
        <trans-unit id="4bfad8b6a5366a04a7526e534903361716196c11" translate="yes" xml:space="preserve">
          <source>If VERSION is provided, &lt;code&gt;&lt;a href=&quot;package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; sets the &lt;code&gt;$VERSION&lt;/code&gt; variable in the given namespace to a &lt;a href=&quot;../version&quot;&gt;version&lt;/a&gt; object with the VERSION provided. VERSION must be a &quot;strict&quot; style version number as defined by the &lt;a href=&quot;../version&quot;&gt;version&lt;/a&gt; module: a positive decimal number (integer or decimal-fraction) without exponentiation or else a dotted-decimal v-string with a leading 'v' character and at least three components. You should set &lt;code&gt;$VERSION&lt;/code&gt; only once per package.</source>
          <target state="translated">Если предоставляется VERSION, &lt;code&gt;&lt;a href=&quot;package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; устанавливает переменную &lt;code&gt;$VERSION&lt;/code&gt; в данном пространстве имен для объекта &lt;a href=&quot;../version&quot;&gt;версии&lt;/a&gt; с предоставленной VERSION. ВЕРСИЯ должна быть номером версии в &quot;строгом&quot; стиле, как определено модулем &lt;a href=&quot;../version&quot;&gt;версии&lt;/a&gt; : положительное десятичное число (целое или десятичная дробь) без возведения в степень или десятичная строка с точками с начальным символом 'v' и не менее трех составные части. Вы должны установить &lt;code&gt;$VERSION&lt;/code&gt; только один раз для каждого пакета.</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">Если</target>
        </trans-unit>
        <trans-unit id="d95c8bef773580433166be7c2c32b85e8e849e6f" translate="yes" xml:space="preserve">
          <source>If a 2-digit code is entered, it is converted to 3 digits by prepending a 0.</source>
          <target state="translated">Если вводится 2-значный код,то он преобразуется в 3 цифры,предваряя 0.</target>
        </trans-unit>
        <trans-unit id="e64a7d7369be70b0218a1b95be79c2c2deb28c1d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; is used in a context that is looking for a list, a list comprising all input lines is returned, one line per list element. It's easy to grow to a rather large data space this way, so use with care.</source>
          <target state="translated">Если &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; используется в контексте, который ищет список, возвращается список, содержащий все входные строки, по одной строке на элемент списка. Таким образом легко вырасти до довольно большого пространства данных, поэтому используйте его с осторожностью.</target>
        </trans-unit>
        <trans-unit id="259cdf2dd383c0f84fbe2ca3b6aceeeeaeccb785" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can find a &lt;code&gt;CxEVAL&lt;/code&gt; block on the context stack, then the stack is popped to that level and the return op in that block is assigned to &lt;code&gt;PL_restartop&lt;/code&gt; ; then a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; is performed. This normally passes control back to the guard. In the case of &lt;code&gt;perl_run&lt;/code&gt; and &lt;code&gt;call_sv&lt;/code&gt; , a non-null &lt;code&gt;PL_restartop&lt;/code&gt; triggers re-entry to the runops loop. The is the normal way that &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; is handled within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; может найти блок &lt;code&gt;CxEVAL&lt;/code&gt; в стеке контекста, тогда стек выталкивается на этот уровень, и &lt;code&gt;PL_restartop&lt;/code&gt; возврата в этом блоке назначается PL_restartop ; затем выполняется &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; . Обычно это возвращает управление охраннику. В случае &lt;code&gt;perl_run&lt;/code&gt; и &lt;code&gt;call_sv&lt;/code&gt; ненулевой &lt;code&gt;PL_restartop&lt;/code&gt; запускает повторный вход в цикл runops. Это нормальный способ обработки &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;croak&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e842b426c14ec5c17e64ac341313bcce514b5ce" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), the case map used by &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , and &lt;code&gt;\U&lt;/code&gt; is taken from the current locale. If Unicode (for example, &lt;code&gt;\N{}&lt;/code&gt; or code points of 0x100 or beyond) is being used, the case map used by &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , and &lt;code&gt;\U&lt;/code&gt; is as defined by Unicode. That means that case-mapping a single character can sometimes produce a sequence of several characters. Under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; produces the same results as &lt;code&gt;\L&lt;/code&gt; for all locales but a UTF-8 one, where it instead uses the Unicode definition.</source>
          <target state="translated">Если действует форма &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , включающая &lt;code&gt;LC_CTYPE&lt;/code&gt; (см. &lt;a href=&quot;perllocale&quot;&gt;Perllocale&lt;/a&gt; ), то карта регистра, используемая &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; и &lt;code&gt;\U&lt;/code&gt; , берется из текущей локали. Если используется Юникод (например, &lt;code&gt;\N{}&lt;/code&gt; или кодовые точки 0x100 или выше), то карта регистра, используемая &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; и &lt;code&gt;\U&lt;/code&gt; определяется Unicode. Это означает, что преобразование регистра одного символа может иногда создавать последовательность из нескольких символов. При &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; производит те же результаты, &lt;code&gt;\L&lt;/code&gt; для всех языков, кроме UTF-8, где вместо этого используется определение Unicode.</target>
        </trans-unit>
        <trans-unit id="549e5fcf45cf7944f8141812970bb7a27ad11345" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Net::POP3&lt;/code&gt; object goes out of scope before &lt;code&gt;quit&lt;/code&gt; method is called then the &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; method will called before the connection is closed. This means that any messages marked to be deleted will not be.</source>
          <target state="translated">Если объект &lt;code&gt;Net::POP3&lt;/code&gt; выходит за пределы области действия до &lt;code&gt;quit&lt;/code&gt; метода quit, метод &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; будет вызван до закрытия соединения. Это означает, что никаких сообщений, отмеченных для удаления, не будет.</target>
        </trans-unit>
        <trans-unit id="a47a3059ef284fb95d6b9b8a42daebf746f1630a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Net::POP3&lt;/code&gt; object goes out of scope before &lt;code&gt;quit&lt;/code&gt; method is called then the &lt;code&gt;reset&lt;/code&gt; method will called before the connection is closed. This means that any messages marked to be deleted will not be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ca4e33c078b9485b94c680710b01ed3f239b5b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;die&lt;/code&gt; can find a &lt;code&gt;CxEVAL&lt;/code&gt; block on the context stack, then the stack is popped to that level and the return op in that block is assigned to &lt;code&gt;PL_restartop&lt;/code&gt;; then a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; is performed. This normally passes control back to the guard. In the case of &lt;code&gt;perl_run&lt;/code&gt; and &lt;code&gt;call_sv&lt;/code&gt;, a non-null &lt;code&gt;PL_restartop&lt;/code&gt; triggers re-entry to the runops loop. The is the normal way that &lt;code&gt;die&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; is handled within an &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb19ff7cc72a6855d9adc1ecae2faf667648c06d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;glob&lt;/code&gt; expression is used as the condition of a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;for&lt;/code&gt; loop, then it will be implicitly assigned to &lt;code&gt;$_&lt;/code&gt;. If either a &lt;code&gt;glob&lt;/code&gt; expression or an explicit assignment of a &lt;code&gt;glob&lt;/code&gt; expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c439913b54ad4e9472f5fab7228ffbede4917134" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;timeout&lt;/code&gt; in seconds is provided, it is used when a timeout is not given to the ping() method (below). The timeout must be greater than 0 and the default, if not specified, is 5 seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05512b28e37ad32af54fde978f1e0fe4ada4db04" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;use locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), the case map used by &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, and &lt;code&gt;\U&lt;/code&gt; is taken from the current locale. If Unicode (for example, &lt;code&gt;\N{}&lt;/code&gt; or code points of 0x100 or beyond) is being used, the case map used by &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, and &lt;code&gt;\U&lt;/code&gt; is as defined by Unicode. That means that case-mapping a single character can sometimes produce a sequence of several characters. Under &lt;code&gt;use locale&lt;/code&gt;, &lt;code&gt;\F&lt;/code&gt; produces the same results as &lt;code&gt;\L&lt;/code&gt; for all locales but a UTF-8 one, where it instead uses the Unicode definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="043d74f31a25532198b1527d3ae5c4b1da9715ef" translate="yes" xml:space="preserve">
          <source>If a CODE reference is not used, a</source>
          <target state="translated">Если ссылка на КОД не используется,a</target>
        </trans-unit>
        <trans-unit id="e12066458359083bdcf249636aa07df8a14816c7" translate="yes" xml:space="preserve">
          <source>If a CODE reference is used then a</source>
          <target state="translated">Если используется ссылка на CODE,то</target>
        </trans-unit>
        <trans-unit id="f9ad0abaf0eff45a492a44f419b412cf87f4dd03" translate="yes" xml:space="preserve">
          <source>If a FILEHANDLE is supplied, it must be writable and opened in append mode (i.e., use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, '&amp;gt;&amp;gt;filename')&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen(FH,...,O_APPEND|O_RDWR)&lt;/a&gt;&lt;/code&gt;. If a filename is supplied, it should not be held open elsewhere. (Win32)</source>
          <target state="translated">Если предоставляется FILEHANDLE, он должен быть доступен для записи и открыт в режиме добавления (т. &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen(FH,...,O_APPEND|O_RDWR)&lt;/a&gt;&lt;/code&gt; Используйте &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, '&amp;gt;&amp;gt;filename')&lt;/code&gt; или sysopen (FH, ..., O_APPEND | O_RDWR) . Если указано имя файла, оно не должны храниться где-либо еще. (Win32)</target>
        </trans-unit>
        <trans-unit id="4d47de1f691dd0b1134ca70f07b0ea6e9d81891d" translate="yes" xml:space="preserve">
          <source>If a Perl script begins with the Unicode &lt;code&gt;BOM&lt;/code&gt; (UTF-16LE, UTF16-BE), or if the script looks like non-&lt;code&gt;BOM&lt;/code&gt;-marked UTF-16 of either endianness, Perl will correctly read in the script as the appropriate Unicode encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e2f604f1de94503f88fcf2788fa5b11ed58ca8" translate="yes" xml:space="preserve">
          <source>If a Perl script begins with the bytes that form the UTF-8 encoding of the Unicode BYTE ORDER MARK (&lt;code&gt;BOM&lt;/code&gt;, see &lt;a href=&quot;#Unicode-Encodings&quot;&gt;&quot;Unicode Encodings&quot;&lt;/a&gt;), those bytes are completely ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af3f41934dd0fe8f979cc12d4f4c701b5fb0dcf" translate="yes" xml:space="preserve">
          <source>If a Pod processor sees any command other than the ones listed above (like &quot;=head&quot;, or &quot;=haed1&quot;, or &quot;=stuff&quot;, or &quot;=cuttlefish&quot;, or &quot;=w123&quot;), that processor must by default treat this as an error. It must not process the paragraph beginning with that command, must by default warn of this as an error, and may abort the parse. A Pod parser may allow a way for particular applications to add to the above list of known commands, and to stipulate, for each additional command, whether formatting codes should be processed.</source>
          <target state="translated">Если процессор Pod видит любую команду,кроме перечисленных выше (например,&quot;=head&quot;,или &quot;=haed1&quot;,или &quot;=stuff&quot;,или &quot;=cuttlefish&quot;,или &quot;=w123&quot;),то этот процессор должен по умолчанию рассматривать это как ошибку.Он не должен обрабатывать абзац,начинающийся с этой команды,должен по умолчанию предупреждать об этом как об ошибке и может прервать анализ.Парсер Pod может позволять конкретным приложениям добавлять к вышеуказанному списку известные команды,а также указывать для каждой дополнительной команды,следует ли обрабатывать коды форматирования.</target>
        </trans-unit>
        <trans-unit id="84d7b60c1fec814496b3c4bc1816a8d5d03c5699" translate="yes" xml:space="preserve">
          <source>If a Pod processor sees any formatting code other than the ones listed above (as in &quot;N&amp;lt;...&amp;gt;&quot;, or &quot;Q&amp;lt;...&amp;gt;&quot;, etc.), that processor must by default treat this as an error. A Pod parser may allow a way for particular applications to add to the above list of known formatting codes; a Pod parser might even allow a way to stipulate, for each additional command, whether it requires some form of special processing, as L&amp;lt;...&amp;gt; does.</source>
          <target state="translated">Если процессор Pod видит любой код форматирования, отличный от перечисленных выше (например, &amp;laquo;N &amp;lt;...&amp;gt;&amp;raquo; или &amp;laquo;Q &amp;lt;...&amp;gt;&amp;raquo; и т. Д.), Этот процессор должен по умолчанию рассматривать это как ошибку. . Парсер Pod может позволить конкретным приложениям добавлять к приведенному выше списку известных кодов форматирования; парсер Pod может даже позволить способ оговорить для каждой дополнительной команды, требует ли она какой-либо специальной обработки, как это делает L &amp;lt;...&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="a69d2c6e5370a359253a714b367c144cea0b32a3" translate="yes" xml:space="preserve">
          <source>If a SKIP directive is included with the plan, this method will return it.</source>
          <target state="translated">Если в план включена директива SKIP,то этот метод вернет ее.</target>
        </trans-unit>
        <trans-unit id="fc36fbb42452cd08e5fbc977b40571fcb5ba6163" translate="yes" xml:space="preserve">
          <source>If a SKIP directive was included with the plan, this method will return the explanation, if any.</source>
          <target state="translated">Если в план была включена директива SKIP,то этот метод вернет объяснение,если оно есть.</target>
        </trans-unit>
        <trans-unit id="21c8d4e7e9fdf0b61712f2ee7b9d5069189ec21c" translate="yes" xml:space="preserve">
          <source>If a TODO test does succeed, then the feature in question shouldn't be on the TODO list, now should it?</source>
          <target state="translated">Если тест TODO пройдет успешно,то данная функция не должна быть в списке TODO,не так ли?</target>
        </trans-unit>
        <trans-unit id="2e556764eb70dadb149264cc71dd4704e1aa8ecf" translate="yes" xml:space="preserve">
          <source>If a TODO test passes, &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will report it &quot;UNEXPECTEDLY SUCCEEDED&quot;. When that happens, remove the TODO block with &lt;code&gt;local $TODO&lt;/code&gt; and turn it into a real test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc13fa8b4104f174148a214dadae282567de13a" translate="yes" xml:space="preserve">
          <source>If a character that isn't an octal digit is encountered, a warning is raised, and the value is based on the octal digits before it, discarding it and all following characters up to the closing brace. It is a fatal error if there are no octal digits at all.</source>
          <target state="translated">Если встречается символ,не являющийся восьмеричной цифрой,то повышается предупреждение,и значение основано на восьмеричной цифре перед ним,отбрасывая ее и все последующие символы до замыкающей скобки.Это фатальная ошибка,если вообще не встречается восьмеричная цифра.</target>
        </trans-unit>
        <trans-unit id="b895fdf53ccf75b6f1d6a0f2ed9f43fb2b3e2bde" translate="yes" xml:space="preserve">
          <source>If a check for non-empty is what you wanted then just put it in boolean context (see &lt;a href=&quot;perldata#Scalar-values&quot;&gt;&quot;Scalar values&quot; in perldata&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ce7778730981e7a416c117aaec163fa0497dba" translate="yes" xml:space="preserve">
          <source>If a check for non-empty is what you wanted then just put it in boolean context (see &lt;a href=&quot;perldata#Scalar-values&quot;&gt;Scalar values in perldata&lt;/a&gt;):</source>
          <target state="translated">Если вам нужна проверка на &lt;a href=&quot;perldata#Scalar-values&quot;&gt;непустость,&lt;/a&gt; просто поместите ее в логический контекст (см. Скалярные значения в perldata ):</target>
        </trans-unit>
        <trans-unit id="7bbe66a04a030c6e054fb0dfd4a30c2a7ed6df30" translate="yes" xml:space="preserve">
          <source>If a child calls &quot;skip_all&quot; in the plan, a &lt;code&gt;Test::Builder::Exception&lt;/code&gt; is thrown. Trap this error, call &lt;code&gt;finalize()&lt;/code&gt; and don't run any more tests on the child.</source>
          <target state="translated">Если дочерний элемент в плане вызывает &amp;laquo;skip_all&amp;raquo;, генерируется &lt;code&gt;Test::Builder::Exception&lt;/code&gt; . Перехватите эту ошибку, вызовите &lt;code&gt;finalize()&lt;/code&gt; и больше не запускайте тесты для ребенка.</target>
        </trans-unit>
        <trans-unit id="d87e3904bd84922ce3c7497d798c1def1d62966e" translate="yes" xml:space="preserve">
          <source>If a collation sequence is not given, a default collation sequence is used. If the base is less than or equal to 36, the collation sequence is the string consisting of the 36 characters &quot;0&quot; to &quot;9&quot; and &quot;A&quot; to &quot;Z&quot;. In this case, the letter case in the input is ignored. If the base is greater than 36, and smaller than or equal to 62, the collation sequence is the string consisting of the 62 characters &quot;0&quot; to &quot;9&quot;, &quot;A&quot; to &quot;Z&quot;, and &quot;a&quot; to &quot;z&quot;. A base larger than 62 requires the collation sequence to be specified explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2b6a0e0e45f39177eb31d01e15e452bd57cce8" translate="yes" xml:space="preserve">
          <source>If a comparison subroutine (comp) is defined, it must return less than zero, zero, or greater than zero, if the first comparand is less than, equal, or greater than the second comparand.</source>
          <target state="translated">Если определена подпрограмма сравнения (comp),то она должна возвращать меньше нуля,нуля или больше нуля,если первый компаранд меньше,равен или больше второго компарда.</target>
        </trans-unit>
        <trans-unit id="6bcefbb01c642f7f0fc9b06ad8c1d9b86690b30e" translate="yes" xml:space="preserve">
          <source>If a config variable name ends with &lt;code&gt;list&lt;/code&gt; , it is a list. &lt;code&gt;o conf
KEY &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; removes the first element of the list, &lt;code&gt;o conf KEY &lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; removes the last element of the list. &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; LIST&lt;/code&gt; prepends a list of values to the list, &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; LIST&lt;/code&gt; appends a list of valued to the list.</source>
          <target state="translated">Если имя переменной конфигурации заканчивается на &lt;code&gt;list&lt;/code&gt; , это список. &lt;code&gt;o conf KEY &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; удаляет первый элемент списка, &lt;code&gt;o conf KEY &lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; удаляет последний элемент списка. &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; LIST&lt;/code&gt; добавляет список значений к списку, &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; LIST&lt;/code&gt; добавляет список значений к списку.</target>
        </trans-unit>
        <trans-unit id="5109117db036bd8645f50a5e04d368af63084ec5" translate="yes" xml:space="preserve">
          <source>If a container object, such as a hash or array, is locked, all the elements of that container are not locked. For example, if a thread does a &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt; @a&lt;/code&gt; , any other thread doing a &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock($a[12])&lt;/a&gt;&lt;/code&gt; won't block.</source>
          <target state="translated">Если объект-контейнер, такой как хэш или массив, заблокирован, все элементы этого контейнера не блокируются. Например, если поток выполняет &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt; @a&lt;/code&gt; , любой другой поток, выполняющий &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock($a[12])&lt;/a&gt;&lt;/code&gt; , не будет блокироваться.</target>
        </trans-unit>
        <trans-unit id="0b9475795c5acef3f94e436ae886fcd1f2079b25" translate="yes" xml:space="preserve">
          <source>If a container object, such as a hash or array, is locked, all the elements of that container are not locked. For example, if a thread does a &lt;code&gt;lock @a&lt;/code&gt;, any other thread doing a &lt;code&gt;lock($a[12])&lt;/code&gt; won't block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e40904bfdd4ce1f2ea77e8cac744710e6b6d3c" translate="yes" xml:space="preserve">
          <source>If a custom key refers to a data structure, a deep clone is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f34b9c616480c978cfd69625d6aeaae5e87694" translate="yes" xml:space="preserve">
          <source>If a data type is a Map or Map subtype, valid subkeys will be described as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dca4e72f15d2d8185a5bffef1f8b63be490eec41" translate="yes" xml:space="preserve">
          <source>If a default timeout ($def_timeout) in seconds is provided, it is used when a timeout is not given to the ping() method (below). The timeout must be greater than 0 and the default, if not specified, is 5 seconds.</source>
          <target state="translated">Если предусмотрен таймаут по умолчанию ($def_timeout)в секундах,то он используется,когда таймаут не предоставляется методу ping()(см.ниже).Таймаут должен быть больше 0 и по умолчанию,если не указан,равен 5 секундам.</target>
        </trans-unit>
        <trans-unit id="9cb3d5a547282377cc66b4c5457632db46bb8ed9" translate="yes" xml:space="preserve">
          <source>If a dereference operator is overloaded then it must return a</source>
          <target state="translated">Если оператор перенаправления перегружен,то он должен вернуть a</target>
        </trans-unit>
        <trans-unit id="fe98464b03f834d1a964476866ec0454738cfc5e" translate="yes" xml:space="preserve">
          <source>If a directory name is specified, Perl will switch to that directory before running the program. The &lt;b&gt;-x&lt;/b&gt; switch controls only the disposal of leading garbage. The program must be terminated with &lt;code&gt;__END__&lt;/code&gt; if there is trailing garbage to be ignored; the program can process any or all of the trailing garbage via the &lt;code&gt;DATA&lt;/code&gt; filehandle if desired.</source>
          <target state="translated">Если указано имя каталога, Perl переключится в этот каталог перед запуском программы. &lt;b&gt;-X&lt;/b&gt; переключатель контролирует только удаление ведущих мусора. Программа должна быть завершена с помощью &lt;code&gt;__END__&lt;/code&gt; , если есть завершающий мусор, который следует игнорировать; при желании программа может обработать любой или весь завершающий мусор через дескриптор файла &lt;code&gt;DATA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5aaf565f5088172c3b4f50e88e5260fa4d43f871" translate="yes" xml:space="preserve">
          <source>If a distribution defines a minimal required perl version, this is added to the output as an additional line of the form:</source>
          <target state="translated">Если дистрибутив определяет минимально необходимую версию perl,то это добавляется в выходной файл как дополнительная строка формы:</target>
        </trans-unit>
        <trans-unit id="42b6266ffbedee9d19b5a6a2dc00e2ab21c075e3" translate="yes" xml:space="preserve">
          <source>If a false value (but not &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) is passed, &lt;code&gt;overrideHangul&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideHangul =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">Если передается ложное значение (но не &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;overrideHangul&lt;/code&gt; не имеет никакого эффекта. &lt;code&gt;$Collator-&amp;gt;change(overrideHangul =&amp;gt; 0)&lt;/code&gt; сбрасывает старый.</target>
        </trans-unit>
        <trans-unit id="d7bef52fc8efdf02d89c731e11f307c96984c0d4" translate="yes" xml:space="preserve">
          <source>If a false value (but not &lt;code&gt;undef&lt;/code&gt;) is passed, &lt;code&gt;overrideHangul&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideHangul =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f3060c136c5cb39245327e845028b89a018338" translate="yes" xml:space="preserve">
          <source>If a false value (including &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) is passed, &lt;code&gt;overrideCJK&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideCJK =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">Если передано ложное значение (включая &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;overrideCJK&lt;/code&gt; не действует. &lt;code&gt;$Collator-&amp;gt;change(overrideCJK =&amp;gt; 0)&lt;/code&gt; сбрасывает старый.</target>
        </trans-unit>
        <trans-unit id="4ce3e5ab6913747cb34ccc5fe411d22f75b39a20" translate="yes" xml:space="preserve">
          <source>If a false value (including &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) is passed, &lt;code&gt;overrideOut&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideOut =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">Если передано ложное значение (включая &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;overrideOut&lt;/code&gt; не действует. &lt;code&gt;$Collator-&amp;gt;change(overrideOut =&amp;gt; 0)&lt;/code&gt; сбрасывает старый.</target>
        </trans-unit>
        <trans-unit id="2efe2419737305523ab6685944b8e5967c625c40" translate="yes" xml:space="preserve">
          <source>If a false value (including &lt;code&gt;undef&lt;/code&gt;) is passed, &lt;code&gt;overrideCJK&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideCJK =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b769b78df558ed0ae95630bec3fdf7981f2aba03" translate="yes" xml:space="preserve">
          <source>If a false value (including &lt;code&gt;undef&lt;/code&gt;) is passed, &lt;code&gt;overrideOut&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideOut =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14cf492ed81687842dddeeef058d5e33b14e6b8c" translate="yes" xml:space="preserve">
          <source>If a field width obtained through &lt;code&gt;*&lt;/code&gt; is negative, it has the same effect as the &lt;code&gt;-&lt;/code&gt; flag: left-justification.</source>
          <target state="translated">Если ширина поля, полученная с помощью &lt;code&gt;*&lt;/code&gt; , отрицательна, она имеет тот же эффект, что и флаг &lt;code&gt;-&lt;/code&gt; : выравнивание по левому краю.</target>
        </trans-unit>
        <trans-unit id="b67747c87623a5829c474216ed820d9c376a76fd" translate="yes" xml:space="preserve">
          <source>If a file named by an argument cannot be opened for some reason, Perl warns you about it, and moves on to the next file. Note that the lines are printed automatically. An error occurring during printing is treated as fatal. To suppress printing use the &lt;a href=&quot;#-n&quot;&gt;&quot;-n&quot;&lt;/a&gt; switch. A &lt;b&gt;-p&lt;/b&gt; overrides a &lt;b&gt;-n&lt;/b&gt; switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9605e9893d52ad305cb79e90d906d025024d5412" translate="yes" xml:space="preserve">
          <source>If a file named by an argument cannot be opened for some reason, Perl warns you about it, and moves on to the next file. Note that the lines are printed automatically. An error occurring during printing is treated as fatal. To suppress printing use the &lt;b&gt;-n&lt;/b&gt; switch. A &lt;b&gt;-p&lt;/b&gt; overrides a &lt;b&gt;-n&lt;/b&gt; switch.</source>
          <target state="translated">Если файл, названный аргументом, не может быть открыт по какой-либо причине, Perl предупреждает вас об этом и переходит к следующему файлу. Обратите внимание, что линии печатаются автоматически. Ошибка, возникающая во время печати, считается фатальной. Чтобы подавить печать, используйте переключатель &lt;b&gt;-n&lt;/b&gt; . &lt;b&gt;-P&lt;/b&gt; переопределяет &lt;b&gt;-n&lt;/b&gt; переключатель.</target>
        </trans-unit>
        <trans-unit id="7607c4673d0f39465175ed86077289b9bf56cef9" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you read a key from a DBM database.</source>
          <target state="translated">Если фильтр был установлен этим методом,то он будет вызываться каждый раз,когда вы читаете ключ из базы данных DBM.</target>
        </trans-unit>
        <trans-unit id="ffcdc45cfdda9fabc4fc72ffad32b6bd83924c58" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you read a value from a DBM database.</source>
          <target state="translated">Если фильтр был установлен этим методом,то он будет вызываться каждый раз,когда вы читаете значение из базы данных DBM.</target>
        </trans-unit>
        <trans-unit id="cd250eca2a3b32b9a72984e5551322c2a78954ba" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you write a key to a DBM database.</source>
          <target state="translated">Если фильтр был установлен этим методом,то он будет вызываться каждый раз при записи ключа в базу данных DBM.</target>
        </trans-unit>
        <trans-unit id="6d4a7b6c0f00f48df8682a8b26e45e64646603ea" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you write a value to a DBM database.</source>
          <target state="translated">Если фильтр был установлен этим методом,то он будет вызываться каждый раз,когда вы записываете значение в базу данных DBM.</target>
        </trans-unit>
        <trans-unit id="07c279eee0e239fdbb7a9180f0e7ca0c343b1372" translate="yes" xml:space="preserve">
          <source>If a finalized set of requirements is cloned, the cloned requirements are not also finalized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c644e7c4d09f78ea460ddc805cbed0f24eef71" translate="yes" xml:space="preserve">
          <source>If a fully qualified $class is given, its abbreviated version is checked first.</source>
          <target state="translated">Если дается полностью квалифицированный $класс,то сначала проверяется его сокращенная версия.</target>
        </trans-unit>
        <trans-unit id="61efacc190b96b684717f3100b2802427ca3f5f2" translate="yes" xml:space="preserve">
          <source>If a hyphen in a character class cannot syntactically be part of a range, for instance because it is the first or the last character of the character class, or if it immediately follows a range, the hyphen isn't special, and so is considered a character to be matched literally. If you want a hyphen in your set of characters to be matched and its position in the class is such that it could be considered part of a range, you must escape that hyphen with a backslash.</source>
          <target state="translated">Если дефис в классе символов не может синтаксически быть частью диапазона,например,потому что он является первым или последним символом класса символов,или если он непосредственно следует за диапазоном,то дефис не является специальным,и поэтому считается,что символ соответствует буквально.Если вы хотите,чтобы дефис в вашем наборе символов совпал и его положение в классе таково,что его можно было бы считать частью диапазона,вы должны избежать этого дефиса с обратным слешем.</target>
        </trans-unit>
        <trans-unit id="8e9b736d2bd9dc9660e81744f77377a13eb0a302" translate="yes" xml:space="preserve">
          <source>If a key appears more than once in the initializer list of a hash, the last occurrence wins:</source>
          <target state="translated">Если ключ появляется в списке инициализатора хэша несколько раз,то выигрывает последнее событие:</target>
        </trans-unit>
        <trans-unit id="e38101b895429346e058b0e8e435924731bb16b2" translate="yes" xml:space="preserve">
          <source>If a layer provides &lt;code&gt;Open()&lt;/code&gt; it should normally call the &lt;code&gt;Open()&lt;/code&gt; method of next layer down (if any) and then push itself on top if that succeeds. &lt;code&gt;PerlIOBase_open&lt;/code&gt; is provided to do exactly that, so in most cases you don't have to write your own &lt;code&gt;Open()&lt;/code&gt; method. If this method is not defined, other layers may have difficulty pushing themselves on top of it during open.</source>
          <target state="translated">Если уровень предоставляет &lt;code&gt;Open()&lt;/code&gt; он обычно должен вызвать метод &lt;code&gt;Open()&lt;/code&gt; следующего нижнего уровня (если есть), а затем подтолкнуть себя к вершине, если это удалось. &lt;code&gt;PerlIOBase_open&lt;/code&gt; предназначен именно для этого, поэтому в большинстве случаев вам не нужно писать собственный метод &lt;code&gt;Open()&lt;/code&gt; . Если этот метод не определен, другим слоям может быть трудно надавить на него во время открытия.</target>
        </trans-unit>
        <trans-unit id="73dbe9c1af884c682c784ff2164f939b559495d3" translate="yes" xml:space="preserve">
          <source>If a lexical variable is given an attribute, there is no symbol table to which it belongs, so the symbol table argument (&lt;code&gt;$_[1]&lt;/code&gt; ) is set to the string &lt;code&gt;'LEXICAL'&lt;/code&gt; in that case. Likewise, ascribing an attribute to an anonymous subroutine results in a symbol table argument of &lt;code&gt;'ANON'&lt;/code&gt; .</source>
          <target state="translated">Если лексической переменной присваивается атрибут, таблица символов, которой она принадлежит, отсутствует, поэтому в этом случае аргумент таблицы символов ( &lt;code&gt;$_[1]&lt;/code&gt; ) устанавливается &lt;code&gt;'LEXICAL'&lt;/code&gt; строке 'LEXICAL' . Аналогично, приписывание атрибута анонимной подпрограмме приводит к аргументу таблицы символов &lt;code&gt;'ANON'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e69004ab41c9f2ba069a062aa5bbadc27b894ffc" translate="yes" xml:space="preserve">
          <source>If a lexical variable is given an attribute, there is no symbol table to which it belongs, so the symbol table argument (&lt;code&gt;$_[1]&lt;/code&gt;) is set to the string &lt;code&gt;'LEXICAL'&lt;/code&gt; in that case. Likewise, ascribing an attribute to an anonymous subroutine results in a symbol table argument of &lt;code&gt;'ANON'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373e9d26b4e220dbf14e875851af78e4ef70cdec" translate="yes" xml:space="preserve">
          <source>If a line was available from the source stream, &lt;code&gt;filter_read()&lt;/code&gt; returns a status value greater than zero and appends the line to &lt;code&gt;$_&lt;/code&gt; . A status value of zero indicates end-of-file, less than zero means an error. The filter function itself is expected to return its status in the same way, and put the filtered line it wants written to the source stream in &lt;code&gt;$_&lt;/code&gt; . The use of &lt;code&gt;$_&lt;/code&gt; accounts for the brevity of most Perl source filters.</source>
          <target state="translated">Если строка была доступна из исходного потока, &lt;code&gt;filter_read()&lt;/code&gt; возвращает значение статуса больше нуля и добавляет строку к &lt;code&gt;$_&lt;/code&gt; . Нулевое значение состояния указывает на конец файла, значение меньше нуля означает ошибку. Ожидается, что сама функция фильтра вернет свой статус таким же образом и поместит отфильтрованную строку, которую она хочет записать, в исходный поток в &lt;code&gt;$_&lt;/code&gt; . Использование &lt;code&gt;$_&lt;/code&gt; объясняет краткость большинства исходных фильтров Perl.</target>
        </trans-unit>
        <trans-unit id="b437e27438def56dcad1625b5eefb30ef0e6432f" translate="yes" xml:space="preserve">
          <source>If a line was available from the source stream, &lt;code&gt;filter_read()&lt;/code&gt; returns a status value greater than zero and appends the line to &lt;code&gt;$_&lt;/code&gt;. A status value of zero indicates end-of-file, less than zero means an error. The filter function itself is expected to return its status in the same way, and put the filtered line it wants written to the source stream in &lt;code&gt;$_&lt;/code&gt;. The use of &lt;code&gt;$_&lt;/code&gt; accounts for the brevity of most Perl source filters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9579e356ad7f9bb206c2b31ab9df7d7dd13fd989" translate="yes" xml:space="preserve">
          <source>If a list is given then it is evaluated from left to right so that any specifications in the list that conflict with a previous specification are overridden by the later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb73e02f11dc05b75008088bd5b205cf808a5add" translate="yes" xml:space="preserve">
          <source>If a matching entry cannot be found, and a default entry exists, then a reference to the default entry is returned.</source>
          <target state="translated">Если подходящая запись не может быть найдена,а запись по умолчанию существует,возвращается ссылка на запись по умолчанию.</target>
        </trans-unit>
        <trans-unit id="c613dbc045a6d1ccd39d5e4d8985654cb6efdedb" translate="yes" xml:space="preserve">
          <source>If a message can be controlled by the &lt;code&gt;warnings&lt;/code&gt; pragma, its warning category is included with the classification letter in the description below. E.g. &lt;code&gt;(W closed)&lt;/code&gt; means a warning in the &lt;code&gt;closed&lt;/code&gt; category.</source>
          <target state="translated">Если сообщением можно управлять с помощью &lt;code&gt;warnings&lt;/code&gt; warnings, его категория предупреждения включается в классификационную букву в описании ниже. Например &lt;code&gt;(W closed)&lt;/code&gt; означает предупреждение в &lt;code&gt;closed&lt;/code&gt; категории.</target>
        </trans-unit>
        <trans-unit id="f00576e48e7083129f4536c4d9542b2af3efddb9" translate="yes" xml:space="preserve">
          <source>If a method for an operation is not found then Perl tries to autogenerate a substitute implementation from the operations that have been defined.</source>
          <target state="translated">Если метод для операции не найден,то Perl пытается автоматически сгенерировать замещающую реализацию из операций,которые были определены.</target>
        </trans-unit>
        <trans-unit id="0bdd74a3b17bde34780674e393224f07968f9f1d" translate="yes" xml:space="preserve">
          <source>If a module attempts to import any of these symbols the Exporter will give the module an opportunity to handle the situation before generating an error. The Exporter will call an export_fail method with a list of the failed symbols:</source>
          <target state="translated">Если модуль попытается импортировать любой из этих символов,то Экспортер предоставит модулю возможность разобраться с ситуацией перед тем,как сгенерировать ошибку.Экспортер вызовет метод export_fail со списком неудачных символов:</target>
        </trans-unit>
        <trans-unit id="a6c5a19663c54ceb738fad6d48fbb290bbe10648" translate="yes" xml:space="preserve">
          <source>If a module does not build for some reason, look carefully for why it failed, and report problems to the module author. If it looks like the extension building support is at fault, report that with full details of how the build failed using the GitHub issue tracker at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e9244ade28e8f11cc0bc5968d58da31945ce21" translate="yes" xml:space="preserve">
          <source>If a module does not build for some reason, look carefully for why it failed, and report problems to the module author. If it looks like the extension building support is at fault, report that with full details of how the build failed using the perlbug utility.</source>
          <target state="translated">Если модуль по каким-либо причинам не собирается,внимательно проверьте,почему он вышел из строя,и сообщите о проблемах автору модуля.Если выглядит так,будто поддержка сборки расширений находится в сборе,сообщите об этом с подробной информацией о том,как сборка завершилась неудачно,используя утилиту perlbug.</target>
        </trans-unit>
        <trans-unit id="094a8b4d892c0d307d87dac5429320ae267e0ba1" translate="yes" xml:space="preserve">
          <source>If a module implements XSUBs, you will need one of the supported C compilers. You must make sure you have set up the environment for the compiler for command-line compilation before running &lt;code&gt;perl Makefile.PL&lt;/code&gt; or any invocation of make.</source>
          <target state="translated">Если модуль реализует XSUB, вам понадобится один из поддерживаемых компиляторов C. Перед запуском &lt;code&gt;perl Makefile.PL&lt;/code&gt; или любым вызовом make необходимо убедиться, что вы настроили среду для компилятора для компиляции из командной строки .</target>
        </trans-unit>
        <trans-unit id="9711733a9e84337767e9b5acb7ff59757c774ea1" translate="yes" xml:space="preserve">
          <source>If a name does not already have a suitable prefix and/or suffix then the corresponding file will be searched for by trying combinations of prefix and suffix appropriate to the platform: &quot;$name.o&quot;, &quot;lib$name.*&quot; and &quot;$name&quot;.</source>
          <target state="translated">Если имя еще не имеет подходящего префикса и/или суффикса,то будет произведен поиск соответствующего файла с использованием комбинаций префикса и суффикса,соответствующих платформе:&quot;$name.o&quot;,&quot;lib$name.*&quot; и &quot;$name&quot;.</target>
        </trans-unit>
        <trans-unit id="71674c3e4540508bc53564e31d00df9a0af1f1d2" translate="yes" xml:space="preserve">
          <source>If a name resolve operation fails to provide a name, then this flag will cause getnameinfo() to indicate an error, rather than returning the numeric representation as a human-readable string.</source>
          <target state="translated">Если операция по разрешению имен не сможет предоставить имя,то этот флаг приведет к тому,что getnameinfo()укажет на ошибку,вместо того,чтобы возвращать числовое представление в виде человекочитаемой строки.</target>
        </trans-unit>
        <trans-unit id="31b368c0d757e116a5dfb072a97b4193c426b9b0" translate="yes" xml:space="preserve">
          <source>If a negative array index is used to read from an array, the index will be translated to a positive one internally by calling FETCHSIZE before being passed to FETCH. You may disable this feature by assigning a true value to the variable &lt;code&gt;$NEGATIVE_INDICES&lt;/code&gt; in the tied array class.</source>
          <target state="translated">Если для чтения из массива используется отрицательный индекс массива, индекс будет преобразован в положительный внутренне путем вызова FETCHSIZE перед передачей в FETCH. Вы можете отключить эту функцию, присвоив истинное значение переменной &lt;code&gt;$NEGATIVE_INDICES&lt;/code&gt; в классе связанного массива.</target>
        </trans-unit>
        <trans-unit id="77fd7f19527eab5261c210a54c173bb0abc87920" translate="yes" xml:space="preserve">
          <source>If a package uses overload, it carries a special flag. This flag is also set when new functions are defined or @ISA is modified. There will be a slight speed penalty on the very first operation thereafter that supports overloading, while the overload tables are updated. If there is no overloading present, the flag is turned off. Thus the only speed penalty thereafter is the checking of this flag.</source>
          <target state="translated">Если пакет использует перегрузку,он несет специальный флаг.Этот флаг также устанавливается,когда определяются новые функции или изменяется @ISA.После этого при первой же операции,поддерживающей перегрузку,при обновлении таблиц перегрузки будет небольшой штраф за превышение скорости.Если перегрузка отсутствует,флаг отключается.Таким образом,единственный штраф за превышение скорости после этого-проверка этого флага.</target>
        </trans-unit>
        <trans-unit id="eef6b1875e2dcae080c75ee35ffb78afc980a5f8" translate="yes" xml:space="preserve">
          <source>If a pattern does not contain a special backtracking verb that allows an argument, then &lt;code&gt;$REGERROR&lt;/code&gt; and &lt;code&gt;$REGMARK&lt;/code&gt; are not touched at all.</source>
          <target state="translated">Если в шаблоне нет специального глагола &lt;code&gt;$REGERROR&lt;/code&gt; возвратом, допускающего аргумент, то $ REGERROR и &lt;code&gt;$REGMARK&lt;/code&gt; вообще не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="9f0b6253b5fcfd411b56a12da1005e8889d7cecd" translate="yes" xml:space="preserve">
          <source>If a piece of code is under the control of the &lt;code&gt;warnings&lt;/code&gt; pragma, both the &lt;code&gt;$^W&lt;/code&gt; variable and the &lt;b&gt;-w&lt;/b&gt; flag will be ignored for the scope of the lexical warning.</source>
          <target state="translated">Если фрагмент кода находится под управлением &lt;code&gt;warnings&lt;/code&gt; warnings, и переменная &lt;code&gt;$^W&lt;/code&gt; и флаг &lt;b&gt;-w&lt;/b&gt; будут проигнорированы для области лексического предупреждения.</target>
        </trans-unit>
        <trans-unit id="dc66a04b7fd6c8f1331b2adb91a4455713a61616" translate="yes" xml:space="preserve">
          <source>If a plan has not yet been output, it will do so.</source>
          <target state="translated">Если план еще не был выпущен,он сделает это.</target>
        </trans-unit>
        <trans-unit id="f9d2f49ea2b290886ecf360d9425d5113040021a" translate="yes" xml:space="preserve">
          <source>If a precision obtained through &lt;code&gt;*&lt;/code&gt; is negative, it counts as having no precision at all.</source>
          <target state="translated">Если точность, полученная с помощью &lt;code&gt;*&lt;/code&gt; , отрицательна, она считается не имеющей точности вообще.</target>
        </trans-unit>
        <trans-unit id="2493d17a98c3b1f685aa6fcd91f6a228a3382409" translate="yes" xml:space="preserve">
          <source>If a precompiled pattern is embedded in a larger pattern then the effect of &lt;code&gt;&quot;msixpluadn&quot;&lt;/code&gt; will be propagated appropriately. The effect that the &lt;code&gt;/o&lt;/code&gt; modifier has is not propagated, being restricted to those patterns explicitly using it.</source>
          <target state="translated">Если предварительно скомпилированный шаблон встроен в более крупный шаблон, то эффект &lt;code&gt;&quot;msixpluadn&quot;&lt;/code&gt; будет распространяться соответствующим образом. Эффект, который имеет модификатор &lt;code&gt;/o&lt;/code&gt; , не распространяется, ограничиваясь теми шаблонами, которые его явно используют.</target>
        </trans-unit>
        <trans-unit id="cfe77c7e04c6532a52f2ea4bb204b4b081b46114" translate="yes" xml:space="preserve">
          <source>If a program's environment specifies an LC_NUMERIC locale and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
locale&lt;/code&gt; is in effect when the format is declared, the locale is used to specify the decimal point character in formatted output. Formatted output cannot be controlled by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; at the time when write() is called. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for further discussion of locale handling.</source>
          <target state="translated">Если в среде программы задан языковой стандарт LC_NUMERIC и &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; при объявлении формата, языковой стандарт используется для указания символа десятичной точки в форматированном выводе. Форматированный вывод нельзя контролировать с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; во время вызова write (). См. &lt;a href=&quot;perllocale&quot;&gt;Perllocale&lt;/a&gt; для дальнейшего обсуждения обработки локали.</target>
        </trans-unit>
        <trans-unit id="bedf07956f494f1e8bca1dc60af93c0e865cbc39" translate="yes" xml:space="preserve">
          <source>If a program's environment specifies an LC_NUMERIC locale and &lt;code&gt;use locale&lt;/code&gt; is in effect when the format is declared, the locale is used to specify the decimal point character in formatted output. Formatted output cannot be controlled by &lt;code&gt;use locale&lt;/code&gt; at the time when write() is called. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for further discussion of locale handling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f41131148d4a0b9a531181bbeee21c21fa27808" translate="yes" xml:space="preserve">
          <source>If a property is obsolete, etc, the entry will be flagged with the same characters used in the table in the &lt;a href=&quot;#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;section above&lt;/a&gt;, like &lt;b&gt;D&lt;/b&gt; or &lt;b&gt;S&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbdd7653484d14bb99878153118f9a9fc7a64201" translate="yes" xml:space="preserve">
          <source>If a queue is empty, &lt;code&gt;dequeue()&lt;/code&gt; blocks until another thread enqueues something. This makes queues ideal for event loops and other communications between threads.</source>
          <target state="translated">Если очередь пуста, &lt;code&gt;dequeue()&lt;/code&gt; блокируется, пока другой поток не поставит что-либо в очередь. Это делает очереди идеальными для циклов событий и других коммуникаций между потоками.</target>
        </trans-unit>
        <trans-unit id="d8a808372475f8c939dd3899bae64db28b71a73e" translate="yes" xml:space="preserve">
          <source>If a reference happens to be a reference to an object, then there are probably methods to access the things referred to, and you should probably stick to those methods unless you're in the class package that defines the object's methods. In other words, be nice, and don't violate the object's encapsulation without a very good reason. Perl does not enforce encapsulation. We are not totalitarians here. We do expect some basic civility though.</source>
          <target state="translated">Если ссылка является ссылкой на объект,то,вероятно,существуют методы для доступа к предметам,на которые делается ссылка,и вы,вероятно,должны придерживаться этих методов,если только вы не находитесь в пакете классов,который определяет методы объекта.Другими словами,будьте любезны и не нарушайте инкапсуляцию объекта без веской на то причины.Perl не применяет инкапсуляцию.Мы здесь не тоталитаристы.Хотя мы ожидаем некоторой элементарной цивилизованности.</target>
        </trans-unit>
        <trans-unit id="c8efe9417a8ca522054e8e0f20aa5ebe3ad20734" translate="yes" xml:space="preserve">
          <source>If a regexp has a variable that interpolates a code expression, Perl treats the regexp as an error. If the code expression is precompiled into a variable, however, interpolating is ok. The question is, why is this an error?</source>
          <target state="translated">Если регеxp имеет переменную,которая интерполирует выражение кода,Perl рассматривает регеxp как ошибку.Однако,если выражение кода прекомпилировано в переменную,то интерполяция нормальная.Вопрос в том,почему это ошибка?</target>
        </trans-unit>
        <trans-unit id="d5bd95a2da72abd4235bfb3025f329041ecd2afc" translate="yes" xml:space="preserve">
          <source>If a regexp matches in more than one place in the string, Perl will always match at the earliest possible point in the string:</source>
          <target state="translated">Если регеxp совпадает более чем в одном месте строки,то Perl всегда будет совпадать в самой ранней точке строки:</target>
        </trans-unit>
        <trans-unit id="eaf4b93182f52023e0f84b564980685b7296c6d9" translate="yes" xml:space="preserve">
          <source>If a regular bracketed character class contains a &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; and is matched against a non-Unicode code point, a warning may be raised, as the result is not Unicode-defined. No such warning will come when using this extended form.</source>
          <target state="translated">Если обычный класс символов в квадратных скобках содержит &lt;code&gt;\p{}&lt;/code&gt; или &lt;code&gt;\P{}&lt;/code&gt; и сопоставляется с кодовой точкой, отличной от Unicode, может появиться предупреждение, поскольку результат не определен в Unicode. При использовании этой расширенной формы такого предупреждения не будет.</target>
        </trans-unit>
        <trans-unit id="f85e430ff8e0f946fbbcd7fbdf03ad676d0029b5" translate="yes" xml:space="preserve">
          <source>If a result does not have a callback defined for it, this callback will be invoked. Thus, if all of the previous result types are specified as callbacks, this callback will</source>
          <target state="translated">Если результат не имеет определенного для него обратного вызова,то этот вызов будет вызван.Таким образом,если все предыдущие типы результатов определены как обратные,то этот вызов будет</target>
        </trans-unit>
        <trans-unit id="7c88e9a20d1a229d11dbc65d34fee24d0f8252b1" translate="yes" xml:space="preserve">
          <source>If a script does not contain such a cooky, then to avoid calling</source>
          <target state="translated">Если сценарий не содержит такого печенья,то,чтобы избежать вызова</target>
        </trans-unit>
        <trans-unit id="7e6d780b3e70414e72c5be7308b60f82c00d250e" translate="yes" xml:space="preserve">
          <source>If a second argument is given and it corresponds to a valid locale, the locale for the category is set to that value, and the function returns the now-current locale value. You can then use this in yet another call to &lt;code&gt;setlocale()&lt;/code&gt; . (In some implementations, the return value may sometimes differ from the value you gave as the second argument--think of it as an alias for the value you gave.)</source>
          <target state="translated">Если указан второй аргумент и он соответствует допустимому языку, языковой стандарт для категории устанавливается на это значение, и функция возвращает текущее значение языкового стандарта. Затем вы можете использовать это в еще одном вызове &lt;code&gt;setlocale()&lt;/code&gt; . (В некоторых реализациях возвращаемое значение может иногда отличаться от значения, которое вы указали в качестве второго аргумента - воспринимайте его как псевдоним для значения, которое вы указали.)</target>
        </trans-unit>
        <trans-unit id="3e39a56243de1505c2a60308e0e3b7ae64ceb413" translate="yes" xml:space="preserve">
          <source>If a second argument is given and it corresponds to a valid locale, the locale for the category is set to that value, and the function returns the now-current locale value. You can then use this in yet another call to &lt;code&gt;setlocale()&lt;/code&gt;. (In some implementations, the return value may sometimes differ from the value you gave as the second argument--think of it as an alias for the value you gave.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a945f54fa17399a38d6421bac299acb5873c21" translate="yes" xml:space="preserve">
          <source>If a second argument is given then it should be the name of the desired output file. If the special output filename &quot;-&quot; or &quot;&amp;gt;&amp;amp;STDOUT&quot; is given then the STDOUT filehandle is used for output (and no open or close is performed). If the special output filename &quot;&amp;gt;&amp;amp;STDERR&quot; is given then the STDERR filehandle is used for output (and no open or close is performed). If no output filehandle is currently in use and no output filename is specified, then &quot;-&quot; is implied. Alternatively, filehandle references or objects that support the regular IO operations (like &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, e.g. &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO::String&lt;/a&gt;) are also accepted; the object must already be opened.</source>
          <target state="translated">Если указан второй аргумент, то это должно быть имя желаемого выходного файла. Если указано специальное выходное имя файла &amp;laquo;-&amp;raquo; или &amp;laquo;&amp;gt; &amp;amp; STDOUT&amp;raquo;, то для вывода используется дескриптор файла STDOUT (и ни открытие, ни закрытие не выполняется). Если задано специальное имя файла вывода &quot;&amp;gt; &amp;amp; STDERR&quot;, то для вывода используется дескриптор файла STDERR (при этом открытие или закрытие не выполняется). Если в настоящее время дескриптор выходного файла не используется и имя выходного файла не указано, то подразумевается &amp;laquo;-&amp;raquo;. В качестве альтернативы также принимаются ссылки на дескрипторы файлов или объекты, которые поддерживают обычные операции ввода-вывода (например, &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , например, &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO :: String&lt;/a&gt; ); объект уже должен быть открыт.</target>
        </trans-unit>
        <trans-unit id="477169172ccc2cfa646e6b1ff7ebcaf7ea663dbd" translate="yes" xml:space="preserve">
          <source>If a second argument is given then it should correspond to a filehandle where output should be sent (otherwise the default output filehandle is &lt;code&gt;STDOUT&lt;/code&gt; if no output filehandle is currently in use).</source>
          <target state="translated">Если указан второй аргумент, то он должен соответствовать дескриптору файла, куда должен быть отправлен вывод (в противном случае дескриптор выходного файла по умолчанию - &lt;code&gt;STDOUT&lt;/code&gt; , если в настоящее время дескриптор выходного файла не используется).</target>
        </trans-unit>
        <trans-unit id="93e01c4263faa2fd7e903bd96fbfc6f719b4224a" translate="yes" xml:space="preserve">
          <source>If a signal of any given type fires multiple times during an opcode (such as from a fine-grained timer), the handler for that signal will be called only once, after the opcode completes; all other instances will be discarded. Furthermore, if your system's signal queue gets flooded to the point that there are signals that have been raised but not yet caught (and thus not deferred) at the time an opcode completes, those signals may well be caught and deferred during subsequent opcodes, with sometimes surprising results. For example, you may see alarms delivered even after calling &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm(0)&lt;/a&gt;&lt;/code&gt; as the latter stops the raising of alarms but does not cancel the delivery of alarms raised but not yet caught. Do not depend on the behaviors described in this paragraph as they are side effects of the current implementation and may change in future versions of Perl.</source>
          <target state="translated">Если сигнал любого заданного типа срабатывает несколько раз во время выполнения кода операции (например, из детального таймера), обработчик этого сигнала будет вызываться только один раз после завершения кода операции; все остальные экземпляры будут отброшены. Кроме того, если очередь сигналов вашей системы затоплена до такой степени, что есть сигналы, которые были подняты, но еще не перехвачены (и, следовательно, не отложены) во время завершения кода операции, эти сигналы вполне могут быть перехвачены и отложены во время последующих кодов операции, с иногда удивительные результаты. Например, вы можете видеть, что сигналы тревоги поступают даже после вызова &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm(0)&lt;/a&gt;&lt;/code&gt; поскольку последний останавливает подачу сигналов тревоги, но не отменяет доставку поднятых, но еще не зафиксированных сигналов тревоги. Не полагайтесь на поведение, описанное в этом абзаце, поскольку оно является побочным эффектом текущей реализации и может измениться в будущих версиях Perl.</target>
        </trans-unit>
        <trans-unit id="1391421af9c89c0d87f56f7e90949f1788025d04" translate="yes" xml:space="preserve">
          <source>If a signal of any given type fires multiple times during an opcode (such as from a fine-grained timer), the handler for that signal will be called only once, after the opcode completes; all other instances will be discarded. Furthermore, if your system's signal queue gets flooded to the point that there are signals that have been raised but not yet caught (and thus not deferred) at the time an opcode completes, those signals may well be caught and deferred during subsequent opcodes, with sometimes surprising results. For example, you may see alarms delivered even after calling &lt;code&gt;alarm(0)&lt;/code&gt; as the latter stops the raising of alarms but does not cancel the delivery of alarms raised but not yet caught. Do not depend on the behaviors described in this paragraph as they are side effects of the current implementation and may change in future versions of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c4924d3d30f658cd6ca34abca8d30fc0b456c3" translate="yes" xml:space="preserve">
          <source>If a single version is listed, then that version is considered to be the minimum version supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca9f14adad1a4346557fbd963ffe8837b4e2de6" translate="yes" xml:space="preserve">
          <source>If a specified constant &lt;code&gt;EFOO&lt;/code&gt; does not exist on the system, &lt;code&gt;$!{EFOO}&lt;/code&gt; returns &lt;code&gt;&quot;&quot;&lt;/code&gt; . You may use &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $!{EFOO}&lt;/code&gt; to check whether the constant is available on the system.</source>
          <target state="translated">Если указанная константа &lt;code&gt;EFOO&lt;/code&gt; не существует в системе, &lt;code&gt;$!{EFOO}&lt;/code&gt; возвращает &lt;code&gt;&quot;&quot;&lt;/code&gt; . Вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $!{EFOO}&lt;/code&gt; чтобы проверить, доступна ли константа в системе.</target>
        </trans-unit>
        <trans-unit id="bf4eb314d513c3316ce1fa9889a8d0bccfeb7ad3" translate="yes" xml:space="preserve">
          <source>If a specified constant &lt;code&gt;EFOO&lt;/code&gt; does not exist on the system, &lt;code&gt;$!{EFOO}&lt;/code&gt; returns &lt;code&gt;&quot;&quot;&lt;/code&gt;. You may use &lt;code&gt;exists $!{EFOO}&lt;/code&gt; to check whether the constant is available on the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f800d47729ac41db50a73befe5a0c18db31026bf" translate="yes" xml:space="preserve">
          <source>If a string is UTF-8, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; to get at the value, unless &lt;code&gt;UTF8_IS_INVARIANT(*s)&lt;/code&gt; in which case you can use &lt;code&gt;*s&lt;/code&gt; .</source>
          <target state="translated">Если строка является UTF-8, &lt;b&gt;всегда&lt;/b&gt; используйте &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; для получения значения, если только &lt;code&gt;UTF8_IS_INVARIANT(*s)&lt;/code&gt; не может использовать &lt;code&gt;*s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5565b45434f39b2ddc21d26b181951efb62cd428" translate="yes" xml:space="preserve">
          <source>If a string is UTF-8, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; to get at the value, unless &lt;code&gt;UTF8_IS_INVARIANT(*s)&lt;/code&gt; in which case you can use &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be10a035bc9dd04a9faa3e7d6666d736bd26b25" translate="yes" xml:space="preserve">
          <source>If a sub has both a PROTO and a BLOCK, the prototype is not applied until after the BLOCK is completely defined. This means that a recursive function with a prototype has to be predeclared for the prototype to take effect, like so:</source>
          <target state="translated">Если подлодка имеет и ПРОТО,и БЛОКИРОВКУ,прототип не применяется до тех пор,пока БЛОКИРОВКА не будет полностью определена.Это означает,что рекурсивная функция с прототипом должна быть предзаявлена,чтобы прототип вступил в силу:</target>
        </trans-unit>
        <trans-unit id="0608dc713e7e2ffc835fe7b94ed6aa1dd9da10a4" translate="yes" xml:space="preserve">
          <source>If a subroutine reference was given, it is invoked as:</source>
          <target state="translated">Если была дана ссылка на подпрограмму,то она вызывается как:</target>
        </trans-unit>
        <trans-unit id="b5b26c7bacf7c0c773c98a08b7cfd7b95eaadc8d" translate="yes" xml:space="preserve">
          <source>If a substring is known to match at end-of-line only, it may be followed by &lt;code&gt;$&lt;/code&gt; , as in &lt;code&gt;floating 'k'$&lt;/code&gt; .</source>
          <target state="translated">Если известно, что подстрока соответствует только в конце строки, за ней может следовать &lt;code&gt;$&lt;/code&gt; , как в &lt;code&gt;floating 'k'$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2a7b0f64e136490191d68028d9bfc30ff8c824f" translate="yes" xml:space="preserve">
          <source>If a substring is known to match at end-of-line only, it may be followed by &lt;code&gt;$&lt;/code&gt;, as in &lt;code&gt;floating 'k'$&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bac00f48a56f95c981f68b27c67c1613b3abed" translate="yes" xml:space="preserve">
          <source>If a test had either a &lt;code&gt;TODO&lt;/code&gt; or &lt;code&gt;SKIP&lt;/code&gt; directive, this method will return the accompanying explanation, if present.</source>
          <target state="translated">Если в тесте была &lt;code&gt;TODO&lt;/code&gt; директива TODO или &lt;code&gt;SKIP&lt;/code&gt; , этот метод вернет сопровождающее объяснение, если оно есть.</target>
        </trans-unit>
        <trans-unit id="65b9290b4f037c914cf42f893f1aba1433a9e97a" translate="yes" xml:space="preserve">
          <source>If a test number is greater than the number of planned tests, this method will return true. Unplanned tests will</source>
          <target state="translated">Если номер теста превышает количество запланированных тестов,этот метод вернет true.Незапланированные тесты</target>
        </trans-unit>
        <trans-unit id="6169b8ce6480907cccaf2d8c56d0f00c7332c0b3" translate="yes" xml:space="preserve">
          <source>If a tied hash is evaluated in scalar context, the &lt;code&gt;SCALAR&lt;/code&gt; method is called (with a fallback to &lt;code&gt;FIRSTKEY&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f0a88031cba297a38b9bb2a8d9794138cdfcc6" translate="yes" xml:space="preserve">
          <source>If a transformation subroutine (xfrm) is defined, its value is used to transform the lines read from the filehandle before their comparison.</source>
          <target state="translated">Если задана подпрограмма преобразования (xfrm),то ее значение используется для преобразования строк,считанных из файла перед их сравнением.</target>
        </trans-unit>
        <trans-unit id="571f9ad4d812cfdda52b01e4ae41c48c7aa1a889" translate="yes" xml:space="preserve">
          <source>If a true value is given (non-zero but should be positive), it will be added as a terminator primary weight to the end of every standard Hangul syllable. Secondary and any higher weights for terminator are set to zero. If the value is false or &lt;code&gt;hangul_terminator&lt;/code&gt; key does not exist, insertion of terminator weights will not be performed.</source>
          <target state="translated">Если дано истинное значение (отличное от нуля, но должно быть положительным), оно будет добавлено в качестве основного веса терминатора в конец каждого стандартного слога хангыль. Вторичный и любые более высокие веса терминатора устанавливаются на ноль. Если значение равно false или ключ &lt;code&gt;hangul_terminator&lt;/code&gt; не существует, вставка весовых коэффициентов терминатора выполняться не будет.</target>
        </trans-unit>
        <trans-unit id="06c503e180fbd73d4ade263d4ec3fc736e96785b" translate="yes" xml:space="preserve">
          <source>If a typed lexical variable (&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Class
$var&lt;/code&gt; ) holding a reference is used to access a hash element and a package with the same name as the type has declared class fields using this pragma, then the hash key is verified at compile time. If the variables are not typed, access is only checked at run time.</source>
          <target state="translated">Если типизированная лексическая переменная ( &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Class $var&lt;/code&gt; ), содержащая ссылку, используется для доступа к хэш-элементу и пакету с тем же именем, что и тип, объявивший поля класса с помощью этой прагмы, то хеш-ключ проверяется во время компиляции. Если переменные не введены, доступ проверяется только во время выполнения.</target>
        </trans-unit>
        <trans-unit id="748870f6864101e2665ecfedb42ab9a1b32e539e" translate="yes" xml:space="preserve">
          <source>If a typed lexical variable (&lt;code&gt;my Class $var&lt;/code&gt;) holding a reference is used to access a hash element and a package with the same name as the type has declared class fields using this pragma, then the hash key is verified at compile time. If the variables are not typed, access is only checked at run time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56a688e323d9747dee356792880eafa156d2877" translate="yes" xml:space="preserve">
          <source>If a utility or module isn't available, it will be marked in a cache (see the &lt;code&gt;$METHOD_FAIL&lt;/code&gt; variable further down), so it will not be tried again. The &lt;code&gt;fetch&lt;/code&gt; method will only fail when all options are exhausted, and it was not able to retrieve the file.</source>
          <target state="translated">Если утилита или модуль недоступны, они будут отмечены в кэше (см. &lt;code&gt;$METHOD_FAIL&lt;/code&gt; ниже), поэтому повторная попытка их выполнения не выполняется . Метод &lt;code&gt;fetch&lt;/code&gt; завершится ошибкой только в том случае, если все параметры исчерпаны и не удалось получить файл.</target>
        </trans-unit>
        <trans-unit id="17e415afdb54d5332d73e9d658477c2317a9747c" translate="yes" xml:space="preserve">
          <source>If a variable is declared inside a CODE: section it will follow any typemap code that is emitted for the input parameters. This may result in the declaration ending up after C code, which is C syntax error. Similar errors may happen with an explicit &lt;code&gt;;&lt;/code&gt; -type or &lt;code&gt;+&lt;/code&gt; -type initialization of parameters is used (see &lt;a href=&quot;#Initializing-Function-Parameters&quot;&gt;Initializing Function Parameters&lt;/a&gt;). Declaring these variables in an INIT: section will not help.</source>
          <target state="translated">Если переменная объявлена ​​в разделе CODE :, она будет следовать за любым кодом карты типов, который создается для входных параметров. Это может привести к тому, что объявление окажется после кода C, что является синтаксической ошибкой C. Подобные ошибки могут произойти с явным &lt;code&gt;;&lt;/code&gt; Используется инициализация параметров -типа или &lt;code&gt;+&lt;/code&gt; -типа (см. &lt;a href=&quot;#Initializing-Function-Parameters&quot;&gt;Инициализация параметров функции&lt;/a&gt; ). Объявление этих переменных в разделе INIT: не поможет.</target>
        </trans-unit>
        <trans-unit id="1207e0b0d0efedf009a2fba67d60a91b64445106" translate="yes" xml:space="preserve">
          <source>If a variable is declared inside a CODE: section it will follow any typemap code that is emitted for the input parameters. This may result in the declaration ending up after C code, which is C syntax error. Similar errors may happen with an explicit &lt;code&gt;;&lt;/code&gt;-type or &lt;code&gt;+&lt;/code&gt;-type initialization of parameters is used (see &lt;a href=&quot;#Initializing-Function-Parameters&quot;&gt;&quot;Initializing Function Parameters&quot;&lt;/a&gt;). Declaring these variables in an INIT: section will not help.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3996807bb1f09e79ba835867b4d5ba2a1e4f04" translate="yes" xml:space="preserve">
          <source>If a version object is compared against a non-version object, the non-object term will be converted to a version object using &lt;code&gt;parse()&lt;/code&gt;. This may give surprising results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e1471095c4d68dab8592febf94b7e3ac2a2016" translate="yes" xml:space="preserve">
          <source>If accept() is interrupted by a signal, $! will be set to EINTR. If this happens, we can safely continue to the next iteration of the loop and another call to accept(). It is important that your signal handling code not modify the value of $!, or else this test will likely fail. In the REAPER subroutine we create a local version of $! before calling waitpid(). When waitpid() sets $! to ECHILD as it inevitably does when it has no more children waiting, it updates the local copy and leaves the original unchanged.</source>
          <target state="translated">Если accept()будет прервана сигналом,то $! будет установлен в EINTR.Если это произойдет,мы сможем безопасно продолжить следующую итерацию цикла и еще один вызов функции accept().Важно,чтобы код обработки сигнала не изменял значение $!,иначе этот тест,скорее всего,провалится.В подпрограмме REAPER мы создаем локальную версию $! перед вызовом waitpid().Когда функция waitpid()устанавливает $! в ECHILD,как она неизбежно делает,когда у нее больше нет дочерних элементов,она обновляет локальную копию и оставляет оригинал без изменений.</target>
        </trans-unit>
        <trans-unit id="752e6cffd40215caddfd723588dccf4863a5ed16" translate="yes" xml:space="preserve">
          <source>If adding a new module to a set, follow the original author's standards for naming modules and the interface to methods in those modules.</source>
          <target state="translated">При добавлении нового модуля в набор,следуйте оригинальным авторским стандартам для именования модулей и интерфейсу к методам в этих модулях.</target>
        </trans-unit>
        <trans-unit id="740a7df0564a13f66fe6f00e1a8f73b803531ecf" translate="yes" xml:space="preserve">
          <source>If after any stripping of indentation in verbatim blocks, there remain tabs, this method call indicates what to do with them. &lt;code&gt;0&lt;/code&gt; means leave them as tabs, any other number indicates that each tab is to be translated so as to have tab stops every &lt;code&gt;n&lt;/code&gt; columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c30aaa76b20fc01d8891caaf8c421bdbbefa39ad" translate="yes" xml:space="preserve">
          <source>If after that process the layer is still not defined then the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; will fail.</source>
          <target state="translated">Если после этого процесса слой все еще не определен, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; не удастся.</target>
        </trans-unit>
        <trans-unit id="c550e6d69474a6a7c10a80260775c6595e782f16" translate="yes" xml:space="preserve">
          <source>If after that process the layer is still not defined then the &lt;code&gt;open&lt;/code&gt; will fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f5b65dba45a85e174c3b613f61ee902daa93694" translate="yes" xml:space="preserve">
          <source>If all actions were successful install will return a hashref of the results as described above for the $result parameter. If any action is a failure then install will die, therefore it is recommended to pass in the $result parameter instead of using the return value. If the result parameter is provided then the returned hashref will be the passed in hashref.</source>
          <target state="translated">Если все действия были выполнены успешно,то для параметра $result будет возвращен хэшреф результатов,как описано выше.Если какое-либо действие окажется неудачным,то установка умрет,поэтому рекомендуется передавать в параметре $result вместо использования возвращаемого значения.Если задан параметр результата,то возвращаемый хешреф будет передан в хешрефе.</target>
        </trans-unit>
        <trans-unit id="127255eea385053cfe8f53f8f2c648f76a8be49c" translate="yes" xml:space="preserve">
          <source>If all data that comes from a certain handle is encoded in exactly the same way, you can tell the PerlIO system to automatically decode everything, with the &lt;code&gt;encoding&lt;/code&gt; layer. If you do this, you can't accidentally forget to decode or encode anymore, on things that use the layered handle.</source>
          <target state="translated">Если все данные, поступающие от определенного дескриптора, кодируются точно так же, вы можете указать системе PerlIO автоматически декодировать все с помощью уровня &lt;code&gt;encoding&lt;/code&gt; . Если вы сделаете это, вы больше не сможете случайно забыть декодировать или кодировать вещи, которые используют многоуровневый дескриптор.</target>
        </trans-unit>
        <trans-unit id="3e7d1b1bb140827b5655410f34d1155c7f80618e" translate="yes" xml:space="preserve">
          <source>If all goes okay and no errors during a build, you'll get two independent distributions: &lt;code&gt;wince-mips-pocket-wce300&lt;/code&gt; and &lt;code&gt;mips-wce300-thr&lt;/code&gt; .</source>
          <target state="translated">Если во время сборки все пойдет нормально и ошибок нет, вы получите два независимых дистрибутива: &lt;code&gt;wince-mips-pocket-wce300&lt;/code&gt; и &lt;code&gt;mips-wce300-thr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9089d68477d6441e4f9e9f5ebed86f489f07115" translate="yes" xml:space="preserve">
          <source>If all is well then update your blead branch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab3e0df4f550d075ed2874e19cdd1793f373e2a" translate="yes" xml:space="preserve">
          <source>If all this is intimidating, have no (well, maybe only a little) fear. There are modules that can help. The &lt;code&gt;File::Spec&lt;/code&gt; modules provide methods to do the Right Thing on whatever platform happens to be running the program.</source>
          <target state="translated">Если все это пугает, не бойтесь (ну, может быть, совсем немного). Есть модули, которые могут помочь. В &lt;code&gt;File::Spec&lt;/code&gt; модули обеспечивают методы , чтобы сделать правильные вещи на любой платформе , случается, запустив программу.</target>
        </trans-unit>
        <trans-unit id="ae7ad2a8e725968ebffe98c6ec06a2f880b60f52" translate="yes" xml:space="preserve">
          <source>If all you want to do is pretend to be telnet but don't need the initial telnet handshaking, then the standard dual-process approach will suffice:</source>
          <target state="translated">Если все,что вы хотите сделать,это притвориться telnet,но не нуждаетесь в начальном telnet рукопожатии,то стандартного двухпроцессного подхода будет достаточно:</target>
        </trans-unit>
        <trans-unit id="9403f48a0d39d844d9c0ac74b1c19be5f1602977" translate="yes" xml:space="preserve">
          <source>If all your tests passed, &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If no tests were ever run &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; will throw a warning and exit with 255. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114fc5763881eaed2b695ddb5eda1e514b33dd63" translate="yes" xml:space="preserve">
          <source>If all your tests passed, &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If no tests were ever run &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; will throw a warning and exit with 255. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</source>
          <target state="translated">Если все ваши тесты пройдены, &lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt; завершится с нулем (что нормально). Если что-то не удалось, он выйдет с указанием количества сбоев. Если вы запустите меньше (или больше) тестов, чем планировали, недостающие (или дополнительные) будут считаться ошибками. Если тесты никогда не запускались, &lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt; выдаст предупреждение и завершит работу с 255. Если тест завершится, даже после успешного завершения всех тестов, он все равно будет считаться неудачным и завершится с 255.</target>
        </trans-unit>
        <trans-unit id="a98f6624ef41fa5865752ff72d1c88c5adce8ff1" translate="yes" xml:space="preserve">
          <source>If all your tests passed, Test::Builder will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If no tests were ever run Test::Builder will throw a warning and exit with 255. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</source>
          <target state="translated">Если все ваши тесты прошли,Test::Builder выйдет с нулем (что нормально).Если что-то провалилось,он выйдет с тем,сколько провалилось.Если вы запустили меньше (или больше)тестов,чем планировали,то пропущенные (или дополнительные)тесты будут считаться неудачными.Если ни один тест не был запущен Test::Builder бросит предупреждение и выйдет с 255.Если тест умер,даже после успешного завершения всех тестов,он все равно будет считаться неудачным и выйдет с 255.</target>
        </trans-unit>
        <trans-unit id="ec52cc18e24a40a3b425f46525ccb32d3bbfcd0d" translate="yes" xml:space="preserve">
          <source>If all your tests passed, Test::Simple will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If no tests were ever run Test::Simple will throw a warning and exit with 255. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</source>
          <target state="translated">Если все ваши тесты прошли,Test::Simple выйдет с нулем (что нормально).Если что-то провалилось,то со сколькими провалились тесты,они завершатся.Если вы прогоните меньше (или больше)тестов,чем планировали,то пропущенные (или дополнительные)тесты будут считаться неудачными.Если ни один тест не был запущен Test::Simple бросит предупреждение и выйдет с 255.Если тест умер,даже после успешного завершения всех тестов,он все равно будет считаться неудачным и выйдет с 255.</target>
        </trans-unit>
        <trans-unit id="bf21a78dfdb342ccff4796ddae824fa3095f386e" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ExtraField&lt;/code&gt; option is specified and it is a simple scalar, it must conform to the sub-field structure as defined in RFC 1952.</source>
          <target state="translated">Если &lt;code&gt;ExtraField&lt;/code&gt; параметр ExtraField, и это простой скаляр, он должен соответствовать структуре подполя, как определено в RFC 1952.</target>
        </trans-unit>
        <trans-unit id="703bb32d1796efb54146381859e7e166335fd702" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ExtraField&lt;/code&gt; option is specified and it is a simple scalar, the structure will not be checked. The only error is if the length is too big.</source>
          <target state="translated">Если &lt;code&gt;ExtraField&lt;/code&gt; параметр ExtraField, и это простой скаляр, структура не будет проверяться. Единственная ошибка - слишком большая длина.</target>
        </trans-unit>
        <trans-unit id="d5888ada14b086770c285ef36da99e64d4b36a12" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ExtraField&lt;/code&gt; option is specified the second byte of the ID will be checked in each subfield to ensure that it does not contain the reserved value 0x00.</source>
          <target state="translated">Если &lt;code&gt;ExtraField&lt;/code&gt; параметр ExtraField, второй байт идентификатора будет проверяться в каждом подполе, чтобы убедиться, что он не содержит зарезервированного значения 0x00.</target>
        </trans-unit>
        <trans-unit id="bba67c55f0a73d622c034c758b4c54c06d0297ce" translate="yes" xml:space="preserve">
          <source>If an AUTOLOAD routine is an XSUB, as with Perl subroutines, Perl puts the fully-qualified name of the autoloaded subroutine in the $AUTOLOAD variable of the XSUB's package.</source>
          <target state="translated">Если рутина AUTOLOAD является XSUB,как и в случае с подпрограммами Perl,то Perl помещает полное имя автозагружаемой подпрограммы в переменную $AUTOLOAD пакета XSUB.</target>
        </trans-unit>
        <trans-unit id="5f16d14b8173a324e3c6a5e5bf643eb4986c26e1" translate="yes" xml:space="preserve">
          <source>If an IPC encounters a fatal error it should use this. This will print the message to STDERR with &lt;code&gt;'IPC Fatal Error: '&lt;/code&gt; prefixed to it, then it will forcefully exit 255. IPC errors may occur in threads or processes other than the main one, this method provides the best chance of the harness noticing the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42bdc376fb833e498b49e6edb80ebe7de88f4149" translate="yes" xml:space="preserve">
          <source>If an Input glob matches the same file more than once, only the first will be used.</source>
          <target state="translated">Если входной глобус совпадает с одним и тем же файлом более одного раза,будет использоваться только первый.</target>
        </trans-unit>
        <trans-unit id="4c7ac1d42b2433b8600fc2dd6eb1a16139df0641" translate="yes" xml:space="preserve">
          <source>If an XSUB is created to offer a direct translation between this function and Perl, then this XSUB will be used from Perl with the following code. The $status and $timep variables will contain the output of the function.</source>
          <target state="translated">Если XSUB создается,чтобы предложить прямую трансляцию между этой функцией и Perl,то этот XSUB будет использоваться с Perl со следующим кодом.Переменные $status и $timep будут содержать вывод функции.</target>
        </trans-unit>
        <trans-unit id="b382afe3d07f60c5f6eced5294d3838170432890" translate="yes" xml:space="preserve">
          <source>If an XSUB name contains &lt;code&gt;::&lt;/code&gt; , it is considered to be a C++ method. The generated Perl function will assume that its first argument is an object pointer. The object pointer will be stored in a variable called THIS. The object should have been created by C++ with the new() function and should be blessed by Perl with the sv_setref_pv() macro. The blessing of the object by Perl can be handled by a typemap. An example typemap is shown at the end of this section.</source>
          <target state="translated">Если имя XSUB содержит &lt;code&gt;::&lt;/code&gt; , это считается методом C ++. Сгенерированная функция Perl предполагает, что ее первый аргумент является указателем на объект. Указатель объекта будет сохранен в переменной с именем THIS. Объект должен был быть создан C ++ с помощью функции new () и должен быть благословлен Perl макросом sv_setref_pv (). Благословение объекта в Perl может быть обработано картой типов. Пример карты типа показан в конце этого раздела.</target>
        </trans-unit>
        <trans-unit id="1b3718c1d670d39036e818ea2e8844505748f38c" translate="yes" xml:space="preserve">
          <source>If an XSUB name contains &lt;code&gt;::&lt;/code&gt;, it is considered to be a C++ method. The generated Perl function will assume that its first argument is an object pointer. The object pointer will be stored in a variable called THIS. The object should have been created by C++ with the new() function and should be blessed by Perl with the sv_setref_pv() macro. The blessing of the object by Perl can be handled by a typemap. An example typemap is shown at the end of this section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2e1d1934ece2d63d504b4355cb9c8a6aa0fa5a" translate="yes" xml:space="preserve">
          <source>If an angle-bracket-based globbing expression is used as the condition of a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;for&lt;/code&gt; loop, then it will be implicitly assigned to &lt;code&gt;$_&lt;/code&gt;. If either a globbing expression or an explicit assignment of a globbing expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5be5707a4fed01d7fc6a9c5c683f16ea2406809" translate="yes" xml:space="preserve">
          <source>If an argument callback routine is specified, &lt;code&gt;@ARGV&lt;/code&gt; will always be empty upon successful return of GetOptions() since all options have been processed. The only exception is when &lt;code&gt;--&lt;/code&gt; is used:</source>
          <target state="translated">Если указана процедура обратного вызова аргумента, &lt;code&gt;@ARGV&lt;/code&gt; всегда будет пустым после успешного возврата GetOptions (), поскольку все параметры были обработаны. Единственное исключение, когда &lt;code&gt;--&lt;/code&gt; используется:</target>
        </trans-unit>
        <trans-unit id="b39b97b3c5875ed6ddbb4cadef1665f0d49ebbe7" translate="yes" xml:space="preserve">
          <source>If an argument is given, it must correspond to the desired section heading number, in which case only the specified section heading is returned. If there is no current section heading at the specified level, then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если указан аргумент, он должен соответствовать желаемому номеру заголовка раздела, и в этом случае возвращается только указанный заголовок раздела. Если на указанном уровне нет заголовка текущего раздела, возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7271fc38171101f8ded47e78d280e28ab4aefe24" translate="yes" xml:space="preserve">
          <source>If an attribute handler is declared and the &lt;code&gt;:ATTR&lt;/code&gt; specifier is given the name of a built-in type (&lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , or &lt;code&gt;CODE&lt;/code&gt; ), the handler is only applied to declarations of that type. For example, the following definition:</source>
          <target state="translated">Если объявлен обработчик атрибута и &lt;code&gt;:ATTR&lt;/code&gt; присвоено имя встроенного типа ( &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; или &lt;code&gt;CODE&lt;/code&gt; ), обработчик применяется только к объявлениям этого типа. Например, следующее определение:</target>
        </trans-unit>
        <trans-unit id="99c7ef44f90555314050f910e8588b5f9dbab3f7" translate="yes" xml:space="preserve">
          <source>If an attribute handler is declared and the &lt;code&gt;:ATTR&lt;/code&gt; specifier is given the name of a built-in type (&lt;code&gt;SCALAR&lt;/code&gt;, &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt;, or &lt;code&gt;CODE&lt;/code&gt;), the handler is only applied to declarations of that type. For example, the following definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62eb757e944d2fdd579513e058242369fd9ee059" translate="yes" xml:space="preserve">
          <source>If an element of</source>
          <target state="translated">Если элемент</target>
        </trans-unit>
        <trans-unit id="12dcad5cabf51c630b511f4237ee95faf62760f4" translate="yes" xml:space="preserve">
          <source>If an element, call it ELEMENT, is not on this list, try using this command to find out why:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac822e62f394feec698ce4d683fc3173f8604479" translate="yes" xml:space="preserve">
          <source>If an empty list, &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, or nothing that matches the first 3 values above is returned, then &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; looks at the remaining elements of &lt;a href=&quot;perlvar#%40INC&quot;&gt;&lt;code&gt;@INC&lt;/code&gt;&lt;/a&gt;. Note that this filehandle must be a real filehandle (strictly a typeglob or reference to a typeglob, whether blessed or unblessed); tied filehandles will be ignored and processing will stop there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34964fb1164dd648c7d2582c841b9ac59c8a6438" translate="yes" xml:space="preserve">
          <source>If an empty list, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, or nothing that matches the first 3 values above is returned, then &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks at the remaining elements of @INC. Note that this filehandle must be a real filehandle (strictly a typeglob or reference to a typeglob, whether blessed or unblessed); tied filehandles will be ignored and processing will stop there.</source>
          <target state="translated">Если возвращается пустой список, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; или ничего, что соответствует первым трем значениям, указанным выше, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; просматривает оставшиеся элементы @INC. Обратите внимание, что этот дескриптор файла должен быть настоящим дескриптором файла (строго typeglob или ссылкой на typeglob, будь то благословенный или не благословенный); связанные дескрипторы файлов будут проигнорированы, и на этом обработка остановится.</target>
        </trans-unit>
        <trans-unit id="e6b9ed06c157d2ccb39c11bcda5c6ea1f6b42a42" translate="yes" xml:space="preserve">
          <source>If an empty list, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, or nothing that matches the first 3 values above is returned, then &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks at the remaining elements of @INC. Note that this filehandle must be a real filehandle (strictly a typeglob or reference to a typeglob, whether blessed or unblessed); tied filehandles will be ignored and processing will stop there.</source>
          <target state="translated">Если возвращается пустой список, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; или ничего, что соответствует первым трем значениям, указанным выше, &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; просматривает оставшиеся элементы @INC. Обратите внимание, что этот дескриптор файла должен быть настоящим дескриптором файла (строго typeglob или ссылкой на typeglob, будь то благословенный или не благословенный); связанные дескрипторы файлов будут проигнорированы, и на этом обработка остановится.</target>
        </trans-unit>
        <trans-unit id="f919dfddbef4a1a12f08337d7a834831006d9b11" translate="yes" xml:space="preserve">
          <source>If an error is encountered during conversion, output file will be removed and a warning emitted instead of terminating the conversion immediately.</source>
          <target state="translated">При возникновении ошибки при конвертировании выходной файл будет удален,и вместо немедленного завершения конвертирования будет выдано предупреждение.</target>
        </trans-unit>
        <trans-unit id="9714806e81ca60318ef1d507fb9add3187535d9b" translate="yes" xml:space="preserve">
          <source>If an error occurs &lt;code&gt;blocking&lt;/code&gt; will return undef and &lt;code&gt;$!&lt;/code&gt; will be set.</source>
          <target state="translated">В случае ошибки &lt;code&gt;blocking&lt;/code&gt; вернет undef и &lt;code&gt;$!&lt;/code&gt; будет установлен.</target>
        </trans-unit>
        <trans-unit id="223081f636c4dc0e612cdeecd4fd8749800bcc2c" translate="yes" xml:space="preserve">
          <source>If an error occurs in parsing or compilation, in most cases a valid op tree (most likely null) is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred. Some compilation errors, however, will throw an exception immediately.</source>
          <target state="translated">Если при разборе или компиляции возникает ошибка,в большинстве случаев все равно возвращается корректное дерево оп (скорее всего,нулевое).Ошибка отражается в состоянии синтаксического анализатора,как правило,приводя к единичному исключению на верхнем уровне синтаксического анализа,которое охватывает все возникшие ошибки компиляции.Однако некоторые ошибки компиляции сразу же бросают исключение.</target>
        </trans-unit>
        <trans-unit id="409c88cc16ea56deb3ee2fd13496f8443cdeb8ed" translate="yes" xml:space="preserve">
          <source>If an error occurs in parsing or compilation, in most cases a valid op tree is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred. Some compilation errors, however, will throw an exception immediately.</source>
          <target state="translated">Если возникает ошибка при разборе или компиляции,в большинстве случаев все равно возвращается корректное дерево опций.Ошибка отражается в состоянии синтаксического анализатора,как правило,приводя к единичному исключению на верхнем уровне синтаксического анализа,которое охватывает все возникшие ошибки компиляции.Однако некоторые ошибки компиляции сразу же бросают исключение.</target>
        </trans-unit>
        <trans-unit id="fb3a0347b1d41b96c13bdbefc10e2d1afbf9de50" translate="yes" xml:space="preserve">
          <source>If an error occurs in parsing, which can only occur if the label is mandatory, a valid label is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred.</source>
          <target state="translated">Если при разборе возникает ошибка,которая может возникнуть только в том случае,если этикетка является обязательной,то в любом случае возвращается действительная этикетка.Ошибка отражается в состоянии синтаксического анализатора,что обычно приводит к единичному исключению на верхнем уровне синтаксического анализа,которое охватывает все возникшие ошибки компиляции.</target>
        </trans-unit>
        <trans-unit id="d9bdcdf03abe1ba577aa0e79f3435579268caad1" translate="yes" xml:space="preserve">
          <source>If an error occurs, it SHOULD return the fragment of string that has been converted and modify $octets in-place to remove the converted part leaving it starting with the problem fragment. If perlio_ok() is true, SHOULD becomes MUST.</source>
          <target state="translated">При возникновении ошибки он ДОЛЖЕН вернуть преобразованный фрагмент строки и изменить $octets на месте,чтобы удалить преобразованный фрагмент,оставив его начиная с проблемного фрагмента.Если переменная perlio_ok()имеет значение true,то функция SHOULD становится ОБЯЗАТЕЛЬНОЙ.</target>
        </trans-unit>
        <trans-unit id="5cf7457198e3f9cd671a04a577836ab4a9017358" translate="yes" xml:space="preserve">
          <source>If an error occurs, it SHOULD return the octet sequence for the fragment of string that has been converted and modify $string in-place to remove the converted part leaving it starting with the problem fragment. If perlio_ok() is true, SHOULD becomes MUST.</source>
          <target state="translated">При возникновении ошибки она ДОЛЖНА вернуть октетную последовательность для преобразованного фрагмента строки и модифицировать $string на месте,чтобы удалить преобразованную часть,оставив ее начиная с проблемного фрагмента.Если переменная perlio_ok()имеет значение true,то SHOULD становится ОБЯЗАТЕЛЬНЫМ.</target>
        </trans-unit>
        <trans-unit id="0c2d11e497e2ae0afa960e508853e27c914d2845" translate="yes" xml:space="preserve">
          <source>If an existing module &lt;b&gt;almost&lt;/b&gt; does what you want, consider writing a patch, writing a subclass, or otherwise extending the existing module rather than rewriting it.</source>
          <target state="translated">Если существующий модуль &lt;b&gt;почти&lt;/b&gt; выполняет то, что вы хотите, подумайте о написании патча, написании подкласса или ином расширении существующего модуля, а не его переписывании.</target>
        </trans-unit>
        <trans-unit id="82c1aacb1c3709d4e7d697aae2bed5c77802f47c" translate="yes" xml:space="preserve">
          <source>If an exit status</source>
          <target state="translated">Если статус выхода</target>
        </trans-unit>
        <trans-unit id="cea12036a9c231320c44066b7b5457646bd39537" translate="yes" xml:space="preserve">
          <source>If an exit status is</source>
          <target state="translated">Если статус выхода</target>
        </trans-unit>
        <trans-unit id="e2873de2f1e9af5ea740b20953d89320900ebe0e" translate="yes" xml:space="preserve">
          <source>If an extant $SIG{__WARN__} handler is discovered, it will continue to be honored, but only after the diagnostics::splainthis() function (the module's $SIG{__WARN__} interceptor) has had its way with your warnings.</source>
          <target state="translated">Если будет обнаружен существующий обработчик $SIG{__WARN__},то он будет продолжать выполняться,но только после того,как функция диагностики::splainthis()(перехватчик модуля $SIG{__WARN__})справится с вашими предупреждениями.</target>
        </trans-unit>
        <trans-unit id="d72e4c503af6f4a09cfa2171e2474d37da483a9b" translate="yes" xml:space="preserve">
          <source>If an extension is being built away from the perl source then MakeMaker will leave PERL_SRC undefined and default to using the installed copy of the perl library. The other variables default to the following:</source>
          <target state="translated">Если расширение собирается отдельно от источника perl,то MakeMaker оставит PERL_SRC неопределенным и по умолчанию будет использовать установленную копию библиотеки perl.Остальные переменные по умолчанию следующие:</target>
        </trans-unit>
        <trans-unit id="a1c876b366d6c58e85d7243f2dbcbb0c36548470" translate="yes" xml:space="preserve">
          <source>If an extension is being built below the &lt;code&gt;ext/&lt;/code&gt; directory of the perl source then MakeMaker will set PERL_SRC automatically (e.g., &lt;code&gt;../..&lt;/code&gt;). If PERL_SRC is defined and the extension is recognized as a standard extension, then other variables default to the following:</source>
          <target state="translated">Если расширение создается под каталогом &lt;code&gt;ext/&lt;/code&gt; исходного кода perl, MakeMaker автоматически устанавливает PERL_SRC (например, &lt;code&gt;../..&lt;/code&gt; ). Если PERL_SRC определен и расширение распознается как стандартное расширение, тогда другие переменные по умолчанию имеют следующие значения:</target>
        </trans-unit>
        <trans-unit id="a0316d054e0262fb322cda466200340b0b6b9a08" translate="yes" xml:space="preserve">
          <source>If an extractor returns a defined value, that value is immediately treated as the next extracted field and pushed onto the list of fields. If the extractor was specified in a hash reference, the field is also blessed into the appropriate class,</source>
          <target state="translated">Если извлекающее устройство возвращает определенное значение,то это значение сразу же рассматривается как следующее извлеченное поле и вытесняется в список полей.Если извлекатель был указан в ссылке на хэш,то поле также благословляется в соответствующий класс,</target>
        </trans-unit>
        <trans-unit id="19aae17e0a99010e0b921850c1a03e6076850e68" translate="yes" xml:space="preserve">
          <source>If an infinity or a not-a-number is recognized, &lt;code&gt;*sp&lt;/code&gt; will point to one byte past the end of the recognized string. If the recognition fails, zero is returned, and &lt;code&gt;*sp&lt;/code&gt; will not move.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e24bf211ae35444c0a5b02834d4c163f847646" translate="yes" xml:space="preserve">
          <source>If an infinity or a not-a-number is recognized, the *sp will point to one byte past the end of the recognized string. If the recognition fails, zero is returned, and the *sp will not move.</source>
          <target state="translated">Если распознана бесконечность или не-число,то *sp будет указывать на один байт,прошедший мимо конца распознанной строки.При неудачном распознавании возвращается ноль,а *sp не будет перемещаться.</target>
        </trans-unit>
        <trans-unit id="ce09f2ed6b39791e05ffc528e1a968457528299e" translate="yes" xml:space="preserve">
          <source>If an object does not support the method specified (determined using UNIVERSAL::can()) then the call will be skipped. If the method dies a warning will be generated.</source>
          <target state="translated">Если объект не поддерживает указанный метод (определяется с помощью UNIVERSAL::can()),то вызов будет пропущен.Если метод умрет,то будет выдано предупреждение.</target>
        </trans-unit>
        <trans-unit id="24adf3fb9ad8a72560fd633d7f97a817649bd630" translate="yes" xml:space="preserve">
          <source>If an operation is trapped in this way, then the code in STRING will not be executed. If such a trapped operation occurs or any other compile-time or return error, then $@ is set to the error message, just as with an eval().</source>
          <target state="translated">Если операция поймана таким образом,то код в STRING выполняться не будет.Если такая операция попала в ловушку или произошла любая другая ошибка компиляции или возврата,то $@ устанавливается в сообщение об ошибке,так же,как и eval().</target>
        </trans-unit>
        <trans-unit id="010067cf6d54e236b69f60d21b2be969b22dcb45" translate="yes" xml:space="preserve">
          <source>If an optional feature is used by a consumer to add additional prerequisites, the consumer should merge the optional feature prerequisites into those given by the &lt;code&gt;prereqs&lt;/code&gt; key using the same semantics. See &lt;a href=&quot;#Merging-and-Resolving-Prerequisites&quot;&gt;&quot;Merging and Resolving Prerequisites&quot;&lt;/a&gt; for details on merging prerequisites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed03e924684c92a9ff3960f906eb5ec6eb3ba279" translate="yes" xml:space="preserve">
          <source>If an output file depends on extra input files beside the script itself, a hash ref can be used in version 7.36 and above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c694eae799a264caff23c78599d66c65a6eff8ab" translate="yes" xml:space="preserve">
          <source>If an uncaught exception results in interpreter exit, the exit code is determined from the values of &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; with this pseudocode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215592828190613f91a4fc9378ebe41cd5d2be61" translate="yes" xml:space="preserve">
          <source>If an uncaught exception results in interpreter exit, the exit code is determined from the values of &lt;code&gt;$!&lt;/code&gt; and &lt;code&gt;$?&lt;/code&gt; with this pseudocode:</source>
          <target state="translated">Если неперехваченное исключение приводит к завершению работы интерпретатора, код выхода определяется по значениям &lt;code&gt;$!&lt;/code&gt; и &lt;code&gt;$?&lt;/code&gt; с этим псевдокодом:</target>
        </trans-unit>
        <trans-unit id="9816162ad52f74eb6f76cc05f87a2c2e46e90fd4" translate="yes" xml:space="preserve">
          <source>If another process currently has read, write, and/or delete access to the file and you don't allow that level of sharing, then your call to &lt;code&gt;CreateFile&lt;/code&gt; will fail. If you requested read, write, and/or delete access and another process already has the file open but doesn't allow that level of sharing, then your call to &lt;code&gt;createFile&lt;/code&gt; will fail. Once you have the file open, if another process tries to open it with read, write, and/or delete access and you don't allow that level of sharing, then that process won't be allowed to open the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c5b88805d10f4113bd0a0998d163f4bc00c5dc" translate="yes" xml:space="preserve">
          <source>If another process currently has read, write, and/or delete access to the file and you don't allow that level of sharing, then your call to &lt;code&gt;createFile&lt;/code&gt; will fail. If you requested read, write, and/or delete access and another process already has the file open but doesn't allow that level of sharing, then your call to &lt;code&gt;createFile&lt;/code&gt; will fail. Once you have the file open, if another process tries to open it with read, write, and/or delete access and you don't allow that level of sharing, then that process won't be allowed to open the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b864a885bc89443cbce8d662bf2be7249be99d8" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;test_args&lt;/code&gt; are given they will be appended to the end of the command argument list.</source>
          <target state="translated">Если заданы какие-либо &lt;code&gt;test_args&lt;/code&gt; , они будут добавлены в конец списка аргументов команды.</target>
        </trans-unit>
        <trans-unit id="37251314e00b333d40467d467ca5c0c35c0e366e" translate="yes" xml:space="preserve">
          <source>If any argument to &lt;b&gt;podselect&lt;/b&gt; is a reference to a hash (associative array) then the values with the following keys are processed as follows:</source>
          <target state="translated">Если какой-либо аргумент &lt;b&gt;podselect&lt;/b&gt; является ссылкой на хэш (ассоциативный массив), то значения со следующими ключами обрабатываются следующим образом:</target>
        </trans-unit>
        <trans-unit id="0fa7b6de1acc5eb4980a2653a96afb04a72dd14b" translate="yes" xml:space="preserve">
          <source>If any arguments remain, and &lt;code&gt;GetOptionsFromString&lt;/code&gt; was not called in list context, a message will be given and &lt;code&gt;GetOptionsFromString&lt;/code&gt; will return failure.</source>
          <target state="translated">Если остались какие-либо аргументы и &lt;code&gt;GetOptionsFromString&lt;/code&gt; не был вызван в контексте списка, будет выдано сообщение, и &lt;code&gt;GetOptionsFromString&lt;/code&gt; вернет ошибку.</target>
        </trans-unit>
        <trans-unit id="59b5cfa2ac91aed4f93a07d4f29fc54a851c06d0" translate="yes" xml:space="preserve">
          <source>If any destructors are triggered as a result, the hv itself may be freed.</source>
          <target state="translated">Если в результате сработают деструкторы,то сам hv может быть освобожден.</target>
        </trans-unit>
        <trans-unit id="dd7074163e07f37b8a41bd25ef8050c203f85577" translate="yes" xml:space="preserve">
          <source>If any directories are included in @names they are searched before @dl_library_path. Directories may be specified as &lt;b&gt;-Ldir&lt;/b&gt;. Any other names are treated as filenames to be searched for.</source>
          <target state="translated">Если какие-либо каталоги включены в @names, их поиск выполняется до @dl_library_path. Каталоги могут быть указаны как &lt;b&gt;-Ldir&lt;/b&gt; . Любые другие имена рассматриваются как имена файлов, подлежащих поиску.</target>
        </trans-unit>
        <trans-unit id="864b32c42a324d7506e9ca2ec49f2bbc8bbdcf83" translate="yes" xml:space="preserve">
          <source>If any element of LIST is an lvalue, you can modify it by modifying VAR inside the loop. Conversely, if any element of LIST is NOT an lvalue, any attempt to modify that element will fail. In other words, the &lt;code&gt;foreach&lt;/code&gt; loop index variable is an implicit alias for each item in the list that you're looping over.</source>
          <target state="translated">Если какой-либо элемент LIST является lvalue, вы можете изменить его, изменив VAR внутри цикла. И наоборот, если какой-либо элемент LIST НЕ является lvalue, любая попытка изменить этот элемент потерпит неудачу. Другими словами, индексная переменная цикла &lt;code&gt;foreach&lt;/code&gt; является неявным псевдонимом для каждого элемента в списке, который вы перебираете.</target>
        </trans-unit>
        <trans-unit id="3cbc5bd59ee7e5290e2a6a24d40e5bd7de01e87c" translate="yes" xml:space="preserve">
          <source>If any function has the OVERLOAD: keyword, several additional lines will be defined in the c file generated by xsubpp in order to register with the overload magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="705cbac0d6d9464ed1b8a92ba681b4a46a07d153" translate="yes" xml:space="preserve">
          <source>If any list operator (&lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt;, etc.) or any unary operator (&lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call.</source>
          <target state="translated">Если за любым оператором списка ( &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; и т. Д.) Или любым унарным оператором ( &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; и т. Д.) Следует левая скобка в качестве следующего токена, оператор и аргументы в скобках считаются имеющими наивысший приоритет, просто как обычный вызов функции.</target>
        </trans-unit>
        <trans-unit id="cec7c53718240c968018769a330928a1255918e0" translate="yes" xml:space="preserve">
          <source>If any list operator (&lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt;, etc.) or any unary operator (&lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call. For example, because named unary operators are higher precedence than &lt;code&gt;||&lt;/code&gt;:</source>
          <target state="translated">Если за любым оператором списка ( &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; и т. Д.) Или любым унарным оператором ( &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; и т. Д.) Следует левая скобка в качестве следующего токена, оператор и аргументы в скобках считаются имеющими наивысший приоритет, просто как обычный вызов функции. Например, потому что именованные унарные операторы имеют более высокий приоритет, чем &lt;code&gt;||&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fc09b29b0e202c3ba1b9de2b8c7b1a00d9fcb394" translate="yes" xml:space="preserve">
          <source>If any list operator (&lt;code&gt;print()&lt;/code&gt;, etc.) or any unary operator (&lt;code&gt;chdir()&lt;/code&gt;, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="189e6bb75ad5ffde9c93fb5cd316abd2034296e1" translate="yes" xml:space="preserve">
          <source>If any list operator (&lt;code&gt;print()&lt;/code&gt;, etc.) or any unary operator (&lt;code&gt;chdir()&lt;/code&gt;, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call. For example, because named unary operators are higher precedence than &lt;code&gt;||&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b227e6f9b5d8d36337845d9688db6eb8efa3551d" translate="yes" xml:space="preserve">
          <source>If any module's own AUTOLOAD subroutine has no need to fallback to the AutoLoader's AUTOLOAD subroutine (because it doesn't have any AutoSplit subroutines), then that module should not use &lt;b&gt;AutoLoader&lt;/b&gt; at all.</source>
          <target state="translated">Если для собственной подпрограммы AUTOLOAD какого-либо модуля нет необходимости откатываться к подпрограмме AUTOLOAD AutoLoader (потому что она не имеет подпрограмм AutoSplit), то этот модуль вообще не должен использовать &lt;b&gt;AutoLoader&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="54f05d2b51008f086be29ce06ad2dc1e36ce0970" translate="yes" xml:space="preserve">
          <source>If any of the alternatives matches, the hash &lt;code&gt;%+&lt;/code&gt; is bound to contain the three key-value pairs.</source>
          <target state="translated">Если какая-либо из альтернатив совпадает, хэш &lt;code&gt;%+&lt;/code&gt; обязательно должен содержать три пары ключ-значение.</target>
        </trans-unit>
        <trans-unit id="dde2e9ba6df88b543ea738e9014946a615cc8feb" translate="yes" xml:space="preserve">
          <source>If any of the entries in an import list begins with !, : or / then the list is treated as a series of specifications which either add to or delete from the list of names to import. They are processed left to right. Specifications are in the form:</source>
          <target state="translated">Если любой из пунктов списка для импорта начинается с !,:или /,то список рассматривается как серия спецификаций,которые либо добавляются в список для импорта,либо удаляются из него.Они обрабатываются слева направо.Спецификации оформляются в виде:</target>
        </trans-unit>
        <trans-unit id="eed3f110a3402c08d6252799be2b5ee0618e62e2" translate="yes" xml:space="preserve">
          <source>If any of the file tests (or either the &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt;&lt;code&gt;lstat&lt;/code&gt;&lt;/a&gt; operator) is given the special filehandle consisting of a solitary underline, then the stat structure of the previous file test (or &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; operator) is used, saving a system call. (This doesn't work with &lt;code&gt;-t&lt;/code&gt;, and you need to remember that &lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt;&lt;code&gt;lstat&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;-l&lt;/code&gt; leave values in the stat structure for the symbolic link, not the real file.) (Also, if the stat buffer was filled by an &lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt;&lt;code&gt;lstat&lt;/code&gt;&lt;/a&gt; call, &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; will reset it with the results of &lt;code&gt;stat _&lt;/code&gt;). Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd2433b191431a7e89003ab4a4e523c3a5de0d9" translate="yes" xml:space="preserve">
          <source>If any of the file tests (or either the &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; operator) is given the special filehandle consisting of a solitary underline, then the stat structure of the previous file test (or stat operator) is used, saving a system call. (This doesn't work with &lt;code&gt;-t&lt;/code&gt; , and you need to remember that lstat() and &lt;code&gt;-l&lt;/code&gt; leave values in the stat structure for the symbolic link, not the real file.) (Also, if the stat buffer was filled by an &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; will reset it with the results of &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; ). Example:</source>
          <target state="translated">Если любому из файловых тестов (или оператору &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; ) присваивается специальный дескриптор файла, состоящий из одиночного подчеркивания, то используется структура stat предыдущего теста файла (или оператора stat), сохраняя системный вызов. (Это не работает с &lt;code&gt;-t&lt;/code&gt; , и вам нужно помнить, что lstat () и &lt;code&gt;-l&lt;/code&gt; оставляют значения в структуре stat для символьной ссылки, а не для реального файла.) (Кроме того, если буфер stat был заполнен &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; и &lt;code&gt;-B&lt;/code&gt; сбросят его с результатами &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; ). Пример:</target>
        </trans-unit>
        <trans-unit id="c70d4afb0f7f0b8a4b2bcb0de7d2fe106cb41892" translate="yes" xml:space="preserve">
          <source>If any of the file tests (or either the &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; operator) is given the special filehandle consisting of a solitary underline, then the stat structure of the previous file test (or stat operator) is used, saving a system call. (This doesn't work with &lt;code&gt;-t&lt;/code&gt; , and you need to remember that lstat() and &lt;code&gt;-l&lt;/code&gt; leave values in the stat structure for the symbolic link, not the real file.) (Also, if the stat buffer was filled by an &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; will reset it with the results of &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; ). Example:</source>
          <target state="translated">Если любому из файловых тестов (или оператору &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; ) присваивается специальный дескриптор файла, состоящий из одиночного подчеркивания, то используется структура stat предыдущего теста файла (или оператора stat), сохраняя системный вызов. (Это не работает с &lt;code&gt;-t&lt;/code&gt; , и вам нужно помнить, что lstat () и &lt;code&gt;-l&lt;/code&gt; оставляют значения в структуре stat для символьной ссылки, а не для реального файла.) (Кроме того, если буфер stat был заполнен &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; и &lt;code&gt;-B&lt;/code&gt; сбросят его с результатами &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; ). Пример:</target>
        </trans-unit>
        <trans-unit id="4eae7869337353cadd5cbfe4d84a955fd03cd8ba" translate="yes" xml:space="preserve">
          <source>If any of the given search directories contains a</source>
          <target state="translated">Если любой из заданных поисковых каталогов содержит</target>
        </trans-unit>
        <trans-unit id="0865eba790bb7da4cb38d4fafb11a71c0ca93d75" translate="yes" xml:space="preserve">
          <source>If any of the three values is &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; that time value will not be used. So, for example, to set only the &lt;code&gt;$mtime&lt;/code&gt; you would use this</source>
          <target state="translated">Если любое из трех значений - &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , это значение времени использоваться не будет. Так, например, чтобы установить только &lt;code&gt;$mtime&lt;/code&gt; вы должны использовать это</target>
        </trans-unit>
        <trans-unit id="f9ae80c94036ecc3639a1310fc69fc12fe61781c" translate="yes" xml:space="preserve">
          <source>If any of the three values is &lt;code&gt;undef&lt;/code&gt; that time value will not be used. So, for example, to set only the &lt;code&gt;$mtime&lt;/code&gt; you would use this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="341a4d7e4dbc9eeb69d34b947d58bc6f15ecb9f2" translate="yes" xml:space="preserve">
          <source>If any part of LIST is an array, &lt;code&gt;foreach&lt;/code&gt; will get very confused if you add or remove elements within the loop body, for example with &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;. So don't do that.</source>
          <target state="translated">Если какая-либо часть LIST является массивом, &lt;code&gt;foreach&lt;/code&gt; очень запутается, если вы добавите или удалите элементы в теле цикла, например, с помощью &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; . Так что не делай этого.</target>
        </trans-unit>
        <trans-unit id="a6977803bb4132cdee0ca3d69dd5582749d63459" translate="yes" xml:space="preserve">
          <source>If any part of LIST is an array, &lt;code&gt;foreach&lt;/code&gt; will get very confused if you add or remove elements within the loop body, for example with &lt;code&gt;splice&lt;/code&gt;. So don't do that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31cf9c709860eea50a338d60ff5edf1e2478723c" translate="yes" xml:space="preserve">
          <source>If applicable, please include details on what the user should do to correct the error; documenting an error as indicating &quot;the input buffer is too small&quot; without telling the user how to increase the size of the input buffer (or at least telling them that it isn't possible) aren't very useful.</source>
          <target state="translated">Если применимо,пожалуйста,включите подробности о том,что пользователь должен сделать,чтобы исправить ошибку;документирование ошибки как указание &quot;входной буфер слишком мал&quot;,не говоря пользователю,как увеличить размер входного буфера (или,по крайней мере,сказав,что это невозможно),не очень полезно.</target>
        </trans-unit>
        <trans-unit id="17ebb7f065dcd7d1005a6e70cd7fc9ddab662a16" translate="yes" xml:space="preserve">
          <source>If argument is specified, it is an advice on minimal size of line to be included into history. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; means do not include anything into history. Returns the old value.</source>
          <target state="translated">Если указан аргумент, это совет по минимальному размеру строки для включения в историю. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; означает, что ничего не заносить в историю. Возвращает старое значение.</target>
        </trans-unit>
        <trans-unit id="558be544e424e324e7828785f1d0946baec4a52b" translate="yes" xml:space="preserve">
          <source>If argument is specified, it is an advice on minimal size of line to be included into history. &lt;code&gt;undef&lt;/code&gt; means do not include anything into history. Returns the old value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dfd62fe55f271b39c6841425a803e9153fccfd7" translate="yes" xml:space="preserve">
          <source>If at least one handle is ready for the specified kind of operation, the result will be an array of 3 elements, each a reference to an array which will hold the handles that are ready for reading, writing and have exceptions respectively. Upon timeout, an empty list is returned, with &lt;code&gt;$!&lt;/code&gt; unchanged. Upon error, an empty list is returned, with &lt;code&gt;$!&lt;/code&gt; set to indicate the error. To distinguish between timeout and error, set &lt;code&gt;$!&lt;/code&gt; to zero before calling this method, and check it after an empty list is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84097126d5165e3f6c46b39868c8cad17c6bb873" translate="yes" xml:space="preserve">
          <source>If backward compatibility for Perls &lt;b&gt;under&lt;/b&gt; 5.6 is important, one must write instead a &lt;code&gt;use vars&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd699eb48fd240fe4a2bcf57e3a3520a6ee8d6f2" translate="yes" xml:space="preserve">
          <source>If backward compatibility for Perls under 5.6 is important, one must write instead a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; statement.</source>
          <target state="translated">Если важна обратная совместимость для Perls до &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 5.6, следует написать вместо нее оператор &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars .</target>
        </trans-unit>
        <trans-unit id="b7d0b9799b974e77c25f857fd60005fd09516395" translate="yes" xml:space="preserve">
          <source>If bits is 4 or less, the string is broken into bytes, then the bits of each byte are broken into 8/BITS groups. Bits of a byte are numbered in a little-endian-ish way, as in &lt;code&gt;0x01&lt;/code&gt; , &lt;code&gt;0x02&lt;/code&gt; , &lt;code&gt;0x04&lt;/code&gt; , &lt;code&gt;0x08&lt;/code&gt; , &lt;code&gt;0x10&lt;/code&gt; , &lt;code&gt;0x20&lt;/code&gt; , &lt;code&gt;0x40&lt;/code&gt; , &lt;code&gt;0x80&lt;/code&gt; . For example, breaking the single input byte &lt;code&gt;&lt;a href=&quot;chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; into two groups gives a list &lt;code&gt;(0x6, 0x3)&lt;/code&gt; ; breaking it into 4 groups gives &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; .</source>
          <target state="translated">Если битов 4 или меньше, строка разбивается на байты, затем биты каждого байта разбиваются на группы 8 / BITS. Биты байта пронумерованы по принципу little-endian, как в &lt;code&gt;0x01&lt;/code&gt; , &lt;code&gt;0x02&lt;/code&gt; , &lt;code&gt;0x04&lt;/code&gt; , &lt;code&gt;0x08&lt;/code&gt; , &lt;code&gt;0x10&lt;/code&gt; , &lt;code&gt;0x20&lt;/code&gt; , &lt;code&gt;0x40&lt;/code&gt; , &lt;code&gt;0x80&lt;/code&gt; . Например, &lt;code&gt;&lt;a href=&quot;chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; одного входного байта chr (0x36) на две группы дает список &lt;code&gt;(0x6, 0x3)&lt;/code&gt; ; разбив его на 4 группы, вы &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77d4537f5763ddf89d58388ac5f77f55fec21e75" translate="yes" xml:space="preserve">
          <source>If bits is 4 or less, the string is broken into bytes, then the bits of each byte are broken into 8/BITS groups. Bits of a byte are numbered in a little-endian-ish way, as in &lt;code&gt;0x01&lt;/code&gt; , &lt;code&gt;0x02&lt;/code&gt; , &lt;code&gt;0x04&lt;/code&gt; , &lt;code&gt;0x08&lt;/code&gt; , &lt;code&gt;0x10&lt;/code&gt; , &lt;code&gt;0x20&lt;/code&gt; , &lt;code&gt;0x40&lt;/code&gt; , &lt;code&gt;0x80&lt;/code&gt; . For example, breaking the single input byte &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; into two groups gives a list &lt;code&gt;(0x6, 0x3)&lt;/code&gt; ; breaking it into 4 groups gives &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; .</source>
          <target state="translated">Если битов 4 или меньше, строка разбивается на байты, затем биты каждого байта разбиваются на группы 8 / BITS. Биты байта пронумерованы по принципу little-endian, как в &lt;code&gt;0x01&lt;/code&gt; , &lt;code&gt;0x02&lt;/code&gt; , &lt;code&gt;0x04&lt;/code&gt; , &lt;code&gt;0x08&lt;/code&gt; , &lt;code&gt;0x10&lt;/code&gt; , &lt;code&gt;0x20&lt;/code&gt; , &lt;code&gt;0x40&lt;/code&gt; , &lt;code&gt;0x80&lt;/code&gt; . Например, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; одного входного байта chr (0x36) на две группы дает список &lt;code&gt;(0x6, 0x3)&lt;/code&gt; ; разбив его на 4 группы, вы &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0fce82eab0f0647014ec432d0b3fa1af89e83a3" translate="yes" xml:space="preserve">
          <source>If bits is 4 or less, the string is broken into bytes, then the bits of each byte are broken into 8/BITS groups. Bits of a byte are numbered in a little-endian-ish way, as in &lt;code&gt;0x01&lt;/code&gt;, &lt;code&gt;0x02&lt;/code&gt;, &lt;code&gt;0x04&lt;/code&gt;, &lt;code&gt;0x08&lt;/code&gt;, &lt;code&gt;0x10&lt;/code&gt;, &lt;code&gt;0x20&lt;/code&gt;, &lt;code&gt;0x40&lt;/code&gt;, &lt;code&gt;0x80&lt;/code&gt;. For example, breaking the single input byte &lt;code&gt;chr(0x36)&lt;/code&gt; into two groups gives a list &lt;code&gt;(0x6, 0x3)&lt;/code&gt;; breaking it into 4 groups gives &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf0f5d848a9043e820336aaa7c2b5b535010685b" translate="yes" xml:space="preserve">
          <source>If both arguments to &lt;code&gt;copy&lt;/code&gt; are not file handles, then &lt;code&gt;copy&lt;/code&gt; will perform a &quot;system copy&quot; of the input file to a new output file, in order to preserve file attributes, indexed file structure,</source>
          <target state="translated">Если оба аргумента для &lt;code&gt;copy&lt;/code&gt; не являются дескрипторами файла, то при &lt;code&gt;copy&lt;/code&gt; будет выполнено &amp;laquo;системное копирование&amp;raquo; входного файла в новый выходной файл, чтобы сохранить атрибуты файла, структуру индексированного файла,</target>
        </trans-unit>
        <trans-unit id="e9104a77e501731bf3173e5f8cc7012527cca560" translate="yes" xml:space="preserve">
          <source>If both the SIGNAL and the PROCESS are negative, the results are undefined. A warning may be produced in a future version.</source>
          <target state="translated">Если и СИГНАЛ,и ПРОЦЕСС отрицательны,результаты не определены.Предупреждение может быть выдано в будущей версии.</target>
        </trans-unit>
        <trans-unit id="43c2b718c80fc2756eb63ba9991217396d36da72" translate="yes" xml:space="preserve">
          <source>If braces are not needed to specify a property (e.g., &lt;code&gt;\pL&lt;/code&gt; ), the left column contains both forms, with and without braces.</source>
          <target state="translated">Если фигурные скобки не нужны для указания свойства (например, &lt;code&gt;\pL&lt;/code&gt; ), левый столбец содержит обе формы с фигурными скобками и без них.</target>
        </trans-unit>
        <trans-unit id="8260701f533c58633eabb2e152bfb995da51c762" translate="yes" xml:space="preserve">
          <source>If braces are not needed to specify a property (e.g., &lt;code&gt;\pL&lt;/code&gt;), the left column contains both forms, with and without braces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a4169e83148646605b11ff599e0ccd6579a7d78" translate="yes" xml:space="preserve">
          <source>If branches are involved (ie. $Revision: 1.5.3.4$) it's a little more complicated.</source>
          <target state="translated">Если вовлечены ветки (т.е.$Revision:1.5.3.4$),то это немного сложнее.</target>
        </trans-unit>
        <trans-unit id="2c0abc37f0d263edf159adfc0dd160a4e923f046" translate="yes" xml:space="preserve">
          <source>If building completes successfully, you can set up smoke testing as described in the Test::Smoke documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c319407a62fb715df8d4d26f7931f9374106237" translate="yes" xml:space="preserve">
          <source>If building natively on PASE, please do the build under the /QOpenSys directory, since Perl is happier when built on a case sensitive filesystem.</source>
          <target state="translated">При сборке на PASE,пожалуйста,выполняйте сборку в каталоге /QOpenSys,так как Perl счастливее,если он построен на файловой системе,чувствительной к регистру.</target>
        </trans-unit>
        <trans-unit id="973afa89149c95161585621016fbc1be5e704a2e" translate="yes" xml:space="preserve">
          <source>If building with the cross-compiler provided by mingw-w64.org you'll need to uncomment the line that sets GCCCROSS in the makefile.mk. Do this only if it's the cross-compiler - ie only if the bin folder doesn't contain a gcc.exe. (The cross-compiler does not provide a gcc.exe, g++.exe, ar.exe, etc. Instead, all of these executables are prefixed with 'x86_64-w64-mingw32-'.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2edb493675bf68411bac8372236ccf07c63ce62d" translate="yes" xml:space="preserve">
          <source>If building with the cross-compiler provided by mingw-w64.sourceforge.net you'll need to uncomment the line that sets GCCCROSS in the makefile.mk. Do this only if it's the cross-compiler - ie only if the bin folder doesn't contain a gcc.exe. (The cross-compiler does not provide a gcc.exe, g++.exe, ar.exe, etc. Instead, all of these executables are prefixed with 'x86_64-w64-mingw32-'.)</source>
          <target state="translated">При сборке с помощью кросс-компилятора,предоставляемого mingw-w64.sourceforge.net,необходимо снять комментарий со строки,устанавливающей GCCCROSS в makefile.mk.Делайте это только если это кросс-компилятор-т.е.только если папка bin не содержит gcc.exe.(Кросс-компилятор не предоставляет gcc.exe,g++.exe,ar.exe и т.д.).Вместо этого все эти исполняемые файлы имеют префикс 'x86_64-w64-mingw32-').</target>
        </trans-unit>
        <trans-unit id="9e17d613e1404f153f1b0ce16d928004818ba4b8" translate="yes" xml:space="preserve">
          <source>If by daemon process you mean one that's detached (disassociated from its tty), then the following process is reported to work on most Unixish systems. Non-Unix users should check their Your_OS::Process module for other solutions.</source>
          <target state="translated">Если под демоническим процессом вы подразумеваете процесс,который отделен от tty,то,как сообщается,следующий процесс работает на большинстве Unixish-систем.Пользователи,не являющиеся UNUnix,должны проверить свой модуль Your_OS::Process на наличие других решений.</target>
        </trans-unit>
        <trans-unit id="f14156857ddead4c835ba55e44d3f79ccfb246a2" translate="yes" xml:space="preserve">
          <source>If by some reasons</source>
          <target state="translated">Если по каким-либо причинам</target>
        </trans-unit>
        <trans-unit id="85a1911ef5d789d9bb6809a0f2c6b323a8f5cec0" translate="yes" xml:space="preserve">
          <source>If callbacks are used, they will be issued before this call returns.</source>
          <target state="translated">При использовании обратных вызовов они будут выданы до того,как этот вызов будет возвращен.</target>
        </trans-unit>
        <trans-unit id="313e870db9c5d448dca42a14416b5684a916e7ce" translate="yes" xml:space="preserve">
          <source>If called as &lt;code&gt;sv_vcatpvfn&lt;/code&gt; or flags has the &lt;code&gt;SV_GMAGIC&lt;/code&gt; bit set, calls get magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="706aad3a29650f166c943e5c886b39dcd0a4394e" translate="yes" xml:space="preserve">
          <source>If called as &lt;code&gt;sv_vcatpvfn&lt;/code&gt; or flags include &lt;code&gt;SV_GMAGIC&lt;/code&gt; , calls get magic.</source>
          <target state="translated">Если &lt;code&gt;sv_vcatpvfn&lt;/code&gt; как sv_vcatpvfn или флаги включают &lt;code&gt;SV_GMAGIC&lt;/code&gt; , вызовы становятся волшебными.</target>
        </trans-unit>
        <trans-unit id="614a0f52f1c33eb959730f1d5d32f8786b9d57d8" translate="yes" xml:space="preserve">
          <source>If called as an instance method (i.e. $md5-&amp;gt;new) it will just reset the state the object to the state of a newly created object. No new object is created in this case.</source>
          <target state="translated">Если вызывается как метод экземпляра (например, $ md5-&amp;gt; new), он просто сбрасывает состояние объекта до состояния вновь созданного объекта. В этом случае новый объект не создается.</target>
        </trans-unit>
        <trans-unit id="9eff0140ef6933e6b5cb7ac53c50b2609e62aacb" translate="yes" xml:space="preserve">
          <source>If called as an instance method, the value is assigned to the invocand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8679ce9e8862eb205bcd677039372fd6e97a03da" translate="yes" xml:space="preserve">
          <source>If called in a list context and the global variable &lt;code&gt;$INSTANCES&lt;/code&gt; is a true value, it will return a list of the full paths to instances of the binary where found in &lt;code&gt;PATH&lt;/code&gt; , or an empty list if it was not found.</source>
          <target state="translated">Если &lt;code&gt;$INSTANCES&lt;/code&gt; в контексте списка и глобальная переменная $ INSTANCES является истинным значением, она вернет список полных путей к экземплярам двоичного файла, найденным в &lt;code&gt;PATH&lt;/code&gt; , или пустой список, если он не был найден.</target>
        </trans-unit>
        <trans-unit id="df3b5a11aab4c086bd9cac6e1ddae966355312d8" translate="yes" xml:space="preserve">
          <source>If called in a list context and the global variable &lt;code&gt;$INSTANCES&lt;/code&gt; is a true value, it will return a list of the full paths to instances of the binary where found in &lt;code&gt;PATH&lt;/code&gt;, or an empty list if it was not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8293e343dafdb403ea7c5d5ddbde243205b61a6" translate="yes" xml:space="preserve">
          <source>If called in a list context, it will return a list of the full paths to instances of the binary where found in &lt;code&gt;PATH&lt;/code&gt; , or an empty list if it was not found.</source>
          <target state="translated">Если вызывается в контексте списка, он вернет список полных путей к экземплярам двоичного &lt;code&gt;PATH&lt;/code&gt; , найденным в PATH , или пустой список, если он не был найден.</target>
        </trans-unit>
        <trans-unit id="f5370268c560e6f64c9874ef2c0fc0f892b2ca25" translate="yes" xml:space="preserve">
          <source>If called in a list context, it will return a list of the full paths to instances of the binary where found in &lt;code&gt;PATH&lt;/code&gt;, or an empty list if it was not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522ffa67a9fbac5fe032f13cc8e4e97e4f0b245b" translate="yes" xml:space="preserve">
          <source>If called in a scalar context it will return the full path to the binary you asked for if it was found, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it was not.</source>
          <target state="translated">При вызове в скалярном контексте он вернет полный путь к запрашиваемому вами двоичному файлу, если он был найден, или &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если его нет.</target>
        </trans-unit>
        <trans-unit id="8320f2054497a9bae0f18de5b046bd415cc37b89" translate="yes" xml:space="preserve">
          <source>If called in a scalar context it will return the full path to the binary you asked for if it was found, or &lt;code&gt;undef&lt;/code&gt; if it was not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f63f3ffa5199ae8cbe82545b9235a06bf20e5c" translate="yes" xml:space="preserve">
          <source>If called in a scalar context, &lt;code&gt;getsym&lt;/code&gt; returns the value of the symbol whose name is given as the argument to the call, or &lt;code&gt;undef&lt;/code&gt; if no such symbol exists. Symbols in the local symbol table are always used in preference to symbols in the global symbol table. If called in a list context, &lt;code&gt;getsym&lt;/code&gt; returns a two-element list, whose first element is the value of the symbol, and whose second element is the string 'GLOBAL' or 'LOCAL', indicating the table from which the symbol's value was read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5dcbe2314e7e7c1c4c1bcc0ca660c9625dfb9c3" translate="yes" xml:space="preserve">
          <source>If called in scalar context, only the filehandle is returned and the file will automatically be deleted when closed on operating systems that support this (see the description of tmpfile() elsewhere in this document). This is the preferred mode of operation, as if you only have a filehandle, you can never create a race condition by fumbling with the filename. On systems that can not unlink an open file or can not mark a file as temporary when it is opened (for example, Windows NT uses the &lt;code&gt;O_TEMPORARY&lt;/code&gt; flag) the file is marked for deletion when the program ends (equivalent to setting UNLINK to 1). The &lt;code&gt;UNLINK&lt;/code&gt; flag is ignored if present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e86b593d758e5e3c8998823e4b17f5dfdc961bc" translate="yes" xml:space="preserve">
          <source>If called in scalar context, only the filehandle is returned and the file will automatically be deleted when closed on operating systems that support this (see the description of tmpfile() elsewhere in this document). This is the preferred mode of operation, as if you only have a filehandle, you can never create a race condition by fumbling with the filename. On systems that can not unlink an open file or can not mark a file as temporary when it is opened (for example, Windows NT uses the C</source>
          <target state="translated">При вызове в контексте скаляра возвращается только файловый менеджер,и файл будет автоматически удален при закрытии на операционных системах,поддерживающих это (см.описание функции tmpfile()в другом месте этого документа).Это предпочтительный режим работы,так как если у вас только файловый менеджер,вы никогда не сможете создать условия гонки,перепутав имя файла.На системах,которые не могут развязать открытый файл или не могут пометить файл как временный при его открытии (например,Windows NT использует C</target>
        </trans-unit>
        <trans-unit id="2926650808a88d22bd30c27717549af3be1de564" translate="yes" xml:space="preserve">
          <source>If called when &lt;code&gt;use utf8&lt;/code&gt; is in effect, the string will be assumed to be encoded in UTF-8, and &lt;code&gt;evalbytes&lt;/code&gt; will make a temporary copy to work from, downgraded to non-UTF-8. If this is not possible (because one or more characters in it require UTF-8), the &lt;code&gt;evalbytes&lt;/code&gt; will fail with the error stored in &lt;code&gt;$@&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c83187abf3e8e59deed13ec45be5007e63c321fb" translate="yes" xml:space="preserve">
          <source>If called with a property that doesn't have synonyms for its values, it returns the input value, possibly normalized with capitalization and underscores, but not necessarily checking that the input value is valid.</source>
          <target state="translated">Если вызывается свойство,не имеющее синонимов для своих значений,оно возвращает входное значение,возможно,нормированное с заглавными буквами и подчеркиванием,но не обязательно проверяет,является ли входное значение действительным.</target>
        </trans-unit>
        <trans-unit id="abcbf5b218ac08698c7495d3bca85cf2f5fc593a" translate="yes" xml:space="preserve">
          <source>If called with an argument &lt;code&gt;blocking&lt;/code&gt; will turn on non-blocking IO if &lt;code&gt;BOOL&lt;/code&gt; is false, and turn it off if &lt;code&gt;BOOL&lt;/code&gt; is true.</source>
          <target state="translated">При вызове с аргументом &lt;code&gt;blocking&lt;/code&gt; включит неблокирующий ввод-вывод, если &lt;code&gt;BOOL&lt;/code&gt; имеет значение false, и выключит, если &lt;code&gt;BOOL&lt;/code&gt; имеет значение true.</target>
        </trans-unit>
        <trans-unit id="cd8fbca057a7b0f8546bef2e8eba78cd01155b5c" translate="yes" xml:space="preserve">
          <source>If called with an argument the &lt;code&gt;list&lt;/code&gt; returns the size of the message in octets.</source>
          <target state="translated">Если вызывается с аргументом, &lt;code&gt;list&lt;/code&gt; возвращает размер сообщения в октетах.</target>
        </trans-unit>
        <trans-unit id="d3101b42b801bc480044d4583af8814cf3a6fda1" translate="yes" xml:space="preserve">
          <source>If called without arguments a reference to a hash is returned. The keys will be the &lt;code&gt;MSGNUM&lt;/code&gt; 's of all undeleted messages and the values will be their size in octets.</source>
          <target state="translated">При вызове без аргументов возвращается ссылка на хэш. Ключами будут &lt;code&gt;MSGNUM&lt;/code&gt; всех восстановленных сообщений, а значениями - их размер в октетах.</target>
        </trans-unit>
        <trans-unit id="9173f9598d9b0aafc765ff35df05afedacca6dc3" translate="yes" xml:space="preserve">
          <source>If called without arguments a reference to a hash is returned. The keys will be the &lt;code&gt;MSGNUM&lt;/code&gt;'s of all undeleted messages and the values will be their size in octets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048702f1da8ec8b9e869f3d2d0c04bad9a57c4d8" translate="yes" xml:space="preserve">
          <source>If can not unlink open file, defer removal until later available since 0.06.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e77963c1065ed922557c941a37ed57186c92ec48" translate="yes" xml:space="preserve">
          <source>If capturing parenthesis are used in a regular expression, we can refer to the part of the source string that was matched, and match exactly the same thing. There are three ways of referring to such</source>
          <target state="translated">Если в регулярном выражении используются каппинговые скобки,то мы можем ссылаться на ту часть исходной строки,которая была сопоставлена,и совпадать точно с той же самой.Есть три способа ссылаться на такой</target>
        </trans-unit>
        <trans-unit id="ca37e501b1a5684a1fb419774ed5fda0c1e909b2" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; (&lt;code&gt;-Accflags=-DPERL_MEM_LOG&lt;/code&gt;), both memory and SV allocations go through logging functions, which is handy for breakpoint setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef19162a844967deef3f5d85d04764641f71041" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; , both memory and SV allocations go through logging functions, which is handy for breakpoint setting.</source>
          <target state="translated">Если скомпилирован с &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; , как память, так и выделение SV проходят через функции регистрации, что удобно для установки точки останова.</target>
        </trans-unit>
        <trans-unit id="505c257963541e6d1081b0bfdec05dc2d7991e03" translate="yes" xml:space="preserve">
          <source>If constant folding was not performed, the execution-order thread is created.</source>
          <target state="translated">Если постоянное сгибание не было выполнено,создается поток выполнения заказа.</target>
        </trans-unit>
        <trans-unit id="9c0592ae26e8bb261300ebbed2b588cacc05e4ff" translate="yes" xml:space="preserve">
          <source>If cross-compiling, this variable can be used to modify the environment on the target system. However, how and where it's used, and even if it's used at all, is entirely dependent on both the transport mechanism (targetrun) and what the target system is. Unless the relevant documentation says otherwise, it is genereally not useful.</source>
          <target state="translated">При кросс-компиляции эта переменная может быть использована для изменения окружения на целевой системе.Однако,как и где она используется,и даже если используется вообще,полностью зависит как от транспортного механизма (targetrun),так и от того,что такое целевая система.Если в соответствующей документации не указано иное,это не является полезным с точки зрения жанра.</target>
        </trans-unit>
        <trans-unit id="c66c617b16e576e77dc9dc8e186d44f33fe447f3" translate="yes" xml:space="preserve">
          <source>If cross-compiling, this variable contains the location of sh on the target system. If not, this will be the same as $sh.</source>
          <target state="translated">При кросс-компиляции эта переменная содержит местоположение sh на целевой системе.Если нет,то это будет то же самое,что и $sh.</target>
        </trans-unit>
        <trans-unit id="60357fb3a62a70cdf0b8804a617b55fe7b82dc59" translate="yes" xml:space="preserve">
          <source>If cross-compiling, this variable contains the target architecture. If not, this will be empty.</source>
          <target state="translated">При кросс-компиляции эта переменная содержит целевую архитектуру.Если нет,то она будет пустой.</target>
        </trans-unit>
        <trans-unit id="e5ce981aa84829db1548a6d11516c6b5fa9cbc60" translate="yes" xml:space="preserve">
          <source>If d_procselfexe is defined, $procselfexe is the filename of the symbolic link pointing to the absolute pathname of the executing program.</source>
          <target state="translated">Если определено значение d_procselfexe,то $procselfexe-это имя файла символической ссылки,указывающего на абсолютный путь выполняющейся программы.</target>
        </trans-unit>
        <trans-unit id="dc4c096ee5da0f37bd52c68590795a5281826f8c" translate="yes" xml:space="preserve">
          <source>If declared at the outermost scope (the file scope), then lexicals work somewhat like C's file statics. They are available to all functions in that same file declared below them, but are inaccessible from outside that file. This strategy is sometimes used in modules to create private variables that the whole module can see.</source>
          <target state="translated">Если они объявлены в самой внешней области видимости (файловой области видимости),то лексики работают в некоторой степени как файловая статика С.Они доступны для всех функций в том же самом объявленном под ними файле,но недоступны извне этого файла.Эта стратегия иногда используется в модулях для создания приватных переменных,которые видит весь модуль.</target>
        </trans-unit>
        <trans-unit id="145d6c1efc9692f7f88fb5f7ebc95c113e29dc12" translate="yes" xml:space="preserve">
          <source>If defined but false, the socket will be set to non-blocking mode. If not specified it defaults to &lt;code&gt;1&lt;/code&gt; (blocking mode).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9038caa549899b94401a0838d72ace7d4bde5fe6" translate="yes" xml:space="preserve">
          <source>If defined but false, the socket will be set to non-blocking mode. Otherwise it will default to blocking mode. See the NON-BLOCKING section below for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae3059e06d397630c09d4c165cce518cf89f33b" translate="yes" xml:space="preserve">
          <source>If defined specifies whether color output is desired. If &lt;code&gt;color&lt;/code&gt; is not defined it will default to color output if color support is available on the current platform and output is not being redirected.</source>
          <target state="translated">Если определено, указывает, требуется ли цветной вывод. Если &lt;code&gt;color&lt;/code&gt; не определен, по умолчанию будет использоваться цветной вывод, если поддержка цвета доступна на текущей платформе и вывод не перенаправляется.</target>
        </trans-unit>
        <trans-unit id="f94a897ccd9f764c01b106a5cdfcd1ac35d63b36" translate="yes" xml:space="preserve">
          <source>If defined, gives a maximum time in seconds to block per &lt;code&gt;connect()&lt;/code&gt; call when in blocking mode. If missing, no timeout is applied other than that provided by the underlying operating system. When in non-blocking mode this parameter is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f028cf73562b9d54628306ef212e57f51c8b344" translate="yes" xml:space="preserve">
          <source>If defined, puts the socket into listening mode where new connections can be accepted using the &lt;code&gt;accept&lt;/code&gt; method. The value given is used as the &lt;code&gt;listen(2)&lt;/code&gt; queue size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e020a19c9382a48776779d2ba22b74e383d938da" translate="yes" xml:space="preserve">
          <source>If defined, set the &lt;code&gt;IPV6_V6ONLY&lt;/code&gt; sockopt when creating &lt;code&gt;PF_INET6&lt;/code&gt; sockets to the given value. If true, a listening-mode socket will only listen on the &lt;code&gt;AF_INET6&lt;/code&gt; addresses; if false it will also accept connections from &lt;code&gt;AF_INET&lt;/code&gt; addresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3bd5a9c7fbd30c1f819a008f41219b5c451f73" translate="yes" xml:space="preserve">
          <source>If desired, an optional hash-ref may be specified as the first argument to customize certain aspects of the parse-tree that is created and returned. The set of recognized option keywords are:</source>
          <target state="translated">При желании в качестве первого аргумента для настройки некоторых аспектов создаваемого и возвращаемого дерева разбора можно указать необязательный хэш-файл.Набор распознаваемых ключевых слов опции:</target>
        </trans-unit>
        <trans-unit id="c417457bb41c44d12dd8e05efc098db997c407b3" translate="yes" xml:space="preserve">
          <source>If developing modules for private internal or project specific use, that will never be released to the public, then you should ensure that their names will not clash with any future public module. You can do this either by using the reserved Local::* category or by using a category name that includes an underscore like Foo_Corp::*.</source>
          <target state="translated">Если вы разрабатываете модули для частного внутреннего или проектного использования,которые никогда не будут выпущены для всеобщего доступа,то вы должны убедиться,что их имена не будут конфликтовать с любыми будущими публичными модулями.Вы можете сделать это либо с помощью зарезервированной категории Local::*,либо с помощью имени категории,содержащего символ подчеркивания типа Foo_Corp::*.</target>
        </trans-unit>
        <trans-unit id="1bf0d1f77248c2c58d4104ac428f32e38cbba679" translate="yes" xml:space="preserve">
          <source>If either (or both!) is a subroutine reference, it is run and used as the value for comparing. For example:</source>
          <target state="translated">Если любая из подпрограмм (или обе!)является ссылкой на подпрограмму,она запускается и используется в качестве значения для сравнения.Например:</target>
        </trans-unit>
        <trans-unit id="28e0eb14814bacb4c751344661d230f561ecbcda" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;LocalHost&lt;/code&gt; or &lt;code&gt;PeerHost&lt;/code&gt; (or their &lt;code&gt;...Addr&lt;/code&gt; synonyms) have any of the following special forms then special parsing is applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0201c4d3bcdfd14f6a2e27e712be0d303b850c91" translate="yes" xml:space="preserve">
          <source>If either name is unknown, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt; &quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . This function does not recognize those in the property parameter, returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если какое-либо имя неизвестно, возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что Perl обычно распознает имена свойств в регулярных выражениях с дополнительным &lt;code&gt;&quot;Is_&lt;/code&gt; &amp;raquo; (с подчеркиванием или без него), например &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . Эта функция не распознает те, что указаны в параметре свойства, возвращая &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2293e2a6915536d356b477a7689ee15921487cbe" translate="yes" xml:space="preserve">
          <source>If either name is unknown, &lt;code&gt;undef&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt;&quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt;. This function does not recognize those in the property parameter, returning &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3926f5454427802efbe3e6cffcb07732270c9a24" translate="yes" xml:space="preserve">
          <source>If either operand of scalar &lt;code&gt;&quot;..&quot;&lt;/code&gt; is a constant expression, that operand is considered true if it is equal (&lt;code&gt;==&lt;/code&gt; ) to the current input line number (the &lt;code&gt;$.&lt;/code&gt; variable).</source>
          <target state="translated">Если любой из операндов скаляра &lt;code&gt;&quot;..&quot;&lt;/code&gt; является постоянным выражением, этот операнд считается истинным, если он равен ( &lt;code&gt;==&lt;/code&gt; ) текущему номеру строки ввода ( переменная &lt;code&gt;$.&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5ec204ca8034e3ccafb322d0a50a88db1356b7fd" translate="yes" xml:space="preserve">
          <source>If either operand of scalar &lt;code&gt;&quot;..&quot;&lt;/code&gt; is a constant expression, that operand is considered true if it is equal (&lt;code&gt;==&lt;/code&gt;) to the current input line number (the &lt;code&gt;$.&lt;/code&gt; variable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2cb5b8cc9c4debb5e9c1cd9b0aff54bfa3a6950" translate="yes" xml:space="preserve">
          <source>If either reader or writer is the empty string or undefined, this will be replaced by an autogenerated filehandle. If so, you must pass a valid lvalue in the parameter slot so it can be overwritten in the caller, or an exception will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99b132bd00ba92228931c93b4096f125672ade0" translate="yes" xml:space="preserve">
          <source>If either reader or writer is the null string, this will be replaced by an autogenerated filehandle. If so, you must pass a valid lvalue in the parameter slot so it can be overwritten in the caller, or an exception will be raised.</source>
          <target state="translated">Если нулевой строкой является либо читатель,либо писатель,то она будет заменена на автогенерированную файловую обработку.Если это так,то вы должны передать действительное значение l в слоте параметров,чтобы оно могло быть перезаписано в вызывающем устройстве,или будет поднято исключение.</target>
        </trans-unit>
        <trans-unit id="c51794930a0cb952da1b5da2c73c8a1455bd1093" translate="yes" xml:space="preserve">
          <source>If embedded documentation (in pod format, see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;) is detected in the script, &lt;code&gt;--help&lt;/code&gt; will also show how to access the documentation.</source>
          <target state="translated">Если встроенная документация (в формате pod, см. &lt;a href=&quot;../perlpod&quot;&gt;Perlpod&lt;/a&gt; ) обнаружена в скрипте, &lt;code&gt;--help&lt;/code&gt; также покажет, как получить доступ к документации.</target>
        </trans-unit>
        <trans-unit id="497536c61f20254b3ce1e548c2f1737e3ae2f43e" translate="yes" xml:space="preserve">
          <source>If embedded documentation (in pod format, see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) is detected in the script, &lt;code&gt;--help&lt;/code&gt; will also show how to access the documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69dc58793e20f2f8fe02b29cbd122e892cc2714a" translate="yes" xml:space="preserve">
          <source>If empty is false, mark gv with GVf_INTRO so the next reference assigned is localized, which is how &lt;code&gt; local *foo = $someref; &lt;/code&gt; works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0235b3841ba3dad5d7f48423a5cbad1433ac050" translate="yes" xml:space="preserve">
          <source>If empty is true, replace the GP with a new GP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d066b26000935ae7bb2e10a40ebaebacd4b8b0" translate="yes" xml:space="preserve">
          <source>If enabled, case is ignored when matching option names. If, however, bundling is enabled as well, single character options will be treated case-sensitive.</source>
          <target state="translated">Если включена,регистр игнорируется при совпадении имен опций.Если,однако,включена и опция &quot;Пакетирование&quot;,односимвольные опции будут обработаны с учетом регистра.</target>
        </trans-unit>
        <trans-unit id="db7040756e9968d1786c608e978b27880a9b3f0b" translate="yes" xml:space="preserve">
          <source>If everything else fails, you need to build a stand-alone DLL for perl. Contact me, I did it once. Sockets would not work, as a lot of other stuff.</source>
          <target state="translated">Если все остальное провалится,вам нужно построить отдельную DLL для perl.Свяжись со мной,я сделал это однажды.Розетки не сработают,как и многие другие вещи.</target>
        </trans-unit>
        <trans-unit id="86e67737b28b03a977f15c49feac3a8313e09ab0" translate="yes" xml:space="preserve">
          <source>If exception handling is all you're interested in, use one of the many CPAN modules that handle exceptions, such as &lt;a href=&quot;Try::Tiny&quot;&gt;Try::Tiny&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7b09ae5de32a801bf3504292c1ba7f8a26bf8f" translate="yes" xml:space="preserve">
          <source>If exception handling is all you're interested in, use one of the many CPAN modules that handle exceptions, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Try::Tiny&quot;&gt;Try::Tiny&lt;/a&gt;.</source>
          <target state="translated">Если все, что вас интересует, - это обработка исключений, используйте один из многих модулей CPAN, обрабатывающих исключения, например &lt;a href=&quot;http://search.cpan.org/perldoc/Try::Tiny&quot;&gt;Try :: Tiny&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="24299a423807f4b77a396032f4cc65f70fe49537" translate="yes" xml:space="preserve">
          <source>If explicitly enabled by</source>
          <target state="translated">Если явно разрешено</target>
        </trans-unit>
        <trans-unit id="8ede30fd7e2f6fae82106f61a77ef1de04cb5cb3" translate="yes" xml:space="preserve">
          <source>If false, STDERR is not captured (though it is 'relayed' to keep it somewhat synchronized with STDOUT.)</source>
          <target state="translated">Если false,то STDERR не захватывается (хотя он &quot;ретранслируется&quot;,чтобы сохранить некоторую синхронизацию с STDOUT).</target>
        </trans-unit>
        <trans-unit id="9b5838f52003c96db3e6bffb7f5e0838c7d79e5c" translate="yes" xml:space="preserve">
          <source>If false, readline support in the debugger is disabled in order to debug applications that themselves use ReadLine.</source>
          <target state="translated">В случае ложного срабатывания поддержка readline в отладчике отключается для отладки приложений,которые сами используют ReadLine.</target>
        </trans-unit>
        <trans-unit id="b1fe899108d979b4e6baf329c011d799eeebe85b" translate="yes" xml:space="preserve">
          <source>If filenames might use strange characters, it is safest to open it with &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is magic and can translate characters like &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt; , and &lt;code&gt;|&lt;/code&gt;, which may be the wrong thing to do. (Sometimes, though, it's the right thing.) Three-arg open can also help protect against this translation in cases where it is undesirable.</source>
          <target state="translated">Если в именах файлов могут использоваться странные символы, безопаснее открыть его с помощью &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; , а не &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; - это волшебство и может переводить такие символы, как &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; и &lt;code&gt;|&lt;/code&gt; , что может быть неправильным. (Иногда, однако, это правильно.) Открытие с тремя аргументами также может помочь защитить от этого перевода в тех случаях, когда это нежелательно.</target>
        </trans-unit>
        <trans-unit id="6f78c1ed61e34e06bf280f0bbcc412ab7e6a2d2f" translate="yes" xml:space="preserve">
          <source>If find is used in &lt;a href=&quot;perlsec#Taint-mode&quot;&gt;taint-mode&lt;/a&gt; (-T command line switch or if EUID != UID or if EGID != GID), then internally directory names have to be untainted before they can be &lt;code&gt;chdir&lt;/code&gt;'d to. Therefore they are checked against a regular expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca04d4d675b32f985d24c749a113dd2e8503548" translate="yes" xml:space="preserve">
          <source>If find is used in taint-mode (-T command line switch or if EUID != UID or if EGID != GID) then internally directory names have to be untainted before they can be chdir'ed to. Therefore they are checked against a regular expression</source>
          <target state="translated">Если find используется в taint-mode (переключатель командной строки -T или если EUID !=UID или если EGID !=GID),то имена внутренних каталогов должны быть недоступны для chdir'ed.Поэтому они проверяются на соответствие регулярному выражению</target>
        </trans-unit>
        <trans-unit id="ea1ec16d1d9147a52b3c1c50c90741c5c208db46" translate="yes" xml:space="preserve">
          <source>If flags contains &lt;code&gt;PERL_PV_ESCAPE_QUOTE&lt;/code&gt; then any double quotes in the string will also be escaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae542d10e971a673bbde2971d115357debc351d4" translate="yes" xml:space="preserve">
          <source>If flags contains PERL_PV_ESCAPE_QUOTE then any double quotes in the string will also be escaped.</source>
          <target state="translated">Если флаги содержат PERL_PV_ESCAPE_QUOTE,то любые двойные кавычки в строке также будут экранированы.</target>
        </trans-unit>
        <trans-unit id="5f11c4bbd633be0ac4ec3da7d6d4106626b272c7" translate="yes" xml:space="preserve">
          <source>If for some reason you want to have complete control over the data connection, this includes generating it and calling the &lt;code&gt;response&lt;/code&gt; method when required, then the user can use these methods to do so.</source>
          <target state="translated">Если по какой-то причине вы хотите иметь полный контроль над подключением к данным, это включает его создание и вызов метода &lt;code&gt;response&lt;/code&gt; когда это необходимо, тогда пользователь может использовать эти методы для этого.</target>
        </trans-unit>
        <trans-unit id="527032a383661eed954e5386c22fa00fa6ffa0b3" translate="yes" xml:space="preserve">
          <source>If generating a manual page from standard input, the name will be set to &lt;code&gt;STDIN&lt;/code&gt; if this option is not provided. Providing this option is strongly recommended to set a meaningful manual page name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f20d3ebb86a1fb4909973670b43aa80acbb4c8" translate="yes" xml:space="preserve">
          <source>If hash values couldn't be lists, you lose. You'd probably have to combine all the cities into a single string somehow, and then when time came to write the output, you'd have to break the string into a list, sort the list, and turn it back into a string. This is messy and error-prone. And it's frustrating, because Perl already has perfectly good lists that would solve the problem if only you could use them.</source>
          <target state="translated">Если хэш-значения не могут быть списками,ты проигрываешь.Вам,наверное,пришлось бы как-то объединить все города в одну строку,а потом,когда пришло время писать вывод,вам пришлось бы разбить строку на список,отсортировать список и превратить его обратно в строку.Это грязно и предрасположено к ошибкам.И это расстраивает,потому что у Perl уже есть отличные списки,которые бы решили проблему,если бы вы только могли их использовать.</target>
        </trans-unit>
        <trans-unit id="774c1ecd49cf47f66e5a805e842abcc07904cbac" translate="yes" xml:space="preserve">
          <source>If hints are not available for the specified subroutines, this will cause a compile-time error. Insisting on hints for Perl's built-in functions (eg, &lt;code&gt;open&lt;/code&gt; and &lt;code&gt;close&lt;/code&gt;) is always successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8d248524799b9e3f004b01925fdada9567cc4f" translate="yes" xml:space="preserve">
          <source>If i&amp;lt;checked_at&amp;gt; is a reference to a scalar, then instead it gives the characters pre-checked at the beginning, (and the number of chars by which the C variable name has been advanced. These need to be chopped from the front of</source>
          <target state="translated">Если i &amp;lt;checked_at&amp;gt; является ссылкой на скаляр, то вместо этого он дает символы, предварительно проверенные в начале, (и количество символов, на которое было продвинуто имя переменной C. Они должны быть вырезаны с начала</target>
        </trans-unit>
        <trans-unit id="0cd56861a4473054d59049046296e1c9cc1b21dc" translate="yes" xml:space="preserve">
          <source>If illegalproto warnings are enabled, the prototype declared inside this attribute will be sanity checked at compile time.</source>
          <target state="translated">При включённом предупреждении нелегального прототипа,объявленный внутри этого атрибута,будет проверяться на вменяемость во время компиляции.</target>
        </trans-unit>
        <trans-unit id="4d3aefb53a3e40d895443465bbfd3168415b47af" translate="yes" xml:space="preserve">
          <source>If in doubt, break the expression into simpler terms, or cast all operands to the desired resulting type.</source>
          <target state="translated">В случае сомнений,разбить выражение на более простые термины или привести все операнды к желаемому результирующему типу.</target>
        </trans-unit>
        <trans-unit id="ce224243c2c27e9c319eeded5da4d7520f7a48e0" translate="yes" xml:space="preserve">
          <source>If instead of the recommended GNU make you would like to use the system supplied make program then be sure to install the default rules file properly via the shell command:</source>
          <target state="translated">Если вместо рекомендуемой GNU сделать так,чтобы вы хотели пользоваться поставляемой системой make,то убедитесь,что файл с правилами по умолчанию установлен правильно с помощью команды командной строки оболочки:</target>
        </trans-unit>
        <trans-unit id="8c224a826076db854fafc0daefe6f5025badc4ce" translate="yes" xml:space="preserve">
          <source>If instead you intended to match the word 'foo' at the end of the line followed by whitespace and the word 'bar' on the next line then you can use &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/$(?)\/&lt;/a&gt;&lt;/code&gt; (for example: &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo$(?)\s+bar/&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если вместо этого вы намеревались сопоставить слово 'foo' в конце строки, за которым следует пробел, и слово 'bar' в следующей строке, вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/$(?)\/&lt;/a&gt;&lt;/code&gt; (Например: &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo$(?)\s+bar/&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="835a22059d43bc5ff6100b52d4ba22bb32621c13" translate="yes" xml:space="preserve">
          <source>If instead you intended to match the word 'foo' at the end of the line followed by whitespace and the word 'bar' on the next line then you can use &lt;code&gt;m/$(?)\/&lt;/code&gt; (for example: &lt;code&gt;m/foo$(?)\s+bar/&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d629d0bcda097aa38909a34c55f2d4899baf7fd4" translate="yes" xml:space="preserve">
          <source>If instead you want to sort the array &lt;code&gt;@key&lt;/code&gt; with the comparison routine &lt;code&gt;find_records()&lt;/code&gt; then you can use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03def7cbe4cc9c7f39111662b050f07a1bc1197" translate="yes" xml:space="preserve">
          <source>If instead you want to sort the array @key with the comparison routine &lt;code&gt;find_records()&lt;/code&gt; then you can use:</source>
          <target state="translated">Если вместо этого вы хотите отсортировать массив @key с помощью процедуры сравнения &lt;code&gt;find_records()&lt;/code&gt; вы можете использовать:</target>
        </trans-unit>
        <trans-unit id="d1fc62400435ca2b18e437e1de72ea45d0c40705" translate="yes" xml:space="preserve">
          <source>If invalid, a &lt;code&gt;Malformed UTF-8 character&lt;/code&gt; warning is produced. The &quot;C0&quot; means &quot;process the string character per character&quot;. Without that, the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U*&quot;, ...)&lt;/code&gt; would work in &lt;code&gt;U0&lt;/code&gt; mode (the default if the format string starts with &lt;code&gt;U&lt;/code&gt; ) and it would return the bytes making up the UTF-8 encoding of the target string, something that will always work.</source>
          <target state="translated">Если он недействителен, &lt;code&gt;Malformed UTF-8 character&lt;/code&gt; предупреждение о неверном формате UTF-8 . &amp;laquo;C0&amp;raquo; означает &amp;laquo;обрабатывать строковый символ за символ&amp;raquo;. Без этого &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U*&quot;, ...)&lt;/code&gt; будет работать в режиме &lt;code&gt;U0&lt;/code&gt; (по умолчанию, если строка формата начинается с &lt;code&gt;U&lt;/code&gt; ), и он вернет байты, составляющие кодировку UTF-8 целевой строки, что-то это всегда будет работать.</target>
        </trans-unit>
        <trans-unit id="7e4f3a7639737362f11e314ec120738bd4bec5b1" translate="yes" xml:space="preserve">
          <source>If invalid, a &lt;code&gt;Malformed UTF-8 character&lt;/code&gt; warning is produced. The &quot;C0&quot; means &quot;process the string character per character&quot;. Without that, the &lt;code&gt;unpack(&quot;U*&quot;, ...)&lt;/code&gt; would work in &lt;code&gt;U0&lt;/code&gt; mode (the default if the format string starts with &lt;code&gt;U&lt;/code&gt;) and it would return the bytes making up the UTF-8 encoding of the target string, something that will always work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c33e52f177d40ae2c3679305c70e4a9572745e" translate="yes" xml:space="preserve">
          <source>If it ain't broke, don't fix it! Perl 4 library scripts should continue to work with no problems. You may need to make some minor changes (like escaping non-array @'s in double quoted strings) but there is no need to convert a .pl file into a Module for just that.</source>
          <target state="translated">Если он не сломался,не чини его! Скрипты библиотеки Perl 4 должны продолжать работать без проблем.Вам может понадобиться внести некоторые незначительные изменения (например,экранирование не массива @ в двойных кавычках),но для этого нет необходимости преобразовывать .pl-файл в Модуль.</target>
        </trans-unit>
        <trans-unit id="5ae3aaa5715ffc32724b48d8610f7a354399dcc4" translate="yes" xml:space="preserve">
          <source>If it does not yet provide support for any encoding, one could write a derived class with such a &lt;code&gt;param&lt;/code&gt; method:</source>
          <target state="translated">Если он еще не обеспечивает поддержку для любого кодирования, можно был бы написать производный класс с такими &lt;code&gt;param&lt;/code&gt; способом:</target>
        </trans-unit>
        <trans-unit id="9548720aabed2519dabd7936701802a11d8a7465" translate="yes" xml:space="preserve">
          <source>If it exists, this field must contains a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed0026aa4685c99082bcd85012c95fb26671228" translate="yes" xml:space="preserve">
          <source>If it is defined and perl is compiled with the C macro &lt;code&gt;DL_UNLOAD_ALL_AT_EXIT&lt;/code&gt; defined, then it is called automatically when the interpreter exits for every shared object or library loaded by DynaLoader::bootstrap. All such library references are stored in @dl_librefs by DynaLoader::Bootstrap as it loads the libraries. The files are unloaded in last-in, first-out order.</source>
          <target state="translated">Если он определен и perl скомпилирован с определенным макросом C &lt;code&gt;DL_UNLOAD_ALL_AT_EXIT&lt;/code&gt; , то он вызывается автоматически, когда интерпретатор завершает работу для каждого общего объекта или библиотеки, загруженной DynaLoader :: bootstrap. Все такие ссылки на библиотеки хранятся в @dl_librefs программой DynaLoader :: Bootstrap по мере загрузки библиотек. Файлы выгружаются в порядке очереди.</target>
        </trans-unit>
        <trans-unit id="5b2268451c0f057ce91551f0143bc7efcca84a61" translate="yes" xml:space="preserve">
          <source>If it is determined to be case insensitive, during survey() it may skip pod files/modules that happen to be equal to names it's already seen, ignoring case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d25babefad3e04149e431c9fc9b4ab7fa3f715" translate="yes" xml:space="preserve">
          <source>If it is important to you that your bug be fixed, do monitor the issue tracker (you will be subscribed to notifications for issues you submit or comment on) and the commit logs to development versions of Perl, and encourage the maintainers with kind words or offers of frosty beverages. (Please do be kind to the maintainers. Harassing or flaming them is likely to have the opposite effect of the one you want.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860a9992a29a5bed07a92916afafcc39c4466897" translate="yes" xml:space="preserve">
          <source>If it is important to you that your bug be fixed, do monitor the perl5-porters@perl.org mailing list (mailing lists are moderated, your message may take a while to show up) and the commit logs to development versions of Perl, and encourage the maintainers with kind words or offers of frosty beverages. (Please do be kind to the maintainers. Harassing or flaming them is likely to have the opposite effect of the one you want.)</source>
          <target state="translated">Если вам важно,чтобы ошибка была исправлена,проследите за списком рассылки perl5-porters@perl.org (списки рассылки модерируются,ваше сообщение может занять некоторое время)и журналами коммитов к разрабатываемым версиям Perl,а также поощряйте мейнтейнеров добрыми словами или предложениями замороженных напитков.(Пожалуйста,будьте добры к сопровождающим.Преследование или поджог их,скорее всего,будет иметь противоположный эффект по сравнению с тем,что вы хотите).</target>
        </trans-unit>
        <trans-unit id="835fcc1c62a963fd6a71d84d2861d08fa2d6dba4" translate="yes" xml:space="preserve">
          <source>If it is impossible to tell from the parameters passed back from the C callback what the context is, then you may need to create a sequence of C callback interface functions, and store pointers to each in an array.</source>
          <target state="translated">Если по параметрам,переданным обратно из C callback,невозможно определить,что такое контекст,то может потребоваться создать последовательность интерфейсных функций C callback,и сохранить указатели на каждый из них в массиве.</target>
        </trans-unit>
        <trans-unit id="5680f195fb6f8f7119b1a5d53970a5a24089ffc3" translate="yes" xml:space="preserve">
          <source>If it is intended that a new perl binary be produced, this variable may hold a name for that binary. Defaults to perl</source>
          <target state="translated">Если предполагается,что будет произведен новый двоичный файл perl,эта переменная может содержать имя этого двоичного файла.По умолчанию используется значение perl</target>
        </trans-unit>
        <trans-unit id="3922ec0b4a5411b9d0c3915227bde5d37e804a93" translate="yes" xml:space="preserve">
          <source>If it persists, you may disable this warnings, see &lt;a href=&quot;#PERL_BADFREE&quot;&gt;&quot;&lt;code&gt;PERL_BADFREE&lt;/code&gt;&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1ca7ba722f679f82900212b2623b7a140c3fd8" translate="yes" xml:space="preserve">
          <source>If it persists, you may disable this warnings, see &lt;a href=&quot;#PERL_BADFREE&quot;&gt;PERL_BADFREE&lt;/a&gt;.</source>
          <target state="translated">Если он не исчезнет, ​​вы можете отключить это предупреждение, см. &lt;a href=&quot;#PERL_BADFREE&quot;&gt;PERL_BADFREE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3596d2c66fdea5d09f2cf7238ff867c93df8d69a" translate="yes" xml:space="preserve">
          <source>If it runs thru the entire given list of language-tags, and finds no classes for those exact terms, it then tries &quot;superordinate&quot; language classes. So if no &quot;en-US&quot; class (i.e., YourProjClass::en_us) was found, nor classes for anything else in that list, we then try its superordinate, &quot;en&quot; (i.e., YourProjClass::en), and so on thru the other language-tags in the given list: &quot;es&quot;. (The other language-tags in our example list: happen to have no superordinates.)</source>
          <target state="translated">Если он пробегает через весь приведенный список языковых тегов и не находит классов для этих конкретных терминов,то он пытается использовать &quot;вышестоящие&quot; классы языка.Таким образом,если не найдено ни класса &quot;en-US&quot; (т.е.YourProjClass::en_us),ни классов для чего-либо еще в этом списке,то мы попробуем его вышестоящий класс &quot;en&quot; (т.е.YourProjClass::en),и т.д.через другие теги языка в данном списке:&quot;es&quot;.(У других языковых тегов в нашем списке примеров:так случилось,что у них нет вышестоящих координат).</target>
        </trans-unit>
        <trans-unit id="956013cc75574f32898bd3291e14ae9c281c9d63" translate="yes" xml:space="preserve">
          <source>If it's a regular enough string that it always has the same format, you can split it up and pass the parts to &lt;code&gt;timelocal&lt;/code&gt; in the standard &lt;a href=&quot;Time::Local&quot;&gt;Time::Local&lt;/a&gt; module. Otherwise, you should look into the &lt;a href=&quot;Date::Calc&quot;&gt;Date::Calc&lt;/a&gt;, &lt;a href=&quot;Date::Parse&quot;&gt;Date::Parse&lt;/a&gt;, and &lt;a href=&quot;Date::Manip&quot;&gt;Date::Manip&lt;/a&gt; modules from CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9c27ad93f7400ed6fd8cabde972a2941b1fcc1" translate="yes" xml:space="preserve">
          <source>If it's a regular enough string that it always has the same format, you can split it up and pass the parts to &lt;code&gt;timelocal&lt;/code&gt; in the standard &lt;a href=&quot;time/local&quot;&gt;Time::Local&lt;/a&gt; module. Otherwise, you should look into the &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Parse&quot;&gt;Date::Parse&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date::Manip&lt;/a&gt; modules from CPAN.</source>
          <target state="translated">Если это достаточно обычная строка, которая всегда имеет один и тот же формат, вы можете разделить ее и передать части &lt;code&gt;timelocal&lt;/code&gt; в стандартном модуле &lt;a href=&quot;time/local&quot;&gt;Time :: Local&lt;/a&gt; . В противном случае вам следует изучить модули &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Parse&quot;&gt;Date :: Parse&lt;/a&gt; и &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date :: Manip&lt;/a&gt; из CPAN.</target>
        </trans-unit>
        <trans-unit id="95cd7c9791eb757b708be268b21d99a1603edf51" translate="yes" xml:space="preserve">
          <source>If it's run from a terminal,</source>
          <target state="translated">Если он работает от терминала,</target>
        </trans-unit>
        <trans-unit id="6e686f47ff84852246c986f46416264b0b26f101" translate="yes" xml:space="preserve">
          <source>If just a raw diff is provided, it is also possible use this two-step process:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e1fe8c1c0f93c5cc464283fb0d88ef22d53da9" translate="yes" xml:space="preserve">
          <source>If layers are not explicitly specified, the handle will be opened with the layers specified by the &lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt;${^OPEN}&lt;/a&gt; variable (usually set by using the &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma for a lexical scope, or the &lt;code&gt;-C&lt;/code&gt; command-line switch or &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable for the main program scope).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e46426c1bbbb04008f9627a6d4ae412c2a64f7b8" translate="yes" xml:space="preserve">
          <source>If layers are not specified in the open() call or &lt;code&gt;${^OPEN}&lt;/code&gt; variable, the handle will be opened with the default layer stack configured for that architecture; see &lt;a href=&quot;#Defaults-and-how-to-override-them&quot;&gt;&quot;Defaults and how to override them&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec1e5cfa3f1d5f23853bddc58974b89d51e4343" translate="yes" xml:space="preserve">
          <source>If linking miniperl</source>
          <target state="translated">При перекрутке миниперла</target>
        </trans-unit>
        <trans-unit id="6f1ded59583efe50b40fd8b1ab3b5be326101642" translate="yes" xml:space="preserve">
          <source>If locale matching rules are in effect, the case map is taken from the current locale for code points less than 255, and from Unicode rules for larger code points. However, matches that would cross the Unicode rules/non-Unicode rules boundary (ords 255/256) will not succeed, unless the locale is a UTF-8 one. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bdbff6d4225cd79b23186ed9cad6253292a76ca" translate="yes" xml:space="preserve">
          <source>If locale matching rules are in effect, the case map is taken from the current locale for code points less than 255, and from Unicode rules for larger code points. However, matches that would cross the Unicode rules/non-Unicode rules boundary (ords 255/256) will not succeed. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">Если действуют правила сопоставления языковых стандартов, то карта регистра берется из текущего языкового стандарта для кодовых точек меньше 255 и из правил Юникода для более крупных кодовых точек. Однако совпадения, которые пересекают границу правил Unicode / правил не-Unicode (порядки 255/256), не будут успешными. Смотрите &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="763f933c48615038adc7019dfce8f6c0c593c306" translate="yes" xml:space="preserve">
          <source>If locale rules are not in effect, the use of a Unicode property will force the regular expression into using Unicode rules, if it isn't already.</source>
          <target state="translated">Если правила локали не действуют,то использование свойства Юникод заставит регулярное выражение использовать правила Юникода,если это еще не так.</target>
        </trans-unit>
        <trans-unit id="d834fc3f63056ccac9737e1620e9488be6eb7541" translate="yes" xml:space="preserve">
          <source>If maketext goes to look in an individual %Lexicon for an entry for</source>
          <target state="translated">Если Макетекст пойдет искать в индивидуальном %Lexicon для записи для</target>
        </trans-unit>
        <trans-unit id="3e3dcee3a8b9bd973fa29d705bfdb80867c80c81" translate="yes" xml:space="preserve">
          <source>If many functions use the same failure indication based on the return value, you may want to create a special typedef to handle this situation. Put</source>
          <target state="translated">Если многие функции используют одну и ту же индикацию сбоя,основанную на возвращаемом значении,то для обработки этой ситуации может понадобиться создать специальный шрифт typedef.Пишите на .</target>
        </trans-unit>
        <trans-unit id="b606db88e20200612d730cc961241a27da21957f" translate="yes" xml:space="preserve">
          <source>If module is installed, peeks into the module's manpage, reads the headline, and returns it. Moreover, if the module has been downloaded within this session, does the equivalent on the downloaded module even if it hasn't been installed yet.</source>
          <target state="translated">Если модуль установлен,загляните в меню модуля,прочитайте заголовок и верните его.Более того,если модуль был загружен в этом сеансе,делает эквивалент на загруженном модуле,даже если он ещё не был установлен.</target>
        </trans-unit>
        <trans-unit id="dd58d8ff347dcd8c05f67e1fd3ee4d2440157ff1" translate="yes" xml:space="preserve">
          <source>If more arguments are provided then they are all appended to the message, thus all these lines will have the same effect on the state of the $ctx object:</source>
          <target state="translated">Если аргументов больше,то все они добавляются к сообщению,таким образом,все эти строки будут одинаково влиять на состояние объекта $ctx:</target>
        </trans-unit>
        <trans-unit id="d7d32d6074826a3d2d75814ea308b5ddeaca2f3c" translate="yes" xml:space="preserve">
          <source>If more delimiters than escape chars are specified, the last escape char is used for the remaining delimiters. If no escape char is specified for a given specified delimiter, '\' is used.</source>
          <target state="translated">Если указано больше разделителей,чем экранирующих символов,то для остальных используется последняя экранирующая диаграмма.Если для заданного разделителя не указано ни одной управляющей переменной,то используется '\'.</target>
        </trans-unit>
        <trans-unit id="285c13c421c908ec1b5157ff1d11ce664fe6f585" translate="yes" xml:space="preserve">
          <source>If more than one argument is given then the entire argument list is assumed to be a hash. If a hash is supplied (either as a reference or as a list) it should contain one or more elements with the following keys:</source>
          <target state="translated">Если дается более одного аргумента,то весь список аргументов считается хэшем.Если поставляется хэш (как ссылка или как список),он должен содержать один или несколько элементов со следующими ключами:</target>
        </trans-unit>
        <trans-unit id="39e41b545db315dc5126671cc2bd5d88f5c30e3d" translate="yes" xml:space="preserve">
          <source>If more than one restriction of &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;distribution&lt;/code&gt; , etc. is specified, the results of the separately computed match values must all match. If so, the hashref represented by the YAML document is returned as the preference structure for the current distribution.</source>
          <target state="translated">Если указано более одного ограничения &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;distribution&lt;/code&gt; и т. Д., Результаты отдельно вычисленных значений соответствия должны совпадать. Если это так, хэш-ссылка, представленная документом YAML, возвращается в качестве структуры предпочтений для текущего распределения.</target>
        </trans-unit>
        <trans-unit id="da05e2a6f3037e503e2698db0f33736532af13ae" translate="yes" xml:space="preserve">
          <source>If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="translated">Если список содержит более одной переменной,он должен быть заключен в круглые скобки.</target>
        </trans-unit>
        <trans-unit id="463724a0fef86ec9bcf7097a4a23f19c350c87fd" translate="yes" xml:space="preserve">
          <source>If more than one variable is listed, the list must be placed in parentheses. With a parenthesised list, &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; can be used as a dummy placeholder. However, since initialization of state variables in such lists is currently not possible this would serve no purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5915108dabbdb47d0e6487842fce0264a4b8c92e" translate="yes" xml:space="preserve">
          <source>If more than one variable is listed, the list must be placed in parentheses. With a parenthesised list, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder. However, since initialization of state variables in list context is currently not possible this would serve no purpose.</source>
          <target state="translated">Если указано более одной переменной, список должен быть заключен в круглые скобки. Со списком в скобках &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; можно использовать как фиктивный заполнитель. Однако, поскольку инициализация переменных состояния в контексте списка в настоящее время невозможна, это бесполезно.</target>
        </trans-unit>
        <trans-unit id="13f0dd65ec56750a188884a636ba7b4f0428367d" translate="yes" xml:space="preserve">
          <source>If more than one variable is listed, the list must be placed in parentheses. With a parenthesised list, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder. However, since initialization of state variables in list context is currently not possible this would serve no purpose.</source>
          <target state="translated">Если указано более одной переменной, список должен быть заключен в круглые скобки. Со списком в скобках &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; можно использовать как фиктивный заполнитель. Однако, поскольку инициализация переменных состояния в контексте списка в настоящее время невозможна, это бесполезно.</target>
        </trans-unit>
        <trans-unit id="cc246b70384e8a417eb59e4e6e4575312d9d1e0a" translate="yes" xml:space="preserve">
          <source>If more than one variable or expression is given to &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, they must be placed in parentheses. This operator works by saving the current values of those variables in its argument list on a hidden stack and restoring them upon exiting the block, subroutine, or eval. This means that called subroutines can also reference the local variable, but not the global one. The argument list may be assigned to if desired, which allows you to initialize your local variables. (If no initializer is given for a particular variable, it is created with an undefined value.)</source>
          <target state="translated">Если в &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; дано несколько переменных или выражений , их необходимо заключить в круглые скобки. Этот оператор работает, сохраняя текущие значения этих переменных в своем списке аргументов в скрытом стеке и восстанавливая их при выходе из блока, подпрограммы или eval. Это означает, что вызываемые подпрограммы также могут ссылаться на локальную переменную, но не на глобальную. При желании можно назначить список аргументов, что позволяет инициализировать локальные переменные. (Если для конкретной переменной не указан инициализатор, она создается с неопределенным значением.)</target>
        </trans-unit>
        <trans-unit id="085c88b116674b900e024434a6a7c1e9689729b6" translate="yes" xml:space="preserve">
          <source>If more than one variable or expression is given to &lt;code&gt;local&lt;/code&gt;, they must be placed in parentheses. This operator works by saving the current values of those variables in its argument list on a hidden stack and restoring them upon exiting the block, subroutine, or eval. This means that called subroutines can also reference the local variable, but not the global one. The argument list may be assigned to if desired, which allows you to initialize your local variables. (If no initializer is given for a particular variable, it is created with an undefined value.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e3db41fbfcf6140e9c02e059dd4c934fd6f5ad" translate="yes" xml:space="preserve">
          <source>If multiple distinct capture groups have the same name then the $+{NAME} will refer to the leftmost defined group in the match.</source>
          <target state="translated">Если несколько различных групп захвата имеют одно и то же имя,то $+{NAME}будет относиться к самой левой определенной группе в матче.</target>
        </trans-unit>
        <trans-unit id="585d6ab5fb9075615690fae06a03a5a68fb5033a" translate="yes" xml:space="preserve">
          <source>If multiple distinct capture groups have the same name, then &lt;code&gt;$+{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; will refer to the leftmost defined group in the match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba43723459a9559595b0c9aa2500eb340a4dc46e" translate="yes" xml:space="preserve">
          <source>If multiple distinct capture groups have the same name, then &lt;code&gt;$+{NAME}&lt;/code&gt; will refer to the leftmost defined group in the match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfee97a70420feb4c2945973c34123d251dd9c2" translate="yes" xml:space="preserve">
          <source>If multiple files from one program are desired an array ref can be used.</source>
          <target state="translated">При необходимости использования нескольких файлов из одной программы можно использовать ссылку на массив.</target>
        </trans-unit>
        <trans-unit id="081ad6caef0052cfab1aad2ae1061ca747e43248" translate="yes" xml:space="preserve">
          <source>If multiple transliterations are given for a character, only the first one is used:</source>
          <target state="translated">Если для символа задано несколько транслитераций,то используется только первая:</target>
        </trans-unit>
        <trans-unit id="c414b75ce1c860047ef0a566364396ec60b38e43" translate="yes" xml:space="preserve">
          <source>If my tests take too long to run I may be able to speed them up by running multiple test scripts in parallel. This is particularly effective if the tests are I/O bound or if I have multiple CPU cores. I tell prove to run my tests in parallel like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766c6735ff098a4b925a773897fe49012fa4895d" translate="yes" xml:space="preserve">
          <source>If name passed in doesn't specify a readable file, appends</source>
          <target state="translated">Если передаваемое имя не указывает читаемый файл,то добавляется</target>
        </trans-unit>
        <trans-unit id="1afec739c7f1e924deac0edbd4a6af96f74019ce" translate="yes" xml:space="preserve">
          <source>If necessary switch the input stream to handle unicode. This only has any effect for I/O handle based streams.</source>
          <target state="translated">При необходимости переключите входной поток для работы с юникодом.Это имеет эффект только для потоков,основанных на обработке входов/выходов.</target>
        </trans-unit>
        <trans-unit id="1f88753647459114bf0fff92153d71fa3be1ef0c" translate="yes" xml:space="preserve">
          <source>If needed, &lt;code&gt;$new_size&lt;/code&gt; will be rounded up to the next multiple of the memory page size (usually 4096 or 8192).</source>
          <target state="translated">При необходимости &lt;code&gt;$new_size&lt;/code&gt; будет округлено до следующего кратного размера страницы памяти (обычно 4096 или 8192).</target>
        </trans-unit>
        <trans-unit id="13ffb9e8f4aa9a45a3175ee9916b5d80efc23ef5" translate="yes" xml:space="preserve">
          <source>If needed, a thread can be exited at any time by calling &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; . This will cause the thread to return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in a scalar context, or the empty list in a list context.</source>
          <target state="translated">При необходимости из потока можно выйти в любое время, вызвав &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; . Это приведет к тому, что поток вернет &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в скалярном контексте или пустой список в контексте списка.</target>
        </trans-unit>
        <trans-unit id="7fa85a1effefc4c0579975cf6db618b5a32a7f98" translate="yes" xml:space="preserve">
          <source>If needed, a thread can be exited at any time by calling &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt;. This will cause the thread to return &lt;code&gt;undef&lt;/code&gt; in a scalar context, or the empty list in a list context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba4f2509d5dd63a76d44f087cc7f42f7f77c757a" translate="yes" xml:space="preserve">
          <source>If needed, scripts can be written so as to run on both threaded and non-threaded Perls:</source>
          <target state="translated">При необходимости,скрипты могут быть написаны так,чтобы работать как на потоковых,так и на непоточных Perls:</target>
        </trans-unit>
        <trans-unit id="91fbdba912e7cde9b89fa3cefbc9b3e7d8d65343" translate="yes" xml:space="preserve">
          <source>If needed, these methods should be defined by the package inheriting from &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. See &lt;a href=&quot;../perltie#SCALAR&quot;&gt;SCALAR in perltie&lt;/a&gt; to find out what happens when &lt;code&gt;SCALAR&lt;/code&gt; does not exist.</source>
          <target state="translated">При необходимости эти методы должны быть определены пакетом, унаследованным от &lt;b&gt;Tie :: Hash&lt;/b&gt; , &lt;b&gt;Tie :: StdHash&lt;/b&gt; или &lt;b&gt;Tie :: ExtraHash&lt;/b&gt; . См. &lt;a href=&quot;../perltie#SCALAR&quot;&gt;SCALAR в perltie,&lt;/a&gt; чтобы узнать, что происходит, когда &lt;code&gt;SCALAR&lt;/code&gt; не существует.</target>
        </trans-unit>
        <trans-unit id="e7be13126ea530b0bd8ee259471daa2d8234b8a5" translate="yes" xml:space="preserve">
          <source>If needed, these methods should be defined by the package inheriting from &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. See &lt;a href=&quot;perltie#SCALAR&quot;&gt;&quot;SCALAR&quot; in perltie&lt;/a&gt; to find out what happens when &lt;code&gt;SCALAR&lt;/code&gt; does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a52a7ddea6d450e656d921a0db2fecb1485c60" translate="yes" xml:space="preserve">
          <source>If needed, thread warnings can be suppressed by using:</source>
          <target state="translated">При необходимости,предупреждения по резьбе могут быть подавлены с помощью использования:</target>
        </trans-unit>
        <trans-unit id="7aac81b2bba7d90df4570fdaec9abe8879fce464" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;Family&lt;/code&gt; nor any hosts or addresses are passed, nor any &lt;code&gt;*AddrInfo&lt;/code&gt;, then the constructor has no information on which to decide a socket family to create. In this case, it performs a &lt;code&gt;getaddinfo&lt;/code&gt; call with the &lt;code&gt;AI_ADDRCONFIG&lt;/code&gt; flag, no host name, and a service name of &lt;code&gt;&quot;0&quot;&lt;/code&gt;, and uses the family of the first returned result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d589a6c51332c7705521b2b0ef94169fba9785" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;Type&lt;/code&gt; nor &lt;code&gt;Proto&lt;/code&gt; hints are provided, a default of &lt;code&gt;SOCK_STREAM&lt;/code&gt; and &lt;code&gt;IPPROTO_TCP&lt;/code&gt; respectively will be set, to maintain compatibility with &lt;code&gt;IO::Socket::INET&lt;/code&gt;. Other named arguments that are not recognised are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="620d906a2e9dd53f3e33bb69b96c36a7f678920a" translate="yes" xml:space="preserve">
          <source>If neither of those work, then you can't use adb to cross-compile to your device. Either try rooting it, or go for the ssh route.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8270c68932b39381b724db912d7e0064edb351" translate="yes" xml:space="preserve">
          <source>If neither the &lt;code&gt;-L&lt;/code&gt; or &lt;code&gt;-l&lt;/code&gt; prefix is present in an entry, the entry is considered a directory to search if it is in fact a directory, and a library to search for otherwise. The &lt;code&gt;$Config{lib_ext}&lt;/code&gt; suffix will be appended to any entries that are not directories and don't already have the suffix.</source>
          <target state="translated">Если в записи нет ни префикса &lt;code&gt;-L&lt;/code&gt; , ни &lt;code&gt;-l&lt;/code&gt; , запись считается каталогом для поиска, если это на самом деле каталог, и библиотекой для поиска в противном случае. &lt;code&gt;$Config{lib_ext}&lt;/code&gt; суффикс будет добавлен к любым записям, которые не являются каталогами и еще не имеет суффикса.</target>
        </trans-unit>
        <trans-unit id="2d1c5c51b75ebf17552d122abb9f110644200dac" translate="yes" xml:space="preserve">
          <source>If neither the &lt;code&gt;G_METHOD&lt;/code&gt; nor &lt;code&gt;G_METHOD_NAMED&lt;/code&gt; flag is supplied, the SV may be any of a CV, a GV, a reference to a CV, a reference to a GV or &lt;code&gt;SvPV(sv)&lt;/code&gt; will be used as the name of the sub to call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d1d1804f2f0f5f5a1b0fb679650c8cfecd87fb" translate="yes" xml:space="preserve">
          <source>If neither the exit status nor the verbose level is specified, then the default is to use an exit status of 2 with a verbose level of 0.</source>
          <target state="translated">Если ни статус выхода,ни многословный уровень не указаны,то по умолчанию используется статус выхода 2 с многословным уровнем 0.</target>
        </trans-unit>
        <trans-unit id="ca010fd55b822b0537501828b1432d2b69dedb67" translate="yes" xml:space="preserve">
          <source>If neither your configured &lt;code&gt;yaml_module&lt;/code&gt; nor YAML.pm is installed, CPAN.pm falls back to using Data::Dumper and Storable and looks for files with the extensions &lt;code&gt;.dd&lt;/code&gt; or &lt;code&gt;.st&lt;/code&gt; in the &lt;code&gt;prefs_dir&lt;/code&gt; directory. These files are expected to contain one or more hashrefs. For Data::Dumper generated files, this is expected to be done with by defining &lt;code&gt;$VAR1&lt;/code&gt; , &lt;code&gt;$VAR2&lt;/code&gt; , etc. The YAML shell would produce these with the command</source>
          <target state="translated">Если ни один настроенный &lt;code&gt;yaml_module&lt;/code&gt; ни YAML.pm установлен, CPAN.pm возвращается к использованию Data :: Dumper хранящимся и ищет файлы с расширениями &lt;code&gt;.dd&lt;/code&gt; или &lt;code&gt;.st&lt;/code&gt; в &lt;code&gt;prefs_dir&lt;/code&gt; каталоге. Ожидается, что эти файлы будут содержать один или несколько хэш-адресов. Ожидается, что для файлов, сгенерированных Data :: Dumper, это будет сделано путем определения &lt;code&gt;$VAR1&lt;/code&gt; , &lt;code&gt;$VAR2&lt;/code&gt; и т. Д. Оболочка YAML создаст их с помощью команды</target>
        </trans-unit>
        <trans-unit id="1ff3f3f68e857a065a27224d0e20ede58778f1ae" translate="yes" xml:space="preserve">
          <source>If new() is called as an instance method (i.e. $ctx-&amp;gt;new) it will just reset the state the object to the state of a newly created object. No new object is created in this case, and the return value is the reference to the object (i.e. $ctx).</source>
          <target state="translated">Если new () вызывается как метод экземпляра (например, $ ctx-&amp;gt; new), он просто сбрасывает состояние объекта до состояния вновь созданного объекта. В этом случае новый объект не создается, а возвращаемое значение - это ссылка на объект (т.е. $ ctx).</target>
        </trans-unit>
        <trans-unit id="2e13ee0a65adecfa0d8e7d8968c5c8fbe048cddb" translate="yes" xml:space="preserve">
          <source>If no $default is provided an empty string will be used instead.</source>
          <target state="translated">Если $default не указан,вместо него будет использована пустая строка.</target>
        </trans-unit>
        <trans-unit id="0472c17854436e8327aa450d7bb9d0ca29c0fa4c" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;$VERSION&lt;/code&gt; was specified on the &lt;code&gt;bootstrap&lt;/code&gt; line, the last line becomes</source>
          <target state="translated">Если в строке &lt;code&gt;bootstrap&lt;/code&gt; не было указано &lt;code&gt;$VERSION&lt;/code&gt; , последняя строка становится</target>
        </trans-unit>
        <trans-unit id="1b4091cfd69b61e159053e0bbc2425f479136432" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;$section_spec&lt;/code&gt; arguments are given, then the existing set of selected sections is cleared out (which means &lt;code&gt;all&lt;/code&gt; sections will be processed).</source>
          <target state="translated">Если аргументы &lt;code&gt;$section_spec&lt;/code&gt; не указаны, то существующий набор выбранных разделов очищается (что означает, что &lt;code&gt;all&lt;/code&gt; разделы будут обработаны).</target>
        </trans-unit>
        <trans-unit id="c0be16a9153a991182a683ab2886f1fa902dd9f4" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; is found and if the last statement is an expression, its value is returned. If the last statement is a loop control structure like a &lt;code&gt;foreach&lt;/code&gt; or a &lt;code&gt;while&lt;/code&gt; , the returned value is unspecified. The empty sub returns the empty list.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; не найдено и если последний оператор является выражением, возвращается его значение. Если последний оператор представляет собой структуру управления циклом, такую ​​как &lt;code&gt;foreach&lt;/code&gt; или &lt;code&gt;while&lt;/code&gt; , возвращаемое значение не указано. Пустая подпрограмма возвращает пустой список.</target>
        </trans-unit>
        <trans-unit id="97d668cbdc526d3cbea7edc6414a728eb26feaf0" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;return&lt;/code&gt; is found and if the last statement is an expression, its value is returned. If the last statement is a loop control structure like a &lt;code&gt;foreach&lt;/code&gt; or a &lt;code&gt;while&lt;/code&gt;, the returned value is unspecified. The empty sub returns the empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9cd2f55bd05fa55b1648853a5a5e34325f19ca" translate="yes" xml:space="preserve">
          <source>If no @args are given, no @cmds will be returned.</source>
          <target state="translated">Если @args не даны,@cmds не будут возвращены.</target>
        </trans-unit>
        <trans-unit id="d11be4d28581ad6cd28ff2cca82d45474710696d" translate="yes" xml:space="preserve">
          <source>If no MANIFEST.SKIP file is found, a default set of skips will be used, similar to the example above. If you want nothing skipped, simply make an empty MANIFEST.SKIP file.</source>
          <target state="translated">Если файл MANIFEST.SKIP не найден,будет использован набор пропусков по умолчанию,как в примере выше.Если вы ничего не хотите пропустить,просто сделайте пустой MANIFEST.SKIP файл.</target>
        </trans-unit>
        <trans-unit id="482e18ae3dbe759dbfcebf52b00cc2a6c84ee16a" translate="yes" xml:space="preserve">
          <source>If no argument is given, the highest possible setting will be used, which is rarely useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc9afdb8826971e1f36212e96bd04623eb38e92" translate="yes" xml:space="preserve">
          <source>If no argument is given, the limit check will be deactivated (same as when &lt;code&gt;0&lt;/code&gt; is specified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae10c8870eae9f10da944c7a01e813768cc713b" translate="yes" xml:space="preserve">
          <source>If no arguments are given to pod2man it will read from @ARGV.</source>
          <target state="translated">Если pod2man не аргументирован,он будет читаться из @ARGV.</target>
        </trans-unit>
        <trans-unit id="87c6b87283ba7c4ecec068cb48f3ae13420b59ed" translate="yes" xml:space="preserve">
          <source>If no arguments are given, &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; returns the entire formatted archive as a string, which could be useful if you'd like to stuff the archive into a socket or a pipe to gzip or something.</source>
          <target state="translated">Если аргументы не указаны, &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; возвращает весь форматированный архив в виде строки, что может быть полезно, если вы хотите поместить архив в сокет или канал для gzip или что-то в этом роде.</target>
        </trans-unit>
        <trans-unit id="0ab20efd7be2867edc836fd9f4e9fd1df47b1ae4" translate="yes" xml:space="preserve">
          <source>If no arguments are given, &lt;code&gt;write&lt;/code&gt; returns the entire formatted archive as a string, which could be useful if you'd like to stuff the archive into a socket or a pipe to gzip or something.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="886a141165f04df6d6f369bc4c3d2d482bb6efce" translate="yes" xml:space="preserve">
          <source>If no arguments are passed then the current article in the currently selected newsgroup is fetched.</source>
          <target state="translated">Если аргументы не передаются,то запрашивается текущая статья в текущей выбранной группе новостей.</target>
        </trans-unit>
        <trans-unit id="1361c81765e284924a4726230ee621f378f42412" translate="yes" xml:space="preserve">
          <source>If no error occurs, &lt;code&gt;eval&lt;/code&gt; sets &lt;code&gt;$@&lt;/code&gt; to the empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc296f09027fdaaecb023b3cebc4e9cba37abbb" translate="yes" xml:space="preserve">
          <source>If no extension is supplied, and your system supports it, the original</source>
          <target state="translated">Если расширение не поставляется,а ваша система его поддерживает,то оригинальный</target>
        </trans-unit>
        <trans-unit id="85c571c913f7bfa21e872b065c24a094b4bb7659" translate="yes" xml:space="preserve">
          <source>If no files or directories are supplied, &lt;code&gt;prove&lt;/code&gt; looks for all files matching the pattern &lt;code&gt;t/*.t&lt;/code&gt;.</source>
          <target state="translated">Если файлы или каталоги не поставляются, &lt;code&gt;prove&lt;/code&gt; внешний вид для всех файлов , соответствующих шаблону &lt;code&gt;t/*.t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4c68647b34bca31278b9d9c157de53c4f611c93" translate="yes" xml:space="preserve">
          <source>If no flags argument is give then &lt;code&gt;GLOB_CSH&lt;/code&gt; is set, and on VMS and Windows systems, &lt;code&gt;GLOB_NOCASE&lt;/code&gt; too. Otherwise the flags to use are determined solely by the flags argument. The POSIX defined flags are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea57f19921408109bb2fb4d00e16350d27b4844" translate="yes" xml:space="preserve">
          <source>If no import list is supplied, all possible VMS-specific features are assumed. Currently, there are four VMS-specific features available: 'status' (a.k.a '$?'), 'exit', 'time' and 'hushed'.</source>
          <target state="translated">Если список импортируемых данных не поставляется,то предполагается наличие всех возможных специфических для VMS функций.В настоящее время доступны четыре специфических для VMS функции:&quot;статус&quot; (также известный как &quot;$?&quot;),&quot;выход&quot;,&quot;время&quot; и &quot;замалчивание&quot;.</target>
        </trans-unit>
        <trans-unit id="d4ceff2a6aadec6052244b97bba7012539a0b105" translate="yes" xml:space="preserve">
          <source>If no import list is supplied, all possible restrictions are assumed. (This is the safest mode to operate in, but is sometimes too strict for casual programming.) Currently, there are three possible things to be strict about: &quot;subs&quot;, &quot;vars&quot;, and &quot;refs&quot;.</source>
          <target state="translated">Если список импортируемых товаров не поставляется,принимаются все возможные ограничения.(Это самый безопасный режим для работы,но иногда слишком строгий для случайного программирования).В настоящее время есть три возможных ограничения:&quot;subs&quot;,&quot;vars&quot; и &quot;refs&quot;.</target>
        </trans-unit>
        <trans-unit id="c1d6512b9a9d5a5a9bf4112bcb1e3a393263f0b9" translate="yes" xml:space="preserve">
          <source>If no items exists at the specified index (i.e., the queue is empty, or the index is beyond the number of items on the queue), then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если в указанном индексе нет элементов (т. Е. Очередь пуста или индекс превышает количество элементов в очереди), то возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78d629698ed39f1b937dab840c0e7631f8015fc9" translate="yes" xml:space="preserve">
          <source>If no items exists at the specified index (i.e., the queue is empty, or the index is beyond the number of items on the queue), then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9e3e2a819c8fb3d75385fda77f033e08dfb423" translate="yes" xml:space="preserve">
          <source>If no options are given, Pod::Man uses the name of the input file with any trailing &lt;code&gt;.pod&lt;/code&gt;, &lt;code&gt;.pm&lt;/code&gt;, or &lt;code&gt;.pl&lt;/code&gt; stripped as the man page title, to section 1 unless the file ended in &lt;code&gt;.pm&lt;/code&gt; in which case it defaults to section 3, to a centered title of &quot;User Contributed Perl Documentation&quot;, to a centered footer of the Perl version it is run with, and to a left-hand footer of the modification date of its input (or the current date if given &lt;code&gt;STDIN&lt;/code&gt; for input).</source>
          <target state="translated">Если параметры не указаны, Pod :: Man использует имя входного файла с любым завершающим &lt;code&gt;.pod&lt;/code&gt; , &lt;code&gt;.pm&lt;/code&gt; или &lt;code&gt;.pl&lt;/code&gt; ,вырезанным в качестве заголовка страницы руководства, до раздела 1, если только файл не заканчивается на &lt;code&gt;.pm&lt;/code&gt; ,и в этом случае он по умолчанию используется раздел 3, центрированный заголовок &amp;laquo;Пользовательской документации Perl&amp;raquo;, центрированный нижний колонтитул версии Perl, с которой он запускается, и левый нижний колонтитул даты модификации его ввода (или текущая дата, если задан &lt;code&gt;STDIN&lt;/code&gt; для ввода).</target>
        </trans-unit>
        <trans-unit id="1f1608fb3d0f72aad27d7541f9de6e52f802b4ee" translate="yes" xml:space="preserve">
          <source>If no second argument is provided and the category is &lt;code&gt;LC_ALL&lt;/code&gt; , the result is implementation-dependent. It may be a string of concatenated locale names (separator also implementation-dependent) or a single locale name. Please consult your</source>
          <target state="translated">Если второй аргумент не &lt;code&gt;LC_ALL&lt;/code&gt; , а категория - LC_ALL , результат зависит от реализации. Это может быть строка объединенных имен локали (разделитель также зависит от реализации) или одно имя локали. Проконсультируйтесь со своим</target>
        </trans-unit>
        <trans-unit id="267c1696e15f2baca20bbece162193151736f0bb" translate="yes" xml:space="preserve">
          <source>If no second argument is provided and the category is &lt;code&gt;LC_ALL&lt;/code&gt;, the result is implementation-dependent. It may be a string of concatenated locale names (separator also implementation-dependent) or a single locale name. Please consult your &lt;a href=&quot;http://man.he.net/man3/setlocale&quot;&gt;setlocale(3)&lt;/a&gt; man page for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed489574b7ebc8c696d017fb9515c4a591232a34" translate="yes" xml:space="preserve">
          <source>If no second argument is provided and the category is something other than &lt;code&gt;LC_ALL&lt;/code&gt; , the function returns a string naming the current locale for the category. You can use this value as the second argument in a subsequent call to &lt;code&gt;setlocale()&lt;/code&gt; , &lt;b&gt;but&lt;/b&gt; on some platforms the string is opaque, not something that most people would be able to decipher as to what locale it means.</source>
          <target state="translated">Если второй аргумент не &lt;code&gt;LC_ALL&lt;/code&gt; и категория отличается от LC_ALL , функция возвращает строку с указанием текущего языкового стандарта для категории. Вы можете использовать это значение в качестве второго аргумента в последующем вызове &lt;code&gt;setlocale()&lt;/code&gt; , &lt;b&gt;но&lt;/b&gt; на некоторых платформах строка непрозрачна, и большинство людей не сможет понять, какой языковой стандарт она означает.</target>
        </trans-unit>
        <trans-unit id="64041fec58a65d66b2f703a3782bbd84be6d1203" translate="yes" xml:space="preserve">
          <source>If no second argument is provided and the category is something other than &lt;code&gt;LC_ALL&lt;/code&gt;, the function returns a string naming the current locale for the category. You can use this value as the second argument in a subsequent call to &lt;code&gt;setlocale()&lt;/code&gt;, &lt;b&gt;but&lt;/b&gt; on some platforms the string is opaque, not something that most people would be able to decipher as to what locale it means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53385049e198591f3af9c0f621b19586d0e6e03c" translate="yes" xml:space="preserve">
          <source>If no string is specified via the &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator, the &lt;code&gt;$_&lt;/code&gt; variable is searched and modified. Unless the &lt;code&gt;/r&lt;/code&gt; option is used, the string specified must be a scalar variable, an array element, a hash element, or an assignment to one of those; that is, some sort of scalar lvalue.</source>
          <target state="translated">Если с помощью оператора &lt;code&gt;=~&lt;/code&gt; или &lt;code&gt;!~&lt;/code&gt; Строка не указана, выполняется поиск и изменение переменной &lt;code&gt;$_&lt;/code&gt; . Если не используется параметр &lt;code&gt;/r&lt;/code&gt; , указанная строка должна быть скалярной переменной, элементом массива, хеш-элементом или присвоением одному из них; то есть какое-то скалярное lvalue.</target>
        </trans-unit>
        <trans-unit id="9ee4d303ec9de35b4bd6b8caf1f726ddd4ca7c6e" translate="yes" xml:space="preserve">
          <source>If no such Pod file is found, this method returns undef.</source>
          <target state="translated">Если такой Pod-файл не найден,этот метод возвращает undef.</target>
        </trans-unit>
        <trans-unit id="34cd3d77c3969309ab95d1d80fe464b5d299344d" translate="yes" xml:space="preserve">
          <source>If no urllist has been chosen yet, would you prefer CPAN.pm to connect to the built-in default sites without asking? (yes/no)?</source>
          <target state="translated">Если еще не выбран urllist,предпочтете ли вы CPAN.pm для подключения к встроенным сайтам по умолчанию без запроса? (да/нет)?</target>
        </trans-unit>
        <trans-unit id="b1457b54499e074ed5ffc48ffd57a11b298ba627" translate="yes" xml:space="preserve">
          <source>If no value is associated with the attribute, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed.</source>
          <target state="translated">Если с атрибутом не связано никакого значения, передается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e6ead3ce8c862f9ee6e9b2af0ca9c9d3945d613" translate="yes" xml:space="preserve">
          <source>If no value is associated with the attribute, &lt;code&gt;undef&lt;/code&gt; is passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf2ca53d71d01f547a112c6b13519e5e34d198d" translate="yes" xml:space="preserve">
          <source>If non-empty braces are the only wildcard characters used in the &lt;a href=&quot;#glob-EXPR&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt;, no filenames are matched, but potentially many strings are returned. For example, this produces nine strings, one for each pairing of fruits and colors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3641612d3261f449a8b25c55086ede32d34dbbcb" translate="yes" xml:space="preserve">
          <source>If non-empty braces are the only wildcard characters used in the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, no filenames are matched, but potentially many strings are returned. For example, this produces nine strings, one for each pairing of fruits and colors:</source>
          <target state="translated">Если непустые фигурные скобки являются единственными подстановочными знаками, используемыми в &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; , имена файлов не сопоставляются, но потенциально возвращается много строк. Например, получается девять струн, по одной для каждой пары фруктов и цветов:</target>
        </trans-unit>
        <trans-unit id="1328c99f7fc26be401ecc4c3daf8d11e272b065b" translate="yes" xml:space="preserve">
          <source>If non-empty braces are the only wildcard characters used in the &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, no filenames are matched, but potentially many strings are returned. For example, this produces nine strings, one for each pairing of fruits and colors:</source>
          <target state="translated">Если непустые фигурные скобки являются единственными подстановочными знаками, используемыми в &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; , имена файлов не сопоставляются, но потенциально возвращается много строк. Например, получается девять струн, по одной для каждой пары фруктов и цветов:</target>
        </trans-unit>
        <trans-unit id="cf3289643abb0e0247bc66bf82c16e180f16eb54" translate="yes" xml:space="preserve">
          <source>If none of the above apply, for backwards compatibility reasons, the &lt;code&gt;/d&lt;/code&gt; modifier is the one in effect by default. As this can lead to unexpected results, it is best to specify which other rule set should be used.</source>
          <target state="translated">Если ничего из вышеперечисленного не применимо, по причинам обратной совместимости по умолчанию действует модификатор &lt;code&gt;/d&lt;/code&gt; . Поскольку это может привести к неожиданным результатам, лучше всего указать, какой другой набор правил следует использовать.</target>
        </trans-unit>
        <trans-unit id="c4f8a0262880dda1d52bfe8a37ad85562f38ba99" translate="yes" xml:space="preserve">
          <source>If none of the settings are enabled or the respective methods are missing, &lt;code&gt;JSON::PP&lt;/code&gt; throws an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7c7d8696c46f8858c11c99d7d1a93c5e34454b" translate="yes" xml:space="preserve">
          <source>If none of the three command line flags (&lt;b&gt;-w&lt;/b&gt;, &lt;b&gt;-W&lt;/b&gt; or &lt;b&gt;-X&lt;/b&gt;) that control warnings is used and neither &lt;code&gt;$^W&lt;/code&gt; nor the &lt;code&gt;warnings&lt;/code&gt; pragma are used, then default warnings will be enabled and optional warnings disabled. This means that legacy code that doesn't attempt to control the warnings will work unchanged.</source>
          <target state="translated">Если не используется ни один из трех флагов командной строки ( &lt;b&gt;-w&lt;/b&gt; , &lt;b&gt;-W&lt;/b&gt; или &lt;b&gt;-X&lt;/b&gt; ), управляющих предупреждениями, и не используются ни &lt;code&gt;$^W&lt;/code&gt; ни прагма &lt;code&gt;warnings&lt;/code&gt; , то предупреждения по умолчанию будут включены, а дополнительные предупреждения отключены. Это означает, что устаревший код, который не пытается контролировать предупреждения, будет работать без изменений.</target>
        </trans-unit>
        <trans-unit id="3318e55dc39962c8bcf2ab6429b4489bcf36fce0" translate="yes" xml:space="preserve">
          <source>If none of those language-tags leads to loadable classes, we then try classes derived from YourProjClass-&amp;gt;fallback_languages() and then if nothing comes of that, we use classes named by YourProjClass-&amp;gt;fallback_language_classes(). Then in the (probably quite unlikely) event that that fails, we just return undef.</source>
          <target state="translated">Если ни один из этих языковых тегов не ведет к загружаемым классам, мы затем пробуем классы, производные от YourProjClass-&amp;gt; fallback_languages ​​(), а затем, если из этого ничего не выходит, мы используем классы, названные YourProjClass-&amp;gt; fallback_language_classes (). Затем в (что, вероятно, маловероятно) случае неудачи мы просто возвращаем undef.</target>
        </trans-unit>
        <trans-unit id="92205bb5b979576b7a4566bdd880e8993ef8accb" translate="yes" xml:space="preserve">
          <source>If not 0, then it will be a count of the number of items returned by the subroutine. These items will be stored on the Perl stack. The section</source>
          <target state="translated">Если не 0,то это будет подсчет количества элементов,возвращенных подпрограммой.Эти пункты будут сохранены в стеке Perl.Раздел</target>
        </trans-unit>
        <trans-unit id="59c73f98889212850b2a78b85e24e752ffbdf926" translate="yes" xml:space="preserve">
          <source>If not 0, then it will be a count of the number of items returned by the subroutine. These items will be stored on the Perl stack. The section &lt;a href=&quot;#Returning-a-List-of-Values&quot;&gt;&quot;Returning a List of Values&quot;&lt;/a&gt; gives an example of using the G_ARRAY flag and the mechanics of accessing the returned items from the Perl stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15089e00b79e7ab36a4d99102807c33fe5f2fa61" translate="yes" xml:space="preserve">
          <source>If not already thread-shared, the other complex data types will be cloned (recursively, if needed, and including any &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt;ings and read-only settings) into thread-shared structures before being placed onto a queue.</source>
          <target state="translated">Если потоки еще не разделены, другие сложные типы данных будут клонированы (рекурсивно, если необходимо, включая любые &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; и настройки только для чтения) в структуры, совместно используемые потоками, перед помещением в очередь.</target>
        </trans-unit>
        <trans-unit id="bd2af9d148c476fa264b6faed90957e58a463b95" translate="yes" xml:space="preserve">
          <source>If not already thread-shared, the other complex data types will be cloned (recursively, if needed, and including any &lt;code&gt;bless&lt;/code&gt;ings and read-only settings) into thread-shared structures before being placed onto a queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68037dc7029dc4e3c365e1435ac66af09bfe7401" translate="yes" xml:space="preserve">
          <source>If not defined, the socket option will not be changed, and default value set by the operating system will apply. For repeatable behaviour across platforms it is recommended this value always be defined for listening-mode sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6242ea32a785a3ff0172e42255ea915052f271" translate="yes" xml:space="preserve">
          <source>If not explicitly stated, the thread's context is implied from the context of the &lt;code&gt;-&amp;gt;create()&lt;/code&gt; call:</source>
          <target state="translated">Если не указано явно, контекст потока подразумевается из контекста вызова &lt;code&gt;-&amp;gt;create()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="546f552a865a929b4eb67739806b6d1165a21c9a" translate="yes" xml:space="preserve">
          <source>If not present or if it returns false, then the stream is left with the UTF-8 flag clear. The</source>
          <target state="translated">Если его нет или если он возвращает false,то поток оставляется с флагом UTF-8.</target>
        </trans-unit>
        <trans-unit id="2aa39c0e8f5ce84edfe0042135e7b88219cc53b5" translate="yes" xml:space="preserve">
          <source>If not specified, this parameter defaults to the OS code of the Operating System this module was built on. The value 3 is used as a catch-all for all Unix variants and unknown Operating Systems.</source>
          <target state="translated">Если параметр не указан,то по умолчанию он соответствует коду операционной системы,на которой построен данный модуль.Значение 3 используется как catch-all для всех Unix-вариантов и неизвестных операционных систем.</target>
        </trans-unit>
        <trans-unit id="5be9107047108eada41300dc934c5b436deb60f0" translate="yes" xml:space="preserve">
          <source>If not successful &lt;code&gt;$status&lt;/code&gt; will hold the</source>
          <target state="translated">В случае неудачи &lt;code&gt;$status&lt;/code&gt; будет удерживать</target>
        </trans-unit>
        <trans-unit id="aff9c9f30e8137171bc8ec7e751402e0d4e840fb" translate="yes" xml:space="preserve">
          <source>If not successful, &lt;code&gt;$i&lt;/code&gt; will be</source>
          <target state="translated">Если не удастся, &lt;code&gt;$i&lt;/code&gt; будет</target>
        </trans-unit>
        <trans-unit id="b50aafa5c3c8fb148f77f7f985f1a7044430dc1d" translate="yes" xml:space="preserve">
          <source>If not successful, the returned compression object, &lt;code&gt;$z&lt;/code&gt; , will be</source>
          <target state="translated">В случае неудачи возвращаемый объект сжатия &lt;code&gt;$z&lt;/code&gt; будет</target>
        </trans-unit>
        <trans-unit id="12b14a0f96d5dc839995d0658014681616dce040" translate="yes" xml:space="preserve">
          <source>If not successful, the returned compression object, &lt;code&gt;$z&lt;/code&gt;, will be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8abade20743149de14f55b6a98559ef8ef9d29a" translate="yes" xml:space="preserve">
          <source>If not successful, the returned deflation object, &lt;code&gt;$d&lt;/code&gt; , will be</source>
          <target state="translated">В случае неудачи возвращаемый объект дефляции &lt;code&gt;$d&lt;/code&gt; будет</target>
        </trans-unit>
        <trans-unit id="a55077829587b52f718a05dd4622ff7cb59c31d0" translate="yes" xml:space="preserve">
          <source>If not successful, the returned deflation object, &lt;code&gt;$d&lt;/code&gt;, will be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98576d6e30e44a960914f7dcf4587ee17092e2df" translate="yes" xml:space="preserve">
          <source>If not successful, the returned deflation stream (&lt;code&gt;$d&lt;/code&gt; ) will be</source>
          <target state="translated">В случае неудачи возвращаемый поток дефляции ( &lt;code&gt;$d&lt;/code&gt; ) будет</target>
        </trans-unit>
        <trans-unit id="31b0629650565b4db9feee16aed7f875e955eba9" translate="yes" xml:space="preserve">
          <source>If not successful, the returned deflation stream (&lt;code&gt;$d&lt;/code&gt;) will be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7bd4ba1b78daba8a26ec4a9a7d4b9cf1b5da29e" translate="yes" xml:space="preserve">
          <source>If not successful, the returned uncompression object, &lt;code&gt;$z&lt;/code&gt; , will be</source>
          <target state="translated">В случае неудачи возвращенный объект распаковки &lt;code&gt;$z&lt;/code&gt; будет</target>
        </trans-unit>
        <trans-unit id="ff81451b912d52c5c65d903982a9c2e6578403e7" translate="yes" xml:space="preserve">
          <source>If not successful, the returned uncompression object, &lt;code&gt;$z&lt;/code&gt;, will be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c88e7dc3b6ede485e4fd5bdcc2d18ce257150ea" translate="yes" xml:space="preserve">
          <source>If not under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , the source is treated as ASCII + 128 extra controls, and identifiers should match</source>
          <target state="translated">Если не &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , источник обрабатывается как дополнительные элементы управления ASCII + 128, и идентификаторы должны соответствовать</target>
        </trans-unit>
        <trans-unit id="6275358c6fb498ac9c62eac9a2037ee571ebd990" translate="yes" xml:space="preserve">
          <source>If not under &lt;code&gt;use utf8&lt;/code&gt;, the source is treated as ASCII + 128 extra generic characters, and identifiers should match</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf92a54eaec2aef254d98d2b3572cf157430f6f" translate="yes" xml:space="preserve">
          <source>If not, you can use a Fisher-Yates shuffle.</source>
          <target state="translated">Если нет,можешь использовать тасовку &quot;Фишер-Йейтс&quot;.</target>
        </trans-unit>
        <trans-unit id="63aa47bb8d880da4c29744c1e2b5b0be9d2d8c10" translate="yes" xml:space="preserve">
          <source>If not, you may need to dig in the indices to find it in the directory of the current maintainer.</source>
          <target state="translated">Если нет,возможно,вам понадобится покопаться в индексах,чтобы найти его в каталоге текущего мейнтейнера.</target>
        </trans-unit>
        <trans-unit id="86c0e89f96b9aaaff68e6f577691cea5717917d9" translate="yes" xml:space="preserve">
          <source>If ob is true and the SV is blessed, the description is the class name, otherwise it is the type of the SV, &quot;SCALAR&quot;, &quot;ARRAY&quot; etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bf684ef82a39d22f842daf13f965778d5ecf34" translate="yes" xml:space="preserve">
          <source>If ob is true and the SV is blessed, the string is the class name, otherwise it is the type of the SV, &quot;SCALAR&quot;, &quot;ARRAY&quot; etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3dd66c8bbe90e184bf0c3b78ff920f066856ccf" translate="yes" xml:space="preserve">
          <source>If omitted, PATTERN defaults to a single space, &lt;code&gt;&quot; &quot;&lt;/code&gt; , triggering the previously described</source>
          <target state="translated">Если он опущен, ШАБЛОН по умолчанию использует один пробел &lt;code&gt;&quot; &quot;&lt;/code&gt; , вызывая ранее описанный</target>
        </trans-unit>
        <trans-unit id="48ccc574ab641252333c06cf11483c32d32127b7" translate="yes" xml:space="preserve">
          <source>If omitted, PATTERN defaults to a single space, &lt;code&gt;&quot; &quot;&lt;/code&gt;, triggering the previously described</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db6f61ce06c88ac7402efe003ec5c4f69fd8d53" translate="yes" xml:space="preserve">
          <source>If omitted, the maximum is the 4th.</source>
          <target state="translated">Если пропустить,максимум-4-е.</target>
        </trans-unit>
        <trans-unit id="8cf02da092076b8bc64e89cb4d51247518c5d4fc" translate="yes" xml:space="preserve">
          <source>If one attempts to print this value, then the overloaded operator &lt;code&gt;&quot;&quot;&lt;/code&gt; will be called, which will call &lt;code&gt;nomethod&lt;/code&gt; operator. The result of this operator will be stringified again, but this result is again of type &lt;code&gt;symbolic&lt;/code&gt; , which will lead to an infinite loop.</source>
          <target state="translated">Если &lt;code&gt;nomethod&lt;/code&gt; распечатать это значение, будет вызван перегруженный оператор &lt;code&gt;&quot;&quot;&lt;/code&gt; , который вызовет оператор nomethod . Результат этого оператора снова будет преобразован в строку, но этот результат снова будет &lt;code&gt;symbolic&lt;/code&gt; типа , что приведет к бесконечному циклу.</target>
        </trans-unit>
        <trans-unit id="d9a4c46026548a387f73d613ce2e2d57e8735167" translate="yes" xml:space="preserve">
          <source>If one attempts to print this value, then the overloaded operator &lt;code&gt;&quot;&quot;&lt;/code&gt; will be called, which will call &lt;code&gt;nomethod&lt;/code&gt; operator. The result of this operator will be stringified again, but this result is again of type &lt;code&gt;symbolic&lt;/code&gt;, which will lead to an infinite loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1adcb84ff8cdfac7bb94b3520eb9afd47061bae" translate="yes" xml:space="preserve">
          <source>If one can be sure that a particular program is a Perl script expecting filenames in @ARGV, the clever programmer can write something like this:</source>
          <target state="translated">Если можно быть уверенным,что конкретная программа-это Perl скрипт,ожидающий имен файлов в @ARGV,то умный программист может написать что-то подобное:</target>
        </trans-unit>
        <trans-unit id="b9a4785b4cb95e8fee7a09364380427defe0f204" translate="yes" xml:space="preserve">
          <source>If one is compiling Perl with the &lt;code&gt;-DPERL_GLOBAL_STRUCT&lt;/code&gt; the &lt;code&gt;dVAR&lt;/code&gt; definition is needed if the Perl global variables (see</source>
          <target state="translated">Если один компилирует Perl с &lt;code&gt;-DPERL_GLOBAL_STRUCT&lt;/code&gt; &lt;code&gt;dVAR&lt;/code&gt; определение требуется , если глобальные переменные Perl (см</target>
        </trans-unit>
        <trans-unit id="e3e822ed5577ab52cc19452e08717fd8eeaeaafa" translate="yes" xml:space="preserve">
          <source>If one of the input arguments to the C function is the length of a string argument &lt;code&gt;NAME&lt;/code&gt; , one can substitute the name of the length-argument by &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; in the XSUB declaration. This argument must be omitted when the generated Perl function is called. E.g.,</source>
          <target state="translated">Если одним из входных аргументов функции C является длина строкового аргумента &lt;code&gt;NAME&lt;/code&gt; , можно заменить имя аргумента &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; на длину (NAME) в объявлении XSUB. Этот аргумент необходимо опустить при вызове сгенерированной функции Perl. Например,</target>
        </trans-unit>
        <trans-unit id="9ecfea0dc1bd53f365a6275977cf6664ba11e8c2" translate="yes" xml:space="preserve">
          <source>If one of the input arguments to the C function is the length of a string argument &lt;code&gt;NAME&lt;/code&gt;, one can substitute the name of the length-argument by &lt;code&gt;length(NAME)&lt;/code&gt; in the XSUB declaration. This argument must be omitted when the generated Perl function is called. E.g.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80356b3107601264757c736090081f30d00dbd0c" translate="yes" xml:space="preserve">
          <source>If one of the values is the string &quot;FATAL&quot;, then all the warnings in that list will be considered fatal, just as with the &lt;b&gt;warnings&lt;/b&gt; pragma itself. Should you need to specify that some warnings are fatal, and others are merely enabled, you can pass the &lt;b&gt;warnings&lt;/b&gt; parameter twice:</source>
          <target state="translated">Если одно из значений являются строка &amp;laquo;FATAL&amp;raquo;, то все предупреждения в этом списке будут считаться фатальными, так же , как и на &lt;b&gt;предупреждении&lt;/b&gt; Pragma себя. Если вам нужно указать, что некоторые предупреждения являются фатальными, а другие просто включены, вы можете передать параметр &lt;b&gt;warnings&lt;/b&gt; дважды:</target>
        </trans-unit>
        <trans-unit id="58b3d6b8eb5c53fb4bf738ec026bd17996fb8d7b" translate="yes" xml:space="preserve">
          <source>If one wants to use pure Perl and to be compatible with Perl versions prior to 5.10, the general answer is to use &lt;code&gt;if-elsif-else&lt;/code&gt;:</source>
          <target state="translated">Если кто-то хочет использовать чистый Perl и быть совместимым с версиями Perl до 5.10, общий ответ - использовать &lt;code&gt;if-elsif-else&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4cca592d5a52d0591c75e10935311d781bcd5906" translate="yes" xml:space="preserve">
          <source>If only PATTERN is given, EXPR defaults to &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b8235b34f1e041150a031d0b9fbd780bdea304" translate="yes" xml:space="preserve">
          <source>If only PATTERN is given, EXPR defaults to &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">Если указан только ШАБЛОН, по умолчанию EXPR равен &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b59bbcd014d4d50d7bf3779e9aa4f7e93178c1ba" translate="yes" xml:space="preserve">
          <source>If only a filename is available, the following approach may be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b33dab707b9e6e2b41538d9f24bfd52b59d430" translate="yes" xml:space="preserve">
          <source>If opening the client side of a named pipe, then you can also set &lt;code&gt;$uFlags&lt;/code&gt; to include &lt;code&gt;SECURITY_SQOS_PRESENT&lt;/code&gt; along with one of the other &lt;code&gt;SECURITY_*&lt;/code&gt; constants to specify the security quality of service to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f62f719bae656eebb99613fc3c3f5af6bf3f5f" translate="yes" xml:space="preserve">
          <source>If opening the client side of a named pipe, then you can also specify &lt;code&gt;SECURITY_SQOS_PRESENT&lt;/code&gt; along with one of the other &lt;code&gt;SECURITY_*&lt;/code&gt; constants to specify the security quality of service to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16392afc89510c0fc9dd7ff46ccb0d1b3e97fcef" translate="yes" xml:space="preserve">
          <source>If other charset support is needed, please file a bug report against CPAN.pm at rt.cpan.org and describe your needs. Maybe we can extend the support or maybe UTF-8 terminals become widely available.</source>
          <target state="translated">Если необходима поддержка других кодировок,пожалуйста,отправьте сообщение об ошибке на CPAN.pm на rt.cpan.org и опишите ваши потребности.Может быть,мы сможем расширить поддержку или,возможно,UTF-8 терминалы станут широко доступны.</target>
        </trans-unit>
        <trans-unit id="a07176206cda4e320bb3d161ccf541de7489aeb9" translate="yes" xml:space="preserve">
          <source>If our include file had contained #include directives, these would not have been processed by h2xs. There is no good solution to this right now.</source>
          <target state="translated">Если бы наш включаемый файл содержал директивы #include,они не были бы обработаны h2xs.Сейчас нет хорошего решения.</target>
        </trans-unit>
        <trans-unit id="1342cd54e96ee75c7832a17e50d7545968334b8a" translate="yes" xml:space="preserve">
          <source>If parse errors are found in the TAP output, a note of this will be made in the summary report. To see all of the parse errors, set this argument to true:</source>
          <target state="translated">Если в выводе TAP будут найдены ошибки при разборе,то об этом будет сделано замечание в сводном отчете.Чтобы увидеть все ошибки при разборе,установите этот аргумент в true:</target>
        </trans-unit>
        <trans-unit id="390961095f8040e196a232b583180a54cb19ea61" translate="yes" xml:space="preserve">
          <source>If passed a filehandle will write a copy of all parsed TAP to that handle.</source>
          <target state="translated">В случае передачи файлового дескриптора в этот дескриптор будет записана копия всех разобранных TAP.</target>
        </trans-unit>
        <trans-unit id="5a4f883097b033ba66596455cc092c01c5e9be39" translate="yes" xml:space="preserve">
          <source>If performance is an issue, and you don't care if the output is in the same case as the input, Use &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; to transform to the case most employed within the data. If the data are primarily UPPERCASE non-Latin1, then apply &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[a-z]/[A-Z]/&lt;/a&gt;&lt;/code&gt;, and then &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;. If the data are primarily lowercase non Latin1 then apply &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[A-Z]/[a-z]/&lt;/a&gt;&lt;/code&gt; before sorting. If the data are primarily UPPERCASE and include Latin-1 characters then apply:</source>
          <target state="translated">Если производительность является проблемой, и вас не волнует, находится ли вывод в том же регистре, что и ввод, используйте &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; для преобразования в регистр, наиболее часто используемый в данных. Если данные в основном прописные, а не Latin1, то примените &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[a-z]/[A-Z]/&lt;/a&gt;&lt;/code&gt; , а затем &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; . Если данные в основном в нижнем регистре, а не в Latin1, тогда перед сортировкой примените &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[A-Z]/[a-z]/&lt;/a&gt;&lt;/code&gt; . Если данные в основном прописные и содержат символы Latin-1, примените:</target>
        </trans-unit>
        <trans-unit id="9462aa1810ea1a2dacbf899e5d319c5498156bac" translate="yes" xml:space="preserve">
          <source>If performance is an issue, and you don't care if the output is in the same case as the input, Use &lt;code&gt;tr///&lt;/code&gt; to transform to the case most employed within the data. If the data are primarily UPPERCASE non-Latin1, then apply &lt;code&gt;tr/[a-z]/[A-Z]/&lt;/code&gt;, and then &lt;code&gt;sort()&lt;/code&gt;. If the data are primarily lowercase non Latin1 then apply &lt;code&gt;tr/[A-Z]/[a-z]/&lt;/code&gt; before sorting. If the data are primarily UPPERCASE and include Latin-1 characters then apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751a8c8edea51ef360f8293f82ac9e36b697517a" translate="yes" xml:space="preserve">
          <source>If perl has been configured to not have the current directory in &lt;a href=&quot;perlvar#%40INC&quot;&gt;&lt;code&gt;@INC&lt;/code&gt;&lt;/a&gt; by default, this variable can be set to &lt;code&gt;&quot;1&quot;&lt;/code&gt; to reinstate it. It's primarily intended for use while building and testing modules that have not been updated to deal with &quot;.&quot; not being in &lt;code&gt;@INC&lt;/code&gt; and should not be set in the environment for day-to-day use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab79de5389c6af407dc202c7877566f66fb7264b" translate="yes" xml:space="preserve">
          <source>If perl has not yet been installed then PERL_SRC can be defined on the command line as shown in the previous section.</source>
          <target state="translated">Если perl еще не установлен,то PERL_SRC может быть определен в командной строке,как показано в предыдущем разделе.</target>
        </trans-unit>
        <trans-unit id="527ed5a2bdcdb5849d3d992698d64bca35b1da28" translate="yes" xml:space="preserve">
          <source>If perl is invoked using the &lt;b&gt;-e&lt;/b&gt; option or the perl script is read from &lt;code&gt;STDIN&lt;/code&gt; then FindBin sets both &lt;code&gt;$Bin&lt;/code&gt; and &lt;code&gt;$RealBin&lt;/code&gt; to the current directory.</source>
          <target state="translated">Если perl вызывается с использованием параметра &lt;b&gt;-e&lt;/b&gt; или сценарий perl читается из &lt;code&gt;STDIN&lt;/code&gt; , тогда FindBin устанавливает и &lt;code&gt;$Bin&lt;/code&gt; и &lt;code&gt;$RealBin&lt;/code&gt; в текущий каталог.</target>
        </trans-unit>
        <trans-unit id="c28bb9f5b57ae9540614c1c058beb6e3302cae11" translate="yes" xml:space="preserve">
          <source>If perl was installed correctly and your shadow library was written properly, the &lt;code&gt;getpw*()&lt;/code&gt; functions described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; should in theory provide (read-only) access to entries in the shadow password file. To change the file, make a new shadow password file (the format varies from system to system--see</source>
          <target state="translated">Если perl был установлен правильно и ваша теневая библиотека была написана правильно, функции &lt;code&gt;getpw*()&lt;/code&gt; , описанные в &lt;a href=&quot;perlfunc&quot;&gt;perlfunc, теоретически&lt;/a&gt; должны предоставлять (только для чтения) доступ к записям в файле теневых паролей. Чтобы изменить файл, создайте новый файл теневого пароля (формат различается от системы к системе - см.</target>
        </trans-unit>
        <trans-unit id="eba76bf8bea1221ff81d36866fefb38b38f1c83e" translate="yes" xml:space="preserve">
          <source>If perl was installed correctly and your shadow library was written properly, the &lt;code&gt;getpw*()&lt;/code&gt; functions described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; should in theory provide (read-only) access to entries in the shadow password file. To change the file, make a new shadow password file (the format varies from system to system--see &lt;a href=&quot;http://man.he.net/man1/passwd&quot;&gt;passwd(1)&lt;/a&gt; for specifics) and use &lt;code&gt;pwd_mkdb(8)&lt;/code&gt; to install it (see &lt;a href=&quot;http://man.he.net/man8/pwd_mkdb&quot;&gt;pwd_mkdb(8)&lt;/a&gt; for more details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa77499616bd2f38224ed594fc316a580948f20" translate="yes" xml:space="preserve">
          <source>If possible, move() will simply rename the file. Otherwise, it copies the file to the new location and deletes the original. If an error occurs during this copy-and-delete process, you may be left with a (possibly partial) copy of the file under the destination name.</source>
          <target state="translated">Если возможно,функция move()просто переименует файл.В противном случае она копирует файл в новое место и удаляет оригинал.Если во время этого процесса копирования и удаления произойдет ошибка,вы можете остаться с (возможно,частичной)копией файла под именем получателя.</target>
        </trans-unit>
        <trans-unit id="2306ef44bf2f2a60c7ac6a896505074bcea6c96c" translate="yes" xml:space="preserve">
          <source>If possible, register the module with CPAN. Follow the instructions and links on:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821e3f8f257e241afb18f9d12ceda656792b21cb" translate="yes" xml:space="preserve">
          <source>If possible, register the module with CPAN. You should include details of its location in your announcement.</source>
          <target state="translated">По возможности зарегистрируйте модуль в CPAN.Вы должны указать его местоположение в своем объявлении.</target>
        </trans-unit>
        <trans-unit id="00df1bad6fa3810b7a0fb796a7103c7f28a05f8c" translate="yes" xml:space="preserve">
          <source>If possible, this form should be used to prevent possible race conditions.</source>
          <target state="translated">По возможности,эту форму следует использовать для предотвращения возможных гоночных условий.</target>
        </trans-unit>
        <trans-unit id="34d4da8aa87987ec9ceda1c43801e78b64cdc28a" translate="yes" xml:space="preserve">
          <source>If present on a regex, &lt;code&gt;&quot;#&quot;&lt;/code&gt; comments will be handled differently by the tokenizer in some cases.</source>
          <target state="translated">Комментарии &lt;code&gt;&quot;#&quot;&lt;/code&gt; если они присутствуют в регулярном выражении, в некоторых случаях обрабатываются токенизатором по-разному.</target>
        </trans-unit>
        <trans-unit id="fcb106d01e2834098b09ad25220c5df2510aa768" translate="yes" xml:space="preserve">
          <source>If present, $hints should be a reference to a hash, where the following keys are recognised:</source>
          <target state="translated">Если они присутствуют,то $hints должны быть ссылкой на хэш,где распознаются следующие клавиши:</target>
        </trans-unit>
        <trans-unit id="768b78e920d55b41dde42ac4d330e515e86f1cd7" translate="yes" xml:space="preserve">
          <source>If present, each callback corresponding to a given result type will be called with the result as the argument if the &lt;code&gt;run&lt;/code&gt; method is used:</source>
          <target state="translated">Если присутствует, каждый обратный вызов, соответствующий данному типу результата, будет вызываться с результатом в качестве аргумента, если &lt;code&gt;run&lt;/code&gt; метод run :</target>
        </trans-unit>
        <trans-unit id="80e76146570d6b35c93035dd97f6090cb9b7cbba" translate="yes" xml:space="preserve">
          <source>If present, it should be a reference to a scalar. This scalar will be made to reference an array, which will be used to store all files and directories unlinked during the call. If nothing is unlinked, the array will be empty.</source>
          <target state="translated">Если присутствует,то это должна быть ссылка на скаляр.Этот скаляр будет ссылаться на массив,который будет использоваться для хранения всех файлов и каталогов,несвязанных во время вызова.Если ничего не будет снято,то массив будет пустым.</target>
        </trans-unit>
        <trans-unit id="865f6f3c95c9ee0c681ecdf2cdcadf01272955ae" translate="yes" xml:space="preserve">
          <source>If present, it should be a reference to a scalar. This scalar will be made to reference an array, which will be used to store any errors that are encountered. See the &lt;a href=&quot;#ERROR-HANDLING&quot;&gt;&quot;ERROR HANDLING&quot;&lt;/a&gt; section for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf6326ff6faceb306eebc039298d3cef21ae0f2" translate="yes" xml:space="preserve">
          <source>If present, it should be a reference to a scalar. This scalar will be made to reference an array, which will be used to store any errors that are encountered. See the &lt;a href=&quot;#ERROR-HANDLING&quot;&gt;ERROR HANDLING&lt;/a&gt; section for more information.</source>
          <target state="translated">Если присутствует, это должна быть ссылка на скаляр. Этот скаляр будет использоваться для ссылки на массив, который будет использоваться для хранения любых обнаруженных ошибок. См. Раздел &lt;a href=&quot;#ERROR-HANDLING&quot;&gt;ОБРАБОТКА ОШИБОК&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="28236ec2fcbd77071db6f4df51ebe2ad1353410f" translate="yes" xml:space="preserve">
          <source>If present, will cause &lt;code&gt;make_path&lt;/code&gt; to print the name of each directory as it is created. By default nothing is printed.</source>
          <target state="translated">Если присутствует, &lt;code&gt;make_path&lt;/code&gt; будет печатать имя каждого каталога по мере его создания. По умолчанию ничего не печатается.</target>
        </trans-unit>
        <trans-unit id="ba616b58ac8bd248e0e92e90224a9f0e82a7126d" translate="yes" xml:space="preserve">
          <source>If present, will cause &lt;code&gt;remove_tree&lt;/code&gt; to print the name of each file as it is unlinked. By default nothing is printed.</source>
          <target state="translated">Если присутствует, то &lt;code&gt;remove_tree&lt;/code&gt; будет печатать имя каждого файла, поскольку он не связан. По умолчанию ничего не печатается.</target>
        </trans-unit>
        <trans-unit id="da38e80a5de666bdd4124bbd72eac17c8b7acaf5" translate="yes" xml:space="preserve">
          <source>If present, will cause any created directory to be owned by &lt;code&gt;$owner&lt;/code&gt; . If the value is numeric, it will be interpreted as a uid, otherwise as username is assumed. An error will be issued if the username cannot be mapped to a uid, or the uid does not exist, or the process lacks the privileges to change ownership.</source>
          <target state="translated">Если присутствует, то любой созданный каталог будет принадлежать &lt;code&gt;$owner&lt;/code&gt; . Если значение числовое, оно будет интерпретировано как uid, иначе предполагается имя пользователя. Ошибка будет выдана, если имя пользователя не может быть сопоставлено с uid, или uid не существует, или процессу не хватает привилегий для смены владельца.</target>
        </trans-unit>
        <trans-unit id="0ff53c547d7a4dd3bf846157fd728900f2d937f3" translate="yes" xml:space="preserve">
          <source>If present, will cause any created directory to be owned by &lt;code&gt;$owner&lt;/code&gt;. If the value is numeric, it will be interpreted as a uid; otherwise a username is assumed. An error will be issued if the username cannot be mapped to a uid, the uid does not exist or the process lacks the privileges to change ownership.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6bc6a6c714ec1098b00e8f4665bf29765d41191" translate="yes" xml:space="preserve">
          <source>If present, will cause any created directory to be owned by the group &lt;code&gt;$group&lt;/code&gt; . If the value is numeric, it will be interpreted as a gid, otherwise as group name is assumed. An error will be issued if the group name cannot be mapped to a gid, or the gid does not exist, or the process lacks the privileges to change group ownership.</source>
          <target state="translated">Если присутствует, то любой созданный каталог будет принадлежать группе &lt;code&gt;$group&lt;/code&gt; . Если значение числовое, оно будет интерпретировано как gid, в противном случае предполагается имя группы. Будет выдана ошибка, если имя группы не может быть сопоставлено с gid, или gid не существует, или процессу не хватает привилегий для изменения владельца группы.</target>
        </trans-unit>
        <trans-unit id="5ebd22cc8259df10471aba5e6db2f4331d3b55f7" translate="yes" xml:space="preserve">
          <source>If present, will cause any created directory to be owned by the group &lt;code&gt;$group&lt;/code&gt;. If the value is numeric, it will be interpreted as a gid; otherwise a group name is assumed. An error will be issued if the group name cannot be mapped to a gid, the gid does not exist or the process lacks the privileges to change group ownership.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a365bb62991d043cada86ad3beb15687e9b5977b" translate="yes" xml:space="preserve">
          <source>If program usage has been explicitly requested by the user, it is often desirable to exit with a status of 1 (as opposed to 0) after issuing the user-requested usage message. It is also desirable to give a more verbose description of program usage in this case.</source>
          <target state="translated">Если использование программы было явно запрошено пользователем,то после выдачи сообщения об использовании,запрошенного пользователем,часто желательно выйти со статусом 1 (в отличие от 0).В этом случае желательно также дать более подробное описание использования программы.</target>
        </trans-unit>
        <trans-unit id="8bf641be539c33c01972d9eed772b4572f957d25" translate="yes" xml:space="preserve">
          <source>If provided, this argument will place the socket into listening mode. New connections can then be accepted using the &lt;a href=&quot;IO::Socket#accept&quot;&gt;&quot;accept&quot; in IO::Socket&lt;/a&gt; method. The value given is used as the &lt;code&gt;listen(2)&lt;/code&gt; queue size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3608d191706961b1f05c1c4d43ca10631cdf8b" translate="yes" xml:space="preserve">
          <source>If run on any operating system other than Windows, this will import the functions &lt;code&gt;setlocale&lt;/code&gt; and &lt;code&gt;LC_ALL&lt;/code&gt; from &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;. On Windows it does nothing.</source>
          <target state="translated">При запуске в любой операционной системе, кроме Windows, будут импортированы функции &lt;code&gt;setlocale&lt;/code&gt; и &lt;code&gt;LC_ALL&lt;/code&gt; из &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; . В Windows ничего не делает.</target>
        </trans-unit>
        <trans-unit id="9d9d2ff0e902fe5020fe3d38bdc23ea71c9ea208" translate="yes" xml:space="preserve">
          <source>If run with no arguments, filters standard input to standard output.</source>
          <target state="translated">При отсутствии аргументов,фильтрует стандартный вход на стандартный выход.</target>
        </trans-unit>
        <trans-unit id="53f4c878607755d2bdfa2564e4393c026538b21e" translate="yes" xml:space="preserve">
          <source>If running under taint mode, and if $ENV{TMPDIR} is tainted, it is not used.</source>
          <target state="translated">Если запущен в режиме taint,и если $ENV{TMPDIR}запятнан,то он не используется.</target>
        </trans-unit>
        <trans-unit id="c028c3067c9e1833a7b2f721beaf502c1d3b87c3" translate="yes" xml:space="preserve">
          <source>If running under taint mode, and if the environment variables are tainted, they are not used.</source>
          <target state="translated">При работе в режиме taint,и если переменные окружения запятнаны,они не используются.</target>
        </trans-unit>
        <trans-unit id="bc42709752d603d6e86a31cea878bd9ef78c5a40" translate="yes" xml:space="preserve">
          <source>If safety matters to you (and why else would you be using the Opcode module?) then you should not rely on the definition of this, or indeed any other, optag!</source>
          <target state="translated">Если для вас важна безопасность (и зачем еще использовать модуль Opcode?),то вы не должны полагаться на определение этого или любого другого оптага!</target>
        </trans-unit>
        <trans-unit id="84fe2228be06f7c485981c30717e0cd96c85c324" translate="yes" xml:space="preserve">
          <source>If set &lt;code&gt;formatter&lt;/code&gt; must be an object that is capable of formatting the TAP output. See &lt;a href=&quot;TAP::Formatter::Console&quot;&gt;TAP::Formatter::Console&lt;/a&gt; for an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c49a3b26a25358ee584c0e87edb350360c053486" translate="yes" xml:space="preserve">
          <source>If set &lt;code&gt;formatter&lt;/code&gt; must be an object that is capable of formatting the TAP output. See &lt;a href=&quot;formatter/console&quot;&gt;TAP::Formatter::Console&lt;/a&gt; for an example.</source>
          <target state="translated">Если установлено , средство &lt;code&gt;formatter&lt;/code&gt; должно быть объектом, способным форматировать вывод TAP. См. Пример &lt;a href=&quot;formatter/console&quot;&gt;TAP :: Formatter :: Console&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d7e12ada666ebe5ce88788573ab7d416ccee0e3" translate="yes" xml:space="preserve">
          <source>If set and Encode is not available, silently fall back to non-UTF-8 mode without complaining to standard error. This environment variable is set during Perl core builds, which build Encode after podlators. Encode is expected to not (yet) be available in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6406e3d3c8ec686d43e0bd0630b45054571335" translate="yes" xml:space="preserve">
          <source>If set forward, the details of the missing tests are filled in as 'unknown'. if set backward, the details of the intervening tests are deleted. You can erase history if you really want to.</source>
          <target state="translated">Если установить перемотку вперед,то детали пропущенных тестов будут заполнены как &quot;неизвестные&quot;.если установить назад,то детали промежуточных тестов будут удалены.Вы можете стереть историю,если действительно хотите.</target>
        </trans-unit>
        <trans-unit id="94a6b6735d1cf67d97faf5afa93385c976f8d9ca" translate="yes" xml:space="preserve">
          <source>If set to 'none', no man pages will be installed.</source>
          <target state="translated">Если установлено значение &quot;нет&quot;,никаких man-страниц не будет установлено.</target>
        </trans-unit>
        <trans-unit id="35193d3a52f1a67d3457cb0804a53caff3b762a2" translate="yes" xml:space="preserve">
          <source>If set to 0, the contents of the output parameter of the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method will be overwritten by the uncompressed data.</source>
          <target state="translated">Если установлено значение 0, содержимое выходного параметра метода &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; будет перезаписано несжатыми данными.</target>
        </trans-unit>
        <trans-unit id="0eba3cfab3094093ee2a0a7a3f1a02110ff8208f" translate="yes" xml:space="preserve">
          <source>If set to 0, the contents of the output parameter of the &lt;code&gt;read&lt;/code&gt; method will be overwritten by the uncompressed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63134c061d53f609b58fe4db77f806b2b217214c" translate="yes" xml:space="preserve">
          <source>If set to 1, all uncompressed data will be appended to the output parameter of the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">Если установлено значение 1, все несжатые данные будут добавлены к выходному параметру метода &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9f5b0a88e94e90aa98c8ce846cf8f2a8299b4e1" translate="yes" xml:space="preserve">
          <source>If set to 1, all uncompressed data will be appended to the output parameter of the &lt;code&gt;read&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99badbf73893e25506e2b45aeb306043f0421e4" translate="yes" xml:space="preserve">
          <source>If set to a true value instruct &lt;code&gt;TAP::Parser&lt;/code&gt; to ignore exit and wait status from test scripts.</source>
          <target state="translated">Если установлено истинное значение, &lt;code&gt;TAP::Parser&lt;/code&gt; игнорирует статус выхода и ожидания из тестовых сценариев.</target>
        </trans-unit>
        <trans-unit id="7addd0cdb6e060b7f425d641cdc5802f63dc6646" translate="yes" xml:space="preserve">
          <source>If set to a true value then MakeMaker's prompt function will always return the default without waiting for user input.</source>
          <target state="translated">Если установлено значение true,то функция запросов MakeMaker всегда вернет значение по умолчанию,не дожидаясь ввода данных пользователем.</target>
        </trans-unit>
        <trans-unit id="37acce4270c3ae4d059b2f5d5497684bcefbd070" translate="yes" xml:space="preserve">
          <source>If set to a true value, Pod::PlainText will assume that each sentence ends in two spaces, and will try to preserve that spacing. If set to false, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space. Defaults to true.</source>
          <target state="translated">Если установить значение true,Pod::PlainText будет считать,что каждое предложение заканчивается на два пробела,и попытается сохранить это расстояние.Если установлено значение false,все последовательные пробельные символы в невербатичных параграфах будут сжаты в один пробел.По умолчанию равно true.</target>
        </trans-unit>
        <trans-unit id="9fb9b386eec98159e51954bb5d28974ecee8a0eb" translate="yes" xml:space="preserve">
          <source>If set to a true value, Pod::Text will assume that each sentence ends in two spaces, and will try to preserve that spacing. If set to false, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space. Defaults to false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e0bdf314190ede062d43bfa363f6d6ba57f992" translate="yes" xml:space="preserve">
          <source>If set to a true value, Pod::Text will assume that each sentence ends in two spaces, and will try to preserve that spacing. If set to false, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space. Defaults to true.</source>
          <target state="translated">Если установить значение true,Pod::Text будет считать,что каждое предложение заканчивается на два пробела,и попытается сохранить это расстояние.Если установлено значение false,все последовательные пробельные символы в невербатичных параграфах будут сжаты в один пробел.По умолчанию равно true.</target>
        </trans-unit>
        <trans-unit id="c7ea67874e15073f2f8a8748dd116175b232517b" translate="yes" xml:space="preserve">
          <source>If set to a true value, a blank line is printed after a &lt;code&gt;=head1&lt;/code&gt; heading. If set to false (the default), no blank line is printed after &lt;code&gt;=head1&lt;/code&gt; , although one is still printed after &lt;code&gt;=head2&lt;/code&gt; . This is the default because it's the expected formatting for manual pages; if you're formatting arbitrary text documents, setting this to true may result in more pleasing output.</source>
          <target state="translated">Если установлено истинное значение, после заголовка &lt;code&gt;=head1&lt;/code&gt; печатается пустая строка . Если установлено значение false (по умолчанию), пустая строка не печатается после &lt;code&gt;=head1&lt;/code&gt; , хотя одна все равно печатается после &lt;code&gt;=head2&lt;/code&gt; . Это значение по умолчанию, потому что это ожидаемое форматирование для справочных страниц; если вы форматируете произвольные текстовые документы, установка этого значения в true может привести к более приятному результату.</target>
        </trans-unit>
        <trans-unit id="12cadcd0631c167f67b19339e2f3ebc608babfe8" translate="yes" xml:space="preserve">
          <source>If set to a true value, a blank line is printed after a &lt;code&gt;=head1&lt;/code&gt; heading. If set to false (the default), no blank line is printed after &lt;code&gt;=head1&lt;/code&gt;, although one is still printed after &lt;code&gt;=head2&lt;/code&gt;. This is the default because it's the expected formatting for manual pages; if you're formatting arbitrary text documents, setting this to true may result in more pleasing output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c7d693600594b39fe949ae434a7a5fc8a792dc" translate="yes" xml:space="preserve">
          <source>If set to a true value, a blank line is printed after a &lt;code&gt;=headN&lt;/code&gt; headings. If set to false (the default), no blank line is printed after &lt;code&gt;=headN&lt;/code&gt; . This is the default because it's the expected formatting for manual pages; if you're formatting arbitrary text documents, setting this to true may result in more pleasing output.</source>
          <target state="translated">Если установлено истинное значение, после заголовков a &lt;code&gt;=headN&lt;/code&gt; печатается пустая строка . Если установлено значение false (по умолчанию), после &lt;code&gt;=headN&lt;/code&gt; не печатается пустая строка . Это значение по умолчанию, потому что это ожидаемое форматирование для справочных страниц; если вы форматируете произвольные текстовые документы, установка этого значения в true может привести к более приятному результату.</target>
        </trans-unit>
        <trans-unit id="3fb0153c7c54ce2bccc40f5b7e2d5aff19532ce7" translate="yes" xml:space="preserve">
          <source>If set to a true value, indicates to the debugger that the code being debugged uses threads.</source>
          <target state="translated">Если установлено значение true,указывает отладчику,что отлаживаемый код использует потоки.</target>
        </trans-unit>
        <trans-unit id="e75bb2ef91a1a8c8b0ee4cbc07e5ef237213911f" translate="yes" xml:space="preserve">
          <source>If set to a true value, only test results with directives will be displayed. This overrides other settings such as &lt;code&gt;verbose&lt;/code&gt; , &lt;code&gt;failures&lt;/code&gt; , or &lt;code&gt;comments&lt;/code&gt; .</source>
          <target state="translated">Если установлено истинное значение, будут отображаться только результаты тестов с директивами. Это отменяет другие настройки, такие как &lt;code&gt;verbose&lt;/code&gt; , &lt;code&gt;failures&lt;/code&gt; или &lt;code&gt;comments&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6403db7bde854649adecbe2fe72bc17d3ded2ac7" translate="yes" xml:space="preserve">
          <source>If set to a true value, only test results with directives will be displayed. This overrides other settings such as &lt;code&gt;verbose&lt;/code&gt; or &lt;code&gt;failures&lt;/code&gt; .</source>
          <target state="translated">Если установлено истинное значение, будут отображаться только результаты тестов с директивами. Это отменяет другие настройки, такие как &lt;code&gt;verbose&lt;/code&gt; или &lt;code&gt;failures&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5dc7bcb42a07b398704f1044000bc451673cf348" translate="yes" xml:space="preserve">
          <source>If set to a true value, only test results with directives will be displayed. This overrides other settings such as &lt;code&gt;verbose&lt;/code&gt; or &lt;code&gt;failures&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56370371763a8fe8f684fb9af4f85fc5b478e2a6" translate="yes" xml:space="preserve">
          <source>If set to a true value, only test results with directives will be displayed. This overrides other settings such as &lt;code&gt;verbose&lt;/code&gt;, &lt;code&gt;failures&lt;/code&gt;, or &lt;code&gt;comments&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace0eebb3ad1da3562cf6ba2f4eb062020ce0829" translate="yes" xml:space="preserve">
          <source>If set to a true value, selects an alternate output format that, among other things, uses a different heading style and marks &lt;code&gt;=item&lt;/code&gt; entries with a colon in the left margin. Defaults to false.</source>
          <target state="translated">Если установлено истинное значение, выбирается альтернативный формат вывода, который, помимо прочего, использует другой стиль заголовка и отмечает &lt;code&gt;=item&lt;/code&gt; записи с двоеточием в левом поле. По умолчанию - false.</target>
        </trans-unit>
        <trans-unit id="341f05ae650241bc98a8aa05ba502f05572aa8ee" translate="yes" xml:space="preserve">
          <source>If set to a true value, source entries will be converted into utf8-strings (available in Perl 5.6.1 or later). This feature needs the &lt;b&gt;Encode&lt;/b&gt; or &lt;b&gt;Encode::compat&lt;/b&gt; module.</source>
          <target state="translated">Если установлено истинное значение, исходные записи будут преобразованы в строки utf8 (доступно в Perl 5.6.1 или новее). Для этой функции требуется модуль &lt;b&gt;Encode&lt;/b&gt; или &lt;b&gt;Encode :: compat&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="e52de704a5928c9a6d768f4b0d7d8f6e786b6b18" translate="yes" xml:space="preserve">
          <source>If set to a true value, the non-POD parts of the input file will be included in the output. Useful for viewing code documented with POD blocks with the POD rendered and the code left intact.</source>
          <target state="translated">Если установлено значение true,части входного файла,не являющиеся POD,будут включены в выходной файл.Полезно для просмотра кода,документированного блоками POD с отрисовкой POD и кодом,оставшимся нетронутым.</target>
        </trans-unit>
        <trans-unit id="77ffaa19bbb496da1b7f2a485ed0c35990cc9fa8" translate="yes" xml:space="preserve">
          <source>If set to nonzero, forces a flush right away and after every write or print on the currently selected output channel. Default is 0 (regardless of whether the channel is really buffered by the system or not; &lt;code&gt;$|&lt;/code&gt; tells you only whether you've asked Perl explicitly to flush after each write). STDOUT will typically be line buffered if output is to the terminal and block buffered otherwise. Setting this variable is useful primarily when you are outputting to a pipe or socket, such as when you are running a Perl program under &lt;b&gt;rsh&lt;/b&gt; and want to see the output as it's happening. This has no effect on input buffering. See &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt; for that. See &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; on how to select the output channel. See also &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">Если установлено значение, отличное от нуля, принудительно выполняет сброс сразу после каждой записи или печати на текущем выбранном канале вывода. По умолчанию - 0 (независимо от того, действительно ли канал буферизирован системой или нет; &lt;code&gt;$|&lt;/code&gt; сообщает вам только, запрашивали ли вы явную очистку Perl после каждой записи). STDOUT обычно буферизуется по строке, если вывод поступает на терминал, и в противном случае буферизуется блоком. Установка этой переменной полезна в первую очередь при выводе в канал или сокет, например, когда вы запускаете программу Perl под &lt;b&gt;rsh&lt;/b&gt; и хотите видеть вывод в том виде, в каком он происходит. Это не влияет на буферизацию ввода. Для этого см. &lt;a href=&quot;functions/getc&quot;&gt;Getc&lt;/a&gt; . См. Раздел &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; о том, как выбрать выходной канал. См. Также &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b32ab50f4a2e4d52971c50b3ce21204c6ea713f8" translate="yes" xml:space="preserve">
          <source>If set to nonzero, forces a flush right away and after every write or print on the currently selected output channel. Default is 0 (regardless of whether the channel is really buffered by the system or not; &lt;code&gt;$|&lt;/code&gt; tells you only whether you've asked Perl explicitly to flush after each write). STDOUT will typically be line buffered if output is to the terminal and block buffered otherwise. Setting this variable is useful primarily when you are outputting to a pipe or socket, such as when you are running a Perl program under &lt;b&gt;rsh&lt;/b&gt; and want to see the output as it's happening. This has no effect on input buffering. See &lt;a href=&quot;perlfunc#getc&quot;&gt;&quot;getc&quot; in perlfunc&lt;/a&gt; for that. See &lt;a href=&quot;perlfunc#select&quot;&gt;&quot;select&quot; in perlfunc&lt;/a&gt; on how to select the output channel. See also &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615ff3b3ad3b33807d03afb15df6a2d1917cfce6" translate="yes" xml:space="preserve">
          <source>If set to the name of a file or device when Perl is run with the &lt;a href=&quot;#-Dletters&quot;&gt;-Di&lt;/a&gt; command-line switch, the logging of certain operations of the PerlIO subsystem will be redirected to the specified file rather than going to stderr, which is the default. The file is opened in append mode. Typical uses are in Unix:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910076b95e48e767183ba95d8bfd82a29fd1f4b7" translate="yes" xml:space="preserve">
          <source>If set to the name of a file or device, certain operations of PerlIO subsystem will be logged to that file, which is opened in append mode. Typical uses are in Unix:</source>
          <target state="translated">Если задать имя файла или устройства,то определенные операции подсистемы PerlIO будут протоколироваться в этот файл,который открывается в режиме приложения.Типичное использование-в Unix:</target>
        </trans-unit>
        <trans-unit id="a2a487ec4b2cdae05d408b6e8c6a9dd6b1beda15" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;Params::Check&quot;&gt;Params::Check&lt;/a&gt; will &lt;code&gt;croak&lt;/code&gt; when an error during template validation occurs, rather than return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e47711b0a2673f5f59abca021e0aa968949985" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;Params::Check&quot;&gt;Params::Check&lt;/a&gt; will no longer convert all keys from the user input to lowercase, but instead expect them to be in the case the template provided. This is useful when you want to use similar keys with different casing in your templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f253f67365056571734a093e4d2ab45914323e0" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;Params::Check&quot;&gt;Params::Check&lt;/a&gt; will require all values passed to be &lt;code&gt;defined&lt;/code&gt;. If you wish to enable this on a 'per key' basis, use the template option &lt;code&gt;defined&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e74293048eac70b152d671b3afa7d17f3695a7" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;Params::Check&quot;&gt;Params::Check&lt;/a&gt; will sanity check templates, validating for errors and unknown keys. Although very useful for debugging, this can be somewhat slow in hot-code and large loops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="907b3689c8943c9530c2bccd5f2399b3ea311ce8" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will &lt;code&gt;croak&lt;/code&gt; when an error during template validation occurs, rather than return &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">Если установлено значение true, &lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt; будет &lt;code&gt;croak&lt;/code&gt; при возникновении ошибки во время проверки шаблона, а не возвращать &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="262e77d8ecddf65d8252c722de18aca6dafa7dd4" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will no longer convert all keys from the user input to lowercase, but instead expect them to be in the case the template provided. This is useful when you want to use similar keys with different casing in your templates.</source>
          <target state="translated">Если установлено значение true, &lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt; больше не будет преобразовывать все ключи из пользовательского ввода в нижний регистр, а вместо этого ожидает, что они будут в случае предоставленного шаблона. Это полезно, если вы хотите использовать в шаблонах похожие ключи с разным регистром.</target>
        </trans-unit>
        <trans-unit id="fcd2802dc60a0f5aa656aa8d36630b4a5a1195a7" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will require all values passed to be &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;. If you wish to enable this on a 'per key' basis, use the template option &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Если установлено значение true, &lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt; потребует, чтобы были &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; все передаваемые значения . Если вы хотите включить это для каждого ключа, используйте вместо этого &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; параметр шаблона .</target>
        </trans-unit>
        <trans-unit id="b62a3740f4d2f3949ae331d68aff300bd8b9c5aa" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will sanity check templates, validating for errors and unknown keys. Although very useful for debugging, this can be somewhat slow in hot-code and large loops.</source>
          <target state="translated">Если установлено значение true, &lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt; будет проверять работоспособность шаблонов на наличие ошибок и неизвестных ключей. Хотя это очень полезно для отладки, это может быть несколько медленным в горячем коде и больших циклах.</target>
        </trans-unit>
        <trans-unit id="df88f116b1eff18f21bd345796868ca93d04ee66" translate="yes" xml:space="preserve">
          <source>If set to true, a crc32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$d-&amp;gt;crc32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">Если установлено значение true, будет вычислена контрольная сумма crc32 несжатых данных. Используйте метод &lt;code&gt;$d-&amp;gt;crc32&lt;/code&gt; чтобы получить это значение.</target>
        </trans-unit>
        <trans-unit id="bbd8aed6bbb2cb495083f75e98d7497f01edca37" translate="yes" xml:space="preserve">
          <source>If set to true, a crc32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$i-&amp;gt;crc32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">Если установлено значение true, будет вычислена контрольная сумма crc32 несжатых данных. Используйте метод &lt;code&gt;$i-&amp;gt;crc32&lt;/code&gt; чтобы получить это значение.</target>
        </trans-unit>
        <trans-unit id="d4a8f4d307b72654b7c09182b593e029ffb7af20" translate="yes" xml:space="preserve">
          <source>If set to true, all keys in the template that are marked as to be stored in a scalar, will also be removed from the result set.</source>
          <target state="translated">Если установлено значение true,все ключи в шаблоне,которые помечены как хранящиеся в скаляре,также будут удалены из результирующего набора.</target>
        </trans-unit>
        <trans-unit id="8a9a61d55c40cdf983928fb90e5f246e820a5b49" translate="yes" xml:space="preserve">
          <source>If set to true, an adler32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$d-&amp;gt;adler32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">Если установлено значение true, будет вычислена контрольная сумма adler32 несжатых данных. Используйте метод &lt;code&gt;$d-&amp;gt;adler32&lt;/code&gt; чтобы получить это значение.</target>
        </trans-unit>
        <trans-unit id="a5a30a93daed908c592b28db82a1a0b5d4a5ffc0" translate="yes" xml:space="preserve">
          <source>If set to true, an adler32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$i-&amp;gt;adler32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">Если установлено значение true, будет вычислена контрольная сумма adler32 несжатых данных. Используйте метод &lt;code&gt;$i-&amp;gt;adler32&lt;/code&gt; чтобы получить это значение.</target>
        </trans-unit>
        <trans-unit id="dbc945146e02b49c89057b1636cf31aa2669f101" translate="yes" xml:space="preserve">
          <source>If set to true, immediately extract entries when reading them. This gives you the same memory break as the &lt;code&gt;extract_archive&lt;/code&gt; function. Note however that entries will not be read into memory, but written straight to disk. This means no &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects are created for you to inspect.</source>
          <target state="translated">Если установлено значение true, сразу извлекать записи при их чтении. Это дает тот же разрыв памяти, что и функция &lt;code&gt;extract_archive&lt;/code&gt; . Однако учтите, что записи не будут считываться в память, а будут записаны прямо на диск. Это означает, что объекты &lt;code&gt;Archive::Tar::File&lt;/code&gt; не создаются для проверки.</target>
        </trans-unit>
        <trans-unit id="8be646f7a5def96ccc7c7343df2cffa456a1c220" translate="yes" xml:space="preserve">
          <source>If set to true, no &quot;1..N&quot; header will be printed.</source>
          <target state="translated">Если установлено значение true,заголовок &quot;1..N&quot; не будет распечатан.</target>
        </trans-unit>
        <trans-unit id="7adb95e8ec0ed6e84fcb01131c2b90c160ee5335" translate="yes" xml:space="preserve">
          <source>If set to true, this option will remove compressed data from the input buffer of the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method as the inflate progresses.</source>
          <target state="translated">Если установлено значение true, эта опция будет удалять сжатые данные из входного буфера метода &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; мере выполнения inflate.</target>
        </trans-unit>
        <trans-unit id="d55732bd7089a68f6b5548af27b4b056d17dc65d" translate="yes" xml:space="preserve">
          <source>If set true no diagnostics will be printed. This includes calls to &lt;code&gt;diag()&lt;/code&gt; .</source>
          <target state="translated">Если установлено true, диагностика не печатается. Сюда входят вызовы &lt;code&gt;diag()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5397281aac6b794ebe8bf86c258022bd58733ebd" translate="yes" xml:space="preserve">
          <source>If set true no diagnostics will be printed. This includes calls to &lt;code&gt;diag()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6758cd1f0be9e6394226a98fea1a97b18f4a012d" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;sources&lt;/code&gt; must be a hashref containing the names of the &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s to load and/or configure. The values are a hash of configuration that will be accessible to the source handlers via &lt;a href=&quot;TAP::Parser::Source#config_for&quot;&gt;&quot;config_for&quot; in TAP::Parser::Source&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767e45d99bc3772f600dade44827bcaf3503a3c0" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;sources&lt;/code&gt; must be a hashref containing the names of the &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s to load and/or configure. The values are a hash of configuration that will be accessible to the source handlers via &lt;a href=&quot;parser/source#config_for&quot;&gt;config_for in TAP::Parser::Source&lt;/a&gt;.</source>
          <target state="translated">Если установлено, &lt;code&gt;sources&lt;/code&gt; должен быть хэш-ссылкой, содержащей имена &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; для загрузки и / или настройки. Значения представляют собой хэш конфигурации, который будет доступен обработчикам исходного кода через &lt;a href=&quot;parser/source#config_for&quot;&gt;config_for в TAP :: Parser :: Source&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f1db51044dc4cdaf8453a0cac36827443c78520" translate="yes" xml:space="preserve">
          <source>If set, END blocks are executed when the interpreter is destroyed. This is normally set by perl itself after the interpreter is constructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a162adb7a0dc8b66567284e3d48459cecdcd046" translate="yes" xml:space="preserve">
          <source>If set, a directory which fails the</source>
          <target state="translated">Если установлено,то каталог,в котором не удается</target>
        </trans-unit>
        <trans-unit id="430e0a0ebf21ab8f824a0951a1408be6d39c892f" translate="yes" xml:space="preserve">
          <source>If set, and POD_MAN_DATE and the &lt;code&gt;date&lt;/code&gt; options are not set, this will be used as the modification time of the source file, overriding the timestamp of the input file or the current time. It should be set to the desired time in seconds since UNIX epoch. This is primarily useful to ensure reproducible builds of the same output file given the same source and Pod::Man version, even when file timestamps may not be consistent. See &lt;a href=&quot;https://reproducible-builds.org/specs/source-date-epoch/&quot;&gt;https://reproducible-builds.org/specs/source-date-epoch/&lt;/a&gt; for the full specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50fc3d2d4510057c46811e96115fbf4e2aa5439b" translate="yes" xml:space="preserve">
          <source>If set, general protection faults do not generate a dialogue box but can instead be handled by the process via an exception handler. This bit should not be set by programs that don't know how to handle such faults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36dd77001e7c6eaf4c115da0bfdc18f666edd086" translate="yes" xml:space="preserve">
          <source>If set, indicates that when a critical error is encountered, the call that triggered the error fails immediately. Normally this bit is not set, which means that a critical error causes a dialogue box to appear notifying the desktop user that some application has triggered a critical error. The dialogue box allows the desktop user to decide whether the critical error is returned to the process, is ignored, or the offending operation is retried.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e6aaabd1216511f49764603b89114f7c2c7520" translate="yes" xml:space="preserve">
          <source>If set, should be the name of a file (in the output directory) to write the HTML index to. The default value is &quot;index.html&quot;. If you set this to a false value, no contents file will be written.</source>
          <target state="translated">Если установлено,то должно быть имя файла (в выходной директории),в который будет записываться HTML-индекс.Значением по умолчанию является &quot;index.html&quot;.Если это значение установлено в false,то никакой файл содержимого записываться не будет.</target>
        </trans-unit>
        <trans-unit id="fed7ed0698b463358f79ea435791a3f79370827d" translate="yes" xml:space="preserve">
          <source>If set, the debugger goes into &lt;code&gt;NonStop&lt;/code&gt; mode and will not connect to a TTY. If interrupted (or if control goes to the debugger via explicit setting of $DB::signal or $DB::single from the Perl script), it connects to a TTY specified in the &lt;code&gt;TTY&lt;/code&gt; option at startup, or to a tty found at runtime using the &lt;code&gt;Term::Rendezvous&lt;/code&gt; module of your choice.</source>
          <target state="translated">Если установлено, отладчик переходит в режим &lt;code&gt;NonStop&lt;/code&gt; и не будет подключаться к TTY. В случае прерывания (или если управление передается отладчику посредством явной установки $ DB :: signal или $ DB :: single из Perl-скрипта), он подключается к TTY, указанному в параметре &lt;code&gt;TTY&lt;/code&gt; при запуске, или к tty, найденному в время выполнения, используя выбранный вами модуль &lt;code&gt;Term::Rendezvous&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f19bf560504f7c9497b672610231bba49eba7830" translate="yes" xml:space="preserve">
          <source>If set, the debugger goes into non-interactive mode until interrupted, or programmatically by setting $DB::signal or $DB::single.</source>
          <target state="translated">Если установлено,отладчик переходит в неинтерактивный режим до тех пор,пока не будет прерван,или программно,установив $DB::signal или $DB::single.</target>
        </trans-unit>
        <trans-unit id="f315d5d8357d35b3e7a9f240785d04d5f2c0b17f" translate="yes" xml:space="preserve">
          <source>If set, then when an attempt to continue reading from or writing to an already open file [usually on a removable medium like a floppy diskette] finds the file no longer available, the call will immediately fail. Normally this bit is not set, which means that instead a dialogue box will appear notifying the desktop user that some application has run into this problem. The dialogue box allows the desktop user to decide whether the failure is returned to the process, is ignored, or the offending operation is retried.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8533dab20da5503a1d14e1f563a58d7fccbc547" translate="yes" xml:space="preserve">
          <source>If set, this causes memory access misalignment faults to be automatically fixed in a manner invisible to the process. This flag is ignored on x86-based versions of Windows NT. This flag is not supported on Windows 95.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825ea211f8cc0b564969fbeabe2d0a330315f1a6" translate="yes" xml:space="preserve">
          <source>If set, this dumps out memory statistics after execution. If set to an integer greater than one, also dumps out memory statistics after compilation.</source>
          <target state="translated">Если установлено,то после выполнения выпадает статистика памяти.Если установлено целое число больше единицы,то и статистика памяти после компиляции будет выкапываться.</target>
        </trans-unit>
        <trans-unit id="8b969433f335481102ca199a1faf8cf07ca2debd" translate="yes" xml:space="preserve">
          <source>If set, this symbol indicates that only the version-specific components of a perl installation should be installed. This may be useful for making a test installation of a new version without disturbing the existing installation. Setting versiononly is equivalent to setting installperl's -v option. In particular, the non-versioned scripts and programs such as a2p, c2ph, h2xs, pod2*, and perldoc are not installed (see &lt;code&gt;INSTALL&lt;/code&gt; for a more complete list). Nor are the man pages installed. Usually, this is undef.</source>
          <target state="translated">Если установлено, этот символ указывает на то, что должны быть установлены только компоненты установки Perl, зависящие от версии. Это может быть полезно для выполнения тестовой установки новой версии без нарушения существующей установки. Установка только версии эквивалентна установке параметра installperl -v. В частности, не устанавливаются скрипты и программы без поддержки версий, такие как a2p, c2ph, h2xs, pod2 * и perldoc (см. &lt;code&gt;INSTALL&lt;/code&gt; для более полного списка). Также не установлены страницы руководства. Обычно это undef.</target>
        </trans-unit>
        <trans-unit id="80c94ecda6e710c6fc8e753f6f4382b5d0835ec4" translate="yes" xml:space="preserve">
          <source>If set, this will be used as the value of the left-hand footer unless the &lt;code&gt;date&lt;/code&gt; option is explicitly set, overriding the timestamp of the input file or the current time. This is primarily useful to ensure reproducible builds of the same output file given the same source and Pod::Man version, even when file timestamps may not be consistent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be95242fd4f1700426db0866219ce183a7c4d43" translate="yes" xml:space="preserve">
          <source>If setmagic is false then no set magic will be called on the new (empty) SV. This typically means that assignment will soon follow (e.g. 'local $x = $y'), and that will handle the magic.</source>
          <target state="translated">Если setmagic ложный,то в новом (пустом)SV не будет вызвана магическая установка.Обычно это означает,что скоро произойдет присвоение (например,'local $x=$y'),и оно будет обрабатывать магию.</target>
        </trans-unit>
        <trans-unit id="b7db0eb29b687c30aa2094a54d8f1f63ca4df7c5" translate="yes" xml:space="preserve">
          <source>If several symbol categories exist in &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; , it's usually useful to create the utility &quot;:all&quot; to simplify &quot;use&quot; statements.</source>
          <target state="translated">Если в &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; существует несколько категорий символов , обычно полезно создать служебную программу &quot;: all&quot; для упрощения операторов использования.</target>
        </trans-unit>
        <trans-unit id="3f21602986b59b3bc1a9d6d50edec0ff3a9a1224" translate="yes" xml:space="preserve">
          <source>If several symbol categories exist in &lt;code&gt;%EXPORT_TAGS&lt;/code&gt;, it's usually useful to create the utility &quot;:all&quot; to simplify &quot;use&quot; statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d650df7f1b284cce9178200761c079c663691a8" translate="yes" xml:space="preserve">
          <source>If so, please try to reuse the existing modules either in whole or by inheriting useful features into a new class. If this is not practical try to get together with the module authors to work on extending or enhancing the functionality of the existing modules. A perfect example is the plethora of packages in perl4 for dealing with command line options.</source>
          <target state="translated">Если это так,то попробуйте повторно использовать существующие модули либо целиком,либо унаследовав полезные функции в новом классе.Если это непрактично,попробуйте вместе с авторами модулей поработать над расширением или улучшением функциональности существующих модулей.Прекрасным примером является множество пакетов на perl4 для работы с опциями командной строки.</target>
        </trans-unit>
        <trans-unit id="dcc2c875ef26b86def7f4287ef7a97e0b0212c08" translate="yes" xml:space="preserve">
          <source>If so, that's great news; bug reports with patches are likely to receive significantly more attention and interest than those without patches. Please attach your patch to the report using the &lt;code&gt;-p&lt;/code&gt; option. When sending a patch, create it using &lt;code&gt;git format-patch&lt;/code&gt; if possible, though a unified diff created with &lt;code&gt;diff -pu&lt;/code&gt; will do nearly as well.</source>
          <target state="translated">Если так, это отличная новость; отчеты об ошибках с исправлениями, вероятно, получат значительно больше внимания и интереса, чем отчеты без исправлений. Прикрепите свой патч к отчету с помощью опции &lt;code&gt;-p&lt;/code&gt; . При отправке патча, если возможно , создайте его с помощью &lt;code&gt;git format-patch&lt;/code&gt; , хотя унифицированный diff, созданный с помощью &lt;code&gt;diff -pu&lt;/code&gt; , подойдет почти так же.</target>
        </trans-unit>
        <trans-unit id="dfaefac0caf9158c6cac0a67edf5328c9dac8509" translate="yes" xml:space="preserve">
          <source>If so, that's great news; bug reports with patches are likely to receive significantly more attention and interest than those without patches. Please submit your patch via the GitHub Pull Request workflow as described in &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt;. You may also send patches to &lt;b&gt;perl5-porters@perl.org&lt;/b&gt;. When sending a patch, create it using &lt;code&gt;git format-patch&lt;/code&gt; if possible, though a unified diff created with &lt;code&gt;diff -pu&lt;/code&gt; will do nearly as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41db44860ffe2b84a712b997e64175db6318266" translate="yes" xml:space="preserve">
          <source>If some events detected in</source>
          <target state="translated">Если некоторые события были обнаружены в</target>
        </trans-unit>
        <trans-unit id="4a24b9aa82fff6a4581557ce8337d0476898456b" translate="yes" xml:space="preserve">
          <source>If some threads have not finished running when the main Perl thread ends, Perl will warn you about it and die, since it is impossible for Perl to clean up itself while other threads are running.</source>
          <target state="translated">Если некоторые потоки не закончили работу,когда заканчивается основной поток Perl,Perl предупредит вас об этом и умрет,так как Perl не может почистить себя,пока другие потоки работают.</target>
        </trans-unit>
        <trans-unit id="5c202d6491a5606cc9c88606232cf0104e601803" translate="yes" xml:space="preserve">
          <source>If something in a program isn&amp;rsquo;t the value you&amp;rsquo;re looking for but indicates where the value is, that&amp;rsquo;s indirection. This can be done with either &lt;b&gt;symbolic references&lt;/b&gt; or &lt;b&gt;hard&lt;/b&gt;.</source>
          <target state="translated">Если что-то в программе не является тем значением, которое вы ищете, а указывает, где находится значение, это косвенное указание. Это можно сделать как с &lt;b&gt;символическими ссылками, так&lt;/b&gt; и с &lt;b&gt;жесткими&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="6d353132ec4a6837954d3ce352dc8e97cba1ae50" translate="yes" xml:space="preserve">
          <source>If something in the Perl core is marked as &lt;b&gt;deprecated&lt;/b&gt;, we may remove it from the core in the future, though we might not. Generally, backward incompatible changes will have deprecation warnings for two release cycles before being removed, but may be removed after just one cycle if the risk seems quite low or the benefits quite high.</source>
          <target state="translated">Если что-то в ядре Perl помечено как &lt;b&gt;устаревшее&lt;/b&gt; , мы можем удалить это из ядра в будущем, но не можем. Как правило, обратно несовместимые изменения будут иметь предупреждения об устаревании в течение двух циклов выпуска перед удалением, но могут быть удалены только после одного цикла, если риск кажется довольно низким или преимущества довольно высокими.</target>
        </trans-unit>
        <trans-unit id="5fdc0cac0824435fe5437bd44fc271afb23e92f6" translate="yes" xml:space="preserve">
          <source>If something in the Perl core is marked as &lt;b&gt;experimental&lt;/b&gt;, we may change its behaviour, deprecate or remove it without notice. While we'll always do our best to smooth the transition path for users of experimental features, you should contact the perl5-porters mailinglist if you find an experimental feature useful and want to help shape its future.</source>
          <target state="translated">Если что-то в ядре Perl помечено как &lt;b&gt;экспериментальное&lt;/b&gt; , мы можем изменить его поведение, исключить его или удалить без предварительного уведомления. Хотя мы всегда делаем все возможное, чтобы облегчить переход пользователей экспериментальных функций, вам следует связаться со списком рассылки perl5-porters, если вы сочтете экспериментальную функцию полезной и хотите помочь сформировать ее будущее.</target>
        </trans-unit>
        <trans-unit id="5fae6eb432d77d8528c8b9785dccec21b272faf2" translate="yes" xml:space="preserve">
          <source>If something in there fails, you'll know which one it was and that will make tracking down the problem easier. Try to put a bit of debugging information into the test names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12083dc2cfbc1c39486c5540691a063ce5c5018f" translate="yes" xml:space="preserve">
          <source>If spaces extend into the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if</source>
          <target state="translated">Если в следующий фрагмент вводимого текста будут вставлены пробелы,то будет прочитан следующий фрагмент.Обычно текущий фрагмент отбрасывается в одно и то же время,но если</target>
        </trans-unit>
        <trans-unit id="14e709a02e4eecb15fa27505b7e71a09c11f743c" translate="yes" xml:space="preserve">
          <source>If spaces extend into the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; bit set, then the current chunk will not be discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593e478a0d37f7a9d8665d309a9a7733f6ec02c1" translate="yes" xml:space="preserve">
          <source>If specified the contents of &lt;code&gt;DATA&lt;/code&gt; and a termination string &lt;code&gt;&quot;.\r\n&quot;&lt;/code&gt; is sent to the server. The result will be true if the data was accepted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6dd58d3559146e497eb5b446f27a9cb126713f8" translate="yes" xml:space="preserve">
          <source>If specified, strings are normalized before preparation of sort keys (the normalization is executed after preprocess).</source>
          <target state="translated">Если указано,то перед подготовкой ключей сортировки происходит нормализация строк (нормализация выполняется после препроцесса).</target>
        </trans-unit>
        <trans-unit id="c54d25c0a371a4a7533e5b6eb7a37c54566669f4" translate="yes" xml:space="preserve">
          <source>If specified, the coderef is used to preprocess each string before the formation of sort keys.</source>
          <target state="translated">Если указано,то кодреф используется для препроцессирования каждой строки перед формированием ключей сортировки.</target>
        </trans-unit>
        <trans-unit id="df742ffc92755882ac205c4e8f1710a25c417cf9" translate="yes" xml:space="preserve">
          <source>If specified, the coderef is used to rewrite lines in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; . The coderef will get each line, and then should return a rewritten line according to the UCA file format. If the coderef returns an empty line, the line will be skipped.</source>
          <target state="translated">Если указано, ссылка на код используется для перезаписи строк в &lt;code&gt;table&lt;/code&gt; или &lt;code&gt;entry&lt;/code&gt; . Coderef получит каждую строку, а затем должен вернуть переписанную строку в соответствии с форматом файла UCA. Если ссылка на код возвращает пустую строку, она будет пропущена.</target>
        </trans-unit>
        <trans-unit id="65a1895406fe003bd9c8df18e562302ad473cb2d" translate="yes" xml:space="preserve">
          <source>If specified, the coderef is used to rewrite lines in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt;. The coderef will get each line, and then should return a rewritten line according to the UCA file format. If the coderef returns an empty line, the line will be skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd186f184cd201e115617cc1e9809ac56ff41627" translate="yes" xml:space="preserve">
          <source>If specified, the given string will be stripped off from the beginning of the C function name in the generated XS functions (if it starts with that prefix). This only applies to XSUBs without &lt;code&gt;CODE&lt;/code&gt; or &lt;code&gt;PPCODE&lt;/code&gt; blocks. For example, the XS:</source>
          <target state="translated">Если указано, данная строка будет удалена из начала имени функции C в сгенерированных функциях XS (если она начинается с этого префикса). Это применимо только к XSUB без блоков &lt;code&gt;CODE&lt;/code&gt; или &lt;code&gt;PPCODE&lt;/code&gt; . Например, XS:</target>
        </trans-unit>
        <trans-unit id="db33e17f1262611ad9b1ad5050ad6146c6b090c4" translate="yes" xml:space="preserve">
          <source>If specified, this option will disable the creation of all extra fields in the zip local and central headers. So the &lt;code&gt;exTime&lt;/code&gt; , &lt;code&gt;exUnix2&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; , &lt;code&gt;ExtraFieldLocal&lt;/code&gt; and &lt;code&gt;ExtraFieldCentral&lt;/code&gt; options will be ignored.</source>
          <target state="translated">Если указано, этот параметр отключит создание всех дополнительных полей в локальном и центральном заголовках ZIP. Таким образом, параметры &lt;code&gt;exTime&lt;/code&gt; , &lt;code&gt;exUnix2&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; , &lt;code&gt;ExtraFieldLocal&lt;/code&gt; и &lt;code&gt;ExtraFieldCentral&lt;/code&gt; будут проигнорированы.</target>
        </trans-unit>
        <trans-unit id="6aa95b55da4c40155f92625ffd4e21427121a5f5" translate="yes" xml:space="preserve">
          <source>If specified, this option will disable the creation of all extra fields in the zip local and central headers. So the &lt;code&gt;exTime&lt;/code&gt;, &lt;code&gt;exUnix2&lt;/code&gt;, &lt;code&gt;exUnixN&lt;/code&gt;, &lt;code&gt;ExtraFieldLocal&lt;/code&gt; and &lt;code&gt;ExtraFieldCentral&lt;/code&gt; options will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0066c7ecc8871ce3a62f9b83ef61508d6113e7" translate="yes" xml:space="preserve">
          <source>If specified, this option will force the creation of the smallest possible compliant gzip header (which is exactly 10 bytes long) as defined in RFC 1952.</source>
          <target state="translated">Если эта опция будет задана,то она заставит создать минимально возможный соответствующий заголовок gzip (который имеет длину ровно 10 байт),как определено в RFC 1952.</target>
        </trans-unit>
        <trans-unit id="74b346bb75048f3d43315e1f91c059eb29d865aa" translate="yes" xml:space="preserve">
          <source>If speed is of little concern, the common idiom uses grep in scalar context (which returns the number of items that passed its condition) to traverse the entire list. This does have the benefit of telling you how many matches it found, though.</source>
          <target state="translated">Если скорость не вызывает особого беспокойства,то общая идиома использует grep в скалярном контексте (который возвращает количество элементов,прошедших через его условие)для прохождения по всему списку.Однако,это имеет преимущество,так как позволяет узнать,сколько совпадений она нашла.</target>
        </trans-unit>
        <trans-unit id="8029f3ea6d316f66b8a86b9af29af453cce204da" translate="yes" xml:space="preserve">
          <source>If start_color is non-null then it will be inserted after the opening quote (if there is one) but before the escaped text. If end_color is non-null then it will be inserted after the escaped text but before any quotes or ellipses.</source>
          <target state="translated">Если переменная start_color не является нулевой,то она будет вставлена после стартовой кавычки (если она есть),но до экранированного текста.Если переменная end_color не является полной,то она будет вставлена после экранированного текста,но перед любыми кавычками или эллипсами.</target>
        </trans-unit>
        <trans-unit id="741bc8e54000bbf6547a93a37e27f9bd7b7bf22e" translate="yes" xml:space="preserve">
          <source>If straightforward stream-based parsing wont meet your needs (as is likely the case for tasks such as translating PODs into structured markup languages like HTML and XML) then you may need to take the tree-based approach. Rather than doing everything in one pass and calling the &lt;b&gt;interpolate()&lt;/b&gt; method to expand sequences into text, it may be desirable to instead create a parse-tree using the &lt;b&gt;parse_text()&lt;/b&gt; method to return a tree-like structure which may contain an ordered list of children (each of which may be a text-string, or a similar tree-like structure).</source>
          <target state="translated">Если простой парсинг на основе потоков не отвечает вашим потребностям (как это, вероятно, имеет место для таких задач, как перевод POD на структурированные языки разметки, такие как HTML и XML), вам может потребоваться подход на основе дерева. Вместо того, чтобы делать все за один проход и вызывать метод &lt;b&gt;interpolate ()&lt;/b&gt; для преобразования последовательностей в текст, может быть желательно вместо этого создать дерево синтаксического анализа, используя метод &lt;b&gt;parse_text (),&lt;/b&gt; чтобы вернуть древовидную структуру, которая может содержать упорядоченный список дочерних элементов (каждый из которых может быть текстовой строкой или подобной древовидной структурой).</target>
        </trans-unit>
        <trans-unit id="2063c72cde7216e8c8fe940ebf2fb1f781846427" translate="yes" xml:space="preserve">
          <source>If subroutine signatures are enabled (see &lt;a href=&quot;#Signatures&quot;&gt;&quot;Signatures&quot;&lt;/a&gt;), then the shorter PROTO syntax is unavailable, because it would clash with signatures. In that case, a prototype can only be declared in the form of an attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d14b7e2a788098ee234bfc1585ff4767dfdaee2" translate="yes" xml:space="preserve">
          <source>If subroutine signatures are enabled (see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt;), then the shorter PROTO syntax is unavailable, because it would clash with signatures. In that case, a prototype can only be declared in the form of an attribute.</source>
          <target state="translated">Если подпрограммы подпрограмм включены (см. &amp;laquo; &lt;a href=&quot;#Signatures&quot;&gt;Подписи&amp;raquo;&lt;/a&gt; ), то более короткий синтаксис PROTO недоступен, так как он будет конфликтовать с подписями. В этом случае прототип может быть объявлен только в форме атрибута.</target>
        </trans-unit>
        <trans-unit id="42c7d01f7359f4959eaf7c155ab3009451137cea" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;$i&lt;/code&gt; will hold the inflation object and &lt;code&gt;$status&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">В случае успеха &lt;code&gt;$i&lt;/code&gt; будет содержать объект инфляции, а &lt;code&gt;$status&lt;/code&gt; будет &lt;code&gt;Z_OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf6796a439d489957a46f406c119c69951b658a8" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;$i&lt;/code&gt; will hold the inflation object and &lt;code&gt;$status&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec38a973765ca012bc6fc104f4b8ef70937c9614" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;$i&lt;/code&gt; will hold the inflation stream and &lt;code&gt;$status&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">В случае успеха &lt;code&gt;$i&lt;/code&gt; будет удерживать поток инфляции, а &lt;code&gt;$status&lt;/code&gt; будет &lt;code&gt;Z_OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6af1f82c337ffb0cd08fe17aa27a424683eba9a" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;$i&lt;/code&gt; will hold the inflation stream and &lt;code&gt;$status&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34b524a05a94eda9eec45a5e52e923221e9853a" translate="yes" xml:space="preserve">
          <source>If successful, it returns the in-memory gzip file. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;$gzerrno&lt;/code&gt; variable will store the zlib error code.</source>
          <target state="translated">В случае успеха он возвращает файл gzip в памяти. В противном случае возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , а переменная &lt;code&gt;$gzerrno&lt;/code&gt; сохранит код ошибки zlib.</target>
        </trans-unit>
        <trans-unit id="81c786291c2ee4a09a4250b9266414c8b0d7512f" translate="yes" xml:space="preserve">
          <source>If successful, it returns the in-memory gzip file. Otherwise it returns &lt;code&gt;undef&lt;/code&gt; and the &lt;code&gt;$gzerrno&lt;/code&gt; variable will store the zlib error code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4a46b7cfb2406db4688f3a0ac9d424f4865a652" translate="yes" xml:space="preserve">
          <source>If successful, it returns the uncompressed gzip file. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;$gzerrno&lt;/code&gt; variable will store the zlib error code.</source>
          <target state="translated">В случае успеха он возвращает несжатый файл gzip. В противном случае возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , а переменная &lt;code&gt;$gzerrno&lt;/code&gt; сохранит код ошибки zlib.</target>
        </trans-unit>
        <trans-unit id="b546e05843ef34edaf10ea0003e7e36111124750" translate="yes" xml:space="preserve">
          <source>If successful, it returns the uncompressed gzip file. Otherwise it returns &lt;code&gt;undef&lt;/code&gt; and the &lt;code&gt;$gzerrno&lt;/code&gt; variable will store the zlib error code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f77490ec0c061ac3ae6e48aedaf1d41d413b95c" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised compression object, &lt;code&gt;$z&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;BZ_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$z&lt;/code&gt; , only.</source>
          <target state="translated">В случае успеха, он возвращает объект инициализируется сжатия, &lt;code&gt;$z&lt;/code&gt; и &lt;code&gt;$status&lt;/code&gt; в &lt;code&gt;BZ_OK&lt;/code&gt; в контексте списка. В скалярном контексте он возвращает только объект дефляции &lt;code&gt;$z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afab4c4ec82d17a0d3d79f9261a109b3948960bc" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised compression object, &lt;code&gt;$z&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;BZ_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$z&lt;/code&gt;, only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="003d593630b18abe30c9939f8d44076e1ce90807" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised deflation object, &lt;code&gt;$d&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;Z_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$d&lt;/code&gt; , only.</source>
          <target state="translated">В случае успеха, он возвращает объект инициализируется дефляции, &lt;code&gt;$d&lt;/code&gt; и &lt;code&gt;$status&lt;/code&gt; в &lt;code&gt;Z_OK&lt;/code&gt; в контексте списка. В скалярном контексте он возвращает только объект дефляции, &lt;code&gt;$d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9aa536487df74029d769a48c392afba84c5f24e" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised deflation object, &lt;code&gt;$d&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;Z_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$d&lt;/code&gt;, only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f86208486cf7be6093bb8b7191e306d09fb04dc" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised deflation stream, &lt;code&gt;$d&lt;/code&gt; and &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;Z_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation stream, &lt;code&gt;$d&lt;/code&gt; , only.</source>
          <target state="translated">В случае успеха, он будет возвращать инициализируется поток дефляции, &lt;code&gt;$d&lt;/code&gt; и &lt;code&gt;$status&lt;/code&gt; в &lt;code&gt;Z_OK&lt;/code&gt; в контексте списка. В скалярном контексте он возвращает только поток дефляции &lt;code&gt;$d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dab6fec9c63017bda459ab8c2b830d444d4282cf" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised deflation stream, &lt;code&gt;$d&lt;/code&gt; and &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;Z_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation stream, &lt;code&gt;$d&lt;/code&gt;, only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d2c70da3dce90528345981e79d77f52c5f5ddb" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised uncompression object, &lt;code&gt;$z&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;BZ_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$z&lt;/code&gt; , only.</source>
          <target state="translated">В случае успеха, он возвращает инициализируется объект, распаковки &lt;code&gt;$z&lt;/code&gt; и &lt;code&gt;$status&lt;/code&gt; в &lt;code&gt;BZ_OK&lt;/code&gt; в контексте списка. В скалярном контексте он возвращает только объект дефляции &lt;code&gt;$z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2677208b617b8465686e69e5dcf570d05d7bc09" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised uncompression object, &lt;code&gt;$z&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;BZ_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$z&lt;/code&gt;, only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9905dac4184f6f7193dddf39eab6d02ad4540f03" translate="yes" xml:space="preserve">
          <source>If supplied with an argument that can't be a code point, &lt;code&gt;charblock()&lt;/code&gt; tries to do the opposite and interpret the argument as an old-style block name. On an ASCII platform, the return value is a</source>
          <target state="translated">Если предоставлен аргумент, который не может быть кодовой точкой, &lt;code&gt;charblock()&lt;/code&gt; пытается сделать обратное и интерпретировать аргумент как имя блока старого стиля. На платформе ASCII возвращаемое значение -</target>
        </trans-unit>
        <trans-unit id="343b1f1d2e0b0c3a0e2a3dffed0083feca7d527c" translate="yes" xml:space="preserve">
          <source>If supplied with an argument that can't be a code point, charscript() tries to do the opposite and interpret the argument as a script name. The return value is a</source>
          <target state="translated">Если поставляется аргумент,который не может быть точкой кода,то charscript()пытается сделать обратное и интерпретировать аргумент как имя сценария.Возвращаемое значение равно</target>
        </trans-unit>
        <trans-unit id="95ecffacfac149266d204e25c816abb11a57c234" translate="yes" xml:space="preserve">
          <source>If supported by the core Perl version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6599907df819640d703f0de46e603f79205c931" translate="yes" xml:space="preserve">
          <source>If supported by the core Perl version, this function will return an ANSI path name for the current directory if the long pathname cannot be represented in the system codepage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dcad45e80ec56c1bf86fbe3660554c170755ed1" translate="yes" xml:space="preserve">
          <source>If supported by the core Perl version, this function will return an ANSI path name if the full pathname cannot be represented in the system codepage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608c69ec5dc593b8e31469808e911c9b8c28fab1" translate="yes" xml:space="preserve">
          <source>If tcsh is your login shell then use the setenv command.</source>
          <target state="translated">Если tcsh-оболочка для входа в систему,используйте команду setenv.</target>
        </trans-unit>
        <trans-unit id="6722301f4d6d5b294f3eee46d693b203a67e97d7" translate="yes" xml:space="preserve">
          <source>If that doesn't make much sense, consider the analogy of a command pipeline. Say you have a shell script stored in the compressed file</source>
          <target state="translated">Если это не имеет смысла,рассмотрим аналогию командного трубопровода.Скажем,у вас есть скрипт оболочки,хранящийся в сжатом файле.</target>
        </trans-unit>
        <trans-unit id="e0190f66a1f731aebdad4c16cbe570cf5e90169e" translate="yes" xml:space="preserve">
          <source>If that doesn't suit your needs, you can explicitly set the filename used in the zip archive by specifying the &lt;a href=&quot;#File-Naming-Options&quot;&gt;Name&lt;/a&gt; option, like so</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce337d0a942d7a20e0ccbeff20a1fe0816cdba5" translate="yes" xml:space="preserve">
          <source>If that doesn't work (it relies on features of your stdio implementation), then you need something more like this:</source>
          <target state="translated">Если это не работает (это зависит от возможностей вашей stdio реализации),то вам нужно что-то более похожее на это:</target>
        </trans-unit>
        <trans-unit id="ace9cde0327f63e0372278440efb1605dee92be3" translate="yes" xml:space="preserve">
          <source>If that doesn't work (some I/O implementations are particularly cantankerous), you might need something like this:</source>
          <target state="translated">Если это не сработает (некоторые реализации ввода/вывода особенно кантанкерны),вам может понадобиться что-нибудь подобное:</target>
        </trans-unit>
        <trans-unit id="76b21d1151e484221dbc92ea1c2c56d3ec4082a9" translate="yes" xml:space="preserve">
          <source>If that doesn't work, give up on your stdio package and use sysread.</source>
          <target state="translated">Если это не сработает,бросьте свой студийный пакет и используйте sysread.</target>
        </trans-unit>
        <trans-unit id="0580b926aa13464eaf5222ef23bd075e2a2e806d" translate="yes" xml:space="preserve">
          <source>If that doesn't work, try seeking to a different part of the file and then back.</source>
          <target state="translated">Если это не сработает,попробуйте поискать другую часть файла,а затем обратно.</target>
        </trans-unit>
        <trans-unit id="b4eb30982662b9e20db4ab3ae1666e6a76a6e58a" translate="yes" xml:space="preserve">
          <source>If that doesn't work, try seeking to a different part of the file, reading something, and then seeking back.</source>
          <target state="translated">Если это не сработает,попробуйте поискать другую часть файла,прочитать что-нибудь,а затем поискать обратно.</target>
        </trans-unit>
        <trans-unit id="4c63d398b08eb5cb7f3f37514cbe92856008dc42" translate="yes" xml:space="preserve">
          <source>If that gives too much output every day, you may want to watch only for three modules. You can write</source>
          <target state="translated">Если это дает слишком много вывода каждый день,вы можете захотеть смотреть только для трех модулей.Вы можете написать</target>
        </trans-unit>
        <trans-unit id="b86041bbbb4cc3f3c7bede4e6b1882292fbc734e" translate="yes" xml:space="preserve">
          <source>If that module is not available, then HTTP::Tiny will search several system-specific default locations for a CA certificate file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c73f5392dc820a97b0a4426cb998de73cb28f26" translate="yes" xml:space="preserve">
          <source>If that warnings category has been set to &quot;FATAL&quot; in the calling module then die. Otherwise return.</source>
          <target state="translated">Если в вызывающем модуле эта категория предупреждений была установлена на &quot;FATAL&quot;,то она умирает.В противном случае возвращайтесь.</target>
        </trans-unit>
        <trans-unit id="313f3cd86007469b883802f17e39affb3f8c8794" translate="yes" xml:space="preserve">
          <source>If that warnings category has been set to &quot;FATAL&quot; in the scope where &lt;code&gt;$object&lt;/code&gt; is first used then die. Otherwise return.</source>
          <target state="translated">Если эта категория предупреждений была установлена ​​на &quot;FATAL&quot; в области, где &lt;code&gt;$object&lt;/code&gt; используется впервые, а затем умереть. В противном случае вернитесь.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">Если</target>
        </trans-unit>
        <trans-unit id="dea88bea19f46633af98810723372bbf40ef70b7" translate="yes" xml:space="preserve">
          <source>If the &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;. This indicates that the caller is expecting numeric behaviour. The fourth argument will be &lt;code&gt;undef&lt;/code&gt;, as that position (&lt;code&gt;$_[3]&lt;/code&gt;) is reserved for use by &lt;a href=&quot;#nomethod&quot;&gt;&quot;nomethod&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961ec9e4bcc802a6b4814ce90b4ef69a38577267" translate="yes" xml:space="preserve">
          <source>If the &quot;bitwise&quot; feature is enabled via &lt;code&gt;use feature 'bitwise'&lt;/code&gt; or &lt;code&gt;use v5.28&lt;/code&gt;, then this operator always treats its operands as numbers. Before Perl 5.28 this feature produced a warning in the &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64579e960549e55b6b337ed2444636b1b80df4aa" translate="yes" xml:space="preserve">
          <source>If the &quot;bitwise&quot; feature is enabled via &lt;code&gt;use feature 'bitwise'&lt;/code&gt; or &lt;code&gt;use v5.28&lt;/code&gt;, then this operator always treats its operands as numbers. Before Perl 5.28. this feature produced a warning in the &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27af0b330e562f7c0bf54946fd3c82282b9d8b27" translate="yes" xml:space="preserve">
          <source>If the &quot;bitwise&quot; feature is enabled via &lt;code&gt;use feature 'bitwise'&lt;/code&gt; or &lt;code&gt;use v5.28&lt;/code&gt;, then unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; always treats its argument as a number, and an alternate form of the operator, &lt;code&gt;&quot;~.&quot;&lt;/code&gt;, always treats its argument as a string. So &lt;code&gt;~0&lt;/code&gt; and &lt;code&gt;~&quot;0&quot;&lt;/code&gt; will both give 2**32-1 on 32-bit platforms, whereas &lt;code&gt;~.0&lt;/code&gt; and &lt;code&gt;~.&quot;0&quot;&lt;/code&gt; will both yield &lt;code&gt;&quot;\xff&quot;&lt;/code&gt;. Until Perl 5.28, this feature produced a warning in the &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4493cf703f913ddbd099cc80db075e294c3617b1" translate="yes" xml:space="preserve">
          <source>If the &quot;external&quot; protocol is specified, the ping() method attempts to use the &lt;code&gt;Net::Ping::External&lt;/code&gt; module to ping the remote host. &lt;code&gt;Net::Ping::External&lt;/code&gt; interfaces with your system's default &lt;code&gt;ping&lt;/code&gt; utility to perform the ping, and generally produces relatively accurate results. If &lt;code&gt;Net::Ping::External&lt;/code&gt; if not installed on your system, specifying the &quot;external&quot; protocol will result in an error.</source>
          <target state="translated">Если указан &amp;laquo;внешний&amp;raquo; протокол, метод ping () пытается использовать модуль &lt;code&gt;Net::Ping::External&lt;/code&gt; для проверки связи удаленного хоста. &lt;code&gt;Net::Ping::External&lt;/code&gt; взаимодействует с утилитой &lt;code&gt;ping&lt;/code&gt; вашей системы по умолчанию для выполнения ping и обычно дает относительно точные результаты. Если &lt;code&gt;Net::Ping::External&lt;/code&gt; не установлен в вашей системе, указание &amp;laquo;внешнего&amp;raquo; протокола приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="b022b01a378125712b4875c54365686882089f63" translate="yes" xml:space="preserve">
          <source>If the &quot;icmp&quot; protocol is specified, the ping() method sends an icmp echo message to the remote host, which is what the UNIX ping program does. If the echoed message is received from the remote host and the echoed information is correct, the remote host is considered reachable. Specifying the &quot;icmp&quot; protocol requires that the program be run as root or that the program be setuid to root.</source>
          <target state="translated">Если указан протокол &quot;icmp&quot;,метод ping()посылает эхо-сообщение icmp на удаленный хост,что и делает ping-программа UNIX.Если эхо-сообщение получено от удаленного хоста и эхо-информация верна,то удаленный хост считается доступным.Указание протокола &quot;icmp&quot; требует,чтобы программа была запущена от имени root или чтобы программа была настроена на root.</target>
        </trans-unit>
        <trans-unit id="20101303a26c3ad1b48f828a91b98648450fed40" translate="yes" xml:space="preserve">
          <source>If the &quot;syn&quot; protocol is specified, the &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method will only send a TCP SYN packet to the remote host then immediately return. If the syn packet was sent successfully, it will return a true value, otherwise it will return false. NOTE: Unlike the other protocols, the return value does NOT determine if the remote host is alive or not since the full TCP three-way handshake may not have completed yet. The remote host is only considered reachable if it receives a TCP ACK within the timeout specified. To begin waiting for the ACK packets, use the &lt;a href=&quot;#ack&quot;&gt;&quot;ack&quot;&lt;/a&gt; method as explained below. Use the &quot;syn&quot; protocol instead the &quot;tcp&quot; protocol to determine reachability of multiple destinations simultaneously by sending parallel TCP SYN packets. It will not block while testing each remote host. This protocol does not require any special privileges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3280089081e0a65bf27928777cbd13d99f6f66b" translate="yes" xml:space="preserve">
          <source>If the &quot;syn&quot; protocol is specified, the ping() method will only send a TCP SYN packet to the remote host then immediately return. If the syn packet was sent successfully, it will return a true value, otherwise it will return false. NOTE: Unlike the other protocols, the return value does NOT determine if the remote host is alive or not since the full TCP three-way handshake may not have completed yet. The remote host is only considered reachable if it receives a TCP ACK within the timeout specified. To begin waiting for the ACK packets, use the ack() method as explained below. Use the &quot;syn&quot; protocol instead the &quot;tcp&quot; protocol to determine reachability of multiple destinations simultaneously by sending parallel TCP SYN packets. It will not block while testing each remote host. demo/fping is provided in this distribution to demonstrate the &quot;syn&quot; protocol as an example. This protocol does not require any special privileges.</source>
          <target state="translated">Если указан протокол &quot;syn&quot;,то метод ping()будет посылать только TCP SYN пакет на удаленный хост,а затем немедленно возвращать его.Если пакет syn был успешно отправлен,он вернет значение true,в противном случае-false.ПРИМЕЧАНИЕ:В отличие от других протоколов,возвращаемое значение НЕ определяет,жив удаленный хост или нет,так как полное трехстороннее TCP-квитирование,возможно,еще не завершено.Удаленный хост считается доступным только в том случае,если он получает TCP ACK в течение указанного таймаута.Чтобы начать ожидание ACK-пакетов,используйте метод ack(),как объяснено ниже.Используйте вместо протокола &quot;tcp&quot; протокол &quot;syn&quot; для определения достижимости нескольких пунктов назначения одновременно,посылая параллельные пакеты TCP SYN.Он не будет блокироваться при тестировании каждого удаленного хоста.Для демонстрации протокола &quot;syn&quot; в качестве примера в данном дистрибутиве приводится demo/fping.Данный протокол не требует никаких специальных привилегий.</target>
        </trans-unit>
        <trans-unit id="7238cf0824cb05db1486e3141c96b6c642d31d1f" translate="yes" xml:space="preserve">
          <source>If the &quot;user:password&quot; stanza contains reserved characters, they must be percent-escaped:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318d6b49d6250a4816190433cf297845eb70cba7" translate="yes" xml:space="preserve">
          <source>If the $crc parameters is &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the crc value will be reset.</source>
          <target state="translated">Если параметры $ crc - &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , значение crc будет сброшено.</target>
        </trans-unit>
        <trans-unit id="abcc06c7fad286b05b36114515df89ab3f899db0" translate="yes" xml:space="preserve">
          <source>If the $crc parameters is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the crc value will be reset.</source>
          <target state="translated">Если параметры $ crc - &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , значение crc будет сброшено.</target>
        </trans-unit>
        <trans-unit id="0e9952545241861fa2f27861c631fbcce0156104" translate="yes" xml:space="preserve">
          <source>If the $crc parameters is &lt;code&gt;undef&lt;/code&gt;, the crc value will be reset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302e31c3384df8bb8c31ef52a9d8291c6e65b38e" translate="yes" xml:space="preserve">
          <source>If the $must_be_file argument is provided and is TRUE, then return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; unless the image looks like it belongs to a file dump.</source>
          <target state="translated">Если аргумент $ must_be_file предоставлен и имеет значение ИСТИНА, вернуть &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если изображение не выглядит как принадлежащее дампу файла.</target>
        </trans-unit>
        <trans-unit id="32046e73c61ab6dfbb991e61669caae203688f3e" translate="yes" xml:space="preserve">
          <source>If the $must_be_file argument is provided and is TRUE, then return &lt;code&gt;undef&lt;/code&gt; unless the image looks like it belongs to a file dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865165ad77b0593f721d466f6d0ebabfe1d34482" translate="yes" xml:space="preserve">
          <source>If the $string is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если $ string - &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , возвращается &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="688f0ecd47d63e749a9dd5c5cac2e57d32b8ed3a" translate="yes" xml:space="preserve">
          <source>If the $string is &lt;code&gt;undef&lt;/code&gt;, then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076c07280263c9d15e3255695b14d837c538bc87" translate="yes" xml:space="preserve">
          <source>If the &amp;lt;$input_filename_or_reference&amp;gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for reading and the input data will be read from it.</source>
          <target state="translated">Если параметр &amp;lt;$ input_filename_or_reference&amp;gt; является простым скаляром, предполагается, что это имя файла. Этот файл будет открыт для чтения, и из него будут считываться входные данные.</target>
        </trans-unit>
        <trans-unit id="e6e87357913d48be4073006d8b0866ceef5457d5" translate="yes" xml:space="preserve">
          <source>If the 'name' is '&amp;amp;' the corresponding entry in the PAD is a CV representing a possible closure.</source>
          <target state="translated">Если &amp;laquo;имя&amp;raquo; - &amp;laquo;&amp;amp;&amp;raquo;, соответствующая запись в PAD представляет собой резюме, представляющее возможное закрытие.</target>
        </trans-unit>
        <trans-unit id="85fe5da8ded285f9f24f40aa84216e564fcc0c0a" translate="yes" xml:space="preserve">
          <source>If the 'name' is &lt;code&gt;&amp;amp;&lt;/code&gt; the corresponding entry in the PAD is a CV representing a possible closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab0adefdbb8eb1bb75234fb2c512e529ae68ac9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;Mozilla::CA&quot;&gt;Mozilla::CA&lt;/a&gt; module is installed, HTTP::Tiny will use the CA file included with it as a source of trusted CA's. (This means you trust Mozilla, the author of Mozilla::CA, the CPAN mirror where you got Mozilla::CA, the toolchain used to install it, and your operating system security, right?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45cb5ded2282f7dcd41dd84a212cb40770ba3961" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;-W&lt;/b&gt; flag is used on the command line, it will enable all warnings throughout the program regardless of whether warnings were disabled locally using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; or &lt;code&gt;$^W =0&lt;/code&gt; . This includes all files that get included via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;. Think of it as the Perl equivalent of the &quot;lint&quot; command.</source>
          <target state="translated">Если в командной строке используется флаг &lt;b&gt;-W&lt;/b&gt; , он включит все предупреждения во всей программе независимо от того, были ли предупреждения отключены локально &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; или &lt;code&gt;$^W =0&lt;/code&gt; . Сюда входят все файлы, которые включаются через &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; . Думайте об этом как о Perl-эквиваленте команды &amp;laquo;lint&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="67f0f299ae6f5832a23754313dcbdf3deeea5b62" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;-W&lt;/b&gt; flag is used on the command line, it will enable all warnings throughout the program regardless of whether warnings were disabled locally using &lt;code&gt;no warnings&lt;/code&gt; or &lt;code&gt;$^W =0&lt;/code&gt;. This includes all files that get included via &lt;code&gt;use&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt;. Think of it as the Perl equivalent of the &quot;lint&quot; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544ad5b88e657a2b04055790eb69377a583771e6" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;ExtUtils::Embed&lt;/b&gt; module isn't part of your Perl distribution, you can retrieve it from &lt;a href=&quot;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&quot;&gt;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&lt;/a&gt; (If this documentation came from your Perl distribution, then you're running 5.004 or better and you already have it.)</source>
          <target state="translated">Если модуль &lt;b&gt;ExtUtils :: Embed&lt;/b&gt; не является частью вашего дистрибутива Perl, вы можете получить его по &lt;a href=&quot;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&quot;&gt;адресу http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&lt;/a&gt; (если эта документация пришла из вашего Дистрибутив Perl, значит, вы используете версию 5.004 или выше и она у вас уже есть.)</target>
        </trans-unit>
        <trans-unit id="e9d6651b3488b419cbb556cfd921ab740de960ba" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;ExtUtils::Embed&lt;/b&gt; module isn't part of your Perl distribution, you can retrieve it from &lt;a href=&quot;https://metacpan.org/pod/ExtUtils::Embed&quot;&gt;https://metacpan.org/pod/ExtUtils::Embed&lt;/a&gt; (If this documentation came from your Perl distribution, then you're running 5.004 or better and you already have it.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e97ddfc26315857071022b6a58a8c5330f9bda" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;-S&quot;&lt;/code&gt; or &lt;code&gt;-&quot;S&quot;&lt;/code&gt; switch is present</source>
          <target state="translated">Если присутствует переключатель &lt;code&gt;&quot;-S&quot;&lt;/code&gt; или &lt;code&gt;-&quot;S&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bcfb6b5f36fe9b097b6d4cfdd0d5b8347d4498d3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;#!&lt;/code&gt; line does not contain the word &quot;perl&quot; nor the word &quot;indir&quot; the program named after the &lt;code&gt;#!&lt;/code&gt; is executed instead of the Perl interpreter. This is slightly bizarre, but it helps people on machines that don't do &lt;code&gt;#!&lt;/code&gt; , because they can tell a program that their SHELL is</source>
          <target state="translated">Если &lt;code&gt;#!&lt;/code&gt; Строка не содержит ни слова &quot;perl&quot;, ни слова &quot;indir&quot; программы, названной после &lt;code&gt;#!&lt;/code&gt; выполняется вместо интерпретатора Perl. Это немного странно, но помогает людям на машинах, которые не делают &lt;code&gt;#!&lt;/code&gt; , потому что они могут сообщить программе, что их ОБОЛОЧКА</target>
        </trans-unit>
        <trans-unit id="604833b3bed6d2cdd6969680b3567a88335ca6e8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;#!&lt;/code&gt; line does not contain the word &quot;perl&quot; nor the word &quot;indir&quot;, the program named after the &lt;code&gt;#!&lt;/code&gt; is executed instead of the Perl interpreter. This is slightly bizarre, but it helps people on machines that don't do &lt;code&gt;#!&lt;/code&gt;, because they can tell a program that their SHELL is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263d47f71006c52e232d04a65727d383732b439a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$Encode::Guess::NoUTFAutoGuess&lt;/code&gt; variable is set to a true value, no heuristics will be applied to UTF8/16/32, and the result will be limited to the suspects and &lt;code&gt;ascii&lt;/code&gt; .</source>
          <target state="translated">Если для переменной &lt;code&gt;$Encode::Guess::NoUTFAutoGuess&lt;/code&gt; установлено истинное значение, эвристика не будет применяться к UTF8 / 16/32 , и результат будет ограничен подозреваемыми и &lt;code&gt;ascii&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="353ab226583ec1c10fd3aef68a690f9c11e31e86" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$Encode::Guess::NoUTFAutoGuess&lt;/code&gt; variable is set to a true value, no heuristics will be applied to UTF8/16/32, and the result will be limited to the suspects and &lt;code&gt;ascii&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad3f883582e4c647a3748b90c080c6161d8d898" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle, the compressed data will be read from it. The string '-' can be used as an alias for standard input.</source>
          <target state="translated">Если параметр &lt;code&gt;$input&lt;/code&gt; является дескриптором файла, сжатые данные будут считываться из него. Строку &amp;laquo;-&amp;raquo; можно использовать как псевдоним для стандартного ввода.</target>
        </trans-unit>
        <trans-unit id="fe51b5d7f895a2847c85f0654d41581417ffbf8a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input&lt;/code&gt; parameter is a filename, the value of &lt;code&gt;$input&lt;/code&gt; will be used for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b21ca0ba17da1de5557b8c2561a39c672e345ba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input&lt;/code&gt; parameter is a scalar, it is assumed to be a filename. This file will be opened for reading and the compressed data will be read from it.</source>
          <target state="translated">Если параметр &lt;code&gt;$input&lt;/code&gt; является скаляром, предполагается, что это имя файла. Этот файл будет открыт для чтения, и из него будут считываться сжатые данные.</target>
        </trans-unit>
        <trans-unit id="f3e74e002fc30cd5c7fe440b4d039e155035cde7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input&lt;/code&gt; parameter is not a filename, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c806bbadc7d9dce5be50aca2c285d39455523f0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter is a filehandle, the input data will be read from it. The string '-' can be used as an alias for standard input.</source>
          <target state="translated">Если параметр &lt;code&gt;$input_filename_or_reference&lt;/code&gt; является дескриптором файла, входные данные будут считываться из него. Строку &amp;laquo;-&amp;raquo; можно использовать как псевдоним для стандартного ввода.</target>
        </trans-unit>
        <trans-unit id="b1c3cf35342f4c34421c4e26433c64dd55c114d3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for reading and the input data will be read from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="573972f31f94bcc5ce697159aca1ad87294adc22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter is any other type, &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">Если параметр &lt;code&gt;$input_filename_or_reference&lt;/code&gt; относится к любому другому типу, будет возвращен &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95490becd5727b45000e58c74b6e1c6ae0970e6a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter is any other type, &lt;code&gt;undef&lt;/code&gt; will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4cccbcdf0c65cc8f40030797afae3d268325f9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$need&lt;/code&gt; argument is given then it will check that the current version (as defined by the $VERSION variable in the package) is greater than or equal to &lt;code&gt;$need&lt;/code&gt; ; it will die if this is not the case. This method is called automatically by the &lt;code&gt;VERSION&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если указан аргумент &lt;code&gt;$need&lt;/code&gt; он проверит, что текущая версия (как определено переменной $ VERSION в пакете) больше или равна &lt;code&gt;$need&lt;/code&gt; ; он умрет, если это не так. Этот метод вызывается автоматически формой &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; &lt;code&gt;VERSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a6a3d7b2f8102b10a0c4c1e7ed04569381bcca7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$need&lt;/code&gt; argument is given then it will check that the current version (as defined by the $VERSION variable in the package) is greater than or equal to &lt;code&gt;$need&lt;/code&gt;; it will die if this is not the case. This method is called automatically by the &lt;code&gt;VERSION&lt;/code&gt; form of &lt;code&gt;use&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e612a8de15e6e3ebce7b57945845f8b7dc29222" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle, the compressed data will be written to it. The string '-' can be used as an alias for standard output.</source>
          <target state="translated">Если параметр &lt;code&gt;$output&lt;/code&gt; является дескриптором файла, в него будут записаны сжатые данные. Строку &amp;laquo;-&amp;raquo; можно использовать как псевдоним для стандартного вывода.</target>
        </trans-unit>
        <trans-unit id="ca1b12c1cf4a15c9b6156dfb74283d87ea201fd5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for writing and the compressed data will be written to it.</source>
          <target state="translated">Если параметр &lt;code&gt;$output&lt;/code&gt; является простым скаляром, предполагается, что это имя файла. Этот файл будет открыт для записи, и в него будут записаны сжатые данные.</target>
        </trans-unit>
        <trans-unit id="59757227a4fe8fdd27a95b595bd3ff8c8a163939" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">Если параметр &lt;code&gt;$output&lt;/code&gt; относится к любому другому типу, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; :: new вернет undef.</target>
        </trans-unit>
        <trans-unit id="837bf156c80a35ed162d613d42ade6562e2894a9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt;::new will return undef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cadc0cd9a0990edba8eef6811ffbf43a8f495bbc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">Если параметр &lt;code&gt;$output&lt;/code&gt; относится к любому другому типу, &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; :: new вернет undef.</target>
        </trans-unit>
        <trans-unit id="196148e89da9cfbfe329bbc55db61beb8a5968d9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Deflate&lt;/code&gt;::new will return undef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e714bc9d0ca60a68f45566881bf3e6145bc1ce5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">Если параметр &lt;code&gt;$output&lt;/code&gt; относится к любому другому типу, &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; :: new вернет undef.</target>
        </trans-unit>
        <trans-unit id="08b9bed1be5f46be48a5455f8dcb9b223a356d8d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Gzip&lt;/code&gt;::new will return undef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876928fea8ebdaa591df8075f9c404fb23d04a28" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">Если параметр &lt;code&gt;$output&lt;/code&gt; относится к любому другому типу, &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; :: new вернет undef.</target>
        </trans-unit>
        <trans-unit id="5fc1018e332332481571232c14a9c9881c4640fa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt;::new will return undef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38552f9e6ec9c67c09d8bddc8275dd8bdd5d8803" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Zip&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">Если параметр &lt;code&gt;$output&lt;/code&gt; имеет любой другой тип, &lt;code&gt;IO::Compress::Zip&lt;/code&gt; :: new вернет undef.</target>
        </trans-unit>
        <trans-unit id="c1b6039aa2ae2d0c506fff4cceb4d05934eba7f6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Zip&lt;/code&gt;::new will return undef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc18113fea92f93f29a91b56f7f76e4dd3fc2c3e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a filehandle, the compressed data will be written to it. The string '-' can be used as an alias for standard output.</source>
          <target state="translated">Если параметр &lt;code&gt;$output_filename_or_reference&lt;/code&gt; является дескриптором файла, сжатые данные будут записаны в него. Строку &amp;laquo;-&amp;raquo; можно использовать как псевдоним для стандартного вывода.</target>
        </trans-unit>
        <trans-unit id="b000e8d3bf3971a53c3d271eb802381bc6b99814" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a filehandle, the uncompressed data will be written to it. The string '-' can be used as an alias for standard output.</source>
          <target state="translated">Если параметр &lt;code&gt;$output_filename_or_reference&lt;/code&gt; является дескриптором файла, в него будут записаны несжатые данные. Строку &amp;laquo;-&amp;raquo; можно использовать как псевдоним для стандартного вывода.</target>
        </trans-unit>
        <trans-unit id="4843925dd2f30aabd060449fee92e5566394585d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for writing and the compressed data will be written to it.</source>
          <target state="translated">Если параметр &lt;code&gt;$output_filename_or_reference&lt;/code&gt; является простым скаляром, предполагается, что это имя файла. Этот файл будет открыт для записи, и в него будут записаны сжатые данные.</target>
        </trans-unit>
        <trans-unit id="82c61471bec0e7ab85ea6d51b841a7cd924bb91c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for writing and the uncompressed data will be written to it.</source>
          <target state="translated">Если параметр &lt;code&gt;$output_filename_or_reference&lt;/code&gt; является простым скаляром, предполагается, что это имя файла. Этот файл будет открыт для записи, и в него будут записаны несжатые данные.</target>
        </trans-unit>
        <trans-unit id="171f6debdc3c19e16dbddc9b4ccb5eb09a1f9e1d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is any other type, &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">Если параметр &lt;code&gt;$output_filename_or_reference&lt;/code&gt; имеет любой другой тип, будет возвращен &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7817f217aafc05c7b99d4b799af6c64aa75fd355" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is any other type, &lt;code&gt;undef&lt;/code&gt; will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2259a2e974894cbf8831f8e74de6dee67d652d9c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$regexp&lt;/code&gt; variable contains a code expression, the user could then execute arbitrary Perl code. For instance, some joker could search for &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;('rm -rf *');&lt;/code&gt; to erase your files. In this sense, the combination of interpolation and code expressions</source>
          <target state="translated">Если переменная &lt;code&gt;$regexp&lt;/code&gt; содержит кодовое выражение, пользователь может выполнить произвольный код Perl. Например, какой-нибудь шутник мог искать &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;('rm -rf *');&lt;/code&gt; чтобы стереть ваши файлы. В этом смысле сочетание интерполяции и кодовых выражений</target>
        </trans-unit>
        <trans-unit id="f36385595fbe40440c2dd4edd9a51197f185c95d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$regexp&lt;/code&gt; variable contains a code expression, the user could then execute arbitrary Perl code. For instance, some joker could search for &lt;code&gt;system('rm -rf *');&lt;/code&gt; to erase your files. In this sense, the combination of interpolation and code expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cead10e67b406c29ab565d567b9609063d5776ca" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a buffer, this method will return &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если объект &lt;code&gt;$z&lt;/code&gt; связан с буфером, этот метод вернет &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e56611d957be7289e8984a9c8a2d5654cbe3409" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a buffer, this method will return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58dcaddb355cecd931c021172a4bedf908dd76a9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a file or a filehandle, &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; will return the underlying file descriptor. Once the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если объект &lt;code&gt;$z&lt;/code&gt; связан с файлом или дескриптором файла, &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; вернет базовый дескриптор файла. После &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; метода &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; fileno вернет &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd0509a249a2be85806909612af8871ff25800ff" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a file or a filehandle, &lt;code&gt;fileno&lt;/code&gt; will return the underlying file descriptor. Once the &lt;code&gt;close&lt;/code&gt; method is called &lt;code&gt;fileno&lt;/code&gt; will return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8acbfda88a1601bef7d039c62529de82f9b15c5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a file or a filehandle, this method returns the current autoflush setting for the underlying filehandle. If &lt;code&gt;EXPR&lt;/code&gt; is present, and is non-zero, it will enable flushing after every write/print operation.</source>
          <target state="translated">Если объект &lt;code&gt;$z&lt;/code&gt; связан с файлом или дескриптором файла, этот метод возвращает текущую настройку автозапуска для базового дескриптора файла. Если &lt;code&gt;EXPR&lt;/code&gt; присутствует и не равен нулю, он будет включать сброс после каждой операции записи / печати.</target>
        </trans-unit>
        <trans-unit id="4f22b38f141c1394908e5c44c3cf641e6013a601" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;(*ACCEPT)&lt;/code&gt; is inside of capturing groups then the groups are marked as ended at the point at which the &lt;code&gt;(*ACCEPT)&lt;/code&gt; was encountered. For instance:</source>
          <target state="translated">Если &lt;code&gt;(*ACCEPT)&lt;/code&gt; находится внутри групп захвата, то группы помечаются как завершенные в точке, в которой обнаружено &lt;code&gt;(*ACCEPT)&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="d96d9f9f8c91a22bdf7e1a3536eeb47596adfe1c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-Strict&lt;/code&gt; option is disabled, the comment field can contain any character except NULL. If any null characters are present, the field will be truncated at the first NULL.</source>
          <target state="translated">Если опция &lt;code&gt;-Strict&lt;/code&gt; отключена, поле комментария может содержать любой символ, кроме NULL. Если присутствуют какие-либо нулевые символы, поле будет обрезано до первого значения NULL.</target>
        </trans-unit>
        <trans-unit id="8a0625a9517209d9c735d420fbb7b372c06cae56" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-Strict&lt;/code&gt; option is enabled, &lt;code&gt;$string&lt;/code&gt; can only consist of ISO 8859-1 characters.</source>
          <target state="translated">Если &lt;code&gt;-Strict&lt;/code&gt; опция -Strict , &lt;code&gt;$string&lt;/code&gt; может состоять только из символов ISO 8859-1.</target>
        </trans-unit>
        <trans-unit id="7e727e67c9a9b626ab111993b625d6fae0b44b5e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-Strict&lt;/code&gt; option is enabled, the comment can only consist of ISO 8859-1 characters plus line feed.</source>
          <target state="translated">Если &lt;code&gt;-Strict&lt;/code&gt; опция -Strict , комментарий может состоять только из символов ISO 8859-1 плюс перевод строки.</target>
        </trans-unit>
        <trans-unit id="687858bb0364e03075315214e49915f4063efd20" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-i&lt;/code&gt; switch is present but no extension for a backup copy is given, then inplace editing creates a new version of a file; the existing copy is not deleted. (Note that if an extension is given, an existing file is renamed to the backup file, as is the case under other operating systems, so it does not remain as a previous version under the original filename.)</source>
          <target state="translated">Если параметр &lt;code&gt;-i&lt;/code&gt; присутствует, но не задано расширение для резервной копии, то при редактировании на месте создается новая версия файла; существующая копия не удаляется. (Обратите внимание, что если задано расширение, существующий файл переименовывается в файл резервной копии, как в случае с другими операционными системами, поэтому он не остается в качестве предыдущей версии под исходным именем файла.)</target>
        </trans-unit>
        <trans-unit id="ee96a00037808dbdc95697095ca0c22513112f61" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-v&lt;/code&gt; option is present, column 1 is expanded to include</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e7588692ec4768237d3953ea6a6c6164462271b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;...Host&lt;/code&gt; argument is in this special form and the corresponding &lt;code&gt;...Service&lt;/code&gt; or &lt;code&gt;...Port&lt;/code&gt; argument is also defined, the one parsed from the &lt;code&gt;...Host&lt;/code&gt; argument will take precedence and the other will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eacdf4c079f427c39ca731549e9ca77acc2ef88" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/a&lt;/code&gt; modifier is in effect ...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e67bdd40f66f8b280f344ca0cd6466ca71728404" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/a&lt;/code&gt; modifier, is in effect ...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a06195ed61d1ad05b053f7cec670bab3d1b47d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/c&lt;/code&gt; modifier is specified, the</source>
          <target state="translated">Если указан модификатор &lt;code&gt;/c&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="d41dfd0659ebb24e37b486d073bb483e95d40816" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/c&lt;/code&gt; modifier is specified, the characters to be transliterated are the ones NOT in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d32f95725bf186859393e8afb0285f817b2b2c4d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/d&lt;/code&gt; modifier is specified, any characters specified by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f363164df63c08b01c2f8d842eb83178238fca" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/d&lt;/code&gt; modifier is used, the</source>
          <target state="translated">Если используется модификатор &lt;code&gt;/d&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="228d53bdcd18fe101fa332b95e05c49d501e9bd9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/g&lt;/code&gt; option is not used, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; in list context returns a list consisting of the subexpressions matched by the parentheses in the pattern, that is, (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; ...) (Note that here &lt;code&gt;$1&lt;/code&gt; etc. are also set). When there are no parentheses in the pattern, the return value is the list &lt;code&gt;(1)&lt;/code&gt; for success. With or without parentheses, an empty list is returned upon failure.</source>
          <target state="translated">Если параметр &lt;code&gt;/g&lt;/code&gt; не используется, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; в контексте списка возвращает список, состоящий из подвыражений, совпадающих с круглыми скобками в шаблоне, то есть ( &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; ...) (Обратите внимание, что здесь &lt;code&gt;$1&lt;/code&gt; и т. Д. также установлены). Если в шаблоне нет скобок, возвращаемое значение - это список &lt;code&gt;(1)&lt;/code&gt; для успеха. В случае ошибки со скобками или без них возвращается пустой список.</target>
        </trans-unit>
        <trans-unit id="4847a17bc99ad2bd83a46004a16f9056518239f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/g&lt;/code&gt; option is not used, &lt;code&gt;m//&lt;/code&gt; in list context returns a list consisting of the subexpressions matched by the parentheses in the pattern, that is, (&lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;...) (Note that here &lt;code&gt;$1&lt;/code&gt; etc. are also set). When there are no parentheses in the pattern, the return value is the list &lt;code&gt;(1)&lt;/code&gt; for success. With or without parentheses, an empty list is returned upon failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f80ef36f0d767bd1b67ec24494f102a4ec7c1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option is present, a new copy of the string is made and its characters transliterated, and this copy is returned no matter whether it was modified or not: the original string is always left unchanged. The new copy is always a plain string, even if the input string is an object or a tied variable.</source>
          <target state="translated">Если присутствует параметр &lt;code&gt;/r&lt;/code&gt; (неразрушающий), создается новая копия строки и ее символы транслитерируются, и эта копия возвращается независимо от того, была ли она изменена или нет: исходная строка всегда остается неизменной. Новая копия всегда является простой строкой, даже если входная строка является объектом или связанной переменной.</target>
        </trans-unit>
        <trans-unit id="a9229f75d9765b6c9e80a754666b4ec3786ce235" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option is used then it runs the substitution on a copy of the string and instead of returning the number of substitutions, it returns the copy whether or not a substitution occurred. The original string is never changed when &lt;code&gt;/r&lt;/code&gt; is used. The copy will always be a plain string, even if the input is an object or a tied variable.</source>
          <target state="translated">Если используется параметр &lt;code&gt;/r&lt;/code&gt; (неразрушающий), то он запускает замену на копии строки и вместо того, чтобы возвращать количество замен, он возвращает копию, независимо от того, произошла ли подстановка. Исходная строка никогда не изменяется при использовании &lt;code&gt;/r&lt;/code&gt; . Копия всегда будет простой строкой, даже если входные данные являются объектом или связанной переменной.</target>
        </trans-unit>
        <trans-unit id="c65b706b15e1b297f5f1c28d84acdcb1bb86c23a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/s&lt;/code&gt; modifier is specified, sequences of characters, all in a row, that were transliterated to the same character are squashed down to a single instance of that character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98015ad9cab949396e11223bb4b809b828f32a12" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ADLER32&lt;/code&gt; option is not enabled in the constructor for this object, this method will always return 0;</source>
          <target state="translated">Если параметр &lt;code&gt;ADLER32&lt;/code&gt; не включен в конструкторе этого объекта, этот метод всегда будет возвращать 0;</target>
        </trans-unit>
        <trans-unit id="e7e3cc3b120420d3fe3e5903cbe74d0d544abd6d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to false, the output buffers in the &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; and &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; methods will be truncated before uncompressed data is written to them.</source>
          <target state="translated">Если для параметра &lt;code&gt;AppendOutput&lt;/code&gt; установлено значение false, буферы вывода в методах &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; и &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; будут усечены перед записью в них несжатых данных.</target>
        </trans-unit>
        <trans-unit id="dc67d2e9493b30b20a1a27f63c6bc36f875e42fb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to true in the constructor for the &lt;code&gt;$d&lt;/code&gt; object, the compressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If it is false, &lt;code&gt;$output&lt;/code&gt; will be truncated before any compressed data is written to it.</source>
          <target state="translated">Если для параметра &lt;code&gt;AppendOutput&lt;/code&gt; установлено значение true в конструкторе объекта &lt;code&gt;$d&lt;/code&gt; , сжатые данные будут добавлены к &lt;code&gt;$output&lt;/code&gt; . Если это false, &lt;code&gt;$output&lt;/code&gt; будет обрезан перед записью в него сжатых данных.</target>
        </trans-unit>
        <trans-unit id="894535f526af30d884a71d76dd392439745e70a6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to true in the constructor for the &lt;code&gt;$d&lt;/code&gt; object, the compressed data will be appended to &lt;code&gt;$output&lt;/code&gt;. If it is false, &lt;code&gt;$output&lt;/code&gt; will be truncated before any compressed data is written to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241ec910d4c3fc198870214959a19e4587117b91" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to true in the constructor for this object, the uncompressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If it is false, &lt;code&gt;$output&lt;/code&gt; will be truncated before any uncompressed data is written to it.</source>
          <target state="translated">Если для параметра &lt;code&gt;AppendOutput&lt;/code&gt; задано значение true в конструкторе этого объекта, несжатые данные будут добавлены в &lt;code&gt;$output&lt;/code&gt; . Если это ложь, &lt;code&gt;$output&lt;/code&gt; будет обрезан перед записью в него несжатых данных.</target>
        </trans-unit>
        <trans-unit id="41b5894e323b1e78083ec3fd1e539c059bbe6e54" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to true in the constructor for this object, the uncompressed data will be appended to &lt;code&gt;$output&lt;/code&gt;. If it is false, &lt;code&gt;$output&lt;/code&gt; will be truncated before any uncompressed data is written to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a4bdafd5b4aee2bfba5a403d17509d788319bb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Archive::Tar&lt;/code&gt; module is installed and either the &lt;code&gt;uncompress&lt;/code&gt; or &lt;code&gt;gunzip&lt;/code&gt; programs are available, you can use one of these workarounds to read &lt;code&gt;.tar.Z&lt;/code&gt; files.</source>
          <target state="translated">Если &lt;code&gt;Archive::Tar&lt;/code&gt; установлен модуль и либо &lt;code&gt;uncompress&lt;/code&gt; или &lt;code&gt;gunzip&lt;/code&gt; программы доступны, вы можете использовать один из этих способов , чтобы читать &lt;code&gt;.tar.Z&lt;/code&gt; файлы.</target>
        </trans-unit>
        <trans-unit id="da717ba776ac7b943780ea377cd85c35cc7f2655" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Bzip2 object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">Если при &lt;code&gt;AutoClose&lt;/code&gt; объекта IO :: Compress :: Bzip2 была включена опция AutoClose , и этот объект связан с файлом, базовый файл также будет закрыт.</target>
        </trans-unit>
        <trans-unit id="2451f14f493fd0c1b2a744f1ca680885802c97fb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Deflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">Если при &lt;code&gt;AutoClose&lt;/code&gt; объекта IO :: Compress :: Deflate была включена опция AutoClose , и этот объект связан с файлом, базовый файл также будет закрыт.</target>
        </trans-unit>
        <trans-unit id="a262cca6ca624ccbcc230f0a9a299f301469ea87" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Gzip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">Если при &lt;code&gt;AutoClose&lt;/code&gt; объекта IO :: Compress :: Gzip была включена опция AutoClose , и этот объект связан с файлом, основной файл также будет закрыт.</target>
        </trans-unit>
        <trans-unit id="e1abc2a1019c01d985ed7b90e95e969f6f299bf2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::RawDeflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">Если опция &lt;code&gt;AutoClose&lt;/code&gt; была включена при создании объекта IO :: Compress :: RawDeflate, и объект был связан с файлом, базовый файл также будет закрыт.</target>
        </trans-unit>
        <trans-unit id="f5ea66329ad2b4187630d779016bfcf01873661d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Zip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">Если при &lt;code&gt;AutoClose&lt;/code&gt; объекта IO :: Compress :: Zip была включена опция AutoClose , и этот объект связан с файлом, основной файл также будет закрыт.</target>
        </trans-unit>
        <trans-unit id="efa0131be286b8ee087293f106c69cc7176b941b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::AnyInflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">Если опция &lt;code&gt;AutoClose&lt;/code&gt; была включена при создании объекта IO :: Uncompress :: AnyInflate, и этот объект связан с файлом, базовый файл также будет закрыт.</target>
        </trans-unit>
        <trans-unit id="d7295924866c46c6268e8a714d1d64a580c31683" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::AnyUncompress object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">Если опция &lt;code&gt;AutoClose&lt;/code&gt; была включена при создании объекта IO :: Uncompress :: AnyUncompress, и этот объект связан с файлом, основной файл также будет закрыт.</target>
        </trans-unit>
        <trans-unit id="d590344cfdd3022553efe336602191d1dbf477b6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Bunzip2 object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">Если при &lt;code&gt;AutoClose&lt;/code&gt; объекта IO :: Uncompress :: Bunzip2 была включена опция AutoClose, и этот объект связан с файлом, основной файл также будет закрыт.</target>
        </trans-unit>
        <trans-unit id="d48a250e20975c54010e5628db4f5baad9a34122" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Gunzip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">Если опция &lt;code&gt;AutoClose&lt;/code&gt; была включена при создании объекта IO :: Uncompress :: Gunzip, и этот объект связан с файлом, основной файл также будет закрыт.</target>
        </trans-unit>
        <trans-unit id="52452c9550cd8363c6c8237af362cc345e53f457" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Inflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">Если опция &lt;code&gt;AutoClose&lt;/code&gt; была включена при создании объекта IO :: Uncompress :: Inflate, и объект был связан с файлом, базовый файл также будет закрыт.</target>
        </trans-unit>
        <trans-unit id="34f0502573716752984911463b9f0d1cdbf46468" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::RawInflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">Если опция &lt;code&gt;AutoClose&lt;/code&gt; была включена при создании объекта IO :: Uncompress :: RawInflate, и объект связан с файлом, базовый файл также будет закрыт.</target>
        </trans-unit>
        <trans-unit id="a4a69474f66acefa05c78e7afea37ef49d0b67b4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Unzip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">Если опция &lt;code&gt;AutoClose&lt;/code&gt; была включена при создании объекта IO :: Uncompress :: Unzip, и объект связан с файлом, базовый файл также будет закрыт.</target>
        </trans-unit>
        <trans-unit id="94bf536d1f0d5c1626e7c3b73aa7b49722d0966b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; bit is set in &lt;code&gt;gflags&lt;/code&gt; then it indicates that the caller only knows about the genuine GV version of &lt;code&gt;namegv&lt;/code&gt;, and accordingly the corresponding bit will always be set in &lt;code&gt;*ckflags_p&lt;/code&gt;, regardless of the check function's recorded requirements. If the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; bit is clear in &lt;code&gt;gflags&lt;/code&gt; then it indicates the caller knows about the possibility of passing something other than a GV as &lt;code&gt;namegv&lt;/code&gt;, and accordingly the corresponding bit may be either set or clear in &lt;code&gt;*ckflags_p&lt;/code&gt;, indicating the check function's recorded requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c82a8f9dcfd859cf531bf1cebfe4f1f3355707c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CPAN_META_JSON_BACKEND&lt;/code&gt; environment variable does not exist, and if &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; environment variable exists, is true and is not &quot;JSON::PP&quot;, then the &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; module (version 2.5 or greater) will be loaded and used to interpret &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt;. If &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; is not installed or is too old, an exception will be thrown. Note that at the time of writing, the only useful values are 1, which will tell &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; to guess, or &lt;a href=&quot;JSON::XS&quot;&gt;JSON::XS&lt;/a&gt; - if you want to use a newer JSON module, see &lt;a href=&quot;#CPAN_META_JSON_BACKEND&quot;&gt;&quot;CPAN_META_JSON_BACKEND&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ac2a9fbc05192cf46afe1261683a81419aaa4d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CRC32&lt;/code&gt; option is not enabled in the constructor for this object, this method will always return 0;</source>
          <target state="translated">Если опция &lt;code&gt;CRC32&lt;/code&gt; не включена в конструкторе для этого объекта, этот метод всегда будет возвращать 0;</target>
        </trans-unit>
        <trans-unit id="1078abcc96e5bc5e00a4c013f64ebcf42ad64647" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ConsumeInput&lt;/code&gt; option has been set to true when the &lt;code&gt;Compress::Raw::Zlib::Inflate&lt;/code&gt; object is created, the &lt;code&gt;$input&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt; . On completion it will contain what remains of the input buffer after inflation. In practice, this means that when the return status is &lt;code&gt;Z_OK&lt;/code&gt; the &lt;code&gt;$input&lt;/code&gt; parameter will contain an empty string, and when the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$input&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="translated">Если для параметра &lt;code&gt;ConsumeInput&lt;/code&gt; было установлено значение true при создании объекта &lt;code&gt;Compress::Raw::Zlib::Inflate&lt;/code&gt; , параметр &lt;code&gt;$input&lt;/code&gt; изменяется с помощью &lt;code&gt;inflate&lt;/code&gt; . По завершении он будет содержать то, что осталось от входного буфера после инфляции. На практике это означает, что когда статус возврата - &lt;code&gt;Z_OK&lt;/code&gt; , параметр &lt;code&gt;$input&lt;/code&gt; будет содержать пустую строку, а когда статус возврата - &lt;code&gt;Z_STREAM_END&lt;/code&gt; , параметр &lt;code&gt;$input&lt;/code&gt; будет содержать то, что (если что-то) было сохранено во входном буфере после дефлированных данных. поток.</target>
        </trans-unit>
        <trans-unit id="fc67951579ca54e84043acbb0bb761bab4628359" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ConsumeInput&lt;/code&gt; option has been set to true when the &lt;code&gt;Compress::Raw::Zlib::Inflate&lt;/code&gt; object is created, the &lt;code&gt;$input&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt;. On completion it will contain what remains of the input buffer after inflation. In practice, this means that when the return status is &lt;code&gt;Z_OK&lt;/code&gt; the &lt;code&gt;$input&lt;/code&gt; parameter will contain an empty string, and when the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$input&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a12981a50e52bd8360e58342fda216fd19888ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Encode::LEAVE_SRC&lt;/code&gt; bit is</source>
          <target state="translated">Если бит &lt;code&gt;Encode::LEAVE_SRC&lt;/code&gt; установлен</target>
        </trans-unit>
        <trans-unit id="62a22e2f1c67e582e14dc75490b36c8927949628" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;G_METHOD&lt;/code&gt; flag is supplied, the SV may be a reference to a CV or &lt;code&gt;SvPV(sv)&lt;/code&gt; will be used as the name of the method to call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60434689d4799ff053da9df2280e53454e60d84f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;G_METHOD_NAMED&lt;/code&gt; flag is supplied, &lt;code&gt;SvPV(sv)&lt;/code&gt; will be used as the name of the method to call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd3991b928d2bed7eef1e209952394cc1a3b16f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Listen&lt;/code&gt; argument is given, but false, the queue size will be set to 5.</source>
          <target state="translated">Если аргумент &lt;code&gt;Listen&lt;/code&gt; задан, но false, размер очереди будет равен 5.</target>
        </trans-unit>
        <trans-unit id="1143100ee61e97ea2197747ccc58abb62c39ba7a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Minimal&lt;/code&gt; option is set to true, this option will be ignored.</source>
          <target state="translated">Если для параметра &lt;code&gt;Minimal&lt;/code&gt; установлено значение true, этот параметр будет проигнорирован.</target>
        </trans-unit>
        <trans-unit id="9ef4eef7ec7365669f7a6fdd21df15f840876c21" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PERL_PV_PRETTY_ELLIPSES&lt;/code&gt; flag is set and not all characters in string were output then an ellipsis &lt;code&gt;...&lt;/code&gt; will be appended to the string. Note that this happens AFTER it has been quoted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49e3d7b68bb44fc1098b8d656037c9de9b76dfb2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PERL_PV_PRETTY_QUOTE&lt;/code&gt; flag is set then the result will be double quoted with any double quotes in the string escaped. Otherwise if the &lt;code&gt;PERL_PV_PRETTY_LTGT&lt;/code&gt; flag is set then the result be wrapped in angle brackets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113ffd5bd789ac46d3a6013680e6ad870731e0ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;REQUEST_METHOD&lt;/code&gt; environment variable is set, then this might be a CGI process and &lt;code&gt;HTTP_PROXY&lt;/code&gt; would be set from the &lt;code&gt;Proxy:&lt;/code&gt; header, which is a security risk. If &lt;code&gt;REQUEST_METHOD&lt;/code&gt; is set, &lt;code&gt;HTTP_PROXY&lt;/code&gt; (the upper case variant only) is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0cd9b590461a3324fa8fa68396f36ebee97301" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Strict&lt;/code&gt; is on it will automatically enable this option.</source>
          <target state="translated">Если &lt;code&gt;Strict&lt;/code&gt; он автоматически включит эту опцию.</target>
        </trans-unit>
        <trans-unit id="1a5a03dfea212cb5b29a1fbf2d5e717d48359451" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;YAML&lt;/code&gt; or the &lt;code&gt;YAML::Syck&lt;/code&gt; module is installed a record of the internal state of all modules is written to disk after each step. The files contain a signature of the currently running perl version for later perusal.</source>
          <target state="translated">Если установлен модуль &lt;code&gt;YAML&lt;/code&gt; или &lt;code&gt;YAML::Syck&lt;/code&gt; запись внутреннего состояния всех модулей записывается на диск после каждого шага. Файлы содержат подпись текущей версии Perl для последующего изучения.</target>
        </trans-unit>
        <trans-unit id="c82a6fc0a2f95bf7629d02360284d3c7a1ca8a6f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;can&lt;/code&gt; returns false, then that is passed to &lt;code&gt;ok&lt;/code&gt; . If it returns true, then the larger expression &lt;code&gt;$thingy-&amp;gt;can('some_method') &amp;amp;&amp;amp; 1&lt;/code&gt; returns 1, which &lt;code&gt;ok&lt;/code&gt; sees as a simple signal of success, as you would expect.</source>
          <target state="translated">Если &lt;code&gt;can&lt;/code&gt; возвращает false, то это передается в &lt;code&gt;ok&lt;/code&gt; . Если она возвращает значение ИСТИНА, то большее выражение &lt;code&gt;$thingy-&amp;gt;can('some_method') &amp;amp;&amp;amp; 1&lt;/code&gt; возвращает 1, который &lt;code&gt;ok&lt;/code&gt; видит , как простой сигнал успеха, как и следовало ожидать.</target>
        </trans-unit>
        <trans-unit id="876835f5a189b420b4b1dda2b457e7a93555e339" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;can&lt;/code&gt; returns false, then that is passed to &lt;code&gt;ok&lt;/code&gt;. If it returns true, then the larger expression &lt;code&gt;$thingy-&amp;gt;can('some_method') &amp;amp;&amp;amp; 1&lt;/code&gt; returns 1, which &lt;code&gt;ok&lt;/code&gt; sees as a simple signal of success, as you would expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb03363c1cc83c40db7187bc0c1808c11643507" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;charscript()&lt;/code&gt; argument is not a known script, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если аргумент &lt;code&gt;charscript()&lt;/code&gt; неизвестен сценарию, возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ecb007ef4038a90f65cf1dae4d321b995b3815d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;charscript()&lt;/code&gt; argument is not a known script, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc210b43b03b8ee41f920df8c0e913cce7e9cdb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;content&lt;/code&gt; option is a code reference, it will be called iteratively to provide the content body of the request. It should return the empty string or undef when the iterator is exhausted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7688f4c054c95562671f461204e8d1909c8763" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;content&lt;/code&gt; option is the empty string, no &lt;code&gt;content-type&lt;/code&gt; or &lt;code&gt;content-length&lt;/code&gt; headers will be generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6115ecc6df609b525cd058a3289a9b186700a5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;data_callback&lt;/code&gt; option is provided, it will be called iteratively until the entire response body is received. The first argument will be a string containing a chunk of the response body, the second argument will be the in-progress response hash reference, as described below. (This allows customizing the action of the callback based on the &lt;code&gt;status&lt;/code&gt; or &lt;code&gt;headers&lt;/code&gt; received prior to the content body.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15aaa040db904ad0d7e939ff87d0289e4ed113e7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;decimal string --&amp;gt; native integer&lt;/code&gt; conversion cannot be done without loss of information, the result is compatible with the conversion sequence &lt;code&gt;decimal_string --&amp;gt; native_floating_point --&amp;gt; native_integer&lt;/code&gt; . In particular, rounding is strongly biased to 0, though a number like &lt;code&gt;&quot;0.99999999999999999999&quot;&lt;/code&gt; has a chance of being rounded to 1.</source>
          <target state="translated">Если &lt;code&gt;decimal string --&amp;gt; native integer&lt;/code&gt; преобразование не может быть выполнено без потери информации, результат совместим с последовательностью преобразования &lt;code&gt;decimal_string --&amp;gt; native_floating_point --&amp;gt; native_integer&lt;/code&gt; . В частности, округление сильно смещено до 0, хотя такое число, как &lt;code&gt;&quot;0.99999999999999999999&quot;&lt;/code&gt; может быть округлено до 1.</target>
        </trans-unit>
        <trans-unit id="c844a354fc5d5e3ba8448bfcc0461c2e96ef53fc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;decimal string --&amp;gt; native integer&lt;/code&gt; conversion cannot be done without loss of information, the result is compatible with the conversion sequence &lt;code&gt;decimal_string --&amp;gt; native_floating_point --&amp;gt; native_integer&lt;/code&gt;. In particular, rounding is strongly biased to 0, though a number like &lt;code&gt;&quot;0.99999999999999999999&quot;&lt;/code&gt; has a chance of being rounded to 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4484ac7779a53de50aea47a7a5981f680fda36" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;encoding&lt;/code&gt; pragma is in scope then the lengths returned are calculated from the length of &lt;code&gt;$/&lt;/code&gt; in Unicode characters, which is not always the same as the length of &lt;code&gt;$/&lt;/code&gt; in the native encoding.</source>
          <target state="translated">Если прагма &lt;code&gt;encoding&lt;/code&gt; находится в области видимости, то возвращаемые длины вычисляются из длины &lt;code&gt;$/&lt;/code&gt; в символах Юникода, которая не всегда совпадает с длиной &lt;code&gt;$/&lt;/code&gt; в собственной кодировке.</target>
        </trans-unit>
        <trans-unit id="bb917cbee0d97141aac38b7ae445c57c18b27f43" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;export_fail&lt;/code&gt; method returns an empty list then no error is recorded and all the requested symbols are exported. If the returned list is not empty then an error is generated for each symbol and the export fails. The Exporter provides a default &lt;code&gt;export_fail&lt;/code&gt; method which simply returns the list unchanged.</source>
          <target state="translated">Если метод &lt;code&gt;export_fail&lt;/code&gt; возвращает пустой список, то ошибка не записывается и все запрошенные символы экспортируются. Если возвращенный список не пуст, для каждого символа генерируется ошибка и экспорт не выполняется. Экспортер предоставляет метод по умолчанию &lt;code&gt;export_fail&lt;/code&gt; , который просто возвращает список без изменений.</target>
        </trans-unit>
        <trans-unit id="276362d098a443c72a3870f2a2d48ae260499ef9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gv&lt;/code&gt; is present and is not in the symbol table, then this function simply returns. This checked will be skipped if &lt;code&gt;flags &amp;amp; 1&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;gv&lt;/code&gt; присутствует и его нет в таблице символов, эта функция просто возвращается. Этот флажок будет пропущен, если &lt;code&gt;flags &amp;amp; 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9956d32eb4cf510432b5c2113065ce4d2ab05fcd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gv&lt;/code&gt; is present and is not in the symbol table, then this function simply returns. This checked will be skipped if &lt;code&gt;flags &amp;amp; 1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798f35bb0e17493f55f47f1e0e601507174d7021" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;maxdepth&lt;/code&gt; is included, it must be a numeral</source>
          <target state="translated">Если &lt;code&gt;maxdepth&lt;/code&gt; , она должна быть числовой.</target>
        </trans-unit>
        <trans-unit id="58bc648a8e07d1ab46d67c368d31d1e61d6eb6fc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;realpath&lt;/code&gt; function is not available, or is unable to return the real path of the file, &lt;code&gt;unixrealpath&lt;/code&gt; will use the same internal procedure as the &lt;code&gt;vmsrealpath&lt;/code&gt; function and convert the output to a Unix format specification. It is not available on non-VMS systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622e9bbb1973cba189a5047eab876b3fea0127f4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;table&lt;/code&gt; attribute (see below) is set then a renderer may choose to display the table instead of the details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4672f4a6483db1b05eeb609d8e652aab384c295c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;timelocal()&lt;/code&gt; function is given a non-existent local time, it will simply return an epoch value for the time one hour later.</source>
          <target state="translated">Если функции &lt;code&gt;timelocal()&lt;/code&gt; задано несуществующее местное время, она просто вернет значение эпохи для времени на час позже.</target>
        </trans-unit>
        <trans-unit id="d8b1721e1ae657f367e4018c29dc66b147cf1c09" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;uncompress&lt;/code&gt; or &lt;code&gt;gunzip&lt;/code&gt; programs are available, you can use one of these workarounds to read &lt;code&gt;.tar.Z&lt;/code&gt; files from &lt;code&gt;Archive::Tar&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;uncompress&lt;/code&gt; или &lt;code&gt;gunzip&lt;/code&gt; программы доступны, вы можете использовать один из этих способов , чтобы читать &lt;code&gt;.tar.Z&lt;/code&gt; файлы из &lt;code&gt;Archive::Tar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cddc99dbc25aed0c730c0fe2bb39cef906b6e6a7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;unicode_eval&lt;/code&gt; feature is enabled (which is the default under a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; or higher declaration), EXPR or &lt;code&gt;$_&lt;/code&gt; is treated as a string of characters, so &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declarations have no effect, and source filters are forbidden. In the absence of the &lt;code&gt;unicode_eval&lt;/code&gt; feature, the string will sometimes be treated as characters and sometimes as bytes, depending on the internal encoding, and source filters activated within the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; exhibit the erratic, but historical, behaviour of affecting some outer file scope that is still compiling. See also the &lt;a href=&quot;#evalbytes&quot;&gt;evalbytes&lt;/a&gt; keyword, which always treats its input as a byte stream and works properly with source filters, and the &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; pragma.</source>
          <target state="translated">Если функция &lt;code&gt;unicode_eval&lt;/code&gt; включена (что является значением по умолчанию при объявлении &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; или более поздней версии ), EXPR или &lt;code&gt;$_&lt;/code&gt; обрабатываются как строка символов, поэтому объявления &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; не имеют эффекта, а исходные фильтры запрещены. В отсутствие функции &lt;code&gt;unicode_eval&lt;/code&gt; строка иногда будет обрабатываться как символы, а иногда как байты, в зависимости от внутренней кодировки, а исходные фильтры, активированные в &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , демонстрируют неустойчивое, но историческое поведение, влияющее на некоторую внешнюю область действия файла, которая является все еще компилируется. См. Также &lt;a href=&quot;#evalbytes&quot;&gt;evalbytes&lt;/a&gt;ключевое слово, которое всегда обрабатывает свой ввод как поток байтов и правильно работает с исходными фильтрами, а также директиву &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87e45908e093ce58a5e789307a68cc9a88437767" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;unicode_eval&lt;/code&gt; feature is enabled (which is the default under a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; or higher declaration), EXPR or &lt;code&gt;$_&lt;/code&gt; is treated as a string of characters, so &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declarations have no effect, and source filters are forbidden. In the absence of the &lt;code&gt;unicode_eval&lt;/code&gt; feature, the string will sometimes be treated as characters and sometimes as bytes, depending on the internal encoding, and source filters activated within the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; exhibit the erratic, but historical, behaviour of affecting some outer file scope that is still compiling. See also the &lt;a href=&quot;evalbytes&quot;&gt;evalbytes&lt;/a&gt; keyword, which always treats its input as a byte stream and works properly with source filters, and the &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; pragma.</source>
          <target state="translated">Если функция &lt;code&gt;unicode_eval&lt;/code&gt; включена (что является значением по умолчанию при объявлении &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; или более поздней версии ), EXPR или &lt;code&gt;$_&lt;/code&gt; обрабатываются как строка символов, поэтому объявления &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; не имеют эффекта, а исходные фильтры запрещены. В отсутствие функции &lt;code&gt;unicode_eval&lt;/code&gt; строка иногда будет обрабатываться как символы, а иногда как байты, в зависимости от внутренней кодировки, а исходные фильтры, активированные в &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , демонстрируют неустойчивое, но историческое поведение, влияющее на некоторую внешнюю область действия файла, которая является все еще компилируется. См. Также &lt;a href=&quot;evalbytes&quot;&gt;evalbytes&lt;/a&gt;ключевое слово, которое всегда обрабатывает свой ввод как поток байтов и правильно работает с исходными фильтрами, а также директиву &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="094a307e3b02182e7190ab8c7d41908a31be7b6f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;utf8&lt;/code&gt; option is not given, the encoding of its output file handle will be forced to the detected encoding of the input POD, which preserves whatever the input text is. This ensures backward compatibility with earlier, pre-Unicode versions of this module, without large numbers of Perl warnings.</source>
          <target state="translated">Если опция &lt;code&gt;utf8&lt;/code&gt; не указана, кодировка его дескриптора выходного файла будет принудительно соответствовать обнаруженной кодировке входного POD, которая сохраняет любой входной текст. Это обеспечивает обратную совместимость с более ранними версиями этого модуля, предшествующими Unicode, без большого количества предупреждений Perl.</target>
        </trans-unit>
        <trans-unit id="9d9b06ad91f4e14141b1e47f8d38395a6c62e787" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;utf8&lt;/code&gt;-flag is enabled, &lt;code&gt;encode&lt;/code&gt;/&lt;code&gt;decode&lt;/code&gt; will encode all characters using the corresponding UTF-8 multi-byte sequence, and will expect your input strings to be encoded as UTF-8, that is, no &quot;character&quot; of the input string must have any value &amp;gt; 255, as UTF-8 does not allow that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5abb9df31ef6516fcae104f653339d0026bd9e0" translate="yes" xml:space="preserve">
          <source>If the AIX Toolbox version of lib gdbm &amp;lt; 1.8.3-5 is installed on your system then Perl will not work. This library contains the header files /opt/freeware/include/gdbm/dbm.h|ndbm.h which conflict with the AIX system versions. The lib gdbm will be automatically removed from the wanted libraries if the presence of one of these two header files is detected. If you want to build Perl with GDBM support then please install at least gdbm-devel-1.8.3-5 (or higher).</source>
          <target state="translated">Если в вашей системе установлена ​​версия lib gdbm &amp;lt;1.8.3-5 для AIX Toolbox, Perl работать не будет. Эта библиотека содержит файлы заголовков /opt/freeware/include/gdbm/dbm.h|ndbm.h, которые конфликтуют с версиями системы AIX. Lib gdbm будет автоматически удален из требуемых библиотек, если будет обнаружен один из этих двух файлов заголовков. Если вы хотите собрать Perl с поддержкой GDBM, установите по крайней мере gdbm-devel-1.8.3-5 (или выше).</target>
        </trans-unit>
        <trans-unit id="e4f37200eb3cc7a4dd0c87959fbb6c2e093e138e" translate="yes" xml:space="preserve">
          <source>If the C function setvbuf() is available, then &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; sets the buffering policy for the FileHandle. The calling sequence for the Perl function is the same as its C counterpart, including the macros &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; , and &lt;code&gt;_IONBF&lt;/code&gt; , except that the buffer parameter specifies a scalar variable to use as a buffer. WARNING: A variable used as a buffer by &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; must not be modified in any way until the FileHandle is closed or until &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; is called again, or memory corruption may result!</source>
          <target state="translated">Если C-функция setvbuf () доступна, тогда &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; устанавливает политику буферизации для FileHandle. Последовательность вызова функции Perl такая же, как и у ее аналога в C, включая макросы &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; и &lt;code&gt;_IONBF&lt;/code&gt; , за исключением того, что параметр buffer указывает скалярную переменную для использования в качестве буфера. ВНИМАНИЕ: переменную, используемую &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; в качестве буфера, нельзя изменять каким-либо образом, пока FileHandle не будет закрыт или пока &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; будет вызван снова, иначе это может привести к повреждению памяти!</target>
        </trans-unit>
        <trans-unit id="299d706db577fab624c88622bc091e3abdb77143" translate="yes" xml:space="preserve">
          <source>If the C function setvbuf() is available, then &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; sets the buffering policy for the FileHandle. The calling sequence for the Perl function is the same as its C counterpart, including the macros &lt;code&gt;_IOFBF&lt;/code&gt;, &lt;code&gt;_IOLBF&lt;/code&gt;, and &lt;code&gt;_IONBF&lt;/code&gt;, except that the buffer parameter specifies a scalar variable to use as a buffer. WARNING: A variable used as a buffer by &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; must not be modified in any way until the FileHandle is closed or until &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; is called again, or memory corruption may result!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7ae4abb775cdaecaa965021a5be89b2c2a0678" translate="yes" xml:space="preserve">
          <source>If the C functions fgetpos() and fsetpos() are available, then &lt;code&gt;FileHandle::getpos&lt;/code&gt; returns an opaque value that represents the current position of the FileHandle, and &lt;code&gt;FileHandle::setpos&lt;/code&gt; uses that value to return to a previously visited position.</source>
          <target state="translated">Если доступны функции C fgetpos () и fsetpos (), тогда &lt;code&gt;FileHandle::getpos&lt;/code&gt; возвращает непрозрачное значение, которое представляет текущую позицию FileHandle, а &lt;code&gt;FileHandle::setpos&lt;/code&gt; использует это значение для возврата к ранее посещенной позиции.</target>
        </trans-unit>
        <trans-unit id="50ebbabfe865d409f0b42636c02f4e83fa99aca9" translate="yes" xml:space="preserve">
          <source>If the C functions setbuf() and/or setvbuf() are available, then &lt;code&gt;IO::Handle::setbuf&lt;/code&gt; and &lt;code&gt;IO::Handle::setvbuf&lt;/code&gt; set the buffering policy for an IO::Handle. The calling sequences for the Perl functions are the same as their C counterparts--including the constants &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; , and &lt;code&gt;_IONBF&lt;/code&gt; for setvbuf()--except that the buffer parameter specifies a scalar variable to use as a buffer. You should only change the buffer before any I/O, or immediately after calling flush.</source>
          <target state="translated">Если функции C setbuf () и / или setvbuf () доступны, то &lt;code&gt;IO::Handle::setbuf&lt;/code&gt; и &lt;code&gt;IO::Handle::setvbuf&lt;/code&gt; задают политику буферизации для IO :: Handle. Последовательности вызовов функций Perl такие же, как и их аналоги в C, включая константы &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; и &lt;code&gt;_IONBF&lt;/code&gt; для setvbuf (), за исключением того, что параметр buffer указывает скалярную переменную для использования в качестве буфера. Вы должны изменять буфер только перед любым вводом-выводом или сразу после вызова flush.</target>
        </trans-unit>
        <trans-unit id="4b39a4db83d5ceb015a67a35d8f623bb0eb08d0e" translate="yes" xml:space="preserve">
          <source>If the C functions setbuf() and/or setvbuf() are available, then &lt;code&gt;IO::Handle::setbuf&lt;/code&gt; and &lt;code&gt;IO::Handle::setvbuf&lt;/code&gt; set the buffering policy for an IO::Handle. The calling sequences for the Perl functions are the same as their C counterparts--including the constants &lt;code&gt;_IOFBF&lt;/code&gt;, &lt;code&gt;_IOLBF&lt;/code&gt;, and &lt;code&gt;_IONBF&lt;/code&gt; for setvbuf()--except that the buffer parameter specifies a scalar variable to use as a buffer. You should only change the buffer before any I/O, or immediately after calling flush.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7a6c24ac237588ebe82997b3227d4077970889" translate="yes" xml:space="preserve">
          <source>If the FHCRC bit is set in the gzip FLG header byte, the CRC16 bytes in the header must match the crc16 value of the gzip header actually read.</source>
          <target state="translated">Если бит FHCRC установлен в байте заголовка gzip FLG,то CRC16 байт в заголовке должен совпадать со значением crc16 фактически прочитанного заголовка gzip.</target>
        </trans-unit>
        <trans-unit id="716df9a8cd6dfb775c171f4188701d3aabf993bd" translate="yes" xml:space="preserve">
          <source>If the PATTERN contains &lt;a href=&quot;../perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;capturing groups&lt;/a&gt;, then for each separator, an additional field is produced for each substring captured by a group (in the order in which the groups are specified, as per &lt;a href=&quot;../perlretut#Backreferences&quot;&gt;backreferences&lt;/a&gt;); if any group does not match, then it captures the &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value instead of a substring. Also, note that any such additional field is produced whenever there is a separator (that is, whenever a split occurs), and such an additional field does &lt;b&gt;not&lt;/b&gt; count towards the LIMIT. Consider the following expressions evaluated in list context (each returned list is provided in the associated comment):</source>
          <target state="translated">Если ШАБЛОН содержит &lt;a href=&quot;../perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;группы захвата&lt;/a&gt; , то для каждого разделителя создается дополнительное поле для каждой подстроки, захваченной группой (в том порядке, в котором группы указаны, согласно &lt;a href=&quot;../perlretut#Backreferences&quot;&gt;обратным ссылкам&lt;/a&gt; ); если какая-либо группа не соответствует, то вместо подстроки перехватывается значение &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Также обратите внимание, что любое такое дополнительное поле создается всякий раз, когда есть разделитель (то есть всякий раз, когда происходит разделение), и такое дополнительное поле &lt;b&gt;не&lt;/b&gt; учитывается в LIMIT. Рассмотрим следующие выражения, оцениваемые в контексте списка (каждый возвращенный список предоставляется в соответствующем комментарии):</target>
        </trans-unit>
        <trans-unit id="19ac8a832643510531c14e9722a2a956f43fd56c" translate="yes" xml:space="preserve">
          <source>If the PATTERN contains &lt;a href=&quot;perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;capturing groups&lt;/a&gt;, then for each separator, an additional field is produced for each substring captured by a group (in the order in which the groups are specified, as per &lt;a href=&quot;perlretut#Backreferences&quot;&gt;backreferences&lt;/a&gt;); if any group does not match, then it captures the &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; value instead of a substring. Also, note that any such additional field is produced whenever there is a separator (that is, whenever a split occurs), and such an additional field does &lt;b&gt;not&lt;/b&gt; count towards the LIMIT. Consider the following expressions evaluated in list context (each returned list is provided in the associated comment):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d842f2ab3731c9a4a0e7946b2b84aa92b80adc" translate="yes" xml:space="preserve">
          <source>If the PATTERN contains &lt;a href=&quot;perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;capturing groups&lt;/a&gt;, then for each separator, an additional field is produced for each substring captured by a group (in the order in which the groups are specified, as per &lt;a href=&quot;perlretut#Backreferences&quot;&gt;backreferences&lt;/a&gt;); if any group does not match, then it captures the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value instead of a substring. Also, note that any such additional field is produced whenever there is a separator (that is, whenever a split occurs), and such an additional field does &lt;b&gt;not&lt;/b&gt; count towards the LIMIT. Consider the following expressions evaluated in list context (each returned list is provided in the associated comment):</source>
          <target state="translated">Если ШАБЛОН содержит &lt;a href=&quot;perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;группы захвата&lt;/a&gt; , то для каждого разделителя создается дополнительное поле для каждой подстроки, захваченной группой (в том порядке, в котором группы указаны, согласно &lt;a href=&quot;perlretut#Backreferences&quot;&gt;обратным ссылкам&lt;/a&gt; ); если какая-либо группа не соответствует, то вместо подстроки перехватывается значение &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Также обратите внимание, что любое такое дополнительное поле создается всякий раз, когда есть разделитель (то есть всякий раз, когда происходит разделение), и такое дополнительное поле &lt;b&gt;не&lt;/b&gt; учитывается в LIMIT. Рассмотрим следующие выражения, оцениваемые в контексте списка (каждый возвращенный список предоставляется в соответствующем комментарии):</target>
        </trans-unit>
        <trans-unit id="4e7443d40abaa23829b9ab709311a1922fe461b6" translate="yes" xml:space="preserve">
          <source>If the PERL_PV_PRETTY_ELLIPSES flag is set and not all characters in string were output then an ellipsis &lt;code&gt;...&lt;/code&gt; will be appended to the string. Note that this happens AFTER it has been quoted.</source>
          <target state="translated">Если установлен флаг PERL_PV_PRETTY_ELLIPSES и не все символы в строке были выведены, то к строке будет добавлено многоточие &lt;code&gt;...&lt;/code&gt; Обратите внимание, что это происходит ПОСЛЕ того, как оно было процитировано.</target>
        </trans-unit>
        <trans-unit id="09680d261a6a88f2e5836c919a2510509957b1e5" translate="yes" xml:space="preserve">
          <source>If the PERL_PV_PRETTY_QUOTE flag is set then the result will be double quoted with any double quotes in the string escaped. Otherwise if the PERL_PV_PRETTY_LTGT flag is set then the result be wrapped in angle brackets.</source>
          <target state="translated">Если установлен флаг PERL_PV_PRETTY_QUOTE,то результат будет двойной кавычкой с любыми двойными кавычками в экранированной строке.В противном случае,если установлен флаг PERL_PV_PRETTY_LTGT,то результат будет заключен в угловые скобки.</target>
        </trans-unit>
        <trans-unit id="b990fe2846203877eedfbcf554045c1e773431f8" translate="yes" xml:space="preserve">
          <source>If the POD is inconsistent about the indentation of verbatim blocks, but you have figured out a heuristic to determine how much a particular verbatim block is indented, you can pass a code reference instead. The code reference will be executed with one argument, an array reference of all the lines in the verbatim block, and should return the value to be stripped from each line. For example, if you decide that you're fine to use the first line of the verbatim block to set the standard for indentation of the rest of the block, you can look at the first line and return the appropriate value, like so:</source>
          <target state="translated">Если POD непоследователен в отношении отступов дословных блоков,но вы разобрались в эвристике,чтобы определить,насколько сильно отпечатан конкретный дословный блок,вы можете передать вместо него ссылку на код.Ссылка на код будет выполнена с одним аргументом-ссылкой на массив всех строк в дословном блоке,и должна вернуть значение,которое нужно удалить из каждой строки.Например,если вы решили,что можно использовать первую строку дословного блока для задания стандарта отступов от остальной части блока,вы можете посмотреть на первую строку и вернуть соответствующее значение,подобно этому:</target>
        </trans-unit>
        <trans-unit id="d38f09a374f3f254883a79ac66d4d89714b8faea" translate="yes" xml:space="preserve">
          <source>If the POD source does not include an &lt;code&gt;=encoding&lt;/code&gt; declaration, the parser will attempt to guess the encoding (selecting one of UTF-8 or CP 1252) by examining the first non-ASCII bytes and applying the heuristic described in &lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;. (If the POD source contains only ASCII bytes, the encoding is assumed to be ASCII.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9fd97e2c853d040e2b1f08382eba5acd7317a9d" translate="yes" xml:space="preserve">
          <source>If the POD source does not include an &lt;code&gt;=encoding&lt;/code&gt; declaration, the parser will attempt to guess the encoding (selecting one of UTF-8 or Latin-1) by examining the first non-ASCII bytes and applying the heuristic described in &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;.</source>
          <target state="translated">Если источник POD не включает объявление &lt;code&gt;=encoding&lt;/code&gt; , синтаксический анализатор попытается угадать кодировку (выбрав один из UTF-8 или Latin-1), проверив первые байты, отличные от ASCII, и применив эвристику, описанную в &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="539121ee50a224917b8fad7fe828de50a4356761" translate="yes" xml:space="preserve">
          <source>If the POD you're parsing adheres to a consistent indentation policy, you can have such indentation stripped from the beginning of every line of your verbatim blocks. This method tells Pod::Simple what to strip. For two-space indents, you'd use:</source>
          <target state="translated">Если POD,который вы разбираете,придерживается последовательной политики отпечатков,вы можете удалить такой отпечаток с начала каждой строки ваших дословных блоков.Этот метод говорит Pod::Простое,что нужно удалить.Для двухпространственных отступов вы бы использовали:</target>
        </trans-unit>
        <trans-unit id="41c4b629a3e2e0346fc506d9a6f6a02afa0eab8b" translate="yes" xml:space="preserve">
          <source>If the PV of the SV is an octet sequence in Perl's extended UTF-8 and contains a multiple-byte character, the &lt;code&gt;SvUTF8&lt;/code&gt; flag is turned on so that it looks like a character. If the PV contains only single-byte characters, the &lt;code&gt;SvUTF8&lt;/code&gt; flag stays off. Scans PV for validity and returns FALSE if the PV is invalid UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767d61bbd817028665e597ffd44d52d2f3072a5a" translate="yes" xml:space="preserve">
          <source>If the PV of the SV is an octet sequence in UTF-8 and contains a multiple-byte character, the &lt;code&gt;SvUTF8&lt;/code&gt; flag is turned on so that it looks like a character. If the PV contains only single-byte characters, the &lt;code&gt;SvUTF8&lt;/code&gt; flag stays off. Scans PV for validity and returns false if the PV is invalid UTF-8.</source>
          <target state="translated">Если PV SV является последовательностью октетов в UTF-8 и содержит многобайтовый символ, то &lt;code&gt;SvUTF8&lt;/code&gt; флаг SvUTF8, поэтому он выглядит как символ. Если PV содержит только однобайтовые символы, флаг &lt;code&gt;SvUTF8&lt;/code&gt; остается выключенным. Проверяет PV на достоверность и возвращает false, если PV является недопустимым UTF-8.</target>
        </trans-unit>
        <trans-unit id="5ce916c1cc7717c4e805155c2d7548fbc24c77ee" translate="yes" xml:space="preserve">
          <source>If the Perl script is being executed as &lt;code&gt;perl scriptname&lt;/code&gt; , then the &lt;b&gt;-%c&lt;/b&gt; option must appear on the command line: &lt;code&gt;perl -%c scriptname&lt;/code&gt;.</source>
          <target state="translated">Если сценарий Perl выполняется с именем &lt;code&gt;perl scriptname&lt;/code&gt; , тогда в командной строке должна появиться опция &lt;b&gt;-% c&lt;/b&gt; : &lt;code&gt;perl -%c scriptname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f041d8f750e7891231f6ef945e98ccc9b459b45e" translate="yes" xml:space="preserve">
          <source>If the Perl script is being executed as &lt;code&gt;perl scriptname&lt;/code&gt;, then the &lt;b&gt;-%c&lt;/b&gt; option must appear on the command line: &lt;code&gt;perl -%c scriptname&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde4187a6aa163d9c96f574141763bdd38ae34f7" translate="yes" xml:space="preserve">
          <source>If the Perl script is being executed as a command using the #! mechanism (or its local equivalent), this error can usually be fixed by editing the #! line so that the &lt;b&gt;-%c&lt;/b&gt; option is a part of Perl's first argument: e.g. change &lt;code&gt;perl -n -%c&lt;/code&gt; to &lt;code&gt;perl -%c -n&lt;/code&gt; .</source>
          <target state="translated">Если сценарий Perl выполняется как команда с использованием символа #! механизма (или его локального эквивалента), эту ошибку обычно можно исправить, отредактировав #! так, чтобы параметр &lt;b&gt;-% c&lt;/b&gt; был частью первого аргумента Perl: например, замените &lt;code&gt;perl -n -%c&lt;/code&gt; на &lt;code&gt;perl -%c -n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8bf71d735699bc0d3dafa8fc7795c33b9452d54" translate="yes" xml:space="preserve">
          <source>If the Perl script is being executed as a command using the #! mechanism (or its local equivalent), this error can usually be fixed by editing the #! line so that the &lt;b&gt;-%c&lt;/b&gt; option is a part of Perl's first argument: e.g. change &lt;code&gt;perl -n -%c&lt;/code&gt; to &lt;code&gt;perl -%c -n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c878ced38c4f673dcc4c3921e7ce406e54b4b71" translate="yes" xml:space="preserve">
          <source>If the README file seems to be getting too large you may wish to split out some of the sections into separate files: INSTALL, Copying, ToDo etc.</source>
          <target state="translated">Если файл README кажется слишком большим,вы можете разделить некоторые секции на отдельные файлы:УСТАНОВКА,копирование,ToDo и т.д.</target>
        </trans-unit>
        <trans-unit id="bcda0ef071779fc235b5cd85b1d75a393d7ae1e4" translate="yes" xml:space="preserve">
          <source>If the Time::HiRes module has been installed, you can specify the special tag &lt;code&gt;:hireswallclock&lt;/code&gt; for Benchmark (if Time::HiRes is not available, the tag will be silently ignored). This tag will cause the wallclock time to be measured in microseconds, instead of integer seconds. Note though that the speed computations are still conducted in CPU time, not wallclock time.</source>
          <target state="translated">Если модуль Time :: HiRes был установлен, вы можете указать специальный тег &lt;code&gt;:hireswallclock&lt;/code&gt; для Benchmark (если Time :: HiRes недоступен, тег будет автоматически проигнорирован). Этот тег приведет к тому, что время настенных часов будет измеряться в микросекундах, а не в целых секундах. Однако обратите внимание, что вычисления скорости по-прежнему производятся во времени процессора, а не во времени настенных часов.</target>
        </trans-unit>
        <trans-unit id="1e0de044d27a1f06d198fa6cd4b199e7a501a7e3" translate="yes" xml:space="preserve">
          <source>If the UNTIE method exists then the warning above does not occur. Instead the UNTIE method is passed the count of &quot;extra&quot; references and can issue its own warning if appropriate. e.g. to replicate the no UNTIE case this method can be used:</source>
          <target state="translated">Если метод UNTIE существует,то вышеуказанное предупреждение не возникает.Вместо этого методу UNTIE передается количество &quot;лишних&quot; ссылок и при необходимости может выдать собственное предупреждение,например,для повторения случая,когда UNTIE не существует,этот метод не может быть использован:</target>
        </trans-unit>
        <trans-unit id="143e00ba94fc0b7d94b37e36ca76fc91860f4e9a" translate="yes" xml:space="preserve">
          <source>If the URL includes a &quot;user:password&quot; stanza, they will be used for Basic-style authorization headers. (Authorization headers will not be included in a redirected request.) For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ecfe64b91fdc6593a92259993f050bf990c0868" translate="yes" xml:space="preserve">
          <source>If the VERSION argument is present between Module and LIST, then the &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; will call the &lt;code&gt;VERSION&lt;/code&gt; method in class Module with the given version as an argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afcfedf6cd11f719819da193333a7cf6de0732a7" translate="yes" xml:space="preserve">
          <source>If the VERSION argument is present between Module and LIST, then the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; will call the VERSION method in class Module with the given version as an argument. The default VERSION method, inherited from the UNIVERSAL class, croaks if the given version is larger than the value of the variable &lt;code&gt;$Module::VERSION&lt;/code&gt; .</source>
          <target state="translated">Если аргумент VERSION присутствует между Module и LIST, то &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; вызовет метод VERSION в классе Module с заданной версией в качестве аргумента. Метод VERSION по умолчанию, унаследованный от класса UNIVERSAL, хрипит, если данная версия больше, чем значение переменной &lt;code&gt;$Module::VERSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28fd8c6bb88e030936b47d8b396e97702a34b855" translate="yes" xml:space="preserve">
          <source>If the VERSION argument is present between Module and LIST, then the &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; will call the VERSION method in class Module with the given version as an argument. The default VERSION method, inherited from the UNIVERSAL class, croaks if the given version is larger than the value of the variable &lt;code&gt;$Module::VERSION&lt;/code&gt; .</source>
          <target state="translated">Если аргумент VERSION присутствует между Module и LIST, то &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; вызовет метод VERSION в классе Module с заданной версией в качестве аргумента. Метод VERSION по умолчанию, унаследованный от класса UNIVERSAL, хрипит, если данная версия больше, чем значение переменной &lt;code&gt;$Module::VERSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="333bd150f2ebb931ff98dd0682381076be3b30d6" translate="yes" xml:space="preserve">
          <source>If the XSUB has a return type of &lt;code&gt;void&lt;/code&gt; then the compiler will not declare a RETVAL variable for that function. When using a PPCODE: section no manipulation of the RETVAL variable is required, the section may use direct stack manipulation to place output values on the stack.</source>
          <target state="translated">Если XSUB имеет тип возвращаемого значения &lt;code&gt;void&lt;/code&gt; , то компилятор не будет объявлять переменную RETVAL для этой функции. При использовании секции PPCODE: никаких манипуляций с переменной RETVAL не требуется, секция может использовать прямые манипуляции со стеком для помещения выходных значений в стек.</target>
        </trans-unit>
        <trans-unit id="bebee72fc9aa0a9b169227a410e90f7f3df000ed" translate="yes" xml:space="preserve">
          <source>If the above does not work, or is not adequate for your application, then file a bug report on &lt;a href=&quot;http://rt.cpan.org/Public/&quot;&gt;http://rt.cpan.org/Public/&lt;/a&gt; against the problematic module.</source>
          <target state="translated">Если описанное выше не работает или не подходит для вашего приложения, отправьте отчет об ошибке на &lt;a href=&quot;http://rt.cpan.org/Public/&quot;&gt;http://rt.cpan.org/Public/&lt;/a&gt; для проблемного модуля.</target>
        </trans-unit>
        <trans-unit id="f43e61e618bcd86d5e8194fe59eff43dd8c761f1" translate="yes" xml:space="preserve">
          <source>If the above does not work, or is not adequate for your application, then file a bug report on &lt;a href=&quot;https://rt.cpan.org/Public/&quot;&gt;https://rt.cpan.org/Public/&lt;/a&gt; against the problematic module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f8b1f2470978bb7eb295cba54688c501c99623" translate="yes" xml:space="preserve">
          <source>If the above evaluates as true, the following methods will be available on the &lt;code&gt;$result&lt;/code&gt; object.</source>
          <target state="translated">Если приведенное выше значение истинно, для объекта &lt;code&gt;$result&lt;/code&gt; будут доступны следующие методы .</target>
        </trans-unit>
        <trans-unit id="3626e8a47b75cd9814f9aabb6f3226e20a12cd72" translate="yes" xml:space="preserve">
          <source>If the act of unimporting your module (via a &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;) should cause source code filtering to cease, create an &lt;code&gt;unimport&lt;/code&gt; subroutine, and have it call &lt;code&gt;filter_del&lt;/code&gt; . Make sure that the call to &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; in step 5 will not accidentally read past the &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. Effectively this limits source code filters to line-by-line operation, unless the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine does some fancy pre-pre-parsing of the source code it's filtering.</source>
          <target state="translated">Если акт unimporting вашего модуля (через &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; ) должен вызывать исходный код фильтрации прекратить, создать &lt;code&gt;unimport&lt;/code&gt; подпрограмму, и есть его называют &lt;code&gt;filter_del&lt;/code&gt; . Убедитесь, что вызов &lt;code&gt;filter_read&lt;/code&gt; или &lt;code&gt;filter_read_exact&lt;/code&gt; на шаге 5 случайно не прочитает после &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; . По сути, это ограничивает фильтры исходного кода построчными операциями, если только подпрограмма &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; не выполняет какой-то необычный предварительный анализ исходного кода, который она фильтрует.</target>
        </trans-unit>
        <trans-unit id="03a3b15e2a6cd5a22375d6379cdf2984cfbb61b0" translate="yes" xml:space="preserve">
          <source>If the act of unimporting your module (via a &lt;code&gt;no&lt;/code&gt;) should cause source code filtering to cease, create an &lt;code&gt;unimport&lt;/code&gt; subroutine, and have it call &lt;code&gt;filter_del&lt;/code&gt;. Make sure that the call to &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; in step 5 will not accidentally read past the &lt;code&gt;no&lt;/code&gt;. Effectively this limits source code filters to line-by-line operation, unless the &lt;code&gt;import&lt;/code&gt; subroutine does some fancy pre-pre-parsing of the source code it's filtering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14d384ae54d7fd6956617c902dc52b4f7c913e2" translate="yes" xml:space="preserve">
          <source>If the archive creation fails for any reason, &lt;code&gt;create_archive&lt;/code&gt; will return false. Please use the &lt;code&gt;error&lt;/code&gt; method to find the cause of the failure.</source>
          <target state="translated">Если создание архива по какой-либо причине не удается, &lt;code&gt;create_archive&lt;/code&gt; вернет false. Воспользуйтесь методом &lt;code&gt;error&lt;/code&gt; чтобы найти причину сбоя.</target>
        </trans-unit>
        <trans-unit id="bdb2a47c2b4d923874ce10a47d541cda074eec3d" translate="yes" xml:space="preserve">
          <source>If the argument has any characters in it other than those matching &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;, it must be a file</source>
          <target state="translated">Если аргумент имеет какие - либо символы , в нем , кроме тех , которые удовлетворяют &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;:&lt;/code&gt; или &lt;code&gt;'&lt;/code&gt; , то он должен быть файл</target>
        </trans-unit>
        <trans-unit id="78aee964b82335874ff16d75333783914537914b" translate="yes" xml:space="preserve">
          <source>If the argument has any characters in it other than those matching &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;, it must be a file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad412a6b0ecba8c1d6ad813bdece11aeaddeb49" translate="yes" xml:space="preserve">
          <source>If the argument is &quot;/cygdrive&quot;, then just the volume mount settings, and the cygdrive mount prefix are returned.</source>
          <target state="translated">Если аргумент &quot;/cygdrive&quot;,то возвращаются только настройки монтирования тома и префикс монтирования cygdrive.</target>
        </trans-unit>
        <trans-unit id="b2f2982f0afdcf62760763525865c85306c36f4e" translate="yes" xml:space="preserve">
          <source>If the argument is a compiled regular expression as returned by &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, then this function returns the pattern.</source>
          <target state="translated">Если аргумент является скомпилированным регулярным выражением, возвращенным &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; , тогда эта функция возвращает шаблон.</target>
        </trans-unit>
        <trans-unit id="7b654339779464179184dbeba32e40251c7e2e80" translate="yes" xml:space="preserve">
          <source>If the argument is a compiled regular expression as returned by &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, then this function returns what the optimiser considers to be the longest anchored fixed string and longest floating fixed string in the pattern.</source>
          <target state="translated">Если аргумент является скомпилированным регулярным выражением, возвращенным &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; , то эта функция возвращает то, что оптимизатор считает самой длинной закрепленной фиксированной строкой и самой длинной плавающей фиксированной строкой в ​​шаблоне.</target>
        </trans-unit>
        <trans-unit id="81692e2cadc8efc40c200d83e4422a4728d67dbc" translate="yes" xml:space="preserve">
          <source>If the argument is a compiled regular expression as returned by &lt;code&gt;qr//&lt;/code&gt;, then this function returns the pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c12c2dc9e5c6145a6b58c7acda0a55ed2d46c4" translate="yes" xml:space="preserve">
          <source>If the argument is a compiled regular expression as returned by &lt;code&gt;qr//&lt;/code&gt;, then this function returns what the optimiser considers to be the longest anchored fixed string and longest floating fixed string in the pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5788205c6ad8a4a8ebfb81bffe26f845a9b7bbcb" translate="yes" xml:space="preserve">
          <source>If the argument is a distribution file name (recognized by embedded slashes), it is processed. If it is a module, CPAN determines the distribution file in which this module is included and processes that, following any dependencies named in the module's META.yml or Makefile.PL (this behavior is controlled by the configuration parameter &lt;code&gt;prerequisites_policy&lt;/code&gt; ). If an argument is enclosed in slashes it is treated as a regular expression: it is expanded and if the result is a single object (distribution, bundle or module), this object is processed.</source>
          <target state="translated">Если аргументом является имя файла распространения (распознается встроенными косыми чертами), он обрабатывается. Если это модуль, CPAN определяет файл распределения , в котором этот модуль включен и процессы , что после каких - либо зависимостей , названные в META.yml модуля или Makefile.PL (это поведение контролируется параметром конфигурации &lt;code&gt;prerequisites_policy&lt;/code&gt; ). Если аргумент заключен в косую черту, он рассматривается как регулярное выражение: он раскрывается, и если результатом является отдельный объект (распределение, пакет или модуль), этот объект обрабатывается.</target>
        </trans-unit>
        <trans-unit id="b117f48b026da0b0825304f95daf71b17bbf61f6" translate="yes" xml:space="preserve">
          <source>If the argument matches only &lt;code&gt;[\w:']&lt;/code&gt;, it must be a module</source>
          <target state="translated">Если аргумент соответствует только &lt;code&gt;[\w:']&lt;/code&gt; , это должен быть модуль</target>
        </trans-unit>
        <trans-unit id="0af3cf093a2df4958131449dc2e48cabc581ef28" translate="yes" xml:space="preserve">
          <source>If the argument matches only &lt;code&gt;\w&lt;/code&gt; , it could either be a module or a file. We will try to find &lt;code&gt;file.pm&lt;/code&gt; first in &lt;code&gt;@INC&lt;/code&gt; and if that fails, we will try to find &lt;code&gt;file&lt;/code&gt; in @INC. If both fail, we die with the respective error messages.</source>
          <target state="translated">Если аргумент соответствует только &lt;code&gt;\w&lt;/code&gt; , это может быть либо модуль, либо файл. Мы будем стараться найти &lt;code&gt;file.pm&lt;/code&gt; первый в &lt;code&gt;@INC&lt;/code&gt; , и если это не удастся, мы будем пытаться найти &lt;code&gt;file&lt;/code&gt; в @INC. Если оба терпят неудачу, мы умираем с соответствующими сообщениями об ошибках.</target>
        </trans-unit>
        <trans-unit id="a134e7d8148a5bb9fcca57ef03ba8d4ffbcb83b6" translate="yes" xml:space="preserve">
          <source>If the argument matches only &lt;code&gt;\w&lt;/code&gt;, it could either be a module or a file. We will try to find &lt;code&gt;file.pm&lt;/code&gt; first in &lt;code&gt;@INC&lt;/code&gt; and if that fails, we will try to find &lt;code&gt;file&lt;/code&gt; in @INC. If both fail, we die with the respective error messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="950fc5f071c3850318ce53caaa9abf5b8d7e4b09" translate="yes" xml:space="preserve">
          <source>If the argument ops disagree with the prototype, for example by having an unacceptable number of arguments, a valid op tree is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred. In the error message, the callee is referred to by the name defined by the</source>
          <target state="translated">Если аргумент ops не согласен с прототипом,например,имея недопустимое количество аргументов,то дерево опций возвращается в любом случае.Ошибка отражается в состоянии синтаксического анализатора,как правило,приводя к единичному исключению на верхнем уровне синтаксического анализа,которое охватывает все возникшие ошибки компиляции.В сообщении об ошибке на callee ссылаются по имени,определяемому параметром</target>
        </trans-unit>
        <trans-unit id="83ab7b8277b9fed6236e40a3daaed85d393da0e1" translate="yes" xml:space="preserve">
          <source>If the argument ops disagree with the prototype, for example by having an unacceptable number of arguments, a valid op tree is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred. In the error message, the callee is referred to by the name defined by the &lt;code&gt;namegv&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4e5120bb33dd7cd87d33b762323635453284d3" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;charblock()&lt;/code&gt; is not a known block, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если аргумент функции &lt;code&gt;charblock()&lt;/code&gt; неизвестен, возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cddc796120fb296cf9c181c113316137b8a64880" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;charblock()&lt;/code&gt; is not a known block, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7830cf54412f961c402c681fff76496d227d2f2" translate="yes" xml:space="preserve">
          <source>If the attribute name is unqualified, the attribute is installed in the current package. Otherwise it is installed in the qualifier's package:</source>
          <target state="translated">Если имя атрибута не определено,то атрибут устанавливается в текущем пакете.В противном случае он устанавливается в пакет квалификатора:</target>
        </trans-unit>
        <trans-unit id="c1735572aa151643b864cff0b5bfb1e1bb6554fd" translate="yes" xml:space="preserve">
          <source>If the author's vision of the future of their module is sufficiently different from the vision of the pumpkin holder and perl5-porters as a whole so as to cause serious problems for Perl, the pumpkin holder may choose to formally fork the version of the module in the Perl core from the one maintained by the author. This should not be done lightly and should &lt;b&gt;always&lt;/b&gt; if at all possible be done only after direct input from Larry. If this is done, it must then be made explicit in the module as distributed with the Perl core that it is a forked version and that while it is based on the original author's work, it is no longer maintained by them. This must be noted in both the documentation and in the comments in the source of the module.</source>
          <target state="translated">Если авторское видение будущего своего модуля существенно отличается от видения держателя для тыквы и perl5-porters в целом, чтобы вызвать серьезные проблемы для Perl, держатель для тыквы может решить формально форкнуть версию модуля в ядро Perl из того, что поддерживается автором. Это не следует делать легкомысленно и &lt;b&gt;всегда,&lt;/b&gt; если это вообще возможно, следует делать только после прямого ввода Ларри. Если это будет сделано, тогда в модуле, распространяемом с ядром Perl, должно быть явно указано, что это разветвленная версия, и что, хотя она основана на оригинальной работе автора, она больше не поддерживается ими. Это необходимо отметить как в документации, так и в комментариях в исходном коде модуля.</target>
        </trans-unit>
        <trans-unit id="955f45edead883f952974a52b2340b4943a3c2b2" translate="yes" xml:space="preserve">
          <source>If the av argument is a tied array then will call the &lt;code&gt;EXTEND&lt;/code&gt; tied array method with an argument of &lt;code&gt;(key+1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff96c964c43432c71bf023f75aff4edc100165c" translate="yes" xml:space="preserve">
          <source>If the backslash is followed by a single digit, it's a backreference.</source>
          <target state="translated">Если за обратным слешем следует одна цифра,это обратная ссылка.</target>
        </trans-unit>
        <trans-unit id="a1567cb832ddb83a0b923a12411e03c46deba90f" translate="yes" xml:space="preserve">
          <source>If the beginning of some prebuilt path matches</source>
          <target state="translated">Если начало какого-то предварительно построенного пути совпадает</target>
        </trans-unit>
        <trans-unit id="e7f4bb43b4cedf6c41cad2b5a8c09df968a788f0" translate="yes" xml:space="preserve">
          <source>If the block of code given to &lt;a href=&quot;#pairmap&quot;&gt;&quot;pairmap&quot;&lt;/a&gt; contains lexical variables that are captured by a returned closure, and the closure is executed after the block has been re-used for the next iteration, these lexicals will not see the correct values. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10167b28b5bd2cad97967630ae689888c6716c8a" translate="yes" xml:space="preserve">
          <source>If the block of code given to &lt;a href=&quot;#pairmap&quot;&gt;pairmap&lt;/a&gt; contains lexical variables that are captured by a returned closure, and the closure is executed after the block has been re-used for the next iteration, these lexicals will not see the correct values. For example:</source>
          <target state="translated">Если блок кода, переданный в &lt;a href=&quot;#pairmap&quot;&gt;pairmap,&lt;/a&gt; содержит лексические переменные, которые захватываются возвращенным замыканием, и замыкание выполняется после того, как блок был повторно использован для следующей итерации, эти лексические элементы не будут видеть правильные значения. Например:</target>
        </trans-unit>
        <trans-unit id="4767b1747b48c85b5657695ae3a62c62eedbd7cb" translate="yes" xml:space="preserve">
          <source>If the bunzip2 program encounters a file containing multiple bzip2 files concatenated together it will automatically uncompress them all. The example below illustrates this behaviour</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440a5d8f345e7d80a2856dd0eeb83f250fbc92a1" translate="yes" xml:space="preserve">
          <source>If the byte length &lt;code&gt;l1&lt;/code&gt; is non-zero, it says how far into &lt;code&gt;s1&lt;/code&gt; to check for fold equality. In other words, &lt;code&gt;s1&lt;/code&gt; +&lt;code&gt;l1&lt;/code&gt; will be used as a goal to reach. The scan will not be considered to be a match unless the goal is reached, and scanning won't continue past that goal. Correspondingly for &lt;code&gt;l2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt; .</source>
          <target state="translated">Если длина байта &lt;code&gt;l1&lt;/code&gt; не равна нулю, это говорит, как далеко в &lt;code&gt;s1&lt;/code&gt; проверять равенство сгиба. Другими словами, &lt;code&gt;s1&lt;/code&gt; + &lt;code&gt;l1&lt;/code&gt; будет использоваться как цель для достижения. Сканирование не будет считаться совпадением, если цель не будет достигнута, и сканирование не будет продолжено после этой цели. Соответственно для &lt;code&gt;l2&lt;/code&gt; по &lt;code&gt;s2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2fca1e4d1004f5ffcdaa83a7b896a3cca0e13fe" translate="yes" xml:space="preserve">
          <source>If the byte length &lt;code&gt;l1&lt;/code&gt; is non-zero, it says how far into &lt;code&gt;s1&lt;/code&gt; to check for fold equality. In other words, &lt;code&gt;s1&lt;/code&gt;+&lt;code&gt;l1&lt;/code&gt; will be used as a goal to reach. The scan will not be considered to be a match unless the goal is reached, and scanning won't continue past that goal. Correspondingly for &lt;code&gt;l2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7b55adcf46426f8905247d52b7cd465b36f52b" translate="yes" xml:space="preserve">
          <source>If the c89 compiler complains of syntax errors during the build of the Socket extension then be sure to fix the syntax error in the system header /usr/include/sys/socket.h.</source>
          <target state="translated">Если компилятор c89 жалуется на синтаксические ошибки во время сборки расширения Socket,то обязательно исправьте синтаксическую ошибку в системном заголовке /usr/include/sys/socket.h.</target>
        </trans-unit>
        <trans-unit id="440bf862cd2a86e099efb047265c5fac0693c286" translate="yes" xml:space="preserve">
          <source>If the call is to an lvalue subroutine, and &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; is defined &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; (</source>
          <target state="translated">Если вызов к подпрограмме - значение, и &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; определена &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="679d082044403152b577fab1a0ed8a9174ec8af7" translate="yes" xml:space="preserve">
          <source>If the call is to an lvalue subroutine, and &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; is defined &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt;(</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e23c7323ae1871ee025af31121766b37b8d3a26" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;load&lt;/code&gt; is from &lt;code&gt;YourPackage&lt;/code&gt; , then that can be further simplified to</source>
          <target state="translated">Если вызов &lt;code&gt;load&lt;/code&gt; &lt;code&gt;YourPackage&lt;/code&gt; из YourPackage , то его можно упростить до</target>
        </trans-unit>
        <trans-unit id="5682bd082d01ef4bbac6126150d3b6f81612d0af" translate="yes" xml:space="preserve">
          <source>If the character following the backslash is an ASCII letter or an ASCII digit, then the sequence may be special; if so, it's listed below. A few letters have not been used yet, so escaping them with a backslash doesn't change them to be special. A future version of Perl may assign a special meaning to them, so if you have warnings turned on, Perl issues a warning if you use such a sequence. [1].</source>
          <target state="translated">Если символ,следующий за обратным слешем,является буквой ASCII или цифрой ASCII,то последовательность может быть специальной;если это так,то она перечислена ниже.Несколько букв еще не были использованы,поэтому их удаление обратным слешем не меняет их на специальные.Будущая версия Perl может присвоить им специальное значение,поэтому,если у вас включены предупреждения,Perl выдаст предупреждение,если вы используете такую последовательность.[1].</target>
        </trans-unit>
        <trans-unit id="da17f25e114b45ba4ef865a9786c813cdbdd1421" translate="yes" xml:space="preserve">
          <source>If the character is canonically decomposable (including Hangul Syllables), it returns the (full) canonical decomposition as a string. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если символ канонически разложим (включая слоги хангыль), он возвращает (полное) каноническое разложение в виде строки. В противном случае возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49a5873bb2356b7ed86679de87b264a15f6d0e92" translate="yes" xml:space="preserve">
          <source>If the character is canonically decomposable (including Hangul Syllables), it returns the (full) canonical decomposition as a string. Otherwise it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a39c4975b03ffeafb0215bb69dbcb4fdb18e47" translate="yes" xml:space="preserve">
          <source>If the character is compatibility decomposable (including Hangul Syllables), it returns the (full) compatibility decomposition as a string. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если символ является разложимым по совместимости (включая слоги хангыля), он возвращает (полное) разложение совместимости в виде строки. В противном случае возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5de2fa7cb97ef2dd5b4c83623de57ebc81f1d7c6" translate="yes" xml:space="preserve">
          <source>If the character is compatibility decomposable (including Hangul Syllables), it returns the (full) compatibility decomposition as a string. Otherwise it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e1499119842240cb994c8553e174c966c0608a" translate="yes" xml:space="preserve">
          <source>If the characters delimiting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65221cae28ebb56c2b7e384de16ed70d718d62d1" translate="yes" xml:space="preserve">
          <source>If the child falls out of scope before &lt;code&gt;finalize&lt;/code&gt; is called, a failure diagnostic will be issued and the child is considered to have failed.</source>
          <target state="translated">Если дочерний элемент выходит за пределы области действия до &lt;code&gt;finalize&lt;/code&gt; , будет выдана диагностика сбоя, и дочерний элемент считается потерпевшим неудачу.</target>
        </trans-unit>
        <trans-unit id="ac2316f205b2709d84d9e07b732224a9e1bdef17" translate="yes" xml:space="preserve">
          <source>If the child process dies for any reason, the next write to $chld_in is likely to generate a SIGPIPE in the parent, which is fatal by default. So you may wish to handle this signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc80dbef3fa7a98447bcda86b6b6a922737dbbf" translate="yes" xml:space="preserve">
          <source>If the child process dies for any reason, the next write to CHLD_IN is likely to generate a SIGPIPE in the parent, which is fatal by default. So you may wish to handle this signal.</source>
          <target state="translated">Если дочерний процесс умирает по какой-либо причине,то при следующей записи в CHLD_IN в родительском процессе,скорее всего,будет сгенерирован SIGPIPE,который по умолчанию является фатальным.Поэтому вы,возможно,захотите обработать этот сигнал.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
