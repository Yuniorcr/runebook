<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="bda6d4349e03cdc3822accb764cf2332f0d166cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct()&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;struct()&lt;/code&gt; функция</target>
        </trans-unit>
        <trans-unit id="7a95e760c73406947e7da7714b03782e42d5fa06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct&lt;/code&gt; function has three forms of parameter-list.</source>
          <target state="translated">Функция &lt;code&gt;struct&lt;/code&gt; имеет три формы списка параметров.</target>
        </trans-unit>
        <trans-unit id="ca2248434d315d7f4555ab09ed558fffeb25af18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument is a pointer to the SV that is to acquire a new magical feature.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; аргумент является указателем на SV , который должен приобрести новую магическую функцию.</target>
        </trans-unit>
        <trans-unit id="9d1732cdeea04b3b5302655756ff012b4b97e760" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument must be a reference value. The &lt;code&gt;stash&lt;/code&gt; argument specifies which class the reference will belong to. See &lt;a href=&quot;#Stashes-and-Globs&quot;&gt;Stashes and Globs&lt;/a&gt; for information on converting class names into stashes.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; аргумент должен быть контрольное значение. В &lt;code&gt;stash&lt;/code&gt; аргумент определяет , какой класс ссылка будет принадлежать. См. &lt;a href=&quot;#Stashes-and-Globs&quot;&gt;Тайники и Глобусы&lt;/a&gt; для получения информации о преобразовании имен классов в тайники.</target>
        </trans-unit>
        <trans-unit id="5aa9fb7196f50b878b4d2185150e32ef86a1a0ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_cat*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; later in this document.</source>
          <target state="translated">Функции &lt;code&gt;sv_cat*()&lt;/code&gt; недостаточно универсальны, чтобы работать со значениями, имеющими &amp;laquo;магию&amp;raquo;. См. Раздел &amp;laquo; &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Волшебные виртуальные таблицы&amp;raquo;&lt;/a&gt; далее в этом документе.</target>
        </trans-unit>
        <trans-unit id="451bffe03c920b337c26d3f6c5c7b3d0a90a952c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_set*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; later in this document.</source>
          <target state="translated">Функции &lt;code&gt;sv_set*()&lt;/code&gt; недостаточно универсальны, чтобы работать со значениями, имеющими &amp;laquo;магию&amp;raquo;. См. Раздел &amp;laquo; &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Волшебные виртуальные таблицы&amp;raquo;&lt;/a&gt; далее в этом документе.</target>
        </trans-unit>
        <trans-unit id="264e3c8ac2fdd944cc02ae92713944fc8cf6494f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;taint&lt;/code&gt; pragma causes any substrings from a match with a tainted variable to be tainted as well. This is not normally the case, as regexps are often used to extract the safe bits from a tainted variable. Use &lt;code&gt;taint&lt;/code&gt; when you are not extracting safe bits, but are performing some other processing. Both &lt;code&gt;taint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; pragmas are lexically scoped, which means they are in effect only until the end of the block enclosing the pragmas.</source>
          <target state="translated">&lt;code&gt;taint&lt;/code&gt; Прагма вызывает какие - либо подстроки из матча с испорченным переменным будут испорчена , а также. Обычно это не так, поскольку регулярные выражения часто используются для извлечения безопасных битов из испорченной переменной. Используйте &lt;code&gt;taint&lt;/code&gt; , когда вы не извлекаете безопасные биты, а выполняете другую обработку. Обе &lt;code&gt;taint&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; имеют лексическую область видимости, что означает, что они действуют только до конца блока, содержащего прагмы.</target>
        </trans-unit>
        <trans-unit id="0e22b53957ab545ec5f1fe43f2463dbb75fb5bef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test_diag&lt;/code&gt; function prepends comment hashes and spacing to the start and newlines to the end of the expected output passed to it and adds it to the list of expected error output. So, instead of writing</source>
          <target state="translated">Функция &lt;code&gt;test_diag&lt;/code&gt; добавляет хеши комментариев и интервалы к началу и новые строки к концу переданного ожидаемого вывода и добавляет его в список ожидаемых выводов ошибок. Итак, вместо того, чтобы писать</target>
        </trans-unit>
        <trans-unit id="9a044497bbeccf899d123e744ac60158148d66b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thing&lt;/code&gt; argument can be any of an &lt;code&gt;SV*&lt;/code&gt; , &lt;code&gt;AV*&lt;/code&gt; , or &lt;code&gt;HV*&lt;/code&gt; . The functions are identical except that &lt;code&gt;newRV_inc&lt;/code&gt; increments the reference count of the &lt;code&gt;thing&lt;/code&gt; , while &lt;code&gt;newRV_noinc&lt;/code&gt; does not. For historical reasons, &lt;code&gt;newRV&lt;/code&gt; is a synonym for &lt;code&gt;newRV_inc&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;thing&lt;/code&gt; аргумент может быть любой из &lt;code&gt;SV*&lt;/code&gt; , &lt;code&gt;AV*&lt;/code&gt; или &lt;code&gt;HV*&lt;/code&gt; . Эти функции идентичны , за исключением того &lt;code&gt;newRV_inc&lt;/code&gt; увеличивает счетчик ссылок на &lt;code&gt;thing&lt;/code&gt; , в то время как &lt;code&gt;newRV_noinc&lt;/code&gt; нет. По историческим причинам &lt;code&gt;newRV&lt;/code&gt; является синонимом &lt;code&gt;newRV_inc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="764690cb5a9a1e69711deb7f1d4bd7570cd33533" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;threads-&amp;gt;self()&lt;/code&gt; class method provides your program with a way to get an object representing the thread it's currently in. You can use this object in the same way as the ones returned from thread creation.</source>
          <target state="translated">Метод &lt;code&gt;threads-&amp;gt;self()&lt;/code&gt; предоставляет вашей программе способ получить объект, представляющий поток, в котором он сейчас находится. Вы можете использовать этот объект так же, как и те, которые возвращаются при создании потока.</target>
        </trans-unit>
        <trans-unit id="5cb77a0f1c56daabcc9daa1cb20e1afceca163c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tid&lt;/code&gt; method returns the tid of a thread. The tid is a monotonically increasing integer assigned when a thread is created. The main thread of a program will have a tid of zero, while subsequent threads will have tids assigned starting with one.</source>
          <target state="translated">Метод &lt;code&gt;tid&lt;/code&gt; возвращает tid потока. Tid - это монотонно возрастающее целое число, присваиваемое при создании потока. Главный поток программы будет иметь нулевое значение, тогда как последующим потокам будут назначены идентификаторы, начинающиеся с единицы.</target>
        </trans-unit>
        <trans-unit id="62cae6d3e02f73d7641c7861d0693bc4b08d5c81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; functions perform range checking on the input $sec, $min, $hour, $mday, and $mon values by default.</source>
          <target state="translated">Функции &lt;code&gt;timelocal()&lt;/code&gt; и &lt;code&gt;timegm()&lt;/code&gt; выполняют проверку диапазона входных значений $ sec, $ min, $ hour, $ mday и $ mon.</target>
        </trans-unit>
        <trans-unit id="3444ad2f99e605827ac849ba41549cb93537c5ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; function is implemented using the same cache. We just assume that we're translating a GMT time, and then fudge it when we're done for the timezone and daylight savings arguments. Note that the timezone is evaluated for each date because countries occasionally change their official timezones. Assuming that &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; corrects for these changes, this routine will also be correct.</source>
          <target state="translated">Функция &lt;code&gt;timelocal()&lt;/code&gt; реализована с использованием того же кеша. Мы просто предполагаем, что переводим время по Гринвичу, а затем подделываем его, когда закончим с аргументами о часовом поясе и переходе на летнее время. Обратите внимание, что часовой пояс оценивается для каждой даты, потому что страны иногда меняют свои официальные часовые пояса. Если предположить, что &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; исправляет эти изменения, эта процедура также будет правильной.</target>
        </trans-unit>
        <trans-unit id="7969d03acba8ec22322bc524970a2e67bf531eeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument should be equal to the &lt;code&gt;how&lt;/code&gt; value when the &lt;code&gt;SV&lt;/code&gt; was initially made magical.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; аргумента должен быть равен &lt;code&gt;how&lt;/code&gt; значение , когда &lt;code&gt;SV&lt;/code&gt; был первоначально сделан волшебно.</target>
        </trans-unit>
        <trans-unit id="e605c3e8404b3b1569b2a8f6ee2a28bb09c8e25f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u&lt;/code&gt; template to &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; will render EBCDIC data in EBCDIC characters equivalent to their ASCII counterparts. For example, the following will print &quot;Yes indeed\n&quot; on either an ASCII or EBCDIC computer:</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; шаблона &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; будет оказывать EBCDIC данных в EBCDIC символов эквивалентны их ASCII аналоги. Например, на компьютере ASCII или EBCDIC будет напечатано &quot;Да, действительно \ n&quot;:</target>
        </trans-unit>
        <trans-unit id="6a1909f52d28496be25968c9641232bd70a050cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;up&lt;/code&gt; method increases the semaphore's count by the number specified (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">Метод &lt;code&gt;up&lt;/code&gt; увеличивает количество семафоров на указанное число (которое должно быть целым числом&amp;gt; = 1) или на единицу, если число не указано.</target>
        </trans-unit>
        <trans-unit id="3bfafbe930277e35ea02604239f7cd015c3326fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade&lt;/code&gt; command first runs an &lt;code&gt;r&lt;/code&gt; command with the given arguments and then installs the newest versions of all modules that were listed by that.</source>
          <target state="translated">Команда &lt;code&gt;upgrade&lt;/code&gt; сначала запускает команду &lt;code&gt;r&lt;/code&gt; с указанными аргументами, а затем устанавливает новейшие версии всех модулей, которые были перечислены при этом.</target>
        </trans-unit>
        <trans-unit id="ed2a8ecd68dda5352fc1303d01e5cd582863eba1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;urllist&lt;/code&gt; parameter of the configuration table contains a list of URLs used for downloading. If the list contains any &lt;code&gt;file&lt;/code&gt; URLs, CPAN always tries there first. This feature is disabled for index files. So the recommendation for the owner of a CD-ROM with CPAN contents is: include your local, possibly outdated CD-ROM as a &lt;code&gt;file&lt;/code&gt; URL at the end of urllist, e.g.</source>
          <target state="translated">Параметр &lt;code&gt;urllist&lt;/code&gt; таблицы конфигурации содержит список URL-адресов, используемых для загрузки. Если в списке есть URL-адреса &lt;code&gt;file&lt;/code&gt; , CPAN всегда пробует их первым. Эта функция отключена для индексных файлов. Таким образом, рекомендация для владельца компакт-диска с содержимым CPAN: включите локальный, возможно устаревший компакт-диск в качестве URL-адреса &lt;code&gt;file&lt;/code&gt; в конце списка URL-адресов, например</target>
        </trans-unit>
        <trans-unit id="468aa2690cfac4f39947fa49f9490387f38518f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; and &lt;code&gt;utf8::upgrade()&lt;/code&gt; aren't needed if the argument is above 0xFF, so the above could have been written as</source>
          <target state="translated">&lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; и &lt;code&gt;utf8::upgrade()&lt;/code&gt; не требуется , если аргумент выше 0xFF, поэтому выше можно было бы записать в виде</target>
        </trans-unit>
        <trans-unit id="0a270d12703e96872d5ec49cc2bfa5c1ab0eb455" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vars&lt;/code&gt; pragma (see &lt;a href=&quot;perlmod#vars&quot;&gt;vars in perlmod&lt;/a&gt;) may be used in such situations as an alternative to explicitly qualifying all globals with the package namespace. Variables pre-declared with this pragma will be visible to any autoloaded routines (but will not be invisible outside the package, unfortunately).</source>
          <target state="translated">&lt;code&gt;vars&lt;/code&gt; прагму (см &lt;a href=&quot;perlmod#vars&quot;&gt;вары в perlmod&lt;/a&gt; могут быть использованы в таких ситуациях , в качестве альтернативы , чтобы явно квалифицировать все глобалы с пространством имен пакета). Переменные, предварительно объявленные с помощью этой прагмы, будут видимы для любых автоматически загружаемых подпрограмм (но, к сожалению, не будут невидимы вне пакета).</target>
        </trans-unit>
        <trans-unit id="8a981f510b5bc1a31c1fe6f83ee184b884a41beb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;verbose&lt;/code&gt; and &lt;code&gt;inc&lt;/code&gt; attributes influence the behavior of this search; notably, &lt;code&gt;inc&lt;/code&gt; , if true, adds @INC</source>
          <target state="translated">В &lt;code&gt;verbose&lt;/code&gt; и &lt;code&gt;inc&lt;/code&gt; дополнительные атрибуты влияют на поведение этого поиска; в частности, &lt;code&gt;inc&lt;/code&gt; , если true, добавляет @INC</target>
        </trans-unit>
        <trans-unit id="42e9db15fd405837558fc69a3922cf4c07b0d66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; return type for this function tells the &lt;b&gt;xsubpp&lt;/b&gt; compiler that the RETVAL variable is not needed or used and that it should not be created. In most scenarios the void return type should be used with the PPCODE: directive.</source>
          <target state="translated">Тип возврата &lt;code&gt;void&lt;/code&gt; для этой функции сообщает компилятору &lt;b&gt;xsubpp,&lt;/b&gt; что переменная RETVAL не нужна или не используется и что ее не следует создавать. В большинстве сценариев возвращаемый тип void следует использовать с директивой PPCODE :.</target>
        </trans-unit>
        <trans-unit id="0803129a0bffe56a31c42b951ef5b3d0fb1885a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wanted()&lt;/code&gt; function does whatever verifications you want on each file and directory. Note that despite its name, the &lt;code&gt;wanted()&lt;/code&gt; function is a generic callback function, and does &lt;b&gt;not&lt;/b&gt; tell File::Find if a file is &quot;wanted&quot; or not. In fact, its return value is ignored.</source>
          <target state="translated">Функция want &lt;code&gt;wanted()&lt;/code&gt; выполняет все необходимые проверки для каждого файла и каталога. Обратите внимание, что, несмотря на свое название, функция &lt;code&gt;wanted()&lt;/code&gt; является общей функцией обратного вызова и &lt;b&gt;не&lt;/b&gt; сообщает File :: Find, является ли файл &amp;laquo;желаемым&amp;raquo; или нет. Фактически, его возвращаемое значение игнорируется.</target>
        </trans-unit>
        <trans-unit id="31b1fe49028e0123810b9a17034fff70bf1be6cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warnings&lt;/code&gt; pragma gives control over which warnings are enabled in which parts of a Perl program. It's a more flexible alternative for both the command line flag &lt;b&gt;-w&lt;/b&gt; and the equivalent Perl variable, &lt;code&gt;$^W&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;warnings&lt;/code&gt; Прагма дает контроль над которым предупреждение включены в каких частях программы Perl. Это более гибкая альтернатива как флаг командной строки &lt;b&gt;-w&lt;/b&gt; и эквивалентной переменной Perl, &lt;code&gt;$^W&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d599e8a7252be8237239500a33b9cae49be5da2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warnings&lt;/code&gt; pragma provides a number of functions that are useful for module authors. These are used when you want to report a module-specific warning to a calling module has enabled warnings via the &lt;code&gt;warnings&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;code&gt;warnings&lt;/code&gt; Прагма предоставляет ряд функций , которые являются полезными для авторов модуля. Они используются, когда вы хотите сообщить о специфическом для модуля предупреждении вызывающему модулю, включившему предупреждения, с помощью &lt;code&gt;warnings&lt;/code&gt; warnings.</target>
        </trans-unit>
        <trans-unit id="eaaf2c2b19accccb92902e0f89453388a8136ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; modifier is an experimental feature that first appeared in Perl 5.14. To use it, you should include a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.14&lt;/code&gt; declaration. (Technically, it requires only the &lt;code&gt;switch&lt;/code&gt; feature, but that aspect of it was not available before 5.14.) Operative only from within a &lt;code&gt;foreach&lt;/code&gt; loop or a &lt;code&gt;given&lt;/code&gt; block, it executes the statement only if the smartmatch &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt; is true. If the statement executes, it is followed by a &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; from inside a &lt;code&gt;foreach&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; from inside a &lt;code&gt;given&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; модификатор является экспериментальной функцией , которая впервые появилась в Perl 5.14. Чтобы использовать его, вы должны включить объявление &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.14&lt;/code&gt; . (Технически для этого требуется только функция &lt;code&gt;switch&lt;/code&gt; , но этот аспект не был доступен до 5.14.) Работающий только из цикла &lt;code&gt;foreach&lt;/code&gt; или &lt;code&gt;given&lt;/code&gt; блока, он выполняет оператор, только если smartmatch &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt; истинно. Если оператор выполняется, за ним следует &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; изнутри &lt;code&gt;foreach&lt;/code&gt; и &lt;code&gt;break&lt;/code&gt; изнутри &lt;code&gt;given&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e19be3044d8f18bead09bab3403090b34e1156d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;until&lt;/code&gt; modifiers have the usual &quot;&lt;code&gt;while&lt;/code&gt; loop&quot; semantics (conditional evaluated first), except when applied to a &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;-BLOCK (or to the Perl4 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;-SUBROUTINE statement), in which case the block executes once before the conditional is evaluated.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; , и &lt;code&gt;until&lt;/code&gt; , модификаторы не имеют обычный &amp;laquo; в &lt;code&gt;while&lt;/code&gt; петля&amp;raquo; семантика (условные сначала вычисляется), кроме случаев , когда применяется к &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; -блок (или к Perl4 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; -SUBROUTINE заявление), в этом случае блок выполняется один раз до того , как условно оценивается .</target>
        </trans-unit>
        <trans-unit id="3d5b06f931731acb22dad061fcd52f2783c874b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement executes the block as long as the expression is &lt;a href=&quot;#Truth-and-Falsehood&quot;&gt;true&lt;/a&gt;. The &lt;code&gt;until&lt;/code&gt; statement executes the block as long as the expression is false. The LABEL is optional, and if present, consists of an identifier followed by a colon. The LABEL identifies the loop for the loop control statements &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;. If the LABEL is omitted, the loop control statement refers to the innermost enclosing loop. This may include dynamically looking back your call-stack at run time to find the LABEL. Such desperate behavior triggers a warning if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag.</source>
          <target state="translated">Оператор &lt;code&gt;while&lt;/code&gt; выполняет блок, пока выражение &lt;a href=&quot;#Truth-and-Falsehood&quot;&gt;истинно&lt;/a&gt; . Оператор &lt;code&gt;until&lt;/code&gt; выполняет блок, пока выражение ложно. LABEL является необязательным и, если присутствует, состоит из идентификатора, за которым следует двоеточие. LABEL идентифицирует цикл для операторов управления циклом &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; . Если LABEL опущен, оператор управления циклом относится к самому внутреннему охватывающему циклу. Это может включать динамический просмотр вашего стека вызовов во время выполнения, чтобы найти LABEL. Такое отчаянное поведение вызывает предупреждение , если вы используете &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; прагму или &lt;b&gt;-w&lt;/b&gt; флаг.</target>
        </trans-unit>
        <trans-unit id="42f557fbb89c75fd2ab740d93d25721ccbf0fda2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; function allows another thread to take control of the CPU. The exact results are implementation-dependent.</source>
          <target state="translated">Функция &lt;code&gt;yield&lt;/code&gt; позволяет другому потоку взять под контроль ЦП. Точные результаты зависят от реализации.</target>
        </trans-unit>
        <trans-unit id="246e63b2eb0074027eaf6b6fe6bf0995cbbb987b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operators return the last value evaluated (unlike C's &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, which return 0 or 1). Thus, a reasonably portable way to find out the home directory might be:</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt; Операторы , &lt;code&gt;//&lt;/code&gt; и &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; возвращают последнее вычисленное значение (в отличие от C &lt;code&gt;||&lt;/code&gt; и &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , которые возвращают 0 или 1). Таким образом, достаточно переносимый способ узнать домашний каталог может быть следующим:</target>
        </trans-unit>
        <trans-unit id="11f57b3d94eabb5c19fb9360ab6afe8316dfa0a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~~&lt;/code&gt; operator compares its operands &quot;polymorphically&quot;, determining how to compare them according to their actual types (numeric, string, array, hash, etc.) Like the equality operators with which it shares the same precedence, &lt;code&gt;~~&lt;/code&gt; returns 1 for true and &lt;code&gt;&quot;&quot;&lt;/code&gt; for false. It is often best read aloud as &quot;in&quot;, &quot;inside of&quot;, or &quot;is contained in&quot;, because the left operand is often looked for</source>
          <target state="translated">Оператор &lt;code&gt;~~&lt;/code&gt; &amp;laquo;полиморфно&amp;raquo; сравнивает свои операнды, определяя, как их сравнивать в соответствии с их фактическими типами (числовые, строковые, массивы, хеш-коды и т. Д.). Подобно операторам равенства, с которыми он имеет одинаковый приоритет, &lt;code&gt;~~&lt;/code&gt; возвращает 1 для истина и &lt;code&gt;&quot;&quot;&lt;/code&gt; для ложь. Часто его лучше читать вслух как &amp;laquo;внутри&amp;raquo;, &amp;laquo;внутри&amp;raquo; или &amp;laquo;содержится в&amp;raquo;, потому что часто ищут левый операнд.</target>
        </trans-unit>
        <trans-unit id="ef321bd7088ac81817f2231db61c1174692aaac0" translate="yes" xml:space="preserve">
          <source>The ADLER32 checksum field must be present.</source>
          <target state="translated">Поле контрольной суммы ADLER32 должно присутствовать.</target>
        </trans-unit>
        <trans-unit id="9c4519701849f27da68be727b95e63207f2a9abf" translate="yes" xml:space="preserve">
          <source>The AIX tar does not fill all unused space in the tar archive with 0x00. This sometimes leads to warning messages from &lt;code&gt;Archive::Tar&lt;/code&gt; .</source>
          <target state="translated">AIX tar не заполняет все неиспользуемое пространство в tar-архиве значением 0x00. Иногда это приводит к предупреждающим сообщениям от &lt;code&gt;Archive::Tar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5549afa573e8454744ea43299cd8d8505147fcd" translate="yes" xml:space="preserve">
          <source>The ALIAS: Keyword</source>
          <target state="translated">Ключевое слово</target>
        </trans-unit>
        <trans-unit id="2ce9242faeeab07eef2f7afd701bea6933de8059" translate="yes" xml:space="preserve">
          <source>The ALIAS: keyword allows an XSUB to have two or more unique Perl names and to know which of those names was used when it was invoked. The Perl names may be fully-qualified with package names. Each alias is given an index. The compiler will setup a variable called &lt;code&gt;ix&lt;/code&gt; which contain the index of the alias which was used. When the XSUB is called with its declared name &lt;code&gt;ix&lt;/code&gt; will be 0.</source>
          <target state="translated">Ключевое слово ALIAS: позволяет XSUB иметь два или более уникальных имени Perl и знать, какое из этих имен использовалось при его вызове. Имена Perl могут быть полностью уточнены именами пакетов. Каждому псевдониму присваивается индекс. Компилятор установит переменную с именем &lt;code&gt;ix&lt;/code&gt; , которая будет содержать индекс использованного псевдонима. Когда XSUB вызывается с его объявленным именем, &lt;code&gt;ix&lt;/code&gt; будет 0.</target>
        </trans-unit>
        <trans-unit id="15fd0430aabb02304def7c36146cf671599d3942" translate="yes" xml:space="preserve">
          <source>The API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="9ed04c99d7b2c6a9ba47b9e4b73c73bb3ccc347c" translate="yes" xml:space="preserve">
          <source>The API was changed in the 2.0 branch. For a time, &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; tried, unsuccessfully, to deal with the two different calling mechanisms. This approach was considered a failure.</source>
          <target state="translated">API был изменен в ветке 2.0. Какое-то время &lt;code&gt;mkpath&lt;/code&gt; и &lt;code&gt;rmtree&lt;/code&gt; безуспешно пытались разобраться с двумя разными механизмами вызова. Такой подход был признан неудачным.</target>
        </trans-unit>
        <trans-unit id="009ead0f6ffd2c056d27d3bfda98818a54d2faea" translate="yes" xml:space="preserve">
          <source>The ASCII region (0x00-0x7f) is preserved for all encodings, even though this conflicts with mappings by the Unicode Consortium.</source>
          <target state="translated">Область ASCII (0x00-0x7f)сохраняется для всех кодировок,даже если это противоречит отображениям консорциума Unicode.</target>
        </trans-unit>
        <trans-unit id="b3c4e287eeab5aae5482e7df8b6e409cada7c372" translate="yes" xml:space="preserve">
          <source>The ASCII/Latin-1/Unicode character with that number. A leading &quot;0x&quot; means that</source>
          <target state="translated">Символ ASCII/Latin-1/Unicode с этим номером.Ведущий &quot;0x&quot; означает,что</target>
        </trans-unit>
        <trans-unit id="e2afefe4f37ea14f731718bb07a4d6306f1639c5" translate="yes" xml:space="preserve">
          <source>The AUTOLOAD method, discussed in &lt;a href=&quot;perlsub#Autoloading&quot;&gt;Autoloading in perlsub&lt;/a&gt; lets you capture calls to undefined functions and methods.</source>
          <target state="translated">Метод AUTOLOAD, описанный в &lt;a href=&quot;perlsub#Autoloading&quot;&gt;разделе Автозагрузка в perlsub,&lt;/a&gt; позволяет захватывать вызовы неопределенных функций и методов.</target>
        </trans-unit>
        <trans-unit id="31231455a0cef5b5794db63f07a47d2f6efab12c" translate="yes" xml:space="preserve">
          <source>The ActiveState Pages, &lt;a href=&quot;http://www.activestate.com/&quot;&gt;http://www.activestate.com/&lt;/a&gt;</source>
          <target state="translated">Страницы ActiveState, &lt;a href=&quot;http://www.activestate.com/&quot;&gt;http://www.activestate.com/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fbbc6fc0e5dd1ef33879bfc672f5e3e8813e4f97" translate="yes" xml:space="preserve">
          <source>The Adventures of Tom Bombadil</source>
          <target state="translated">Приключения Тома Бомбадила</target>
        </trans-unit>
        <trans-unit id="e2e0a5aea5199e87efc4db9939033262cf1e73b8" translate="yes" xml:space="preserve">
          <source>The Alignment Pit</source>
          <target state="translated">Яма для выравнивания</target>
        </trans-unit>
        <trans-unit id="68a751b9c456def01d238b0c06471f4927931bb2" translate="yes" xml:space="preserve">
          <source>The American Standard Code for Information Interchange (ASCII or US-ASCII) is a set of integers running from 0 to 127 (decimal) that have standardized interpretations by the computers which use ASCII. For example, 65 means the letter &quot;A&quot;. The range 0..127 can be covered by setting the bits in a 7-bit binary digit, hence the set is sometimes referred to as &quot;7-bit ASCII&quot;. ASCII was described by the American National Standards Institute document ANSI X3.4-1986. It was also described by ISO 646:1991 (with localization for currency symbols). The full ASCII set is given in the table &lt;a href=&quot;#recipe-3&quot;&gt;below&lt;/a&gt; as the first 128 elements. Languages that can be written adequately with the characters in ASCII include English, Hawaiian, Indonesian, Swahili and some Native American languages.</source>
          <target state="translated">Американский стандартный код для обмена информацией (ASCII или US-ASCII) - это набор целых чисел от 0 до 127 (десятичный), которые имеют стандартизованную интерпретацию компьютерами, использующими ASCII. Например, 65 означает букву &amp;laquo;А&amp;raquo;. Диапазон 0..127 может быть покрыт путем установки битов в 7-битную двоичную цифру, поэтому набор иногда называют &amp;laquo;7-битным ASCII&amp;raquo;. ASCII был описан в документе Американского национального института стандартов ANSI X3.4-1986. Он также был описан в ISO 646: 1991 (с локализацией символов валют). Полный набор ASCII представлен в таблице &lt;a href=&quot;#recipe-3&quot;&gt;ниже&lt;/a&gt; как первые 128 элементов. Языки, которые могут быть адекватно написаны с использованием символов в ASCII, включают английский, гавайский, индонезийский, суахили и некоторые языки коренных американцев.</target>
        </trans-unit>
        <trans-unit id="f3ff218a8809c68d0eb083f2cf66b8207142d4f0" translate="yes" xml:space="preserve">
          <source>The American Standard Code for Information Interchange (a 7-bit character set adequate only for poorly representing English text). Often used loosely to describe the lowest 128 values of the various ISO-8859-X character sets, a bunch of mutually incompatible 8-bit codes best described as half ASCII. See also &lt;b&gt;Unicode&lt;/b&gt;.</source>
          <target state="translated">Американский стандартный код для обмена информацией (7-битный набор символов, подходящий только для плохого представления английского текста). Часто используется в общих чертах для описания наименьших 128 значений различных наборов символов ISO-8859-X, совокупность взаимно несовместимых 8-битных кодов, лучше всего описываемых как половина ASCII. См. Также &lt;b&gt;Unicode&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="fd1c7da39d90054f5c4c81dc1a1fa13bcbbe82e7" translate="yes" xml:space="preserve">
          <source>The Anatomy of an XSUB</source>
          <target state="translated">Анатомия XSUB</target>
        </trans-unit>
        <trans-unit id="0746d95bfde5c5ba18bf27b5d1463ad01ffdafa1" translate="yes" xml:space="preserve">
          <source>The Argument Stack</source>
          <target state="translated">Стойка аргументов</target>
        </trans-unit>
        <trans-unit id="59f8369b68ee932dd97b5ec57202b3f3969c4a83" translate="yes" xml:space="preserve">
          <source>The Arrow Operator</source>
          <target state="translated">Стрелочный оператор</target>
        </trans-unit>
        <trans-unit id="e40e5d487b331e1f7f4c2477322a84662ea1dcde" translate="yes" xml:space="preserve">
          <source>The Art of Computer Programming</source>
          <target state="translated">Искусство компьютерного программирования</target>
        </trans-unit>
        <trans-unit id="e6a71a9e8ae70e8f61fd0c5d80d8189dbf3cf681" translate="yes" xml:space="preserve">
          <source>The AutoSplit and &lt;b&gt;AutoLoader&lt;/b&gt; modules automate the creation of forward declarations. The AutoSplit module creates an 'index' file containing forward declarations of all the AutoSplit subroutines. When the AutoLoader module is 'use'd it loads these declarations into its callers package.</source>
          <target state="translated">Модули AutoSplit и &lt;b&gt;AutoLoader&lt;/b&gt; автоматизируют создание форвардных объявлений. Модуль AutoSplit создает &amp;laquo;индексный&amp;raquo; файл, содержащий предварительные объявления всех подпрограмм AutoSplit. Когда модуль AutoLoader используется, он загружает эти объявления в свой пакет вызывающих.</target>
        </trans-unit>
        <trans-unit id="547ca45f60093a7fb15745aaa1976d8399cc0918" translate="yes" xml:space="preserve">
          <source>The B-determined class of the OP, in all caps.</source>
          <target state="translated">Класс Б,определяемый ОП,во всех прописных буквах.</target>
        </trans-unit>
        <trans-unit id="fad9fed447a0e7963d894765232a4acc4b663de9" translate="yes" xml:space="preserve">
          <source>The B::Xref module is used to generate a cross reference listing of all definitions and uses of variables, subroutines and formats in a Perl program. It is implemented as a backend for the Perl compiler.</source>
          <target state="translated">Модуль B::Xref используется для генерации перекрёстного списка всех определений и использования переменных,подпрограмм и форматов в Perl программе.Он реализован как бэкэнд для компилятора Perl.</target>
        </trans-unit>
        <trans-unit id="8026a52e63f99adbefc0e084618e1f479fd95572" translate="yes" xml:space="preserve">
          <source>The BITS mode (&quot;0&quot;) interprets the contents of</source>
          <target state="translated">Режим BITS (&quot;0&quot;)интерпретирует содержание</target>
        </trans-unit>
        <trans-unit id="ba88dd1d9005852348725927325ddcf383a69f7c" translate="yes" xml:space="preserve">
          <source>The BLOCK construct can be used to emulate case structures.</source>
          <target state="translated">Конструкция BLOCK может быть использована для эмуляции регистровых структур.</target>
        </trans-unit>
        <trans-unit id="6dfef44d3b22aafe27912b6966e2a486d9c0c14d" translate="yes" xml:space="preserve">
          <source>The BOOT: Keyword</source>
          <target state="translated">Лодка:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="d4a87a13d39a77a50a617134650c09dd8bdc8e3b" translate="yes" xml:space="preserve">
          <source>The BOOT: keyword is used to add code to the extension's bootstrap function. The bootstrap function is generated by the &lt;b&gt;xsubpp&lt;/b&gt; compiler and normally holds the statements necessary to register any XSUBs with Perl. With the BOOT: keyword the programmer can tell the compiler to add extra statements to the bootstrap function.</source>
          <target state="translated">Ключевое слово BOOT: используется для добавления кода в функцию начальной загрузки расширения. Функция начальной загрузки генерируется компилятором &lt;b&gt;xsubpp&lt;/b&gt; и обычно содержит операторы, необходимые для регистрации любых XSUB в Perl. С помощью ключевого слова BOOT: программист может указать компилятору добавить дополнительные операторы к функции начальной загрузки.</target>
        </trans-unit>
        <trans-unit id="ad4a573da9545ff1a8eab5e0d4f5f08622036178" translate="yes" xml:space="preserve">
          <source>The BTREE file type optionally allows a single key to be associated with an arbitrary number of values. This option is enabled by setting the flags element of &lt;code&gt;$DB_BTREE&lt;/code&gt; to R_DUP when creating the database.</source>
          <target state="translated">Тип файла BTREE дополнительно позволяет связать один ключ с произвольным количеством значений. Эта опция включается установкой для элемента flags &lt;code&gt;$DB_BTREE&lt;/code&gt; R_DUP при создании базы данных.</target>
        </trans-unit>
        <trans-unit id="4a8451f6eedb6a6056c8ac828a203a8cf8bdc79c" translate="yes" xml:space="preserve">
          <source>The BTREE interface has a feature which allows partial keys to be matched. This functionality is</source>
          <target state="translated">Интерфейс BTREE имеет функцию,позволяющую сопоставлять частичные клавиши.Эта функциональность</target>
        </trans-unit>
        <trans-unit id="19350bba9c33f125fd021dceab5ff7633dce372c" translate="yes" xml:space="preserve">
          <source>The BUILD and INSTALL steps are identical to those for Unix. Some modules generate Makefiles that work better with GNU make, which is available from &lt;a href=&quot;http://www.mks.com/s390/gnu/&quot;&gt;http://www.mks.com/s390/gnu/&lt;/a&gt;</source>
          <target state="translated">Шаги BUILD и INSTALL идентичны шагам для Unix. Некоторые модули генерируют файлы Makefile, которые лучше работают с GNU make, доступной по &lt;a href=&quot;http://www.mks.com/s390/gnu/&quot;&gt;адресу http://www.mks.com/s390/gnu/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06987733f8223bbe1dde5201da803a816622002c" translate="yes" xml:space="preserve">
          <source>The Basic Principle</source>
          <target state="translated">Основной принцип</target>
        </trans-unit>
        <trans-unit id="afdc8705dda034aabf31fc65386bddfb61c3e95b" translate="yes" xml:space="preserve">
          <source>The Benchmark module encapsulates a number of routines to help you figure out how long it takes to execute some code.</source>
          <target state="translated">Модуль Benchmark инкапсулирует ряд подпрограмм,чтобы помочь вам понять,сколько времени занимает выполнение некоторого кода.</target>
        </trans-unit>
        <trans-unit id="869885b765935f032e1e45165248683c4d860661" translate="yes" xml:space="preserve">
          <source>The Berkeley DB 4.1.25 has been tested with Tru64 V5.1A and found to work. The latest Berkeley DB can be found from &lt;a href=&quot;http://www.sleepycat.com&quot;&gt;http://www.sleepycat.com&lt;/a&gt;.</source>
          <target state="translated">Berkeley DB 4.1.25 был протестирован с Tru64 V5.1A и признан работоспособным. Последнюю версию Berkeley DB можно найти на &lt;a href=&quot;http://www.sleepycat.com&quot;&gt;сайте http://www.sleepycat.com&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1425da38b0881b20e7239aedd72aa0c3d5db10c1" translate="yes" xml:space="preserve">
          <source>The Bessel function of the first kind of the order zero.</source>
          <target state="translated">Функция Бесселя первого вида обнуления ордера.</target>
        </trans-unit>
        <trans-unit id="95802efdaca31b27a14913bfe1089183b4ec8875" translate="yes" xml:space="preserve">
          <source>The C API for the backtrace is as follows:</source>
          <target state="translated">C API для обратной связи выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="89f382052ffa523340ba739809ce6ebbf65c53dd" translate="yes" xml:space="preserve">
          <source>The C array of a padlist, containing the pads. Only subscript it with numbers &amp;gt;= 1, as the 0th entry is not guaranteed to remain usable.</source>
          <target state="translated">Массив C списка площадок, содержащий площадки. Только индексируйте его числами&amp;gt; = 1, так как 0-я запись не гарантируется, что ее можно будет использовать.</target>
        </trans-unit>
        <trans-unit id="9d9a695f29b97a18f6840062c9b13365fc424c17" translate="yes" xml:space="preserve">
          <source>The C array of pad entries.</source>
          <target state="translated">С массивом записей блокнотов.</target>
        </trans-unit>
        <trans-unit id="82cdebaae9f3b94b2c40ce92be9ab7f40abcb4e4" translate="yes" xml:space="preserve">
          <source>The C array of pad names.</source>
          <target state="translated">С массивом названий блокнотов.</target>
        </trans-unit>
        <trans-unit id="66ccfe4f23602b2282c83a4407f8d3eb55b4ce47" translate="yes" xml:space="preserve">
          <source>The C code asks for:</source>
          <target state="translated">Код Си просит:</target>
        </trans-unit>
        <trans-unit id="1755acfd3f32daf3e3ba7fab9fbb3582e6e7bc1c" translate="yes" xml:space="preserve">
          <source>The C function required to call</source>
          <target state="translated">Функция C,необходимая для вызова</target>
        </trans-unit>
        <trans-unit id="593e19336c2ea1e5b6f3c47a320c97c9b260fd7c" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, wrapped if necessary, to ensure that it will return the length of the string written to the buffer. Only rare pre-ANSI systems need the wrapper function - usually this is a direct call to &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Библиотека C &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; , при необходимости обернутая, чтобы гарантировать, что она вернет длину строки, записанной в буфер. Только в редких системах до ANSI требуется функция оболочки - обычно это прямой вызов &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f593f0f7e2f42e16decd49842d3eba832ba134e" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;snprintf&lt;/code&gt; functionality, if available and standards-compliant (uses &lt;code&gt;vsnprintf&lt;/code&gt; , actually). However, if the &lt;code&gt;vsnprintf&lt;/code&gt; is not available, will unfortunately use the unsafe &lt;code&gt;vsprintf&lt;/code&gt; which can overrun the buffer (there is an overrun check, but that may be too late). Consider using &lt;code&gt;sv_vcatpvf&lt;/code&gt; instead, or getting &lt;code&gt;vsnprintf&lt;/code&gt; .</source>
          <target state="translated">Функциональность &lt;code&gt;snprintf&lt;/code&gt; библиотеки C , если она доступна и совместима со стандартами (на самом деле, использует &lt;code&gt;vsnprintf&lt;/code&gt; ). Однако, если &lt;code&gt;vsnprintf&lt;/code&gt; недоступен, к сожалению, будет использоваться небезопасный &lt;code&gt;vsprintf&lt;/code&gt; , который может переполнить буфер (есть проверка переполнения, но это может быть слишком поздно). Рассмотрите возможность использования вместо этого &lt;code&gt;sv_vcatpvf&lt;/code&gt; или получения &lt;code&gt;vsnprintf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="661ddafc70911db04cf396a10417bb22f9c9013f" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;strlcat&lt;/code&gt; if available, or a Perl implementation of it. This operates on C &lt;code&gt;NUL&lt;/code&gt; -terminated strings.</source>
          <target state="translated">Библиотека C &lt;code&gt;strlcat&lt;/code&gt; , если она доступна, или ее реализация на Perl. Это работает со строками, завершающимися в C &lt;code&gt;NUL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f1fcfbd88c7e47c13102ec9e5c6df21938df7a0" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;strlcpy&lt;/code&gt; if available, or a Perl implementation of it. This operates on C &lt;code&gt;NUL&lt;/code&gt; -terminated strings.</source>
          <target state="translated">Библиотека C &lt;code&gt;strlcpy&lt;/code&gt; , если она доступна, или ее реализация на Perl. Это работает со строками, завершающимися в C &lt;code&gt;NUL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e368fd4b911113fa139d4b324c13f128de90489" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;vsnprintf&lt;/code&gt; if available and standards-compliant. However, if if the &lt;code&gt;vsnprintf&lt;/code&gt; is not available, will unfortunately use the unsafe &lt;code&gt;vsprintf&lt;/code&gt; which can overrun the buffer (there is an overrun check, but that may be too late). Consider using &lt;code&gt;sv_vcatpvf&lt;/code&gt; instead, or getting &lt;code&gt;vsnprintf&lt;/code&gt; .</source>
          <target state="translated">Библиотека C &lt;code&gt;vsnprintf&lt;/code&gt; , если она доступна и соответствует стандартам. Однако, если &lt;code&gt;vsnprintf&lt;/code&gt; недоступен, к сожалению, будет использоваться небезопасный &lt;code&gt;vsprintf&lt;/code&gt; , который может переполнить буфер (есть проверка переполнения, но это может быть слишком поздно). Рассмотрите возможность использования вместо этого &lt;code&gt;sv_vcatpvf&lt;/code&gt; или получения &lt;code&gt;vsnprintf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5183e1e6aa36fa93c903a6e7e44a0cb72c213922" translate="yes" xml:space="preserve">
          <source>The C library routines listed in the table below return values based on the current locale. Use the entries in the final column for that functionality. The other two columns always assume a POSIX (or C) locale. The entries in the ASCII column are only meaningful for ASCII inputs, returning FALSE for anything else. Use these only when you &lt;b&gt;know&lt;/b&gt; that is what you want. The entries in the Latin1 column assume that the non-ASCII 8-bit characters are as Unicode defines, them, the same as ISO-8859-1, often called Latin 1.</source>
          <target state="translated">Подпрограммы библиотеки C, перечисленные в таблице ниже, возвращают значения в зависимости от текущей локали. Для этой функции используйте записи в последнем столбце. Два других столбца всегда предполагают языковой стандарт POSIX (или C). Записи в столбце ASCII имеют смысл только для входных данных ASCII, возвращая FALSE для всех остальных. Используйте их только тогда, когда &lt;b&gt;знаете,&lt;/b&gt; что именно этого хотите. Записи в столбце Latin1 предполагают, что 8-битные символы, отличные от ASCII, соответствуют определению Unicode, они такие же, как ISO-8859-1, часто называемые Latin 1.</target>
        </trans-unit>
        <trans-unit id="a28b4e51a54be7620c06b31ca4a6442c8879a612" translate="yes" xml:space="preserve">
          <source>The C pre-processor macro to use in the &lt;code&gt;#ifdef&lt;/code&gt; . This defaults to the</source>
          <target state="translated">Макрос препроцессора C для использования в &lt;code&gt;#ifdef&lt;/code&gt; . По умолчанию это</target>
        </trans-unit>
        <trans-unit id="e289a8cac4c6625ed2e896b05f021cd0b663f2cc" translate="yes" xml:space="preserve">
          <source>The C signature of the corresponding function should be</source>
          <target state="translated">Подпись С соответствующей функции должна быть</target>
        </trans-unit>
        <trans-unit id="434fa80b2289a7e8297f9f4dbd629257d6d523b1" translate="yes" xml:space="preserve">
          <source>The C source code and header files mostly live in the root of the source tree. There are a few platform-specific directories which contain C code. In addition, some of the modules shipped with Perl include C or XS code.</source>
          <target state="translated">Исходный код на C и заголовочные файлы в основном живут в корне дерева исходных текстов.Существует несколько платформоспецифичных каталогов,которые содержат код на Си.Кроме того,некоторые модули,поставляемые с Perl,содержат код на C или XS.</target>
        </trans-unit>
        <trans-unit id="128905b571f66231b1c910d09a2688b981aad8fb" translate="yes" xml:space="preserve">
          <source>The C standard defines the &lt;code&gt;LC_MONETARY&lt;/code&gt; category, but not a function that is affected by its contents. (Those with experience of standards committees will recognize that the working group decided to punt on the issue.) Consequently, Perl essentially takes no notice of it. If you really want to use &lt;code&gt;LC_MONETARY&lt;/code&gt; , you can query its contents--see &lt;a href=&quot;#The-localeconv-function&quot;&gt;The localeconv function&lt;/a&gt;--and use the information that it returns in your application's own formatting of currency amounts. However, you may well find that the information, voluminous and complex though it may be, still does not quite meet your requirements: currency formatting is a hard nut to crack.</source>
          <target state="translated">Стандарт C определяет категорию &lt;code&gt;LC_MONETARY&lt;/code&gt; , но не функцию, на которую влияет ее содержимое. (Те, у кого есть опыт работы с комитетами по стандартам, поймут, что рабочая группа решила заняться этим вопросом.) Следовательно, Perl по существу не замечает этого. Если вы действительно хотите использовать &lt;code&gt;LC_MONETARY&lt;/code&gt; , вы можете запросить его содержимое - см. &lt;a href=&quot;#The-localeconv-function&quot;&gt;Функция localeconv&lt;/a&gt; - и использовать информацию, которую она возвращает, в собственном форматировании денежных сумм вашего приложения. Однако вы вполне можете обнаружить, что информация, какой бы объемной и сложной она ни была, все же не совсем соответствует вашим требованиям: форматирование валюты - это крепкий орешек.</target>
        </trans-unit>
        <trans-unit id="9998f45e4c7233897bbe30273f117556d7539b74" translate="yes" xml:space="preserve">
          <source>The C structures used by Perl's internals to hold SV and OP information (PVIV, AV, HV, ..., OP, SVOP, UNOP, ...) are modelled on a class hierarchy and the &lt;code&gt;B&lt;/code&gt; module gives access to them via a true object hierarchy. Structure fields which point to other objects (whether types of SV or types of OP) are represented by the &lt;code&gt;B&lt;/code&gt; module as Perl objects of the appropriate class.</source>
          <target state="translated">Структуры C, используемые внутренним устройством Perl для хранения информации SV и OP (PVIV, AV, HV, ..., OP, SVOP, UNOP, ...), смоделированы на основе иерархии классов, и модуль &lt;code&gt;B&lt;/code&gt; предоставляет доступ к ним через истинная иерархия объектов. Поля структуры, которые указывают на другие объекты (будь то типы SV или типы OP), представлены модулем &lt;code&gt;B&lt;/code&gt; как объекты Perl соответствующего класса.</target>
        </trans-unit>
        <trans-unit id="e52cd1f128c9fdf3705990415e2a1725ce8c0daa" translate="yes" xml:space="preserve">
          <source>The C style for loop is rarely needed in Perl since Perl provides the more friendly list scanning &lt;code&gt;foreach&lt;/code&gt; loop.</source>
          <target state="translated">Стиль C для цикла for редко требуется в Perl, поскольку Perl предоставляет более удобный цикл просмотра списка по каждому &lt;code&gt;foreach&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41766adf1b20a48cee72fe6667e88ebc85cdc6f9" translate="yes" xml:space="preserve">
          <source>The C variable which corresponds to Perl's $^W warning variable.</source>
          <target state="translated">Переменная C,которая соответствует переменной предупреждения Perl's $^W.</target>
        </trans-unit>
        <trans-unit id="dfa119354e27d0075a95b6198dbb34324da3f2fb" translate="yes" xml:space="preserve">
          <source>The C-level function pointer is returned in</source>
          <target state="translated">Указатель функции С-уровня возвращается в</target>
        </trans-unit>
        <trans-unit id="230e53618d509a745420dd7ed8f916298cb8a1f6" translate="yes" xml:space="preserve">
          <source>The C-level function pointer is supplied in</source>
          <target state="translated">Указатель функции С-уровня поставляется в</target>
        </trans-unit>
        <trans-unit id="1e1b0aeffa7ba38a3388c23b72c5a0f47c58d0b1" translate="yes" xml:space="preserve">
          <source>The C3 MRO</source>
          <target state="translated">C3 MRO</target>
        </trans-unit>
        <trans-unit id="0890f76e297e8a69278390e1b8b2216c138a276e" translate="yes" xml:space="preserve">
          <source>The C3 order also lets you call methods in sibling classes with the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; pseudo-class. See the &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; documentation for more details on this feature.</source>
          <target state="translated">Порядок C3 также позволяет вам вызывать методы в родственных классах со &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; псевдоклассом. Дополнительную информацию об этой функции см. &lt;a href=&quot;mro&quot;&gt;В&lt;/a&gt; документации по mro .</target>
        </trans-unit>
        <trans-unit id="d0ff2a087cbd21d4354452514069e5aa62203f63" translate="yes" xml:space="preserve">
          <source>The CASE: Keyword</source>
          <target state="translated">CASE:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="c34759e310ffd05ba41a3c6d9e4717368401e66b" translate="yes" xml:space="preserve">
          <source>The CASE: keyword allows an XSUB to have multiple distinct parts with each part acting as a virtual XSUB. CASE: is greedy and if it is used then all other XS keywords must be contained within a CASE:. This means nothing may precede the first CASE: in the XSUB and anything following the last CASE: is included in that case.</source>
          <target state="translated">Ключевое слово CASE:позволяет XSUB иметь несколько отдельных частей,каждая из которых действует как виртуальный XSUB.CASE:является жадным,и если оно используется,то все остальные ключевые слова XS должны содержаться внутри CASE:.Это означает,что ничто не может предшествовать первому CASE:в XSUB и в этом случае включается все,что следует за последним CASE:.</target>
        </trans-unit>
        <trans-unit id="fae674d05cdd7c7c93ed58176b2c5091862f5184" translate="yes" xml:space="preserve">
          <source>The CLEANUP: Keyword</source>
          <target state="translated">ОЧИСТКА:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="241f3ed896c795a2f153c574bd096719fc549cce" translate="yes" xml:space="preserve">
          <source>The CODE: Keyword</source>
          <target state="translated">КОД:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="75462a30b7eda0a1256e9e78d46c9b66a39ca496" translate="yes" xml:space="preserve">
          <source>The CODEHASHREF is a reference to a hash containing names as keys and either a string to eval or a code reference for each value. For each (KEY, VALUE) pair in the CODEHASHREF, this routine will call</source>
          <target state="translated">CODEHASHREF-это ссылка на хэш,содержащий имена в качестве ключей и либо строку для оценки,либо кодовую ссылку для каждого значения.Для каждой пары (KEY,VALUE)в CODEHASHREF эта рутина будет вызывать команду</target>
        </trans-unit>
        <trans-unit id="2d375a6aa9b8906ba2ffceffe206a677c43a7349" translate="yes" xml:space="preserve">
          <source>The COP's hint flags, rendered with abbreviated names if possible. An empty string if this is not a COP. Here are the symbols used:</source>
          <target state="translated">флаги подсказок КС,по возможности с сокращенными названиями.Пустая строка,если это не COP.Вот использованные символы:</target>
        </trans-unit>
        <trans-unit id="1edd5ccb6f317807268c4d710f3579aef8a9d833" translate="yes" xml:space="preserve">
          <source>The COUNT can be zero or negative, see timethis().</source>
          <target state="translated">COUNT может быть нулевым или отрицательным,см.timethis().</target>
        </trans-unit>
        <trans-unit id="d7abd867e28669bc36a83d10cc2868dd307bb204" translate="yes" xml:space="preserve">
          <source>The COUNT can be zero or negative: this means the</source>
          <target state="translated">COUNT может быть нулевым или отрицательным:это означает,что</target>
        </trans-unit>
        <trans-unit id="7180933318067029f5e634690ac1d29792da70f9" translate="yes" xml:space="preserve">
          <source>The CPAN indexes are usually rebuilt once or twice per hour, but the typical CPAN mirror mirrors only once or twice per day. Depending on the quality of your mirror and your desire to be on the bleeding edge, you may want to set the following value to more or less than one day (which is the default). It determines after how many days CPAN.pm downloads new indexes.</source>
          <target state="translated">Обычно CPAN-индексы перестраиваются один или два раза в час,но типичные CPAN-зеркала зеркала перестраиваются только один или два раза в день.В зависимости от качества вашего зеркала и вашего желания быть на краю кровотечения,вы можете установить следующее значение более или менее одного дня (что является значением по умолчанию).Оно определяет,через сколько дней CPAN.pm загружает новые индексы.</target>
        </trans-unit>
        <trans-unit id="377d91db5cfe6b5bd06da1ed353fc316766187b9" translate="yes" xml:space="preserve">
          <source>The CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ExtendedColor&quot;&gt;Term::ExtendedColor&lt;/a&gt; provides a different and more comprehensive interface for 256-color emulators that may be more convenient. The CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console::ANSI&quot;&gt;Win32::Console::ANSI&lt;/a&gt; provides ANSI color (and other escape sequence) support in the Win32 Console environment.</source>
          <target state="translated">Модуль CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ExtendedColor&quot;&gt;Term :: ExtendedColor&lt;/a&gt; предоставляет другой, более полный интерфейс для 256-цветных эмуляторов, который может быть более удобным. Модуль CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console::ANSI&quot;&gt;Win32 :: Console :: ANSI&lt;/a&gt; обеспечивает поддержку цвета ANSI (и других управляющих последовательностей) в среде Win32 Console.</target>
        </trans-unit>
        <trans-unit id="d6b4425af9b4e8fb2b471139f3e26220141f7951" translate="yes" xml:space="preserve">
          <source>The CPAN module also supports named and versioned</source>
          <target state="translated">Модуль CPAN также поддерживает именованные и версированные</target>
        </trans-unit>
        <trans-unit id="0c026574d1a86a555bc568a8cb4ff270316b96bc" translate="yes" xml:space="preserve">
          <source>The CPAN module automates or at least simplifies the make and install of perl modules and extensions. It includes some primitive searching capabilities and knows how to use LWP, HTTP::Tiny, Net::FTP and certain external download clients to fetch distributions from the net.</source>
          <target state="translated">Модуль CPAN автоматизирует или,по крайней мере,упрощает изготовление и установку perl модулей и расширений.Он включает в себя некоторые возможности примитивного поиска и знает,как использовать LWP,HTTP::Tiny,Net::FTP и некоторые внешние клиенты загрузки для получения дистрибутивов из сети.</target>
        </trans-unit>
        <trans-unit id="4e178ebb5191d2f8095d21912890034971c23f17" translate="yes" xml:space="preserve">
          <source>The CPAN module can detect when a module which you are trying to build depends on prerequisites. If this happens, it can build the prerequisites for you automatically ('follow'), ask you for confirmation ('ask'), or just ignore them ('ignore'). Choosing 'follow' also sets PERL_AUTOINSTALL and PERL_EXTUTILS_AUTOINSTALL for &quot;--defaultdeps&quot; if not already set.</source>
          <target state="translated">Модуль CPAN может определить,когда модуль,который вы пытаетесь построить,зависит от предварительных условий.Если это произойдет,он может автоматически создать предпосылки для вас (&quot;следовать&quot;),запросить подтверждение (&quot;спросить&quot;)или просто проигнорировать их (&quot;проигнорировать&quot;).Выбор 'следовать' также устанавливает PERL_AUTOINSTALL и PERL_EXTUTILS_AUTOINSTALL для &quot;--defaultdeps&quot;,если они еще не установлены.</target>
        </trans-unit>
        <trans-unit id="6c6573c37a2e4b0e2c1f6ecf5ee527de52c79b5e" translate="yes" xml:space="preserve">
          <source>The CPAN program is trying to depend on as little as possible so the user can use it in hostile environment. It works better the more goodies the environment provides. For example if you try in the CPAN shell</source>
          <target state="translated">Программа CPAN пытается как можно меньше зависеть от нее,чтобы пользователь мог использовать ее во враждебном окружении.Она работает лучше,чем больше пользы предоставляет окружение.Например,если вы попробуете в CPAN оболочке</target>
        </trans-unit>
        <trans-unit id="85d1aee245c3b6a287276d71fb8b02358e6086ca" translate="yes" xml:space="preserve">
          <source>The CPAN testers ( &lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt; ) are a group of volunteers who test CPAN modules on a variety of platforms.</source>
          <target state="translated">Тестировщики CPAN ( &lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt; ) - это группа добровольцев, которые тестируют модули CPAN на различных платформах.</target>
        </trans-unit>
        <trans-unit id="e02636a6cb280626a26310497466ab4002dc994b" translate="yes" xml:space="preserve">
          <source>The CRC32 and ISIZE trailer fields must be present.</source>
          <target state="translated">Поля для прицепов CRC32 и ISIZE должны присутствовать.</target>
        </trans-unit>
        <trans-unit id="9feb874c73b191dd9599e9b2017419a0da4abb3d" translate="yes" xml:space="preserve">
          <source>The C_ARGS: Keyword</source>
          <target state="translated">C_ARGS:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="701e155d0ecdee0723938fe9c7bf1396f627436a" translate="yes" xml:space="preserve">
          <source>The C_ARGS: keyword allows creating of XSUBS which have different calling sequence from Perl than from C, without a need to write CODE: or PPCODE: section. The contents of the C_ARGS: paragraph is put as the argument to the called C function without any change.</source>
          <target state="translated">Ключевое слово C_ARGS:позволяет создавать XSUBS,которые имеют иную последовательность вызовов с Perl,чем с C,без необходимости записывать раздел CODE:или PPCODE:.Содержимое параграфа C_ARGS:помещается в качестве аргумента в вызываемую функцию C без изменений.</target>
        </trans-unit>
        <trans-unit id="8dd34313e432c589bd3beca248664e04fa335c40" translate="yes" xml:space="preserve">
          <source>The Carp module first appeared in Larry Wall's perl 5.000 distribution. Since then it has been modified by several of the perl 5 porters. Andrew Main (Zefram) &amp;lt;zefram@fysh.org&amp;gt; divested Carp into an independent distribution.</source>
          <target state="translated">Модуль Carp впервые появился в дистрибутиве Perl 5.000 Ларри Уолла. С тех пор он был изменен несколькими портерами Perl 5. Эндрю Мэйн (Zefram) &amp;lt;zefram@fysh.org&amp;gt; выделил Carp в независимый дистрибутив.</target>
        </trans-unit>
        <trans-unit id="73aa54f605c75d537db25ae13f844b387570066b" translate="yes" xml:space="preserve">
          <source>The Carp routines are useful in your own modules because they act like &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt;, but with a message which is more likely to be useful to a user of your module. In the case of &lt;code&gt;cluck()&lt;/code&gt; and &lt;code&gt;confess()&lt;/code&gt; , that context is a summary of every call in the call-stack; &lt;code&gt;longmess()&lt;/code&gt; returns the contents of the error message.</source>
          <target state="translated">Подпрограммы Carp полезны в ваших собственных модулях, потому что они действуют как &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; , но с сообщением, которое с большей вероятностью будет полезно пользователю вашего модуля. В случае &lt;code&gt;cluck()&lt;/code&gt; и &lt;code&gt;confess()&lt;/code&gt; этот контекст представляет собой сводку каждого вызова в стеке вызовов; &lt;code&gt;longmess()&lt;/code&gt; возвращает содержимое сообщения об ошибке.</target>
        </trans-unit>
        <trans-unit id="0a9dcee0d40bd7f4aac08fafa5945185600a2589" translate="yes" xml:space="preserve">
          <source>The Carp routines don't handle exception objects currently. If called with a first argument that is a reference, they simply call die() or warn(), as appropriate.</source>
          <target state="translated">В настоящее время Carp-процедуры не работают с объектами исключений.При вызове с первым аргументом,который является ссылкой,они просто вызывают die()или warning(),соответственно.</target>
        </trans-unit>
        <trans-unit id="f74ecb659d2dae844024a2a7edc2eb73241a6948" translate="yes" xml:space="preserve">
          <source>The Color Stack</source>
          <target state="translated">Цветной стек</target>
        </trans-unit>
        <trans-unit id="0e751c2cd8e75382ca856116ff4097eafeafab18" translate="yes" xml:space="preserve">
          <source>The Comprehensive Perl Archive Network (CPAN) offers a wealth of extensions, some of which require a C compiler to build. Look in &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; for more information on CPAN.</source>
          <target state="translated">Комплексная сеть архивов Perl (CPAN) предлагает множество расширений, для сборки некоторых из которых требуется компилятор C. Посетите &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; для получения дополнительной информации о CPAN.</target>
        </trans-unit>
        <trans-unit id="2a3290ed25612a4eaac36507c34578ae080df3b2" translate="yes" xml:space="preserve">
          <source>The Comprehensive Perl Archive Network. (See the Camel Preface and Camel chapter 19, &amp;ldquo;CPAN&amp;rdquo; for details.)</source>
          <target state="translated">Комплексная сеть архивов Perl. (Подробности см. В Предисловии к Camel и в главе 19 &amp;laquo;CPAN&amp;raquo; о верблюдах.)</target>
        </trans-unit>
        <trans-unit id="fbde9b6a7a92989c5e72924e954088639a082096" translate="yes" xml:space="preserve">
          <source>The Config module contains all the information that was available to the &lt;code&gt;Configure&lt;/code&gt; program at Perl build time (over 900 values).</source>
          <target state="translated">Модуль Config содержит всю информацию, которая была доступна программе &lt;code&gt;Configure&lt;/code&gt; во время сборки Perl (более 900 значений).</target>
        </trans-unit>
        <trans-unit id="f82ec628dc6b60e59ddc0aa4e8da2f644e35b47f" translate="yes" xml:space="preserve">
          <source>The Config module is installed into the architecture and version specific library directory ($Config{installarchlib}) and it checks the perl version number when loaded.</source>
          <target state="translated">Модуль Config устанавливается в каталог библиотек архитектуры и конкретных версий ($Config{installarchlib})и при загрузке проверяет номер версии perl.</target>
        </trans-unit>
        <trans-unit id="cfdfb921abaaac3f8f467a1db7786aa8a018327d" translate="yes" xml:space="preserve">
          <source>The Config::Extensions module provides a hash &lt;code&gt;%Extensions&lt;/code&gt; containing all the core extensions that were enabled for this perl. The hash is keyed by extension name, with each entry having one of 3 possible values:</source>
          <target state="translated">Модуль Config :: Extensions предоставляет хэш &lt;code&gt;%Extensions&lt;/code&gt; содержащий все основные расширения, которые были включены для этого perl. Ключ хеша задается именем расширения, каждая запись имеет одно из трех возможных значений:</target>
        </trans-unit>
        <trans-unit id="93bfc257b83bc0f3f1d509f0feed1135175ce382" translate="yes" xml:space="preserve">
          <source>The Conformance Test for the UCA is available under &lt;a href=&quot;http://www.unicode.org/Public/UCA/&quot;&gt;http://www.unicode.org/Public/UCA/&lt;/a&gt;.</source>
          <target state="translated">Тест на соответствие для УЦА доступен по &lt;a href=&quot;http://www.unicode.org/Public/UCA/&quot;&gt;адресу http://www.unicode.org/Public/UCA/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9099e439d69987253b372d83d6abc9bc4c12963" translate="yes" xml:space="preserve">
          <source>The Curses module from CPAN provides a dynamically loadable object module interface to a curses library. A small demo can be found at the directory &lt;a href=&quot;http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz&quot;&gt;http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz&lt;/a&gt; ; this program repeats a command and updates the screen as needed, rendering &lt;b&gt;rep ps axu&lt;/b&gt; similar to &lt;b&gt;top&lt;/b&gt;.</source>
          <target state="translated">Модуль Curses из CPAN предоставляет интерфейс динамически загружаемого объектного модуля для библиотеки curses. Небольшую демонстрацию можно найти в каталоге &lt;a href=&quot;http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz&quot;&gt;http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz&lt;/a&gt; ; эта программа повторяет команду и обновляет экран по мере необходимости, отображая &lt;b&gt;rep ps axu&lt;/b&gt; аналогично &lt;b&gt;top&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="e14abdffc22e514738def0dbe442a1a41dfd62a8" translate="yes" xml:space="preserve">
          <source>The CvDEPTH'th entry of a PADLIST is a PAD (an AV) which is the stack frame at that depth of recursion into the CV. The 0th slot of a frame AV is an AV which is @_. Other entries are storage for variables and op targets.</source>
          <target state="translated">Ввод CvDEPTH'а PADLIST-это PAD (AV),который является рамкой стека на этой глубине рекурсии в CV.0-й слот кадра AV-это AV,который является @_.Остальные записи являются хранилищем для переменных и целей опции.</target>
        </trans-unit>
        <trans-unit id="4c8b698edc086f6d5f09074b59ab49b539df94b8" translate="yes" xml:space="preserve">
          <source>The Cygwin &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt; implementation has holes (it can not restrict file access by native Win32 programs).</source>
          <target state="translated">В реализации Cygwin &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt; есть дыры (она не может ограничивать доступ к файлам с помощью собственных программ Win32).</target>
        </trans-unit>
        <trans-unit id="24d81b19eab85eca5ef9e9f2cae5a86c87573ad6" translate="yes" xml:space="preserve">
          <source>The Cygwin &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink()&lt;/a&gt;&lt;/code&gt; functions make the</source>
          <target state="translated">Функции Cygwin &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink()&lt;/a&gt;&lt;/code&gt; делают</target>
        </trans-unit>
        <trans-unit id="ba192629e74cc31eca240e3c966c286bb927abba" translate="yes" xml:space="preserve">
          <source>The Cygwin environment for Win32;</source>
          <target state="translated">Среда Cygwin для Win32;</target>
        </trans-unit>
        <trans-unit id="1c285b2bd2bfb42d86890b2e5f1ea0881773f57b" translate="yes" xml:space="preserve">
          <source>The Cygwin tools are ports of the popular GNU development tools for Win32 platforms. They run thanks to the Cygwin library which provides the UNIX system calls and environment these programs expect. More information about this project can be found at:</source>
          <target state="translated">Инструменты Cygwin являются портами популярных GNU инструментов разработки для Win32 платформ.Они работают благодаря библиотеке Cygwin,которая обеспечивает системные вызовы UNIX и среду,ожидаемую этими программами.Более подробную информацию об этом проекте можно найти по адресу:</target>
        </trans-unit>
        <trans-unit id="b1c1f15ff329b2e8194094e815d08360dc942cc0" translate="yes" xml:space="preserve">
          <source>The DB_BTREE format is useful when you want to store data in a given order. By default the keys will be stored in lexical order, but as you will see from the example shown in the next section, it is very easy to define your own sorting function.</source>
          <target state="translated">Формат DB_BTREE полезен,когда вы хотите хранить данные в заданном порядке.По умолчанию ключи будут храниться в лексическом порядке,но,как вы увидите из примера,показанного в следующем разделе,очень легко определить свою собственную функцию сортировки.</target>
        </trans-unit>
        <trans-unit id="da84dd6e821316467ab753b852b3c6f56039e638" translate="yes" xml:space="preserve">
          <source>The DB_File interface was written by Paul Marquess &amp;lt;pmqs@cpan.org&amp;gt;.</source>
          <target state="translated">Интерфейс DB_File был написан Полом Маркизом &amp;lt;pmqs@cpan.org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="bc4b830fc8435dde71447902321a40e9b54b9e85" translate="yes" xml:space="preserve">
          <source>The DB_File tests (db-btree.t, db-hash.t, db-recno.t) may fail you have installed a newer version of Berkeley DB into the system and the -I and -L compiler and linker flags introduce version conflicts with the DB 1.85 headers and libraries that came with the Tru64. For example, mixing a DB v2 library with the DB v1 headers is a bad idea. Watch out for Configure options -Dlocincpth and -Dloclibpth, and check your /usr/local/include and /usr/local/lib since they are included by default.</source>
          <target state="translated">Тесты DB_File (db-btree.t,db-hash.t,db-recno.t)могут не сработать,если вы установили в систему более новую версию БД Berkeley,а флаги компилятора -I и -L и компоновщика компоновки вводят конфликты версий с заголовками и библиотеками БД 1.85,которые поставляются с Tru64.Например,смешивание библиотеки DB v2 с заголовками DB v1-плохая идея.Обратите внимание на опции Configure -Dlocincpth и -Dloclibpth,и проверьте /usr/local/include и /usr/local/lib,так как они включены по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4aa7475384871e821eca8486a731a00b705b7453" translate="yes" xml:space="preserve">
          <source>The DB_HASH file format is probably the most commonly used of the three file formats that &lt;b&gt;DB_File&lt;/b&gt; supports. It is also very straightforward to use.</source>
          <target state="translated">Формат файла DB_HASH, вероятно, является наиболее часто используемым из трех форматов файлов, которые поддерживает &lt;b&gt;DB_File&lt;/b&gt; . Его также очень просто использовать.</target>
        </trans-unit>
        <trans-unit id="093622558089c2ef694fcbf575b62744b7d5e02e" translate="yes" xml:space="preserve">
          <source>The DEBUGGING define exposes more code to the compiler, therefore more ways for things to go wrong. You should try it.</source>
          <target state="translated">Определение DEBUGGING раскрывает компилятору больше кода,а значит больше возможностей для того,чтобы что-то пошло не так.Попробуйте.</target>
        </trans-unit>
        <trans-unit id="cd3218b27f646c5b1da0c16a7d86f78d988008e7" translate="yes" xml:space="preserve">
          <source>The DECC$FILENAME_UNIX_REPORT logical name controls how Perl interprets filenames to the extent that Perl uses the CRTL internally for many purposes, and attempts to follow CRTL conventions for reporting filenames. The DECC$FILENAME_UNIX_ONLY feature differs in that it expects all filenames passed to the C run-time to be already in Unix format. This feature is not yet supported in Perl since Perl uses traditional OpenVMS file specifications internally and in the test harness, and it is not yet clear whether this mode will be useful or useable. The feature logical name DECC$POSIX_COMPLIANT_PATHNAMES is new with the RMS Symbolic Link SDK and included with OpenVMS v8.3, but is not yet supported in Perl.</source>
          <target state="translated">Логическое имя DECC$FILENAME_UNIX_REPORT управляет тем,как Perl интерпретирует имена файлов в той степени,в которой Perl использует CRTL для многих целей,и пытается следовать конвенциям CRTL для отчетности по именам файлов.Функция DECC$FILENAME_UNIX_ONLY отличается тем,что она ожидает,что все имена файлов,переданные во время выполнения C,будут уже в формате Unix.Эта возможность еще не поддерживается в Perl,так как Perl использует традиционные спецификации файлов OpenVMS как внутри,так и в тестовом жгуте,и пока не ясно,будет ли этот режим полезным или пригодным для использования.Логическое имя функции DECC$POSIX_COMPLIANT_PATHNAMES является новым в RMS Symbolic Link SDK и включено в OpenVMS v8.3,но пока не поддерживается в Perl.</target>
        </trans-unit>
        <trans-unit id="9d134d51441969270625bd1289ca90b131d940f8" translate="yes" xml:space="preserve">
          <source>The DOS FAT filesystem can accommodate only &quot;8.3&quot; style filenames. Under the &quot;case-insensitive, but case-preserving&quot; HPFS (OS/2) and NTFS (NT) filesystems you may have to be careful about case returned with functions like &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; or used with functions like &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Файловая система DOS FAT может поддерживать имена файлов только в стиле &quot;8.3&quot;. В файловых системах HPFS (OS / 2) и NTFS (NT) с &quot;нечувствительностью к регистру, но сохраняющими регистр&quot; вам, возможно, придется быть осторожным с регистром, возвращаемым функциями, такими как &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; , или используемыми с функциями, такими как &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37eace57ea45e399a72f8107235f1e100b1ee8bb" translate="yes" xml:space="preserve">
          <source>The DynaLoader is designed to be a very simple high-level interface that is sufficiently general to cover the requirements of SunOS, HP-UX, Linux, VMS and other platforms.</source>
          <target state="translated">DynaLoader разработан как очень простой интерфейс высокого уровня,достаточно общий,чтобы покрыть требования SunOS,HP-UX,Linux,VMS и других платформ.</target>
        </trans-unit>
        <trans-unit id="f912c465834fcee4d486c53fdce3a5c5359e646e" translate="yes" xml:space="preserve">
          <source>The EBCDIC code page in use on Siemens' BS2000 system is distinct from 1047 and 0037. It is identified below as the POSIX-BC set. Like 0037 and 1047, it is the same as ISO 8859-1 in 20 code point values.</source>
          <target state="translated">Кодовая страница EBCDIC,используемая в системе BS2000 компании Siemens,отличается от 1047 и 0037.Она идентифицируется ниже как набор POSIX-BC.Как и 0037 и 1047,она аналогична ISO 8859-1 в 20 значениях кодовых точек.</target>
        </trans-unit>
        <trans-unit id="79364f1341ebeff610668d7a68e618ee03998d55" translate="yes" xml:space="preserve">
          <source>The EBCDIC controls provide three possible line terminator characters, CR (0x0D), LF (0x25), and NL (0x15). On ASCII platforms, the symbols &quot;NL&quot; and &quot;LF&quot; refer to the same character, but in strict EBCDIC terminology they are different ones. The EBCDIC NL is mapped to the C1 control called &quot;NEL&quot; (&quot;Next Line&quot;; here's a case where the mapping makes quite a bit of sense, and hence isn't just arbitrary). On some EBCDIC platforms, this NL or NEL is the typical line terminator. This is true of z/OS and BS2000. In these platforms, the C compilers will swap the LF and NEL code points, so that &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is 0x15, and refers to NL. Perl does that too; you can see it in the code chart &lt;a href=&quot;#recipe-3&quot;&gt;below&lt;/a&gt;. This makes things generally &quot;just work&quot; without you even having to be aware that there is a swap.</source>
          <target state="translated">Элементы управления EBCDIC предоставляют три возможных символа конца строки: CR (0x0D), LF (0x25) и NL (0x15). На платформах ASCII символы &amp;laquo;NL&amp;raquo; и &amp;laquo;LF&amp;raquo; относятся к одному и тому же символу, но в строгой терминологии EBCDIC они разные. EBCDIC NL отображается на элемент управления C1, называемый &amp;laquo;NEL&amp;raquo; (&amp;laquo;Следующая строка&amp;raquo;; вот случай, когда отображение имеет некоторый смысл и, следовательно, не просто произвольно). На некоторых платформах EBCDIC этот NL или NEL является типичным терминатором линии. Это верно для z / OS и BS2000. На этих платформах компиляторы C меняют местами кодовые точки LF и NEL, так что &lt;code&gt;&quot;\n&quot;&lt;/code&gt; равно 0x15 и относится к NL. Perl тоже это делает; вы можете увидеть это в таблице кодов &lt;a href=&quot;#recipe-3&quot;&gt;ниже&lt;/a&gt; . Это заставляет вещи &quot;просто работать&quot;без необходимости даже знать, что есть своп.</target>
        </trans-unit>
        <trans-unit id="ebf0849b9c64cecc2853f7671dcdaa67dfb5bd40" translate="yes" xml:space="preserve">
          <source>The EMX environment for DOS, OS/2, etc. emx@iaehv.nl, &lt;a href=&quot;ftp://hobbes.nmsu.edu/pub/os2/dev/emx/&quot;&gt;ftp://hobbes.nmsu.edu/pub/os2/dev/emx/&lt;/a&gt; Also &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;.</source>
          <target state="translated">Среда EMX для DOS, OS / 2 и т. Д. Emx@iaehv.nl, &lt;a href=&quot;ftp://hobbes.nmsu.edu/pub/os2/dev/emx/&quot;&gt;ftp://hobbes.nmsu.edu/pub/os2/dev/emx/&lt;/a&gt; Также &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="256f82d42fe9ffdaee741a9745d27494e5988357" translate="yes" xml:space="preserve">
          <source>The EXPORT_XSUB_SYMBOLS: Keyword</source>
          <target state="translated">EXPORT_XSUB_SYMBOLS:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="dc2d72754e20f4d7576339fd0b632f9904767606" translate="yes" xml:space="preserve">
          <source>The EXPORT_XSUB_SYMBOLS: keyword is likely something you will never need. In perl versions earlier than 5.16.0, this keyword does nothing. Starting with 5.16, XSUB symbols are no longer exported by default. That is, they are &lt;code&gt;static&lt;/code&gt; functions. If you include</source>
          <target state="translated">Ключевое слово EXPORT_XSUB_SYMBOLS: вероятно, вам никогда не понадобится. В версиях perl до 5.16.0 это ключевое слово ничего не делает. Начиная с версии 5.16 символы XSUB больше не экспортируются по умолчанию. То есть это &lt;code&gt;static&lt;/code&gt; функции. Если вы включите</target>
        </trans-unit>
        <trans-unit id="617a336bda8dcf8d5dea55c8c402db880f815331" translate="yes" xml:space="preserve">
          <source>The EXPR can be arbitrarily complicated provided its final operation is an element or slice of an aggregate:</source>
          <target state="translated">EXPR может быть произвольно сложным при условии,что его конечной операцией является элемент или кусочек агрегата:</target>
        </trans-unit>
        <trans-unit id="c1575f71c727dbc3cc08a704b1c6455476c26b21" translate="yes" xml:space="preserve">
          <source>The EXTEND() macro is used to make room on the argument stack for 2 return values. The PPCODE: directive causes the &lt;b&gt;xsubpp&lt;/b&gt; compiler to create a stack pointer available as &lt;code&gt;SP&lt;/code&gt; , and it is this pointer which is being used in the EXTEND() macro. The values are then pushed onto the stack with the PUSHs() macro.</source>
          <target state="translated">Макрос EXTEND () используется для освобождения места в стеке аргументов для двух возвращаемых значений. Директива PPCODE: заставляет компилятор &lt;b&gt;xsubpp&lt;/b&gt; создать указатель стека, доступный как &lt;code&gt;SP&lt;/code&gt; , и именно этот указатель используется в макросе EXTEND (). Затем значения помещаются в стек с помощью макроса PUSHs ().</target>
        </trans-unit>
        <trans-unit id="24d94044d20d73e1e217702a7997adf3573359ef" translate="yes" xml:space="preserve">
          <source>The Eclipse Perl Integration Project integrates Perl editing/debugging with Eclipse.</source>
          <target state="translated">Интеграционный проект Eclipse Perl объединяет редактирование/отладку Perl с Eclipse.</target>
        </trans-unit>
        <trans-unit id="089e76f353c6f78abb99ad80ce2ae65f3d8d4946" translate="yes" xml:space="preserve">
          <source>The Eighth, and Final Rule of Sys::Syslog is:</source>
          <target state="translated">Восьмое и последнее правило Sys::Syslog:</target>
        </trans-unit>
        <trans-unit id="45e6da0d5cb898ad01f0a9bae1837646548ecfe3" translate="yes" xml:space="preserve">
          <source>The Ellipsis Statement</source>
          <target state="translated">Эллипсисное заявление</target>
        </trans-unit>
        <trans-unit id="e36201c57b08755e4246cc5ce75f450c34e846b3" translate="yes" xml:space="preserve">
          <source>The Encode module is not available.</source>
          <target state="translated">Модуль кодирования недоступен.</target>
        </trans-unit>
        <trans-unit id="a85df1c32e44ae493b3d9d47f5ce746d47a72805" translate="yes" xml:space="preserve">
          <source>The Encode package comes with</source>
          <target state="translated">Пакет Encode поставляется в комплекте с</target>
        </trans-unit>
        <trans-unit id="1795442e49f2b33213fac82a59f9aa602577ec9d" translate="yes" xml:space="preserve">
          <source>The End Of Cargo Cult Programming</source>
          <target state="translated">Программирование культа груза в конце</target>
        </trans-unit>
        <trans-unit id="8b81b46699720b949c812be3aaed26b804f52e55" translate="yes" xml:space="preserve">
          <source>The English module, loaded via</source>
          <target state="translated">Английский модуль,загруженный через</target>
        </trans-unit>
        <trans-unit id="f6ae3dbecbd56f2fb799d619d775a492c5918b30" translate="yes" xml:space="preserve">
          <source>The English name $EXCEPTIONS_BEING_CAUGHT is slightly misleading, because the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value does not indicate whether exceptions are being caught, since compilation of the main program does not catch exceptions.</source>
          <target state="translated">Английское имя $ EXCEPTIONS_BEING_CAUGHT немного вводит в заблуждение, потому что &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; не указывает, перехватываются ли исключения, поскольку компиляция основной программы не перехватывает исключения.</target>
        </trans-unit>
        <trans-unit id="a563900434d5f24e6b403136d7617e396332a2c1" translate="yes" xml:space="preserve">
          <source>The Execution of this file takes 2 parameters as input. The first being the NetWare SDK path, second being the path for CodeWarrior Compiler &amp;amp; tools. Execution of this file sets these paths and also sets the build type to Release by default.</source>
          <target state="translated">Выполнение этого файла принимает 2 параметра в качестве входных данных. Первый - это путь к NetWare SDK, второй - путь для компилятора и инструментов CodeWarrior. Выполнение этого файла устанавливает эти пути, а также по умолчанию устанавливает тип сборки Release.</target>
        </trans-unit>
        <trans-unit id="f147b2a13785e77381665ed5dff1c497a9b6d450" translate="yes" xml:space="preserve">
          <source>The Exporter module implements an &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method which allows a module to export functions and variables to its users' namespaces. Many modules use Exporter rather than implementing their own &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method because Exporter provides a highly flexible interface, with an implementation optimised for the common case.</source>
          <target state="translated">Модуль Exporter реализует метод &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; который позволяет модулю экспортировать функции и переменные в пространства имен своих пользователей. Многие модули используют Exporter, а не реализуют свой собственный метод &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; поскольку Exporter предоставляет очень гибкий интерфейс с реализацией, оптимизированной для общего случая.</target>
        </trans-unit>
        <trans-unit id="f4abee164dbbeb51e77682498dd2aaadf957faf7" translate="yes" xml:space="preserve">
          <source>The Exporter module will convert an attempt to import a number from a module into a call to &lt;code&gt;$module_name-&amp;gt;VERSION($value)&lt;/code&gt; . This can be used to validate that the version of the module being used is greater than or equal to the required version.</source>
          <target state="translated">Модуль Exporter преобразует попытку импорта числа из модуля в вызов &lt;code&gt;$module_name-&amp;gt;VERSION($value)&lt;/code&gt; . Это можно использовать для проверки того, что версия используемого модуля больше или равна требуемой версии.</target>
        </trans-unit>
        <trans-unit id="7c52e8ff54cbaf19ce5405ab1f4fcb23fdb70082" translate="yes" xml:space="preserve">
          <source>The Extended Binary Coded Decimal Interchange Code refers to a large collection of single- and multi-byte coded character sets that are quite different from ASCII and ISO 8859-1, and are all slightly different from each other; they typically run on host computers. The EBCDIC encodings derive from 8-bit byte extensions of Hollerith punched card encodings, which long predate ASCII. The layout on the cards was such that high bits were set for the upper and lower case alphabetic characters &lt;code&gt;[a-z]&lt;/code&gt; and &lt;code&gt;[A-Z]&lt;/code&gt; , but there were gaps within each Latin alphabet range, visible in the table &lt;a href=&quot;#recipe-3&quot;&gt;below&lt;/a&gt;. These gaps can cause complications.</source>
          <target state="translated">Расширенный двоично-десятичный код обмена относится к большой коллекции однобайтовых и многобайтовых кодированных наборов символов, которые сильно отличаются от ASCII и ISO 8859-1, и все они немного отличаются друг от друга; они обычно работают на хост-компьютерах. Кодировки EBCDIC являются производными от 8-битных байтовых расширений кодировок перфокарт Холлерита, которые задолго до ASCII. Расположение на карточках было таким, что старшие биты были установлены для букв верхнего и нижнего регистра &lt;code&gt;[a-z]&lt;/code&gt; и &lt;code&gt;[A-Z]&lt;/code&gt; , но в каждом диапазоне латинского алфавита были пробелы, которые видны в таблице &lt;a href=&quot;#recipe-3&quot;&gt;ниже&lt;/a&gt; . Эти промежутки могут вызвать осложнения.</target>
        </trans-unit>
        <trans-unit id="6f06c8685e10bb2298b3fbb853d3946ef5600f7b" translate="yes" xml:space="preserve">
          <source>The Extended Time field (ID &quot;UT&quot;), set using the &lt;code&gt;exTime&lt;/code&gt; option, and the Unix2 extra field (ID &quot;Ux), set using the &lt;code&gt;exUnix2&lt;/code&gt; option, are examples of extra fields.</source>
          <target state="translated">Поле расширенного времени (ID &amp;laquo;UT&amp;raquo;), установленное с &lt;code&gt;exTime&lt;/code&gt; опции exTime , и дополнительное поле Unix2 (ID &amp;laquo;Ux), установленное с &lt;code&gt;exUnix2&lt;/code&gt; опции exUnix2 , являются примерами дополнительных полей.</target>
        </trans-unit>
        <trans-unit id="fcb46fea1b1fd4aac6612092ac926ea662164c18" translate="yes" xml:space="preserve">
          <source>The FALLBACK: Keyword</source>
          <target state="translated">FALLBACK:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="81e67da9b589fcad262531decfe34d5e04ad538d" translate="yes" xml:space="preserve">
          <source>The FTP protocol allows files to be sent to or fetched from the server. Each transfer involves a &lt;b&gt;local file&lt;/b&gt; (on the client) and a &lt;b&gt;remote file&lt;/b&gt; (on the server). In this module, the same file name will be used for both local and remote if only one is specified. This means that transferring remote file &lt;code&gt;/path/to/file&lt;/code&gt; will try to put that file in &lt;code&gt;/path/to/file&lt;/code&gt; locally, unless you specify a local file name.</source>
          <target state="translated">Протокол FTP позволяет отправлять файлы на сервер или получать с него. Каждая передача включает &lt;b&gt;локальный файл&lt;/b&gt; (на клиенте) и &lt;b&gt;удаленный файл&lt;/b&gt; (на сервере). В этом модуле одно и то же имя файла будет использоваться как для локального, так и для удаленного, если указано только одно. Это означает, что при передаче удаленного файла &lt;code&gt;/path/to/file&lt;/code&gt; будет помещен в &lt;code&gt;/path/to/file&lt;/code&gt; локально, если вы не укажете имя локального файла.</target>
        </trans-unit>
        <trans-unit id="19ca5c1f27cf809b055786ff82f78ffa209098e1" translate="yes" xml:space="preserve">
          <source>The Field @* for Variable-Width Multi-Line Text</source>
          <target state="translated">Поле @*для многострочного текста переменной ширины</target>
        </trans-unit>
        <trans-unit id="e40af0a7d64eded8997f1df4aaf651855caff401" translate="yes" xml:space="preserve">
          <source>The Field ^* for Variable-Width One-line-at-a-time Text</source>
          <target state="translated">Поле ^*для Текста переменной ширины на одну строку в один раз.</target>
        </trans-unit>
        <trans-unit id="051fa4e84ae2fee9062644631a452abe1ffe1819" translate="yes" xml:space="preserve">
          <source>The Fifth Rule of Sys::Syslog is:</source>
          <target state="translated">Пятое правило Sys::Syslog:</target>
        </trans-unit>
        <trans-unit id="916ba58ad633c9294928c7ea005c39a240dcf055" translate="yes" xml:space="preserve">
          <source>The File::Compare::compare function compares the contents of two sources, each of which can be a file or a file handle. It is exported from File::Compare by default.</source>
          <target state="translated">Функция File::Compare::comparison сравнивает содержимое двух источников,каждый из которых может быть файлом или файловым дескриптором.По умолчанию она экспортируется из File::Compare.</target>
        </trans-unit>
        <trans-unit id="ca8ebdce3138f1ac959e2447b9991cb0fe638baf" translate="yes" xml:space="preserve">
          <source>The File::Copy module provides two basic functions, &lt;code&gt;copy&lt;/code&gt; and &lt;code&gt;move&lt;/code&gt; , which are useful for getting the contents of a file from one place to another.</source>
          <target state="translated">Модуль File :: Copy предоставляет две основные функции, &lt;code&gt;copy&lt;/code&gt; и &lt;code&gt;move&lt;/code&gt; , которые полезны для переноса содержимого файла из одного места в другое.</target>
        </trans-unit>
        <trans-unit id="09b1bcb4dc016e97cb98e50f74998315b3fcc200" translate="yes" xml:space="preserve">
          <source>The File::Temp has been a standard module since Perl 5.6.1. If you don't have a modern enough Perl installed, use the &lt;code&gt;new_tmpfile&lt;/code&gt; class method from the IO::File module to get a filehandle opened for reading and writing. Use it if you don't need to know the file's name:</source>
          <target state="translated">File :: Temp был стандартным модулем начиная с Perl 5.6.1. Если у вас не установлен достаточно современный Perl, используйте &lt;code&gt;new_tmpfile&lt;/code&gt; класса new_tmpfile из модуля IO :: File, чтобы открыть дескриптор файла для чтения и записи. Используйте его, если вам не нужно знать имя файла:</target>
        </trans-unit>
        <trans-unit id="b913943216bac4cfd103b39436c3d12211246595" translate="yes" xml:space="preserve">
          <source>The Filter</source>
          <target state="translated">Фильтр</target>
        </trans-unit>
        <trans-unit id="43340f79f355f6131007a53845317a0044b9a6f5" translate="yes" xml:space="preserve">
          <source>The Filter::Simple module exports into the package that calls &lt;code&gt;FILTER&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;s it directly) -- such as package &quot;BANG&quot; in the above example -- two automagically constructed subroutines -- &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;unimport&lt;/code&gt; -- which take care of all the nasty details.</source>
          <target state="translated">Модуль Filter :: Simple экспортирует в пакет, который вызывает &lt;code&gt;FILTER&lt;/code&gt; (или &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; его напрямую) - например, пакет &amp;laquo;BANG&amp;raquo; в приведенном выше примере - две автоматически созданные подпрограммы - &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;unimport&lt;/code&gt; - которые заботятся обо всем неприятные подробности.</target>
        </trans-unit>
        <trans-unit id="6e7c10894c7b8df4a2736098e84057abd21e37b8" translate="yes" xml:space="preserve">
          <source>The Filter::Simple module provides a simplified interface to Filter::Util::Call; one that is sufficient for most common cases.</source>
          <target state="translated">Модуль Фильтр::Простой предоставляет упрощенный интерфейс к Фильтру::Util::Call,достаточный для большинства распространенных случаев.</target>
        </trans-unit>
        <trans-unit id="bddf2be2229684864beadb4258752319125e5d27" translate="yes" xml:space="preserve">
          <source>The First Rule of Sys::Syslog is:</source>
          <target state="translated">Первое правило Sys::Syslog:</target>
        </trans-unit>
        <trans-unit id="c785438975752290d77a3cbc9b618a56d2ef340f" translate="yes" xml:space="preserve">
          <source>The Fourth Rule of Sys::Syslog is:</source>
          <target state="translated">Четвертое правило Sys::Syslog:</target>
        </trans-unit>
        <trans-unit id="9fc0887978d7a0f1367b4c9ada979ec50584ea98" translate="yes" xml:space="preserve">
          <source>The FreeBSD extensions to the POSIX standard are the following flags:</source>
          <target state="translated">Расширения FreeBSD к стандарту POSIX-это следующие флаги:</target>
        </trans-unit>
        <trans-unit id="ab3e557141760f9299f04ad34f2deeabfcc7fef0" translate="yes" xml:space="preserve">
          <source>The FreeMiNT port uses GNU dld for loadable module capabilities. So ensure you have that library installed when building perl.</source>
          <target state="translated">Порт FreeMiNT использует GNU dld для возможностей загружаемых модулей.Так что убедитесь,что у вас установлена эта библиотека при сборке perl.</target>
        </trans-unit>
        <trans-unit id="f0fd999d74111938e315c20e741e008d3fd7c5c7" translate="yes" xml:space="preserve">
          <source>The GNU C Compiler</source>
          <target state="translated">Компилятор GNU C</target>
        </trans-unit>
        <trans-unit id="d9d4765228818a588c101c574dcfb1a870a89ab7" translate="yes" xml:space="preserve">
          <source>The GV returned from &lt;code&gt;gv_fetchmeth&lt;/code&gt; may be a method cache entry, which is not visible to Perl code. So when calling &lt;code&gt;call_sv&lt;/code&gt; , you should not use the GV directly; instead, you should use the method's CV, which can be obtained from the GV with the &lt;code&gt;GvCV&lt;/code&gt; macro.</source>
          <target state="translated">GV, возвращаемый из &lt;code&gt;gv_fetchmeth&lt;/code&gt; , может быть записью кэша метода, которая не видна для кода Perl. Поэтому при вызове &lt;code&gt;call_sv&lt;/code&gt; вы не должны использовать GV напрямую; вместо этого вы должны использовать CV метода, который можно получить из GV с &lt;code&gt;GvCV&lt;/code&gt; макроса GvCV .</target>
        </trans-unit>
        <trans-unit id="b49130058618570dadbdb5fe7db0bf1f3977aebe" translate="yes" xml:space="preserve">
          <source>The GV which was last used for a filehandle input operation. (&lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; )</source>
          <target state="translated">GV, который последний раз использовался для операции ввода дескриптора файла. ( &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f9210879f69c79f8b2c57a2c424d2e90c56d2548" translate="yes" xml:space="preserve">
          <source>The G_KEEPERR flag is meant to be used in conjunction with G_EVAL in</source>
          <target state="translated">Флаг G_KEEPERR предназначается для использования в сочетании с G_EVAL в</target>
        </trans-unit>
        <trans-unit id="270052086120a712d1ce772352a3feccf55ed3d1" translate="yes" xml:space="preserve">
          <source>The G_KEEPERR flag was introduced in Perl version 5.002.</source>
          <target state="translated">Флаг G_KEEPERR был введен в Perl версии 5.002.</target>
        </trans-unit>
        <trans-unit id="c166e1d44ca297aba655d34fc5c35cdba6de63b6" translate="yes" xml:space="preserve">
          <source>The Gamma function [C99].</source>
          <target state="translated">Гамма-функция [C99].</target>
        </trans-unit>
        <trans-unit id="c28a373a90d22851cb6b0c5d6429010695515e8d" translate="yes" xml:space="preserve">
          <source>The Generic Object</source>
          <target state="translated">Общий объект</target>
        </trans-unit>
        <trans-unit id="be19e055acdc9d4cfa79691a16d99bc6afcec772" translate="yes" xml:space="preserve">
          <source>The Getopt::Long module implements an extended getopt function called GetOptions(). It parses the command line from &lt;code&gt;@ARGV&lt;/code&gt; , recognizing and removing specified options and their possible values.</source>
          <target state="translated">Модуль Getopt :: Long реализует расширенную функцию getopt, называемую GetOptions (). Он анализирует командную строку из &lt;code&gt;@ARGV&lt;/code&gt; , распознавая и удаляя указанные параметры и их возможные значения.</target>
        </trans-unit>
        <trans-unit id="2070520f96de2fb3aff1e83e6888cb8e89e845b4" translate="yes" xml:space="preserve">
          <source>The Gods Must Be Crazy</source>
          <target state="translated">Боги,должно быть,сошли с ума.</target>
        </trans-unit>
        <trans-unit id="95a2e8168d41f50bb6b37295098c965f76153807" translate="yes" xml:space="preserve">
          <source>The Guide</source>
          <target state="translated">Руководство</target>
        </trans-unit>
        <trans-unit id="5298e135f008dcbe68c1cb6c5368e25d31e290a3" translate="yes" xml:space="preserve">
          <source>The HP ANSI C Compiler</source>
          <target state="translated">Компилятор HP ANSI C</target>
        </trans-unit>
        <trans-unit id="cbc8f650d8669a3292691821f3fcd62a7f570f6f" translate="yes" xml:space="preserve">
          <source>The HP porting centres are limited in what systems they are allowed to port to and they usually choose the two most recent OS versions available.</source>
          <target state="translated">Центры переноса HP ограничены в том,на какие системы им разрешен перенос,и обычно выбирают две последние доступные версии ОС.</target>
        </trans-unit>
        <trans-unit id="f122712cd3f618cf66f5c1f12ee353af13431595" translate="yes" xml:space="preserve">
          <source>The HTML/XML character reference modes are about the same. In place of &lt;code&gt;\x{&lt;i&gt;HHHH&lt;/i&gt;}&lt;/code&gt;, HTML uses &lt;code&gt;&amp;amp;#&lt;i&gt;NNN&lt;/i&gt;;&lt;/code&gt; where</source>
          <target state="translated">Режимы ссылки на символы HTML / XML примерно такие же. Вместо &lt;code&gt;\x{&lt;i&gt;HHHH&lt;/i&gt;}&lt;/code&gt; HTML используется &lt;code&gt;&amp;amp;#&lt;i&gt;NNN&lt;/i&gt;;&lt;/code&gt; где</target>
        </trans-unit>
        <trans-unit id="36100c08868e01dc8cc43e522dca19e6917bba7c" translate="yes" xml:space="preserve">
          <source>The Hitchhiker's Guide to the Galaxy</source>
          <target state="translated">Путеводитель автостопщика по Галактике...</target>
        </trans-unit>
        <trans-unit id="e1c3679460c98c3b3c6c4ab57a10e09b7a1778d9" translate="yes" xml:space="preserve">
          <source>The Hobbit</source>
          <target state="translated">Хоббит</target>
        </trans-unit>
        <trans-unit id="ff076bcca2d7f3f3bc21f192dd45509aa2d50344" translate="yes" xml:space="preserve">
          <source>The I/O layers can also be specified more flexibly with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma. See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;, or look at the following example.</source>
          <target state="translated">Слои ввода-вывода также могут быть определены более гибко с помощью директивы &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; . См. &lt;a href=&quot;open&quot;&gt;Open&lt;/a&gt; или посмотрите на следующий пример.</target>
        </trans-unit>
        <trans-unit id="9bb410ea518f5686bb8957c03ada154b43330468" translate="yes" xml:space="preserve">
          <source>The IANA is responsible for delegating management of the top level country domains. The country domains are the two-letter (lowercase) codes from ISO 3166 with a few other additions.</source>
          <target state="translated">IANA отвечает за делегирование управления страновыми доменами верхнего уровня.Домены стран представляют собой двухбуквенные (строчные)коды из ИСО 3166 с некоторыми другими дополнениями.</target>
        </trans-unit>
        <trans-unit id="494453dbfde6185be2550cd595666629ce3cd776" translate="yes" xml:space="preserve">
          <source>The IANA language subtag registry.</source>
          <target state="translated">Реестр языковых подтегов IANA.</target>
        </trans-unit>
        <trans-unit id="14ed0108ca9064725768107f673bb9f9f4c35fe4" translate="yes" xml:space="preserve">
          <source>The IBM ANSI C Compiler</source>
          <target state="translated">Компилятор IBM ANSI C</target>
        </trans-unit>
        <trans-unit id="02dd8ba3a34ffd809cf07605a9d86d87105f9946" translate="yes" xml:space="preserve">
          <source>The IBM APAR number for this problem is IZ50240 (Reported component ID: 5765G0300 / AIX 5.3). It is possible to get an ifix for that problem. If you need an ifix please contact your local IBM AIX support.</source>
          <target state="translated">Номер IBM APAR для этой проблемы-IZ50240 (Идентификатор компонента:5765G0300/AIX 5.3).Для этой проблемы можно получить ifix.Если вам нужен ifix,пожалуйста,свяжитесь с местной поддержкой IBM AIX.</target>
        </trans-unit>
        <trans-unit id="a6c290ab208815021765007f305a8fc14c88a6b4" translate="yes" xml:space="preserve">
          <source>The IBM's compiler patch levels 5.0.0.0 and 5.0.1.0 have compiler optimization bugs that affect compiling perl.c and regcomp.c, respectively. If Perl's configuration detects those compiler patch levels, optimization is turned off for the said source code files. Upgrading to at least 5.0.2.0 is recommended.</source>
          <target state="translated">В патчах компилятора IBM уровней 5.0.0.0 и 5.0.1.0 есть ошибки оптимизации компилятора,которые влияют на компиляцию perl.c и regcomp.c соответственно.Если конфигурация Perl обнаруживает эти патч-уровни компилятора,оптимизация для указанных файлов исходного кода отключается.Рекомендуется обновление до версии не менее 5.0.2.0.</target>
        </trans-unit>
        <trans-unit id="9495fe8f41686bc61a5fe351f28585160b7d92af" translate="yes" xml:space="preserve">
          <source>The ID header in an &lt;code&gt;ExtraField&lt;/code&gt; sub-field can consist of any two bytes.</source>
          <target state="translated">Заголовок ID в &lt;code&gt;ExtraField&lt;/code&gt; может состоять из любых двух байтов.</target>
        </trans-unit>
        <trans-unit id="e1d154173604900e6d649a0362f6607140bc599a" translate="yes" xml:space="preserve">
          <source>The IDs of all objects available within a program are strings that can be expanded to the corresponding real objects with the &lt;code&gt;CPAN::Shell-&amp;gt;expand(&quot;Module&quot;,@things)&lt;/code&gt; method. Expand returns a list of CPAN::Module objects according to the &lt;code&gt;@things&lt;/code&gt; arguments given. In scalar context, it returns only the first element of the list.</source>
          <target state="translated">Идентификаторы всех объектов, доступных в программе, представляют собой строки, которые могут быть расширены до соответствующих реальных объектов с помощью &lt;code&gt;CPAN::Shell-&amp;gt;expand(&quot;Module&quot;,@things)&lt;/code&gt; . Expand возвращает список объектов CPAN :: Module в соответствии с &lt;code&gt;@things&lt;/code&gt; аргументами @things . В скалярном контексте он возвращает только первый элемент списка.</target>
        </trans-unit>
        <trans-unit id="10ac6c437c9901ca659c989f66f60ed9a2a13418" translate="yes" xml:space="preserve">
          <source>The IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT Keywords</source>
          <target state="translated">Ключевые слова IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT</target>
        </trans-unit>
        <trans-unit id="348998c68227b2675b00049ded155d9a2e0cebf4" translate="yes" xml:space="preserve">
          <source>The INCLUDE: Keyword</source>
          <target state="translated">ВКЛЮЧАЙТЕ:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="2fd635a1ef0c21453ce812dc91933d7964a41662" translate="yes" xml:space="preserve">
          <source>The INCLUDE_COMMAND: Keyword</source>
          <target state="translated">INCLUDE_COMMAND:ключевое слово</target>
        </trans-unit>
        <trans-unit id="edaf758a314e34d83c79323397c8453ba48d6649" translate="yes" xml:space="preserve">
          <source>The INIT: Keyword</source>
          <target state="translated">ИНИТ:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="c2a1ae034dc0e7090561071ada28079423ed98bf" translate="yes" xml:space="preserve">
          <source>The INIT: directive contains code that will be placed immediately after the argument stack is decoded. C does not allow variable declarations at arbitrary locations inside a function, so this is usually the best way to declare local variables needed by the XSUB. (Alternatively, one could put the whole &lt;code&gt;PPCODE:&lt;/code&gt; section into braces, and put these declarations on top.)</source>
          <target state="translated">Директива INIT: содержит код, который будет размещен сразу после декодирования стека аргументов. C не допускает объявления переменных в произвольных местах внутри функции, поэтому обычно это лучший способ объявить локальные переменные, необходимые XSUB. (В качестве альтернативы можно было бы поместить весь раздел &lt;code&gt;PPCODE:&lt;/code&gt; в фигурные скобки и поместить эти объявления вверху.)</target>
        </trans-unit>
        <trans-unit id="08f7558037e95071c749920f4074890a9d7217ea" translate="yes" xml:space="preserve">
          <source>The INIT: keyword allows initialization to be inserted into the XSUB before the compiler generates the call to the C function. Unlike the CODE: keyword above, this keyword does not affect the way the compiler handles RETVAL.</source>
          <target state="translated">Ключевое слово INIT:позволяет вставить инициализацию в XSUB до того,как компилятор сгенерирует вызов функции С.В отличие от вышеприведенного ключевого слова CODE:это ключевое слово не влияет на то,как компилятор обрабатывает RETVAL.</target>
        </trans-unit>
        <trans-unit id="05bebe82f53ea5f020b6b0d4fe1069dcc8a1edbb" translate="yes" xml:space="preserve">
          <source>The INPUT and OUTPUT sections substitute underscores for double-colons on the fly, giving the desired effect. This example demonstrates some of the power and versatility of the typemap facility.</source>
          <target state="translated">Замена секций INPUT и OUTPUT подчеркивает двойные колонки на лету,давая желаемый эффект.Этот пример демонстрирует некоторые возможности и универсальность типовой карты.</target>
        </trans-unit>
        <trans-unit id="970adbac5d031ff3f8daeef101bb8b55901dc870" translate="yes" xml:space="preserve">
          <source>The INPUT: Keyword</source>
          <target state="translated">ИНПУТ:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="21ee92ef918e68068f302b993af8bd2d49672033" translate="yes" xml:space="preserve">
          <source>The INSTALL file in the perl top-level has much information that is only relevant to people building Perl on Unix-like systems. In particular, you can safely ignore any information that talks about &quot;Configure&quot;.</source>
          <target state="translated">Файл INSTALL на верхнем уровне perl содержит много информации,которая имеет отношение только к людям,собирающим Perl на Unix-подобных системах.В частности,вы можете безопасно игнорировать любую информацию,которая говорит о &quot;Configure&quot;.</target>
        </trans-unit>
        <trans-unit id="0adfc9336795bed66f7e1ae7c7424119e43e300c" translate="yes" xml:space="preserve">
          <source>The INSTALL... macros in turn default to their %Config ($Config{installprivlib}, $Config{installarchlib}, etc.) counterparts.</source>
          <target state="translated">Макросы по умолчанию УСТАНОВЛЯЮТСЯ их %Config ($Config{installprivlib},$Config{installarchlib}и т.д.)аналогами.</target>
        </trans-unit>
        <trans-unit id="9023b649b609edcd17550081d28e4a80cf681ce5" translate="yes" xml:space="preserve">
          <source>The INTERFACE: Keyword</source>
          <target state="translated">ИНТЕРФЕЙС:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="e1fc34a9a712c8a8848d549ec748ba68c13f33e7" translate="yes" xml:space="preserve">
          <source>The INTERFACE_MACRO: Keyword</source>
          <target state="translated">INTERFACE_MACRO:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="1dc68d829f3e7afebf9178286cb38cc376f6ec35" translate="yes" xml:space="preserve">
          <source>The IO::Pty and Expect modules from CPAN can help with this, as they provide a real tty (well, a pseudo-tty, actually), which gets you back to line buffering in the invoked command again.</source>
          <target state="translated">Модули IO::Pty и Expect из CPAN могут помочь в этом,так как они предоставляют реальную tty (ну,на самом деле,псевдо-тройку),которая возвращает вас к буферизации строк в вызываемой команде.</target>
        </trans-unit>
        <trans-unit id="99807f53289794deab86efdaf9d7a76fb60defb6" translate="yes" xml:space="preserve">
          <source>The IO::Socket(3) manpage describes the object library, and the Socket(3) manpage describes the low-level interface to sockets. Besides the obvious functions in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, you should also check out the</source>
          <target state="translated">Справочная страница IO :: Socket (3) описывает библиотеку объектов, а справочная страница Socket (3) описывает низкоуровневый интерфейс для сокетов. Помимо очевидных функций в &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; , вам также следует проверить</target>
        </trans-unit>
        <trans-unit id="dd19329497c4746f419d864be77ab0a23a7089f7" translate="yes" xml:space="preserve">
          <source>The ISO 4217 data.</source>
          <target state="translated">Дата по ИСО 4217.</target>
        </trans-unit>
        <trans-unit id="9aedc742ca6fb2dc7b951347169405aefc47d178" translate="yes" xml:space="preserve">
          <source>The ISO 8601 standard defines the date format to be YYYY-MM-DD, and the time format to be hh:mm:ss (24 hour clock), and if combined, they should be concatenated with date first and with a capital 'T' in front of the time.</source>
          <target state="translated">Стандарт ISO 8601 определяет формат даты как YYYY-MM-DD,а формат времени как hh:mm:ss (24-часовые часы),и в случае их объединения они должны быть соединены с датой вперед и с заглавной буквой &quot;T&quot; перед временем.</target>
        </trans-unit>
        <trans-unit id="b1897fe9f53f26e8ee1d177c372171adf09aeabb" translate="yes" xml:space="preserve">
          <source>The ISO 8859-</source>
          <target state="translated">ISO 8859-</target>
        </trans-unit>
        <trans-unit id="be3a3d5a87727d649fad4e25cef60372ccbe4e20" translate="yes" xml:space="preserve">
          <source>The IVdf will expand to whatever is the correct format for the IVs.</source>
          <target state="translated">IVdf будет расширен до любого правильного формата для IVs.</target>
        </trans-unit>
        <trans-unit id="2438b4ecbe3dbd078f85fcd76de3ac8517dfbe33" translate="yes" xml:space="preserve">
          <source>The Inside-out Technique</source>
          <target state="translated">Техника &quot;изнутри</target>
        </trans-unit>
        <trans-unit id="bfd4ccd468ad208229b8e304f3f53a782dd6a87c" translate="yes" xml:space="preserve">
          <source>The Intent</source>
          <target state="translated">Намерение</target>
        </trans-unit>
        <trans-unit id="94771cb0c8e4f1f0a6f837c00d85c8dc460252be" translate="yes" xml:space="preserve">
          <source>The Internet line terminator is &quot;\015\012&quot;. Under ASCII variants of Unix, that could usually be written as &quot;\r\n&quot;, but under other systems, &quot;\r\n&quot; might at times be &quot;\015\015\012&quot;, &quot;\012\012\015&quot;, or something completely different. The standards specify writing &quot;\015\012&quot; to be conformant (be strict in what you provide), but they also recommend accepting a lone &quot;\012&quot; on input (be lenient in what you require). We haven't always been very good about that in the code in this manpage, but unless you're on a Mac from way back in its pre-Unix dark ages, you'll probably be ok.</source>
          <target state="translated">Интернет-терминатор линии &quot;\015\012&quot;.В ASCII-вариантах Unix,которые обычно могли быть написаны как &quot;\r\n&quot;,но в других системах &quot;\r\n&quot; иногда мог быть &quot;\015\015\012&quot;,&quot;\012\012\015&quot;,или что-то совершенно другое.В стандартах указано,что написание &quot;\015\012&quot; должно соответствовать (быть строгим в том,что вы предоставляете),но они также рекомендуют принимать одинокое &quot;\012&quot; на входе (быть снисходительным в том,что вы требуете).Мы не всегда были очень хороши в этом коде на этой странице,но если вы не на Mac с давних времён его до-Униксового мрака,то,скорее всего,с вами всё будет в порядке.</target>
        </trans-unit>
        <trans-unit id="501b92baa8d232237960cf668a9120aec4afdddd" translate="yes" xml:space="preserve">
          <source>The Keyed-Hash Message Authentication Code (HMAC):</source>
          <target state="translated">Код аутентификации ключевых и хеш-сообщений (HMAC):</target>
        </trans-unit>
        <trans-unit id="d65b2222a8c282dae9b3cd28518dc29329740227" translate="yes" xml:space="preserve">
          <source>The LAYER parameter of the binmode() function is described as &quot;DISCIPLINE&quot; in &quot;Programming Perl, 3rd Edition&quot;. However, since the publishing of this book, by many known as &quot;Camel III&quot;, the consensus of the naming of this functionality has moved from &quot;discipline&quot; to &quot;layer&quot;. All documentation of this version of Perl therefore refers to &quot;layers&quot; rather than to &quot;disciplines&quot;. Now back to the regularly scheduled documentation...</source>
          <target state="translated">Параметр LAYER функции binmode()описан как &quot;DISCIPLINE&quot; в &quot;Programming Perl,3rd Edition&quot;.Однако со времени публикации этой книги,многими известной как &quot;Camel III&quot;,консенсус в отношении названия этой функциональности переместился с &quot;дисциплины&quot; на &quot;слой&quot;.Поэтому вся документация этой версии Perl относится к &quot;слоям&quot;,а не к &quot;дисциплинам&quot;.Теперь вернемся к регулярной документации...</target>
        </trans-unit>
        <trans-unit id="c5a27ef16f958a529f7db36014226c11d0b2a269" translate="yes" xml:space="preserve">
          <source>The LENGTH must be less than or equal to the buffer size.</source>
          <target state="translated">LENGTH должен быть меньше или равен размеру буфера.</target>
        </trans-unit>
        <trans-unit id="ea2784880355655cd5260296b326df11e2887853" translate="yes" xml:space="preserve">
          <source>The LLP64 data model is different from the LP64 data model that is the norm on 64-bit Unix platforms. In the former, &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt; are both 32-bit data types, while pointers are 64 bits wide. In addition, there is a separate 64-bit wide integral type, &lt;code&gt;__int64&lt;/code&gt; . In contrast, the LP64 data model that is pervasive on Unix platforms provides &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; as the 32-bit type, while both the &lt;code&gt;long&lt;/code&gt; type and pointers are of 64-bit precision. Note that both models provide for 64-bits of addressability.</source>
          <target state="translated">Модель данных LLP64 отличается от модели данных LP64, которая является нормой для 64-битных платформ Unix. В первом случае &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;long&lt;/code&gt; являются 32-битными типами данных, а указатели имеют ширину 64 бита. Кроме того, существует отдельный целочисленный тип шириной 64 бита, &lt;code&gt;__int64&lt;/code&gt; . Напротив, модель данных LP64, широко распространенная на платформах Unix, предоставляет &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; как 32-битный тип, в то время как как &lt;code&gt;long&lt;/code&gt; тип, так и указатели имеют 64-битную точность. Обратите внимание, что обе модели обеспечивают адресность 64 бита.</target>
        </trans-unit>
        <trans-unit id="89a865b15f025e4125f9521e0cbb444b319a7463" translate="yes" xml:space="preserve">
          <source>The Layout</source>
          <target state="translated">Макет</target>
        </trans-unit>
        <trans-unit id="3892e7769cde3def977297b2fd107c985947cfbb" translate="yes" xml:space="preserve">
          <source>The Lays of Beleriand</source>
          <target state="translated">Белерианские Слёзы</target>
        </trans-unit>
        <trans-unit id="b0afa09df1fad56be5d5842b1eca124439a7ca1c" translate="yes" xml:space="preserve">
          <source>The LimitOutput option.</source>
          <target state="translated">Опция LimitOutput.</target>
        </trans-unit>
        <trans-unit id="7609c4332cdddf67282a426dcc844b81450f8724" translate="yes" xml:space="preserve">
          <source>The Locale-Codes distribution.</source>
          <target state="translated">Распространение локальных кодов.</target>
        </trans-unit>
        <trans-unit id="4371d0e1d710e94eadf09e06051f14e2003db5e7" translate="yes" xml:space="preserve">
          <source>The Locale/Maketext.pm source. Observe that the module is much shorter than its documentation!</source>
          <target state="translated">Источник в Локале/Мактексте.Обратите внимание,что модуль намного короче,чем документация!</target>
        </trans-unit>
        <trans-unit id="38bb5321e46a281dda4ae130db97eaa961627a32" translate="yes" xml:space="preserve">
          <source>The Lord of the Rings</source>
          <target state="translated">Властелин колец</target>
        </trans-unit>
        <trans-unit id="65d1f880f060efd8bb95b4c1ef3aa2f9bbc16903" translate="yes" xml:space="preserve">
          <source>The MANIFEST file contains the names of all the files just created in the Mytest directory.</source>
          <target state="translated">Файл MANIFEST содержит имена всех только что созданных файлов в каталоге Mytest.</target>
        </trans-unit>
        <trans-unit id="cc342c2add9e7769b6276801f43191956bbbeb6e" translate="yes" xml:space="preserve">
          <source>The MD5 algorithm is defined in RFC 1321. This implementation is derived from the reference C code in RFC 1321 which is covered by the following copyright statement:</source>
          <target state="translated">Алгоритм MD5 определен в RFC 1321.Эта реализация получена из кода ссылки C в RFC 1321,на который распространяется следующее заявление об авторских правах:</target>
        </trans-unit>
        <trans-unit id="a517aaaef144e51dda68ffaef4baabb6659f9741" translate="yes" xml:space="preserve">
          <source>The MODULE Keyword</source>
          <target state="translated">Ключевое слово MODULE</target>
        </trans-unit>
        <trans-unit id="d640b9c0318e742980f68cffc45a40affd82cb5f" translate="yes" xml:space="preserve">
          <source>The MODULE keyword is used to start the XS code and to specify the package of the functions which are being defined. All text preceding the first MODULE keyword is considered C code and is passed through to the output with POD stripped, but otherwise untouched. Every XS module will have a bootstrap function which is used to hook the XSUBs into Perl. The package name of this bootstrap function will match the value of the last MODULE statement in the XS source files. The value of MODULE should always remain constant within the same XS file, though this is not required.</source>
          <target state="translated">Ключевое слово MODULE используется для запуска кода XS и указания пакета определяемых функций.Весь текст,предшествующий первому ключевому слову MODULE,считается C-кодом и передается на выход с лишенным POD,но в остальном нетронутым.Каждый модуль XS будет иметь функцию bootstrap,которая используется для подключения XSUBs на Perl.Имя пакета этой функции bootstrap будет соответствовать значению последнего оператора MODULE в исходных файлах XS.Значение MODULE всегда должно оставаться постоянным в пределах одного и того же XS файла,хотя это не требуется.</target>
        </trans-unit>
        <trans-unit id="eb4b2ce583f381cfbe7f078522f5b75cf8b0acdd" translate="yes" xml:space="preserve">
          <source>The MY_CXT_INIT macro initializes storage for the &lt;code&gt;my_cxt_t&lt;/code&gt; struct.</source>
          <target state="translated">Макрос MY_CXT_INIT инициализирует хранилище для структуры &lt;code&gt;my_cxt_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dd4eb6a77854464c830f76b78c6ac15e92b669d" translate="yes" xml:space="preserve">
          <source>The Makefile to be produced may be altered by adding arguments of the form &lt;code&gt;KEY=VALUE&lt;/code&gt; . E.g.</source>
          <target state="translated">Создаваемый Makefile можно изменить, добавив аргументы в форме &lt;code&gt;KEY=VALUE&lt;/code&gt; . Например</target>
        </trans-unit>
        <trans-unit id="ad78ec4ae3b5a4c78156cf44036606a40c32aaf5" translate="yes" xml:space="preserve">
          <source>The Mantra</source>
          <target state="translated">Мантра</target>
        </trans-unit>
        <trans-unit id="1b194ffb2833786ebe5362ee6e09704940be3454" translate="yes" xml:space="preserve">
          <source>The Memoize man page.</source>
          <target state="translated">Мужская страничка &quot;Memoize&quot;.</target>
        </trans-unit>
        <trans-unit id="8b07a539021a149c75372ae5a8d60bcacade8512" translate="yes" xml:space="preserve">
          <source>The Microsoft Visual C++ compilers are also now being given away free. They are available as &quot;Visual C++ Toolkit 2003&quot; or &quot;Visual C++ 2005-2013 Express Edition&quot; (and also as part of the &quot;.NET Framework SDK&quot;) and are the same compilers that ship with &quot;Visual C++ .NET 2003 Professional&quot; or &quot;Visual C++ 2005-2013 Professional&quot; respectively.</source>
          <target state="translated">Компиляторы Microsoft Visual C++также раздаются бесплатно.Они доступны как &quot;Visual C++Toolkit 2003&quot; или &quot;Visual C++2005-2013 Express Edition&quot; (а также как часть &quot;.NET Framework SDK&quot;)и являются теми же компиляторами,которые поставляются с &quot;Visual C++.NET 2003 Professional&quot; или &quot;Visual C++2005-2013 Professional&quot; соответственно.</target>
        </trans-unit>
        <trans-unit id="b6efbee1ed83675ffebd32144ba8248768436ab5" translate="yes" xml:space="preserve">
          <source>The NAME section (&lt;code&gt;=head1 NAME&lt;/code&gt; ) should consist of a single paragraph with the script/module name, followed by a dash `-' and a very short description of what the thing is good for.</source>
          <target state="translated">Раздел NAME ( &lt;code&gt;=head1 NAME&lt;/code&gt; ) должен состоять из одного абзаца с именем скрипта / модуля, за которым следует тире &amp;laquo;-&amp;raquo; и очень краткое описание того, для чего это нужно.</target>
        </trans-unit>
        <trans-unit id="552a987af386f5239d1d91c8f3cd7d6b46b27cbb" translate="yes" xml:space="preserve">
          <source>The NAME section should be recognized specially and index entries emitted for everything in that section. This would have to be deferred until the next section, since extraneous things in NAME tends to confuse various man page processors. Currently, no index entries are emitted for anything in NAME.</source>
          <target state="translated">Раздел &quot;ФАМИЛИЯ&quot; должен быть распознан специально,и записи индекса должны выделяться для всего,что находится в этом разделе.Это придется отложить до следующего раздела,так как посторонние вещи в ФАМИЛИИ имеют тенденцию путать различные процессоры man-страниц.В настоящее время ни для чего в разделе ФАМИЛИЯ не публикуются никакие записи индекса.</target>
        </trans-unit>
        <trans-unit id="eede37533894539b6f0e561b631aee0b3870de35" translate="yes" xml:space="preserve">
          <source>The NEVER keyword must appear by itself if used within the Notify option and &quot;requests that a DSN not be returned to the sender under any conditions.&quot;</source>
          <target state="translated">Ключевое слово НИКОГДА не должно появляться само по себе,если оно используется в опции Уведомление и &quot;требует,чтобы DSN не возвращался отправителю ни при каких условиях&quot;.</target>
        </trans-unit>
        <trans-unit id="1dccb0bb054644651ad0c69767bda009b1d0637b" translate="yes" xml:space="preserve">
          <source>The NO_INIT Keyword</source>
          <target state="translated">Ключевое слово NO_INIT</target>
        </trans-unit>
        <trans-unit id="23729fabcc944859639583f78edb8c8ef05b2818" translate="yes" xml:space="preserve">
          <source>The NO_INIT keyword is used to indicate that a function parameter is being used only as an output value. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will normally generate code to read the values of all function parameters from the argument stack and assign them to C variables upon entry to the function. NO_INIT will tell the compiler that some parameters will be used for output rather than for input and that they will be handled before the function terminates.</source>
          <target state="translated">Ключевое слово NO_INIT используется для обозначения того, что параметр функции используется только как выходное значение. &lt;b&gt;Xsubpp&lt;/b&gt; компилятор обычно генерирует код для чтения значения всех параметров функции из стека аргументов и назначить их переменные C при входе в функцию. NO_INIT сообщит компилятору, что некоторые параметры будут использоваться для вывода, а не для ввода, и что они будут обработаны до завершения функции.</target>
        </trans-unit>
        <trans-unit id="8fd6dba18911a57231232a7c939d805f823c76e7" translate="yes" xml:space="preserve">
          <source>The NO_OUTPUT Keyword</source>
          <target state="translated">Ключевое слово NO_OUTPUT</target>
        </trans-unit>
        <trans-unit id="03379df3fc9b65eb904066ecff904227f6ca6017" translate="yes" xml:space="preserve">
          <source>The NO_OUTPUT can be placed as the first token of the XSUB. This keyword indicates that while the C subroutine we provide an interface to has a non-&lt;code&gt;void&lt;/code&gt; return type, the return value of this C subroutine should not be returned from the generated Perl subroutine.</source>
          <target state="translated">NO_OUTPUT можно разместить как первый токен XSUB. Это ключевое слово указывает, что, хотя подпрограмма C, для которой мы предоставляем интерфейс, имеет &lt;code&gt;void&lt;/code&gt; тип возврата, возвращаемое значение этой подпрограммы C не должно возвращаться из сгенерированной подпрограммы Perl.</target>
        </trans-unit>
        <trans-unit id="904e01c3e307ff335e43430a3d4bc1ddd9643078" translate="yes" xml:space="preserve">
          <source>The Name_Alias property is also of this form. But each scalar consists of two components: 1) the name, and 2) the type of alias this is. They are separated by a colon and a space. In Unicode 6.1, there are several alias types:</source>
          <target state="translated">Свойство Name_Alias также имеет эту форму.Но каждый скаляр состоит из двух компонентов:1)имя и 2)тип псевдонима.Они разделены двоеточием и пробелом.В Юникоде 6.1 есть несколько типов псевдонимов:</target>
        </trans-unit>
        <trans-unit id="b8335e651ec579d0644f75bd5c6369bb3697cc7b" translate="yes" xml:space="preserve">
          <source>The Nestable version works by looking for hash references being stored and converting them to tied hashes so that they too can have references as keys. This will happen without warning whenever you store a reference to one of your own hashes in the tied hash.</source>
          <target state="translated">Версия Nestable работает путем поиска хранимых ссылок на хэши и их преобразования в привязанные хэши,чтобы они тоже могли иметь ссылки в качестве ключей.Это происходит без предупреждения всякий раз,когда вы храните ссылку на один из ваших собственных хэшей в связанном хэше.</target>
        </trans-unit>
        <trans-unit id="1aaccf615c02a846abe966f8242837a674850c5a" translate="yes" xml:space="preserve">
          <source>The Net::FTP class is a subclass of Net::Cmd and IO::Socket::INET.</source>
          <target state="translated">Класс Net::FTP является подклассом Net::Cmd и IO::Socket::INET.</target>
        </trans-unit>
        <trans-unit id="01eaa0b5dde8380e0c7a54964e805d8bfcf3acc6" translate="yes" xml:space="preserve">
          <source>The Net::NNTP class is a subclass of Net::Cmd and IO::Socket::INET.</source>
          <target state="translated">Класс Net::NNTP является подклассом Net::Cmd и IO::Socket::INET.</target>
        </trans-unit>
        <trans-unit id="da23b39231b794a7054fda91fbd214625459379e" translate="yes" xml:space="preserve">
          <source>The Net::POP3 class is a subclass of Net::Cmd and IO::Socket::INET.</source>
          <target state="translated">Класс Net::POP3 является подклассом Net::Cmd и IO::Socket::INET.</target>
        </trans-unit>
        <trans-unit id="8d68199e14c6e60b44de999602d0fae86539eba2" translate="yes" xml:space="preserve">
          <source>The Net::SMTP class is a subclass of Net::Cmd and IO::Socket::INET.</source>
          <target state="translated">Класс Net::SMTP является подклассом Net::Cmd и IO::Socket::INET.</target>
        </trans-unit>
        <trans-unit id="64f60cb8e2581437bfdc17a813e7b06233279924" translate="yes" xml:space="preserve">
          <source>The OP's flags, abbreviated as a series of symbols.</source>
          <target state="translated">Флаги ОП,сокращенно серия символов.</target>
        </trans-unit>
        <trans-unit id="895a69280490efde337cd0fd19af585a8e383312" translate="yes" xml:space="preserve">
          <source>The OP's name, in all caps.</source>
          <target state="translated">Имя ОП,во всех прописных буквах.</target>
        </trans-unit>
        <trans-unit id="02eabb0cd331fbbf23966749354f0c2df6db1d07" translate="yes" xml:space="preserve">
          <source>The OP's name.</source>
          <target state="translated">Название ОП.</target>
        </trans-unit>
        <trans-unit id="2e25dacc5e61c7fb0d63f53483335a706cbf1613" translate="yes" xml:space="preserve">
          <source>The OP's private flags, rendered with abbreviated names if possible.</source>
          <target state="translated">Личные флаги ОП,по возможности с сокращенными названиями.</target>
        </trans-unit>
        <trans-unit id="59e423cd50aec687154fc4dc506adc4e55e686ff" translate="yes" xml:space="preserve">
          <source>The OP-specific information of the OP (such as the SV for an SVOP, the non-local exit pointers for a LOOP, etc.) enclosed in parentheses.</source>
          <target state="translated">Специфическая для ОП информация об ОП (например,SV для SVOP,нелокальные указатели выхода для LOOP и т.д.)заключена в круглые скобки.</target>
        </trans-unit>
        <trans-unit id="0f586844a0e8ae4292abb29dd5184b53fc4b9536" translate="yes" xml:space="preserve">
          <source>The OS/390 and z/OS C run-time libraries provide &lt;code&gt;_atoe()&lt;/code&gt; and &lt;code&gt;_etoa()&lt;/code&gt; functions.</source>
          <target state="translated">Библиотеки времени выполнения OS / 390 и z / OS C предоставляют функции &lt;code&gt;_atoe()&lt;/code&gt; и &lt;code&gt;_etoa()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efc93b2b68cdc27d26189d3924b12fba2216cd16" translate="yes" xml:space="preserve">
          <source>The OUTPUT: Keyword</source>
          <target state="translated">ВЫХОД:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="6558e5f212b7172c05e18d1a7261588a3081027f" translate="yes" xml:space="preserve">
          <source>The OUTPUT: keyword can also be used to indicate that function parameters are output variables. This may be necessary when a parameter has been modified within the function and the programmer would like the update to be seen by Perl.</source>
          <target state="translated">Ключевое слово OUTPUT:также может быть использовано для указания того,что параметры функции являются выходными переменными.Это может быть необходимо,когда параметр был изменен внутри функции,и программист хотел бы,чтобы обновление было видно на Perl.</target>
        </trans-unit>
        <trans-unit id="73a9f4665d98e2b1d4598fa0b47867a5d82b1767" translate="yes" xml:space="preserve">
          <source>The OUTPUT: keyword indicates that certain function parameters should be updated (new values made visible to Perl) when the XSUB terminates or that certain values should be returned to the calling Perl function. For simple functions which have no CODE: or PPCODE: section, such as the sin() function above, the RETVAL variable is automatically designated as an output value. For more complex functions the &lt;b&gt;xsubpp&lt;/b&gt; compiler will need help to determine which variables are output variables.</source>
          <target state="translated">Ключевое слово OUTPUT: указывает, что определенные параметры функции должны быть обновлены (новые значения становятся видимыми для Perl) при завершении XSUB или что определенные значения должны быть возвращены вызывающей функции Perl. Для простых функций, у которых нет раздела CODE: или PPCODE:, таких как функция sin () выше, переменная RETVAL автоматически назначается как выходное значение. Для более сложных функций компилятору &lt;b&gt;xsubpp&lt;/b&gt; потребуется помощь, чтобы определить, какие переменные являются выходными.</target>
        </trans-unit>
        <trans-unit id="4cc5401f4b3edfb0209daaa58ea92639a885ffb3" translate="yes" xml:space="preserve">
          <source>The OUTPUT: keyword will also allow an output parameter to be mapped to a matching piece of code rather than to a typemap.</source>
          <target state="translated">Ключевое слово OUTPUT:также позволит сопоставить выходной параметр с соответствующим куском кода,а не с типовой картой.</target>
        </trans-unit>
        <trans-unit id="9ee72e50bec09b405c45fd6861c78e461f0c9260" translate="yes" xml:space="preserve">
          <source>The OVERLOAD: Keyword</source>
          <target state="translated">Оверлоад:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="7288e63116c84272f399850db852020e0cc73247" translate="yes" xml:space="preserve">
          <source>The Opcode module allow you to define an</source>
          <target state="translated">Модуль Опкод позволяет определять</target>
        </trans-unit>
        <trans-unit id="959cf82efacd7e02d3ef8885dabccff7457e7125" translate="yes" xml:space="preserve">
          <source>The Opcode module is not usually used directly. See the ops pragma and Safe modules for more typical uses.</source>
          <target state="translated">Модуль Опкод обычно не используется напрямую.Более типичные примеры использования см.в разделах &quot;Оптический модуль&quot; и &quot;Безопасный модуль&quot;.</target>
        </trans-unit>
        <trans-unit id="fc2df1bcfc1883b7877806492c6187e99dd073c7" translate="yes" xml:space="preserve">
          <source>The Opcode package contains functions for manipulating operator names tags and sets. All are available for export by the package.</source>
          <target state="translated">Пакет Opcode содержит функции для манипулирования тегами и наборами имен операторов.Все они доступны для экспорта пакетом.</target>
        </trans-unit>
        <trans-unit id="d8d0c8d509c42bd9d64cbd39302a78c4a8138b0f" translate="yes" xml:space="preserve">
          <source>The Output File Glob is a normal string, with 2 glob-like features.</source>
          <target state="translated">Глобус выходного файла-это обычная строка,с 2 глобусами.</target>
        </trans-unit>
        <trans-unit id="84f8f10721f91385f97d9092c39e5e78fd029d2f" translate="yes" xml:space="preserve">
          <source>The PACKAGE Keyword</source>
          <target state="translated">Ключевое слово ПАКЕТА</target>
        </trans-unit>
        <trans-unit id="865d0a1c65f77bfae0d9586920617d375bc6acfd" translate="yes" xml:space="preserve">
          <source>The PADLIST has a C array where pads are stored.</source>
          <target state="translated">В PADLIST есть массив C,в котором хранятся колодки.</target>
        </trans-unit>
        <trans-unit id="14a42650858d4f29fe76f5f506d61c2fcd72c3a0" translate="yes" xml:space="preserve">
          <source>The PASE environment is a runtime environment for OS/400 that can run executables built for PowerPC AIX in OS/400; see &lt;a href=&quot;perlos400&quot;&gt;perlos400&lt;/a&gt;. PASE is ASCII-based, not EBCDIC-based as the ILE.</source>
          <target state="translated">Среда PASE - это среда выполнения для OS / 400, которая может запускать исполняемые файлы, созданные для PowerPC AIX в OS / 400; см. &lt;a href=&quot;perlos400&quot;&gt;perlos400&lt;/a&gt; . PASE основан на ASCII, а не на EBCDIC, как ILE.</target>
        </trans-unit>
        <trans-unit id="1f72b8482ed4bc7cb03eba7f8d7c5860c8cba587" translate="yes" xml:space="preserve">
          <source>The PATH isn't the only environment variable which can cause problems. Because some shells may use the variables IFS, CDPATH, ENV, and BASH_ENV, Perl checks that those are either empty or untainted when starting subprocesses. You may wish to add something like this to your setid and taint-checking scripts.</source>
          <target state="translated">PATH не единственная переменная окружения,которая может вызвать проблемы.Так как некоторые оболочки могут использовать переменные IFS,CDPATH,ENV и BASH_ENV,Perl проверяет,что они либо пустые,либо незаполненные при запуске подпроцессов.Возможно,вы захотите добавить что-нибудь подобное в свои скрипты проверки setid и taint-checking.</target>
        </trans-unit>
        <trans-unit id="74d39bcf239c4e87e009e146ae36fe8545147ee4" translate="yes" xml:space="preserve">
          <source>The PATHEXT env variable will be used to get a list of extensions that might indicate a command, otherwise .com, .exe, .bat and .cmd will be used by default.</source>
          <target state="translated">Переменная PATHEXT env будет использоваться для получения списка расширений,которые могут указывать на команду,в противном случае по умолчанию будут использоваться .com,.exe,.bat и .cmd.</target>
        </trans-unit>
        <trans-unit id="7243f6ac7c83fe20c93feefd9b08218632215bc2" translate="yes" xml:space="preserve">
          <source>The PATTERN need not be constant; an expression may be used to specify a pattern that varies at runtime.</source>
          <target state="translated">ДАТЧЕРН не обязательно должен быть константным;выражение может быть использовано для указания шаблона,который изменяется во время выполнения.</target>
        </trans-unit>
        <trans-unit id="692a1dbebc7770986f39cc91bf3402c713778957" translate="yes" xml:space="preserve">
          <source>The PERL5DB environment variable is only used when Perl is started with a bare &lt;b&gt;-d&lt;/b&gt; switch.</source>
          <target state="translated">Переменная среды PERL5DB используется только тогда, когда Perl запускается с ключом &lt;b&gt;-d&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="1eee98df1ea759ea4940bac25b454fb3fd49fcab" translate="yes" xml:space="preserve">
          <source>The PERL5LIB and PERLLIB logical names work as documented in &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt;, except that the element separator is '|' instead of ':'. The directory specifications may use either VMS or Unix syntax.</source>
          <target state="translated">Логические имена PERL5LIB и PERLLIB работают, как описано в &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt; , за исключением того, что разделителем элементов является '|' вместо того ':'. В спецификациях каталогов может использоваться синтаксис VMS или Unix.</target>
        </trans-unit>
        <trans-unit id="368f8cf4322638139da678fdc3327c77e1a054e7" translate="yes" xml:space="preserve">
          <source>The PERLIO environment variable is completely ignored when Perl is run in taint mode.</source>
          <target state="translated">Переменная окружения PERLIO полностью игнорируется,когда Perl запущен в режиме taint.</target>
        </trans-unit>
        <trans-unit id="054efbf018fd73b713cd0bc442abab0d7792d243" translate="yes" xml:space="preserve">
          <source>The PERLLIB environment variable is completely ignored when Perl is run in taint mode.</source>
          <target state="translated">Переменная окружения PERLLIB полностью игнорируется,когда Perl запущен в режиме taint.</target>
        </trans-unit>
        <trans-unit id="d86bdeabcf0cc9f48a3238fc1e1e9701f94852a2" translate="yes" xml:space="preserve">
          <source>The PERL_MAGIC_uvar interface for hashes</source>
          <target state="translated">Интерфейс PERL_MAGIC_uvar для хэшей</target>
        </trans-unit>
        <trans-unit id="fb91b23c022ab8bc327b326b9c283bc9250f0c0a" translate="yes" xml:space="preserve">
          <source>The PERL_VMS_EXCEPTION_DEBUG being defined as &quot;ENABLE&quot; will cause the VMS debugger to be invoked if a fatal exception that is not otherwise handled is raised. The purpose of this is to allow debugging of internal Perl problems that would cause such a condition.</source>
          <target state="translated">Определение PERL_VMS_EXCEPTION_DEBUG как &quot;ENABLE&quot; приведет к вызову отладчика VMS,если будет поднято фатальное исключение,которое не обрабатывается иным образом.Это сделано для того,чтобы разрешить отладку внутренних проблем с Perl,которые могут привести к такому состоянию.</target>
        </trans-unit>
        <trans-unit id="7e2373bae9a9b5526191c72b5feebb5b501ede90" translate="yes" xml:space="preserve">
          <source>The POD file has some &lt;code&gt;=item&lt;/code&gt; and/or &lt;code&gt;=head&lt;/code&gt; commands that have the same text. Potential hyperlinks to such a text cannot be unique then. This warning is printed only with warning level greater than one.</source>
          <target state="translated">В файле POD есть несколько команд &lt;code&gt;=item&lt;/code&gt; и / или &lt;code&gt;=head&lt;/code&gt; с одинаковым текстом. Тогда потенциальные гиперссылки на такой текст не могут быть уникальными. Это предупреждение печатается только с уровнем предупреждения больше единицы.</target>
        </trans-unit>
        <trans-unit id="6a2061d2e11b2e67b0037b468d2ff510b08d969a" translate="yes" xml:space="preserve">
          <source>The POD names of files are the plain basenames with any Perl-like extension (.pm, .pl, .pod) stripped, and path separators replaced by &lt;code&gt;::&lt;/code&gt; 's.</source>
          <target state="translated">Имена файлов POD - это простые базовые имена с удаленными расширениями, подобными Perl (.pm, .pl, .pod), и замененными разделителями путей на &lt;code&gt;::&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3f7ef3aaed3b96c670ec2c717b4d27aac5d999a" translate="yes" xml:space="preserve">
          <source>The POSIX class matches according to the locale, except:</source>
          <target state="translated">Класс POSIX совпадает в соответствии с локалью,кроме того:</target>
        </trans-unit>
        <trans-unit id="d05b25c0d51d4520f59dbd5e7b83c675d81a2280" translate="yes" xml:space="preserve">
          <source>The POSIX class matches the same as its Full-range counterpart.</source>
          <target state="translated">Класс POSIX совпадает со своим полнодиапазонным аналогом.</target>
        </trans-unit>
        <trans-unit id="a91522989698e72a81436ce9d52c71f12180a429" translate="yes" xml:space="preserve">
          <source>The POSIX class matches the same as the ASCII range counterpart.</source>
          <target state="translated">Класс POSIX совпадает с аналогом диапазона ASCII.</target>
        </trans-unit>
        <trans-unit id="45eac6affb7dfd81e7b1ef63dd7e0a2e6da662a9" translate="yes" xml:space="preserve">
          <source>The POSIX class matches the same as the Full-range counterpart.</source>
          <target state="translated">Класс POSIX совпадает с полнодиапазонным аналогом.</target>
        </trans-unit>
        <trans-unit id="dc901c76cdcb97dea7310ea8ea924293bb5949f6" translate="yes" xml:space="preserve">
          <source>The POSIX defined flags for bsd_glob() are:</source>
          <target state="translated">Для функции bsd_glob()определены флаги POSIX:</target>
        </trans-unit>
        <trans-unit id="0fced43544b15278205eeaf1ce05bf21af49dca0" translate="yes" xml:space="preserve">
          <source>The POSIX module (part of the standard perl distribution) implements &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; , and other mathematical and trigonometric functions. The &lt;code&gt;&lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt;&lt;/code&gt; module (part of the standard perl distribution) defines mathematical functions that work on both the reals and the imaginary numbers. &lt;code&gt;Math::Complex&lt;/code&gt; is not as efficient as POSIX, but POSIX can't work with complex numbers.</source>
          <target state="translated">Модуль POSIX (часть стандартного дистрибутива Perl) реализует &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; и другие математические и тригонометрические функции. Модуль &lt;code&gt;&lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt;&lt;/code&gt; (часть стандартного распределения Perl) определяет математические функции, которые работают как с действительными, так и с мнимыми числами. &lt;code&gt;Math::Complex&lt;/code&gt; не так эффективен, как POSIX, но POSIX не может работать с комплексными числами.</target>
        </trans-unit>
        <trans-unit id="58a76e828b7178504f0efaab58e9fc7ae8c408e4" translate="yes" xml:space="preserve">
          <source>The POSIX module permits you to access all (or nearly all) the standard POSIX 1003.1 identifiers. Many of these identifiers have been given Perl-ish interfaces.</source>
          <target state="translated">Модуль POSIX позволяет получить доступ ко всем (или почти ко всем)стандартным идентификаторам POSIX 1003.1.Многим из этих идентификаторов были предоставлены интерфейсы Perl-ish.</target>
        </trans-unit>
        <trans-unit id="bb00001e36c555e321a2c3180d9872e8c4493925" translate="yes" xml:space="preserve">
          <source>The POSIX provided &lt;code&gt;GLOB_APPEND&lt;/code&gt; , &lt;code&gt;GLOB_DOOFFS&lt;/code&gt; , and the FreeBSD extensions &lt;code&gt;GLOB_ALTDIRFUNC&lt;/code&gt; , and &lt;code&gt;GLOB_MAGCHAR&lt;/code&gt; flags have not been implemented in the Perl version because they involve more complex interaction with the underlying C structures.</source>
          <target state="translated">POSIX предоставил &lt;code&gt;GLOB_APPEND&lt;/code&gt; , &lt;code&gt;GLOB_DOOFFS&lt;/code&gt; , а расширения FreeBSD &lt;code&gt;GLOB_ALTDIRFUNC&lt;/code&gt; и &lt;code&gt;GLOB_MAGCHAR&lt;/code&gt; не были реализованы в версии Perl, поскольку они предполагают более сложное взаимодействие с базовыми структурами C.</target>
        </trans-unit>
        <trans-unit id="a0d47d53c93142215e84e50218c868cd954904f3" translate="yes" xml:space="preserve">
          <source>The POSIX::strftime() approach has the benefit of being, in theory, independent of the current locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for details.</source>
          <target state="translated">Преимущество подхода POSIX :: strftime () состоит в том, что он теоретически не зависит от текущей локали. См. Подробности в &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4be5af1b8c4f7ec96a716021937a3c9561f2d5c" translate="yes" xml:space="preserve">
          <source>The POSTCALL: Keyword</source>
          <target state="translated">ПОСТКАЛ:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="58e421a82995ac1225598edc3f8a16b394004724" translate="yes" xml:space="preserve">
          <source>The POSTCALL: block does not make a lot of sense when the C subroutine call is supplied by user by providing either CODE: or PPCODE: section.</source>
          <target state="translated">Блок POSTCALL:не имеет смысла,когда пользователь предоставляет вызов подпрограммы C,предоставляя либо раздел CODE:,либо PPCODE:.</target>
        </trans-unit>
        <trans-unit id="b336bc59359478eb80f69f21fc081230df6f7578" translate="yes" xml:space="preserve">
          <source>The PPCODE: Keyword</source>
          <target state="translated">PPCODE:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="cfd48109a24f72ee93cb2960e4b31f2a2958e886" translate="yes" xml:space="preserve">
          <source>The PPCODE: keyword is an alternate form of the CODE: keyword and is used to tell the &lt;b&gt;xsubpp&lt;/b&gt; compiler that the programmer is supplying the code to control the argument stack for the XSUBs return values. Occasionally one will want an XSUB to return a list of values rather than a single value. In these cases one must use PPCODE: and then explicitly push the list of values on the stack. The PPCODE: and CODE: keywords should not be used together within the same XSUB.</source>
          <target state="translated">Ключевое слово PPCODE: является альтернативной формой ключевого слова CODE: и используется, чтобы сообщить компилятору &lt;b&gt;xsubpp,&lt;/b&gt; что программист предоставляет код для управления стеком аргументов для возвращаемых значений XSUB. Иногда требуется, чтобы XSUB возвращал список значений, а не одно значение. В этих случаях необходимо использовать PPCODE: и затем явно поместить список значений в стек. Ключевые слова PPCODE: и CODE: не должны использоваться вместе в одном XSUB.</target>
        </trans-unit>
        <trans-unit id="6f7f4e638293474e32a1342be9b48c14f4f2f5af" translate="yes" xml:space="preserve">
          <source>The PREFIX Keyword</source>
          <target state="translated">Ключевое слово PREFIX</target>
        </trans-unit>
        <trans-unit id="52a603903d899ccd2bb20a31b53d728d154bd0a6" translate="yes" xml:space="preserve">
          <source>The PREFIX keyword designates prefixes which should be removed from the Perl function names. If the C function is &lt;code&gt;rpcb_gettime()&lt;/code&gt; and the PREFIX value is &lt;code&gt;rpcb_&lt;/code&gt; then Perl will see this function as &lt;code&gt;gettime()&lt;/code&gt; .</source>
          <target state="translated">Ключевое слово PREFIX обозначает префиксы, которые следует удалить из имен функций Perl. Если функция C - это &lt;code&gt;rpcb_gettime()&lt;/code&gt; а значение PREFIX - &lt;code&gt;rpcb_&lt;/code&gt; , тогда Perl увидит эту функцию как &lt;code&gt;gettime()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88877bb4605c88019ee2001796614ad12f854190" translate="yes" xml:space="preserve">
          <source>The PREINIT: Keyword</source>
          <target state="translated">ПРЕИНИТЕТ:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="81434e6a015b3cc52c205c8d0096aa1b8047f180" translate="yes" xml:space="preserve">
          <source>The PREINIT: keyword allows extra variables to be declared immediately before or after the declarations of the parameters from the INPUT: section are emitted.</source>
          <target state="translated">Ключевое слово PREINIT:позволяет объявлять дополнительные переменные непосредственно до или после объявления параметров из секции INPUT:.</target>
        </trans-unit>
        <trans-unit id="fe7bb955840f60bbf203155b0452f242dc963bed" translate="yes" xml:space="preserve">
          <source>The PROTOTYPE: Keyword</source>
          <target state="translated">Прототип:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="88332a599c2ebe7acc31d1e6540ad41d11fdae24" translate="yes" xml:space="preserve">
          <source>The PROTOTYPES: Keyword</source>
          <target state="translated">Прототипы:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="4762c608488c900a25e5c9ce4a388703783fff72" translate="yes" xml:space="preserve">
          <source>The PROTOTYPES: keyword corresponds to &lt;b&gt;xsubpp&lt;/b&gt;'s &lt;code&gt;-prototypes&lt;/code&gt; and &lt;code&gt;-noprototypes&lt;/code&gt; options. This keyword overrides the command line options. Prototypes are enabled by default. When prototypes are enabled XSUBs will be given Perl prototypes. This keyword may be used multiple times in an XS module to enable and disable prototypes for different parts of the module.</source>
          <target state="translated">Прототипы: ключевое слово соответствует в &lt;b&gt;xsubpp&lt;/b&gt; &amp;laquo;s &lt;code&gt;-prototypes&lt;/code&gt; и &lt;code&gt;-noprototypes&lt;/code&gt; варианты. Это ключевое слово переопределяет параметры командной строки. По умолчанию прототипы включены. Когда прототипы включены, XSUB будут получать прототипы Perl. Это ключевое слово может использоваться несколько раз в модуле XS, чтобы включать и отключать прототипы для различных частей модуля.</target>
        </trans-unit>
        <trans-unit id="32ef6835ed63a718cf287a36ed5a59d894d8bfe4" translate="yes" xml:space="preserve">
          <source>The PV of the sv is returned.</source>
          <target state="translated">Возвращается фотовспышка ЗВ.</target>
        </trans-unit>
        <trans-unit id="cbea6ce0d8ba0f98747339e84eb8596aa1948b13" translate="yes" xml:space="preserve">
          <source>The Perl 5 core includes mechanisms to help porters make backwards incompatible changes more compatible such as the &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;deprecate&quot;&gt;deprecate&lt;/a&gt; modules. Please use them when appropriate.</source>
          <target state="translated">Ядро Perl 5 включает механизмы, помогающие переносчикам сделать обратно несовместимые изменения более совместимыми, такие как &lt;a href=&quot;feature&quot;&gt;функции&lt;/a&gt; и &lt;a href=&quot;deprecate&quot;&gt;устаревшие&lt;/a&gt; модули. Пожалуйста, используйте их при необходимости.</target>
        </trans-unit>
        <trans-unit id="bab276840135536c5b050850ebb3b382c1feec45" translate="yes" xml:space="preserve">
          <source>The Perl 5 smartmatch and &lt;code&gt;given&lt;/code&gt; /&lt;code&gt;when&lt;/code&gt; constructs are not compatible with their Perl 6 analogues. The most visible difference and least important difference is that, in Perl 5, parentheses are required around the argument to &lt;code&gt;given()&lt;/code&gt; and &lt;code&gt;when()&lt;/code&gt; (except when this last one is used as a statement modifier). Parentheses in Perl 6 are always optional in a control construct such as &lt;code&gt;if()&lt;/code&gt; , &lt;code&gt;while()&lt;/code&gt; , or &lt;code&gt;when()&lt;/code&gt; ; they can't be made optional in Perl 5 without a great deal of potential confusion, because Perl 5 would parse the expression</source>
          <target state="translated">Конструкции SmartMatch и &lt;code&gt;given&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; в Perl 5 несовместимы с их аналогами в Perl 6. Наиболее заметное и наименее важное отличие состоит в том, что в Perl 5 круглые скобки требуются вокруг аргумента для &lt;code&gt;given()&lt;/code&gt; и &lt;code&gt;when()&lt;/code&gt; (кроме тех случаев, когда последний используется как модификатор оператора). Скобки в Perl 6 всегда необязательны в конструкции элемента управления, такой как &lt;code&gt;if()&lt;/code&gt; , &lt;code&gt;while()&lt;/code&gt; или &lt;code&gt;when()&lt;/code&gt; ; они не могут быть необязательными в Perl 5 без большой потенциальной путаницы, потому что Perl 5 будет анализировать выражение</target>
        </trans-unit>
        <trans-unit id="5d32638db8a1c22afb3b560c2715ac8287958e39" translate="yes" xml:space="preserve">
          <source>The Perl 5 source code is available at &amp;lt;&lt;a href=&quot;http://perl5.git.perl.org/perl.git&quot;&gt;http://perl5.git.perl.org/perl.git&lt;/a&gt;&amp;gt; and ExtUtils-CBuilder may be found in the</source>
          <target state="translated">Исходный код Perl 5 доступен по адресу &amp;lt; &lt;a href=&quot;http://perl5.git.perl.org/perl.git&quot;&gt;http://perl5.git.perl.org/perl.git&lt;/a&gt; &amp;gt;, а ExtUtils-CBuilder можно найти в</target>
        </trans-unit>
        <trans-unit id="afeaca8df1b6424181f3a66ccbb3b6382d64c41b" translate="yes" xml:space="preserve">
          <source>The Perl API changes over time. New functions are added or the interfaces of existing functions are changed. The &lt;code&gt;Devel::PPPort&lt;/code&gt; module tries to provide compatibility code for some of these changes, so XS writers don't have to code it themselves when supporting multiple versions of Perl.</source>
          <target state="translated">Perl API со временем меняется. Добавляются новые функции или изменяются интерфейсы существующих функций. Модуль &lt;code&gt;Devel::PPPort&lt;/code&gt; пытается предоставить код совместимости для некоторых из этих изменений, поэтому разработчикам XS не нужно кодировать его самим при поддержке нескольких версий Perl.</target>
        </trans-unit>
        <trans-unit id="b3ddaaeb977cd171a0809e4c9d46db7115a9f674" translate="yes" xml:space="preserve">
          <source>The Perl Archive Toolkit ( &lt;a href=&quot;http://par.perl.org/&quot;&gt;http://par.perl.org/&lt;/a&gt; ) is Perl's analog to Java's JAR. It's freely available and on CPAN ( &lt;a href=&quot;http://search.cpan.org/dist/PAR/&quot;&gt;http://search.cpan.org/dist/PAR/&lt;/a&gt; ).</source>
          <target state="translated">Perl Archive Toolkit ( &lt;a href=&quot;http://par.perl.org/&quot;&gt;http://par.perl.org/&lt;/a&gt; ) является аналогом Perl JAR для Java. Он находится в свободном доступе и на CPAN ( &lt;a href=&quot;http://search.cpan.org/dist/PAR/&quot;&gt;http://search.cpan.org/dist/PAR/&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f01c36b942223cd02d483b2f8710a5fcbe7b3f1a" translate="yes" xml:space="preserve">
          <source>The Perl Authors Upload SErver (&lt;a href=&quot;http://pause.perl.org&quot;&gt;http://pause.perl.org&lt;/a&gt;), the gateway for &lt;b&gt;modules&lt;/b&gt; on their way to &lt;b&gt;CPAN&lt;/b&gt;.</source>
          <target state="translated">Авторы Perl загружают сервер SErver ( &lt;a href=&quot;http://pause.perl.org&quot;&gt;http://pause.perl.org&lt;/a&gt; ), шлюз для &lt;b&gt;модулей&lt;/b&gt; на пути к &lt;b&gt;CPAN&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b633506d32991c982d57371e8ff5e8e620c6651c" translate="yes" xml:space="preserve">
          <source>The Perl Compiler Backend</source>
          <target state="translated">Бэкэнд компилятора Perl</target>
        </trans-unit>
        <trans-unit id="528f579664ac974a57416a02a9f4d6f1fb344d5b" translate="yes" xml:space="preserve">
          <source>The Perl DLL is installed in \System\Libs\. The Perl libraries and extension DLLs are installed in \System\Libs\Perl\X.Y.Z\. The PerlApp is installed in \System\Apps\, and the SIS also installs a couple of demo scripts in \Perl\ (C:\Mydocs\Perl\ on Nokia 7710).</source>
          <target state="translated">Perl DLL установлена на сайте \System\Libs\.Библиотеки Perl и расширения DLL установлены по адресу \System\Libs\Perl\X.Y.Z\.PerlApp устанавливается по адресу \System\Apps\,а SIS также устанавливает пару демо-скриптов по адресу \Perl\ (C:\Mydocs\Perl\ на Nokia 7710).</target>
        </trans-unit>
        <trans-unit id="b0d4827468980c5df0784a8af4ce7848ecde4b66" translate="yes" xml:space="preserve">
          <source>The Perl Debugger</source>
          <target state="translated">Отладчик Perl</target>
        </trans-unit>
        <trans-unit id="003a86b939921d18b908afadb31a1624a5c158e1" translate="yes" xml:space="preserve">
          <source>The Perl Dev Kit ( &lt;a href=&quot;http://www.activestate.com/Products/Perl_Dev_Kit/&quot;&gt;http://www.activestate.com/Products/Perl_Dev_Kit/&lt;/a&gt; ) from ActiveState can &quot;Turn your Perl programs into ready-to-run executables for HP-UX, Linux, Solaris and Windows.&quot;</source>
          <target state="translated">Perl Dev Kit ( &lt;a href=&quot;http://www.activestate.com/Products/Perl_Dev_Kit/&quot;&gt;http://www.activestate.com/Products/Perl_Dev_Kit/&lt;/a&gt; ) от ActiveState может &amp;laquo;превратить ваши Perl-программы в готовые к запуску исполняемые файлы для HP-UX, Linux, Solaris и Windows&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="1c56af5a226a11b5977e777d4fb79e3fb6c794f9" translate="yes" xml:space="preserve">
          <source>The Perl Forked Debugger</source>
          <target state="translated">Вилочный отладчик Perl.</target>
        </trans-unit>
        <trans-unit id="076abbe7cec0580634f13cf92571ce869da1bf79" translate="yes" xml:space="preserve">
          <source>The Perl Foundation is an advocacy organization for the Perl language which maintains the web site &lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt; as a general advocacy site for the Perl language. It uses the domain to provide general support services to the Perl community, including the hosting of mailing lists, web sites, and other services. There are also many other sub-domains for special topics like learning Perl and jobs in Perl, such as:</source>
          <target state="translated">Perl Foundation - это организация, защищающая язык Perl, которая поддерживает веб-сайт &lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt; в качестве общего сайта защиты языка Perl. Он использует домен для предоставления общих услуг поддержки сообществу Perl, включая размещение списков рассылки, веб-сайтов и других услуг. Есть также много других поддоменов для специальных тем, таких как изучение Perl и работа на Perl, например:</target>
        </trans-unit>
        <trans-unit id="d177a21aa5a9fba680e844771ded5bc126e66e5c" translate="yes" xml:space="preserve">
          <source>The Perl Journal</source>
          <target state="translated">Журнал &quot;Перл</target>
        </trans-unit>
        <trans-unit id="b540cf823fa7d059f14c61e7a0646ec955faa0d9" translate="yes" xml:space="preserve">
          <source>The Perl Profiler</source>
          <target state="translated">Профилировщик Perl</target>
        </trans-unit>
        <trans-unit id="b016030ffb60704d0c5d1297b6257d8c67a0ebea" translate="yes" xml:space="preserve">
          <source>The Perl Review, &lt;a href=&quot;http://www.theperlreview.com&quot;&gt;http://www.theperlreview.com&lt;/a&gt; maintains a website and Google calendar (&lt;a href=&quot;http://www.theperlreview.com/community_calendar&quot;&gt;http://www.theperlreview.com/community_calendar&lt;/a&gt;) for tracking workshops, hackathons, Perl Mongers meetings, and other events. Views of this calendar are at &lt;a href=&quot;http://www.perl.org/events.html&quot;&gt;http://www.perl.org/events.html&lt;/a&gt; and &lt;a href=&quot;http://www.yapc.org&quot;&gt;http://www.yapc.org&lt;/a&gt;.</source>
          <target state="translated">Perl Review, &lt;a href=&quot;http://www.theperlreview.com&quot;&gt;http://www.theperlreview.com&lt;/a&gt; поддерживает веб-сайт и календарь Google ( &lt;a href=&quot;http://www.theperlreview.com/community_calendar&quot;&gt;http://www.theperlreview.com/community_calendar&lt;/a&gt; ) для отслеживания семинаров, хакатонов, встреч Perl Mongers и других событий. Просмотр этого календаря находится на &lt;a href=&quot;http://www.perl.org/events.html&quot;&gt;http://www.perl.org/events.html&lt;/a&gt; и &lt;a href=&quot;http://www.yapc.org&quot;&gt;http://www.yapc.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6955a584a390227f3bb9df6a8ce1cb0fe482186c" translate="yes" xml:space="preserve">
          <source>The Perl argument stack is used to store the values which are sent as parameters to the XSUB and to store the XSUB's return value(s). In reality all Perl functions (including non-XSUB ones) keep their values on this stack all the same time, each limited to its own range of positions on the stack. In this document the first position on that stack which belongs to the active function will be referred to as position 0 for that function.</source>
          <target state="translated">Стек аргументов Perl используется для хранения значений,которые посылаются в качестве параметров XSUB,и для хранения возвращаемых XSUB значений.В реальности все Perl-функции (в том числе и не XSUB-функции)сохраняют свои значения в этом стеке все время,каждая из которых ограничивается своим собственным диапазоном позиций на стеке.В этом документе первая позиция на этом стеке,принадлежащая активной функции,будет называться для этой функции позицией 0.</target>
        </trans-unit>
        <trans-unit id="1afd605920f29e13092c6aa9a01dbc8ba4878de1" translate="yes" xml:space="preserve">
          <source>The Perl build system starts with the</source>
          <target state="translated">Система сборки Perl начинается с</target>
        </trans-unit>
        <trans-unit id="337328dc6570faaca13781601b8dac575ac43697" translate="yes" xml:space="preserve">
          <source>The Perl community has a rather large IRC presence. For starters, it has its own IRC network, &lt;a href=&quot;irc://irc.perl.org&quot;&gt;irc://irc.perl.org&lt;/a&gt;. General (not help-oriented) chat can be found at &lt;a href=&quot;irc://irc.perl.org/#perl&quot;&gt;irc://irc.perl.org/#perl&lt;/a&gt;. Many other more specific chats are also hosted on the network. Information about irc.perl.org is located on the network's website: &lt;a href=&quot;http://www.irc.perl.org&quot;&gt;http://www.irc.perl.org&lt;/a&gt;. For a more help-oriented #perl, check out &lt;a href=&quot;irc://irc.freenode.net/#perl&quot;&gt;irc://irc.freenode.net/#perl&lt;/a&gt;. Perl 6 development also has a presence in &lt;a href=&quot;irc://irc.freenode.net/#perl6&quot;&gt;irc://irc.freenode.net/#perl6&lt;/a&gt;. Most Perl-related channels will be kind enough to point you in the right direction if you ask nicely.</source>
          <target state="translated">Сообщество Perl имеет довольно большое присутствие в IRC. Во-первых, у него есть собственная IRC-сеть &lt;a href=&quot;irc://irc.perl.org&quot;&gt;irc: //irc.perl.org&lt;/a&gt; . Общий (не ориентированный на помощь) чат можно найти по адресу &lt;a href=&quot;irc://irc.perl.org/#perl&quot;&gt;irc: //irc.perl.org/#perl&lt;/a&gt; . В сети также размещено множество других более конкретных чатов. Информация об irc.perl.org находится на веб-сайте сети: &lt;a href=&quot;http://www.irc.perl.org&quot;&gt;http://www.irc.perl.org&lt;/a&gt; . Для более ориентированного на помощь #perl посетите &lt;a href=&quot;irc://irc.freenode.net/#perl&quot;&gt;irc: //irc.freenode.net/#perl&lt;/a&gt; . Разработка Perl 6 также присутствует в &lt;a href=&quot;irc://irc.freenode.net/#perl6&quot;&gt;irc: //irc.freenode.net/#perl6&lt;/a&gt; . Большинство каналов, связанных с Perl, будут достаточно любезны, чтобы указать вам правильное направление, если вы вежливо спросите.</target>
        </trans-unit>
        <trans-unit id="1e71a9470b64a2480ea7c8c2886a8ca9bc8c982c" translate="yes" xml:space="preserve">
          <source>The Perl community is as diverse as Perl, and there is a large amount of evidence that the Perl users apply TMTOWTDI to all endeavors, not just programming. From websites, to IRC, to mailing lists, there is more than one way to get involved in the community.</source>
          <target state="translated">Сообщество Perl столь же разнообразно,как и Perl,и существует множество свидетельств того,что пользователи Perl применяют TMTOWTDI во всех начинаниях,а не только при программировании.От вебсайтов,IRC,до списков рассылки-существует не один способ участия в сообществе.</target>
        </trans-unit>
        <trans-unit id="75fca85980fcb62b1837d386b956468cb5d6629f" translate="yes" xml:space="preserve">
          <source>The Perl community is geared toward supporting the most recent releases, so you'll have an easier time finding help for those.</source>
          <target state="translated">Сообщество Perl нацелено на поддержку самых последних релизов,так что вам будет проще найти помощь для них.</target>
        </trans-unit>
        <trans-unit id="660fe5fd6a64acb9219ffd0837bb1e282e990fa7" translate="yes" xml:space="preserve">
          <source>The Perl core has an extensive test suite. If you add new tests (or new modules with tests), you may need to update the</source>
          <target state="translated">Ядро Perl имеет обширный набор для тестирования.Если вы добавляете новые тесты (или новые модули с тестами),вам может понадобиться обновление</target>
        </trans-unit>
        <trans-unit id="8f13ce29b0232702f230a3b4d47d029f48d1ff8a" translate="yes" xml:space="preserve">
          <source>The Perl core uses a handful of keys in &lt;code&gt;%^H&lt;/code&gt; which do not follow this convention, because they predate it. Keys that follow the convention won't conflict with the core's historical keys.</source>
          <target state="translated">Ядро Perl использует несколько ключей в &lt;code&gt;%^H&lt;/code&gt; которые не соответствуют этому соглашению, потому что они предшествуют ему. Ключи, соответствующие соглашению, не будут конфликтовать с историческими ключами ядра.</target>
        </trans-unit>
        <trans-unit id="40fdaea2f094775674cd40eee5e41200dd9b0a76" translate="yes" xml:space="preserve">
          <source>The Perl development team are called Perl 5 Porters, and their organization is described at &lt;a href=&quot;http://perldoc.perl.org/perlpolicy.html&quot;&gt;http://perldoc.perl.org/perlpolicy.html&lt;/a&gt;. The organizational rules really just boil down to one: Larry is always right, even when he was wrong.</source>
          <target state="translated">Команда разработчиков Perl называется Perl 5 Porters, и их организация описана на &lt;a href=&quot;http://perldoc.perl.org/perlpolicy.html&quot;&gt;http://perldoc.perl.org/perlpolicy.html&lt;/a&gt; . Организационные правила на самом деле сводятся к одному: Ларри всегда прав, даже когда он был неправ.</target>
        </trans-unit>
        <trans-unit id="85f7977946f345bcbaa5f5a8afb688bfb2d58512" translate="yes" xml:space="preserve">
          <source>The Perl development team occasionally make changes to the internal core of the language, but all possible efforts are made toward backward compatibility.</source>
          <target state="translated">Команда разработчиков Perl время от времени вносит изменения во внутреннее ядро языка,но при этом предпринимаются все возможные усилия для обеспечения обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="bef6ea773b29bc42d6bc39580b413ba88c9c2941" translate="yes" xml:space="preserve">
          <source>The Perl engine/interpreter and the host are orthogonal entities. There could be one or more interpreters in a process, and one or more &quot;hosts&quot;, with free association between them.</source>
          <target state="translated">Двигатель/переводчик Perl и хозяин являются ортогональными сущностями.В процессе может быть один или несколько переводчиков,и один или несколько &quot;хостов&quot;,со свободной ассоциацией между ними.</target>
        </trans-unit>
        <trans-unit id="be2ab355cd62828f3bbc09e8a520aa45842fe8c2" translate="yes" xml:space="preserve">
          <source>The Perl equivalent for this is &lt;code&gt;$#myarray&lt;/code&gt; .</source>
          <target state="translated">Эквивалент Perl для этого - &lt;code&gt;$#myarray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bbb1426c72d3038d784b1de2b64c8aea8f60fd1" translate="yes" xml:space="preserve">
          <source>The Perl executables can be easily rebuilt at any moment. Moreover, one can use the</source>
          <target state="translated">Исполняемые файлы на Perl могут быть легко перестроены в любой момент.Более того,можно использовать</target>
        </trans-unit>
        <trans-unit id="d136d03bdd5714dfcd154602e7c27ff31ede4518" translate="yes" xml:space="preserve">
          <source>The Perl forked debugger places the debugger commands and output in a separate X-11 terminal window so that commands and output from multiple processes are not mixed together.</source>
          <target state="translated">Вилочный отладчик Perl помещает команды отладчика и выводит их в отдельное окно терминала X-11,чтобы команды и вывод от нескольких процессов не смешивались.</target>
        </trans-unit>
        <trans-unit id="fa02d08b07357f1b109729d24eaf520757219ddc" translate="yes" xml:space="preserve">
          <source>The Perl functions for dealing with sockets have the same names as the corresponding system calls in C, but their arguments tend to differ for two reasons. First, Perl filehandles work differently than C file descriptors. Second, Perl already knows the length of its strings, so you don't need to pass that information.</source>
          <target state="translated">Perl-функции для работы с сокетами имеют те же имена,что и соответствующие системные вызовы в C,но их аргументы имеют тенденцию отличаться по двум причинам.Во-первых,файловые дескрипторы на Perl работают иначе,чем дескрипторы на C.Во-вторых,Perl уже знает длину своих строк,поэтому передавать эту информацию не нужно.</target>
        </trans-unit>
        <trans-unit id="92147dd8f1d29e8ce474756b4726d9b1d8e42e16" translate="yes" xml:space="preserve">
          <source>The Perl interface was written by Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, and is released under the artistic license. Further modifications were made by Greg Bacon &amp;lt;gbacon@cs.uah.edu&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, and Thomas Wegner &amp;lt;wegner_thomas@yahoo.com&amp;gt;. The C glob code has the following copyright:</source>
          <target state="translated">Интерфейс Perl был написан Натаном Торкингтоном &amp;lt;gnat@frii.com&amp;gt; и выпущен под художественной лицензией. Дальнейшие изменения были внесены Грегом Бэкон &amp;lt;gbacon@cs.uah.edu&amp;gt;, Гурусами Сарати &amp;lt;gsar@activestate.com&amp;gt; и Томасом Вегнером &amp;lt;wegner_thomas@yahoo.com&amp;gt;. Код C glob имеет следующие авторские права:</target>
        </trans-unit>
        <trans-unit id="99bc4ac3d59eed09e1d0f94b3a3f01535d2fc89d" translate="yes" xml:space="preserve">
          <source>The Perl interpreter can be regarded as a closed box: it has an API for feeding it code or otherwise making it do things, but it also has functions for its own use. This smells a lot like an object, and there are ways for you to build Perl so that you can have multiple interpreters, with one interpreter represented either as a C structure, or inside a thread-specific structure. These structures contain all the context, the state of that interpreter.</source>
          <target state="translated">Интерпретатор Perl можно рассматривать как закрытый ящик:у него есть API для подкачки своего кода или для того,чтобы заставить его делать что-то другое,но есть и функции для собственного использования.Это очень похоже на объект,и для вас есть способы собрать Perl так,чтобы у вас было несколько интерпретаторов,один интерпретатор был представлен либо как структура C,либо как потокоспецифичная структура.Эти структуры содержат весь контекст,состояние этого интерпретатора.</target>
        </trans-unit>
        <trans-unit id="4ec97d45bb2f6ea56e5a238f738362154db298f5" translate="yes" xml:space="preserve">
          <source>The Perl logo is a trademark of the Perl Foundation.</source>
          <target state="translated">Логотип Perl является торговой маркой Фонда Perl.</target>
        </trans-unit>
        <trans-unit id="6b8a4b8bd5fc4d36250e80003bd49d95bed77a10" translate="yes" xml:space="preserve">
          <source>The Perl model for function call and return values is simple: all functions are passed as parameters one single flat list of scalars, and all functions likewise return to their caller one single flat list of scalars. Any arrays or hashes in these call and return lists will collapse, losing their identities--but you may always use pass-by-reference instead to avoid this. Both call and return lists may contain as many or as few scalar elements as you'd like. (Often a function without an explicit return statement is called a subroutine, but there's really no difference from Perl's perspective.)</source>
          <target state="translated">Модель Perl для вызова и возврата значений функций проста:все функции передаются в качестве параметров одного единого плоского списка скаляров,и все функции аналогичным образом возвращают вызывающему их абоненту один единственный плоский список скаляров.Любые массивы или хэши в этих списках вызовов и возвратов рухнут,теряя свою идентичность-но вы всегда можете использовать передачу по ссылке,чтобы избежать этого.И список вызовов,и список возвратов могут содержать столько или столько скалярных элементов,сколько вы захотите.(Часто функция без явного выражения возврата называется подпрограммой,но с точки зрения Perl в этом нет никакой разницы).</target>
        </trans-unit>
        <trans-unit id="b9ee0cf4ab63cf1be081346d4784ae92aedc21e4" translate="yes" xml:space="preserve">
          <source>The Perl motto is &quot;There's more than one way to do it.&quot; Divining how many more is left as an exercise to the reader.</source>
          <target state="translated">Девиз Perl:&quot;Есть не один способ сделать это&quot;.Размышляя,сколько еще осталось,как упражнение для читателя.</target>
        </trans-unit>
        <trans-unit id="b25f4bf878cf14a357970d887adcbf624e87e118" translate="yes" xml:space="preserve">
          <source>The Perl parser will expand $variable and @variable references in regular expressions unless the delimiter is a single quote. Remember, too, that the right-hand side of a &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitution is considered a double-quoted string (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details). Remember also that any regex special characters will be acted on unless you precede the substitution with \Q. Here's an example:</source>
          <target state="translated">Парсер Perl будет расширять ссылки на $ переменные и @ переменные в регулярных выражениях, если в качестве разделителя не используется одинарная кавычка. Помните также, что правая часть подстановки &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; считается строкой в ​​двойных кавычках (подробнее см. &lt;a href=&quot;perlop&quot;&gt;Perlop&lt;/a&gt; ). Помните также, что любые специальные символы регулярных выражений будут обрабатываться, если вы не поставите перед заменой \ Q. Вот пример:</target>
        </trans-unit>
        <trans-unit id="0bc52b1056fd349e5d759d3b05d91376e2d9a16e" translate="yes" xml:space="preserve">
          <source>The Perl port has been done for the most part using the Symbian standard POSIX-ish STDLIB library. It is a reasonably complete library, but certain corners of such emulation libraries that tend to be left unimplemented on non-UNIX platforms have been left unimplemented also this time: fork(), signals(), user/group ids, select() working for sockets, non-blocking sockets, and so forth. See the file</source>
          <target state="translated">Порт на Perl был сделан по большей части с использованием библиотеки STDLIB стандарта Symbian POSIX-ish STDLIB.Это достаточно полная библиотека,но некоторые углы таких библиотек эмуляции,которые,как правило,остаются нереализованными на неUNIX платформах,были оставлены нереализованными и на этот раз:fork(),signals(),user/group ids,select(),работающая для сокетов,неблокирующие сокеты,и так далее.Смотрите файл</target>
        </trans-unit>
        <trans-unit id="b67868d8a32ed03bc87b830fb6a6b1a5f3f79a34" translate="yes" xml:space="preserve">
          <source>The Perl regular expression &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs give access to most of the Unicode character properties. The table below shows all these constructs, both single and compound forms.</source>
          <target state="translated">Конструкции &lt;code&gt;\p{}&lt;/code&gt; и &lt;code&gt;\P{}&lt;/code&gt; регулярного выражения Perl предоставляют доступ к большинству свойств символов Юникода. В таблице ниже показаны все эти конструкции, как одиночные, так и составные формы.</target>
        </trans-unit>
        <trans-unit id="f0e8425fc37fe67a70d8b01bf266a53e0f530848" translate="yes" xml:space="preserve">
          <source>The Perl source tree is big. Here's some of the thing you'll find in it:</source>
          <target state="translated">Дерево первоисточников Perl большое.Вот кое-что из того,что ты найдешь в нем:</target>
        </trans-unit>
        <trans-unit id="6a0d4acb6c550a60d6a38a5a63678cce3e904bee" translate="yes" xml:space="preserve">
          <source>The Perl subroutine,</source>
          <target state="translated">Подпрограмма &quot;Перл&quot;,</target>
        </trans-unit>
        <trans-unit id="df3a691d5cbb91293ddf18af01bb5af5f01bbb73" translate="yes" xml:space="preserve">
          <source>The Perl syntax error message from the last &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; operator. If &lt;code&gt;$@&lt;/code&gt; is the null string, the last &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; parsed and executed correctly (although the operations you invoked may have failed in the normal fashion).</source>
          <target state="translated">Сообщение об ошибке синтаксиса Perl от последнего оператора &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; . Если &lt;code&gt;$@&lt;/code&gt; является пустой строкой, последняя &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; проанализирована и выполнена правильно (хотя операции, которые вы вызывали, могли завершиться сбоем в обычном режиме).</target>
        </trans-unit>
        <trans-unit id="968a791625fe0d4ef7287cb8aaab8e329d603dbe" translate="yes" xml:space="preserve">
          <source>The Perl test suite may still report some errors on the Hurd. The &quot;lib/anydbm&quot; and &quot;pragma/warnings&quot; tests will almost certainly fail. Both failures are not really specific to the Hurd, as indicated by the test suite output.</source>
          <target state="translated">Тестовый комплект Perl все еще может сообщать о некоторых ошибках в Hurd.Тесты &quot;lib/anydbm&quot; и &quot;pragma/warnings&quot; почти наверняка провалятся.Обе ошибки не являются специфическими для Hurd,о чем свидетельствует вывод набора тестов.</target>
        </trans-unit>
        <trans-unit id="f6abf53e543be5d8676f05668af9e144a63af4c4" translate="yes" xml:space="preserve">
          <source>The Perl variables that are available for interpolation into typemaps are the following:</source>
          <target state="translated">Переменные Perl,доступные для интерполяции в типовых картах,следующие:</target>
        </trans-unit>
        <trans-unit id="6bcd8c322dd20c222b91b35688318973e6596a5a" translate="yes" xml:space="preserve">
          <source>The Perl warning &quot;Wide character in ...&quot; is caused by such a character. With no specified encoding layer, Perl tries to fit things into a single byte. When it can't, it emits this warning (if warnings are enabled), and uses UTF-8 encoded data instead.</source>
          <target state="translated">Предупреждение Perl &quot;Широкий символ в ...&quot; вызвано таким символом.При отсутствии заданного слоя кодировки Perl пытается уместить вещи в один байт.Когда он не может,он выдает это предупреждение (если предупреждения включены),а вместо него использует данные в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="4d7feb5052b0fb54136f812ed2c2ffa2175dab42" translate="yes" xml:space="preserve">
          <source>The Perl-QA list attempted to ensure backwards compatibility with &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt;. However, there are some minor differences.</source>
          <target state="translated">Список Perl-QA попытался обеспечить обратную совместимость с &lt;a href=&quot;../test/harness&quot;&gt;Test :: Harness&lt;/a&gt; . Однако есть небольшие отличия.</target>
        </trans-unit>
        <trans-unit id="a9ec1c232da33c6ab26241322f9069a9704be0af" translate="yes" xml:space="preserve">
          <source>The PerlApp also is started when the &quot;Perl recognizer&quot; (also included and installed) detects a Perl file being activated through the GUI, and offers either to install it under \Perl (if the Perl file is in the inbox of the messaging application) or to run it (if the Perl file is under \Perl).</source>
          <target state="translated">PerlApp также запускается,когда &quot;Perl распознаватель&quot; (также включенный и установленный)обнаруживает файл Perl,активируемый через графический интерфейс,и предлагает либо установить его под \Perl (если файл Perl находится во входящей почте приложения для обмена сообщениями),либо запустить его (если файл Perl находится под \Perl).</target>
        </trans-unit>
        <trans-unit id="c6111a686e0ef0ac50573a59b08dc1b8aeb3287a" translate="yes" xml:space="preserve">
          <source>The PerlApp application demonstrates how to embed Perl interpreters to a Symbian application. The &quot;Time&quot; menu item runs the following Perl code: &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &quot;Running in &quot;, $^O, &quot;\n&quot;, &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; , the &quot;Oneliner&quot; allows one to type in Perl code, and the &quot;Run&quot; opens a file chooser for selecting a Perl file to run.</source>
          <target state="translated">Приложение PerlApp демонстрирует, как встраивать интерпретаторы Perl в приложение Symbian. Пункт меню &amp;laquo;Время&amp;raquo; запускает следующий Perl код: &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &quot;Running in &quot;, $^O, &quot;\n&quot;, &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; , то &amp;laquo;Oneliner&amp;raquo; позволяет ввести код Perl, и &amp;laquo;Run&amp;raquo; открывает файл chooser для выбора файла Perl для запуска.</target>
        </trans-unit>
        <trans-unit id="b43fd89b2979a98b7d902f7d0334218ba2ca529e" translate="yes" xml:space="preserve">
          <source>The PerlIO abstraction was introduced in perl5.003_02 but languished as just an abstraction until perl5.7.0. However during that time a number of perl extensions switched to using it, so the API is mostly fixed to maintain (source) compatibility.</source>
          <target state="translated">PerlIO абстракция была введена в perl5.003_02,но до версии perl5.7.0 она была просто абстракцией.Однако за это время ряд perl расширений перешел на его использование,поэтому API в основном исправлено для поддержания (исходной)совместимости.</target>
        </trans-unit>
        <trans-unit id="43641046aefdabfa554afe6cf89fa8594b9147ac" translate="yes" xml:space="preserve">
          <source>The PerlIO is set to textmode. Use PerlIO_binmode if this is not the desired mode.</source>
          <target state="translated">PerlIO настроен на текстовый режим.Используйте PerlIO_binmode,если это не тот режим,который вам нужен.</target>
        </trans-unit>
        <trans-unit id="df2a9946f78c97c4cb0379505dfaf42cfc784763" translate="yes" xml:space="preserve">
          <source>The PerlIO::via module allows you to develop PerlIO layers in Perl, without having to go into the nitty gritty of programming C with XS as the interface to Perl.</source>
          <target state="translated">PerlIO::via модуль позволяет разрабатывать слои PerlIO на Perl,без необходимости вникать в нитти программирования C с XS в качестве интерфейса к Perl.</target>
        </trans-unit>
        <trans-unit id="69b9d42402dbac92bb5f313095f98e57d920e008" translate="yes" xml:space="preserve">
          <source>The Pod format is not necessarily sufficient for writing a book. Pod is just meant to be an idiot-proof common source for nroff, HTML, TeX, and other markup languages, as used for online documentation. Translators exist for &lt;b&gt;pod2text&lt;/b&gt;, &lt;b&gt;pod2html&lt;/b&gt;, &lt;b&gt;pod2man&lt;/b&gt; (that's for nroff(1) and troff(1)), &lt;b&gt;pod2latex&lt;/b&gt;, and &lt;b&gt;pod2fm&lt;/b&gt;. Various others are available in CPAN.</source>
          <target state="translated">Формат Pod не обязательно достаточен для написания книги. Pod - это просто защищенный от идиотов общий источник для nroff, HTML, TeX и других языков разметки, используемых для онлайн-документации. Переводчики существуют для &lt;b&gt;pod2text&lt;/b&gt; , &lt;b&gt;pod2html&lt;/b&gt; , &lt;b&gt;pod2man&lt;/b&gt; (это для nroff (1) и troff (1)), &lt;b&gt;pod2latex&lt;/b&gt; и &lt;b&gt;pod2fm&lt;/b&gt; . Различные другие доступны в CPAN.</target>
        </trans-unit>
        <trans-unit id="5181d340ea28e7004e1fc926376f0269c6a7af0c" translate="yes" xml:space="preserve">
          <source>The Pod parser normally expects to read octets and to convert those octets to characters based on the &lt;code&gt;=encoding&lt;/code&gt; declaration in the Pod source. Set this option to a true value to indicate that the Pod source is already a Perl character stream. This tells the parser to ignore any &lt;code&gt;=encoding&lt;/code&gt; command and to skip all the code paths involving decoding octets.</source>
          <target state="translated">Парсер Pod обычно ожидает чтения октетов и преобразования этих октетов в символы на основе объявления &lt;code&gt;=encoding&lt;/code&gt; в источнике Pod. Установите для этого параметра значение true, чтобы указать, что источником Pod уже является поток символов Perl. Это указывает синтаксическому анализатору игнорировать любую команду &lt;code&gt;=encoding&lt;/code&gt; и пропускать все пути кода, включающие октеты декодирования.</target>
        </trans-unit>
        <trans-unit id="d54e40195036f1a1a1b5551f96370345ff64638a" translate="yes" xml:space="preserve">
          <source>The Pod::Simple parser expects to read &lt;b&gt;octets&lt;/b&gt;. The parser will decode the octets into Perl's internal character string representation using the value of the &lt;code&gt;=encoding&lt;/code&gt; declaration in the POD source.</source>
          <target state="translated">Парсер Pod :: Simple ожидает чтения &lt;b&gt;октетов&lt;/b&gt; . Парсер декодирует октеты во внутреннее представление символьной строки Perl, используя значение объявления &lt;code&gt;=encoding&lt;/code&gt; в источнике POD.</target>
        </trans-unit>
        <trans-unit id="a52e0eb3298b4fa461fa923215cc1e681ac40256" translate="yes" xml:space="preserve">
          <source>The Pod::Usage distribution comes with a script pod2usage which offers a command line interface to the functionality of Pod::Usage. See &lt;a href=&quot;../pod2usage&quot;&gt;pod2usage&lt;/a&gt;.</source>
          <target state="translated">В дистрибутив Pod :: Usage входит скрипт pod2usage, который предлагает интерфейс командной строки для функциональности Pod :: Usage. См. &lt;a href=&quot;../pod2usage&quot;&gt;Pod2usage&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27cf4d4fc397867d0e2a99e5b7bffdeae843c96c" translate="yes" xml:space="preserve">
          <source>The Portable Operating System Interface specification.</source>
          <target state="translated">Спецификация интерфейса портативной операционной системы.</target>
        </trans-unit>
        <trans-unit id="355c15d3884285cbe9de6e8c0623457a61fdc6ca" translate="yes" xml:space="preserve">
          <source>The Problem</source>
          <target state="translated">Проблема</target>
        </trans-unit>
        <trans-unit id="cca8ca027231a86237a6c4dda51f169cc4d16c32" translate="yes" xml:space="preserve">
          <source>The Pugs prototype Perl 6 Object Model uses C3</source>
          <target state="translated">Прототип Pugs Perl 6 объектная модель использует C3</target>
        </trans-unit>
        <trans-unit id="77d5d72ac418e20fd29b7eec3b6c8de1afc54920" translate="yes" xml:space="preserve">
          <source>The REGEXP struct is defined in</source>
          <target state="translated">Структура REGEXP определена в</target>
        </trans-unit>
        <trans-unit id="2ad89d37eadf28843f6bcc04fe292798559736be" translate="yes" xml:space="preserve">
          <source>The REGEXP structure</source>
          <target state="translated">Структура REGEXP</target>
        </trans-unit>
        <trans-unit id="8da65302c118d1898dddaf19bb76877bb8166258" translate="yes" xml:space="preserve">
          <source>The REGEXP structure contains all the data that Perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that Perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts, such as if the pattern anchored in some way, or what flags were used during the compile, or if the program contains special constructs that Perl needs to be aware of.</source>
          <target state="translated">Структура REGEXP содержит все данные,которые Perl должен знать,чтобы правильно работать с регулярным выражением.Она включает данные об оптимизациях,которые Perl может использовать для определения того,действительно ли следует использовать регекс-движок,а также различную другую контрольную информацию,необходимую для правильного выполнения шаблонов в различных контекстах,например,если шаблон каким-то образом закреплен,или какие флаги были использованы во время компиляции,или если программа содержит специальные конструкции,о которых Perl должен быть осведомлен.</target>
        </trans-unit>
        <trans-unit id="1d6f38948819f825c1778442bfb0bf54fd236038" translate="yes" xml:space="preserve">
          <source>The REQUIRE: Keyword</source>
          <target state="translated">ЗАПИСЬ:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="eb7911fb319180325559ab93300e4a8e754d4918" translate="yes" xml:space="preserve">
          <source>The REQUIRE: keyword is used to indicate the minimum version of the &lt;b&gt;xsubpp&lt;/b&gt; compiler needed to compile the XS module. An XS module which contains the following statement will compile with only &lt;b&gt;xsubpp&lt;/b&gt; version 1.922 or greater:</source>
          <target state="translated">Ключевое слово REQUIRE: используется для указания минимальной версии компилятора &lt;b&gt;xsubpp,&lt;/b&gt; необходимой для компиляции модуля XS. Модуль XS, содержащий следующий оператор, будет компилироваться только с &lt;b&gt;xsubpp&lt;/b&gt; версии 1.922 или выше:</target>
        </trans-unit>
        <trans-unit id="325d9dc6bcb33887233fc6bb3fee83c1db779aa6" translate="yes" xml:space="preserve">
          <source>The RETVAL Variable</source>
          <target state="translated">Переменная RETVAL</target>
        </trans-unit>
        <trans-unit id="2c001438878b5f3376fc8700b6556da0eb7ce7c1" translate="yes" xml:space="preserve">
          <source>The RETVAL variable is a special C variable that is declared automatically for you. The C type of RETVAL matches the return type of the C library function. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will declare this variable in each XSUB with non-&lt;code&gt;void&lt;/code&gt; return type. By default the generated C function will use RETVAL to hold the return value of the C library function being called. In simple cases the value of RETVAL will be placed in ST(0) of the argument stack where it can be received by Perl as the return value of the XSUB.</source>
          <target state="translated">Переменная RETVAL - это специальная переменная C, которая объявляется автоматически. Тип C для RETVAL соответствует типу возврата функции библиотеки C. &lt;b&gt;Xsubpp&lt;/b&gt; компилятор объявит это переменный в каждом XSub с не- &lt;code&gt;void&lt;/code&gt; типа возвращаемого значения . По умолчанию сгенерированная функция C будет использовать RETVAL для хранения возвращаемого значения вызываемой библиотечной функции C. В простых случаях значение RETVAL будет помещено в ST (0) стека аргументов, откуда оно может быть получено Perl как возвращаемое значение XSUB.</target>
        </trans-unit>
        <trans-unit id="b5719fca838ea2f703064b736671d8a5c53c2b7c" translate="yes" xml:space="preserve">
          <source>The Ram is a cookbook with hundreds of examples of using Perl to accomplish specific tasks:</source>
          <target state="translated">Рам-это кулинарная книга с сотнями примеров использования Perl для выполнения конкретных задач:</target>
        </trans-unit>
        <trans-unit id="bda5eb8009d503d3f7d7ac84a0313722c46a6dc4" translate="yes" xml:space="preserve">
          <source>The Rest</source>
          <target state="translated">Отдых</target>
        </trans-unit>
        <trans-unit id="c06052540c4d2319036f128e767c17cbef7e664e" translate="yes" xml:space="preserve">
          <source>The Role of the typemap File in Your Distribution</source>
          <target state="translated">Роль файла типовой карты в вашем распространении</target>
        </trans-unit>
        <trans-unit id="5afe900033efd0b8bef5b765a85f46485e313663" translate="yes" xml:space="preserve">
          <source>The SCOPE: Keyword</source>
          <target state="translated">СКОПЕ:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="3f77c1166b9eee5ec219ef962a60436e0a2f2130" translate="yes" xml:space="preserve">
          <source>The SCOPE: keyword allows scoping to be enabled for a particular XSUB. If enabled, the XSUB will invoke ENTER and LEAVE automatically.</source>
          <target state="translated">Ключевое слово SCOPE:позволяет включить определение масштаба для конкретного XSUB.Если эта опция включена,XSUB будет автоматически вызывать ENTER и LEAVE.</target>
        </trans-unit>
        <trans-unit id="3f3c8dbe377ba2fb462f83142477acc2c9fed9b5" translate="yes" xml:space="preserve">
          <source>The SEEK_* constants can be imported from the &lt;code&gt;Fcntl&lt;/code&gt; module if you don't wish to use the numbers &lt;code&gt;0&lt;/code&gt;&lt;code&gt;1&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt; in your code.</source>
          <target state="translated">Константы SEEK_ * могут быть импортированы из модуля &lt;code&gt;Fcntl&lt;/code&gt; , если вы не хотите использовать в коде числа &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; или &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6874e0e71dff8b677770e211cb23f7a0bc03af61" translate="yes" xml:space="preserve">
          <source>The STDIN filehandle used by the command is inherited from Perl's STDIN. For example:</source>
          <target state="translated">Файловая ручка STDIN,используемая командой,наследуется от STDIN Perl.Например:</target>
        </trans-unit>
        <trans-unit id="c9698c556df2cef5c4ee4e944157366d894bd711" translate="yes" xml:space="preserve">
          <source>The SV arena serves the secondary purpose of allowing still-live SVs to be located and destroyed during final cleanup.</source>
          <target state="translated">Арена SV служит вторичной целью,позволяя местоположение неподвижных SV и их уничтожение во время финальной уборки.</target>
        </trans-unit>
        <trans-unit id="82e45de5e22cb3332054cbfb0b3a963e2aa8939b" translate="yes" xml:space="preserve">
          <source>The SV returned has a refcount of 1.</source>
          <target state="translated">Возвращаемое SV имеет пересчет 1.</target>
        </trans-unit>
        <trans-unit id="3397a37f03fe6e25c10e0df218712221b41b076a" translate="yes" xml:space="preserve">
          <source>The SV* corresponding to the $_ variable. Works even if there is a lexical $_ in scope.</source>
          <target state="translated">SV*,соответствующая переменной $_.Работает,даже если в области видимости есть лексический $_.</target>
        </trans-unit>
        <trans-unit id="166ec7ce6ae952f37ed9ee7074b722386bfc06c5" translate="yes" xml:space="preserve">
          <source>The SYS:/temp is preferred in Novell NetWare and the C:\system\temp for Symbian (the File::Spec::Win32 is used also for those platforms).</source>
          <target state="translated">SYS:/temp предпочтительнее в Novell NetWare и C:\system\temp для Symbian (File::Spec::Win32 также используется для этих платформ).</target>
        </trans-unit>
        <trans-unit id="c305a702522737f58ad2f086c3a8baae101bf7fa" translate="yes" xml:space="preserve">
          <source>The Safe extension module allows the creation of compartments in which perl code can be evaluated. Each compartment has</source>
          <target state="translated">Модуль расширения Safe позволяет создавать отсеки,в которых можно оценивать perl-код.Каждое отделение имеет</target>
        </trans-unit>
        <trans-unit id="f3ebdf6626009aca2f7b1117ac99eeb3a50e8a0f" translate="yes" xml:space="preserve">
          <source>The Second Rule of Sys::Syslog is:</source>
          <target state="translated">Второе правило Sys::Syslog:</target>
        </trans-unit>
        <trans-unit id="59ce582565e3aa2e433ddd5ed3ee6bdecbd67e3d" translate="yes" xml:space="preserve">
          <source>The Secure Hash Standard (Draft FIPS PUB 180-4) can be found at:</source>
          <target state="translated">Стандарт безопасности хэша (проект FIPS PUB 180-4)можно найти по адресу:</target>
        </trans-unit>
        <trans-unit id="a0cf9a0044474cf0b7a47510d7ab73b298c8894f" translate="yes" xml:space="preserve">
          <source>The SelfLoader can load stubs automatically at module initialization with the statement 'SelfLoader-&amp;gt;load_stubs()';, but you may wish to avoid having the stub loading overhead associated with your initialization (though note that the SelfLoader::load_stubs method will be called sooner or later - at latest when the first sub is being autoloaded). In this case, you can put the sub stubs before the __DATA__ token. This can be done manually, but this module allows automatic generation of the stubs.</source>
          <target state="translated">SelfLoader может автоматически загружать заглушки при инициализации модуля с помощью оператора SelfLoader-&amp;gt; load_stubs ();, но вы можете избежать накладных расходов на загрузку заглушек, связанных с вашей инициализацией (хотя обратите внимание, что будет вызываться метод SelfLoader :: load_stubs рано или поздно - не позднее, чем при автозагрузке первого саба). В этом случае вы можете поместить суб-заглушки перед токеном __DATA__. Это можно сделать вручную, но этот модуль позволяет автоматически создавать заглушки.</target>
        </trans-unit>
        <trans-unit id="c273113828f1c56d85466a94fe42bd54d051b33a" translate="yes" xml:space="preserve">
          <source>The Seventh Rule of Sys::Syslog is:</source>
          <target state="translated">Седьмое правило Sys::Syslog:</target>
        </trans-unit>
        <trans-unit id="48b5fdd7473bc512821401bfc6bdb55846607392" translate="yes" xml:space="preserve">
          <source>The Silmarillion</source>
          <target state="translated">Сильмариллион</target>
        </trans-unit>
        <trans-unit id="3d872a2e6f315517170676af6926b6bd336f2e79" translate="yes" xml:space="preserve">
          <source>The Sixth Rule of Sys::Syslog is:</source>
          <target state="translated">Шестое правило Sys::Syslog:</target>
        </trans-unit>
        <trans-unit id="2615af73b1e9a8107739890b278d6bb8e8c58b89" translate="yes" xml:space="preserve">
          <source>The Socket library makes this slightly easier:</source>
          <target state="translated">Библиотека Socket немного облегчает эту задачу:</target>
        </trans-unit>
        <trans-unit id="0346baceabdf020f1948aaad1950b71c29c8313d" translate="yes" xml:space="preserve">
          <source>The Solaris FAQ is available at &lt;a href=&quot;http://www.science.uva.nl/pub/solaris/solaris2.html&quot;&gt;http://www.science.uva.nl/pub/solaris/solaris2.html&lt;/a&gt;.</source>
          <target state="translated">FAQ по Solaris доступен по адресу &lt;a href=&quot;http://www.science.uva.nl/pub/solaris/solaris2.html&quot;&gt;http://www.science.uva.nl/pub/solaris/solaris2.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6524b148594d89baefb15f79bab2c7c15e79227" translate="yes" xml:space="preserve">
          <source>The Solution</source>
          <target state="translated">Решение</target>
        </trans-unit>
        <trans-unit id="f8bdb1b7f6851c01f4e6dd6b9335a25cbb9f32fe" translate="yes" xml:space="preserve">
          <source>The Source Filters distribution is available on CPAN, in</source>
          <target state="translated">Распространение фильтров источников доступно на CPAN,в разделе</target>
        </trans-unit>
        <trans-unit id="c95deb069230cbfe43ae345e5dcb1b877dd184d4" translate="yes" xml:space="preserve">
          <source>The Storable engine can also store data into a Perl scalar instead, to later retrieve them. This is mainly used to freeze a complex structure in some safe compact memory place (where it can possibly be sent to another process via some IPC, since freezing the structure also serializes it in effect). Later on, and maybe somewhere else, you can thaw the Perl scalar out and recreate the original complex structure in memory.</source>
          <target state="translated">Двигатель Storable также может хранить данные в скаляре на Perl,а затем извлекать их.В основном это используется для замораживания сложной структуры в каком-нибудь безопасном компактном месте памяти (где она может быть отправлена в другой процесс через какой-нибудь IPC,так как замораживание структуры также сериализует ее в действительности).Позже,а может быть и в другом месте,вы можете разморозить Perl скаляр и воссоздать исходную сложную структуру в памяти.</target>
        </trans-unit>
        <trans-unit id="b46a98161104ffbf830836edabb2204067559b45" translate="yes" xml:space="preserve">
          <source>The Storable package brings persistence to your Perl data structures containing SCALAR, ARRAY, HASH or REF objects, i.e. anything that can be conveniently stored to disk and retrieved at a later time.</source>
          <target state="translated">Пакет Storable обеспечивает персистентность ваших структур данных Perl,содержащих объекты SCALAR,ARRAY,HASH или REF,т.е.все,что можно удобно хранить на диске и впоследствии извлекать.</target>
        </trans-unit>
        <trans-unit id="1c31479831ac23c24002214051aef3521fbb967b" translate="yes" xml:space="preserve">
          <source>The Sun Managers' FAQ is available at &lt;a href=&quot;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&quot;&gt;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&lt;/a&gt;</source>
          <target state="translated">Часто задаваемые вопросы менеджеров Sun доступны по адресу &lt;a href=&quot;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&quot;&gt;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e4005ffb38cdcce66cf2552b3af0aed0d38d327" translate="yes" xml:space="preserve">
          <source>The Symbian port is licensed under the same terms as Perl itself.</source>
          <target state="translated">Симбианский порт лицензирован на тех же условиях,что и сам Perl.</target>
        </trans-unit>
        <trans-unit id="2d3f94b6eeafe888e9cb15f1090b03b3cc5b3e69" translate="yes" xml:space="preserve">
          <source>The Syntax of Variable Names</source>
          <target state="translated">Синтаксис переменных имен</target>
        </trans-unit>
        <trans-unit id="0dcb2ce1d39ebcd7787f9ace607f3511d6d60bc4" translate="yes" xml:space="preserve">
          <source>The SysV IPC code above was written long ago, and it's definitely clunky looking. For a more modern look, see the IPC::SysV module.</source>
          <target state="translated">SysV IPC код выше был написан давным-давно,и он определенно неуклюже выглядит.Для более современного взгляда смотрите модуль IPC::SysV.</target>
        </trans-unit>
        <trans-unit id="81ef1999f4ab1d77c16c0134c1c911b0b6e377cd" translate="yes" xml:space="preserve">
          <source>The TEMPLATE has the same format as in the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function. Here's a subroutine that does substring:</source>
          <target state="translated">ШАБЛОН имеет тот же формат, что и функция &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; . Вот подпрограмма, которая выполняет подстроку:</target>
        </trans-unit>
        <trans-unit id="14ab3be603ef17e174d5422d8fa9db4cbcd8a394" translate="yes" xml:space="preserve">
          <source>The TEMPLATE has the same format as in the &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function. Here's a subroutine that does substring:</source>
          <target state="translated">ШАБЛОН имеет тот же формат, что и функция &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; . Вот подпрограмма, которая выполняет подстроку:</target>
        </trans-unit>
        <trans-unit id="c84fad0e6672900e0ccb385df9c5a53aa073119f" translate="yes" xml:space="preserve">
          <source>The TEMPLATE is a sequence of characters that give the order and type of values, as follows:</source>
          <target state="translated">TEMPLATE представляет собой последовательность символов,которые дают порядок и тип значений,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="aa18d821da8b238046aafed6e970f790f7308b97" translate="yes" xml:space="preserve">
          <source>The TTY to use for debugging I/O.</source>
          <target state="translated">TTY для отладки ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="28ac83583a93c3bbe04e5be7ac1ae0bf8d97eb60" translate="yes" xml:space="preserve">
          <source>The TYPEMAP file</source>
          <target state="translated">Файл TYPEMAP</target>
        </trans-unit>
        <trans-unit id="10a06ea76a05d039fe9de3770c4f7ea4ca5db2f3" translate="yes" xml:space="preserve">
          <source>The TYPEMAP: Keyword</source>
          <target state="translated">TYPEMAP:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="a995c45f782f6eac7b2e49619c36fb98f70351d5" translate="yes" xml:space="preserve">
          <source>The T_SYSRET typemap is used to process return values from system calls. It is only meaningful when passing values from C to perl (there is no concept of passing a system return value from Perl to C).</source>
          <target state="translated">Типовая карта T_SYSRET используется для обработки возвращаемых значений из системных вызовов.Она имеет смысл только при передаче значений от C к perl (отсутствует концепция передачи возвращаемого системного значения от Perl к C).</target>
        </trans-unit>
        <trans-unit id="c00d492559cf23114ccf6a4416bb2a3622dd118a" translate="yes" xml:space="preserve">
          <source>The Tale of the Children of Hurin</source>
          <target state="translated">Повесть о детях Хурина.</target>
        </trans-unit>
        <trans-unit id="dc20618b36ece0cca578d0aaf6a793d399b51768" translate="yes" xml:space="preserve">
          <source>The Tamil digits (U+0BE6 - U+0BEF) can also legally be used in old-style Tamil numbers in which they would appear no more than one in a row, separated by characters that mean &quot;times 10&quot;, &quot;times 100&quot;, etc. (See &lt;a href=&quot;http://www.unicode.org/notes/tn21&quot;&gt;http://www.unicode.org/notes/tn21&lt;/a&gt;.)</source>
          <target state="translated">Тамильские цифры (U + 0BE6 - U + 0BEF) также могут законно использоваться в тамильских числах старого стиля, в которых они будут появляться не более одной в строке, разделенных символами, которые означают &amp;laquo;умножить на 10&amp;raquo;, &amp;laquo;умножить на 100&amp;raquo;. и т. д. (См. &lt;a href=&quot;http://www.unicode.org/notes/tn21&quot;&gt;http://www.unicode.org/notes/tn21&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="47ba114bf39e8b27a93263e54d8b1d42bd44b898" translate="yes" xml:space="preserve">
          <source>The Term::ReadKey module from CPAN may be easier to use. Recent versions include also support for non-portable systems as well.</source>
          <target state="translated">Модуль Term::ReadKey из CPAN может быть проще в использовании.Последние версии включают также поддержку для неподвижных систем.</target>
        </trans-unit>
        <trans-unit id="35a1f7393254a3b1337f16135889cbf5d4ddbd76" translate="yes" xml:space="preserve">
          <source>The Third Rule of Sys::Syslog is:</source>
          <target state="translated">Третье правило Sys::Syslog:</target>
        </trans-unit>
        <trans-unit id="93fb358185964087944f1d6c1078da04b430b4f0" translate="yes" xml:space="preserve">
          <source>The Tree subsubsection in XML::Parser</source>
          <target state="translated">Подраздел &quot;Дерево&quot; в XML::Parser</target>
        </trans-unit>
        <trans-unit id="8dd1d72b0140a01ec4804e7eb5bb38229499e0d2" translate="yes" xml:space="preserve">
          <source>The U/WIN environment for Win32, &lt;a href=&quot;http://www.research.att.com/sw/tools/uwin/&quot;&gt;http://www.research.att.com/sw/tools/uwin/&lt;/a&gt;</source>
          <target state="translated">Среда U / WIN для Win32, &lt;a href=&quot;http://www.research.att.com/sw/tools/uwin/&quot;&gt;http://www.research.att.com/sw/tools/uwin/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="769648b0d99f3965f04ad4c0ff49f028dec18b56" translate="yes" xml:space="preserve">
          <source>The UNICODE_WARN_NONCHAR and UNICODE_DISALLOW_NONCHAR flags affect how the function handles a Unicode non-character. And likewise, the UNICODE_WARN_SUPER and UNICODE_DISALLOW_SUPER flags affect the handling of code points that are above the Unicode maximum of 0x10FFFF. Code points above 0x7FFF_FFFF (which are even less portable) can be warned and/or disallowed even if other above-Unicode code points are accepted, by the UNICODE_WARN_FE_FF and UNICODE_DISALLOW_FE_FF flags.</source>
          <target state="translated">Флаги UNICODE_WARN_NONCHAR и UNICODE_DISALLOW_NONCHAR влияют на то,как функция обрабатывает несимволы Unicode.Также флаги UNICODE_WARN_SUPER и UNICODE_DISALLOW_SUPER влияют на обработку кодовых точек,максимальный размер которых в Юникоде равен 0x10FFFF.Точки кода выше 0x7FFF_FFFF (которые еще менее переносимы)могут быть предупреждены и/или запрещены,даже если приняты другие точки кода выше Юникода,флагами UNICODE_WARN_FE_FF и UNICODE_DISALLOW_FE_FF.</target>
        </trans-unit>
        <trans-unit id="b1a9962a264046baa6e654280499186de4c8dcb8" translate="yes" xml:space="preserve">
          <source>The UNIVERSAL Class</source>
          <target state="translated">УНИВЕРСАЛЬНЫЙ Класс</target>
        </trans-unit>
        <trans-unit id="626ffdf925f7f1a1535b1e7a24ab5f1836995ec2" translate="yes" xml:space="preserve">
          <source>The URL or relative path of a CSS file to include. This option is not set by default.</source>
          <target state="translated">URL-адрес или относительный путь к включаемому CSS-файлу.Эта опция не установлена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="40bee207a472a4fd5b0841568ca70dbba8442ce0" translate="yes" xml:space="preserve">
          <source>The URL or relative path of a JavaScript file to pull in. This option is not set by default.</source>
          <target state="translated">URL или относительный путь к JavaScript-файлу для подключения.Эта опция не установлена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="da88ae39f79698f8a366077011136f1217b89d12" translate="yes" xml:space="preserve">
          <source>The USE_PERLIO implementation is described in &lt;a href=&quot;perliol&quot;&gt;perliol&lt;/a&gt;.</source>
          <target state="translated">Реализация USE_PERLIO описана в &lt;a href=&quot;perliol&quot;&gt;perliol&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5daf05eaea510ba5b0017fb9c306e9890c51ff94" translate="yes" xml:space="preserve">
          <source>The UTF-32 family is pretty much like the UTF-16 family, except that the units are 32-bit, and therefore the surrogate scheme is not needed. UTF-32 is a fixed-width encoding. The &lt;code&gt;BOM&lt;/code&gt; signatures are &lt;code&gt;0x00 0x00 0xFE 0xFF&lt;/code&gt; for BE and &lt;code&gt;0xFF 0xFE 0x00 0x00&lt;/code&gt; for LE.</source>
          <target state="translated">Семейство UTF-32 во многом похоже на семейство UTF-16, за исключением того, что модули являются 32-битными, и поэтому суррогатная схема не требуется. UTF-32 - это кодировка с фиксированной шириной. В &lt;code&gt;BOM&lt;/code&gt; подпись &lt;code&gt;0x00 0x00 0xFE 0xFF&lt;/code&gt; для В и &lt;code&gt;0xFF 0xFE 0x00 0x00&lt;/code&gt; для LE.</target>
        </trans-unit>
        <trans-unit id="1dd8debe441de21cb20cb60141841b3943f5b160" translate="yes" xml:space="preserve">
          <source>The UTF8 flag</source>
          <target state="translated">Флаг UTF8</target>
        </trans-unit>
        <trans-unit id="e84247eff9f0cf26586d5f7b3851d2932bd10a42" translate="yes" xml:space="preserve">
          <source>The UTF8 flag, also called SvUTF8, is an internal flag that indicates that the current internal representation is UTF-8. Without the flag, it is assumed to be ISO-8859-1. Perl converts between these automatically. (Actually Perl usually assumes the representation is ASCII; see &lt;a href=&quot;#Why-do-regex-character-classes-sometimes-match-only-in-the-ASCII-range%3f&quot;&gt;Why do regex character classes sometimes match only in the ASCII range?&lt;/a&gt; above.)</source>
          <target state="translated">Флаг UTF8, также называемый SvUTF8, является внутренним флагом, который указывает, что текущее внутреннее представление - UTF-8. Без флага предполагается, что это ISO-8859-1. Perl автоматически преобразует их между ними. (На самом деле Perl обычно предполагает, что представление - это ASCII; см. &lt;a href=&quot;#Why-do-regex-character-classes-sometimes-match-only-in-the-ASCII-range%3f&quot;&gt;Почему классы символов регулярных выражений иногда совпадают только в диапазоне ASCII?&lt;/a&gt; Выше.)</target>
        </trans-unit>
        <trans-unit id="0c156f969a0dd40349df4b801ec75724f31841f0" translate="yes" xml:space="preserve">
          <source>The UTF8_CHECK_ONLY flag overrides the behavior when a non-allowed (by other flags) malformation is found. If this flag is set, the routine assumes that the caller will raise a warning, and this function will silently just set &lt;code&gt;retlen&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt; (cast to &lt;code&gt;STRLEN&lt;/code&gt; ) and return zero.</source>
          <target state="translated">Флаг UTF8_CHECK_ONLY переопределяет поведение при обнаружении недопустимого (другими флагами) искажения. Если этот флаг установлен, процедура предполагает, что вызывающий объект выдаст предупреждение, и эта функция просто установит &lt;code&gt;retlen&lt;/code&gt; на &lt;code&gt;-1&lt;/code&gt; (приведение к &lt;code&gt;STRLEN&lt;/code&gt; ) и вернет ноль.</target>
        </trans-unit>
        <trans-unit id="fe051c2554d575b5ef8dd3483cd37e0f3f831882" translate="yes" xml:space="preserve">
          <source>The Unicode &lt;code&gt;Script&lt;/code&gt; and &lt;code&gt;Script_Extensions&lt;/code&gt; properties give what script a given character is in. Either property can be specified with the compound form like &lt;code&gt;\p{Script=Hebrew}&lt;/code&gt; (short: &lt;code&gt;\p{sc=hebr}&lt;/code&gt; ), or &lt;code&gt;\p{Script_Extensions=Javanese}&lt;/code&gt; (short: &lt;code&gt;\p{scx=java}&lt;/code&gt; ). In addition, Perl furnishes shortcuts for all &lt;code&gt;Script&lt;/code&gt; property names. You can omit everything up through the equals (or colon), and simply write &lt;code&gt;\p{Latin}&lt;/code&gt; or &lt;code&gt;\P{Cyrillic}&lt;/code&gt; . (This is not true for &lt;code&gt;Script_Extensions&lt;/code&gt; , which is required to be written in the compound form.)</source>
          <target state="translated">Свойства Unicode &lt;code&gt;Script&lt;/code&gt; и &lt;code&gt;Script_Extensions&lt;/code&gt; указывают,в каком скрипте находится данный символ. Любое свойство может быть указано в составной форме, например &lt;code&gt;\p{Script=Hebrew}&lt;/code&gt; (сокращенно: &lt;code&gt;\p{sc=hebr}&lt;/code&gt; ) или &lt;code&gt;\p{Script_Extensions=Javanese}&lt;/code&gt; (сокращенно: &lt;code&gt;\p{scx=java}&lt;/code&gt; ). Кроме того, Perl предоставляет ярлыки для всех имен свойств &lt;code&gt;Script&lt;/code&gt; . Вы можете пропустить все, вплоть до знака равенства (или двоеточия), и просто написать &lt;code&gt;\p{Latin}&lt;/code&gt; или &lt;code&gt;\P{Cyrillic}&lt;/code&gt; . (Это неверно для &lt;code&gt;Script_Extensions&lt;/code&gt; , который требуется записывать в составной форме.)</target>
        </trans-unit>
        <trans-unit id="68ace88196ee8ab90b1eb6e05c27ca6293cc1949" translate="yes" xml:space="preserve">
          <source>The Unicode &lt;code&gt;\p{Script}&lt;/code&gt; property is used to categorize every Unicode character into the language script it is written in. For example, English, French, and a bunch of other European languages are written in the Latin script. But there is also the Greek script, the Thai script, the Katakana script, etc. You can test whether a character is in a particular script with, for example &lt;code&gt;\p{Latin}&lt;/code&gt; , &lt;code&gt;\p{Greek}&lt;/code&gt; , or &lt;code&gt;\p{Katakana}&lt;/code&gt; . To test if it isn't in the Balinese script, you would use &lt;code&gt;\P{Balinese}&lt;/code&gt; .</source>
          <target state="translated">Свойство Unicode &lt;code&gt;\p{Script}&lt;/code&gt; используется для категоризации каждого символа Unicode в соответствии с языковым сценарием, на котором он написан. Например, английский, французский и ряд других европейских языков написаны латинскими буквами. Но есть также греческий сценарий, тайский сценарий, сценарий катакана и т. Д. Вы можете проверить, находится ли персонаж в конкретном сценарии, например, &lt;code&gt;\p{Latin}&lt;/code&gt; , &lt;code&gt;\p{Greek}&lt;/code&gt; или &lt;code&gt;\p{Katakana}&lt;/code&gt; . Чтобы проверить, нет ли этого в балийском сценарии, вы должны использовать &lt;code&gt;\P{Balinese}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c137959e417f1d80c5a78f30067a032e5b5cba1e" translate="yes" xml:space="preserve">
          <source>The Unicode CLDR project extracts the POSIX portion of many of its locales, available at</source>
          <target state="translated">В рамках проекта Unicode CLDR извлекается часть POSIX из многих его локалей,доступных по адресу</target>
        </trans-unit>
        <trans-unit id="d486f8bf02133ca434524335056eb02772644059" translate="yes" xml:space="preserve">
          <source>The Unicode Character Map</source>
          <target state="translated">Карта персонажей Юникода</target>
        </trans-unit>
        <trans-unit id="c5ce90a3e4de6a4acbbf53c0744b1a0991c6efd2" translate="yes" xml:space="preserve">
          <source>The Unicode Consortium has a list of articles and books, some of which give a much more in depth treatment of Unicode: &lt;a href=&quot;http://unicode.org/resources/readinglist.html&quot;&gt;http://unicode.org/resources/readinglist.html&lt;/a&gt;</source>
          <target state="translated">Консорциум Unicode имеет список статей и книг, в некоторых из которых дается гораздо более глубокое рассмотрение Unicode: &lt;a href=&quot;http://unicode.org/resources/readinglist.html&quot;&gt;http://unicode.org/resources/readinglist.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f47c9f664ce4e52a0db000d2410941371e77032" translate="yes" xml:space="preserve">
          <source>The Unicode Standard, Version 6.1</source>
          <target state="translated">Стандарт Юникода,версия 6.1.</target>
        </trans-unit>
        <trans-unit id="ceaf176fe24089b589f5a8df64bfcb78329c82a1" translate="yes" xml:space="preserve">
          <source>The Unicode character sets associates characters with integers. Encoding these numbers in an equal number of bytes would more than double the requirements for storing texts written in Latin alphabets. The UTF-8 encoding avoids this by storing the most common (from a western point of view) characters in a single byte while encoding the rarer ones in three or more bytes.</source>
          <target state="translated">Символ Юникода ассоциирует символы с целыми числами.Кодирование этих чисел равным количеством байт более чем в два раза превышает требования к хранению текстов,написанных на латинских алфавитах.Кодировка UTF-8 позволяет избежать этого за счет хранения наиболее распространенных (с западной точки зрения)символов в одном байте при кодировании более редких в три и более байта.</target>
        </trans-unit>
        <trans-unit id="b01639a1272db3c72594d5482698c9a198da2486" translate="yes" xml:space="preserve">
          <source>The Unicode code points are just abstract numbers. To input and output these abstract numbers, the numbers must be</source>
          <target state="translated">Точки кода Юникода-это просто абстрактные числа.Для ввода и вывода этих абстрактных чисел,они должны иметь вид</target>
        </trans-unit>
        <trans-unit id="fee82003cf69ee996e6b6206be19d9eb1e9b4ae7" translate="yes" xml:space="preserve">
          <source>The Unicode data base is delivered in two different formats. The XML version is valid for more modern Unicode releases. The other version is a collection of files. The two are intended to give equivalent information. Perl uses the older form; this allows you to recompile Perl to use early Unicode releases.</source>
          <target state="translated">База данных Unicode поставляется в двух различных форматах.XML-версия действительна для более современных релизов Юникода.Другая версия представляет собой набор файлов.Эти файлы предназначены для предоставления эквивалентной информации.Perl использует старую форму;это позволяет перекомпилировать Perl для использования ранних релизов Юникода.</target>
        </trans-unit>
        <trans-unit id="0af64faddaa46b640051dd4c06cacd9bdf1c61ba" translate="yes" xml:space="preserve">
          <source>The Unicode name for each of the control characters (such as LINE FEED) is the empty string. However almost all had names assigned by other standards, such as the ASCII Standard, or were in common use. &lt;code&gt;viacode&lt;/code&gt; returns these names as the &quot;best&quot; ones available. Unicode 6.1 has created Name_Aliases for each of them, including alternate names, like NEW LINE. &lt;code&gt;viacode&lt;/code&gt; uses the original name, &quot;LINE FEED&quot; in preference to the alternate. Similarly the name returned for U+FEFF is &quot;ZERO WIDTH NO-BREAK SPACE&quot;, not &quot;BYTE ORDER MARK&quot;.</source>
          <target state="translated">Имя Unicode для каждого из управляющих символов (например, LINE FEED) - это пустая строка. Однако почти все они имели имена, присвоенные другими стандартами, такими как стандарт ASCII, или использовались повсеместно. &lt;code&gt;viacode&lt;/code&gt; возвращает эти имена как &amp;laquo;лучшие&amp;raquo; из имеющихся. Unicode 6.1 создал Name_Aliases для каждого из них, включая альтернативные имена, например NEW LINE. &lt;code&gt;viacode&lt;/code&gt; использует исходное имя &amp;laquo;LINE FEED&amp;raquo; вместо альтернативного. Точно так же имя, возвращаемое для U + FEFF, - &quot;ПРОБЕЛ НУЛЕВОЙ ШИРИНЫ БЕЗ РАЗРЫВА&quot;, а не &quot;МЕТКА ПОРЯДКА БАЙТОВ&quot;.</target>
        </trans-unit>
        <trans-unit id="1ac858cb298c00054e86b0d115cb91b95f10f3cf" translate="yes" xml:space="preserve">
          <source>The Unicode standard prefers using hexadecimal notation because that more clearly shows the division of Unicode into blocks of 256 characters. Hexadecimal is also simply shorter than decimal. You can use decimal notation, too, but learning to use hexadecimal just makes life easier with the Unicode standard. The &lt;code&gt;U+HHHH&lt;/code&gt; notation uses hexadecimal, for example.</source>
          <target state="translated">Стандарт Unicode предпочитает использовать шестнадцатеричную нотацию, потому что это более четко показывает разделение Unicode на блоки по 256 символов. Шестнадцатеричный формат просто короче десятичного. Вы также можете использовать десятичную нотацию, но обучение использованию шестнадцатеричной системы просто упрощает жизнь благодаря стандарту Unicode. &lt;code&gt;U+HHHH&lt;/code&gt; обозначения использует шестнадцатеричные, например.</target>
        </trans-unit>
        <trans-unit id="e6fd7f938d86967a9161a418271cce0d06cd2600" translate="yes" xml:space="preserve">
          <source>The Unicode standard prefers using hexadecimal notation for the code points. If numbers like &lt;code&gt;0x0041&lt;/code&gt; are unfamiliar to you, take a peek at a later section, &lt;a href=&quot;#Hexadecimal-Notation&quot;&gt;Hexadecimal Notation&lt;/a&gt;. The Unicode standard uses the notation &lt;code&gt;U+0041 LATIN CAPITAL LETTER A&lt;/code&gt;, to give the hexadecimal code point and the normative name of the character.</source>
          <target state="translated">Стандарт Unicode предпочитает использовать шестнадцатеричную нотацию для кодовых точек. Если числа вроде &lt;code&gt;0x0041&lt;/code&gt; вам незнакомы, загляните в следующий раздел, &lt;a href=&quot;#Hexadecimal-Notation&quot;&gt;Шестнадцатеричная нотация&lt;/a&gt; . В стандарте Unicode используется обозначение &lt;code&gt;U+0041 LATIN CAPITAL LETTER A&lt;/code&gt; для обозначения шестнадцатеричной кодовой точки и нормативного имени символа.</target>
        </trans-unit>
        <trans-unit id="c02514a64c1d2f4e4fce35a40ef0864ea99b3007" translate="yes" xml:space="preserve">
          <source>The Unicode::Collate module for perl was written by SADAHIRO Tomoyuki, &amp;lt;SADAHIRO@cpan.org&amp;gt;. This module is Copyright(C) 2001-2014, SADAHIRO Tomoyuki. Japan. All rights reserved.</source>
          <target state="translated">Модуль Unicode :: Collate для perl был написан SADAHIRO Tomoyuki, &amp;lt;SADAHIRO@cpan.org&amp;gt;. Авторские права на этот модуль (C) 2001-2014, SADAHIRO Tomoyuki. Япония. Все права защищены.</target>
        </trans-unit>
        <trans-unit id="473e3f8c820ceadead01839cdf7e14621c8d192f" translate="yes" xml:space="preserve">
          <source>The Unicode::UCD module offers a series of functions that provide a simple interface to the Unicode Character Database.</source>
          <target state="translated">Модуль Unicode::UCD предлагает ряд функций,которые обеспечивают простой интерфейс к базе данных символов Unicode.</target>
        </trans-unit>
        <trans-unit id="26e3ce0808d98a59d29700d316741aae764f2a61" translate="yes" xml:space="preserve">
          <source>The Unix System V IPC (&lt;code&gt;msg*(), sem*(), shm*()&lt;/code&gt; ) is not available even on all Unix platforms.</source>
          <target state="translated">IPC Unix System V ( &lt;code&gt;msg*(), sem*(), shm*()&lt;/code&gt; ) недоступен даже на всех платформах Unix.</target>
        </trans-unit>
        <trans-unit id="fae3b6a0c7efbf25175bd611a319e0fb66e5613e" translate="yes" xml:space="preserve">
          <source>The Unix column assumes that you are not accessing a serial line (like a tty) in canonical mode. If you are, then CR on input becomes &quot;\n&quot;, and &quot;\n&quot; on output becomes CRLF.</source>
          <target state="translated">Столбец Unix предполагает,что вы не получаете доступ к последовательной строке (например,tty)в каноническом режиме.Если это так,то CR на входе становится &quot;\n&quot;,а &quot;\n&quot; на выходе становится CRLF.</target>
        </trans-unit>
        <trans-unit id="dd39418cfe05cee0fae6b087e55e6c5b32837941" translate="yes" xml:space="preserve">
          <source>The Unix emulation library's translation of filenames to native assumes that this sort of translation is required, and it allows a user-defined list of known suffixes that it will transpose in this fashion. This may seem transparent, but consider that with these rules</source>
          <target state="translated">Перевод имен файлов в библиотеке эмуляции Unix на родной язык предполагает,что такой перевод необходим,и позволяет получить определяемый пользователем список известных суффиксов,которые он будет переносить таким образом.Это может показаться прозрачным,но учтите,что с этими правилами</target>
        </trans-unit>
        <trans-unit id="fb551ea7181334bc4b0216d63d17835797e645a3" translate="yes" xml:space="preserve">
          <source>The Unix permission &lt;code&gt;rwxr-x---&lt;/code&gt; is represented as three sets of three bits, or three octal digits: &lt;code&gt;0750&lt;/code&gt; (the leading 0 indicates octal and isn't one of the digits). The &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; value is such a number representing disabled permissions bits. The permission (or &quot;mode&quot;) values you pass &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; are modified by your umask, so even if you tell &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; to create a file with permissions &lt;code&gt;0777&lt;/code&gt; , if your umask is &lt;code&gt;0022&lt;/code&gt; , then the file will actually be created with permissions &lt;code&gt;0755&lt;/code&gt; . If your &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; were &lt;code&gt;0027&lt;/code&gt; (group can't write; others can't read, write, or execute), then passing &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;&lt;code&gt;0666&lt;/code&gt; would create a file with mode &lt;code&gt;0640&lt;/code&gt; (because &lt;code&gt;0666 &amp;amp;~ 027&lt;/code&gt; is &lt;code&gt;0640&lt;/code&gt; ).</source>
          <target state="translated">Разрешение Unix &lt;code&gt;rwxr-x---&lt;/code&gt; представлено в виде трех наборов из трех битов или трех восьмеричных цифр: &lt;code&gt;0750&lt;/code&gt; ( начальный 0 означает восьмеричное, а не одну из цифр). Значение &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; - это такое число, представляющее биты отключенных разрешений. Значения разрешений (или &quot;режима&quot;), которые вы передаете &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; , изменяются вашей umask, поэтому даже если вы &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; создать файл с разрешениями &lt;code&gt;0777&lt;/code&gt; , если ваша umask - &lt;code&gt;0022&lt;/code&gt; , тогда файл будет фактически создан с разрешениями &lt;code&gt;0755&lt;/code&gt; . Если ваша &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; была &lt;code&gt;0027&lt;/code&gt; (группа не может писать; другие не могут читать, писать или выполнять), тогда передача &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; &lt;code&gt;0666&lt;/code&gt; создаст файл с режимом &lt;code&gt;0640&lt;/code&gt; (потому что &lt;code&gt;0666 &amp;amp;~ 027&lt;/code&gt; - &lt;code&gt;0640&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="96615142b96c010257cd138eceafdbdb1fcfb3bc" translate="yes" xml:space="preserve">
          <source>The Unix permission &lt;code&gt;rwxr-x---&lt;/code&gt; is represented as three sets of three bits, or three octal digits: &lt;code&gt;0750&lt;/code&gt; (the leading 0 indicates octal and isn't one of the digits). The &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; value is such a number representing disabled permissions bits. The permission (or &quot;mode&quot;) values you pass &lt;code&gt;&lt;a href=&quot;mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; are modified by your umask, so even if you tell &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; to create a file with permissions &lt;code&gt;0777&lt;/code&gt; , if your umask is &lt;code&gt;0022&lt;/code&gt; , then the file will actually be created with permissions &lt;code&gt;0755&lt;/code&gt; . If your &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; were &lt;code&gt;0027&lt;/code&gt; (group can't write; others can't read, write, or execute), then passing &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;&lt;code&gt;0666&lt;/code&gt; would create a file with mode &lt;code&gt;0640&lt;/code&gt; (because &lt;code&gt;0666 &amp;amp;~ 027&lt;/code&gt; is &lt;code&gt;0640&lt;/code&gt; ).</source>
          <target state="translated">Разрешение Unix &lt;code&gt;rwxr-x---&lt;/code&gt; представлено в виде трех наборов из трех битов или трех восьмеричных цифр: &lt;code&gt;0750&lt;/code&gt; ( начальный 0 означает восьмеричное, а не одну из цифр). Значение &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; - это такое число, представляющее биты отключенных разрешений. Значения разрешений (или &quot;режима&quot;), которые вы передаете &lt;code&gt;&lt;a href=&quot;mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; , изменяются вашей umask, поэтому даже если вы &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; создать файл с разрешениями &lt;code&gt;0777&lt;/code&gt; , если ваша umask - &lt;code&gt;0022&lt;/code&gt; , тогда файл будет фактически создан с разрешениями &lt;code&gt;0755&lt;/code&gt; . Если ваша &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; была &lt;code&gt;0027&lt;/code&gt; (группа не может писать; другие не могут читать, писать или выполнять), тогда передача &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; &lt;code&gt;0666&lt;/code&gt; создаст файл с режимом &lt;code&gt;0640&lt;/code&gt; (потому что &lt;code&gt;0666 &amp;amp;~ 027&lt;/code&gt; - &lt;code&gt;0640&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d68f3b12b3008b73f340d97bbe8121b4ae3d9886" translate="yes" xml:space="preserve">
          <source>The Unix program that displays online documentation (manual pages) for you.</source>
          <target state="translated">Программа Unix,отображающая онлайн-документацию (страницы с инструкциями)для вас.</target>
        </trans-unit>
        <trans-unit id="025899dcfc40460b6af9f2e480800fa184584302" translate="yes" xml:space="preserve">
          <source>The VERSIONCHECK: Keyword</source>
          <target state="translated">ВЕРСИОНЧЕК:Ключевое слово</target>
        </trans-unit>
        <trans-unit id="191f8a3a602b994bc056ffe04831bd5feed30108" translate="yes" xml:space="preserve">
          <source>The VERSIONCHECK: keyword corresponds to &lt;b&gt;xsubpp&lt;/b&gt;'s &lt;code&gt;-versioncheck&lt;/code&gt; and &lt;code&gt;-noversioncheck&lt;/code&gt; options. This keyword overrides the command line options. Version checking is enabled by default. When version checking is enabled the XS module will attempt to verify that its version matches the version of the PM module.</source>
          <target state="translated">VersionCheck: ключевое слово соответствует в &lt;b&gt;xsubpp&lt;/b&gt; &amp;laquo;s &lt;code&gt;-versioncheck&lt;/code&gt; и &lt;code&gt;-noversioncheck&lt;/code&gt; варианты. Это ключевое слово переопределяет параметры командной строки. По умолчанию проверка версий включена. Когда проверка версии включена, модуль XS будет пытаться проверить, соответствует ли его версия версии модуля PM.</target>
        </trans-unit>
        <trans-unit id="04e7acc0343752ab985314abfd05d75387072015" translate="yes" xml:space="preserve">
          <source>The VMS operating system has two filesystems, designated by their on-disk structure (ODS) level: ODS-2 and its successor ODS-5. The initial port of Perl to VMS pre-dates ODS-5, but all current testing and development assumes ODS-5 and its capabilities, including case preservation, extended characters in filespecs, and names up to 8192 bytes long.</source>
          <target state="translated">Операционная система ЗИС имеет две файловые системы,обозначенные уровнем их структуры на диске (ODS):ОDS-2 и ее преемник ОDS-5.Первоначальный порт Perl в СУБД датируется ОDS-5,но все текущие испытания и разработки предполагают наличие ОDS-5 и ее возможности,включая сохранение регистров,расширенные символы в файловых спецификациях и имена длиной до 8192 байт.</target>
        </trans-unit>
        <trans-unit id="b30b00a3df196d84b7a24a918a3d0aa60756c262" translate="yes" xml:space="preserve">
          <source>The VOS mailing list.</source>
          <target state="translated">Список рассылки VOS.</target>
        </trans-unit>
        <trans-unit id="1e59303fe7c8cd36efc35383c5bbb06ef61bf43f" translate="yes" xml:space="preserve">
          <source>The Win95/NT installation, when using the ActiveState installer for Perl, will modify the Registry to associate the</source>
          <target state="translated">Установка Win95/NT,при использовании инсталлятора ActiveState для Perl,изменит реестр для связи с</target>
        </trans-unit>
        <trans-unit id="f858558f020a34e7480b07972a3c08c5fd6984b6" translate="yes" xml:space="preserve">
          <source>The Win95/NT installation, when using the ActiveState port of Perl, will modify the Registry to associate the &lt;code&gt;.pl&lt;/code&gt; extension with the perl interpreter. If you install another port, perhaps even building your own Win95/NT Perl from the standard sources by using a Windows port of gcc (e.g., with cygwin or mingw32), then you'll have to modify the Registry yourself. In addition to associating &lt;code&gt;.pl&lt;/code&gt; with the interpreter, NT people can use: &lt;code&gt;SET PATHEXT=%PATHEXT%;.PL&lt;/code&gt; to let them run the program &lt;code&gt;install-linux.pl&lt;/code&gt; merely by typing &lt;code&gt;install-linux&lt;/code&gt; .</source>
          <target state="translated">Установка Win95 / NT при использовании порта Perl ActiveState изменит реестр, чтобы связать расширение &lt;code&gt;.pl&lt;/code&gt; с интерпретатором perl. Если вы устанавливаете другой порт, возможно, даже собираете свой собственный Perl для Win95 / NT из стандартных источников, используя порт gcc для Windows (например, с cygwin или mingw32), вам придется самостоятельно изменить реестр. Помимо связывания &lt;code&gt;.pl&lt;/code&gt; с интерпретатором, NT-люди могут использовать: &lt;code&gt;SET PATHEXT=%PATHEXT%;.PL&lt;/code&gt; чтобы позволить им запускать программу &lt;code&gt;install-linux.pl&lt;/code&gt; , просто набрав &lt;code&gt;install-linux&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="beb45e4cde225026f4e16a740e28e45e50f2309b" translate="yes" xml:space="preserve">
          <source>The Windows SDK can be downloaded from &lt;a href=&quot;http://www.microsoft.com/&quot;&gt;http://www.microsoft.com/&lt;/a&gt;. The MinGW64 compiler is available at &lt;a href=&quot;http://sourceforge.net/projects/mingw-w64&quot;&gt;http://sourceforge.net/projects/mingw-w64&lt;/a&gt;. The latter is actually a cross-compiler targeting Win64. There's also a trimmed down compiler (no java, or gfortran) suitable for building perl available at: &lt;a href=&quot;http://strawberryperl.com/package/kmx/64_gcctoolchain/&quot;&gt;http://strawberryperl.com/package/kmx/64_gcctoolchain/&lt;/a&gt;</source>
          <target state="translated">Windows SDK можно загрузить с &lt;a href=&quot;http://www.microsoft.com/&quot;&gt;http://www.microsoft.com/&lt;/a&gt; . Компилятор MinGW64 доступен по адресу &lt;a href=&quot;http://sourceforge.net/projects/mingw-w64&quot;&gt;http://sourceforge.net/projects/mingw-w64&lt;/a&gt; . Последний на самом деле является кросс-компилятором, ориентированным на Win64. Также есть урезанный компилятор (без java или gfortran), подходящий для сборки Perl, доступный по адресу: &lt;a href=&quot;http://strawberryperl.com/package/kmx/64_gcctoolchain/&quot;&gt;http://strawberryperl.com/package/kmx/64_gcctoolchain/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c1dd1e762380b02f42ad88590f07ac599a582c23" translate="yes" xml:space="preserve">
          <source>The Windows documentation describes the shell parsing rules here: &lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true&quot;&gt;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true&lt;/a&gt; and the C runtime parsing rules here: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx&lt;/a&gt;.</source>
          <target state="translated">В документации Windows описаны правила синтаксического анализа оболочки здесь: &lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true&quot;&gt;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true&lt;/a&gt; и правила синтаксического анализа среды выполнения C здесь : &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0944600f567f37796a44d203cb305a8c3dc31877" translate="yes" xml:space="preserve">
          <source>The World Factbook maintained by the CIA is a potential source of the data. Unfortunately, it adds/preserves non-standard codes, so it is no longer used as a source of data.</source>
          <target state="translated">Потенциальным источником данных является &quot;Всемирный справочник фактов&quot;,который ведет ЦРУ.К сожалению,в нем добавляются/сохраняются нестандартные коды,поэтому он больше не используется в качестве источника данных.</target>
        </trans-unit>
        <trans-unit id="91e3c6e2754b93eaf46a2a00de960a8c0e2e11b1" translate="yes" xml:space="preserve">
          <source>The XL C for AIX is integrated in the XL C/C++ for AIX compiler and therefore also supported.</source>
          <target state="translated">XL C for AIX интегрирован в XL C/C++для компилятора AIX и поэтому также поддерживается.</target>
        </trans-unit>
        <trans-unit id="26b303e7615c750693be69ec473b2f4dff6fc26e" translate="yes" xml:space="preserve">
          <source>The XPUSH* macros will automatically extend the return stack to prevent it from being overrun. You push values onto the stack in the order you want them seen by the calling program.</source>
          <target state="translated">Макросы XPUSH*автоматически расширяют стек возврата,чтобы предотвратить его переполнение.Вы нажимаете значения на стек в том порядке,в котором хотите,чтобы они были видны вызывающей программе.</target>
        </trans-unit>
        <trans-unit id="a60c05b1221aad4f1b3aa2c5d4dc4eb83e2bb2ba" translate="yes" xml:space="preserve">
          <source>The XROVER command returns reference information for the article(s) specified.</source>
          <target state="translated">Команда XROVER возвращает справочную информацию для указанного изделия (изделий).</target>
        </trans-unit>
        <trans-unit id="11313e63e9f00be77c380f5038dabb62b6e1dd06" translate="yes" xml:space="preserve">
          <source>The XS code, with ellipsis, follows.</source>
          <target state="translated">Код XS,с эллипсисом,следующий.</target>
        </trans-unit>
        <trans-unit id="f7fa3ea30854edb41afcb9fc07a8de31e1d1857c" translate="yes" xml:space="preserve">
          <source>The XS compiler is called &lt;b&gt;xsubpp&lt;/b&gt;. This compiler creates the constructs necessary to let an XSUB manipulate Perl values, and creates the glue necessary to let Perl call the XSUB. The compiler uses &lt;b&gt;typemaps&lt;/b&gt; to determine how to map C function parameters and output values to Perl values and back. The default typemap (which comes with Perl) handles many common C types. A supplementary typemap may also be needed to handle any special structures and types for the library being linked. For more information on typemaps, see &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;.</source>
          <target state="translated">Компилятор XS называется &lt;b&gt;xsubpp&lt;/b&gt; . Этот компилятор создает конструкции, необходимые для того, чтобы позволить XSUB манипулировать значениями Perl, и создает связующее звено, необходимое для того, чтобы Perl мог вызывать XSUB. Компилятор использует &lt;b&gt;карты типов,&lt;/b&gt; чтобы определить, как отображать параметры функции C и выходные значения в значения Perl и обратно. Карта типов по умолчанию (которая поставляется с Perl) обрабатывает многие распространенные типы C. Дополнительная карта типов может также потребоваться для обработки любых специальных структур и типов для связываемой библиотеки. Для получения дополнительной информации о типовых картах см. &lt;a href=&quot;perlxstypemap&quot;&gt;Perlxstypemap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7b25a71b5ed14cc6ac2648af9eea46c98febfb6" translate="yes" xml:space="preserve">
          <source>The XS implementation uses code from metamail. Copyright 1991 Bell Communications Research, Inc. (Bellcore)</source>
          <target state="translated">Реализация XS использует код из metamail.Авторское право 1991 Bell Communications Research,Inc.(Bellcore)</target>
        </trans-unit>
        <trans-unit id="d9806f72759923810498b1550dc8fe607f007c38" translate="yes" xml:space="preserve">
          <source>The XS language allows one to describe the mapping between how the C routine is used, and how the corresponding Perl routine is used. It also allows creation of Perl routines which are directly translated to C code and which are not related to a pre-existing C function. In cases when the C interface coincides with the Perl interface, the XSUB declaration is almost identical to a declaration of a C function (in K&amp;amp;R style). In such circumstances, there is another tool called &lt;code&gt;h2xs&lt;/code&gt; that is able to translate an entire C header file into a corresponding XS file that will provide glue to the functions/macros described in the header file.</source>
          <target state="translated">Язык XS позволяет описать соответствие между тем, как используется подпрограмма C, и тем, как используется соответствующая подпрограмма Perl. Он также позволяет создавать подпрограммы Perl, которые непосредственно транслируются в код C и не связаны с ранее существовавшей функцией C. В случаях, когда интерфейс C совпадает с интерфейсом Perl, объявление XSUB практически идентично объявлению функции C (в стиле K&amp;amp;R). В таких обстоятельствах есть еще один инструмент, называемый &lt;code&gt;h2xs&lt;/code&gt; , который может переводить весь файл заголовка C в соответствующий файл XS, который обеспечивает связь с функциями / макросами, описанными в файле заголовка.</target>
        </trans-unit>
        <trans-unit id="5ec313ae92b11ca169ff5d7233881fd7bd18d45a" translate="yes" xml:space="preserve">
          <source>The XS module can use INCLUDE: to pull that file into it.</source>
          <target state="translated">Модуль XS может использовать INCLUDE:для втягивания в него этого файла.</target>
        </trans-unit>
        <trans-unit id="218e35287369aa01c3e7fcdd8962b5804ec13123" translate="yes" xml:space="preserve">
          <source>The XSUB follows.</source>
          <target state="translated">Далее следует XSUB.</target>
        </trans-unit>
        <trans-unit id="8e74c8817464edf988ad4bdeab912f47c5f34e75" translate="yes" xml:space="preserve">
          <source>The XSUB mechanism is a simple way for Perl programs to access C subroutines. An XSUB routine will have a stack that contains the arguments from the Perl program, and a way to map from the Perl data structures to a C equivalent.</source>
          <target state="translated">Механизм XSUB является простым способом доступа Perl программ к подпрограммам на языке C.Механизм XSUB будет иметь стек,содержащий аргументы из Perl-программы,и способ отображения из Perl-структур данных в C-эквивалент.</target>
        </trans-unit>
        <trans-unit id="5d59b445869847df575ae1068c63533e2dbc9b4f" translate="yes" xml:space="preserve">
          <source>The XSUB will look like the code which follows. A CODE: block is used to call the real rpcb_gettime() function with the parameters in the correct order for that function.</source>
          <target state="translated">XSUB будет выглядеть как следующий код.КОД:блок используется для вызова реальной функции rpcb_gettime()с параметрами в правильном для этой функции порядке.</target>
        </trans-unit>
        <trans-unit id="4912ec37b73cb1d3321d6d839b0519b8e1f0ad32" translate="yes" xml:space="preserve">
          <source>The XSUB's parameters are usually evaluated immediately after entering the XSUB. The INPUT: keyword can be used to force those parameters to be evaluated a little later. The INPUT: keyword can be used multiple times within an XSUB and can be used to list one or more input variables. This keyword is used with the PREINIT: keyword.</source>
          <target state="translated">Параметры XSUB обычно оцениваются сразу после ввода XSUB.Ключевое слово INPUT:может быть использовано для того,чтобы заставить эти параметры быть обработанными чуть позже.INPUT:ключевое слово может быть использовано несколько раз в XSUB и может быть использовано для перечисления одной или нескольких входных переменных.Это ключевое слово используется с ключевым словом PREINIT:.</target>
        </trans-unit>
        <trans-unit id="889ae69f0e646c6957d38054ac7106368e38cd84" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's equivalent of &lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;. The returned &lt;code&gt;PERL_CONTEXT&lt;/code&gt; structure can be interrogated to find all the information returned to Perl by &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt;. Note that XSUBs don't get a stack frame, so &lt;code&gt;caller_cx(0, NULL)&lt;/code&gt; will return information for the immediately-surrounding Perl code.</source>
          <target state="translated">Эквивалент &lt;a href=&quot;functions/caller&quot;&gt;вызывающего абонента в&lt;/a&gt; XSUB-Writer . Возвращенный &lt;code&gt;PERL_CONTEXT&lt;/code&gt; структура может быть допрошена , чтобы найти всю информацию , возвращаемую в Perl по &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что XSUB не получают фрейм стека, поэтому &lt;code&gt;caller_cx(0, NULL)&lt;/code&gt; будет возвращать информацию для непосредственно окружающего кода Perl.</target>
        </trans-unit>
        <trans-unit id="cf42b7fd9e4e74da90d9e8ca347b2091c98166db" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's equivalent to Perl's &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt;. Returns &lt;code&gt;G_VOID&lt;/code&gt; , &lt;code&gt;G_SCALAR&lt;/code&gt; or &lt;code&gt;G_ARRAY&lt;/code&gt; for void, scalar or list context, respectively. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; for a usage example.</source>
          <target state="translated">Эквивалент для XSub-писателя на Perl, &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt; . Возвращает &lt;code&gt;G_VOID&lt;/code&gt; , &lt;code&gt;G_SCALAR&lt;/code&gt; или &lt;code&gt;G_ARRAY&lt;/code&gt; для пустого, скалярного или списка контекстов соответственно. См. &lt;a href=&quot;perlcall&quot;&gt;Пример&lt;/a&gt; использования perlcall .</target>
        </trans-unit>
        <trans-unit id="75d69996de0f1c3559d54da444421bb8a65343e9" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;free&lt;/code&gt; function.</source>
          <target state="translated">Интерфейс XSUB-Writer к функции C &lt;code&gt;free&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="407a1fe0a1b35df310a191803c348a1466dc758e" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;malloc&lt;/code&gt; function, with cast. See also &lt;code&gt;Newx&lt;/code&gt; .</source>
          <target state="translated">Интерфейс разработчика XSUB для функции &lt;code&gt;malloc&lt;/code&gt; в языке C с приведением типов . См. Также &lt;code&gt;Newx&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03573c77e22afa37657d3ab695d4f1f77625b4b6" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;malloc&lt;/code&gt; function.</source>
          <target state="translated">Интерфейс разработчика XSUB для функции &lt;code&gt;malloc&lt;/code&gt; C.</target>
        </trans-unit>
        <trans-unit id="bb6fbdec07f505cf20563b49cda07ec35e3c5893" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;malloc&lt;/code&gt; function. The allocated memory is zeroed with &lt;code&gt;memzero&lt;/code&gt; . See also &lt;code&gt;Newx&lt;/code&gt; .</source>
          <target state="translated">Интерфейс разработчика XSUB для функции &lt;code&gt;malloc&lt;/code&gt; C. &lt;code&gt;memzero&lt;/code&gt; память обнуляется с помощью memzero . См. Также &lt;code&gt;Newx&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="012775e63d169c2ca0d945eee45190f976576a44" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;memcpy&lt;/code&gt; function. The &lt;code&gt;src&lt;/code&gt; is the source, &lt;code&gt;dest&lt;/code&gt; is the destination, &lt;code&gt;nitems&lt;/code&gt; is the number of items, and &lt;code&gt;type&lt;/code&gt; is the type. May fail on overlapping copies. See also &lt;code&gt;Move&lt;/code&gt; .</source>
          <target state="translated">Интерфейс XSUB-Writer для функции C &lt;code&gt;memcpy&lt;/code&gt; . &lt;code&gt;src&lt;/code&gt; является источником, &lt;code&gt;dest&lt;/code&gt; является местом, &lt;code&gt;nitems&lt;/code&gt; является количество элементов, а также &lt;code&gt;type&lt;/code&gt; является типом. Может выйти из строя при наложении копий. См. Также &lt;code&gt;Move&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45005a2398999be54551083e5df9a69f712a0c93" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;memmove&lt;/code&gt; function. The &lt;code&gt;src&lt;/code&gt; is the source, &lt;code&gt;dest&lt;/code&gt; is the destination, &lt;code&gt;nitems&lt;/code&gt; is the number of items, and &lt;code&gt;type&lt;/code&gt; is the type. Can do overlapping moves. See also &lt;code&gt;Copy&lt;/code&gt; .</source>
          <target state="translated">Интерфейс XSUB- &lt;code&gt;memmove&lt;/code&gt; функции memmove C. &lt;code&gt;src&lt;/code&gt; является источником, &lt;code&gt;dest&lt;/code&gt; является местом, &lt;code&gt;nitems&lt;/code&gt; является количество элементов, а также &lt;code&gt;type&lt;/code&gt; является типом. Может делать ходы внахлест. См. Также &lt;code&gt;Copy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a4b16e416d5be5fce93e4644cc50a90934125a5" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;memzero&lt;/code&gt; function. The &lt;code&gt;dest&lt;/code&gt; is the destination, &lt;code&gt;nitems&lt;/code&gt; is the number of items, and &lt;code&gt;type&lt;/code&gt; is the type.</source>
          <target state="translated">Интерфейс XSUB- &lt;code&gt;memzero&lt;/code&gt; функции C memzero . &lt;code&gt;dest&lt;/code&gt; является местом, &lt;code&gt;nitems&lt;/code&gt; является количество элементов, а также &lt;code&gt;type&lt;/code&gt; является типом.</target>
        </trans-unit>
        <trans-unit id="37176570a3748e41537c9ad870ca5c052d9042c5" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;realloc&lt;/code&gt; function, with cast.</source>
          <target state="translated">Интерфейс XSub-писателя в C &lt;code&gt;realloc&lt;/code&gt; функции, с литыми.</target>
        </trans-unit>
        <trans-unit id="c8ea9501eaec9d4dc35b91e9053fafc1e103de32" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;realloc&lt;/code&gt; function.</source>
          <target state="translated">Интерфейс XSub-писатель в C &lt;code&gt;realloc&lt;/code&gt; функции.</target>
        </trans-unit>
        <trans-unit id="b5f612b4df0e6a83ff9d89b145ebd6884b1f570e" translate="yes" xml:space="preserve">
          <source>The XSUBPP Program</source>
          <target state="translated">Программа XSUBPP</target>
        </trans-unit>
        <trans-unit id="1e85e39271c3e660414eb16aa8d858f60416c1a5" translate="yes" xml:space="preserve">
          <source>The XSUBs for the blue() and set_blue() methods are defined with the class name but the parameter for the object (THIS, or &quot;self&quot;) is implicit and is not listed.</source>
          <target state="translated">XSUB для методов blue()и set_blue()определяются с именем класса,но параметр для объекта (THIS,или &quot;self&quot;)является неявным и не указан в списке.</target>
        </trans-unit>
        <trans-unit id="f515a1ddc8e361ef2e2c6d0f98a0db815d43b99f" translate="yes" xml:space="preserve">
          <source>The YAML files themselves must have the &lt;code&gt;.yml&lt;/code&gt; extension; all other files are ignored (for two exceptions see</source>
          <target state="translated">Сами файлы YAML должны иметь расширение &lt;code&gt;.yml&lt;/code&gt; ; все остальные файлы игнорируются (два исключения см.</target>
        </trans-unit>
        <trans-unit id="d674c081d1720c0407789140462f1119f634eb87" translate="yes" xml:space="preserve">
          <source>The Zxxx, Zyyy, and Zzzz codes are not used.</source>
          <target state="translated">Коды Zxxx,Zyyy и Zzzz не используются.</target>
        </trans-unit>
        <trans-unit id="eb61dbdf150df0568557c97e9633ab5164b764f0" translate="yes" xml:space="preserve">
          <source>The __DATA__ token</source>
          <target state="translated">Символ __DATA__</target>
        </trans-unit>
        <trans-unit id="463e37f3f7783165c25668e9edcd6bb8f407a3e5" translate="yes" xml:space="preserve">
          <source>The _splain_ Program</source>
          <target state="translated">Программа _splain_</target>
        </trans-unit>
        <trans-unit id="14c9176f141fa52e2e9b370433e3e5dfafe8e555" translate="yes" xml:space="preserve">
          <source>The ability of an independent subexpression to prevent backtracking can be quite useful. Suppose we want to match a non-empty string enclosed in parentheses up to two levels deep. Then the following regexp matches:</source>
          <target state="translated">Способность независимого подвыражения для предотвращения обратного слежения может быть весьма полезна.Предположим,мы хотим сопоставить непустую строку,заключенную в круглые скобки,с глубиной до двух уровней.Тогда следующие регенерации совпадут:</target>
        </trans-unit>
        <trans-unit id="d9ff4522b539fedb72c69d4e7d1a591065047a06" translate="yes" xml:space="preserve">
          <source>The ability to create &quot;canned&quot; filters. These allow commonly used filters to be packaged into a stand-alone module.</source>
          <target state="translated">Возможность создания &quot;консервированных&quot; фильтров.Это позволяет упаковывать часто используемые фильтры в автономный модуль.</target>
        </trans-unit>
        <trans-unit id="76b03d5ecb823d555d353e5848c41c73876ec792" translate="yes" xml:space="preserve">
          <source>The ability to easily apply multiple filters to a single DBM file.</source>
          <target state="translated">Возможность легко применять несколько фильтров к одному файлу DBM.</target>
        </trans-unit>
        <trans-unit id="2a644c13f043d9a916e16c6cb02fd3b3d632a99e" translate="yes" xml:space="preserve">
          <source>The ability to put additional declarations before the typemap entries are processed is very handy in the cases when typemap conversions manipulate some global state:</source>
          <target state="translated">Возможность ставить дополнительные объявления перед обработкой записей типовой карты очень удобна в тех случаях,когда преобразования типовой карты манипулируют каким-либо глобальным состоянием:</target>
        </trans-unit>
        <trans-unit id="bca0d0a62c6e09e5d5a84f9c8ee968851fbd9ea7" translate="yes" xml:space="preserve">
          <source>The ability to specify a different outermost delimiter bracket is useful in some circumstances. For example, in the Parse::RecDescent module, parser actions which are to be performed only on a successful parse are specified using a &lt;code&gt;&amp;lt;defer:...&amp;gt;&lt;/code&gt; directive. For example:</source>
          <target state="translated">Возможность указать другую крайнюю скобку-ограничитель полезна в некоторых случаях. Например, в модуле Parse :: RecDescent действия парсера, которые должны выполняться только при успешном синтаксическом анализе, указываются с помощью директивы &lt;code&gt;&amp;lt;defer:...&amp;gt;&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="7bc890528d2492bad24f35a51d7d007c56cdbd51" translate="yes" xml:space="preserve">
          <source>The above attempts to show how the layer scheme works in a simple case. The application's &lt;code&gt;PerlIO *&lt;/code&gt; points to an entry in the table(s) representing open (allocated) handles. For example the first three slots in the table correspond to &lt;code&gt;stdin&lt;/code&gt; ,&lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; . The table in turn points to the current &quot;top&quot; layer for the handle - in this case an instance of the generic buffering layer &quot;perlio&quot;. That layer in turn points to the next layer down - in this case the low-level &quot;unix&quot; layer.</source>
          <target state="translated">Вышеупомянутая попытка показать, как схема слоев работает в простом случае. К заявке &lt;code&gt;PerlIO *&lt;/code&gt; указует на запись в таблице (ы) , представляющий открытой (выделенная) ручку. Например, первые три слота в таблице соответствуют &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; и &lt;code&gt;stderr&lt;/code&gt; . Таблица, в свою очередь, указывает на текущий &amp;laquo;верхний&amp;raquo; слой для дескриптора - в данном случае на экземпляр общего уровня буферизации &amp;laquo;perlio&amp;raquo;. Этот уровень, в свою очередь, указывает на следующий уровень ниже - в данном случае на низкоуровневый уровень &amp;laquo;unix&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="abf94dbab29db68325894cd60a65f3c2a1fc56fa" translate="yes" xml:space="preserve">
          <source>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</source>
          <target state="translated">Вышеупомянутое уведомление об авторском праве и настоящее уведомление о разрешении должны быть включены во все копии или существенные части Программного обеспечения.</target>
        </trans-unit>
        <trans-unit id="267b118ff06011e806ac608fae00f2938fa2a609" translate="yes" xml:space="preserve">
          <source>The above example works only if &lt;code&gt;&quot;s&quot;&lt;/code&gt; is &lt;code&gt;NUL&lt;/code&gt; -terminated; otherwise you have to pass its length to &lt;code&gt;newSVpv&lt;/code&gt; .</source>
          <target state="translated">Приведенный выше пример работает только тогда , когда &lt;code&gt;&quot;s&quot;&lt;/code&gt; является &lt;code&gt;NUL&lt;/code&gt; -завершённым; в противном случае вы должны передать его длину в &lt;code&gt;newSVpv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a24a47b6e29ea30653b134f5da5c978447aa0575" translate="yes" xml:space="preserve">
          <source>The above example would print out the message:</source>
          <target state="translated">В приведенном выше примере сообщение будет распечатано:</target>
        </trans-unit>
        <trans-unit id="f4ebb52f7b218814c788462297b6da7a43f52650" translate="yes" xml:space="preserve">
          <source>The above four are optional except in other formatting codes, notably &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; , and when preceded by a capital letter.</source>
          <target state="translated">Вышеупомянутые четыре являются необязательными, за исключением других кодов форматирования, особенно &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; , и когда им предшествует заглавная буква.</target>
        </trans-unit>
        <trans-unit id="dd54f214af2e16fd555100563837da248db5495d" translate="yes" xml:space="preserve">
          <source>The above is a somewhat simplified view of what really happens. Since Perl allows more flexible calling conventions than C, XSUBs may do much more in practice, such as checking input parameters for validity, throwing exceptions (or returning undef/empty list) if the return value from the C function indicates failure, calling different C functions based on numbers and types of the arguments, providing an object-oriented interface, etc.</source>
          <target state="translated">Вышеуказанное представляет собой несколько упрощенный взгляд на то,что происходит на самом деле.Так как Perl допускает более гибкие соглашения по вызову,чем C,XSUB могут делать гораздо больше на практике,например,проверять входные параметры на достоверность,бросать исключения (или возвращать undef/empty list),если возвращаемое значение из функции C указывает на неудачу,вызывать различные функции C на основе чисел и типов аргументов,предоставлять объектно-ориентированный интерфейс и т.д.</target>
        </trans-unit>
        <trans-unit id="754ca936a964e1d5816b54783f4e5f1ce663020d" translate="yes" xml:space="preserve">
          <source>The above is roughly equivalent to a &quot;stdio&quot; buffered stream, but with much more flexibility:</source>
          <target state="translated">Вышеуказанное примерно эквивалентно &quot;студийному&quot; буферизованному потоку,но с гораздо большей гибкостью:</target>
        </trans-unit>
        <trans-unit id="7fcad7cfc523d43a196084786f96b8329cc3ac60" translate="yes" xml:space="preserve">
          <source>The above module is very primitive. It does not implement mutator methods (&lt;code&gt;++&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; and so on), does not do deep copying (not required without mutators!), and implements only those arithmetic operations which are used in the example.</source>
          <target state="translated">Вышеупомянутый модуль очень примитивен. Он не реализует методы мутаторов ( &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; и т. Д.), Не выполняет глубокого копирования (без мутаторов не требуется!) И реализует только те арифметические операции, которые используются в примере.</target>
        </trans-unit>
        <trans-unit id="281ac3a4234dba5767807b1f7ef90bcb868fb84e" translate="yes" xml:space="preserve">
          <source>The above recipes describe the ordering of matches</source>
          <target state="translated">Вышеприведенные рецепты описывают порядок заказа спичек</target>
        </trans-unit>
        <trans-unit id="abb826d1f92a77f8ee5fb15c131983e89da595f3" translate="yes" xml:space="preserve">
          <source>The above search for &quot;interpreter&quot; is recursive: if</source>
          <target state="translated">Указанный выше поиск &quot;переводчика&quot; является рекурсивным:если</target>
        </trans-unit>
        <trans-unit id="b606cf43c801f260cbdfb890db240a19d58a3f8e" translate="yes" xml:space="preserve">
          <source>The above subroutine may be called with either one or two arguments. The default value expression is evaluated when the subroutine is called, so it may provide different default values for different calls. It is only evaluated if the argument was actually omitted from the call. For example,</source>
          <target state="translated">Вышеуказанная подпрограмма может быть вызвана с одним или двумя аргументами.Выражение со значением по умолчанию вычисляется при вызове подпрограммы,поэтому оно может предоставлять разные значения по умолчанию для разных вызовов.Оно вычисляется только в том случае,если аргумент был фактически опущен из вызова.Например,</target>
        </trans-unit>
        <trans-unit id="54c21b6df45da0f9df4499ebff5512482a22c709" translate="yes" xml:space="preserve">
          <source>The above test passes two values to &lt;code&gt;ok(arg1, arg2)&lt;/code&gt; -- the first a coderef, and the second is the number 4. Before &lt;code&gt;ok&lt;/code&gt; compares them, it calls the coderef, and uses its return value as the real value of this parameter. Assuming that &lt;code&gt;$bytecount&lt;/code&gt; returns 4, &lt;code&gt;ok&lt;/code&gt; ends up testing &lt;code&gt;4 eq 4&lt;/code&gt; . Since that's true, this test passes.</source>
          <target state="translated">Вышеупомянутый тест передает два значения в &lt;code&gt;ok(arg1, arg2)&lt;/code&gt; - первое - это кодовая ссылка, а второе - число 4. Прежде чем &lt;code&gt;ok&lt;/code&gt; сравнивает их, он вызывает кодовую ссылку и использует ее возвращаемое значение в качестве реального значения этого параметра. . Если предположить , что &lt;code&gt;$bytecount&lt;/code&gt; возвращает 4, &lt;code&gt;ok&lt;/code&gt; заканчивает тестирование &lt;code&gt;4 eq 4&lt;/code&gt; . Поскольку это правда, этот тест проходит.</target>
        </trans-unit>
        <trans-unit id="b1ef6a2bf455cf77affd01d5de26884f122aeca1" translate="yes" xml:space="preserve">
          <source>The above variables have all been localized and may be changed without affecting data outside of the wanted function.</source>
          <target state="translated">Все перечисленные выше переменные были локализованы и могут быть изменены,не затрагивая данные,находящиеся за пределами требуемой функции.</target>
        </trans-unit>
        <trans-unit id="ae51a1ce20f245092ecaad634de2dfa1ff5d3441" translate="yes" xml:space="preserve">
          <source>The above won't happen every time competing process update the same &lt;b&gt;DB_File&lt;/b&gt; database, but it does illustrate why the technique should not be used.</source>
          <target state="translated">Вышеупомянутое не будет происходить каждый раз, когда конкурирующий процесс обновляет одну и &lt;b&gt;ту&lt;/b&gt; же &lt;b&gt;базу&lt;/b&gt; данных &lt;b&gt;DB_File&lt;/b&gt; , но он показывает, почему этот метод не следует использовать.</target>
        </trans-unit>
        <trans-unit id="3f1ad066d4a66bd948f60c33d21673c18f0eb993" translate="yes" xml:space="preserve">
          <source>The accessor method provided by &lt;code&gt;struct&lt;/code&gt; for an element depends on the declared type of the element.</source>
          <target state="translated">Метод доступа, предоставляемый &lt;code&gt;struct&lt;/code&gt; для элемента, зависит от объявленного типа элемента.</target>
        </trans-unit>
        <trans-unit id="2cc7abc6dcf89e4b9609885153970267df830f15" translate="yes" xml:space="preserve">
          <source>The accessor methods assume that the actual storage for the data in the tied hash is in the hash referenced by &lt;code&gt;(&lt;a href=&quot;../functions/tied&quot;&gt;tied&lt;/a&gt;(%tiedhash))-&amp;gt;[0]&lt;/code&gt; . Thus overwritten &lt;code&gt;TIEHASH&lt;/code&gt; method should return an array reference with the first element being a hash reference, and the remaining methods should operate on the hash &lt;code&gt;%{ $_[0]-&amp;gt;[0] }&lt;/code&gt; :</source>
          <target state="translated">Методы доступа предполагают, что фактическое хранилище данных в связанном хэше находится в хэше, на который ссылается &lt;code&gt;(&lt;a href=&quot;../functions/tied&quot;&gt;tied&lt;/a&gt;(%tiedhash))-&amp;gt;[0]&lt;/code&gt; . Таким образом, перезаписанный метод &lt;code&gt;TIEHASH&lt;/code&gt; должен возвращать ссылку на массив, где первый элемент является ссылкой на хэш, а остальные методы должны работать с хешем &lt;code&gt;%{ $_[0]-&amp;gt;[0] }&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="225d5409f9e31ec1fd3549dba0dd919b3904ec0c" translate="yes" xml:space="preserve">
          <source>The accessor methods assume that the actual storage for the data in the tied hash is in the hash referenced by &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt;. Thus overwritten &lt;code&gt;TIEHASH&lt;/code&gt; method should return a hash reference, and the remaining methods should operate on the hash referenced by the first argument:</source>
          <target state="translated">Методы доступа предполагают, что фактическое хранилище данных в связанном хэше находится в хэше, на который ссылается &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt; . Таким образом, перезаписанный метод &lt;code&gt;TIEHASH&lt;/code&gt; должен возвращать ссылку на хэш, а остальные методы должны работать с хешем, на который ссылается первый аргумент:</target>
        </trans-unit>
        <trans-unit id="2198a837e059e4191004ad59c18436a206b5087a" translate="yes" xml:space="preserve">
          <source>The accessor's argument, if any, is assigned to the element.</source>
          <target state="translated">Аргумент аксессуара,если таковой имеется,присваивается элементу.</target>
        </trans-unit>
        <trans-unit id="0a55122025df9d01179435aa1526880dbd188b0d" translate="yes" xml:space="preserve">
          <source>The accessor's argument, if any, is assigned to the element. The accessor will &lt;code&gt;croak&lt;/code&gt; if this is not an appropriate object reference.</source>
          <target state="translated">Аргумент средства доступа, если он есть, присваивается элементу. Аксессор будет &lt;code&gt;croak&lt;/code&gt; если это не подходящая ссылка на объект.</target>
        </trans-unit>
        <trans-unit id="bc291805bbdf71f35da9613fd10fc72effdd81d3" translate="yes" xml:space="preserve">
          <source>The act of calling up a deity, daemon, program, method, subroutine, or function to get it to do what you think it&amp;rsquo;s supposed to do. We usually &amp;ldquo;call&amp;rdquo; subroutines but &amp;ldquo;invoke&amp;rdquo; methods, since it sounds cooler.</source>
          <target state="translated">Акт вызова божества, демона, программы, метода, подпрограммы или функции, чтобы заставить их делать то, что, по вашему мнению, они должны делать. Обычно мы &amp;laquo;вызываем&amp;raquo; подпрограммы, но &amp;laquo;вызываем&amp;raquo; методы, потому что это звучит круче.</target>
        </trans-unit>
        <trans-unit id="0aae7e6b56823ac18d0d863614b52f8ccee20556" translate="yes" xml:space="preserve">
          <source>The act of emptying a &lt;b&gt;buffer&lt;/b&gt;, often before it&amp;rsquo;s full.</source>
          <target state="translated">Акт опустошения &lt;b&gt;буфера&lt;/b&gt; , часто до его заполнения.</target>
        </trans-unit>
        <trans-unit id="da4cbb2e16fc1345262c617dbbfacc0e9a82482b" translate="yes" xml:space="preserve">
          <source>The action begins in</source>
          <target state="translated">Действие начинается с</target>
        </trans-unit>
        <trans-unit id="c50575ea6cd15b6f99786b019f7fd7d151291681" translate="yes" xml:space="preserve">
          <source>The actual &lt;code&gt;SvUTF8&lt;/code&gt; flag of the &lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt; scalar is significant, but not the whole story regarding the input character encoding. Normally, when a file is being read, the scalar contains octets and its &lt;code&gt;SvUTF8&lt;/code&gt; flag is off, but the octets should be interpreted as UTF-8 if the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma is in effect. During a string eval, however, the scalar may have the &lt;code&gt;SvUTF8&lt;/code&gt; flag on, and in this case its octets should be interpreted as UTF-8 unless the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma is in effect. This logic may change in the future; use this function instead of implementing the logic yourself.</source>
          <target state="translated">Фактический &lt;code&gt;SvUTF8&lt;/code&gt; флаг из &lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt; скалярной значителен, но не вся история о кодировании входного символа. Обычно при чтении файла скаляр содержит октеты, а его флаг &lt;code&gt;SvUTF8&lt;/code&gt; выключен, но октеты следует интерпретировать как UTF-8, если действует прагма &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; . Однако во время выполнения строки eval на &lt;code&gt;SvUTF8&lt;/code&gt; может быть установлен флаг SvUTF8 , и в этом случае его октеты должны интерпретироваться как UTF-8, если не действует прагма &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; . Эта логика может измениться в будущем; используйте эту функцию вместо того, чтобы самостоятельно реализовывать логику.</target>
        </trans-unit>
        <trans-unit id="7dd5fba3f25088e2897b2cb955245840fd943e5f" translate="yes" xml:space="preserve">
          <source>The actual difference between PPCODE: and CODE: sections is in the initialization of &lt;code&gt;SP&lt;/code&gt; macro (which stands for the</source>
          <target state="translated">Фактическая разница между разделами PPCODE: и CODE: заключается в инициализации макроса &lt;code&gt;SP&lt;/code&gt; (который означает</target>
        </trans-unit>
        <trans-unit id="c8adbcba0e7f4d6240d43127016adb7bebb0e850" translate="yes" xml:space="preserve">
          <source>The actual functions called are known as PP code, and they're spread between four files:</source>
          <target state="translated">Настоящие вызываемые функции известны как PP код,и они распределены между четырьмя файлами:</target>
        </trans-unit>
        <trans-unit id="9fed5c7ec6f1ab01c643aa93a8adb0f82c40adfa" translate="yes" xml:space="preserve">
          <source>The actual numbers are stored as unsigned big integers (with separate sign).</source>
          <target state="translated">Реальные числа хранятся в виде неподписанных больших целых чисел (с отдельным знаком).</target>
        </trans-unit>
        <trans-unit id="7371146aaafc3d93e00f035ea0ab638040fbcf08" translate="yes" xml:space="preserve">
          <source>The actual permissions set depend on the value of the &lt;code&gt;CYGWIN&lt;/code&gt; in the SYSTEM environment settings. (Cygwin)</source>
          <target state="translated">Фактический набор разрешений зависит от значения &lt;code&gt;CYGWIN&lt;/code&gt; в настройках среды SYSTEM. (Cygwin)</target>
        </trans-unit>
        <trans-unit id="6f09daaa018160f529d356d689ea131810985b7e" translate="yes" xml:space="preserve">
          <source>The actual sizes (in bytes) of native shorts, ints, longs, and long longs on the platform where Perl was built are also available from the command line:</source>
          <target state="translated">Реальные размеры (в байтах)нативных шортов,ints,longs и long long long на платформе,где был собран Perl,также доступны из командной строки:</target>
        </trans-unit>
        <trans-unit id="b9688cf79c9a25cc4e9f2e8b4c5ac878b783210d" translate="yes" xml:space="preserve">
          <source>The actual values on the argument stack are pointers to the values passed in. When an argument is listed as being an OUTPUT value, its corresponding value on the stack (i.e., ST(0) if it was the first argument) is changed. You can verify this by looking at the C code generated for Example 3. The code for the round() XSUB routine contains lines that look like this:</source>
          <target state="translated">Действительные значения в стеке аргументов являются указателями на передаваемые значения.Когда аргумент указан как OUTPUT-значение,его соответствующее значение на стеке (т.е.ST(0),если это был первый аргумент)изменяется.Вы можете проверить это,посмотрев на код на языке C,сгенерированный для Примера 3.Код рутины round()XSUB содержит строки,которые выглядят следующим образом:</target>
        </trans-unit>
        <trans-unit id="9efd0030f2fab9c72c68391b18e8706f0e577dc3" translate="yes" xml:space="preserve">
          <source>The add_bits() method is an alternative to add() that allow partial bytes to be appended to the message. Most users should just ignore this method as partial bytes is very unlikely to be of any practical use.</source>
          <target state="translated">Метод add_bits()является альтернативой функции add(),которая позволяет добавлять к сообщению частичные байты.Большинство пользователей должны просто игнорировать этот метод,так как частичные байты вряд ли будут иметь какое-либо практическое применение.</target>
        </trans-unit>
        <trans-unit id="4385ce0c6decd2654eecaf2223aa22c33620d447" translate="yes" xml:space="preserve">
          <source>The addfile() method will croak() if it fails reading data for some reason. If it croaks it is unpredictable what the state of the $ctx object will be in. The addfile() method might have been able to read the file partially before it failed. It is probably wise to discard or reset the $ctx object if this occurs.</source>
          <target state="translated">Метод addfile()будет croak(),если по какой-то причине не удастся прочитать данные.Если он перекроется,то непредсказуемо,в каком состоянии будет находиться объект $ctx.Метод addfile(),возможно,смог бы частично прочитать файл до того,как произошел сбой.Вероятно,в этом случае было бы разумно отбросить или сбросить объект $ctx.</target>
        </trans-unit>
        <trans-unit id="29515a29b800fb1b3a5d264f9d3d2a8c7827591b" translate="yes" xml:space="preserve">
          <source>The addfile() method will croak() if it fails reading data for some reason. If it croaks it is unpredictable what the state of the $md5 object will be in. The addfile() method might have been able to read the file partially before it failed. It is probably wise to discard or reset the $md5 object if this occurs.</source>
          <target state="translated">Метод addfile()будет croak(),если по какой-то причине не удастся прочитать данные.Если он перекроется,то непредсказуемо,в каком состоянии будет находиться объект $md5.Метод addfile(),возможно,смог бы частично прочитать файл до того,как произошел сбой.Вероятно,в этом случае было бы разумно отбросить или сбросить объект $md5.</target>
        </trans-unit>
        <trans-unit id="bad770ef214b3ea483bf0a738f9ad60704fafe4f" translate="yes" xml:space="preserve">
          <source>The addition of threads has changed Perl's internals substantially. There are implications for people who write modules with XS code or external libraries. However, since Perl data is not shared among threads by default, Perl modules stand a high chance of being thread-safe or can be made thread-safe easily. Modules that are not tagged as thread-safe should be tested or code reviewed before being used in production code.</source>
          <target state="translated">Добавление нитей существенно изменило внутреннюю часть Perl.Это имеет последствия для людей,которые пишут модули с кодом XS или внешними библиотеками.Тем не менее,поскольку данные Perl по умолчанию не разделяются между потоками,модули Perl имеют высокие шансы быть потокобезопасными или могут быть сделаны потокобезопасными легко.Модули,которые не помечены как потоково-безопасные должны быть протестированы или код рассматривается перед использованием в производственном коде.</target>
        </trans-unit>
        <trans-unit id="9fb5062c416df742306ccabb4b5f706bc8df9b28" translate="yes" xml:space="preserve">
          <source>The additional state of being</source>
          <target state="translated">Дополнительное состояние бытия</target>
        </trans-unit>
        <trans-unit id="e003249c8de3365551eedf50a46a7442176acc5e" translate="yes" xml:space="preserve">
          <source>The address family (e.g. &lt;code&gt;AF_INET&lt;/code&gt; )</source>
          <target state="translated">Семейство адресов (например, &lt;code&gt;AF_INET&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f126536906b38b811e2283014aef5b17fb2a2bb1" translate="yes" xml:space="preserve">
          <source>The address in a packed string (such as would be returned by pack_sockaddr_in())</source>
          <target state="translated">Адрес в упакованной строке (например,возвращается функцией pack_sockaddr_in())</target>
        </trans-unit>
        <trans-unit id="9ca884174256cffd8e2121d14b1b2f9600471f92" translate="yes" xml:space="preserve">
          <source>The address of the OP's SV, if it has an SV, in hexadecimal.</source>
          <target state="translated">Адрес ЗП,если у него есть ЗП,в шестнадцатеричной системе.</target>
        </trans-unit>
        <trans-unit id="452ef6486bc83e321d333ed85c0a567a4e8c1783" translate="yes" xml:space="preserve">
          <source>The address of the OP's first child, in hexadecimal.</source>
          <target state="translated">Адрес первого ребенка ОП,в шестнадцатеричном.</target>
        </trans-unit>
        <trans-unit id="2838690d17f05c70e3e67bc06eecc94e3f275b6e" translate="yes" xml:space="preserve">
          <source>The address of the OP's last child, in hexadecimal.</source>
          <target state="translated">Адрес последнего ребенка ОП,в шестнадцатеричном.</target>
        </trans-unit>
        <trans-unit id="e332f1e7f698853a5727152a76eca59b2c2b494a" translate="yes" xml:space="preserve">
          <source>The address of the OP's next OP, in hexadecimal.</source>
          <target state="translated">Адрес следующей ОП,в шестнадцатеричной системе.</target>
        </trans-unit>
        <trans-unit id="1290cc2c32604c72580d6a56eb9a2ca86ec89ccf" translate="yes" xml:space="preserve">
          <source>The address of the OP's next youngest sibling, in hexadecimal.</source>
          <target state="translated">Адрес следующего младшего брата ОП,в шестнадцатиричном.</target>
        </trans-unit>
        <trans-unit id="b68836e0a8059af6d65948c4349c2eade8a16af3" translate="yes" xml:space="preserve">
          <source>The address of the OP, in hexadecimal.</source>
          <target state="translated">Адрес ОП,в шестнадцатеричной системе.</target>
        </trans-unit>
        <trans-unit id="09ebb8cc7d0fd73db86fd8a64bea18fe0c098b0c" translate="yes" xml:space="preserve">
          <source>The address tables of DLLs are patched only once, when they are loaded. The addresses of the entry points into DLLs are guaranteed to be the same for all the programs which use the same DLL. This removes the runtime fixup - once DLL is loaded, its code is read-only.</source>
          <target state="translated">Адресные таблицы DLL исправляются только один раз,когда они загружены.Адреса точек входа в DLL гарантированно одинаковы для всех программ,использующих одну и ту же DLL.Это устраняет исправление во время выполнения-после загрузки DLL ее код доступен только для чтения.</target>
        </trans-unit>
        <trans-unit id="c74bfa2ec2baf330be7b8d46296fdd61de05ff99" translate="yes" xml:space="preserve">
          <source>The advantage of this approach comparing to ALIAS: keyword is that there is no need to code a switch statement, each Perl function (which shares the same XSUB) knows which C function it should call. Additionally, one can attach an extra function remainder() at runtime by using</source>
          <target state="translated">Преимущество такого подхода по сравнению с ALIAS:ключевое слово состоит в том,что нет необходимости кодировать оператор switch,каждая функция Perl (которая разделяет тот же XSUB)знает,какую функцию C она должна вызывать.Кроме того,можно прикрепить дополнительную функцию remainder()во время выполнения с помощью функции</target>
        </trans-unit>
        <trans-unit id="1ba0a293372a8086f2c3cb8bd66f4ad49631031c" translate="yes" xml:space="preserve">
          <source>The advantage of this technique is that you have complete control over the implementation of your filter. The big disadvantage is the increased complexity required to write the filter - not only do you need to understand the source filter hooks, but you also need a reasonable knowledge of Perl guts. One of the few times it is worth going to this trouble is when writing a source scrambler. The &lt;code&gt;decrypt&lt;/code&gt; filter (which unscrambles the source before Perl parses it) included with the source filter distribution is an example of a C source filter (see Decryption Filters, below).</source>
          <target state="translated">Преимущество этого метода в том, что вы полностью контролируете реализацию вашего фильтра. Большим недостатком является повышенная сложность, требуемая для написания фильтра - вам нужно не только разбираться в хуках исходных фильтров, но также необходимо иметь разумные знания в области Perl. Один из немногих случаев, когда стоит пойти на эту проблему, - это при написании скремблера исходного кода. &lt;code&gt;decrypt&lt;/code&gt; фильтр (который расшифровывает источник , прежде чем Perl , анализирует его) , включенный с распределением исходного фильтра является примером источника С фильтром (см дешифрований фильтров, ниже).</target>
        </trans-unit>
        <trans-unit id="072e0efbeb225d357c21442cc8c46a3dcf93b381" translate="yes" xml:space="preserve">
          <source>The advantage of using the above macros is that you don't have to setup an extra function for &lt;code&gt;call_*&lt;/code&gt; , and that using these macros is faster than using &lt;code&gt;call_*&lt;/code&gt; .</source>
          <target state="translated">Преимущество использования вышеуказанных макросов заключается в том, что вам не нужно настраивать дополнительную функцию для &lt;code&gt;call_*&lt;/code&gt; , и что использование этих макросов быстрее, чем использование &lt;code&gt;call_*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53174719bc4a34362607e16e39670825ed959235" translate="yes" xml:space="preserve">
          <source>The agent on whose behalf a &lt;b&gt;method&lt;/b&gt; is invoked. In a &lt;b&gt;class&lt;/b&gt; method, the invocant is a package name. In an &lt;b&gt;instance&lt;/b&gt; method, the invocant is an object reference.</source>
          <target state="translated">Агент, от имени которого вызывается &lt;b&gt;метод&lt;/b&gt; . В методе &lt;b&gt;класса&lt;/b&gt; вызывающим является имя пакета. В методе &lt;b&gt;экземпляра&lt;/b&gt; вызывающий является ссылкой на объект.</target>
        </trans-unit>
        <trans-unit id="3e3cbe3ecc5eb1d553a5d35837bcb40ffd7eda37" translate="yes" xml:space="preserve">
          <source>The aim of the implementation is to provide the PerlIO API in a flexible and platform neutral manner. It is also a trial of an &quot;Object Oriented C, with vtables&quot; approach which may be applied to Perl 6.</source>
          <target state="translated">Цель реализации-обеспечить гибкий и платформонейтральный API PerlIO.Это также пробный вариант подхода &quot;Объектно-ориентированный C,с таблицами&quot;,который может быть применен к Perl 6.</target>
        </trans-unit>
        <trans-unit id="eca34d276a1e0da5bdcd3481f3be5f1fa01ec807" translate="yes" xml:space="preserve">
          <source>The aim of this stage is to take the Perl source, and turn it into an op tree. We'll see what one of those looks like later. Strictly speaking, there's three things going on here.</source>
          <target state="translated">Цель этого этапа-взять источник Perl и превратить его в дерево операций.Посмотрим,как будет выглядеть один из них позже.Строго говоря,здесь происходит три вещи.</target>
        </trans-unit>
        <trans-unit id="1c84b06bf15cbe5bd96e34833737cbd3f8f36b72" translate="yes" xml:space="preserve">
          <source>The alarm() test failure is caused by system() apparently blocking alarm(). That is probably a libc bug, and given that SunOS 4.x has been end-of-lifed years ago, don't hold your breath for a fix. In addition to that, don't try anything too Unicode-y, especially with Encode, and you should be fine in SunOS 4.x.</source>
          <target state="translated">Неисправность теста функции alarm()вызвана тем,что система(),по-видимому,заблокировала функцию alarm().Вероятно,это ошибка libc,и,учитывая,что SunOS 4.x была выведена из строя много лет назад,не задерживайте дыхание на исправление.В дополнение к этому,не пытайтесь сделать что-нибудь слишком Unicode-y,особенно с Encode,и вы должны быть в порядке в SunOS 4.x.</target>
        </trans-unit>
        <trans-unit id="ac23951d81146a4c25773847fcd1353c10dfdb5b" translate="yes" xml:space="preserve">
          <source>The alias_code function is deprecated and will be removed in the December 2014 release.</source>
          <target state="translated">Функция alias_code устарела и будет удалена в релизах декабря 2014 года.</target>
        </trans-unit>
        <trans-unit id="f5829e682c777d3809510d4e74d665806fe75e9a" translate="yes" xml:space="preserve">
          <source>The alias_code function is preserved for backwards compatibility, but the following two are identical:</source>
          <target state="translated">Функция alias_code сохраняется для обратной совместимости,но следующие две идентичны:</target>
        </trans-unit>
        <trans-unit id="70cc56ad5f5fa00e1dcd91a0319ec7c86448a5ca" translate="yes" xml:space="preserve">
          <source>The alloc command allows you to give the ftp server a hint about the size of the file about to be transferred using the ALLO ftp command. Some storage systems use this to make intelligent decisions about how to store the file. The &lt;code&gt;SIZE&lt;/code&gt; argument represents the size of the file in bytes. The &lt;code&gt;RECORD_SIZE&lt;/code&gt; argument indicates a maximum record or page size for files sent with a record or page structure.</source>
          <target state="translated">Команда alloc позволяет вам сообщить ftp-серверу о размере файла, который должен быть передан, с помощью команды ALLO ftp. Некоторые системы хранения используют это, чтобы принимать разумные решения о том, как хранить файл. &lt;code&gt;SIZE&lt;/code&gt; аргумент представляет размер файла в байтах. &lt;code&gt;RECORD_SIZE&lt;/code&gt; аргумент указывает максимальную запись или размер страницы для файлов , отправленных с записью страницы или структуры.</target>
        </trans-unit>
        <trans-unit id="b33892c53e0bb40f7871a5fed62579159a0f62e4" translate="yes" xml:space="preserve">
          <source>The alternative &lt;code&gt;STORABLE_attach&lt;/code&gt; method provides a solution for these shared objects. Instead of &lt;code&gt;STORABLE_freeze&lt;/code&gt; --&amp;gt; &lt;code&gt;STORABLE_thaw&lt;/code&gt; , you implement &lt;code&gt;STORABLE_freeze&lt;/code&gt; --&amp;gt; &lt;code&gt;STORABLE_attach&lt;/code&gt; instead.</source>
          <target state="translated">Альтернативный метод &lt;code&gt;STORABLE_attach&lt;/code&gt; предоставляет решение для этих общих объектов. Вместо &lt;code&gt;STORABLE_freeze&lt;/code&gt; -&amp;gt; &lt;code&gt;STORABLE_thaw&lt;/code&gt; вы реализуете &lt;code&gt;STORABLE_freeze&lt;/code&gt; -&amp;gt; &lt;code&gt;STORABLE_attach&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="402e3151897f6beaece02f0ebb7344497fe45587" translate="yes" xml:space="preserve">
          <source>The alternative is to put the stubs in before the &lt;code&gt;__DATA__&lt;/code&gt; token BEFORE releasing the module, and for this purpose the &lt;code&gt;Devel::SelfStubber&lt;/code&gt; module is available. However this does require the extra step of ensuring that the stubs are in the module. If this is done I strongly recommend that this is done BEFORE releasing the module - it should NOT be done at install time in general.</source>
          <target state="translated">Альтернативой является установка заглушек перед токеном &lt;code&gt;__DATA__&lt;/code&gt; ПЕРЕД выпуском модуля, и для этой цели &lt;code&gt;Devel::SelfStubber&lt;/code&gt; модуль Devel :: SelfStubber . Однако это требует дополнительного шага по обеспечению наличия заглушек в модуле. Если это будет сделано, я настоятельно рекомендую сделать это ПЕРЕД выпуском модуля - в целом это НЕ следует делать во время установки.</target>
        </trans-unit>
        <trans-unit id="6f8e08a6bd15bdf7cb57a249a2eb325f0bdb259e" translate="yes" xml:space="preserve">
          <source>The amount of sbrk(2)ed memory needed to keep buckets aligned.</source>
          <target state="translated">Объем памяти sbrk(2)ed,необходимый для выравнивания ведер.</target>
        </trans-unit>
        <trans-unit id="24d94fd90247d993fe24e78a68e00db6f524e13c" translate="yes" xml:space="preserve">
          <source>The anger you feel when the computer is being lazy. This makes you write programs that don&amp;rsquo;t just react to your needs, but actually anticipate them. Or at least that pretend to. Hence, the second great virtue of a programmer. See also &lt;b&gt;laziness&lt;/b&gt; and &lt;b&gt;hubris&lt;/b&gt;.</source>
          <target state="translated">Гнев, который вы чувствуете, когда компьютер ленивается. Это заставляет вас писать программы, которые не просто реагируют на ваши потребности, но фактически предвосхищают их. Или хотя бы притворяться. Отсюда второе большое достоинство программиста. Смотрите также &lt;b&gt;лень&lt;/b&gt; и &lt;b&gt;высокомерие&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2d396c6c924a9cda1b9caf0839be7530a8ba7f62" translate="yes" xml:space="preserve">
          <source>The anonymous subroutine returned by add_function_generator() isn't technically a closure because it refers to no lexicals outside its own scope. Using a closure gives you a</source>
          <target state="translated">Анонимная подпрограмма,возвращаемая функцией add_function_generator(),технически не является завершающей,так как не имеет отношения к лексике,выходящей за рамки ее границ.Использование функции закрытия дает вам</target>
        </trans-unit>
        <trans-unit id="7c26228772d7852b95995c9f2def9a6401f105ab" translate="yes" xml:space="preserve">
          <source>The answer is &lt;b&gt;recursion&lt;/b&gt;, and maybe &lt;b&gt;threads&lt;/b&gt;. Both these can create several execution pointers going into the same subroutine. For the subroutine-child not write over the temporaries for the subroutine-parent (lifespan of which covers the call to the child), the parent and the child should have different scratchpads. (</source>
          <target state="translated">Ответ - &lt;b&gt;рекурсия&lt;/b&gt; и, возможно, &lt;b&gt;потоки&lt;/b&gt; . Оба они могут создать несколько указателей выполнения, входящих в одну и ту же подпрограмму. Для того, чтобы дочерняя подпрограмма не перезаписывала временные файлы для родительской подпрограммы (срок жизни которой покрывает вызов дочерней подпрограммы), родительская и дочерняя подпрограммы должны иметь разные блокноты. (</target>
        </trans-unit>
        <trans-unit id="352a5795d3c7f4b3f3c9dafd2990d2244d787ba4" translate="yes" xml:space="preserve">
          <source>The answer is that our regexp works well until we get past the last real match. Then the regexp will fail to match a synchronized &lt;code&gt;TGA&lt;/code&gt; and start stepping ahead one character position at a time, not what we want. The solution is to use &lt;code&gt;\G&lt;/code&gt; to anchor the match to the codon alignment:</source>
          <target state="translated">Ответ заключается в том, что наше регулярное выражение работает хорошо, пока мы не пройдем последнее реальное совпадение. Тогда регулярное выражение не сможет соответствовать синхронизированному &lt;code&gt;TGA&lt;/code&gt; и начнет продвигаться вперед на одну позицию символа за раз, а не то, что мы хотим. Решение состоит в том, чтобы использовать &lt;code&gt;\G&lt;/code&gt; для привязки совпадения к выравниванию кодонов:</target>
        </trans-unit>
        <trans-unit id="08cdc226d03f36a2e4fc74ff822641ef90ed1cc6" translate="yes" xml:space="preserve">
          <source>The answer lies in the optimizations the regex engine makes. In the first case, all the engine sees are plain old characters (aside from the &lt;code&gt;?{}&lt;/code&gt; construct). It's smart enough to realize that the string 'ddd' doesn't occur in our target string before actually running the pattern through. But in the second case, we've tricked it into thinking that our pattern is more complicated. It takes a look, sees our character class, and decides that it will have to actually run the pattern to determine whether or not it matches, and in the process of running it hits the print statement before it discovers that we don't have a match.</source>
          <target state="translated">Ответ кроется в оптимизации, которую делает механизм регулярных выражений. В первом случае все, что видит движок, - это простые старые символы (кроме конструкции &lt;code&gt;?{}&lt;/code&gt; ). Достаточно умен, чтобы понять, что строка 'ddd' не встречается в нашей целевой строке, до фактического выполнения шаблона. Но во втором случае мы обманом заставили его думать, что наш шаблон более сложный. Он смотрит, видит наш класс символов и решает, что ему нужно будет фактически запустить шаблон, чтобы определить, соответствует ли он, и в процессе выполнения он обращается к оператору печати, прежде чем обнаружит, что у нас нет соответствие.</target>
        </trans-unit>
        <trans-unit id="a5831b08e8cef23b3074e1a04c2a596b4fb392c8" translate="yes" xml:space="preserve">
          <source>The answer to requirement 2) is that a regexp (mostly) uses Unicode characters. The &quot;mostly&quot; is for messy backward compatibility reasons, but starting in Perl 5.14, any regex compiled in the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (which is automatically turned on within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher) will turn that &quot;mostly&quot; into &quot;always&quot;. If you want to handle Unicode properly, you should ensure that &lt;code&gt;'unicode_strings'&lt;/code&gt; is turned on. Internally, this is encoded to bytes using either UTF-8 or a native 8 bit encoding, depending on the history of the string, but conceptually it is a sequence of characters, not bytes. See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for a tutorial about that.</source>
          <target state="translated">Ответ на требование 2) заключается в том, что регулярное выражение (в основном) использует символы Unicode. &amp;laquo;В основном&amp;raquo; используется из соображений беспорядочной обратной совместимости, но начиная с Perl 5.14 любое регулярное выражение, скомпилированное в рамках функции &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (которая автоматически включается в рамках &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; или выше), превратит это &quot; в основном &amp;laquo;в&amp;laquo; всегда &amp;raquo;. Если вы хотите правильно обрабатывать Unicode, вы должны убедиться, что &lt;code&gt;'unicode_strings'&lt;/code&gt; включен. Внутренне это кодируется в байты с использованием либо UTF-8, либо собственной 8-битной кодировки, в зависимости от истории строки, но концептуально это последовательность символов, а не байтов. См. &lt;a href=&quot;perlunitut&quot;&gt;Руководство&lt;/a&gt; по этому поводу в perlunitut .</target>
        </trans-unit>
        <trans-unit id="ab2461c5e3f0cff2ecb68a3151a2d92b8a70b40b" translate="yes" xml:space="preserve">
          <source>The answers may be off by few percentages because of the irregular (slightly aspherical) form of the Earth. The errors are at worst about 0.55%, but generally below 0.3%.</source>
          <target state="translated">Ответы могут быть выключены на несколько процентов из-за нерегулярной (слегка асферической)формы Земли.Ошибки в худшем случае около 0.55%,но в целом ниже 0.3%.</target>
        </trans-unit>
        <trans-unit id="d59be2ed12ab2165af09c3bf2c28e33ef82222db" translate="yes" xml:space="preserve">
          <source>The appended output looks like:</source>
          <target state="translated">Добавленный выход выглядит так:</target>
        </trans-unit>
        <trans-unit id="0bd30cce9c74d0ed491dced5ecc139a5a1ba48e4" translate="yes" xml:space="preserve">
          <source>The appropriate string for the capability will be returned.</source>
          <target state="translated">Будет возвращена соответствующая строка для возможности.</target>
        </trans-unit>
        <trans-unit id="3156ec770160eccf0b831e893b19fba7da139602" translate="yes" xml:space="preserve">
          <source>The arcus (also known as the inverse) functions of the sine, cosine, and tangent</source>
          <target state="translated">Арка (также известная как обратная)выполняет функции синуса,косинуса и тангенса.</target>
        </trans-unit>
        <trans-unit id="ef155b03ef2bd4353f5f3ae9ce3143e92ce08f0b" translate="yes" xml:space="preserve">
          <source>The arcus cofunctions of the sine, cosine, and tangent (acosec/acsc and acotan/acot are aliases). Note that atan2(0, 0) is not well-defined.</source>
          <target state="translated">Аркусные кофункции синуса,косинуса и тангенса (acosec/acsc и acotan/acot-это псевдонимы).Обратите внимание,что atan2(0,0)нечетко определен.</target>
        </trans-unit>
        <trans-unit id="d90394bf6d1003afd92e57075638d8ec96a8f149" translate="yes" xml:space="preserve">
          <source>The area (also known as the inverse) functions of the hyperbolic sine, cosine, and tangent</source>
          <target state="translated">Область (также известная как обратная)функции гиперболического синуса,косинуса и тангенса</target>
        </trans-unit>
        <trans-unit id="96b07ebcfe3eb3364fc6d5a9b44430b864f7f185" translate="yes" xml:space="preserve">
          <source>The area cofunctions of the hyperbolic sine, cosine, and tangent (acsch/acosech and acoth/acotanh are aliases)</source>
          <target state="translated">Областные кофункции гиперболического синуса,косинуса и тангенса (acsch/acosech и acoth/acotanh-псевдонимы)</target>
        </trans-unit>
        <trans-unit id="5ccdfb64dc7931913963c31e04d78b0a9af3ae93" translate="yes" xml:space="preserve">
          <source>The area in which a particular invocation of a particular file or subroutine keeps some of its temporary values, including any lexically scoped variables.</source>
          <target state="translated">Область,в которой конкретное обращение к определенному файлу или подпрограмме сохраняет некоторые из своих временных значений,включая любые лексически обработанные переменные.</target>
        </trans-unit>
        <trans-unit id="d10c9af72d3c8216f90487b0cb07489720300b93" translate="yes" xml:space="preserve">
          <source>The arg variable is initially set by taking the value from ST(0), then is stored back into ST(0) at the end of the routine.</source>
          <target state="translated">Переменная arg сначала устанавливается путем взятия значения из ST(0),а затем в конце рутины сохраняется обратно в ST(0).</target>
        </trans-unit>
        <trans-unit id="4d814bb4a725af841ef1489f2dfafba121655945" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;level&lt;/code&gt; should be either 0 or -1. If &lt;code&gt;level==0&lt;/code&gt; , as a side-effect creates a glob with the given &lt;code&gt;name&lt;/code&gt; in the given &lt;code&gt;stash&lt;/code&gt; which in the case of success contains an alias for the subroutine, and sets up caching info for this glob.</source>
          <target state="translated">Аргумент &lt;code&gt;level&lt;/code&gt; должен быть либо 0 или -1. Если &lt;code&gt;level==0&lt;/code&gt; , в качестве побочного эффекта создается глобус с заданным &lt;code&gt;name&lt;/code&gt; в заданном &lt;code&gt;stash&lt;/code&gt; который в случае успеха содержит псевдоним для подпрограммы, и устанавливает информацию кеширования для этого глобуса.</target>
        </trans-unit>
        <trans-unit id="46a90c11604ca06c6858b07026656614cf325b22" translate="yes" xml:space="preserve">
          <source>The argument after &lt;code&gt;'autotie'&lt;/code&gt; is a reference to a hash in which each key is the name of an attribute to be created, and each value is the class to which variables ascribed that attribute should be tied.</source>
          <target state="translated">Аргумент после &lt;code&gt;'autotie'&lt;/code&gt; - это ссылка на хэш, в котором каждый ключ - это имя создаваемого атрибута, а каждое значение - это класс, к которому переменные, приписанные этому атрибуту, должны быть связаны.</target>
        </trans-unit>
        <trans-unit id="de7c9584c8050b2d0fdb24caf50ee070b0a90073" translate="yes" xml:space="preserve">
          <source>The argument specification can be</source>
          <target state="translated">Спецификация аргумента может быть</target>
        </trans-unit>
        <trans-unit id="e56eb85000cd23825e22500ebb61377895023bf6" translate="yes" xml:space="preserve">
          <source>The argument specification is optional. If omitted, the option is considered boolean, a value of 1 will be assigned when the option is used on the command line.</source>
          <target state="translated">Спецификация аргументов является необязательной.Если опция опущена,она считается булевой,при использовании в командной строке будет присвоено значение 1.</target>
        </trans-unit>
        <trans-unit id="f70b3fa6aabdcb387bd854a30ff21340870477da" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;LIST_CACHE&lt;/code&gt; or &lt;code&gt;SCALAR_CACHE&lt;/code&gt; must either be one of the following four strings:</source>
          <target state="translated">Аргумент &lt;code&gt;LIST_CACHE&lt;/code&gt; или &lt;code&gt;SCALAR_CACHE&lt;/code&gt; должен быть одной из следующих четырех строк:</target>
        </trans-unit>
        <trans-unit id="c5464d59534d6182be5453dd048427e6d0c50353" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;$heading1&lt;/code&gt; , &lt;code&gt;$heading2&lt;/code&gt; , etc. are the heading titles of the corresponding sections, subsections, etc. to try and match. If &lt;code&gt;$headingN&lt;/code&gt; is omitted then it defaults to the current corresponding section heading title in the input.</source>
          <target state="translated">Аргументы &lt;code&gt;$heading1&lt;/code&gt; , &lt;code&gt;$heading2&lt;/code&gt; и т. Д. Представляют собой заголовки соответствующих разделов, подразделов и т. Д. , Которые необходимо сопоставить. Если &lt;code&gt;$headingN&lt;/code&gt; не указан, то по умолчанию используется текущий заголовок соответствующего раздела во входных данных.</target>
        </trans-unit>
        <trans-unit id="0c2d811d7e533f13a02dc5ccb0c9cf2822f648ef" translate="yes" xml:space="preserve">
          <source>The arguments after the</source>
          <target state="translated">Аргументы после</target>
        </trans-unit>
        <trans-unit id="c3ee6db939d4bf6fb2dbd132ec653ceddc879c3d" translate="yes" xml:space="preserve">
          <source>The arguments and expected behaviour of these methods are described in &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt;.</source>
          <target state="translated">Аргументы и ожидаемое поведение этих методов описаны в &lt;a href=&quot;../digest&quot;&gt;Дайджесте&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5c76d2b203709556f900b75ce0e52a9ac994219" translate="yes" xml:space="preserve">
          <source>The arguments are available via @ARGV, not $1, $2, etc.</source>
          <target state="translated">Аргументы доступны через @ARGV,а не через $1,$2 и т.д.</target>
        </trans-unit>
        <trans-unit id="6cb92f325e1877b21a75fa1acba0a791fd4726a3" translate="yes" xml:space="preserve">
          <source>The arguments of &lt;code&gt;sv_setpvf&lt;/code&gt; are processed like &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, and the formatted output becomes the value.</source>
          <target state="translated">Аргументы &lt;code&gt;sv_setpvf&lt;/code&gt; обрабатываются как &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; , и форматированный вывод становится значением.</target>
        </trans-unit>
        <trans-unit id="839631a833c7558b199549ece29ff396d5371aa7" translate="yes" xml:space="preserve">
          <source>The arguments passed to the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement which invokes &lt;b&gt;sigtrap&lt;/b&gt; are processed in order. When a signal name or the name of one of &lt;b&gt;sigtrap&lt;/b&gt;'s signal lists is encountered a handler is immediately installed, when an option is encountered it affects subsequently installed handlers.</source>
          <target state="translated">Аргументы, переданные оператору &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , который вызывает &lt;b&gt;sigtrap&lt;/b&gt; , обрабатываются по порядку. Когда встречается имя сигнала или имя одного из &lt;b&gt;списков&lt;/b&gt; сигналов &lt;b&gt;sigtrap,&lt;/b&gt; немедленно устанавливается обработчик, а при обнаружении опции он влияет на установленные впоследствии обработчики.</target>
        </trans-unit>
        <trans-unit id="a181ad8a8d3a3252da75be7994d668c484c4410f" translate="yes" xml:space="preserve">
          <source>The arguments should be a hashref with</source>
          <target state="translated">Споры должны быть хэшрэфом с</target>
        </trans-unit>
        <trans-unit id="01c93f64cbaa573f1e972a244178e4f2a83875d0" translate="yes" xml:space="preserve">
          <source>The arguments themselves are any values following the &lt;code&gt;flags&lt;/code&gt; argument.</source>
          <target state="translated">Сами аргументы - это любые значения, следующие за аргументом &lt;code&gt;flags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="380902efca5b9b3a75f7c59abab4db85bec7e897" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;given&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; are in scalar context, and &lt;code&gt;given&lt;/code&gt; assigns the &lt;code&gt;$_&lt;/code&gt; variable its topic value.</source>
          <target state="translated">Аргументы для &lt;code&gt;given&lt;/code&gt; и &lt;code&gt;when&lt;/code&gt; находятся в скалярном контексте, а &lt;code&gt;given&lt;/code&gt; присваивает переменной &lt;code&gt;$_&lt;/code&gt; значение темы.</target>
        </trans-unit>
        <trans-unit id="bee53666a69514e40c684814c2f3de57ce34649e" translate="yes" xml:space="preserve">
          <source>The arguments to layers are by default returned in parentheses after the name of the layer, and certain layers (like &lt;code&gt;utf8&lt;/code&gt; ) are not real layers but instead flags on real layers; to get all of these returned separately, use the optional &lt;code&gt;details&lt;/code&gt; argument:</source>
          <target state="translated">Аргументы для слоев по умолчанию возвращаются в круглых скобках после имени слоя, а некоторые слои (например, &lt;code&gt;utf8&lt;/code&gt; ) не являются реальными слоями, а вместо этого являются флагами на реальных слоях; чтобы получить все это по отдельности, используйте необязательный аргумент &lt;code&gt;details&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6e693a7b71ba349ddefc634c4aa1cd90dc56ea7f" translate="yes" xml:space="preserve">
          <source>The arithmetics with pure imaginary numbers works just like you would expect it with real numbers... you just have to remember that</source>
          <target state="translated">Арифметика с чистыми воображаемыми числами работает так же,как и с реальными числами...вы просто должны помнить,что</target>
        </trans-unit>
        <trans-unit id="27b0340458e5b6bada543e551d3178c4f1de6919" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;@ARGV&lt;/code&gt; contains the command-line arguments intended for the script. &lt;code&gt;$#ARGV&lt;/code&gt; is generally the number of arguments minus one, because &lt;code&gt;$ARGV[0]&lt;/code&gt; is the first argument,</source>
          <target state="translated">Массив &lt;code&gt;@ARGV&lt;/code&gt; содержит аргументы командной строки, предназначенные для сценария. &lt;code&gt;$#ARGV&lt;/code&gt; - это обычно количество аргументов минус один, потому что &lt;code&gt;$ARGV[0]&lt;/code&gt; является первым аргументом,</target>
        </trans-unit>
        <trans-unit id="5e6fff9bfd20cc94284be277039aa46feebe2516" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;@F&lt;/code&gt; contains the fields of each line read in when autosplit mode is turned on. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the &lt;b&gt;-a&lt;/b&gt; switch. This array is package-specific, and must be declared or given a full package name if not in package main when running under &lt;code&gt;strict 'vars'&lt;/code&gt; .</source>
          <target state="translated">Массив &lt;code&gt;@F&lt;/code&gt; содержит поля каждой строки, считываемые при включенном режиме автодробления. Смотрите &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; для ключа &lt;b&gt;-a&lt;/b&gt; . Этот массив зависит от пакета и должен быть объявлен или ему должно быть дано полное имя пакета, если он не находится в главном пакете при работе со &lt;code&gt;strict 'vars'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8441a1e4197d6b374d0c52606833f2a1d2d3753" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;@INC&lt;/code&gt; contains the list of places that the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; EXPR&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; constructs look for their library files. It initially consists of the arguments to any &lt;b&gt;-I&lt;/b&gt; command-line switches, followed by the default Perl library, probably</source>
          <target state="translated">Массив &lt;code&gt;@INC&lt;/code&gt; содержит список мест, в которых конструкции &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; EXPR&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ищут файлы своих библиотек. Первоначально он состоит из аргументов для любых ключей командной строки &lt;b&gt;-I&lt;/b&gt; , за которыми следует библиотека Perl по умолчанию, возможно</target>
        </trans-unit>
        <trans-unit id="a14a26b2dd6454634cc1107915a7a3aee19dc784" translate="yes" xml:space="preserve">
          <source>The array indices start with 0. A negative subscript retrieves its value from the end. In our example, &lt;code&gt;$myarray[-1]&lt;/code&gt; would have been 5000, and &lt;code&gt;$myarray[-2]&lt;/code&gt; would have been 500.</source>
          <target state="translated">Индексы массива начинаются с 0. Отрицательный индекс извлекает свое значение с конца. В нашем примере &lt;code&gt;$myarray[-1]&lt;/code&gt; было бы 5000, а &lt;code&gt;$myarray[-2]&lt;/code&gt; было бы 500.</target>
        </trans-unit>
        <trans-unit id="5870f5124d5a86e2473fbde56d4d16aa6bdafbce" translate="yes" xml:space="preserve">
          <source>The array returned by the &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; operator is divided up according to the same rules the CRTL &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; routine. Therefore, the &quot;system time&quot; elements will always be 0, since there is no difference between &quot;user time&quot; and &quot;system&quot; time under VMS, and the time accumulated by a subprocess may or may not appear separately in the &quot;child time&quot; field, depending on whether &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; keeps track of subprocesses separately. Note especially that the VAXCRTL (at least) keeps track only of subprocesses spawned using &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;; it will not accumulate the times of subprocesses spawned via pipes, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;, or backticks.</source>
          <target state="translated">Массив, возвращаемый оператором &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; , разделяется по тем же правилам, что и процедура CRTL &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; . Следовательно, элементы &amp;laquo;системного времени&amp;raquo; всегда будут равны 0, поскольку нет разницы между &amp;laquo;временем пользователя&amp;raquo; и &amp;laquo;системным&amp;raquo; временем в VMS, а время, накопленное подпроцессом, может появляться или не отображаться отдельно в &amp;laquo;дочернем времени&amp;raquo; поле, в зависимости от того, отслеживает ли &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; подпроцессы отдельно. Обратите особое внимание на то, что VAXCRTL (по крайней мере) отслеживает только подпроцессы, порожденные с помощью &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; ; он не будет накапливать время подпроцессов, созданных с помощью каналов, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; или обратных кавычек.</target>
        </trans-unit>
        <trans-unit id="3e203923e4bb3b1b85d85c3be6cf6dca987c9241" translate="yes" xml:space="preserve">
          <source>The arrays &lt;code&gt;@EXPORT&lt;/code&gt; and &lt;code&gt;@EXPORT_OK&lt;/code&gt; in a module hold lists of symbols that are going to be exported into the users name space by default, or which they can request to be exported, respectively. The symbols can represent functions, scalars, arrays, hashes, or typeglobs. The symbols must be given by full name with the exception that the ampersand in front of a function is optional, e.g.</source>
          <target state="translated">Массивы &lt;code&gt;@EXPORT&lt;/code&gt; и &lt;code&gt;@EXPORT_OK&lt;/code&gt; в модуле содержат списки символов, которые будут экспортированы в пространство имен пользователей по умолчанию или которые они могут запросить для экспорта, соответственно. Символы могут представлять функции, скаляры, массивы, хэши или типы глобусов. Символы должны быть даны по полному имени, за исключением того, что амперсанд перед функцией является необязательным, например</target>
        </trans-unit>
        <trans-unit id="6be6541bf2f3c9c38b314f884349aae8de53fdfb" translate="yes" xml:space="preserve">
          <source>The arrays completely specify the mappings for all possible code points. The final element in an inversion map returned by this function will always be for the range that consists of all the code points that aren't legal Unicode, but that are expressible on the platform. (That is, it starts with code point 0x110000, the first code point above the legal Unicode maximum, and extends to infinity.) The value for that range will be the same that any typical unassigned code point has for the specified property. (Certain unassigned code points are not &quot;typical&quot;; for example the non-character code points, or those in blocks that are to be written right-to-left. The above-Unicode range's value is not based on these atypical code points.) It could be argued that, instead of treating these as unassigned Unicode code points, the value for this range should be &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. If you wish, you can change the returned arrays accordingly.</source>
          <target state="translated">Массивы полностью определяют сопоставления для всех возможных кодовых точек. Последний элемент в карте инверсии, возвращаемой этой функцией, всегда будет для диапазона, который состоит из всех кодовых точек, которые не являются допустимыми Unicode, но которые могут быть выражены на платформе. (То есть он начинается с кодовой точки 0x110000, первой кодовой точки выше допустимого максимума Unicode, и продолжается до бесконечности.) Значение для этого диапазона будет таким же, как любая типичная неназначенная кодовая точка для указанного свойства. (Некоторые неназначенные кодовые точки не являются &amp;laquo;типичными&amp;raquo;; например, несимвольные кодовые точки или те, которые должны быть записаны справа налево в блоках. Вышеуказанное значение диапазона Unicode не основано на этих нетипичных кодовых точках. Можно утверждать, что вместо того, чтобы рассматривать их как неназначенные кодовые точки Unicode,значение для этого диапазона должно быть &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . При желании вы можете соответствующим образом изменить возвращаемые массивы.</target>
        </trans-unit>
        <trans-unit id="215f34a814c5d96aebb0e5a01677224428736e62" translate="yes" xml:space="preserve">
          <source>The arrays.h/arrays.c code in the &lt;a href=&quot;http://search.cpan.org/perldoc/PGPLOT&quot;&gt;PGPLOT&lt;/a&gt; module on CPAN does just this. If you're doing a lot of float or double processing, consider using the &lt;a href=&quot;http://search.cpan.org/perldoc/PDL&quot;&gt;PDL&lt;/a&gt; module from CPAN instead--it makes number-crunching easy.</source>
          <target state="translated">Именно это и делает код array.h / array.c в модуле &lt;a href=&quot;http://search.cpan.org/perldoc/PGPLOT&quot;&gt;PGPLOT&lt;/a&gt; на CPAN. Если вы выполняете много операций с плавающей запятой или двойной обработкой, подумайте об использовании вместо этого модуля &lt;a href=&quot;http://search.cpan.org/perldoc/PDL&quot;&gt;PDL&lt;/a&gt; из CPAN - это упрощает обработку чисел.</target>
        </trans-unit>
        <trans-unit id="7c674ebc98c67a6b78e8bff2084920a9483e6761" translate="yes" xml:space="preserve">
          <source>The arrow points to the sequence number of the next op; they're not displayed in -exec mode, for obvious reasons.</source>
          <target state="translated">Стрелка указывает на порядковый номер следующей операции;по понятным причинам они не отображаются в режиме -exec.</target>
        </trans-unit>
        <trans-unit id="d3369ef5421624f50c9461a4385bdfc6e73878c8" translate="yes" xml:space="preserve">
          <source>The art of defining something (at least partly) in terms of itself, which is a naughty no-no in dictionaries but often works out okay in computer programs if you&amp;rsquo;re careful not to recurse forever (which is like an infinite loop with more spectacular failure modes).</source>
          <target state="translated">Искусство определять что-то (по крайней мере частично) в терминах самого себя, что является непослушным в словарях, но часто работает нормально в компьютерных программах, если вы осторожны, чтобы не повторять навсегда (что похоже на бесконечный цикл с большим количеством впечатляющие режимы отказа).</target>
        </trans-unit>
        <trans-unit id="44c6ad6b4370d28f2449d941c6198878c199473e" translate="yes" xml:space="preserve">
          <source>The article &quot;Constants in Perl&quot;, in</source>
          <target state="translated">Статья &quot;Constants in Perl&quot;,in</target>
        </trans-unit>
        <trans-unit id="f1506bf3257cec0583c1b75ddabb2245f7506472" translate="yes" xml:space="preserve">
          <source>The assignment to &lt;code&gt;$^R&lt;/code&gt; above is properly localized, so the old value of &lt;code&gt;$^R&lt;/code&gt; is restored if the assertion is backtracked; compare &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;.</source>
          <target state="translated">Присваивание &lt;code&gt;$^R&lt;/code&gt; выше правильно локализовано, поэтому старое значение &lt;code&gt;$^R&lt;/code&gt; восстанавливается, если утверждение выполняется с возвратом; сравните &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="afaa9c220de769e54d663ab2c9c6d4f430c692cd" translate="yes" xml:space="preserve">
          <source>The assignment variants of these operators (&lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt; ) behave likewise under the feature.</source>
          <target state="translated">Варианты присваивания этих операторов ( &lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt; ) Ведут себя аналогично под этой функцией.</target>
        </trans-unit>
        <trans-unit id="71ba6eda663c17eb85a62c08062fb7adfc8e5822" translate="yes" xml:space="preserve">
          <source>The association between the filter object and the source stream is made with the &lt;code&gt;filter_add()&lt;/code&gt; function. This takes a filter object as a parameter (&lt;code&gt;$ref&lt;/code&gt; in this case) and installs it in the source stream.</source>
          <target state="translated">Связь между объектом фильтра и исходным потоком осуществляется с помощью функции &lt;code&gt;filter_add()&lt;/code&gt; . Он принимает объект фильтра в качестве параметра ( в данном случае &lt;code&gt;$ref&lt;/code&gt; ) и устанавливает его в исходный поток.</target>
        </trans-unit>
        <trans-unit id="12a98cd04a6eb830d540ea5356e8449610414ff4" translate="yes" xml:space="preserve">
          <source>The atmark() functionality is also exportable as sockatmark() function:</source>
          <target state="translated">Функция atmark()также экспортируется как функция sockatmark():</target>
        </trans-unit>
        <trans-unit id="30252fd845cfc7120c5fe1c8c4bfc41149abe5bb" translate="yes" xml:space="preserve">
          <source>The atmark() implementation: Copyright 2001, Lincoln Stein &amp;lt;lstein@cshl.org&amp;gt;. This module is distributed under the same terms as Perl itself. Feel free to use, modify and redistribute it as long as you retain the correct attribution.</source>
          <target state="translated">Реализация atmark (): Copyright 2001, Lincoln Stein &amp;lt;lstein@cshl.org&amp;gt;. Этот модуль распространяется на тех же условиях, что и сам Perl. Не стесняйтесь использовать, изменять и распространять его, если сохраняете правильную атрибуцию.</target>
        </trans-unit>
        <trans-unit id="82c21f7a3ae183ec4d3047341406ff01ae50460f" translate="yes" xml:space="preserve">
          <source>The attribute list is passed as a list of constant strings to the code which associates them with the subroutine. In particular, the second example of valid syntax above currently looks like this in terms of how it's parsed and invoked:</source>
          <target state="translated">Список атрибутов передается в виде списка константных строк в код,который связывает их с подпрограммой.В частности,второй приведенный выше пример корректного синтаксиса на данный момент выглядит именно так с точки зрения того,как он разбирается и вызывается:</target>
        </trans-unit>
        <trans-unit id="b657a6989977956f6b98ac68863da82534e8cebe" translate="yes" xml:space="preserve">
          <source>The attributes must be valid as simple identifier names (without any punctuation other than the '_' character). They may have a parameter list appended, which is only checked for whether its parentheses ('(',')') nest properly.</source>
          <target state="translated">Атрибуты должны быть действительны как простые имена идентификаторов (без знаков препинания,отличных от символа '_').К ним может прилагаться список параметров,который проверяется только на правильность вложения скобок ('(',')').</target>
        </trans-unit>
        <trans-unit id="6773066d674b1f4d653955ef73a085c07f393513" translate="yes" xml:space="preserve">
          <source>The author is particularly grateful to</source>
          <target state="translated">Автор выражает особую благодарность</target>
        </trans-unit>
        <trans-unit id="a93ac8e5cbb3f89224036c2390524cda7879089a" translate="yes" xml:space="preserve">
          <source>The author that PAUSE allows to assign &lt;b&gt;co-maintainer&lt;/b&gt; permissions to a &lt;b&gt;namespace&lt;/b&gt;. A primary maintainer can give up this distinction by assigning it to another PAUSE author. See Camel chapter 19, &amp;ldquo;CPAN&amp;rdquo;.</source>
          <target state="translated">Автор, который PAUSE позволяет назначать права &lt;b&gt;со-сопровождающего&lt;/b&gt; для &lt;b&gt;пространства имен&lt;/b&gt; . Основной сопровождающий может отказаться от этого различия, назначив его другому автору PAUSE. См. Camel главу 19, &amp;laquo;CPAN&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="08620722332423b72a0cf9f7ae67e151d08d71e3" translate="yes" xml:space="preserve">
          <source>The author would like to thank Jeff Pinyan, Andrew Johnson, Peter Haworth, Ronald J Kimball, and Joe Smith for all their helpful comments.</source>
          <target state="translated">Автор благодарит Джеффа Пиняна,Эндрю Джонсона,Питера Хоуорта,Рональда Джей Кимбалла и Джо Смита за все их полезные комментарии.</target>
        </trans-unit>
        <trans-unit id="7842e70d44fa0066b01f00b794f28e99cc120d48" translate="yes" xml:space="preserve">
          <source>The author would like to thank Mark-Jason Dominus, Tom Christiansen, Ilya Zakharevich, Brad Hughes, and Mike Giroux for all their helpful comments.</source>
          <target state="translated">Автор благодарит Марка-Джейсона Доминика,Тома Кристиансена,Илью Захаревича,Брэда Хьюза и Майка Жиру за все их полезные комментарии.</target>
        </trans-unit>
        <trans-unit id="d5ab428bb4c4aa590bf7abb081e2b965dbe912a0" translate="yes" xml:space="preserve">
          <source>The author's book</source>
          <target state="translated">Книга автора</target>
        </trans-unit>
        <trans-unit id="c9e7cff5bfc96623d1a90b00467d7f7914fdeb06" translate="yes" xml:space="preserve">
          <source>The authors make &lt;b&gt;no warranty&lt;/b&gt;, implied or otherwise, about the suitability of this software for safety or security purposes.</source>
          <target state="translated">Авторы не дают &lt;b&gt;никаких гарантий&lt;/b&gt; , подразумеваемых или иных, относительно пригодности этого программного обеспечения для целей безопасности.</target>
        </trans-unit>
        <trans-unit id="9dd8067e06812735b51136d8d5ba18979e5deef6" translate="yes" xml:space="preserve">
          <source>The authors shall not in any case be liable for special, incidental, consequential, indirect or other similar damages arising from the use of this software.</source>
          <target state="translated">Авторы ни в коем случае не несут ответственности за специальный,случайный,косвенный или иной аналогичный ущерб,возникший в результате использования данного программного обеспечения.</target>
        </trans-unit>
        <trans-unit id="bac4f3e7625a4b29694017ee1288427918dba79c" translate="yes" xml:space="preserve">
          <source>The auto-decrement operator is not magical.</source>
          <target state="translated">Оператор авто-декрементации не является волшебным.</target>
        </trans-unit>
        <trans-unit id="c93a7c7b52c97bf0962eebd109f5c679236979ad" translate="yes" xml:space="preserve">
          <source>The auto-increment operator has a little extra builtin magic to it. If you increment a variable that is numeric, or that has ever been used in a numeric context, you get a normal increment. If, however, the variable has been used in only string contexts since it was set, and has a value that is not the empty string and matches the pattern &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; , the increment is done as a string, preserving each character within its range, with carry:</source>
          <target state="translated">Оператор автоинкремента имеет небольшую дополнительную встроенную магию. Если вы увеличиваете числовую переменную или переменную, которая когда-либо использовалась в числовом контексте, вы получите нормальное приращение. Если, однако, переменная использовалась только в строковом контексте с момента ее установки и имеет значение, которое не является пустой строкой и соответствует шаблону &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; , приращение выполняется как строка с сохранением каждого символа в пределах своего диапазона с переносом:</target>
        </trans-unit>
        <trans-unit id="2fa846bc3447cd43bb267eb92f634f66df9d2ff7" translate="yes" xml:space="preserve">
          <source>The autodie pragma &lt;b&gt;&amp;lt;does not check calls to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;&lt;/b&gt;&amp;gt;.</source>
          <target state="translated">Прагма autodie &lt;b&gt;&amp;lt;не проверяет вызовы &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; &lt;/b&gt; &amp;gt;.</target>
        </trans-unit>
        <trans-unit id="6a915a44546183301bc1ab2da7f5d31390cf86d3" translate="yes" xml:space="preserve">
          <source>The autodocumentation system was originally added to the Perl core by Benjamin Stuhl. Documentation is by whoever was kind enough to document their functions.</source>
          <target state="translated">Система автодокументирования была первоначально добавлена в ядро Perl Бенджамином Штулем.Документация-это тот,кто был достаточно добр,чтобы документировать их функции.</target>
        </trans-unit>
        <trans-unit id="3c574214b5c14cf6b803beb9ac59c1988cd63384" translate="yes" xml:space="preserve">
          <source>The automatic and manual perl installation leave precompiled paths inside perl executables. While these paths are overwriteable (see &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;PERLLIB_PREFIX&lt;/a&gt;, &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;), some people may prefer binary editing of paths inside the executables/DLLs.</source>
          <target state="translated">Автоматическая и ручная установка perl оставляет предварительно скомпилированные пути внутри исполняемых файлов perl. Хотя эти пути можно перезаписывать (см. &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;PERLLIB_PREFIX&lt;/a&gt; , &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt; ), некоторые люди могут предпочесть двоичное редактирование путей внутри исполняемых файлов / DLL.</target>
        </trans-unit>
        <trans-unit id="ff6dd9cd9205a8a816f4c19d3aaf08bb26c3152c" translate="yes" xml:space="preserve">
          <source>The available binary operators are:</source>
          <target state="translated">Доступные двоичные операторы:</target>
        </trans-unit>
        <trans-unit id="68bb2a0daa0abd0313002b533bf42c71219aad2d" translate="yes" xml:space="preserve">
          <source>The available diagnostics are:</source>
          <target state="translated">Доступна диагностика:</target>
        </trans-unit>
        <trans-unit id="d8dc3fd07c3386d7e5ad61722c90a54b40f250e5" translate="yes" xml:space="preserve">
          <source>The available fields in the structure are:</source>
          <target state="translated">Доступные поля в структуре:</target>
        </trans-unit>
        <trans-unit id="191f1bb9111a3757ed2ccf45e0e506ae45f1cb2d" translate="yes" xml:space="preserve">
          <source>The available locales depend on your operating system; try whether &lt;code&gt;locale -a&lt;/code&gt; shows them or man pages for &quot;locale&quot; or &quot;nlsinfo&quot; or the direct approach &lt;code&gt;ls /usr/lib/nls/loc&lt;/code&gt; or &lt;code&gt;ls /usr/lib/nls&lt;/code&gt; or &lt;code&gt;ls /usr/lib/locale&lt;/code&gt; . Not all the locales that your vendor supports are necessarily installed: please consult your operating system's documentation and possibly your local system administration. The locale names are probably something like &lt;code&gt;xx_XX.(ISO)?8859-N&lt;/code&gt; or &lt;code&gt;xx_XX.(ISO)?8859N&lt;/code&gt;, for example &lt;code&gt;fr_CH.ISO8859-1&lt;/code&gt; is the Swiss (CH) variant of French (fr), ISO Latin (8859) 1 (-1) which is the Western European character set.</source>
          <target state="translated">Доступные языковые стандарты зависят от вашей операционной системы; попробуйте, показывает ли &lt;code&gt;locale -a&lt;/code&gt; их или страницы руководства для &quot;locale&quot; или &quot;nlsinfo&quot;, или прямой подход &lt;code&gt;ls /usr/lib/nls/loc&lt;/code&gt; или &lt;code&gt;ls /usr/lib/nls&lt;/code&gt; или &lt;code&gt;ls /usr/lib/locale&lt;/code&gt; . Не все локали, поддерживаемые вашим поставщиком, обязательно установлены: обратитесь к документации вашей операционной системы и, возможно, к вашему местному системному администратору. Названия локали, вероятно, выглядят примерно как &lt;code&gt;xx_XX.(ISO)?8859-N&lt;/code&gt; или &lt;code&gt;xx_XX.(ISO)?8859N&lt;/code&gt; , например &lt;code&gt;fr_CH.ISO8859-1&lt;/code&gt; - это швейцарский (CH) вариант французского (fr), ISO Latin (8859) 1 (-1), который является набором символов Западной Европы.</target>
        </trans-unit>
        <trans-unit id="7b104fea0c3b585be7abd9fdcae3632fd9df0849" translate="yes" xml:space="preserve">
          <source>The available mechanisms are:</source>
          <target state="translated">Имеющиеся механизмы:</target>
        </trans-unit>
        <trans-unit id="54ed46c150718473d8504c434e30cd577b337e90" translate="yes" xml:space="preserve">
          <source>The available options are:</source>
          <target state="translated">Доступны следующие варианты:</target>
        </trans-unit>
        <trans-unit id="456a0ea0217776b650b3498424ef7ee39f3e2d1e" translate="yes" xml:space="preserve">
          <source>The backend for the &lt;code&gt;SvPVbytex_force&lt;/code&gt; macro. Always use the macro instead.</source>
          <target state="translated">Бэкенд для &lt;code&gt;SvPVbytex_force&lt;/code&gt; макроса. Вместо этого всегда используйте макрос.</target>
        </trans-unit>
        <trans-unit id="6595fe0b01dc35e2c9393282a00929c691d16bd4" translate="yes" xml:space="preserve">
          <source>The backend for the &lt;code&gt;SvPVutf8x_force&lt;/code&gt; macro. Always use the macro instead.</source>
          <target state="translated">Бэкенд для &lt;code&gt;SvPVutf8x_force&lt;/code&gt; макроса. Вместо этого всегда используйте макрос.</target>
        </trans-unit>
        <trans-unit id="77f66884acce6cf3a3939cb28b0a48cb55b42d47" translate="yes" xml:space="preserve">
          <source>The backslash</source>
          <target state="translated">Обратная косая черта</target>
        </trans-unit>
        <trans-unit id="d905ecd546099386ec13c3559da83e50955fb3c5" translate="yes" xml:space="preserve">
          <source>The backslash character &lt;code&gt;'\'&lt;/code&gt; is a metacharacter itself and needs to be backslashed:</source>
          <target state="translated">Символ обратной косой черты &lt;code&gt;'\'&lt;/code&gt; сам по себе является метасимволом и требует обратной косой черты:</target>
        </trans-unit>
        <trans-unit id="3991be487f455d5a6205c52bea36150b4cf4f97a" translate="yes" xml:space="preserve">
          <source>The backslash sequence can mean either ASCII- or Full-range Unicode, depending on various factors as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;.</source>
          <target state="translated">Последовательность обратной косой черты может означать либо ASCII-, либо полный диапазон Unicode, в зависимости от различных факторов, как описано в разделе &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Какой модификатор набора символов действует? в перлре&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6d38a5acb41572fd3f6bf7b206aa3e31dca4b0b" translate="yes" xml:space="preserve">
          <source>The backtick operator does no translation of the return value, unlike &lt;b&gt;csh&lt;/b&gt;.</source>
          <target state="translated">Оператор обратного апострофа не переводит возвращаемое значение, в отличие от &lt;b&gt;csh&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="ee45daa9d8b6e8559dda882c9eead013ce496d22" translate="yes" xml:space="preserve">
          <source>The backtick operator does variable interpolation without regard to the presence of single quotes in the command.</source>
          <target state="translated">Оператор с обратной связью выполняет интерполяцию переменных без учета наличия в команде одиночных кавычек.</target>
        </trans-unit>
        <trans-unit id="8cd2b3706bb4ede8bd356d31a0615f4df40a7834" translate="yes" xml:space="preserve">
          <source>The backtrace returns the stack trace of the C call frames, with the symbol names (function names), the object names (like &quot;perl&quot;), and if it can, also the source code locations (&lt;a href=&quot;file:line&quot;&gt;file:line&lt;/a&gt;).</source>
          <target state="translated">Backtrace возвращает трассировку стека фреймов вызовов C с именами символов (имена функций), именами объектов (например, &amp;laquo;perl&amp;raquo;) и, если возможно, также местоположениями исходного кода ( &lt;a href=&quot;file:line&quot;&gt;файл: строка&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8bed32736e1b2815ccd999741f9407d4d43d0e8b" translate="yes" xml:space="preserve">
          <source>The base class implementation of the &lt;b&gt;interior_sequence()&lt;/b&gt; method simply returns the raw text of the interior sequence (as it occurred in the input) to the caller.</source>
          <target state="translated">Реализация базового класса метода &lt;b&gt;interior_sequence ()&lt;/b&gt; просто возвращает необработанный текст внутренней последовательности (в том виде, в котором он присутствует во входных данных) вызывающей стороне.</target>
        </trans-unit>
        <trans-unit id="c9ddcb47643cb89116a0a922b50075bea2f25a0e" translate="yes" xml:space="preserve">
          <source>The base class implementation of this method returns the given text.</source>
          <target state="translated">Реализация базового класса этого метода возвращает данный текст.</target>
        </trans-unit>
        <trans-unit id="3f5a827dc5c599719e7ecb28e524afa3505acc67" translate="yes" xml:space="preserve">
          <source>The base class implementation of this method simply prints the text block as it occurred in the input stream).</source>
          <target state="translated">Реализация базового класса этого метода просто распечатывает текстовый блок,как это произошло во входном потоке).</target>
        </trans-unit>
        <trans-unit id="df7aaeb92a14b1f8eaf4aa28b1e80496ba8b43fa" translate="yes" xml:space="preserve">
          <source>The base class implementation of this method simply prints the textblock (unmodified) to the output filehandle.</source>
          <target state="translated">Реализация базового класса этого метода просто выводит текстовый блок (немодифицированный)в выходной файловый менеджер.</target>
        </trans-unit>
        <trans-unit id="303eecbc86fd9c0b4febc57eac0a317dd40331d4" translate="yes" xml:space="preserve">
          <source>The base class implementation of this method simply treats the raw POD command as normal block of paragraph text (invoking the &lt;b&gt;textblock()&lt;/b&gt; method with the command paragraph).</source>
          <target state="translated">Реализация этого метода в базовом классе просто обрабатывает необработанную команду POD как обычный блок текста абзаца (вызывая метод &lt;b&gt;textblock ()&lt;/b&gt; с абзацем команды).</target>
        </trans-unit>
        <trans-unit id="b322d5503c2a18a0550bcf3559879c8738ef1a3f" translate="yes" xml:space="preserve">
          <source>The base class' &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method is &lt;b&gt;not&lt;/b&gt; called.</source>
          <target state="translated">Метод &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; базового класса &lt;b&gt;не&lt;/b&gt; вызывается .</target>
        </trans-unit>
        <trans-unit id="869b6928181db8fd7439173a04a65a2b691f1a82" translate="yes" xml:space="preserve">
          <source>The base function, e.g., &lt;code&gt;isALPHA()&lt;/code&gt; , takes an octet (either a &lt;code&gt;char&lt;/code&gt; or a &lt;code&gt;U8&lt;/code&gt; ) as input and returns a boolean as to whether or not the character represented by that octet is (or on non-ASCII platforms, corresponds to) an ASCII character in the named class based on platform, Unicode, and Perl rules. If the input is a number that doesn't fit in an octet, FALSE is returned.</source>
          <target state="translated">Базовая функция, например &lt;code&gt;isALPHA()&lt;/code&gt; , принимает октет ( &lt;code&gt;char&lt;/code&gt; или &lt;code&gt;U8&lt;/code&gt; ) в качестве входных данных и возвращает логическое значение , указывающее , соответствует ли символ, представленный этим октетом (или на платформах, отличных от ASCII,) символ ASCII в названном классе на основе правил платформы, Unicode и Perl. Если введенное число не помещается в октет, возвращается FALSE.</target>
        </trans-unit>
        <trans-unit id="b4a446b2fbdd7a1f128f546637cc4e95f828763e" translate="yes" xml:space="preserve">
          <source>The base port of Perl to Symbian only implements the basic POSIX-like functionality; it does not implement any further Symbian or Series 60, Series 80, or UIQ bindings for Perl.</source>
          <target state="translated">Базовый порт Perl на Symbian реализует только базовую POSIX-подобную функциональность;он не реализует никаких других привязок Symbian или Series 60,Series 80,или UIQ для Perl.</target>
        </trans-unit>
        <trans-unit id="7b0c0715021b7093caa628303290fd7be9406317" translate="yes" xml:space="preserve">
          <source>The base revision level of this package, from the</source>
          <target state="translated">Уровень базовой ревизии данного пакета,из</target>
        </trans-unit>
        <trans-unit id="1f81368d64cf4514ffa26dd1724286707ec25460" translate="yes" xml:space="preserve">
          <source>The base should be zero or between 2 and 36, inclusive. When the base is zero or omitted &lt;code&gt;strtol&lt;/code&gt; will use the string itself to determine the base: a leading &quot;0x&quot; or &quot;0X&quot; means hexadecimal; a leading &quot;0&quot; means octal; any other leading characters mean decimal. Thus, &quot;1234&quot; is parsed as a decimal number, &quot;01234&quot; as an octal number, and &quot;0x1234&quot; as a hexadecimal number.</source>
          <target state="translated">База должна быть равна нулю или от 2 до 36 включительно. Когда база равна нулю или опущена, &lt;code&gt;strtol&lt;/code&gt; будет использовать саму строку для определения базы: ведущий &amp;laquo;0x&amp;raquo; или &amp;laquo;0X&amp;raquo; означает шестнадцатеричный; ведущий &amp;laquo;0&amp;raquo; означает восьмеричный; любые другие ведущие символы означают десятичное число. Таким образом, &amp;laquo;1234&amp;raquo; анализируется как десятичное число, &amp;laquo;01234&amp;raquo; как восьмеричное число и &amp;laquo;0x1234&amp;raquo; как шестнадцатеричное число.</target>
        </trans-unit>
        <trans-unit id="d0bf4e2fa899dc153c411be4c5898369064784f4" translate="yes" xml:space="preserve">
          <source>The base structure of a regop is defined in</source>
          <target state="translated">Базовая структура регопа определена в</target>
        </trans-unit>
        <trans-unit id="29446f6b360bcce933609abf092817cd60b4c651" translate="yes" xml:space="preserve">
          <source>The base64 encoded string returned is not padded to be a multiple of 4 bytes long. If you want interoperability with other base64 encoded md5 digests you might want to append the string &quot;==&quot; to the result.</source>
          <target state="translated">Возвращаемая строка в кодировке base64 не имеет длины,кратной 4 байтам.Если вам нужна интероперабельность с другими md5-дайджестами в base64-кодировке,то к результату можно добавить строку &quot;==&quot;.</target>
        </trans-unit>
        <trans-unit id="d8ffce64bc52685123cf17779b3bc30ab4b06b36" translate="yes" xml:space="preserve">
          <source>The basic &lt;code&gt;quant&lt;/code&gt; method that Locale::Maketext provides should be good for many languages. For some languages, it might be useful to modify it (or its constituent &lt;code&gt;numerate&lt;/code&gt; method) to take a plural form in the two-argument call to &lt;code&gt;quant&lt;/code&gt; (as in &quot;[quant,_1,files]&quot;) if it's all-around easier to infer the singular form from the plural, than to infer the plural form from the singular.</source>
          <target state="translated">Основной &lt;code&gt;quant&lt;/code&gt; метод Locale :: Maketext обеспечивает должно быть хорошо для многих языков. Для некоторых языков, возможно , было бы полезно , чтобы изменить его (или его составной &lt;code&gt;numerate&lt;/code&gt; метод) , чтобы принять форму множественного числа в два-аргумента вызова &lt;code&gt;quant&lt;/code&gt; (как в &amp;laquo;[квант, _1, файлы]&amp;raquo;) , если это все вокруг проще выводить форму единственного числа от множественного числа, чем выводить форму множественного числа от единственного числа.</target>
        </trans-unit>
        <trans-unit id="bd8f1357516762bbb931d125e3d2a8b11599ee5f" translate="yes" xml:space="preserve">
          <source>The basic IPC facilities of Perl are built out of the good old Unix signals, named pipes, pipe opens, the Berkeley socket routines, and SysV IPC calls. Each is used in slightly different situations.</source>
          <target state="translated">Основные IPC сооружения Perl построены на старых добрых сигналах Unix,названных трубах,отверстиях в трубах,маршрутах разъемов Berkeley и вызовах SysV IPC.Каждый из них используется в несколько различных ситуациях.</target>
        </trans-unit>
        <trans-unit id="9eaaba65a1dac8dd5fd38c2dd581e65245159383" translate="yes" xml:space="preserve">
          <source>The basic building block of Perl strings has always been a &quot;character&quot;. The changes basically come down to that the implementation no longer thinks that a character is always just a single byte.</source>
          <target state="translated">Основным строительным блоком строк Perl всегда был &quot;персонаж&quot;.Изменения в основном сводятся к тому,что реализация больше не думает,что символ-это всегда только один байт.</target>
        </trans-unit>
        <trans-unit id="bf944598ad68a6908fe4ecd014a8a61a7b06d00e" translate="yes" xml:space="preserve">
          <source>The basic data structure is a PerlIOl:</source>
          <target state="translated">Базовая структура данных-это PerlIOl:</target>
        </trans-unit>
        <trans-unit id="b5815b577f436fdec50339dbc9340f9c6b027e08" translate="yes" xml:space="preserve">
          <source>The basic design of Locale::Maketext is object-oriented, and Locale::Maketext is an abstract base class, from which you derive a &quot;project class&quot;. The project class (with a name like &quot;TkBocciBall::Localize&quot;, which you then use in your module) is in turn the base class for all the &quot;language classes&quot; for your project (with names &quot;TkBocciBall::Localize::it&quot;, &quot;TkBocciBall::Localize::en&quot;, &quot;TkBocciBall::Localize::fr&quot;, etc.).</source>
          <target state="translated">Базовый дизайн Locale::Maketext является объектно-ориентированным,а Locale::Maketext-это абстрактный базовый класс,из которого вы получаете &quot;класс проекта&quot;.Класс проекта (с именем типа &quot;TkBocciBall::Localize&quot;,который вы затем используете в своем модуле)в свою очередь является базовым классом для всех &quot;языковых классов&quot; вашего проекта (с именами &quot;TkBocciBall::Localize::it&quot;,&quot;TkBocciBall::Localize::en&quot;,&quot;TkBocciBall::Localize::fr&quot; и т.д.).</target>
        </trans-unit>
        <trans-unit id="7d3d2515e50dae3561d665210b7c755d11c489ee" translate="yes" xml:space="preserve">
          <source>The basic design of Math::BigInt allows simple subclasses with very little work, as long as a few simple rules are followed:</source>
          <target state="translated">Базовый дизайн Math::BigInt позволяет создавать простые подклассы с очень небольшим объемом работы,при условии соблюдения нескольких простых правил:</target>
        </trans-unit>
        <trans-unit id="1933c32469836b92b1e6ed87797ae53de2e4a98a" translate="yes" xml:space="preserve">
          <source>The basic files in a module look something like this.</source>
          <target state="translated">Основные файлы в модуле выглядят примерно так.</target>
        </trans-unit>
        <trans-unit id="341f2c68b6960d075517d469051ae07bb1f926b7" translate="yes" xml:space="preserve">
          <source>The basic idea of inserting, changing, or deleting a line from a text file involves reading and printing the file to the point you want to make the change, making the change, then reading and printing the rest of the file. Perl doesn't provide random access to lines (especially since the record input separator, &lt;code&gt;$/&lt;/code&gt; , is mutable), although modules such as &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; can fake it.</source>
          <target state="translated">Основная идея вставки, изменения или удаления строки из текстового файла заключается в чтении и печати файла до точки, в которой вы хотите внести изменение, внесении изменений, а затем чтении и печати остальной части файла. Perl не предоставляет произвольный доступ к строкам (тем более, что разделитель входных данных записи, &lt;code&gt;$/&lt;/code&gt; , изменяемый), хотя такие модули, как &lt;a href=&quot;tie/file&quot;&gt;Tie :: File,&lt;/a&gt; могут подделывать его.</target>
        </trans-unit>
        <trans-unit id="99456abf05b5371483583dbfe86305dc116a350f" translate="yes" xml:space="preserve">
          <source>The basic purpose of this module is to print out either &quot;ok #&quot; or &quot;not ok #&quot; depending on if a given test succeeded or failed. Everything else is just gravy.</source>
          <target state="translated">Основное назначение этого модуля-распечатка либо &quot;ok #&quot;,либо &quot;not ok #&quot; в зависимости от того,удался или не удался тот или иной тест.Все остальное-просто соус.</target>
        </trans-unit>
        <trans-unit id="64db8342329369b417d189ab1b4fe97232b396bf" translate="yes" xml:space="preserve">
          <source>The basic structure of this routine is to try to find the start- and/or end-points of where the pattern could match, and to ensure that the string is long enough to match the pattern. It tries to use more efficient methods over less efficient methods and may involve considerable cross-checking of constraints to find the place in the string that matches. For instance it may try to determine that a given fixed string must be not only present but a certain number of chars before the end of the string, or whatever.</source>
          <target state="translated">Основная структура этой рутины состоит в том,чтобы попытаться найти начальную и/или конечную точки,в которых шаблон может совпадать,и убедиться в том,что строка достаточно длинная,чтобы совпасть с шаблоном.Она пытается использовать более эффективные методы,а не менее эффективные методы,и может включать в себя значительную перекрестную проверку ограничений для поиска места в строке,которое совпадает.Например,он может попытаться определить,что заданная фиксированная строка должна быть не только присутствовать,но и иметь определенное количество символов до конца строки,или что-то в этом роде.</target>
        </trans-unit>
        <trans-unit id="80dbc79bfdbd83bc8576245228c2b94ef265f584" translate="yes" xml:space="preserve">
          <source>The basic unit of Perl testing is the ok. For each thing you want to test your program will print out an &quot;ok&quot; or &quot;not ok&quot; to indicate pass or fail. You do this with the &lt;code&gt;ok()&lt;/code&gt; function (see below).</source>
          <target state="translated">Основной единицей тестирования Perl является ОК. Для каждой вещи, которую вы хотите протестировать, ваша программа будет распечатывать &amp;laquo;ОК&amp;raquo; или &amp;laquo;Не ОК&amp;raquo;, чтобы указать, прошел или не прошел. Вы делаете это с помощью функции &lt;code&gt;ok()&lt;/code&gt; (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="9d2230b748e4308cffef19ddef65b44d6210c473" translate="yes" xml:space="preserve">
          <source>The behavior implied by the &lt;b&gt;use warnings&lt;/b&gt; pragma is not mandatory.</source>
          <target state="translated">Поведение, подразумеваемое прагмой &lt;b&gt;use&lt;/b&gt; warnings, не является обязательным.</target>
        </trans-unit>
        <trans-unit id="b5f143aadeaa7a8e64e344e87d8748a02f3060a4" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if LENGTH is greater than the length of the file.</source>
          <target state="translated">Поведение не определено,если LENGTH больше длины файла.</target>
        </trans-unit>
        <trans-unit id="2f1c51d0082c9a007ed014e64f75cf7ba3d7eb5f" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; on a directory handle depends on the operating system. On a system with dirfd(3) or similar, &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; on a directory handle returns the underlying file descriptor associated with the handle; on systems with no such support, it returns the undefined value, and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">Поведение &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; для дескриптора каталога зависит от операционной системы. В системе с dirfd (3) или аналогичной, &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; в дескрипторе каталога возвращает базовый дескриптор файла, связанный с дескриптором; в системах без такой поддержки он возвращает неопределенное значение и устанавливает &lt;code&gt;$!&lt;/code&gt; (эррно).</target>
        </trans-unit>
        <trans-unit id="ac7e84891cea0201bfbd9008ae17bfca2f62f2a2" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; within a regex code block (such as &lt;code&gt;/(?{...})/&lt;/code&gt; ) is subject to change.</source>
          <target state="translated">Поведение &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; в блоке кода регулярного выражения (например, &lt;code&gt;/(?{...})/&lt;/code&gt; ) может быть изменено.</target>
        </trans-unit>
        <trans-unit id="57f854aca9536e1cea9a0904019b31bc3e9f0356" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; on a directory handle depends on the operating system. On a system with dirfd(3) or similar, &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; on a directory handle returns the underlying file descriptor associated with the handle; on systems with no such support, it returns the undefined value, and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">Поведение &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; для дескриптора каталога зависит от операционной системы. В системе с dirfd (3) или аналогичной, &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; в дескрипторе каталога возвращает базовый дескриптор файла, связанный с дескриптором; в системах без такой поддержки он возвращает неопределенное значение и устанавливает &lt;code&gt;$!&lt;/code&gt; (эррно).</target>
        </trans-unit>
        <trans-unit id="00c21c5f299927d5b3bf2172e0cf7aff5e3373e8" translate="yes" xml:space="preserve">
          <source>The behavior of PREFIX is complicated and depends closely on how your Perl is configured. The resulting installation locations will vary from machine to machine and even different installations of Perl on the same machine. Because of this, its difficult to document where prefix will place your modules.</source>
          <target state="translated">Поведение PREFIX является сложным и тесно зависит от того,как настроен ваш Perl.В результате,места установки будут варьироваться от машины к машине и даже разные установки Perl на одной и той же машине.Из-за этого,трудно документировать,где префикс будет размещать ваши модули.</target>
        </trans-unit>
        <trans-unit id="93dc5bd5efb782736e0942603b0c8fa1c754b397" translate="yes" xml:space="preserve">
          <source>The behavior of a smartmatch depends on what type of things its arguments are, as determined by the following table. The first row of the table whose types apply determines the smartmatch behavior. Because what actually happens is mostly determined by the type of the second operand, the table is sorted on the right operand instead of on the left.</source>
          <target state="translated">Поведение смарт-матча зависит от того,какие у него аргументы,как это определено в следующей таблице.Первая строка таблицы,к которой применяются типы аргументов,определяет поведение смартматча.Поскольку то,что на самом деле происходит,в основном определяется типом второго операнда,таблица сортируется не слева,а справа от операнда.</target>
        </trans-unit>
        <trans-unit id="f414c994d5bce7014330ec5990bba640279929f3" translate="yes" xml:space="preserve">
          <source>The behavior of binary arithmetic operators depends on whether they're used on numbers or strings. The operators treat a string as a series of bits and work with that (the string &lt;code&gt;&quot;3&quot;&lt;/code&gt; is the bit pattern &lt;code&gt;00110011&lt;/code&gt; ). The operators work with the binary form of a number (the number &lt;code&gt;3&lt;/code&gt; is treated as the bit pattern &lt;code&gt;00000011&lt;/code&gt; ).</source>
          <target state="translated">Поведение двоичных арифметических операторов зависит от того, используются ли они для чисел или строк. Операторы обрабатывают строку как серию битов и работают с ней (строка &lt;code&gt;&quot;3&quot;&lt;/code&gt; - это битовая комбинация &lt;code&gt;00110011&lt;/code&gt; ). Операторы работают с двоичной формой числа (число &lt;code&gt;3&lt;/code&gt; обрабатывается как битовая комбинация &lt;code&gt;00000011&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="31eed332c2e58a5c0964723f7df67ca11212685a" translate="yes" xml:space="preserve">
          <source>The behavior of kill when a</source>
          <target state="translated">Поведение убийства,когда</target>
        </trans-unit>
        <trans-unit id="d59b4319820011355ea137761a33247562041027" translate="yes" xml:space="preserve">
          <source>The behavior of local() on non-existent members of composite types is subject to change in future.</source>
          <target state="translated">Поведение local()на несуществующих членах составных типов может измениться в будущем.</target>
        </trans-unit>
        <trans-unit id="7ad390bfcc2f23a71fab54461bd3359a98aa3f6d" translate="yes" xml:space="preserve">
          <source>The behavior of these operators is problematic (and subject to change) if either or both of the strings are encoded in UTF-8 (see &lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;Byte and Character Semantics in perlunicode&lt;/a&gt;.</source>
          <target state="translated">Поведение этих операторов проблематично (и может быть изменено), если одна или обе строки закодированы в UTF-8 (см. &lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;Семантику байтов и символов в perlunicode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a64f313f128b7624f16c0e92b9e3e3d919ea21bc" translate="yes" xml:space="preserve">
          <source>The behavior of tied arrays is not precisely the same as for regular arrays. For example:</source>
          <target state="translated">Поведение привязанных массивов не совсем такое,как у обычных массивов.Например:</target>
        </trans-unit>
        <trans-unit id="e661f036702b62721315aa1d02abc1020897293c" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;code&gt;%-&lt;/code&gt; is implemented via the &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="translated">Поведение &lt;code&gt;%-&lt;/code&gt; реализуется через модуль &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f2f442d7e61435532ac3ebe398b46e4cb8b23b2" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;code&gt;&lt;a href=&quot;__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; within a regex code block (such as &lt;code&gt;/(?{...})/&lt;/code&gt; ) is subject to change.</source>
          <target state="translated">Поведение &lt;code&gt;&lt;a href=&quot;__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; в блоке кода регулярного выражения (например, &lt;code&gt;/(?{...})/&lt;/code&gt; ) может быть изменено.</target>
        </trans-unit>
        <trans-unit id="ecf97494e2dabd3d3c4d6cda259bfc77c61ec233" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; within a regex code block (such as &lt;code&gt;/(?{...})/&lt;/code&gt; ) is subject to change.</source>
          <target state="translated">Поведение &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; в блоке кода регулярного выражения (например, &lt;code&gt;/(?{...})/&lt;/code&gt; ) может быть изменено.</target>
        </trans-unit>
        <trans-unit id="893a97392f7263bab5a8304f6d49e881ca91ba83" translate="yes" xml:space="preserve">
          <source>The behaviour of File::Fetch can be altered by changing the following global variables:</source>
          <target state="translated">Поведение File::Fetch может быть изменено путем изменения следующих глобальных переменных:</target>
        </trans-unit>
        <trans-unit id="9225f0f55c56aed5c676f19da54d01c0121ae5ab" translate="yes" xml:space="preserve">
          <source>The behaviour of IPC::Cmd can be altered by changing the following global variables:</source>
          <target state="translated">Поведение IPC::Cmd может быть изменено путем изменения следующих глобальных переменных:</target>
        </trans-unit>
        <trans-unit id="d64ba516b01f1b6dc31324edef30defa2d23432c" translate="yes" xml:space="preserve">
          <source>The behaviour of Module::Load::Conditional can be altered by changing the following global variables:</source>
          <target state="translated">Поведение модуля::Загрузка::Условие может быть изменено путем изменения следующих глобальных переменных:</target>
        </trans-unit>
        <trans-unit id="47460fd55663b585106f39954f79fa9625db07e7" translate="yes" xml:space="preserve">
          <source>The behaviour of Params::Check can be altered by changing the following global variables:</source>
          <target state="translated">Поведение Params::Check может быть изменено путем изменения следующих глобальных переменных:</target>
        </trans-unit>
        <trans-unit id="deb69a58f590c98de917558022e0254d1d774946" translate="yes" xml:space="preserve">
          <source>The behaviour of the function depends on the arguments:</source>
          <target state="translated">Поведение функции зависит от аргументов:</target>
        </trans-unit>
        <trans-unit id="6ec80595e1c021e2b98071cdf1e5337bff9c960f" translate="yes" xml:space="preserve">
          <source>The behaviour of this option is dependent on the type of &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">Поведение этой опции зависит от типа &lt;code&gt;$output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db32480c737ba8d1007a7ce0c4ddf37612954128" translate="yes" xml:space="preserve">
          <source>The behaviour of this option is dependent on the type of output data stream.</source>
          <target state="translated">Поведение этой опции зависит от типа выходного потока данных.</target>
        </trans-unit>
        <trans-unit id="ae8ebb83ae7fe5dc9eabc5af8c2815aedcfc7b2d" translate="yes" xml:space="preserve">
          <source>The belief that &amp;ldquo;small is beautiful&amp;rdquo;. Paradoxically, if you say something in a small language, it turns out big, and if you say it in a big language, it turns out small. Go figure.</source>
          <target state="translated">Вера в то, что &amp;laquo;маленькое - красиво&amp;raquo;. Как это ни парадоксально, если вы говорите что-то на малом языке, оно получается большим, а если вы говорите это на большом языке, оно получается маленьким. Иди разбери.</target>
        </trans-unit>
        <trans-unit id="5dcff025d12c2edfa9fc4a567fa29e7990ea6873" translate="yes" xml:space="preserve">
          <source>The benefit of using &lt;code&gt;-Mlib=/foo&lt;/code&gt; over &lt;code&gt;-I/foo&lt;/code&gt; , is that the former will automagically remove any duplicated directories, while the latter will not.</source>
          <target state="translated">Преимущество использования &lt;code&gt;-Mlib=/foo&lt;/code&gt; по сравнению с &lt;code&gt;-I/foo&lt;/code&gt; состоит в том, что первый автоматически удалит все повторяющиеся каталоги, а второй - нет.</target>
        </trans-unit>
        <trans-unit id="18900f73de54d7de200d866c09a29fdcc8cd53a3" translate="yes" xml:space="preserve">
          <source>The best algorithm depends on many things. On average, mergesort does fewer comparisons than quicksort, so it may be better when complicated comparison routines are used. Mergesort also takes advantage of pre-existing order, so it would be favored for using &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; to merge several sorted arrays. On the other hand, quicksort is often faster for small arrays, and on arrays of a few distinct values, repeated many times. You can force the choice of algorithm with this pragma, but this feels heavy-handed, so the subpragmas beginning with a &lt;code&gt;_&lt;/code&gt; may not persist beyond Perl 5.8. The default algorithm is mergesort, which will be stable even if you do not explicitly demand it. But the stability of the default sort is a side-effect that could change in later versions. If stability is important, be sure to say so with a</source>
          <target state="translated">Лучший алгоритм зависит от многих вещей. В среднем сортировка слиянием выполняет меньше сравнений, чем быстрая сортировка, поэтому может быть лучше при использовании сложных процедур сравнения. Mergesort также использует уже существующий порядок, поэтому было бы предпочтительнее использовать &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; для объединения нескольких отсортированных массивов. С другой стороны, быстрая сортировка часто выполняется быстрее для небольших массивов и для массивов из нескольких различных значений, повторяющихся много раз. Вы можете принудительно выбрать алгоритм с помощью этой прагмы, но это кажется неуклюжим, поэтому субпрагмы, начинающиеся с &lt;code&gt;_&lt;/code&gt; может не сохраняться после Perl 5.8. По умолчанию используется алгоритм сортировки слиянием, который будет стабильным, даже если вы не потребуете его явно. Но стабильность сортировки по умолчанию - это побочный эффект, который может измениться в более поздних версиях. Если важна стабильность, обязательно скажите об этом</target>
        </trans-unit>
        <trans-unit id="25c86820424aca2962f29e4f76c6234dbf83f89d" translate="yes" xml:space="preserve">
          <source>The best comments explain</source>
          <target state="translated">Лучшие комментарии объясняют</target>
        </trans-unit>
        <trans-unit id="97fb423abf47c78c911e5c1b325aae0069b921b4" translate="yes" xml:space="preserve">
          <source>The best way to avoid this oddity is to use this pragma RIGHT AFTER other modules are loaded. i.e.</source>
          <target state="translated">Лучший способ избежать этой странности-это использовать эту прагму ПРАВО ПОСЛЕ загрузки других модулей,т.е.</target>
        </trans-unit>
        <trans-unit id="7c4c0bd8f72ca6e9c0f331a5d5955e9a813aecd9" translate="yes" xml:space="preserve">
          <source>The best way to do this is to come up with a better algorithm. This can often make a dramatic difference. Jon Bentley's book</source>
          <target state="translated">Лучший способ сделать это-придумать лучший алгоритм.Часто это может существенно изменить ситуацию.Книга Джона Бентли</target>
        </trans-unit>
        <trans-unit id="98421bf65e01fd86f5f0e0be25fe15a961951223" translate="yes" xml:space="preserve">
          <source>The best way to know for sure, and pick up many helpful suggestions, is to ask someone who knows. Comp.lang.perl.misc is read by just about all the people who develop modules and it's the best place to ask.</source>
          <target state="translated">Лучший способ узнать наверняка и получить много полезных советов-это спросить кого-то,кто знает.Comp.lang.perl.misc читают практически все люди,которые разрабатывают модули,и это лучшее место,чтобы спросить.</target>
        </trans-unit>
        <trans-unit id="f32d03eab0e341d80074007f2d5b494b8f3cdcfe" translate="yes" xml:space="preserve">
          <source>The best way to prevent this issue is to use waitpid(), as in the following example:</source>
          <target state="translated">Лучший способ предотвратить эту проблему-использовать waitpid(),как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="832c6230c64f67a2bd05effe72650dfa3f10cba9" translate="yes" xml:space="preserve">
          <source>The best way to unlock a file is to discard the object and untie the array. It is probably unsafe to unlock the file without also untying it, because if you do, changes may remain unwritten inside the object. That is why there is no shortcut for unlocking. If you really want to unlock the file prematurely, you know what to do; if you don't know what to do, then don't do it.</source>
          <target state="translated">Лучший способ разблокировать файл-это отбросить объект и развязать массив.Скорее всего,небезопасно разблокировать файл,не привязывая его,так как в этом случае изменения могут остаться не записанными внутри объекта.Поэтому ярлыка для разблокировки нет.Если вы действительно хотите разблокировать файл преждевременно,вы знаете,что делать;если вы не знаете,что делать,то не делайте этого.</target>
        </trans-unit>
        <trans-unit id="7b82cd1f6eaec920a028950cb809a9a88e952b55" translate="yes" xml:space="preserve">
          <source>The big advantage of this form is that it makes it much easier to write patterns with references that can be interpolated in larger patterns, even if the larger pattern also contains capture groups.</source>
          <target state="translated">Большим преимуществом этой формы является то,что она значительно упрощает написание шаблонов со ссылками,которые могут быть интерполированы в более крупные шаблоны,даже если более крупный шаблон также содержит группы захвата.</target>
        </trans-unit>
        <trans-unit id="d54be9133193e99a54a3311620e4e293b6619ef3" translate="yes" xml:space="preserve">
          <source>The big difference between the two types of filter is that the</source>
          <target state="translated">Большая разница между двумя типами фильтров заключается в том,что</target>
        </trans-unit>
        <trans-unit id="f4cd1959ad69d1f5686957182fd610eaea766644" translate="yes" xml:space="preserve">
          <source>The big difference between this filter and the previous example is the use of context data in the filter object. The filter object is based on a hash reference, and is used to keep various pieces of context information between calls to the filter function. All but two of the hash fields are used for error reporting. The first of those two, Enabled, is used by the filter to determine whether the debugging code should be given to the Perl parser. The second, InTraceBlock, is true when the filter has encountered a &lt;code&gt;DEBUG_BEGIN&lt;/code&gt; line, but has not yet encountered the following &lt;code&gt;DEBUG_END&lt;/code&gt; line.</source>
          <target state="translated">Большая разница между этим фильтром и предыдущим примером заключается в использовании контекстных данных в объекте фильтра. Объект фильтра основан на ссылке на хэш и используется для хранения различных частей контекстной информации между вызовами функции фильтрации. Все поля, кроме двух, используются для отчетов об ошибках. Первый из этих двух, Enabled, используется фильтром, чтобы определить, следует ли передавать код отладки парсеру Perl. Второй, InTraceBlock, истинен, когда фильтр обнаружил строку &lt;code&gt;DEBUG_BEGIN&lt;/code&gt; , но еще не обнаружил следующую строку &lt;code&gt;DEBUG_END&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52b096e99c9cb93102a3127548a39ec46a5e6a20" translate="yes" xml:space="preserve">
          <source>The big problem with this approach is that if you don't have control over source code being run in the child process, you can't control what it does with pipe buffering. Thus you can't just open a pipe to &lt;code&gt;cat -v&lt;/code&gt; and continually read and write a line from it.</source>
          <target state="translated">Большая проблема с этим подходом заключается в том, что если у вас нет контроля над исходным кодом, выполняемым в дочернем процессе, вы не можете контролировать то, что он делает, с помощью буферизации канала. Таким образом, вы не можете просто открыть канал для &lt;code&gt;cat -v&lt;/code&gt; и постоянно читать и писать из него строку.</target>
        </trans-unit>
        <trans-unit id="6486f0bee06ebbaca6cfa5b06fc46e3b4ab031bf" translate="yes" xml:space="preserve">
          <source>The biggest difference between Perl</source>
          <target state="translated">Самая большая разница между Perl</target>
        </trans-unit>
        <trans-unit id="10223441fe4732f3b2ec434dced2b599c8ca3725" translate="yes" xml:space="preserve">
          <source>The biggest difference is that the first construction would reinstate the initial value of $var, irrespective of how control exits the block: &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, etc. It is a little bit more efficient as well.</source>
          <target state="translated">Самая большая разница в том, что первая конструкция восстановит начальное значение $ var, независимо от того, как элемент управления выходит из блока: &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; и т. Д. Это также немного более эффективно.</target>
        </trans-unit>
        <trans-unit id="3dfc4089faf0bdc2fe8184811a388d88572e3199" translate="yes" xml:space="preserve">
          <source>The biggest trap of all is forgetting to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; or use the &lt;b&gt;-w&lt;/b&gt; switch; see &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; and &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. The second biggest trap is not making your entire program runnable under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; . The third biggest trap is not reading the list of changes in this version of Perl; see &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perldelta.html&quot;&gt;perldelta&lt;/a&gt;.</source>
          <target state="translated">Самая большая ловушка - это забыть &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; или использовать ключ &lt;b&gt;-w&lt;/b&gt; ; см. &lt;a href=&quot;warnings&quot;&gt;предупреждения&lt;/a&gt; и &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; . Вторая по величине ловушка - не сделать всю вашу программу работоспособной при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использовании&lt;/a&gt; . Третья по значимости ловушка - это не чтение списка изменений в этой версии Perl; см. &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perldelta.html&quot;&gt;perldelta&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86312f7a492ad492d886bde4c3d6e414b56f1879" translate="yes" xml:space="preserve">
          <source>The binary can be installed into the directory where perl normally resides on your machine with</source>
          <target state="translated">Двоичный файл может быть установлен в каталог,где perl обычно находится на Вашей машине,при помощи</target>
        </trans-unit>
        <trans-unit id="153cbfaf81971e19f89aca8f0baea516f2171a06" translate="yes" xml:space="preserve">
          <source>The binary number may optionally be prefixed with &quot;0b&quot; or &quot;b&quot; unless &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; is set in</source>
          <target state="translated">Двоичное число может дополнительно иметь префикс &amp;laquo;0b&amp;raquo; или &amp;laquo;b&amp;raquo;, если &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; не установлен в</target>
        </trans-unit>
        <trans-unit id="5cc1bf2dab8b81eb0899313841a54927fbe7de16" translate="yes" xml:space="preserve">
          <source>The binary operators &lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt;&lt;code&gt;==&lt;/code&gt;&lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt; and the unary operators &lt;code&gt;-&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; will attempt to convert arguments to integers. If both conversions are possible without loss of precision, and the operation can be performed without loss of precision then the integer result is used. Otherwise arguments are converted to floating point format and the floating point result is used. The caching of conversions (as described above) means that the integer conversion does not throw away fractional parts on floating point numbers.</source>
          <target state="translated">Бинарные операторы &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; &lt;code&gt;==&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; И унарные операторы &lt;code&gt;-&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; будут пытаться преобразовать аргументы в целые числа. Если оба преобразования возможны без потери точности, и операция может быть выполнена без потери точности, то используется целочисленный результат. В противном случае аргументы преобразуются в формат с плавающей запятой и используется результат с плавающей запятой. Кэширование преобразований (как описано выше) означает, что целочисленное преобразование не отбрасывает дробные части чисел с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="1bc82db291b733618e76b84e58f74ac2a34e10aa" translate="yes" xml:space="preserve">
          <source>The bit complement operator &lt;code&gt;~&lt;/code&gt; may produce surprising results if used on strings containing characters with ordinal values above 255. In such a case, the results are consistent with the internal encoding of the characters, but not with much else. So don't do that. Similarly for &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt;: you will be operating on the internally-encoded bit patterns of the Unicode characters, not on the code point values, which is very probably not what you want.</source>
          <target state="translated">Оператор битового дополнения &lt;code&gt;~&lt;/code&gt; может дать неожиданные результаты, если он используется в строках, содержащих символы с порядковыми значениями выше 255. В таком случае результаты согласуются с внутренней кодировкой символов, но не с многим другим. Так что не делай этого. Аналогично для &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt; : вы будете работать с внутренне закодированными битовыми шаблонами символов Unicode, а не со значениями кодовой точки, что, скорее всего, не то, что вам нужно.</target>
        </trans-unit>
        <trans-unit id="d35eca1d1b5259b3fe2499ebc8287ac008c74743" translate="yes" xml:space="preserve">
          <source>The bit of magic mentioned in the section title occurs when the regexp backtracks in the process of searching for a match. If the regexp backtracks over a code expression and if the variables used within are localized using &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, the changes in the variables produced by the code expression are undone! Thus, if we wanted to count how many times a character got matched inside a group, we could use, e.g.,</source>
          <target state="translated">Волшебство, упомянутое в заголовке раздела, происходит, когда регулярное выражение возвращается в процессе поиска совпадения. Если регулярное выражение выполняет возврат по выражению кода и если используемые в нем переменные локализованы с использованием &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; , изменения в переменных, произведенных выражением кода, отменяются! Таким образом, если мы хотим подсчитать, сколько раз встречался персонаж внутри группы, мы могли бы использовать, например,</target>
        </trans-unit>
        <trans-unit id="37e1e5bfe9f52e71b4a679c89e1ebe8060bbbb9c" translate="yes" xml:space="preserve">
          <source>The bit string operators, &lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt; and (starting in v5.22) &lt;code&gt;&amp;amp;. |. ^.  ~.&lt;/code&gt; can operate on characters that don't fit into a byte. However, the current behavior is likely to change. You should not use these operators on strings that are encoded in UTF-8. If you're not sure about the encoding of a string, downgrade it before using any of these operators; you can use &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::utf8_downgrade() &lt;/a&gt;.</source>
          <target state="translated">Операторы битовой строки &lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt; и (начиная с v5.22) &lt;code&gt;&amp;amp;. |. ^. ~.&lt;/code&gt; может работать с символами, которые не помещаются в байт. Однако нынешнее поведение, вероятно, изменится. Вы не должны использовать эти операторы для строк, закодированных в UTF-8. Если вы не уверены в кодировке строки, понизьте ее до использования любого из этих операторов; вы можете использовать &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: utf8_downgrade ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="798f07dedaf152fa64ff8f36aa832d747a59dede" translate="yes" xml:space="preserve">
          <source>The bitmask</source>
          <target state="translated">Битмаска</target>
        </trans-unit>
        <trans-unit id="7f65bb852dcddd2ea289cb9a819f8b8574f5d891" translate="yes" xml:space="preserve">
          <source>The bitwise operators such as &amp;amp; ^ | may return different results when operating on string or character data in a Perl program running on an EBCDIC platform than when run on an ASCII platform. Here is an example adapted from the one in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;:</source>
          <target state="translated">Побитовые операторы, такие как &amp;amp; ^ | может возвращать разные результаты при работе со строковыми или символьными данными в программе Perl, работающей на платформе EBCDIC, чем при работе на платформе ASCII. Вот пример, адаптированный из &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="6f959154b03d16bc90e316f48db81d6452186e11" translate="yes" xml:space="preserve">
          <source>The bless() operator may be used to associate the object a reference points to with a package functioning as an object class. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">Оператор bless () может использоваться для связывания объекта, на который указывает ссылка, с пакетом, функционирующим как класс объектов. См. &lt;a href=&quot;perlobj&quot;&gt;Perlobj&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62c6e0f6d8c3596c1d5e718f86c80115574f39a3" translate="yes" xml:space="preserve">
          <source>The blibdirs.ts target is deprecated. Depend on blibdirs instead.</source>
          <target state="translated">Цель blibdirs.ts устарела.Зависит от blibdirs.</target>
        </trans-unit>
        <trans-unit id="a0e8f481ec3e68f2eee488cdec2641a9ee4fc58d" translate="yes" xml:space="preserve">
          <source>The body of an object is never examined by an inside-out class, only its reference address is used. This allows for the body of an actual object to be</source>
          <target state="translated">Тело объекта никогда не проверяется внутренним классом,используется только его ссылочный адрес.Это позволяет телу реального объекта быть</target>
        </trans-unit>
        <trans-unit id="5f03e7d3d4bcb5b96cdb3a0cb31e708fb5a607fe" translate="yes" xml:space="preserve">
          <source>The bond between a magical variable and its implementation class. See the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo; and Camel chapter 14, &amp;ldquo;Tied Variables&amp;rdquo;.</source>
          <target state="translated">Связь между магической переменной и классом ее реализации. См. Функцию &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; в Camel, глава 27, &amp;laquo;Функции&amp;raquo;, и Camel, глава 14, &amp;laquo;Связанные переменные&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3d1559aa0f7fe592165823ac05e1383677536c15" translate="yes" xml:space="preserve">
          <source>The boss thread does relatively little work. While tasks aren't necessarily performed faster than with any other method, it tends to have the best user-response times.</source>
          <target state="translated">Нить босса работает относительно мало.Хотя задачи не обязательно выполняются быстрее,чем любым другим методом,он,как правило,имеет лучшее время отклика пользователя.</target>
        </trans-unit>
        <trans-unit id="4d643dd67e77ce12596be6c04808856092685be2" translate="yes" xml:space="preserve">
          <source>The boss/worker model usually has one</source>
          <target state="translated">У модели &quot;босс/работник&quot; обычно есть одна.</target>
        </trans-unit>
        <trans-unit id="7cb25d97420dee45b6ff8e8d1d3ce98bc5f8cf9f" translate="yes" xml:space="preserve">
          <source>The bottom line is that Perl has always practiced &quot;Character Semantics&quot;, but with the advent of Unicode, that is now different than &quot;Byte Semantics&quot;.</source>
          <target state="translated">Суть в том,что Перл всегда практиковал &quot;Семантику персонажей&quot;,но с появлением Юникода,которая теперь отличается от &quot;Семантики байтов&quot;.</target>
        </trans-unit>
        <trans-unit id="b78f42ecd2e198ccb02cbf24e0cb3e2f279a41cb" translate="yes" xml:space="preserve">
          <source>The bottom line is that using &lt;code&gt;/o&lt;/code&gt; is almost never a good idea.</source>
          <target state="translated">Суть в том, что использование &lt;code&gt;/o&lt;/code&gt; почти никогда не бывает хорошей идеей.</target>
        </trans-unit>
        <trans-unit id="d9acf6e820cb60c3e92eccf3aa1b7d56933e4bb1" translate="yes" xml:space="preserve">
          <source>The bracketing construct &lt;code&gt;( ... )&lt;/code&gt; creates capture groups (also referred to as capture buffers). To refer to the current contents of a group later on, within the same pattern, use &lt;code&gt;\g1&lt;/code&gt; (or &lt;code&gt;\g{1}&lt;/code&gt; ) for the first, &lt;code&gt;\g2&lt;/code&gt; (or &lt;code&gt;\g{2}&lt;/code&gt; ) for the second, and so on. This is called a</source>
          <target state="translated">Конструкция брекетинга &lt;code&gt;( ... )&lt;/code&gt; создает группы захвата (также называемые буферами захвата). Чтобы позже обратиться к текущему содержимому группы в рамках того же шаблона, используйте &lt;code&gt;\g1&lt;/code&gt; (или &lt;code&gt;\g{1}&lt;/code&gt; ) для первого, &lt;code&gt;\g2&lt;/code&gt; (или &lt;code&gt;\g{2}&lt;/code&gt; ) для второго и так далее. Это называется</target>
        </trans-unit>
        <trans-unit id="e36070a31e90d55267b22c4c53ba4bb76bc4e98b" translate="yes" xml:space="preserve">
          <source>The btree format allows arbitrary key/value pairs to be stored in a sorted, balanced binary tree.</source>
          <target state="translated">Формат btree позволяет хранить произвольные пары ключ/значение в отсортированном,сбалансированном двоичном дереве.</target>
        </trans-unit>
        <trans-unit id="3d23a8ab70ee632140bebef4fc4a9cc18111b1ba" translate="yes" xml:space="preserve">
          <source>The bucket usage information provided by &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(%hash)&lt;/a&gt;&lt;/code&gt; is not available. What this means is that using %tied_hash in boolean context doesn't work right (currently this always tests false, regardless of whether the hash is empty or hash elements).</source>
          <target state="translated">Информация об использовании корзины, предоставленная &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(%hash)&lt;/a&gt;&lt;/code&gt; недоступна. Это означает, что использование% tied_hash в логическом контексте не работает правильно (в настоящее время это всегда проверяет ложь, независимо от того, является ли хеш пустым или хеш-элементами).</target>
        </trans-unit>
        <trans-unit id="ca05fef836743ccb209a85580910e15958fde72d" translate="yes" xml:space="preserve">
          <source>The buffer for this layer currently holds data written to it but not sent to next layer.</source>
          <target state="translated">В буфере для этого слоя в настоящее время хранятся данные,записанные на него,но не отправленные на следующий уровень.</target>
        </trans-unit>
        <trans-unit id="7906bb96b8244bc39b3b8a2c3c66a3c0af5824fe" translate="yes" xml:space="preserve">
          <source>The buffer for this layer currently holds unconsumed data read from layer below.</source>
          <target state="translated">В буфере для этого слоя в настоящее время хранятся неконсолидированные данные,считанные с нижнего уровня.</target>
        </trans-unit>
        <trans-unit id="6ea453ad94b47d04a0aaf4ba8a7c5a8d66aac757" translate="yes" xml:space="preserve">
          <source>The buffer for this layer should be filled (for read) from layer below. When you &quot;subclass&quot; PerlIOBuf layer, you want to use its</source>
          <target state="translated">Буфер для этого слоя должен быть заполнен (для чтения)из слоя ниже.Когда вы &quot;подкласс&quot; PerlIOBuf слоя,вы хотите использовать его</target>
        </trans-unit>
        <trans-unit id="0b0da711f6da8dbe92866cc34757189eaf594fa5" translate="yes" xml:space="preserve">
          <source>The buffer parameters can either be a scalar or a scalar reference.</source>
          <target state="translated">Параметры буфера могут быть как скалярными,так и скалярными.</target>
        </trans-unit>
        <trans-unit id="3180fcf8985754e2c180a612db1e7626b0444c64" translate="yes" xml:space="preserve">
          <source>The buffer size parameter is ignored. If either argument to &lt;code&gt;copy&lt;/code&gt; is a handle to an opened file, then data is copied using Perl operators, and no effort is made to preserve file attributes or record structure.</source>
          <target state="translated">Параметр размера буфера игнорируется. Если любой из аргументов для &lt;code&gt;copy&lt;/code&gt; является дескриптором открытого файла, то данные копируются с использованием операторов Perl, и не предпринимается никаких усилий для сохранения атрибутов файла или структуры записи.</target>
        </trans-unit>
        <trans-unit id="3a3e5d3d24ac3da5ee8782f3b635bd002510477d" translate="yes" xml:space="preserve">
          <source>The build procedure is completely standard:</source>
          <target state="translated">Процедура сборки является полностью стандартной:</target>
        </trans-unit>
        <trans-unit id="eb86001bb0f7c51ab8f75bc125c6599630a9618e" translate="yes" xml:space="preserve">
          <source>The build process is dependent on the location of the NetWare SDK. Once the Tools &amp;amp; SDK are installed, the build environment has to be setup. The following batch files setup the environment.</source>
          <target state="translated">Процесс сборки зависит от расположения NetWare SDK. После установки Tools &amp;amp; SDK необходимо настроить среду сборки. Следующие командные файлы настраивают среду.</target>
        </trans-unit>
        <trans-unit id="66dc024a88d2f72023e3d27090cc749788a83502" translate="yes" xml:space="preserve">
          <source>The build requires CodeWarrior compiler and linker. In addition, the &quot;NetWare SDK&quot;, &quot;NLM &amp;amp; NetWare Libraries for C&quot; and &quot;NetWare Server Protocol Libraries for C&quot;, all available at &lt;a href=&quot;http://developer.novell.com/wiki/index.php/Category:Novell_Developer_Kit&quot;&gt;http://developer.novell.com/wiki/index.php/Category:Novell_Developer_Kit&lt;/a&gt;, are required. Microsoft Visual C++ version 4.2 or later is also required.</source>
          <target state="translated">Для сборки требуются компилятор и компоновщик CodeWarrior. Кроме того, &amp;laquo;NetWare SDK&amp;raquo;, &amp;laquo;NLM &amp;amp; NetWare Libraries для C&amp;raquo; и &amp;laquo;Библиотеки протоколов сервера NetWare для C&amp;raquo; доступны по адресу &lt;a href=&quot;http://developer.novell.com/wiki/index.php/Category:Novell_Developer_Kit&quot;&gt;http://developer.novell.com/wiki/index.php/Category:Novell_Developer_Kit&lt;/a&gt; , необходимы. Также требуется Microsoft Visual C ++ версии 4.2 или новее.</target>
        </trans-unit>
        <trans-unit id="2ba6778f7060ad4df8f24bbc1bdc4f90be4ddf10" translate="yes" xml:space="preserve">
          <source>The build system that Perl uses is called metaconfig. This system is maintained separately from the Perl core.</source>
          <target state="translated">Система сборки,которую использует Perl,называется metaconfig.Эта система поддерживается отдельно от ядра Perl.</target>
        </trans-unit>
        <trans-unit id="942228e32ca9b0927fd55428e4055983f76b4ec4" translate="yes" xml:space="preserve">
          <source>The built-ins &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; can also be overridden, but due to special magic, their original syntax is preserved, and you don't have to define a prototype for their replacements. (You can't override the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; syntax, though).</source>
          <target state="translated">Встроенные функции &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; также можно переопределить, но из-за особой магии их исходный синтаксис сохраняется, и вам не нужно определять прототип для их замены. (Однако вы не можете переопределить синтаксис &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="296da44de5630b90165936266a71322d333ad173" translate="yes" xml:space="preserve">
          <source>The bulk of the &lt;code&gt;B&lt;/code&gt; module is the methods for accessing fields of these structures.</source>
          <target state="translated">Основная часть модуля &lt;code&gt;B&lt;/code&gt; - это методы доступа к полям этих структур.</target>
        </trans-unit>
        <trans-unit id="8b0e07205f847f3c71cfbfff3ef8429008605c63" translate="yes" xml:space="preserve">
          <source>The bulk of the work is done by the &lt;code&gt;check_num()&lt;/code&gt; subroutine, which takes a reference to its input queue and a prime number that it's responsible for. After pulling in the input queue and the prime that the subroutine is checking (line 11), we create a new queue (line 13) and reserve a scalar for the thread that we're likely to create later (line 12).</source>
          <target state="translated">Основная часть работы выполняется подпрограммой &lt;code&gt;check_num()&lt;/code&gt; , которая берет ссылку на свою входную очередь и простое число, за которое она отвечает. После извлечения входной очереди и прайма, который проверяет подпрограмма (строка 11), мы создаем новую очередь (строка 13) и резервируем скаляр для потока, который мы, вероятно, создадим позже (строка 12).</target>
        </trans-unit>
        <trans-unit id="791442532861b4bafb692d53705783ee9bec0932" translate="yes" xml:space="preserve">
          <source>The byteorder on the platform where Perl was built is also available via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Байтердер на платформе, на которой был построен Perl, также доступен через &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2a22ccaf7c6bd804cab616f223b89fb4c998d9e8" translate="yes" xml:space="preserve">
          <source>The byteorder on the platform where Perl was built is also available via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Байтердер на платформе, на которой был построен Perl, также доступен через &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="95b43b81c5e8935337a225eeb872942eb25c3b63" translate="yes" xml:space="preserve">
          <source>The cache itself consumes about 310 bytes per cached record, so if your file has many short records, you may want to decrease the cache memory limit, or else the cache overhead may exceed the size of the cached data.</source>
          <target state="translated">Сам кэш потребляет около 310 байт на запись в кэше,поэтому если в вашем файле много коротких записей,вы можете захотеть уменьшить лимит кэш-памяти,иначе накладные расходы на кэш-память могут превысить размер кэшированных данных.</target>
        </trans-unit>
        <trans-unit id="64eab8d82090d9e1801adf3ce396bf3e93f4b8ee" translate="yes" xml:space="preserve">
          <source>The call graph looks like this:</source>
          <target state="translated">График звонков выглядит вот так:</target>
        </trans-unit>
        <trans-unit id="438b1deafb199f6d78cd53708e2c5819899363df" translate="yes" xml:space="preserve">
          <source>The call is implemented in terms of either Perl's or your system's native fread(3) library function. To get a true read(2) system call, see &lt;a href=&quot;#sysread-FILEHANDLE%2cSCALAR%2cLENGTH%2cOFFSET&quot;&gt;sysread&lt;/a&gt;.</source>
          <target state="translated">Вызов реализован в терминах функции библиотеки fread (3) Perl или вашей системы. Чтобы получить системный вызов true read (2), см. &lt;a href=&quot;#sysread-FILEHANDLE%2cSCALAR%2cLENGTH%2cOFFSET&quot;&gt;Sysread&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="743d372bad1a8cad2381aca07cbb441a9da8196f" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;XSLoader::load()&lt;/code&gt; (or &lt;code&gt;bootstrap()&lt;/code&gt; ) calls the module's bootstrap code. For modules build by</source>
          <target state="translated">Вызов &lt;code&gt;XSLoader::load()&lt;/code&gt; (или &lt;code&gt;bootstrap()&lt;/code&gt; ) вызывает код начальной загрузки модуля. Для модулей, созданных</target>
        </trans-unit>
        <trans-unit id="3ec6acbf7a32681ee91fb2a933c9fbfbb9c3da0d" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;from_to()&lt;/code&gt; changes the bytes in &lt;code&gt;$data&lt;/code&gt; , but nothing material about the nature of the string has changed as far as Perl is concerned. Both before and after the call, the string &lt;code&gt;$data&lt;/code&gt; contains just a bunch of 8-bit bytes. As far as Perl is concerned, the encoding of the string remains as &quot;system-native 8-bit bytes&quot;.</source>
          <target state="translated">Вызов &lt;code&gt;from_to()&lt;/code&gt; изменяет байты в &lt;code&gt;$data&lt;/code&gt; , но с точки зрения Perl ничего существенного в отношении природы строки не изменилось. И до, и после вызова строка &lt;code&gt;$data&lt;/code&gt; содержит всего лишь набор 8-битных байтов. Что касается Perl, кодировка строки остается &amp;laquo;системными 8-битными байтами&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ad70e5f54776fc0924c4e470d4ee9b439b4f2953" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;warnings::register&lt;/code&gt; will create a new warnings category called &quot;MyMod::Abc&quot;, i.e. the new category name matches the current package name. The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function in the module will display a warning message if it gets given a relative path as a parameter. This warnings will only be displayed if the code that uses &lt;code&gt;MyMod::Abc&lt;/code&gt; has actually enabled them with the &lt;code&gt;warnings&lt;/code&gt; pragma like below.</source>
          <target state="translated">Вызов &lt;code&gt;warnings::register&lt;/code&gt; создаст новую категорию предупреждений под названием &amp;laquo;MyMod :: Abc&amp;raquo;, то есть имя новой категории соответствует имени текущего пакета. Функция &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; в модуле отобразит предупреждающее сообщение, если ей будет задан относительный путь в качестве параметра. Эти предупреждения будут отображаться только если код , который использует &lt;code&gt;MyMod::Abc&lt;/code&gt; фактически позволил им с &lt;code&gt;warnings&lt;/code&gt; прагмой , как показано ниже.</target>
        </trans-unit>
        <trans-unit id="de39aad93d96a8313ed651448e2dc806dfea3c70" translate="yes" xml:space="preserve">
          <source>The call to GetOptions() parses the command line arguments that are present in &lt;code&gt;@ARGV&lt;/code&gt; and sets the option variable to the value &lt;code&gt;1&lt;/code&gt; if the option did occur on the command line. Otherwise, the option variable is not touched. Setting the option value to true is often called</source>
          <target state="translated">Вызов GetOptions () анализирует аргументы командной строки, которые присутствуют в &lt;code&gt;@ARGV&lt;/code&gt; , и устанавливает для переменной option значение &lt;code&gt;1&lt;/code&gt; , если опция действительно присутствует в командной строке. В противном случае переменная option не затрагивается. Установка значения параметра в значение true часто называется</target>
        </trans-unit>
        <trans-unit id="171eeffe94ffcbbb77d480c5aae1700315d244fd" translate="yes" xml:space="preserve">
          <source>The call to the program that is able to compile perlmain.c. Defaults to $(CC).</source>
          <target state="translated">Вызов программы,способной скомпилировать perlmain.c.По умолчанию $(CC).</target>
        </trans-unit>
        <trans-unit id="acb2e8bffbae50387da55c62d3573564cf939bc2" translate="yes" xml:space="preserve">
          <source>The call to this method is currently made</source>
          <target state="translated">В настоящее время осуществляется обращение к этому методу</target>
        </trans-unit>
        <trans-unit id="af59be20c7eb663137f8b78548e36aec5ac0b8fe" translate="yes" xml:space="preserve">
          <source>The callback methods &lt;code&gt;start_code&lt;/code&gt; and &lt;code&gt;end_code&lt;/code&gt; emits the &lt;code&gt;code&lt;/code&gt; tags before and after &lt;code&gt;handle_code&lt;/code&gt; is invoked, so you might want to override these together with &lt;code&gt;handle_code&lt;/code&gt; if this wrapping isn't suitable.</source>
          <target state="translated">Методы обратного вызова &lt;code&gt;start_code&lt;/code&gt; и &lt;code&gt;end_code&lt;/code&gt; эмитирует &lt;code&gt;code&lt;/code&gt; метки до и после того, как &lt;code&gt;handle_code&lt;/code&gt; вызывается, так что вы можете переопределить их вместе с &lt;code&gt;handle_code&lt;/code&gt; если упаковка не подходит.</target>
        </trans-unit>
        <trans-unit id="6e4b93d3f2cc24bc6cb3f704f926b3838cfb6c18" translate="yes" xml:space="preserve">
          <source>The callback routine's return value is not used for anything.</source>
          <target state="translated">Возвращаемое значение обратного вызова ни для чего не используется.</target>
        </trans-unit>
        <trans-unit id="df4f95aac52b872cdb00cff71137de388b659b49" translate="yes" xml:space="preserve">
          <source>The callbacks are called for each opcode visited by Concise, in the same order as they are added. Each subroutine is passed five parameters.</source>
          <target state="translated">Обратные вызовы вызываются для каждого опкода,посещаемого Concise,в том же порядке,в котором они добавляются.Каждой подпрограмме передается пять параметров.</target>
        </trans-unit>
        <trans-unit id="cf3ef404c2544a6e1a747fcdf0563fa6c44b7664" translate="yes" xml:space="preserve">
          <source>The caller is responsible for incrementing the reference count of the array returned if it wants to keep the structure. Hence, if you have created a temporary value that you keep no pointer to, &lt;code&gt;sv_2mortal()&lt;/code&gt; to ensure that it is disposed of correctly. If you have cached your return value, then return a pointer to it without changing the reference count.</source>
          <target state="translated">Вызывающий отвечает за увеличение счетчика ссылок возвращаемого массива, если он хочет сохранить структуру. Следовательно, если вы создали временное значение, на которое у вас нет указателя, используйте &lt;code&gt;sv_2mortal()&lt;/code&gt; чтобы убедиться, что оно правильно удалено . Если вы кэшировали возвращаемое значение, верните на него указатель без изменения счетчика ссылок.</target>
        </trans-unit>
        <trans-unit id="261ce3b0bcf399d133cb40e0b62c874dd44f485a" translate="yes" xml:space="preserve">
          <source>The calling context of the function (scalar or list context) is propagated to the normalizer. This means that if the memoized function will treat its arguments differently in list context than it would in scalar context, you can have the normalizer function select its behavior based on the results of &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt;. Even if called in a list context, a normalizer should still return a single string.</source>
          <target state="translated">Контекст вызова функции (скалярный контекст или контекст списка) передается в нормализатор. Это означает, что если мемоизированная функция будет обрабатывать свои аргументы в контексте списка иначе, чем в скалярном контексте, вы можете сделать так, чтобы функция нормализатора выбрала свое поведение на основе результатов &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt; . Даже если он вызывается в контексте списка, нормализатор все равно должен возвращать одну строку.</target>
        </trans-unit>
        <trans-unit id="8bf2965af27484a7764a15d3bbb805341a4c18b1" translate="yes" xml:space="preserve">
          <source>The canonical list of operator names is the contents of the array PL_op_name defined and initialised in file</source>
          <target state="translated">Канонический список имен операторов-это содержимое массива PL_op_name,определенного и инициализированного в файле</target>
        </trans-unit>
        <trans-unit id="c754480a0b53533e23d99a04ff3b99e5ce4e8f9f" translate="yes" xml:space="preserve">
          <source>The canonical name for the host if the &lt;code&gt;AI_CANONNAME&lt;/code&gt; flag was provided, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise. This field will only be present on the first returned address.</source>
          <target state="translated">Каноническое имя хоста, если был &lt;code&gt;AI_CANONNAME&lt;/code&gt; флаг AI_CANONNAME , или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в противном случае. Это поле будет присутствовать только на первом возвращенном адресе.</target>
        </trans-unit>
        <trans-unit id="2ddb3e29fbb2261125aa3969a5b44d4db9de4c6e" translate="yes" xml:space="preserve">
          <source>The canonical name of a delegate distribution to install instead. Useful when a new version, although it tests OK itself, breaks something else or a developer release or a fork is already uploaded that is better than the last released version.</source>
          <target state="translated">Каноническое имя дистрибутива делегата для установки вместо него.Полезно,когда новая версия,хотя и тестирует саму себя OK,разбивает что-то другое,или выпускает разработчик,или уже загружена вилка,которая лучше,чем последняя выпущенная версия.</target>
        </trans-unit>
        <trans-unit id="69da2adf0aadd37547ac813fb993aa6ad1179ac5" translate="yes" xml:space="preserve">
          <source>The canonical name of a given encoding does not necessarily agree with IANA Character Set Registry, commonly seen as &lt;code&gt;Content-Type:
text/plain; charset=&lt;i&gt;WHATEVER&lt;/i&gt;&lt;/code&gt;. For most cases, the canonical name works, but sometimes it does not, most notably with &quot;utf-8-strict&quot;.</source>
          <target state="translated">Каноническое имя данной кодировки не обязательно согласуется с реестром набора символов IANA, обычно обозначаемым как &lt;code&gt;Content-Type: text/plain; charset=&lt;i&gt;WHATEVER&lt;/i&gt;&lt;/code&gt; . В большинстве случаев каноническое имя работает, но иногда нет, особенно с &amp;laquo;utf-8-strict&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7959d4667d41c3277e70505dbf41353d2303db33" translate="yes" xml:space="preserve">
          <source>The capability whose string is to be output.</source>
          <target state="translated">Способность,строка которой должна быть выведена.</target>
        </trans-unit>
        <trans-unit id="a744fed76bc528e01936c6092d667062609b77e5" translate="yes" xml:space="preserve">
          <source>The caret allows for simpler stringification of compiled regular expressions. These look like</source>
          <target state="translated">Каретта позволяет упростить строковку скомпилированных регулярных выражений.Они выглядят как</target>
        </trans-unit>
        <trans-unit id="743958808118b71ad904b9a5f8eed52c69df8dc0" translate="yes" xml:space="preserve">
          <source>The caret tells Perl that this cluster doesn't inherit the flags of any surrounding pattern, but uses the system defaults (&lt;code&gt;d-imsx&lt;/code&gt; ), modified by any flags specified.</source>
          <target state="translated">Каретка сообщает Perl, что этот кластер не наследует флаги какого-либо окружающего шаблона, но использует системные значения по умолчанию ( &lt;code&gt;d-imsx&lt;/code&gt; ), измененные любыми указанными флагами.</target>
        </trans-unit>
        <trans-unit id="d4cdf247822c1c118e5e2a91cdbbd856905f935f" translate="yes" xml:space="preserve">
          <source>The case used for capitals that are followed by lowercase characters instead of by more capitals. Sometimes called sentence case or headline case. English doesn&amp;rsquo;t use Unicode titlecase, but casing rules for English titles are more complicated than simply capitalizing each word&amp;rsquo;s first character.</source>
          <target state="translated">Регистр, используемый для заглавных букв, после которых идут строчные буквы вместо большего количества заглавных букв. Иногда называется падежом предложения или падежом заголовка. Английский язык не использует регистр заголовков Unicode, но правила регистра для заголовков на английском языке более сложны, чем простое использование заглавных букв в первом символе каждого слова.</target>
        </trans-unit>
        <trans-unit id="d711d105fb7ff9ba5105330930cd96c20b047fd3" translate="yes" xml:space="preserve">
          <source>The casemap used in Unicode when comparing or matching without regard to case. Comparing lower-, title-, or uppercase are all unreliable due to Unicode&amp;rsquo;s complex, one-to-many case mappings. Foldcase is a &lt;b&gt;lowercase&lt;/b&gt; variant (using a partially decomposed &lt;b&gt;normalization&lt;/b&gt; form for certain codepoints) created specifically to resolve this.</source>
          <target state="translated">Таблица случаев, используемая в Юникоде при сравнении или сопоставлении без учета регистра. Сравнение нижнего, заглавного или прописного регистра ненадежно из-за сложных отображений Unicode &amp;laquo;один ко многим&amp;raquo;. Foldcase - это вариант в &lt;b&gt;нижнем регистре&lt;/b&gt; (с использованием частично разложенной формы &lt;b&gt;нормализации&lt;/b&gt; для определенных кодовых точек), созданный специально для решения этой проблемы.</target>
        </trans-unit>
        <trans-unit id="f16ecea32ddc45aef48d30c6428e765b0124d50c" translate="yes" xml:space="preserve">
          <source>The cases when the shell is used are:</source>
          <target state="translated">Случаи,когда используется оболочка:</target>
        </trans-unit>
        <trans-unit id="90158421e0d058f44be7171e42f898369c12eafb" translate="yes" xml:space="preserve">
          <source>The categories are currently:</source>
          <target state="translated">Категории в настоящее время:</target>
        </trans-unit>
        <trans-unit id="998a96285bef3fbf35e88e13ee25ef0e94c840c0" translate="yes" xml:space="preserve">
          <source>The character following &lt;code&gt;\c&lt;/code&gt; is mapped to some other character as shown in the table:</source>
          <target state="translated">Символ, следующий за &lt;code&gt;\c&lt;/code&gt; , отображается на другой символ, как показано в таблице:</target>
        </trans-unit>
        <trans-unit id="0182edc494649671b24bec81ea32f4948632cbbf" translate="yes" xml:space="preserve">
          <source>The character set /adul flags cancel each other out. So, in this example,</source>
          <target state="translated">Флаги символов /adul отменяют друг друга.Итак,в этом примере,</target>
        </trans-unit>
        <trans-unit id="9d4fb2a2ad59e5fb5f2e1ac776d2184744805bf9" translate="yes" xml:space="preserve">
          <source>The character set rules are determined by an enum that is contained in this field. This is still experimental and subject to change, but the current interface returns the rules by use of the in-line function &lt;code&gt;get_regex_charset(const U32 flags)&lt;/code&gt; . The only currently documented value returned from it is REGEX_LOCALE_CHARSET, which is set if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect. If present in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; will use the locale dependent definition of whitespace when RXf_SKIPWHITE or RXf_WHITE is in effect. ASCII whitespace is defined as per &lt;a href=&quot;perlapi#isSPACE&quot;&gt;isSPACE&lt;/a&gt;, and by the internal macros &lt;code&gt;is_utf8_space&lt;/code&gt; under UTF-8, and &lt;code&gt;isSPACE_LC&lt;/code&gt; under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
locale&lt;/code&gt; .</source>
          <target state="translated">Правила набора символов определяются перечислением, содержащимся в этом поле. Это все еще экспериментально и может быть изменено, но текущий интерфейс возвращает правила с помощью &lt;code&gt;get_regex_charset(const U32 flags)&lt;/code&gt; функции get_regex_charset (const U32 flags) . Единственное в настоящее время задокументированное значение, возвращаемое из него, - это REGEX_LOCALE_CHARSET, который устанавливается, если действует &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; . Если присутствует в &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; будет использовать зависящее от локали определение пробела, когда действуют RXf_SKIPWHITE или RXf_WHITE. ASCII - пробел определяется в соответствии со &lt;a href=&quot;perlapi#isSPACE&quot;&gt;isSPACE&lt;/a&gt; , а внутренние макросы &lt;code&gt;is_utf8_space&lt;/code&gt; под UTF-8, и &lt;code&gt;isSPACE_LC&lt;/code&gt; при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a9c5d866ba1d6358a34fce2d9ed9c3acf7a55d6" translate="yes" xml:space="preserve">
          <source>The character set to declare in the Content-Type meta tag created by default for &lt;code&gt;html_header_tags&lt;/code&gt; . Note that this option will be ignored if the value of &lt;code&gt;html_header_tags&lt;/code&gt; is changed. Defaults to &quot;ISO-8859-1&quot;.</source>
          <target state="translated">Набор символов для объявления в метатеге Content-Type, созданном по умолчанию для &lt;code&gt;html_header_tags&lt;/code&gt; . Обратите внимание, что этот параметр будет проигнорирован при изменении значения &lt;code&gt;html_header_tags&lt;/code&gt; . По умолчанию &amp;laquo;ISO-8859-1&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="71daab686bee256e6d597c2f8159505d9e02d07d" translate="yes" xml:space="preserve">
          <source>The characters &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; are special in the L&amp;lt;...&amp;gt; context. Although the hyperlink parser does its best to determine which &quot;/&quot; is text and which is a delimiter in case of doubt, one ought to escape these literal characters like this:</source>
          <target state="translated">Персонажи &lt;code&gt;|&lt;/code&gt; и &lt;code&gt;/&lt;/code&gt; являются особенными в контексте L &amp;lt;...&amp;gt;. Хотя синтаксический анализатор гиперссылок делает все возможное, чтобы определить, какой символ &amp;laquo;/&amp;raquo; является текстом, а какой является разделителем в случае сомнений, следует избегать этих буквальных символов следующим образом:</target>
        </trans-unit>
        <trans-unit id="9e5d809d420604eb5bdc15b23bb82aec938490ad" translate="yes" xml:space="preserve">
          <source>The characters used to recall a command or spawn a shell. By default, both are set to &lt;code&gt;!&lt;/code&gt; , which is unfortunate.</source>
          <target state="translated">Символы, используемые для вызова команды или создания оболочки. По умолчанию для обоих установлено значение &lt;code&gt;!&lt;/code&gt; , что прискорбно.</target>
        </trans-unit>
        <trans-unit id="ffd9954b7982718c7437be17e29fbfd3df1a4fe1" translate="yes" xml:space="preserve">
          <source>The check routine returns the node which should be inserted into the tree (if the top-level node was not modified, check routine returns its argument).</source>
          <target state="translated">Программа проверки возвращает узел,который должен быть вставлен в дерево (если узел верхнего уровня не был изменен,то программа проверки возвращает его аргумент).</target>
        </trans-unit>
        <trans-unit id="47475762ffe9e435213b5064a86af730e143c18a" translate="yes" xml:space="preserve">
          <source>The chunk of memory which is pointed to by &lt;code&gt;p&lt;/code&gt; is Safefree()ed at the end of</source>
          <target state="translated">Фрагмент памяти, на который указывает &lt;code&gt;p&lt;/code&gt; , является Safefree () ed в конце</target>
        </trans-unit>
        <trans-unit id="16a3c0a4c50db86e628588170d93fcb36250d2c0" translate="yes" xml:space="preserve">
          <source>The class created by &lt;code&gt;struct&lt;/code&gt; must not be a subclass of another class other than &lt;code&gt;UNIVERSAL&lt;/code&gt; .</source>
          <target state="translated">Класс, созданный &lt;code&gt;struct&lt;/code&gt; не должен быть подклассом другого класса, кроме &lt;code&gt;UNIVERSAL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="232a87cc5cdc58df0837defb5b9c5d4aee8a3bd8" translate="yes" xml:space="preserve">
          <source>The class method &lt;code&gt;less-&amp;gt;of( NAME )&lt;/code&gt; returns a boolean to tell you whether your user requested less of something.</source>
          <target state="translated">Метод класса &lt;code&gt;less-&amp;gt;of( NAME )&lt;/code&gt; возвращает логическое значение, чтобы сообщить вам, запрашивал ли ваш пользователь что-то меньшее.</target>
        </trans-unit>
        <trans-unit id="94cc64c25f30949cf122aa35d8a463e7d89e7056" translate="yes" xml:space="preserve">
          <source>The class method is invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; @array, classname&lt;/code&gt; . Associates an array instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association. The method should return an object of a class which provides the methods below.</source>
          <target state="translated">Метод класса вызывается командой &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; @array, classname&lt;/code&gt; . Связывает экземпляр массива с указанным классом. &lt;code&gt;LIST&lt;/code&gt; будет представлять дополнительные аргументы (по линиям &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; и соотечественников), необходимые для завершения ассоциации. Метод должен возвращать объект класса, который предоставляет следующие методы.</target>
        </trans-unit>
        <trans-unit id="d36e86369efaf1df03cb1d3f2a6ee7366375ea68" translate="yes" xml:space="preserve">
          <source>The class methods invoked for modifying and fetching are these:</source>
          <target state="translated">Методы класса,вызываемые для модификации и извлечения,таковы:</target>
        </trans-unit>
        <trans-unit id="16f1f45dc986b853b9f9c28d5e7c510f2818ec6c" translate="yes" xml:space="preserve">
          <source>The class of the OP's SV, if it has one, in all caps (e.g., 'IV').</source>
          <target state="translated">Класс SV ОП,если он имеет один,во всех прописных буквах (например,&quot;IV&quot;).</target>
        </trans-unit>
        <trans-unit id="1a1cd2e1aca2f382b8e61ec8f61c8bcfacf6a4ed" translate="yes" xml:space="preserve">
          <source>The classic example of where callbacks are used is when writing an event driven program, such as for an X11 application. In this case you register functions to be called whenever specific events occur, e.g., a mouse button is pressed, the cursor moves into a window or a menu item is selected.</source>
          <target state="translated">Классическим примером использования обратных вызовов является запись программы,управляемой событиями,например,для приложения X11.В этом случае регистрируются функции,вызываемые при возникновении определенных событий,например,нажатие кнопки мыши,перемещение курсора в окно или выбор пункта меню.</target>
        </trans-unit>
        <trans-unit id="99430da67a315f54b20e2f72a5fd52a7326fcd42" translate="yes" xml:space="preserve">
          <source>The clobber method is simply:</source>
          <target state="translated">Клобберный метод прост:</target>
        </trans-unit>
        <trans-unit id="d62999c9944be1bb3aba520e7d0e62efb63cb438" translate="yes" xml:space="preserve">
          <source>The clone method creates a copy of the digest state object and returns a reference to the copy.</source>
          <target state="translated">Метод клонирования создает копию объекта состояния дайджеста и возвращает ссылку на копию.</target>
        </trans-unit>
        <trans-unit id="32e3ee7a8f238c3dc42124d9afe27b0f78dc70db" translate="yes" xml:space="preserve">
          <source>The code</source>
          <target state="translated">Код</target>
        </trans-unit>
        <trans-unit id="563ad7ecb10abdc47d619f7b3d0884f86cf94b31" translate="yes" xml:space="preserve">
          <source>The code above can be rearranged to get around the problem, like this:</source>
          <target state="translated">Вышеуказанный код можно переставить,чтобы обойти проблему,вот так:</target>
        </trans-unit>
        <trans-unit id="ecf14a60f040b746943a04d158c46f884d48943b" translate="yes" xml:space="preserve">
          <source>The code above uses DB_File, but again it will work with any of the DBM modules.</source>
          <target state="translated">Код выше использует DB_File,но опять же он будет работать с любым из модулей DBM.</target>
        </trans-unit>
        <trans-unit id="6d3c51612c2ccbd720904d0ac0d50a474014ffdd" translate="yes" xml:space="preserve">
          <source>The code above uses SDBM_File, but it will work with any of the DBM modules.</source>
          <target state="translated">Код выше использует SDBM_File,но он будет работать с любым из модулей DBM.</target>
        </trans-unit>
        <trans-unit id="d0ef4aba54c8ec4419ef4523d1390067d9ff6620" translate="yes" xml:space="preserve">
          <source>The code below can be used to traverse a zip file, one compressed data stream at a time.</source>
          <target state="translated">Приведенный ниже код может быть использован для прохождения через zip-файл,по одному сжатому потоку данных за раз.</target>
        </trans-unit>
        <trans-unit id="d29217257764218057a5c39c6d3e329014141e5b" translate="yes" xml:space="preserve">
          <source>The code below for</source>
          <target state="translated">Код ниже для</target>
        </trans-unit>
        <trans-unit id="1d78d26d7e9f445a9bc052e60af207768e7330c6" translate="yes" xml:space="preserve">
          <source>The code below is the example given in the section</source>
          <target state="translated">Приведенный ниже код является примером,приведенным в разделе</target>
        </trans-unit>
        <trans-unit id="6e196e9f225b5138a983bdb659d302d31a1c384a" translate="yes" xml:space="preserve">
          <source>The code below makes use of both modules, but it only enables warnings from &lt;code&gt;Derived&lt;/code&gt; .</source>
          <target state="translated">В приведенном ниже коде используются оба модуля, но разрешены только предупреждения от &lt;code&gt;Derived&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b70175bee574db6d4bbb54ae246e1319c020349" translate="yes" xml:space="preserve">
          <source>The code block introduces a new scope from the perspective of lexical variable declarations, but &lt;b&gt;not&lt;/b&gt; from the perspective of &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; and similar localizing behaviours. So later code blocks within the same pattern will still see the values which were localized in earlier blocks. These accumulated localizations are undone either at the end of a successful match, or if the assertion is backtracked (compare &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;). For example,</source>
          <target state="translated">Блок кода вводит новую область видимости с точки зрения объявления лексических переменных, но &lt;b&gt;не&lt;/b&gt; с точки зрения &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; и аналогичного поведения при локализации. Таким образом, более поздние блоки кода в рамках того же шаблона по-прежнему будут видеть значения, которые были локализованы в более ранних блоках. Эти накопленные локализации отменяются либо в конце успешного сопоставления, либо при возврате утверждения (сравните &amp;laquo; &lt;a href=&quot;#Backtracking&quot;&gt;Отслеживание с возвратом&amp;raquo;&lt;/a&gt; ). Например,</target>
        </trans-unit>
        <trans-unit id="e98d3c5b00844f7eee566f69a2fd1ffcc0553db1" translate="yes" xml:space="preserve">
          <source>The code can only see the compartment's namespace (as returned by the &lt;b&gt;root&lt;/b&gt; method). The compartment's root package appears to be the &lt;code&gt;main::&lt;/code&gt; package to the code inside the compartment.</source>
          <target state="translated">Код может видеть только пространство имен отсека (возвращаемое &lt;b&gt;корневым&lt;/b&gt; методом). Корневой пакет отсека выглядит как &lt;code&gt;main::&lt;/code&gt; package для кода внутри отсека.</target>
        </trans-unit>
        <trans-unit id="7cc1bb98d53bdcc3465bf9409e43dfe68967ea92" translate="yes" xml:space="preserve">
          <source>The code in the enclosing block has warnings enabled, but the inner block has them disabled. In this case that means the assignment to the scalar &lt;code&gt;$c&lt;/code&gt; will trip the &lt;code&gt;&quot;Scalar value @a[0] better written as $a[0]&quot;&lt;/code&gt; warning, but the assignment to the scalar &lt;code&gt;$b&lt;/code&gt; will not.</source>
          <target state="translated">В коде во включающем блоке включены предупреждения, но во внутреннем блоке они отключены. В этом случае это означает, что присвоение скаляру &lt;code&gt;$c&lt;/code&gt; вызовет &lt;code&gt;&quot;Scalar value @a[0] better written as $a[0]&quot;&lt;/code&gt; , а присвоение скаляру &lt;code&gt;$b&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="3bbef419a6073b40632618263de6b83e9a3b2f8c" translate="yes" xml:space="preserve">
          <source>The code involved in &lt;code&gt;study_chunk()&lt;/code&gt; is extremely cryptic. Be careful. :-)</source>
          <target state="translated">Код, задействованный в &lt;code&gt;study_chunk()&lt;/code&gt; , чрезвычайно загадочен. Быть осторожен. :-)</target>
        </trans-unit>
        <trans-unit id="fa55939059730530d1f6070150cdfbb84afaa7d4" translate="yes" xml:space="preserve">
          <source>The code is executed</source>
          <target state="translated">Код выполнен</target>
        </trans-unit>
        <trans-unit id="8fe7ae8735b35c106099f4a767ac8bec4145c55c" translate="yes" xml:space="preserve">
          <source>The code is executed in the package &lt;code&gt;DB&lt;/code&gt; . Note that</source>
          <target state="translated">Код выполняется в &lt;code&gt;DB&lt;/code&gt; пакета . Обратите внимание, что</target>
        </trans-unit>
        <trans-unit id="5bdd192de0a16314fb946ed4a5f124bbba34ce51" translate="yes" xml:space="preserve">
          <source>The code is hosted on Github: https://github.com/jonathanstowe/Term-Cap please feel free to fork, submit patches etc, etc there.</source>
          <target state="translated">Код размещен на Github:https://github.com/jonathanstowe/Term-Cap,пожалуйста,не стесняйтесь вилки,присылайте патчи и т.д.и т.п.там.</target>
        </trans-unit>
        <trans-unit id="6188bbd338f5f4453ec5eefb9a596ee762c4a047" translate="yes" xml:space="preserve">
          <source>The code is not optimized for speed, especially because we use &lt;code&gt;Math::Complex&lt;/code&gt; and thus go quite near complex numbers while doing the computations even when the arguments are not. This, however, cannot be completely avoided if we want things like &lt;code&gt;asin(2)&lt;/code&gt; to give an answer instead of giving a fatal runtime error.</source>
          <target state="translated">Код не оптимизирован для скорости, особенно потому, что мы используем &lt;code&gt;Math::Complex&lt;/code&gt; и, таким образом, приближаемся к комплексным числам при выполнении вычислений, даже если аргументы не являются. Однако этого нельзя полностью избежать, если мы хотим, чтобы такие вещи, как &lt;code&gt;asin(2)&lt;/code&gt; давали ответ вместо фатальной ошибки времени выполнения.</target>
        </trans-unit>
        <trans-unit id="eeb45ce8e4c72e0b27d2dd4e6b03aed6d8283a3c" translate="yes" xml:space="preserve">
          <source>The code isn't pretty as I mentioned -- I never thought it would be a 1000- line program when I started, or I might not have begun. :-) But I would have been less cavalier in how the parts of the program communicated with each other, etc. It might also have helped if I didn't have to divine the makeup of the stabs on the fly, and then account for micro differences between my compiler and gcc.</source>
          <target state="translated">Код не очень красивый,как я упоминал-я никогда не думал,что это будет 1000-строчная программа,когда я начинал,или я,возможно,не начинал.:-)Но я был бы менее бесцеремонен в том,как части программы общаются друг с другом и так далее.Также могло бы помочь,если бы мне не приходилось боготворить макияж ударов на лету,а затем учитывать микроразличия между моим компилятором и gcc.</target>
        </trans-unit>
        <trans-unit id="9e137833ea36c6bb446c1454de0e7f32827ac2db" translate="yes" xml:space="preserve">
          <source>The code reference associated with &lt;code&gt;Store&lt;/code&gt; will be called before any key/value is written to the database and the code reference associated with &lt;code&gt;Fetch&lt;/code&gt; will be called after any key/value is read from the database.</source>
          <target state="translated">Ссылка на код, связанная с &lt;code&gt;Store&lt;/code&gt; , будет вызываться перед записью любого ключа / значения в базу данных, а ссылка на код, связанная с &lt;code&gt;Fetch&lt;/code&gt; , будет вызываться после чтения любого ключа / значения из базы данных.</target>
        </trans-unit>
        <trans-unit id="9112803a8d3c96a68465b0bcde1920f2e7e6a455" translate="yes" xml:space="preserve">
          <source>The code to be parsed comes from</source>
          <target state="translated">Код,который нужно разобрать,исходит от</target>
        </trans-unit>
        <trans-unit id="ab517e2a8ba12a27ab2bbd36c075257a2d62e599" translate="yes" xml:space="preserve">
          <source>The code:</source>
          <target state="translated">Код:</target>
        </trans-unit>
        <trans-unit id="43bd0609e5f4f6c76dfb80ec0b3769b0a1ce5867" translate="yes" xml:space="preserve">
          <source>The codes generated by this module are standard terminal control codes, complying with ECMA-048 and ISO 6429 (generally referred to as &quot;ANSI color&quot; for the color codes). The non-color control codes (bold, dark, italic, underline, and reverse) are part of the earlier ANSI X3.64 standard for control sequences for video terminals and peripherals.</source>
          <target state="translated">Коды,генерируемые этим модулем,являются стандартными кодами управления терминалом,соответствующими ECMA-048 и ISO 6429 (обычно называемыми &quot;ANSI color&quot; для цветовых кодов).Нецветные коды управления (жирный,темный,курсив,подчеркивание и реверс)являются частью более раннего стандарта ANSI X3.64 для управляющих последовательностей для видеотерминалов и периферийных устройств.</target>
        </trans-unit>
        <trans-unit id="6fab56ccb009185913550effa31ed3b9edd378e9" translate="yes" xml:space="preserve">
          <source>The codesets currently supported are:</source>
          <target state="translated">В настоящее время поддерживаются кодеры:</target>
        </trans-unit>
        <trans-unit id="71e94bac38239334b6900c0a017267aa1a8ae397" translate="yes" xml:space="preserve">
          <source>The cofunctions of the hyperbolic sine, cosine, and tangent (cosech/csch and cotanh/coth are aliases)</source>
          <target state="translated">Софункции гиперболического синуса,косинуса и тангенса (косех/ши и котан/зуб-псевдонимы)</target>
        </trans-unit>
        <trans-unit id="28a5561373d2289312316102a3c2581ebe7698d3" translate="yes" xml:space="preserve">
          <source>The cofunctions of the sine, cosine, and tangent (cosec/csc and cotan/cot are aliases)</source>
          <target state="translated">Софункции синуса,косинуса и касательной (cosec/cc и cotan/cot-псевдонимы).</target>
        </trans-unit>
        <trans-unit id="4a1e9fabea4570a18aadb2a0be8b117d7c1d1876" translate="yes" xml:space="preserve">
          <source>The collective set of &lt;b&gt;environment variables&lt;/b&gt; your &lt;b&gt;process&lt;/b&gt; inherits from its parent. Accessed via &lt;code&gt;%ENV&lt;/code&gt; .</source>
          <target state="translated">Коллективный набор &lt;b&gt;переменных среды, которые&lt;/b&gt; ваш &lt;b&gt;процесс&lt;/b&gt; наследует от своего родителя. Доступ через &lt;code&gt;%ENV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54dbe0de410d1fee14f151bad669e4e7f64514b7" translate="yes" xml:space="preserve">
          <source>The color function doesn't work unless &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; is compatible with your terminal.</source>
          <target state="translated">Функция цвета не работает, если &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt; не совместим с вашим терминалом.</target>
        </trans-unit>
        <trans-unit id="d494da03d1029e001559e320101aec67b6081a14" translate="yes" xml:space="preserve">
          <source>The color stack, including the &lt;code&gt;:pushpop&lt;/code&gt; import tag, PUSHCOLOR, POPCOLOR, LOCALCOLOR, and the $Term::ANSIColor::AUTOLOCAL variable, was added in Term::ANSIColor 2.00, included in Perl 5.10.1.</source>
          <target state="translated">Цветовой стек, включая &lt;code&gt;:pushpop&lt;/code&gt; импорта : pushpop , PUSHCOLOR, POPCOLOR, LOCALCOLOR и переменную $ Term :: ANSIColor :: AUTOLOCAL, был добавлен в Term :: ANSIColor 2.00, включенный в Perl 5.10.1.</target>
        </trans-unit>
        <trans-unit id="99f186121577072655b8ffd874560fdf2ec9538e" translate="yes" xml:space="preserve">
          <source>The column at which to wrap text on the right-hand side. Defaults to 76, unless &lt;b&gt;-t&lt;/b&gt; is given, in which case it's two columns less than the width of your terminal device.</source>
          <target state="translated">Столбец для переноса текста в правой части. По умолчанию 76, если не указано &lt;b&gt;-t&lt;/b&gt; , и в этом случае это на два столбца меньше ширины вашего оконечного устройства.</target>
        </trans-unit>
        <trans-unit id="dc0da64614756f754ff954c33b5269fabc02fce0" translate="yes" xml:space="preserve">
          <source>The column at which to wrap text on the right-hand side. Defaults to 76.</source>
          <target state="translated">Столбец,в который следует обернуть текст справа.По умолчанию 76.</target>
        </trans-unit>
        <trans-unit id="e8623930908f634360f3d6d3225f352295877e28" translate="yes" xml:space="preserve">
          <source>The combination of &lt;code&gt;//g&lt;/code&gt; and &lt;code&gt;\G&lt;/code&gt; allows us to process the string a bit at a time and use arbitrary Perl logic to decide what to do next. Currently, the &lt;code&gt;\G&lt;/code&gt; anchor is only fully supported when used to anchor to the start of the pattern.</source>
          <target state="translated">Комбинация &lt;code&gt;//g&lt;/code&gt; и &lt;code&gt;\G&lt;/code&gt; позволяет нам обрабатывать строку понемногу и использовать произвольную логику Perl, чтобы решить, что делать дальше. В настоящее время привязка &lt;code&gt;\G&lt;/code&gt; полностью поддерживается только тогда, когда она используется для привязки к началу шаблона.</target>
        </trans-unit>
        <trans-unit id="970e7f15d0c6ab9e35629ba58fe853786b66b02c" translate="yes" xml:space="preserve">
          <source>The combination of multiple command- line switches (</source>
          <target state="translated">Комбинация из нескольких переключателей командной строки (</target>
        </trans-unit>
        <trans-unit id="e655e997e08648320978a6ff86ae273d24047f81" translate="yes" xml:space="preserve">
          <source>The combined effect of 3 &amp;amp; 4 is that it will allow code which uses the &lt;code&gt;warnings&lt;/code&gt; pragma to control the warning behavior of $^W-type code (using a &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $^W=0&lt;/code&gt; ) if it really wants to, but not vice-versa.</source>
          <target state="translated">Комбинированный эффект 3 и 4 заключается в том, что он позволяет коду, который использует прагму &lt;code&gt;warnings&lt;/code&gt; управлять поведением предупреждений кода типа $ ^ W (с использованием &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $^W=0&lt;/code&gt; ), если он действительно этого хочет, но не наоборот. наоборот.</target>
        </trans-unit>
        <trans-unit id="c5195e2f756a78470c45dda1ae8fbd38d00cbe08" translate="yes" xml:space="preserve">
          <source>The command &quot;=for</source>
          <target state="translated">Команда &quot;=для</target>
        </trans-unit>
        <trans-unit id="3d8aeb4458c1560b0d5ab2e46d755733e3bb6324" translate="yes" xml:space="preserve">
          <source>The command does not start.</source>
          <target state="translated">Команда не запускается.</target>
        </trans-unit>
        <trans-unit id="7e6f4f93a21a7f88a65ff2221b6911802d75f842" translate="yes" xml:space="preserve">
          <source>The command is killed by a signal.</source>
          <target state="translated">Команда уничтожена сигналом.</target>
        </trans-unit>
        <trans-unit id="914be5b158c3cc5be779f3d3fed5d23185a3c4a4" translate="yes" xml:space="preserve">
          <source>The command line interface is tightly integrated with an &lt;b&gt;emacs&lt;/b&gt; extension and there's a &lt;b&gt;vi&lt;/b&gt; interface too.</source>
          <target state="translated">Интерфейс командной строки тесно интегрирован с расширением &lt;b&gt;emacs, также&lt;/b&gt; есть интерфейс &lt;b&gt;vi&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="f789ad4d35bca82f26a9236e86bce7a57e057b98" translate="yes" xml:space="preserve">
          <source>The command line is not split by GetOptions, but by the command line interpreter (CLI). On Unix, this is the shell. On Windows, it is COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.</source>
          <target state="translated">Командная строка разделена не GetOptions,а интерпретатором командной строки (CLI).В Unix это оболочка.В Windows это COMMAND.COM или CMD.EXE.В других операционных системах есть и другие CLI.</target>
        </trans-unit>
        <trans-unit id="a12dc653b968ec55d9bfea4484d747acafd8c027" translate="yes" xml:space="preserve">
          <source>The command returns a non-zero exit value (but see below).</source>
          <target state="translated">Команда возвращает ненулевое значение выхода (но см.ниже).</target>
        </trans-unit>
        <trans-unit id="ccf7fbf7b3dd60fe57ca23a7e47b3c4eeb05e932" translate="yes" xml:space="preserve">
          <source>The command used to load the debugger code. The default is:</source>
          <target state="translated">Команда,используемая для загрузки кода отладчика.По умолчанию:</target>
        </trans-unit>
        <trans-unit id="35175a977556088d11ca4a7b0e7332f1ce787324" translate="yes" xml:space="preserve">
          <source>The command's STDOUT and STDERR (and possibly STDIN, depending on your shell) will be the same as the parent's. You won't need to catch SIGCHLD because of the double-fork taking place; see below for details.</source>
          <target state="translated">Команды STDOUT и STDERR (и,возможно,STDIN,в зависимости от вашей оболочки)будут такими же,как и у родителя.Вам не нужно будет ловить SIGCHLD из-за того,что происходит двойная вилка;подробности смотрите ниже.</target>
        </trans-unit>
        <trans-unit id="75337684a9346d140506f8cf5d632c3a6fe46276" translate="yes" xml:space="preserve">
          <source>The command-line mentioned in the SYNOPSIS section corresponds to the Perl code</source>
          <target state="translated">Командная строка,упомянутая в разделе SYNOPSIS,соответствует коду Perl</target>
        </trans-unit>
        <trans-unit id="ea72136c38b086284678c74c52f83815bf874db4" translate="yes" xml:space="preserve">
          <source>The commands &lt;code&gt;=pod&lt;/code&gt; and &lt;code&gt;=cut&lt;/code&gt; do not take any arguments.</source>
          <target state="translated">Команды &lt;code&gt;=pod&lt;/code&gt; и &lt;code&gt;=cut&lt;/code&gt; не принимают никаких аргументов.</target>
        </trans-unit>
        <trans-unit id="f1e3cdc1d66a6ddbc94785be80a34d0a817fb94d" translate="yes" xml:space="preserve">
          <source>The commands available in the shell interface are methods in the package CPAN::Shell. If you enter the shell command, your input is split by the Text::ParseWords::shellwords() routine, which acts like most shells do. The first word is interpreted as the method to be invoked, and the rest of the words are treated as the method's arguments. Continuation lines are supported by ending a line with a literal backslash.</source>
          <target state="translated">Команды,доступные в интерфейсе оболочки,являются методами из пакета CPAN::Shell.Если вы вводите команду оболочки,ваш ввод разделен рутиной Text::ParseWords::shellwords(),которая действует,как большинство оболочек.Первое слово интерпретируется как метод для вызова,а остальные слова рассматриваются как аргументы метода.Строки продолжения поддерживаются завершением строки буквенным обратным слешем.</target>
        </trans-unit>
        <trans-unit id="50c172c64b8304a2667bbd4145cf67a46b69892f" translate="yes" xml:space="preserve">
          <source>The commit message should include a description of the problem that the patch corrects or new functionality that the patch adds.</source>
          <target state="translated">Сообщение о фиксации должно содержать описание проблемы,которую исправляет патч,или новой функциональности,которую добавляет патч.</target>
        </trans-unit>
        <trans-unit id="a48a6b9a39f2c1e8f05ac68afbc7708f295daa69" translate="yes" xml:space="preserve">
          <source>The common (and original) usage of B::Concise was for command-line renderings of simple code, as given in EXAMPLE. But you can also use &lt;b&gt;B::Concise&lt;/b&gt; from your code, and call compile() directly, and repeatedly. By doing so, you can avoid the compile-time only operation of O.pm, and even use the debugger to step through B::Concise::compile() itself.</source>
          <target state="translated">Обычно (и исходно) B :: Concise использовался для рендеринга простого кода из командной строки, как указано в ПРИМЕРЕ. Но вы также можете использовать &lt;b&gt;B :: Concise&lt;/b&gt; из своего кода и вызывать compile () напрямую и многократно. Поступая так, вы можете избежать операции O.pm только во время компиляции и даже использовать отладчик для пошагового выполнения самой B :: Concise :: compile ().</target>
        </trans-unit>
        <trans-unit id="092b88432af421400f5d15e398af7e25459b6caf" translate="yes" xml:space="preserve">
          <source>The comparison function is required to behave. If it returns inconsistent results (sometimes saying &lt;code&gt;$x[1]&lt;/code&gt; is less than &lt;code&gt;$x[2]&lt;/code&gt; and sometimes saying the opposite, for example) the results are not well-defined.</source>
          <target state="translated">Функция сравнения должна работать. Если он возвращает противоречивые результаты (иногда говорят, что &lt;code&gt;$x[1]&lt;/code&gt; меньше, чем &lt;code&gt;$x[2]&lt;/code&gt; а иногда, например, говорят обратное), результаты не являются четко определенными.</target>
        </trans-unit>
        <trans-unit id="edfa309c58fb1bf1eba2e1c0e1a54aa1aefcb60b" translate="yes" xml:space="preserve">
          <source>The compilation of a subroutine can be affected by a few compiler directives, &lt;b&gt;pragmas&lt;/b&gt;. These are:</source>
          <target state="translated">На компиляцию подпрограммы могут влиять несколько директив компилятора, &lt;b&gt;прагм&lt;/b&gt; . Эти:</target>
        </trans-unit>
        <trans-unit id="ecde94171862ef8b275c6d67c44a792fcd8d5efd" translate="yes" xml:space="preserve">
          <source>The compile tree is executed in a runops function. There are two runops functions, in</source>
          <target state="translated">Дерево компиляции выполняется в функции runops.Существует две функции рун,в</target>
        </trans-unit>
        <trans-unit id="79a77bf1e2569d28ea6eda34147b4768d49e28ad" translate="yes" xml:space="preserve">
          <source>The compiler will search for typemap files called</source>
          <target state="translated">Компилятор будет искать файлы типовых карт с именами</target>
        </trans-unit>
        <trans-unit id="111471390604961ec6523ced1b372373b53d8003" translate="yes" xml:space="preserve">
          <source>The compiler would immediately flag that as an error</source>
          <target state="translated">Компилятор сразу же поставит флаг,что в качестве ошибки</target>
        </trans-unit>
        <trans-unit id="89f4eed42cf9fec88c7f54948d286e3b27120ba8" translate="yes" xml:space="preserve">
          <source>The complementary error function [C99].</source>
          <target state="translated">Функция дополнительной ошибки [C99].</target>
        </trans-unit>
        <trans-unit id="ed6f778f02ef1fa177aa048ce5ee5aeaef666a7f" translate="yes" xml:space="preserve">
          <source>The complete Perl documentation is available with the Perl distribution. If you have Perl installed locally, you probably have the documentation installed as well: type &lt;code&gt;perldoc perl&lt;/code&gt; in a terminal or &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fperldoc.perl.org%2fperl.html&quot;&gt;view online&lt;/a&gt;.</source>
          <target state="translated">Полная документация Perl доступна в дистрибутиве Perl. Если у вас установлен Perl локально, возможно, у вас также установлена ​​документация: введите &lt;code&gt;perldoc perl&lt;/code&gt; в терминале или &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fperldoc.perl.org%2fperl.html&quot;&gt;просмотрите в Интернете&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="068df1cb71064dd3af102dcffe784783c3c8d76f" translate="yes" xml:space="preserve">
          <source>The complete array will be walked to ensure that it only contains valid filenames before any data is compressed.</source>
          <target state="translated">Полный массив будет обходить,чтобы убедиться,что он содержит только действительные имена файлов,прежде чем любые данные будут сжаты.</target>
        </trans-unit>
        <trans-unit id="3bc7e120c73e8eddc193ee78a2c4c1f364b17641" translate="yes" xml:space="preserve">
          <source>The complete array will be walked to ensure that it only contains valid filenames before any data is uncompressed.</source>
          <target state="translated">Полный массив будет обходить,чтобы убедиться,что он содержит только действительные имена файлов,прежде чем любые данные будут распакованы.</target>
        </trans-unit>
        <trans-unit id="98b6ca723bf0fecfbf2258563e5ac721bc8076d0" translate="yes" xml:space="preserve">
          <source>The complete list of keys that can be specified in the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive are given, separated by spaces, in the values of the hash &lt;code&gt;%overload::ops&lt;/code&gt; :</source>
          <target state="translated">Полный список ключей, которые могут быть указаны в директиве &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; , дается через пробел в значениях хэша &lt;code&gt;%overload::ops&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="52c281d1dec7eebd9b6bf4d9cf26bf4311a392cc" translate="yes" xml:space="preserve">
          <source>The complete table can be found in the Sun Managers' FAQ &lt;a href=&quot;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&quot;&gt;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&lt;/a&gt; under &quot;9.1) Which Sun models run which versions of SunOS?&quot;.</source>
          <target state="translated">Полную таблицу можно найти в FAQ менеджеров Sun &lt;a href=&quot;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&quot;&gt;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq в&lt;/a&gt; разделе &amp;laquo;9.1) Какие модели Sun работают с какими версиями SunOS?&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="243520c31a219c7d1aad4ef85de5d88764701e20" translate="yes" xml:space="preserve">
          <source>The completion character &amp;lt;tab&amp;gt; cannot be changed.</source>
          <target state="translated">Знак завершения &amp;lt;tab&amp;gt; нельзя изменить.</target>
        </trans-unit>
        <trans-unit id="57f8fbb5c61dbf32a6295f7091431384e77ad0b9" translate="yes" xml:space="preserve">
          <source>The complicated syntaxes of this code are discussed at length in &lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;Formatting Codes in perlpod&lt;/a&gt;, and implementation details are discussed below, in &lt;a href=&quot;#About-L%3c...%3e-Codes&quot;&gt;About L&amp;lt;...&amp;gt; Codes&lt;/a&gt;. Parsing the contents of L&amp;lt;content&amp;gt; is tricky. Notably, the content has to be checked for whether it looks like a URL, or whether it has to be split on literal &quot;|&quot; and/or &quot;/&quot; (in the right order!), and so on,</source>
          <target state="translated">Сложный синтаксис этого кода подробно обсуждается в &lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;разделе &amp;laquo;Коды форматирования в perlpod&amp;raquo;&lt;/a&gt; , а подробности реализации обсуждаются ниже в разделе &amp;laquo; &lt;a href=&quot;#About-L%3c...%3e-Codes&quot;&gt;О кодах L &amp;lt;...&amp;gt;&amp;raquo;&lt;/a&gt; . Разбирать содержимое L &amp;lt;content&amp;gt; сложно. Примечательно, что содержимое должно быть проверено на предмет того, выглядит ли оно как URL-адрес или его нужно разделить на буквальный символ &quot;|&quot; и / или &quot;/&quot; (в правильном порядке!) и т. д.,</target>
        </trans-unit>
        <trans-unit id="3e080e954af33f166a94bcfa488743e85b7e060c" translate="yes" xml:space="preserve">
          <source>The compound way of writing these is like &lt;code&gt;\p{General_Category=Number}&lt;/code&gt; (short: &lt;code&gt;\p{gc:n}&lt;/code&gt; ). But Perl furnishes shortcuts in which everything up through the equal or colon separator is omitted. So you can instead just write &lt;code&gt;\pN&lt;/code&gt; .</source>
          <target state="translated">Составной способ их записи выглядит как &lt;code&gt;\p{General_Category=Number}&lt;/code&gt; (сокращенно: &lt;code&gt;\p{gc:n}&lt;/code&gt; ). Но Perl предоставляет сокращения, в которых опускается все, что до разделителя равно или двоеточия. Вместо этого вы можете просто написать &lt;code&gt;\pN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4be8f3e8beb322b0e55f10e2929087827e8f380" translate="yes" xml:space="preserve">
          <source>The computer on which a program or other data resides.</source>
          <target state="translated">Компьютер,на котором находится программа или другие данные.</target>
        </trans-unit>
        <trans-unit id="cfcbad8d7cd3118bc2c84750149f972c9d76bac3" translate="yes" xml:space="preserve">
          <source>The concatenation operator is &quot;.&quot;, not the null string. (Using the null string would render &lt;code&gt;/pat/ /pat/&lt;/code&gt; unparsable, because the third slash would be interpreted as a division operator--the tokenizer is in fact slightly context sensitive for operators like &quot;/&quot;, &quot;?&quot;, and &quot;&amp;gt;&quot;. And in fact, &quot;.&quot; itself can be the beginning of a number.)</source>
          <target state="translated">Оператор конкатенации - &amp;laquo;.&amp;raquo;, А не пустая строка. (Использование нулевой строки сделает &lt;code&gt;/pat/ /pat/&lt;/code&gt; неразборчивым, потому что третья косая черта будет интерпретироваться как оператор деления - токенизатор на самом деле немного контекстно-зависимый для таких операторов, как &amp;laquo;/&amp;raquo;, &amp;laquo;?&amp;raquo; И &amp;laquo;&amp;gt; &quot;. И на самом деле&quot;. &quot;Может быть началом числа.)</target>
        </trans-unit>
        <trans-unit id="7397c296c9007588d87f382f9ceff5394823ef48" translate="yes" xml:space="preserve">
          <source>The concise style uses symbols to convey maximum info with minimal clutter (like hex addresses). With just a little practice, you can start to see the flowers, not just the branches, in the trees.</source>
          <target state="translated">Краткий стиль использует символы для передачи максимальной информации с минимальным нагромождением (например,шестнадцатеричные адреса).С помощью небольшой практики вы можете начать видеть цветы,а не только ветви,на деревьях.</target>
        </trans-unit>
        <trans-unit id="d9749679dc3561ae81ba863d8e80238321089767" translate="yes" xml:space="preserve">
          <source>The concrete formatter must implement</source>
          <target state="translated">Конкретное формообразующее средство должно реализовывать</target>
        </trans-unit>
        <trans-unit id="ec6253a94addb83f76f25a71c4752860278fa23c" translate="yes" xml:space="preserve">
          <source>The conditions can be any Perl expression. See the list of operators in the next section for information on comparison and boolean logic operators, which are commonly used in conditional statements.</source>
          <target state="translated">Условиями могут быть любые выражения на Perl.Информацию о сравнительных и булевых логических операторах,которые обычно используются в условных операторах,смотрите в списке операторов в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="543b88d3ab70df9ad92d2d1112ca25224746b1f5" translate="yes" xml:space="preserve">
          <source>The configuration data is held globally in a file in the perl installation tree, but a user may override any of these values by providing their own. This can be done by having a &lt;code&gt;.libnetrc&lt;/code&gt; file in their home directory. This file should return a reference to a HASH containing the keys described below. For example</source>
          <target state="translated">Данные конфигурации хранятся глобально в файле в дереве установки Perl, но пользователь может переопределить любое из этих значений, указав свое собственное. Это можно сделать, имея файл &lt;code&gt;.libnetrc&lt;/code&gt; в их домашнем каталоге. Этот файл должен возвращать ссылку на HASH, содержащий ключи, описанные ниже. Например</target>
        </trans-unit>
        <trans-unit id="9a78f97fbb5cf4075595c0b03128bde7af0266c1" translate="yes" xml:space="preserve">
          <source>The configuration dialog can be started any time later again by issuing the command &lt;code&gt; o conf init &lt;/code&gt; in the CPAN shell. A subset of the configuration dialog can be run by issuing &lt;code&gt;o conf init WORD&lt;/code&gt; where WORD is any valid config variable or a regular expression.</source>
          <target state="translated">Диалог конфигурации можно снова запустить в любое время позже, введя команду &lt;code&gt; o conf init &lt;/code&gt; в оболочке CPAN. Подмножество диалогового окна конфигурации можно запустить, &lt;code&gt;o conf init WORD&lt;/code&gt; команду o conf init WORD, где WORD - любая допустимая переменная конфигурации или регулярное выражение.</target>
        </trans-unit>
        <trans-unit id="b4c7562be2672acce7fe43e87808c7f47379f387" translate="yes" xml:space="preserve">
          <source>The configuration parameter check_sigs is there to turn signature checking on or off.</source>
          <target state="translated">В конфигурационном параметре check_sigs предусмотрена возможность включения или выключения проверки сигнатур.</target>
        </trans-unit>
        <trans-unit id="92e8c71c043d1ee5895cf5c5a239168a7f0a8975" translate="yes" xml:space="preserve">
          <source>The confusion arises because people incorrectly assume that the sigil denotes the variable type.</source>
          <target state="translated">Путаница возникает из-за того,что люди ошибочно полагают,что знак обозначает тип переменной.</target>
        </trans-unit>
        <trans-unit id="72def2ab61e0c7e7dccd965b3f9393136d20aa03" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;pi&lt;/code&gt; and some handy multiples of it (pi2, pi4, and pip2 (pi/2) and pip4 (pi/4)) are also available if separately exported:</source>
          <target state="translated">Константа &lt;code&gt;pi&lt;/code&gt; и некоторые удобные кратные ей (pi2, pi4 и pip2 (pi / 2) и pip4 (pi / 4)) также доступны при отдельном экспорте:</target>
        </trans-unit>
        <trans-unit id="c81821f9e03375c52f91dde5667119328458dcfd" translate="yes" xml:space="preserve">
          <source>The constant function &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; returns a comparable number that represents the highest file version number that this version of Storable fully supports (but see discussion of &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; above). The constant &lt;code&gt;Storable::BIN_WRITE_VERSION_NV&lt;/code&gt; function returns what file version is written and might be less than &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; in some configurations.</source>
          <target state="translated">Постоянная функция &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; возвращает сопоставимое число, которое представляет наивысший номер версии файла, который полностью поддерживает эта версия Storable (но см. Обсуждение &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; выше). Постоянная &lt;code&gt;Storable::BIN_WRITE_VERSION_NV&lt;/code&gt; возвращает версию записанного файла и может быть меньше, чем &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; в некоторых конфигурациях.</target>
        </trans-unit>
        <trans-unit id="9018d00ba0cf85500f9049cabc293077c6a815d2" translate="yes" xml:space="preserve">
          <source>The construct</source>
          <target state="translated">Конструкция</target>
        </trans-unit>
        <trans-unit id="8226460345430ec3df47c2bd35c2d238766995a6" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;\$v{timep}=@{[$v{timep}=$arg]}&lt;/code&gt; used in the above example has a two-fold purpose: first, when this line is processed by &lt;b&gt;xsubpp&lt;/b&gt;, the Perl snippet &lt;code&gt;$v{timep}=$arg&lt;/code&gt; is evaluated. Second, the text of the evaluated snippet is output into the generated C file (inside a C comment)! During the processing of &lt;code&gt;char *host&lt;/code&gt; line, &lt;code&gt;$arg&lt;/code&gt; will evaluate to &lt;code&gt;ST(0)&lt;/code&gt; , and &lt;code&gt;$v{timep}&lt;/code&gt; will evaluate to &lt;code&gt;ST(1)&lt;/code&gt; .</source>
          <target state="translated">Конструкция &lt;code&gt;\$v{timep}=@{[$v{timep}=$arg]}&lt;/code&gt; используемая в приведенном выше примере, имеет &lt;b&gt;двоякое&lt;/b&gt; назначение: во-первых, когда эта строка обрабатывается &lt;b&gt;xsubpp&lt;/b&gt; , фрагмент Perl &lt;code&gt;$v{timep}=$arg&lt;/code&gt; вычисляется $ arg . Во-вторых, текст оцененного фрагмента выводится в сгенерированный файл C (внутри комментария C)! Во время обработки строки &lt;code&gt;char *host&lt;/code&gt; &lt;code&gt;$arg&lt;/code&gt; будет оценивать как &lt;code&gt;ST(0)&lt;/code&gt; , а &lt;code&gt;$v{timep}&lt;/code&gt; будет оценивать как &lt;code&gt;ST(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b59007854896f819ee065a798da86e7867bce96e" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;new&lt;/code&gt; creates and returns an empty &lt;code&gt;TAP::Parser::YAMLish::Reader&lt;/code&gt; object.</source>
          <target state="translated">Конструктор &lt;code&gt;new&lt;/code&gt; создает и возвращает пустой объект &lt;code&gt;TAP::Parser::YAMLish::Reader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bad8668cdf1d431ad701326f6748ece18b79658" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;new&lt;/code&gt; creates and returns an empty &lt;code&gt;TAP::Parser::YAMLish::Writer&lt;/code&gt; object.</source>
          <target state="translated">Конструктор &lt;code&gt;new&lt;/code&gt; создает и возвращает пустой объект &lt;code&gt;TAP::Parser::YAMLish::Writer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c2fcf35a44aabf097cd59f3a3854953c70e5fcd" translate="yes" xml:space="preserve">
          <source>The constructor can also accept additional parameters that define the object. Let's write a real constructor for the &lt;code&gt;File&lt;/code&gt; class we used earlier:</source>
          <target state="translated">Конструктор также может принимать дополнительные параметры, определяющие объект. Напишем реальный конструктор для класса &lt;code&gt;File&lt;/code&gt; ,который мы использовали ранее:</target>
        </trans-unit>
        <trans-unit id="3a88176407788666ff0021721dd4e56b3400cf3f" translate="yes" xml:space="preserve">
          <source>The constructor creates a new object and optionally initialises it with a set of handles.</source>
          <target state="translated">Конструктор создает новый объект и опционально инициализирует его набором дескрипторов.</target>
        </trans-unit>
        <trans-unit id="26002f2b8ad63b7adc28307355437aa48afa5d7b" translate="yes" xml:space="preserve">
          <source>The constructor for a &lt;code&gt;Net::Netrc&lt;/code&gt; object is not called new as it does not really create a new object. But instead is called &lt;code&gt;lookup&lt;/code&gt; as this is essentially what it does.</source>
          <target state="translated">Конструктор для объекта &lt;code&gt;Net::Netrc&lt;/code&gt; не называется новым, поскольку на самом деле он не создает новый объект. Но вместо этого это называется &lt;code&gt;lookup&lt;/code&gt; как это по сути то, что он делает.</target>
        </trans-unit>
        <trans-unit id="5e4047980f5ac3eb3127d3d68b5f254e9299a0fd" translate="yes" xml:space="preserve">
          <source>The constructor for all the singletons used to represent modules, distributions, authors, and bundles. If the object already exists, this method returns the object; otherwise, it calls the constructor.</source>
          <target state="translated">Конструктор для всех синглонов,используемых для представления модулей,дистрибутивов,авторов и связок.Если объект уже существует,то этот метод возвращает объект;в противном случае он вызывает конструктор.</target>
        </trans-unit>
        <trans-unit id="a54cf785d15de998f3ac18ade864f218319b1ee1" translate="yes" xml:space="preserve">
          <source>The constructor of a generated class can be passed a list of</source>
          <target state="translated">Конструктору сгенерированного класса может быть передан список</target>
        </trans-unit>
        <trans-unit id="bb7df7aab984a9c0e691c8f805de279350cf56e0" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;Digest::MD5&lt;/code&gt; object which encapsulate the state of the MD5 message-digest algorithm.</source>
          <target state="translated">Конструктор возвращает новый объект &lt;code&gt;Digest::MD5&lt;/code&gt; который инкапсулирует состояние алгоритма дайджеста сообщения MD5.</target>
        </trans-unit>
        <trans-unit id="2e6b2441df01bfc969fd7dfde15484f966dcaf52" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Color&lt;/code&gt; object. If &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; is not installed, returns undef.</source>
          <target state="translated">Конструктор возвращает новый объект &lt;code&gt;TAP::Formatter::Color&lt;/code&gt; . Если &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt; не установлен, возвращает undef.</target>
        </trans-unit>
        <trans-unit id="972195b07373ba2fa384173c37fb399dc7626fb1" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Console::Session&lt;/code&gt; object.</source>
          <target state="translated">Конструктор возвращает новый объект &lt;code&gt;TAP::Formatter::Console::Session&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64d08d3b354e3667ab5da2f82eaec44dd6d25ea5" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; object. If a &lt;a href=&quot;../harness&quot;&gt;TAP::Harness&lt;/a&gt; is created with no &lt;code&gt;formatter&lt;/code&gt; a &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; is automatically created. If any of the following options were given to TAP::Harness-&amp;gt;new they well be passed to this constructor which accepts an optional hashref whose allowed keys are:</source>
          <target state="translated">Конструктор возвращает новый объект &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; . Если &lt;a href=&quot;../harness&quot;&gt;TAP :: Harness&lt;/a&gt; не создается с не &lt;code&gt;formatter&lt;/code&gt; в &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; автоматически создается. Если для TAP :: Harness-&amp;gt; new были заданы какие-либо из следующих параметров, они должны быть переданы этому конструктору, который принимает дополнительный хэш-адрес, разрешенные ключи которого:</target>
        </trans-unit>
        <trans-unit id="cdf8ec5d8f9e8688b8b1e013d18928a0b5fdbbeb" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Harness&lt;/code&gt; object. It accepts an optional hashref whose allowed keys are:</source>
          <target state="translated">Конструктор возвращает новый объект &lt;code&gt;TAP::Harness&lt;/code&gt; . Он принимает необязательный хэш-адрес, разрешенные ключи которого:</target>
        </trans-unit>
        <trans-unit id="093c7ac00d4bfb4c1a8deee532d1b8ad2334e8c0" translate="yes" xml:space="preserve">
          <source>The constructor returns some object that encapsulate the state of the message-digest algorithm. You can add data to the object and finally ask for the digest. The &quot;XXX&quot; should of course be replaced by the proper name of the digest algorithm you want to use.</source>
          <target state="translated">Конструктор возвращает некоторый объект,который инкапсулирует состояние самого дайджеста сообщений.Вы можете добавить данные к объекту и,наконец,запросить дайджест.Разумеется,&quot;XXX&quot; должно быть заменено на правильное имя алгоритма дайджеста,который вы хотите использовать.</target>
        </trans-unit>
        <trans-unit id="f4ebdab724a22632fec3a1d054882b1bc817c7d6" translate="yes" xml:space="preserve">
          <source>The content of the here doc is treated just as it would be if the string were embedded in backticks. Thus the content is interpolated as though it were double quoted and then executed via the shell, with the results of the execution returned.</source>
          <target state="translated">Содержимое этого документа обрабатывается так же,как если бы строка была встроена в бэк-стик.Таким образом,содержимое интерполируется так,как если бы оно было заключено в двойные кавычки,а затем выполняется через оболочку,при этом возвращаются результаты выполнения.</target>
        </trans-unit>
        <trans-unit id="6af50a9986dd8fc345d5bd2a482a8608eafdf212" translate="yes" xml:space="preserve">
          <source>The content of the text chunk in the buffer is commonly exactly one complete line of input, up to and including a newline terminator, but there are situations where it is otherwise. The octets of the buffer may be intended to be interpreted as either UTF-8 or Latin-1. The function &lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt; tells you which. Do not use the &lt;code&gt;SvUTF8&lt;/code&gt; flag on this scalar, which may disagree with it.</source>
          <target state="translated">Содержимое фрагмента текста в буфере обычно представляет собой ровно одну полную строку ввода, вплоть до символа конца строки включительно, но бывают ситуации, когда это бывает иначе. Октеты буфера могут быть интерпретированы как UTF-8 или Latin-1. Функция &lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt; сообщает вам, какие именно. Не используйте флаг &lt;code&gt;SvUTF8&lt;/code&gt; на этом скаляре , который может с ним не согласиться.</target>
        </trans-unit>
        <trans-unit id="3c50b9c6cd39ffa60fa752e0357613216ec7e1d3" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;$/&lt;/code&gt; are used to determine what constitutes a line terminator.</source>
          <target state="translated">Содержимое &lt;code&gt;$/&lt;/code&gt; используется для определения признака конца строки.</target>
        </trans-unit>
        <trans-unit id="18d18ed7c7a8db27a58a80fd58640cc3bbfe1bce" translate="yes" xml:space="preserve">
          <source>The contents of the Comment header field, if present. If no comment is present, the value will be undef. Note this is different from a zero length comment, which will return an empty string.</source>
          <target state="translated">Содержимое поля заголовка комментария,если таковое имеется.Если комментарий отсутствует,значение будет недоступно.Обратите внимание,что это отличается от комментария нулевой длины,который вернет пустую строку.</target>
        </trans-unit>
        <trans-unit id="f67589a8aeaaf0494de7c02234d42e486e771e87" translate="yes" xml:space="preserve">
          <source>The contents of the Name header field, if present. If no name is present, the value will be undef. Note this is different from a zero length name, which will return an empty string.</source>
          <target state="translated">Содержимое поля заголовка &quot;Имя&quot;,если таковое имеется.Если имя отсутствует,значение будет недоступно.Обратите внимание,что это отличается от имени нулевой длины,которое вернет пустую строку.</target>
        </trans-unit>
        <trans-unit id="9456b1413183ce2a7cacbf69ac958ec33df9e078" translate="yes" xml:space="preserve">
          <source>The contents of the above &quot;=begin :yetanotherformat&quot; ... &quot;=end :yetanotherformat&quot; region</source>
          <target state="translated">Содержание вышеприведенного &quot;=начало :yetanotherformat&quot; ...&quot;=завершить :yetanotherformat&quot; ...</target>
        </trans-unit>
        <trans-unit id="7bdc8b3d3c8ea3698e851bea6c870ef22be74842" translate="yes" xml:space="preserve">
          <source>The contents of the string are split into arguments using a call to &lt;code&gt;Text::ParseWords::shellwords&lt;/code&gt; . As with &lt;code&gt;GetOptionsFromArray&lt;/code&gt; , the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched.</source>
          <target state="translated">Содержимое строки разделяется на аргументы с помощью вызова &lt;code&gt;Text::ParseWords::shellwords&lt;/code&gt; . Как и в случае с &lt;code&gt;GetOptionsFromArray&lt;/code&gt; , глобальный &lt;code&gt;@ARGV&lt;/code&gt; не затрагивается.</target>
        </trans-unit>
        <trans-unit id="ee0a191734836657a10b5b7b1f37002c95e61a13" translate="yes" xml:space="preserve">
          <source>The contents of the string changes, but not the nature of the string. Perl doesn't know any more after the call than before that the contents of the string indicates the affirmative.</source>
          <target state="translated">Меняется содержимое строки,но не ее природа.Perl не знает после вызова больше,чем до того,что содержимое строки указывает на утвердительность.</target>
        </trans-unit>
        <trans-unit id="fa23695f3fe9b71ce5ed23d56ccd05be2c1e1b36" translate="yes" xml:space="preserve">
          <source>The contents should be an integer; different bits of it are used for different pragmatic flags. Here's an example:</source>
          <target state="translated">Содержимое должно быть целым числом,разные его биты используются для разных прагматических флагов.Вот пример:</target>
        </trans-unit>
        <trans-unit id="29b067c45824f7dfd004988f65509a605101a269" translate="yes" xml:space="preserve">
          <source>The context (void, scalar or list) for the return value(s) for &lt;code&gt;-&amp;gt;join()&lt;/code&gt; is determined at the time of thread creation.</source>
          <target state="translated">Контекст (void, скаляр или список) для возвращаемых значений для &lt;code&gt;-&amp;gt;join()&lt;/code&gt; определяется во время создания потока.</target>
        </trans-unit>
        <trans-unit id="cafef0e58c037c46bb556fc0f1a1471183c9edb3" translate="yes" xml:space="preserve">
          <source>The context type may also be used as the</source>
          <target state="translated">Тип контекста может также использоваться в качестве</target>
        </trans-unit>
        <trans-unit id="cd3e46d3e11cb302e5746c299ddd22b0f06326e3" translate="yes" xml:space="preserve">
          <source>The context-free version of Perl_warner is called Perl_warner_nocontext, and does not take the extra argument. Instead it does dTHX; to get the context from thread-local storage. We &lt;code&gt;#define warner Perl_warner_nocontext&lt;/code&gt; so that extensions get source compatibility at the expense of performance. (Passing an arg is cheaper than grabbing it from thread-local storage.)</source>
          <target state="translated">Контекстно-свободная версия Perl_warner называется Perl_warner_nocontext и не принимает дополнительный аргумент. Вместо этого он делает dTHX; чтобы получить контекст из локального хранилища потока. Мы &lt;code&gt;#define warner Perl_warner_nocontext&lt;/code&gt; , чтобы расширения получали исходную совместимость за счет производительности. (Передача аргумента дешевле, чем его получение из локального хранилища потока.)</target>
        </trans-unit>
        <trans-unit id="a306525389293789c4d3b564d2695ad27f640911" translate="yes" xml:space="preserve">
          <source>The conversion from Perl to C is left as an exercise to the reader, but the prototype would be:</source>
          <target state="translated">Преобразование из Perl в C оставлено как упражнение для читателя,но прототипом будет:</target>
        </trans-unit>
        <trans-unit id="5dab7a329fdfbc3426218724b9a43e87edffc6ee" translate="yes" xml:space="preserve">
          <source>The copy constructor is called only before a call to a function declared to implement a mutator, for example, if &lt;code&gt;++$b;&lt;/code&gt; in the code above is effected via a method declared for key &lt;code&gt;'++'&lt;/code&gt; (or 'nomethod', passed &lt;code&gt;'++'&lt;/code&gt; as the fourth argument) or, by autogeneration, &lt;code&gt;'+='&lt;/code&gt; . It is not called if the increment operation is effected by a call to the method for &lt;code&gt;'+'&lt;/code&gt; since, in the equivalent code,</source>
          <target state="translated">Конструктор копирования вызывается только перед вызовом функции, объявленной для реализации мутатора, например, if &lt;code&gt;++$b;&lt;/code&gt; в приведенном выше коде выполняется с помощью метода, объявленного для ключа &lt;code&gt;'++'&lt;/code&gt; (или 'nomethod', переданного &lt;code&gt;'++'&lt;/code&gt; в качестве четвертого аргумента), или путем автогенерации &lt;code&gt;'+='&lt;/code&gt; . Он не вызывается, если операция приращения выполняется вызовом метода для &lt;code&gt;'+'&lt;/code&gt; , поскольку в эквивалентном коде</target>
        </trans-unit>
        <trans-unit id="ed73a5b2044d7fb703c52c07bf589cfde908abd5" translate="yes" xml:space="preserve">
          <source>The copy constructor is not called if Perl determines that it is unnecessary because there is no other reference to the data being modified.</source>
          <target state="translated">Конструктор копирования не вызывается,если Perl определяет,что он не нужен,так как нет другой ссылки на изменяемые данные.</target>
        </trans-unit>
        <trans-unit id="dd210b745dfa94e566cd092061cca3c4c3e619ac" translate="yes" xml:space="preserve">
          <source>The core &lt;a href=&quot;devel/peek&quot;&gt;Devel::Peek&lt;/a&gt; module lets us examine SVs from a Perl program. Let's see, for instance, how Perl treats the constant &lt;code&gt;&quot;hello&quot;&lt;/code&gt; .</source>
          <target state="translated">Ядро &lt;a href=&quot;devel/peek&quot;&gt;Devel :: Peek&lt;/a&gt; модуль позволяет нам исследовать из КИ программы Perl. Давайте посмотрим, например, как Perl обрабатывает константу &lt;code&gt;&quot;hello&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="216872d0879be12be32ab51a2f74dd9e0b301e2c" translate="yes" xml:space="preserve">
          <source>The core development team (known as the Perl Porters) are a group of highly altruistic individuals committed to producing better software for free than you could hope to purchase for money. You may snoop on pending developments via the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.nntp.perl.org%2fgroup%2fperl.perl5.porters%2f&quot;&gt;archives&lt;/a&gt; or read the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fdev.perl.org%2fperl5%2fdocs%2fp5p-faq.html&quot;&gt;faq&lt;/a&gt;, or you can subscribe to the mailing list by sending perl5-porters-subscribe@perl.org a subscription request (an empty message with no subject is fine).</source>
          <target state="translated">Основная группа разработчиков (известная как Perl Porters) - это группа очень альтруистических людей, приверженных созданию более качественного программного обеспечения бесплатно, чем вы могли бы надеяться купить за деньги. Вы можете следить за незавершенными разработками через &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.nntp.perl.org%2fgroup%2fperl.perl5.porters%2f&quot;&gt;архивы&lt;/a&gt; или читать &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fdev.perl.org%2fperl5%2fdocs%2fp5p-faq.html&quot;&gt;часто задаваемые вопросы&lt;/a&gt; , или вы можете подписаться на список рассылки, отправив perl5-porters-subscribe@perl.org запрос на подписку (пустое сообщение без темы - нормально).</target>
        </trans-unit>
        <trans-unit id="0cd6f3115d2d6dbe91a070c10c729356bd227008" translate="yes" xml:space="preserve">
          <source>The core distribution can now run its regression tests in parallel on Unix-like platforms. Instead of running &lt;code&gt;make test&lt;/code&gt; , set &lt;code&gt;TEST_JOBS&lt;/code&gt; in your environment to the number of tests to run in parallel, and run &lt;code&gt;make test_harness&lt;/code&gt; . On a Bourne-like shell, this can be done as</source>
          <target state="translated">Базовый дистрибутив теперь может выполнять свои регрессионные тесты параллельно на Unix-подобных платформах. Вместо запуска &lt;code&gt;make test&lt;/code&gt; установите для &lt;code&gt;TEST_JOBS&lt;/code&gt; в вашей среде количество тестов, которые будут выполняться параллельно, и запустите &lt;code&gt;make test_harness&lt;/code&gt; . На оболочке типа Борна это можно сделать как</target>
        </trans-unit>
        <trans-unit id="e662bc8801eef788dff3d6316ec77e7ad811db79" translate="yes" xml:space="preserve">
          <source>The core uses the same testing style as the rest of Perl, a simple &quot;ok/not ok&quot; run through Test::Harness, but there are a few special considerations.</source>
          <target state="translated">Ядро использует тот же стиль тестирования,что и остальные Perl,простое &quot;ok/not ok&quot; проходит через Test::Harness,но есть несколько особых соображений.</target>
        </trans-unit>
        <trans-unit id="a3ac8ff08d630fcfeea5350e81e0c2b799df3c84" translate="yes" xml:space="preserve">
          <source>The corpse of a &lt;b&gt;process&lt;/b&gt;, in the form of a file left in the &lt;b&gt;working directory&lt;/b&gt; of the process, usually as a result of certain kinds of fatal errors.</source>
          <target state="translated">Труп &lt;b&gt;процесса&lt;/b&gt; в виде файла, оставшегося в &lt;b&gt;рабочем каталоге&lt;/b&gt; процесса, обычно в результате определенных видов фатальных ошибок.</target>
        </trans-unit>
        <trans-unit id="ad72ec528dbf7e40ea844e46e3a129f3b3eadb6f" translate="yes" xml:space="preserve">
          <source>The correct code is &lt;code&gt;MAN3PODS =&amp;gt; { }&lt;/code&gt; .</source>
          <target state="translated">Правильный код: &lt;code&gt;MAN3PODS =&amp;gt; { }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7eb7322d9e711d10a989215f61754b35fdcb57a5" translate="yes" xml:space="preserve">
          <source>The correct procedure, then, is to use &lt;code&gt;newRV_noinc&lt;/code&gt; instead of &lt;code&gt;newRV_inc&lt;/code&gt; . Then, if and when the last reference is destroyed, the reference count of the SV will go to zero and it will be destroyed, stopping any memory leak.</source>
          <target state="translated">Следовательно, правильная процедура - использовать &lt;code&gt;newRV_noinc&lt;/code&gt; вместо &lt;code&gt;newRV_inc&lt;/code&gt; . Затем, если и когда последняя ссылка будет уничтожена, счетчик ссылок SV станет нулевым, и он будет уничтожен, остановив любую утечку памяти.</target>
        </trans-unit>
        <trans-unit id="e90480b056b891e1197a3bfca2f65f9341469925" translate="yes" xml:space="preserve">
          <source>The correspondence between OPs and</source>
          <target state="translated">Переписка между ОП и</target>
        </trans-unit>
        <trans-unit id="3e632bae0f91b7fe9b42695b7f4eb9541547d7ab" translate="yes" xml:space="preserve">
          <source>The corresponding bright foreground color attributes (colors 8 to 15) are:</source>
          <target state="translated">Соответствующими яркими атрибутами цвета переднего плана (цвета от 8 до 15)являются:</target>
        </trans-unit>
        <trans-unit id="15d3a8f91abd0b678be46a5c74457eb9c1a22a59" translate="yes" xml:space="preserve">
          <source>The corresponding command to get the current value of &lt;code&gt;$version&lt;/code&gt; is:</source>
          <target state="translated">Соответствующая команда для получения текущего значения &lt;code&gt;$version&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05b1215b3085d02b291dbd96e47ab01de8dfb44a" translate="yes" xml:space="preserve">
          <source>The corresponding values are interpreted as regular expressions. The &lt;code&gt;distribution&lt;/code&gt; related one will be matched against the canonical distribution name, e.g. &quot;AUTHOR/Foo-Bar-3.14.tar.gz&quot;.</source>
          <target state="translated">Соответствующие значения интерпретируются как регулярные выражения. &lt;code&gt;distribution&lt;/code&gt; один связанный будет сравниваться с каноническим именем распределения, например , &amp;laquo;АВТОР / Foo-Bar-3.14.tar.gz&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="128893376b086988df0b6fe82266dcff7ded3c2c" translate="yes" xml:space="preserve">
          <source>The corresponding values are references to functions which take three arguments: the first one is the</source>
          <target state="translated">Соответствующими значениями являются ссылки на функции,которые принимают три аргумента:первый-это</target>
        </trans-unit>
        <trans-unit id="6d3c7b629f0ebabb7666a1418d689e5fcefefd4a" translate="yes" xml:space="preserve">
          <source>The count of the saved lines in the history (assuming &lt;code&gt;HistFile&lt;/code&gt; above).</source>
          <target state="translated">Количество сохраненных строк в истории (при условии, что &lt;code&gt;HistFile&lt;/code&gt; выше).</target>
        </trans-unit>
        <trans-unit id="8a76e9ed23620e2d0138b893f98a44b589dac036" translate="yes" xml:space="preserve">
          <source>The cpd tool detects cut-and-paste coding. If one instance of the cut-and-pasted code changes, all the other spots should probably be changed, too. Therefore such code should probably be turned into a subroutine or a macro.</source>
          <target state="translated">Инструмент cpd обнаруживает кодировку нарезки и вставки.Если один экземпляр прорезанного кода изменяется,то,скорее всего,должны быть изменены и все остальные места.Поэтому такой код,скорее всего,следует превратить в подпрограмму или макрос.</target>
        </trans-unit>
        <trans-unit id="4315b91912980da8ee0d1d0ed73982372319566a" translate="yes" xml:space="preserve">
          <source>The critical thing when considering performance is to remember there is no such thing as a &lt;code&gt;Golden Bullet&lt;/code&gt; , which is why there are no rules, only guidelines.</source>
          <target state="translated">При рассмотрении производительности важно помнить, что не существует такой вещи, как &amp;laquo; &lt;code&gt;Golden Bullet&lt;/code&gt; , поэтому здесь нет правил, а есть только рекомендации.</target>
        </trans-unit>
        <trans-unit id="2b2f6d378553efd3b9ab7bab3a4069e081f7b24e" translate="yes" xml:space="preserve">
          <source>The crucial thing to understand about the Windows environment is that the command line you type in is processed twice before Perl sees it. First, your command shell (usually CMD.EXE) preprocesses the command line, to handle redirection, environment variable expansion, and location of the executable to run. Then, the perl executable splits the remaining command line into individual arguments, using the C runtime library upon which Perl was built.</source>
          <target state="translated">Ключевым моментом,который необходимо понять в среде Windows,является то,что командная строка,которую вы вводите,обрабатывается дважды,прежде чем Perl увидит ее.Во-первых,ваша командная оболочка (обычно CMD.EXE)препроцессирует командную строку,чтобы обрабатывать перенаправление,расширение переменных окружения и расположение исполняемого файла для выполнения.Затем исполняемый файл perl разбивает оставшуюся командную строку на отдельные аргументы,используя библиотеку времени выполнения C,на которой был собран Perl.</target>
        </trans-unit>
        <trans-unit id="1bc259f8a74780b8f0344bb67ea81414fbf6762f" translate="yes" xml:space="preserve">
          <source>The crypt package distributed with Cygwin is a Linux compatible 56-bit DES crypt port by Corinna Vinschen.</source>
          <target state="translated">Пакет крипт,распространяемый вместе с Cygwin,представляет собой 56-битный DES-порт крипта,совместимый с Linux,разработанный Коринной Виншен.</target>
        </trans-unit>
        <trans-unit id="831281b1eb1b6cf65cdf498d326c123b4d2ac980" translate="yes" xml:space="preserve">
          <source>The csh_glob() function can also be exported, but you should not use it directly unless you really know what you are doing. It splits the pattern into words and feeds each one to bsd_glob(). Perl's own glob() function uses this internally.</source>
          <target state="translated">Функция csh_glob()также может быть экспортирована,но вы не должны использовать ее напрямую,если вы действительно не знаете,что делаете.Она разделяет паттерн на слова и передает каждый из них в bsd_glob().Собственная функция Perl glob()использует это внутренне.</target>
        </trans-unit>
        <trans-unit id="bb0c5fc2762311ff2f0c2ca9c51463e63c575d45" translate="yes" xml:space="preserve">
          <source>The ctime() function provides a way of getting at the scalar sense of the original CORE::localtime() function.</source>
          <target state="translated">Функция ctime()обеспечивает способ получения скалярного смысла исходной функции CORE::localtime().</target>
        </trans-unit>
        <trans-unit id="cc603efa123dedf5ee9218533c5f2218c02b0847" translate="yes" xml:space="preserve">
          <source>The cube root [C99].</source>
          <target state="translated">Кубический корень [C99].</target>
        </trans-unit>
        <trans-unit id="64523d7c78b273edb939e95b2a44e78339d21a0e" translate="yes" xml:space="preserve">
          <source>The current format name is stored in the variable &lt;code&gt;$~&lt;/code&gt; (&lt;code&gt;$FORMAT_NAME&lt;/code&gt; ), and the current top of form format name is in &lt;code&gt;$^&lt;/code&gt; (&lt;code&gt;$FORMAT_TOP_NAME&lt;/code&gt; ). The current output page number is stored in &lt;code&gt;$%&lt;/code&gt; (&lt;code&gt;$FORMAT_PAGE_NUMBER&lt;/code&gt; ), and the number of lines on the page is in &lt;code&gt;$=&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_PER_PAGE&lt;/code&gt; ). Whether to autoflush output on this handle is stored in &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$OUTPUT_AUTOFLUSH&lt;/code&gt; ). The string output before each top of page (except the first) is stored in &lt;code&gt;$^L&lt;/code&gt; (&lt;code&gt;$FORMAT_FORMFEED&lt;/code&gt; ). These variables are set on a per-filehandle basis, so you'll need to select() into a different one to affect them:</source>
          <target state="translated">Текущее имя формата хранится в переменной &lt;code&gt;$~&lt;/code&gt; ( &lt;code&gt;$FORMAT_NAME&lt;/code&gt; ), а текущее имя формата верхней части формы находится в &lt;code&gt;$^&lt;/code&gt; ( &lt;code&gt;$FORMAT_TOP_NAME&lt;/code&gt; ). Номер текущей выходной страницы хранится в &lt;code&gt;$%&lt;/code&gt; ( &lt;code&gt;$FORMAT_PAGE_NUMBER&lt;/code&gt; ), а количество строк на странице - в &lt;code&gt;$=&lt;/code&gt; ( &lt;code&gt;$FORMAT_LINES_PER_PAGE&lt;/code&gt; ). Сохраняется ли автоматическая очистка вывода для этого дескриптора в &lt;code&gt;$|&lt;/code&gt; ( &lt;code&gt;$OUTPUT_AUTOFLUSH&lt;/code&gt; ). Строка, выводимая перед каждой верхней частью страницы (кроме первой), сохраняется в &lt;code&gt;$^L&lt;/code&gt; ( &lt;code&gt;$FORMAT_FORMFEED&lt;/code&gt; ). Эти переменные устанавливаются для каждого дескриптора файла, поэтому вам нужно будет выбрать () другой, чтобы повлиять на них:</target>
        </trans-unit>
        <trans-unit id="bbbf873260d45973f075c0f7d16575580f2c6333" translate="yes" xml:space="preserve">
          <source>The current hierarchy is:</source>
          <target state="translated">Текущая иерархия:</target>
        </trans-unit>
        <trans-unit id="824b38e0c77c472868114a17d1e97b269bb0ba11" translate="yes" xml:space="preserve">
          <source>The current implementation does not allow specification of the required version of the module.</source>
          <target state="translated">Текущая реализация не позволяет специфицировать требуемую версию модуля.</target>
        </trans-unit>
        <trans-unit id="282bec354d0f4d4b762dd47ad0eb5b6ecfd1f6ce" translate="yes" xml:space="preserve">
          <source>The current input line is normally in $_, not $0. It generally does not have the newline stripped. ($0 is the name of the program executed.) See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">Текущая строка ввода обычно находится в $ _, а не в $ 0. Обычно в нем не удаляется новая строка. ($ 0 - это имя выполняемой программы.) См. &lt;a href=&quot;perlvar&quot;&gt;Perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18f618cc025364ce800e5f345611b3c1497a1ed6" translate="yes" xml:space="preserve">
          <source>The current kinds of Magic Virtual Tables are:</source>
          <target state="translated">Текущие виды Виртуальных Волшебных Столов:</target>
        </trans-unit>
        <trans-unit id="5c4fde69768c885a1c05aaf0e69e2380f88e2b66" translate="yes" xml:space="preserve">
          <source>The current leading implementation of Perl 6, Rakudo, released a &quot;useful, usable, 'early adopter'&quot; distribution of Perl 6 (called Rakudo Star) in July of 2010. Please see &lt;a href=&quot;http://rakudo.org/&quot;&gt;http://rakudo.org/&lt;/a&gt; for more information.</source>
          <target state="translated">Текущая ведущая реализация Perl 6, Rakudo, в июле 2010 года выпустила &amp;laquo;полезный, удобный и&amp;laquo; ранний последователь &amp;raquo;&amp;raquo; дистрибутива Perl 6 (называемого Rakudo Star). Пожалуйста, посетите &lt;a href=&quot;http://rakudo.org/&quot;&gt;http://rakudo.org/&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="22d3f495bb4240a9d3bab6ec75da601351d12c2b" translate="yes" xml:space="preserve">
          <source>The current locale is exposed to XS code except possibly &lt;code&gt;LC_NUMERIC&lt;/code&gt; (explained in the next paragraph). There have not been reports of problems with the other categories. Perl initializes things on start-up so that the current locale is the one which is indicated by the user's environment in effect at that time. See &lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;ENVIRONMENT in perllocale&lt;/a&gt;.</source>
          <target state="translated">Текущая локаль доступна для кода XS, за исключением, возможно, &lt;code&gt;LC_NUMERIC&lt;/code&gt; (объяснено в следующем абзаце). Сообщений о проблемах с другими категориями не поступало. Perl инициализирует вещи при запуске, так что текущая локаль - это та, которая указана в среде пользователя, действующей в то время. Смотрите &lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;ENVIRONMENT в perllocale&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="061c069ca3fcc48e2c1a6a5055f7be81ca6838c7" translate="yes" xml:space="preserve">
          <source>The current locale is set at execution time by &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; described below. If that function hasn't yet been called in the course of the program's execution, the current locale is that which was determined by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; in effect at the start of the program. If there is no valid environment, the current locale is whatever the system default has been set to. On POSIX systems, it is likely, but not necessarily, the &quot;C&quot; locale. On Windows, the default is set via the computer's &lt;code&gt;Control Panel-&amp;gt;Regional &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; Language Options&lt;/code&gt; (or its current equivalent).</source>
          <target state="translated">Текущая локаль устанавливается во время выполнения с помощью &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale (),&lt;/a&gt; описанной ниже. Если эта функция еще не была вызвана в ходе выполнения программы, текущая локаль - это то, что было определено &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ОКРУЖЕНИЕМ,&lt;/a&gt; действующим в начале программы. Если допустимая среда отсутствует, текущая локаль - это то, что было установлено по умолчанию в системе. В системах POSIX это вероятно, но не обязательно, локаль &quot;C&quot;. В Windows значение по умолчанию устанавливается через &lt;code&gt;Control Panel-&amp;gt;Regional &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; Language Options&lt;/code&gt; компьютера - &amp;gt; Язык и региональные стандарты (или его текущий эквивалент).</target>
        </trans-unit>
        <trans-unit id="b7f42f27fb52f98cb07c551fabc648053a689c30" translate="yes" xml:space="preserve">
          <source>The current locale is used when going outside of Perl with operations like &lt;a href=&quot;functions/system&quot;&gt;system LIST&lt;/a&gt; or &lt;a href=&quot;perlop#qx%2fSTRING%2f&quot;&gt;qx//&lt;/a&gt;, if those operations are locale-sensitive.</source>
          <target state="translated">Текущая локаль используется при выходе из Perl с такими операциями, как &lt;a href=&quot;functions/system&quot;&gt;системный LIST&lt;/a&gt; или &lt;a href=&quot;perlop#qx%2fSTRING%2f&quot;&gt;qx //&lt;/a&gt; , если эти операции зависят от локали.</target>
        </trans-unit>
        <trans-unit id="ea51628874f50840c20248e49e31ecc39bc8aab0" translate="yes" xml:space="preserve">
          <source>The current major release of Perl is Perl 5, first released in 1994. It can run scripts from the previous major release, Perl 4 (March 1991), but has significant differences.</source>
          <target state="translated">В настоящее время основным релизом Perl является Perl 5,впервые выпущенный в 1994 году.Он может выполнять скрипты предыдущего мажорного релиза,Perl 4 (март 1991),но имеет значительные отличия.</target>
        </trans-unit>
        <trans-unit id="1ad75b57a59621fb77288b117b229032ac9f513f" translate="yes" xml:space="preserve">
          <source>The current naming convention is:</source>
          <target state="translated">Текущее соглашение об именах:</target>
        </trans-unit>
        <trans-unit id="b2e2b3b69c2218e4d8359acb1335a4024632d82a" translate="yes" xml:space="preserve">
          <source>The current offset on the Perl internal stack (cf. &lt;code&gt;SP&lt;/code&gt; ) is restored at the end of</source>
          <target state="translated">Текущее смещение во внутреннем стеке Perl (см. &lt;code&gt;SP&lt;/code&gt; ) восстанавливается в конце</target>
        </trans-unit>
        <trans-unit id="c030186501458b34adb46e2d42aa7b81f218a056" translate="yes" xml:space="preserve">
          <source>The current page length (printable lines) of the currently selected output channel. The default is 60.</source>
          <target state="translated">Текущая длина страницы (строки для печати)текущего выбранного выходного канала.По умолчанию 60.</target>
        </trans-unit>
        <trans-unit id="3d4eb19bb10369473283d32cc7dd71a86ff46c90" translate="yes" xml:space="preserve">
          <source>The current page number of the currently selected output channel.</source>
          <target state="translated">Номер текущей страницы текущего выбранного выходного канала.</target>
        </trans-unit>
        <trans-unit id="770296232bd3d822ead8ffe492b7e0e282b9f95e" translate="yes" xml:space="preserve">
          <source>The current phase of the perl interpreter.</source>
          <target state="translated">Текущая фаза работы переводчика perl.</target>
        </trans-unit>
        <trans-unit id="a2857cd700aaf0537f04949257bdb10786ea5148" translate="yes" xml:space="preserve">
          <source>The current set of characters after which a string may be broken to fill continuation fields (starting with &lt;code&gt;^&lt;/code&gt;) in a format. The default is &quot; \n-&quot;, to break on a space, newline, or a hyphen.</source>
          <target state="translated">Текущий набор символов, после которого строка может быть разбита для заполнения полей продолжения (начиная с &lt;code&gt;^&lt;/code&gt; ) в формате. По умолчанию используется &amp;laquo;\ n-&amp;raquo;, чтобы разделить пробел, новую строку или дефис.</target>
        </trans-unit>
        <trans-unit id="981300e195cac4e7353f833304330d8ac58b67a9" translate="yes" xml:space="preserve">
          <source>The current set of warning checks enabled by the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma. It has the same scoping as the &lt;code&gt;$^H&lt;/code&gt; and &lt;code&gt;%^H&lt;/code&gt; variables. The exact values are considered internal to the &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; pragma and may change between versions of Perl.</source>
          <target state="translated">Текущий набор предупредительных проверок включен в &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; прагмы. Он имеет ту же область видимости, что и переменные &lt;code&gt;$^H&lt;/code&gt; и &lt;code&gt;%^H&lt;/code&gt; Точные значения считаются внутренними для прагмы &lt;a href=&quot;warnings&quot;&gt;предупреждений&lt;/a&gt; и могут изменяться в зависимости от версии Perl.</target>
        </trans-unit>
        <trans-unit id="e48b124af22e055d2f998460eddfa2b05c504d05" translate="yes" xml:space="preserve">
          <source>The current setting for a particular CV can be retrieved by &lt;a href=&quot;#cv_get_call_checker&quot;&gt;cv_get_call_checker&lt;/a&gt;.</source>
          <target state="translated">Текущие настройки для конкретного резюме можно получить с помощью &lt;a href=&quot;#cv_get_call_checker&quot;&gt;cv_get_call_checker&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b952480064e555e874a4e5bab67374e0afa43170" translate="yes" xml:space="preserve">
          <source>The current state is quite close to this target. Known limitations:</source>
          <target state="translated">Текущее состояние довольно близко к этой цели.Известные ограничения:</target>
        </trans-unit>
        <trans-unit id="8b45957d0c48ff5a61159add09d1cced4fe06354" translate="yes" xml:space="preserve">
          <source>The current value of &lt;code&gt;$,&lt;/code&gt; (if any) is printed between each LIST item. The current value of &lt;code&gt;$\&lt;/code&gt; (if any) is printed after the entire LIST has been printed. Because print takes a LIST, anything in the LIST is evaluated in list context, including any subroutines whose return lists you pass to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;. Be careful not to follow the print keyword with a left parenthesis unless you want the corresponding right parenthesis to terminate the arguments to the print; put parentheses around all arguments (or interpose a &lt;code&gt;+&lt;/code&gt; , but that doesn't look as good).</source>
          <target state="translated">Текущее значение &lt;code&gt;$,&lt;/code&gt; (если есть) печатается между каждым элементом СПИСКА. Текущее значение &lt;code&gt;$\&lt;/code&gt; (если есть) печатается после того, как будет напечатан весь СПИСОК. Поскольку print принимает СПИСОК, все, что есть в СПИСКЕ, оценивается в контексте списка, включая любые подпрограммы, списки возврата которых вы передаете на &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; . Будьте осторожны и не ставьте за ключевым словом print левую круглую скобку, если только вы не хотите, чтобы соответствующая правая скобка завершала аргументы печати; заключите все аргументы в круглые скобки (или вставьте &lt;code&gt;+&lt;/code&gt; , но это выглядит не очень хорошо).</target>
        </trans-unit>
        <trans-unit id="d3b381c8d22a96ce946901e90864741d92df1af5" translate="yes" xml:space="preserve">
          <source>The current value of &lt;code&gt;$,&lt;/code&gt; (if any) is printed between each LIST item. The current value of &lt;code&gt;$\&lt;/code&gt; (if any) is printed after the entire LIST has been printed. Because print takes a LIST, anything in the LIST is evaluated in list context, including any subroutines whose return lists you pass to &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;. Be careful not to follow the print keyword with a left parenthesis unless you want the corresponding right parenthesis to terminate the arguments to the print; put parentheses around all arguments (or interpose a &lt;code&gt;+&lt;/code&gt; , but that doesn't look as good).</source>
          <target state="translated">Текущее значение &lt;code&gt;$,&lt;/code&gt; (если есть) печатается между каждым элементом СПИСКА. Текущее значение &lt;code&gt;$\&lt;/code&gt; (если есть) печатается после того, как будет напечатан весь СПИСОК. Поскольку print принимает СПИСОК, все, что есть в СПИСКЕ, оценивается в контексте списка, включая любые подпрограммы, списки возврата которых вы передаете на &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; . Будьте осторожны и не ставьте за ключевым словом print левую круглую скобку, если только вы не хотите, чтобы соответствующая правая скобка завершала аргументы печати; заключите все аргументы в круглые скобки (или вставьте &lt;code&gt;+&lt;/code&gt; , но это выглядит не очень хорошо).</target>
        </trans-unit>
        <trans-unit id="16a7c40e8bbfe13e91d735da741af8520eabede2" translate="yes" xml:space="preserve">
          <source>The current value of &lt;code&gt;$archname&lt;/code&gt; can be found with this command:</source>
          <target state="translated">Текущее значение &lt;code&gt;$archname&lt;/code&gt; можно найти с помощью этой команды:</target>
        </trans-unit>
        <trans-unit id="db4a25bfed587546962de5c8d6543f967c92521a" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; accumulator for &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; lines. A format contains &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; calls that put their result into &lt;code&gt;$^A&lt;/code&gt; . After calling its format, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; prints out the contents of &lt;code&gt;$^A&lt;/code&gt; and empties. So you never really see the contents of &lt;code&gt;$^A&lt;/code&gt; unless you call &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; yourself and then look at it. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; and &lt;a href=&quot;functions/formline&quot;&gt;formline PICTURE,LIST&lt;/a&gt;.</source>
          <target state="translated">Текущее значение аккумулятора &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; для строк &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; . Формат содержит &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; вызовы , которые ставят их результат в &lt;code&gt;$^A&lt;/code&gt; . После вызова своего формата &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; распечатает содержимое &lt;code&gt;$^A&lt;/code&gt; и опустошает. Таким образом, вы никогда не увидите содержимое &lt;code&gt;$^A&lt;/code&gt; если вы &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; не вызовете formline (), а затем посмотрите на него. Смотрите &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; и &lt;a href=&quot;functions/formline&quot;&gt;formline ИЗОБРАЖЕНИЕ, СПИСОК&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed07dc52d8f87fe5efbcd1795acd592cb2bcdd55" translate="yes" xml:space="preserve">
          <source>The current value of the debugging flags. May be read or set. Like its command-line equivalent, you can use numeric or symbolic values, eg &lt;code&gt;$^D = 10&lt;/code&gt; or &lt;code&gt;$^D = &quot;st&quot;&lt;/code&gt; .</source>
          <target state="translated">Текущее значение флагов отладки. Можно прочитать или установить. Как и его эквивалент в командной строке, вы можете использовать числовые или символьные значения, например, &lt;code&gt;$^D = 10&lt;/code&gt; или &lt;code&gt;$^D = &quot;st&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="761048a9f6779920117c38b6975281ec2824cbaa" translate="yes" xml:space="preserve">
          <source>The current value of the flag associated with the &lt;b&gt;-c&lt;/b&gt; switch. Mainly of use with &lt;b&gt;-MO=...&lt;/b&gt; to allow code to alter its behavior when being compiled, such as for example to &lt;code&gt;AUTOLOAD&lt;/code&gt; at compile time rather than normal, deferred loading. Setting &lt;code&gt;$^C = 1&lt;/code&gt; is similar to calling &lt;code&gt;B::minus_c&lt;/code&gt; .</source>
          <target state="translated">Текущее значение флага, связанного с переключателем &lt;b&gt;-c&lt;/b&gt; . В основном используется с &lt;b&gt;-MO = ...,&lt;/b&gt; чтобы позволить коду изменять свое поведение при компиляции, например, в &lt;code&gt;AUTOLOAD&lt;/code&gt; во время компиляции, а не при нормальной отложенной загрузке. Установка &lt;code&gt;$^C = 1&lt;/code&gt; аналогична вызову &lt;code&gt;B::minus_c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5468ce0ac69ee02e09a591df294df02b8e8e00dd" translate="yes" xml:space="preserve">
          <source>The current value of the inplace-edit extension. Use &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to disable inplace editing.</source>
          <target state="translated">Текущее значение расширения inplace-edit. Используйте &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , чтобы отключить редактирование на месте.</target>
        </trans-unit>
        <trans-unit id="ab0d30902e8f62034444f0c46f34be59caec65d2" translate="yes" xml:space="preserve">
          <source>The current value of the regex debugging flags. Set to 0 for no debug output even when the &lt;code&gt;re 'debug'&lt;/code&gt; module is loaded. See &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; for details.</source>
          <target state="translated">Текущее значение флагов отладки регулярного выражения. Установите значение 0, чтобы отладочная информация не выводилась, даже если загружен модуль &lt;code&gt;re 'debug'&lt;/code&gt; . Подробности смотрите в &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a22922d7a166dbc35ec6d0a0c534fd11892caf1b" translate="yes" xml:space="preserve">
          <source>The current value of the warning switch, initially true if &lt;b&gt;-w&lt;/b&gt; was used, false otherwise, but directly modifiable.</source>
          <target state="translated">Текущее значение переключателя предупреждения, изначально истина, если использовалась &lt;b&gt;-w&lt;/b&gt; , в противном случае - ложь, но может быть изменена напрямую.</target>
        </trans-unit>
        <trans-unit id="434ca8d76bd8ecc27a064789f98b19395ab4f212" translate="yes" xml:space="preserve">
          <source>The current version of the standards for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; is available at &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&lt;/a&gt;.</source>
          <target state="translated">Текущая версия стандартов для &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; доступна по адресу &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6af70deb3b449e89c48e84135fbdeb7d79f07a9c" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/ansicolor/&quot;&gt;http://www.eyrie.org/~eagle/software/ansicolor/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">Текущая версия этого модуля всегда доступна на его веб-сайте &lt;a href=&quot;http://www.eyrie.org/~eagle/software/ansicolor/&quot;&gt;http://www.eyrie.org/~eagle/software/ansicolor/&lt;/a&gt; . Он также является частью основного дистрибутива Perl начиная с версии 5.6.0.</target>
        </trans-unit>
        <trans-unit id="b31c3cebc8faae4e8a4925e48535264d89073d95" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;.</source>
          <target state="translated">Текущая версия этого модуля всегда доступна на его веб-сайте &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5a8854edfd01b7a5e559e1a5294ccbba9d0afe6" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">Текущая версия этого модуля всегда доступна на его веб-сайте &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt; . Он также является частью основного дистрибутива Perl начиная с версии 5.6.0.</target>
        </trans-unit>
        <trans-unit id="c47cd4fd8d9bd245ee61848360efac4088607cb6" translate="yes" xml:space="preserve">
          <source>The current version of this script is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">Текущая версия этого сценария всегда доступна на его веб-сайте &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt; . Он также является частью основного дистрибутива Perl начиная с версии 5.6.0.</target>
        </trans-unit>
        <trans-unit id="9d8fe5626c6979a9718f106c0652b7d905296f64" translate="yes" xml:space="preserve">
          <source>The current version was written by Graham Barr.</source>
          <target state="translated">Текущая версия была написана Грэмом Барром.</target>
        </trans-unit>
        <trans-unit id="7c32f08e82229236d88693ec9eaad5ec8a635209" translate="yes" xml:space="preserve">
          <source>The current working directory of the program is</source>
          <target state="translated">Текущая рабочая директория программы</target>
        </trans-unit>
        <trans-unit id="588f5e820c106e9822f858102bdf0e7ae9b574c7" translate="yes" xml:space="preserve">
          <source>The customary Perl approach for processing all the lines in a file is to do so one line at a time:</source>
          <target state="translated">Обычный Perl-подход для обработки всех строк в файле состоит в том,чтобы делать это по одной строке за раз:</target>
        </trans-unit>
        <trans-unit id="a4504c4a63cdd557da723133c8d2b75666dc8630" translate="yes" xml:space="preserve">
          <source>The cwd() is the most natural form for the current architecture. For most systems it is identical to `pwd` (but without the trailing line terminator).</source>
          <target state="translated">cwd()является наиболее естественной формой для текущей архитектуры.Для большинства систем она идентична `pwd` (но без терминатора трейлинговой линии).</target>
        </trans-unit>
        <trans-unit id="40c9ebfbdf9a557c5ad182c1d60f03fd99fa74ef" translate="yes" xml:space="preserve">
          <source>The data argument passes in the value (if any) associated with the attribute. For example, if &lt;code&gt;&amp;amp;foo&lt;/code&gt; had been declared:</source>
          <target state="translated">Аргумент данных передает значение (если есть), связанное с атрибутом. Например, если был объявлен &lt;code&gt;&amp;amp;foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4057a2800ea2edef8acd376fce4a738947ca16f2" translate="yes" xml:space="preserve">
          <source>The data can be aggregated into obvious structures, especially if there's a large amount of data in each aggregate.</source>
          <target state="translated">Данные могут быть агрегированы в очевидные структуры,особенно если в каждой из них имеется большой объем данных.</target>
        </trans-unit>
        <trans-unit id="f1737bbb402e005395886a66a62fefd166798f8a" translate="yes" xml:space="preserve">
          <source>The data is stored as a list of values from the time and times functions:</source>
          <target state="translated">Данные сохраняются в виде списка значений из функций времени и времени:</target>
        </trans-unit>
        <trans-unit id="083ecdb4eb83b1283f9d7370b6905eb300e214e7" translate="yes" xml:space="preserve">
          <source>The data may be retrieved using the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; function if the underlying type of the byte stream is known.</source>
          <target state="translated">Данные могут быть получены с помощью функции &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; если известен базовый тип байтового потока.</target>
        </trans-unit>
        <trans-unit id="9bb2c0f943e4592858ab2d05373119174b2d2dda" translate="yes" xml:space="preserve">
          <source>The data was added as a Unicode string and when writing it out to disk, the &lt;code&gt;:utf8&lt;/code&gt; line discipline wasn't set by &lt;code&gt;Archive::Tar&lt;/code&gt; , so Perl tried to convert the string to ISO-8859 and failed. The written file now contains garbage.</source>
          <target state="translated">Данные были добавлены как строка Unicode, и при записи на диск дисциплина строки &lt;code&gt;:utf8&lt;/code&gt; не была установлена ​​с помощью &lt;code&gt;Archive::Tar&lt;/code&gt; , поэтому Perl попытался преобразовать строку в ISO-8859 и потерпел неудачу. Теперь записанный файл содержит мусор.</target>
        </trans-unit>
        <trans-unit id="93ccb288f67ba8fe0c8510721b3e70886d45432a" translate="yes" xml:space="preserve">
          <source>The date and day names in dates formatted by &lt;code&gt;strftime()&lt;/code&gt; could be manipulated to advantage by a malicious user able to subvert the &lt;code&gt;LC_DATE&lt;/code&gt; locale. (&quot;Look--it says I wasn't in the building on Sunday.&quot;)</source>
          <target state="translated">Имена даты и дня в датах, отформатированных с помощью &lt;code&gt;strftime()&lt;/code&gt; могут быть использованы злонамеренным пользователем, способным &lt;code&gt;LC_DATE&lt;/code&gt; локаль LC_DATE . (&amp;laquo;Послушайте, там написано, что меня не было в здании в воскресенье&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="c40b16f78ce75cc859be91a0613f27d3f68c2364" translate="yes" xml:space="preserve">
          <source>The day of the year is in the list returned by the &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; function. Without an argument &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; uses the current time.</source>
          <target state="translated">День года находится в списке, возвращаемом функцией &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; . Без аргумента &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; использует текущее время.</target>
        </trans-unit>
        <trans-unit id="32d7e957f2b60e8e8af1a45f78007f3a710223c2" translate="yes" xml:space="preserve">
          <source>The days of just flinging strings around are over. It's well established that modern programs need to be capable of communicating funny accented letters, and things like euro symbols. This means that programmers need new habits. It's easy to program Unicode capable software, but it does require discipline to do it right.</source>
          <target state="translated">Дни,когда просто бросали струны,закончились.Хорошо известно,что современные программы должны быть способны передавать смешные акцентированные буквы и вещи вроде евросимволов.Это значит,что программистам нужны новые привычки.Программировать программы,способные работать с Unicode,легко,но для того,чтобы сделать это правильно,требуется дисциплина.</target>
        </trans-unit>
        <trans-unit id="7d9856be0d4d4aa47742843ac8ee15803c0a6dbf" translate="yes" xml:space="preserve">
          <source>The debugger does not currently work in conjunction with the &lt;b&gt;-W&lt;/b&gt; command-line switch, because it itself is not free of warnings.</source>
          <target state="translated">Отладчик в настоящее время не работает вместе с параметром командной строки &lt;b&gt;-W&lt;/b&gt; , потому что сам он не свободен от предупреждений.</target>
        </trans-unit>
        <trans-unit id="bff20683f233c3b1a43e85dddcc26c68e9457e08" translate="yes" xml:space="preserve">
          <source>The debugger has numerous options settable using the &lt;code&gt;o&lt;/code&gt; command, either interactively or from the environment or an rc file. (./.perldb or ~/.perldb under Unix.)</source>
          <target state="translated">Отладчик имеет множество опций, которые можно установить с помощью команды &lt;code&gt;o&lt;/code&gt; либо в интерактивном режиме, либо из среды или файла rc. (./.perldb или ~ / .perldb под Unix.)</target>
        </trans-unit>
        <trans-unit id="2b8f02d76c62b5ac783a580e7846d6536aa86d85" translate="yes" xml:space="preserve">
          <source>The debugger probably contains enough configuration hooks that you won't ever have to modify it yourself. You may change the behaviour of the debugger from within the debugger using its &lt;code&gt;o&lt;/code&gt; command, from the command line via the &lt;code&gt;PERLDB_OPTS&lt;/code&gt; environment variable, and from customization files.</source>
          <target state="translated">Отладчик, вероятно, содержит достаточно хуков настройки, которые вам никогда не придется изменять самостоятельно. Вы можете изменить поведение отладчика изнутри отладчика, используя его команду &lt;code&gt;o&lt;/code&gt; , из командной строки через &lt;code&gt;PERLDB_OPTS&lt;/code&gt; среды PERLDB_OPTS и из файлов настройки.</target>
        </trans-unit>
        <trans-unit id="24bc00b2a7165b041b9ffd101df7fc63fd2218dd" translate="yes" xml:space="preserve">
          <source>The debugger prompt is something like</source>
          <target state="translated">Подсказка отладчика-это что-то вроде</target>
        </trans-unit>
        <trans-unit id="f8e855d0dba7087b2dc163f59ea22e7610600301" translate="yes" xml:space="preserve">
          <source>The debugging output at compile time looks like this:</source>
          <target state="translated">Вывод отладки во время компиляции выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="5cc26823ddc27c25d44117d4b49405e558f3683c" translate="yes" xml:space="preserve">
          <source>The declared variable is not introduced (is not visible) until after the current statement. Thus,</source>
          <target state="translated">Объявленная переменная не вводится (не видна)до тех пор,пока не появится текущее утверждение.Таким образом,</target>
        </trans-unit>
        <trans-unit id="9ae51c467cb04a1b525475d0b1964978fbf97d39" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;:perlio&lt;/code&gt; layer retries &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; as described above; interrupted &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; calls will always be retried.</source>
          <target state="translated">По умолчанию &lt;code&gt;:perlio&lt;/code&gt; слой perlio пытается &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; как описано выше; прерванные вызовы &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; всегда будут повторяться.</target>
        </trans-unit>
        <trans-unit id="7af57631245798d230b9a42590aed5504edc7411" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;TIEHASH&lt;/code&gt; method stores &quot;extra&quot; arguments to tie() starting from offset 1 in the array referenced by &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt;; this is the same storage algorithm as in TIEHASH subroutine above. Hence, a typical package inheriting from &lt;b&gt;Tie::ExtraHash&lt;/b&gt; does not need to overwrite this method.</source>
          <target state="translated">Метод &lt;code&gt;TIEHASH&lt;/code&gt; по умолчанию сохраняет &amp;laquo;лишние&amp;raquo; аргументы функции tie (), начиная со смещения 1 в массиве, на который ссылается &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt; ; это тот же алгоритм хранения, что и в подпрограмме TIEHASH выше. Следовательно, типичный пакет, унаследованный от &lt;b&gt;Tie :: ExtraHash&lt;/b&gt; , не требует перезаписи этого метода.</target>
        </trans-unit>
        <trans-unit id="8bacf1d67275db56db4c207815d6942a42814176" translate="yes" xml:space="preserve">
          <source>The default behavior is restored with the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; pragma, or upon reaching the end of the block enclosing &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . Note that &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; calls may be nested, and that what is in effect within an inner scope will revert to the outer scope's rules at the end of the inner scope.</source>
          <target state="translated">Поведение по умолчанию восстанавливается с помощью прагмы &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; или по достижении конца блока, включающего &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . Обратите внимание, что вызовы &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; могут быть вложенными, и что то, что действует во внутренней области, вернется к правилам внешней области в конце внутренней области.</target>
        </trans-unit>
        <trans-unit id="ebc252c3cc028e1614732f1daa492845981dc49a" translate="yes" xml:space="preserve">
          <source>The default behavior is to allow either VMS or Unix syntax on input and to return VMS syntax on output unless Unix syntax has been explicitly requested via the &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; CRTL feature.</source>
          <target state="translated">Поведение по умолчанию - разрешить синтаксис VMS или Unix на входе и вернуть синтаксис VMS на выходе, если синтаксис Unix не был явно запрошен с помощью функции &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; CRTL.</target>
        </trans-unit>
        <trans-unit id="6dccc7bf2df4ee545fc6ed04ddf3f01c1358bdf3" translate="yes" xml:space="preserve">
          <source>The default behaviour of file test operators is to use the simple mode bits as returned by the stat() family of system calls. However, many operating systems have additional features to define more complex access rights, for example ACLs (Access Control Lists). For such environments, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; may help the permission operators to return results more consistent with other tools.</source>
          <target state="translated">По умолчанию операторы проверки файлов используют биты простого режима, возвращаемые семейством системных вызовов stat (). Однако многие операционные системы имеют дополнительные функции для определения более сложных прав доступа, например ACL (списки контроля доступа). В таких средах &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; может помочь операторам разрешений возвращать результаты, более согласованные с другими инструментами.</target>
        </trans-unit>
        <trans-unit id="1e443bdcb2163a4573139a1dc139dfc380443bd8" translate="yes" xml:space="preserve">
          <source>The default blacklist is [qw|ftp|], as &lt;code&gt;/bin/ftp&lt;/code&gt; is rather unreliable.</source>
          <target state="translated">Черный список по умолчанию - [qw | ftp |], так как &lt;code&gt;/bin/ftp&lt;/code&gt; довольно ненадежен.</target>
        </trans-unit>
        <trans-unit id="ed0767b7e5643475189138ab836319b55629d878" translate="yes" xml:space="preserve">
          <source>The default buffer size is 4096.</source>
          <target state="translated">По умолчанию размер буфера 4096.</target>
        </trans-unit>
        <trans-unit id="8bc00fd19b1a0edf6b2c0d08377dcc6685c37357" translate="yes" xml:space="preserve">
          <source>The default can be overridden by setting the environment variable PERLIO to a space separated list of layers (&lt;code&gt;unix&lt;/code&gt; or platform low level layer is always pushed first).</source>
          <target state="translated">Значение по умолчанию можно переопределить, установив для переменной среды PERLIO список слоев, разделенных пробелами ( уровень нижнего уровня &lt;code&gt;unix&lt;/code&gt; или платформы всегда помещается первым).</target>
        </trans-unit>
        <trans-unit id="34b91bbcac281ec343e20574aee63c504ba37c87" translate="yes" xml:space="preserve">
          <source>The default command shells on DOS descendant operating systems (such as they are) usually do not expand wildcard arguments supplied to programs. They consider it the application's job to handle that. This is commonly achieved by linking the application (in our case, perl) with startup code that the C runtime libraries usually provide. However, doing that results in incompatible perl versions (since the behavior of the argv expansion code differs depending on the compiler, and it is even buggy on some compilers). Besides, it may be a source of frustration if you use such a perl binary with an alternate shell that *does* expand wildcards.</source>
          <target state="translated">Командные оболочки по умолчанию на операционных системах-потомках DOS (таких,как они есть)обычно не расширяют аргументы подстановки подстановки,предоставляемые программам.Они считают это задачей приложения.Обычно это достигается компоновкой приложения (в нашем случае perl)с исходным кодом,который обычно предоставляют библиотеки времени исполнения C.Однако,это приводит к несовместимым версиям perl (так как поведение кода расширения argv отличается в зависимости от компилятора,а на некоторых компиляторах это даже является ошибкой).Кроме того,это может быть источником разочарования,если вы используете такой бинарный файл perl с альтернативной оболочкой,которая *does*расширяет подстановочные знаки.</target>
        </trans-unit>
        <trans-unit id="83afe3e15499ebffd14384524a4838c21ad9ac57" translate="yes" xml:space="preserve">
          <source>The default delivery policy of signals changed in Perl v5.8.0 from immediate (also known as &quot;unsafe&quot;) to deferred, also known as &quot;safe signals&quot;. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more information.</source>
          <target state="translated">Политика доставки сигналов по умолчанию в Perl v5.8.0 была изменена с немедленной (также известной как &amp;laquo;небезопасная&amp;raquo;) на отложенную, также известную как &amp;laquo;безопасные сигналы&amp;raquo;. См. &lt;a href=&quot;perlipc&quot;&gt;Perlipc&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="f60de20ca32864441bb2ece16480b765adbc68d5" translate="yes" xml:space="preserve">
          <source>The default filename translation is roughly &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr|/.|./|;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">По умолчанию перевод имени файла примерно равен &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr|/.|./|;&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="141616a08e099cc503e54695ac44f2c439029e1f" translate="yes" xml:space="preserve">
          <source>The default for this option is off.</source>
          <target state="translated">По умолчанию эта опция выключена.</target>
        </trans-unit>
        <trans-unit id="841e53532f4d336433d317d532f99affc692102b" translate="yes" xml:space="preserve">
          <source>The default hash function has been modified with the intention of making it harder to infer the hash seed.</source>
          <target state="translated">Функция хэша по умолчанию была изменена с целью затруднить вывод семени хэша.</target>
        </trans-unit>
        <trans-unit id="917b792910290b9f104f9e9bb1c1c376f6e62a1b" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing.</source>
          <target state="translated">Реализация по умолчанию ничего не делает.</target>
        </trans-unit>
        <trans-unit id="ba4a564c2fb984db1b9ac70f6b103f10fd3f2c07" translate="yes" xml:space="preserve">
          <source>The default in Perl 5.8.0 and later is to automatically use the &lt;code&gt;:perlio&lt;/code&gt; layer.</source>
          <target state="translated">По умолчанию в Perl 5.8.0 и новее автоматически используется слой &lt;code&gt;:perlio&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c034d8cea0ccefbe74b407c47763a2d7febf85bd" translate="yes" xml:space="preserve">
          <source>The default input &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is coming from. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDIN&lt;/code&gt; .</source>
          <target state="translated">Входной &lt;b&gt;поток&lt;/b&gt; по умолчанию для вашей программы, которому, если возможно, не важно, откуда берутся его данные. Представлен в программе Perl &lt;b&gt;дескриптором файла &lt;/b&gt; &lt;code&gt;STDIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c65b453abcd65763f1788a5bfac88b6cf8e06702" translate="yes" xml:space="preserve">
          <source>The default input and pattern-searching space. The following pairs are equivalent:</source>
          <target state="translated">Пространство для ввода и поиска шаблонов по умолчанию.Следующие пары эквивалентны:</target>
        </trans-unit>
        <trans-unit id="cea52ce10c001ee673712587e9b895266781fd26" translate="yes" xml:space="preserve">
          <source>The default installation directory of Perl under PASE is /QOpenSys/perl. This can be modified if needed with Configure parameter -Dprefix=/some/dir.</source>
          <target state="translated">По умолчанию каталогом установки Perl в PASE является /QOpenSys/perl.При необходимости его можно изменить с помощью параметра Configure -Dprefix=/some/dir.</target>
        </trans-unit>
        <trans-unit id="c02bd4590e22b3fdced3d71cd3c3281cc1a0a660" translate="yes" xml:space="preserve">
          <source>The default installation location for this release uses the traditional UNIX directory layout under /usr/local. This is the recommended location for most users, and will leave the Apple-supplied Perl and its modules undisturbed.</source>
          <target state="translated">Место установки по умолчанию для этого выпуска использует традиционную раскладку каталогов UNIX в каталоге /usr/local.Это рекомендуемое место установки для большинства пользователей,оно оставит нетронутым поставляемый Apple Perl и его модули.</target>
        </trans-unit>
        <trans-unit id="2cf27b908bba58a1adbe27495a165db5ad0a8770" translate="yes" xml:space="preserve">
          <source>The default is 0.</source>
          <target state="translated">По умолчанию 0.</target>
        </trans-unit>
        <trans-unit id="b6e007f998a46a63459c07f21e8e579bcd3ddb9e" translate="yes" xml:space="preserve">
          <source>The default is 0;</source>
          <target state="translated">По умолчанию 0;</target>
        </trans-unit>
        <trans-unit id="2fede1b14731afaa7b9b9368ecc641901f9fa509" translate="yes" xml:space="preserve">
          <source>The default is 1 when &lt;a href=&quot;../warnings&quot;&gt;warnings&lt;/a&gt; are enabled, 0 otherwise;</source>
          <target state="translated">По умолчанию 1, когда &lt;a href=&quot;../warnings&quot;&gt;предупреждения&lt;/a&gt; включены, в противном случае - 0;</target>
        </trans-unit>
        <trans-unit id="515832f976590cbb3c71bc0d7d3d0a86a107732b" translate="yes" xml:space="preserve">
          <source>The default is 1.</source>
          <target state="translated">По умолчанию 1.</target>
        </trans-unit>
        <trans-unit id="895305ba9904fa755bf8e86c105e9e415a01803b" translate="yes" xml:space="preserve">
          <source>The default is 15 seconds. If you set this value to 0, no timeout will occur, but this is not recommended.</source>
          <target state="translated">По умолчанию 15 секунд.Если вы установите это значение в 0,таймаут не произойдет,но это не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="df47c42104d45d72a320a61c09a39d1b3d97871e" translate="yes" xml:space="preserve">
          <source>The default is 1;</source>
          <target state="translated">По умолчанию 1;</target>
        </trans-unit>
        <trans-unit id="f462ad28c3fd0db899a9c6ebf2e36d1b531777fa" translate="yes" xml:space="preserve">
          <source>The default is 4096.</source>
          <target state="translated">По умолчанию 4096.</target>
        </trans-unit>
        <trans-unit id="32bc975de1e1a4635ed927b65955622d6412a442" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;0&lt;/code&gt; .</source>
          <target state="translated">По умолчанию - &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b05c3b862baf5dbb3b6628baf4b68b1570abdb4" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;1&lt;/code&gt; .</source>
          <target state="translated">По умолчанию &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e7ce922e57105bce0e95e91cfca276a6a4bf1ac" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;1&lt;/code&gt; for the root user and &lt;code&gt;0&lt;/code&gt; for normal users.</source>
          <target state="translated">По умолчанию это &lt;code&gt;1&lt;/code&gt; для пользователя root и &lt;code&gt;0&lt;/code&gt; для обычных пользователей.</target>
        </trans-unit>
        <trans-unit id="bbf2b1ea0900573472d5b071e3de19f7567ee6bd" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">По умолчанию - &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b961dbd8be6b25800dc4b37b67546efccad28f8e" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; .</source>
          <target state="translated">По умолчанию - &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc194b0254a7cf1688815756a4f2837510b9b267" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; .</source>
          <target state="translated">По умолчанию - &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb390eebfd5c04071c6f9ae432a01e30ec460a80" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;pod&lt;/code&gt; .</source>
          <target state="translated">По умолчанию - &lt;code&gt;pod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d0a0f1ca8eef2f6fbf6f39dbd7668ad5fbc612a" translate="yes" xml:space="preserve">
          <source>The default is Z_DEFAULT_COMPRESSION.</source>
          <target state="translated">По умолчанию Z_DEFAULT_COMPRESSION.</target>
        </trans-unit>
        <trans-unit id="ae93ce6388b29eb983caf1def75b439a9873a0b9" translate="yes" xml:space="preserve">
          <source>The default is Z_DEFAULT_STRATEGY.</source>
          <target state="translated">По умолчанию Z_DEFAULT_STRATEGY.</target>
        </trans-unit>
        <trans-unit id="b30329767ad59c2dc5630061d1ce79106ced2716" translate="yes" xml:space="preserve">
          <source>The default is no dictionary.</source>
          <target state="translated">По умолчанию не существует словаря.</target>
        </trans-unit>
        <trans-unit id="0eaff3b0b1b9eb661e7fc7bd656a07d77ba2a1ef" translate="yes" xml:space="preserve">
          <source>The default is not to cuddle.</source>
          <target state="translated">По умолчанию-не обниматься.</target>
        </trans-unit>
        <trans-unit id="9c65dc0d3752b5562d0e04006d66de6352709010" translate="yes" xml:space="preserve">
          <source>The default is to try &lt;code&gt;native&lt;/code&gt; , &lt;code&gt;tcp&lt;/code&gt; , &lt;code&gt;udp&lt;/code&gt; , &lt;code&gt;unix&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;stream&lt;/code&gt; , &lt;code&gt;console&lt;/code&gt; . Under systems with the Win32 API, &lt;code&gt;eventlog&lt;/code&gt; will be added as the first mechanism to try if &lt;code&gt;Win32::EventLog&lt;/code&gt; is available.</source>
          <target state="translated">По умолчанию используется &lt;code&gt;native&lt;/code&gt; , &lt;code&gt;tcp&lt;/code&gt; , &lt;code&gt;udp&lt;/code&gt; , &lt;code&gt;unix&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;stream&lt;/code&gt; , &lt;code&gt;console&lt;/code&gt; . В системах с Win32 API &lt;code&gt;eventlog&lt;/code&gt; будет добавлен в качестве первого механизма для проверки доступности &lt;code&gt;Win32::EventLog&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69bb3e1a426b5cc38eac62d98ea857e63ed9b5dd" translate="yes" xml:space="preserve">
          <source>The default iterator variable in a &lt;code&gt;foreach&lt;/code&gt; loop if no other variable is supplied.</source>
          <target state="translated">Переменная итератора по умолчанию в цикле &lt;code&gt;foreach&lt;/code&gt; , если не указана другая переменная.</target>
        </trans-unit>
        <trans-unit id="375ddf0ab7799023484d02f8a221ca6afd3b2054" translate="yes" xml:space="preserve">
          <source>The default memory limit is 2Mib. You can adjust the maximum read cache size by supplying the &lt;code&gt;memory&lt;/code&gt; option. The argument is the desired cache size, in bytes.</source>
          <target state="translated">Предел памяти по умолчанию - 2 МБ. Вы можете настроить максимальный размер кэша чтения, указав параметр &lt;code&gt;memory&lt;/code&gt; . Аргументом является желаемый размер кеша в байтах.</target>
        </trans-unit>
        <trans-unit id="97d617432e38273ff2337188090afe707d321e91" translate="yes" xml:space="preserve">
          <source>The default method is ZIP_CM_DEFLATE.</source>
          <target state="translated">Метод по умолчанию ZIP_CM_DEFLATE.</target>
        </trans-unit>
        <trans-unit id="d06faea5104288d8b0b633dc0567b8b191f0df74" translate="yes" xml:space="preserve">
          <source>The default name of the new configuration file is &quot;libnet.cfg&quot;, and by default it is written to the current directory, unless otherwise specified using the -o option, &lt;code&gt;-o newfile&lt;/code&gt; .</source>
          <target state="translated">Имя нового файла конфигурации по умолчанию - &amp;laquo;libnet.cfg&amp;raquo;, и по умолчанию он записывается в текущий каталог, если иное не указано с помощью параметра -o, &lt;code&gt;-o newfile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e5074809750e6c620d635552cb416989d3d15b2" translate="yes" xml:space="preserve">
          <source>The default name of the old configuration file is by default &quot;libnet.cfg&quot;, unless otherwise specified using the -i option, &lt;code&gt;-i oldfile&lt;/code&gt; , and it is searched first from the current directory, and then from your module path.</source>
          <target state="translated">Имя старого файла конфигурации по умолчанию - &quot;libnet.cfg&quot;, если иное не указано с помощью параметра -i, &lt;code&gt;-i oldfile&lt;/code&gt; , и поиск выполняется сначала из текущего каталога, а затем из пути к вашему модулю.</target>
        </trans-unit>
        <trans-unit id="5eb6185afb472dae00827acf41154ba83b345446" translate="yes" xml:space="preserve">
          <source>The default normalizer just concatenates the arguments with character 28 in between. (In ASCII, this is called FS or control-\.) This always works correctly for functions with only one string argument, and also when the arguments never contain character 28. However, it can confuse certain argument lists:</source>
          <target state="translated">Нормализатор по умолчанию просто конкапсулирует аргументы с символом 28 между ними.(В ASCII это называется FS или control-\.)Это всегда корректно работает для функций только с одним строковым аргументом,а также когда аргументы никогда не содержат символ 28.Однако,это может запутать некоторые списки аргументов:</target>
        </trans-unit>
        <trans-unit id="b39e82de8afe051a851d53770ae84cf3c68d41cb" translate="yes" xml:space="preserve">
          <source>The default normalizer will turn this into something like &lt;code&gt;&quot;13\034ARRAY(0x436c1f)&quot;&lt;/code&gt; . That would be all right, except that a subsequent array of numbers might be stored at a different location even though it contains the same data. If this happens, &lt;code&gt;Memoize&lt;/code&gt; will think that the arguments are different, even though they are equivalent. In this case, a normalizer like this is appropriate:</source>
          <target state="translated">Нормализатор по умолчанию превратит это во что-то вроде &lt;code&gt;&quot;13\034ARRAY(0x436c1f)&quot;&lt;/code&gt; . Это было бы хорошо, за исключением того, что последующий массив чисел может храниться в другом месте, даже если он содержит те же данные. Если это произойдет, &lt;code&gt;Memoize&lt;/code&gt; будет думать, что аргументы разные, даже если они эквивалентны. В этом случае подходит такой нормализатор:</target>
        </trans-unit>
        <trans-unit id="e5d60aed408340ddef56e731c14beba1f193a756" translate="yes" xml:space="preserve">
          <source>The default of building Perl statically may cause problems with complex applications like Tk: in that case consider building shared Perl</source>
          <target state="translated">По умолчанию сборка Perl статически может вызвать проблемы со сложными приложениями,такими как Tk:в этом случае рассмотрим сборку общего Perl</target>
        </trans-unit>
        <trans-unit id="ac5f6413f6edd9db793b85ce42ea2d862be3c9a0" translate="yes" xml:space="preserve">
          <source>The default operator mask for a newly created compartment is the ':default' optag.</source>
          <target state="translated">Оператором по умолчанию для вновь созданного помещения является оптаг ':по умолчанию'.</target>
        </trans-unit>
        <trans-unit id="cd7a35f6ae99c836f5d425b35999dec2510b2218" translate="yes" xml:space="preserve">
          <source>The default options gathered by Configure with the assistance of</source>
          <target state="translated">Опции по умолчанию,собранные Настроить с помощью</target>
        </trans-unit>
        <trans-unit id="340bacd1cab82a806d284b26719b4d768c188a8d" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for nasty remarks that don&amp;rsquo;t belong in &lt;b&gt;standard output&lt;/b&gt;. Represented within a Perl program by the output&amp;gt; &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDERR&lt;/code&gt; . You can use this stream explicitly, but the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; built-ins write to your standard error stream automatically (unless trapped or otherwise intercepted).</source>
          <target state="translated">Вывода по умолчанию &lt;b&gt;поток&lt;/b&gt; для противных замечаний , которые не входят в &lt;b&gt;стандартный вывод&lt;/b&gt; . Представлен в программе Perl выходным&amp;gt; &lt;b&gt;дескриптором файла &lt;/b&gt; &lt;code&gt;STDERR&lt;/code&gt; . Вы можете использовать этот поток явно, но встроенные модули &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; записываются в стандартный поток ошибок автоматически (если только они не были захвачены или перехвачены иным образом).</target>
        </trans-unit>
        <trans-unit id="aa254ec270a416bb3ac03f5a884b155a435c80cb" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is going. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">Выходной &lt;b&gt;поток&lt;/b&gt; по умолчанию для вашей программы, которому, если возможно, не важно, куда идут его данные. Представлен в программе Perl &lt;b&gt;дескриптором файла &lt;/b&gt; &lt;code&gt;STDOUT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e96d4d616212a6cfd4d2816b5ab3f17c9db66319" translate="yes" xml:space="preserve">
          <source>The default output of self-referential structures can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed, but the nested references to &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">Вывод по умолчанию самореферентных структур может быть &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , но вложенные ссылки на &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a5f2d9e51d87e9b71a9bd992e69d11af3ccda88f" translate="yes" xml:space="preserve">
          <source>The default path for perl binary is /QOpenSys/perl/bin/perl. You'll want to symlink /QOpenSys/usr/bin/perl to this file so you don't have to modify your path.</source>
          <target state="translated">Путь по умолчанию для двоичного файла perl-/QOpenSys/perl/bin/perl.Вы захотите создать сим-ссылку /QOpenSys/usr/bin/perl на этот файл,чтобы вам не пришлось изменять путь.</target>
        </trans-unit>
        <trans-unit id="c0e7903465e131bba24e8f9fa0f5926ebf1b8dce" translate="yes" xml:space="preserve">
          <source>The default per-thread stack size for different platforms varies significantly, and is almost always far more than is needed for most applications. On Win32, Perl's makefile explicitly sets the default stack to 16 MB; on most other platforms, the system default is used, which again may be much larger than is needed.</source>
          <target state="translated">Размер стека по умолчанию для разных платформ значительно варьируется и почти всегда намного больше,чем требуется для большинства приложений.На Win32 makefile Perl явно устанавливает размер стека по умолчанию в 16 МБ;на большинстве других платформ используется системный стек по умолчанию,который опять-таки может быть намного больше,чем требуется.</target>
        </trans-unit>
        <trans-unit id="02fbe3c9bc6d319100d5d82a643c83d45a2aaf27" translate="yes" xml:space="preserve">
          <source>The default per-thread stack size may be set at the start of the application through the use of the environment variable &lt;code&gt;PERL5_ITHREADS_STACK_SIZE&lt;/code&gt; :</source>
          <target state="translated">Размер стека по умолчанию для каждого потока может быть установлен при запуске приложения с помощью переменной среды &lt;code&gt;PERL5_ITHREADS_STACK_SIZE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d17c04396f5d2338f66524479b64e4296e2bc5c4" translate="yes" xml:space="preserve">
          <source>The default perl executable is flexible enough to support most usages. However, one may want something yet more flexible; for example, one may want to find Perl DLL relatively to the location of the EXE file; or one may want to ignore the environment when setting the Perl-library search patch, etc.</source>
          <target state="translated">Исполняемый файл perl по умолчанию достаточно гибкий,чтобы поддерживать большинство функций.Однако,может понадобиться что-то более гибкое;например,можно найти Perl DLL относительно места расположения EXE-файла;или можно игнорировать окружение при установке патча для поиска Perl-библиотеки и т.д.</target>
        </trans-unit>
        <trans-unit id="7009bdcf386245a7873fc69dc2c48c3bfdcf71d9" translate="yes" xml:space="preserve">
          <source>The default permissions to use if a new file is created. The actual permissions will be modified by the user's umask, so you should probably use 0666 here. (See &lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;.)</source>
          <target state="translated">Разрешения по умолчанию, используемые при создании нового файла. Фактические разрешения будут изменены umask пользователя, поэтому вам, вероятно, следует использовать здесь 0666. (См. &lt;a href=&quot;functions/umask&quot;&gt;Umask&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="af672db5716c0b823ab6d08666d2a653d572eae5" translate="yes" xml:space="preserve">
          <source>The default place to put the next value or input record when a &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; operation's result is tested by itself as the sole criterion of a &lt;code&gt;while&lt;/code&gt; test. Outside a &lt;code&gt;while&lt;/code&gt; test, this will not happen.</source>
          <target state="translated">Место по умолчанию для размещения следующего значения или входной записи, когда &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; или результат &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; операции проверяется сам по себе в качестве единственного критерия теста &lt;code&gt;while&lt;/code&gt; . Вне в &lt;code&gt;while&lt;/code&gt; тест, это не произойдет.</target>
        </trans-unit>
        <trans-unit id="c5df9208ed1f779ba0f9d5864d277d9b22483511" translate="yes" xml:space="preserve">
          <source>The default rendering is top-down, so they're not in execution order. This form reflects the way the stack is used to parse and evaluate expressions; the add operates on the two terms below it in the tree.</source>
          <target state="translated">По умолчанию рендеринг ведется сверху вниз,поэтому они не находятся в порядке исполнения.Эта форма отражает то,как стек используется для разбора и оценки выражений;добавление оперирует двумя терминами,расположенными под ним в дереве.</target>
        </trans-unit>
        <trans-unit id="2fc20ab6a2146e41cd4461ac23c56be7f29f5c25" translate="yes" xml:space="preserve">
          <source>The default rounding mode is 'even'. By using &lt;code&gt;Math::BigFloat-&amp;gt;round_mode($round_mode);&lt;/code&gt; you can get and set the default mode for subsequent rounding. The usage of &lt;code&gt;$Math::BigFloat::$round_mode&lt;/code&gt; is no longer supported. The second parameter to the round functions then overrides the default temporarily.</source>
          <target state="translated">По умолчанию используется режим округления &amp;laquo;четный&amp;raquo;. Используя &lt;code&gt;Math::BigFloat-&amp;gt;round_mode($round_mode);&lt;/code&gt; вы можете получить и установить режим по умолчанию для последующего округления. Использование &lt;code&gt;$Math::BigFloat::$round_mode&lt;/code&gt; больше не поддерживается. Затем второй параметр функций округления временно отменяет значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0c0082ed0ee0f68ac7247af3405f6e36532a7d14" translate="yes" xml:space="preserve">
          <source>The default set of layers should give acceptable results on all platforms</source>
          <target state="translated">Набор слоев по умолчанию должен давать приемлемые результаты на всех платформах</target>
        </trans-unit>
        <trans-unit id="98f212f2163021f600388dfedb85757788b2ee77" translate="yes" xml:space="preserve">
          <source>The default sort function is cmp, string comparison, which would sort &lt;code&gt;(1, 2, 10)&lt;/code&gt; into &lt;code&gt;(1, 10, 2)&lt;/code&gt; . &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; , used above, is the numerical comparison operator.</source>
          <target state="translated">Функция сортировки по умолчанию - cmp, сравнение строк, которая сортирует &lt;code&gt;(1, 2, 10)&lt;/code&gt; в &lt;code&gt;(1, 10, 2)&lt;/code&gt; . &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; , использованный выше, является оператором числового сравнения.</target>
        </trans-unit>
        <trans-unit id="baa9ec2a72f812d2fff5978a7051ec1d9ead2a46" translate="yes" xml:space="preserve">
          <source>The default subscript separator is &quot;\034&quot;, the same as SUBSEP in &lt;b&gt;awk&lt;/b&gt;.</source>
          <target state="translated">Разделитель нижнего индекса по умолчанию - &quot;\ 034&quot;, такой же, как SUBSEP в &lt;b&gt;awk&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="fedbef30ad12f7c78358c3195161f7bf65ed2265" translate="yes" xml:space="preserve">
          <source>The default text formatter is &lt;a href=&quot;text&quot;&gt;Pod::Text&lt;/a&gt;. The base class for Pod::Usage can be defined by pre-setting &lt;code&gt;$Pod::Usage::Formatter&lt;/code&gt;</source>
          <target state="translated">Средство форматирования текста по умолчанию - &lt;a href=&quot;text&quot;&gt;Pod :: Text&lt;/a&gt; . Базовый класс для Pod :: Usage можно определить, предварительно установив &lt;code&gt;$Pod::Usage::Formatter&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2eca7e39567cc3a4e38f07441f8e4f7046f9b14f" translate="yes" xml:space="preserve">
          <source>The default type for the constants. If not specified &lt;code&gt;IV&lt;/code&gt; is assumed.</source>
          <target state="translated">Тип по умолчанию для констант. Если не указано иное, предполагается &lt;code&gt;IV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a6f652439685a6a403073936eade467faa79602" translate="yes" xml:space="preserve">
          <source>The default typemap in the</source>
          <target state="translated">Типовая карта по умолчанию в</target>
        </trans-unit>
        <trans-unit id="82f3cb0c641077271c3068ea9c85e22ba715cfbb" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;div_scale&lt;/code&gt; is 40.</source>
          <target state="translated">Значение по умолчанию для &lt;code&gt;div_scale&lt;/code&gt; - 40.</target>
        </trans-unit>
        <trans-unit id="609bf4918ead31f720f19323f5cf2348643f6d2e" translate="yes" xml:space="preserve">
          <source>The default value for CCHOME in the makefiles for Visual C++ may not be correct for some versions. Make sure the default exists and is valid.</source>
          <target state="translated">Значение по умолчанию для CCHOME в makefiles для Visual C++может быть некорректным для некоторых версий.Убедитесь,что значение по умолчанию существует и является правильным.</target>
        </trans-unit>
        <trans-unit id="1f34862d6782defbe2c5b2a0445c8f00de39fa4d" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;XSINTERFACE_FUNC&lt;/code&gt; and &lt;code&gt;XSINTERFACE_FUNC_SET&lt;/code&gt; . An INTERFACE keyword with an empty list of functions can be omitted if INTERFACE_MACRO keyword is used.</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;XSINTERFACE_FUNC&lt;/code&gt; и &lt;code&gt;XSINTERFACE_FUNC_SET&lt;/code&gt; . Ключевое слово INTERFACE с пустым списком функций может быть опущено, если используется ключевое слово INTERFACE_MACRO.</target>
        </trans-unit>
        <trans-unit id="3ae2f809fd681df4fcb45c0c13d99a0283fc66b8" translate="yes" xml:space="preserve">
          <source>The definition used for complex arguments of atan2() is</source>
          <target state="translated">Определение,используемое для сложных аргументов atan2(),следующее</target>
        </trans-unit>
        <trans-unit id="6431fb44fb840f90a758f20a67dcf8b7a9374aa9" translate="yes" xml:space="preserve">
          <source>The del_dup() Method</source>
          <target state="translated">Метод del_dup()</target>
        </trans-unit>
        <trans-unit id="ed1ded41373481d9b3a2afdb892465f6f5d0d39d" translate="yes" xml:space="preserve">
          <source>The delimiter provided to &lt;code&gt;extract_bracketed&lt;/code&gt; was not one of &lt;code&gt;'()[]&amp;lt;&amp;gt;{}'&lt;/code&gt; .</source>
          <target state="translated">Разделитель, предоставленный для &lt;code&gt;extract_bracketed&lt;/code&gt; , не был одним из &lt;code&gt;'()[]&amp;lt;&amp;gt;{}'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e6b6844fe43a8d8ec1aad6ff952638a46635ab3" translate="yes" xml:space="preserve">
          <source>The denizens of makemaker@perl.org.</source>
          <target state="translated">Денизены makemaker@perl.org.</target>
        </trans-unit>
        <trans-unit id="d6c12d31655a68b617bd8f8ac7d7b41ffa97d8df" translate="yes" xml:space="preserve">
          <source>The dereferencing cases (as opposed to method-calling cases) are somewhat extended by the experimental &lt;code&gt;postderef&lt;/code&gt; feature. For the details of that feature, consult &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;Postfix Dereference Syntax in perlref&lt;/a&gt;.</source>
          <target state="translated">Варианты разыменования (в отличие от случаев вызова методов) несколько расширены экспериментальной &lt;code&gt;postderef&lt;/code&gt; . Для получения подробной информации об этой функции обратитесь &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;к синтаксису разыменования постфикса в perlref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c06b4b9a1d8e7058531ada60d67614dbcf01dfd0" translate="yes" xml:space="preserve">
          <source>The deserializing hook called on the object during deserialization. But wait: if we're deserializing, there's no object yet... right?</source>
          <target state="translated">Крючок для десериализации вызывал объект во время десериализации.Но подождите:если мы дезериализуем,то пока нет никакого объекта...верно?</target>
        </trans-unit>
        <trans-unit id="8a2f99ef5bda346c32f63e70a7361acb83da8b02" translate="yes" xml:space="preserve">
          <source>The design intent is for &lt;code&gt;\d&lt;/code&gt; to exactly match the set of characters that can safely be used with &quot;normal&quot; big-endian positional decimal syntax, where, for example 123 means one 'hundred', plus two 'tens', plus three 'ones'. This positional notation does not necessarily apply to characters that match the other type of &quot;digit&quot;, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , and so &lt;code&gt;\d&lt;/code&gt; doesn't match them.</source>
          <target state="translated">Замысел проекта состоит в том, чтобы &lt;code&gt;\d&lt;/code&gt; точно соответствовал набору символов, который можно безопасно использовать с &quot;нормальным&quot; позиционным десятичным синтаксисом с прямым порядком байтов, где, например, 123 означает одну &quot;сотню&quot; плюс две &quot;десятки&quot; плюс три &quot; один. Это позиционное обозначение не обязательно применяется к символам, которые соответствуют другому типу &amp;laquo;цифры&amp;raquo;, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , и поэтому &lt;code&gt;\d&lt;/code&gt; им не соответствует.</target>
        </trans-unit>
        <trans-unit id="d6ec3b1b57d74d9cf92c20c7537d430a4cb91982" translate="yes" xml:space="preserve">
          <source>The desire of users to express filenames of the form &lt;code&gt;&amp;lt;Foo$Dir&amp;gt;.Bar&lt;/code&gt; on the command line unquoted causes problems, too: &lt;code&gt;``&lt;/code&gt; command output capture has to perform a guessing game. It assumes that a string &lt;code&gt;&amp;lt;[^&amp;lt;&amp;gt;]+\$[^&amp;lt;&amp;gt;]&amp;gt;&lt;/code&gt; is a reference to an environment variable, whereas anything else involving &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; is redirection, and generally manages to be 99% right. Of course, the problem remains that scripts cannot rely on any Unix tools being available, or that any tools found have Unix-like command line arguments.</source>
          <target state="translated">Желание пользователей выразить имена файлов в форме &lt;code&gt;&amp;lt;Foo$Dir&amp;gt;.Bar&lt;/code&gt; в командной строке без кавычек также вызывает проблемы: &lt;code&gt;``&lt;/code&gt; захват вывода команды должен выполнять игру в угадывание. Предполагается, что строка &lt;code&gt;&amp;lt;[^&amp;lt;&amp;gt;]+\$[^&amp;lt;&amp;gt;]&amp;gt;&lt;/code&gt; является ссылкой на переменную окружения, тогда как все остальное, связанное с &lt;code&gt;&amp;lt;&lt;/code&gt; или &lt;code&gt;&amp;gt;&lt;/code&gt; , является перенаправлением и, как правило, оказывается правильным на 99%. Конечно, проблема остается в том, что сценарии не могут полагаться на какие-либо доступные инструменты Unix или что любые найденные инструменты имеют аргументы командной строки, подобные Unix.</target>
        </trans-unit>
        <trans-unit id="a11af240187e8ce0ea57c0f5d9817fa72798ba59" translate="yes" xml:space="preserve">
          <source>The desired exit status to pass to the &lt;b&gt;exit()&lt;/b&gt; function. This should be an integer, or else the string &quot;NOEXIT&quot; to indicate that control should simply be returned without terminating the invoking process.</source>
          <target state="translated">Желаемый статус выхода для перехода к функции &lt;b&gt;exit ()&lt;/b&gt; . Это должно быть целое число или строка &amp;laquo;NOEXIT&amp;raquo;, указывающая, что управление должно быть просто возвращено без завершения вызывающего процесса.</target>
        </trans-unit>
        <trans-unit id="a47bdc95431692c8deb0f97084523a81a5887de3" translate="yes" xml:space="preserve">
          <source>The desired level of &quot;verboseness&quot; to use when printing the usage message. If the corresponding value is 0, then only the &quot;SYNOPSIS&quot; section of the pod documentation is printed. If the corresponding value is 1, then the &quot;SYNOPSIS&quot; section, along with any section entitled &quot;OPTIONS&quot;, &quot;ARGUMENTS&quot;, or &quot;OPTIONS AND ARGUMENTS&quot; is printed. If the corresponding value is 2 or more then the entire manpage is printed.</source>
          <target state="translated">Желаемый уровень &quot;глаголовой неопределенности&quot; для использования при печати сообщения об использовании.Если соответствующее значение равно 0,то печатается только раздел &quot;SYNOPSIS&quot; документации по подставке.Если соответствующее значение равно 1,то печатается раздел &quot;СИНОПСИС&quot;,а также любой раздел под названием &quot;ВНИМАНИЯ&quot;,&quot;АРГУМЕНТЫ&quot; или &quot;ВНИМАНИЯ И АРГУМЕНТЫ&quot;.Если соответствующее значение равно 2 или более,то печатается вся рабочая страница.</target>
        </trans-unit>
        <trans-unit id="2b3e64d006f3001c3df4472f5962fd664df30c48" translate="yes" xml:space="preserve">
          <source>The desired level of verbosity to use:</source>
          <target state="translated">Желаемый уровень глаголов:</target>
        </trans-unit>
        <trans-unit id="1f8c4d84dbcf0f5f2d69ca16b4ced3235af3fefd" translate="yes" xml:space="preserve">
          <source>The destination for the option must be an array or array reference.</source>
          <target state="translated">Местом назначения опции должен быть массив или ссылка на массив.</target>
        </trans-unit>
        <trans-unit id="2940ce84da888fbb72c23c514c9cdd4e2c7bab4a" translate="yes" xml:space="preserve">
          <source>The detection algorithm works something like this:</source>
          <target state="translated">Алгоритм обнаружения работает примерно так:</target>
        </trans-unit>
        <trans-unit id="cfd0b50108607e59344e69b0de3bc9fd4f301247" translate="yes" xml:space="preserve">
          <source>The diagnostics Pragma</source>
          <target state="translated">Диагностика Прагма</target>
        </trans-unit>
        <trans-unit id="9e8272da23da05393615d77b37bcea56278deff5" translate="yes" xml:space="preserve">
          <source>The diagnostics of this test normally just refer to 'the object'. If you'd like them to be more specific, you can supply an $object_name (for example 'Test customer').</source>
          <target state="translated">Диагностика этого теста обычно относится только к &quot;объекту&quot;.Если вы хотите,чтобы они были более конкретными,то можете указать имя $object_name (например,'Test customer').</target>
        </trans-unit>
        <trans-unit id="67027b213e7e98e89fd8e5ebf75f4789f0806d73" translate="yes" xml:space="preserve">
          <source>The diagram below represents a single source stream, with the flow of source from a Perl script file on the left into the Perl parser on the right. This is how Perl normally operates.</source>
          <target state="translated">Диаграмма ниже представляет собой единый поток исходных текстов,с потоком исходных текстов из файла скрипта Perl слева в парсер Perl справа.Так обычно работает Perl.</target>
        </trans-unit>
        <trans-unit id="09d12bc25e1c17128a784d1b2ff7f2b3ea6c5f9e" translate="yes" xml:space="preserve">
          <source>The die on line 4 pops the context stack back down to the CxEVAL, leaving it as:</source>
          <target state="translated">На четвертой строке появляется контекстный стек обратно вниз к CxEVAL,оставляя его как:</target>
        </trans-unit>
        <trans-unit id="930610eed704196a6c02e9606fed36fd7cdf0a59" translate="yes" xml:space="preserve">
          <source>The die pops the first &lt;code&gt;CxEVAL&lt;/code&gt; off the context stack, sets &lt;code&gt;PL_restartop&lt;/code&gt; from it, does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; , and control returns to the top &lt;code&gt;docatch&lt;/code&gt; . This then starts another third-level runops level, which executes the nextstate, pushmark and die ops on line 4. At the point that the second &lt;code&gt;pp_die&lt;/code&gt; is called, the C call stack looks exactly like that above, even though we are no longer within an inner eval; this is because of the optimization mentioned earlier. However, the context stack now looks like this, ie with the top CxEVAL popped:</source>
          <target state="translated">&lt;code&gt;CxEVAL&lt;/code&gt; первый CxEVAL из стека контекста, устанавливает из него &lt;code&gt;PL_restartop&lt;/code&gt; , выполняет &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; , и управление возвращается в верхний &lt;code&gt;docatch&lt;/code&gt; . Затем запускается еще один уровень runops третьего уровня, который выполняет операции nextstate, pushmark и die в строке 4. В момент, когда &lt;code&gt;pp_die&lt;/code&gt; второй pp_die , стек вызовов C выглядит точно так же, как указано выше, даже если мы уже не внутри внутренний eval; это из-за оптимизации, упомянутой ранее. Однако стек контекста теперь выглядит так, т.е. с выдвинутым верхним CxEVAL:</target>
        </trans-unit>
        <trans-unit id="6ed5acbfe1a4a69e2eecb34b13c8306880da82cf" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;extract_tagged&lt;/code&gt; and the anonymous subroutines generated by &lt;code&gt;gen_extract_tagged&lt;/code&gt; , is that those generated subroutines:</source>
          <target state="translated">Разница между &lt;code&gt;extract_tagged&lt;/code&gt; и анонимными подпрограммами, сгенерированными &lt;code&gt;gen_extract_tagged&lt;/code&gt; , заключается в том, что эти сгенерированные подпрограммы:</target>
        </trans-unit>
        <trans-unit id="7e6f28f40692ae97e2ea2e8080e59d267505ccf0" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;minlen&lt;/code&gt; and &lt;code&gt;minlenret&lt;/code&gt; can be seen in the following pattern:</source>
          <target state="translated">Разницу между &lt;code&gt;minlen&lt;/code&gt; и &lt;code&gt;minlenret&lt;/code&gt; можно увидеть в следующем образце:</target>
        </trans-unit>
        <trans-unit id="f8ae9fbf98646f2ef8526e7b39bf817f11262438" translate="yes" xml:space="preserve">
          <source>The difference between a block and a script is that scripts are closer to the linguistic notion of a set of code points required to represent languages, while block is more of an artifact of the Unicode code point numbering and separation into blocks of consecutive code points (so far the size of a block is some multiple of 16, like 128 or 256).</source>
          <target state="translated">Отличие блока от скрипта состоит в том,что скрипты ближе к языковому понятию набора точек кода,необходимых для представления языков,в то время как блок является скорее артефактом нумерации точек кода Юникода и разделения на блоки последовательных точек кода (до сих пор размер блока несколько кратный 16,например 128 или 256).</target>
        </trans-unit>
        <trans-unit id="4e0fd5df1eb8c3e578915cd6f8934c4fe5cf676a" translate="yes" xml:space="preserve">
          <source>The difference between these two properties involves characters that are used in multiple scripts. For example the digits '0' through '9' are used in many parts of the world. These are placed in a script named &lt;code&gt;Common&lt;/code&gt; . Other characters are used in just a few scripts. For example, the &lt;code&gt;&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot;&lt;/code&gt; is used in both Japanese scripts, Katakana and Hiragana, but nowhere else. The &lt;code&gt;Script&lt;/code&gt; property places all characters that are used in multiple scripts in the &lt;code&gt;Common&lt;/code&gt; script, while the &lt;code&gt;Script_Extensions&lt;/code&gt; property places those that are used in only a few scripts into each of those scripts; while still using &lt;code&gt;Common&lt;/code&gt; for those used in many scripts. Thus both these match:</source>
          <target state="translated">Разница между этими двумя свойствами заключается в символах, которые используются в нескольких скриптах. Например, цифры от &amp;laquo;0&amp;raquo; до &amp;laquo;9&amp;raquo; используются во многих частях мира. Они помещаются в скрипт с именем &lt;code&gt;Common&lt;/code&gt; . Другие символы используются всего в нескольких сценариях. Например, &lt;code&gt;&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot;&lt;/code&gt; используется в обоих японских шрифтах, Катакане и Хирагане, но больше нигде. Свойство &lt;code&gt;Script&lt;/code&gt; помещает все символы, которые используются в нескольких сценариях, в &lt;code&gt;Common&lt;/code&gt; сценарий, а свойство &lt;code&gt;Script_Extensions&lt;/code&gt; помещает символы , которые используются только в нескольких сценариях, в каждый из этих сценариев; пока все еще используется &lt;code&gt;Common&lt;/code&gt; для тех, которые используются во многих скриптах. Таким образом, оба эти совпадения:</target>
        </trans-unit>
        <trans-unit id="f324cedd823e628f1ed8025386bfb26cab3778ab" translate="yes" xml:space="preserve">
          <source>The difference is clear to see and the dereferencing approach is slower. While it managed to execute an average of 628,930 times a second during our test, the direct approach managed to run an additional 204,403 times, unfortunately. Unfortunately, because there are many examples of code written using the multiple layer direct variable access, and it's usually horrible. It is, however, minusculy faster. The question remains whether the minute gain is actually worth the eyestrain, or the loss of maintainability.</source>
          <target state="translated">Разница очевидна,а подход с использованием разыменования происходит медленнее.В то время как во время нашего теста ему удалось выполнить в среднем 628 930 раз в секунду,при прямом подходе,к сожалению,удалось выполнить еще 204 403 раза.К сожалению,потому что примеров кода,написанного с использованием многоуровневого прямого доступа к переменным,много,и это,как правило,ужасно.Однако он работает в несколько раз быстрее.Остается вопрос,стоит ли на самом деле минутный выигрыш зрительного нерва,или же это потеря удобства обслуживания.</target>
        </trans-unit>
        <trans-unit id="c9d466e6cdc3e3b171ba671cc22acace7243054b" translate="yes" xml:space="preserve">
          <source>The difference is the sigil, that special character in front of the array name. The &lt;code&gt;$&lt;/code&gt; sigil means &quot;exactly one item&quot;, while the &lt;code&gt;@&lt;/code&gt; sigil means &quot;zero or more items&quot;. The &lt;code&gt;$&lt;/code&gt; gets you a single scalar, while the &lt;code&gt;@&lt;/code&gt; gets you a list.</source>
          <target state="translated">Разница в сигиле, специальном символе перед именем массива. Символ &lt;code&gt;$&lt;/code&gt; означает &amp;laquo;ровно один элемент&amp;raquo;, а символ &lt;code&gt;@&lt;/code&gt; означает &amp;laquo;ноль или более элементов&amp;raquo;. &lt;code&gt;$&lt;/code&gt; Получает вас один скаляр, в то время как &lt;code&gt;@&lt;/code&gt; получает вам список.</target>
        </trans-unit>
        <trans-unit id="c2b0921f524dbbf7564616e5853365d0c767bfc6" translate="yes" xml:space="preserve">
          <source>The digest can be delivered in three formats:</source>
          <target state="translated">Дайджест может быть доставлен в трех форматах:</target>
        </trans-unit>
        <trans-unit id="0155d0c091234cee22dc790957626f27306487e0" translate="yes" xml:space="preserve">
          <source>The direction you must follow the great circle (also known as</source>
          <target state="translated">Направление,в котором вы должны следовать по большому кругу (также известному как</target>
        </trans-unit>
        <trans-unit id="03d134305af0df1045ab396312ef86cfab55c5d9" translate="yes" xml:space="preserve">
          <source>The direction you would have to go from London to Tokyo (in radians, straight north being zero, straight east being pi/2).</source>
          <target state="translated">Направление от Лондона до Токио (в радиусах,прямо на север-ноль,прямо на восток-пи/2).</target>
        </trans-unit>
        <trans-unit id="9159a72a045b505fc788bec97c5202fb7f87247c" translate="yes" xml:space="preserve">
          <source>The directory portion may or may not be returned with a trailing '/'.</source>
          <target state="translated">Часть каталога может возвращаться или не возвращаться с замыкающим символом &quot;/&quot;.</target>
        </trans-unit>
        <trans-unit id="efd54b0e8774d4521e37e9c7dad7074640dfad53" translate="yes" xml:space="preserve">
          <source>The directory you are put into when you log in. On a Unix system, the name is often placed into &lt;code&gt;$ENV{HOME}&lt;/code&gt; or &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; by</source>
          <target state="translated">Каталог, в который вы попадаете при входе в систему. В системе Unix имя часто помещается в &lt;code&gt;$ENV{HOME}&lt;/code&gt; или &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; помощью</target>
        </trans-unit>
        <trans-unit id="0f834768c044521ed2139a347066ecd1f6fd454d" translate="yes" xml:space="preserve">
          <source>The directory, if specified, must appear immediately following the &lt;b&gt;-x&lt;/b&gt; with no intervening whitespace.</source>
          <target state="translated">Каталог, если он указан, должен располагаться сразу после &lt;b&gt;-x&lt;/b&gt; без пробелов.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
