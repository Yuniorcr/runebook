<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d57dd39f43cd00fc9fcf08a3e6ef2330c6e56ff0" translate="yes" xml:space="preserve">
          <source>The following will determine the maximum length of the longest allowable pathname on the filesystem which holds &lt;code&gt;/var&lt;/code&gt;.</source>
          <target state="translated">Следующее будет определять максимальную длину самого длинного допустимого пути в файловой системе, которая содержит &lt;code&gt;/var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cbb13ad67db7840db7c7d12b58ddc55ef0ed900" translate="yes" xml:space="preserve">
          <source>The following will get the machine's clock speed.</source>
          <target state="translated">Следующие получат тактовую частоту машины.</target>
        </trans-unit>
        <trans-unit id="577c472e2dc0fc4d87aa88d05e48ae7e476e2971" translate="yes" xml:space="preserve">
          <source>The following will probably not do what you expect:</source>
          <target state="translated">Нижеследующее,вероятно,не оправдает ваших ожиданий:</target>
        </trans-unit>
        <trans-unit id="5c8bd82fe901dea332f23983ad9e29577c0fed4c" translate="yes" xml:space="preserve">
          <source>The following will probably not print what you expect:</source>
          <target state="translated">Нижеследующее,вероятно,не напечатает то,что вы ожидаете:</target>
        </trans-unit>
        <trans-unit id="119de64c9692dd9e013f0596370be8f29169b856" translate="yes" xml:space="preserve">
          <source>The following will query the current &lt;code&gt;LC_CTYPE&lt;/code&gt; category. (No second argument means 'query'.)</source>
          <target state="translated">Следующее будет запрашивать текущую категорию &lt;code&gt;LC_CTYPE&lt;/code&gt; . (Отсутствие второго аргумента означает &amp;laquo;запрос&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="5966453b4cde6268559966748dc7d8bf8fdd0ec2" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_COLLATE&lt;/code&gt; behaviour to Argentinian Spanish. &lt;b&gt;NOTE&lt;/b&gt;: The naming and availability of locales depends on your operating system. Please consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for how to find out which locales are available in your system.</source>
          <target state="translated">Следующее устанавливает поведение &lt;code&gt;LC_COLLATE&lt;/code&gt; на аргентинский испанский. &lt;b&gt;ПРИМЕЧАНИЕ&lt;/b&gt; . Именование и доступность языковых стандартов зависит от вашей операционной системы. Пожалуйста, обратитесь к &lt;a href=&quot;perllocale&quot;&gt;perllocale,&lt;/a&gt; чтобы узнать, какие локали доступны в вашей системе.</target>
        </trans-unit>
        <trans-unit id="5abcdbfe7d0b6ac6ed18a19f7b6cc537b1839b5d" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_CTYPE&lt;/code&gt; behaviour according to the locale environment variables (the second argument &lt;code&gt;&quot;&quot;&lt;/code&gt; ). Please see your system's &lt;code&gt;setlocale(3)&lt;/code&gt; documentation for the locale environment variables' meaning or consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">Следующее установит поведение &lt;code&gt;LC_CTYPE&lt;/code&gt; в соответствии с переменными среды локали (второй аргумент &lt;code&gt;&quot;&quot;&lt;/code&gt; ). Пожалуйста, обратитесь к документации по &lt;code&gt;setlocale(3)&lt;/code&gt; вашей системы, чтобы узнать значение переменных окружения локали, или обратитесь к &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="216ff7e1b32a193101b360016063f1dbe17b7ec9" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_CTYPE&lt;/code&gt; behaviour according to the locale environment variables (the second argument &lt;code&gt;&quot;&quot;&lt;/code&gt;). Please see your system's &lt;code&gt;setlocale(3)&lt;/code&gt; documentation for the locale environment variables' meaning or consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbd57a3195c4519fb09fab198f3facf1b32479f" translate="yes" xml:space="preserve">
          <source>The following will set the traditional UNIX system locale behavior (the second argument &lt;code&gt;&quot;C&quot;&lt;/code&gt; ).</source>
          <target state="translated">Следующее установит традиционное поведение языкового стандарта системы UNIX (второй аргумент &lt;code&gt;&quot;C&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d989bfd17f8da94563bcb6ebfdcbf583a757e87" translate="yes" xml:space="preserve">
          <source>The following will set the traditional UNIX system locale behavior (the second argument &lt;code&gt;&quot;C&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d394598bfc021311cf0f2bb824273bc318b5797a" translate="yes" xml:space="preserve">
          <source>The following would first try to find Math::BigInt::Foo, then Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:</source>
          <target state="translated">Сначала попробуйте найти Math::BigInt::Foo,затем Math::BigInt::Bar,а когда это тоже не удастся,вернитесь к Math::BigInt::Calc:</target>
        </trans-unit>
        <trans-unit id="9ce20518f56534bcc1118c0bf986d78eef528c90" translate="yes" xml:space="preserve">
          <source>The following:</source>
          <target state="translated">Следующее:</target>
        </trans-unit>
        <trans-unit id="678f5358c7187caa2da5eff48aaaa0b704fbae9c" translate="yes" xml:space="preserve">
          <source>The followings items are mostly for reference and general Unicode knowledge, Perl doesn't use these constructs internally.</source>
          <target state="translated">Следующие пункты в основном для справки и общего знания Юникода,Perl не использует эти конструкции внутри себя.</target>
        </trans-unit>
        <trans-unit id="0e4f79728d04ec0471d6bf96e407b112aa0cabf3" translate="yes" xml:space="preserve">
          <source>The foregoing mechanism for overriding built-in is restricted, quite deliberately, to the package that requests the import. There is a second method that is sometimes applicable when you wish to override a built-in everywhere, without regard to namespace boundaries. This is achieved by importing a sub into the special namespace &lt;code&gt;CORE::GLOBAL::&lt;/code&gt; . Here is an example that quite brazenly replaces the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator with something that understands regular expressions.</source>
          <target state="translated">Вышеупомянутый механизм для переопределения встроенного ограничен, вполне сознательно, пакетом, который запрашивает импорт. Есть второй метод, который иногда применим, когда вы хотите переопределить встроенный везде, вне зависимости от границ пространства имен. Это достигается путем импорта подпространства в специальное пространство имен &lt;code&gt;CORE::GLOBAL::&lt;/code&gt; . Вот пример, который довольно нагло заменяет оператор &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; чем-то, что понимает регулярные выражения.</target>
        </trans-unit>
        <trans-unit id="ef8b42b5ef636a805f830b90ca5398d8a3c613f1" translate="yes" xml:space="preserve">
          <source>The foregoing mechanism for overriding built-in is restricted, quite deliberately, to the package that requests the import. There is a second method that is sometimes applicable when you wish to override a built-in everywhere, without regard to namespace boundaries. This is achieved by importing a sub into the special namespace &lt;code&gt;CORE::GLOBAL::&lt;/code&gt;. Here is an example that quite brazenly replaces the &lt;code&gt;glob&lt;/code&gt; operator with something that understands regular expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b85c90a6a43ec9e5bf7a5a11ec769ca8bd55e119" translate="yes" xml:space="preserve">
          <source>The fork() emulation is implemented at the level of the Perl interpreter. What this means in general is that running fork() will actually clone the running interpreter and all its state, and run the cloned interpreter in a separate thread, beginning execution in the new thread just after the point where the fork() was called in the parent. We will refer to the thread that implements this child &quot;process&quot; as the pseudo-process.</source>
          <target state="translated">Эмуляция fork()реализована на уровне интерпретатора Perl.В общем,это означает,что выполнение fork()фактически клонирует работающий интерпретатор и все его состояние,и запустит клонированный интерпретатор в отдельном потоке,начав выполнение в новом потоке сразу после точки,в которой была вызвана функция fork()в родительском.Мы будем ссылаться на поток,реализующий этот дочерний &quot;процесс&quot;,как на псевдо-процесс.</target>
        </trans-unit>
        <trans-unit id="e04f09879ad602b86af95f9f6d5d371e6757eda4" translate="yes" xml:space="preserve">
          <source>The fork() emulation may not behave as expected when it is executed in an application which embeds a Perl interpreter and calls Perl APIs that can evaluate bits of Perl code. This stems from the fact that the emulation only has knowledge about the Perl interpreter's own data structures and knows nothing about the containing application's state. For example, any state carried on the application's own call stack is out of reach.</source>
          <target state="translated">Эмуляция fork()может вести себя не так,как ожидалось,когда она выполняется в приложении,которое встраивает Perl-интерпретатор и вызывает Perl API,которые могут оценивать биты Perl-кода.Это связано с тем,что эмуляция имеет представление только о собственных структурах данных Perl-интерпретатора и ничего не знает о состоянии приложения,в котором он находится.Например,любое состояние,переносимое собственным стеком вызовов приложения,недоступно.</target>
        </trans-unit>
        <trans-unit id="0708717756f902c5ff59069bd45289469d28d91c" translate="yes" xml:space="preserve">
          <source>The fork() emulation will not work entirely correctly when called from within a BEGIN block. The forked copy will run the contents of the BEGIN block, but will not continue parsing the source stream after the BEGIN block. For example, consider the following code:</source>
          <target state="translated">Эмуляция fork()будет работать не совсем корректно при вызове из блока BEGIN.Форковочная копия будет запускать содержимое блока BEGIN,но не будет продолжать разбор исходного потока после блока BEGIN.Например,рассмотрим следующий код:</target>
        </trans-unit>
        <trans-unit id="15be1c6ce9042f03bee94913baeb82a3ff565ee8" translate="yes" xml:space="preserve">
          <source>The fork() has to come before the setsid() to ensure you aren't a process group leader; the setsid() will fail if you are. If your system doesn't have the setsid() function, open</source>
          <target state="translated">Форк()должна прийти перед функцией setsid(),чтобы убедиться,что вы не являетесь лидером группы процессов;функция setsid()не будет работать,если вы являетесь лидером группы процессов;если вы являетесь лидером,функция setsid()не будет работать.Если ваша система не имеет функции setsid(),откройте</target>
        </trans-unit>
        <trans-unit id="9d31d094967d18a344cd7885a66ada91947ca8a3" translate="yes" xml:space="preserve">
          <source>The forked debugger requires the environment variable &lt;code&gt;TERM&lt;/code&gt; to be &lt;code&gt;xterm&lt;/code&gt; , and the environment variable &lt;code&gt;DISPLAY&lt;/code&gt; to exist. &lt;code&gt;xterm&lt;/code&gt; must be in lower case.</source>
          <target state="translated">Разветвленный отладчик требует, чтобы переменная среды &lt;code&gt;TERM&lt;/code&gt; была &lt;code&gt;xterm&lt;/code&gt; , а переменная среды &lt;code&gt;DISPLAY&lt;/code&gt; существовала. &lt;code&gt;xterm&lt;/code&gt; должен быть в нижнем регистре.</target>
        </trans-unit>
        <trans-unit id="80ddbda74fdf5f4c1a0f7f135f152cdae53aae97" translate="yes" xml:space="preserve">
          <source>The forked debugger requires the environment variable &lt;code&gt;TERM&lt;/code&gt; to be &lt;code&gt;xterm&lt;/code&gt;, and the environment variable &lt;code&gt;DISPLAY&lt;/code&gt; to exist. &lt;code&gt;xterm&lt;/code&gt; must be in lower case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a1b936aa7515813dbe100195592b08e94ebcb1" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;$x **= $y&lt;/code&gt; is faster than &lt;code&gt;$x = $x ** $y;&lt;/code&gt; , though.</source>
          <target state="translated">Форма &lt;code&gt;$x **= $y&lt;/code&gt; быстрее, чем &lt;code&gt;$x = $x ** $y;&lt;/code&gt; , хотя.</target>
        </trans-unit>
        <trans-unit id="6d60b9b98398cc175682fc83afb5cb2a3d960481" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;$x **= $y&lt;/code&gt; is faster than &lt;code&gt;$x = $x ** $y;&lt;/code&gt;, though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea29df8f31e738f8731934d29265ffb8df1b05f7" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt;, available in Perl 4, is no longer available. Replace any occurrence of &lt;code&gt;if BLOCK&lt;/code&gt; by &lt;code&gt;if (&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK)&lt;/code&gt; .</source>
          <target state="translated">Форма &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt; , доступная в Perl 4, больше не доступна. Замените любое вхождение &lt;code&gt;if BLOCK&lt;/code&gt; на &lt;code&gt;if (&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ab550c0e5d5dbe7a57264f4fc68930ea27ef872" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt;, available in Perl 4, is no longer available. Replace any occurrence of &lt;code&gt;if BLOCK&lt;/code&gt; by &lt;code&gt;if (do BLOCK)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d89d2ce75f6dd9a5b033644a202a3e0573863e" translate="yes" xml:space="preserve">
          <source>The formal syntax of a section specification is:</source>
          <target state="translated">Формальный синтаксис спецификации секции:</target>
        </trans-unit>
        <trans-unit id="feafac52c2f0bb1c62c34d80f1ccae00a8b7bff5" translate="yes" xml:space="preserve">
          <source>The format is roughly the same as a header section except for the fallback flag: | followed by 0..3. The meaning of the possible values is as follows:</source>
          <target state="translated">Формат примерно такой же,как и раздел заголовков,за исключением флага fallback:|,за которым следует 0...3.Значение возможных значений следующее:</target>
        </trans-unit>
        <trans-unit id="7de51818a43a9eeabc5f149d791bcd953969e5ec" translate="yes" xml:space="preserve">
          <source>The format is the same as PREREQ_PM.</source>
          <target state="translated">Формат тот же,что и PREREQ_PM.</target>
        </trans-unit>
        <trans-unit id="4a91025674068746c104cf678dff09a87e09a62d" translate="yes" xml:space="preserve">
          <source>The format is:</source>
          <target state="translated">Формат таков:</target>
        </trans-unit>
        <trans-unit id="cab7930ea8f9bb0b5e8551406e705f9d6d55872a" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; is shown below</source>
          <target state="translated">Формат конструктора для &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; показан ниже.</target>
        </trans-unit>
        <trans-unit id="2b7f4c6f10c021d585a52efc7c38f1f01339227d" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; is shown below</source>
          <target state="translated">Формат конструктора для &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; показан ниже.</target>
        </trans-unit>
        <trans-unit id="e03dc6c86b8958f9b62ec7a6a483ad0e4753decb" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; is shown below</source>
          <target state="translated">Формат конструктора для &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; показан ниже.</target>
        </trans-unit>
        <trans-unit id="2cd916282c4e6b36ecc3a6af27b028bb638d27b9" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; is shown below</source>
          <target state="translated">Формат конструктора для &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; показан ниже.</target>
        </trans-unit>
        <trans-unit id="96cf103266184d2ab7c512526262f24222f5b3fa" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Zip&lt;/code&gt; is shown below</source>
          <target state="translated">Формат конструктора для &lt;code&gt;IO::Compress::Zip&lt;/code&gt; показан ниже.</target>
        </trans-unit>
        <trans-unit id="7cddd4e7224584228dd40d8278ce06df26d30be6" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::AnyInflate is shown below</source>
          <target state="translated">Ниже показан формат конструктора для IO::Uncompress::AnyInflate</target>
        </trans-unit>
        <trans-unit id="f335334476f7fdad7a158077eda96d1e77d620ba" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::AnyUncompress is shown below</source>
          <target state="translated">Формат конструктора для IO::Uncompress::AnyUncompress показан ниже</target>
        </trans-unit>
        <trans-unit id="d8f9f10c69da3c0a902ce3d0bf3a43a4fe3d0d99" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Bunzip2 is shown below</source>
          <target state="translated">Ниже показан формат конструктора для IO::Uncompress::Bunzip2</target>
        </trans-unit>
        <trans-unit id="1aee64e705754fe9513f8b1c5a275541fbf25126" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Gunzip is shown below</source>
          <target state="translated">Ниже показан формат конструктора для IO::Uncompress::Gunzip</target>
        </trans-unit>
        <trans-unit id="e0479ea0c00c6dbc0391fab896f56792a7f58abf" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Inflate is shown below</source>
          <target state="translated">Ниже показан формат конструктора для IO::Uncompress::Inflate</target>
        </trans-unit>
        <trans-unit id="abbcd988c20a7a7af1b1b62b62f212c0f098a642" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::RawInflate is shown below</source>
          <target state="translated">Ниже показан формат конструктора для IO::Uncompress::RawInflate</target>
        </trans-unit>
        <trans-unit id="266217c42524ecb82328e7bc0e8f8cf67f30e119" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Unzip is shown below</source>
          <target state="translated">Ниже показан формат конструктора для IO::Uncompress::Unzip</target>
        </trans-unit>
        <trans-unit id="6ce17f5dc7d5e6006e0ab81d86bb016be0d29f0f" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;#gmtime&quot;&gt;gmtime&lt;/a&gt; builtin. See also the &lt;code&gt;Time::Local&lt;/code&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by time()), and the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's strftime(3) and mktime(3) functions.</source>
          <target state="translated">Формат этого скалярного значения &lt;b&gt;не&lt;/b&gt; зависит от локали, а встроен в Perl. Для GMT вместо местного времени используйте встроенную &lt;a href=&quot;#gmtime&quot;&gt;функцию gmtime&lt;/a&gt; . См. Также модуль &lt;code&gt;Time::Local&lt;/code&gt; (для преобразования секунд, минут, часов и т. Д. Обратно в целочисленное значение, возвращаемое функцией time ()), а также функции strftime (3) и mktime (3) модуля &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c7d4e187b4ee40d7ac4cdd3dd9c17ff06ab82de" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;#gmtime-EXPR&quot;&gt;&lt;code&gt;gmtime&lt;/code&gt;&lt;/a&gt; builtin. See also the &lt;a href=&quot;Time::Local&quot;&gt;&lt;code&gt;Time::Local&lt;/code&gt;&lt;/a&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by &lt;a href=&quot;#time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;), and the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's &lt;a href=&quot;posix#strftime&quot;&gt;&lt;code&gt;strftime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;posix#mktime&quot;&gt;&lt;code&gt;mktime&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2da41af1cf680b6887d63dd253c6e01471391c6" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;gmtime&quot;&gt;gmtime&lt;/a&gt; builtin. See also the &lt;code&gt;Time::Local&lt;/code&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by time()), and the &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; module's strftime(3) and mktime(3) functions.</source>
          <target state="translated">Формат этого скалярного значения &lt;b&gt;не&lt;/b&gt; зависит от локали, а встроен в Perl. Для GMT вместо местного времени используйте встроенную &lt;a href=&quot;gmtime&quot;&gt;функцию gmtime&lt;/a&gt; . См. Также модуль &lt;code&gt;Time::Local&lt;/code&gt; (для преобразования секунд, минут, часов и т. Д. Обратно в целочисленное значение, возвращаемое функцией time ()), а также функции strftime (3) и mktime (3) модуля &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fb9dcbdf87a920318a01eb480379e8f7c7c3de2" translate="yes" xml:space="preserve">
          <source>The format specifier detection is not complete printf-syntax detection, but it should catch most common cases.</source>
          <target state="translated">Определение спецификатора формата не является полным обнаружением синтаксиса printf,но оно должно улавливать наиболее распространенные случаи.</target>
        </trans-unit>
        <trans-unit id="256ecd9d04a27fc1ec23dd2c77863e67bcf5ad16" translate="yes" xml:space="preserve">
          <source>The formats supported are</source>
          <target state="translated">Поддерживаемые форматы</target>
        </trans-unit>
        <trans-unit id="0577a9efbbb4297e7d5cf847fb8e2a9cc4cdfef4" translate="yes" xml:space="preserve">
          <source>The formats supported are:</source>
          <target state="translated">Поддерживаются следующие форматы:</target>
        </trans-unit>
        <trans-unit id="f7762b6266ff516b0fab73ac7af6d025adc1f538" translate="yes" xml:space="preserve">
          <source>The formats that can convert characters to numbers and vice versa will be different from their ASCII counterparts when executed on an EBCDIC platform. Examples include:</source>
          <target state="translated">Форматы,которые могут преобразовывать символы в цифры и наоборот,будут отличаться от их аналогов в формате ASCII при выполнении на платформе EBCDIC.Примеры включают в себя:</target>
        </trans-unit>
        <trans-unit id="5f27c48c4d04704c74b0b5d7d716d5ed43b40c07" translate="yes" xml:space="preserve">
          <source>The former default in which Perl would always use a loose interpretation of UTF-8 has now been overruled:</source>
          <target state="translated">Бывший дефолт,в котором Perl всегда использовал свободную интерпретацию UTF-8,теперь отменен:</target>
        </trans-unit>
        <trans-unit id="bacc21ee4934a43e7cffae5409abb3139d8d7444" translate="yes" xml:space="preserve">
          <source>The former is defined to imply Unicode handling; and the latter indicates a Unicode locale, hence a Unicode interpretation of all strings within it.</source>
          <target state="translated">Первое определение подразумевает работу с Юникодом;а второе указывает на локаль Юникода,следовательно,интерпретацию всех строк в нем.</target>
        </trans-unit>
        <trans-unit id="abc8578e218b1958e7644bd43d9d008d1386b618" translate="yes" xml:space="preserve">
          <source>The formerly undocumented STRICT argument sets strictness: if true 'use strict;' is used, otherwise it uses 'no strict;'. &lt;b&gt;Note&lt;/b&gt;: if STRICT is omitted 'no strict;' is the default.</source>
          <target state="translated">Ранее недокументированный аргумент STRICT устанавливает строгость: if true 'use strict;' используется, в противном случае используется 'no strict;'. &lt;b&gt;Примечание&lt;/b&gt; : если STRICT опущен, 'no strict;' по умолчанию.</target>
        </trans-unit>
        <trans-unit id="18a3596eca3e6e803312bc68b427ff1f1eeb325a" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;(?'&lt;i&gt;NAME&lt;/i&gt;'&lt;i&gt;pattern&lt;/i&gt;)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;&lt;i&gt;NAME&lt;/i&gt;&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)&lt;/code&gt; are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c48d78ca541fb734f8a681b44e6478f12be1be" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;(?'NAME'pattern)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;NAME&amp;gt;pattern)&lt;/code&gt; are equivalent.</source>
          <target state="translated">Формы &lt;code&gt;(?'NAME'pattern)&lt;/code&gt; и &lt;code&gt;(?&amp;lt;NAME&amp;gt;pattern)&lt;/code&gt; эквивалентны.</target>
        </trans-unit>
        <trans-unit id="3165776bcfd76f28e0c24205090accd64be6f1e3" translate="yes" xml:space="preserve">
          <source>The formula is from the Red Dragon book (reformulated to use the data available) and is documented at &lt;a href=&quot;http://www.strchr.com/hash_functions&quot;&gt;http://www.strchr.com/hash_functions&lt;/a&gt;</source>
          <target state="translated">Формула взята из книги Red Dragon (переформулирована с учетом имеющихся данных) и задокументирована по адресу &lt;a href=&quot;http://www.strchr.com/hash_functions&quot;&gt;http://www.strchr.com/hash_functions.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea332d524efecd12f52e313e0715e604daa7345f" translate="yes" xml:space="preserve">
          <source>The four &lt;code&gt;CPAN::*&lt;/code&gt; Classes: Author, Bundle, Module, Distribution</source>
          <target state="translated">Четыре класса &lt;code&gt;CPAN::*&lt;/code&gt; : Author, Bundle, Module, Distribution</target>
        </trans-unit>
        <trans-unit id="4ebe0eef114ce361363114266a5b30d9fc215c2f" translate="yes" xml:space="preserve">
          <source>The four &lt;code&gt;filter_*&lt;/code&gt; methods shown above are available in all the DBM modules that ship with Perl, namely DB_File, GDBM_File, NDBM_File, ODBM_File and SDBM_File.</source>
          <target state="translated">Четыре &lt;code&gt;filter_*&lt;/code&gt; показанные выше, доступны во всех модулях DBM, которые поставляются с Perl, а именно DB_File, GDBM_File, NDBM_File, ODBM_File и SDBM_File.</target>
        </trans-unit>
        <trans-unit id="a87cd62b5e4a547576560e5204e87547d60f9cfe" translate="yes" xml:space="preserve">
          <source>The four CPAN::* Classes: Author, Bundle, Module, Distribution</source>
          <target state="translated">Занятия:Автор,Пакет,Модуль,Распределение</target>
        </trans-unit>
        <trans-unit id="fe1fb546f60704c6d1d156b3f6fadf776528094a" translate="yes" xml:space="preserve">
          <source>The four element types -- scalar, array, hash, and class -- are represented by strings -- &lt;code&gt;'$'&lt;/code&gt; , &lt;code&gt;'@'&lt;/code&gt; , &lt;code&gt;'%'&lt;/code&gt; , and a class name -- optionally preceded by a &lt;code&gt;'*'&lt;/code&gt; .</source>
          <target state="translated">Четыре типа элементов - скаляр, массив, хэш и класс - представлены строками - &lt;code&gt;'$'&lt;/code&gt; , &lt;code&gt;'@'&lt;/code&gt; , &lt;code&gt;'%'&lt;/code&gt; и именем класса, которому может предшествовать &lt;code&gt;'*'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92b64884f8f61e4bda03f0b1b810258bc7d0365f" translate="yes" xml:space="preserve">
          <source>The four element types -- scalar, array, hash, and class -- are represented by strings -- &lt;code&gt;'$'&lt;/code&gt;, &lt;code&gt;'@'&lt;/code&gt;, &lt;code&gt;'%'&lt;/code&gt;, and a class name -- optionally preceded by a &lt;code&gt;'*'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010d48814dc6637936a58a714f4a5b8ac2c0e5b8" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is 0.</source>
          <target state="translated">Четвертый элемент (index [3]) ( &lt;code&gt;$default&lt;/code&gt; ) в списке, возвращаемом для этого формата, равен 0.</target>
        </trans-unit>
        <trans-unit id="2e817fac52edc4c5e0caee985a6afb86c7862868" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; .</source>
          <target state="translated">Четвертым элементом (index [3]) ( &lt;code&gt;$default&lt;/code&gt; ) в списке, возвращаемом для этого формата, является &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d015fffd23c241225267b70dd79dfdb0ced38265" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is the empty string.</source>
          <target state="translated">Четвертым элементом (index [3]) ( &lt;code&gt;$default&lt;/code&gt; ) в списке, возвращаемом для этого формата, является пустая строка.</target>
        </trans-unit>
        <trans-unit id="dbf8c5de03271df9c0ea8fd5c41bcc753a3e2e78" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt;) in the list returned for this format is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a31746958b0c54f45a9490ade3495335e57ef5" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt;) in the list returned for this format is &lt;code&gt;&quot;NaN&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ce6cb48f2a76c182227b4de66778e078fb3c5c" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt;) in the list returned for this format is the empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee5dc54dca610abdb335a6016c33fad310b745e" translate="yes" xml:space="preserve">
          <source>The fourth argument,</source>
          <target state="translated">Четвертый аргумент,</target>
        </trans-unit>
        <trans-unit id="d46f45156438266dbc454cfdd5c8500aa9cf2dd2" translate="yes" xml:space="preserve">
          <source>The fourth operation is the same as the logical not of the third operation and is specified the same way as the third with the addition of a caret character &lt;code&gt;^&lt;/code&gt; at the beginning of the test string just inside the open square bracket.</source>
          <target state="translated">Четвертая операция аналогична логическому не третьей операции и указывается так же, как и третья, с добавлением символа вставки &lt;code&gt;^&lt;/code&gt; в начале тестовой строки внутри открытой квадратной скобки.</target>
        </trans-unit>
        <trans-unit id="bc43b69f9d12ff24c27cb6addf7ed86730581d51" translate="yes" xml:space="preserve">
          <source>The fourth through ninth highest priorities are to look in the corresponding grandparent, great-grandparent and great-great-grandparent directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517bbe0d839ce687e5bde7b590dd68865b524c37" translate="yes" xml:space="preserve">
          <source>The friends locked into &lt;code&gt;M$&lt;/code&gt; world would appreciate the fact that this executable runs under DOS, Win0.3*, Win0.95 and WinNT with an appropriate extender. See &lt;a href=&quot;#Other-OSes&quot;&gt;&quot;Other OSes&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67d6a9240f3ec0e157e3e0a648b8e35a0a7ab23" translate="yes" xml:space="preserve">
          <source>The friends locked into &lt;code&gt;M$&lt;/code&gt; world would appreciate the fact that this executable runs under DOS, Win0.3*, Win0.95 and WinNT with an appropriate extender. See &lt;a href=&quot;#Other-OSes&quot;&gt;Other OSes&lt;/a&gt;.</source>
          <target state="translated">Друзья, запертые в мире &lt;code&gt;M$&lt;/code&gt; будут признательны за то, что этот исполняемый файл работает под DOS, Win0.3 *, Win0.95 и WinNT с соответствующим расширителем. См. &lt;a href=&quot;#Other-OSes&quot;&gt;Другие ОС&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="043867751e64107d60b95a69e8badcc29251fb84" translate="yes" xml:space="preserve">
          <source>The full circle is 2</source>
          <target state="translated">Полный круг-2</target>
        </trans-unit>
        <trans-unit id="d29a10ef910506015d780ee21ef968e5b95cf038" translate="yes" xml:space="preserve">
          <source>The full definition for this field is given in the &lt;a href=&quot;#Prereq-Spec&quot;&gt;&quot;Prereq Spec&quot;&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37765aa0855e93aba1c1cfea3d54b9c2c469bca1" translate="yes" xml:space="preserve">
          <source>The full documentation for &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; provides a thorough reference to this function, beyond the best-practice basics covered here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66fe9d715897deb9cd4770d030e58e58ff7af5a" translate="yes" xml:space="preserve">
          <source>The full list of alternatives is:</source>
          <target state="translated">Полный список альтернатив:</target>
        </trans-unit>
        <trans-unit id="e2b044fa3549d52ee2f4f118ecc7f64b424bcc29" translate="yes" xml:space="preserve">
          <source>The full set of contributors always includes the folks mentioned in &lt;a href=&quot;IO::Stringy#CHANGE-LOG&quot;&gt;&quot;CHANGE LOG&quot; in IO::Stringy&lt;/a&gt;. But just the same, special thanks to the following individuals for their invaluable contributions (if I've forgotten or misspelled your name, please email me!):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baccc1ffc22a33efb39b1687159250f28dc423fa" translate="yes" xml:space="preserve">
          <source>The full text of the license can be found in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a153a5f23194fa493b49953e70a37ba58abfd1" translate="yes" xml:space="preserve">
          <source>The full text of the license can be found in the LICENSE file included with this module.</source>
          <target state="translated">Полный текст лицензии можно найти в файле LICENSE,входящем в состав этого модуля.</target>
        </trans-unit>
        <trans-unit id="c54557502ca6f64ebd0cff3c9dbc11ca01487c1f" translate="yes" xml:space="preserve">
          <source>The full version number of this package, such as 5.6.1 (or 5_6_1). This combines revision, patchlevel, and subversion to get the full version number, including any possible subversions. This is suitable for use as a directory name, and hence is filesystem dependent.</source>
          <target state="translated">Номер полной версии данного пакета,например,5.6.1 (или 5_6_1).Он сочетает в себе ревизию,уровень патча и субверсию,чтобы получить полный номер версии,включая все возможные субверсии.Это подходит для использования в качестве имени каталога,и,следовательно,зависит от файловой системы.</target>
        </trans-unit>
        <trans-unit id="5bc944c87864f3d28f9f02ec1b783a4a9aacca33" translate="yes" xml:space="preserve">
          <source>The fully qualified method name that was called is available in the &lt;code&gt;$AUTOLOAD&lt;/code&gt; package global for your class. Since this is a global, if you want to refer to do it without a package name prefix under &lt;code&gt;strict
'vars'&lt;/code&gt; , you need to declare it.</source>
          <target state="translated">Полное имя вызванного метода доступно в глобальном пакете &lt;code&gt;$AUTOLOAD&lt;/code&gt; для вашего класса. Поскольку это глобальный параметр, если вы хотите сделать это без префикса имени пакета в &lt;code&gt;strict 'vars'&lt;/code&gt; , вам необходимо объявить его.</target>
        </trans-unit>
        <trans-unit id="46868bf85da4047d1fd48569f16bb118135bfc66" translate="yes" xml:space="preserve">
          <source>The fully qualified method name that was called is available in the &lt;code&gt;$AUTOLOAD&lt;/code&gt; package global for your class. Since this is a global, if you want to refer to do it without a package name prefix under &lt;code&gt;strict 'vars'&lt;/code&gt;, you need to declare it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c7ff8a6b152356b1c3b87a4fa36cf4002b4367" translate="yes" xml:space="preserve">
          <source>The function</source>
          <target state="translated">Функция</target>
        </trans-unit>
        <trans-unit id="d66346d1633c0f93998400fd3d2d89ef6dd2f1f1" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;utf8#Utility-functions&quot;&gt;&lt;code&gt;utf8::utf8_upgrade()&lt;/code&gt;&lt;/a&gt; can be explicitly used to permanently (unless a subsequent &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; is called) cause a string to be treated as Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1263ec90688607ca3bc3ec7bfb0fe38e6efd4c6" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::utf8_upgrade() &lt;/a&gt; can be explicitly used to permanently (unless a subsequent &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; is called) cause a string to be treated as Unicode.</source>
          <target state="translated">Функцию &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: utf8_upgrade ()&lt;/a&gt; можно явно использовать для постоянного (если не &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; последующий вызов utf8 :: utf8_downgrade () ) для обработки строки как Unicode.</target>
        </trans-unit>
        <trans-unit id="0110ffd54f081ff34d7394303d2f5fa900a42f45" translate="yes" xml:space="preserve">
          <source>The function &lt;b&gt;pod_find&lt;/b&gt; searches for POD documents in a given set of files and/or directories. It returns a hash with the file names as keys and the POD name as value. The POD name is derived from the file name and its position in the directory tree.</source>
          <target state="translated">Функция &lt;b&gt;pod_find&lt;/b&gt; ищет документы POD в заданном наборе файлов и / или каталогов. Он возвращает хеш с именами файлов в качестве ключей и именем POD в качестве значения. Имя POD является производным от имени файла и его позиции в дереве каталогов.</target>
        </trans-unit>
        <trans-unit id="48cfcd3ef7cb24df407c69f7ab8cfb221b006395" translate="yes" xml:space="preserve">
          <source>The function &lt;b&gt;simplify_name&lt;/b&gt; is equivalent to &lt;b&gt;basename&lt;/b&gt;, but also strips Perl-like extensions (.pm, .pl, .pod) and extensions like</source>
          <target state="translated">Функция &lt;b&gt;simpleify_name&lt;/b&gt; эквивалентна &lt;b&gt;basename&lt;/b&gt; , но также удаляет Perl-подобные расширения (.pm, .pl, .pod) и такие расширения, как</target>
        </trans-unit>
        <trans-unit id="977e84004739e29fbaa341106fb1e524db41e10d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; has been deprecated, so code has been included to display a warning message whenever the calling module has (at least) the &quot;deprecated&quot; warnings category enabled. Something like this, say.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; устарела, поэтому был включен код для отображения предупреждающего сообщения всякий раз, когда вызывающий модуль имеет (по крайней мере) категорию &quot;устаревшие&quot; предупреждения. Что-то вроде этого, допустим.</target>
        </trans-unit>
        <trans-unit id="509f0d861d7a99d6a484f51f2a9188a5713a5b35" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;filter_read&lt;/code&gt; takes two forms:</source>
          <target state="translated">Функция &lt;code&gt;filter_read&lt;/code&gt; принимает две формы:</target>
        </trans-unit>
        <trans-unit id="5c27f77e8d833b52d6b699513cb75e12cfb41e38" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;hostname()&lt;/code&gt; in the &lt;a href=&quot;Sys::Hostname&quot;&gt;Sys::Hostname&lt;/a&gt; module has always been documented to be called with no arguments. Historically it has not enforced this, and has actually accepted and ignored any arguments. As a result, some users have got the mistaken impression that an argument does something useful. To avoid these bugs, the function is being made strict. Passing arguments was deprecated in Perl 5.28 and became fatal in Perl 5.32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2b0d9ecb1c14fb1e59a3fd0192de217a46316b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;open&lt;/code&gt; has been deprecated, so code has been included to display a warning message whenever the calling module has (at least) the &quot;deprecated&quot; warnings category enabled. Something like this, say.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd4d38aee306d70f6097ade577ca383b52839ef" translate="yes" xml:space="preserve">
          <source>The function I18N::LangTags::List::name(...) is not exported.</source>
          <target state="translated">Функция I18N::LangTags::List::name(...)не экспортируется.</target>
        </trans-unit>
        <trans-unit id="5583893e9ddd698662f18f40b85c6a69394dd032" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be created. Its behaviour may be tuned by an optional hashref appearing as the last parameter on the call.</source>
          <target state="translated">Функция принимает список каталогов,которые необходимо создать.Ее поведение может быть настроено с помощью опционального хэшрефа,появляющегося в качестве последнего параметра при вызове.</target>
        </trans-unit>
        <trans-unit id="1ccfd3fbf49c44a49b4970d5b4592c2961b06827" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be removed. (In point of fact, it will also accept filesystem entries which are not directories, such as regular files and symlinks. But, as its name suggests, its intent is to remove trees rather than individual files.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c25ffe36bf18f7f44be765fa3c82188ddbc3925" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be removed. Its behaviour may be tuned by an optional hashref appearing as the last parameter on the call.</source>
          <target state="translated">Функция принимает список каталогов,которые необходимо удалить.Ее поведение может быть настроено с помощью опционального хэшрефа,появляющегося в качестве последнего параметра при вызове.</target>
        </trans-unit>
        <trans-unit id="3ef41ec1c0dbf85f3bcd0cef90f173dc6b18dec6" translate="yes" xml:space="preserve">
          <source>The function call &lt;code&gt;shell&lt;/code&gt; takes two optional arguments: one the prompt, the second the default initial command line (the latter only works if a real ReadLine interface module is installed).</source>
          <target state="translated">&lt;code&gt;shell&lt;/code&gt; вызова функции принимает два необязательных аргумента: один - приглашение, второй - начальная командная строка по умолчанию (последняя работает, только если установлен настоящий интерфейсный модуль ReadLine).</target>
        </trans-unit>
        <trans-unit id="f64674aceb9b0908fa74a739ca7fbade2ac2ee6e" translate="yes" xml:space="preserve">
          <source>The function declaration must be visible at compile time. The prototype affects only interpretation of new-style calls to the function, where new-style is defined as not using the &lt;code&gt;&amp;amp;&lt;/code&gt; character. In other words, if you call it like a built-in function, then it behaves like a built-in function. If you call it like an old-fashioned subroutine, then it behaves like an old-fashioned subroutine. It naturally falls out from this rule that prototypes have no influence on subroutine references like &lt;code&gt;\&amp;amp;foo&lt;/code&gt; or on indirect subroutine calls like &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; or &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt; .</source>
          <target state="translated">Объявление функции должно быть видимым во время компиляции. Прототип влияет только на интерпретацию вызовов функции нового стиля, где новый стиль определяется как не использующий символ &lt;code&gt;&amp;amp;&lt;/code&gt; . Другими словами, если вы вызываете ее как встроенную функцию, она ведет себя как встроенная функция. Если вы вызываете это как старомодную подпрограмму, то она ведет себя как старомодная подпрограмма. Естественно, из этого правила выходит, что прототипы не влияют на ссылки подпрограмм, такие как &lt;code&gt;\&amp;amp;foo&lt;/code&gt; или на косвенные вызовы подпрограмм, такие как &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; или &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a54076d47c791003b92c3959d64c01e6039e0bd6" translate="yes" xml:space="preserve">
          <source>The function declaration must be visible at compile time. The prototype affects only interpretation of new-style calls to the function, where new-style is defined as not using the &lt;code&gt;&amp;amp;&lt;/code&gt; character. In other words, if you call it like a built-in function, then it behaves like a built-in function. If you call it like an old-fashioned subroutine, then it behaves like an old-fashioned subroutine. It naturally falls out from this rule that prototypes have no influence on subroutine references like &lt;code&gt;\&amp;amp;foo&lt;/code&gt; or on indirect subroutine calls like &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; or &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a4f089237c0dd0b61fdd70575a337b465e2308" translate="yes" xml:space="preserve">
          <source>The function extracts the entry of the specified terminal type</source>
          <target state="translated">Функция извлекает запись указанного типа клеммы</target>
        </trans-unit>
        <trans-unit id="dbacf36c4d8a578101fa6d12242c4841f7204b60" translate="yes" xml:space="preserve">
          <source>The function interface uses attribute strings to describe the colors and text attributes to assign to text. The recognized non-color attributes are clear, reset, bold, dark, faint, italic, underline, underscore, blink, reverse, and concealed. Clear and reset (reset to default attributes), dark and faint (dim and saturated), and underline and underscore are equivalent, so use whichever is the most intuitive to you.</source>
          <target state="translated">Интерфейс функции использует строки атрибутов для описания цветов и текстовых атрибутов для присвоения текста.Распознанные нецветные атрибуты являются четкими,сброшенными,полужирными,темными,бледными,курсивными,подчеркиваниями,подчеркиваниями,мигающими,обратными и скрытыми.Четкость и сброс (сброс к атрибутам по умолчанию),темность и тусклость (тусклость и насыщенность),а также подчеркивание и подчеркивание эквивалентны,поэтому используйте тот,который наиболее интуитивно понятен для вас.</target>
        </trans-unit>
        <trans-unit id="6f3bb6ac191764523c9d934c739e063f3ecbe7de" translate="yes" xml:space="preserve">
          <source>The function is called from the tokeniser, whenever a possible keyword is seen. &lt;code&gt;keyword_ptr&lt;/code&gt; points at the word in the parser's input buffer, and &lt;code&gt;keyword_len&lt;/code&gt; gives its length; it is not null-terminated. The function is expected to examine the word, and possibly other state such as &lt;a href=&quot;perlvar#%25%5EH&quot;&gt;%^H&lt;/a&gt;, to decide whether it wants to handle it as an extended keyword. If it does not, the function should return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt;, and the normal parser process will continue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55694c97e9ceb329d9698a51681bd4944db4ba6e" translate="yes" xml:space="preserve">
          <source>The function is called from the tokeniser, whenever a possible keyword is seen. &lt;code&gt;keyword_ptr&lt;/code&gt; points at the word in the parser's input buffer, and &lt;code&gt;keyword_len&lt;/code&gt; gives its length; it is not null-terminated. The function is expected to examine the word, and possibly other state such as &lt;a href=&quot;perlvar#%25%5eH&quot;&gt;%^H&lt;/a&gt;, to decide whether it wants to handle it as an extended keyword. If it does not, the function should return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; , and the normal parser process will continue.</source>
          <target state="translated">Функция вызывается из токенизатора всякий раз, когда встречается возможное ключевое слово. &lt;code&gt;keyword_ptr&lt;/code&gt; указывает на слово во входном буфере парсера, а &lt;code&gt;keyword_len&lt;/code&gt; дает его длину; он не заканчивается нулем. Ожидается, что функция проверяет слово и, возможно, другое состояние, такое как &lt;a href=&quot;perlvar#%25%5eH&quot;&gt;% ^ H&lt;/a&gt; , чтобы решить, хочет ли она обрабатывать его как расширенное ключевое слово. В противном случае функция должна вернуть &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; , и нормальный процесс синтаксического анализа будет продолжен.</target>
        </trans-unit>
        <trans-unit id="9306c5da74b3095d5bd155bcdf129a71eee56339" translate="yes" xml:space="preserve">
          <source>The function looks in the symbol table of &lt;code&gt;$package&lt;/code&gt; for the typeglob for &lt;code&gt;$referent&lt;/code&gt; , which is a reference to a variable or subroutine (SCALAR, ARRAY, HASH, or CODE). If it finds the typeglob, it returns it. Otherwise, it returns undef. Note that &lt;code&gt;findsym&lt;/code&gt; memoizes the typeglobs it has previously successfully found, so subsequent calls with the same arguments should be much faster.</source>
          <target state="translated">Функция ищет в таблице символов &lt;code&gt;$package&lt;/code&gt; typeglob для &lt;code&gt;$referent&lt;/code&gt; , который является ссылкой на переменную или подпрограмму (SCALAR, ARRAY, HASH или CODE). Если он находит typeglob, он его возвращает. В противном случае возвращается undef. Обратите внимание, что &lt;code&gt;findsym&lt;/code&gt; запоминает объекты типа, которые он ранее успешно нашел, поэтому последующие вызовы с теми же аргументами должны выполняться намного быстрее.</target>
        </trans-unit>
        <trans-unit id="4cae2e767271065d7f78fa3e9c794bcd99ab2963" translate="yes" xml:space="preserve">
          <source>The function looks in the symbol table of &lt;code&gt;$package&lt;/code&gt; for the typeglob for &lt;code&gt;$referent&lt;/code&gt;, which is a reference to a variable or subroutine (SCALAR, ARRAY, HASH, or CODE). If it finds the typeglob, it returns it. Otherwise, it returns undef. Note that &lt;code&gt;findsym&lt;/code&gt; memoizes the typeglobs it has previously successfully found, so subsequent calls with the same arguments should be much faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228b62ac93f3c97adf4846ab7a229490257f21f2" translate="yes" xml:space="preserve">
          <source>The function name and the return type must be placed on separate lines and should be flush left-adjusted.</source>
          <target state="translated">Имя функции и тип возврата должны располагаться на отдельных строках и должны быть отрегулированы заподлицо слева.</target>
        </trans-unit>
        <trans-unit id="497e4c985232c356046790edf3b0a4494724ab06" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;-Name =&amp;gt; value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">Функция необязательно принимает ряд именованных параметров, указанных как &lt;code&gt;-Name =&amp;gt; value&lt;/code&gt; . Это позволяет настраивать отдельные параметры без необходимости указывать их все в списке параметров.</target>
        </trans-unit>
        <trans-unit id="c334e8eba917e7f07e2743dd2e109fa8bab331b7" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;-Name=&amp;gt;value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">Функция необязательно принимает ряд именованных параметров, указанных как &lt;code&gt;-Name=&amp;gt;value&lt;/code&gt; . Это позволяет настраивать отдельные параметры без необходимости указывать их все в списке параметров.</target>
        </trans-unit>
        <trans-unit id="24c3d21a118e57cb0a792d18dd4aca22a45547ff" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;Name =&amp;gt; value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">Функция необязательно принимает ряд именованных параметров, указанных как пары &lt;code&gt;Name =&amp;gt; value&lt;/code&gt; . Это позволяет настраивать отдельные параметры без необходимости указывать их все в списке параметров.</target>
        </trans-unit>
        <trans-unit id="91502bdfeb749a40030a89a237be0405bf938f7b" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;NULL&lt;/code&gt; if there is no occurrence of &lt;code&gt;little&lt;/code&gt; within &lt;code&gt;big&lt;/code&gt;. If &lt;code&gt;little&lt;/code&gt; is the empty string, &lt;code&gt;big&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd7c1c2cc7bcbc10e2084326d92993267a12ffd" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;TRUE&lt;/code&gt; if the input string is empty, or if the corresponding C function returns &lt;code&gt;TRUE&lt;/code&gt; for every byte in the string.</source>
          <target state="translated">Функция возвращает &lt;code&gt;TRUE&lt;/code&gt; если входная строка пуста, или если соответствующая функция C возвращает &lt;code&gt;TRUE&lt;/code&gt; для каждого байта в строке.</target>
        </trans-unit>
        <trans-unit id="d8c35a5a4f8d066f0d21fe352b171cb7a12a9b6f" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; on error, with the reason for the error placed in &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt;. Just what is in the packed string depends on LEVEL and OPTNAME; consult &lt;a href=&quot;http://man.he.net/man2/getsockopt&quot;&gt;getsockopt(2)&lt;/a&gt; for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt;) format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18bb210a9d041841ab7e7d3f647d6ee1d366da33" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, with the reason for the error placed in &lt;code&gt;$!&lt;/code&gt; . Just what is in the packed string depends on LEVEL and OPTNAME; consult getsockopt(2) for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt; ) format.</source>
          <target state="translated">Функция возвращает упакованную строку, представляющую запрошенную опцию сокета, или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; при ошибке, с указанием причины ошибки в &lt;code&gt;$!&lt;/code&gt; . То, что находится в упакованной строке, зависит от LEVEL и OPTNAME; обратитесь к getsockopt (2) за подробностями. Обычно параметр является целым числом, и в этом случае результатом является упакованное целое число, которое можно декодировать с помощью функции &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; с форматом &lt;code&gt;i&lt;/code&gt; (или &lt;code&gt;I&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f3bdd5d171fe014406932479dff47095d4169b23" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, with the reason for the error placed in &lt;code&gt;$!&lt;/code&gt; . Just what is in the packed string depends on LEVEL and OPTNAME; consult getsockopt(2) for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt; ) format.</source>
          <target state="translated">Функция возвращает упакованную строку, представляющую запрошенную опцию сокета, или &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; при ошибке, с указанием причины ошибки в &lt;code&gt;$!&lt;/code&gt; . То, что находится в упакованной строке, зависит от LEVEL и OPTNAME; обратитесь к getsockopt (2) за подробностями. Обычно параметр является целым числом, и в этом случае результатом является упакованное целое число, которое можно декодировать с помощью функции &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; с форматом &lt;code&gt;i&lt;/code&gt; (или &lt;code&gt;I&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e9c09e2f85dbb39e869f16bb5dde4b83ed886b56" translate="yes" xml:space="preserve">
          <source>The function returns a pointer to the constructed subroutine. If the sub is anonymous then ownership of one counted reference to the subroutine is transferred to the caller. If the sub is named then the caller does not get ownership of a reference. In most such cases, where the sub has a non-phase name, the sub will be alive at the point it is returned by virtue of being contained in the glob that names it. A phase-named subroutine will usually be alive by virtue of the reference owned by the phase's automatic run queue. A &lt;code&gt;BEGIN&lt;/code&gt; subroutine may have been destroyed already by the time this function returns, but currently bugs occur in that case before the caller gets control. It is the caller's responsibility to ensure that it knows which of these situations applies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9011070fbeb03f4af4eed5e55fde28d9eee21f2e" translate="yes" xml:space="preserve">
          <source>The function returns a pointer to the constructed subroutine. If the sub is anonymous then ownership of one counted reference to the subroutine is transferred to the caller. If the sub is named then the caller does not get ownership of a reference. In most such cases, where the sub has a non-phase name, the sub will be alive at the point it is returned by virtue of being contained in the glob that names it. A phase-named subroutine will usually be alive by virtue of the reference owned by the phase's automatic run queue. But a &lt;code&gt;BEGIN&lt;/code&gt; subroutine, having already been executed, will quite likely have been destroyed already by the time this function returns, making it erroneous for the caller to make any use of the returned pointer. It is the caller's responsibility to ensure that it knows which of these situations applies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c416a15314ff142b876195908cf3e0998cacb0b" translate="yes" xml:space="preserve">
          <source>The function returns a true value if the file was written successfully. Otherwise it returns a false value.</source>
          <target state="translated">Функция возвращает истинное значение,если файл был успешно записан.В противном случае она возвращает ложное значение.</target>
        </trans-unit>
        <trans-unit id="96868ec2f844938f055b367738ce668b3149cb6e" translate="yes" xml:space="preserve">
          <source>The function returns the list of directories actually created during the call; in scalar context the number of directories created.</source>
          <target state="translated">Функция возвращает список каталогов,фактически созданных при вызове;в скалярном контексте-количество созданных каталогов.</target>
        </trans-unit>
        <trans-unit id="74e8f0415f195a35d73e8c99a877efa398a5fbfc" translate="yes" xml:space="preserve">
          <source>The function returns the menu id of the selected push button:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30520da28728f4bcd1c4695681153ff43915f3de" translate="yes" xml:space="preserve">
          <source>The function returns the number of files successfully deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b560ee48a1c4113ae4a064c91e40e3ebfc92205" translate="yes" xml:space="preserve">
          <source>The function should be defined like this:</source>
          <target state="translated">Функция должна быть определена таким образом:</target>
        </trans-unit>
        <trans-unit id="af1dfdcedd7b6d95c274f658ea41922443e248ed" translate="yes" xml:space="preserve">
          <source>The function should return a reference to an array containing the parent classes in order. The names of the classes should be the result of calling &lt;code&gt;HvENAME()&lt;/code&gt; on the stash. In those cases where &lt;code&gt;HvENAME()&lt;/code&gt; returns null, &lt;code&gt;HvNAME()&lt;/code&gt; should be used instead.</source>
          <target state="translated">Функция должна возвращать ссылку на массив, содержащий родительские классы по порядку. Имена классов должны быть результатом вызова &lt;code&gt;HvENAME()&lt;/code&gt; в тайнике. В тех случаях, когда &lt;code&gt;HvENAME()&lt;/code&gt; возвращает null, следует использовать &lt;code&gt;HvNAME()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df40ff756f018edab3521eb313090bdefa039e32" translate="yes" xml:space="preserve">
          <source>The function takes as first argument a key to test against, and as second argument any form of criteria that are also allowed by the &lt;code&gt;allow&lt;/code&gt; key in the template.</source>
          <target state="translated">Функция принимает в качестве первого аргумента ключ для проверки, а в качестве второго аргумента - любую форму критерия, которая также разрешена ключом &lt;code&gt;allow&lt;/code&gt; в шаблоне.</target>
        </trans-unit>
        <trans-unit id="f1378c8817cc1e710b51660b130f3baf8dd96ee6" translate="yes" xml:space="preserve">
          <source>The function takes one optional parameter, a reference to a hash. The contents of the hash allow the deflation interface to be tailored.</source>
          <target state="translated">Функция принимает один дополнительный параметр-ссылку на хэш.Содержимое хэша позволяет настроить дефляционный интерфейс.</target>
        </trans-unit>
        <trans-unit id="deea19e69043d11a7254610da5a869b1f9452180" translate="yes" xml:space="preserve">
          <source>The function that handles the &lt;code&gt;allow&lt;/code&gt; key in the template is also available for independent use.</source>
          <target state="translated">Функция, которая обрабатывает ключ &lt;code&gt;allow&lt;/code&gt; в шаблоне, также доступна для независимого использования.</target>
        </trans-unit>
        <trans-unit id="efcf392cc09771ca25c0652559e59fca2e7a7c50" translate="yes" xml:space="preserve">
          <source>The function visit() scans the SV arenas list, and calls a specified function for each SV it finds which is still live - ie which has an SvTYPE other than all 1's, and a non-zero SvREFCNT. visit() is used by the following functions (specified as [function that calls visit()] / [function called by visit() for each SV]):</source>
          <target state="translated">Функция visit()сканирует список арен SV и вызывает указанную функцию для каждого SV,которое она находит и которое все еще живое-т.е.которое имеет SvTYPE,отличный от всех 1,и ненулевой SvREFCNT.visit()используется следующими функциями (указанными как [функция,которая вызывает функцию visit()]/[функция,вызываемая функцией visit()для каждого SV]):</target>
        </trans-unit>
        <trans-unit id="8032aad3c9c6371a7328397cdc751815bd8235bd" translate="yes" xml:space="preserve">
          <source>The function will by default replace characters that can't be decoded by &quot;\x{FFFD}&quot;, the Unicode replacement character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19570f411b75d35372886127cc2a69449d9a4b6b" translate="yes" xml:space="preserve">
          <source>The function will croak with &quot;Wide character in subroutine entry&quot; if $bytes contains characters with code above 255. The base64 encoding is only defined for single-byte characters. Use the Encode module to select the byte encoding you want.</source>
          <target state="translated">Функция будет крокодится с &quot;Широкий символ в подпрограммной записи&quot;,если $байты содержат символы с кодом выше 255.Кодировка base64 определена только для однобайтовых символов.Используйте модуль Encode для выбора нужной байтовой кодировки.</target>
        </trans-unit>
        <trans-unit id="b2a6bb6e55b46f9d735e2cbaab0b636efd193e6e" translate="yes" xml:space="preserve">
          <source>The function,</source>
          <target state="translated">Функция,</target>
        </trans-unit>
        <trans-unit id="56c2336779d3eb8fad6f134e1b3afd4055cf95fc" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_add&lt;/code&gt; , actually installs the filter. It takes one parameter which should be a reference. The kind of reference used will dictate which of the two filter types will be used.</source>
          <target state="translated">Функция &lt;code&gt;filter_add&lt;/code&gt; фактически устанавливает фильтр. Требуется один параметр, который должен быть ссылкой. Тип используемой ссылки будет определять, какой из двух типов фильтров будет использоваться.</target>
        </trans-unit>
        <trans-unit id="953ee510269653d7250cb2c022a3b5e06178a57a" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_add&lt;/code&gt;, actually installs the filter. It takes one parameter which should be a reference. The kind of reference used will dictate which of the two filter types will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8317ff780b8620fb08e8151dfdbf3a52d2d611" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_del&lt;/code&gt; , is used to disable the current filter. It does not affect the running of the filter. All it does is tell Perl not to call filter any more.</source>
          <target state="translated">Функция &lt;code&gt;filter_del&lt;/code&gt; используется для отключения текущего фильтра. Это не влияет на работу фильтра. Все, что он делает, это говорит Perl больше не вызывать фильтр.</target>
        </trans-unit>
        <trans-unit id="5390ee2005fc8c59e72212b433101c76ad550f15" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_del&lt;/code&gt;, is used to disable the current filter. It does not affect the running of the filter. All it does is tell Perl not to call filter any more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85467ff647b7ea9bd91bc8fa0103d9ae4aadb9f" translate="yes" xml:space="preserve">
          <source>The functional interface is simply importable functions with the same name as the algorithm. The functions take the message as argument and return the digest. Example:</source>
          <target state="translated">Функциональный интерфейс-это просто импортируемые функции с тем же именем,что и алгоритм.Функции принимают сообщение в качестве аргумента и возвращают дайджест.Пример:</target>
        </trans-unit>
        <trans-unit id="bf5b597fcbc2815c78fabe6a0ba67f38e49a2b3d" translate="yes" xml:space="preserve">
          <source>The functional interface needs Perl5.005 or better.</source>
          <target state="translated">Для функционального интерфейса нужен Perl5.005 или лучше.</target>
        </trans-unit>
        <trans-unit id="4bdd9d3e5903e6dd1f8e73f664d773008086b093" translate="yes" xml:space="preserve">
          <source>The functions</source>
          <target state="translated">Функции</target>
        </trans-unit>
        <trans-unit id="856ff8ad4698542f2d294ec36a49315416bf6990" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;http://man.he.net/man3/recvmsg&quot;&gt;recvmsg(3)&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/sendmsg&quot;&gt;sendmsg(3)&lt;/a&gt;, and &lt;a href=&quot;http://man.he.net/man3/socketpair&quot;&gt;socketpair(3)&lt;/a&gt; are not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9afae1770d87c27f0936f76c113b3734ec61024b" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;accept()&lt;/code&gt;, &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;pipe()&lt;/code&gt;, &lt;code&gt;readpipe()&lt;/code&gt; (as well as the related &lt;code&gt;qx&lt;/code&gt; and &lt;code&gt;`STRING`&lt;/code&gt; operators), &lt;code&gt;socket()&lt;/code&gt;, &lt;code&gt;socketpair()&lt;/code&gt;, and &lt;code&gt;sysopen()&lt;/code&gt; are affected by the lexical value of this variable. The implicit &lt;a href=&quot;#ARGV&quot;&gt;&quot;ARGV&quot;&lt;/a&gt; handle opened by &lt;code&gt;readline()&lt;/code&gt; (or the related &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; operators) on passed filenames is also affected (but not if it opens &lt;code&gt;STDIN&lt;/code&gt;). If this variable is not set, these functions will set the default layers as described in &lt;a href=&quot;perlio#Defaults-and-how-to-override-them&quot;&gt;&quot;Defaults and how to override them&quot; in PerlIO&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ff03911b440c28f50688f4c9ab7665ef4a1c34" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;cond_wait()&lt;/code&gt; and &lt;code&gt;cond_signal()&lt;/code&gt; can be used in conjunction with locks to notify co-operating threads that a resource has become available. They are very similar in use to the functions found in &lt;code&gt;pthreads&lt;/code&gt; . However for most purposes, queues are simpler to use and more intuitive. See &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; for more details.</source>
          <target state="translated">Функции &lt;code&gt;cond_wait()&lt;/code&gt; и &lt;code&gt;cond_signal()&lt;/code&gt; могут использоваться вместе с блокировками для уведомления взаимодействующих потоков о том, что ресурс стал доступен. Они очень похожи по использованию на функции в &lt;code&gt;pthreads&lt;/code&gt; . Однако для большинства целей очереди проще в использовании и интуитивно понятны. См. &lt;a href=&quot;threads/shared&quot;&gt;Thread :: shared&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="fdd336a11c2e07577ac0c13e1a2f33bcdcefa052" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;cond_wait()&lt;/code&gt; and &lt;code&gt;cond_signal()&lt;/code&gt; can be used in conjunction with locks to notify co-operating threads that a resource has become available. They are very similar in use to the functions found in &lt;code&gt;pthreads&lt;/code&gt;. However for most purposes, queues are simpler to use and more intuitive. See &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b4904f96b85af2bf6cf4659323a42dfc8558db" translate="yes" xml:space="preserve">
          <source>The functions and attributes are accessed via the &quot;tab&quot; (for table) member of &lt;code&gt;PerlIOl&lt;/code&gt; . The functions (methods of the layer &quot;class&quot;) are fixed, and are defined by the &lt;code&gt;PerlIO_funcs&lt;/code&gt; type. They are broadly the same as the public &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; functions:</source>
          <target state="translated">Доступ к функциям и атрибутам осуществляется через элемент &quot;tab&quot; (для таблицы) &lt;code&gt;PerlIOl&lt;/code&gt; . Функции (методы уровня &amp;laquo;класс&amp;raquo;) фиксированы и определяются типом &lt;code&gt;PerlIO_funcs&lt;/code&gt; . В целом они аналогичны общедоступным функциям &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da42f49a5d951340d77c54e3152012268bbac221" translate="yes" xml:space="preserve">
          <source>The functions and attributes are accessed via the &quot;tab&quot; (for table) member of &lt;code&gt;PerlIOl&lt;/code&gt;. The functions (methods of the layer &quot;class&quot;) are fixed, and are defined by the &lt;code&gt;PerlIO_funcs&lt;/code&gt; type. They are broadly the same as the public &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641685ab6429ec4eade93850f03823bb632c2710" translate="yes" xml:space="preserve">
          <source>The functions and attributes of the &quot;layer class&quot;.</source>
          <target state="translated">Функции и атрибуты &quot;класса слоя&quot;.</target>
        </trans-unit>
        <trans-unit id="04a02ab73237464478de303a6921e51a12145bbd" translate="yes" xml:space="preserve">
          <source>The functions are modeled on those in</source>
          <target state="translated">Функции смоделированы на моделях из</target>
        </trans-unit>
        <trans-unit id="58e04ab7b2e7ccd7568d030e0e66721438c5c1d0" translate="yes" xml:space="preserve">
          <source>The functions in this module work as well as can be expected when used on earlier Unicode versions. But, obviously, they use the available data from that Unicode version. For example, if the Unicode version predates the definition of the script property (Unicode 3.1), then any function that deals with scripts is going to return &lt;code&gt;undef&lt;/code&gt; for the script portion of the return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529009dfac752f5a2536ceedfad4fb1e6f70b3ed" translate="yes" xml:space="preserve">
          <source>The functions in this section can serve as terms in an expression. They fall into two major categories: list operators and named unary operators. These differ in their precedence relationship with a following comma. (See the precedence table in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.) List operators take more than one argument, while unary operators can never take more than one argument. Thus, a comma terminates the argument of a unary operator, but merely separates the arguments of a list operator. A unary operator generally provides scalar context to its argument, while a list operator may provide either scalar or list contexts for its arguments. If it does both, scalar arguments come first and list argument follow, and there can only ever be one such list argument. For instance, &lt;a href=&quot;#splice-ARRAY%2COFFSET%2CLENGTH%2CLIST&quot;&gt;&lt;code&gt;splice&lt;/code&gt;&lt;/a&gt; has three scalar arguments followed by a list, whereas &lt;a href=&quot;#gethostbyname-NAME&quot;&gt;&lt;code&gt;gethostbyname&lt;/code&gt;&lt;/a&gt; has four scalar arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de8f908f8a6f8cbbe7a5d22657a37b7e7e24b80c" translate="yes" xml:space="preserve">
          <source>The functions in this section can serve as terms in an expression. They fall into two major categories: list operators and named unary operators. These differ in their precedence relationship with a following comma. (See the precedence table in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.) List operators take more than one argument, while unary operators can never take more than one argument. Thus, a comma terminates the argument of a unary operator, but merely separates the arguments of a list operator. A unary operator generally provides scalar context to its argument, while a list operator may provide either scalar or list contexts for its arguments. If it does both, scalar arguments come first and list argument follow, and there can only ever be one such list argument. For instance, splice() has three scalar arguments followed by a list, whereas gethostbyname() has four scalar arguments.</source>
          <target state="translated">Функции в этом разделе могут служить терминами в выражении. Они делятся на две основные категории: операторы списков и именованные унарные операторы. Они различаются по своему приоритету следующей запятой. (См. Таблицу приоритетов в &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.) Операторы списка принимают более одного аргумента, тогда как унарные операторы никогда не могут принимать более одного аргумента. Таким образом, запятая завершает аргумент унарного оператора, но просто разделяет аргументы оператора списка. Унарный оператор обычно предоставляет скалярный контекст своему аргументу, тогда как оператор списка может предоставлять либо скалярный контекст, либо контекст списка для своих аргументов. Если он делает и то, и другое, сначала идут скалярные аргументы, а следуют аргументы списка, и может быть только один такой аргумент списка. Например, splice () имеет три скалярных аргумента, за которыми следует список, тогда как gethostbyname () имеет четыре скалярных аргумента.</target>
        </trans-unit>
        <trans-unit id="db44e2533a11b8e3bb17098404db4eb4f6f38bb9" translate="yes" xml:space="preserve">
          <source>The functions not currently implemented include:</source>
          <target state="translated">К функциям,которые в настоящее время не выполняются,относятся:</target>
        </trans-unit>
        <trans-unit id="c91d15f478afdf6edcd21180f278e6de93659c87" translate="yes" xml:space="preserve">
          <source>The functions returns the number of files successfully deleted.</source>
          <target state="translated">Функции возвращают количество успешно удаленных файлов.</target>
        </trans-unit>
        <trans-unit id="f6bd4366287856a0db88fc6b5b6a7d5f623cdf54" translate="yes" xml:space="preserve">
          <source>The functions that create ops, which have names like &lt;code&gt;newUNOP&lt;/code&gt; and &lt;code&gt;newBINOP&lt;/code&gt;, call a &quot;check&quot; function associated with each op type, before returning the op. The check functions can mangle the op as they see fit, and even replace it with an entirely new one. These functions are defined in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2856f3e4382d9f450458c2b6360a3461fef80e3f" translate="yes" xml:space="preserve">
          <source>The functions were deprecated in Perl 5.20, and removed in Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c725eeff7e9a331143580354d26ee52b59f30b" translate="yes" xml:space="preserve">
          <source>The gb2312han ordering includes 5 code points in private use area (E2D8..E2DC), that can't utilize &lt;code&gt;weightGB2312()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c6db468e398f8e94d67db3b6a47dc8ea853c6f" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wdeclaration-after-statement&lt;/code&gt; scans for such problems (by default on starting from Perl 5.9.4).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f00447c143aee7d5d5fe37917ea4e13f05bb95" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wdeclaration-after-statements&lt;/code&gt; scans for such problems (by default on starting from Perl 5.9.4).</source>
          <target state="translated">Параметр gcc &lt;code&gt;-Wdeclaration-after-statements&lt;/code&gt; сканирует на наличие таких проблем (по умолчанию при запуске с Perl 5.9.4).</target>
        </trans-unit>
        <trans-unit id="5ee3a23159a200898de862e7d5879870227625eb" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wendif-labels&lt;/code&gt; warns about the bad variant (by default on starting from Perl 5.9.4).</source>
          <target state="translated">Параметр gcc &lt;code&gt;-Wendif-labels&lt;/code&gt; предупреждает о плохом варианте (по умолчанию при запуске с Perl 5.9.4).</target>
        </trans-unit>
        <trans-unit id="4d2d0d644a6adc7963542dd47a318273c10c274d" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wformat&lt;/code&gt; scans for such problems.</source>
          <target state="translated">Параметр gcc &lt;code&gt;-Wformat&lt;/code&gt; выполняет поиск таких проблем.</target>
        </trans-unit>
        <trans-unit id="e2a941e3cdebbe41caee4c09c99b319335c33a51" translate="yes" xml:space="preserve">
          <source>The general answer is to use a CPAN module such as &lt;a href=&quot;Switch::Plain&quot;&gt;Switch::Plain&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af02f4de16ebe9571db6e3223402235667685fe3" translate="yes" xml:space="preserve">
          <source>The general format of this hash ref is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02921462c864d8e6c2a3ae360252bde69882166" translate="yes" xml:space="preserve">
          <source>The general structure of this module was written by Paul Evans &amp;lt;leonerd@leonerd.org.uk&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3325d45be5f27fbb2d4ff677421100e7fd8bb0" translate="yes" xml:space="preserve">
          <source>The generated C++ code will call &lt;code&gt;new&lt;/code&gt; .</source>
          <target state="translated">Сгенерированный код C ++ вызовет &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c6b61d936feb406f72b49e0c15b50e08be699f5" translate="yes" xml:space="preserve">
          <source>The generated C++ code will call &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40f7df8e8a0ceca1fdf5c8cc98299f799cdbb11" translate="yes" xml:space="preserve">
          <source>The generated Makefile enables the user of the extension to invoke</source>
          <target state="translated">Сгенерированный Makefile позволяет пользователю расширения ссылаться на</target>
        </trans-unit>
        <trans-unit id="ddf93e71778e5593e96208d788b15d2297c9188f" translate="yes" xml:space="preserve">
          <source>The generated singletons are kept around from instantiation until the end of the shell session. &amp;lt;plugin_list&amp;gt; can be reconfigured at any time at run time. While the cpan shell is running, it checks all activated plugins at each of the 8 reference points listed above and runs the respective method if it is implemented for that object. The method is called with the active CPAN::Distribution object passed in as an argument.</source>
          <target state="translated">Сгенерированные синглтоны хранятся с момента создания до конца сеанса оболочки. &amp;lt;plugin_list&amp;gt; можно изменить в любой момент во время выполнения. Во время работы оболочки cpan она проверяет все активированные плагины в каждой из 8 контрольных точек, перечисленных выше, и запускает соответствующий метод, если он реализован для этого объекта. Метод вызывается с переданным в качестве аргумента активным объектом CPAN :: Distribution.</target>
        </trans-unit>
        <trans-unit id="04c9e6d408a35a88cbae891becfacfd45984120c" translate="yes" xml:space="preserve">
          <source>The generated trailer for a CODE: section ensures that the number of return values Perl will see is either 0 or 1 (depending on the &lt;code&gt;void&lt;/code&gt; ness of the return value of the C function, and heuristics mentioned in &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt;). The trailer generated for a PPCODE: section is based on the number of return values and on the number of times &lt;code&gt;SP&lt;/code&gt; was updated by &lt;code&gt;[X]PUSH*()&lt;/code&gt; macros.</source>
          <target state="translated">Сгенерированный трейлер для раздела CODE: гарантирует, что количество возвращаемых значений, которые Perl увидит, равно 0 или 1 (в зависимости от &lt;code&gt;void&lt;/code&gt; возвращаемого значения функции C и эвристики, упомянутой в &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;переменной RETVAL&lt;/a&gt; ). Конечный элемент, сгенерированный для раздела PPCODE:, основан на количестве возвращаемых значений и количестве раз, когда &lt;code&gt;SP&lt;/code&gt; обновлялся макросом &lt;code&gt;[X]PUSH*()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7153904b949c21e4b5069542df02f96114b91ebc" translate="yes" xml:space="preserve">
          <source>The generated trailer for a CODE: section ensures that the number of return values Perl will see is either 0 or 1 (depending on the &lt;code&gt;void&lt;/code&gt;ness of the return value of the C function, and heuristics mentioned in &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;&quot;The RETVAL Variable&quot;&lt;/a&gt;). The trailer generated for a PPCODE: section is based on the number of return values and on the number of times &lt;code&gt;SP&lt;/code&gt; was updated by &lt;code&gt;[X]PUSH*()&lt;/code&gt; macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ff48f0e128b0a15571a8a0caa4b35598c3501a" translate="yes" xml:space="preserve">
          <source>The generation number of the name at offset &lt;code&gt;po&lt;/code&gt; in the current compiling pad (lvalue).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147459e5132af1acc303407a971ff312e870e58e" translate="yes" xml:space="preserve">
          <source>The generation number of the name at offset &lt;code&gt;po&lt;/code&gt; in the current compiling pad (lvalue). Note that &lt;code&gt;SvUVX&lt;/code&gt; is hijacked for this purpose.</source>
          <target state="translated">Номер поколения имени по смещению &lt;code&gt;po&lt;/code&gt; в текущей компилируемой панели (lvalue). Обратите внимание, что для этой цели используется &lt;code&gt;SvUVX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65beebb121c6a44259be26715db186e4a704f7cf" translate="yes" xml:space="preserve">
          <source>The generic flag bits are a hybrid of &lt;code&gt;O_XXXXX&lt;/code&gt; style flags deduced from the mode string passed to &lt;code&gt;PerlIO_open()&lt;/code&gt; , and state bits for typical buffer layers.</source>
          <target state="translated">Биты общих флагов представляют собой гибрид &lt;code&gt;O_XXXXX&lt;/code&gt; стиля O_XXXXX, выведенных из строки режима, переданной в &lt;code&gt;PerlIO_open()&lt;/code&gt; , и битов состояния для типичных буферных слоев.</target>
        </trans-unit>
        <trans-unit id="7439e63d8439f40f7da5afff81864b98adf5ed8e" translate="yes" xml:space="preserve">
          <source>The generic flag bits are a hybrid of &lt;code&gt;O_XXXXX&lt;/code&gt; style flags deduced from the mode string passed to &lt;code&gt;PerlIO_open()&lt;/code&gt;, and state bits for typical buffer layers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9373f74aec3f2b814c36a72b32de7c1df8cce7e8" translate="yes" xml:space="preserve">
          <source>The generic names by which a &lt;b&gt;subroutine&lt;/b&gt; knows its &lt;b&gt;arguments&lt;/b&gt;. In many languages, formal arguments are always given individual names; in Perl, the formal arguments are just the elements of an array. The formal arguments to a Perl program are &lt;code&gt;$ARGV[0]&lt;/code&gt; , &lt;code&gt;$ARGV[1]&lt;/code&gt; , and so on. Similarly, the formal arguments to a Perl subroutine are &lt;code&gt;$_[0]&lt;/code&gt; , &lt;code&gt;$_[1]&lt;/code&gt; , and so on. You may give the arguments individual names by assigning the values to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; list. See also &lt;b&gt;actual arguments&lt;/b&gt;.</source>
          <target state="translated">Общие имена, по которым &lt;b&gt;подпрограмма&lt;/b&gt; знает свои &lt;b&gt;аргументы&lt;/b&gt; . Во многих языках формальным аргументам всегда даются индивидуальные имена; в Perl формальные аргументы - это просто элементы массива. Формальные аргументы программы Perl: &lt;code&gt;$ARGV[0]&lt;/code&gt; , &lt;code&gt;$ARGV[1]&lt;/code&gt; и так далее. Точно так же формальные аргументы подпрограммы Perl - это &lt;code&gt;$_[0]&lt;/code&gt; , &lt;code&gt;$_[1]&lt;/code&gt; и так далее. Вы можете дать аргументам индивидуальные имена, присвоив значения &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; списку. См. Также &lt;b&gt;реальные аргументы&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="f91ba75da27279a516590191fc599f042d12a39a" translate="yes" xml:space="preserve">
          <source>The generic names by which a &lt;b&gt;subroutine&lt;/b&gt; knows its &lt;b&gt;arguments&lt;/b&gt;. In many languages, formal arguments are always given individual names; in Perl, the formal arguments are just the elements of an array. The formal arguments to a Perl program are &lt;code&gt;$ARGV[0]&lt;/code&gt;, &lt;code&gt;$ARGV[1]&lt;/code&gt;, and so on. Similarly, the formal arguments to a Perl subroutine are &lt;code&gt;$_[0]&lt;/code&gt;, &lt;code&gt;$_[1]&lt;/code&gt;, and so on. You may give the arguments individual names by assigning the values to a &lt;code&gt;my&lt;/code&gt; list. See also &lt;b&gt;actual arguments&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34968429c314c796b06ef13d6256c2eed375227" translate="yes" xml:space="preserve">
          <source>The get_dup() Method</source>
          <target state="translated">Метод get_dup()</target>
        </trans-unit>
        <trans-unit id="777933c68edb9f2b520827371d959a89885f825a" translate="yes" xml:space="preserve">
          <source>The getaddrinfo() function converts a hostname and a service name into a list of structures, each containing a potential way to connect() to the named service on the named host.</source>
          <target state="translated">Функция getaddrinfo()преобразует имя хоста и имя сервиса в список структур,каждая из которых содержит потенциальный способ соединения()с именованным сервисом на именованном хосте.</target>
        </trans-unit>
        <trans-unit id="b2567e2f657f48e5ffd91f457d438d649766ac8c" translate="yes" xml:space="preserve">
          <source>The getdcwd() function is also provided on Win32 to get the current working directory on the specified drive, since Windows maintains a separate current working directory for each drive. If no drive is specified then the current drive is assumed.</source>
          <target state="translated">Функция getdcwd()также предусмотрена на Win32 для получения текущей рабочей директории на указанном диске,так как Windows поддерживает отдельную текущую рабочую директорию для каждого диска.Если диск не указан,то предполагается текущий диск.</target>
        </trans-unit>
        <trans-unit id="7ef18c4cc3726de3de6ec3372bc632ef914a89f5" translate="yes" xml:space="preserve">
          <source>The getgr() function is a simple front-end that forwards a numeric argument to getgrgid() and the rest to getgrnam().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ed783ab1755c8923c2106affd806182a9b2682" translate="yes" xml:space="preserve">
          <source>The gethost() function is a simple front-end that forwards a numeric argument to gethostbyaddr() by way of Socket::inet_aton, and the rest to gethostbyname().</source>
          <target state="translated">Функция gethost()представляет собой простой внешний интерфейс,который передает числовой аргумент gethostbyaddr()с помощью Socket::inet_aton,а остальные-с помощью gethostbyname().</target>
        </trans-unit>
        <trans-unit id="91be5f2becab7f44b4c2d8e8646f84ed2e15605f" translate="yes" xml:space="preserve">
          <source>The gethost() functions do this in the Perl core:</source>
          <target state="translated">Функции gethost()делают это в ядре Perl:</target>
        </trans-unit>
        <trans-unit id="3d809f6317a210fb06b8763a59c516ccb0250c8f" translate="yes" xml:space="preserve">
          <source>The getnameinfo() function converts a socket address, such as returned by getsockname() or getpeername(), into a pair of human-readable strings representing the address and service name.</source>
          <target state="translated">Функция getnameinfo()преобразует адрес сокета,например,возвращаемый функцией getockname()или getpeername(),в пару читаемых человеком строк,представляющих адрес и имя сервиса.</target>
        </trans-unit>
        <trans-unit id="c7341d184608dfa3d666b4de167cfb9267a092b7" translate="yes" xml:space="preserve">
          <source>The getnet() function is a simple front-end that forwards a numeric argument to getnetbyaddr(), and the rest to getnetbyname().</source>
          <target state="translated">Функция getnet()представляет собой простой внешний интерфейс,который передает числовой аргумент для функции getnetbyaddr(),а остальное-для функции getnetbyname().</target>
        </trans-unit>
        <trans-unit id="a2bc6ce1fe12be1b0104870e6335dfcba678d52a" translate="yes" xml:space="preserve">
          <source>The getnet() functions do this in the Perl core:</source>
          <target state="translated">Функции getnet()делают это в ядре Perl:</target>
        </trans-unit>
        <trans-unit id="723d74402111c283b1693c27eac4e9e45b8e6ed9" translate="yes" xml:space="preserve">
          <source>The getproto() function is a simple front-end that forwards a numeric argument to getprotobyport(), and the rest to getprotobyname().</source>
          <target state="translated">Функция getproto()представляет собой простой внешний интерфейс,который передает числовой аргумент в getprotobyport(),а остальные-в getprotobyname().</target>
        </trans-unit>
        <trans-unit id="7135ce934ee6874d87ad890231c34f496a98c1a0" translate="yes" xml:space="preserve">
          <source>The getpw() function is a simple front-end that forwards a numeric argument to getpwuid() and the rest to getpwnam().</source>
          <target state="translated">Функция getpw()представляет собой простой фронт-энд,который передает числовой аргумент для getpwuid(),а остальное-для getpwnam().</target>
        </trans-unit>
        <trans-unit id="0d0b8e4657c6706a0314a90d140b3591ebd5a9bb" translate="yes" xml:space="preserve">
          <source>The getserv() function is a simple front-end that forwards a numeric argument to getservbyport(), and the rest to getservbyname().</source>
          <target state="translated">Функция geterv()представляет собой простой внешний интерфейс,который передает числовой аргумент в функцию getervbyport(),а остальное-в функцию getervbyname().</target>
        </trans-unit>
        <trans-unit id="7b3093ca7aacbd788d18481992e739fec224cedd" translate="yes" xml:space="preserve">
          <source>The given arguments are made consistent as though by calling &lt;code&gt;mktime()&lt;/code&gt; before calling your system's &lt;code&gt;strftime()&lt;/code&gt; function, except that the &lt;code&gt;isdst&lt;/code&gt; value is not affected.</source>
          <target state="translated">Приведенные аргументы согласовываются, как если бы вызывается &lt;code&gt;mktime()&lt;/code&gt; перед вызовом системной &lt;code&gt;strftime()&lt;/code&gt; , за исключением того, что значение &lt;code&gt;isdst&lt;/code&gt; не изменяется .</target>
        </trans-unit>
        <trans-unit id="a46f0a3dc0d7705f81eb9d2736f8d38ab0c36cf3" translate="yes" xml:space="preserve">
          <source>The given link to</source>
          <target state="translated">Данная ссылка на</target>
        </trans-unit>
        <trans-unit id="1b7e0113518a74a9ca8cd3adb44721180fc0bb94" translate="yes" xml:space="preserve">
          <source>The glob angle-bracket operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is a pathname generator that implements the rules for file name pattern matching used by Unix-like shells such as the Bourne shell or C shell.</source>
          <target state="translated">Оператор глобальных угловых скобок &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; - это генератор путей, который реализует правила сопоставления с образцом имен файлов, используемые Unix-подобными оболочками, такими как оболочка Bourne или оболочка C.</target>
        </trans-unit>
        <trans-unit id="5e215c589947f616aa94dd5242e9494420cfca28" translate="yes" xml:space="preserve">
          <source>The glob containing the output field separator - &lt;code&gt;*,&lt;/code&gt; in Perl space.</source>
          <target state="translated">Глобус, содержащий разделитель выходного поля - &lt;code&gt;*,&lt;/code&gt; в пространстве Perl.</target>
        </trans-unit>
        <trans-unit id="72ac12b62c28c3baeece5702a243d181ecdda5a0" translate="yes" xml:space="preserve">
          <source>The glob was stopped because an error was encountered.</source>
          <target state="translated">Глобус был остановлен из-за ошибки.</target>
        </trans-unit>
        <trans-unit id="f628027fc4ac19b3e64d6b57171d06712a0f4de2" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;debug&lt;/code&gt; and &lt;code&gt;debugcolor&lt;/code&gt; pragmas allow one to get detailed debugging info about regexp compilation and execution. &lt;code&gt;debugcolor&lt;/code&gt; is the same as debug, except the debugging information is displayed in color on terminals that can display termcap color sequences. Here is example output:</source>
          <target state="translated">&lt;code&gt;debugcolor&lt;/code&gt; global &lt;code&gt;debug&lt;/code&gt; и debugcolor позволяют получить подробную отладочную информацию о компиляции и выполнении регулярного выражения. &lt;code&gt;debugcolor&lt;/code&gt; совпадает с отладкой, за исключением того, что отладочная информация отображается в цвете на терминалах, которые могут отображать цветовые последовательности termcap. Вот пример вывода:</target>
        </trans-unit>
        <trans-unit id="2364252b351b212be51c3b8e4ec104f73d0c11a2" translate="yes" xml:space="preserve">
          <source>The global variable $Devel::Peek::pv_limit can be set to limit the number of character printed in various string values. Setting it to 0 means no limit.</source>
          <target state="translated">Глобальная переменная $Devel::Peek::pv_limit может быть установлена для ограничения количества символов,выводимых в различных строковых значениях.Установка в 0 означает отсутствие ограничений.</target>
        </trans-unit>
        <trans-unit id="8c46d35ee4a0a86a8c41ca71ad737aa7e8fc9118" translate="yes" xml:space="preserve">
          <source>The global variables, like &lt;code&gt;@ARGV&lt;/code&gt; or the punctuation variables, must be &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt;. This block reads in</source>
          <target state="translated">Глобальные переменные, такие как &lt;code&gt;@ARGV&lt;/code&gt; или переменные знаки пунктуации, должны быть &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; роскопию с &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; . Этот блок читается в</target>
        </trans-unit>
        <trans-unit id="8eb2db16d327a3b3a5febe18528925e67ce48750" translate="yes" xml:space="preserve">
          <source>The global variables, like &lt;code&gt;@ARGV&lt;/code&gt; or the punctuation variables, must be &lt;code&gt;local&lt;/code&gt;ized with &lt;code&gt;local()&lt;/code&gt;. This block reads in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fffe8d3b97109dc55047625158598478b942552" translate="yes" xml:space="preserve">
          <source>The glossary of this document is based upon this site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968cbdca6785865baa2b963e00c7cf59fd1ce4f6" translate="yes" xml:space="preserve">
          <source>The glue code pulls the arguments from the Perl stack, converts these Perl values to the formats expected by a C function, call this C function, transfers the return values of the C function back to Perl. Return values here may be a conventional C return value or any C function arguments that may serve as output parameters. These return values may be passed back to Perl either by putting them on the Perl stack, or by modifying the arguments supplied from the Perl side.</source>
          <target state="translated">Клеевой код вытаскивает аргументы из стека Perl,преобразует эти Perl-значения в форматы,ожидаемые функцией C,вызывает эту функцию C,передает возвращаемые значения функции C обратно на Perl.Возвращаемые значения здесь могут быть обычным возвращаемым значением C или любыми аргументами функции C,которые могут служить выходными параметрами.Эти возвращаемые значения могут быть переданы обратно на Perl либо путем помещения их в стек Perl,либо путем изменения аргументов,передаваемых со стороны Perl.</target>
        </trans-unit>
        <trans-unit id="cfb79bdb1e9bdcf50c5258db72c30cb6aeb1e3e1" translate="yes" xml:space="preserve">
          <source>The gmctime() function provides a way of getting at the scalar sense of the original CORE::gmtime() function.</source>
          <target state="translated">Функция gmctime()обеспечивает способ получения скалярного смысла исходной функции CORE::gmtime().</target>
        </trans-unit>
        <trans-unit id="15e78ea46607c2d827f12212191bcd40dffea850" translate="yes" xml:space="preserve">
          <source>The goal here is to have a testing utility that's simple to learn, quick to use and difficult to trip yourself up with while still providing more flexibility than the existing Test.pm. As such, the names of the most common routines are kept tiny, special cases and magic side-effects are kept to a minimum. WYSIWYG.</source>
          <target state="translated">Цель здесь заключается в том,чтобы иметь утилиту для тестирования,которая проста в изучении,быстра в использовании и сложна в использовании,обеспечивая при этом большую гибкость по сравнению с существующим Test.pm.Таким образом,названия наиболее распространенных процедур хранятся в крошечном виде,особые случаи и магические побочные эффекты сведены к минимуму.WYSIWYG.</target>
        </trans-unit>
        <trans-unit id="a352895328c4895bdf1e088252c7cfc98a73fd07" translate="yes" xml:space="preserve">
          <source>The goal of the CPAN Testers project (&lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt;) is to test as many CPAN packages as possible on as many platforms as possible. This provides valuable feedback to module authors and potential users to identify bugs or platform compatibility issues and improves the overall quality and value of CPAN.</source>
          <target state="translated">Цель проекта CPAN Testers ( &lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt; ) - протестировать как можно больше пакетов CPAN на как можно большем количестве платформ. Это обеспечивает ценную обратную связь с авторами модулей и потенциальными пользователями для выявления ошибок или проблем совместимости платформ и улучшает общее качество и ценность CPAN.</target>
        </trans-unit>
        <trans-unit id="dc55056f0c4ea6c7742a56f2eaefd841cb6edeb2" translate="yes" xml:space="preserve">
          <source>The goal of the CPAN Testers project (http://testers.cpan.org/) is to test as many CPAN packages as possible on as many platforms as possible. This provides valuable feedback to module authors and potential users to identify bugs or platform compatibility issues and improves the overall quality and value of CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373cfbe1fa7d52d17deaf7ae1d8864f358d08a8b" translate="yes" xml:space="preserve">
          <source>The good news is that at least some DBM module should be available, and &lt;a href=&quot;anydbm_file&quot;&gt;&lt;code&gt;AnyDBM_File&lt;/code&gt;&lt;/a&gt; will use whichever module it can find. Of course, then the code needs to be fairly strict, dropping to the greatest common factor (e.g., not exceeding 1K for each record), so that it will work with any DBM module. See &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4f9c804c591c85f4c73346c685fe6b75566956" translate="yes" xml:space="preserve">
          <source>The good news is that at least some DBM module should be available, and &lt;code&gt;AnyDBM_File&lt;/code&gt; will use whichever module it can find. Of course, then the code needs to be fairly strict, dropping to the greatest common factor (e.g., not exceeding 1K for each record), so that it will work with any DBM module. See &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; for more details.</source>
          <target state="translated">Хорошая новость в том, что должен быть доступен хотя бы какой-то модуль DBM, и &lt;code&gt;AnyDBM_File&lt;/code&gt; будет использовать любой модуль, который сможет найти. Конечно, тогда код должен быть достаточно строгим, с уменьшением до наибольшего общего множителя (например, не превышающего 1 КБ для каждой записи), чтобы он работал с любым модулем DBM. См. &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="0b5a1d8ce58ba1e38f16f3a0f1eb5ac058c6d368" translate="yes" xml:space="preserve">
          <source>The good old C code quality inspector, &lt;code&gt;lint&lt;/code&gt; , is available in several platforms, but please be aware that there are several different implementations of it by different vendors, which means that the flags are not identical across different platforms.</source>
          <target state="translated">Старый добрый инспектор качества кода C, &lt;code&gt;lint&lt;/code&gt; , доступен на нескольких платформах, но имейте в виду, что существует несколько различных его реализаций от разных поставщиков, а это означает, что флаги не идентичны на разных платформах.</target>
        </trans-unit>
        <trans-unit id="339c076fdfc281a53eef98387e350ea8944bc3d1" translate="yes" xml:space="preserve">
          <source>The good old C code quality inspector, &lt;code&gt;lint&lt;/code&gt;, is available in several platforms, but please be aware that there are several different implementations of it by different vendors, which means that the flags are not identical across different platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a4aa574c2f36a349fb65698d1079a80c8716e6" translate="yes" xml:space="preserve">
          <source>The grammar gives you the following rule: you can make the thing on the left of the colon if you see all the things on the right in sequence. This is called a &quot;reduction&quot;, and the aim of parsing is to completely reduce the input. There are several different ways you can perform a reduction, separated by vertical bars: so, &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;=&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; makes a &lt;code&gt;term&lt;/code&gt; , and &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;+&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; can also make a &lt;code&gt;term&lt;/code&gt; .</source>
          <target state="translated">Грамматика дает вам следующее правило: вы можете создать вещь слева от двоеточия, если увидите все элементы справа по порядку. Это называется &amp;laquo;редукцией&amp;raquo;, и цель синтаксического анализа - полностью уменьшить ввод. Существует несколько различных способов сокращения, разделенных вертикальными полосами: так, &lt;code&gt;term&lt;/code&gt; за которым следует &lt;code&gt;=&lt;/code&gt; , за которым следует &lt;code&gt;term&lt;/code&gt; образует &lt;code&gt;term&lt;/code&gt; , а &lt;code&gt;term&lt;/code&gt; за которым следует &lt;code&gt;+&lt;/code&gt; , за которым следует &lt;code&gt;term&lt;/code&gt; также может образовывать &lt;code&gt;term&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99ddf81d340c9da6ddca44ef926625a7b314c62b" translate="yes" xml:space="preserve">
          <source>The grammar gives you the following rule: you can make the thing on the left of the colon if you see all the things on the right in sequence. This is called a &quot;reduction&quot;, and the aim of parsing is to completely reduce the input. There are several different ways you can perform a reduction, separated by vertical bars: so, &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;=&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; makes a &lt;code&gt;term&lt;/code&gt;, and &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;+&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; can also make a &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f689a3c521cea873db9ec7a159a154a44941fb63" translate="yes" xml:space="preserve">
          <source>The grammar, lines one and three of the snippet above, tells you how to build up more complex forms. These complex forms, &quot;non-terminal symbols&quot; are generally placed in lower case. &lt;code&gt;term&lt;/code&gt; here is a non-terminal symbol, representing a single expression.</source>
          <target state="translated">Грамматика, первая и третья строки приведенного выше фрагмента, рассказывает вам, как создавать более сложные формы. Эти сложные формы, &amp;laquo;нетерминальные символы&amp;raquo; обычно помещаются в нижний регистр. &lt;code&gt;term&lt;/code&gt; здесь - нетерминальный символ, представляющий одно выражение.</target>
        </trans-unit>
        <trans-unit id="d748b942ca422b33db3c9c207b20fcf5e35fbf06" translate="yes" xml:space="preserve">
          <source>The great_circle_midpoint() is just a special case of</source>
          <target state="translated">Функция great_circle_midpoint()является особым случаем функции</target>
        </trans-unit>
        <trans-unit id="65a277526deeb0c81c0a5dcd559529318f7f89a5" translate="yes" xml:space="preserve">
          <source>The group as a whole is interpreted as follows:</source>
          <target state="translated">Группа в целом интерпретируется следующим образом:</target>
        </trans-unit>
        <trans-unit id="fc9b7c0745af45eb8fd74cee86dd53c561106e37" translate="yes" xml:space="preserve">
          <source>The group id owning the file</source>
          <target state="translated">Идентификатор группы,владеющей файлом</target>
        </trans-unit>
        <trans-unit id="163b6e7222a22b065c1007b2d5c671945f219faa" translate="yes" xml:space="preserve">
          <source>The group name that owns the file</source>
          <target state="translated">Имя группы,которой принадлежит файл</target>
        </trans-unit>
        <trans-unit id="89fddac9a52f335bd6aece8163a19a7049c17f30" translate="yes" xml:space="preserve">
          <source>The grouping assigns a value to &lt;code&gt;\g1&lt;/code&gt;, so that the same 3-letter sequence is used for both parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5464b947891c7dfe478004d22eea99e392c2554b" translate="yes" xml:space="preserve">
          <source>The grouping assigns a value to \g1, so that the same 3-letter sequence is used for both parts.</source>
          <target state="translated">Группировка присваивает значение \g1,так что для обеих частей используется одна и та же 3-буквенная последовательность.</target>
        </trans-unit>
        <trans-unit id="28563bfc58252e6ce5590c38ddeee29b7156bffa" translate="yes" xml:space="preserve">
          <source>The grouping construct &lt;code&gt;( ... )&lt;/code&gt; creates capture groups (also referred to as capture buffers). To refer to the current contents of a group later on, within the same pattern, use &lt;code&gt;\g1&lt;/code&gt; (or &lt;code&gt;\g{1}&lt;/code&gt;) for the first, &lt;code&gt;\g2&lt;/code&gt; (or &lt;code&gt;\g{2}&lt;/code&gt;) for the second, and so on. This is called a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a808380dda4fa48a019446ad652d6dc63c38be3d" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also allow the extraction of the parts of a string that matched. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. They can be used just as ordinary variables:</source>
          <target state="translated">Метасимволы группировки &lt;code&gt;()&lt;/code&gt; также позволяют извлекать совпадающие части строки. Для каждой группы совпадающая часть попадает в специальные переменные &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; и т. Д. Их можно использовать как обычные переменные:</target>
        </trans-unit>
        <trans-unit id="c2b66b10db32d7f5b9d549c39f4a96523e13167f" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also allow the extraction of the parts of a string that matched. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. They can be used just as ordinary variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7778e0ad49a7501b63144277c49609f424265cc5" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also serve another completely different function: they allow the extraction of the parts of a string that matched. This is very useful to find out what matched and for text processing in general. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. They can be used just as ordinary variables:</source>
          <target state="translated">Метасимволы группировки &lt;code&gt;()&lt;/code&gt; также выполняют другую совершенно другую функцию: они позволяют извлекать совпадающие части строки. Это очень полезно, чтобы узнать, что совпало, и для обработки текста в целом. Для каждой группы совпадающая часть попадает в специальные переменные &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; и т. Д. Их можно использовать как обычные переменные:</target>
        </trans-unit>
        <trans-unit id="f7d8e07f21ecf7c9b89414eb2748089fabb93562" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also serve another completely different function: they allow the extraction of the parts of a string that matched. This is very useful to find out what matched and for text processing in general. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eece9645dd47cfb0899002c6d7925c002a7646e" translate="yes" xml:space="preserve">
          <source>The guts of &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; utility.</source>
          <target state="translated">Внутренности &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; полезности.</target>
        </trans-unit>
        <trans-unit id="4573f027ad2a701c6d9118677a3e8b776808d62d" translate="yes" xml:space="preserve">
          <source>The guts of &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; utility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1a967bf7f342dcba1f488528612191eac5ba1e" translate="yes" xml:space="preserve">
          <source>The gzip support in &lt;code&gt;Compress::Zlib&lt;/code&gt; version 1.x can only work with a real filesystem filehandle. The filehandles used by Apache modules are not associated with the filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2c643a66e3a499a113b39d3630e9b4f6beb5ae" translate="yes" xml:space="preserve">
          <source>The handle identifies a directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31680a03b79cf90dad61ef90684e16f85b576d96" translate="yes" xml:space="preserve">
          <source>The handler names are based on the underlying type of the variable being declared or of the reference passed. Because these attributes are associated with subroutine or variable declarations, this deliberately ignores any possibility of being blessed into some package. Thus, a subroutine declaration uses &quot;CODE&quot; as its</source>
          <target state="translated">Имена обработчиков основываются на основном типе декларируемой переменной или передаваемой ссылки.Так как эти атрибуты связаны с объявлениями подпрограмм или переменных,это сознательно игнорирует любую возможность быть благословленным в каком-то пакете.Таким образом,в подпрограммной декларации используется &quot;CODE&quot; как ее</target>
        </trans-unit>
        <trans-unit id="a4c1e3467d4145540134804fd2549f602b627fdd" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals calls &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (actually &lt;code&gt;croak&lt;/code&gt; ) with a message indicating which signal was caught.</source>
          <target state="translated">Обработчик, используемый для последовательно установленных сигналов, вызывает &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (фактически &lt;code&gt;croak&lt;/code&gt; ) с сообщением, указывающим, какой сигнал был пойман.</target>
        </trans-unit>
        <trans-unit id="00d58947b3aad48761af600208c9e3fd41356ea5" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals calls &lt;code&gt;die&lt;/code&gt; (actually &lt;code&gt;croak&lt;/code&gt;) with a message indicating which signal was caught.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f12af1084926ed2ac194950a97f332b400e2448" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals outputs a Perl stack trace to STDERR and then tries to dump core. This is the default signal handler.</source>
          <target state="translated">Обработчик,используемый для последующих установленных сигналов,выводит трассу стека Perl в STDERR и затем пытается сбросить ядро.Это обработчик сигналов по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d5126c9fee7d8a5338a4248383236dc9ecb51986" translate="yes" xml:space="preserve">
          <source>The handling of A &amp;amp; P in MBI/MBF (the old core code shipped with Perl versions &amp;lt;= 5.7.2) is like this:</source>
          <target state="translated">Обработка A &amp;amp; P в MBI / MBF (старый код ядра, поставляемый с версиями Perl &amp;lt;= 5.7.2) выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="fc9357967428b2793ab9d519118dce3147a43e76" translate="yes" xml:space="preserve">
          <source>The handling of errors by the layer is not specified. e.g. when $! should be set explicitly, when the error handling should be just delegated to the top layer.</source>
          <target state="translated">Обработка ошибок слоем не указана,например,когда $! должен быть задан явно,когда обработка ошибок должна быть просто делегирована верхнему слою.</target>
        </trans-unit>
        <trans-unit id="3b8d0bb90f4b079a36f72ce61ffbf0db337af8a2" translate="yes" xml:space="preserve">
          <source>The handling of hyphens and em dashes is somewhat fragile, and one may get the wrong one under some circumstances. This should only matter for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">Обработка дефисов и длинных тире несколько хрупка, и при некоторых обстоятельствах можно ошибиться. Это должно иметь значение только для вывода &lt;b&gt;troff&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="de0cf92f651484ad4efbe5f702009188bf5e94e3" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%ENV&lt;/code&gt; contains your current environment. Setting a value in &lt;code&gt;ENV&lt;/code&gt; changes the environment for any child processes you subsequently &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; off.</source>
          <target state="translated">Хэш &lt;code&gt;%ENV&lt;/code&gt; содержит вашу текущую среду. Установка значения в &lt;code&gt;ENV&lt;/code&gt; изменяет среду для любых дочерних процессов, которые вы впоследствии отключаете &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="195033ec6c0348a9a8c6b6c6ac70c90873828bda" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%ENV&lt;/code&gt; contains your current environment. Setting a value in &lt;code&gt;ENV&lt;/code&gt; changes the environment for any child processes you subsequently &lt;code&gt;fork()&lt;/code&gt; off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3342ea08441abded27300d3bc9cbf7a4f36851e5" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%INC&lt;/code&gt; contains entries for each filename included via the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; operators. The key is the filename you specified (with module names converted to pathnames), and the value is the location of the file found. The &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operator uses this hash to determine whether a particular file has already been included.</source>
          <target state="translated">Хэш &lt;code&gt;%INC&lt;/code&gt; содержит записи для каждого имени файла, включенные с помощью операторов &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; . Ключ - это указанное вами имя файла (с преобразованием имен модулей в пути), а значение - расположение найденного файла. Оператор &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; использует этот хэш, чтобы определить, был ли уже включен конкретный файл.</target>
        </trans-unit>
        <trans-unit id="266d3cf7610b8376c6c9862a0efb7aafe1dd7d00" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%INC&lt;/code&gt; contains entries for each filename included via the &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, or &lt;code&gt;use&lt;/code&gt; operators. The key is the filename you specified (with module names converted to pathnames), and the value is the location of the file found. The &lt;code&gt;require&lt;/code&gt; operator uses this hash to determine whether a particular file has already been included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0c946c442c59fafdf0cc03f5925a7d6a67576e" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%SIG&lt;/code&gt; contains signal handlers for signals. For example:</source>
          <target state="translated">Хэш &lt;code&gt;%SIG&lt;/code&gt; содержит обработчики сигналов. Например:</target>
        </trans-unit>
        <trans-unit id="2b378e4f482e4b01f36a8f2a09efa90c92e18352" translate="yes" xml:space="preserve">
          <source>The hash algorithm is defined in the &lt;code&gt;PERL_HASH&lt;/code&gt; macro:</source>
          <target state="translated">Алгоритм хеширования определен в макросе &lt;code&gt;PERL_HASH&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9dd8951a5e30b83106f470f819a5f4eb8b3cc146" translate="yes" xml:space="preserve">
          <source>The hash contains a &quot;version&quot; key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea3de2cc53cbdd71b8b1d8903e357859f8beec1" translate="yes" xml:space="preserve">
          <source>The hash described above is returned for locale-independent casing, where at least one of the mappings has length longer than one. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the code point may have mappings, but if so, all are length one, and are returned by &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;. Note that when this function does return a value, it will be for the complete set of mappings for a code point, even those whose length is one.</source>
          <target state="translated">Описанный выше хэш возвращается для не зависящего от языкового стандарта регистра, когда по крайней мере одно из сопоставлений имеет длину больше единицы. Если возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , кодовая точка может иметь сопоставления, но если да, все имеют длину один и возвращаются &lt;a href=&quot;#charinfo()&quot;&gt;функцией charinfo ()&lt;/a&gt; . Обратите внимание, что когда эта функция действительно возвращает значение, оно будет для полного набора отображений для кодовой точки, даже для тех, длина которых равна единице.</target>
        </trans-unit>
        <trans-unit id="711d74daff085b3047aba5916127a254ddfd4772" translate="yes" xml:space="preserve">
          <source>The hash described above is returned for locale-independent casing, where at least one of the mappings has length longer than one. If &lt;code&gt;undef&lt;/code&gt; is returned, the code point may have mappings, but if so, all are length one, and are returned by &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt;. Note that when this function does return a value, it will be for the complete set of mappings for a code point, even those whose length is one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c18c1acf75672457070b2eb9996c5075b3edce2" translate="yes" xml:space="preserve">
          <source>The hash does not support exists().</source>
          <target state="translated">Хэш не поддерживает существование().</target>
        </trans-unit>
        <trans-unit id="8ead17751b61a27f00737722511d4f0a6b122f2d" translate="yes" xml:space="preserve">
          <source>The hash has the same structure as the one returned by Storable::file_magic(). The &lt;code&gt;file&lt;/code&gt; element is true if the image is a file image.</source>
          <target state="translated">Хэш имеет ту же структуру, что и возвращаемый Storable :: file_magic (). Элемент &lt;code&gt;file&lt;/code&gt; имеет значение true, если изображение является файловым изображением.</target>
        </trans-unit>
        <trans-unit id="5130b4f9ca4de414c6b75c63b4b5de1f1cac05d9" translate="yes" xml:space="preserve">
          <source>The hash reference returned by the new() function can be used to examine and modify the contents of the .packlist. Items may be added/deleted from the .packlist by modifying the hash. If the value associated with a hash key is a scalar, the entry written to the .packlist by any subsequent write() will be a simple filename. If the value is a hash, the entry written will be the filename followed by the key=value pairs from the hash. Reading back the .packlist will recreate the original entries.</source>
          <target state="translated">Хэш-ссылка,возвращаемая функцией new(),может быть использована для изучения и изменения содержимого .packlist.Элементы могут быть добавлены/удалены из .packlist путем изменения хэша.Если значение,связанное с хэшем,является скаляром,то запись,записанная в .packlist любой последующей функцией write(),будет простым именем файла.Если значение является хэшем,то записываемая запись будет именем файла,за которым последуют пары ключ=значение из хэша.Чтение обратно .packlist воссоздает оригинальные записи.</target>
        </trans-unit>
        <trans-unit id="7516ee71ac16390106261a6b0bbe1da56c817eef" translate="yes" xml:space="preserve">
          <source>The hash returned has the following elements:</source>
          <target state="translated">Возвращаемый хэш имеет следующие элементы:</target>
        </trans-unit>
        <trans-unit id="5e040a1ccea7ca71c3bad7dc1e4a1dfbebdc6ad0" translate="yes" xml:space="preserve">
          <source>The hash structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a906eb4ff4eda3db678faefd07c14f14845797" translate="yes" xml:space="preserve">
          <source>The hash variable you want to tie.</source>
          <target state="translated">Переменная гашиша,которую ты хочешь связать.</target>
        </trans-unit>
        <trans-unit id="1e40f9760b2e7d5577d2825dfdedf13a7e442c00" translate="yes" xml:space="preserve">
          <source>The head of the chain of deleted ops is returned, or &lt;code&gt;NULL&lt;/code&gt; if no ops were deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ab4ffe148d6038400649049035912b11305e989" translate="yes" xml:space="preserve">
          <source>The head of the chain of deleted ops is returned, or NULL if no ops were deleted.</source>
          <target state="translated">Возвращается глава цепочки удаленных операторов,или NULL,если ни один из операторов не был удален.</target>
        </trans-unit>
        <trans-unit id="fb8198ac36c0383db875a5b5488218cc0db38e42" translate="yes" xml:space="preserve">
          <source>The head of the stack is &lt;code&gt;PL_markstack_ptr&lt;/code&gt;, and points to the most recently-pushed item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387a371cfd5487134922ec368d5a02aa122c9278" translate="yes" xml:space="preserve">
          <source>The head of the stack is &lt;code&gt;PL_stack_sp&lt;/code&gt;, and points to the most recently-pushed item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa9e497fb69d1c1631afd8e4e7265382a3e02b69" translate="yes" xml:space="preserve">
          <source>The head of the stack is indexed by &lt;code&gt;PL_savestack_ix&lt;/code&gt;, an integer which stores the index in the array at which the next item should be pushed. (Note that this is different to most other stacks, which reference the most recently-pushed item).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaff0f01d94e655d09c1c9c0abff908c801c87d2" translate="yes" xml:space="preserve">
          <source>The head of the stack is indexed by &lt;code&gt;PL_scopestack_ix&lt;/code&gt;, an integer which stores the index of the array or arrays at which the next item should be pushed. (Note that this is different to most other stacks, which reference the most recently-pushed item).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf516ef8c50debb6627d05e33ce24dc47fb581a2" translate="yes" xml:space="preserve">
          <source>The head of the stack is indexed by &lt;code&gt;PL_tmps_ix&lt;/code&gt;, an integer which stores the index in the array of the most recently-pushed item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c336f0d4ef1d936490e8c7b4819c090f6400cf2" translate="yes" xml:space="preserve">
          <source>The header file written by this module, typically</source>
          <target state="translated">Заголовочный файл,написанный этим модулем,обычно</target>
        </trans-unit>
        <trans-unit id="4c85c6655d7d1206831fdc527a34ff595586e985" translate="yes" xml:space="preserve">
          <source>The header section continues until a line containing the word CHARMAP. This section has a form of</source>
          <target state="translated">Раздел заголовка продолжается до строки,содержащей слово CHARMAP.Этот раздел имеет форму</target>
        </trans-unit>
        <trans-unit id="a528e0d6eaf7b88f88a4f152246f56b029cd4490" translate="yes" xml:space="preserve">
          <source>The heart of Storable is written in C for decent speed. Extra low-level optimizations have been made when manipulating perl internals, to sacrifice encapsulation for the benefit of greater speed.</source>
          <target state="translated">Сердце Сторибла написано на C для приличной скорости.Дополнительные низкоуровневые оптимизации были сделаны при манипулировании perl внутренностями,чтобы пожертвовать инкапсуляцией в пользу большей скорости.</target>
        </trans-unit>
        <trans-unit id="a8fcb5ed9aadb57481c4a4c9eabfd488f403dcd6" translate="yes" xml:space="preserve">
          <source>The here-doc modifier &lt;code&gt;~&lt;/code&gt; allows you to indent your here-docs to make the code more readable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6afbf6cabde867bd59953ce46fc882087b1bd27" translate="yes" xml:space="preserve">
          <source>The hex number may optionally be prefixed with &quot;0x&quot; or &quot;x&quot; unless &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; is set in</source>
          <target state="translated">Шестнадцатеричное число может дополнительно иметь префикс &amp;laquo;0x&amp;raquo; или &amp;laquo;x&amp;raquo;, если &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; не установлен в</target>
        </trans-unit>
        <trans-unit id="13723a6864537beca2cddb32c984b567fe87e40b" translate="yes" xml:space="preserve">
          <source>The hex number may optionally be prefixed with &lt;code&gt;&quot;0x&quot;&lt;/code&gt; or &lt;code&gt;&quot;x&quot;&lt;/code&gt; unless &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; is set in &lt;code&gt;*flags&lt;/code&gt; on entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e84dec921d35d3ee6755f09b85656ef3201e9eb" translate="yes" xml:space="preserve">
          <source>The high-order 4 bytes of the total number of cylinders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70cee26392a760c84fafaebf12b0f84ec8e67796" translate="yes" xml:space="preserve">
          <source>The higher-level loops preserve an additional state between iterations: whether the last match was zero-length. To break the loop, the following match after a zero-length match is prohibited to have a length of zero. This prohibition interacts with backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;&quot;Backtracking&quot;&lt;/a&gt;), and so the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e478860a296847f9fc713c230a9fb9343e5f150e" translate="yes" xml:space="preserve">
          <source>The higher-level loops preserve an additional state between iterations: whether the last match was zero-length. To break the loop, the following match after a zero-length match is prohibited to have a length of zero. This prohibition interacts with backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;), and so the</source>
          <target state="translated">Циклы более высокого уровня сохраняют дополнительное состояние между итерациями: было ли последнее совпадение нулевой длины. Чтобы разорвать цикл, следующее совпадение после совпадения нулевой длины запрещено иметь нулевую длину. Этот запрет взаимодействует с отслеживанием с возвратом (см. &lt;a href=&quot;#Backtracking&quot;&gt;Отслеживание с возвратом&lt;/a&gt; ), и поэтому</target>
        </trans-unit>
        <trans-unit id="5d5a041b27e5325dac6f1b79cae3bff7a7552bef" translate="yes" xml:space="preserve">
          <source>The highest priority is to look in the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59406d517ca12a7bf5809c9dbfccd1e683e04f9f" translate="yes" xml:space="preserve">
          <source>The hinting interface allows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a2214ecae9d593eb49cab164240c89849da3aae" translate="yes" xml:space="preserve">
          <source>The hintsfile is eval()ed immediately after the arguments given to WriteMakefile are stuffed into a hash reference $self but before this reference becomes blessed. So if you want to do the equivalent to override or create an attribute you would say something like</source>
          <target state="translated">Файл подсказки eval()ed сразу после того,как аргументы,переданные в WriteMakefile,засовываются в хэш-ссылку $elf,но до того,как эта ссылка становится благословенной.Таким образом,если вы хотите сделать эквивалент переопределения или создать атрибут,то скажите что-нибудь наподобие</target>
        </trans-unit>
        <trans-unit id="c6b34cade6e81d89b062f256b78cf0c9f72eec68" translate="yes" xml:space="preserve">
          <source>The hook used by perl's &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; operator. &lt;b&gt;ptype&lt;/b&gt; is perl's character for the kind of IO:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; оператором binmode в Perl . &lt;b&gt;ptype&lt;/b&gt; - это символ Perl для типа ввода-вывода:</target>
        </trans-unit>
        <trans-unit id="1add1ef58ecb7c35c4f838c64caf5db36bdf795e" translate="yes" xml:space="preserve">
          <source>The hook used by perl's &lt;code&gt;binmode&lt;/code&gt; operator. &lt;b&gt;ptype&lt;/b&gt; is perl's character for the kind of IO:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f349975f67add93f8850a9eaf9c6c17fd6d7655e" translate="yes" xml:space="preserve">
          <source>The host name supplied to getaddrinfo() did not provide any usable address data.</source>
          <target state="translated">Имя хоста,предоставленное для getaddrinfo(),не содержало никаких данных об адресе,которые можно было бы использовать.</target>
        </trans-unit>
        <trans-unit id="26f0f0653cc389e36c588050d688c99bccaa9d07" translate="yes" xml:space="preserve">
          <source>The host name supplied to getaddrinfo() does not exist, or the address supplied to getnameinfo() is not associated with a host name and the &lt;code&gt;NI_NAMEREQD&lt;/code&gt; flag was supplied.</source>
          <target state="translated">Имя хоста, указанное в getaddrinfo (), не существует, или адрес, предоставленный getnameinfo (), не связан с именем хоста, и был предоставлен флаг &lt;code&gt;NI_NAMEREQD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5eeccb55ae3d60bff3752f2dd5a946e36daa986" translate="yes" xml:space="preserve">
          <source>The hostname in the uri. Will be empty if host was originally 'localhost' for a 'file://' url.</source>
          <target state="translated">Имя хозяина в Ури.Будет пустым,если хост изначально был 'localhost' для url 'file://'.</target>
        </trans-unit>
        <trans-unit id="c156a44c9f3418b797d3bba0a0c3707b47fb0ac1" translate="yes" xml:space="preserve">
          <source>The hub class or subclass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b8df6ac6b4142b5235e5c136ec2dc940fbfdbc" translate="yes" xml:space="preserve">
          <source>The hub is the place where all events get processed and handed off to the formatter. The hub also tracks test state, and provides several hooks into the event pipeline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bcd00b585852692b974ea751e079b51540b5b54" translate="yes" xml:space="preserve">
          <source>The hyperbolic sine, cosine, and tangent</source>
          <target state="translated">Гиперболический синус,косинус и тангенс...</target>
        </trans-unit>
        <trans-unit id="ff901843574864f25cda07a5ab8922dd36a5d5b7" translate="yes" xml:space="preserve">
          <source>The icmp and icmpv6 protocols requires that the program be run as root or that it be setuid to root. The other protocols do not require special privileges, but not all network devices implement tcp or udp echo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67744a35db2bbac17aada3b55cebfdff3c8d58f" translate="yes" xml:space="preserve">
          <source>The icmp protocol requires that the program be run as root or that it be setuid to root. The other protocols do not require special privileges, but not all network devices implement tcp or udp echo.</source>
          <target state="translated">Протокол icmp требует,чтобы программа запускалась от имени root или чтобы она была setuid от имени root.Другие протоколы не требуют специальных привилегий,но не все сетевые устройства реализуют tcp или udp echo.</target>
        </trans-unit>
        <trans-unit id="0eb904ac9079537474ee2cc5638a1c5ecde2814c" translate="yes" xml:space="preserve">
          <source>The id must start with a letter (a-z or A-Z)</source>
          <target state="translated">Идентификатор должен начинаться с буквы (a-z или A-Z).</target>
        </trans-unit>
        <trans-unit id="28d56a775fecdcfc9d3c448ae0628addf0163100" translate="yes" xml:space="preserve">
          <source>The ideal (but a bit ugly) way to never have to think about that is to use &lt;code&gt;BEGIN&lt;/code&gt; blocks. So the first part of the &lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;&lt;/a&gt; code could be rewritten as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28df5f4390b3a084c824acbbd266525edf8be51a" translate="yes" xml:space="preserve">
          <source>The ideal (but a bit ugly) way to never have to think about that is to use &lt;code&gt;BEGIN&lt;/code&gt; blocks. So the first part of the &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; code could be rewritten as:</source>
          <target state="translated">Идеальный (но немного уродливый) способ никогда не думать об этом - использовать блоки &lt;code&gt;BEGIN&lt;/code&gt; . Таким образом, первую часть кода &lt;a href=&quot;#SYNOPSIS&quot;&gt;ОБЗОР&lt;/a&gt; можно переписать как:</target>
        </trans-unit>
        <trans-unit id="3e76ae6d87db97d0c1319c6311b06f1b4140b992" translate="yes" xml:space="preserve">
          <source>The immediate, in addition to the current stable release, the previous stable release is maintained. See &lt;a href=&quot;perlpolicy#MAINTENANCE-AND-SUPPORT&quot;&gt;&quot;MAINTENANCE AND SUPPORT&quot; in perlpolicy&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b5bd1f2c1aa12d8d86dc87b94e48313e6fd68a" translate="yes" xml:space="preserve">
          <source>The immediate, previous releases (i.e. perl5.14.x ) are usually maintained for a while, although not at the same level as the current releases.</source>
          <target state="translated">Непосредственные,предыдущие выпуски (т.е.perl5.14.x ),как правило,поддерживаются в течение некоторого времени,хотя и не на том же уровне,что и текущие выпуски.</target>
        </trans-unit>
        <trans-unit id="805f5e34bdac09e91b618eb56a2ba5ac7b88cd61" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;:raw&lt;/code&gt; is as a pseudo-layer which when &quot;pushed&quot; pops itself and then any layers which do not declare themselves as suitable for binary data. (Undoing :utf8 and :crlf are implemented by clearing flags rather than popping layers but that is an implementation detail.)</source>
          <target state="translated">Реализация &lt;code&gt;:raw&lt;/code&gt; - это псевдослой, который при &quot;нажатии&quot; выскакивает сам, а затем любые слои, которые не объявляют себя подходящими для двоичных данных. (Отмена: utf8 и: crlf реализуются путем очистки флагов, а не выталкивания слоев, но это деталь реализации.)</target>
        </trans-unit>
        <trans-unit id="74166820cac25a2e66888d5644d8d2715e58984a" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;:raw&lt;/code&gt; is as a pseudo-layer which when &quot;pushed&quot; pops itself and then any layers which would modify the binary data stream. (Undoing &lt;code&gt;:utf8&lt;/code&gt; and &lt;code&gt;:crlf&lt;/code&gt; may be implemented by clearing flags rather than popping layers but that is an implementation detail.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1868b2d1d8d2925ab9482699d09a63b0f1af9f3c" translate="yes" xml:space="preserve">
          <source>The implementation of individual components of the system is likely to change over time.</source>
          <target state="translated">Внедрение отдельных компонентов системы,вероятно,со временем изменится.</target>
        </trans-unit>
        <trans-unit id="6075b5ee16206eda7e75f744a66591ab7ff6ad34" translate="yes" xml:space="preserve">
          <source>The implementation of the C3 MRO and switchable MROs within the perl core was written by Brandon L Black. Nicholas Clark created the pluggable interface, refactored Brandon's implementation to work with it, and wrote this document.</source>
          <target state="translated">Реализация C3 MRO и переключаемых MRO в рамках perl ядра была написана Брэндоном Л.Блэком.Николас Кларк создал подключаемый интерфейс,обновил реализацию Брэндона для работы с ним и написал этот документ.</target>
        </trans-unit>
        <trans-unit id="0af6409c892c8fe954ef686ac149074100758771" translate="yes" xml:space="preserve">
          <source>The implementation that surfaces this limitation will not be changed. See the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f92ca5378313f5f6ef2629dcf71bf80c645c279f" translate="yes" xml:space="preserve">
          <source>The implication of the above description is that a pattern containing nested parentheses will result in a call graph which cycles through &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt; , &lt;code&gt;regpiece()&lt;/code&gt; , &lt;code&gt;regatom()&lt;/code&gt; , &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt;</source>
          <target state="translated">Из приведенного выше описания следует, что шаблон, содержащий вложенные скобки, приведет к графу вызовов, который циклически проходит через &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt; , &lt;code&gt;regpiece()&lt;/code&gt; , &lt;code&gt;regatom()&lt;/code&gt; , &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a5213d8ec5be4ed3cc0fcaff5c663e1f7ec79164" translate="yes" xml:space="preserve">
          <source>The implication of the above description is that a pattern containing nested parentheses will result in a call graph which cycles through &lt;code&gt;reg()&lt;/code&gt;, &lt;code&gt;regbranch()&lt;/code&gt;, &lt;code&gt;regpiece()&lt;/code&gt;, &lt;code&gt;regatom()&lt;/code&gt;, &lt;code&gt;reg()&lt;/code&gt;, &lt;code&gt;regbranch()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ca45a7499fa655d95fb3a1c14575987ee3c0c2" translate="yes" xml:space="preserve">
          <source>The implicit iterator variable in the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">Неявная переменная итератора в функциях &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0c861ae3d9b69a61149562b6cbed085fb5fa583" translate="yes" xml:space="preserve">
          <source>The implicit iterator variable in the &lt;code&gt;grep()&lt;/code&gt; and &lt;code&gt;map()&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49df36702f6a3c6192de102a29688dbe9fd4061b" translate="yes" xml:space="preserve">
          <source>The implicit variable of &lt;code&gt;given()&lt;/code&gt; .</source>
          <target state="translated">Неявная переменная &lt;code&gt;given()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7bb5561c43ecc998d31a66fa1460eabbf5c497c" translate="yes" xml:space="preserve">
          <source>The implicit variable of &lt;code&gt;given()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c82ff9343f818ba122f89e2a74fb9d1d0fecda" translate="yes" xml:space="preserve">
          <source>The importance of these tests is proportional to the alleged stability of a module. A module which purports to be stable or which hopes to achieve wide use should adhere to as strict a testing regime as possible.</source>
          <target state="translated">Важность этих тестов пропорциональна предполагаемой стабильности модуля.Модуль,претендующий на стабильность или надеющийся на широкое использование,должен придерживаться как можно более строгого режима тестирования.</target>
        </trans-unit>
        <trans-unit id="09af00710c80d3dd70ebd96fd4367e42313c5d25" translate="yes" xml:space="preserve">
          <source>The importance of writing good test scripts cannot be over-emphasized. You should closely follow the &quot;ok/not ok&quot; style that Perl itself uses, so that it is very easy and unambiguous to determine the outcome of each test case. When you find and fix a bug, make sure you add a test case for it.</source>
          <target state="translated">Невозможно переоценить важность написания хороших тестовых сценариев.Следует внимательно следить за стилем &quot;ok/not ok&quot;,используемым самим Perl,чтобы очень легко и однозначно определить результат каждого тестового случая.Когда вы найдете и исправите ошибку,убедитесь,что вы добавили тестовый пример для нее.</target>
        </trans-unit>
        <trans-unit id="a4561daf93366d570e71e9394fec54f9d31846e6" translate="yes" xml:space="preserve">
          <source>The important and distinguishing feature of run_forked is execution timeout which at first seems to be quite a simple task but if you think that the program which you're spawning might spawn some children itself (which in their turn could do the same and so on) it turns out to be not a simple issue.</source>
          <target state="translated">Важной и отличительной особенностью run_forked является таймаут выполнения,который поначалу кажется довольно простой задачей,но если Вы думаете,что программа,которую Вы нерестите,может сама породить несколько детей (которые,в свою очередь,могут сделать то же самое и т.д.),то это оказывается не простой проблемой.</target>
        </trans-unit>
        <trans-unit id="4973662d6822686f7aa087396e5cfac037bf9b09" translate="yes" xml:space="preserve">
          <source>The important parts of that are the second argument (the increment) to HEAP, and allowing the stack to be &quot;Above the (16M) line&quot;. If the heap increment is too small then when perl (for example loading unicode/Name.pl) tries to create a &quot;big&quot; (400K+) string it cannot fit in a single segment and you get &quot;Out of Memory!&quot; - even if there is still plenty of memory available.</source>
          <target state="translated">Важными частями являются второй аргумент (инкремент)к HEAP,позволяющий стеку быть &quot;Выше линии (16M)&quot;.Если куча приращений слишком мала,то когда perl (например,загружающий unicode/Name.pl)пытается создать &quot;большую&quot; (400K+)строку,она не может поместиться в один сегмент,и вы получаете &quot;Из Памяти!&quot;.-даже если памяти все еще достаточно.</target>
        </trans-unit>
        <trans-unit id="3f69c866bd6b570c0ad67a5d6dcc4f47abb90206" translate="yes" xml:space="preserve">
          <source>The included contents will be inserted into the MANIFEST.SKIP file in between</source>
          <target state="translated">Включенное содержимое будет вставлено в файл MANIFEST.SKIP между</target>
        </trans-unit>
        <trans-unit id="321a9d8c0c3e343e922f69286afb469449a8323c" translate="yes" xml:space="preserve">
          <source>The independent subexpression &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; doesn't care about the rest of the regexp, so it sees an &lt;code&gt;'a'&lt;/code&gt; and grabs it. Then the rest of the regexp &lt;code&gt;ab&lt;/code&gt; cannot match. Because &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; is independent, there is no backtracking and the independent subexpression does not give up its &lt;code&gt;'a'&lt;/code&gt;. Thus the match of the regexp as a whole fails. A similar behavior occurs with completely independent regexps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02e5563a36b89e14fcbd689f1595a21037cddaee" translate="yes" xml:space="preserve">
          <source>The independent subexpression &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; doesn't care about the rest of the regexp, so it sees an &lt;code&gt;a&lt;/code&gt; and grabs it. Then the rest of the regexp &lt;code&gt;ab&lt;/code&gt; cannot match. Because &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; is independent, there is no backtracking and the independent subexpression does not give up its &lt;code&gt;a&lt;/code&gt; . Thus the match of the regexp as a whole fails. A similar behavior occurs with completely independent regexps:</source>
          <target state="translated">Независимое подвыражение &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; A *) не заботится об остальной части регулярного выражения, поэтому оно видит &lt;code&gt;a&lt;/code&gt; и захватывает его. Тогда остальная часть регулярного выражения &lt;code&gt;ab&lt;/code&gt; не может совпадать. Поскольку &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; является независимым, нет никакого возврата, и независимое подвыражение не отказывается от своего &lt;code&gt;a&lt;/code&gt; . Таким образом, совпадение регулярного выражения в целом не выполняется. Аналогичное поведение происходит с полностью независимыми регулярными выражениями:</target>
        </trans-unit>
        <trans-unit id="d8911df7ecc3a80cd7cb7748b8608afa2215b297" translate="yes" xml:space="preserve">
          <source>The index entry specified contains nothing but whitespace.</source>
          <target state="translated">Указанная запись индекса не содержит ничего,кроме пробелов.</target>
        </trans-unit>
        <trans-unit id="8993f68ea89e04e52354fc3b53dacbbf01363016" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;a href=&quot;#index-STR%2CSUBSTR%2CPOSITION&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; returns -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed2b9d5332f95abb7e28bc54e5124d59c88ac74f" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; returns -1.</source>
          <target state="translated">Функция индекса ищет одну строку в другой, но без поведения, подобного подстановочным знакам, при полном совпадении с шаблоном регулярного выражения. Он возвращает позицию первого вхождения SUBSTR в STR в POSITION или после него. Если POSITION опущено, поиск начинается с начала строки. POSITION до начала строки или после ее конца обрабатывается, как если бы это было начало или конец, соответственно. POSITION и возвращаемое значение основаны на нуле. Если подстрока не найдена, &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; возвращает -1.</target>
        </trans-unit>
        <trans-unit id="052a5a20374b32a9d318c8e657a3fc6d2c067a62" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;code&gt;&lt;a href=&quot;index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; returns -1.</source>
          <target state="translated">Функция индекса ищет одну строку в другой, но без поведения, подобного подстановочным знакам, при полном совпадении с шаблоном регулярного выражения. Он возвращает позицию первого вхождения SUBSTR в STR в POSITION или после него. Если POSITION опущено, поиск начинается с начала строки. POSITION до начала строки или после ее конца обрабатывается, как если бы это было начало или конец, соответственно. POSITION и возвращаемое значение основаны на нуле. Если подстрока не найдена, &lt;code&gt;&lt;a href=&quot;index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; возвращает -1.</target>
        </trans-unit>
        <trans-unit id="1deb1e733742d1b9b4e186c9d57759d15dd95d6b" translate="yes" xml:space="preserve">
          <source>The index of the last allocated space in the padlist. Note that the last pad may be in an earlier slot. Any entries following it will be &lt;code&gt;NULL&lt;/code&gt; in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d12f86f44aac2e21ecbe7b61cc95b95675209f" translate="yes" xml:space="preserve">
          <source>The index of the last allocated space in the padlist. Note that the last pad may be in an earlier slot. Any entries following it will be NULL in that case.</source>
          <target state="translated">Индекс последнего выделенного места в списке.Обратите внимание,что последний блокнот может находиться в более раннем слоте.Любые записи,следующие за ним,в этом случае будут NULL.</target>
        </trans-unit>
        <trans-unit id="e58a7f8912fdbd8eaa97b22ef4d5d356a40471d5" translate="yes" xml:space="preserve">
          <source>The index of the last pad entry.</source>
          <target state="translated">Индекс последней записи колодки.</target>
        </trans-unit>
        <trans-unit id="9c1326f686e664ef67aae2567ac4696fd6d57b00" translate="yes" xml:space="preserve">
          <source>The index of the last pad name.</source>
          <target state="translated">Индекс фамилии блокнота.</target>
        </trans-unit>
        <trans-unit id="6e35b0206297becebb26c609423d65b1dfe24dd3" translate="yes" xml:space="preserve">
          <source>The indexing merely outputs messages via &lt;code&gt;.tm&lt;/code&gt; for each major page, section, subsection, item, and any &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; directives. See &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda2671ac9e05ad8e30450bd5f169c0ab42ddce2" translate="yes" xml:space="preserve">
          <source>The indexing merely outputs messages via &lt;code&gt;.tm&lt;/code&gt; for each major page, section, subsection, item, and any &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; directives. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for more details.</source>
          <target state="translated">Индексирование просто выводит сообщения через &lt;code&gt;.tm&lt;/code&gt; для каждой основной страницы, раздела, подраздела, элемента и любых директив &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; . См. &lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="c99d2cd33e1325afbec2e3f58c4236d44c82d895" translate="yes" xml:space="preserve">
          <source>The inferred anchor text is implemented per &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;:</source>
          <target state="translated">Предполагаемый текст привязки реализован в &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f2d5d2272835d0eeff1fcb72d6fc348f5deff4fa" translate="yes" xml:space="preserve">
          <source>The inferred anchor text is implemented per &lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfbacdda04f65b21a64f3fbe8dd597fa30ae2f5" translate="yes" xml:space="preserve">
          <source>The infinity and not-a-number have their own special arithmetic rules. The general rule is that they are &quot;contagious&quot;: &lt;code&gt;Inf&lt;/code&gt; plus one is &lt;code&gt;Inf&lt;/code&gt; , and &lt;code&gt;NaN&lt;/code&gt; plus one is &lt;code&gt;NaN&lt;/code&gt; . Where things get interesting is when you combine infinities and not-a-numbers: &lt;code&gt;Inf&lt;/code&gt; minus &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; divided by &lt;code&gt;INf&lt;/code&gt; are &lt;code&gt;NaN&lt;/code&gt; (while &lt;code&gt;Inf&lt;/code&gt; plus &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; times &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; ). &lt;code&gt;NaN&lt;/code&gt; is also curious in that it does not equal any number,</source>
          <target state="translated">У бесконечности и не-числа есть свои особые арифметические правила. Общее правило состоит в том, что они &amp;laquo;заразны&amp;raquo;: &lt;code&gt;Inf&lt;/code&gt; плюс один - это &lt;code&gt;Inf&lt;/code&gt; , а &lt;code&gt;NaN&lt;/code&gt; плюс один - это &lt;code&gt;NaN&lt;/code&gt; . Все становится интересно, когда вы комбинируете бесконечности и не-числа: &lt;code&gt;Inf&lt;/code&gt; минус &lt;code&gt;Inf&lt;/code&gt; и &lt;code&gt;Inf&lt;/code&gt; , разделенные на &lt;code&gt;INf&lt;/code&gt; , равны &lt;code&gt;NaN&lt;/code&gt; (в то время как &lt;code&gt;Inf&lt;/code&gt; плюс &lt;code&gt;Inf&lt;/code&gt; - это &lt;code&gt;Inf&lt;/code&gt; , а &lt;code&gt;Inf&lt;/code&gt; , умноженное на &lt;code&gt;Inf&lt;/code&gt; , равно &lt;code&gt;Inf&lt;/code&gt; ). &lt;code&gt;NaN&lt;/code&gt; также любопытно тем, что не равно никакому числу,</target>
        </trans-unit>
        <trans-unit id="b82803e1dc2591f87a6c585b7453fcb7c5b2d49b" translate="yes" xml:space="preserve">
          <source>The infinity and not-a-number have their own special arithmetic rules. The general rule is that they are &quot;contagious&quot;: &lt;code&gt;Inf&lt;/code&gt; plus one is &lt;code&gt;Inf&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; plus one is &lt;code&gt;NaN&lt;/code&gt;. Where things get interesting is when you combine infinities and not-a-numbers: &lt;code&gt;Inf&lt;/code&gt; minus &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; divided by &lt;code&gt;Inf&lt;/code&gt; are &lt;code&gt;NaN&lt;/code&gt; (while &lt;code&gt;Inf&lt;/code&gt; plus &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; times &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt;). &lt;code&gt;NaN&lt;/code&gt; is also curious in that it does not equal any number,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7be9da06f66cb02df4f43ae1ea9430b4a4ec21" translate="yes" xml:space="preserve">
          <source>The infinity as a constant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e5e47a18eb5768545b57a7c2da190e8c801676" translate="yes" xml:space="preserve">
          <source>The infinity is the result of certain math operations that overflow the floating point range, like 9**9**9. The not-a-number is the result when the result is undefined or unrepresentable. Though note that you cannot get &lt;code&gt;NaN&lt;/code&gt; from some common &quot;undefined&quot; or &quot;out-of-range&quot; operations like dividing by zero, or square root of a negative number, since Perl generates fatal errors for those.</source>
          <target state="translated">Бесконечность - это результат определенных математических операций, которые выходят за пределы диапазона с плавающей запятой, например 9 ** 9 ** 9. Не-число - это результат, когда результат не определен или непредставим. Однако обратите внимание, что вы не можете получить &lt;code&gt;NaN&lt;/code&gt; из некоторых обычных операций &amp;laquo;undefined&amp;raquo; или &amp;laquo;вне диапазона&amp;raquo;, таких как деление на ноль или квадратный корень из отрицательного числа, поскольку Perl генерирует для них фатальные ошибки.</target>
        </trans-unit>
        <trans-unit id="00c49c340cf01a0ad0057e1d1a4eb69e30e225ff" translate="yes" xml:space="preserve">
          <source>The information in</source>
          <target state="translated">Информация в</target>
        </trans-unit>
        <trans-unit id="477d4eda55a2d3f9993a8441da0761392c6f4bde" translate="yes" xml:space="preserve">
          <source>The init routine asks a few questions and writes a CPAN/Config.pm or CPAN/MyConfig.pm file (depending on what it is currently using).</source>
          <target state="translated">Программа init задает несколько вопросов и записывает файл CPAN/Config.pm или CPAN/MyConfig.pm (в зависимости от того,что она в данный момент использует).</target>
        </trans-unit>
        <trans-unit id="46a6f162dfe4fd1932efaab095f3ad6c7065353c" translate="yes" xml:space="preserve">
          <source>The initial Haiku port was done by Ingo Weinhold &amp;lt;ingo_weinhold@gmx.de&amp;gt;.</source>
          <target state="translated">Первоначальный перенос Haiku был сделан Инго Вайнхольдом &amp;lt;ingo_weinhold@gmx.de&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="98cc24e951f63d830750ae3c1189e0eb891874c8" translate="yes" xml:space="preserve">
          <source>The initial call must supply the root of the tree as both top and o.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30baee764016e0fd1d74fa20302dc7f15e17366e" translate="yes" xml:space="preserve">
          <source>The initial comment shows a contrived, even dangerous example. By overriding &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; globally, you would be forcing the new (and subversive) behavior for the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator for</source>
          <target state="translated">В первоначальном комментарии приводится надуманный, даже опасный пример. &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; переопределение глобуса приведет к новому (и подрывному) поведению оператора &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; для</target>
        </trans-unit>
        <trans-unit id="60355db9cd866fe1c7fe0bda38b193d6a4e848c8" translate="yes" xml:space="preserve">
          <source>The initial comment shows a contrived, even dangerous example. By overriding &lt;code&gt;glob&lt;/code&gt; globally, you would be forcing the new (and subversive) behavior for the &lt;code&gt;glob&lt;/code&gt; operator for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825ce23847c0393ed93e8d89640392b4a5b33a5c" translate="yes" xml:space="preserve">
          <source>The initial program is started up using the locale specified from the environment, as currently, described in &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt;. All newly created threads start with &lt;code&gt;LC_ALL&lt;/code&gt; set to &lt;code&gt;&quot;C&quot;&lt;/code&gt;&amp;gt;. Each thread may use &lt;code&gt;POSIX::setlocale()&lt;/code&gt; to query or switch its locale at any time, without affecting any other thread. All locale-dependent operations automatically use their thread's locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd35ba0a15f59402bf69541a0c2a672b5245bb7" translate="yes" xml:space="preserve">
          <source>The initializer for a class element is an object of the corresponding class, or of one of it's subclasses, or a reference to a hash containing named arguments to be passed to the element's constructor.</source>
          <target state="translated">Инициализатором элемента класса является объект соответствующего класса,или одного из его подклассов,или ссылка на хэш,содержащий именованные аргументы для передачи конструктору элемента.</target>
        </trans-unit>
        <trans-unit id="12094a548e09c78cbb33f308cc132c5c3175cfa2" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;curlen&lt;/code&gt; parameter was 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7270a1d75b517033df50fe18fd9734207c302454" translate="yes" xml:space="preserve">
          <source>The input character at &lt;code&gt;p&lt;/code&gt; is assumed to be well-formed.</source>
          <target state="translated">Предполагается, что входной символ в &lt;code&gt;p&lt;/code&gt; имеет правильный формат.</target>
        </trans-unit>
        <trans-unit id="5b4da48b1525c95aa66984d855f728baeff9dd23" translate="yes" xml:space="preserve">
          <source>The input data will be read from each file in turn.</source>
          <target state="translated">Входные данные будут поочередно считываться из каждого файла.</target>
        </trans-unit>
        <trans-unit id="6a300bdc55cb2694c445f5d77189a272f405a2c8" translate="yes" xml:space="preserve">
          <source>The input number must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">Входное число должно быть неотрицательным целым числом или строкой, начинающейся с &lt;code&gt;&quot;U+&quot;&lt;/code&gt; или &lt;code&gt;&quot;0x&quot;&lt;/code&gt; а остаток должен быть шестнадцатеричным целым числом. Литеральная числовая константа должна быть беззнаковой; он будет интерпретироваться как шестнадцатеричный, если в начале стоит ноль или содержит не десятичные шестнадцатеричные цифры; в противном случае он будет интерпретирован как десятичный. Если он начинается с &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , он интерпретируется как кодовая точка Unicode; в противном случае он интерпретируется как родной. (Только кодовые точки ниже 256 могут отличаться между Unicode и собственным кодом.) Таким образом, &lt;code&gt;U+41&lt;/code&gt; всегда является латинской буквой &amp;laquo;A&amp;raquo;; но &lt;code&gt;0x41&lt;/code&gt; может быть &quot; ПРОБЕЛОМ БЕЗ ПЕРЕРЫВА &quot; на платформах EBCDIC.</target>
        </trans-unit>
        <trans-unit id="3bfc355d9523e05f661ba51d39053e5f158eac0d" translate="yes" xml:space="preserve">
          <source>The input number must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt;, it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74af33c799ba9469f42a06ffc1422c08fe76ab11" translate="yes" xml:space="preserve">
          <source>The input parameter name is loosely matched, which means that white space, hyphens, and underscores are ignored (except for the trailing underscore in the old_form grandfathered-in &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; , and both of which mean &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; ).</source>
          <target state="translated">Имя входного параметра нечетко совпадает, что означает, что пробелы, дефисы и подчеркивания игнорируются (за исключением конечного подчеркивания в устаревшем &lt;code&gt;&quot;L_&quot;&lt;/code&gt; old_form , которое лучше записать как &lt;code&gt;&quot;LC&quot;&lt;/code&gt; , и оба из них означают &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="50a387d524817a7fe881c13a9828020ec107aa28" translate="yes" xml:space="preserve">
          <source>The input parameter name is loosely matched, which means that white space, hyphens, and underscores are ignored (except for the trailing underscore in the old_form grandfathered-in &lt;code&gt;&quot;L_&quot;&lt;/code&gt;, which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt;, and both of which mean &lt;code&gt;General_Category=Cased Letter&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e74e0d2d8b749838155344b24b616732216f51a" translate="yes" xml:space="preserve">
          <source>The input record separator - &lt;code&gt;$/&lt;/code&gt; in Perl space.</source>
          <target state="translated">Разделитель входной записи - &lt;code&gt;$/&lt;/code&gt; в пространстве Perl.</target>
        </trans-unit>
        <trans-unit id="7fa23e4762b9d73d4eaf4fe4ff40a6345a28b068" translate="yes" xml:space="preserve">
          <source>The input record separator, newline by default. This influences Perl's idea of what a &quot;line&quot; is. Works like &lt;b&gt;awk&lt;/b&gt;'s RS variable, including treating empty lines as a terminator if set to the null string (an empty line cannot contain any spaces or tabs). You may set it to a multi-character string to match a multi-character terminator, or to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to read through the end of file. Setting it to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; means something slightly different than setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; , if the file contains consecutive empty lines. Setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; will treat two or more consecutive empty lines as a single empty line. Setting to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; will blindly assume that the next input character belongs to the next paragraph, even if it's a newline.</source>
          <target state="translated">Разделитель входной записи, новая строка по умолчанию. Это влияет на представление Perl о том, что такое &amp;laquo;линия&amp;raquo;. Работает как переменная RS в &lt;b&gt;awk&lt;/b&gt; , в том числе обрабатывает пустые строки как терминатор, если установлена ​​пустая строка (пустая строка не может содержать пробелов или табуляции). Вы можете установить для него многосимвольную строку, чтобы соответствовать многосимвольному терминатору, или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , чтобы прочитать конец файла. Установка &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; означает несколько иное, чем установка &lt;code&gt;&quot;&quot;&lt;/code&gt; , если файл содержит последовательные пустые строки. Установка в &lt;code&gt;&quot;&quot;&lt;/code&gt; будет рассматривать две или более последовательных пустых строки как одну пустую строку. Установка на &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; слепо предположит, что следующий входной символ принадлежит следующему абзацу, даже если это перевод строки.</target>
        </trans-unit>
        <trans-unit id="e85a2d63aac48888c217e5fc29fb75b0836651b1" translate="yes" xml:space="preserve">
          <source>The input record separator, newline by default. This influences Perl's idea of what a &quot;line&quot; is. Works like &lt;b&gt;awk&lt;/b&gt;'s RS variable, including treating empty lines as a terminator if set to the null string (an empty line cannot contain any spaces or tabs). You may set it to a multi-character string to match a multi-character terminator, or to &lt;code&gt;undef&lt;/code&gt; to read through the end of file. Setting it to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; means something slightly different than setting to &lt;code&gt;&quot;&quot;&lt;/code&gt;, if the file contains consecutive empty lines. Setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; will treat two or more consecutive empty lines as a single empty line. Setting to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; will blindly assume that the next input character belongs to the next paragraph, even if it's a newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a207c3a9402edc134f0e1308be59f0ea92cbf62" translate="yes" xml:space="preserve">
          <source>The input sequence is not standard UTF-8, but a Perl extension. This bit is set only if the input &lt;code&gt;flags&lt;/code&gt; parameter contains either the &lt;code&gt;UTF8_DISALLOW_PERL_EXTENDED&lt;/code&gt; or the &lt;code&gt;UTF8_WARN_PERL_EXTENDED&lt;/code&gt; flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1ce589ec1298c83c9efa29e1da93e2c83adb1f" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that &lt;code&gt;curlen&lt;/code&gt; is smaller than required for a complete sequence. In other words, the input is for a partial character sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da71ee8003bfe3e8ec2c57918f6f663af8a1ae47" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that a non-continuation type byte was found in a position where only a continuation type one should be. See also &lt;a href=&quot;#UTF8_GOT_SHORT&quot;&gt;&quot;&lt;code&gt;UTF8_GOT_SHORT&lt;/code&gt;&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4e094d6ddae88fabdfbba8b8e5241b863d54f9" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that it is for a -Unicode UTF-16 surrogate code point. This bit is set only if the input &lt;code&gt;flags&lt;/code&gt; parameter contains either the &lt;code&gt;UTF8_DISALLOW_SURROGATE&lt;/code&gt; or the &lt;code&gt;UTF8_WARN_SURROGATE&lt;/code&gt; flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff44b5ee5ee25243c0818e9bac3059eeea96ab14" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that it is for a code point that is not representable in the number of bits available in an IV on the current platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903db38b58d5e3ef05b722cc2b0b61f1d172318a" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that it is for a non-Unicode code point; that is, one above the legal Unicode maximum. This bit is set only if the input &lt;code&gt;flags&lt;/code&gt; parameter contains either the &lt;code&gt;UTF8_DISALLOW_SUPER&lt;/code&gt; or the &lt;code&gt;UTF8_WARN_SUPER&lt;/code&gt; flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c430a74085221ab38d297957bbc930788c28aae9" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that the first byte was a UTF-8 continuation byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7003ec3d60fe29e1076b40608f946cd82019d546" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that there is some other sequence that evaluates to the same code point, but that sequence is shorter than this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e2a05c675d83b32cdc798d03f4bd19670bf464" translate="yes" xml:space="preserve">
          <source>The insertion of a scalar or list value somewhere in the middle of another value, such that it appears to have been there all along. In Perl, variable interpolation happens in double-quoted strings and patterns, and list interpolation occurs when constructing the list of values to pass to a list operator or other such construct that takes a</source>
          <target state="translated">Вставка скаляра или значения списка где-то посередине другого значения,так,чтобы казалось,что оно все время находилось там.В Perl интерполяция переменных происходит в строках и шаблонах в двойных кавычках,а интерполяция списков происходит при построении списка значений для передачи в оператор list или другую подобную конструкцию,которая принимает значение a</target>
        </trans-unit>
        <trans-unit id="4d21a2b8d717cbebbeaee5c37e1b249a9b6f4299" translate="yes" xml:space="preserve">
          <source>The inspiration for the stop codon DNA example came from the ZIP code example in chapter 7 of</source>
          <target state="translated">Вдохновение для примера ДНК кодона стопа пришло из примера ZIP-кода в главе 7 из</target>
        </trans-unit>
        <trans-unit id="4a97f9d9b06cf863773b30ca4503b6a95be51b13" translate="yes" xml:space="preserve">
          <source>The installation paths that you set during the build get compiled into perl, so you don't have to do anything additional to start using that perl (except add its location to your PATH variable).</source>
          <target state="translated">Установочные пути,которые вы задали во время сборки,компилируются в perl,так что вам не нужно делать ничего дополнительного,чтобы начать использовать этот perl (кроме добавления его местоположения в переменную PATH).</target>
        </trans-unit>
        <trans-unit id="ed7ec50305347f54da6bfda8296e9515a40cfdd4" translate="yes" xml:space="preserve">
          <source>The installer is ancient and has a few bugs on the paths it uses. You will have to fix them later. Basically, some things go into &quot;C:/Program Files/Windows CE Tools&quot;, others go into &quot;C:/Windows CE Tools&quot; regardless of the path you gave to the installer (the default will be &quot;C:/Windows CE Tools&quot;). Reboots will be required for the installer to proceed. Also .c and .h associations with Visual Studio might get overridden when installing EVC4. You have been warned.</source>
          <target state="translated">Программа установки древняя и имеет несколько ошибок на используемых ею путях.Вам придется исправить их позже.В основном,некоторые вещи попадают в &quot;C:/Program Files/Windows CE Tools&quot;,другие-в &quot;C:/Windows CE Tools&quot;,независимо от того,какой путь вы указали программе установки (по умолчанию это будет &quot;C:/Windows CE Tools&quot;).Для продолжения работы программе установки потребуются перезагрузки.Также при установке EVC4 могут быть переопределены ассоциации .c и .h с Visual Studio.Вы были предупреждены.</target>
        </trans-unit>
        <trans-unit id="5b7ef7bcb453733f9ef12df7a7d461832dbe120b" translate="yes" xml:space="preserve">
          <source>The installman script will try to run on OS/390. There will be fewer errors if you have a roff utility installed. You can obtain GNU groff from the Redbook SG24-5944-00 ftp site.</source>
          <target state="translated">Скрипт installman будет пытаться работать под OS/390.Ошибок будет меньше,если у вас установлена утилита roff.Вы можете получить GNU groff с ftp-сайта Redbook SG24-5944-00.</target>
        </trans-unit>
        <trans-unit id="85593ec8ae8efa2e0dca43eb532734290d86abb5" translate="yes" xml:space="preserve">
          <source>The integer a computer uses to represent a given character. ASCII codepoints are in the range 0 to 127; Unicode codepoints are in the range 0 to 0x1F_FFFF; and Perl codepoints are in the range 0 to 2&amp;sup3;&amp;sup2;&amp;minus;1 or 0 to 2⁶⁴&amp;minus;1, depending on your native integer size. In Perl Culture, sometimes called &lt;b&gt;ordinals&lt;/b&gt;.</source>
          <target state="translated">Целое число, используемое компьютером для представления данного символа. Кодовые точки ASCII находятся в диапазоне от 0 до 127; Кодовые точки Unicode находятся в диапазоне от 0 до 0x1F_FFFF; а кодовые точки Perl находятся в диапазоне от 0 до 2&amp;sup3;&amp;sup2; &amp;minus; 1 или от 0 до 2⁶⁴ &amp;minus; 1, в зависимости от вашего собственного целочисленного размера. В Perl Culture иногда называют &lt;b&gt;порядковыми&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="fffacf90cdbd65b0d80477a60f2e9ed117d5e990" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; , and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="translated">Целочисленные форматы &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; и &lt;code&gt;J&lt;/code&gt; по своей природе непереносимы между процессорами и операционными системами, потому что они подчиняются собственному байтовому порядку и порядку байтов. Например, 4-байтовое целое число 0x12345678 (305419896 десятичное число) будет изначально упорядочено (упорядочено и обработано регистрами ЦП) в байты как</target>
        </trans-unit>
        <trans-unit id="c85dc9716f98ce9d26e0b8a1181441b82dd671db" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; , and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="translated">Целочисленные форматы &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; и &lt;code&gt;J&lt;/code&gt; по своей природе непереносимы между процессорами и операционными системами, потому что они подчиняются собственному байтовому порядку и порядку байтов. Например, 4-байтовое целое число 0x12345678 (305419896 десятичное число) будет изначально упорядочено (упорядочено и обработано регистрами ЦП) в байты как</target>
        </trans-unit>
        <trans-unit id="8d253eb6809a9562624388d35993ef60096f96e8" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;I&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1696e5627c4e618d6b57f471d56db53f3261ebc8" translate="yes" xml:space="preserve">
          <source>The integer four, not to be confused with six, Tom&amp;rsquo;s favorite editor. IV also means an internal Integer Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold, not to be confused with an &lt;b&gt;NV&lt;/b&gt;.</source>
          <target state="translated">Целое число четыре, не путать с шестью, любимый редактор Тома. IV также означает внутреннее целочисленное значение типа, который может содержать &lt;b&gt;скаляр&lt;/b&gt; , не путать с &lt;b&gt;NV&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="38f7f88bfbbfc7fbb6565adc2a9af0982c4ebbc9" translate="yes" xml:space="preserve">
          <source>The integer or name form of the &lt;code&gt;condition&lt;/code&gt; allows us to choose, with more flexibility, what to match based on what matched earlier in the regexp. This searches for words of the form &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; or &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt; :</source>
          <target state="translated">Целочисленная или именная форма &lt;code&gt;condition&lt;/code&gt; позволяет нам выбирать с большей гибкостью, что сопоставить, на основе того, что совпадало ранее в регулярном выражении. Это ищет слова вида &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; или &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fa48e81451f89adaf419b03b6f56f3e3cdc6501d" translate="yes" xml:space="preserve">
          <source>The integer or name form of the &lt;code&gt;condition&lt;/code&gt; allows us to choose, with more flexibility, what to match based on what matched earlier in the regexp. This searches for words of the form &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; or &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05de89837820906430d66857198677bee870304" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="translated">Целочисленные типы &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; и &lt;code&gt;L&lt;/code&gt; могут сопровождаться символом &lt;code&gt;!&lt;/code&gt; модификатор, чтобы указать родные короткие или длинные. Как показано в приведенном выше примере, пустой &lt;code&gt;l&lt;/code&gt; означает ровно 32 бита, хотя собственная &lt;code&gt;long&lt;/code&gt; видит локальный компилятор C, может быть больше. В основном это проблема на 64-битных платформах. Вы можете увидеть, используете ли вы &lt;code&gt;!&lt;/code&gt; имеет значение таким образом:</target>
        </trans-unit>
        <trans-unit id="e28530f74a983b5b7c88ba8ea81f426cbf7efd7c" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="translated">Целочисленные типы &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; и &lt;code&gt;L&lt;/code&gt; могут сопровождаться символом &lt;code&gt;!&lt;/code&gt; модификатор, чтобы указать родные короткие или длинные. Как показано в приведенном выше примере, пустой &lt;code&gt;l&lt;/code&gt; означает ровно 32 бита, хотя собственная &lt;code&gt;long&lt;/code&gt; видит локальный компилятор C, может быть больше. В основном это проблема на 64-битных платформах. Вы можете увидеть, используете ли вы &lt;code&gt;!&lt;/code&gt; имеет значение таким образом:</target>
        </trans-unit>
        <trans-unit id="b9395373d953b00358ac2a4a8b3d6e5305da7861" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5708b037f56278734976c0deaf7b452666b9a4" translate="yes" xml:space="preserve">
          <source>The intended purpose of this routine is to concatenate</source>
          <target state="translated">Целью этой рутины является конкатенация</target>
        </trans-unit>
        <trans-unit id="35499217c3dc076a80a3d7b854f65596514d0493" translate="yes" xml:space="preserve">
          <source>The intent is simplicity of use, not power of expression. Paragraphs look like paragraphs (block format), so that they stand out visually, and so that I could run them through &lt;code&gt;fmt&lt;/code&gt; easily to reformat them (that's F7 in my version of &lt;b&gt;vi&lt;/b&gt;, or Esc Q in my version of &lt;b&gt;emacs&lt;/b&gt;). I wanted the translator to always leave the &lt;code&gt;'&lt;/code&gt; and &lt;code&gt;`&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; quotes alone, in verbatim mode, so I could slurp in a working program, shift it over four spaces, and have it print out, er, verbatim. And presumably in a monospace font.</source>
          <target state="translated">Цель - простота использования, а не сила выражения. Абзацы выглядят как абзацы (блочный формат), поэтому они выделяются визуально и чтобы я мог легко пропустить их через &lt;code&gt;fmt&lt;/code&gt; , чтобы переформатировать их (это F7 в моей версии &lt;b&gt;vi&lt;/b&gt; или Esc Q в моей версии &lt;b&gt;emacs&lt;/b&gt; ). Я хотел , чтобы переводчик всегда оставить &lt;code&gt;'&lt;/code&gt; и &lt;code&gt;`&lt;/code&gt; и &lt;code&gt;&quot;&lt;/code&gt; цитаты в одиночку, в стенографических режиме, так что я мог хлебать в рабочей программе, переложить ее на четыре пространства, и он распечатать, гм, дословно. И предположительно в моноширинный шрифт.</target>
        </trans-unit>
        <trans-unit id="0fe331c074ca976ebd60519539ebf547e9a5979f" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt;, which can be set by any system call, this means that the value of the exit code used by &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ab1ae02bd72d53207c68855ddd39b0273ee3a8" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;code&gt;$!&lt;/code&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt; , which can be set by any system call, this means that the value of the exit code used by &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="translated">Цель состоит в том, чтобы втиснуть как можно больше информации о вероятной причине в ограниченное пространство кода выхода из системы. Однако как &lt;code&gt;$!&lt;/code&gt; - это значение &lt;code&gt;errno&lt;/code&gt; C , которое может быть установлено любым системным вызовом, это означает, что значение кода выхода, используемого &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , может быть непредсказуемым, поэтому на него не следует полагаться, кроме как ненулевое.</target>
        </trans-unit>
        <trans-unit id="0547c3f088cded7d6e36027ba3384ed9126a4a35" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;code&gt;$!&lt;/code&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt; , which can be set by any system call, this means that the value of the exit code used by &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="translated">Цель состоит в том, чтобы втиснуть как можно больше информации о вероятной причине в ограниченное пространство кода выхода из системы. Однако как &lt;code&gt;$!&lt;/code&gt; - это значение &lt;code&gt;errno&lt;/code&gt; C , которое может быть установлено любым системным вызовом, это означает, что значение кода выхода, используемого &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , может быть непредсказуемым, поэтому на него не следует полагаться, кроме как ненулевое.</target>
        </trans-unit>
        <trans-unit id="2e91002a8407b92abe1904ddf5c320e2e26254c0" translate="yes" xml:space="preserve">
          <source>The interaction with the Perl compilation happens inside package &lt;code&gt;myint&lt;/code&gt; :</source>
          <target state="translated">Взаимодействие с компиляцией Perl происходит внутри пакета &lt;code&gt;myint&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aadf28bb5828714b5bb46305e38581c5103da604" translate="yes" xml:space="preserve">
          <source>The interaction with the Perl compilation happens inside package &lt;code&gt;myint&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4116edd722cc9f90eb68f17a977fcbd1367d5c" translate="yes" xml:space="preserve">
          <source>The interactive debugger understands the following commands:</source>
          <target state="translated">Интерактивный отладчик понимает следующие команды:</target>
        </trans-unit>
        <trans-unit id="99a3cf2098e457c2b3c584e37ad9ed7869d1340e" translate="yes" xml:space="preserve">
          <source>The interested reader might have seen a number of flags that signify encodings or codesets - &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;latin1&lt;/code&gt; and &lt;code&gt;ascii&lt;/code&gt;. There seems to be some confusion on what these do, so here is a short comparison:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70d776f0381bce09991021b76dd2d122db7ce29" translate="yes" xml:space="preserve">
          <source>The interesting thing about &lt;code&gt;&amp;amp;&lt;/code&gt; is that you can generate new syntax with it, provided it's in the initial position:</source>
          <target state="translated">Интересно, что с помощью &lt;code&gt;&amp;amp;&lt;/code&gt; можно сгенерировать новый синтаксис, если он находится в исходной позиции:</target>
        </trans-unit>
        <trans-unit id="2354b426f3be078a3ef57dbce0f8523b4f89323f" translate="yes" xml:space="preserve">
          <source>The interface defined by this module is missing some of the later additions to perl's debugging functionality. As such, this interface should be considered highly experimental and subject to change.</source>
          <target state="translated">В интерфейсе,определенном этим модулем,отсутствуют некоторые из последующих дополнений к отладочной функциональности perl.Как таковой,этот интерфейс следует рассматривать как высокоэкспериментальный и подверженный изменениям.</target>
        </trans-unit>
        <trans-unit id="6bc76db195856b77ae9c9e32f58ddf5271ff9965" translate="yes" xml:space="preserve">
          <source>The interface exposed by this module is very close to the current implementation of restricted hashes. Over time it is expected that this behavior will be extended and the interface abstracted further.</source>
          <target state="translated">Интерфейс,предоставляемый этим модулем,очень близок к текущей реализации ограниченных хэшей.Со временем ожидается,что это поведение будет расширено и интерфейс будет абстрагироваться дальше.</target>
        </trans-unit>
        <trans-unit id="25ed6271fa2a1e00048e3f70c7ae05b81e869ba4" translate="yes" xml:space="preserve">
          <source>The interface is a bit odd because this is the result of a quick refactoring. Don't rely on it.</source>
          <target state="translated">Интерфейс немного странный,потому что это результат быстрого рефакторинга.Не полагайтесь на это.</target>
        </trans-unit>
        <trans-unit id="4f992c0404449ac096de07bc9c29b6b99091aebe" translate="yes" xml:space="preserve">
          <source>The interface provided by version 2 of this module should be 100% backward compatible with version 1. If you find a difference in the expected behaviour please contact the author (See &lt;a href=&quot;#AUTHOR&quot;&gt;&quot;AUTHOR&quot;&lt;/a&gt;). See &lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;&quot;GZIP INTERFACE&quot;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86fb605133e4937943b1ba063015c9eb55c6a1c4" translate="yes" xml:space="preserve">
          <source>The interface provided by version 2 of this module should be 100% backward compatible with version 1. If you find a difference in the expected behaviour please contact the author (See &lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt;). See &lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;GZIP INTERFACE&lt;/a&gt;</source>
          <target state="translated">Интерфейс, предоставляемый версией 2 этого модуля, должен быть на 100% обратно совместим с версией 1. Если вы обнаружите разницу в ожидаемом поведении, обратитесь к автору (см. &lt;a href=&quot;#AUTHOR&quot;&gt;АВТОР&lt;/a&gt; ). См. &lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;ИНТЕРФЕЙС GZIP&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="869b0eb21cd8ea8a7cd6e0d3a06abffd6a4f3e9a" translate="yes" xml:space="preserve">
          <source>The interface provides two ways to calculate digests: all-at-once, or in stages. To illustrate, the following short program computes the SHA-256 digest of &quot;hello world&quot; using each approach:</source>
          <target state="translated">Интерфейс предоставляет два способа расчета дайджестов:полностью или поэтапно.Для иллюстрации,следующая короткая программа рассчитывает дайджест SHA-256 &quot;hello world&quot;,используя каждый подход:</target>
        </trans-unit>
        <trans-unit id="fb22cb5dbe02d4f126e70eb38eba99f572c134f7" translate="yes" xml:space="preserve">
          <source>The interface to Exec in entirely encapsulated within the perl class, there is no need to access the low level methods directly and they are not exported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="506d079f3d8576c485b8b85a9995943fec82c8f8" translate="yes" xml:space="preserve">
          <source>The interface to the arexx.class in entirely encapsulated within the perl class, there is no need to access the low level methods directly and they are not exported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dedf705c01e5c3576fd3717e147541ecb372f63" translate="yes" xml:space="preserve">
          <source>The internal advisory locking is implemented using Perl's flock() routine. If your system does not support any form of flock(), or if you share your files across NFS, you might wish to use other forms of locking by using modules such as LockFile::Simple which lock a file using a filesystem entry, instead of locking the file descriptor.</source>
          <target state="translated">Внутренняя блокировка консультаций осуществляется с помощью функции flock()Perl.Если ваша система не поддерживает никакую форму flock(),или если вы совместно используете файлы через NFS,вы можете захотеть использовать другие формы блокировки,используя такие модули,как LockFile::Simple,которые блокируют файл,используя запись файловой системы,вместо блокировки дескриптора файла.</target>
        </trans-unit>
        <trans-unit id="b695712dbfa2556923ae8104354e307b6dd7d107" translate="yes" xml:space="preserve">
          <source>The internal structure of version objects is a blessed hash with several components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798a90f8fceb3237e533c15e8087d7887afcfeb7" translate="yes" xml:space="preserve">
          <source>The internal variable for debugging support. The meanings of the various bits are subject to change, but currently indicate:</source>
          <target state="translated">Внутренняя переменная для поддержки отладки.Значения различных битов могут меняться,но в настоящее время указывают:</target>
        </trans-unit>
        <trans-unit id="85c386c4c074fc2a85f669eb89082305e3dd4f12" translate="yes" xml:space="preserve">
          <source>The internals automatically clone any name with characters 128-255 but none 256+ (ie one that could be either in bytes or utf8) into a second entry which is utf8 encoded.</source>
          <target state="translated">Внутреннее устройство автоматически клонирует любое имя с символами 128-255,но не 256+(т.е.такое,которое может быть либо в байтах,либо в utf8)во вторую запись,которая закодирована в utf8.</target>
        </trans-unit>
        <trans-unit id="68038f581434d0080618601485190514733606bb" translate="yes" xml:space="preserve">
          <source>The interpretation of operations and values in Perl sometimes depends on the requirements of the context around the operation or value. There are two major contexts: list and scalar. Certain operations return list values in contexts wanting a list, and scalar values otherwise. If this is true of an operation it will be mentioned in the documentation for that operation. In other words, Perl overloads certain operations based on whether the expected return value is singular or plural. Some words in English work this way, like &quot;fish&quot; and &quot;sheep&quot;.</source>
          <target state="translated">Интерпретация операций и значений в Perl иногда зависит от требований контекста вокруг операции или значения.Существует два основных контекста:список и скаляр.Некоторые операции возвращают значения списков в контекстах,где требуется список,и скалярные значения в противном случае.Если это так в отношении операции,то это будет упомянуто в документации к данной операции.Другими словами,Perl перегружает определенные операции в зависимости от того,является ли ожидаемое возвращаемое значение единственным или множественным.Некоторые слова на английском языке работают таким образом,например,&quot;рыба&quot; и &quot;овца&quot;.</target>
        </trans-unit>
        <trans-unit id="061664239d0f872c4965463ddd59f598a09d06f0" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="translated">Интерпретация операторов прав доступа к файлам &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; по умолчанию основана исключительно на режиме файла, uid и gid пользователя. Могут быть и другие причины, по которым вы не можете прочитать, записать или выполнить файл: например, элементы управления доступом к сетевой файловой системе, ACL (списки управления доступом), файловые системы только для чтения и нераспознанные исполняемые форматы. Обратите внимание, что использование этих шести конкретных операторов для проверки возможности выполнения той или иной операции обычно является ошибкой, поскольку может привести к возникновению условий гонки.</target>
        </trans-unit>
        <trans-unit id="de2595dbfaf95d22e9019632865663f297c76092" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="translated">Интерпретация операторов прав доступа к файлам &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; по умолчанию основана исключительно на режиме файла, uid и gid пользователя. Могут быть и другие причины, по которым вы не можете прочитать, записать или выполнить файл: например, элементы управления доступом к сетевой файловой системе, ACL (списки управления доступом), файловые системы только для чтения и нераспознанные исполняемые форматы. Обратите внимание, что использование этих шести конкретных операторов для проверки возможности выполнения той или иной операции обычно является ошибкой, поскольку может привести к возникновению условий гонки.</target>
        </trans-unit>
        <trans-unit id="488736b34ccb462579468e7b97e0ddad7de84d1d" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;, &lt;code&gt;-x&lt;/code&gt;, and &lt;code&gt;-X&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e2e01e4adc3fb9225914fc17730078576e41c6" translate="yes" xml:space="preserve">
          <source>The inverse function to &lt;code&gt;pairs&lt;/code&gt;; this function takes a list of &lt;code&gt;ARRAY&lt;/code&gt; references containing two elements each, and returns a flattened list of the two values from each of the pairs, in order. This is notionally equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54a39a0dd2a9db45fcc8606c6b9dc540f8d071d" translate="yes" xml:space="preserve">
          <source>The inverse operation - packing byte contents from a string of hexadecimal digits - is just as easily written. For instance:</source>
          <target state="translated">Обратная операция-упаковка содержимого байта из строки шестнадцатеричных цифр-так же легко пишется.Например:</target>
        </trans-unit>
        <trans-unit id="8aacdda2a613fe684f7ff0ec49be15c7f7bad342" translate="yes" xml:space="preserve">
          <source>The is the number of bytes that the Storable header occupies.</source>
          <target state="translated">Это количество байт,которое занимает заголовок Storable.</target>
        </trans-unit>
        <trans-unit id="e08f7fe6dcc4a4ede748bb6d3fcab7c9e89b331c" translate="yes" xml:space="preserve">
          <source>The issue of whether to pass the arguments in a hash or a hashref is largely a matter of personal style.</source>
          <target state="translated">Вопрос о том,передавать ли аргументы в гашише или в хэше,во многом зависит от личного стиля.</target>
        </trans-unit>
        <trans-unit id="1270f1d87441c40c65f184813fb9549f6a05140e" translate="yes" xml:space="preserve">
          <source>The item you want to look up. Nested modules (such as &lt;code&gt;File::Basename&lt;/code&gt; ) are specified either as &lt;code&gt;File::Basename&lt;/code&gt; or &lt;code&gt;File/Basename&lt;/code&gt; . You may also give a descriptive name of a page, such as &lt;code&gt;perlfunc&lt;/code&gt; . For URLs, HTTP and HTTPS are the only kind currently supported.</source>
          <target state="translated">Элемент, который вы хотите найти. Вложенные модули (такие как &lt;code&gt;File::Basename&lt;/code&gt; ) указываются либо как &lt;code&gt;File::Basename&lt;/code&gt; либо как &lt;code&gt;File/Basename&lt;/code&gt; . Вы также можете дать описательное имя страницы, например &lt;code&gt;perlfunc&lt;/code&gt; . Для URL-адресов в настоящее время поддерживаются только HTTP и HTTPS.</target>
        </trans-unit>
        <trans-unit id="4344e301a9e97fdf3fc9733e6ebe72949a9af633" translate="yes" xml:space="preserve">
          <source>The item you want to look up. Nested modules (such as &lt;code&gt;File::Basename&lt;/code&gt;) are specified either as &lt;code&gt;File::Basename&lt;/code&gt; or &lt;code&gt;File/Basename&lt;/code&gt;. You may also give a descriptive name of a page, such as &lt;code&gt;perlfunc&lt;/code&gt;. For URLs, HTTP and HTTPS are the only kind currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fbe0de2b65f06cfcea380e50cf6bef09ae06281" translate="yes" xml:space="preserve">
          <source>The iterator used by &lt;code&gt;each&lt;/code&gt; is attached to the hash or array, and is shared between all iteration operations applied to the same hash or array. Thus all uses of &lt;code&gt;each&lt;/code&gt; on a single hash or array advance the same iterator location. All uses of &lt;code&gt;each&lt;/code&gt; are also subject to having the iterator reset by any use of &lt;code&gt;keys&lt;/code&gt; or &lt;code&gt;values&lt;/code&gt; on the same hash or array, or by the hash (but not array) being referenced in list context. This makes &lt;code&gt;each&lt;/code&gt;-based loops quite fragile: it is easy to arrive at such a loop with the iterator already part way through the object, or to accidentally clobber the iterator state during execution of the loop body. It's easy enough to explicitly reset the iterator before starting a loop, but there is no way to insulate the iterator state used by a loop from the iterator state used by anything else that might execute during the loop body. To avoid these problems, use a &lt;code&gt;foreach&lt;/code&gt; loop rather than &lt;code&gt;while&lt;/code&gt;-&lt;code&gt;each&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b950b023ee8eee0b58c44c704206373f4189c22c" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;&quot;~~&quot;&lt;/code&gt; allows you to override the smart matching logic used by the &lt;code&gt;~~&lt;/code&gt; operator and the switch construct (&lt;code&gt;given&lt;/code&gt; /&lt;code&gt;when&lt;/code&gt; ). See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; and &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">Клавиша &lt;code&gt;&quot;~~&quot;&lt;/code&gt; позволяет вам переопределить логику интеллектуального сопоставления, используемую оператором &lt;code&gt;~~&lt;/code&gt; и конструкцией переключателя ( &lt;code&gt;given&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; ). См. &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Операторы переключения в perlsyn&lt;/a&gt; и &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a2c34ae8224e419d58656178fbc2e7d6c0054d2" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;&quot;~~&quot;&lt;/code&gt; allows you to override the smart matching logic used by the &lt;code&gt;~~&lt;/code&gt; operator and the switch construct (&lt;code&gt;given&lt;/code&gt;/&lt;code&gt;when&lt;/code&gt;). See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt; and &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c40c6befa9e830eefbf95715d61be0cceba411db" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;'-X'&lt;/code&gt; is used to specify a subroutine to handle all the filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on: see &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt; for the full list); it is not possible to overload any filetest operator individually. To distinguish them, the letter following the '-' is passed as the second argument (that is, in the slot that for binary operators is used to pass the second operand).</source>
          <target state="translated">Ключ &lt;code&gt;'-X'&lt;/code&gt; используется для указания подпрограммы для обработки всех операторов проверки файлов ( &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; и т. Д .: См. &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt; для полного списка); невозможно перегрузить любой оператор filetest по отдельности. Чтобы различать их, буква, следующая за &amp;laquo;-&amp;raquo;, передается в качестве второго аргумента (то есть в слоте, который используется для двоичных операторов для передачи второго операнда).</target>
        </trans-unit>
        <trans-unit id="d619e5f63abc98b8cfd8901f2a523fddccb94536" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;'-X'&lt;/code&gt; is used to specify a subroutine to handle all the filetest operators (&lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-x&lt;/code&gt;, and so on: see &lt;a href=&quot;perlfunc#-X&quot;&gt;&quot;-X&quot; in perlfunc&lt;/a&gt; for the full list); it is not possible to overload any filetest operator individually. To distinguish them, the letter following the '-' is passed as the second argument (that is, in the slot that for binary operators is used to pass the second operand).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e57e8aa67b22950a3905dc0aca0c46d976bdaa4" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;key&lt;/code&gt; of &lt;code&gt;hv&lt;/code&gt; is deleted at the end of</source>
          <target state="translated">Ключ &lt;code&gt;key&lt;/code&gt; из &lt;code&gt;hv&lt;/code&gt; удаляется в конце</target>
        </trans-unit>
        <trans-unit id="39231120b3a0f9f7321946d1dcf4e67b7cbb06d0" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;neg&lt;/code&gt; is used for unary minus to disambiguate it from binary &lt;code&gt;-&lt;/code&gt; .</source>
          <target state="translated">Ключ &lt;code&gt;neg&lt;/code&gt; используется для унарного минуса, чтобы отличить его от двоичного &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8014230ab511707fdf318f6f60f165829ac3a885" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;neg&lt;/code&gt; is used for unary minus to disambiguate it from binary &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af0ef3d95080a656a5a0ae273ae380c9667ee38" translate="yes" xml:space="preserve">
          <source>The key function is</source>
          <target state="translated">Ключевая функция заключается в том,чтобы</target>
        </trans-unit>
        <trans-unit id="890e53c79df507f41db3dd4d31cb915a4367afdd" translate="yes" xml:space="preserve">
          <source>The key here is the &lt;code&gt;nss_delete&lt;/code&gt; call. One workaround for this bug seems to be to create add to the file</source>
          <target state="translated">Ключевым моментом здесь является вызов &lt;code&gt;nss_delete&lt;/code&gt; . Одним из способов обхода этой ошибки, похоже, является создание добавления в файл</target>
        </trans-unit>
        <trans-unit id="f07d5f582b98b9cdfa2323f91d8c44e6ee01e73a" translate="yes" xml:space="preserve">
          <source>The key is specified by</source>
          <target state="translated">Ключ определяется</target>
        </trans-unit>
        <trans-unit id="dbf499b463a1d246f5657c7bd10575193916c7a6" translate="yes" xml:space="preserve">
          <source>The key is specified by &lt;code&gt;keypv&lt;/code&gt; and &lt;code&gt;keylen&lt;/code&gt;. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;COPHH_KEY_UTF8&lt;/code&gt; bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. &lt;code&gt;hash&lt;/code&gt; is a precomputed hash of the key string, or zero if it has not been precomputed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4574cc32e125230b635f70eb51279af8024135" translate="yes" xml:space="preserve">
          <source>The keys allowed in each of these pre-defined references is limited to the names used in the equivalent C structure. So, for example, the $DB_HASH reference will only allow keys called &lt;code&gt;bsize&lt;/code&gt; , &lt;code&gt;cachesize&lt;/code&gt; , &lt;code&gt;ffactor&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;lorder&lt;/code&gt; and &lt;code&gt;nelem&lt;/code&gt; .</source>
          <target state="translated">Ключи, разрешенные в каждой из этих предопределенных ссылок, ограничены именами, используемыми в эквивалентной структуре C. Так, например, ссылка $ DB_HASH будет разрешать только ключи с &lt;code&gt;bsize&lt;/code&gt; , &lt;code&gt;cachesize&lt;/code&gt; , &lt;code&gt;ffactor&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;lorder&lt;/code&gt; и &lt;code&gt;nelem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2b4b1e7a4b07bed8f5dd49d279e3a199199b7a2" translate="yes" xml:space="preserve">
          <source>The keys allowed in each of these pre-defined references is limited to the names used in the equivalent C structure. So, for example, the $DB_HASH reference will only allow keys called &lt;code&gt;bsize&lt;/code&gt;, &lt;code&gt;cachesize&lt;/code&gt;, &lt;code&gt;ffactor&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;lorder&lt;/code&gt; and &lt;code&gt;nelem&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ed2e67811ac5de5639075023acf0cc2ec381bf" translate="yes" xml:space="preserve">
          <source>The keys in the bottom layer hash with the meanings of their values are:</source>
          <target state="translated">Ключи в хэше нижнего слоя со значениями их значений:</target>
        </trans-unit>
        <trans-unit id="7d244bc64e243794d6821e1a0dcab4a24a9f05ad" translate="yes" xml:space="preserve">
          <source>The keys in the hash with the meanings of their values are:</source>
          <target state="translated">Ключи в хэше со значениями их значений:</target>
        </trans-unit>
        <trans-unit id="b936421bf8217d2a23b78502c20a19e381f28f92" translate="yes" xml:space="preserve">
          <source>The keys of &lt;code&gt;%-&lt;/code&gt; -like hashes correspond to all buffer names found in the regular expression; the keys of &lt;code&gt;%+&lt;/code&gt; -like hashes list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="translated">Ключи &lt;code&gt;%-&lt;/code&gt; -подобных хэшей соответствуют всем именам буферов в регулярном выражении; ключи &lt;code&gt;%+&lt;/code&gt; -подобных хэшей перечисляют только имена захваченных буферов (и, таким образом, связанных с определенными значениями).</target>
        </trans-unit>
        <trans-unit id="997d8f5f7d84196f7ef0d41e7b97b099b732ef37" translate="yes" xml:space="preserve">
          <source>The keys of &lt;code&gt;%-&lt;/code&gt;-like hashes correspond to all buffer names found in the regular expression; the keys of &lt;code&gt;%+&lt;/code&gt;-like hashes list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780fac85dedcdee4447dcad5c8a8d6b15a9a2af1" translate="yes" xml:space="preserve">
          <source>The keys of &lt;code&gt;provides&lt;/code&gt; are package names that can be found within the distribution. If a package name key is provided, it must have a Map with the following valid subkeys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108fc2066c755818e3590f4d9c35e36d3cb855db" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;%+&lt;/code&gt; hash list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="translated">Ключи хэша &lt;code&gt;%+&lt;/code&gt; перечисляют только имена захваченных буферов (и, таким образом, связанных с определенными значениями).</target>
        </trans-unit>
        <trans-unit id="c4094ef8d037d1a4f33eb2e2deddaec00fa1265e" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;%-&lt;/code&gt; hash correspond to all buffer names found in the regular expression.</source>
          <target state="translated">Ключи хэша &lt;code&gt;%-&lt;/code&gt; соответствуют всем именам буферов в регулярном выражении.</target>
        </trans-unit>
        <trans-unit id="cfdae1829d96426970bd25497a8e45b42e9a79f4" translate="yes" xml:space="preserve">
          <source>The keys of the hash will be the names of the entries in the directory. Reading a value from the hash will be the result of calling &lt;code&gt;File::stat::lstat&lt;/code&gt; . Deleting an element from the hash will delete the corresponding file or subdirectory, provided that &lt;code&gt;DIR_UNLINK&lt;/code&gt; is included in the &lt;code&gt;OPTIONS&lt;/code&gt; .</source>
          <target state="translated">Ключи хэша будут названиями записей в каталоге. Чтение значения из хеша будет результатом вызова &lt;code&gt;File::stat::lstat&lt;/code&gt; . Удаление элемента из хэша приведет к удалению соответствующего файла или подкаталога при условии, что &lt;code&gt;DIR_UNLINK&lt;/code&gt; включен в &lt;code&gt;OPTIONS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7764c6575d016ad4721493c64443d8e32ddb0474" translate="yes" xml:space="preserve">
          <source>The keys of the hash will be the names of the entries in the directory. Reading a value from the hash will be the result of calling &lt;code&gt;File::stat::lstat&lt;/code&gt;. Deleting an element from the hash will delete the corresponding file or subdirectory, provided that &lt;code&gt;DIR_UNLINK&lt;/code&gt; is included in the &lt;code&gt;OPTIONS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055987f11411d4374756daa33a787f39e5c8e2e5" translate="yes" xml:space="preserve">
          <source>The keys of this hash are the names of all the known subroutines. Each value is an encoded string that has the sprintf(3) format &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt; .</source>
          <target state="translated">Ключи этого хэша - это имена всех известных подпрограмм. Каждое значение представляет собой закодированную строку в формате sprintf (3) &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99eed0ed09082d94a43f5eb252bf07930e49246a" translate="yes" xml:space="preserve">
          <source>The keys of this hash are the names of all the known subroutines. Each value is an encoded string that has the sprintf(3) format &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3904530800da7eda131d2f33bddbe47a09140ae0" translate="yes" xml:space="preserve">
          <source>The kind of computer you&amp;rsquo;re working on, where one &amp;ldquo;kind of computer&amp;rdquo; means all those computers sharing a compatible machine language. Since Perl programs are (typically) simple text files, not executable images, a Perl program is much less sensitive to the architecture it&amp;rsquo;s running on than programs in other languages, such as C, that are &lt;b&gt;compiled&lt;/b&gt; into machine code. See also &lt;b&gt;platform&lt;/b&gt; and &lt;b&gt;operating system&lt;/b&gt;.</source>
          <target state="translated">Тип компьютера, на котором вы работаете, где один &amp;laquo;вид компьютера&amp;raquo; означает все эти компьютеры, использующие совместимый машинный язык. Поскольку программы Perl (как правило) представляют собой простые текстовые файлы, а не исполняемые изображения, программа Perl гораздо менее чувствительна к архитектуре, на которой она работает, чем программы на других языках, таких как C, которые &lt;b&gt;компилируются&lt;/b&gt; в машинный код. См. Также &lt;b&gt;платформу&lt;/b&gt; и &lt;b&gt;операционную систему&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="af5d08a24c9445659f44e97ac90d397b8dd843c2" translate="yes" xml:space="preserve">
          <source>The known import symbols are the &lt;code&gt;:gzip_external&lt;/code&gt; , &lt;code&gt;:gzip_read_open&lt;/code&gt; , and &lt;code&gt;:gzip_write_open&lt;/code&gt; . Anything else is not recognized.</source>
          <target state="translated">Известные импортные символы являются &lt;code&gt;:gzip_external&lt;/code&gt; , &lt;code&gt;:gzip_read_open&lt;/code&gt; и &lt;code&gt;:gzip_write_open&lt;/code&gt; . Ничего другого не распознается.</target>
        </trans-unit>
        <trans-unit id="f60d39e599c1ed70fbcd2d9685b7a2c305ef74b7" translate="yes" xml:space="preserve">
          <source>The known import symbols are the &lt;code&gt;:gzip_external&lt;/code&gt;, &lt;code&gt;:gzip_read_open&lt;/code&gt;, and &lt;code&gt;:gzip_write_open&lt;/code&gt;. Anything else is not recognized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad665994ad3405e05efc579c556de49d4423595" translate="yes" xml:space="preserve">
          <source>The label of the statement or block the OP is the start of, if any.</source>
          <target state="translated">Метка утверждения или блокировка ОП является началом,если таковое имеется.</target>
        </trans-unit>
        <trans-unit id="147bc8ea909cecad4fb730859bb2907f9623910d" translate="yes" xml:space="preserve">
          <source>The lack of processing of &lt;code&gt;\\&lt;/code&gt; creates specific restrictions on the post-processed text. If the delimiter is &lt;code&gt;/&lt;/code&gt;, one cannot get the combination &lt;code&gt;\/&lt;/code&gt; into the result of this step. &lt;code&gt;/&lt;/code&gt; will finish the regular expression, &lt;code&gt;\/&lt;/code&gt; will be stripped to &lt;code&gt;/&lt;/code&gt; on the previous step, and &lt;code&gt;\\/&lt;/code&gt; will be left as is. Because &lt;code&gt;/&lt;/code&gt; is equivalent to &lt;code&gt;\/&lt;/code&gt; inside a regular expression, this does not matter unless the delimiter happens to be character special to the RE engine, such as in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s*foo*bar*&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m[foo]&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;?foo?&lt;/code&gt; ; or an alphanumeric char, as in:</source>
          <target state="translated">Отсутствие обработки &lt;code&gt;\\&lt;/code&gt; создает определенные ограничения на постобработанный текст. Если разделителем является &lt;code&gt;/&lt;/code&gt; , нельзя получить комбинацию &lt;code&gt;\/&lt;/code&gt; в результате этого шага. &lt;code&gt;/&lt;/code&gt; завершит регулярное выражение, &lt;code&gt;\/&lt;/code&gt; будет разделено на &lt;code&gt;/&lt;/code&gt; на предыдущем шаге, а &lt;code&gt;\\/&lt;/code&gt; останется как есть. Поскольку &lt;code&gt;/&lt;/code&gt; эквивалентен &lt;code&gt;\/&lt;/code&gt; внутри регулярного выражения, это не имеет значения, если только разделитель не является специальным символом для механизма RE, например в &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s*foo*bar*&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m[foo]&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;?foo?&lt;/code&gt; ; или буквенно-цифровой символ, например:</target>
        </trans-unit>
        <trans-unit id="552da7166581dad2c401fcf7fae959ad601a8345" translate="yes" xml:space="preserve">
          <source>The lack of processing of &lt;code&gt;\\&lt;/code&gt; creates specific restrictions on the post-processed text. If the delimiter is &lt;code&gt;/&lt;/code&gt;, one cannot get the combination &lt;code&gt;\/&lt;/code&gt; into the result of this step. &lt;code&gt;/&lt;/code&gt; will finish the regular expression, &lt;code&gt;\/&lt;/code&gt; will be stripped to &lt;code&gt;/&lt;/code&gt; on the previous step, and &lt;code&gt;\\/&lt;/code&gt; will be left as is. Because &lt;code&gt;/&lt;/code&gt; is equivalent to &lt;code&gt;\/&lt;/code&gt; inside a regular expression, this does not matter unless the delimiter happens to be character special to the RE engine, such as in &lt;code&gt;s*foo*bar*&lt;/code&gt;, &lt;code&gt;m[foo]&lt;/code&gt;, or &lt;code&gt;m?foo?&lt;/code&gt;; or an alphanumeric char, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc7f7d746e559a86f68b3adb7a4d97f4b51af95" translate="yes" xml:space="preserve">
          <source>The langinfo() function is just a wrapper for the C nl_langinfo() interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11a57a26c23b0ae665c99897a59d6791986dbc2" translate="yes" xml:space="preserve">
          <source>The langinfo() function queries various locale information that can be used to localize output and user interfaces. It uses the current underlying locale, regardless of whether or not it was called from within the scope of &lt;code&gt;use locale&lt;/code&gt;. The langinfo() function requires one numeric argument that identifies the locale constant to query: if no argument is supplied, &lt;code&gt;$_&lt;/code&gt; is used. The numeric constants appropriate to be used as arguments are exportable from I18N::Langinfo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329bfa336d3d2c69ff7cf1363d051c82b14482d1" translate="yes" xml:space="preserve">
          <source>The langinfo() function queries various locale information that can be used to localize output and user interfaces. The langinfo() requires one numeric argument that identifies the locale constant to query: if no argument is supplied, &lt;code&gt;$_&lt;/code&gt; is used. The numeric constants appropriate to be used as arguments are exportable from I18N::Langinfo.</source>
          <target state="translated">Функция langinfo () запрашивает различную информацию о локали, которую можно использовать для локализации вывода и пользовательских интерфейсов. Langinfo () требует одного числового аргумента, который идентифицирует константу локали для запроса: если аргумент не указан, используется &lt;code&gt;$_&lt;/code&gt; . Числовые константы, подходящие для использования в качестве аргументов, можно экспортировать из I18N :: Langinfo.</target>
        </trans-unit>
        <trans-unit id="4ed86afb0e8b9f19c52713fc505ca8e2e35f2532" translate="yes" xml:space="preserve">
          <source>The langinfo() is just a wrapper for the C nl_langinfo() interface.</source>
          <target state="translated">langinfo()-это просто обёртка для интерфейса C nl_langinfo().</target>
        </trans-unit>
        <trans-unit id="5d6f822e607c368c541adb8e9be9fa017016c7dd" translate="yes" xml:space="preserve">
          <source>The language is intended to be practical (easy to use, efficient, complete) rather than beautiful (tiny, elegant, minimal). It combines (in the author's opinion, anyway) some of the best features of &lt;b&gt;sed&lt;/b&gt;, &lt;b&gt;awk&lt;/b&gt;, and &lt;b&gt;sh&lt;/b&gt;, making it familiar and easy to use for Unix users to whip up quick solutions to annoying problems. Its general-purpose programming facilities support procedural, functional, and object-oriented programming paradigms, making Perl a comfortable language for the long haul on major projects, whatever your bent.</source>
          <target state="translated">Язык задуман скорее как практичный (простой в использовании, эффективный, полный), чем красивый (крошечный, элегантный, минималистичный). Он сочетает в себе (во всяком случае, по мнению автора) некоторые из лучших функций &lt;b&gt;sed&lt;/b&gt; , &lt;b&gt;awk&lt;/b&gt; и &lt;b&gt;sh&lt;/b&gt; , что делает его знакомым и простым в использовании для пользователей Unix, чтобы быстро находить решения досадных проблем. Его универсальные средства программирования поддерживают парадигмы процедурного, функционального и объектно-ориентированного программирования, что делает Perl удобным языком для длительной работы с крупными проектами, независимо от ваших предпочтений.</target>
        </trans-unit>
        <trans-unit id="80a9351ce80597f624479310f1723e625f630d11" translate="yes" xml:space="preserve">
          <source>The language is intended to be practical (easy to use, efficient, complete) rather than beautiful (tiny, elegant, minimal). Its major features are that it's easy to use, supports both procedural and object-oriented (OO) programming, has powerful built-in support for text processing, and has one of the world's most impressive collections of third-party modules.</source>
          <target state="translated">Язык призван быть практичным (простым в использовании,эффективным,полным),а не красивым (крошечным,элегантным,минималистичным).Основными его особенностями являются простота использования,поддержка как процедурного,так и объектно-ориентированного (OO)программирования,мощная встроенная поддержка обработки текста,а также одна из самых впечатляющих коллекций модулей сторонних разработчиков.</target>
        </trans-unit>
        <trans-unit id="80efcc67009b4f458fbcd0e166207fe80337c34a" translate="yes" xml:space="preserve">
          <source>The language used is chosen from the loc_lang call. If a lookup is not possible, the i-default language will be used. If the lookup is not in the i-default language, then the key will be returned.</source>
          <target state="translated">Используемый язык выбирается из вызова loc_lang.Если поиск невозможен,будет использоваться язык i-default.Если поиск не на языке i-default,то будет возвращен ключ.</target>
        </trans-unit>
        <trans-unit id="fba6e11da7ba55d0215680ecc246683e4db3e510" translate="yes" xml:space="preserve">
          <source>The large file compilation environment is obtained with</source>
          <target state="translated">Среда компиляции больших файлов получается с помощью</target>
        </trans-unit>
        <trans-unit id="9d7ccfee30c3456085edda4007d3ffab9032209b" translate="yes" xml:space="preserve">
          <source>The largest acceptable code point is the Unicode maximum 0x10FFFF, and must not be a surrogate nor a non-character code point. Thus this excludes any code point from Perl's extended UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0842cd9650e7d459b2b787beb02fa153564ea6" translate="yes" xml:space="preserve">
          <source>The largest acceptable code point is the Unicode maximum 0x10FFFF. This differs from &lt;code&gt;&lt;a href=&quot;#isSTRICT_UTF8_CHAR&quot;&gt;&quot;isSTRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; only in that it accepts non-character code points. This corresponds to &lt;a href=&quot;http://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode Corrigendum #9&lt;/a&gt;. which said that non-character code points are merely discouraged rather than completely forbidden in open interchange. See &lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;&quot;Noncharacter code points&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c14ad6f7057f3647ab0ef224e2d72569a519808" translate="yes" xml:space="preserve">
          <source>The largest code point that is representable in UTF-EBCDIC is U+7FFF_FFFF. If you do &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; on a larger value, a runtime error (similar to division by 0) will happen.</source>
          <target state="translated">Самая большая кодовая точка, которая может быть представлена ​​в UTF-EBCDIC, - это U + 7FFF_FFFF. Если вы выполните &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; для большего значения, произойдет ошибка времени выполнения (аналогичная делению на 0).</target>
        </trans-unit>
        <trans-unit id="81c48ef57866e1c8154c2bdc64ad152dcbc81938" translate="yes" xml:space="preserve">
          <source>The largest code point that is representable in UTF-EBCDIC is U+7FFF_FFFF. If you try to pack a larger value into a character, a runtime error (similar to division by 0) will happen.</source>
          <target state="translated">Самой большой точкой кода,представляемой в UTF-EBCDIC,является U+7FFF_FFFF.Если попытаться упаковать большее значение в символ,то произойдет ошибка во время выполнения (аналогично делению на 0).</target>
        </trans-unit>
        <trans-unit id="e2cfb7719205bc05d873fbbc8977b16754d06f9e" translate="yes" xml:space="preserve">
          <source>The last &lt;b&gt;filehandle&lt;/b&gt; that was designated with &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select(FILEHANDLE)&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;STDOUT&lt;/code&gt; , if no filehandle has been selected.</source>
          <target state="translated">Последний &lt;b&gt;дескриптор файла,&lt;/b&gt; который был назначен с помощью &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select(FILEHANDLE)&lt;/a&gt;&lt;/code&gt; ; &lt;code&gt;STDOUT&lt;/code&gt; , если дескриптор файла не выбран.</target>
        </trans-unit>
        <trans-unit id="3778b44d76009b0ef5e1852751bc0831ec54a4e5" translate="yes" xml:space="preserve">
          <source>The last &lt;b&gt;filehandle&lt;/b&gt; that was designated with &lt;code&gt;select(FILEHANDLE)&lt;/code&gt;; &lt;code&gt;STDOUT&lt;/code&gt;, if no filehandle has been selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37441ece1fc3c98a0c6e1bb548dacae86d8fdd9" translate="yes" xml:space="preserve">
          <source>The last and final version of PA-RISC is 2.0, HP no longer sells any system with these CPU's.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544feb1340389177d3430ba94574fe7a8a59484b" translate="yes" xml:space="preserve">
          <source>The last argument is always considered to be the file portion. Since &lt;code&gt;catfile()&lt;/code&gt; uses &lt;code&gt;catdir()&lt;/code&gt; (see above) for the concatenation of the directory portions (if any), the following with regard to relative and absolute paths is true:</source>
          <target state="translated">Последний аргумент всегда считается файловой частью. Поскольку &lt;code&gt;catfile()&lt;/code&gt; использует &lt;code&gt;catdir()&lt;/code&gt; (см. Выше) для конкатенации частей каталога (если таковые имеются), справедливо следующее относительно относительных и абсолютных путей:</target>
        </trans-unit>
        <trans-unit id="3d5ec4d10744144f22c4f4ea812b28436c8dedd9" translate="yes" xml:space="preserve">
          <source>The last example illustrates another feature of threads. You can spawn off several threads using the same subroutine. Each thread executes the same subroutine, but in a separate thread with a separate environment and potentially separate arguments.</source>
          <target state="translated">Последний пример иллюстрирует еще одну особенность потоков.Вы можете порождать несколько потоков,используя одну и ту же подпрограмму.Каждый поток выполняет одну и ту же подпрограмму,но в отдельном потоке с отдельной средой и потенциально отдельными аргументами.</target>
        </trans-unit>
        <trans-unit id="3a9ec3805e1d8d03ada9f35c7b038f53ba566eb8" translate="yes" xml:space="preserve">
          <source>The last example is very slow and outputs extra progress indicators that break the alignment of the result.</source>
          <target state="translated">Последний пример очень медленный и выводит дополнительные индикаторы прогресса,которые нарушают выравнивание результата.</target>
        </trans-unit>
        <trans-unit id="d7140144abdabb3a340f6e7a9626f45a3f6e90a9" translate="yes" xml:space="preserve">
          <source>The last example points out that character classes are like alternations of characters. At a given character position, the first alternative that allows the regexp match to succeed will be the one that matches.</source>
          <target state="translated">Последний пример указывает на то,что классы символов похожи на чередование символов.При заданной позиции символов,первая альтернатива,позволяющая регрессное совпадение,будет той,которая совпадает.</target>
        </trans-unit>
        <trans-unit id="8ff092050a74224fa6cfcc69192829226bfd39ef" translate="yes" xml:space="preserve">
          <source>The last example should print:</source>
          <target state="translated">Последний пример должен быть напечатан:</target>
        </trans-unit>
        <trans-unit id="d1b1f35817845b0ebf71ac4a0203b5b76bf2839d" translate="yes" xml:space="preserve">
          <source>The last example shows a match with an &lt;code&gt;'i'&lt;/code&gt;&lt;b&gt;modifier&lt;/b&gt;, which makes the match case-insensitive.</source>
          <target state="translated">В последнем примере показано совпадение с &lt;b&gt;модификатором &lt;/b&gt; &lt;code&gt;'i'&lt;/code&gt; , что делает совпадение нечувствительным к регистру.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e71d02e5faff1a1d5185411ef0df70f32d8f6d20" translate="yes" xml:space="preserve">
          <source>The last example shows that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regex and replacement are treated as single-quoted strings.</source>
          <target state="translated">Последний пример показывает, что &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; может использовать другие разделители, например &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt; , и даже &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt; . Если используются одинарные кавычки &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; , то регулярное выражение и замена обрабатываются как строки в одинарных кавычках.</target>
        </trans-unit>
        <trans-unit id="1c93c3433d587d711bbae225f518d07bf79a7bfc" translate="yes" xml:space="preserve">
          <source>The last example shows that &lt;code&gt;s///&lt;/code&gt; can use other delimiters, such as &lt;code&gt;s!!!&lt;/code&gt; and &lt;code&gt;s{}{}&lt;/code&gt;, and even &lt;code&gt;s{}//&lt;/code&gt;. If single quotes are used &lt;code&gt;s'''&lt;/code&gt;, then the regex and replacement are treated as single-quoted strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="301cab1c29ad0c90c0fe8b5c51d14a74f03d135a" translate="yes" xml:space="preserve">
          <source>The last form sets the error returned by future calls to &lt;code&gt;fileLastError()&lt;/code&gt; and should not be used often. &lt;code&gt;$uError&lt;/code&gt; must be a numeric error code. Also returns the dual-valued version of &lt;code&gt;$uError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38175234fbd8da1fcb9cc33577b554c9cf1a8cdf" translate="yes" xml:space="preserve">
          <source>The last four modifiers listed above, added in Perl 5.14, control the character set rules, but &lt;code&gt;/a&lt;/code&gt; is the only one you are likely to want to specify explicitly; the other three are selected automatically by various pragmas.</source>
          <target state="translated">Последние четыре модификатора, перечисленные выше, добавленные в Perl 5.14, управляют правилами набора символов, но &lt;code&gt;/a&lt;/code&gt; - единственный модификатор, который вы, вероятно, захотите указать явно; остальные три выбираются автоматически различными прагмами.</target>
        </trans-unit>
        <trans-unit id="5b14495e6536f39321b81d2ad45a9b35a4c183b7" translate="yes" xml:space="preserve">
          <source>The last is particularly useful because it knows about machine-dependent architectures. The &lt;code&gt;lib.pm&lt;/code&gt; pragmatic module was first included with the 5.002 release of Perl.</source>
          <target state="translated">Последний особенно полезен, поскольку знает о машинно-зависимых архитектурах. &lt;code&gt;lib.pm&lt;/code&gt; прагматичный модуль был впервые включен с выпуском Perl 5002.</target>
        </trans-unit>
        <trans-unit id="dee33a8bbee7fed8c390da45a40b2881511f80ec" translate="yes" xml:space="preserve">
          <source>The last item listed (SUNWhea in this example) is the package you need.</source>
          <target state="translated">Последний пункт в списке (SUNWhea в данном примере)-это пакет,который вам нужен.</target>
        </trans-unit>
        <trans-unit id="249e46d8e31e329b6f35d0380e06e9e88206bbb4" translate="yes" xml:space="preserve">
          <source>The last order date for HP 9000 systems was December 31, 2008.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f01afddbe80c4c268f0bac95652fd735743f86" translate="yes" xml:space="preserve">
          <source>The last rites performed by a parent &lt;b&gt;process&lt;/b&gt; on behalf of a deceased child process so that it doesn&amp;rsquo;t remain a &lt;b&gt;zombie&lt;/b&gt;. See the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; function calls.</source>
          <target state="translated">Последние обряды, выполняемые родительским &lt;b&gt;процессом&lt;/b&gt; от имени умершего дочернего процесса, чтобы он не оставался &lt;b&gt;зомби&lt;/b&gt; . Смотрите вызовы функций &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57c0ac80818903e3f90bc72e811a2effb575b793" translate="yes" xml:space="preserve">
          <source>The last rites performed by a parent &lt;b&gt;process&lt;/b&gt; on behalf of a deceased child process so that it doesn&amp;rsquo;t remain a &lt;b&gt;zombie&lt;/b&gt;. See the &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;waitpid&lt;/code&gt; function calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc5a9dc56cbe77d2375a5e43361dd33676d7edc" translate="yes" xml:space="preserve">
          <source>The last three slots are a recent addition, and for source code compatibility they are only checked for if one of the three flags MGf_COPY, MGf_DUP or MGf_LOCAL is set in mg_flags. This means that most code can continue declaring a vtable as a 5-element value. These three are currently used exclusively by the threading code, and are highly subject to change.</source>
          <target state="translated">Последние три слота являются недавним дополнением,и на совместимость с исходным кодом они проверяются только в том случае,если в mg_flags установлен один из трех флагов MGf,MGf_DUP или MGf_LOCAL.Это означает,что большинство кода может продолжать объявлять vtable как 5-элементное значение.В настоящее время эти три элемента используются исключительно в потоковом коде и могут быть изменены.</target>
        </trans-unit>
        <trans-unit id="0f2130944a7df2b125d5d6b5739b2f67242c3907" translate="yes" xml:space="preserve">
          <source>The last time the test program passed, in seconds from the epoch.</source>
          <target state="translated">Последний раз тестовая программа проходила в секундах от эпохи.</target>
        </trans-unit>
        <trans-unit id="21878c9b3f2934bab56f2ab1ab4a5f355bfffef3" translate="yes" xml:space="preserve">
          <source>The last time the test suite failed, in seconds from the epoch.</source>
          <target state="translated">Последний раз тестовый набор провалился,в секундах от эпохи.</target>
        </trans-unit>
        <trans-unit id="c8d2323b355b183370e8260c625d724458199602" translate="yes" xml:space="preserve">
          <source>The last topic of Part 1 briefly covers how regexps are used in Perl programs. Where do they fit into Perl syntax?</source>
          <target state="translated">Последняя тема первой части кратко рассказывает о том,как используются регеxps в программах на Perl.Как они вписываются в синтаксис Perl?</target>
        </trans-unit>
        <trans-unit id="b9c1bf499a546862f7d3dd462a65d36e8e01021a" translate="yes" xml:space="preserve">
          <source>The last two are a little tricky. In &lt;code&gt;[\$x]&lt;/code&gt; , the backslash protects the dollar sign, so the character class has two members &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; . In &lt;code&gt;[\\$x]&lt;/code&gt; , the backslash is protected, so &lt;code&gt;$x&lt;/code&gt; is treated as a variable and substituted in double quote fashion.</source>
          <target state="translated">Последние два немного сложны. В &lt;code&gt;[\$x]&lt;/code&gt; обратная косая черта защищает знак доллара, поэтому класс символов имеет два члена &lt;code&gt;$&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; . В &lt;code&gt;[\\$x]&lt;/code&gt; обратная косая черта защищена, поэтому &lt;code&gt;$x&lt;/code&gt; рассматривается как переменная и заменяется двойными кавычками.</target>
        </trans-unit>
        <trans-unit id="8da4297e9e11b0bed733e96e0a5ce5a0d837c05e" translate="yes" xml:space="preserve">
          <source>The last two are a little tricky. In &lt;code&gt;[\$x]&lt;/code&gt;, the backslash protects the dollar sign, so the character class has two members &lt;code&gt;'$'&lt;/code&gt; and &lt;code&gt;'x'&lt;/code&gt;. In &lt;code&gt;[\\$x]&lt;/code&gt;, the backslash is protected, so &lt;code&gt;$x&lt;/code&gt; is treated as a variable and substituted in double quote fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a00c9f7ecacbf4d6fa87dfc5eecfd61397b17fd" translate="yes" xml:space="preserve">
          <source>The last two constructs may appear unintuitive to most people. The first repeatedly grows a string, whereas the second allocates a large chunk of memory in one go. On some systems, the second is more efficient than the first.</source>
          <target state="translated">Последние две конструкции могут показаться большинству людей неинтуитивно понятными.Первая несколько раз увеличивает строку,в то время как вторая выделяет большой объем памяти за один раз.На некоторых системах вторая более эффективна,чем первая.</target>
        </trans-unit>
        <trans-unit id="701c321a0a2054ebe884423f3ddbe3fca4e7d084" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. (If your platform has a real &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt;, such as Linux and macOS, you can use the list form; it also works on Windows with Perl 5.22 or later.) You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3180c758450e8b48f9775fac7e74a8e6da633b" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. A good rule of thumb is that if your platform has a real &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (in other words, if your platform is Unix, including Linux and MacOS X), you can use the list form. You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="translated">Последние два примера в каждом блоке показывают канал как &amp;laquo;форму списка&amp;raquo;, которая еще не поддерживается на всех платформах. Хорошее практическое правило состоит в том, что если на вашей платформе есть настоящая &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (другими словами, если ваша платформа - Unix, включая Linux и MacOS X), вы можете использовать форму списка. Вы хотели бы использовать форму списка канала, чтобы вы могли передавать команде буквальные аргументы без риска интерпретации оболочкой любых метасимволов оболочки в них. Однако это также запрещает вам открывать каналы для команд, которые намеренно содержат метасимволы оболочки, например:</target>
        </trans-unit>
        <trans-unit id="224277da0631dd2948d98eac0e58b508ae236071" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. A good rule of thumb is that if your platform has a real &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (in other words, if your platform is Unix, including Linux and MacOS X), you can use the list form. You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="translated">Последние два примера в каждом блоке показывают канал как &amp;laquo;форму списка&amp;raquo;, которая еще не поддерживается на всех платформах. Хорошее практическое правило состоит в том, что если на вашей платформе есть настоящая &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (другими словами, если ваша платформа - Unix, включая Linux и MacOS X), вы можете использовать форму списка. Вы хотели бы использовать форму списка канала, чтобы вы могли передавать команде буквальные аргументы без риска интерпретации оболочкой любых метасимволов оболочки в них. Однако это также запрещает вам открывать каналы для команд, которые намеренно содержат метасимволы оболочки, например:</target>
        </trans-unit>
        <trans-unit id="bb538ba5316dfdb33cebda21455c3214d556eb70" translate="yes" xml:space="preserve">
          <source>The last two were added in Perl 5.22.</source>
          <target state="translated">Последние два были добавлены на Perl 5.22.</target>
        </trans-unit>
        <trans-unit id="631d7a78fc9992a33bb8f42345d827210e402509" translate="yes" xml:space="preserve">
          <source>The last type of L structure is for links to/within Pod documents. It is the most complex because it can have a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea40dd6a00c5982372bccbdaaeeb63948e0cf1b4" translate="yes" xml:space="preserve">
          <source>The later gives you some idea of what failed. It also makes it easier to find the test in your script, simply search for &quot;simple exponential&quot;.</source>
          <target state="translated">Последнее дает тебе некоторое представление о том,что провалилось.Это также облегчает поиск теста в вашем скрипте,просто ищите &quot;простой экспоненциальный&quot;.</target>
        </trans-unit>
        <trans-unit id="263e6dbf8c2da6cc4831ea57d73cd01c49808e34" translate="yes" xml:space="preserve">
          <source>The latest</source>
          <target state="translated">Последний</target>
        </trans-unit>
        <trans-unit id="d3a60275112428b3ca0987c2c55a45bca5bde073" translate="yes" xml:space="preserve">
          <source>The latest Net::Ping release can be found at CPAN:</source>
          <target state="translated">Последний релиз Net::Ping можно найти в CPAN:</target>
        </trans-unit>
        <trans-unit id="7b2e54c1e5a52bb047587bf92489f8f96027d992" translate="yes" xml:space="preserve">
          <source>The latest Net::Ping releases are included in cperl and perl5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874b36774125604150e5f59fd5253e7e8be8da9e" translate="yes" xml:space="preserve">
          <source>The latest Perl release (5.22.0 as of this writing) builds without changes under all versions of Mac OS X from 10.3 &quot;Panther&quot; onwards.</source>
          <target state="translated">Последний релиз Perl (5.22.0 на момент написания статьи)собирается без изменений под всеми версиями Mac OS X,начиная с 10.3 &quot;Panther&quot;.</target>
        </trans-unit>
        <trans-unit id="064e946234db5ecc10d952d435ad39de892add96" translate="yes" xml:space="preserve">
          <source>The latest Perl release (5.32.0 as of this writing) builds without changes under all versions of Mac OS X from 10.3 &quot;Panther&quot; onwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfa4e030032052fa74752414fc7476dcdaf2c76" translate="yes" xml:space="preserve">
          <source>The latest libnet release is always on CPAN, you will find it in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc4f25838809cd7645317e2cc9e7753babbc628" translate="yes" xml:space="preserve">
          <source>The latest source tree is available via cvs:</source>
          <target state="translated">Новейшее дерево исходных текстов доступно через cvs:</target>
        </trans-unit>
        <trans-unit id="3373e831da21b443a04c03079b0c28bf4785000a" translate="yes" xml:space="preserve">
          <source>The latest source tree is available via git:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf89850a166f6a4ee0978de00ea5e89c74558d84" translate="yes" xml:space="preserve">
          <source>The latest versions are probably the least deployed and widely tested, so you may want to wait a few months after their release and see what problems others have if you are risk averse.</source>
          <target state="translated">Последние версии,вероятно,наименее развернуты и широко протестированы,так что вы можете подождать несколько месяцев после их выпуска и посмотреть,какие проблемы есть у других,если вы не хотите рисковать.</target>
        </trans-unit>
        <trans-unit id="283b07d7f4b68277645e0b52df897e2c505c20d3" translate="yes" xml:space="preserve">
          <source>The latest versions of perl have more bug fixes.</source>
          <target state="translated">В последних версиях perl исправлено больше ошибок.</target>
        </trans-unit>
        <trans-unit id="5c3562f1019a54d151d180b0074eac428ec1b539" translate="yes" xml:space="preserve">
          <source>The latest versions of perl may contain performance improvements and features not present in older versions. There have been many changes in perl since perl5 was first introduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1651bfa501667c3bfa8d542631578218de1ab189" translate="yes" xml:space="preserve">
          <source>The latter is equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d373e425dea350cf42b44329f2372765cae74bb5" translate="yes" xml:space="preserve">
          <source>The latter pattern would be a character class consisting of a colon, and the letters &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt; .</source>
          <target state="translated">Последний шаблон будет классом символов, состоящим из двоеточия и букв &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; и &lt;code&gt;h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9695d45b272c946f52b02905e21523ca5bea55db" translate="yes" xml:space="preserve">
          <source>The latter pattern would be a character class consisting of a colon, and the letters &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e4aff4d2758e888da3bc5afffc2587abdc395f" translate="yes" xml:space="preserve">
          <source>The lax criteria corresponds to what is currently allowed by the version parser. All of the following formats are acceptable for dotted-decimal formats strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a94f6519fd2ea2b5da884bb4c80f8058226b090" translate="yes" xml:space="preserve">
          <source>The layer is acceptable to have in a binmode(FH) stack - i.e. it does not (or will configure itself not to) transform bytes passing through it.</source>
          <target state="translated">Слой допускается иметь в стеке binmode(FH)-т.е.он не будет (или не настроит себя)преобразовывать проходящие через него байты.</target>
        </trans-unit>
        <trans-unit id="1281105f1d2923419cef70eff9c7bbaca9c31ca4" translate="yes" xml:space="preserve">
          <source>The layer is buffered.</source>
          <target state="translated">Слой буферизован.</target>
        </trans-unit>
        <trans-unit id="aa6e981b462c3b07834414b5da8720376a618be1" translate="yes" xml:space="preserve">
          <source>The layers are returned in the order an open() or binmode() call would use them, and without colons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2977795d28c25d6eee9e0faa6c0a67b12612914" translate="yes" xml:space="preserve">
          <source>The layers are returned in the order an open() or binmode() call would use them. Note that the &quot;default stack&quot; depends on the operating system and on the Perl version, and both the compile-time and runtime configurations of Perl.</source>
          <target state="translated">Слои возвращаются в порядке,в котором их будет использовать вызов open()или binmode().Обратите внимание,что &quot;стек по умолчанию&quot; зависит от операционной системы и от версии Perl,а также от конфигурации времени компиляции и времени выполнения Perl.</target>
        </trans-unit>
        <trans-unit id="b3e7d5b78b27ea298f2a1cae1408ae86359ba800" translate="yes" xml:space="preserve">
          <source>The lddlflags addition is the only abnormal bit.</source>
          <target state="translated">Добавление lddlags-единственный ненормальный бит.</target>
        </trans-unit>
        <trans-unit id="7eced80f21a0420b25c8520fadd19d07b97b6f61" translate="yes" xml:space="preserve">
          <source>The leading 'v' is optional if two or more decimals appear. If only a single decimal is included, then the leading 'v' is required to trigger the dotted-decimal parsing. A leading zero is permitted, though not recommended except when quoted, because of the risk that Perl will treat the number as octal. A trailing underscore plus one or more digits denotes an alpha or development release (and must be quoted to be parsed properly).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff5a5e9eacb7b6806eb625ddd8923ff29d2efc5" translate="yes" xml:space="preserve">
          <source>The leading &lt;code&gt;+{&lt;/code&gt; and &lt;code&gt;{;&lt;/code&gt; always serve to disambiguate the expression to mean either the HASH reference, or the BLOCK.</source>
          <target state="translated">Ведущие &lt;code&gt;+{&lt;/code&gt; и &lt;code&gt;{;&lt;/code&gt; всегда служат для устранения неоднозначности выражения, означающего либо ссылку на HASH, либо BLOCK.</target>
        </trans-unit>
        <trans-unit id="d4369969cfc835357a0f9f590f26252ba7f58c0e" translate="yes" xml:space="preserve">
          <source>The left hand side of the method invocation (or arrow) operator is the object (or class name), and the right hand side is the method name.</source>
          <target state="translated">Левая сторона оператора вызова метода (или стрелки)-это объект (или имя класса),а правая сторона-это имя метода.</target>
        </trans-unit>
        <trans-unit id="2a9cac37843dad5a4ff70fbd9f8ea25d75266dcb" translate="yes" xml:space="preserve">
          <source>The left side of the arrow can be any expression returning a reference, including a previous dereference. Note that &lt;code&gt;$array[$x]&lt;/code&gt; is</source>
          <target state="translated">Левая сторона стрелки может быть любым выражением, возвращающим ссылку, включая предыдущее разыменование. Обратите внимание, что &lt;code&gt;$array[$x]&lt;/code&gt; - это</target>
        </trans-unit>
        <trans-unit id="eb221cc92a9038eecac3c016886c94b3bdd80217" translate="yes" xml:space="preserve">
          <source>The left-hand character up there indicates the context in which the function was called, with &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; meaning scalar or list contexts respectively, and &lt;code&gt;.&lt;/code&gt; meaning void context (which is actually a sort of scalar context). The display above says that you were in the function &lt;code&gt;main::infested&lt;/code&gt; when you ran the stack dump, and that it was called in scalar context from line 10 of the file</source>
          <target state="translated">Левый символ вверху указывает контекст, в котором была вызвана функция, где &lt;code&gt;$&lt;/code&gt; и &lt;code&gt;@&lt;/code&gt; означают скалярный контекст или контекст списка соответственно, и &lt;code&gt;.&lt;/code&gt; что означает пустой контекст (который на самом деле является своего рода скалярным контекстом). На приведенном выше дисплее показано, что вы были в функции &lt;code&gt;main::infested&lt;/code&gt; когда запускали дамп стека, и что она была вызвана в скалярном контексте из строки 10 файла.</target>
        </trans-unit>
        <trans-unit id="d8cc674eda9906f58ae8371f8d5de07f046d9b51" translate="yes" xml:space="preserve">
          <source>The leftmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;lt;&quot;).</source>
          <target state="translated">Крайний левый разделитель, начинающий текст аргумента с внутренней последовательностью (должен быть &quot;&amp;lt;&quot;).</target>
        </trans-unit>
        <trans-unit id="fbadd9b1973b1ad2d4e5362cd034946bff294cd7" translate="yes" xml:space="preserve">
          <source>The length [in bytes] of the section to be formatted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f9e2e6c56a351b6a88108f75341c9d329b9f6c" translate="yes" xml:space="preserve">
          <source>The length at which the argument list is truncated is governed by the next option:</source>
          <target state="translated">Длина,на которой усекается список аргументов,регулируется следующим вариантом:</target>
        </trans-unit>
        <trans-unit id="0c237bc1e8c7da08e4bc9cf58175d51b2735fd6c" translate="yes" xml:space="preserve">
          <source>The length of an array is a scalar value. You may find the length of array @days by evaluating &lt;code&gt;$#days&lt;/code&gt; , as in &lt;b&gt;csh&lt;/b&gt;. However, this isn't the length of the array; it's the subscript of the last element, which is a different value since there is ordinarily a 0th element. Assigning to &lt;code&gt;$#days&lt;/code&gt; actually changes the length of the array. Shortening an array this way destroys intervening values. Lengthening an array that was previously shortened does not recover values that were in those elements.</source>
          <target state="translated">Длина массива - это скалярное значение. Вы можете узнать длину массива @days, оценив &lt;code&gt;$#days&lt;/code&gt; , как в &lt;b&gt;csh&lt;/b&gt; . Однако это не длина массива; это нижний индекс последнего элемента, который представляет собой другое значение, поскольку обычно есть 0-й элемент. Назначение &lt;code&gt;$#days&lt;/code&gt; фактически изменяет длину массива. Укорачивание массива таким образом уничтожает промежуточные значения. Увеличение длины ранее сокращенного массива не восстанавливает значения, которые были в этих элементах.</target>
        </trans-unit>
        <trans-unit id="f563a4457c7ea4c783229c274409e5e0accbf6ff" translate="yes" xml:space="preserve">
          <source>The length of an array is a scalar value. You may find the length of array @days by evaluating &lt;code&gt;$#days&lt;/code&gt;, as in &lt;b&gt;csh&lt;/b&gt;. However, this isn't the length of the array; it's the subscript of the last element, which is a different value since there is ordinarily a 0th element. Assigning to &lt;code&gt;$#days&lt;/code&gt; actually changes the length of the array. Shortening an array this way destroys intervening values. Lengthening an array that was previously shortened does not recover values that were in those elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4741e016ab3bf497ce5ef4aff13131c47a360d63" translate="yes" xml:space="preserve">
          <source>The length of the field is supplied by padding out the field with multiple &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, or &quot;|&quot; characters to specify a non-numeric field with, respectively, left justification, right justification, or centering. For a regular field, the value (up to the first newline) is taken and printed according to the selected justification, truncating excess characters. If you terminate a text field with &quot;...&quot;, three dots will be shown if the value is truncated. A special text field may be used to do rudimentary multi-line text block filling; see &lt;a href=&quot;#Using-Fill-Mode&quot;&gt;&quot;Using Fill Mode&quot;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ef5c234e3b75bc352e3b032ce59b9fa1929612" translate="yes" xml:space="preserve">
          <source>The length of the field is supplied by padding out the field with multiple &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, or &quot;|&quot; characters to specify a non-numeric field with, respectively, left justification, right justification, or centering. For a regular field, the value (up to the first newline) is taken and printed according to the selected justification, truncating excess characters. If you terminate a text field with &quot;...&quot;, three dots will be shown if the value is truncated. A special text field may be used to do rudimentary multi-line text block filling; see &lt;a href=&quot;#Using-Fill-Mode&quot;&gt;Using Fill Mode&lt;/a&gt; for details.</source>
          <target state="translated">Длина поля определяется заполнением поля несколькими знаками &amp;laquo;&amp;lt;&amp;raquo;, &amp;laquo;&amp;gt;&amp;raquo; или &amp;laquo;|&amp;raquo; для указания нечислового поля с выравниванием по левому краю, по правому краю или центрированием соответственно. Для обычного поля значение (до первой новой строки) берется и печатается в соответствии с выбранным выравниванием, усекая лишние символы. Если вы завершите текстовое поле знаком &amp;laquo;...&amp;raquo;, то при усечении значения будут отображаться три точки. Специальное текстовое поле может использоваться для рудиментарного заполнения многострочного текстового блока; подробнее см. &lt;a href=&quot;#Using-Fill-Mode&quot;&gt;Использование режима заливки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="531fdf3344d9288341eaab36c6e742e75614f35e" translate="yes" xml:space="preserve">
          <source>The length of the filed in hex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b66a1a14f6dce4bff1a210ef4e586716a5899b" translate="yes" xml:space="preserve">
          <source>The length of the name.</source>
          <target state="translated">Длина имени.</target>
        </trans-unit>
        <trans-unit id="696a9e70beeee9b566eace1cd87208a1d5c5089e" translate="yes" xml:space="preserve">
          <source>The length(NAME) Keyword</source>
          <target state="translated">Длина (ФАМИЛИЯ)Ключевое слово</target>
        </trans-unit>
        <trans-unit id="b958bd03a02b517c3d184dfcfbefe403cc86c37f" translate="yes" xml:space="preserve">
          <source>The level can be changed as follows:</source>
          <target state="translated">Уровень можно изменить следующим образом:</target>
        </trans-unit>
        <trans-unit id="64e6e89b4814ce7405192ddfc665d5e521c03538" translate="yes" xml:space="preserve">
          <source>The level constants are not exported by the module.</source>
          <target state="translated">Константы уровня не экспортируются модулем.</target>
        </trans-unit>
        <trans-unit id="b4c1d901146534759d309f43fe1b8efda46ffa76" translate="yes" xml:space="preserve">
          <source>The level of detail in Perl module documentation generally goes from less detailed to more detailed. Your SYNOPSIS section should contain a minimal example of use (perhaps as little as one line of code; skip the unusual use cases or anything not needed by most users); the DESCRIPTION should describe your module in broad terms, generally in just a few paragraphs; more detail of the module's routines or methods, lengthy code examples, or other in-depth material should be given in subsequent sections.</source>
          <target state="translated">Уровень детализации документации по модулю Perl,как правило,переходит от менее детализированной к более детализированной.Ваш раздел SYNOPSIS должен содержать минимальный пример использования (возможно,всего одну строчку кода;пропустите необычные случаи использования или что-нибудь,что не нужно большинству пользователей);ОПИСАНИЕ должно описывать ваш модуль в общих чертах,обычно всего в нескольких параграфах;более подробные сведения о подпрограммах или методах модуля,длинные примеры кода или другие подробные материалы должны быть приведены в последующих разделах.</target>
        </trans-unit>
        <trans-unit id="0ce002d9483143d05cc2ba45ea1b81cd48bfc336" translate="yes" xml:space="preserve">
          <source>The lexer can be bypassed as well by creating the pattern from smaller components:</source>
          <target state="translated">Лексер можно обойти,создав деталь из более мелких деталей:</target>
        </trans-unit>
        <trans-unit id="dcb697055788c2e7dd63bc610ab1eb6ac51eb7cf" translate="yes" xml:space="preserve">
          <source>The lexer maintains various &lt;code&gt;char*&lt;/code&gt; pointers to things in the &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; buffer. If &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; is ever reallocated, all of these pointers must be updated. Don't attempt to do this manually, but rather use &lt;a href=&quot;#lex_grow_linestr&quot;&gt;&quot;lex_grow_linestr&quot;&lt;/a&gt; if you need to reallocate the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23265d5a0661d902031b21a8d3925278347efe2b" translate="yes" xml:space="preserve">
          <source>The lexer maintains various &lt;code&gt;char*&lt;/code&gt; pointers to things in the &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; buffer. If &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; is ever reallocated, all of these pointers must be updated. Don't attempt to do this manually, but rather use &lt;a href=&quot;#lex_grow_linestr&quot;&gt;lex_grow_linestr&lt;/a&gt; if you need to reallocate the buffer.</source>
          <target state="translated">Лексер поддерживает различные указатели &lt;code&gt;char*&lt;/code&gt; на объекты в &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; . Если &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; когда-либо перераспределяется, все эти указатели должны быть обновлены. Не пытайтесь сделать это вручную, лучше используйте &lt;a href=&quot;#lex_grow_linestr&quot;&gt;lex_grow_linestr,&lt;/a&gt; если вам нужно перераспределить буфер.</target>
        </trans-unit>
        <trans-unit id="1ed189d83743aeda186a080785030258aac3dd09" translate="yes" xml:space="preserve">
          <source>The libnetcfg utility can be used to configure the libnet. Starting from perl 5.8 libnet is part of the standard Perl distribution, but the libnetcfg can be used for any libnet installation.</source>
          <target state="translated">Утилита libnetcfg может быть использована для настройки libnet.Начиная с версии perl 5.8 libnet является частью стандартного дистрибутива Perl,но libnetcfg может использоваться для любой установки libnet.</target>
        </trans-unit>
        <trans-unit id="b7cb7266f690af0bb383573e50d303e552d377e1" translate="yes" xml:space="preserve">
          <source>The libraries specified may be a mixture of static libraries and import libraries (to link with DLLs). Since both kinds are used pretty transparently on the Win32 platform, we do not attempt to distinguish between them.</source>
          <target state="translated">Указанные библиотеки могут быть смесью статических библиотек и библиотек импорта (для линковки с DLL).Так как оба вида используются довольно прозрачно на платформе Win32,мы не пытаемся отличить их друг от друга.</target>
        </trans-unit>
        <trans-unit id="df259280ce53fd256ff55110ddf21cb58f64ee0c" translate="yes" xml:space="preserve">
          <source>The library that is loaded last is used. Note that this can be overwritten at any time by loading a different library, and numbers constructed with different libraries cannot be used in math operations together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99e76c717b720c6c49420484756d2dfcd410c40" translate="yes" xml:space="preserve">
          <source>The library that is loaded last will be used. Note that this can be overwritten at any time by loading a different library, and numbers constructed with different libraries cannot be used in math operations together.</source>
          <target state="translated">Будет использоваться последняя загруженная библиотека.Обратите внимание,что это может быть перезаписано в любой момент путем загрузки другой библиотеки,и числа,построенные с помощью разных библиотек,не могут быть использованы в математических операциях вместе.</target>
        </trans-unit>
        <trans-unit id="f52597109e4fab2376043609905f67d9e1da90d1" translate="yes" xml:space="preserve">
          <source>The license under which this distribution may be used and redistributed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be37c25dc5d34ce7bba6cfdf56923967183a419" translate="yes" xml:space="preserve">
          <source>The licensing terms of your distribution. Generally it's &quot;perl_5&quot; for the same license as Perl itself.</source>
          <target state="translated">Лицензионные условия вашей дистрибуции.Как правило,это &quot;perl_5&quot; для той же лицензии,что и сам Perl.</target>
        </trans-unit>
        <trans-unit id="ee54e36e284ff26a979d2076f6ca4023c3d73825" translate="yes" xml:space="preserve">
          <source>The line above describes the limits of buckets currently in use. Each bucket has two sizes: memory footprint and the maximal size of user data that can fit into this bucket. Suppose in the above example that the smallest bucket were size 4. The biggest bucket would have usable size 8188, and the memory footprint would be 8192.</source>
          <target state="translated">В вышеприведенной строке описаны лимиты используемых в настоящее время ведер.Каждое ведро имеет два размера:объем памяти и максимальный размер пользовательских данных,которые могут поместиться в это ведро.Предположим в примере выше,что наименьший размер ведра был 4.Самое большое ведро будет иметь полезный размер 8188,а объем памяти-8192.</target>
        </trans-unit>
        <trans-unit id="391452165da7e2f812078f7c3a4920d3947a871e" translate="yes" xml:space="preserve">
          <source>The line in &lt;code&gt;$E-&amp;gt;file&lt;/code&gt; where the exceptional code was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac97bcd51055b69e1b4470987fa154b899ce651a" translate="yes" xml:space="preserve">
          <source>The line number the error occurred in.</source>
          <target state="translated">Номер строки,в которой произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="cc23ac8e14569b4b19694084670492ce2aa4a0c6" translate="yes" xml:space="preserve">
          <source>The line shown is the one that is about to be executed &lt;b&gt;next&lt;/b&gt;, it hasn't happened yet. So while we can print a variable with the letter '&lt;b&gt;p&lt;/b&gt;', at this point all we'd get is an empty (undefined) value back. What we need to do is to step through the next executable statement with an '&lt;b&gt;s&lt;/b&gt;':</source>
          <target state="translated">Показанная строка - это та, которая должна быть выполнена &lt;b&gt;следующей&lt;/b&gt; , но этого еще не произошло. Итак, хотя мы можем вывести переменную с буквой &amp;laquo; &lt;b&gt;p&lt;/b&gt; &amp;raquo;, на этом этапе все, что мы получим, - это пустое (неопределенное) значение. Что нам нужно сделать, так это пройти через следующий исполняемый оператор с буквой ' &lt;b&gt;s&lt;/b&gt; ':</target>
        </trans-unit>
        <trans-unit id="e54713c2cd710c76f4d69536879402921ef82d04" translate="yes" xml:space="preserve">
          <source>The linearized MRO of a class is an ordered array of all of the classes one would search when resolving a method on that class, starting with the class itself.</source>
          <target state="translated">Линеаризованное MRO класса-это упорядоченный массив всех классов,который можно было бы искать при разрешении метода по этому классу,начиная с самого класса.</target>
        </trans-unit>
        <trans-unit id="f96ce0004635ab8058e21a997ff0fdcac4680ebd" translate="yes" xml:space="preserve">
          <source>The link found cannot be parsed because it does not conform to the syntax described in &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="translated">Найденную ссылку невозможно проанализировать, потому что она не соответствует синтаксису, описанному в &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="365c0989adb3aa2936b9a9b37c715ae0175f622e" translate="yes" xml:space="preserve">
          <source>The link-text. If there is none, this must be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the link-text is &quot;Perl Functions&quot;. In &quot;L&amp;lt;Time::HiRes&amp;gt;&quot; and even &quot;L&amp;lt;|Time::HiRes&amp;gt;&quot;, there is no link text. Note that link text may contain formatting.)</source>
          <target state="translated">Текст ссылки. Если его нет, это должно быть &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . (Например, в &amp;laquo;L &amp;lt;Perl Functions | perlfunc&amp;gt;&amp;raquo; текст ссылки - &amp;laquo;Функции Perl&amp;raquo;. В &amp;laquo;L &amp;lt;Time :: HiRes&amp;gt;&amp;raquo; и даже &amp;laquo;L &amp;lt;| Time :: HiRes&amp;gt;&amp;raquo; нет текст ссылки. Обратите внимание, что текст ссылки может содержать форматирование.)</target>
        </trans-unit>
        <trans-unit id="02b503d2f0eeb8483755cc493aa85b3fc0ad66ce" translate="yes" xml:space="preserve">
          <source>The link-text. If there is none, this must be &lt;code&gt;undef&lt;/code&gt;. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the link-text is &quot;Perl Functions&quot;. In &quot;L&amp;lt;Time::HiRes&amp;gt;&quot; and even &quot;L&amp;lt;|Time::HiRes&amp;gt;&quot;, there is no link text. Note that link text may contain formatting.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43c6585f184d3f50d1ee9b3f3e7c9226f529c8c" translate="yes" xml:space="preserve">
          <source>The list becomes the default for</source>
          <target state="translated">Список становится списком по умолчанию для</target>
        </trans-unit>
        <trans-unit id="3deb5bdbb77dae94d3dcc1cd91998f32e0e38f14" translate="yes" xml:space="preserve">
          <source>The list in the second argument means:</source>
          <target state="translated">Список во втором аргументе означает:</target>
        </trans-unit>
        <trans-unit id="e1406e4b9186eac7ca74cdee5b539fc3d6f09c6c" translate="yes" xml:space="preserve">
          <source>The list may well be incomplete, or even wrong in some places. When in doubt, consult the platform-specific README files in the Perl source distribution, and any other documentation resources accompanying a given port.</source>
          <target state="translated">Список может быть неполным или даже неправильным в некоторых местах.В случае сомнений,обратитесь к специфическим для платформы README файлам в дистрибутиве Perl,а также к любой другой документации,сопровождающей данный порт.</target>
        </trans-unit>
        <trans-unit id="47c47cf18ff1538b7e1e7d5d97838485842b3427" translate="yes" xml:space="preserve">
          <source>The list of &lt;b&gt;directories&lt;/b&gt; the system searches to find a program you want to &lt;b&gt;execute&lt;/b&gt;. The list is stored as one of your &lt;b&gt;environment variables&lt;/b&gt;, accessible in Perl as &lt;code&gt;$ENV{PATH}&lt;/code&gt; .</source>
          <target state="translated">Список &lt;b&gt;каталогов,&lt;/b&gt; в которых система ищет программу, которую вы хотите &lt;b&gt;выполнить&lt;/b&gt; . Список хранится как одна из &lt;b&gt;переменных&lt;/b&gt; вашего &lt;b&gt;окружения&lt;/b&gt; , доступная в Perl как &lt;code&gt;$ENV{PATH}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38740fd91fca4080ce68cbb1a2be0d91acbe5b88" translate="yes" xml:space="preserve">
          <source>The list of &lt;b&gt;directories&lt;/b&gt; the system searches to find a program you want to &lt;b&gt;execute&lt;/b&gt;. The list is stored as one of your &lt;b&gt;environment variables&lt;/b&gt;, accessible in Perl as &lt;code&gt;$ENV{PATH}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b24d146d5dbad44a8c4fe5e7cb3811111eac143" translate="yes" xml:space="preserve">
          <source>The list of characters within the character class gives the set of characters matched by the class. &lt;code&gt;&quot;[abc]&quot;&lt;/code&gt; matches a single &quot;a&quot; or &quot;b&quot; or &quot;c&quot;. But if the first character after the &lt;code&gt;&quot;[&quot;&lt;/code&gt; is &lt;code&gt;&quot;^&quot;&lt;/code&gt;, the class instead matches any character not in the list. Within a list, the &lt;code&gt;&quot;-&quot;&lt;/code&gt; character specifies a range of characters, so that &lt;code&gt;a-z&lt;/code&gt; represents all characters between &quot;a&quot; and &quot;z&quot;, inclusive. If you want either &lt;code&gt;&quot;-&quot;&lt;/code&gt; or &lt;code&gt;&quot;]&quot;&lt;/code&gt; itself to be a member of a class, put it at the start of the list (possibly after a &lt;code&gt;&quot;^&quot;&lt;/code&gt;), or escape it with a backslash. &lt;code&gt;&quot;-&quot;&lt;/code&gt; is also taken literally when it is at the end of the list, just before the closing &lt;code&gt;&quot;]&quot;&lt;/code&gt;. (The following all specify the same class of three characters: &lt;code&gt;[-az]&lt;/code&gt;, &lt;code&gt;[az-]&lt;/code&gt;, and &lt;code&gt;[a\-z]&lt;/code&gt;. All are different from &lt;code&gt;[a-z]&lt;/code&gt;, which specifies a class containing twenty-six characters, even on EBCDIC-based character sets.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880294bb5af5ca3525238395f901655f64c2020a" translate="yes" xml:space="preserve">
          <source>The list of functions supported by this module.</source>
          <target state="translated">Перечень функций,поддерживаемых этим модулем.</target>
        </trans-unit>
        <trans-unit id="77160ea4e8b3bcdfb5681dd2b39ffff26dc948b8" translate="yes" xml:space="preserve">
          <source>The list of functions that will need to recompiled is: creat, fgetpos, fopen, freopen, fsetpos, fstat, fstatvfs, fstatvfsdev, ftruncate, ftw, lockf, lseek, lstat, mmap, nftw, open, prealloc, stat, statvfs, statvfsdev, tmpfile, truncate, getrlimit, setrlimit</source>
          <target state="translated">Список функций,которые необходимо будет перекомпилировать:creat,fgetpos,fopen,freopen,fsetpos,fstat,fstatvfs,fstatvfsdev,ftruncate,ftw,lockf,lseek,lstat,mmap,nftw,open,prealloc,stat,statvfs,statvfsdev,tmpfile,truncate,getrlimit,setrlimit</target>
        </trans-unit>
        <trans-unit id="0ece79552d7d2f7d04e0b952118b609964429027" translate="yes" xml:space="preserve">
          <source>The list of libraries needed by Perl only (any libraries needed by extensions only will by dropped, if using dynamic loading).</source>
          <target state="translated">Список библиотек,необходимых только Perl (любые библиотеки,необходимые только для расширений,при использовании динамической загрузки будут выпадать).</target>
        </trans-unit>
        <trans-unit id="8a88dc253dbf62089f3cd58a095e24a1f2508bc5" translate="yes" xml:space="preserve">
          <source>The list of macro definitions to be passed through must be specified using the /MACRO qualifier and must not add another /DEFINE qualifier. We prepend our own comma here to the contents of $(PASTHRU_DEFINE) because it is often empty and a comma always present in CCFLAGS would generate a missing qualifier value error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64ca6ece649f2cd25525c8ae9c0d312fa7bfc44" translate="yes" xml:space="preserve">
          <source>The list of moderators will be public knowledge. At present, it is: Aaron Crane, Andy Dougherty, Ricardo Signes, Steffen M&amp;uuml;ller.</source>
          <target state="translated">Список модераторов будет достоянием общественности. В настоящее время это: Аарон Крейн, Энди Догерти, Рикардо Синьес, Штеффен Мюллер.</target>
        </trans-unit>
        <trans-unit id="78f6263b45ee82cd9e1bdb24d318e0dddc31338c" translate="yes" xml:space="preserve">
          <source>The list of moderators will be public knowledge. At present, it is: Andy Dougherty, Karen Etheridge, Ricardo Signes, Sawyer X, Steffen M&amp;uuml;ller, Todd Rinaldo, Aaron Crane.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1addfaddfdb521f7b3277e8c72cb79cc08f13e02" translate="yes" xml:space="preserve">
          <source>The list of output parameters occurs at the very end of the function, just after the OUTPUT: directive. The use of RETVAL tells Perl that you wish to send this value back as the return value of the XSUB function. In Example 3, we wanted the &quot;return value&quot; placed in the original variable which we passed in, so we listed it (and not RETVAL) in the OUTPUT: section.</source>
          <target state="translated">Список выходных параметров появляется в самом конце функции,сразу после директивы OUTPUT:.Использование RETVAL сообщает Perl,что вы хотите отправить это значение обратно в качестве возвращаемого значения функции XSUB.В примере 3 мы хотели,чтобы &quot;возвращаемое значение&quot; было помещено в исходную переменную,в которую мы передали,поэтому мы перечислили его (а не RETVAL)в разделе OUTPUT:.</target>
        </trans-unit>
        <trans-unit id="2539fe270e83e959d35fc853744365007ae544d9" translate="yes" xml:space="preserve">
          <source>The list of subfields can be supplied in any of the following formats</source>
          <target state="translated">Список подполей может быть предоставлен в любом из следующих форматов</target>
        </trans-unit>
        <trans-unit id="e16fd393ccc48ed4253b4ef65eb2fcd167d75fd6" translate="yes" xml:space="preserve">
          <source>The list of symbols for the iterator is assembled by spawning off a subprocess, which can be slow. Ideally, we should just traverse the process' symbol table directly from C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcba41fba02d24fea6ac236d8112cd5b98ebb87" translate="yes" xml:space="preserve">
          <source>The list of the registered CPAN sites follows. Please note that the sorting order is alphabetical on fields:</source>
          <target state="translated">Ниже приведен список зарегистрированных сайтов CPAN.Пожалуйста,обратите внимание,что порядок сортировки по полям алфавитный:</target>
        </trans-unit>
        <trans-unit id="e411ef2006039baaa3efb0aa87f085a254587fe2" translate="yes" xml:space="preserve">
          <source>The list of the valid options is shown below. Options not specified will remain unchanged.</source>
          <target state="translated">Список действительных опций показан ниже.Не указанные опции останутся без изменений.</target>
        </trans-unit>
        <trans-unit id="cca90ac8d52c301adc0df9b517c693dc0133a8b6" translate="yes" xml:space="preserve">
          <source>The list opened with &lt;code&gt;=over&lt;/code&gt; does not contain any items.</source>
          <target state="translated">Список, открытый с помощью &lt;code&gt;=over&lt;/code&gt; , не содержит никаких элементов.</target>
        </trans-unit>
        <trans-unit id="4d086b1f033b01df712b5de461a87fac4f3a292c" translate="yes" xml:space="preserve">
          <source>The list opened with &lt;code&gt;=over&lt;/code&gt; does not contain anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37870cad335f71a8db1ccbfc9f539b9f8492c3a2" translate="yes" xml:space="preserve">
          <source>The list reference contains one or more strings specifying patterns that are</source>
          <target state="translated">Ссылка на список содержит одну или несколько строк с указанием деталей,которые являются</target>
        </trans-unit>
        <trans-unit id="7ecd93d98b44cbb94ca7891c2599a20dc8e75287" translate="yes" xml:space="preserve">
          <source>The list reference contains one or more strings specifying patterns that must</source>
          <target state="translated">Ссылка на список содержит одну или несколько строк с указанием деталей,которые должны</target>
        </trans-unit>
        <trans-unit id="0da38439f7a00ec9abb7cd8b98624a8251f6fb80" translate="yes" xml:space="preserve">
          <source>The listing below is alphabetical, case insensitive.</source>
          <target state="translated">Перечень ниже в алфавитном порядке,не чувствителен к регистру.</target>
        </trans-unit>
        <trans-unit id="768abd184089ae969a2334570319327e5afad505" translate="yes" xml:space="preserve">
          <source>The listing looks something like this:</source>
          <target state="translated">Список выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="a6fd74766ba848460935d167a256b131af8e02ea" translate="yes" xml:space="preserve">
          <source>The lists are ordered (roughly) so the most preferred names come before less preferred ones.</source>
          <target state="translated">Списки упорядочены (приблизительно),поэтому наиболее предпочтительные имена идут впереди менее предпочтительных.</target>
        </trans-unit>
        <trans-unit id="c3448e4c57076d015f65b6c72251baf22ba5950b" translate="yes" xml:space="preserve">
          <source>The literal string in the regex can be replaced by a variable:</source>
          <target state="translated">Буквенная строка в регексе может быть заменена на переменную:</target>
        </trans-unit>
        <trans-unit id="9605e010408c59883a845d8cc68911d04aa028cd" translate="yes" xml:space="preserve">
          <source>The literal string in the regexp can be replaced by a variable:</source>
          <target state="translated">Буквенная строка в регеxp может быть заменена на переменную:</target>
        </trans-unit>
        <trans-unit id="cc87d2f061afcaaa2771f59160c4bc3540da65d9" translate="yes" xml:space="preserve">
          <source>The literal string to be output. If it starts with a number and an optional '*' then the padding will be increased by an amount relative to this number, if the '*' is present then this amount will be multiplied by $cnt. This part of $string is removed before output/</source>
          <target state="translated">Буквальная строка для вывода.Если она начинается с числа и необязательного '*',то подкладка будет увеличена на сумму относительно этого числа,если '*' присутствует,то эта сумма будет умножена на $cnt.Эта часть строки $cnt удаляется перед выводом/</target>
        </trans-unit>
        <trans-unit id="67b8f203dc692021f65103823771254ae8d76d5b" translate="yes" xml:space="preserve">
          <source>The literals that are converted are &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt; , and starting in v5.8.1, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. Operations that do conversions include &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;utf8::upgrade&lt;/code&gt; (but not &lt;code&gt;utf8::downgrade&lt;/code&gt; ), and &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Конвертируемые литералы: &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt; , а начиная с версии v5.8.1, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; . Операции, выполняющие преобразования, включают &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;utf8::upgrade&lt;/code&gt; (но не &lt;code&gt;utf8::downgrade&lt;/code&gt; ) и &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="116243fae422285ef1d7be17ca7bca8fa87732c6" translate="yes" xml:space="preserve">
          <source>The literals that are converted are &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt;, and starting in v5.8.1, &lt;code&gt;tr///&lt;/code&gt;. Operations that do conversions include &lt;code&gt;chr&lt;/code&gt;, &lt;code&gt;ord&lt;/code&gt;, &lt;code&gt;utf8::upgrade&lt;/code&gt; (but not &lt;code&gt;utf8::downgrade&lt;/code&gt;), and &lt;code&gt;chomp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dba36a88aebe7e92337b13757f05491149d1212d" translate="yes" xml:space="preserve">
          <source>The little number the &lt;b&gt;operating system&lt;/b&gt; uses to keep track of which opened &lt;b&gt;file&lt;/b&gt; you&amp;rsquo;re talking about. Perl hides the file descriptor inside a &lt;b&gt;standard I/O&lt;/b&gt; stream and then attaches the stream to a &lt;b&gt;filehandle&lt;/b&gt;.</source>
          <target state="translated">Небольшое число, используемое &lt;b&gt;операционной системой&lt;/b&gt; для отслеживания того, о каком открытом &lt;b&gt;файле&lt;/b&gt; вы говорите. Perl скрывает дескриптор файла внутри &lt;b&gt;стандартного&lt;/b&gt; потока &lt;b&gt;ввода-вывода,&lt;/b&gt; а затем присоединяет поток к &lt;b&gt;дескриптору файла&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c45e18376e8b086f8c631b86953dc61fd730ab6e" translate="yes" xml:space="preserve">
          <source>The load function that dl_load_file() calls may require an absolute pathname. The dl_findfile() function and @dl_library_path can be used to search for and return the absolute pathname for the library/object that you wish to load.</source>
          <target state="translated">Функция load,которую вызывает dl_load_file(),может потребовать абсолютного патнана.Функция dl_findfile()и @dl_library_path могут использоваться для поиска и возврата абсолютного пути для библиотеки/объекта,который вы хотите загрузить.</target>
        </trans-unit>
        <trans-unit id="8c46c2259b1d6fa0f7f68fad81b43f4cfbd94e4d" translate="yes" xml:space="preserve">
          <source>The loaded modules are IO::Handle, IO::Seekable, IO::File, IO::Pipe, IO::Socket, IO::Dir. You should instead explicitly import the IO modules you want.</source>
          <target state="translated">Загруженные модули:IO::Handle,IO::Seekable,IO::File,IO::Pipe,IO::Socket,IO::Dir.Вместо этого вы должны явно импортировать нужные вам IO-модули.</target>
        </trans-unit>
        <trans-unit id="0917a1903587e2d522edafea1a2d6e66a9118a13" translate="yes" xml:space="preserve">
          <source>The local() generated a compile-time error because you just touched a global name without fully qualifying it.</source>
          <target state="translated">Функция local()сгенерировала ошибку во время компиляции,потому что вы просто коснулись глобального имени без его полной квалификации.</target>
        </trans-unit>
        <trans-unit id="0cf7efcc5129f771b3d1f0dd51149aa0de4647fc" translate="yes" xml:space="preserve">
          <source>The localeconv function</source>
          <target state="translated">Функция локализации</target>
        </trans-unit>
        <trans-unit id="ba0cd5497a3f02564f53cc5f3cb0a7c74904a185" translate="yes" xml:space="preserve">
          <source>The locking technique went like this.</source>
          <target state="translated">Техника запирания прошла вот так.</target>
        </trans-unit>
        <trans-unit id="6e5d8b4586e8d6172f220183afe910608a1d8583" translate="yes" xml:space="preserve">
          <source>The log level to use, with either the embedded, minimal logger or &lt;a href=&quot;Log::Log4perl&quot;&gt;Log::Log4perl&lt;/a&gt; if it is installed. Possible values are the same as the &lt;code&gt;Log::Log4perl&lt;/code&gt; levels: &lt;code&gt;TRACE&lt;/code&gt;, &lt;code&gt;DEBUG&lt;/code&gt;, &lt;code&gt;INFO&lt;/code&gt;, &lt;code&gt;WARN&lt;/code&gt;, &lt;code&gt;ERROR&lt;/code&gt;, and &lt;code&gt;FATAL&lt;/code&gt;. The default is &lt;code&gt;INFO&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb02723b6a87664f1d9c172d5d68ee624445a8a4" translate="yes" xml:space="preserve">
          <source>The logarithm of the Gamma function [C99].</source>
          <target state="translated">Логаритм Гамма-функции [C99].</target>
        </trans-unit>
        <trans-unit id="12f81008559a10138f818056ec245c593a6400e5" translate="yes" xml:space="preserve">
          <source>The logic of &lt;code&gt;:locale&lt;/code&gt; is described in full in &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt;, but in short it is first trying nl_langinfo(CODESET) and then guessing from the LC_ALL and LANG locale environment variables.</source>
          <target state="translated">Логика &lt;code&gt;:locale&lt;/code&gt; полностью описана в &lt;a href=&quot;encoding&quot;&gt;кодировке&lt;/a&gt; , но, вкратце, сначала выполняется попытка nl_langinfo (CODESET), а затем предположение из переменных среды локали LC_ALL и LANG.</target>
        </trans-unit>
        <trans-unit id="788028f7f75ce2d23138d44a065abd859dafb9ea" translate="yes" xml:space="preserve">
          <source>The logic of &lt;code&gt;:locale&lt;/code&gt; is described in full in &lt;a href=&quot;encoding#The-%3Alocale-sub-pragma&quot;&gt;&quot;The &lt;code&gt;:locale&lt;/code&gt; sub-pragma&quot; in encoding&lt;/a&gt;, but in short it is first trying nl_langinfo(CODESET) and then guessing from the LC_ALL and LANG locale environment variables. &lt;code&gt;:locale&lt;/code&gt; also implicitly turns on &lt;code&gt;:std&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf878ca097d48d543ea19885a2629244c15e1017" translate="yes" xml:space="preserve">
          <source>The logic of finding which locale &lt;code&gt;:locale&lt;/code&gt; uses is as follows:</source>
          <target state="translated">Логика определения того, какой locale &lt;code&gt;:locale&lt;/code&gt; используется, выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="49964803a05917808abe031a83a5e6119fc9d862" translate="yes" xml:space="preserve">
          <source>The lone dot that ends a format can also prematurely end a mail message passing through a misconfigured Internet mailer (and based on experience, such misconfiguration is the rule, not the exception). So when sending format code through mail, you should indent it so that the format-ending dot is not on the left margin; this will prevent SMTP cutoff.</source>
          <target state="translated">Одинокая точка,которая заканчивается форматом,также может преждевременно закончить почтовое сообщение,проходящее через неправильно настроенное почтовое устройство Интернета (и,основываясь на опыте,такая неправильная настройка является правилом,а не исключением).Поэтому при отправке кода формата через почту,вы должны отступить от него так,чтобы точка окончания формата не находилась на левом поле;это предотвратит отсечение SMTP.</target>
        </trans-unit>
        <trans-unit id="23ac1b0fabb60338fc7595b94617767f0048e6fc" translate="yes" xml:space="preserve">
          <source>The lonesome dash</source>
          <target state="translated">Одинокая тире</target>
        </trans-unit>
        <trans-unit id="58b8d17fbed51ef506dcc5bc2dfad68f8e405d89" translate="yes" xml:space="preserve">
          <source>The long answer is that &quot;it depends&quot;, and a good answer cannot be given without knowing (at the very least) the language context. See &lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode::Collate&lt;/a&gt;, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8acab1ed969d76981aca60d63a3ad2f6189741fb" translate="yes" xml:space="preserve">
          <source>The long answer is that &quot;it depends&quot;, and a good answer cannot be given without knowing (at the very least) the language context. See &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt;, and</source>
          <target state="translated">Длинный ответ таков: &amp;laquo;это зависит от обстоятельств&amp;raquo;, и нельзя дать хороший ответ, не зная (по крайней мере) языкового контекста. См. &lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collate&lt;/a&gt; и</target>
        </trans-unit>
        <trans-unit id="12b46ea21e617b9bac57234d9626d778dcbba94b" translate="yes" xml:space="preserve">
          <source>The long answer is that you need to consider character normalization and casing issues: see &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;, Unicode Technical Report #15, &lt;a href=&quot;https://www.unicode.org/unicode/reports/tr15&quot;&gt;Unicode Normalization Forms&lt;/a&gt; and sections on case mapping in the &lt;a href=&quot;https://www.unicode.org&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b351929b2c368a051a670eae8fde3b6788ce75f" translate="yes" xml:space="preserve">
          <source>The long answer is that you need to consider character normalization and casing issues: see &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;, Unicode Technical Report #15, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2funicode%2freports%2ftr15&quot;&gt;Unicode Normalization Forms&lt;/a&gt; and sections on case mapping in the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">Длинный ответ заключается в том, что вам необходимо учитывать проблемы нормализации символов и регистров: см. &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt; , Технический отчет Unicode № 15, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2funicode%2freports%2ftr15&quot;&gt;Формы нормализации Unicode&lt;/a&gt; и разделы, посвященные отображению регистра в &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org&quot;&gt;стандарте Unicode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b13e585010c555d0e300d8fe834b6f46a4ae81c6" translate="yes" xml:space="preserve">
          <source>The long answer is the rest of the manpage :-)</source>
          <target state="translated">Длинный ответ-остальная часть руководства :-)</target>
        </trans-unit>
        <trans-unit id="31adae3a57b090c57ee3c7e6d1bf3e97b3bf17d2" translate="yes" xml:space="preserve">
          <source>The long name is returned in a form nicely capitalized, suitable for printing.</source>
          <target state="translated">Длинное имя возвращается в форме с заглавными буквами,подходящей для печати.</target>
        </trans-unit>
        <trans-unit id="3088cd686b7b7b0dbd27c6c1543c10f8e12363eb" translate="yes" xml:space="preserve">
          <source>The lookahead and lookbehind assertions are generalizations of the anchor concept. Lookahead and lookbehind are zero-width assertions that let us specify which characters we want to test for. The lookahead assertion is denoted by &lt;code&gt;(?=regexp)&lt;/code&gt; and the lookbehind assertion is denoted by &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt;. Some examples are</source>
          <target state="translated">Утверждения просмотра вперед и назад являются обобщением концепции привязки. Lookahead и lookbehind - это утверждения нулевой ширины, которые позволяют нам указать, какие символы мы хотим проверить. Утверждение просмотра вперед обозначается &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; Regexp &lt;code&gt;(?=regexp)&lt;/code&gt; а утверждение просмотра назад обозначается (? &amp;lt;= Fixed-regexp) . Некоторые примеры</target>
        </trans-unit>
        <trans-unit id="5683ae6515c38a0cd77c7a977d476fd0513aeaf5" translate="yes" xml:space="preserve">
          <source>The lookahead and lookbehind assertions are generalizations of the anchor concept. Lookahead and lookbehind are zero-width assertions that let us specify which characters we want to test for. The lookahead assertion is denoted by &lt;code&gt;(?=regexp)&lt;/code&gt; or (starting in 5.32, experimentally in 5.28) &lt;code&gt;(*pla:regexp)&lt;/code&gt; or &lt;code&gt;(*positive_lookahead:regexp)&lt;/code&gt;; and the lookbehind assertion is denoted by &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; or (starting in 5.32, experimentally in 5.28) &lt;code&gt;(*plb:fixed-regexp)&lt;/code&gt; or &lt;code&gt;(*positive_lookbehind:fixed-regexp)&lt;/code&gt;. Some examples are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f75c5b0c19aae838064eb95c9b0bb2969329be" translate="yes" xml:space="preserve">
          <source>The lookbehind &lt;code&gt;condition&lt;/code&gt; allows, along with backreferences, an earlier part of the match to influence a later part of the match. For instance,</source>
          <target state="translated">Просмотра назад &lt;code&gt;condition&lt;/code&gt; позволяет, наряду с, обратными ссылками на первую части матча , чтобы повлиять на позднюю часть матча. Например,</target>
        </trans-unit>
        <trans-unit id="81e7a5f6a959e62bd2ce3d55576db8abdefeae7e" translate="yes" xml:space="preserve">
          <source>The loop will do the right thing for a while, but it will unexpectedly fail.</source>
          <target state="translated">Какое-то время цикл будет делать правильные вещи,но неожиданно провалится.</target>
        </trans-unit>
        <trans-unit id="45575ec17d57b6c0181a285166eef0dbc45075e3" translate="yes" xml:space="preserve">
          <source>The loop will never terminate.</source>
          <target state="translated">Петля никогда не закончится.</target>
        </trans-unit>
        <trans-unit id="ef06996a2f846d6797b75f13080961cc1d5fe17b" translate="yes" xml:space="preserve">
          <source>The low levels of the stack work with the low-level operating system calls (file descriptors in C) getting bytes in and out, the higher layers of the stack buffer, filter, and otherwise manipulate the I/O, and return characters (or bytes) to Perl. Terms</source>
          <target state="translated">Низкие уровни стека работают с низкоуровневыми вызовами операционной системы (файловые дескрипторы на C),получающими байты внутрь и наружу,более высокие уровни буфера стека,фильтруют и иным образом манипулируют входами/выходами,а также возвращают символы (или байты)на Perl.Термины</target>
        </trans-unit>
        <trans-unit id="af589ba8a2b7e981d742f8a3045bf5151d26273f" translate="yes" xml:space="preserve">
          <source>The low-order 4 bytes of the total number of cylinders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dcd393353514c923ef3599ddd24840670260ada" translate="yes" xml:space="preserve">
          <source>The low-order and high-order [respectively] 4 bytes of the offset [in bytes] where the formatting should begin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebbaa8b5bbc22fc30de9a07ab039a1fa2504ddd5" translate="yes" xml:space="preserve">
          <source>The low-order and high-order [respectively] 4 bytes of the starting offset of the partition, measured in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e618b44ecefc43c73cbcbb761a0be8756b4a11d0" translate="yes" xml:space="preserve">
          <source>The lower-level loops are</source>
          <target state="translated">Нижнеуровневые петли</target>
        </trans-unit>
        <trans-unit id="d49e301cfdcfd0dc30c1292d8446531a39bb2c8d" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;$ref&lt;/code&gt; will be turned into a weak reference. This means that it will not hold a reference count on the object it references. Also when the reference count on that object reaches zero, the reference will be set to undef. This function mutates the lvalue passed as its argument and returns no value.</source>
          <target state="translated">Lvalue &lt;code&gt;$ref&lt;/code&gt; будет преобразовано в слабую ссылку. Это означает, что он не будет содержать счетчик ссылок на объект, на который ссылается. Также, когда счетчик ссылок на этот объект достигает нуля, ссылка будет установлена ​​в undef. Эта функция изменяет значение lvalue, переданное в качестве аргумента, и не возвращает значения.</target>
        </trans-unit>
        <trans-unit id="24ee888b5b6764355f1443fa7075b59310751e36" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;$ref&lt;/code&gt; will be turned into a weak reference. This means that it will not hold a reference count on the object it references. Also, when the reference count on that object reaches zero, the reference will be set to undef. This function mutates the lvalue passed as its argument and returns no value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b929552916e7407c841dad6560b9f648df9456" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;REF&lt;/code&gt; will be turned from a weak reference back into a normal (strong) reference again. This function mutates the lvalue passed as its argument and returns no value. This undoes the action performed by &lt;a href=&quot;#weaken&quot;&gt;&quot;weaken&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3f15897ac19338676b9cf56d55755a66f779f6" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;REF&lt;/code&gt; will be turned from a weak reference back into a normal (strong) reference again. This function mutates the lvalue passed as its argument and returns no value. This undoes the action performed by &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt;.</source>
          <target state="translated">Lvalue &lt;code&gt;REF&lt;/code&gt; снова превратится из слабой ссылки обратно в нормальную (сильную) ссылку. Эта функция изменяет значение lvalue, переданное в качестве аргумента, и не возвращает значения. Это отменяет действие выполняемого &lt;a href=&quot;#weaken&quot;&gt;ослабевать&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c832abcca8e03b1175991e252a63bb6082afdd89" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;cxstack&lt;/code&gt; returns the base of the current context stack, while &lt;code&gt;cxstack_ix&lt;/code&gt; is the index of the current frame within that stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b79adf8cca5ef25d3cb23e673042840fb0ff857" translate="yes" xml:space="preserve">
          <source>The macro to put this target on stack is &lt;code&gt;PUSHTARG&lt;/code&gt; , and it is directly used in some opcodes, as well as indirectly in zillions of others, which use it via &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;.</source>
          <target state="translated">Макрос для помещения этой цели в стек - &lt;code&gt;PUSHTARG&lt;/code&gt; , и он напрямую используется в некоторых кодах операций, а также косвенно в миллионах других, которые используют его через &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="693b2cae8dc15e395df0cd8e5b72f3d52fadcead" translate="yes" xml:space="preserve">
          <source>The macro to put this target on stack is &lt;code&gt;PUSHTARG&lt;/code&gt;, and it is directly used in some opcodes, as well as indirectly in zillions of others, which use it via &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde4ff87d6048995f18afa79c7d92547dd919bf7" translate="yes" xml:space="preserve">
          <source>The macros PERL_SYS_INIT3() and PERL_SYS_TERM() provide system-specific tune up of the C runtime environment necessary to run Perl interpreters; they should only be called once regardless of how many interpreters you create or destroy. Call PERL_SYS_INIT3() before you create your first interpreter, and PERL_SYS_TERM() after you free your last interpreter.</source>
          <target state="translated">Макросы PERL_SYS_INIT3()и PERL_SYS_TERM()обеспечивают системную настройку среды исполнения C,необходимую для запуска интерпретаторов Perl;их следует вызывать только один раз,независимо от того,сколько интерпретаторов вы создаете или уничтожаете.Вызовите PERL_SYS_INIT3()перед созданием первого интерпретатора и PERL_SYS_TERM()после освобождения последнего интерпретатора.</target>
        </trans-unit>
        <trans-unit id="b34be3b84eadf2e475f94c5862ce6783466cbe33" translate="yes" xml:space="preserve">
          <source>The macros below now require an extra parameter than in versions prior to Perl 5.32. The final parameter in each one is a pointer into the string supplied by the first parameter beyond which the input will not be read. This prevents potential reading beyond the end of the buffer. &lt;code&gt;isALPHANUMERIC_utf8&lt;/code&gt;, &lt;code&gt;isASCII_utf8&lt;/code&gt;, &lt;code&gt;isBLANK_utf8&lt;/code&gt;, &lt;code&gt;isCNTRL_utf8&lt;/code&gt;, &lt;code&gt;isDIGIT_utf8&lt;/code&gt;, &lt;code&gt;isIDFIRST_utf8&lt;/code&gt;, &lt;code&gt;isPSXSPC_utf8&lt;/code&gt;, &lt;code&gt;isSPACE_utf8&lt;/code&gt;, &lt;code&gt;isVERTWS_utf8&lt;/code&gt;, &lt;code&gt;isWORDCHAR_utf8&lt;/code&gt;, &lt;code&gt;isXDIGIT_utf8&lt;/code&gt;, &lt;code&gt;isALPHANUMERIC_LC_utf8&lt;/code&gt;, &lt;code&gt;isALPHA_LC_utf8&lt;/code&gt;, &lt;code&gt;isASCII_LC_utf8&lt;/code&gt;, &lt;code&gt;isBLANK_LC_utf8&lt;/code&gt;, &lt;code&gt;isCNTRL_LC_utf8&lt;/code&gt;, &lt;code&gt;isDIGIT_LC_utf8&lt;/code&gt;, &lt;code&gt;isGRAPH_LC_utf8&lt;/code&gt;, &lt;code&gt;isIDCONT_LC_utf8&lt;/code&gt;, &lt;code&gt;isIDFIRST_LC_utf8&lt;/code&gt;, &lt;code&gt;isLOWER_LC_utf8&lt;/code&gt;, &lt;code&gt;isPRINT_LC_utf8&lt;/code&gt;, &lt;code&gt;isPSXSPC_LC_utf8&lt;/code&gt;, &lt;code&gt;isPUNCT_LC_utf8&lt;/code&gt;, &lt;code&gt;isSPACE_LC_utf8&lt;/code&gt;, &lt;code&gt;isUPPER_LC_utf8&lt;/code&gt;, &lt;code&gt;isWORDCHAR_LC_utf8&lt;/code&gt;, &lt;code&gt;isXDIGIT_LC_utf8&lt;/code&gt;, &lt;code&gt;toFOLD_utf8&lt;/code&gt;, &lt;code&gt;toLOWER_utf8&lt;/code&gt;, &lt;code&gt;toTITLE_utf8&lt;/code&gt;, and &lt;code&gt;toUPPER_utf8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1139ce181f4f4cad2c7f324461583f5984431bd" translate="yes" xml:space="preserve">
          <source>The macros to simplify this type of error propagation are</source>
          <target state="translated">Макросы для упрощения этого вида распространения ошибок следующие</target>
        </trans-unit>
        <trans-unit id="c70f4757860a22dec9e7cd7195f5c976eb6e087f" translate="yes" xml:space="preserve">
          <source>The mailbox (MBX) that perl can create to communicate with a pipe defaults to a buffer size of 8192 on 64-bit systems, 512 on VAX. The default buffer size is adjustable via the logical name PERL_MBX_SIZE provided that the value falls between 128 and the SYSGEN parameter MAXBUF inclusive. For example, to set the mailbox size to 32767 use &lt;code&gt;$ENV{'PERL_MBX_SIZE'} = 32767;&lt;/code&gt; and then open and use pipe constructs. An alternative would be to issue the command:</source>
          <target state="translated">Почтовый ящик (MBX), который Perl может создать для связи с конвейером, по умолчанию имеет размер буфера 8192 в 64-битных системах и 512 в VAX. Размер буфера по умолчанию регулируется с помощью логического имени PERL_MBX_SIZE при условии, что значение находится между 128 и параметром SYSGEN MAXBUF включительно. Например, чтобы установить размер почтового ящика 32767, используйте &lt;code&gt;$ENV{'PERL_MBX_SIZE'} = 32767;&lt;/code&gt; а затем откройте и используйте конструкции труб. Альтернативой было бы выполнение команды:</target>
        </trans-unit>
        <trans-unit id="08ec92a415b0c7db1f570cc5fe1a3d90ed229b88" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$]&lt;/code&gt; over &lt;code&gt;$^V&lt;/code&gt; is that it works the same on any version of Perl. The disadvantages are that it can't easily be compared to versions in other formats (e.g. literal v-strings, &quot;v1.2.3&quot; or version objects) and numeric comparisons are subject to the binary floating point representation; it's good for numeric literal version checks and bad for comparing to a variable that hasn't been sanity-checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5ef5a84eaac465306135c82a819527f916862a" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$]&lt;/code&gt; over &lt;code&gt;$^V&lt;/code&gt; is that it works the same on any version of Perl. The disadvantages are that it can't easily be compared to versions in other formats (e.g. literal v-strings, &quot;v1.2.3&quot; or version objects) and numeric comparisons can occasionally fail; it's good for string literal version checks and bad for comparing to a variable that hasn't been sanity-checked.</source>
          <target state="translated">Основное преимущество &lt;code&gt;$]&lt;/code&gt; перед &lt;code&gt;$^V&lt;/code&gt; состоит в том, что он работает одинаково в любой версии Perl. Недостатки в том, что его нелегко сравнить с версиями в других форматах (например, буквальные v-строки, &quot;v1.2.3&quot; или объекты версии), а числовые сравнения могут иногда терпеть неудачу; это хорошо для проверки версии строкового литерала и плохо для сравнения с переменной, которая не была проверена на работоспособность.</target>
        </trans-unit>
        <trans-unit id="4dbfa08a8a6c8cbfafaef8a1a762c3513a39fb28" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$^V&lt;/code&gt; over &lt;code&gt;$]&lt;/code&gt; is that, for Perl v5.10.0 or later, it overloads operators, allowing easy comparison against other version representations (e.g. decimal, literal v-string, &quot;v1.2.3&quot;, or objects). The disadvantage is that prior to v5.10.0, it was only a literal v-string, which can't be easily printed or compared, whereas the behavior of &lt;code&gt;$]&lt;/code&gt; is unchanged on all versions of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb52b8877c2d456ae00a93e532373fbd1c4c24a5" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$^V&lt;/code&gt; over &lt;code&gt;$]&lt;/code&gt; is that, for Perl v5.10.0 or later, it overloads operators, allowing easy comparison against other version representations (e.g. decimal, literal v-string, &quot;v1.2.3&quot;, or objects). The disadvantage is that prior to v5.10.0, it was only a literal v-string, which can't be easily printed or compared.</source>
          <target state="translated">Основное преимущество &lt;code&gt;$^V&lt;/code&gt; над &lt;code&gt;$]&lt;/code&gt; состоит в том, что для Perl v5.10.0 или новее он перегружает операторы, что позволяет легко сравнивать их с представлениями других версий (например, десятичными, буквальными v-строками, &quot;v1.2.3&quot; или объектами) . Недостатком является то, что до версии 5.10.0 это была только буквальная v-строка, которую нельзя было легко распечатать или сравнить.</target>
        </trans-unit>
        <trans-unit id="101d1c6f485f1984d68802df9d96ca30aed70d37" translate="yes" xml:space="preserve">
          <source>The main change in &lt;code&gt;Compress::Zlib&lt;/code&gt; version 2.x is that it does not now interface directly to the zlib library. Instead it uses the &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; modules for reading/writing gzip files, and the &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; module for some low-level zlib access.</source>
          <target state="translated">Основное изменение в &lt;code&gt;Compress::Zlib&lt;/code&gt; версии 2.x заключается в том, что теперь он не взаимодействует напрямую с библиотекой zlib. Вместо этого он использует модули &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; и &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; для чтения / записи файлов gzip и модуль &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; для некоторого низкоуровневого доступа к zlib.</target>
        </trans-unit>
        <trans-unit id="372171de4da878145ca85489d35a3856b5f753b3" translate="yes" xml:space="preserve">
          <source>The main difference between this form of the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method and the previous one, is that this one will attempt to return</source>
          <target state="translated">Основное отличие этой формы метода &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; от предыдущей заключается в том, что этот будет пытаться вернуть</target>
        </trans-unit>
        <trans-unit id="208796ee71984ca1960f03809fd6acd6ef109429" translate="yes" xml:space="preserve">
          <source>The main difference between this form of the &lt;code&gt;read&lt;/code&gt; method and the previous one, is that this one will attempt to return</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="506249c3cb5dbdd1518162463cf96d2d3b772f7e" translate="yes" xml:space="preserve">
          <source>The main difference in your code when using &lt;code&gt;LimitOutput&lt;/code&gt; is having to deal with cases where the &lt;code&gt;$input&lt;/code&gt; parameter still contains some uncompressed data that &lt;code&gt;inflate&lt;/code&gt; hasn't processed yet. The status code returned from &lt;code&gt;inflate&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt; if uncompression took place and &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; if the output buffer is full.</source>
          <target state="translated">Основное отличие вашего кода при использовании &lt;code&gt;LimitOutput&lt;/code&gt; заключается в том, что приходится иметь дело со случаями, когда параметр &lt;code&gt;$input&lt;/code&gt; все еще содержит некоторые несжатые данные, которые &lt;code&gt;inflate&lt;/code&gt; еще не обработаны. Код состояния , возвращенный из &lt;code&gt;inflate&lt;/code&gt; будет &lt;code&gt;Z_OK&lt;/code&gt; если распаковки имели место и &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; если выходной буфер заполнен.</target>
        </trans-unit>
        <trans-unit id="92b5e72aa08b04ddc99309d77bb3cb7a3bd1fb12" translate="yes" xml:space="preserve">
          <source>The main division in the context struct is between a substitution scope (&lt;code&gt;CXt_SUBST&lt;/code&gt;) and block scopes, which are everything else. The former is just used while executing &lt;code&gt;s///e&lt;/code&gt;, and won't be discussed further here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05152f518d0f3656c0688ee9cee29d35fcced80c" translate="yes" xml:space="preserve">
          <source>The main enhancements over the standard DBM Filter hooks are:</source>
          <target state="translated">Основные усовершенствования по сравнению со стандартными DBM-фильтровальными крюками:</target>
        </trans-unit>
        <trans-unit id="e1f5b26355b7b70560c834756cb61711542dab38" translate="yes" xml:space="preserve">
          <source>The main interface to Perl's documentation is &lt;code&gt;perldoc&lt;/code&gt; , although if you're reading this, it's more than likely that you've already found it.</source>
          <target state="translated">Основным интерфейсом документации Perl является &lt;code&gt;perldoc&lt;/code&gt; , хотя, если вы читаете это, более чем вероятно, что вы его уже нашли.</target>
        </trans-unit>
        <trans-unit id="d4c0d9f985e6490addfa7c9bcf66885ac7eb6fd4" translate="yes" xml:space="preserve">
          <source>The main interface to Perl's documentation is &lt;code&gt;perldoc&lt;/code&gt;, although if you're reading this, it's more than likely that you've already found it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d35e12fdba0e51aa394bd8618a43431bb51d2f3" translate="yes" xml:space="preserve">
          <source>The main processing loop in the code handles reading of compressed data from STDIN.</source>
          <target state="translated">Основной цикл обработки в коде обрабатывает чтение сжатых данных из STDIN.</target>
        </trans-unit>
        <trans-unit id="10be13178c7ed17eb7ff58045f81aad5069fb2a4" translate="yes" xml:space="preserve">
          <source>The main reason for using these constants is to help avoid spelling mistakes and similar typos. It will not help you if you forget to prefix the '+' though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46fda3610207ec49730bec59c6f9f9a606bd23ef" translate="yes" xml:space="preserve">
          <source>The main restriction is that everything is a metacharacter. Thus, you cannot refer to single characters by doing something like this:</source>
          <target state="translated">Главное ограничение заключается в том,что все является метахарактером.Таким образом,вы не можете ссылаться на отдельные символы,делая что-то подобное:</target>
        </trans-unit>
        <trans-unit id="5f01e11115c777ec013558e25689beffe8389e6e" translate="yes" xml:space="preserve">
          <source>The main run-time, i.e. the execution of &lt;code&gt;PL_main_root&lt;/code&gt; .</source>
          <target state="translated">Основное время выполнения, то есть выполнение &lt;code&gt;PL_main_root&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7fd0d727cdc1e3c76c39fb195a6b8c660cb66d4" translate="yes" xml:space="preserve">
          <source>The main run-time, i.e. the execution of &lt;code&gt;PL_main_root&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fc4f091ec88a6495b33730022421e8180365bf" translate="yes" xml:space="preserve">
          <source>The main thing to bear in mind when comparing Perl's</source>
          <target state="translated">Главное иметь в виду,когда сравниваешь Perl's</target>
        </trans-unit>
        <trans-unit id="c06e6958bf7f6e1def3af629026b1de09d93eea1" translate="yes" xml:space="preserve">
          <source>The main two standard installer modules are the old and well established ExtUtils::MakeMaker (for short: EUMM) which uses the Makefile.PL. And the next generation installer Module::Build (MB) which works with the Build.PL (and often comes with a Makefile.PL too). If a module comes only with one of the two we will use that one but if both are supplied then a decision must be made between EUMM and MB. See also &lt;a href=&quot;http://rt.cpan.org/Ticket/Display.html?id=29235&quot;&gt;http://rt.cpan.org/Ticket/Display.html?id=29235&lt;/a&gt; for a discussion about the right default.</source>
          <target state="translated">Два основных стандартных модуля установки - это старый и хорошо зарекомендовавший себя ExtUtils :: MakeMaker (для краткости: EUMM), который использует Makefile.PL. И установщик нового поколения Module :: Build (MB), который работает с Build.PL (а также часто поставляется с Makefile.PL). Если модуль поставляется только с одним из двух, мы будем использовать его, но если оба поставляются, решение должно быть принято между EUMM и MB. См. Также &lt;a href=&quot;http://rt.cpan.org/Ticket/Display.html?id=29235&quot;&gt;http://rt.cpan.org/Ticket/Display.html?id=29235&lt;/a&gt; для обсуждения правильного значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4a4d251a87e0958567984c04589a931c90f147e2" translate="yes" xml:space="preserve">
          <source>The main two standard installer modules are the old and well established ExtUtils::MakeMaker (for short: EUMM) which uses the Makefile.PL. And the next generation installer Module::Build (MB) which works with the Build.PL (and often comes with a Makefile.PL too). If a module comes only with one of the two we will use that one but if both are supplied then a decision must be made between EUMM and MB. See also http://rt.cpan.org/Ticket/Display.html?id=29235 for a discussion about the right default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05599914a88c35566cdc46d5be82351b5056b7bb" translate="yes" xml:space="preserve">
          <source>The main use for &lt;code&gt;ascii&lt;/code&gt; is to force the output to not contain characters with values &amp;gt; 127, which means you can interpret the resulting string as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and 8-bit-encoding, and still get the same data structure back. This is useful when your channel for JSON transfer is not 8-bit clean or the encoding might be mangled in between (e.g. in mail), and works because ASCII is a proper subset of most 8-bit and multibyte encodings in use in the world.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa39b18861e8c0d0fbd241aca023fce2a33049ad" translate="yes" xml:space="preserve">
          <source>The main use for &lt;code&gt;latin1&lt;/code&gt; is to relatively efficiently store binary data as JSON, at the expense of breaking compatibility with most JSON decoders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866c41ef1cd5e3c514447a1eb0c0a78fc5c432a8" translate="yes" xml:space="preserve">
          <source>The main use for this flag is efficiently encoding binary data as JSON text, as most octets will not be escaped, resulting in a smaller encoded size. The disadvantage is that the resulting JSON text is encoded in latin1 (and must correctly be treated as such when storing and transferring), a rare encoding for JSON. It is therefore most useful when you want to store data structures known to contain binary data efficiently in files or databases, not when talking to other JSON encoders/decoders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06fa4e1ba42a335acb6388e4bce2e76ff0904fc1" translate="yes" xml:space="preserve">
          <source>The main use for this flag is to produce JSON texts that can be transmitted over a 7-bit channel, as the encoded JSON texts will not contain any 8 bit characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f8fe511450837b8803ee63b84fd8df2352eb1f" translate="yes" xml:space="preserve">
          <source>The main use of the &lt;code&gt;@_&lt;/code&gt; pass-through feature is to write subroutines whose main job it is to call other subroutines for you. For further details, see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">Основное использование функции &lt;code&gt;@_&lt;/code&gt; передачи @_ - это написание подпрограмм, основная задача которых - вызывать за вас другие подпрограммы. Для получения дополнительной информации см. &lt;a href=&quot;perlsub&quot;&gt;Perlsub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53e4e2133c40d29e72103e441a447d5a4a38fc75" translate="yes" xml:space="preserve">
          <source>The main use of typeglobs in modern Perl is create symbol table aliases. This assignment:</source>
          <target state="translated">Основным использованием печатных шрифтов в современном Perl является создание псевдонимов таблицы символов.Это задание:</target>
        </trans-unit>
        <trans-unit id="69b1898f468b9694e16716e650f4f44f6641ba6b" translate="yes" xml:space="preserve">
          <source>The main way they do this is by abstracting the solution into a Perl module. If you don't know what one of these is, the rest of this document isn't going to be much use to you. You're also missing out on an awful lot of useful code; consider having a look at &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; and &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt; before coming back here.</source>
          <target state="translated">Основной способ, которым они это делают, - это абстрагирование решения в модуль Perl. Если вы не знаете, что это за один из них, остальная часть этого документа не принесет вам особой пользы. Вы также упускаете очень много полезного кода; подумайте о том, чтобы взглянуть на &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; , &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; и &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall,&lt;/a&gt; прежде чем вернуться сюда.</target>
        </trans-unit>
        <trans-unit id="0f1c38b1c10cfb3cbb67b1b10b401ccad6c0863c" translate="yes" xml:space="preserve">
          <source>The main workhorse. This is a chimera executable: it is compiled as an &lt;code&gt;a.out&lt;/code&gt; -style executable, but is linked with &lt;code&gt;omf&lt;/code&gt; -style dynamic library</source>
          <target state="translated">Основная рабочая лошадка. Это исполняемый файл химеры: он скомпилирован как исполняемый файл в стиле &lt;code&gt;a.out&lt;/code&gt; , но связан с динамической библиотекой в ​​стиле &lt;code&gt;omf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="545144eca602ef4173887f0da06edec85e29ecc4" translate="yes" xml:space="preserve">
          <source>The main workhorse. This is a chimera executable: it is compiled as an &lt;code&gt;a.out&lt;/code&gt;-style executable, but is linked with &lt;code&gt;omf&lt;/code&gt;-style dynamic library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3956c803121907ff5d6974bf9c432a88f1cf833c" translate="yes" xml:space="preserve">
          <source>The major headers should be set out using a &lt;code&gt;=head1&lt;/code&gt; directive, and are historically written in the rather startling ALL UPPER CASE format; this is not mandatory, but it's strongly recommended so that sections have consistent naming across different software packages. Minor headers may be included using &lt;code&gt;=head2&lt;/code&gt; , and are typically in mixed case.</source>
          <target state="translated">Основные заголовки должны быть установлены с помощью директивы &lt;code&gt;=head1&lt;/code&gt; и исторически написаны в довольно поразительном формате ALL UPPER CASE; это не обязательно, но настоятельно рекомендуется, чтобы разделы в разных пакетах программного обеспечения имели единообразные названия. Незначительные заголовки могут быть включены с помощью &lt;code&gt;=head2&lt;/code&gt; и обычно используются в смешанном регистре.</target>
        </trans-unit>
        <trans-unit id="00d415a583ddacb7562640a4ed5cbc374d3a4aac" translate="yes" xml:space="preserve">
          <source>The major headers should be set out using a &lt;code&gt;=head1&lt;/code&gt; directive, and are historically written in the rather startling ALL UPPER CASE format; this is not mandatory, but it's strongly recommended so that sections have consistent naming across different software packages. Minor headers may be included using &lt;code&gt;=head2&lt;/code&gt;, and are typically in mixed case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d78be692306962b0b26bf44b44f51f19191990" translate="yes" xml:space="preserve">
          <source>The major reference book on Perl, written by the creator of Perl, is</source>
          <target state="translated">Главный справочник по Perl,написанный создателем Perl,-это</target>
        </trans-unit>
        <trans-unit id="13680a9d6e9227284375bc26da8c5530041e38fc" translate="yes" xml:space="preserve">
          <source>The majority of messages from the first three classifications above (W, D &amp;amp; S) can be controlled using the &lt;code&gt;warnings&lt;/code&gt; pragma.</source>
          <target state="translated">Большинство сообщений из первых трех классификаций выше (W, D и S) можно контролировать с помощью &lt;code&gt;warnings&lt;/code&gt; warnings.</target>
        </trans-unit>
        <trans-unit id="47a0713a7794ab11956a543900cb0615be7d2460" translate="yes" xml:space="preserve">
          <source>The majority of the code above is concerned with reading the zip local header data. The code that I want to focus on is at the bottom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd369e1f787ef0292f11539410c5f0156585f6b5" translate="yes" xml:space="preserve">
          <source>The make process also creates the Perl extensions as</source>
          <target state="translated">Процесс изготовления также создает расширения Perl как</target>
        </trans-unit>
        <trans-unit id="6834c3d08e7b64ac9a3d75579db624c6bb6535ce" translate="yes" xml:space="preserve">
          <source>The make process runs only under WinNT shell. The NetWare makefile is located under the NetWare folder. This makes use of miniperl.exe to run some of the Perl scripts. To create miniperl.exe, first set the required paths for Visual c++ compiler (specify vcvars32 location) at the command prompt. Then run nmake from win32 folder through WinNT command prompt. The build process can be stopped after miniperl.exe is created. Then run nmake from NetWare folder through WinNT command prompt.</source>
          <target state="translated">Процесс создания работает только под оболочкой WinNT.makefile NetWare находится в папке NetWare.Это делает возможным использование miniperl.exe для запуска некоторых Perl скриптов.Для создания miniperl.exe,сначала установите необходимые пути для компилятора Visual c++(укажите расположение vcvars32)в командной строке.Затем запустите nmake из папки win32 через командную строку WinNT.Процесс сборки может быть остановлен после создания miniperl.exe.Затем запустите nmake из папки NetWare через командную строку WinNT.</target>
        </trans-unit>
        <trans-unit id="6f3be1c564860e93ed0610de17db5187711f88d0" translate="yes" xml:space="preserve">
          <source>The make target 'allsis' combines all the above SIS targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050ece2e16daad9919f83779717a0433d9f5277b" translate="yes" xml:space="preserve">
          <source>The make under /usr/ccs/bin works fine for building perl. If you have the Sun C compilers, you will also have a parallel version of make (dmake). This works fine to build perl, but can sometimes cause problems when running 'make test' due to underspecified dependencies between the different test harness files. The same problem can also affect the building of some add-on modules, so in those cases either specify '-m serial' on the dmake command line, or use /usr/ccs/bin/make instead. If you wish to use GNU make, be sure that the set-group-id bit is not set. If it is, then arrange your PATH so that /usr/ccs/bin/make is before GNU make or else have the system administrator disable the set-group-id bit on GNU make.</source>
          <target state="translated">Марка под /usr/ccs/bin работает нормально для строительства perl.Если у вас есть компиляторы Sun C,то у вас также будет параллельная версия make (dmake).Это отлично работает для сборки perl,но иногда может вызвать проблемы при запуске 'make test' из-за неуточненных зависимостей между различными файлами тестового жгута.Та же проблема может повлиять и на сборку некоторых дополнительных модулей,поэтому в этих случаях либо укажите '-m serial' в командной строке dmake,либо используйте /usr/ccs/bin/make вместо этого.Если вы хотите воспользоваться GNU,убедитесь,что бит set-group-id не установлен.Если это так,организуйте свою PATH так,чтобы /usr/ccs/bin/make был перед тем,как GNU сделает или заставит системного администратора отключить бит set-group-id в GNU make.</target>
        </trans-unit>
        <trans-unit id="093c5a0fa4f10414f0bded11d9711f892cf8d016" translate="yes" xml:space="preserve">
          <source>The makefile for Win32 is used as a reference to create the makefile for NetWare. Also, the make process for NetWare port uses miniperl.exe to run scripts during the make and installation process.</source>
          <target state="translated">makefile для Win32 используется как ссылка для создания makefile для NetWare.Также,процесс make для порта NetWare использует miniperl.exe для выполнения скриптов во время процесса make и установки.</target>
        </trans-unit>
        <trans-unit id="27e98181ad3a79924d7fd39b526549233ec76d6a" translate="yes" xml:space="preserve">
          <source>The man page documenting the an macro set may be</source>
          <target state="translated">Рабочая страница,документирующая набор макросов,может иметь вид</target>
        </trans-unit>
        <trans-unit id="623ee701bbcdbe97eed930b9efd8035f1a031aee" translate="yes" xml:space="preserve">
          <source>The man page documenting the an macro set may be &lt;a href=&quot;http://man.he.net/man5/man&quot;&gt;man(5)&lt;/a&gt; instead of &lt;a href=&quot;http://man.he.net/man7/man&quot;&gt;man(7)&lt;/a&gt; on your system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b2bfc99455c361765a64ae36b53dd690daec7f" translate="yes" xml:space="preserve">
          <source>The man page documenting the man macro set may be</source>
          <target state="translated">Страница man,документирующая набор макросов man,может иметь вид</target>
        </trans-unit>
        <trans-unit id="7f7916f4586e4282d358ae1052455bb329b90846" translate="yes" xml:space="preserve">
          <source>The man page documenting the man macro set may be &lt;a href=&quot;http://man.he.net/man5/man&quot;&gt;man(5)&lt;/a&gt; instead of &lt;a href=&quot;http://man.he.net/man7/man&quot;&gt;man(7)&lt;/a&gt; on your system. Also, please see &lt;a href=&quot;http://man.he.net/man1/pod2man&quot;&gt;pod2man(1)&lt;/a&gt; for extensive documentation on writing manual pages if you've not done it before and aren't familiar with the conventions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284a6c5b883e0ac48b839ca370726900339633bc" translate="yes" xml:space="preserve">
          <source>The mandatory parameter &lt;code&gt;$input&lt;/code&gt; is used to determine the source of the compressed data. This parameter can take one of three forms.</source>
          <target state="translated">Обязательный параметр &lt;code&gt;$input&lt;/code&gt; используется для определения источника сжатых данных. Этот параметр может принимать одну из трех форм.</target>
        </trans-unit>
        <trans-unit id="c485ab3d22837e3f8be3f1796e0e79d8c8f06f1f" translate="yes" xml:space="preserve">
          <source>The mandatory parameter &lt;code&gt;$output&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">Обязательный параметр &lt;code&gt;$output&lt;/code&gt; используется для управления местом назначения сжатых данных. Этот параметр может принимать одну из следующих форм.</target>
        </trans-unit>
        <trans-unit id="de616d536d8ef10cc9a3f654a8c90f376abf8093" translate="yes" xml:space="preserve">
          <source>The manual for GNU &lt;code&gt;gettext&lt;/code&gt; . The gettext dist is available in &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; -- get a recent gettext tarball and look in its &quot;doc/&quot; directory, there's an easily browsable HTML version in there. The gettext documentation asks lots of questions worth thinking about, even if some of their answers are sometimes wonky, particularly where they start talking about pluralization.</source>
          <target state="translated">Руководство для GNU &lt;code&gt;gettext&lt;/code&gt; . Gettext dist доступен в &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; - загрузите последний архивный архив gettext и посмотрите его каталог &amp;laquo;doc /&amp;raquo;, там есть легко просматриваемая HTML-версия. Документация gettext задает множество вопросов, над которыми стоит задуматься, даже если некоторые из их ответов иногда бывают неточными, особенно когда они начинают говорить о множественности.</target>
        </trans-unit>
        <trans-unit id="b1839a690d37e18249310936fdff387ca895bbd5" translate="yes" xml:space="preserve">
          <source>The manual for GNU &lt;code&gt;gettext&lt;/code&gt;. The gettext dist is available in &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; -- get a recent gettext tarball and look in its &quot;doc/&quot; directory, there's an easily browsable HTML version in there. The gettext documentation asks lots of questions worth thinking about, even if some of their answers are sometimes wonky, particularly where they start talking about pluralization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="154ce4660707f31f1810dc0e3b48188806eef41c" translate="yes" xml:space="preserve">
          <source>The many &lt;code&gt;SO_*&lt;/code&gt; and other constants provide the socket option names for getsockopt() and setsockopt().</source>
          <target state="translated">Многие &lt;code&gt;SO_*&lt;/code&gt; и другие предоставляют имена параметров сокета для getsockopt () и setsockopt ().</target>
        </trans-unit>
        <trans-unit id="55aaa52fca491aa374cc9b313f0827cacbb95ed1" translate="yes" xml:space="preserve">
          <source>The map of tags-to-names that it uses is accessible as %I18N::LangTags::List::Name, and it's the same as the list that follows in this documentation, which should be useful to you even if you don't use this module.</source>
          <target state="translated">Карта используемых им тегов доступна в виде %I18N::LangTags::List::Name,и она такая же,как и список,приведенный в этой документации,который должен быть вам полезен даже в том случае,если вы не используете этот модуль.</target>
        </trans-unit>
        <trans-unit id="4ec748c6f374bea6dd407e2a2206dd66cc0ef16e" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and Perl is stored in the global hash &lt;code&gt;Mapping&lt;/code&gt; this time. Using a hash has the distinct advantage that it allows an unlimited number of callbacks to be registered.</source>
          <target state="translated">Отображение между обратным вызовом C и Perl на этот раз сохраняется в глобальном хеш- &lt;code&gt;Mapping&lt;/code&gt; . Использование хеша имеет явное преимущество в том, что он позволяет регистрировать неограниченное количество обратных вызовов.</target>
        </trans-unit>
        <trans-unit id="3b99545de853bbada80b111bce027d144c0231ba" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and the Perl equivalent is stored in the global variable &lt;code&gt;callback&lt;/code&gt; .</source>
          <target state="translated">Отображение между обратным вызовом C и эквивалентом Perl сохраняется в обратном &lt;code&gt;callback&lt;/code&gt; глобальной переменной .</target>
        </trans-unit>
        <trans-unit id="8e93b95ea6fe70dd3da986ffb8fe9a8d23395a81" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and the Perl equivalent is stored in the global variable &lt;code&gt;callback&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc01e02bb3d7483c767fb0c7888218cdd8db8748" translate="yes" xml:space="preserve">
          <source>The mapping from Perl to JSON is slightly more difficult, as Perl is a truly typeless language, so we can only guess which JSON type is meant by a Perl value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a662bfcb14335a42ef03f81101790bf366195df" translate="yes" xml:space="preserve">
          <source>The mapping of &lt;code&gt;U+FFFD&lt;/code&gt; is corrected in Unicode 6.3.0. see &lt;a href=&quot;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&quot;&gt;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&lt;/a&gt; (7.1.4 Trailing Weights). Such a correction is reproduced by this.</source>
          <target state="translated">Отображение &lt;code&gt;U+FFFD&lt;/code&gt; исправлено в Unicode 6.3.0. см. &lt;a href=&quot;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&quot;&gt;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&lt;/a&gt; (7.1.4 Конечные веса). Такое исправление воспроизводится этим.</target>
        </trans-unit>
        <trans-unit id="bff19693156a4d3c9d0ae54fb777710debdba865" translate="yes" xml:space="preserve">
          <source>The maps for almost all properties are simple scalars that should be interpreted as-is. These values are those given in the Unicode-supplied data files, which may be inconsistent as to capitalization and as to which synonym for a property-value is given. The results may be normalized by using the &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b1175bc8b4e9784f2300c93388884be8f7673f" translate="yes" xml:space="preserve">
          <source>The maps for almost all properties are simple scalars that should be interpreted as-is. These values are those given in the Unicode-supplied data files, which may be inconsistent as to capitalization and as to which synonym for a property-value is given. The results may be normalized by using the &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function.</source>
          <target state="translated">Карты почти для всех свойств представляют собой простые скаляры, которые следует интерпретировать как есть. Это те значения, которые указаны в файлах данных с Unicode, которые могут быть несовместимыми в отношении использования заглавных букв и того, какой синоним для значения свойства дан. Результаты могут быть нормализованы с помощью функции &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d366a92e1e29300af2573c9ebee67dbf16243194" translate="yes" xml:space="preserve">
          <source>The maps for the following are available at &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; but remain unsupported because those encodings need an algorithmical approach, currently unsupported by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2864353a5c8a1c71a51a027ee705129966bd16" translate="yes" xml:space="preserve">
          <source>The mark stack stores integers as I32 values, which are the height of the value stack at the time before the list began; thus the mark itself actually points to the value stack entry one before the list. The list itself starts at &lt;code&gt;mark + 1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4bf89cabbc9315682f2b81d303b6aa4fa34849" translate="yes" xml:space="preserve">
          <source>The markup used to embed documentation into your Perl code. Pod stands for &amp;ldquo;Plain old documentation&amp;rdquo;. See Camel chapter 23, &amp;ldquo;Plain Old Documentation&amp;rdquo;.</source>
          <target state="translated">Разметка, используемая для встраивания документации в ваш код Perl. Pod означает &amp;laquo;Обычная старая документация&amp;raquo;. См. Главу 23 Camel &amp;laquo;Обычная старая документация&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="34cc83ddfdc06a0bade5acdcde84b75e2705b198" translate="yes" xml:space="preserve">
          <source>The master web site for CPAN is &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;, &lt;a href=&quot;http://www.cpan.org/SITES.html&quot;&gt;http://www.cpan.org/SITES.html&lt;/a&gt; lists all mirrors.</source>
          <target state="translated">Главный веб-сайт CPAN - &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; , &lt;a href=&quot;http://www.cpan.org/SITES.html&quot;&gt;http://www.cpan.org/SITES.html&lt;/a&gt; содержит список всех зеркал.</target>
        </trans-unit>
        <trans-unit id="3c45f7edc42ff58b499f5e637a319d744b7420b9" translate="yes" xml:space="preserve">
          <source>The match is greedy and non-backtracking, so that the cluster is never broken up into smaller components.</source>
          <target state="translated">Сопоставление жадное и необратное,так что кластер никогда не разбивается на более мелкие компоненты.</target>
        </trans-unit>
        <trans-unit id="c68736af7f30812a5478f14010c89b4ae65386b0" translate="yes" xml:space="preserve">
          <source>The match operator is &quot;=~&quot;, not &quot;~&quot;. (&quot;~&quot; is the one's complement operator, as in C.)</source>
          <target state="translated">Оператор соответствия-&quot;=~&quot;,а не &quot;~&quot;.(&quot;~&quot;-оператор дополнения,как в C).</target>
        </trans-unit>
        <trans-unit id="5795a85f98b64dffbf8aba9e904fb2bc93749e98" translate="yes" xml:space="preserve">
          <source>The match operator is a double quote context, so you can interpolate your variable just like a double quoted string. In this case, you read the regular expression as user input and store it in &lt;code&gt;$regex&lt;/code&gt; . Once you have the pattern in &lt;code&gt;$regex&lt;/code&gt; , you use that variable in the match operator.</source>
          <target state="translated">Оператор сопоставления представляет собой контекст с двойными кавычками, поэтому вы можете интерполировать свою переменную так же, как строку с двойными кавычками. В этом случае вы читаете регулярное выражение как вводимое пользователем и сохраняете его в &lt;code&gt;$regex&lt;/code&gt; . Когда у вас есть шаблон в &lt;code&gt;$regex&lt;/code&gt; , вы используете эту переменную в операторе сопоставления.</target>
        </trans-unit>
        <trans-unit id="fc14d244fbe8a0161a49513d59d3516c03861ccd" translate="yes" xml:space="preserve">
          <source>The match operator is a double quote context, so you can interpolate your variable just like a double quoted string. In this case, you read the regular expression as user input and store it in &lt;code&gt;$regex&lt;/code&gt;. Once you have the pattern in &lt;code&gt;$regex&lt;/code&gt;, you use that variable in the match operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab1da87cbb5d0fd800bfa0309cbbc3c397f76b8" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Оператор сопоставления. Смотрите &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2d946e2bfb34dd4f7ba8364971084f9045ae306" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23da9f3c77f641f40df01068ee8c7ee0a479ea6c" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Оператор сопоставления. Смотрите &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f542541549a1bc6970c3286cf46be7af8b4f2d05" translate="yes" xml:space="preserve">
          <source>The match-once behavior is controlled by the match delimiter being &lt;code&gt;?&lt;/code&gt;; with any other delimiter this is the normal &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">Поведение однократного совпадения контролируется разделителем совпадений &lt;code&gt;?&lt;/code&gt; ; с любым другим разделителем это обычный оператор &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9eb42805d07d25374f7b5e9e6773ad7d57c9e1fb" translate="yes" xml:space="preserve">
          <source>The match-once behavior is controlled by the match delimiter being &lt;code&gt;?&lt;/code&gt;; with any other delimiter this is the normal &lt;code&gt;m//&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeba81f62bbef449f5b856ee7d56cb86c716867d" translate="yes" xml:space="preserve">
          <source>The matched-pattern variables, &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$`&lt;/code&gt; (pre-match), &lt;code&gt;$'&lt;/code&gt; (post-match), and &lt;code&gt;$+&lt;/code&gt; (last match) also are tainted.</source>
          <target state="translated">Переменные сопоставленного шаблона, &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$`&lt;/code&gt; (предварительное совпадение), &lt;code&gt;$'&lt;/code&gt; (после совпадения) и &lt;code&gt;$+&lt;/code&gt; (последнее совпадение) также испорчены.</target>
        </trans-unit>
        <trans-unit id="22ab92cf81444e038908ef762ce8e093bd1b736d" translate="yes" xml:space="preserve">
          <source>The matched-pattern variables, &lt;code&gt;$&amp;amp;&lt;/code&gt;, &lt;code&gt;$`&lt;/code&gt; (pre-match), &lt;code&gt;$'&lt;/code&gt; (post-match), and &lt;code&gt;$+&lt;/code&gt; (last match) also are tainted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef4278a734cc2ba9814c78fdf30442bf1892ae1" translate="yes" xml:space="preserve">
          <source>The matching of encoding names is loose: case does not matter, and many encodings have several aliases. Note that the &lt;code&gt;:utf8&lt;/code&gt; layer must always be specified exactly like that; it is</source>
          <target state="translated">Сопоставление имен кодировок не является произвольным: регистр не имеет значения, и многие кодировки имеют несколько псевдонимов. Обратите внимание, что слой &lt;code&gt;:utf8&lt;/code&gt; всегда должен указываться точно так же; это</target>
        </trans-unit>
        <trans-unit id="906f4ce57c5894760cba731d333a52399d7a0c38" translate="yes" xml:space="preserve">
          <source>The matching of encoding names is loose: case does not matter, and many encodings have several aliases. See &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt; for details and the list of supported locales.</source>
          <target state="translated">Сопоставление имен кодировок не является произвольным: регистр не имеет значения, и многие кодировки имеют несколько псевдонимов. См. Подробные сведения и список поддерживаемых локалей в &lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f9b61e44ff3edc932c4eb7e36f1dd657aefd954" translate="yes" xml:space="preserve">
          <source>The material below is separated into three main sections: main issues of portability (&lt;a href=&quot;#ISSUES&quot;&gt;&quot;ISSUES&quot;&lt;/a&gt;), platform-specific issues (&lt;a href=&quot;#PLATFORMS&quot;&gt;&quot;PLATFORMS&quot;&lt;/a&gt;), and built-in Perl functions that behave differently on various ports (&lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;&quot;FUNCTION IMPLEMENTATIONS&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5401e94f4440b62a9a27d03fcc9d30b1169f66e8" translate="yes" xml:space="preserve">
          <source>The material below is separated into three main sections: main issues of portability (&lt;a href=&quot;#ISSUES&quot;&gt;ISSUES&lt;/a&gt;), platform-specific issues (&lt;a href=&quot;#PLATFORMS&quot;&gt;PLATFORMS&lt;/a&gt;), and built-in Perl functions that behave differently on various ports (&lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;FUNCTION IMPLEMENTATIONS&lt;/a&gt;).</source>
          <target state="translated">Приведенный ниже материал разделен на три основных раздела: основные вопросы переносимости ( &lt;a href=&quot;#ISSUES&quot;&gt;ПРОБЛЕМЫ&lt;/a&gt; ), проблемы, связанные с платформой ( &lt;a href=&quot;#PLATFORMS&quot;&gt;ПЛАТФОРМЫ&lt;/a&gt; ), и встроенные функции Perl, которые по-разному работают на разных портах ( &lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;РЕАЛИЗАЦИЯ ФУНКЦИЙ&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6fb16dd0911e0291e015ca052ebafe0545c2d31f" translate="yes" xml:space="preserve">
          <source>The mathematically logical behavior for what matches when inverting is very different from what people expect, so we have decided to forbid it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8bdf4570ce948d9dc30acbc885de4c23118fcd9" translate="yes" xml:space="preserve">
          <source>The maximal stack recursion limit for your system is returned by &lt;code&gt;stack_depth()&lt;/code&gt; and &lt;code&gt;stack_depth_hash()&lt;/code&gt;. The hash limit is usually half the size of the array and ref limit, as the Perl hash API is not optimal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a757bded9f533a67a5134eccc21794fdd0b6bd" translate="yes" xml:space="preserve">
          <source>The maximum Unicode code point is &lt;code&gt;U+10FFFF&lt;/code&gt; , and Unicode only defines operations on code points up through that. But Perl works on code points up to the maximum permissible unsigned number available on the platform. However, Perl will not accept these from input streams unless lax rules are being used, and will warn (using the warning category &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if any are output.</source>
          <target state="translated">Максимальная кодовая точка Unicode - &lt;code&gt;U+10FFFF&lt;/code&gt; , и Unicode определяет операции только с кодовыми точками выше. Но Perl работает с кодовыми точками до максимально допустимого числа без знака, доступного на платформе. Однако Perl не будет принимать их из входных потоков, если не используются слабые правила, и будет предупреждать (используя категорию предупреждений &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; , которая является подкатегорией &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ), если они выводятся.</target>
        </trans-unit>
        <trans-unit id="b742e9c8b7767f6a214c8234694eb3d1179ce880" translate="yes" xml:space="preserve">
          <source>The maximum Unicode code point is &lt;code&gt;U+10FFFF&lt;/code&gt;, and Unicode only defines operations on code points up through that. But Perl works on code points up to the maximum permissible signed number available on the platform. However, Perl will not accept these from input streams unless lax rules are being used, and will warn (using the warning category &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt;, which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt;) if any are output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf34b110c57827c6b09abffd19d7c17fb58a109" translate="yes" xml:space="preserve">
          <source>The maximum number of UTF-8 bytes a single Unicode character can uppercase/lowercase/titlecase/fold into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc1808d3e3fb6de5739d08162d085e4fb2b2c51" translate="yes" xml:space="preserve">
          <source>The maximum number of parallel tests to run at any time. Which tests can be run in parallel is controlled by &lt;code&gt;rules&lt;/code&gt; . The default is to run only one test at a time.</source>
          <target state="translated">Максимальное количество параллельных тестов для запуска в любое время. Какие тесты можно запускать параллельно, определяется &lt;code&gt;rules&lt;/code&gt; . По умолчанию запускается только один тест за раз.</target>
        </trans-unit>
        <trans-unit id="406651585ee02adfd4eadd3dc163e4004c7e7bf5" translate="yes" xml:space="preserve">
          <source>The maximum number of parallel tests to run at any time. Which tests can be run in parallel is controlled by &lt;code&gt;rules&lt;/code&gt;. The default is to run only one test at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec24717c6af4893fa65de730b8ddea405e13134" translate="yes" xml:space="preserve">
          <source>The maximum number this construct can express is &lt;code&gt;\777&lt;/code&gt; . If you need a larger one, you need to use &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\o{}&lt;/a&gt; instead. If you meant two separate things, you need to separate them:</source>
          <target state="translated">Максимальное число, которое может выразить эта конструкция, равно &lt;code&gt;\777&lt;/code&gt; . Если вам нужен больший, вам нужно вместо него использовать &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\ o {}&lt;/a&gt; . Если вы имели в виду две разные вещи, вам нужно разделить их:</target>
        </trans-unit>
        <trans-unit id="7227c386d0e30465e8c341c159e2afa8f961c0f3" translate="yes" xml:space="preserve">
          <source>The maximum number this construct can express is &lt;code&gt;\777&lt;/code&gt;. If you need a larger one, you need to use &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\o{}&lt;/a&gt; instead. If you meant two separate things, you need to separate them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823e727fb7ce51ed0c50f11b0b5dce6f9f8c6422" translate="yes" xml:space="preserve">
          <source>The maximum size of a Storable header is currently 21 bytes. If the provided $buffer is only the first part of a Storable image it should at least be this long to ensure that read_magic() will recognize it as such.</source>
          <target state="translated">Максимальный размер заголовка Storable в настоящее время составляет 21 байт.Если предоставленный $buffer является только первой частью изображения Storable,то он должен быть,по крайней мере,таким длинным,чтобы функция read_magic()могла распознать его как таковой.</target>
        </trans-unit>
        <trans-unit id="54655c72af2839e9f037d863fc7638dac7966cf0" translate="yes" xml:space="preserve">
          <source>The maximum size of an extra field 65535 bytes.</source>
          <target state="translated">Максимальный размер дополнительного поля 65535 байт.</target>
        </trans-unit>
        <trans-unit id="60da8f51a4ded24731bf101a405dc42107509236" translate="yes" xml:space="preserve">
          <source>The maximum size of the Extra Field 65535 bytes.</source>
          <target state="translated">Максимальный размер Extra Field 65535 байт.</target>
        </trans-unit>
        <trans-unit id="51d29e4ee16b1b5f77f1b62a7cfc84201aec0810" translate="yes" xml:space="preserve">
          <source>The maximum system file descriptor, ordinarily 2. System file descriptors are passed to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;ed processes, while higher file descriptors are not. Also, during an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, system file descriptors are preserved even if the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; fails (ordinary file descriptors are closed before the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; is attempted). The close-on-exec status of a file descriptor will be decided according to the value of &lt;code&gt;$^F&lt;/code&gt; when the corresponding file, pipe, or socket was opened, not the time of the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Максимальный системный файловый дескриптор, обычно 2. Системные файловые дескрипторы передаются процессам &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; ed, а более высокие файловые дескрипторы - нет. Кроме того, во время &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; системные файловые дескрипторы сохраняются даже в случае сбоя &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; (обычные файловые дескрипторы закрываются до попытки &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; ). Статус закрытия дескриптора файла будет определяться в соответствии со значением &lt;code&gt;$^F&lt;/code&gt; при открытии соответствующего файла, канала или сокета, а не временем выполнения &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="255fcbaa29e8f59e394f504d9d5b97b78390691f" translate="yes" xml:space="preserve">
          <source>The maximum system file descriptor, ordinarily 2. System file descriptors are passed to &lt;code&gt;exec()&lt;/code&gt;ed processes, while higher file descriptors are not. Also, during an &lt;code&gt;open()&lt;/code&gt;, system file descriptors are preserved even if the &lt;code&gt;open()&lt;/code&gt; fails (ordinary file descriptors are closed before the &lt;code&gt;open()&lt;/code&gt; is attempted). The close-on-exec status of a file descriptor will be decided according to the value of &lt;code&gt;$^F&lt;/code&gt; when the corresponding file, pipe, or socket was opened, not the time of the &lt;code&gt;exec()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e89770735afbf4b1f68a8769fe96140987a421" translate="yes" xml:space="preserve">
          <source>The maximum width of a single UTF-8 encoded character, in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db9125f66ae949d81694c6e6210bfeb871e3d64e" translate="yes" xml:space="preserve">
          <source>The mechanism of translation of &lt;code&gt;\N{...}&lt;/code&gt; escapes is general and not hardwired into</source>
          <target state="translated">Механизм трансляции экранирования &lt;code&gt;\N{...}&lt;/code&gt; является общим и не встроен в</target>
        </trans-unit>
        <trans-unit id="15610051fc12501695115ef5aed4c6968c7a9267" translate="yes" xml:space="preserve">
          <source>The members whose names begin with &lt;code&gt;int_p_&lt;/code&gt; and &lt;code&gt;int_n_&lt;/code&gt; were added by POSIX.1-2008 and are only available on systems that support them.</source>
          <target state="translated">Члены, имена которых начинаются с &lt;code&gt;int_p_&lt;/code&gt; и &lt;code&gt;int_n_&lt;/code&gt; , были добавлены POSIX.1-2008 и доступны только в системах, которые их поддерживают.</target>
        </trans-unit>
        <trans-unit id="4d5d40b7966fb62c912a4471f016e0810caccade" translate="yes" xml:space="preserve">
          <source>The message attempts to include the name of the called subroutine. If the subroutine has been aliased, the subroutine's original name will be shown, regardless of what name the caller used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="003de5e9e6baa363e9c030caff26155e591e361d" translate="yes" xml:space="preserve">
          <source>The message for the diag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a832ceb4e1a37f34e093f08ce43b0057c15482" translate="yes" xml:space="preserve">
          <source>The message for the note.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0974f2e5536c89d5a7aa01e203cfd55eb3c162" translate="yes" xml:space="preserve">
          <source>The message will be taken from whatever locale would be used by &lt;code&gt;$!&lt;/code&gt;, and will be encoded in the SV in whatever manner would be used by &lt;code&gt;$!&lt;/code&gt;. The details of this process are subject to future change. Currently, the message is taken from the C locale by default (usually producing an English message), and from the currently selected locale when in the scope of the &lt;code&gt;use locale&lt;/code&gt; pragma. A heuristic attempt is made to decode the message from the locale's character encoding, but it will only be decoded as either UTF-8 or ISO-8859-1. It is always correctly decoded in a UTF-8 locale, usually in an ISO-8859-1 locale, and never in any other locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36545165ac282d6d6bbbc3b54b056ad82f2d5183" translate="yes" xml:space="preserve">
          <source>The message, either sent via &lt;code&gt;datasend&lt;/code&gt; or as the &lt;code&gt;MESSAGE&lt;/code&gt; parameter, must be in the format as described by RFC822 and must contain From:, Newsgroups: and Subject: headers.</source>
          <target state="translated">Сообщение, отправленное через &lt;code&gt;datasend&lt;/code&gt; или как параметр &lt;code&gt;MESSAGE&lt;/code&gt; , должно иметь формат, описанный в RFC822, и содержать заголовки From :, Newsgroups: и Subject :.</target>
        </trans-unit>
        <trans-unit id="ee89b7499807e434bb5f68dbb5e73957271240a3" translate="yes" xml:space="preserve">
          <source>The messages are in alphabetical order, without regard to upper or lower-case. Some of these messages are generic. Spots that vary are denoted with a %s or other printf-style escape. These escapes are ignored by the alphabetical order, as are all characters other than letters. To look up your message, just ignore anything that is not a letter.</source>
          <target state="translated">Сообщения расположены в алфавитном порядке,без учета верхнего или нижнего регистра.Некоторые из этих сообщений являются общими.Различные места обозначаются символом %s или другим выходом в стиле printf.Эти экваторы игнорируются в алфавитном порядке,как и все символы,отличные от букв.Чтобы просмотреть сообщение,просто проигнорируйте все,что не является буквой.</target>
        </trans-unit>
        <trans-unit id="e3b332cdd50b0075e2980a517442567c35047868" translate="yes" xml:space="preserve">
          <source>The messages from error exits from inside the Perl core are generally more serious, and are not suppressed.</source>
          <target state="translated">Сообщения об ошибках при выходе из ядра Perl,как правило,более серьезны и не подавляются.</target>
        </trans-unit>
        <trans-unit id="f4b9735187b885f7dd604f43a0be8de295177167" translate="yes" xml:space="preserve">
          <source>The meta facet contains all the meta-data attached to the event. In this case the &lt;code&gt;details&lt;/code&gt; field has no special meaning, but may be present if something sets the 'details' meta-key on the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af14bb7cef38c681cd522700a18f3c2e85c4645f" translate="yes" xml:space="preserve">
          <source>The metacharacter &lt;code&gt;&quot;|&quot;&lt;/code&gt; is used to match one thing or another. Thus</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1808948aa8eaa300120a3b2e59e72e75d61ea383" translate="yes" xml:space="preserve">
          <source>The metaconfig system has its own git repository. Please see its README file in &lt;a href=&quot;http://perl5.git.perl.org/metaconfig.git/&quot;&gt;http://perl5.git.perl.org/metaconfig.git/&lt;/a&gt; for more details.</source>
          <target state="translated">У системы metaconfig есть собственный репозиторий git. См. Его файл README на &lt;a href=&quot;http://perl5.git.perl.org/metaconfig.git/&quot;&gt;http://perl5.git.perl.org/metaconfig.git/&lt;/a&gt; для получения дополнительных сведений.</target>
        </trans-unit>
        <trans-unit id="bc1a65f602d496a5d44a6f0eb65c069b2917da93" translate="yes" xml:space="preserve">
          <source>The metaconfig system has its own git repository. Please see its README file in &lt;a href=&quot;https://github.com/Perl/metaconfig&quot;&gt;https://github.com/Perl/metaconfig&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef4d1d7707c31f137e3be5c9c3439a6616b37606" translate="yes" xml:space="preserve">
          <source>The metadata structure is a data element of type Map. This section describes valid keys within the Map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57044926f6935330105dc7655b75810e4319d78e" translate="yes" xml:space="preserve">
          <source>The metanotation &lt;code&gt;a{b,c,d}e&lt;/code&gt; is a shorthand for &lt;code&gt;abe ace ade&lt;/code&gt; . Left to right order is preserved, with results of matches being sorted separately at a low level to preserve this order. As a special case &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt; are passed undisturbed.</source>
          <target state="translated">Метанотация &lt;code&gt;a{b,c,d}e&lt;/code&gt; - это сокращение от &lt;code&gt;abe ace ade&lt;/code&gt; . Порядок слева направо сохраняется, а результаты совпадений сортируются отдельно на низком уровне для сохранения этого порядка. В качестве особого случая &lt;code&gt;{&lt;/code&gt; , &lt;code&gt;}&lt;/code&gt; и &lt;code&gt;{}&lt;/code&gt; передаются без изменений.</target>
        </trans-unit>
        <trans-unit id="9487974ec391513333e9625acd21a3a26e0c7e56" translate="yes" xml:space="preserve">
          <source>The metanotation &lt;code&gt;a{b,c,d}e&lt;/code&gt; is a shorthand for &lt;code&gt;abe ace ade&lt;/code&gt;. Left to right order is preserved, with results of matches being sorted separately at a low level to preserve this order. As a special case &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt; are passed undisturbed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3047e3773833dff832f2198e8a9edf5e427dcdc4" translate="yes" xml:space="preserve">
          <source>The method &lt;b&gt;simplify_name&lt;/b&gt; is equivalent to &lt;b&gt;basename&lt;/b&gt;, but also strips Perl-like extensions (.pm, .pl, .pod) and extensions like</source>
          <target state="translated">Метод &lt;b&gt;simpleify_name&lt;/b&gt; эквивалентен &lt;b&gt;basename&lt;/b&gt; , но также удаляет Perl-подобные расширения (.pm, .pl, .pod) и такие расширения, как</target>
        </trans-unit>
        <trans-unit id="81b66f93d3069f9e60e8cef6e91ea8cf83a141d7" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;pretty&lt;/code&gt; is doing object-to-string conversion, so it is natural to overload the operator &lt;code&gt;&quot;&quot;&lt;/code&gt; using this method. However, inside such a method it is not necessary to pretty-print the</source>
          <target state="translated">Метод &lt;code&gt;pretty&lt;/code&gt; выполняет преобразование объекта в строку, поэтому естественно перегрузить оператор &lt;code&gt;&quot;&quot;&lt;/code&gt; с помощью этого метода. Однако внутри такого метода нет необходимости красиво печатать</target>
        </trans-unit>
        <trans-unit id="a6763bc5ce44c1cfaff83e339121fc03fa4b9167" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;survey&lt;/code&gt; searches for POD documents in a given set of files and/or directories. This runs the search according to the various options set by the accessors above. (For example, if the &lt;code&gt;inc&lt;/code&gt; attribute is on, as it is by default, then the perl @INC directories are implicitly added to the list of directories (if any) that you specify.)</source>
          <target state="translated">&lt;code&gt;survey&lt;/code&gt; метода выполняет поиск документов POD в заданном наборе файлов и / или каталогов. Это запускает поиск в соответствии с различными параметрами, установленными указанными выше средствами доступа. (Например, если атрибут &lt;code&gt;inc&lt;/code&gt; включен по умолчанию, каталоги perl @INC неявно добавляются в список каталогов (если есть), который вы указываете.)</target>
        </trans-unit>
        <trans-unit id="c2594fdbf7af0dec9dd0b0469d5ba6b9ac83d4b7" translate="yes" xml:space="preserve">
          <source>The method forms return the object itself when called with arguments, so that they can be chained together nicely.</source>
          <target state="translated">Формы метода возвращают сам объект при вызове с аргументами,чтобы их можно было аккуратно связать вместе.</target>
        </trans-unit>
        <trans-unit id="2dce83e2cc72bad00d236d5c3647c5845395811f" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; $scalar, classname&lt;/code&gt; . Associates a new scalar instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">Метод, вызываемый командой &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; $scalar, classname&lt;/code&gt; . Связывает новый экземпляр скаляра с указанным классом. &lt;code&gt;LIST&lt;/code&gt; будет представлять дополнительные аргументы (по строкам &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; и соотечественников), необходимые для завершения ассоциации.</target>
        </trans-unit>
        <trans-unit id="1329855cb3bc4e49bb5ad4447529605d17972380" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; %hash, classname&lt;/code&gt; . Associates a new hash instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">Метод, вызываемый командой &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; %hash, classname&lt;/code&gt; . Связывает новый экземпляр хэша с указанным классом. &lt;code&gt;LIST&lt;/code&gt; будет представлять дополнительные аргументы (по строкам &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; и соотечественников), необходимые для завершения ассоциации.</target>
        </trans-unit>
        <trans-unit id="f4e115efd5b349da6e5daf0e7907f6b8a0251fea" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; *glob, classname&lt;/code&gt; . Associates a new glob instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">Метод, вызываемый командой &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; *glob, classname&lt;/code&gt; . Связывает новый экземпляр глобуса с указанным классом. &lt;code&gt;LIST&lt;/code&gt; будет представлять дополнительные аргументы (по строкам &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; и соотечественников), необходимые для завершения ассоциации.</target>
        </trans-unit>
        <trans-unit id="3c64476d97600b750453bf420a9f4075f0306d1d" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;tie $scalar, classname&lt;/code&gt;. Associates a new scalar instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf56df28d8dc9b4d15467c9f598303b09011b2d" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;tie %hash, classname&lt;/code&gt;. Associates a new hash instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef7e6fea27b8c9527a2ee7d3c51ad487105105d" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;tie *glob, classname&lt;/code&gt;. Associates a new glob instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf5b5c7ccd1b01e888481ba1e2326ba23ba62558" translate="yes" xml:space="preserve">
          <source>The method may be called as a function (this is the legacy interface) and will then use a singleton as invocant.</source>
          <target state="translated">Метод может быть вызван как функция (это наследственный интерфейс)и затем будет использовать одиночную кнопку в качестве инвоканта.</target>
        </trans-unit>
        <trans-unit id="a347cbeea5ef9dc7aa2915d6eb1498ed186d3546" translate="yes" xml:space="preserve">
          <source>The method must then return the object. While technically you can return any Perl scalar, you might have to enable the &lt;code&gt;allow_nonref&lt;/code&gt; setting to make that work in all cases, so better return an actual blessed reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219560b3e009187526f9cca6647b331f9670e08d" translate="yes" xml:space="preserve">
          <source>The method takes care not to use a HERE-doc end marker that appears in the typemap string itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8494bae7398a8984704473fee4ce9cba1c67c3" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; are not defined in &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. Tied hashes do not require presence of these methods, but if defined, the methods will be called in proper time, see &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;.</source>
          <target state="translated">Методы &lt;code&gt;UNTIE&lt;/code&gt; и &lt;code&gt;DESTROY&lt;/code&gt; не определены в &lt;b&gt;Tie :: Hash&lt;/b&gt; , &lt;b&gt;Tie :: StdHash&lt;/b&gt; или &lt;b&gt;Tie :: ExtraHash&lt;/b&gt; . Связанные хэши не требуют наличия этих методов, но, если они определены, методы будут вызываться своевременно, см. &lt;a href=&quot;../perltie&quot;&gt;Perltie&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef8892a6c7e1ed9417668a258714fa58aaa9de51" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; are not defined in &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. Tied hashes do not require presence of these methods, but if defined, the methods will be called in proper time, see &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0efdfb2d42a690264f248f711dbbf09fd69f9a" translate="yes" xml:space="preserve">
          <source>The methods POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE, and EXISTS are required if the perl operator with the corresponding (but lowercase) name is to operate on the tied array. The &lt;b&gt;Tie::Array&lt;/b&gt; class can be used as a base class to implement the first five of these in terms of the basic methods above. The default implementations of DELETE and EXISTS in &lt;b&gt;Tie::Array&lt;/b&gt; simply &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">Методы POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE и EXISTS необходимы, если оператор perl с соответствующим (но в нижнем регистре) именем должен работать с привязанным массивом. Класс &lt;b&gt;Tie :: Array&lt;/b&gt; можно использовать в качестве базового класса для реализации первых пяти из них в терминах базовых методов, описанных выше. Реализации DELETE и EXISTS по умолчанию в &lt;b&gt;Tie :: Array&lt;/b&gt; просто &lt;code&gt;croak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4a5e54d75cc63679c6ace9898dabb0095727d66" translate="yes" xml:space="preserve">
          <source>The methods POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE, and EXISTS are required if the perl operator with the corresponding (but lowercase) name is to operate on the tied array. The &lt;b&gt;Tie::Array&lt;/b&gt; class can be used as a base class to implement the first five of these in terms of the basic methods above. The default implementations of DELETE and EXISTS in &lt;b&gt;Tie::Array&lt;/b&gt; simply &lt;code&gt;croak&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca020c3e2bd3840f09ecda9c60cedd92ab50da2" translate="yes" xml:space="preserve">
          <source>The methods associated with a file might include &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Методы, связанные с файлом, могут включать &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9038e299e83dde3b869fda0661c2f473ffe7af89" translate="yes" xml:space="preserve">
          <source>The methods associated with a file might include &lt;code&gt;rename()&lt;/code&gt; and &lt;code&gt;write()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5263ae238fdcff040734aa4eb38a1f937d29acc1" translate="yes" xml:space="preserve">
          <source>The methods make the assumption that there are 24 hours in a day, 7 days in a week, 365.24225 days in a year and 12 months in a year. (from The Calendar FAQ at &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;)</source>
          <target state="translated">В этих методах предполагается, что 24 часа в сутки, 7 дней в неделе, 365,24225 дней в году и 12 месяцев в году. (из FAQ по календарю на &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="f3937d8a57bcf6a9fc84c7bb1157e33f7b1b81bb" translate="yes" xml:space="preserve">
          <source>The methods make the assumption that there are 24 hours in a day, 7 days in a week, 365.24225 days in a year and 12 months in a year. (from The Calendar FAQ at http://www.tondering.dk/claus/calendar.html)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59cd0464641ff6280d0d7597be80f4d79435c372" translate="yes" xml:space="preserve">
          <source>The methods provided by this package are designed to be used in conjunction with &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;. When MakeMaker writes a Makefile, it creates one or more objects that inherit their methods from a package &lt;a href=&quot;ExtUtils::MM&quot;&gt;MM&lt;/a&gt;. MM itself doesn't provide any methods, but it ISA ExtUtils::MM_Unix class. The inheritance tree of MM lets operating specific packages take the responsibility for all the methods provided by MM_Unix. We are trying to reduce the number of the necessary overrides by defining rather primitive operations within ExtUtils::MM_Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b489e4d842d7bd01e6f982c6cbb73f631b2bc2" translate="yes" xml:space="preserve">
          <source>The methods provided by this package are designed to be used in conjunction with ExtUtils::MakeMaker. When MakeMaker writes a Makefile, it creates one or more objects that inherit their methods from a package &lt;code&gt;MM&lt;/code&gt; . MM itself doesn't provide any methods, but it ISA ExtUtils::MM_Unix class. The inheritance tree of MM lets operating specific packages take the responsibility for all the methods provided by MM_Unix. We are trying to reduce the number of the necessary overrides by defining rather primitive operations within ExtUtils::MM_Unix.</source>
          <target state="translated">Методы, предоставляемые этим пакетом, предназначены для использования вместе с ExtUtils :: MakeMaker. Когда MakeMaker записывает Makefile, он создает один или несколько объектов, которые наследуют свои методы от пакета &lt;code&gt;MM&lt;/code&gt; . Сам MM не предоставляет никаких методов, но это класс ISA ExtUtils :: MM_Unix. Дерево наследования MM позволяет управлять конкретными пакетами, принимая на себя ответственность за все методы, предоставляемые MM_Unix. Мы пытаемся уменьшить количество необходимых переопределений, определяя довольно примитивные операции в ExtUtils :: MM_Unix.</target>
        </trans-unit>
        <trans-unit id="8c66ae4f45a17e24ec4e91baabbe3addbe06fe69" translate="yes" xml:space="preserve">
          <source>The methods return a status value. All return 0 on success. All return -1 to signify an error and set &lt;code&gt;$!&lt;/code&gt; to the exact error code. The return code 1 generally (but not always) means that the key specified did not exist in the database.</source>
          <target state="translated">Методы возвращают значение статуса. Все возвращают 0 в случае успеха. Все возвращают -1 для обозначения ошибки и устанавливают &lt;code&gt;$!&lt;/code&gt; к точному коду ошибки. Код возврата 1 обычно (но не всегда) означает, что указанный ключ не существует в базе данных.</target>
        </trans-unit>
        <trans-unit id="fbd4260de22fedf44d365a30940fb70d70e7661e" translate="yes" xml:space="preserve">
          <source>The methods return true if the argument is positive or negative, respectively. &lt;code&gt;NaN&lt;/code&gt; is neither positive nor negative, while &lt;code&gt;+inf&lt;/code&gt; counts as positive, and &lt;code&gt;-inf&lt;/code&gt; is negative. A &lt;code&gt;zero&lt;/code&gt; is neither positive nor negative.</source>
          <target state="translated">Методы возвращают истину, если аргумент положительный или отрицательный соответственно. &lt;code&gt;NaN&lt;/code&gt; не является ни положительным, ни отрицательным, в то время как &lt;code&gt;+inf&lt;/code&gt; считается положительным, а &lt;code&gt;-inf&lt;/code&gt; отрицательным. &lt;code&gt;zero&lt;/code&gt; не является ни положительным , ни отрицательным.</target>
        </trans-unit>
        <trans-unit id="6c2ef40bc1a0b74efb3bfbccd9cee9239eba6f64" translate="yes" xml:space="preserve">
          <source>The midpoint between London and Tokyo being</source>
          <target state="translated">В средней точке между Лондоном и Токио</target>
        </trans-unit>
        <trans-unit id="bbcb1c9041fb73d5b33a27311e97c3d17c5b0e33" translate="yes" xml:space="preserve">
          <source>The minimal implementation of the package &lt;code&gt;MyMaths&lt;/code&gt; would be something like this:</source>
          <target state="translated">Минимальная реализация пакета &lt;code&gt;MyMaths&lt;/code&gt; будет примерно такой:</target>
        </trans-unit>
        <trans-unit id="3d4726f2195d659bbd07fd552c77e45ca0215cb6" translate="yes" xml:space="preserve">
          <source>The minimal length of the match.</source>
          <target state="translated">Минимальная длина матча.</target>
        </trans-unit>
        <trans-unit id="4d621dfdcd896d4c7f5ef5df72bf41823f001388" translate="yes" xml:space="preserve">
          <source>The minimal string that will allow both the start of the string &lt;code&gt;'^'&lt;/code&gt; and the alternation to match is &lt;code&gt;Th&lt;/code&gt;, with the alternation &lt;code&gt;e|r&lt;/code&gt; matching &lt;code&gt;'e'&lt;/code&gt;. The second quantifier &lt;code&gt;.*&lt;/code&gt; is free to gobble up the rest of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a86715e4677adbc552d12f74a0aff8aa19f9b9f" translate="yes" xml:space="preserve">
          <source>The minimal string that will allow both the start of the string &lt;code&gt;^&lt;/code&gt; and the alternation to match is &lt;code&gt;Th&lt;/code&gt; , with the alternation &lt;code&gt;e|r&lt;/code&gt; matching &lt;code&gt;e&lt;/code&gt; . The second quantifier &lt;code&gt;.*&lt;/code&gt; is free to gobble up the rest of the string.</source>
          <target state="translated">Минимальная строка, которая позволит совпадать как начало строки &lt;code&gt;^&lt;/code&gt; ,так и чередование, - это &lt;code&gt;Th&lt;/code&gt; , а чередование &lt;code&gt;e|r&lt;/code&gt; соответствует &lt;code&gt;e&lt;/code&gt; . Второй квантификатор &lt;code&gt;.*&lt;/code&gt; Может поглотить оставшуюся часть строки.</target>
        </trans-unit>
        <trans-unit id="42ee81d06f4fac118ea52fe7a6d4f7afb844e686" translate="yes" xml:space="preserve">
          <source>The minimum prerequisites for the distribution, to which dynamic configuration will only add items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e954716b49cb8b56dd5f1434ce35c364bc034cbd" translate="yes" xml:space="preserve">
          <source>The minimum required version of Perl for this distribution.</source>
          <target state="translated">Минимально необходимая версия Perl для этого дистрибутива.</target>
        </trans-unit>
        <trans-unit id="8f285323eacf0d3787ce2842089aae064f612899" translate="yes" xml:space="preserve">
          <source>The minimum severity level set by &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; mode may be changed to be ERROR or higher in the future depending on the results of testing and further review.</source>
          <target state="translated">Минимальный уровень серьезности, установленный &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; в режиме &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; , может быть изменен на ERROR или выше в будущем в зависимости от результатов тестирования и дальнейшего анализа.</target>
        </trans-unit>
        <trans-unit id="a1189f16cd283f7a0c83693c3d814114bd713075" translate="yes" xml:space="preserve">
          <source>The minimum severity level set by &lt;code&gt;die&lt;/code&gt; in &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; mode may be changed to be ERROR or higher in the future depending on the results of testing and further review.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0eb7e9cbc117a074d8972fb43eb29ea9f494777" translate="yes" xml:space="preserve">
          <source>The minimum string length (in characters) required for the pattern to match. This is used to prune the search space by not bothering to match any closer to the end of a string than would allow a match. For instance there is no point in even starting the regex engine if the minlen is 10 but the string is only 5 characters long. There is no way that the pattern can match.</source>
          <target state="translated">Минимальная длина строки (в символах),необходимая для соответствия шаблона.Это используется для того,чтобы урезать пространство поиска,не беспокоясь о том,чтобы найти совпадение ближе к концу строки,чем это допустимо.Например,нет смысла даже запускать регекс-движок,если minlen равен 10,но длина строки составляет всего 5 символов.Нет способа,чтобы шаблон мог совпасть.</target>
        </trans-unit>
        <trans-unit id="210162554d25993f24361ef0d0eb6d7705ae9f1e" translate="yes" xml:space="preserve">
          <source>The mkpath() function provide the legacy interface of make_path() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to make_path().</source>
          <target state="translated">Функция mkpath()предоставляет наследственному интерфейсу make_path()другую интерпретацию передаваемых аргументов.В противном случае поведение и возвращаемое значение функции идентичны функции make_path().</target>
        </trans-unit>
        <trans-unit id="06ad56158c8fa5ced75a1aebddb172710774c3d6" translate="yes" xml:space="preserve">
          <source>The mode argument should be a string as would be passed to fopen/PerlIO_open. If it is NULL then - for legacy support - the code will (depending upon the platform and the implementation) either attempt to empirically determine the mode in which</source>
          <target state="translated">Аргументом режима должна быть строка,которая будет передана fopen/PerlIO_open.Если он равен NULL,то-для поддержки наследства-код будет (в зависимости от платформы и реализации)либо пытаться эмпирически определить режим,в котором</target>
        </trans-unit>
        <trans-unit id="a3c9e181407a3d8dbcbede503e296bb6515c64a6" translate="yes" xml:space="preserve">
          <source>The modern convention for OO modules is to always use &lt;code&gt;new&lt;/code&gt; as the name for the constructor, but there is no requirement to do so. Any subroutine that blesses a data structure into a class is a valid constructor in Perl.</source>
          <target state="translated">Современное соглашение для объектно-ориентированных модулей - всегда использовать &lt;code&gt;new&lt;/code&gt; в качестве имени конструктора, но в этом нет необходимости. Любая подпрограмма, добавляющая структуру данных в класс, является допустимым конструктором в Perl.</target>
        </trans-unit>
        <trans-unit id="3447af7744c6d54de16c62d9254e4d7db34879e8" translate="yes" xml:space="preserve">
          <source>The modern successor of &lt;code&gt;CJK.inf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a53357f11465725d38d814ff941d393401ed024" translate="yes" xml:space="preserve">
          <source>The module</source>
          <target state="translated">Модуль</target>
        </trans-unit>
        <trans-unit id="73f13a2108211624409b0cfacd9ef18c01b16a7a" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;Perl::Unsafe::Signals&quot;&gt;Perl::Unsafe::Signals&lt;/a&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e5705c3d4c65fd8c41a20a40b57ad45ad89ac2" translate="yes" xml:space="preserve">
          <source>The module actually implements most of an interface described by Larry Wall on the perl5-porters mailing list here: &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&lt;/a&gt;</source>
          <target state="translated">Модуль фактически реализует большую часть интерфейса, описанного Ларри Уоллом в списке рассылки perl5-porters здесь: &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbe2b6eee3b2ebdf5395a20e5b4843961160d7fa" translate="yes" xml:space="preserve">
          <source>The module actually implements most of an interface described by Larry Wall on the perl5-porters mailing list here: &lt;a href=&quot;https://www.nntp.perl.org/group/perl.perl5.porters/2000/01/msg5283.html&quot;&gt;https://www.nntp.perl.org/group/perl.perl5.porters/2000/01/msg5283.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eac150fbe415255f3cdb34d1744497bc9492853" translate="yes" xml:space="preserve">
          <source>The module also lets you save intermediate SHA states to a string. The</source>
          <target state="translated">Модуль также позволяет сохранять промежуточные SHA-состояния в строку..</target>
        </trans-unit>
        <trans-unit id="ee711fa1cc9e23459ad1dea67a4bc2640b9361b2" translate="yes" xml:space="preserve">
          <source>The module and its user have a contract, part of which is common law, and part of which is &quot;written&quot;. Part of the common law contract is that a module doesn't pollute any namespace it wasn't asked to. The written contract for the module (A.K.A. documentation) may make other provisions. But then you know when you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; RedefineTheWorld&lt;/code&gt; that you're redefining the world and willing to take the consequences.</source>
          <target state="translated">У модуля и его пользователя есть договор, часть которого является общим правом, а часть - &amp;laquo;письменным&amp;raquo;. Частью договора общего права является то, что модуль не загрязняет пространство имен, о котором не просили. Письменный контракт на модуль (документация AKA) может содержать другие положения. Но тогда вы знаете, когда &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; RedefineTheWorld&lt;/code&gt; что вы меняете определение мира и готовы принять на себя последствия.</target>
        </trans-unit>
        <trans-unit id="9372253e447b67364ad520e524aa1e247f7dc577" translate="yes" xml:space="preserve">
          <source>The module and its user have a contract, part of which is common law, and part of which is &quot;written&quot;. Part of the common law contract is that a module doesn't pollute any namespace it wasn't asked to. The written contract for the module (A.K.A. documentation) may make other provisions. But then you know when you &lt;code&gt;use RedefineTheWorld&lt;/code&gt; that you're redefining the world and willing to take the consequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f631dbc58be0710de0b64e0128de801aadc778" translate="yes" xml:space="preserve">
          <source>The module appropriate for the current OS is automatically loaded by File::Spec. Since some modules (like VMS) make use of facilities available only under that OS, it may not be possible to load all modules under all operating systems.</source>
          <target state="translated">Модуль,соответствующий текущей операционной системе,автоматически загружается с помощью File::Spec.Так как некоторые модули (например,VMS)используют возможности,доступные только под данной ОС,загрузка всех модулей под всеми операционными системами может быть невозможна.</target>
        </trans-unit>
        <trans-unit id="f14f53ac2830f28434b0714747d843bf7a9d032c" translate="yes" xml:space="preserve">
          <source>The module author loves to hear how &lt;code&gt;autodie&lt;/code&gt; has made your life better (or worse). Feedback can be sent to &amp;lt;pjf@perltraining.com.au&amp;gt;.</source>
          <target state="translated">Автор модуля любит слышать, как &lt;code&gt;autodie&lt;/code&gt; сделал вашу жизнь лучше (или хуже). Отзывы можно отправлять по адресу &amp;lt;pjf@perltraining.com.au&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="64e716d94d3201717e95856fa71dba02b691c1e4" translate="yes" xml:space="preserve">
          <source>The module functionality relies on symbolic references, so things will break under 'use strict' unless 'no strict &quot;refs&quot;' is also specified.</source>
          <target state="translated">Функциональность модуля основана на символических ссылках,поэтому в разделе &quot;use strict&quot;,если не указано также &quot;no strict refs&quot;,вещи будут ломаться.</target>
        </trans-unit>
        <trans-unit id="0003d7a83a288e163c978c48b4832ab6428ef2d5" translate="yes" xml:space="preserve">
          <source>The module is not entirely round-trip safe: For example it currently simply strips all comments. The order of entries in the maps is, however, preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34dfe6e94b964deab3088dd9f024d26797644959" translate="yes" xml:space="preserve">
          <source>The module is used to replace common UNIX commands. In all cases the functions work from @ARGV rather than taking arguments. This makes them easier to deal with in Makefiles. Call them like this:</source>
          <target state="translated">Модуль используется для замены обычных UNIX-команд.Во всех случаях функции работают из @ARGV,а не принимают аргументы.Это облегчает работу с ними в Makefiles.Вызовите их так:</target>
        </trans-unit>
        <trans-unit id="7b2c2d003f5a465317ebb185dd8468c1c69f2ab8" translate="yes" xml:space="preserve">
          <source>The module itself never broke, you do not need to upgrade.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a785d24a660af5bf727090a58cdad6783dbc670b" translate="yes" xml:space="preserve">
          <source>The module itself works fine, there is no need to upgrade.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c671baea2f821aba32cfc72c5c947bba8fda15dc" translate="yes" xml:space="preserve">
          <source>The module might issue the following warnings:</source>
          <target state="translated">Модуль может выдавать следующие предупреждения:</target>
        </trans-unit>
        <trans-unit id="06580747828c7d751b4066d4d4c51e0e99e3ed97" translate="yes" xml:space="preserve">
          <source>The module that implements the canned filter can take one of two forms. Here is a template for the first</source>
          <target state="translated">Модуль,реализующий консервированный фильтр,может принимать одну из двух форм.Вот шаблон для первой</target>
        </trans-unit>
        <trans-unit id="aa3f15cb2c51087f06437c33aa4d5adadaa3850c" translate="yes" xml:space="preserve">
          <source>The module will auto-detect which, if any, of the supported compression formats is being used.</source>
          <target state="translated">Модуль будет автоматически определять,какой из поддерживаемых форматов сжатия используется,если таковые имеются.</target>
        </trans-unit>
        <trans-unit id="f166adc5fd8c563e508f523c65a82ae50be2d86f" translate="yes" xml:space="preserve">
          <source>The month (&lt;code&gt;mon&lt;/code&gt; ), weekday (&lt;code&gt;wday&lt;/code&gt; ), and yearday (&lt;code&gt;yday&lt;/code&gt; ) begin at zero,</source>
          <target state="translated">Месяц ( &lt;code&gt;mon&lt;/code&gt; ), день недели ( &lt;code&gt;wday&lt;/code&gt; ) и день года ( &lt;code&gt;yday&lt;/code&gt; ) начинаются с нуля,</target>
        </trans-unit>
        <trans-unit id="716f3ac895408852fbfe14ab4075855f3cc5828e" translate="yes" xml:space="preserve">
          <source>The month (&lt;code&gt;mon&lt;/code&gt;), weekday (&lt;code&gt;wday&lt;/code&gt;), and yearday (&lt;code&gt;yday&lt;/code&gt;) begin at zero,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7976bab032857556f1afeeb5486bc37536242264" translate="yes" xml:space="preserve">
          <source>The months and years can be negative for subtractions. Note that there is some &quot;strange&quot; behaviour when adding and subtracting months at the ends of months. Generally when the resulting month is shorter than the starting month then the number of overlap days is added. For example subtracting a month from 2008-03-31 will not result in 2008-02-31 as this is an impossible date. Instead you will get 2008-03-02. This appears to be consistent with other date manipulation tools.</source>
          <target state="translated">Месяцы и годы могут быть отрицательными для вычитаний.Обратите внимание,что существует некоторое &quot;странное&quot; поведение при сложении и вычитании месяцев в конце месяцев.Обычно,когда полученный месяц короче,чем начальный,добавляется количество дней перекрытия.Например,вычитание месяца из 2008-03-31 не приведет к 2008-02-31,так как это невозможная дата.Вместо этого вы получите 2008-03-02.Похоже,что это согласуется с другими инструментами манипулирования датами.</target>
        </trans-unit>
        <trans-unit id="467ee849edeaf9f54792730271f84d84084b5500" translate="yes" xml:space="preserve">
          <source>The more modern form of version assignment, with 3 (or potentially more) integers separated by decimal points (e.g. v1.2.3). This is the form that Perl itself has used since 5.6.0 was released. The leading 'v' is now strongly recommended for clarity, and will throw a warning in a future release if omitted. A leading 'v' character is required to pass the &lt;a href=&quot;#is_strict%28%29&quot;&gt;&quot;is_strict()&quot;&lt;/a&gt; test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9450d19149fb47c1c53f97698b4be633a15d56" translate="yes" xml:space="preserve">
          <source>The more you think about interfacing between two languages, the more you'll realize that the majority of programmer effort has to go into converting between the data structures that are native to either of the languages involved. This trumps other matter such as differing calling conventions because the problem space is so much greater. There are simply more ways to shove data into memory than there are ways to implement a function call.</source>
          <target state="translated">Чем больше вы задумываетесь о взаимодействии между двумя языками,тем больше вы понимаете,что большая часть усилий программиста должна быть направлена на преобразование между структурами данных,которые являются родными для любого из рассматриваемых языков.Это превосходит другие вопросы,такие как различные соглашения о вызовах,потому что проблемное пространство намного больше.Просто существует больше способов запихивания данных в память,чем способов реализации вызова функции.</target>
        </trans-unit>
        <trans-unit id="8176a4ffeb356c4a7a23ddcef37f49bf2bb9d8e2" translate="yes" xml:space="preserve">
          <source>The mortal routines are not just for SVs; AVs and HVs can be made mortal by passing their address (type-casted to &lt;code&gt;SV*&lt;/code&gt; ) to the &lt;code&gt;sv_2mortal&lt;/code&gt; or &lt;code&gt;sv_mortalcopy&lt;/code&gt; routines.</source>
          <target state="translated">Смертные рутины предназначены не только для SV; AV и HV можно сделать смертными, передав их адрес (приведенный к &lt;code&gt;SV*&lt;/code&gt; ) процедурам &lt;code&gt;sv_2mortal&lt;/code&gt; или &lt;code&gt;sv_mortalcopy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="caf6b1916b41e472c1ad4cc38efc1ebb428fd15c" translate="yes" xml:space="preserve">
          <source>The mortal routines are not just for SVs; AVs and HVs can be made mortal by passing their address (type-casted to &lt;code&gt;SV*&lt;/code&gt;) to the &lt;code&gt;sv_2mortal&lt;/code&gt; or &lt;code&gt;sv_mortalcopy&lt;/code&gt; routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a1cfa37e915685db47ff38f6021965013b98c8b" translate="yes" xml:space="preserve">
          <source>The most common CPAN version numbering scheme looks like this:</source>
          <target state="translated">Наиболее распространенная схема нумерации версий CPAN выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="d13f6c55db0d43d578a52888c54a47f93bad3e7e" translate="yes" xml:space="preserve">
          <source>The most common context-specific hints are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c4361ab99106fa73a1bb41dd2c636e6a27fcbec" translate="yes" xml:space="preserve">
          <source>The most common example of this is changing the current working directory using &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;. One thread calls &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;, and the working directory of all the threads changes.</source>
          <target state="translated">Самый распространенный пример этого - изменение текущего рабочего каталога с помощью &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; . Один поток вызывает &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; , и рабочий каталог всех потоков изменяется.</target>
        </trans-unit>
        <trans-unit id="c1920ebe5b8490b9051b66a85a68049c7044d116" translate="yes" xml:space="preserve">
          <source>The most common example of this is changing the current working directory using &lt;code&gt;chdir()&lt;/code&gt;. One thread calls &lt;code&gt;chdir()&lt;/code&gt;, and the working directory of all the threads changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d1fc7a0fdb4e15b4bc8d9defba4491def9b679" translate="yes" xml:space="preserve">
          <source>The most common git command you will use will probably be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7e55ecc01719c5e313506a020593317cb7d856" translate="yes" xml:space="preserve">
          <source>The most common such DOS devices include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f63cc6de2a2448196e1a86a35300d77fbd9cdf9" translate="yes" xml:space="preserve">
          <source>The most common uses of the interactive modes are</source>
          <target state="translated">Наиболее часто используются интерактивные режимы</target>
        </trans-unit>
        <trans-unit id="3f3dfdc5e3f12eaa9aae95ba108f269ad1f91764" translate="yes" xml:space="preserve">
          <source>The most common way to create an object is to pass in key/value pairs where each key is an attribute and each value is what you want assigned to that attribute. No checking is done to verify the attributes or values are valid, you may do that in &lt;code&gt;init()&lt;/code&gt; if desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3870e4765effd8ab5e5da52360ab236ece22162c" translate="yes" xml:space="preserve">
          <source>The most commonly used of these functions is &lt;code&gt;Perl_sv_dump&lt;/code&gt; ; it's used for dumping SVs, AVs, HVs, and CVs. The &lt;code&gt;Devel::Peek&lt;/code&gt; module calls &lt;code&gt;sv_dump&lt;/code&gt; to produce debugging output from Perl-space, so users of that module should already be familiar with its format.</source>
          <target state="translated">Наиболее часто используемая из этих функций - &lt;code&gt;Perl_sv_dump&lt;/code&gt; ; он используется для сброса SV, AV, HV и CV. В &lt;code&gt;Devel::Peek&lt;/code&gt; модуль вызывает &lt;code&gt;sv_dump&lt;/code&gt; производить отладку вывода из Perl-пространства, поэтому пользователи этого модуля уже должны быть знакомы с его форматом.</target>
        </trans-unit>
        <trans-unit id="40e2d355a29a78e1dd4f49324b9dbebe996e6a33" translate="yes" xml:space="preserve">
          <source>The most commonly used of these functions is &lt;code&gt;Perl_sv_dump&lt;/code&gt;; it's used for dumping SVs, AVs, HVs, and CVs. The &lt;code&gt;Devel::Peek&lt;/code&gt; module calls &lt;code&gt;sv_dump&lt;/code&gt; to produce debugging output from Perl-space, so users of that module should already be familiar with its format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3104b20dd3af96ae7f833de8c6d7e1e79108b35" translate="yes" xml:space="preserve">
          <source>The most convenient way of installing a binary distribution of perl is via perl installer</source>
          <target state="translated">Наиболее удобный способ установки двоичного дистрибутива perl-через установщик perl.</target>
        </trans-unit>
        <trans-unit id="8449f9a2d2191f3c7392f9226647d2910704473a" translate="yes" xml:space="preserve">
          <source>The most efficient way is using &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; and &lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;. This is faster than using &lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; when taking many, many strings. It is slower for just a few.</source>
          <target state="translated">Самый эффективный способ - использовать &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; and &lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt; . Это быстрее, чем использование &lt;a href=&quot;functions/substr&quot;&gt;substr,&lt;/a&gt; когда берется много-много строк. Это медленнее всего на немногих.</target>
        </trans-unit>
        <trans-unit id="e62c7de4b0c0c77c458201d125462fa3d57ea6f5" translate="yes" xml:space="preserve">
          <source>The most efficient way is using &lt;a href=&quot;perlfunc#pack&quot;&gt;pack()&lt;/a&gt; and &lt;a href=&quot;perlfunc#unpack&quot;&gt;unpack()&lt;/a&gt;. This is faster than using &lt;a href=&quot;perlfunc#substr&quot;&gt;substr()&lt;/a&gt; when taking many, many strings. It is slower for just a few.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee8f017f47cf02290cdcd6ac5e270d04e302d38" translate="yes" xml:space="preserve">
          <source>The most general way to do this is to cast them to a UV or IV, and print as in the &lt;a href=&quot;#Formatted-Printing-of-IVs%2C-UVs%2C-and-NVs&quot;&gt;previous section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c40808afd7fc4cc79463965386f4682ff94dfa" translate="yes" xml:space="preserve">
          <source>The most hairy case</source>
          <target state="translated">Самый волосатый случай</target>
        </trans-unit>
        <trans-unit id="51dfbd93c1252c67b5797f63c0a32f35baffd72d" translate="yes" xml:space="preserve">
          <source>The most important Perl parsing rule is the first one discussed below: when processing a quoted construct, Perl first finds the end of that construct, then interprets its contents. If you understand this rule, you may skip the rest of this section on the first reading. The other rules are likely to contradict the user's expectations much less frequently than this first one.</source>
          <target state="translated">Самое важное правило разбора Perl-это первое правило,рассмотренное ниже:при обработке цитируемой конструкции Perl сначала находит конец этой конструкции,а затем интерпретирует ее содержимое.Если вы понимаете это правило,вы можете пропустить оставшуюся часть этого раздела при первом чтении.Остальные правила,скорее всего,будут гораздо реже противоречить ожиданиям пользователя,чем это первое правило.</target>
        </trans-unit>
        <trans-unit id="aef7d8dbf9d828ab96b855e0061e1f04b9541021" translate="yes" xml:space="preserve">
          <source>The most important attribute of a socket, like your telephone&amp;rsquo;s telephone number. Typically an IP address. See also &lt;b&gt;port&lt;/b&gt;.</source>
          <target state="translated">Самый важный атрибут розетки, например, номер телефона. Обычно это IP-адрес. См. Также &lt;b&gt;порт&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="10d61cb4054b3dd458a76a9b2241b8875252cd6d" translate="yes" xml:space="preserve">
          <source>The most important of which are probably &lt;code&gt;GV_ADD&lt;/code&gt; and &lt;code&gt;SVf_UTF8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a25c59d901462fca0083edfc964d9c8bf518a04" translate="yes" xml:space="preserve">
          <source>The most important of which are probably GV_ADD and SVf_UTF8.</source>
          <target state="translated">Наиболее важными из них,вероятно,являются GV_ADD и SVf_UTF8.</target>
        </trans-unit>
        <trans-unit id="0626c5878256026e37d6cadc7a0a5c68ea6109bd" translate="yes" xml:space="preserve">
          <source>The most important of which is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aae52fef16fc25bcc3b6593dc3391e48196f1ad" translate="yes" xml:space="preserve">
          <source>The most important thing is to run your programs under the &lt;b&gt;-w&lt;/b&gt; flag at all times. You may turn it off explicitly for particular portions of code via the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;code&gt;$^W&lt;/code&gt; variable if you must. You should also always run under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; or know the reason why not. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; sigtrap&lt;/code&gt; and even &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; diagnostics&lt;/code&gt; pragmas may also prove useful.</source>
          <target state="translated">Самое главное - всегда запускать ваши программы с флагом &lt;b&gt;-w&lt;/b&gt; . Вы можете отключить его в явном виде для отдельных участков коды через &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; прагмы или &lt;code&gt;$^W&lt;/code&gt; переменных , если необходимо. Вы также должны всегда работать в режиме &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; или знать причину, по которой нет. Также могут оказаться полезными &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; sigtrap&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; sigtrap и даже &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; diagnostics&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c3b2954acd0c4fdd7e8575f6e05f126659f29cc" translate="yes" xml:space="preserve">
          <source>The most important thing is to use &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; in all your code or know the reason why not to. You may turn them off explicitly for particular portions of code via &lt;code&gt;no warnings&lt;/code&gt; or &lt;code&gt;no strict&lt;/code&gt;, and this can be limited to the specific warnings or strict features you wish to disable. The &lt;b&gt;-w&lt;/b&gt; flag and &lt;code&gt;$^W&lt;/code&gt; variable should not be used for this purpose since they can affect code you use but did not write, such as modules from core or CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6be7df730b69bf2abfbfef25c9c73eef66cdf79" translate="yes" xml:space="preserve">
          <source>The most important thing to understand about all data structures in Perl--including multidimensional arrays--is that even though they might appear otherwise, Perl &lt;code&gt;@ARRAY&lt;/code&gt; s and &lt;code&gt;%HASH&lt;/code&gt; es are all internally one-dimensional. They can hold only scalar values (meaning a string, number, or a reference). They cannot directly contain other arrays or hashes, but instead contain</source>
          <target state="translated">Самая важная вещь, которую нужно понимать обо всех структурах данных в Perl, включая многомерные массивы, заключается в том, что даже если они могут выглядеть иначе, Perl &lt;code&gt;@ARRAY&lt;/code&gt; и &lt;code&gt;%HASH&lt;/code&gt; es внутренне одномерны. Они могут содержать только скалярные значения (т.е. строку, число или ссылку). Они не могут напрямую содержать другие массивы или хэши, но вместо этого содержат</target>
        </trans-unit>
        <trans-unit id="787b225130f60b5479ecb7c71a8dc7b419116101" translate="yes" xml:space="preserve">
          <source>The most important thing to understand about all data structures in Perl--including multidimensional arrays--is that even though they might appear otherwise, Perl &lt;code&gt;@ARRAY&lt;/code&gt;s and &lt;code&gt;%HASH&lt;/code&gt;es are all internally one-dimensional. They can hold only scalar values (meaning a string, number, or a reference). They cannot directly contain other arrays or hashes, but instead contain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5f029eca08711d302dd8f17b7e7f9e635b1ec8" translate="yes" xml:space="preserve">
          <source>The most popular books</source>
          <target state="translated">Самые популярные книги</target>
        </trans-unit>
        <trans-unit id="c77ae4b23596713f5e5db719e4b12df8a45dd104" translate="yes" xml:space="preserve">
          <source>The most practical use is likely to specify that some tests are not &quot;parallel-ready&quot;. Since mentioning a file with --rules doesn't cause it to be selected to run as a test, you can &quot;set and forget&quot; some rules preferences in your .proverc file. Then you'll be able to take maximum advantage of the performance benefits of parallel testing, while some exceptions are still run in parallel.</source>
          <target state="translated">Наиболее практическое применение,скорее всего,указывает на то,что некоторые тесты не являются &quot;готовыми к параллелям&quot;.Поскольку упоминание файла с помощью --rules не приводит к тому,что он будет выбран для запуска в качестве теста,вы можете &quot;установить и забыть&quot; некоторые предпочтения правил в вашем .proverc файле.Тогда вы сможете максимально использовать преимущества параллельного тестирования,в то время как некоторые исключения все еще выполняются параллельно.</target>
        </trans-unit>
        <trans-unit id="6f276b3b1a0cf0e0ed49a901109064669a604004" translate="yes" xml:space="preserve">
          <source>The most preferable one is &quot;The Default Unicode Collation Element Table&quot; (aka DUCET), available from the Unicode Consortium's website:</source>
          <target state="translated">Наиболее предпочтительным является &quot;Таблица элементов сверки Юникода по умолчанию&quot; (также известная как DUCET),доступная на сайте Консорциума Юникод:</target>
        </trans-unit>
        <trans-unit id="1a2b184063d0bc0a35feb7fb346e45c3d6648eb5" translate="yes" xml:space="preserve">
          <source>The most recent development releases of Perl have been experimenting with removing Perl's dependency on the &quot;normal&quot; standard I/O suite and allowing other stdio implementations to be used. This involves creating a new abstraction layer that then calls whichever implementation of stdio Perl was compiled with. All XSUBs should now use the functions in the PerlIO abstraction layer and not make any assumptions about what kind of stdio is being used.</source>
          <target state="translated">Последние разработки Perl экспериментировали с удалением зависимости Perl от &quot;нормального&quot; стандартного набора входов/выходов и позволяли использовать другие stdio-реализации.Это включает в себя создание нового абстрактного слоя,который затем вызывает любую реализацию stdio Perl,с которой был скомпилирован.Все XSUB теперь должны использовать функции уровня абстракции PerlIO и не делать никаких предположений о том,какой тип stdio используется.</target>
        </trans-unit>
        <trans-unit id="d790d27d68eef3be56d3d5afa1a5d1f30d794f18" translate="yes" xml:space="preserve">
          <source>The most recent upgrade to the PA-RISC design, it added support for 64-bit integer data.</source>
          <target state="translated">В последнем обновлении дизайна PA-RISC была добавлена поддержка 64-битных целочисленных данных.</target>
        </trans-unit>
        <trans-unit id="0603f466834b0d6d823bdd46c3606b7ca755f71a" translate="yes" xml:space="preserve">
          <source>The most recent version of this module, including documentation and any news of importance, will be available at</source>
          <target state="translated">Самая последняя версия этого модуля,включая документацию и любые важные новости,будет доступна по адресу</target>
        </trans-unit>
        <trans-unit id="f4a085ad231e217eed37777279430f48e1cf87a2" translate="yes" xml:space="preserve">
          <source>The most significant information in the output is about the particular</source>
          <target state="translated">Наиболее значимая информация на выходе-это о том.</target>
        </trans-unit>
        <trans-unit id="9de43c038dc457f71dc272efc26e8a4eb0e6b17e" translate="yes" xml:space="preserve">
          <source>The most simple options are the ones that take no values. Their mere presence on the command line enables the option. Popular examples are:</source>
          <target state="translated">Самые простые варианты-это те,которые не берут никаких значений.Их простое присутствие в командной строке позволяет включить опцию.Популярные примеры:</target>
        </trans-unit>
        <trans-unit id="fe61ded48d4439fb9787ec0d115995f08935a048" translate="yes" xml:space="preserve">
          <source>The most useful option the cross referencer has is to save the report to a separate file. For instance, to save the report on</source>
          <target state="translated">Самая полезная опция,которой обладает кросс-справочник-это сохранение отчета в отдельный файл.Например,чтобы сохранить отчет по</target>
        </trans-unit>
        <trans-unit id="762e20af8acff77775848b01e093c2cac3013ec4" translate="yes" xml:space="preserve">
          <source>The most useful types that will be returned are:</source>
          <target state="translated">Наиболее полезные типы,которые будут возвращены:</target>
        </trans-unit>
        <trans-unit id="a4f13e9fd0d66b114f604fe2129d7ad6d576d1c5" translate="yes" xml:space="preserve">
          <source>The movement of bits left or right in a computer word, which has the effect of multiplying or dividing by a power of 2.</source>
          <target state="translated">Движение битов влево или вправо в компьютерном слове,которое имеет эффект умножения или деления на силу 2.</target>
        </trans-unit>
        <trans-unit id="811ee2e71fefd4dbb8ec994c3d2df771d4653871" translate="yes" xml:space="preserve">
          <source>The multiple-bracket form does not affect the interpretation of the contents of the formatting code, only how it must end. That means that the examples above are also exactly the same as this:</source>
          <target state="translated">Форма с несколькими скобками не влияет на интерпретацию содержимого кода форматирования,а только на то,как он должен заканчиваться.Это означает,что примеры,приведенные выше,также точно такие же:</target>
        </trans-unit>
        <trans-unit id="b62777fe39744a74b7fc65bfce887b1ed7aeecd0" translate="yes" xml:space="preserve">
          <source>The mutators for flags all return the JSON::PP object again and thus calls can be chained:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2632e91c7e1b901a77d044556dbd4ff9d5c87be" translate="yes" xml:space="preserve">
          <source>The name</source>
          <target state="translated">Название</target>
        </trans-unit>
        <trans-unit id="db6539b7ba93a9d46c820cb8d93cf44ff14b7c45" translate="yes" xml:space="preserve">
          <source>The name &quot;WinXP/.Net&quot; is used for historical reasons only, to maintain backwards compatibility of the Win32 module. Windows .NET Server has been renamed as Windows 2003 Server before final release and uses a different major/minor version number than Windows XP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32c3c3ac333fcf1879195759e18947b403def2d" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;new&lt;/code&gt; isn't special. We could name our constructor something else:</source>
          <target state="translated">Имя &lt;code&gt;new&lt;/code&gt; не особенное. Мы могли бы назвать наш конструктор как-нибудь иначе:</target>
        </trans-unit>
        <trans-unit id="381ffb5c7c9337af9dd775ed33da7e16dd88d27a" translate="yes" xml:space="preserve">
          <source>The name in the IANA registry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="316e7deb3997f109974511d20499a1d93aa6493c" translate="yes" xml:space="preserve">
          <source>The name is returned as a mortal SV.</source>
          <target state="translated">Имя возвращается в виде смертного СВ.</target>
        </trans-unit>
        <trans-unit id="e84fcc4ee47e1e1b5639888428e055c00959431a" translate="yes" xml:space="preserve">
          <source>The name may contain embedded E&amp;lt;&amp;gt; and Z&amp;lt;&amp;gt; formatting codes, and the section, anchor text, and inferred anchor text may contain any formatting codes. Any double quotes around the section are removed as part of the parsing, as is any leading or trailing whitespace.</source>
          <target state="translated">Имя может содержать встроенные коды форматирования E &amp;lt;&amp;gt; и Z &amp;lt;&amp;gt;, а раздел, текст привязки и предполагаемый текст привязки могут содержать любые коды форматирования. Любые двойные кавычки вокруг раздела удаляются как часть синтаксического анализа, как и любые начальные или конечные пробелы.</target>
        </trans-unit>
        <trans-unit id="8ada838033f411154fe022f162bc95bf1ac56e8a" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;(*SKIP:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; pattern has special significance. If a &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; was encountered while matching, then it is that position which is used as the &quot;skip point&quot;. If no &lt;code&gt;(*MARK)&lt;/code&gt; of that name was encountered, then the &lt;code&gt;(*SKIP)&lt;/code&gt; operator has no effect. When used without a name the &quot;skip point&quot; is where the match point was when executing the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f683b00c5db230ebae95056480292ae0fa37d30" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;(*SKIP:NAME)&lt;/code&gt; pattern has special significance. If a &lt;code&gt;(*MARK:NAME)&lt;/code&gt; was encountered while matching, then it is that position which is used as the &quot;skip point&quot;. If no &lt;code&gt;(*MARK)&lt;/code&gt; of that name was encountered, then the &lt;code&gt;(*SKIP)&lt;/code&gt; operator has no effect. When used without a name the &quot;skip point&quot; is where the match point was when executing the (*SKIP) pattern.</source>
          <target state="translated">Имя шаблона &lt;code&gt;(*SKIP:NAME)&lt;/code&gt; имеет особое значение. Если &lt;code&gt;(*MARK:NAME)&lt;/code&gt; был обнаружен во время сопоставления, то именно эта позиция используется в качестве &amp;laquo;точки пропуска&amp;raquo;. Если &lt;code&gt;(*MARK)&lt;/code&gt; с таким именем не встречено, то оператор &lt;code&gt;(*SKIP)&lt;/code&gt; не действует. При использовании без имени &amp;laquo;точка пропуска&amp;raquo; - это точка совпадения при выполнении шаблона (* SKIP).</target>
        </trans-unit>
        <trans-unit id="4ffbfa835ecb6cb544ad106cd35f35360cfc377b" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;result_class&lt;/code&gt; . Defaults to &lt;code&gt;App::Prove::State::Result&lt;/code&gt; .</source>
          <target state="translated">Имя &lt;code&gt;result_class&lt;/code&gt; . По умолчанию &lt;code&gt;App::Prove::State::Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b922baa1630e5f6c97eeff342a7feb7ab689a79" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;result_class&lt;/code&gt;. Defaults to &lt;code&gt;App::Prove::State::Result&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="689345a6c608b08f0da8c40d1de1f0d6ad537fb4" translate="yes" xml:space="preserve">
          <source>The name of the C subroutine generated which will return the constants. The default is</source>
          <target state="translated">Имя сгенерированной подпрограммы C,которая вернет константы.По умолчанию</target>
        </trans-unit>
        <trans-unit id="24928164de71defca77ef40b5800aabbee56b274" translate="yes" xml:space="preserve">
          <source>The name of the Makefile to be produced. This is used for the second Makefile that will be produced for the MAP_TARGET.</source>
          <target state="translated">Название Макифайла,который будет производиться.Оно используется для второго Makefile,который будет создан для MAP_TARGET.</target>
        </trans-unit>
        <trans-unit id="586bd0a2b6cddbba1d51a20c05e33d4e435a88ba" translate="yes" xml:space="preserve">
          <source>The name of the OP, or 'ex-foo' if the OP is a null that used to be a foo.</source>
          <target state="translated">Название операционной системы,или &quot;ex-foo&quot;,если операционная система является нулевой,которая раньше была фу.</target>
        </trans-unit>
        <trans-unit id="5c8f940ac3ab77f3cca6bf5d7c2332906bee0772" translate="yes" xml:space="preserve">
          <source>The name of the array containing the &lt;b&gt;argument&lt;/b&gt;&lt;b&gt;vector&lt;/b&gt; from the command line. If you use the empty &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator, &lt;code&gt;ARGV&lt;/code&gt; is the name of both the &lt;b&gt;filehandle&lt;/b&gt; used to traverse the arguments and the &lt;b&gt;scalar&lt;/b&gt; containing the name of the current input file.</source>
          <target state="translated">Имя массива, содержащего &lt;b&gt;вектор &lt;/b&gt;&lt;b&gt;аргументов&lt;/b&gt; из командной строки. Если вы используете пустой оператор &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;ARGV&lt;/code&gt; - это имя как &lt;b&gt;дескриптора файла,&lt;/b&gt; используемого для обхода аргументов, так и &lt;b&gt;скаляра,&lt;/b&gt; содержащего имя текущего входного файла.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c0ef9637fb40c44d741c359416d9acc461c4754b" translate="yes" xml:space="preserve">
          <source>The name of the capability to be output.</source>
          <target state="translated">Имя возможности для вывода.</target>
        </trans-unit>
        <trans-unit id="25678c01479ff57e49b16538b63d4932cacd981b" translate="yes" xml:space="preserve">
          <source>The name of the class to use to aggregate test results. The default is &lt;a href=&quot;TAP::Parser::Aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65cd22adf72a74a4b456151c3e1d9f81b33d09a6" translate="yes" xml:space="preserve">
          <source>The name of the class to use to aggregate test results. The default is &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;.</source>
          <target state="translated">Имя класса, используемого для агрегирования результатов тестирования. По умолчанию - &lt;a href=&quot;parser/aggregator&quot;&gt;TAP :: Parser :: Aggregator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f598b6f749ef712a68f14ac426c778ed4bbb049" translate="yes" xml:space="preserve">
          <source>The name of the class to use to format output. The default is &lt;a href=&quot;TAP::Formatter::Console&quot;&gt;TAP::Formatter::Console&lt;/a&gt;, or &lt;a href=&quot;TAP::Formatter::File&quot;&gt;TAP::Formatter::File&lt;/a&gt; if the output isn't a TTY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaad217bdc2e240c2b5911f874d90cf603ae7ab9" translate="yes" xml:space="preserve">
          <source>The name of the class to use to format output. The default is &lt;a href=&quot;formatter/console&quot;&gt;TAP::Formatter::Console&lt;/a&gt;, or &lt;a href=&quot;formatter/file&quot;&gt;TAP::Formatter::File&lt;/a&gt; if the output isn't a TTY.</source>
          <target state="translated">Имя класса, используемого для форматирования вывода. По умолчанию используется &lt;a href=&quot;formatter/console&quot;&gt;TAP :: Formatter :: Console&lt;/a&gt; или &lt;a href=&quot;formatter/file&quot;&gt;TAP :: Formatter :: File,&lt;/a&gt; если вывод не является TTY.</target>
        </trans-unit>
        <trans-unit id="2938c30f6481c7209480e330f5d2558def4c79e1" translate="yes" xml:space="preserve">
          <source>The name of the class to use to multiplex tests during parallel testing. The default is &lt;a href=&quot;TAP::Parser::Multiplexer&quot;&gt;TAP::Parser::Multiplexer&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72da2c41641715361491c5ff4abc5e20b2230add" translate="yes" xml:space="preserve">
          <source>The name of the class to use to multiplex tests during parallel testing. The default is &lt;a href=&quot;parser/multiplexer&quot;&gt;TAP::Parser::Multiplexer&lt;/a&gt;.</source>
          <target state="translated">Имя класса, используемого для мультиплексирования тестов во время параллельного тестирования. По умолчанию - &lt;a href=&quot;parser/multiplexer&quot;&gt;TAP :: Parser :: Multiplexer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d2b438590e86cedd0b4ce69e5a89edf3f57ce2f" translate="yes" xml:space="preserve">
          <source>The name of the class to use to parse TAP. The default is &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5c1530a58c08454895ba69cebd216b2fda858b" translate="yes" xml:space="preserve">
          <source>The name of the class to use to parse TAP. The default is &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="translated">Имя класса, используемого для анализа TAP. По умолчанию - &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6353269469768546ffd890653f96373f13d0ecd8" translate="yes" xml:space="preserve">
          <source>The name of the class to use to schedule test execution. The default is &lt;a href=&quot;TAP::Parser::Scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c363903c8b428e2f92b68d74a94f7359ac65693" translate="yes" xml:space="preserve">
          <source>The name of the class to use to schedule test execution. The default is &lt;a href=&quot;parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="translated">Имя класса, используемого для планирования выполнения теста. По умолчанию - &lt;a href=&quot;parser/scheduler&quot;&gt;TAP :: Parser :: Scheduler&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be46c0fe1db34418e8697bff77cb46ef2046a9fa" translate="yes" xml:space="preserve">
          <source>The name of the constant, as seen by the perl code.</source>
          <target state="translated">Название константы,как видно по коду perl.</target>
        </trans-unit>
        <trans-unit id="4720e470b7493414aa6c88cde788462359384401" translate="yes" xml:space="preserve">
          <source>The name of the current report format for the currently selected output channel. The default format name is the same as the filehandle name. For example, the default format name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is just &lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">Имя текущего формата отчета для текущего выбранного выходного канала. Имя формата по умолчанию совпадает с именем дескриптора файла. Например, имя формата по умолчанию для дескриптора файла &lt;code&gt;STDOUT&lt;/code&gt; - просто &lt;code&gt;STDOUT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f308d321f719413a7daef45e5b751142a5169847" translate="yes" xml:space="preserve">
          <source>The name of the current report format for the currently selected output channel. The default format name is the same as the filehandle name. For example, the default format name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is just &lt;code&gt;STDOUT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e5170077c0838d812432a43efc57d6e9e83c1c" translate="yes" xml:space="preserve">
          <source>The name of the current top-of-page format for the currently selected output channel. The default is the name of the filehandle with &lt;code&gt;_TOP&lt;/code&gt; appended. For example, the default format top name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is &lt;code&gt;STDOUT_TOP&lt;/code&gt; .</source>
          <target state="translated">Имя текущего формата верхней части страницы для текущего выбранного выходного канала. По умолчанию это имя дескриптора файла с добавленным &lt;code&gt;_TOP&lt;/code&gt; . Например, верхнее имя формата по умолчанию для дескриптора файла &lt;code&gt;STDOUT&lt;/code&gt; - &lt;code&gt;STDOUT_TOP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0743a6b94bb8bebfeea265e55206e1f27d87193" translate="yes" xml:space="preserve">
          <source>The name of the current top-of-page format for the currently selected output channel. The default is the name of the filehandle with &lt;code&gt;_TOP&lt;/code&gt; appended. For example, the default format top name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is &lt;code&gt;STDOUT_TOP&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6379fb4c9e525f705c12afeef2d60c9f65c93af3" translate="yes" xml:space="preserve">
          <source>The name of the default local file, that $ff-&amp;gt;output_file falls back to if it would otherwise return no filename. For example when fetching a URI like &lt;a href=&quot;http://www.abc.net.au/&quot;&gt;http://www.abc.net.au/&lt;/a&gt; the contents retrieved may be from a remote file called 'index.html'. The default value of this attribute is literally 'file_default'.</source>
          <target state="translated">Имя локального файла по умолчанию, к которому возвращается $ ff-&amp;gt; output_file, если в противном случае он не вернет имя файла. Например, при получении URI, такого как &lt;a href=&quot;http://www.abc.net.au/&quot;&gt;http://www.abc.net.au/,&lt;/a&gt; полученное содержимое может быть из удаленного файла с именем index.html. Значение этого атрибута по умолчанию буквально &amp;laquo;file_default&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="724f86ff11ab9d4f954a655139b3c95fbd6d6b99" translate="yes" xml:space="preserve">
          <source>The name of the default local file, that $ff-&amp;gt;output_file falls back to if it would otherwise return no filename. For example when fetching a URI like http://www.abc.net.au/ the contents retrieved may be from a remote file called 'index.html'. The default value of this attribute is literally 'file_default'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ff7c2b3c1b5f1d9d21717655a465440b8c3a51" translate="yes" xml:space="preserve">
          <source>The name of the distribution. Often created by taking the &quot;main module&quot; in the distribution and changing &quot;::&quot; to &quot;-&quot;. Sometimes it's completely different, however, as in the case of the &lt;a href=&quot;http://search.cpan.org/author/GAAS/libwww-perl/&quot;&gt;libwww-perl&lt;/a&gt; distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ec9b1148eb41355676951fe5003b4832073d292" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the C code. The default is &lt;code&gt;const-c.inc&lt;/code&gt; . The &lt;code&gt;-&lt;/code&gt; in the name ensures that the file can't be mistaken for anything related to a legitimate perl package name, and not naming the file &lt;code&gt;.c&lt;/code&gt; avoids having to override Makefile.PL's &lt;code&gt;.xs&lt;/code&gt; to &lt;code&gt;.c&lt;/code&gt; rules.</source>
          <target state="translated">Имя записываемого файла, содержащего код C. По умолчанию - &lt;code&gt;const-c.inc&lt;/code&gt; . Знак &lt;code&gt;-&lt;/code&gt; в имени гарантирует, что файл не может быть ошибочно принят за что-либо, имеющее отношение к законному имени пакета perl, а отсутствие имени файла &lt;code&gt;.c&lt;/code&gt; позволяет избежать необходимости переопределения правил Makefile.PL &lt;code&gt;.xs&lt;/code&gt; на &lt;code&gt;.c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd1ff7ef642391e787d3298e4e4d4178df728894" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the C code. The default is &lt;code&gt;const-c.inc&lt;/code&gt;. The &lt;code&gt;-&lt;/code&gt; in the name ensures that the file can't be mistaken for anything related to a legitimate perl package name, and not naming the file &lt;code&gt;.c&lt;/code&gt; avoids having to override Makefile.PL's &lt;code&gt;.xs&lt;/code&gt; to &lt;code&gt;.c&lt;/code&gt; rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bed22db2d9895f574b197dc49845a9793eb5ff4" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the XS code. The default is &lt;code&gt;const-xs.inc&lt;/code&gt; .</source>
          <target state="translated">Имя записываемого файла, содержащего код XS. По умолчанию - &lt;code&gt;const-xs.inc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff977189b5dca37639aa340e96771f65419bc6de" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the XS code. The default is &lt;code&gt;const-xs.inc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d500a8c6262466b93b5ca84e3fdd9132c3d42c" translate="yes" xml:space="preserve">
          <source>The name of the file you want to tie to the hash.</source>
          <target state="translated">Имя файла,который ты хочешь привязать к гашишу.</target>
        </trans-unit>
        <trans-unit id="264313247d929c3123a9e7fe3982f9c4d6734ea2" translate="yes" xml:space="preserve">
          <source>The name of the file.</source>
          <target state="translated">Имя файла.</target>
        </trans-unit>
        <trans-unit id="2fed9b5e3d1ecfa444bc4bf0c0867e79f9d251bc" translate="yes" xml:space="preserve">
          <source>The name of the interior sequence command.</source>
          <target state="translated">Имя команды внутренней последовательности.</target>
        </trans-unit>
        <trans-unit id="850e998443ed95a332bbac695731c9e48b93fd64" translate="yes" xml:space="preserve">
          <source>The name of the label is returned in the form of a fresh scalar. If an optional label is absent, a null pointer is returned.</source>
          <target state="translated">Название этикетки возвращается в виде свежего скаляра.Если необязательная метка отсутствует,возвращается нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="73fad9a569b3c6f7964969b809a10335f9888518" translate="yes" xml:space="preserve">
          <source>The name of the layer whose open() method Perl should invoke on open(). For example if the layer is called APR, you will call:</source>
          <target state="translated">Имя слоя,который должен вызывать метод Perl в open().Например,если слой называется APR,то вы будете вызывать:</target>
        </trans-unit>
        <trans-unit id="72863e084ba8d90c496ae5c6484f120959926659" translate="yes" xml:space="preserve">
          <source>The name of the method</source>
          <target state="translated">Название метода</target>
        </trans-unit>
        <trans-unit id="e4c23f5fa4cbd2a24c92f584213f4e01a597f939" translate="yes" xml:space="preserve">
          <source>The name of the module you wish to verify -- this is a required key</source>
          <target state="translated">Название модуля,который вы хотите проверить-это требуемый ключ.</target>
        </trans-unit>
        <trans-unit id="8baabdd6359e36f0075679bff6c64a42d5070771" translate="yes" xml:space="preserve">
          <source>The name of the operating system under which this copy of Perl was built, as determined during the configuration process. For examples see &lt;a href=&quot;perlport#PLATFORMS&quot;&gt;&quot;PLATFORMS&quot; in perlport&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917bce2995f64faec20b4096ae916c3c8efb0bec" translate="yes" xml:space="preserve">
          <source>The name of the operating system under which this copy of Perl was built, as determined during the configuration process. For examples see &lt;a href=&quot;perlport#PLATFORMS&quot;&gt;PLATFORMS in perlport&lt;/a&gt;.</source>
          <target state="translated">Имя операционной системы, под которой была создана эта копия Perl, как определено в процессе настройки. Примеры см. В разделе &lt;a href=&quot;perlport#PLATFORMS&quot;&gt;ПЛАТФОРМЫ в perlport&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2040df0b9281e990b52b6ffee0618e248f91a919" translate="yes" xml:space="preserve">
          <source>The name of the output file. This is the same as $ff-&amp;gt;file, but any query parameters are stripped off. For example:</source>
          <target state="translated">Имя выходного файла. Это то же самое, что и $ ff-&amp;gt; file, но все параметры запроса удалены. Например:</target>
        </trans-unit>
        <trans-unit id="cbe18d7ad69e81d6c826df352db92d6f22fccd8c" translate="yes" xml:space="preserve">
          <source>The name of the program being documented is conventionally written in bold (using B&amp;lt;&amp;gt;) wherever it occurs, as are all program options. Arguments should be written in italics (I&amp;lt;&amp;gt;). Function names are traditionally written in italics; if you write a function as function(), Pod::Man will take care of this for you. Literal code or commands should be in C&amp;lt;&amp;gt;. References to other man pages should be in the form &lt;code&gt;manpage(section)&lt;/code&gt; or &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt; , and Pod::Man will automatically format those appropriately. The second form, with L&amp;lt;&amp;gt;, is used to request that a POD formatter make a link to the man page if possible. As an exception, one normally omits the section when referring to module documentation since it's not clear what section module documentation will be in; use &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; for module references instead.</source>
          <target state="translated">Имя документируемой программы обычно выделяется жирным шрифтом (с использованием B &amp;lt;&amp;gt;) везде, где оно встречается, как и все параметры программы. Аргументы пишутся курсивом (I &amp;lt;&amp;gt;). Названия функций традиционно пишутся курсивом; если вы напишете функцию как function (), Pod :: Man позаботится об этом за вас. Буквальный код или команды должны быть на C &amp;lt;&amp;gt;. Ссылки на другие страницы руководства должны быть в форме &lt;code&gt;manpage(section)&lt;/code&gt; или &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt; , и Pod :: Man автоматически отформатирует их соответствующим образом. Вторая форма с L &amp;lt;&amp;gt; используется для запроса, чтобы модуль форматирования POD сделал ссылку на страницу руководства, если это возможно. В качестве исключения обычно пропускают этот раздел при обращении к документации модуля, поскольку неясно, в каком разделе будет документация модуля;использовать &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; для ссылок на модули.</target>
        </trans-unit>
        <trans-unit id="1b18709c27f5d88461bdcb14ca9e036ab15a9e4c" translate="yes" xml:space="preserve">
          <source>The name of the program being documented is conventionally written in bold (using B&amp;lt;&amp;gt;) wherever it occurs, as are all program options. Arguments should be written in italics (I&amp;lt;&amp;gt;). Function names are traditionally written in italics; if you write a function as function(), Pod::Man will take care of this for you. Literal code or commands should be in C&amp;lt;&amp;gt;. References to other man pages should be in the form &lt;code&gt;manpage(section)&lt;/code&gt; or &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt;, and Pod::Man will automatically format those appropriately. The second form, with L&amp;lt;&amp;gt;, is used to request that a POD formatter make a link to the man page if possible. As an exception, one normally omits the section when referring to module documentation since it's not clear what section module documentation will be in; use &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; for module references instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1dece7f57632e56f321f082b4b7487de40077a" translate="yes" xml:space="preserve">
          <source>The name of the program currently executing, as typed on the command line. In C, the &lt;b&gt;command&lt;/b&gt; name is passed to the program as the first command-line argument. In Perl, it comes in separately as &lt;code&gt;$0&lt;/code&gt; .</source>
          <target state="translated">Имя выполняемой в данный момент программы, введенное в командной строке. В языке C имя &lt;b&gt;команды&lt;/b&gt; передается программе в качестве первого аргумента командной строки. В Perl он стоит отдельно как &lt;code&gt;$0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24e0c1ed3bcd878bf180116a18e90c254b00991c" translate="yes" xml:space="preserve">
          <source>The name of the program currently executing, as typed on the command line. In C, the &lt;b&gt;command&lt;/b&gt; name is passed to the program as the first command-line argument. In Perl, it comes in separately as &lt;code&gt;$0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87ba5fd11240d3846b6402630cc4fc5a1bb692a" translate="yes" xml:space="preserve">
          <source>The name of the remote file. For the local file name, the result of $ff-&amp;gt;output_file will be used.</source>
          <target state="translated">Имя удаленного файла. Для имени локального файла будет использоваться результат $ ff-&amp;gt; output_file.</target>
        </trans-unit>
        <trans-unit id="7b5484f9bbb8c882de4857813fc18405c14f1941" translate="yes" xml:space="preserve">
          <source>The name of the subtest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a547e6d045957f910163d7d9750610edbb9f85" translate="yes" xml:space="preserve">
          <source>The name of the test that will be displayed after the &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;not
ok&lt;/code&gt; .</source>
          <target state="translated">Название теста, которое будет отображаться после &lt;code&gt;ok&lt;/code&gt; или &lt;code&gt;not ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0319d70ade81e70a5ad5c9b04019b6a6a650fd8c" translate="yes" xml:space="preserve">
          <source>The name of the test that will be displayed after the &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;not ok&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed54953d3ed163e618a466d003f5bcd630ecc77" translate="yes" xml:space="preserve">
          <source>The name of the test. Usually a filename.</source>
          <target state="translated">Название теста.Обычно это фамилия.</target>
        </trans-unit>
        <trans-unit id="bddd22d202ef6bbfb07440852aa85decd3f86741" translate="yes" xml:space="preserve">
          <source>The name of the variable the OP's targ refers to, if any, otherwise the letter t followed by the OP's targ in decimal.</source>
          <target state="translated">Имя переменной,на которую указан знак ОП,если таковой имеется,в противном случае буква t,за которой следует знак ОП в десятичной дроби.</target>
        </trans-unit>
        <trans-unit id="57d8fd0b0612e473ba409ed332506df9547952e4" translate="yes" xml:space="preserve">
          <source>The name of this target is the name of the tarball generated by tardist. This target does the actual work of turning the distdir into a tarball.</source>
          <target state="translated">Имя этой цели-название тарбола,генерируемого тардистом.Эта мишень выполняет фактическую работу по превращению дистрибутива в тарбол.</target>
        </trans-unit>
        <trans-unit id="7f384abee623b7aefa3eee77d6cf325a89576f28" translate="yes" xml:space="preserve">
          <source>The name of this target is the name of the zip file generated by zipdist. This target does the actual work of turning the distdir into a zip file.</source>
          <target state="translated">Имя этой цели-это имя zip-файла,сгенерированного zipdist'ом.Эта цель выполняет фактическую работу по превращению дистрибутива в zip-файл.</target>
        </trans-unit>
        <trans-unit id="40fffdd6d8d082596e0b6d7269c4fc2ab2372dd8" translate="yes" xml:space="preserve">
          <source>The name or URL, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the name (also sometimes called the page) is &quot;perlfunc&quot;. In &quot;L&amp;lt;/CAVEATS&amp;gt;&quot;, the name is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Имя или URL-адрес, или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если нет. (Например, в &amp;laquo;L &amp;lt;Perl Functions | perlfunc&amp;gt;&amp;raquo; имя (также иногда называемое страницей) - &amp;laquo;perlfunc&amp;raquo;. В &amp;laquo;L &amp;lt;/CAVEATS&amp;gt;&amp;raquo; имя - &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="db1774b0bd337a6db893379927df425f03f56870" translate="yes" xml:space="preserve">
          <source>The name or URL, or &lt;code&gt;undef&lt;/code&gt; if none. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the name (also sometimes called the page) is &quot;perlfunc&quot;. In &quot;L&amp;lt;/CAVEATS&amp;gt;&quot;, the name is &lt;code&gt;undef&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032b79c8986bca0bbbc3c31a86f48e2e4e0d3085" translate="yes" xml:space="preserve">
          <source>The name returned is the &quot;best&quot; (defined below) official name or alias for the code point, if available; otherwise your custom alias for it, if defined; otherwise &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. This means that your alias will only be returned for code points that don't have an official Unicode name (nor alias) such as private use code points.</source>
          <target state="translated">Возвращаемое имя является &amp;laquo;наилучшим&amp;raquo; (определенным ниже) официальным именем или псевдонимом для кодовой точки, если доступно; в противном случае ваш собственный псевдоним для него, если он определен; в противном случае &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Это означает, что ваш псевдоним будет возвращен только для кодовых точек, у которых нет официального имени Unicode (или псевдонима), таких как кодовые точки частного использования.</target>
        </trans-unit>
        <trans-unit id="6ccf456e05fb0bbcace6b6fbae7f69f4f9acbb13" translate="yes" xml:space="preserve">
          <source>The name returned is the &quot;best&quot; (defined below) official name or alias for the code point, if available; otherwise your custom alias for it, if defined; otherwise &lt;code&gt;undef&lt;/code&gt;. This means that your alias will only be returned for code points that don't have an official Unicode name (nor alias) such as private use code points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c859e03c561ae7900b19a5195289cf330fd686" translate="yes" xml:space="preserve">
          <source>The name specification contains the name of the option, optionally followed by a list of alternative names separated by vertical bar characters.</source>
          <target state="translated">Спецификация имени содержит имя опции,за которым,по желанию,следует список альтернативных имен,разделенных символами вертикальной полосы.</target>
        </trans-unit>
        <trans-unit id="c00824bf96e3af72974b0dc7167ce50b9784a97a" translate="yes" xml:space="preserve">
          <source>The name stored in the pad name struct. This returns &lt;code&gt;NULL&lt;/code&gt; for a target slot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ea5f2153ac354bb676ac855da5204a1c4f0887" translate="yes" xml:space="preserve">
          <source>The name stored in the pad name struct. This returns NULL for a target slot.</source>
          <target state="translated">Имя,сохраненное в структуре имени блокнота.Возвращает NULL для целевого слота.</target>
        </trans-unit>
        <trans-unit id="8d08870c9ada1df075e2fe0edf360d9170cd33f2" translate="yes" xml:space="preserve">
          <source>The name supplied for the test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9c5d421e8490b0fb44df42960273145ec017c2" translate="yes" xml:space="preserve">
          <source>The name that &lt;code&gt;gv_stash*v&lt;/code&gt; wants is the name of the package whose symbol table you want. The default package is called &lt;code&gt;main&lt;/code&gt; . If you have multiply nested packages, pass their names to &lt;code&gt;gv_stash*v&lt;/code&gt; , separated by &lt;code&gt;::&lt;/code&gt; as in the Perl language itself.</source>
          <target state="translated">Имя, &lt;code&gt;gv_stash*v&lt;/code&gt; хочет gv_stash * v, - это имя пакета, таблица символов которого вам нужна. Пакет по умолчанию называется &lt;code&gt;main&lt;/code&gt; . Если у вас несколько вложенных пакетов, передайте их имена в &lt;code&gt;gv_stash*v&lt;/code&gt; , разделив их символом &lt;code&gt;::&lt;/code&gt; , как в самом языке Perl.</target>
        </trans-unit>
        <trans-unit id="3ac1dff6b7360564b5ef0a6823013e115cd6dc89" translate="yes" xml:space="preserve">
          <source>The name that &lt;code&gt;gv_stash*v&lt;/code&gt; wants is the name of the package whose symbol table you want. The default package is called &lt;code&gt;main&lt;/code&gt;. If you have multiply nested packages, pass their names to &lt;code&gt;gv_stash*v&lt;/code&gt;, separated by &lt;code&gt;::&lt;/code&gt; as in the Perl language itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5602fbc4cb262cfe30268630c826bf892b1b3d53" translate="yes" xml:space="preserve">
          <source>The name used by the Perl community. That includes 'utf8' and 'ascii'. Unlike aliases, canonical names directly reach the method so such frequently used words like 'utf8' don't need to do alias lookups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44f8223ba7b643b349f360058fbf26b1973aa5a7" translate="yes" xml:space="preserve">
          <source>The name used by the organization that defined it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ea1c9f71e1742c14f7e274aadd24083453f785c" translate="yes" xml:space="preserve">
          <source>The name used to execute the current copy of Perl, from C's &lt;code&gt;argv[0]&lt;/code&gt; or (where supported)</source>
          <target state="translated">Имя, используемое для выполнения текущей копии Perl, из &lt;code&gt;argv[0]&lt;/code&gt; C argv [0] или (где поддерживается)</target>
        </trans-unit>
        <trans-unit id="7d5e4108cb484849f5cc23fa9d5c378793d57fcf" translate="yes" xml:space="preserve">
          <source>The names</source>
          <target state="translated">Имена</target>
        </trans-unit>
        <trans-unit id="e163bed624ffb39e2435b88e57776aaac39a8121" translate="yes" xml:space="preserve">
          <source>The names are in the old-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;Old-style versus new-style block names&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618e9ec6e6fd129b3719b6fed50188e89fd59442" translate="yes" xml:space="preserve">
          <source>The names are in the old-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">Имена указаны в старом стиле (см. &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Сравнение имен блоков в старом и новом стиле&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="07ca386df79309f7e041c206d3183ef66c0ddbc4" translate="yes" xml:space="preserve">
          <source>The names associated with pad entries.</source>
          <target state="translated">Имена,связанные с записями в блокнот.</target>
        </trans-unit>
        <trans-unit id="9b163a7bfc6ff4bff1595ddcc9e4a9a73a9a9a05" translate="yes" xml:space="preserve">
          <source>The names have been chosen by analogy with &lt;a href=&quot;Tie::Scalar&quot;&gt;Tie::Scalar&lt;/a&gt; methods names with an additional &lt;b&gt;LENGTH&lt;/b&gt; callback for efficiency. However named capture variables are currently not tied internally but implemented via magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284af84a82eacc68e4acdb3ccfa2e6b8438eb902" translate="yes" xml:space="preserve">
          <source>The names have been chosen by analogy with &lt;a href=&quot;tie/scalar&quot;&gt;Tie::Scalar&lt;/a&gt; methods names with an additional &lt;b&gt;LENGTH&lt;/b&gt; callback for efficiency. However named capture variables are currently not tied internally but implemented via magic.</source>
          <target state="translated">Имена выбраны по аналогии с именами методов &lt;a href=&quot;tie/scalar&quot;&gt;Tie :: Scalar&lt;/a&gt; с дополнительным обратным вызовом &lt;b&gt;LENGTH&lt;/b&gt; для эффективности. Однако именованные переменные захвата в настоящее время не связаны внутренне, а реализованы с помощью магии.</target>
        </trans-unit>
        <trans-unit id="6f2021e99e612abfa74ac94b1f6cbd3e729a273e" translate="yes" xml:space="preserve">
          <source>The names of any symbols that cannot be exported should be listed in the &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; array.</source>
          <target state="translated">Имена любых символов, которые нельзя экспортировать, должны быть перечислены в массиве &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce28b5edeebefe670a07dac363032a7c7d1c8c78" translate="yes" xml:space="preserve">
          <source>The names of one or more patch files or other text attachments to be included with the report. Multiple files must be separated with commas.</source>
          <target state="translated">Имена одного или нескольких патч-файлов или других текстовых вложений,которые должны быть включены в отчет.Несколько файлов должны быть разделены запятыми.</target>
        </trans-unit>
        <trans-unit id="8f857c3b3defbce0780a8f039ec3e39d992aed2b" translate="yes" xml:space="preserve">
          <source>The names of the constants are grouped by length. Generate child subroutines for each group with this number or more names in.</source>
          <target state="translated">Названия констант сгруппированы по длине.Сгенерируйте дочерние подпрограммы для каждой группы с таким номером или несколькими именами.</target>
        </trans-unit>
        <trans-unit id="014e7ffcf388c955244e207841832a805e1b764b" translate="yes" xml:space="preserve">
          <source>The names of the fields can be obtained by calling &lt;code&gt;overview_fmt&lt;/code&gt; .</source>
          <target state="translated">Имена полей можно получить, вызвав &lt;code&gt;overview_fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e645b67ba06f3c61734454bcb81a97d709157227" translate="yes" xml:space="preserve">
          <source>The names of the fields can be obtained by calling &lt;code&gt;overview_fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4fc313d5aefbc7e8f27ebb1be72375df1f65ec2" translate="yes" xml:space="preserve">
          <source>The names of the signals are the ones listed out by &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; on your system, or you can retrieve them using the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Signal&quot;&gt;IPC::Signal&lt;/a&gt;.</source>
          <target state="translated">Имена сигналов перечислены с помощью &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; в вашей системе, или вы можете получить их с помощью модуля CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Signal&quot;&gt;IPC :: Signal&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e02e2136011dc08d1ab7910eb739f830a21ebe7" translate="yes" xml:space="preserve">
          <source>The names of the signals are the ones listed out by &lt;code&gt;kill -l&lt;/code&gt; on your system, or you can retrieve them using the CPAN module &lt;a href=&quot;IPC::Signal&quot;&gt;IPC::Signal&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5a87a1d013fec4fa7021ebe1fad71eb5dada0f" translate="yes" xml:space="preserve">
          <source>The naming of encodings, both by the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; and by the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma allows for flexible names: &lt;code&gt;koi8-r&lt;/code&gt; and &lt;code&gt;KOI8R&lt;/code&gt; will both be understood.</source>
          <target state="translated">Именование кодировок с помощью &lt;code&gt;KOI8R&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; позволяет использовать гибкие имена: &lt;code&gt;koi8-r&lt;/code&gt; и KOI8R будут понятны.</target>
        </trans-unit>
        <trans-unit id="854c8ac2d9120b67c893ac9dc1ee0ecda32433aa" translate="yes" xml:space="preserve">
          <source>The naming of encodings, both by the &lt;code&gt;open()&lt;/code&gt; and by the &lt;code&gt;open&lt;/code&gt; pragma allows for flexible names: &lt;code&gt;koi8-r&lt;/code&gt; and &lt;code&gt;KOI8R&lt;/code&gt; will both be understood.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8afc81fb7787a63e6fa9bc963817cbc2add1c18f" translate="yes" xml:space="preserve">
          <source>The native Win32 version of &lt;code&gt;seek()&lt;/code&gt;. &lt;code&gt;SetFilePointer&lt;/code&gt; sets the position within a file where the next read or write operation will start from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb26ebee327534f7eadec1f76baa31ad090fef00" translate="yes" xml:space="preserve">
          <source>The native status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt; ) command, successful call to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;, or from the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; operator. On POSIX-like systems this value can be decoded with the WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG and WIFCONTINUED functions provided by the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="translated">Собственный статус, возвращаемый последним закрытием канала, командой обратной кавычки ( &lt;code&gt;``&lt;/code&gt; ), успешным вызовом &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; или оператором &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; . В системах, подобных POSIX, это значение можно декодировать с помощью функций WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG и WIFCONTINUED, предоставляемых модулем &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bbaba3e2cc788e3f7da9b6f38cb2688cde834f68" translate="yes" xml:space="preserve">
          <source>The native status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt;) command, successful call to &lt;code&gt;wait()&lt;/code&gt; or &lt;code&gt;waitpid()&lt;/code&gt;, or from the &lt;code&gt;system()&lt;/code&gt; operator. On POSIX-like systems this value can be decoded with the WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG and WIFCONTINUED functions provided by the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f679d50295d2d00d85ba280df81111988684878" translate="yes" xml:space="preserve">
          <source>The natural question: &quot;Why can't Perl compensate for the gaps?&quot; warrants an answer. One good reason is that C compilers might provide (non-ANSI) extensions permitting all sorts of fancy control over the way structures are aligned, even at the level of an individual structure field. And, if this were not enough, there is an insidious thing called &lt;code&gt;union&lt;/code&gt; where the amount of fill bytes cannot be derived from the alignment of the next item alone.</source>
          <target state="translated">Естественный вопрос: &amp;laquo;Почему Perl не может компенсировать пробелы?&amp;raquo; требует ответа. Одна из веских причин заключается в том, что компиляторы C могут предоставлять (не-ANSI) расширения, позволяющие всевозможные причудливые средства управления выравниванием структур, даже на уровне отдельного поля структуры. И, если этого было недостаточно, есть коварная вещь, называемая &lt;code&gt;union&lt;/code&gt; где количество байтов заполнения не может быть получено только путем выравнивания следующего элемента.</target>
        </trans-unit>
        <trans-unit id="73304f2bc3720cbdf5bbe3a347ce1a6a6606cb3e" translate="yes" xml:space="preserve">
          <source>The natural way to do this is to have a hash whose keys are country names. Associated with each country name key is a list of the cities in that country. Each time you read a line of input, split it into a country and a city, look up the list of cities already known to be in that country, and append the new city to the list. When you're done reading the input, iterate over the hash as usual, sorting each list of cities before you print it out.</source>
          <target state="translated">Естественный способ сделать это-иметь хэш,ключами которого являются названия стран.С каждым ключом названия страны связан список городов в этой стране.Каждый раз,когда вы читаете строку ввода,разбиваете ее на страну и город,просматриваете список городов,уже известных в этой стране,и добавляете новый город в список.Когда вы закончите чтение ввода,выполните итерацию по хэшу,как обычно,сортируя каждый список городов перед тем,как распечатать его.</target>
        </trans-unit>
        <trans-unit id="47d44728d6d28aac48e384cc30fefc76b5a26c28" translate="yes" xml:space="preserve">
          <source>The negated versions of the lookahead and lookbehind assertions are denoted by &lt;code&gt;(?!regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; respectively. Or, starting in 5.32 (experimentally in 5.28), &lt;code&gt;(*nla:regexp)&lt;/code&gt;, &lt;code&gt;(*negative_lookahead:regexp)&lt;/code&gt;, &lt;code&gt;(*nlb:regexp)&lt;/code&gt;, or &lt;code&gt;(*negative_lookbehind:regexp)&lt;/code&gt;. They evaluate true if the regexps do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba13cfae515a220e252c3e1157af722de7da0aa" translate="yes" xml:space="preserve">
          <source>The negation is useful for defining (surprise!) negated classes.</source>
          <target state="translated">Отрицание полезно для определения (сюрприз!)отрицательных классов.</target>
        </trans-unit>
        <trans-unit id="db0ad6bd4816ce652496b94f2f1d7976b92ada0c" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_NN&lt;/code&gt; which elide the NULL pointer check.</source>
          <target state="translated">Отрицание этого макроса &lt;code&gt;OP_TYPE_ISNT&lt;/code&gt; также доступно, а также &lt;code&gt;OP_TYPE_IS_NN&lt;/code&gt; и &lt;code&gt;OP_TYPE_ISNT_NN&lt;/code&gt; , которые исключают проверку указателя NULL.</target>
        </trans-unit>
        <trans-unit id="34a8b60e3a36600480a60cec2deec17ff174ebef" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; which elide the &lt;code&gt;NULL&lt;/code&gt; pointer check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691f70fa29f72e49de97eccc12c05c1f840f1b46" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; which elide the NULL pointer check.</source>
          <target state="translated">Отрицание этого макроса &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; также доступно, а также &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; и &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; , которые отменяют проверку нулевого указателя.</target>
        </trans-unit>
        <trans-unit id="528d5b378ab36165946632706d39fa6c9839837e" translate="yes" xml:space="preserve">
          <source>The new behavior provides a much more robust solution for checking Winsock errors in portable software without accidentally matching POSIX tests that were intended for other OSes and may have different meanings for Winsock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68f1f4d38ce035e2e238de529bbc7313afe802e" translate="yes" xml:space="preserve">
          <source>The new class is given a constructor method, &lt;code&gt;new&lt;/code&gt; , for creating struct objects.</source>
          <target state="translated">Новому классу предоставляется метод конструктора &lt;code&gt;new&lt;/code&gt; для создания объектов структуры.</target>
        </trans-unit>
        <trans-unit id="9d80888ad8b596747bf8185a9ccf7eb36f05c472" translate="yes" xml:space="preserve">
          <source>The new class is given a constructor method, &lt;code&gt;new&lt;/code&gt;, for creating struct objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133a286ef1fa797920ffbacb6d543c092bbb9c81" translate="yes" xml:space="preserve">
          <source>The new compare function must be specified when you create the database.</source>
          <target state="translated">Новая функция сравнения должна быть указана при создании базы данных.</target>
        </trans-unit>
        <trans-unit id="6ca5133e85084fb8ccd654bdee5f648c6a7925f9" translate="yes" xml:space="preserve">
          <source>The new interface to the USE_PERLIO implementation. The layers &quot;:crlf&quot; and &quot;:raw&quot; are only ones allowed for other implementations and those are silently ignored. (As of perl5.8 &quot;:raw&quot; is deprecated.) Use PerlIO_binmode() below for the portable case.</source>
          <target state="translated">Новый интерфейс к реализации USE_PERLIO.Слои &quot;:crlf&quot; и &quot;:raw&quot; разрешены только для других реализаций и игнорируются.(Начиная с версии perl5.8 &quot;:raw&quot; является устаревшим.)Используйте PerlIO_binmode(),приведенную ниже,для переносимого кейса.</target>
        </trans-unit>
        <trans-unit id="ef605716ebbaada258955508adf61e07c343c95f" translate="yes" xml:space="preserve">
          <source>The new key is specified by</source>
          <target state="translated">Новый ключ определяется</target>
        </trans-unit>
        <trans-unit id="93da98420a9bfc76d18ae79d8876182fff5c85c5" translate="yes" xml:space="preserve">
          <source>The new key is specified by &lt;code&gt;keypv&lt;/code&gt; and &lt;code&gt;keylen&lt;/code&gt;. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;REFCOUNTED_HE_KEY_UTF8&lt;/code&gt; bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. &lt;code&gt;hash&lt;/code&gt; is a precomputed hash of the key string, or zero if it has not been precomputed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853b1cad8315c050b3031642990285f3b3f61796" translate="yes" xml:space="preserve">
          <source>The new perlIO layer is used. NI-S' favorite.</source>
          <target state="translated">Используется новый слой перлио.Любимый NI-S.</target>
        </trans-unit>
        <trans-unit id="437054ab8086dcb8d5230b53692e92ce8976728d" translate="yes" xml:space="preserve">
          <source>The new prereqs object has no ties to the originals, and altering it further will not alter them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f44fc740bd8115fd48ea2f3dccbe8d30383620f" translate="yes" xml:space="preserve">
          <source>The new routine will be called whenever a built-in function is called without a qualifying package:</source>
          <target state="translated">Новая рутина будет вызываться всякий раз,когда будет вызвана встроенная функция без квалифицирующего пакета:</target>
        </trans-unit>
        <trans-unit id="69fd8169a1c03a87b9cb7323668ea2985b78ca39" translate="yes" xml:space="preserve">
          <source>The new semantics are now only available with &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; . The old semantics are only available through &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; . Users are strongly encouraged to upgrade to at least 2.08 in order to avoid surprises.</source>
          <target state="translated">Новая семантика теперь доступна только с &lt;code&gt;make_path&lt;/code&gt; и &lt;code&gt;remove_tree&lt;/code&gt; . Старая семантика доступна только через &lt;code&gt;mkpath&lt;/code&gt; и &lt;code&gt;rmtree&lt;/code&gt; . Пользователям настоятельно рекомендуется обновиться до версии не ниже 2.08, чтобы избежать сюрпризов.</target>
        </trans-unit>
        <trans-unit id="e786b3ec60d0d79422f9596d38dfebba203b53ce" translate="yes" xml:space="preserve">
          <source>The new semantics are now only available with &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt;. The old semantics are only available through &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt;. Users are strongly encouraged to upgrade to at least 2.08 in order to avoid surprises.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb00043758d6e48f38e06be5dcd0156fe97d078" translate="yes" xml:space="preserve">
          <source>The new shiny result of either genuine new functionality or your arduous refactoring is now ready and correctly exported. So what could possibly go wrong?</source>
          <target state="translated">Новый блестящий результат либо реальной новой функциональности,либо Вашего трудного рефакторинга теперь готов и правильно экспортирован.Так что же может пойти не так?</target>
        </trans-unit>
        <trans-unit id="c231cf25130a94dd10bb860a955a6b6ad30c18f8" translate="yes" xml:space="preserve">
          <source>The new simpler way to call &lt;code&gt;XSLoader::load()&lt;/code&gt; with no arguments at all does not work on Perl 5.8.4 and 5.8.5.</source>
          <target state="translated">Новый более простой способ вызова &lt;code&gt;XSLoader::load()&lt;/code&gt; вообще без аргументов не работает в Perl 5.8.4 и 5.8.5.</target>
        </trans-unit>
        <trans-unit id="80d8983154af8008f3d7e48dfd488df835186d04" translate="yes" xml:space="preserve">
          <source>The new thread creation is line 20. We pass on to it a reference to the queue we've created, and the prime number we've found. In lines 21 through 24, we check to make sure that our new thread got created, and if not, we stop checking any remaining numbers in the queue.</source>
          <target state="translated">Создание новой нити-линия 20.Мы передаем ей ссылку на созданную нами очередь и найденное нами простое число.В строках с 21 по 24 мы проверяем,создан ли наш новый поток,и если нет,то перестаем проверять любые оставшиеся номера в очереди.</target>
        </trans-unit>
        <trans-unit id="9044c695c3da968e5a2ea15d51b8b1e2dbc7cbb0" translate="yes" xml:space="preserve">
          <source>The new() function searches for all the installed .packlists on the system, and stores their contents. The .packlists can be queried with the functions described below. Where it searches by default is determined by the settings found in &lt;code&gt;%Config::Config&lt;/code&gt; , and what the value is of the PERL5LIB environment variable.</source>
          <target state="translated">Функция new () ищет все установленные в системе списки .packlists и сохраняет их содержимое. Списки .packlists можно запросить с помощью функций, описанных ниже. Область поиска по умолчанию определяется настройками, найденными в &lt;code&gt;%Config::Config&lt;/code&gt; , и значением переменной среды PERL5LIB.</target>
        </trans-unit>
        <trans-unit id="e6b22aa358acbe55c29900d7f62b40d0edc02821" translate="yes" xml:space="preserve">
          <source>The new() function searches for all the installed .packlists on the system, and stores their contents. The .packlists can be queried with the functions described below. Where it searches by default is determined by the settings found in &lt;code&gt;%Config::Config&lt;/code&gt;, and what the value is of the PERL5LIB environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e76ad120503fe22fb2abd0288095a443b471d16" translate="yes" xml:space="preserve">
          <source>The newer style replaces these with underscores, like this:</source>
          <target state="translated">Более новый стиль заменяет их подчеркиваниями,вот так:</target>
        </trans-unit>
        <trans-unit id="0249c11220739d961eab9d8efdfb827caa468595" translate="yes" xml:space="preserve">
          <source>The newly created subroutine takes ownership of a reference to the passed in SV.</source>
          <target state="translated">Вновь созданная подпрограмма берет на себя право собственности на ссылку на переданную в SV.</target>
        </trans-unit>
        <trans-unit id="c36ff1fb86ca87ccc2385388c9e1be809de8496c" translate="yes" xml:space="preserve">
          <source>The next 8 bits contain the termination status of the program.</source>
          <target state="translated">Следующие 8 бит содержат статус завершения программы.</target>
        </trans-unit>
        <trans-unit id="429ca09b18f928ad50edc605bbb88976cae30220" translate="yes" xml:space="preserve">
          <source>The next example demonstrates how one would place an explicit undef in the return value, should the need arise.</source>
          <target state="translated">Следующий пример демонстрирует,как можно поместить явный undef в возвращаемое значение,если возникает такая необходимость.</target>
        </trans-unit>
        <trans-unit id="abdb50fe44b0e7ab1495a77ca76309d394c16e26" translate="yes" xml:space="preserve">
          <source>The next example show how to use the &lt;code&gt;LimitOutput&lt;/code&gt; option. Notice the use of two nested loops in this case. The outer loop reads the data from the input source - STDIN and the inner loop repeatedly calls &lt;code&gt;inflate&lt;/code&gt; until &lt;code&gt;$input&lt;/code&gt; is exhausted, we get an error, or the end of the stream is reached. One point worth remembering is by using the &lt;code&gt;LimitOutput&lt;/code&gt; option you also get &lt;code&gt;ConsumeInput&lt;/code&gt; set as well - this makes the code below much simpler.</source>
          <target state="translated">В следующем примере показано, как использовать параметр &lt;code&gt;LimitOutput&lt;/code&gt; . Обратите внимание на использование двух вложенных циклов в этом случае. Внешний цикл считывает данные из источника ввода - STDIN, а внутренний цикл многократно вызывает &lt;code&gt;inflate&lt;/code&gt; до тех пор, пока &lt;code&gt;$input&lt;/code&gt; будет исчерпан, мы не получим ошибку или не будет достигнут конец потока. Следует помнить один момент: используя параметр &lt;code&gt;LimitOutput&lt;/code&gt; , вы также получаете набор &lt;code&gt;ConsumeInput&lt;/code&gt; - это значительно упрощает приведенный ниже код.</target>
        </trans-unit>
        <trans-unit id="a73f1f7691d7497b711d0f4bac2e881b3c885873" translate="yes" xml:space="preserve">
          <source>The next example shows each input parameter evaluated late.</source>
          <target state="translated">В следующем примере показан каждый входной параметр,обработанный с опозданием.</target>
        </trans-unit>
        <trans-unit id="def9f1245a38d3c5116ce761f9376e6f2078f597" translate="yes" xml:space="preserve">
          <source>The next examples will use the following C++ class.</source>
          <target state="translated">В следующих примерах будет использоваться следующий класс C++.</target>
        </trans-unit>
        <trans-unit id="6c82e2eba4791c1303c10eb37d70a72bf59badcd" translate="yes" xml:space="preserve">
          <source>The next option deals with the charset (a.k.a. character set) your terminal supports. In general, CPAN is English speaking territory, so the charset does not matter much but some CPAN have names that are outside the ASCII range. If your terminal supports UTF-8, you should say no to the next question. If it expects ISO-8859-1 (also known as LATIN1) then you should say yes. If it supports neither, your answer does not matter because you will not be able to read the names of some authors anyway. If you answer no, names will be output in UTF-8.</source>
          <target state="translated">Следующий вариант связан с кодовым набором (так же известным как набор символов),который поддерживает ваш терминал.В общем,CPAN является англоязычной территорией,поэтому кодовая таблица не имеет большого значения,но некоторые CPAN имеют имена,которые находятся за пределами диапазона ASCII.Если ваш терминал поддерживает UTF-8,вы должны сказать &quot;нет&quot; следующему вопросу.Если он ожидает ISO-8859-1 (также известный как LATIN1),то вы должны сказать &quot;да&quot;.Если он не поддерживает ни то,ни другое,ваш ответ не имеет значения,потому что вы все равно не сможете прочитать имена некоторых авторов.Если вы ответите &quot;нет&quot;,имена будут выведены в UTF-8.</target>
        </trans-unit>
        <trans-unit id="128477608ba084f3baead065e12f71790ccb5def" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt; es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="translated">Следующий указатель для &lt;code&gt;BRANCH&lt;/code&gt; es интересен тем, что он указывает, куда должно идти выполнение, если ветвление завершится неудачей. При выполнении, если движок пытается перейти от ветки к &lt;code&gt;regnext&lt;/code&gt; , который не является ветвью, то движок будет знать, что весь набор ветвей потерпел неудачу.</target>
        </trans-unit>
        <trans-unit id="49d098f677fc7d28016366882913ea295f0ea710" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt;es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b56244f1caeaf0b5b4e0b479de80d44c501b35d" translate="yes" xml:space="preserve">
          <source>The next step is interpolation in the text obtained, which is now delimiter-independent. There are multiple cases.</source>
          <target state="translated">Следующий шаг-интерполяция в полученном тексте,который теперь является разделительно-независимым.Случаев несколько.</target>
        </trans-unit>
        <trans-unit id="2e9d420a49c5570abf7ae9f3e075e9465afea859" translate="yes" xml:space="preserve">
          <source>The next step is the type-specific context processing; in this case &lt;code&gt;cx_popsub&lt;/code&gt;. In part, this looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b245543afec9985d508833acde280bdb2e09df89" translate="yes" xml:space="preserve">
          <source>The next step is to add some symlinks to system libraries. For example, the development software expect a library &lt;code&gt;libm.so&lt;/code&gt; that normally is a symlink to &lt;code&gt;libm.so.6&lt;/code&gt;. Synology only provides the latter and not the symlink.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e87f516f02471787ab2f018e28d7851e0ac5f9" translate="yes" xml:space="preserve">
          <source>The next step is to pop savestack entries: &lt;code&gt;CX_LEAVE_SCOPE(cx)&lt;/code&gt; is just defined as &lt;code&gt;LEAVE_SCOPE(cx-&amp;gt;blk_oldsaveix)&lt;/code&gt;. Note that during the popping, it's possible for perl to call destructors, call &lt;code&gt;STORE&lt;/code&gt; to undo localisations of tied vars, and so on. Any of these can die or call &lt;code&gt;exit()&lt;/code&gt;. In this case, &lt;code&gt;dounwind()&lt;/code&gt; will be called, and the current context stack frame will be re-processed. Thus it is vital that all steps in popping a context are done in such a way to support reentrancy. The other alternative, of decrementing &lt;code&gt;cxstack_ix&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d612978700e6928f957643eba3d0d61622b6ed" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system via email.</source>
          <target state="translated">Следующий шаг-отправить патч в основную билетную систему Perl по электронной почте.</target>
        </trans-unit>
        <trans-unit id="c53212a853da747bb753ac0eb206bd02a60002ca" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a6f456a2c90d50e2abfb7f37ee6f9a4299445f" translate="yes" xml:space="preserve">
          <source>The next task is to break the problem down into smaller problems that are easily converted into a regexp.</source>
          <target state="translated">Следующая задача-разбить проблему на более мелкие проблемы,которые легко преобразуются в регеxp.</target>
        </trans-unit>
        <trans-unit id="c9e21bae9fb5eef63978dcfa71c7a0d3cb21ec24" translate="yes" xml:space="preserve">
          <source>The next time you wish to make a patch, you need to start from the latest perl in a pristine state. Check you don't have any local changes or added files in your perl check-out which you wish to keep, then run these commands:</source>
          <target state="translated">В следующий раз,когда вы захотите сделать заплатку,вы должны начать с последнего perl в первозданном виде.Проверьте,нет ли у вас локальных изменений или добавленных файлов на perl,которые вы хотите сохранить,затем запустите эти команды:</target>
        </trans-unit>
        <trans-unit id="79f58ceb3f799f52310d0fb9160eed5d3d3eaba7" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is it's like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="translated">Хорошая часть о тестах todo,в отличие от простого комментирования блока тестов,это как иметь программный список todo.Вы знаете,сколько работы осталось сделать,вы знаете,какие есть ошибки,и сразу же узнаете,когда они будут исправлены.</target>
        </trans-unit>
        <trans-unit id="93f6c477375802df02f9578f889b424f60ac9928" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is that it is like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92737be37077b1e4ee6685cd7da7d12b0a775c27" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C requires that certain things be set up in the console before Visual C will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run the &lt;code&gt;vcvars32.bat&lt;/code&gt; file to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; or &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; . On a typical install of a Microsoft C compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files\Microsoft Visual Studio\VC98\Bin. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="translated">Для сборки достаточно nmake, поставляемого с Visual C ++. Visual C требует, чтобы определенные вещи были настроены в консоли, прежде чем Visual C успешно запустится. Чтобы консоль могла запускать компилятор C, вам необходимо заранее запустить файл &lt;code&gt;vcvars32.bat&lt;/code&gt; для компиляции для x86-32 и для x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; или &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; . При типичной установке продукта компилятора Microsoft C эти командные файлы уже будут в вашем &lt;code&gt;PATH&lt;/code&gt; переменная среды, поэтому вы можете просто ввести их без абсолютного пути в консоль. Если вам нужно найти абсолютный путь к пакетному файлу, он обычно находится где-то вроде C: \ Program Files \ Microsoft Visual Studio \ VC98 \ Bin. В некоторых новых продуктах Micrsoft C (выпущенных после ~ 2004 г.) программа установки поместит ярлык в меню &amp;laquo;Пуск&amp;raquo; для запуска нового окна консоли с консолью, уже настроенной для вашей целевой архитектуры (x86-32 или x86-64 или IA64). . С более новыми компиляторами вы также можете использовать старые командные файлы, если захотите.</target>
        </trans-unit>
        <trans-unit id="74b0871cc8ecf5b8ec07f0886c93ea7f99f29900" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C++ requires that certain things be set up in the console before Visual C++ will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run &lt;code&gt;vcvarsall.bat x86&lt;/code&gt; to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat amd64&lt;/code&gt;. On a typical install of a Microsoft C++ compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d92d9609b16a9236c6b0750e878097cebaf141fa" translate="yes" xml:space="preserve">
          <source>The nmake that comes with the Platform SDK will suffice for building Perl. Make sure you are building within one of the &quot;Build Environment&quot; shells available after you install the Platform SDK from the Start Menu.</source>
          <target state="translated">Nmake,которая поставляется с Платформой SDK,будет достаточно для создания Perl.Убедитесь,что вы собираете в одной из оболочек &quot;Build Environment&quot;,доступных после установки Комплекта SDK для платформы из меню &quot;Пуск&quot;.</target>
        </trans-unit>
        <trans-unit id="4cf437af831d898cd280f5f9fa16e3b19f38db9a" translate="yes" xml:space="preserve">
          <source>The node type, either &lt;code&gt;section&lt;/code&gt; or &lt;code&gt;item&lt;/code&gt; . As an unofficial type, there is also &lt;code&gt;hyperlink&lt;/code&gt; , derived from e.g. &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Тип узла: &lt;code&gt;section&lt;/code&gt; или &lt;code&gt;item&lt;/code&gt; . В качестве неофициального типа существует также &lt;code&gt;hyperlink&lt;/code&gt; , производная, например, от &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d0e0bd31f6a31a67e6263a3a5396fe920511c99" translate="yes" xml:space="preserve">
          <source>The non-ASCII characters below 256 can have various meanings, depending on various things. (See, most notably, &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) But usually the whole range can be referred to as ISO-8859-1. Often, the term &quot;Latin-1&quot; (or &quot;Latin1&quot;) is used as an equivalent for ISO-8859-1. But some people treat &quot;Latin1&quot; as referring just to the characters in the range 128 through 255, or somethimes from 160 through 255. This documentation uses &quot;Latin1&quot; and &quot;Latin-1&quot; to refer to all 256 characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6361a2e3097d12a5b1db2175b6f9b22e2b4e005e" translate="yes" xml:space="preserve">
          <source>The non-blocking behaviour is an extension of the &lt;code&gt;IO::Socket::INET&lt;/code&gt; API, unique to &lt;code&gt;IO::Socket::IP&lt;/code&gt;, because the former does not support multi-homed non-blocking connect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8827c5b69a11959983a358ee79f064e14c978f0c" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt; ):</source>
          <target state="translated">Неразрушающий модификатор &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; приводит к возврату результата подстановки вместо изменения &lt;code&gt;$_&lt;/code&gt; (или любой другой переменной, к которой подстановка была привязана с помощью &lt;code&gt;=~&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="33ea7bc6a1364954efde1784eb70e926a46ab789" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;s///r&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e24c19053882dd3539c4f0f017c48b302d8630" translate="yes" xml:space="preserve">
          <source>The non-zero numeric</source>
          <target state="translated">Ненулевое число</target>
        </trans-unit>
        <trans-unit id="ed0d308e2d36922ca367c5db784707665a50eda8" translate="yes" xml:space="preserve">
          <source>The normal Makefile.PL that h2xs generates doesn't know about the mylib directory. We need to tell it that there is a subdirectory and that we will be generating a library in it. Let's add the argument MYEXTLIB to the WriteMakefile call so that it looks like this:</source>
          <target state="translated">Обычный Makefile.PL,который генерирует h2xs,не знает о каталоге mylib.Мы должны сказать ему,что есть подкаталог,и что мы будем генерировать в нем библиотеку.Добавим аргумент MYEXTLIB к вызову WriteMakefile,чтобы он выглядел так:</target>
        </trans-unit>
        <trans-unit id="b1469f4963ec233a67445e77b1dc5adf4ccf9ab7" translate="yes" xml:space="preserve">
          <source>The normal course of action is to call:</source>
          <target state="translated">Обычное дело-позвонить:</target>
        </trans-unit>
        <trans-unit id="32723b8237682738b9e39db42e26b25a535a8b05" translate="yes" xml:space="preserve">
          <source>The normal return provided by &lt;code&gt;scalar(%hash)&lt;/code&gt; is not available. What this means is that using %tied_hash in boolean context doesn't work right (currently this always tests false, regardless of whether the hash is empty or hash elements). [ This paragraph needs review in light of changes in 5.25 ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf683f52c0f42f564cf7e0ed381f4bb97cc8438" translate="yes" xml:space="preserve">
          <source>The normal use of this class is like so:</source>
          <target state="translated">Обычное использование этого класса так и есть:</target>
        </trans-unit>
        <trans-unit id="1ac2010e9cf7828bd4211d3176636428b6a9a255" translate="yes" xml:space="preserve">
          <source>The normal way to run a Perl program is by making it directly executable, or else by passing the name of the source file as an argument on the command line. (An interactive Perl environment is also possible--see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; for details on how to do that.) Upon startup, Perl looks for your program in one of the following places:</source>
          <target state="translated">Обычный способ запустить программу Perl - сделать ее непосредственно исполняемой или передать имя исходного файла в качестве аргумента в командной строке. (Также возможна интерактивная среда Perl - см. &lt;a href=&quot;perldebug&quot;&gt;Perldebug,&lt;/a&gt; чтобы узнать, как это сделать.) При запуске Perl ищет вашу программу в одном из следующих мест:</target>
        </trans-unit>
        <trans-unit id="42b613b12f582e26d7e800d066ea1eb52e714a90" translate="yes" xml:space="preserve">
          <source>The not-a-number as a constant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46672cb58512b6dfcf1bfa852b6fb1012267b6a3" translate="yes" xml:space="preserve">
          <source>The notation still looks a little cumbersome, so there's one more abbreviation:</source>
          <target state="translated">Нотация все еще выглядит немного громоздкой,так что есть еще одна аббревиатура:</target>
        </trans-unit>
        <trans-unit id="faf2109c5b26dde1813deee78331f15408acfe4a" translate="yes" xml:space="preserve">
          <source>The notion that an empty &lt;b&gt;derived class&lt;/b&gt; should behave exactly like its &lt;b&gt;base class&lt;/b&gt;.</source>
          <target state="translated">Представление о том, что пустой &lt;b&gt;производный класс&lt;/b&gt; должен вести себя точно так же, как его &lt;b&gt;базовый класс&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d26e84b13c8c8748080fe4085da63e6e9ef520f9" translate="yes" xml:space="preserve">
          <source>The notion that you can tell an &lt;b&gt;object&lt;/b&gt; to do something generic, and the object will interpret the command in different ways depending on its type. [&amp;lt; Greek &amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, many forms.]</source>
          <target state="translated">Представление о том, что вы можете указать &lt;b&gt;объекту&lt;/b&gt; выполнить что-то общее, и объект будет интерпретировать команду по-разному в зависимости от ее типа. [&amp;lt;Греч. &amp;Pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, много форм.]</target>
        </trans-unit>
        <trans-unit id="ad272f88bed19c2e6cec366907b96e0baf112d7c" translate="yes" xml:space="preserve">
          <source>The notion that, with a complete set of simple tools that work well together, you can build almost anything you want. Which is fine if you&amp;rsquo;re assembling a tricycle, but if you&amp;rsquo;re building a defranishizing comboflux regurgalator, you really want your own machine shop in which to build special tools. Perl is sort of a machine shop.</source>
          <target state="translated">Идея о том, что с полным набором простых инструментов, которые хорошо работают вместе, вы можете построить практически все, что захотите. Это нормально, если вы собираете трехколесный велосипед, но если вы собираете регургалатор comboflux с дефранизацией, вам действительно нужен собственный цех, в котором можно будет создавать специальные инструменты. Perl - это что-то вроде механического цеха.</target>
        </trans-unit>
        <trans-unit id="d8cd6888cbc4c56537079a3ca6af05881fde2aca" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt; , which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="translated">Нулевой дескриптор файла &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; является особенным: его можно использовать для эмуляции поведения &lt;b&gt;sed&lt;/b&gt; и &lt;b&gt;awk&lt;/b&gt; , а также любой другой программы фильтрации Unix, которая принимает список имен файлов, делая то же самое для каждой строки ввода от всех из них. Входные данные из &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; поступают либо из стандартного ввода, либо из каждого файла, указанного в командной строке. Вот как это работает: при первом вычислении &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; &lt;code&gt;@ARGV&lt;/code&gt; массив @ARGV , и если он пуст, &lt;code&gt;$ARGV[0]&lt;/code&gt; устанавливается в &lt;code&gt;&quot;-&quot;&lt;/code&gt; , что при открытии дает стандартный ввод. Затем массив &lt;code&gt;@ARGV&lt;/code&gt; обрабатывается как список имен файлов. Петля</target>
        </trans-unit>
        <trans-unit id="2eb5648c665e9498b1d4e1c662b451796e069c6c" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt;, which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d22af8d2b7cf7cf2c570f3f335ab2a750c99b68" translate="yes" xml:space="preserve">
          <source>The null list is represented by (). Interpolating it in a list has no effect. Thus ((),(),()) is equivalent to (). Similarly, interpolating an array with no elements is the same as if no array had been interpolated at that point.</source>
          <target state="translated">Нулевой список представлен фигурой ().Интерполяция его в списке не имеет никакого эффекта.Таким образом,функция ((),(),())эквивалентна функции ().Аналогично,интерполяция массива без элементов такая же,как если бы в этот момент не было интерполировано ни одного массива.</target>
        </trans-unit>
        <trans-unit id="1797c45a73a5a87e1dcbfe3ceafa93cc5c4f9d01" translate="yes" xml:space="preserve">
          <source>The null loop times can be cached, the key being the number of rounds. The caching can be controlled using calls like these:</source>
          <target state="translated">Время цикла нуля может быть кэшировано,ключом является количество циклов.Кэшированием можно управлять с помощью подобных вызовов:</target>
        </trans-unit>
        <trans-unit id="c43d1fda274f03a112b4082e8056292b9c40d862" translate="yes" xml:space="preserve">
          <source>The number 0, the strings &lt;code&gt;'0'&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; , the empty list &lt;code&gt;()&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; are all false in a boolean context. All other values are true. Negation of a true value by &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; returns a special false value. When evaluated as a string it is treated as &lt;code&gt;&quot;&quot;&lt;/code&gt; , but as a number, it is treated as 0. Most Perl operators that return true or false behave this way.</source>
          <target state="translated">Число 0, строки &lt;code&gt;'0'&lt;/code&gt; и &lt;code&gt;&quot;&quot;&lt;/code&gt; , пустой список &lt;code&gt;()&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в логическом контексте ложны. Все остальные значения верны. Отрицание истинной ценности &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; возвращает специальное ложное значение. При оценке в виде строки он обрабатывается как &lt;code&gt;&quot;&quot;&lt;/code&gt; , но как число он обрабатывается как 0. Большинство операторов Perl, возвращающих истину или ложь, ведут себя подобным образом.</target>
        </trans-unit>
        <trans-unit id="692f2a5740e6be2f2f4c50b1195b7318b218c93b" translate="yes" xml:space="preserve">
          <source>The number after Perl (i.e. the 5 after Perl 5) is the major release of the perl interpreter as well as the version of the language. Each major version has significant differences that earlier versions cannot support.</source>
          <target state="translated">Номер после Perl (т.е.5 после Perl 5)является основным выпуском perl-переводчика,а также версией языка.Каждая основная версия имеет существенные различия,которые не могут быть поддержаны более ранними версиями.</target>
        </trans-unit>
        <trans-unit id="3191b134cb3717b47b8c71b05a1d940752bad987" translate="yes" xml:space="preserve">
          <source>The number for the &quot;generation&quot; of the test run. The first generation is 1 (one) and subsequent generations are 2, 3, etc.</source>
          <target state="translated">Номер для &quot;генерации&quot; тестового прогона.Первое поколение-1 (одно),а последующие-2,3 и т.д.</target>
        </trans-unit>
        <trans-unit id="2535d279c5200f7be07d31d15ce44068cdb20ffd" translate="yes" xml:space="preserve">
          <source>The number of &quot;hidden&quot; sectors for this partition. Actually this is the number of sectors found prior to this partition, that is, the starting offset [as found in &lt;code&gt;$uStartLow&lt;/code&gt; and &lt;code&gt;$ivStartHigh&lt;/code&gt;] divided by the number of bytes per sector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a9d7413ce0d5ac2d4144491992bf44868224aa" translate="yes" xml:space="preserve">
          <source>The number of bytes in each sector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa99ba7fda4b251af40087fa9ad0d33252bbd195" translate="yes" xml:space="preserve">
          <source>The number of concurrent jobs this formatter will handle.</source>
          <target state="translated">Количество параллельных заданий,с которыми будет работать эта форматура.</target>
        </trans-unit>
        <trans-unit id="36ffefa76cdb58a51fa74dc31caa513844b361e2" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after &lt;code&gt;av_fill()&lt;/code&gt; returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2ba45a48d3868e33de1ec7e956df019e81e42a" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after av_fill() returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt; .</source>
          <target state="translated">Количество элементов в массиве будет &lt;code&gt;fill + 1&lt;/code&gt; после возврата av_fill (). Если ранее массив был короче, то добавляемые дополнительные элементы устанавливаются в NULL. Если массив был длиннее, то лишние элементы освобождаются. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; совпадает с &lt;code&gt;av_clear(av)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9161f7d8230483ece3123e0d04957cb7a945f72" translate="yes" xml:space="preserve">
          <source>The number of items in a hash can be obtained by doing:</source>
          <target state="translated">Количество элементов в хэше можно получить,сделав это:</target>
        </trans-unit>
        <trans-unit id="e4c9a33204f057eb951c01e0df7449caf0e7389f" translate="yes" xml:space="preserve">
          <source>The number of lines left on the page of the currently selected output channel.</source>
          <target state="translated">Количество строк,оставшихся на странице текущего выбранного выходного канала.</target>
        </trans-unit>
        <trans-unit id="8b661ef45c3e83256fc7a63d23f91b2343af29ac" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt; . The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) variable. Many error messages report both values, if available.</source>
          <target state="translated">Количество строк, прочитанных до этой, плюс 1. Perl сохраняет отдельный номер строки для каждого исходного или входного файла, который он открывает. Номер строки текущего исходного файла представлен как &lt;code&gt;__LINE__&lt;/code&gt; . Текущий номер строки ввода (для файла, который был прочитан последним через &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ) представлен символом &lt;code&gt;$.&lt;/code&gt; ( &lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) переменная. Во многих сообщениях об ошибках указываются оба значения, если они доступны.</target>
        </trans-unit>
        <trans-unit id="2c32dc65a0983301d8b932b2ff7d13fbe8041de2" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt;. The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt;) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt;) variable. Many error messages report both values, if available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c26ea7021e22061094b1160120712623c26587e" translate="yes" xml:space="preserve">
          <source>The number of retrieval pointers that RMS has to maintain (0 to 127255)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7adfc7b3eafb7c58d678ada0cc8dfa22b0798638" translate="yes" xml:space="preserve">
          <source>The number of seconds the program ran for before being terminated, or 0 if no timeout occurred.</source>
          <target state="translated">Количество секунд,в течение которых программа выполнялась перед завершением,или 0,если таймаут не наступил.</target>
        </trans-unit>
        <trans-unit id="3f0ee453c0514a141454bf624811de74f7121fbc" translate="yes" xml:space="preserve">
          <source>The number of sectors in each track.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701c3dee8ddb529dd17cdf0b20bfe4db85c06698" translate="yes" xml:space="preserve">
          <source>The number of spaces to indent regular text, and the default indentation for &lt;code&gt;=over&lt;/code&gt; blocks. Defaults to 4.</source>
          <target state="translated">Количество пробелов для отступа обычного текста и отступ по умолчанию для &lt;code&gt;=over&lt;/code&gt; блоками. По умолчанию 4.</target>
        </trans-unit>
        <trans-unit id="e68baf88a8ecb32bf1315047769f8d0e186bb5f6" translate="yes" xml:space="preserve">
          <source>The number of tests actually seen</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65eb3487d858db8bd02f6c81679897d6d005441b" translate="yes" xml:space="preserve">
          <source>The number of tests in your script. This means all ok() and skip() calls.</source>
          <target state="translated">Количество тестов в вашем сценарии.Это означает все вызовы ok()и skip().</target>
        </trans-unit>
        <trans-unit id="7a3c79429902da3d2d3d81b8c529fe97388165ba" translate="yes" xml:space="preserve">
          <source>The number of tests that were planned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e2b7e50e91d743cd4a7b27aa45939dc1c6581f" translate="yes" xml:space="preserve">
          <source>The number of tests which failed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e318858e274a3b2d56e4e8546a3453a590b339" translate="yes" xml:space="preserve">
          <source>The number of tests with TODO directives.</source>
          <target state="translated">Количество тестов с директивами TODO.</target>
        </trans-unit>
        <trans-unit id="134bbf3c12ccdb3b17c2429c883dacdca5457a57" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;&quot;comp&quot;&lt;/a&gt; routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43b06bec0238ed7c22fd0d6e38144c2bb8f0d70" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; routine.</source>
          <target state="translated">Количество ссылок на структуру. Когда оно падает до 0, регулярное выражение автоматически освобождается вызовом pregfree. Это должно быть установлено на 1 в программе &lt;a href=&quot;#comp&quot;&gt;компенсации&lt;/a&gt; каждого двигателя .</target>
        </trans-unit>
        <trans-unit id="c7aa069edb979af7f298ec7da8f6245a682e62f6" translate="yes" xml:space="preserve">
          <source>The number of times the test has failed.</source>
          <target state="translated">Количество неудачных тестов.</target>
        </trans-unit>
        <trans-unit id="f294a946b3a2f3d15985548e48a89b85b334300e" translate="yes" xml:space="preserve">
          <source>The number of times the test has passed.</source>
          <target state="translated">Количество пройденных тестов.</target>
        </trans-unit>
        <trans-unit id="1ea0b9d7d53aa08d0e622974bcb543d8e9e34567" translate="yes" xml:space="preserve">
          <source>The number of tracks in each cylinder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ecf3312d862847aadfe59c31f3bcfa85cc3016b" translate="yes" xml:space="preserve">
          <source>The numbering within each branch will be as normal, and any groups following this construct will be numbered as though the construct contained only one branch, that being the one with the most capture groups in it.</source>
          <target state="translated">Нумерация внутри каждой ветви будет как обычно,и любые группы,следующие за этой конструкцией,будут пронумерованы так,как если бы конструкция содержала только одну ветвь,которая является той,в которой находится больше всего захватывающих групп.</target>
        </trans-unit>
        <trans-unit id="d3f5b7856c836d8ae15bae5d2911f695737356ba" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigFloat. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">Числа хранятся как объекты,и их внутренняя часть может измениться в любое время,особенно между математическими операциями.Объекты также могут принадлежать различным классам,таким как Math::BigInt или Math::BigFloat.Смешивание их вместе,даже при нормальных скалярах,не является экстраординарным,а нормальным и ожидаемым.</target>
        </trans-unit>
        <trans-unit id="0d52076285e4f235f1d8532711b46d3578467720" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigInt::Lite. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">Числа хранятся как объекты,и их внутренняя часть может измениться в любое время,особенно между математическими операциями.Объекты также могут принадлежать различным классам,таким как Math::BigInt или Math::BigInt::Lite.Смешивание их вместе,даже при нормальных скалярах,не является экстраординарным,а нормальным и ожидаемым.</target>
        </trans-unit>
        <trans-unit id="d62316f7524c3cde4e634f1fd21e7ac49fd46233" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to 0777), to be modified by the current &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="translated">Режим числовых разрешений, применяемый к каждому созданному каталогу (по умолчанию 0777), который должен быть изменен текущей &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; . Если каталог уже существует (и, следовательно, его не нужно создавать), разрешения не будут изменены.</target>
        </trans-unit>
        <trans-unit id="5dffd7d41fb958bc0c87e558861a514e1606e35f" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to &lt;code&gt;0777&lt;/code&gt;), to be modified by the current &lt;code&gt;umask&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e019f9571f72909dc6712d8ba72dd87f1a9db6" translate="yes" xml:space="preserve">
          <source>The numeric value of the COP's hint flags, or an empty string if this is not a COP.</source>
          <target state="translated">Числовое значение флагов подсказки COP,или пустая строка,если это не COP.</target>
        </trans-unit>
        <trans-unit id="419fea734cd75b36bfd625f906eafadf3594cbdf" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's flags.</source>
          <target state="translated">Числовое значение флагов ОП.</target>
        </trans-unit>
        <trans-unit id="e13f8ed0a121e4b7f2050aa9d7bd9bd36bdb9772" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's private flags.</source>
          <target state="translated">Числовое значение частных флагов ОП.</target>
        </trans-unit>
        <trans-unit id="afdb5b0bce9be5274063464faba90d66849c8cbe" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's targ.</source>
          <target state="translated">Числовое значение ТАРГА ОП.</target>
        </trans-unit>
        <trans-unit id="e4bd78ffa7c276231e5c09572ec79b0007d54b06" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's type, in decimal.</source>
          <target state="translated">Числовое значение типа ОП,в десятичной форме.</target>
        </trans-unit>
        <trans-unit id="38a4063b54e70e2579ef41b45391d9edbcb80e9f" translate="yes" xml:space="preserve">
          <source>The object actually used is of the class &lt;a href=&quot;ExtUtils::MY&quot;&gt;MY&lt;/a&gt; which allows you to override bits of MakeMaker inside your Makefile.PL by declaring MY::foo() methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a6a6fda3b81e72660dadfe40e0c6cbbf8b62d9b" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">Объект повторно благословляется в подкласс &lt;code&gt;IO::Handle&lt;/code&gt; и становится дескриптором на считывающем конце канала. Если заданы &lt;code&gt;ARGS&lt;/code&gt; , вызывается &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;ARGS&lt;/code&gt; передаются в exec.</target>
        </trans-unit>
        <trans-unit id="7b25df29627971e66202a04141c07ea01261d426" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">Объект повторно благословляется в подкласс &lt;code&gt;IO::Handle&lt;/code&gt; и становится дескриптором на записывающем конце канала. Если заданы &lt;code&gt;ARGS&lt;/code&gt; , вызывается &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;ARGS&lt;/code&gt; передаются в exec.</target>
        </trans-unit>
        <trans-unit id="fc8e459a67162585ed649c073732c1f153656661" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt;, and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;fork&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960d4697beb3f7754f165a72fa86b9e206ef71bf" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt;, and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;fork&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e63c161da60788dfbf25012eced379198e6461" translate="yes" xml:space="preserve">
          <source>The object or class on which a method is called is passed as one of the method's arguments, not as a separate &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="translated">Объект или класс, для которого вызывается метод, передается как один из аргументов метода, а не как отдельное значение &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac2428a9234f597f267cadbd7f0f16da4708e348" translate="yes" xml:space="preserve">
          <source>The object oriented interface lets you configure your own encoding or decoding style, within the limits of supported formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b98c3fd23a1ef70ae8197a79094d62be1e4c5c" translate="yes" xml:space="preserve">
          <source>The object oriented interface to &lt;code&gt;Digest::MD5&lt;/code&gt; is described in this section. After a &lt;code&gt;Digest::MD5&lt;/code&gt; object has been created, you will add data to it and finally ask for the digest in a suitable format. A single object can be used to calculate multiple digests.</source>
          <target state="translated">В этом разделе описывается объектно-ориентированный интерфейс к &lt;code&gt;Digest::MD5&lt;/code&gt; . После создания объекта &lt;code&gt;Digest::MD5&lt;/code&gt; вы добавите к нему данные и, наконец, запросите дайджест в подходящем формате. Один объект можно использовать для вычисления нескольких дайджестов.</target>
        </trans-unit>
        <trans-unit id="e33be9a872157d87d04d9ab372ad71b851a50cce" translate="yes" xml:space="preserve">
          <source>The object registry is also used to repair a field hash after thread cloning. Here, the entire object registry is processed. For every reference found there, the field hashes it has used are visited and the entry is updated.</source>
          <target state="translated">Реестр объектов также используется для ремонта хэша полей после клонирования потока.Здесь обрабатывается весь объектный реестр.Для каждой найденной там ссылки,хэши полей,которые он использовал,посещаются и запись обновляется.</target>
        </trans-unit>
        <trans-unit id="90c880f65630ae33e5e929b9f5badc61ea20d016" translate="yes" xml:space="preserve">
          <source>The object registry keeps track of references that have been used as field hash keys. The keys are generated from the reference address like in a field hash (though the registry isn't a field hash). Each value is a weak copy of the original reference, stored in an &lt;code&gt;SV&lt;/code&gt; that is itself magical (&lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; again). The magical structure holds a list (another hash, really) of field hashes that the reference has been used with. When the weakref becomes stale, the magic is activated and uses the list to delete the reference from all field hashes it has been used with. After that, the entry is removed from the object registry itself. Implicitly, that frees the magic structure and the storage it has been using.</source>
          <target state="translated">Реестр объектов отслеживает ссылки, которые использовались в качестве ключей хеширования полей. Ключи генерируются из ссылочного адреса, как в хэше поля (хотя реестр не является хешем поля). Каждое значение является слабой копией исходной ссылки, хранящейся в &lt;code&gt;SV&lt;/code&gt; , который сам по себе является магическим ( снова &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; ). Магическая структура содержит список (на самом деле еще один хеш) хешей полей, с которыми использовалась ссылка. Когда weakref становится устаревшим, магия активируется и использует список для удаления ссылки из всех хэшей полей, с которыми она использовалась. После этого запись удаляется из самого реестра объектов. Неявно это освобождает магическую структуру и хранилище, которое она использовала.</target>
        </trans-unit>
        <trans-unit id="d72391ab64988da73b0a894ff996ef426650aa27" translate="yes" xml:space="preserve">
          <source>The object returned by &lt;code&gt;builder()&lt;/code&gt; may change at runtime so you should call &lt;code&gt;builder()&lt;/code&gt; inside each function rather than store it in a global.</source>
          <target state="translated">Объект, возвращаемый &lt;code&gt;builder()&lt;/code&gt; может измениться во время выполнения, поэтому вы должны вызывать &lt;code&gt;builder()&lt;/code&gt; внутри каждой функции, а не сохранять его в глобальном.</target>
        </trans-unit>
        <trans-unit id="0c2931896c0ae38a7dcf1ceb36dc3228043fb889" translate="yes" xml:space="preserve">
          <source>The object will be serialised as a JSON null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce4a435aaab3b8ce3beeeab8876d2f9007b9517" translate="yes" xml:space="preserve">
          <source>The object will be serialised as a JSON number value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afec221431749f399e52c9677871688987dfbb46" translate="yes" xml:space="preserve">
          <source>The oct() function is commonly used when a string such as &lt;code&gt;644&lt;/code&gt; needs to be converted into a file mode, for example. Although Perl automatically converts strings into numbers as needed, this automatic conversion assumes base 10.</source>
          <target state="translated">Функция oct () обычно используется, когда, например, строку типа &lt;code&gt;644&lt;/code&gt; необходимо преобразовать в файловый режим. Хотя Perl автоматически преобразует строки в числа по мере необходимости, это автоматическое преобразование предполагает основание 10.</target>
        </trans-unit>
        <trans-unit id="09c9c348da6207c41e75d17f6b539e26d9c4cd1f" translate="yes" xml:space="preserve">
          <source>The official (threaded) builds from HP, as they are shipped on the Application DVD/CD's are available on &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt; for both PA-RISC and IPF (Itanium Processor Family). They are built with the HP ANSI-C compiler. Up till 5.8.8 that was done by ActiveState.</source>
          <target state="translated">Официальные (многопоточные) сборки HP, поставляемые на DVD / CD с приложениями, доступны на &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt; для обоих PA-RISC. и IPF (Семейство процессоров Itanium). Они построены с помощью компилятора HP ANSI-C. До 5.8.8 этим занимался ActiveState.</target>
        </trans-unit>
        <trans-unit id="94afd3df7a7936cd7021df875b7cc881f99b3a21" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at GitHub. Posting to the list and the bugtracker is not a right: all participants in discussion are expected to adhere to a standard of conduct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="122c2a7e4876853c52ff4c6bbc23491cac5b2166" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at rt.perl.org. All participants in discussion there are expected to adhere to a standard of conduct.</source>
          <target state="translated">Официальным форумом для разработки perl является список рассылки perl5-портеров,упомянутый выше,и его багтрекер на rt.perl.org.Ожидается,что все участники дискуссии там будут придерживаться стандарта поведения.</target>
        </trans-unit>
        <trans-unit id="206093c38ad914ff8435f60fe865bef14dbff945" translate="yes" xml:space="preserve">
          <source>The official home of this project on the web.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318a2a25e89f6df5d0fee0930895c69196eba39a" translate="yes" xml:space="preserve">
          <source>The official name of VMS as of this writing is OpenVMS.</source>
          <target state="translated">Официальное название VMS на момент написания статьи-OpenVMS.</target>
        </trans-unit>
        <trans-unit id="9e04119b1083995ffa8b809847e51388388f1606" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is</source>
          <target state="translated">Официальный сайт Berkeley DB является</target>
        </trans-unit>
        <trans-unit id="9ae89a7a7356b47202ed85668f00ace437b2ed69" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is &lt;a href=&quot;http://www.oracle.com/technology/products/berkeley-db/db/index.html&quot;&gt;http://www.oracle.com/technology/products/berkeley-db/db/index.html&lt;/a&gt;. All versions of Berkeley DB are available there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b569f6bcadd4a6fd7badb484a162b25dd85b5b2" translate="yes" xml:space="preserve">
          <source>The offset from the start of the file in hex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ba5881483f263a1268bc8d8cd7d41b8c76ce28" translate="yes" xml:space="preserve">
          <source>The old behavior is currently retained, warts and all, for backwards compatibility, but users are encouraged to change any code that tests &lt;code&gt;$!&lt;/code&gt; against &lt;code&gt;E*&lt;/code&gt; constants for Winsock errors to instead test &lt;code&gt;$^E&lt;/code&gt; against &lt;code&gt;WSAE*&lt;/code&gt; constants. After a suitable deprecation period, which started with Perl 5.24, the old behavior may be removed, leaving &lt;code&gt;$!&lt;/code&gt; unchanged after Winsock function calls, to avoid any possible confusion over which error variable to check.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
