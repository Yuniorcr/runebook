<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="9de554883aaffe5a62d4c8a36deea3a837fcd80d" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; returns true if the left argument is numerically greater than or equal to the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; возвращает истину, если левый аргумент численно больше или равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="a7454742c96c82ff2ca0ce93cf67bcd19286a557" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; returns true if the left argument is numerically less than the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; возвращает истину, если левый аргумент численно меньше правого аргумента.</target>
        </trans-unit>
        <trans-unit id="e6d03b55098c5e945a6cff21988ea84460d71573" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; returns the value of its left argument shifted left by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; возвращает значение своего левого аргумента, сдвинутое влево на количество битов, указанное в правом аргументе. Аргументы должны быть целыми числами. (См. Также &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Целочисленную арифметику&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="b5e75cae74350bd47fe89e9c43a86148805f25b1" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; returns true if the left argument is numerically less than or equal to the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; возвращает истину, если левый аргумент численно меньше или равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="c4b96fdd4c2b42fee6d143e7f60bc5e53b9a1f53" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is numerically less than, equal to, or greater than the right argument. If your platform supports &lt;code&gt;NaN&lt;/code&gt; 's (not-a-numbers) as numeric values, using them with &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns undef. &lt;code&gt;NaN&lt;/code&gt; is not &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;==&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; or &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; anything (even &lt;code&gt;NaN&lt;/code&gt; ), so those 5 return false. &lt;code&gt;NaN != NaN&lt;/code&gt; returns true, as does &lt;code&gt;NaN !=&lt;/code&gt;</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; возвращает -1, 0 или 1 в зависимости от того, является ли левый аргумент численно меньше, равен или больше правого аргумента. Если ваша платформа поддерживает &lt;code&gt;NaN&lt;/code&gt; (не числа) в виде числовых значений, использование их с &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; возвращает undef. &lt;code&gt;NaN&lt;/code&gt; не является чем-либо &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;==&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; или &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; (даже &lt;code&gt;NaN&lt;/code&gt; ), поэтому эти 5 возвращают false. &lt;code&gt;NaN != NaN&lt;/code&gt; возвращает истину, как и &lt;code&gt;NaN !=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d0148c51849abf03e9b94e765faa605e272cbf6" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;*&quot;&lt;/code&gt; multiplies two numbers.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;*&quot;&lt;/code&gt; умножает два числа.</target>
        </trans-unit>
        <trans-unit id="01756f918936276dfa8f0de39e3d878d679ba39b" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;**&quot;&lt;/code&gt; is the exponentiation operator. It binds even more tightly than unary minus, so &lt;code&gt;-2**4&lt;/code&gt; is &lt;code&gt;-(2**4)&lt;/code&gt; , not &lt;code&gt;(-2)**4&lt;/code&gt; . (This is implemented using C's &lt;code&gt;pow(3)&lt;/code&gt; function, which actually works on doubles internally.)</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;**&quot;&lt;/code&gt; - это оператор возведения в степень. Он связывает даже сильнее, чем унарный минус, поэтому &lt;code&gt;-2**4&lt;/code&gt; равно &lt;code&gt;-(2**4)&lt;/code&gt; , а не &lt;code&gt;(-2)**4&lt;/code&gt; . (Это реализовано с помощью функции C &lt;code&gt;pow(3)&lt;/code&gt; , которая фактически работает с двойниками внутри.)</target>
        </trans-unit>
        <trans-unit id="e565dc6efc9becadb2f620e3b56356ece28d9ea9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;+&quot;&lt;/code&gt; returns the sum of two numbers.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;+&quot;&lt;/code&gt; возвращает сумму двух чисел.</target>
        </trans-unit>
        <trans-unit id="d264c2219fd49edff5b7c850ac6db5ce0ccf6345" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;,&quot;&lt;/code&gt; is the comma operator. In scalar context it evaluates its left argument, throws that value away, then evaluates its right argument and returns that value. This is just like C's comma operator.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;,&quot;&lt;/code&gt; - оператор запятой. В скалярном контексте он оценивает свой левый аргумент, отбрасывает это значение, затем оценивает свой правый аргумент и возвращает это значение. Это похоже на оператор запятой в C.</target>
        </trans-unit>
        <trans-unit id="afc59f330a0626c101e37690bb504039ec265210" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;-&quot;&lt;/code&gt; returns the difference of two numbers.</source>
          <target state="translated">Двоичный знак &lt;code&gt;&quot;-&quot;&lt;/code&gt; возвращает разницу двух чисел.</target>
        </trans-unit>
        <trans-unit id="843c8445f5431d5cdfeffedb703a08e101bb0fa7" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;.&quot;&lt;/code&gt; concatenates two strings.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;.&quot;&lt;/code&gt; объединяет две строки.</target>
        </trans-unit>
        <trans-unit id="20b0ad876d72e0a4e92413d3b855b37c16cdc3ee" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;..&quot;&lt;/code&gt; is the range operator, which is really two different operators depending on the context. In list context, it returns a list of values counting (up by ones) from the left value to the right value. If the left value is greater than the right value then it returns the empty list. The range operator is useful for writing &lt;code&gt;foreach (1..10)&lt;/code&gt; loops and for doing slice operations on arrays. In the current implementation, no temporary array is created when the range operator is used as the expression in &lt;code&gt;foreach&lt;/code&gt; loops, but older versions of Perl might burn a lot of memory when you write something like this:</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;..&quot;&lt;/code&gt; - это оператор диапазона, который на самом деле представляет собой два разных оператора в зависимости от контекста. В контексте списка он возвращает список значений, отсчитываемых (на единицы) от левого значения к правому. Если левое значение больше правого, возвращается пустой список. Оператор диапазона полезен для написания циклов &lt;code&gt;foreach (1..10)&lt;/code&gt; и для выполнения операций среза над массивами. В текущей реализации временный массив не создается, когда оператор диапазона используется в качестве выражения в циклах &lt;code&gt;foreach&lt;/code&gt; , но более старые версии Perl могут сжигать много памяти, когда вы пишете что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="11d1e4ec8e23351f5601e3a5d4e0c431e5c430e4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;/&quot;&lt;/code&gt; divides two numbers.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;/&quot;&lt;/code&gt; делит два числа.</target>
        </trans-unit>
        <trans-unit id="f0b12adb8c84721a8d6934894abc35e4121a8c82" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;==&quot;&lt;/code&gt; returns true if the left argument is numerically equal to the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;==&quot;&lt;/code&gt; возвращает истину, если левый аргумент численно равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="e8178e90952cecccc1b319f7d1d8a9d3454e685e" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;=~&quot;&lt;/code&gt; binds a scalar expression to a pattern match. Certain operations search or modify the string &lt;code&gt;$_&lt;/code&gt; by default. This operator makes that kind of operation work on some other string. The right argument is a search pattern, substitution, or transliteration. The left argument is what is supposed to be searched, substituted, or transliterated instead of the default &lt;code&gt;$_&lt;/code&gt; . When used in scalar context, the return value generally indicates the success of the operation. The exceptions are substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;) and transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) with the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option, which cause the &lt;b&gt;r&lt;/b&gt;eturn value to be the result of the substitution. Behavior in list context depends on the particular operator. See &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators&lt;/a&gt; for details and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; for examples using these operators.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;=~&quot;&lt;/code&gt; связывает скалярное выражение с сопоставлением с образцом. Некоторые операции ищут или изменяют строку &lt;code&gt;$_&lt;/code&gt; по умолчанию. Этот оператор заставляет такую ​​операцию работать с другой строкой. Правильный аргумент - это шаблон поиска, подстановка или транслитерация. Левый аргумент - это то, что предполагается искать, заменять или транслитерировать вместо значения по умолчанию &lt;code&gt;$_&lt;/code&gt; . При использовании в скалярном контексте возвращаемое значение обычно указывает на успех операции. Исключениями являются подстановка ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ) и транслитерация ( &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ) с параметром &lt;code&gt;/r&lt;/code&gt; (неразрушающий), которые вызывают &lt;b&gt;r&lt;/b&gt;Возвратное значение будет результатом замены. Поведение в контексте списка зависит от конкретного оператора. См. Подробности в &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;разделе Операторы, &lt;/a&gt;&lt;a href=&quot;perlretut&quot;&gt;подобные кавычкам в Regexp,&lt;/a&gt; и примеры использования этих операторов.</target>
        </trans-unit>
        <trans-unit id="aa78120f553c43180d2a32604d493af25ed233d4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;^&quot;&lt;/code&gt; returns its operands XORed together bit by bit.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;^&quot;&lt;/code&gt; возвращает свои операнды, объединенные по принципу XOR, побитно.</target>
        </trans-unit>
        <trans-unit id="671e2c4625e970e48a9399520aaa4fa28b907022" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;and&quot;&lt;/code&gt; returns the logical conjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; except for the very low precedence. This means that it short-circuits: the right expression is evaluated only if the left expression is true.</source>
          <target state="translated">Двоичное &lt;code&gt;&quot;and&quot;&lt;/code&gt; возвращает логическое соединение двух окружающих выражений. Это эквивалент &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , за исключением очень низкого приоритета. Это означает, что он замыкается: правое выражение оценивается, только если левое выражение истинно.</target>
        </trans-unit>
        <trans-unit id="d3c04971ab5e03274c19bebb1ecd8b4175eeef29" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is stringwise less than, equal to, or greater than the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; возвращает -1, 0 или 1 в зависимости от того, является ли левый аргумент строковым меньшим, равным или большим, чем правый аргумент.</target>
        </trans-unit>
        <trans-unit id="1aa12faad44cec6a4de324dfb2d0d28e5041c165" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;eq&quot;&lt;/code&gt; returns true if the left argument is stringwise equal to the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;eq&quot;&lt;/code&gt; возвращает истину, если левый аргумент по строке равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="72766e64c0f2ce882d1581bc9a5363e487361650" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ge&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than or equal to the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;ge&quot;&lt;/code&gt; возвращает истину, если левый аргумент по строке больше или равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="8cbbb7f7848eee7ea44e5adae43d5c8ad553b087" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;gt&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;gt&quot;&lt;/code&gt; возвращает истину, если левый аргумент по строке больше правого аргумента.</target>
        </trans-unit>
        <trans-unit id="cbde6b024ab1e652daab583508091dcc611a1886" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;le&quot;&lt;/code&gt; returns true if the left argument is stringwise less than or equal to the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;le&quot;&lt;/code&gt; возвращает истину, если левый аргумент по строке меньше или равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="98038977bb137332bb318c163315bf5cd770bdda" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;lt&quot;&lt;/code&gt; returns true if the left argument is stringwise less than the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;lt&quot;&lt;/code&gt; возвращает истину, если левый аргумент по строке меньше правого аргумента.</target>
        </trans-unit>
        <trans-unit id="3426ef0b6b1032306f9e34d92f3217cb3cb8f9b5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ne&quot;&lt;/code&gt; returns true if the left argument is stringwise not equal to the right argument.</source>
          <target state="translated">Двоичное &lt;code&gt;&quot;ne&quot;&lt;/code&gt; возвращает истину, если левый аргумент по строке не равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="6e48afc6b41691d3b8112c62d6f3d75de7761a17" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;or&quot;&lt;/code&gt; returns the logical disjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;||&lt;/code&gt; except for the very low precedence. This makes it useful for control flow:</source>
          <target state="translated">Двоичное &lt;code&gt;&quot;or&quot;&lt;/code&gt; возвращает логическое разделение двух окружающих выражений. Это эквивалентно &lt;code&gt;||&lt;/code&gt; за исключением очень низкого приоритета. Это делает его полезным для потока управления:</target>
        </trans-unit>
        <trans-unit id="6eadcc721bf945b4975372194a62fd2f4732fb22" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;x&quot;&lt;/code&gt; is the repetition operator. In scalar context or if the left operand is not enclosed in parentheses, it returns a string consisting of the left operand repeated the number of times specified by the right operand. In list context, if the left operand is enclosed in parentheses or is a list formed by &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt;, it repeats the list. If the right operand is zero or negative (raising a warning on negative), it returns an empty string or an empty list, depending on the context.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;x&quot;&lt;/code&gt; - это оператор повторения. В скалярном контексте или если левый операнд не заключен в круглые скобки, он возвращает строку, состоящую из левого операнда, повторенного количество раз, указанное правым операндом. В контексте списка, если левый операнд заключен в круглые скобки или является списком, сформированным &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt; , он повторяет список. Если правый операнд равен нулю или отрицателен (возникает предупреждение об отрицательном результате), он возвращает пустую строку или пустой список, в зависимости от контекста.</target>
        </trans-unit>
        <trans-unit id="9999af54fad183fd5d0cedce55d894dad6f9d4fe" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;xor&quot;&lt;/code&gt; returns the exclusive-OR of the two surrounding expressions. It cannot short-circuit (of course).</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;xor&quot;&lt;/code&gt; возвращает исключающее ИЛИ двух окружающих выражений. Он не может закоротить (конечно).</target>
        </trans-unit>
        <trans-unit id="878a38ea354402b8caaeaced244837f05ba0dd57" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;|&quot;&lt;/code&gt; returns its operands ORed together bit by bit.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;|&quot;&lt;/code&gt; возвращает свои операнды, объединенные по принципу ИЛИ.</target>
        </trans-unit>
        <trans-unit id="b1489d43a3216d7ad2c82c2a95acd60755df1162" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;||&quot;&lt;/code&gt; performs a short-circuit logical OR operation. That is, if the left operand is true, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;||&quot;&lt;/code&gt; выполняет операцию логического ИЛИ короткого замыкания. То есть, если левый операнд истинен, правый операнд даже не оценивается. Скалярный контекст или контекст списка распространяется вниз до правого операнда, если он вычислен.</target>
        </trans-unit>
        <trans-unit id="f92bb398898c648f24279f387f99c6d49704c347" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;~~&quot;&lt;/code&gt; does a smartmatch between its arguments. Smart matching is described in the next section.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;~~&quot;&lt;/code&gt; выполняет интеллектуальное сопоставление своих аргументов. Интеллектуальное сопоставление описано в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="39d7bf96b3a657465e5f87b07b34fa4dafeb1ef4" translate="yes" xml:space="preserve">
          <source>Binary backward compatibility; this function is a macro but also has a &lt;code&gt;Perl_&lt;/code&gt; implementation (which is exported).</source>
          <target state="translated">Бинарная обратная совместимость; эта функция является макросом, но также имеет реализацию &lt;code&gt;Perl_&lt;/code&gt; (которая экспортируется).</target>
        </trans-unit>
        <trans-unit id="be16b35ee218fa359867cb0e97728996cffd42bc" translate="yes" xml:space="preserve">
          <source>Binary distributions for some proprietary platforms can be found &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt; directory. Because these are not part of the standard distribution, they may and in fact do differ from the base perl port in a variety of ways. You'll have to check their respective release notes to see just what the differences are. These differences can be either positive (e.g. extensions for the features of the particular platform that are not supported in the source release of perl) or negative (e.g. might be based upon a less current source release of perl).</source>
          <target state="translated">Бинарные дистрибутивы для некоторых проприетарных платформ можно найти в каталоге &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt; . Поскольку они не являются частью стандартного дистрибутива, они могут и действительно отличаются от базового порта Perl во многих отношениях. Вам нужно будет проверить соответствующие примечания к выпуску, чтобы увидеть, в чем различия. Эти различия могут быть как положительными (например, расширения для функций конкретной платформы, которые не поддерживаются в исходной версии perl), так и отрицательными (например, могут быть основаны на менее актуальной версии исходного кода perl).</target>
        </trans-unit>
        <trans-unit id="55fd3c0a11bb58bb23e20465875244f2ca59b441" translate="yes" xml:space="preserve">
          <source>Binary installer also creates a folder on your desktop with some useful objects. If you need to change some aspects of the work of the binary installer, feel free to edit the file</source>
          <target state="translated">Двоичный инсталлятор также создает папку на рабочем столе с некоторыми полезными объектами.Если вам нужно изменить некоторые аспекты работы бинарного инсталлятора,не стесняйтесь редактировать файл</target>
        </trans-unit>
        <trans-unit id="a1c1ba08fb761b34a695ec927e7b1037b80a83ca" translate="yes" xml:space="preserve">
          <source>Binary strings (byte strings)</source>
          <target state="translated">Двоичные строки (строки байтов)</target>
        </trans-unit>
        <trans-unit id="9a138af365fa894e34cab06b679f370e8157841c" translate="yes" xml:space="preserve">
          <source>Binding Operators</source>
          <target state="translated">Связывающие операторы</target>
        </trans-unit>
        <trans-unit id="73bb8553f0429ab1a4f3db6aa26eab8529fc1962" translate="yes" xml:space="preserve">
          <source>Binding together several statements in a macro</source>
          <target state="translated">Объединение нескольких утверждений в макро</target>
        </trans-unit>
        <trans-unit id="5549ae8d615ef700c81551ae6af123d2f95aacb7" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Привязывает сетевой адрес к сокету, как это делает bind (2). Возвращает true в случае успеха и false в противном случае. ИМЯ должно быть упакованным адресом соответствующего типа для сокета. См. Примеры в &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client / Server Communication in perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fa331f367a4577bd9809395dd5e94974930bded" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Привязывает сетевой адрес к сокету, как это делает bind (2). Возвращает true в случае успеха и false в противном случае. ИМЯ должно быть упакованным адресом соответствующего типа для сокета. См. Примеры в &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client / Server Communication in perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6974d8c4576a73016b6ecc19f5a2ebc538fab746" translate="yes" xml:space="preserve">
          <source>Birrell, Andrew D. An Introduction to Programming with Threads. Digital Equipment Corporation, 1989, DEC-SRC Research Report #35 online as &lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt; (highly recommended)</source>
          <target state="translated">Биррелл, Эндрю Д. Введение в программирование с помощью потоков. Digital Equipment Corporation, 1989, DEC-SRC Research Report # 35 онлайн по &lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;адресу ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt; (настоятельно рекомендуется)</target>
        </trans-unit>
        <trans-unit id="f6106638b60c4b72e8832174afe58ef2d3da9922" translate="yes" xml:space="preserve">
          <source>Bit Complement Operator ~ And vec()</source>
          <target state="translated">Оператор дополнения битов ~ And vec()</target>
        </trans-unit>
        <trans-unit id="c5e74747e30dab25d0878fbe61b78c61e44df4c0" translate="yes" xml:space="preserve">
          <source>Bit Strings</source>
          <target state="translated">Битовые струны</target>
        </trans-unit>
        <trans-unit id="833619884d42232d65498c141d5b13c648753213" translate="yes" xml:space="preserve">
          <source>Bits are the atoms in the memory world. Access to individual bits may have to be used either as a last resort or because it is the most convenient way to handle your data. Bit string (un)packing converts between strings containing a series of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; characters and a sequence of bytes each containing a group of 8 bits. This is almost as simple as it sounds, except that there are two ways the contents of a byte may be written as a bit string. Let's have a look at an annotated byte:</source>
          <target state="translated">Биты - это атомы в мире памяти. Доступ к отдельным битам может потребоваться либо как последнее средство, либо потому, что это наиболее удобный способ обработки ваших данных. Битовая строка (не) упаковка преобразуется между строками, содержащими серию из &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;1&lt;/code&gt; символов, и последовательность байтов, каждая из которых содержит группу из 8 бит. Это почти так же просто, как кажется, за исключением того, что есть два способа записать содержимое байта в виде битовой строки. Давайте посмотрим на аннотированный байт:</target>
        </trans-unit>
        <trans-unit id="8d8367155a1b407dd5a8766f2b3e58679136cc71" translate="yes" xml:space="preserve">
          <source>Bits that the &lt;b&gt;owner&lt;/b&gt; of a file sets or unsets to allow or disallow access to other people. These flag bits are part of the &lt;b&gt;mode&lt;/b&gt; word returned by the &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; built-in when you ask about a file. On Unix systems, you can check the</source>
          <target state="translated">Биты, которые &lt;b&gt;владелец&lt;/b&gt; файла устанавливает или снимает, чтобы разрешить или запретить доступ другим людям. Эти биты флага являются частью слова &lt;b&gt;режима,&lt;/b&gt; возвращаемого встроенной &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; когда вы спрашиваете о файле. В системах Unix вы можете проверить</target>
        </trans-unit>
        <trans-unit id="9166fa867213d69681d8dc9ba4c66e0e28bd7ae5" translate="yes" xml:space="preserve">
          <source>Bitstrings of any size may be manipulated by the bitwise operators (&lt;code&gt;~ | &amp;amp; ^&lt;/code&gt;).</source>
          <target state="translated">Битовые строки любого размера могут управляться поразрядными операторами ( &lt;code&gt;~ | &amp;amp; ^&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="55bcce66fdecceeb947a789cd32be9b93c7eca65" translate="yes" xml:space="preserve">
          <source>Bitwise And</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b636b8ad1b24ac557aa4eb2c5b388de819e1c9dc" translate="yes" xml:space="preserve">
          <source>Bitwise Or and Exclusive Or</source>
          <target state="translated">Прямо пропорционально или эксклюзивно,или</target>
        </trans-unit>
        <trans-unit id="e12b00fd649b7b2d92cbde1fe11e2e094a03730b" translate="yes" xml:space="preserve">
          <source>Bitwise String Operators</source>
          <target state="translated">Операторы с битовой струной</target>
        </trans-unit>
        <trans-unit id="3dc97888788cc1b09dac9d2412a98d54e24f8b1e" translate="yes" xml:space="preserve">
          <source>Bitwise operators</source>
          <target state="translated">Прямоточные операторы</target>
        </trans-unit>
        <trans-unit id="ea2480b20b616fff68feba2feb22ee1344013e9a" translate="yes" xml:space="preserve">
          <source>Blank lines between chunks that do different things.</source>
          <target state="translated">Пустые линии между кусочками,которые делают разные вещи.</target>
        </trans-unit>
        <trans-unit id="920da8ab7902a7645d8456f5c8da1988c54e0d83" translate="yes" xml:space="preserve">
          <source>Blessed References and Class Objects</source>
          <target state="translated">Благословенные Ссылки и объекты класса</target>
        </trans-unit>
        <trans-unit id="7954a73ad696d763789ec0de2fb44af6092e878a" translate="yes" xml:space="preserve">
          <source>Blesses an SV into a specified package. The SV must be an RV. The package must be designated by its stash (see &lt;code&gt;gv_stashpv()&lt;/code&gt; ). The reference count of the SV is unaffected.</source>
          <target state="translated">Благословляет SV в указанный пакет. SV должен быть RV. Пакет должен быть обозначен его &lt;code&gt;gv_stashpv()&lt;/code&gt; см. Gv_stashpv () ). Счетчик ссылок SV не изменяется.</target>
        </trans-unit>
        <trans-unit id="e54f1e0cbee429156b492ed8b4b751701cbcbd26" translate="yes" xml:space="preserve">
          <source>Blessing</source>
          <target state="translated">Blessing</target>
        </trans-unit>
        <trans-unit id="e84551f3c75d4af55438233d1c2c7909c862fc3b" translate="yes" xml:space="preserve">
          <source>Blindly passing va_list</source>
          <target state="translated">Слепое прохождение va_list</target>
        </trans-unit>
        <trans-unit id="929de0b7c4802448411e951e5153fd25660c3b1f" translate="yes" xml:space="preserve">
          <source>Blindly using variadic macros</source>
          <target state="translated">Слепое использование вариадических макросов</target>
        </trans-unit>
        <trans-unit id="9bf3b25756dcb70819ec2e3fa0ac57e7ce3a0990" translate="yes" xml:space="preserve">
          <source>Block names are matched in the compound form, like &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; or &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; . Unlike most other properties, only a few block names have a Unicode-defined short name. But Perl does provide a (slight, no longer recommended) shortcut: You can say, for example &lt;code&gt;\p{In_Arrows}&lt;/code&gt; or &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; .</source>
          <target state="translated">Имена блоков сопоставляются в составной форме, например &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; или &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; . В отличие от большинства других свойств, только несколько имен блоков имеют краткое имя, определенное в Unicode. Но Perl действительно предоставляет (небольшой, больше не рекомендуемый) ярлык: вы можете сказать, например, &lt;code&gt;\p{In_Arrows}&lt;/code&gt; или &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06992d2c6a4fd06aa405eff11e7109cec33fa12f" translate="yes" xml:space="preserve">
          <source>Blueprint</source>
          <target state="translated">Blueprint</target>
        </trans-unit>
        <trans-unit id="9febcf64ddd4a1c589fafb6acc27a333296a03c8" translate="yes" xml:space="preserve">
          <source>Body of the report. If not included on the command line, or in a file with &lt;b&gt;-f&lt;/b&gt;, you will get a chance to edit the message.</source>
          <target state="translated">Тело отчета. Если не указано в командной строке или в файле с параметром &lt;b&gt;-f&lt;/b&gt; , у вас будет возможность отредактировать сообщение.</target>
        </trans-unit>
        <trans-unit id="d2dcad692e8a39400b913368019fc7eef1d73269" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">Полужирный курсив (возможно, на самом деле наклонный) вариант шрифта фиксированной ширины. Pod :: Man не предполагает, что это у вас есть, и по умолчанию использует &lt;code&gt;CB&lt;/code&gt; . В некоторых системах (например, Solaris) этот шрифт доступен как &lt;code&gt;CX&lt;/code&gt; . Имеет значение только для вывода &lt;b&gt;troff&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="9e34e43ca3b41295b323939a7bd9811db605af24" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">Полужирный курсив (возможно, на самом деле наклонный) вариант шрифта фиксированной ширины. Pod :: Man не предполагает, что это у вас есть, и по умолчанию использует &lt;code&gt;CB&lt;/code&gt; . В некоторых системах (например, Solaris) этот шрифт доступен как &lt;code&gt;CX&lt;/code&gt; . Имеет значение только для вывода troff (1).</target>
        </trans-unit>
        <trans-unit id="b9abc1cd480871c700b51d43c9a44b554d40d55c" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">Полужирный вариант шрифта с фиксированной шириной. По умолчанию &lt;code&gt;CB&lt;/code&gt; . Имеет значение только для вывода &lt;b&gt;troff&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="73204c593462d6c14f32f02ba63b55da40420528" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">Полужирный вариант шрифта с фиксированной шириной. По умолчанию &lt;code&gt;CB&lt;/code&gt; . Имеет значение только для вывода troff (1).</target>
        </trans-unit>
        <trans-unit id="ca3cddd25bd8f6bc4ce35a262e2e1398541ecf3d" translate="yes" xml:space="preserve">
          <source>Bookmarks</source>
          <target state="translated">Bookmarks</target>
        </trans-unit>
        <trans-unit id="fbe3448227f9beab3e352c0b7e28a363ba97c273" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, failing to have the required modules (or the right versions thereof) will be fatal. &lt;code&gt;perl Makefile.PL&lt;/code&gt; will &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; instead of simply informing the user of the missing dependencies.</source>
          <target state="translated">Bool. Если этот параметр равен true, отсутствие необходимых модулей (или их правильных версий) будет фатальным. &lt;code&gt;perl Makefile.PL&lt;/code&gt; будет &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; вместо того , чтобы просто информировать пользователя о недостающих зависимостей.</target>
        </trans-unit>
        <trans-unit id="1a706d5f747a56fb59b2b20adabd115aadfc3ab6" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, the prerequisites will be printed to stdout and MakeMaker will exit. The output format is an evalable hash ref.</source>
          <target state="translated">Булл.Если этот параметр верен,то предварительные условия будут распечатаны в stdout и MakeMaker выйдет.Формат вывода-оценочный хэш-ссылку.</target>
        </trans-unit>
        <trans-unit id="cee421eba15aa24904646f6184653841c5c549d1" translate="yes" xml:space="preserve">
          <source>Boolean methods</source>
          <target state="translated">логические методы</target>
        </trans-unit>
        <trans-unit id="02774d2bd49b309c70bcbf1cd2d7f51fdc3d2b2f" translate="yes" xml:space="preserve">
          <source>Boolean operators</source>
          <target state="translated">логические операторы</target>
        </trans-unit>
        <trans-unit id="1e109ffb226c19879bd546df66c824f1e645625c" translate="yes" xml:space="preserve">
          <source>Boolean options:</source>
          <target state="translated">Булевые варианты:</target>
        </trans-unit>
        <trans-unit id="c8c3f1d753ec555418a750eeff6d7eaeba2abf76" translate="yes" xml:space="preserve">
          <source>Boolean value. If false, disables the &lt;code&gt;X/Y&lt;/code&gt; test count which shows up while tests are running.</source>
          <target state="translated">Логическое значение. Если false, отключает счетчик тестов &lt;code&gt;X/Y&lt;/code&gt; , который отображается во время выполнения тестов.</target>
        </trans-unit>
        <trans-unit id="f6906832f4c5efb1eff6981bd8a551cf05deba12" translate="yes" xml:space="preserve">
          <source>Boolean which tells MakeMaker that it should include the rules to make a perl. This is handled automatically as a switch by MakeMaker. The user normally does not need it.</source>
          <target state="translated">Булева,которая говорит MakeMaker,что он должен включать в себя правила,чтобы сделать perl.Это автоматически обрабатывается как переключатель в MakeMaker.Обычно он не нужен пользователю.</target>
        </trans-unit>
        <trans-unit id="a3aa9ead54da3d9f1481bd131dbbec1f59ea0c12" translate="yes" xml:space="preserve">
          <source>Boolean. Attribute to inhibit descending into subdirectories.</source>
          <target state="translated">Булев.Атрибут для блокировки спуска в подкаталоги.</target>
        </trans-unit>
        <trans-unit id="7cf7bb36f8e532fed41b905555bc401b988f86c8" translate="yes" xml:space="preserve">
          <source>Boss/Worker</source>
          <target state="translated">Boss/Worker</target>
        </trans-unit>
        <trans-unit id="80bcf52e7840ffd18cf3865b5ebb50a306bef71b" translate="yes" xml:space="preserve">
          <source>Both &quot;objects&quot; which are blessed into the class &lt;code&gt;two_refs1&lt;/code&gt; are references to a reference to an array, thus references to a</source>
          <target state="translated">Оба &amp;laquo;объекта&amp;raquo;, которые включены в класс &lt;code&gt;two_refs1&lt;/code&gt; , являются ссылками на ссылку на массив, таким образом, ссылаются на</target>
        </trans-unit>
        <trans-unit id="fdd5582984ca6c53c867eacfa38935bd769631ff" translate="yes" xml:space="preserve">
          <source>Both #1 and #2 make $data consist of a completely valid UTF-8 string, but only #2 turns the UTF8 flag on. #1 is equivalent to:</source>
          <target state="translated">И #1,и #2 делают $data состоящим из полностью действительной строки UTF-8,но только #2 включает флаг UTF8.#1 эквивалентно:</target>
        </trans-unit>
        <trans-unit id="e055e854ed20a46d2f7df7544241f7588b51f8b0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;bsstr()&lt;/code&gt; as well as automated stringify via overload now drop the leading '+'. The old code would return '+3', the new returns '3'. This is to be consistent with Perl and to make &lt;code&gt;cmp&lt;/code&gt; (especially with overloading) to work as you expect. It also solves problems with &lt;code&gt;Test.pm&lt;/code&gt; and &lt;a href=&quot;../test/more&quot;&gt;Test::More&lt;/a&gt;, which stringify arguments before comparing them.</source>
          <target state="translated">Как &lt;code&gt;bstr()&lt;/code&gt; и &lt;code&gt;bsstr()&lt;/code&gt; а также автоматическое преобразование в строку с помощью перегрузки теперь удаляют начальный знак &quot;+&quot;. Старый код вернет &amp;laquo;+3&amp;raquo;, новый - &amp;laquo;3&amp;raquo;. Это должно согласовываться с Perl и заставить &lt;code&gt;cmp&lt;/code&gt; (особенно с перегрузкой) работать так, как вы ожидаете. Он также решает проблемы с &lt;code&gt;Test.pm&lt;/code&gt; и &lt;a href=&quot;../test/more&quot;&gt;Test :: More&lt;/a&gt; , которые преобразовывают аргументы в строку перед их сравнением.</target>
        </trans-unit>
        <trans-unit id="eaeb9ffa94e14cf78c87073a072611e3232fa148" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; and &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; will return &lt;code&gt;MAYBE&lt;/code&gt; . &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is not in NFC (its NFC is &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ), while &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is in NFC.</source>
          <target state="translated">Оба &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; и &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; вернут &lt;code&gt;MAYBE&lt;/code&gt; . &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; не находится в NFC (его NFC - это &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ), а &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; находится в NFC.</target>
        </trans-unit>
        <trans-unit id="24cf9e2240da639243f4502d5aa3bda3947c5953" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; croak if given dates outside the supported range.</source>
          <target state="translated">И &lt;code&gt;timelocal()&lt;/code&gt; и &lt;code&gt;timegm()&lt;/code&gt; квакают, если указаны даты за пределами поддерживаемого диапазона.</target>
        </trans-unit>
        <trans-unit id="9b6b1830495cedccd8298426103e7c2b6bedc5b6" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;wrap()&lt;/code&gt; and &lt;code&gt;fill()&lt;/code&gt; return a single string.</source>
          <target state="translated">Оба &lt;code&gt;wrap()&lt;/code&gt; и &lt;code&gt;fill()&lt;/code&gt; возвращают одну строку.</target>
        </trans-unit>
        <trans-unit id="a3b45c366057bea34b5a8bb7824f2e8dd99b7496" translate="yes" xml:space="preserve">
          <source>Both Perl functions will expect an object as the first parameter. In the generated C++ code the object is called &lt;code&gt;THIS&lt;/code&gt; , and the method call will be performed on this object. So in the C++ code the blue() and set_blue() methods will be called as this:</source>
          <target state="translated">Обе функции Perl ожидают объект в качестве первого параметра. В сгенерированном коде C ++ объект называется &lt;code&gt;THIS&lt;/code&gt; , и вызов метода будет выполняться для этого объекта. Итак, в коде C ++ методы blue () и set_blue () будут вызываться следующим образом:</target>
        </trans-unit>
        <trans-unit id="642b008f0bb09ab02b4608dfe561ba3f906e665d" translate="yes" xml:space="preserve">
          <source>Both YAML.pm and YAML::Syck are capable of deserialising code. As this requires a string eval, which might be a security risk, you can use this option to enable or disable the deserialisation of code via CPAN::DeferredCode. (Note: This does not work under perl 5.6)</source>
          <target state="translated">Как YAML.pm,так и YAML::Syck способны десериализовать код.Поскольку для этого требуется оценка строки,что может представлять риск для безопасности,вы можете использовать эту опцию для включения или отключения десериализации кода с помощью CPAN::DeferredCode.(Замечание:Это не работает в соответствии с разделом 5.6).</target>
        </trans-unit>
        <trans-unit id="1092e6af8de8fc50cc6d06fd73a32b5d8423a7e9" translate="yes" xml:space="preserve">
          <source>Both are bad, and broken, and unportable. Use the PTR2IV() macro that does it right. (Likewise, there are PTR2UV(), PTR2NV(), INT2PTR(), and NUM2PTR().)</source>
          <target state="translated">И то,и другое плохо,и сломано,и непредсказуемо.Используйте макрос PTR2IV(),который делает это правильно.(Также есть PTR2UV(),PTR2NV(),INT2PTR()и NUM2PTR()).</target>
        </trans-unit>
        <trans-unit id="d3767903b8fab9710d5f5dbf8d10a9f6252cdd29" translate="yes" xml:space="preserve">
          <source>Both efforts welcome volunteers. In order to get involved in smoke testing of the perl itself visit &lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http://search.cpan.org/dist/Test-Smoke/&lt;/a&gt;. In order to start smoke testing CPAN modules visit &lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.org/dist/CPAN-Reporter/&lt;/a&gt;.</source>
          <target state="translated">Оба проекта приветствуют добровольцев. Чтобы принять участие в дымовом тестировании самого perl, посетите &lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http://search.cpan.org/dist/Test-Smoke/&lt;/a&gt; . Чтобы начать дымовое тестирование модулей CPAN, посетите &lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt; или &lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt; или &lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.org / dist / CPAN-Reporter /&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a1c59ffc42033f2c98187249f767826197ba8a8" translate="yes" xml:space="preserve">
          <source>Both forms are equivalent.</source>
          <target state="translated">Обе формы эквивалентны.</target>
        </trans-unit>
        <trans-unit id="143f2cf2fc37f6046de22ba46473032b532447b9" translate="yes" xml:space="preserve">
          <source>Both functions return equivalent information (like &lt;code&gt;gettimeofday&lt;/code&gt; ) but with different representations. The names &lt;code&gt;NVtime&lt;/code&gt; and &lt;code&gt;U2time&lt;/code&gt; were selected mainly because they are operating system independent. (&lt;code&gt;gettimeofday&lt;/code&gt; is Unix-centric, though some platforms like Win32 and VMS have emulations for it.)</source>
          <target state="translated">Обе функции возвращают эквивалентную информацию (например, &lt;code&gt;gettimeofday&lt;/code&gt; ), но с разными представлениями. Названия &lt;code&gt;NVtime&lt;/code&gt; и &lt;code&gt;U2time&lt;/code&gt; были выбраны в основном потому, что они не зависят от операционной системы. ( &lt;code&gt;gettimeofday&lt;/code&gt; ориентирован на Unix, хотя на некоторых платформах, таких как Win32 и VMS, есть эмуляции для него.)</target>
        </trans-unit>
        <trans-unit id="0b934a70ce89ebfca7d59daaef7b8bcbcd00a0ef" translate="yes" xml:space="preserve">
          <source>Both install() and uninstall() are specific to the way ExtUtils::MakeMaker handles the installation and deinstallation of perl modules. They are not designed as general purpose tools.</source>
          <target state="translated">И install(),и uninstall()специфичны для способа,которым ExtUtils::MakeMaker управляет установкой и деинсталляцией perl модулей.Они не предназначены для общего использования.</target>
        </trans-unit>
        <trans-unit id="9733ec84f2ee4e84fe6e0d43084959736e1c222c" translate="yes" xml:space="preserve">
          <source>Both numeric and string values are accepted, but note that string values are case sensitive. The default for this setting is &quot;RANDOM&quot; or 1.</source>
          <target state="translated">Принимаются как числовые,так и строковые значения,но учтите,что строковые значения чувствительны к регистру.По умолчанию эта настройка имеет значение &quot;RANDOM&quot; или 1.</target>
        </trans-unit>
        <trans-unit id="4cf5f58736e6000e5a6bd77d8280326d1b82a931" translate="yes" xml:space="preserve">
          <source>Both of the above match the characters &lt;code&gt;\N{U+00}&lt;/code&gt;&lt;code&gt;\N{U+01}&lt;/code&gt; , ... &lt;code&gt;\N{U+08}&lt;/code&gt; , &lt;code&gt;\N{U+09}&lt;/code&gt; , but the &lt;code&gt;\x09&lt;/code&gt; looks like it could be a mistake so the warning is raised (under &lt;code&gt;re 'strict'&lt;/code&gt; ) for it.</source>
          <target state="translated">Оба приведенных выше символа соответствуют символам &lt;code&gt;\N{U+00}&lt;/code&gt; &lt;code&gt;\N{U+01}&lt;/code&gt; , ... &lt;code&gt;\N{U+08}&lt;/code&gt; , &lt;code&gt;\N{U+09}&lt;/code&gt; , но &lt;code&gt;\x09&lt;/code&gt; выглядит так, как будто это могло быть ошибка, поэтому для нее выдается предупреждение (как &lt;code&gt;re 'strict'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d4874cd0d5b99351b1bf775f190f16f304b87eaf" translate="yes" xml:space="preserve">
          <source>Both read and write access.</source>
          <target state="translated">Доступ как для чтения,так и для записи.</target>
        </trans-unit>
        <trans-unit id="e56fad1d57355bf08ff94859ec86b0170dc6755c" translate="yes" xml:space="preserve">
          <source>Both routines return a reference to the hash operated on.</source>
          <target state="translated">Обе программы возвращают ссылку на управляемый хэш.</target>
        </trans-unit>
        <trans-unit id="7a1480fdf3f98f2170cd256ce3b56c618e9acd2d" translate="yes" xml:space="preserve">
          <source>Both signify the monospace (c[ode] style) text consisting of &quot;$x&quot;, one space, &quot;?&quot;, one space, &quot;:&quot;, one space, &quot;$z&quot;. The difference is that in the latter, with the S code, those spaces are not &quot;normal&quot; spaces, but instead are non-breaking spaces.</source>
          <target state="translated">Оба обозначают текст в стиле монопространства (c[ода]),состоящий из &quot;$x&quot;,одного пробела,&quot;?&quot;,одного пробела,&quot;:&quot;,одного пробела,&quot;$z&quot;.Разница состоит в том,что в последнем,с кодом S,эти пробелы не являются &quot;нормальными&quot;,а являются неразрывными пробелами.</target>
        </trans-unit>
        <trans-unit id="ce9280ff05f374fc2e82bcdbf91ea7cf106541bf" translate="yes" xml:space="preserve">
          <source>Both stringify and bstr() now drop the leading '+'. The old code would return '+1.23', the new returns '1.23'. See the documentation in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for reasoning and details.</source>
          <target state="translated">И stringify, и bstr () теперь отбрасывают ведущий &quot;+&quot;. Старый код вернет &amp;laquo;+1,23&amp;raquo;, новый - &amp;laquo;1,23&amp;raquo;. См. Документацию в &lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt; для объяснения и подробностей.</target>
        </trans-unit>
        <trans-unit id="6e26a4aa31b6884fed4ace8e2ed5cfef52233768" translate="yes" xml:space="preserve">
          <source>Both styles work with either objects or typeglobs of real filehandles. (They might also work with strings under some circumstances, but this is risky.)</source>
          <target state="translated">Оба стиля работают либо с объектами,либо с печатными шрифтами реальных файловых ручек.(При некоторых обстоятельствах они также могут работать со строками,но это рискованно).</target>
        </trans-unit>
        <trans-unit id="40008ef1178df5187f4e9e86678b099b5c9935cc" translate="yes" xml:space="preserve">
          <source>Both subroutines here are called in a scalar context, while in:</source>
          <target state="translated">Обе подпрограммы здесь вызываются в скалярном контексте,в то время как внутри:</target>
        </trans-unit>
        <trans-unit id="5b8819b78d506b9303c55ca1c6cd1ccf91f01b90" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;$key&lt;/code&gt; and &lt;code&gt;$value&lt;/code&gt; parameters will be set to the key/value pair read from the database.</source>
          <target state="translated">Оба параметра &lt;code&gt;$key&lt;/code&gt; и &lt;code&gt;$value&lt;/code&gt; будут установлены на пару ключ / значение, прочитанную из базы данных.</target>
        </trans-unit>
        <trans-unit id="65ffa77ee21f2f134768654239d413a7ca561444" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;FETCH&lt;/code&gt; ing function and the &lt;code&gt;EXISTS&lt;/code&gt; functions have the same signature: the arguments are &lt;code&gt;$key, $data&lt;/code&gt; ; $data is the same value as given as argument during tie()ing. Both functions should return an empty list if the value does not exist. If &lt;code&gt;EXISTS&lt;/code&gt; function is different from the &lt;code&gt;FETCH&lt;/code&gt; ing function, it should return a TRUE value on success. The &lt;code&gt;FETCH&lt;/code&gt; ing function should return the intended value if the key is valid.</source>
          <target state="translated">И функция &lt;code&gt;FETCH&lt;/code&gt; ing, и функции &lt;code&gt;EXISTS&lt;/code&gt; имеют одинаковую сигнатуру: аргументы - &lt;code&gt;$key, $data&lt;/code&gt; ; $ data - это то же значение, что и аргумент во время tie () ing. Обе функции должны возвращать пустой список, если значение не существует. Если функция &lt;code&gt;EXISTS&lt;/code&gt; отличается от функции &lt;code&gt;FETCH&lt;/code&gt; ing, она должна вернуть значение ИСТИНА в случае успеха. Функция &lt;code&gt;FETCH&lt;/code&gt; ing должна возвращать предполагаемое значение, если ключ действителен.</target>
        </trans-unit>
        <trans-unit id="a6ed4eca63dc77f9c5ab93bb8224d63244af078a" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;\p&lt;/code&gt; counterparts always assume Unicode rules are in effect. On ASCII platforms, this means they assume that the code points from 128 to 255 are Latin-1, and that means that using them under locale rules is unwise unless the locale is guaranteed to be Latin-1 or UTF-8. In contrast, the POSIX character classes are useful under locale rules. They are affected by the actual rules in effect, as follows:</source>
          <target state="translated">Оба экземпляра &lt;code&gt;\p&lt;/code&gt; всегда предполагают, что действуют правила Unicode. На платформах ASCII это означает, что они предполагают, что кодовые точки от 128 до 255 - это Latin-1, а это означает, что использовать их в соответствии с правилами локали неразумно, если только локаль не гарантированно будет Latin-1 или UTF-8. Напротив, классы символов POSIX полезны в соответствии с правилами локали. На них влияют действующие правила, а именно:</target>
        </trans-unit>
        <trans-unit id="ce95f2fe752d4b23fc80e241799a0c7676e9a5d9" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;filter&lt;/code&gt; method used with a</source>
          <target state="translated">Оба метода &lt;code&gt;filter&lt;/code&gt; используемые с</target>
        </trans-unit>
        <trans-unit id="16bb52db9f75f89e8e102ba17368f296bd30bb0a" translate="yes" xml:space="preserve">
          <source>Both the Store and Fetch filters manipulate &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">Фильтры Store и Fetch управляют &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76973f944d78d30e634a5b0ebc6b4adb75da6f43" translate="yes" xml:space="preserve">
          <source>Both the functions can import the functions that are specified.</source>
          <target state="translated">Обе функции могут импортировать указанные функции.</target>
        </trans-unit>
        <trans-unit id="2ad856a815b0ce3afb8156093d09ab25a9afd217" translate="yes" xml:space="preserve">
          <source>Both the main process and any child processes it forks share the same STDIN, STDOUT, and STDERR filehandles. If both processes try to access them at once, strange things can happen. You may also want to close or reopen the filehandles for the child. You can get around this by opening your pipe with open(), but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">Как основной процесс,так и любые дочерние процессы вилки имеют одинаковые файловые дескрипторы STDIN,STDOUT и STDERR.Если оба процесса попытаются получить доступ к ним одновременно,могут произойти странные вещи.Вы также можете захотеть закрыть или открыть заново файловые дескрипторы для дочернего процесса.Вы можете обойти это,открыв канал с помощью open(),но на некоторых системах это означает,что дочерний процесс не может пережить родителя.</target>
        </trans-unit>
        <trans-unit id="449435c9cac23bf8a94ca4fcd8681004ec825181" translate="yes" xml:space="preserve">
          <source>Both the main process and the backgrounded one (the &quot;child&quot; process) share the same STDIN, STDOUT and STDERR filehandles. If both try to access them at once, strange things can happen. You may want to close or reopen these for the child. You can get around this with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;ing a pipe (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">И основной процесс, и фоновый (&amp;laquo;дочерний&amp;raquo; процесс) используют одни и те же дескрипторы файлов STDIN, STDOUT и STDERR. Если оба попытаются получить к ним доступ одновременно, могут произойти странные вещи. Вы можете закрыть или снова открыть их для ребенка. Вы можете обойти это, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; канал (см. &lt;a href=&quot;functions/open&quot;&gt;Open&lt;/a&gt; ), но в некоторых системах это означает, что дочерний процесс не может пережить родительский.</target>
        </trans-unit>
        <trans-unit id="12969a7fe698e5db30d6dfa2ac116b77818d15ac" translate="yes" xml:space="preserve">
          <source>Both the special and normal mappings are stored in</source>
          <target state="translated">Как специальные,так и обычные картографические отображения хранятся в</target>
        </trans-unit>
        <trans-unit id="1a5aa8697bdd1c4c4522254cc3fbbee82434df88" translate="yes" xml:space="preserve">
          <source>Both these XS declarations correspond to the &lt;code&gt;char*&lt;/code&gt; C type, but they have different semantics, see &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt;.</source>
          <target state="translated">Оба этих объявления XS соответствуют типу &lt;code&gt;char*&lt;/code&gt; C, но имеют разную семантику, см &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;. Унарный оператор &amp;amp;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="457d0ea6cab97df36f6f6888a3f8a1c477cbe9c0" translate="yes" xml:space="preserve">
          <source>Both these methods insert &lt;code&gt;&quot;:full&quot;&lt;/code&gt; automatically as the first argument (if no other argument is given), and you can give the &lt;code&gt;&quot;:full&quot;&lt;/code&gt; explicitly as well, like</source>
          <target state="translated">Оба этих метода автоматически вставляют &lt;code&gt;&quot;:full&quot;&lt;/code&gt; в качестве первого аргумента (если не указан другой аргумент), и вы также можете явно указать &lt;code&gt;&quot;:full&quot;&lt;/code&gt; , например</target>
        </trans-unit>
        <trans-unit id="a673297be17d984a1ebfc2f484aa63db04fb7bb3" translate="yes" xml:space="preserve">
          <source>Both these problems can be cured. Say, if we want to overload hash dereference on a reference to an object which is</source>
          <target state="translated">Обе эти проблемы можно вылечить.Скажем,если мы хотим перегрузить хэш-рассылку на ссылку на объект,которым является</target>
        </trans-unit>
        <trans-unit id="c67dbd5c074e12563a96469c299bb554a98bb89b" translate="yes" xml:space="preserve">
          <source>Both wdayname (day) and monname (month) allow passing in a list to use to index the name of the days against. This can be useful if you need to implement some form of localisation without actually installing or using locales.</source>
          <target state="translated">Как имя дня (день),так и имя месяца (месяц)позволяют пропустить в списке для индексации названия дней.Это может быть полезно,если вам необходимо реализовать некую форму локализации без фактической установки или использования локалей.</target>
        </trans-unit>
        <trans-unit id="5f50d687ceecfadfb877f247a6453725043a7ffb" translate="yes" xml:space="preserve">
          <source>Bottom level UTF-8 decode routine. Returns the native code point value of the first character in the string &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than &lt;code&gt;curlen&lt;/code&gt; bytes; &lt;code&gt;*retlen&lt;/code&gt; (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) will be set to the length, in bytes, of that character.</source>
          <target state="translated">Подпрограмма декодирования UTF-8 нижнего уровня. Возвращает значение собственной кодовой точки первого символа в строке &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , которая, как предполагается, имеет кодировку UTF-8 (или UTF-EBCDIC) и не длиннее &lt;code&gt;curlen&lt;/code&gt; байтов; &lt;code&gt;*retlen&lt;/code&gt; (если &lt;code&gt;retlen&lt;/code&gt; не NULL) будет установлена ​​длина этого символа в байтах.</target>
        </trans-unit>
        <trans-unit id="5ffac88340ff426b9b20077ea20bd37ed9bc04e3" translate="yes" xml:space="preserve">
          <source>Boundaries of Hangul syllables are determined according to conjoining Jamo behavior in</source>
          <target state="translated">Границы слогов Хангула определяются в соответствии с прилегающим поведением Джамо в</target>
        </trans-unit>
        <trans-unit id="fa3c7716ef77e2c3385fc102b1a731781237c324" translate="yes" xml:space="preserve">
          <source>Boykin, Joseph, David Kirschen, Alan Langerman, and Susan LoVerso. Programming under Mach. Addison-Wesley, 1994, ISBN 0-201-52739-1.</source>
          <target state="translated">Бойкин,Джозеф,Дэвид Киршен,Алан Лангерман и Сьюзан ЛоВерсо.Программирование под Mach.Эддисон-Уэсли,1994,ISBN 0-201-52739-1.</target>
        </trans-unit>
        <trans-unit id="cbed39e2d9457a27b38ac123d4072c095875ce37" translate="yes" xml:space="preserve">
          <source>Brace yourself for thanks, bug reports, hate mail and spam coming as result of the previous step. No good deed should remain unpunished!</source>
          <target state="translated">Приготовьтесь к благодарности,сообщениям об ошибках,письмам ненависти и спаму,приходящим в результате предыдущего шага.Ни одно доброе дело не должно остаться безнаказанным!</target>
        </trans-unit>
        <trans-unit id="5fde9354c8205697f6414265780ed0c53484415c" translate="yes" xml:space="preserve">
          <source>Braces are required in referring to named capture groups, but are optional for absolute or relative numbered ones. Braces are safer when creating a regex by concatenating smaller strings. For example if you have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt; , you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">Фигурные скобки необходимы для ссылки на именованные группы захвата, но не обязательны для групп с абсолютными или относительными номерами. Фигурные скобки более безопасны при создании регулярного выражения путем объединения меньших строк. Например, если у вас &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;$a&lt;/code&gt; содержит &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , а &lt;code&gt;$b&lt;/code&gt; содержит &lt;code&gt;&quot;37&quot;&lt;/code&gt; , вы получите &lt;code&gt;/\g137/&lt;/code&gt; что, вероятно, не то, что вы планировали.</target>
        </trans-unit>
        <trans-unit id="2fa9a0b57b5dc549e8decf6cc394f53167efa53b" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a crucial feature of Locale::Maketext. I mean Bracket Notation to provide a replacement for the use of sprintf formatting. Everything you do with Bracket Notation could be done with a sub block, but bracket notation is meant to be much more concise.</source>
          <target state="translated">Нотация кронштейна-важнейшая особенность Locale::Maketext.Я имею в виду Bracket Notation,чтобы обеспечить замену использования форматирования sprintf.Все,что вы делаете с нотацией в скобках,может быть сделано с помощью подблока,но нотация в скобках предназначена для того,чтобы быть более лаконичной.</target>
        </trans-unit>
        <trans-unit id="7d31b6dcf28abb8afbf24fa97f7391fe87364415" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a like a miniature &quot;template&quot; system (in the sense of &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text::Template&lt;/a&gt;, not in the sense of C++ templates), where normal text is passed thru basically as is, but text in special regions is specially interpreted. In Bracket Notation, you use square brackets (&quot;[...]&quot;), not curly braces (&quot;{...}&quot;) to note sections that are specially interpreted.</source>
          <target state="translated">Нотация в скобках похожа на систему миниатюрных &amp;laquo;шаблонов&amp;raquo; (в смысле &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text :: Template&lt;/a&gt; , а не в смысле шаблонов C ++), где обычный текст передается в основном как есть, но текст в специальных областях интерпретируется особым образом. В скобках вы используете квадратные скобки (&amp;laquo;[...]&amp;raquo;), а не фигурные скобки (&amp;laquo;{...}&amp;raquo;), чтобы отметить разделы, которые интерпретируются особым образом.</target>
        </trans-unit>
        <trans-unit id="c69ae72aa90270486c045c7a6541cf13d55632e9" translate="yes" xml:space="preserve">
          <source>Bracket Notation is discussed in a later section. Note that trying to compile a string into Bracket Notation can throw an exception if the string is not syntactically valid (say, by not balancing brackets right.)</source>
          <target state="translated">Нотация в скобках обсуждается в следующем разделе.Обратите внимание,что попытка скомпилировать строку в нотацию в квадратных скобках может привести к возникновению исключения,если строка не является синтаксически корректной (скажем,не балансируя скобки справа).</target>
        </trans-unit>
        <trans-unit id="046d4b6cd34c3e66bcd55c31ba3d01db5f8bac76" translate="yes" xml:space="preserve">
          <source>Bracket groups that are empty, or which consist only of whitespace, are ignored. (Examples: &quot;[]&quot;, &quot;[ ]&quot;, or a [ and a ] with returns and/or tabs and/or spaces between them.</source>
          <target state="translated">Группы в квадратных скобках,которые пусты или состоят только из пробельных символов,игнорируются.(Примеры:&quot;[]&quot;,&quot;[]&quot; или[и а]с возвратами и/или закладками и/или пробелами между ними.</target>
        </trans-unit>
        <trans-unit id="d96a703ba2e31ec739345b11c90028f276d06d37" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes</source>
          <target state="translated">Классы с заключенными в скобки символами</target>
        </trans-unit>
        <trans-unit id="7fd31d2f7c96c6ebd02a583681a9f9dd8128bde2" translate="yes" xml:space="preserve">
          <source>Bracketed character classes are represented by &lt;code&gt;regnode_charclass&lt;/code&gt; structures, which have a four-byte argument and then a 32-byte (256-bit) bitmap indicating which characters in the Latin1 range are included in the class.</source>
          <target state="translated">Классы символов в квадратных скобках представлены структурами &lt;code&gt;regnode_charclass&lt;/code&gt; , которые имеют четырехбайтовый аргумент, а затем 32-байтовое (256-битное) битовое отображение, указывающее, какие символы в диапазоне Latin1 включены в класс.</target>
        </trans-unit>
        <trans-unit id="4f10c5c48b8ce584bf50338e9ce1774e2c591ba3" translate="yes" xml:space="preserve">
          <source>Brackets around a symbolic reference can simply serve to isolate an identifier or variable name from the rest of an expression, just as they always have within a string. For example,</source>
          <target state="translated">Скобки вокруг символической ссылки могут просто служить для того,чтобы изолировать идентификатор или имя переменной от остальной части выражения,точно так же,как они всегда есть внутри строки.Например,</target>
        </trans-unit>
        <trans-unit id="ee4272402a91677e15417810bffa7f99811d776d" translate="yes" xml:space="preserve">
          <source>Brackets must be balanced -- every openbracket must have one matching closebracket, and vice versa. So these are all &lt;b&gt;invalid&lt;/b&gt;:</source>
          <target state="translated">Кронштейны должны быть сбалансированы - каждый открытый кронштейн должен иметь один соответствующий закрывающий кронштейн, и наоборот. Итак, все это &lt;b&gt;недействительно&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="078f4a9c2a661144675f9e2bfab86b75d63064df" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;</source>
          <target state="translated">Брэд Эпплтон &amp;lt;bradapp@enteract.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="976a94f14824f930d58b9616017f2abefc3253d5" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt; (initial version), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">Брэд Эпплтон &amp;lt;bradapp@enteract.com&amp;gt; (начальная версия), Марек Рушал &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="bd85e7290aa8473e575a87a5fd8b95386788c86e" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;, Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">Брэд Эпплтон &amp;lt;bradapp@enteract.com&amp;gt;, Марек Рушаль &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c7ea19e07547da7e5f6a43b6c0892e4265aeebb1" translate="yes" xml:space="preserve">
          <source>Brandon L. Black, &amp;lt;blblack@gmail.com&amp;gt;</source>
          <target state="translated">Брэндон Л. Блэк, &amp;lt;blblack@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="eca2fc6f92666147ac6a607129bb8a0811237538" translate="yes" xml:space="preserve">
          <source>Break out of a &lt;code&gt;given()&lt;/code&gt; block.</source>
          <target state="translated">Выйти из &lt;code&gt;given()&lt;/code&gt; блока.</target>
        </trans-unit>
        <trans-unit id="03d93607f829e7fe2aafd920d3e1c2e3753bb301" translate="yes" xml:space="preserve">
          <source>Break the execution of your program if the module you &lt;code&gt;autouse&lt;/code&gt; d has some initialization which it expects to be done early.</source>
          <target state="translated">&lt;code&gt;autouse&lt;/code&gt; выполнение вашей программы, если модуль, который вы автоматически запускаете, имеет некоторую инициализацию, которую он ожидает сделать раньше.</target>
        </trans-unit>
        <trans-unit id="75e308eb5b16f38422b4dd55b2c10339c108233c" translate="yes" xml:space="preserve">
          <source>Break up text into lines according to Unicode rules.</source>
          <target state="translated">Разбивайте текст на строки в соответствии с правилами Юникода.</target>
        </trans-unit>
        <trans-unit id="5ad0b6bff702cd07f8dbaf1cb4107d1095e60662" translate="yes" xml:space="preserve">
          <source>Break-out the reusable code into one or more separate module files.</source>
          <target state="translated">Разбейте код многоразового использования на один или несколько отдельных файлов модуля.</target>
        </trans-unit>
        <trans-unit id="f19f6b051659b65527c1cf48996b006f5fcd4db1" translate="yes" xml:space="preserve">
          <source>Breakable lines are marked with &lt;code&gt;:&lt;/code&gt; . Lines with breakpoints are marked by &lt;code&gt;b&lt;/code&gt; and those with actions by &lt;code&gt;a&lt;/code&gt; . The line that's about to be executed is marked by &lt;code&gt;==&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Breakable линии отмечены &lt;code&gt;:&lt;/code&gt; . Строки с точками останова помечены буквой &lt;code&gt;b&lt;/code&gt; , а строки с действиями - &lt;code&gt;a&lt;/code&gt; . Строка, которая должна быть выполнена, помечена &lt;code&gt;==&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02352bb0ba7c8d9b86acca1b53f9d1e7553bf956" translate="yes" xml:space="preserve">
          <source>Breaking out</source>
          <target state="translated">Выход в свет</target>
        </trans-unit>
        <trans-unit id="b58f4abd812365aa3e9bf665a84c1fa3c88cdbc5" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a DBM file and a hash.</source>
          <target state="translated">Разрывает связь между файлом DBM и хэшем.</target>
        </trans-unit>
        <trans-unit id="4964084eb3d73be96dd1eeb1af8495c4dc61d5f9" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a variable and a package. (See &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;tie&lt;/a&gt;.) Has no effect if the variable is not tied.</source>
          <target state="translated">Разрывает связь между переменной и пакетом. (См. &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;Связь&lt;/a&gt; .) Не действует, если переменная не привязана.</target>
        </trans-unit>
        <trans-unit id="ebcffdb904889257c266769aa18189925f0f7c13" translate="yes" xml:space="preserve">
          <source>Brent Powers has a &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; module that was designed to work with Memoize and provides expiration of least-recently-used data. The cache is held at a fixed number of entries, and when new data comes in, the least-recently used data is expired. See &lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&lt;/a&gt;.</source>
          <target state="translated">У Brent Powers есть модуль &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; который был разработан для работы с Memoize и обеспечивает истечение срока действия наименее используемых данных. В кэше хранится фиксированное количество записей, и когда поступают новые данные, срок действия наименее недавно использованных данных истекает. См. &lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;Http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d67acd53896f7915d6e2dc925e202a5731fc6800" translate="yes" xml:space="preserve">
          <source>Briefly, &lt;code&gt;/l&lt;/code&gt; sets the character set to that of whatever &lt;b&gt;L&lt;/b&gt;ocale is in effect at the time of the execution of the pattern match.</source>
          <target state="translated">Вкратце, &lt;code&gt;/l&lt;/code&gt; устанавливает набор символов для любого &lt;b&gt;L&lt;/b&gt; ocale, действующего во время выполнения сопоставления с образцом.</target>
        </trans-unit>
        <trans-unit id="4f1d6e87ca75e40a64b990a2d32b737b491cbea9" translate="yes" xml:space="preserve">
          <source>Broadly speaking, performing a match of a string against a pattern involves the following steps:</source>
          <target state="translated">В широком смысле,выполнение сопоставления строки с шаблоном включает в себя следующие шаги:</target>
        </trans-unit>
        <trans-unit id="b0f84539efd4151eb704c02dcc4f761c1702c86d" translate="yes" xml:space="preserve">
          <source>Broken systems</source>
          <target state="translated">Разрушенные системы</target>
        </trans-unit>
        <trans-unit id="fe6990bb386cb0f2d9d5ad6fab5909ce4fbcb2fd" translate="yes" xml:space="preserve">
          <source>Buffer scalar containing the chunk currently under consideration of the text currently being lexed. This is always a plain string scalar (for which &lt;code&gt;SvPOK&lt;/code&gt; is true). It is not intended to be used as a scalar by normal scalar means; instead refer to the buffer directly by the pointer variables described below.</source>
          <target state="translated">Буферный скаляр, содержащий рассматриваемый в данный момент фрагмент текста, который в настоящее время обрабатывается. Это всегда простой скаляр строки (для которого &lt;code&gt;SvPOK&lt;/code&gt; верен). Он не предназначен для использования в качестве скаляра обычными скалярными средствами; вместо этого обращайтесь к буферу напрямую с помощью переменных-указателей, описанных ниже.</target>
        </trans-unit>
        <trans-unit id="aaf695eeaf0754918bfdf3c63ed153867d69dfcf" translate="yes" xml:space="preserve">
          <source>Bug reports and other feedback are most welcome.</source>
          <target state="translated">Сообщения об ошибках и другие отзывы приветствуются.</target>
        </trans-unit>
        <trans-unit id="f3dfa0b6c5b9a870507e0243e43fe93803edb544" translate="yes" xml:space="preserve">
          <source>Bug reports, patches, and nagging provided by lots of folks-- thanks everybody! Special thanks to Michael Schwern &amp;lt;schwern@envirolink.org&amp;gt; for assuring me that a &amp;amp;nested_quotewords() would be useful, and to Jeff Friedl &amp;lt;jfriedl@yahoo-inc.com&amp;gt; for telling me not to worry about error-checking (sort of-- you had to be there).</source>
          <target state="translated">Отчеты об ошибках, патчи и нытье, предоставленные множеством людей - всем спасибо! Особая благодарность Майклу Шверну &amp;lt;schwern@envirolink.org&amp;gt; за то, что он уверил меня, что &amp;amp; nested_quotewords () был бы полезен, и Джеффу Фридлу &amp;lt;jfriedl@yahoo-inc.com&amp;gt; за то, что он сказал мне не беспокоиться о проверке ошибок (вроде как - ты должен был быть там).</target>
        </trans-unit>
        <trans-unit id="829fe5647d6ef5dc40cbf31334f7d303909516a7" translate="yes" xml:space="preserve">
          <source>Bug-fixing by Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2011.</source>
          <target state="translated">Исправление ошибок выполнено Питером Джоном Экламом &amp;lt;pjacklam@online.no&amp;gt; 2010-2011.</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="5f308ba7fc80d9c9a972b67a64671b669a27d16c" translate="yes" xml:space="preserve">
          <source>Bugs (and requests for new features) can be reported to the author though the CPAN RT system: &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&lt;/a&gt;</source>
          <target state="translated">Об ошибках (и запросах на новые функции) можно сообщать автору через систему CPAN RT: &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="888b6006f2872d22aaa1cd6bce9e12ccb31d9655" translate="yes" xml:space="preserve">
          <source>Bugs / Feature Requests</source>
          <target state="translated">Ошибки/Особенности Запросы</target>
        </trans-unit>
        <trans-unit id="798e9f12ff638512bcd89953d3735c6b7ab1cee3" translate="yes" xml:space="preserve">
          <source>Bugs you don't plan to fix. :-)</source>
          <target state="translated">Ошибки,которые ты не планируешь исправлять.:-)</target>
        </trans-unit>
        <trans-unit id="a3c79824d95086093512b52d7ab25ad53dd0d923" translate="yes" xml:space="preserve">
          <source>Build Anomalies with Perl on OS/390</source>
          <target state="translated">Построить аномалии с Perl на OS/390</target>
        </trans-unit>
        <trans-unit id="8197039c73f48aefe4687141c68ac9ca58ef8d5e" translate="yes" xml:space="preserve">
          <source>Build FAQ</source>
          <target state="translated">Построить FAQ</target>
        </trans-unit>
        <trans-unit id="4f1a5b2e8fc6f3c96b77575a0eaa73b7619bef70" translate="yes" xml:space="preserve">
          <source>Build Prerequisites for Perl on AmigaOS</source>
          <target state="translated">Построить Предпосылки для Perl на AmigaOS</target>
        </trans-unit>
        <trans-unit id="431713be1df25e40d76ce4972f5897bc2ac46f53" translate="yes" xml:space="preserve">
          <source>Build an iterator which finds distroprefs files in the tree below the given directory. Within the tree directories matching &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; are pruned.</source>
          <target state="translated">Создайте итератор, который находит файлы distroprefs в дереве под заданным каталогом. В пределах дерева каталоги, совпадающие с &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="025fef91894be2ceb7f450be64f484f9a3dfd148" translate="yes" xml:space="preserve">
          <source>Build instructions for OS/2, &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;</source>
          <target state="translated">Инструкции по &lt;a href=&quot;perlos2&quot;&gt;сборке&lt;/a&gt; для OS / 2, perlos2</target>
        </trans-unit>
        <trans-unit id="6a0c26b6e73b4a14e003052fbfb474ae81ddeb3d" translate="yes" xml:space="preserve">
          <source>Build instructions for Win32 in &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;, or under the Cygnus environment in &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt;.</source>
          <target state="translated">Инструкции по &lt;a href=&quot;perlwin32&quot;&gt;сборке&lt;/a&gt; Win32 в perlwin32 или в среде Cygnus в &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec272960803bf0c1141ddb2cc450b8e7bb399d9c" translate="yes" xml:space="preserve">
          <source>Build man pages, too</source>
          <target state="translated">Построить man-страницы тоже</target>
        </trans-unit>
        <trans-unit id="6e79e48e57f84dbe7fa157bde2a3fead704bb75d" translate="yes" xml:space="preserve">
          <source>Build system</source>
          <target state="translated">Построить систему</target>
        </trans-unit>
        <trans-unit id="f324587551677d6f64a6a55d81e5c02c33aaa350" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the scalar &lt;code&gt;sv&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">Создайте в скалярном &lt;code&gt;dsv&lt;/code&gt; отображаемую версию скалярного &lt;code&gt;sv&lt;/code&gt; , причем отображаемая версия имеет &lt;code&gt;pvlim&lt;/code&gt; не более pvlim байтов (если она длиннее, то остальная часть усекается и к ней будет добавлено &quot;...&quot;).</target>
        </trans-unit>
        <trans-unit id="cc42dbdb87c5e71f504c4dbe80214e6754c41fcb" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the string &lt;code&gt;spv&lt;/code&gt; , length &lt;code&gt;len&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">Создайте в скалярном &lt;code&gt;dsv&lt;/code&gt; отображаемую версию строки &lt;code&gt;spv&lt;/code&gt; , длина &lt;code&gt;len&lt;/code&gt; , причем отображаемая версия имеет &lt;code&gt;pvlim&lt;/code&gt; не более pvlim байтов (если она длиннее, то остальная часть усекается, а к ней добавляется &quot;...&quot;).</target>
        </trans-unit>
        <trans-unit id="4c215cd495fbe90044cc607bb79e970dde2b9028" translate="yes" xml:space="preserve">
          <source>Build, Test, Install Perl on OS/390</source>
          <target state="translated">Сборка,тестирование,установка Perl на OS/390</target>
        </trans-unit>
        <trans-unit id="249199540ceee6ec6b4a1f1daa24666f4aa042eb" translate="yes" xml:space="preserve">
          <source>Build.PL</source>
          <target state="translated">Build.PL</target>
        </trans-unit>
        <trans-unit id="4759bf14d7a511508e86c343c934894b6e8db533" translate="yes" xml:space="preserve">
          <source>Builder</source>
          <target state="translated">Builder</target>
        </trans-unit>
        <trans-unit id="52b5e661f9ecf45eed9a8b41756d5844802fbce9" translate="yes" xml:space="preserve">
          <source>Builder class for Windows platforms</source>
          <target state="translated">Класс сборщика для Windows-платформ</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="2ed0dadcc70796d33055d55283657d04fb0c039a" translate="yes" xml:space="preserve">
          <source>Building 32-bit Perl in Irix</source>
          <target state="translated">Строительство 32-битного Perl в Ирикс</target>
        </trans-unit>
        <trans-unit id="977f968c44ef127f7e68a4bbd06a3bc09d574a03" translate="yes" xml:space="preserve">
          <source>Building 64-bit Perl in Irix</source>
          <target state="translated">Строительство 64-битного Perl в Ирикс</target>
        </trans-unit>
        <trans-unit id="a68801656d21c1742976b2a26b0d97ca179190db" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX</source>
          <target state="translated">Строительные динамические расширения на AIX</target>
        </trans-unit>
        <trans-unit id="cdc5004f31232806335a1cd820513add0b5ef95f" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX &amp;lt; 5L</source>
          <target state="translated">Создание динамических расширений в AIX &amp;lt;5L</target>
        </trans-unit>
        <trans-unit id="60eeab40d6adc2fe265d128c48b6aa4e93a2fcb8" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on HP-UX</source>
          <target state="translated">Строительные динамические расширения на HP-UX</target>
        </trans-unit>
        <trans-unit id="2cca0ab4039ae032282d3c4fa53d7e82995e8594" translate="yes" xml:space="preserve">
          <source>Building Non-XS Modules on DOS</source>
          <target state="translated">Строительство модулей не XS на DOS</target>
        </trans-unit>
        <trans-unit id="e58f39330e280e7de8b3b247f8f97aeb868e7743" translate="yes" xml:space="preserve">
          <source>Building Perl for WinCE</source>
          <target state="translated">Строительный Перл для WinCE</target>
        </trans-unit>
        <trans-unit id="9e84e0a9f11037f0b7fccbdd30b3def3e1270535" translate="yes" xml:space="preserve">
          <source>Building Perl on DOS</source>
          <target state="translated">Строительство Perl на DOS</target>
        </trans-unit>
        <trans-unit id="107439a62a7c6f42562b678d76f2e80c36c5eb66" translate="yes" xml:space="preserve">
          <source>Building Prerequisites for Perl on DOS</source>
          <target state="translated">Построение предпосылок для Perl на DOS</target>
        </trans-unit>
        <trans-unit id="b5ced49870fdf0851779593a86211e669aed437d" translate="yes" xml:space="preserve">
          <source>Building XS Modules on DOS</source>
          <target state="translated">Построение модулей XS на DOS</target>
        </trans-unit>
        <trans-unit id="16ea3711da90cdc1ad8b70bb59bd87c31033d7af" translate="yes" xml:space="preserve">
          <source>Building a 64-bit capable gcc on PA-RISC from source is possible only when you have the HP C-ANSI C compiler or an already working 64-bit binary of gcc available. Best performance for perl is achieved with HP's native compiler.</source>
          <target state="translated">Сборка 64-битного gcc на PA-RISC из исходников возможна только при наличии компилятора HP C-ANSI C или уже работающего 64-битного двоичного gcc.Наилучшая производительность для perl достигается с помощью родного компилятора HP.</target>
        </trans-unit>
        <trans-unit id="b06d77f19e3d0e1947de8d417eb97b9240aba5fe" translate="yes" xml:space="preserve">
          <source>Building a binary distribution</source>
          <target state="translated">Построение бинарного распределения</target>
        </trans-unit>
        <trans-unit id="5eaf641b2cc432d339298d2d7667c55e1df71877" translate="yes" xml:space="preserve">
          <source>Building a regexp</source>
          <target state="translated">Строительство регепа</target>
        </trans-unit>
        <trans-unit id="4f3097c147e745c265a4f8606c6e810a7ad5d9f4" translate="yes" xml:space="preserve">
          <source>Building an LP64 perl</source>
          <target state="translated">Строительство LP64 perl</target>
        </trans-unit>
        <trans-unit id="d601de14ddca518b95c2c6d816b3b797646fe162" translate="yes" xml:space="preserve">
          <source>Building custom</source>
          <target state="translated">Строительный обычай</target>
        </trans-unit>
        <trans-unit id="94d1d0131bb7b5bab11d8fd5a13a49d41b119105" translate="yes" xml:space="preserve">
          <source>Building custom _.EXE_ files</source>
          <target state="translated">Создание пользовательских _.EXE_файлов</target>
        </trans-unit>
        <trans-unit id="58685fabffe8d566dcf90fc429e9988b44fb72cb" translate="yes" xml:space="preserve">
          <source>Building should proceed differently depending on whether the version of perl you install is already present and used on your system, or is a new version not yet used. The description below assumes that the version is new, so installing its DLLs and</source>
          <target state="translated">Сборка должна вестись по-разному в зависимости от того,присутствует ли уже установленная вами версия perl и используется ли она в вашей системе,или же это новая версия,которая еще не используется.Описание ниже предполагает,что версия является новой,поэтому устанавливайте ее DLL и</target>
        </trans-unit>
        <trans-unit id="25399d44a6d52942b965d7741dfbe5b98c44e3b6" translate="yes" xml:space="preserve">
          <source>Building with threads in Irix</source>
          <target state="translated">Здание с резьбой в Ирикс</target>
        </trans-unit>
        <trans-unit id="167534462e1810e98824021557fb475fd2cb9f52" translate="yes" xml:space="preserve">
          <source>Built-in Attributes</source>
          <target state="translated">Встроенные атрибуты</target>
        </trans-unit>
        <trans-unit id="a254cda26c62367280124a0a97ba97ac0047a0c1" translate="yes" xml:space="preserve">
          <source>Builtin operators and functions</source>
          <target state="translated">Сборка операторов и функций</target>
        </trans-unit>
        <trans-unit id="82bac8de7c475e9a140fc89ca8b2ed3375482576" translate="yes" xml:space="preserve">
          <source>Builtin types include:</source>
          <target state="translated">Типы сборки включают в себя:</target>
        </trans-unit>
        <trans-unit id="fbadec79c760a0615a7745522920ce54712b347a" translate="yes" xml:space="preserve">
          <source>Bundle/Snapshot_2012_05_21_00.pm</source>
          <target state="translated">Bundle/Snapshot_2012_05_21_00.pm</target>
        </trans-unit>
        <trans-unit id="c1d562515d11cd030821deea9c673716499b48ca" translate="yes" xml:space="preserve">
          <source>Bundled Encode::Locale</source>
          <target state="translated">Код в комплекте::Locale</target>
        </trans-unit>
        <trans-unit id="9a033a116a34993104733ddb8e62da3f808f4b18" translate="yes" xml:space="preserve">
          <source>Bundles</source>
          <target state="translated">Bundles</target>
        </trans-unit>
        <trans-unit id="57402f7215532c14b5a4891e2bc99d5f27572992" translate="yes" xml:space="preserve">
          <source>Bundles are treated specially in the CPAN package. If you say 'install Bundle::Tkkit' (assuming such a bundle exists), CPAN will install all the modules in the CONTENTS section of the pod. You can install your own Bundles locally by placing a conformant Bundle file somewhere into your @INC path. The autobundle() command which is available in the shell interface does that for you by including all currently installed modules in a snapshot bundle file.</source>
          <target state="translated">Пакеты специально обработаны в пакете CPAN.Если вы скажете 'установите Bundle::Tkkit' (если такой пакет существует),CPAN установит все модули в секции CONTENTS в pod.Вы можете установить свои собственные пакеты локально,поместив соответствующий файл пакета куда-нибудь в путь @INC.Команда autobundle(),доступная в интерфейсе оболочки,сделает это за вас,включив все установленные в данный момент модули в файл пакета снимков.</target>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="d01b7bc2d8bcb3e8147c5617d5cc44c01b525846" translate="yes" xml:space="preserve">
          <source>But</source>
          <target state="translated">But</target>
        </trans-unit>
        <trans-unit id="4409f482ed69df6dea8ad78ddaf1fc21ee472c98" translate="yes" xml:space="preserve">
          <source>But (for the foreseeable future), Pod does not provide any way for Pod authors to distinguish which grouping is meant by the above &quot;=item&quot;-cluster structure. So formatters should format it like so:</source>
          <target state="translated">Но (в обозримом будущем),Pod не предоставляет авторам Pod никакого способа,чтобы отличить,какая группировка подразумевается под вышеуказанной &quot;=пункт&quot;-кластерной структурой.Поэтому форматировщики должны отформатировать его таким образом:</target>
        </trans-unit>
        <trans-unit id="90e0c4e431de8ceb3ea88d2476b9cdf6b06e1777" translate="yes" xml:space="preserve">
          <source>But I consider that somewhat of a distraction from the work of getting the main code working -- to say nothing of the fact that I often have to play with the program a few times before I can decide exactly what wording I want in the messages (which in this case would require me to go changing three lines of code: the call to maketext with that key, and then the two lines in ThisProject/I18N/en.pm).</source>
          <target state="translated">Но я считаю,что в какой-то степени это отвлекает меня от работы,чтобы заставить работать основной код-не говоря уже о том,что мне часто приходится несколько раз поиграть с программой,прежде чем я смогу решить,какая именно формулировка мне нужна в сообщениях (что в данном случае потребовало бы от меня смены трех строк кода:вызова maketext с этим ключом,а затем двух строк в ThisProject/I18N/en.pm).</target>
        </trans-unit>
        <trans-unit id="ab00dd7d452b56d9f0d69d34971f4ee775260627" translate="yes" xml:space="preserve">
          <source>But Unicode's intent is to unify the existing character set standards and practices, and several pre-existing standards have single characters that mean the same thing as some of these combinations, like ISO-8859-1, which has quite a few of them. For example, &lt;code&gt;&quot;LATIN CAPITAL LETTER E
WITH ACUTE&quot;&lt;/code&gt; was already in this standard when Unicode came along. Unicode therefore added it to its repertoire as that single character. But this character is considered by Unicode to be equivalent to the sequence consisting of the character &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; followed by the character &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; .</source>
          <target state="translated">Но намерение Unicode состоит в том, чтобы унифицировать существующие стандарты и методы набора символов, и несколько ранее существовавших стандартов содержат отдельные символы, которые означают то же самое, что и некоторые из этих комбинаций, например ISO-8859-1, в котором их довольно много. Например, &lt;code&gt;&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;&lt;/code&gt; уже была в этом стандарте, когда появился Юникод. Поэтому Unicode добавил его в свой репертуар как этот единственный символ. Но этот символ считается Unicode эквивалентным последовательности, состоящей из символа &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; за которым следует символ &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e01ae5e7eb5b2bd27e52f97c45f989f3f7c27c0" translate="yes" xml:space="preserve">
          <source>But a warning is in order. When using the following to make a copy of a number, only a shallow copy will be made.</source>
          <target state="translated">Но предупреждение в порядке.При следующем использовании для создания копии числа будет сделана только мелкая копия.</target>
        </trans-unit>
        <trans-unit id="402f2e961d9afb45626c390dcfdcf325381214c3" translate="yes" xml:space="preserve">
          <source>But any modifiers will still apply to all the components:</source>
          <target state="translated">Но любые модификаторы все равно будут применяться ко всем компонентам:</target>
        </trans-unit>
        <trans-unit id="066f97bc3c6fb6f4f0d1613419193dc5c411fa60" translate="yes" xml:space="preserve">
          <source>But as you might well imagine, this can get pretty rough on the reader.</source>
          <target state="translated">Но,как ты можешь себе представить,это может стать довольно грубым для читателя.</target>
        </trans-unit>
        <trans-unit id="52f632f5c831c8135e210771e0889bbe7f7800a2" translate="yes" xml:space="preserve">
          <source>But assignment of weight for CJK unified ideographs in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, weights for CJK unified ideographs are treated as undefined. However when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; has no special meaning.</source>
          <target state="translated">Но присвоение веса унифицированным идеограммам CJK в &lt;code&gt;table&lt;/code&gt; или &lt;code&gt;entry&lt;/code&gt; по-прежнему действует. Если &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; передается явно как значение для этого ключа, веса для унифицированных идеографов CJK обрабатываются как неопределенные. Однако, когда &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; не имеет особого значения.</target>
        </trans-unit>
        <trans-unit id="c1e716943619b45aa9ba23cbbf0f24483f934af2" translate="yes" xml:space="preserve">
          <source>But be quite sure that &lt;code&gt;ok&lt;/code&gt; is called exactly as many times in the first block as &lt;code&gt;skip&lt;/code&gt; is called in the second block.</source>
          <target state="translated">Но будьте уверены, что &lt;code&gt;ok&lt;/code&gt; вызывается ровно столько раз в первом блоке, сколько &lt;code&gt;skip&lt;/code&gt; вызывается во втором блоке.</target>
        </trans-unit>
        <trans-unit id="6a9db2da200feea27e3e89ec89ca9f8bf249bcbc" translate="yes" xml:space="preserve">
          <source>But both are slower than assigning the empty list or undefining %HASH or @ARRAY, which is the customary way to empty out an aggregate:</source>
          <target state="translated">Но и то,и другое медленнее,чем присвоение пустого списка или неуточнение %HASH или @ARRAY,что является обычным способом опорожнения агрегата:</target>
        </trans-unit>
        <trans-unit id="527a74597b28c7ec00ae7d09430ff9201f3f5a87" translate="yes" xml:space="preserve">
          <source>But don't bother him, he's retired.</source>
          <target state="translated">Но не беспокойте его,он на пенсии.</target>
        </trans-unit>
        <trans-unit id="04440d595d2cdff8c05a9e9393436d8792f429f8" translate="yes" xml:space="preserve">
          <source>But don't put</source>
          <target state="translated">Но не ставьте</target>
        </trans-unit>
        <trans-unit id="9491e2071e60f65ae593369952ca1ddd75bbfad0" translate="yes" xml:space="preserve">
          <source>But due to an unfixable bug (fixing it would break lots of existing CPAN modules) in the typemap file, the reference count of the &lt;code&gt;AV *&lt;/code&gt; is not properly decremented. Thus, the above XSUB would leak memory whenever it is being called. The same problem exists for &lt;code&gt;HV *&lt;/code&gt; , &lt;code&gt;CV *&lt;/code&gt; , and &lt;code&gt;SVREF&lt;/code&gt; (which indicates a scalar reference, not a general &lt;code&gt;SV *&lt;/code&gt; ). In XS code on perls starting with perl 5.16, you can override the typemaps for any of these types with a version that has proper handling of refcounts. In your &lt;code&gt;TYPEMAP&lt;/code&gt; section, do</source>
          <target state="translated">Но из-за неустранимой ошибки (ее исправление может привести к поломке множества существующих модулей CPAN) в файле typemap, счетчик ссылок &lt;code&gt;AV *&lt;/code&gt; не уменьшается должным образом. Таким образом, указанный выше XSUB будет вызывать утечку памяти при каждом вызове. Та же проблема существует для &lt;code&gt;HV *&lt;/code&gt; , &lt;code&gt;CV *&lt;/code&gt; и &lt;code&gt;SVREF&lt;/code&gt; (что указывает на скалярную ссылку, а не на общий &lt;code&gt;SV *&lt;/code&gt; ). В коде XS на perls, начиная с perl 5.16, вы можете переопределить карты типов для любого из этих типов с помощью версии, которая имеет правильную обработку refcount. В разделе &lt;code&gt;TYPEMAP&lt;/code&gt; сделайте</target>
        </trans-unit>
        <trans-unit id="be9ca11f359e927d9da9a4e640717e37037c1c98" translate="yes" xml:space="preserve">
          <source>But easiest is, if the character is specifiable as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;%&quot;&lt;/code&gt; , to use that; if not so specificable, you can use use &lt;code&gt;\N{}&lt;/code&gt; , if the side effects aren't troublesome. Simply specify all your characters in hex, using &lt;code&gt;\N{U+ZZ}&lt;/code&gt; instead of &lt;code&gt;\xZZ&lt;/code&gt; . &lt;code&gt;\N{}&lt;/code&gt; is the Unicode name, and so it always gives you the Unicode character. &lt;code&gt;\N{U+41}&lt;/code&gt; is the character whose Unicode code point is &lt;code&gt;0x41&lt;/code&gt; , hence is &lt;code&gt;'A'&lt;/code&gt; on all platforms. The side effects are:</source>
          <target state="translated">Но проще всего использовать этот символ как литерал, например &lt;code&gt;&quot;A&quot;&lt;/code&gt; или &lt;code&gt;&quot;%&quot;&lt;/code&gt; ; если это не так конкретно, вы можете использовать use &lt;code&gt;\N{}&lt;/code&gt; , если побочные эффекты не вызывают проблем. Просто укажите все символы в шестнадцатеричном &lt;code&gt;\xZZ&lt;/code&gt; , используя &lt;code&gt;\N{U+ZZ}&lt;/code&gt; вместо \ xZZ . &lt;code&gt;\N{}&lt;/code&gt; - это имя Unicode, поэтому оно всегда дает вам символ Unicode. &lt;code&gt;\N{U+41}&lt;/code&gt; - это символ, у которого кодовая точка Unicode равна &lt;code&gt;0x41&lt;/code&gt; , следовательно, это &lt;code&gt;'A'&lt;/code&gt; на всех платформах. Побочные эффекты:</target>
        </trans-unit>
        <trans-unit id="4e336391004e93bf9adbf972f876990718b27f63" translate="yes" xml:space="preserve">
          <source>But failure_handler_auto, instead of dying or anything, compiles $key, caching it in</source>
          <target state="translated">Но fail_handler_auto,вместо того,чтобы умереть или что-то в этом роде,компилирует $key,кэшируя его в</target>
        </trans-unit>
        <trans-unit id="d44c97279f7f106146fa21778196b89c19981fbb" translate="yes" xml:space="preserve">
          <source>But fear not, there's a simple solution. The module &lt;code&gt;Sub::Name&lt;/code&gt; will reach into the perl internals and assign a name to an anonymous subroutine for you. Simply do this:</source>
          <target state="translated">Но не бойтесь, есть простое решение. Модуль &lt;code&gt;Sub::Name&lt;/code&gt; проникнет внутрь perl и назначит имя анонимной подпрограмме за вас. Просто сделайте это:</target>
        </trans-unit>
        <trans-unit id="6c88ebcfc6d7c83b843d2d6f3e737b05e79bf378" translate="yes" xml:space="preserve">
          <source>But for &quot;directory&quot;, you'd want &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; so that our elementary &lt;code&gt;quant&lt;/code&gt; method doesn't think that the plural of &quot;directory&quot; is &quot;directorys&quot;. And you might find that the output may sound better if you specify a negative form, as in:</source>
          <target state="translated">Но для &amp;laquo;директории&amp;raquo;, вы хотите &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; , так что наш элементарный &lt;code&gt;quant&lt;/code&gt; метод не считает , что множественное число от &amp;laquo;каталога&amp;raquo; является &amp;laquo;directorys&amp;raquo;. И вы можете обнаружить, что вывод может звучать лучше, если вы укажете отрицательную форму, например:</target>
        </trans-unit>
        <trans-unit id="490b6f6af7c2374cd5fd42c108629dc25f1e6fdb" translate="yes" xml:space="preserve">
          <source>But for now, let's look at general issues common to all these types of data structures.</source>
          <target state="translated">Но пока давайте рассмотрим общие вопросы,общие для всех этих типов структур данных.</target>
        </trans-unit>
        <trans-unit id="38fcb950a418ab15715107f772519ba0899f4c7c" translate="yes" xml:space="preserve">
          <source>But for other languages (as is discussed at length in &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;), simple &lt;code&gt;quant&lt;/code&gt; /&lt;code&gt;numf&lt;/code&gt; is not enough. For the particularly problematic Slavic languages, what you may need is a method which you provide with the number, the citation form of the noun to quantify, and the case and gender that the sentence's syntax projects onto that noun slot. The method would then be responsible for determining what grammatical number that numeral projects onto its noun phrase, and what case and gender it may override the normal case and gender with; and then it would look up the noun in a lexicon providing all needed inflected forms.</source>
          <target state="translated">Но для других языков (как подробно обсуждается в &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale :: Maketext :: TPJ13&lt;/a&gt; ), простой &lt;code&gt;quant&lt;/code&gt; / &lt;code&gt;numf&lt;/code&gt; недостаточно. Для особо проблемных славянских языков вам может понадобиться метод, который вы предоставите с числом, формой цитирования существительного для количественной оценки, а также падежом и полом, которые синтаксис предложения проецирует на это место существительного. Затем метод будет отвечать за определение того, какое грамматическое число эта цифра проецирует на свою именную фразу, и с каким падежем и полом оно может замещать нормальный падеж и род; а затем он будет искать существительное в лексиконе, предоставляя все необходимые изменяемые формы.</target>
        </trans-unit>
        <trans-unit id="ef8dab0f4d9389f9bb5dc21779fdfd4e9a160e11" translate="yes" xml:space="preserve">
          <source>But for some processors/formats this cannot be easily controlled; as with the HTML example, the behavior of multiple ambiguous &amp;lt;a name=&quot;</source>
          <target state="translated">Но для некоторых процессоров / форматов это нелегко контролировать; как и в примере HTML, поведение нескольких неоднозначных &amp;lt;a name = &quot;</target>
        </trans-unit>
        <trans-unit id="8b46bf6bc073f2a792b2de8dc4b3f11e31f9c12f" translate="yes" xml:space="preserve">
          <source>But generally, a block is delimited by curly brackets, also known as braces. We will call this syntactic construct a BLOCK.</source>
          <target state="translated">Но,как правило,блок ограничивается фигурными скобками,также известными как фигурные скобки.Мы назовем эту синтаксическую конструкцию BLOCK.</target>
        </trans-unit>
        <trans-unit id="ccefce54f83b7f4c3b397919dd3e84e700ff50bd" translate="yes" xml:space="preserve">
          <source>But if the client asks for &quot;i-Mingo&quot; or &quot;x-mingo&quot;, or &quot;Fr&quot;, then the lookup in %greetings fails. That's the Wrong Thing.</source>
          <target state="translated">Но если клиент попросит &quot;i-Mingo&quot; или &quot;x-mingo&quot;,или &quot;Fr&quot;,то поиск в %greetings провалится.Это неправильная вещь.</target>
        </trans-unit>
        <trans-unit id="ec6083b91636d75d0495261998b67a37e19945dc" translate="yes" xml:space="preserve">
          <source>But if the document starts out:</source>
          <target state="translated">Но если документ начнется:</target>
        </trans-unit>
        <trans-unit id="018410255214e3cce3a8b05ae3d7d99e0330f4d0" translate="yes" xml:space="preserve">
          <source>But if you subclass Pod::Simple::Methody, it will instead do this when it sees a &quot;=head1 Hi there&quot;:</source>
          <target state="translated">Но если вы подкласс Pod::Simple::Methody,то он сделает это,когда увидит &quot;=head1 Hi there&quot;:</target>
        </trans-unit>
        <trans-unit id="0cf73c47906927595e3043b178988fd87c4d5b4a" translate="yes" xml:space="preserve">
          <source>But if you try this:</source>
          <target state="translated">Но если ты попробуешь это:</target>
        </trans-unit>
        <trans-unit id="90ee606d0538a1d21fc1f464d165e33c56162b66" translate="yes" xml:space="preserve">
          <source>But if you want nested occurrences of &lt;code&gt;START&lt;/code&gt; through &lt;code&gt;END&lt;/code&gt; , you'll run up against the problem described in the question in this section on matching balanced text.</source>
          <target state="translated">Но если вам нужны вложенные вхождения от &lt;code&gt;START&lt;/code&gt; до &lt;code&gt;END&lt;/code&gt; , вы столкнетесь с проблемой, описанной в вопросе в этом разделе о сопоставлении сбалансированного текста.</target>
        </trans-unit>
        <trans-unit id="95d91fb2e9c31e4e480c3aa19de7d332e4a9c236" translate="yes" xml:space="preserve">
          <source>But if you write code that uses &lt;code&gt;\005&lt;/code&gt; to mean a TAB or &lt;code&gt;\xC1&lt;/code&gt; to mean an &quot;A&quot;, or &lt;code&gt;\xDF&lt;/code&gt; to mean a &quot;&amp;yuml;&quot; (small &lt;code&gt;&quot;y&quot;&lt;/code&gt; with a diaeresis), then your code may well work on your EBCDIC platform, but not on an ASCII one. That's fine to do if no one will ever want to run your code on an ASCII platform; but the bias in this document will be in writing code portable between EBCDIC and ASCII systems. Again, if every character you care about is easily enterable from your keyboard, you don't have to know anything about ASCII, but many keyboards don't easily allow you to directly enter, say, the character &lt;code&gt;\xDF&lt;/code&gt; , so you have to specify it indirectly, such as by using the &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; escape sequence. In those cases it's easiest to know something about the ASCII/Unicode character sets. If you know that the small &quot;&amp;yuml;&quot; is &lt;code&gt;U+00FF&lt;/code&gt; , then you can instead specify it as &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; , and have the computer automatically translate it to &lt;code&gt;\xDF&lt;/code&gt; on your platform, and leave it as &lt;code&gt;\xFF&lt;/code&gt; on ASCII ones. Or you could specify it by name, &lt;code&gt;\N{LATIN
SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; and not have to know the numbers. Either way works, but require familiarity with Unicode.</source>
          <target state="translated">Но если вы пишете код, который использует &lt;code&gt;\005&lt;/code&gt; для обозначения TAB или &lt;code&gt;\xC1&lt;/code&gt; для обозначения &amp;laquo;A&amp;raquo;, или &lt;code&gt;\xDF&lt;/code&gt; для обозначения &amp;laquo;&amp;yuml;&amp;raquo; (маленький &lt;code&gt;&quot;y&quot;&lt;/code&gt; с тремой), то ваш код вполне может работать на вашем Платформа EBCDIC, но не на платформе ASCII. Это нормально, если никто никогда не захочет запускать ваш код на платформе ASCII; но предвзятость в этом документе будет заключаться в написании кода, переносимого между системами EBCDIC и ASCII. Опять же, если каждый символ, который вам нужен, легко вводится с вашей клавиатуры, вам не нужно ничего знать об ASCII, но многие клавиатуры не позволяют вам напрямую вводить, скажем, символ &lt;code&gt;\xDF&lt;/code&gt; , поэтому вам нужно указать его косвенно, например, используя &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; escape-последовательность. В таких случаях проще всего узнать что-нибудь о наборах символов ASCII / Unicode. Если вы знаете, что маленький &amp;laquo;&amp;yuml;&amp;raquo; - это &lt;code&gt;U+00FF&lt;/code&gt; , то вы можете вместо этого указать его как &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; , и компьютер автоматически переведет его в &lt;code&gt;\xDF&lt;/code&gt; на вашей платформе и оставьте его как &lt;code&gt;\xFF&lt;/code&gt; на ASCII. Или вы можете указать его по имени, &lt;code&gt;\N{LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; и не нужно знать числа. Любой способ работает, но требует знания Юникода.</target>
        </trans-unit>
        <trans-unit id="8cb0a7929d9be6d467d0702a4ca1482bdad00292" translate="yes" xml:space="preserve">
          <source>But if you're a perl programmer, then for you I have something much more wondrous than just a structure offset printer.</source>
          <target state="translated">Но если вы программист на perl,то для вас у меня есть нечто гораздо более удивительное,чем просто структурный офсетный принтер.</target>
        </trans-unit>
        <trans-unit id="95c71d4b40a76244fed8568f06f2e4623c952ed6" translate="yes" xml:space="preserve">
          <source>But in any case, try to keep the features and operating systems separate.</source>
          <target state="translated">Но в любом случае постарайтесь разделить функции и операционные системы.</target>
        </trans-unit>
        <trans-unit id="f86252e7b4ed24cc14ced10c8828354685807171" translate="yes" xml:space="preserve">
          <source>But in case you find the need to...</source>
          <target state="translated">Но на случай,если тебе понадобится...</target>
        </trans-unit>
        <trans-unit id="ca1b980e76b99df2ec3833fb22b3d48a26eb466f" translate="yes" xml:space="preserve">
          <source>But in this particular example, you probably really want</source>
          <target state="translated">Но в данном конкретном примере,вы,вероятно,действительно хотите.</target>
        </trans-unit>
        <trans-unit id="3cee8270da886ebc5c44d683d110f389adb2e169" translate="yes" xml:space="preserve">
          <source>But it actually compiles as this:</source>
          <target state="translated">Но на самом деле все складывается вот так:</target>
        </trans-unit>
        <trans-unit id="823e1d2128bc470581c23a9dfa7a058a23c8a7f1" translate="yes" xml:space="preserve">
          <source>But it also puts the same information in certain fields of the XSUB itself:</source>
          <target state="translated">Но она также помещает ту же информацию в определенные поля самого XSUB:</target>
        </trans-unit>
        <trans-unit id="f5f796fef481b4bfaedc4fb27aaba8e13316d437" translate="yes" xml:space="preserve">
          <source>But it also works on lexically declared aggregates.</source>
          <target state="translated">Но он также работает и с лексически декларированными агрегатами.</target>
        </trans-unit>
        <trans-unit id="bce306df93e9efe810cd4909bfa7982e26681041" translate="yes" xml:space="preserve">
          <source>But it could equally well be a discussion of three (related or equivalent) items, &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;, followed by a paragraph explaining them all, and then a new item &quot;Ut Enim&quot;. In that case, you'd probably want to format it like so:</source>
          <target state="translated">Но с таким же успехом можно было бы обсудить три (связанных или эквивалентных)пункта:&quot;Неке&quot;,&quot;Порро&quot; и &quot;Квисквам Эст&quot;,за которыми следует пункт,разъясняющий все эти пункты,а затем новый пункт &quot;Ут Эним&quot;.В этом случае,возможно,вы захотите отформатировать его таким образом:</target>
        </trans-unit>
        <trans-unit id="ad75a36ebc7396598ae4020570b59b4dddb1d077" translate="yes" xml:space="preserve">
          <source>But it doesn't work at all in Perl 6. Instead, you should use the (parallelizable) &lt;code&gt;any&lt;/code&gt; operator:</source>
          <target state="translated">Но в Perl 6 это вообще не работает. Вместо этого вы должны использовать (распараллеливаемый) оператор &lt;code&gt;any&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bf7fd3170743bf29faac8bcfc9396e4e0b2afa0e" translate="yes" xml:space="preserve">
          <source>But it will croak if:</source>
          <target state="translated">Но она закричит,если..:</target>
        </trans-unit>
        <trans-unit id="ac22b7287d2aed5e7462242749c989d65753c887" translate="yes" xml:space="preserve">
          <source>But never use the bare &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; without having set up a default encoding first. Otherwise, Perl cannot know which of the many, many, many possible flavors of text file you have, and Perl will have no idea how to correctly map the data in your file into actual characters it can work with. Other common encoding formats including &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; , &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; , &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; , and even &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; . See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more about encodings.</source>
          <target state="translated">Но никогда не используйте пустой знак &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; не установив предварительно кодировку по умолчанию. В противном случае Perl не сможет знать, какой из многих, многих, многих возможных вариантов текстового файла у вас есть, и Perl не будет знать, как правильно сопоставить данные в вашем файле с реальными символами, с которыми он может работать. Другие распространенные форматы кодирования, включая &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; , &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; , &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; и даже &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; . См. &lt;a href=&quot;perlunitut&quot;&gt;Perlunitut&lt;/a&gt; для получения дополнительной информации о кодировках.</target>
        </trans-unit>
        <trans-unit id="eca085acb0ddeeb52a224b25677bc101217dcb2a" translate="yes" xml:space="preserve">
          <source>But note that these last three macros are valid only if &lt;code&gt;SvPOK()&lt;/code&gt; is true.</source>
          <target state="translated">Но обратите внимание, что эти последние три макроса действительны, только если &lt;code&gt;SvPOK()&lt;/code&gt; истинно.</target>
        </trans-unit>
        <trans-unit id="5960a3f75e9619ab812c7dea1d6e781ac954880e" translate="yes" xml:space="preserve">
          <source>But note that this doesn't mean that any of the characters in the string are necessary UTF-8 encoded, or that any of the characters have code points greater than 0xFF (255) or even 0x80 (128), or that the string has any characters at all. All the &lt;code&gt;is_utf8()&lt;/code&gt; does is to return the value of the internal &quot;utf8ness&quot; flag attached to the &lt;code&gt;$string&lt;/code&gt; . If the flag is off, the bytes in the scalar are interpreted as a single byte encoding. If the flag is on, the bytes in the scalar are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded code points of the characters. Bytes added to a UTF-8 encoded string are automatically upgraded to UTF-8. If mixed non-UTF-8 and UTF-8 scalars are merged (double-quoted interpolation, explicit concatenation, or printf/sprintf parameter substitution), the result will be UTF-8 encoded as if copies of the byte strings were upgraded to UTF-8: for example,</source>
          <target state="translated">Но обратите внимание, что это не означает, что любой из символов в строке необходим в кодировке UTF-8, или что любой из символов имеет кодовые точки больше, чем 0xFF (255) или даже 0x80 (128), или что строка имеет вообще никаких персонажей. Все, что &lt;code&gt;is_utf8()&lt;/code&gt; , - это возвращает значение внутреннего флага &quot;utf8ness&quot;, прикрепленного к &lt;code&gt;$string&lt;/code&gt; . Если флаг выключен, байты в скаляре интерпретируются как однобайтовая кодировка. Если этот флаг установлен, байты в скаляре интерпретируются как кодовые точки символов в кодировке UTF-8 (переменной длины, потенциально многобайтовые). Байты, добавленные в строку в кодировке UTF-8, автоматически обновляются до UTF-8. Если смешанные скаляры не-UTF-8 и UTF-8 объединяются (интерполяция в двойных кавычках, явная конкатенация или подстановка параметров printf / sprintf), результат будет закодирован в UTF-8, как если бы копии байтовых строк были обновлены до UTF. -8: например,</target>
        </trans-unit>
        <trans-unit id="3ed10f08c2a7b806d29712ea53fb65371e6dda25" translate="yes" xml:space="preserve">
          <source>But prior to v5.16, you must be explicit about which set of charnames you want. The &lt;code&gt;:full&lt;/code&gt; names are the official Unicode character name, alias, or sequence, which all share a namespace.</source>
          <target state="translated">Но до версии 5.16 вы должны четко указать, какой набор имен символов вы хотите. Имя &lt;code&gt;:full&lt;/code&gt; - это официальное имя, псевдоним или последовательность символов Юникода, которые имеют общее пространство имен.</target>
        </trans-unit>
        <trans-unit id="6ea0e56fa9cef58c93ebf2b8ef0ed82782b2271a" translate="yes" xml:space="preserve">
          <source>But recall that not all operating systems support forking or capturing of the output of commands, so this complex statement may not be portable.</source>
          <target state="translated">Но помните,что не все операционные системы поддерживают форкинг или захват вывода команд,поэтому этот сложный оператор может быть не портативным.</target>
        </trans-unit>
        <trans-unit id="f098d4fba29dcb8c3c77666f8cde3d29b4074e10" translate="yes" xml:space="preserve">
          <source>But some modules cannot be built with this mantra. They try to get some extra data from the user via the environment, extra arguments, or interactively--thus disturbing the installation of large bundles like Phalanx100 or modules with many dependencies like Plagger.</source>
          <target state="translated">Но некоторые модули не могут быть построены с помощью этой мантры.Они пытаются получить некоторые дополнительные данные от пользователя через среду,дополнительные аргументы или интерактивно-это мешает установке больших пакетов,таких как Phalanx100 или модулей с множеством зависимостей,таких как Plagger.</target>
        </trans-unit>
        <trans-unit id="b9343448796744b38fdcc31c04963c50f230e565" translate="yes" xml:space="preserve">
          <source>But stringify it and you get just the text content:</source>
          <target state="translated">Но строчите его,и вы получите только текстовое содержимое:</target>
        </trans-unit>
        <trans-unit id="420149069302ad928f47370a01dc8262cabda22d" translate="yes" xml:space="preserve">
          <source>But take care not to pass it as, for example</source>
          <target state="translated">Но будьте осторожны,чтобы не пропустить это,как,например.</target>
        </trans-unit>
        <trans-unit id="f5ed605cf911baa94f53b7f6af1d782e89ccd2f6" translate="yes" xml:space="preserve">
          <source>But testing for taintedness gets you only so far. Sometimes you have just to clear your data's taintedness. Values may be untainted by using them as keys in a hash; otherwise the only way to bypass the tainting mechanism is by referencing subpatterns from a regular expression match. Perl presumes that if you reference a substring using $1, $2, etc. in a non-tainting pattern, that you knew what you were doing when you wrote that pattern. That means using a bit of thought--don't just blindly untaint anything, or you defeat the entire mechanism. It's better to verify that the variable has only good characters (for certain values of &quot;good&quot;) rather than checking whether it has any bad characters. That's because it's far too easy to miss bad characters that you never thought of.</source>
          <target state="translated">Но проверка на запятнанность пока что дает вам только возможность.Иногда нужно просто очистить данные от пятен.Значения могут быть не запятнаны,используя их в качестве ключей в хэше,иначе единственный способ обойти механизм запятнания-это обратиться к подмаскадкам из совпадения регулярных выражений.Perl предполагает,что если вы ссылаетесь на подстроку,использующую $1,$2 и т.д.в не содержащем подстроек шаблоне,то вы знали,что делаете,когда писали этот шаблон.Это означает,что используя немного подумать-не стоит просто слепо ничего не замечать,или вы проиграете весь механизм.Лучше проверить,что в переменной есть только хорошие символы (для определенных значений &quot;хорошие&quot;),чем проверять,нет ли в ней плохих символов.Это потому,что слишком легко пропустить плохие символы,о которых вы никогда не думали.</target>
        </trans-unit>
        <trans-unit id="07ab01a33d4e7c1814e10d3a1451c86fcb0fab16" translate="yes" xml:space="preserve">
          <source>But that can produce ambiguous syntax in certain cases, so it's often better to use the direct method invocation approach:</source>
          <target state="translated">Но в некоторых случаях это может привести к неоднозначному синтаксису,поэтому часто лучше использовать подход прямого вызова метода:</target>
        </trans-unit>
        <trans-unit id="4081f5e36560816f0b341323008a11e961519754" translate="yes" xml:space="preserve">
          <source>But that isn't going to match; at least, not the way you're hoping. It claims that there is no 123 in the string. Here's a clearer picture of why that pattern matches, contrary to popular expectations:</source>
          <target state="translated">Но это не совпадает,по крайней мере,не так,как ты надеешься.Он утверждает,что в строке нет 123.Вот более ясная картина того,почему этот паттерн совпадает,вопреки ожиданиям популярных людей:</target>
        </trans-unit>
        <trans-unit id="07b885fe74e23c15de33bcf3d35cb8fafefcc846" translate="yes" xml:space="preserve">
          <source>But that second &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is rushing ahead. It isn't using a simple literal string for the template. So maybe we should introduce...</source>
          <target state="translated">Но вторая &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; идет впереди. В шаблоне не используется простая буквальная строка. Так что, возможно, нам стоит представить ...</target>
        </trans-unit>
        <trans-unit id="861b5be1d3b22e874a1fd22ed51f10196d9c89e5" translate="yes" xml:space="preserve">
          <source>But that's not terribly pretty. You may find it simpler or clearer in the long run to just do things like this:</source>
          <target state="translated">Но это не очень красиво.Может быть,в конце концов,вам будет проще или понятнее делать такие вещи:</target>
        </trans-unit>
        <trans-unit id="5d68c723e2845ae1a2c75f9213f2beec623c2f67" translate="yes" xml:space="preserve">
          <source>But that's rather inefficient. A better way to do it is to start your program with:</source>
          <target state="translated">Но это довольно неэффективно.Лучший способ сделать это-начать свою программу:</target>
        </trans-unit>
        <trans-unit id="b0666cc872d80abdc9e23386d6ece439d18c0915" translate="yes" xml:space="preserve">
          <source>But the HERE_TARGET must still be flush against the margin. If you want that indented also, you'll have to quote in the indentation.</source>
          <target state="translated">Но HERE_TARGET все равно должен быть смыт с края.Если вы хотите,чтобы этот отступ также был выведен,вам нужно будет процитировать его.</target>
        </trans-unit>
        <trans-unit id="3261d19f3d27e578566dcbff378ffaa4781a7162" translate="yes" xml:space="preserve">
          <source>But the following code is quite bad:</source>
          <target state="translated">Но следующий код довольно плохой:</target>
        </trans-unit>
        <trans-unit id="ce9ae2e6c3f8a198a1ff872d901ef6ec6abf0329" translate="yes" xml:space="preserve">
          <source>But there are some cases where only this solution works (like &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; );</source>
          <target state="translated">Но бывают случаи, когда работает только это решение (например, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; );</target>
        </trans-unit>
        <trans-unit id="6bbd2ecd4d2700eece4600f310be07e3be1c2ebf" translate="yes" xml:space="preserve">
          <source>But there are some cases where you may want to know which character set you are running under. One possible example is doing &lt;a href=&quot;#SORTING&quot;&gt;sorting&lt;/a&gt; in inner loops where performance is critical.</source>
          <target state="translated">Но в некоторых случаях вы можете захотеть узнать, с каким набором символов вы работаете. Один из возможных примеров - &lt;a href=&quot;#SORTING&quot;&gt;сортировка&lt;/a&gt; во внутренних циклах, где производительность имеет решающее значение.</target>
        </trans-unit>
        <trans-unit id="79f382a399e7acdac77923f9261c190aa9a11824" translate="yes" xml:space="preserve">
          <source>But there's no real need for &lt;b&gt;both&lt;/b&gt; to be tempfiles... the following should work just as well, without deadlocking:</source>
          <target state="translated">Но нет никакой реальной необходимости, чтобы &lt;b&gt;оба&lt;/b&gt; были временными файлами ... следующее должно работать точно так же, без взаимоблокировок:</target>
        </trans-unit>
        <trans-unit id="5a55d83408434c70f23ed8c60b8e212b2bfead28" translate="yes" xml:space="preserve">
          <source>But they may be arbitrarily long:</source>
          <target state="translated">Но они могут быть произвольно длинными:</target>
        </trans-unit>
        <trans-unit id="47bd7edd758647409df600b782dfd569cb2795d8" translate="yes" xml:space="preserve">
          <source>But they may span several (non-blank) lines:</source>
          <target state="translated">Но они могут охватывать несколько (не пустых)строк:</target>
        </trans-unit>
        <trans-unit id="af1031e39fec41022cade090893d6211ac853b17" translate="yes" xml:space="preserve">
          <source>But this does not have the effect that someone reading the code would likely expect, as the intersection applies just to &lt;code&gt;\p{Thai}&lt;/code&gt; , excluding the Laotian. Pitfalls like this can be avoided by parenthesizing the component pieces:</source>
          <target state="translated">Но это не имеет того эффекта, который мог бы ожидать кто-то, читающий код, поскольку пересечение относится только к &lt;code&gt;\p{Thai}&lt;/code&gt; , за исключением лаосского. Подобных ловушек можно избежать, заключив в скобки компоненты:</target>
        </trans-unit>
        <trans-unit id="5e39b52a31dfee971d175ae42a65864bfa50aedc" translate="yes" xml:space="preserve">
          <source>But this doesn't match, at least not the way one might expect. Only after inserting the interpolated &lt;code&gt;$a99a&lt;/code&gt; and looking at the resulting full text of the regexp is it obvious that the backreferences have backfired. The subexpression &lt;code&gt;(\w+)&lt;/code&gt; has snatched number 1 and demoted the groups in &lt;code&gt;$a99a&lt;/code&gt; by one rank. This can be avoided by using relative backreferences:</source>
          <target state="translated">Но это не совпадает, по крайней мере, не так, как можно было бы ожидать. Только после вставки интерполированного &lt;code&gt;$a99a&lt;/code&gt; и просмотра полученного полного текста регулярного выражения становится очевидно, что обратные ссылки дали обратный эффект. Подвыражение &lt;code&gt;(\w+)&lt;/code&gt; перехватило номер 1 и &lt;code&gt;$a99a&lt;/code&gt; группы в $ a99a на один ранг. Этого можно избежать, используя относительные обратные ссылки:</target>
        </trans-unit>
        <trans-unit id="3d71f7e1b353d405d0ac11988a391e51c106c8d8" translate="yes" xml:space="preserve">
          <source>But this is not:</source>
          <target state="translated">Но это не так:</target>
        </trans-unit>
        <trans-unit id="b33d301cbe486111cdb963daebee73c9ce3e8834" translate="yes" xml:space="preserve">
          <source>But to avoid portability warnings (see &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;), you may prefer:</source>
          <target state="translated">Но чтобы избежать предупреждений о переносимости (см. &lt;a href=&quot;functions/use&quot;&gt;Использование&lt;/a&gt; ), вы можете предпочесть:</target>
        </trans-unit>
        <trans-unit id="020939326fc990dde03b1b00ce335dbc09c9fc3e" translate="yes" xml:space="preserve">
          <source>But wait: doesn't &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; just return a sequence of bytes? How can we pass this string of bytes to some C code expecting a pointer which is, after all, nothing but a number? The answer is simple: We have to obtain the numeric address from the bytes returned by &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Но подождите: разве &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; просто не возвращает последовательность байтов? Как мы можем передать эту строку байтов в некоторый код C, ожидающий указателя, который, в конце концов, является не чем иным, как числом? Ответ прост: мы должны получить числовой адрес из байтов, возвращаемых &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97c582aeb02e8310ccc2268a23e2a13586d2230f" translate="yes" xml:space="preserve">
          <source>But what if we had an indeterminate number of words? This is the sort of task &lt;code&gt;//g&lt;/code&gt; was made for. To extract all words, form the simple regexp &lt;code&gt;(\w+)&lt;/code&gt; and loop over all matches with &lt;code&gt;/(\w+)/g&lt;/code&gt; :</source>
          <target state="translated">Но что, если бы у нас было неопределенное количество слов? Это своего рода задач &lt;code&gt;//g&lt;/code&gt; было сделано для. Чтобы извлечь все слова, сформируйте простое регулярное выражение &lt;code&gt;(\w+)&lt;/code&gt; и переберите все совпадения с помощью &lt;code&gt;/(\w+)/g&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ae7271808fc8fe6737543912e6a4f4345f08e046" translate="yes" xml:space="preserve">
          <source>But when &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; is used instead of &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; :</source>
          <target state="translated">Но когда &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; используется вместо &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a237c274e15fc51e976c2366d2b1cd3f9bba3c7c" translate="yes" xml:space="preserve">
          <source>But when the following lines are added at the end:</source>
          <target state="translated">Но когда в конце добавляются следующие строки:</target>
        </trans-unit>
        <trans-unit id="b3a7682b246bb8254bfcb416501b69b76a746fd6" translate="yes" xml:space="preserve">
          <source>But with the actual compile tree for &lt;code&gt;$a = $b + $c&lt;/code&gt; it is different: some nodes</source>
          <target state="translated">Но с фактическим деревом компиляции для &lt;code&gt;$a = $b + $c&lt;/code&gt; все иначе: некоторые узлы</target>
        </trans-unit>
        <trans-unit id="4db6b75d323cb14de03fc556f71c215fa0254459" translate="yes" xml:space="preserve">
          <source>But won't work when called as:</source>
          <target state="translated">Но не сработает,когда позвонят как:</target>
        </trans-unit>
        <trans-unit id="41f61e687d338fbf08bd8ac1adb4bd20048487aa" translate="yes" xml:space="preserve">
          <source>But you don't actually have to make two pipe calls. If you have the socketpair() system call, it will do this all for you.</source>
          <target state="translated">Но на самом деле тебе не нужно делать два звонка по трубе.Если у вас есть системный вызов socketpair(),он сделает все это за вас.</target>
        </trans-unit>
        <trans-unit id="8bc61709d9d36e283fe251c9894f7f9c70eff276" translate="yes" xml:space="preserve">
          <source>But you still cannot make assumptions about whether this is correct, unless your policy says it is. You really are best off asking the user.</source>
          <target state="translated">Но вы все еще не можете делать предположений о том,верно ли это,если только ваша политика не говорит об этом.Лучше всего спросить пользователя.</target>
        </trans-unit>
        <trans-unit id="4b9905ad0aeb95ca50441bf7c28631173d039f82" translate="yes" xml:space="preserve">
          <source>But you still have those funny select()s. So just use the FileHandle module. Now, you can access these special variables using lowercase method names instead:</source>
          <target state="translated">Но у тебя все еще есть эти забавные select().Так что просто используйте модуль FileHandle.Теперь вы можете получить доступ к этим специальным переменным,используя вместо этого строчные имена методов:</target>
        </trans-unit>
        <trans-unit id="45dd0cd91dc6886148fd373bfb4f17c3a9594ab0" translate="yes" xml:space="preserve">
          <source>But, by extracting the directive using &lt;code&gt;extract_codeblock($text, '{}', &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, '&amp;lt;&amp;gt;')&lt;/code&gt; the '&amp;gt;' character is only treated as a delimited at the outermost level of the code block, so the directive is parsed correctly.</source>
          <target state="translated">Но при извлечении директивы с помощью &lt;code&gt;extract_codeblock($text, '{}', &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, '&amp;lt;&amp;gt;')&lt;/code&gt; символ '&amp;gt;' обрабатывается только как разделенный на самом внешнем уровне блока кода, поэтому директива анализируется правильно .</target>
        </trans-unit>
        <trans-unit id="25b354100dcfbea76bd0e9e5a69bf58ebc32ab47" translate="yes" xml:space="preserve">
          <source>By calling the class method &lt;code&gt;Math::Complex::display_format&lt;/code&gt; and supplying either &lt;code&gt;&quot;polar&quot;&lt;/code&gt; or &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; as an argument, you override the default display style, which is &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; . Not supplying any argument returns the current settings.</source>
          <target state="translated">Вызывая метод класса &lt;code&gt;Math::Complex::display_format&lt;/code&gt; и &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; в качестве аргумента либо &lt;code&gt;&quot;polar&quot;&lt;/code&gt; либо &amp;laquo;декартовый&amp;raquo; , вы переопределяете стиль отображения по умолчанию, который является &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; . Отсутствие аргумента возвращает текущие настройки.</target>
        </trans-unit>
        <trans-unit id="27d08c1f941525ad751e4a25955a26ef38161991" translate="yes" xml:space="preserve">
          <source>By contrast, if</source>
          <target state="translated">Напротив,если</target>
        </trans-unit>
        <trans-unit id="d13b7913a7d5727103d5a0ff02bb43cd904ec898" translate="yes" xml:space="preserve">
          <source>By convention, CPAN Digest modules do &lt;b&gt;not&lt;/b&gt; pad their Base64 output. Problems can occur when feeding such digests to other software that expects properly padded Base64 encodings.</source>
          <target state="translated">По соглашению, модули дайджеста CPAN &lt;b&gt;не&lt;/b&gt; дополняют свой вывод Base64. Проблемы могут возникнуть при загрузке таких дайджестов в другое программное обеспечение, которое ожидает правильно заполненные кодировки Base64.</target>
        </trans-unit>
        <trans-unit id="fa63c3f7831848cc55dec885e0aadbe7e110091f" translate="yes" xml:space="preserve">
          <source>By convention, all the calls to OS/2 API should indicate their failures by resetting $^E. All the Perl-accessible functions which call OS/2 API may be broken into two classes: some die()s when an API error is encountered, the other report the error via a false return value (of course, this does not concern Perl-accessible functions which</source>
          <target state="translated">По общему правилу,все звонки в OS/2 API должны указывать на свои сбои,сбросив $^E.Все Perl-доступные функции,вызывающие OS/2 API,могут быть разбиты на два класса:одни die()s при обнаружении ошибки API,другие сообщают об ошибке через ложное возвращаемое значение (конечно,это не относится к Perl-доступным функциям,которые</target>
        </trans-unit>
        <trans-unit id="98616871ec55526e1b310a455ba5f2d84e33363e" translate="yes" xml:space="preserve">
          <source>By convention, check routines have names &lt;code&gt;ck_*&lt;/code&gt; . They are usually called from &lt;code&gt;new*OP&lt;/code&gt; subroutines (or &lt;code&gt;convert&lt;/code&gt; ) (which in turn are called from</source>
          <target state="translated">По соглашению, подпрограммы проверки имеют имена &lt;code&gt;ck_*&lt;/code&gt; . Обычно они вызываются из &lt;code&gt;new*OP&lt;/code&gt; подпрограмм * OP (или &lt;code&gt;convert&lt;/code&gt; ) (которые, в свою очередь, вызываются из</target>
        </trans-unit>
        <trans-unit id="3ac2669af1abb44ebf6531e7e05b8563aa92056a" translate="yes" xml:space="preserve">
          <source>By convention, each test is assigned a number in order. This is largely done automatically for you. However, it's often very useful to assign a name to each test. Which would you rather see:</source>
          <target state="translated">По условию,каждому тесту присваивается номер по порядку.В основном это делается автоматически для вас.Однако,часто бывает очень полезно присвоить имя каждому тесту.Которое вы предпочитаете видеть:</target>
        </trans-unit>
        <trans-unit id="9314c5f036387917642398c26237bf03490cfd4b" translate="yes" xml:space="preserve">
          <source>By default</source>
          <target state="translated">По умолчанию</target>
        </trans-unit>
        <trans-unit id="a90acddb58b18220dbe08ab0b09969aa5f8ece27" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;$i-&amp;gt;inflate($input, $output)&lt;/code&gt; will uncompress</source>
          <target state="translated">По умолчанию &lt;code&gt;$i-&amp;gt;inflate($input, $output)&lt;/code&gt; распаковывает</target>
        </trans-unit>
        <trans-unit id="2b6ad4cdfaab155648e7ab26ef526a2e2f9bb93e" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; will build with a private copy of version 1.2.5 of the zlib library. (See the</source>
          <target state="translated">По умолчанию &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; будет компилироваться с частной копией версии 1.2.5 библиотеки zlib. (См.</target>
        </trans-unit>
        <trans-unit id="13d1bc9ce24c11cc5f6efdcd3fee51a91c8038f7" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Hash::Util&lt;/code&gt; does not export anything.</source>
          <target state="translated">По умолчанию &lt;code&gt;Hash::Util&lt;/code&gt; ничего не экспортирует.</target>
        </trans-unit>
        <trans-unit id="09e2116155b494da50686ee8fd22c6f8af75259f" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;List::Util&lt;/code&gt; does not export any subroutines.</source>
          <target state="translated">По умолчанию &lt;code&gt;List::Util&lt;/code&gt; не экспортирует никаких подпрограмм.</target>
        </trans-unit>
        <trans-unit id="5c8967b9c380cc8af7979a94b2f6e12071d5756c" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Scalar::Util&lt;/code&gt; does not export any subroutines.</source>
          <target state="translated">По умолчанию &lt;code&gt;Scalar::Util&lt;/code&gt; не экспортирует никаких подпрограмм.</target>
        </trans-unit>
        <trans-unit id="6a85c45889f6bd96a07b3072c70fdac86872c8e7" translate="yes" xml:space="preserve">
          <source>By default CPAN Meta specification &lt;code&gt;1.4&lt;/code&gt; is used. In order to use CPAN Meta specification &lt;code&gt;2.0&lt;/code&gt; , indicate with &lt;code&gt;meta-spec&lt;/code&gt; the version you want to use.</source>
          <target state="translated">По умолчанию используется мета-спецификация CPAN &lt;code&gt;1.4&lt;/code&gt; . Чтобы использовать CPAN Meta Specification &lt;code&gt;2.0&lt;/code&gt; , укажите в &lt;code&gt;meta-spec&lt;/code&gt; версию, которую вы хотите использовать.</target>
        </trans-unit>
        <trans-unit id="8bc161a96f1f3872cf0bfff0e6212dcccea74651" translate="yes" xml:space="preserve">
          <source>By default Perl does not use the &lt;code&gt;malloc()&lt;/code&gt; included with the Perl source, because it was slower and not entirely thread-safe. If you want to force Perl to build with the old -Dusemymalloc define this.</source>
          <target state="translated">По умолчанию Perl не использует &lt;code&gt;malloc()&lt;/code&gt; включенный в исходный код Perl, потому что он был медленнее и не полностью потокобезопасен. Если вы хотите заставить Perl строить со старым -Dusemymalloc, определите это.</target>
        </trans-unit>
        <trans-unit id="1261dc25c0b95e8495b666b1c3497fb4bd944f86" translate="yes" xml:space="preserve">
          <source>By default Perl uses 64 bit integers. If you want to use smaller 32 bit integers, define this symbol.</source>
          <target state="translated">По умолчанию Perl использует 64-битные целые числа.Если вы хотите использовать меньшие 32-битные целые числа,определите этот символ.</target>
        </trans-unit>
        <trans-unit id="2b8741f41b3847fc8e6d6ed4c668a3b8923660d9" translate="yes" xml:space="preserve">
          <source>By default Pod::Simple::HTML adds a dummy anchor at the top of the HTML. You can change it by calling</source>
          <target state="translated">По умолчанию Pod::Simple::HTML добавляет фиктивный якорь в верхней части HTML.Вы можете изменить его,позвонив</target>
        </trans-unit>
        <trans-unit id="63d675d5fb6fc8fe769b7759c86a5571aae789b8" translate="yes" xml:space="preserve">
          <source>By default floating point numbers substituted inside strings use the dot (&quot;.&quot;) as the decimal separator. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, and POSIX::setlocale() has been called, the character used for the decimal separator is affected by the LC_NUMERIC locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">По умолчанию числа с плавающей запятой, заменяемые внутри строк, используют точку (&quot;.&quot;) В качестве десятичного разделителя. Если действует &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; и была вызвана функция POSIX :: setlocale (), на символ, используемый для десятичного разделителя, влияет локаль LC_NUMERIC. См. &lt;a href=&quot;perllocale&quot;&gt;Perllocale&lt;/a&gt; и &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dadc258ff54a1a05b69b778084fc2dfc7494a970" translate="yes" xml:space="preserve">
          <source>By default it does nothing.</source>
          <target state="translated">По умолчанию он ничего не делает.</target>
        </trans-unit>
        <trans-unit id="4033d9fb012c9ab68d72ab1a3b85a5a59eb68724" translate="yes" xml:space="preserve">
          <source>By default it just prints the stubs, but you can set the global $Devel::SelfStubber::JUST_STUBS to 0 and it will print out the entire module with the stubs positioned correctly.</source>
          <target state="translated">По умолчанию он просто печатает корешки,но вы можете установить глобальный $Devel::SelfStubber::JUST_STUBS на 0 и он распечатает весь модуль с правильно расположенными корешками.</target>
        </trans-unit>
        <trans-unit id="f3cfe07b0874e5c860a9ad1e8fd1566639cad34f" translate="yes" xml:space="preserve">
          <source>By default it writes to &lt;code&gt;cwd()&lt;/code&gt; , but you can override that by specifying the &lt;code&gt;to&lt;/code&gt; argument:</source>
          <target state="translated">По умолчанию он записывает в &lt;code&gt;cwd()&lt;/code&gt; , но вы можете переопределить это, указав аргумент &lt;code&gt;to&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="27c6146d97f6523b1856790ae4b8a285b8e3db7e" translate="yes" xml:space="preserve">
          <source>By default no Unix2 extra field is created.</source>
          <target state="translated">По умолчанию дополнительное поле Unix2 не создается.</target>
        </trans-unit>
        <trans-unit id="0ab606593d4a9d45e75e4256f15600160e7bc2fa" translate="yes" xml:space="preserve">
          <source>By default no UnixN extra field is created.</source>
          <target state="translated">По умолчанию дополнительное поле UnixN не создается.</target>
        </trans-unit>
        <trans-unit id="ee18fc042b3c569119417a51774089c404eb248f" translate="yes" xml:space="preserve">
          <source>By default no extended time field is created.</source>
          <target state="translated">По умолчанию поле с увеличенным временем не создается.</target>
        </trans-unit>
        <trans-unit id="ebb685a0031880a3b5e0df98008f367fed554c4e" translate="yes" xml:space="preserve">
          <source>By default no opmask is in effect and any code can be compiled.</source>
          <target state="translated">По умолчанию ни одна оптическая маска не действует,и любой код может быть скомпилирован.</target>
        </trans-unit>
        <trans-unit id="c2a6e64907872a01e02add6a8ea23d69c4a6e77e" translate="yes" xml:space="preserve">
          <source>By default only the &lt;code&gt;langinfo()&lt;/code&gt; function is exported.</source>
          <target state="translated">По умолчанию экспортируется только &lt;code&gt;langinfo()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d98ec28c38227dc5b1c1a5373143946764c67c67" translate="yes" xml:space="preserve">
          <source>By default the &lt;a href=&quot;parser/sourcehandler/executable&quot;&gt;TAP::Parser::SourceHandler::Executable&lt;/a&gt; class will create a &lt;a href=&quot;parser/iterator/process&quot;&gt;TAP::Parser::Iterator::Process&lt;/a&gt; object to handle the source. This passes the array reference strings as command arguments to &lt;a href=&quot;../ipc/open3&quot;&gt;IPC::Open3::open3&lt;/a&gt;:</source>
          <target state="translated">По умолчанию класс &lt;a href=&quot;parser/sourcehandler/executable&quot;&gt;TAP :: Parser :: SourceHandler :: Executable&lt;/a&gt; создает объект &lt;a href=&quot;parser/iterator/process&quot;&gt;TAP :: Parser :: Iterator :: Process&lt;/a&gt; для обработки источника. Это передает строки ссылок на массив в качестве аргументов команды в &lt;a href=&quot;../ipc/open3&quot;&gt;IPC :: Open3 :: open3&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a48220280114a78503f2a2001b0a32eddecb9d87" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;flush_type&lt;/code&gt; used is &lt;code&gt;Z_FINISH&lt;/code&gt; . Other valid values for &lt;code&gt;flush_type&lt;/code&gt; are &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; , &lt;code&gt;Z_PARTIAL_FLUSH&lt;/code&gt; , &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; and &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; . It is strongly recommended that you only set the &lt;code&gt;flush_type&lt;/code&gt; parameter if you fully understand the implications of what it does. See the &lt;code&gt;zlib&lt;/code&gt; documentation for details.</source>
          <target state="translated">По умолчанию используется &lt;code&gt;flush_type&lt;/code&gt; - &lt;code&gt;Z_FINISH&lt;/code&gt; . Другие допустимые значения для &lt;code&gt;flush_type&lt;/code&gt; : &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; , &lt;code&gt;Z_PARTIAL_FLUSH&lt;/code&gt; , &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; и &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; . Настоятельно рекомендуется устанавливать параметр &lt;code&gt;flush_type&lt;/code&gt; только в том случае, если вы полностью понимаете последствия того, что он делает. Подробности смотрите в документации по &lt;code&gt;zlib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13a328506dc208738ad9d028668747611624fc18" translate="yes" xml:space="preserve">
          <source>By default the Makefile produced includes all the static extensions in the perl library. (Purified versions of library files, e.g., DynaLoader_pure_p1_c0_032.a are automatically ignored to avoid link errors.)</source>
          <target state="translated">По умолчанию Makefile включает в себя все статические расширения в библиотеке perl.(Очищенные версии файлов библиотеки,например,DynaLoader_pure_p1_c0_032.a,автоматически игнорируются во избежание ошибок при линковке).</target>
        </trans-unit>
        <trans-unit id="72406ce9b9b1b9e64fd6ddb212ef0d9f15de7828" translate="yes" xml:space="preserve">
          <source>By default the debugger is called using &lt;code&gt;-d&lt;/code&gt; option to perl. If you want to specify some other option, set the &lt;code&gt;TESTDB_SW&lt;/code&gt; variable:</source>
          <target state="translated">По умолчанию отладчик вызывается с использованием параметра &lt;code&gt;-d&lt;/code&gt; для perl. Если вы хотите указать другую опцию, установите переменную &lt;code&gt;TESTDB_SW&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b2356cae1189c23be90e67a7d45b9477ad72051f" translate="yes" xml:space="preserve">
          <source>By default the directory is deleted when the object goes out of scope.</source>
          <target state="translated">По умолчанию каталог удаляется,когда объект выходит за пределы области видимости.</target>
        </trans-unit>
        <trans-unit id="cbf770fbcc502baf26e331b84104d6aaf9126f59" translate="yes" xml:space="preserve">
          <source>By default the layers from the input side of the filehandle are returned; to get the output side, use the optional &lt;code&gt;output&lt;/code&gt; argument:</source>
          <target state="translated">По умолчанию возвращаются слои со стороны ввода дескриптора файла; чтобы получить выходную сторону, используйте необязательный &lt;code&gt;output&lt;/code&gt; аргумент:</target>
        </trans-unit>
        <trans-unit id="29f25f3b77d3062c86a659cbc91ff07ea769bf59" translate="yes" xml:space="preserve">
          <source>By default this will include *.pm and *.pl and the files found in the PMLIBDIRS directories. Defining PM in the Makefile.PL will override PMLIBDIRS.</source>
          <target state="translated">По умолчанию это будут *.pm и *.pl,а также файлы,находящиеся в каталогах PMLIBDIRS.Определение PM в Makefile.PL переопределит PMLIBDIRS.</target>
        </trans-unit>
        <trans-unit id="1c14ce64b17e700de893a0b00ad2e97e494dcfd4" translate="yes" xml:space="preserve">
          <source>By default verbose output is generated, setting the PERL_INSTALL_QUIET environment variable will silence this output.</source>
          <target state="translated">По умолчанию генерируется подробный вывод,установка переменной окружения PERL_INSTALL_QUIET заставит этот вывод замолчать.</target>
        </trans-unit>
        <trans-unit id="4e63e74d2a508a1a33c3e1bb5754226ab9609082" translate="yes" xml:space="preserve">
          <source>By default your system's F_* and O_* constants (eg, F_DUPFD and O_CREAT) and the FD_CLOEXEC constant are exported into your namespace.</source>
          <target state="translated">По умолчанию в пространство имен экспортируются константы F_*и O_*вашей системы (например,F_DUPFD и O_CREAT),а также константа FD_CLOEXEC.</target>
        </trans-unit>
        <trans-unit id="b44b2a95f6381a248195f00274a8435d100aaa35" translate="yes" xml:space="preserve">
          <source>By default,</source>
          <target state="translated">По умолчанию,</target>
        </trans-unit>
        <trans-unit id="6d88a1aadef2616cc309d3135c3c0ad225e5d689" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;../../cpan/meta/yaml&quot;&gt;CPAN::Meta::YAML&lt;/a&gt; will be used for deserializing YAML data. If the &lt;code&gt;PERL_YAML_BACKEND&lt;/code&gt; environment variable is defined, then it is interpreted as a module to use for deserialization. The given module must be installed, must load correctly and must implement the &lt;code&gt;Load()&lt;/code&gt; function or an exception will be thrown.</source>
          <target state="translated">По умолчанию &lt;a href=&quot;../../cpan/meta/yaml&quot;&gt;CPAN :: Meta :: YAML&lt;/a&gt; будет использоваться для десериализации данных YAML. Если &lt;code&gt;PERL_YAML_BACKEND&lt;/code&gt; среды PERL_YAML_BACKEND определена, она интерпретируется как модуль, используемый для десериализации. Данный модуль должен быть установлен, должен правильно загружаться и реализовывать функцию &lt;code&gt;Load()&lt;/code&gt; иначе будет создано исключение.</target>
        </trans-unit>
        <trans-unit id="a9ce14085141d2bedbc81e908e7a8dd19fcc292a" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;../../json/pp&quot;&gt;JSON::PP&lt;/a&gt; will be used for deserializing JSON data. If the &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; environment variable exists, is true and is not &quot;JSON::PP&quot;, then the &lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON&lt;/a&gt; module (version 2.5 or greater) will be loaded and used to interpret &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; . If &lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON&lt;/a&gt; is not installed or is too old, an exception will be thrown.</source>
          <target state="translated">По умолчанию &lt;a href=&quot;../../json/pp&quot;&gt;JSON :: PP&lt;/a&gt; будет использоваться для десериализации данных JSON. Если &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; среды PERL_JSON_BACKEND существует, имеет значение true и не является &amp;laquo;JSON :: PP&amp;raquo;, то модуль &lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON&lt;/a&gt; (версия 2.5 или выше) будет загружен и использован для интерпретации &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; . Если &lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON&lt;/a&gt; не установлен или слишком старый, будет выдано исключение.</target>
        </trans-unit>
        <trans-unit id="79a294e48ade56dbe097d94ecb2d017b667469c8" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email::Sender::Simple&lt;/a&gt; will try `sendmail` first, if it exists in your $PATH. This generally isn't the case. If there's a remote mail server you use to send mail, consider investigating one of the Transport classes. At time of writing, the available transports include:</source>
          <target state="translated">По умолчанию &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email :: Sender :: Simple&lt;/a&gt; сначала попробует sendmail, если он существует в вашем $ PATH. Обычно это не так. Если есть удаленный почтовый сервер, который вы используете для отправки почты, рассмотрите возможность изучения одного из классов транспорта. На момент написания доступные транспорты включают:</target>
        </trans-unit>
        <trans-unit id="d72ee058cb3ba5edce2a08b405dc90217d0eada0" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;Locale::Maketext::Simple&lt;/b&gt; draws its source from the calling package's</source>
          <target state="translated">По умолчанию &lt;b&gt;Locale :: Maketext :: Simple&lt;/b&gt; извлекает свой источник из вызывающего пакета</target>
        </trans-unit>
        <trans-unit id="35fc08f26016b44845e97a461120088a4d635511" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2man&lt;/b&gt; dies if any errors are detected in the POD input. If &lt;b&gt;--stderr&lt;/b&gt; is given and no &lt;b&gt;--errors&lt;/b&gt; flag is present, errors are sent to standard error, but &lt;b&gt;pod2man&lt;/b&gt; does not abort. This is equivalent to &lt;code&gt;--errors=stderr&lt;/code&gt; and is supported for backward compatibility.</source>
          <target state="translated">По умолчанию &lt;b&gt;pod2man&lt;/b&gt; умирает, если обнаруживаются какие-либо ошибки на входе POD. Если &lt;b&gt;указан --stderr&lt;/b&gt; и нет флага &lt;b&gt;--errors&lt;/b&gt; , ошибки отправляются в стандартную ошибку, но &lt;b&gt;pod2man&lt;/b&gt; не &lt;b&gt;прерывается&lt;/b&gt; . Это эквивалентно &lt;code&gt;--errors=stderr&lt;/code&gt; и поддерживается для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="30d3609c8a43f768f52510e95fef029cac6273de" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2man&lt;/b&gt; produces the most conservative possible *roff output to try to ensure that it will work with as many different *roff implementations as possible. Many *roff implementations cannot handle non-ASCII characters, so this means all non-ASCII characters are converted either to a *roff escape sequence that tries to create a properly accented character (at least for troff output) or to &lt;code&gt;X&lt;/code&gt; .</source>
          <target state="translated">По умолчанию &lt;b&gt;pod2man&lt;/b&gt; производит максимально консервативный вывод * roff, чтобы убедиться, что он будет работать с как можно большим количеством различных реализаций * roff. Многие реализации * РОФФ не может обрабатывать не-ASCII символов, так что это означает , что все символы не-ASCII которые преобразуются либо в * ROFF последовательности побега , который пытается создать правильно акцентировано характер (по крайней мере , для вывода TROFF) или &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7337f82d45ceca3575dcc4fcaada9bab5f7a5ae" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2text&lt;/b&gt; dies if any errors are detected in the POD input. If &lt;b&gt;--stderr&lt;/b&gt; is given and no &lt;b&gt;--errors&lt;/b&gt; flag is present, errors are sent to standard error, but &lt;b&gt;pod2text&lt;/b&gt; does not abort. This is equivalent to &lt;code&gt;--errors=stderr&lt;/code&gt; and is supported for backward compatibility.</source>
          <target state="translated">По умолчанию &lt;b&gt;pod2text&lt;/b&gt; умирает, если во вводе POD обнаруживаются какие-либо ошибки. Если &lt;b&gt;указан --stderr&lt;/b&gt; и нет флага &lt;b&gt;--errors&lt;/b&gt; , ошибки отправляются в стандартную ошибку, но &lt;b&gt;pod2text&lt;/b&gt; не &lt;b&gt;прерывается&lt;/b&gt; . Это эквивалентно &lt;code&gt;--errors=stderr&lt;/code&gt; и поддерживается для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="d7d98831aaac5ae8bfa863600541ce748cdfa2ce" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2text&lt;/b&gt; tries to use the same output encoding as its input encoding (to be backward-compatible with older versions). This option says to instead force the output encoding to UTF-8.</source>
          <target state="translated">По умолчанию &lt;b&gt;pod2text&lt;/b&gt; пытается использовать ту же кодировку вывода, что и его кодировка ввода (для обратной совместимости со старыми версиями). Этот параметр говорит, что вместо этого нужно принудительно использовать кодировку вывода в UTF-8.</target>
        </trans-unit>
        <trans-unit id="f53f148127af7bd5af025188de73dc79a271f7fe" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2usage()&lt;/b&gt; will use &lt;code&gt;$0&lt;/code&gt; as the path to the pod input file. Unfortunately, not all systems on which Perl runs will set &lt;code&gt;$0&lt;/code&gt; properly (although if &lt;code&gt;$0&lt;/code&gt; isn't found, &lt;b&gt;pod2usage()&lt;/b&gt; will search &lt;code&gt;$ENV{PATH}&lt;/code&gt; or else the list specified by the &lt;code&gt;-pathlist&lt;/code&gt; option). If this is the case for your system, you may need to explicitly specify the path to the pod docs for the invoking script using something similar to the following:</source>
          <target state="translated">По умолчанию &lt;b&gt;pod2usage ()&lt;/b&gt; будет использовать &lt;code&gt;$0&lt;/code&gt; в качестве пути к входному файлу модуля. К сожалению, не все системы, в которых работает Perl, будут правильно устанавливать &lt;code&gt;$0&lt;/code&gt; (хотя, если &lt;code&gt;$0&lt;/code&gt; не найден, &lt;b&gt;pod2usage ()&lt;/b&gt; будет искать &lt;code&gt;$ENV{PATH}&lt;/code&gt; или список, указанный параметром &lt;code&gt;-pathlist&lt;/code&gt; ). Если это так для вашей системы, вам может потребоваться явно указать путь к документации модуля для вызывающего скрипта, используя что-то подобное следующему:</target>
        </trans-unit>
        <trans-unit id="139ad65b1f5c08871019f97feca04f36c4d7791f" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; is in a completely POSIX-compatible mode, which uses the POSIX-specification of &lt;code&gt;tar&lt;/code&gt; to store files. For paths greater than 100 characters, this is done using the &lt;code&gt;POSIX header prefix&lt;/code&gt; . Non-POSIX-compatible clients may not support this part of the specification, and may only support the &lt;code&gt;GNU Extended
Header&lt;/code&gt; functionality. To facilitate those clients, you can set the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt; . See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section for details on this variable.</source>
          <target state="translated">По умолчанию &lt;code&gt;Archive::Tar&lt;/code&gt; находится в полностью POSIX-совместимом режиме, который использует POSIX-спецификацию &lt;code&gt;tar&lt;/code&gt; для хранения файлов. Для путей длиной более 100 символов это делается с помощью &lt;code&gt;POSIX header prefix&lt;/code&gt; . Клиенты, не поддерживающие POSIX, могут не поддерживать эту часть спецификации и могут поддерживать только функциональность &lt;code&gt;GNU Extended Header&lt;/code&gt; . Чтобы облегчить работу этих клиентов, вы можете установить для переменной &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; значение &lt;code&gt;true&lt;/code&gt; . См. Раздел &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; для получения подробной информации об этой переменной.</target>
        </trans-unit>
        <trans-unit id="a0ce25419277d6adf6e0c4949f8ca8dca00cd62d" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; will try to &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; your files to whatever mode was specified for the particular file in the archive. In some cases, this may not be desired. In that case, set this variable to &lt;code&gt;0&lt;/code&gt; to disable &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt;-ing.</source>
          <target state="translated">По умолчанию &lt;code&gt;Archive::Tar&lt;/code&gt; попытается &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; ваши файлы в режим chmod, указанный для конкретного файла в архиве. В некоторых случаях это может быть нежелательно. В этом случае установите для этой переменной значение &lt;code&gt;0&lt;/code&gt; , чтобы отключить &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; -ing.</target>
        </trans-unit>
        <trans-unit id="eb67a5af923530004ebe769a16f96c44f7d23600" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; will try to &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; your files if it is able to. In some cases, this may not be desired. In that case, set this variable to &lt;code&gt;0&lt;/code&gt; to disable &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt;-ing, even if it were possible.</source>
          <target state="translated">По умолчанию &lt;code&gt;Archive::Tar&lt;/code&gt; будет пытаться &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; ваши файлы, если это возможно. В некоторых случаях это может быть нежелательно. В этом случае установите для этой переменной значение &lt;code&gt;0&lt;/code&gt; , чтобы отключить &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; -ing, даже если это возможно.</target>
        </trans-unit>
        <trans-unit id="a46faa893a6a331982326586cd0db0d3a2c1dfbd" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; will try to put paths that are over 100 characters in the &lt;code&gt;prefix&lt;/code&gt; field of your tar header, as defined per POSIX-standard. However, some (older) tar programs do not implement this spec. To retain compatibility with these older or non-POSIX compliant versions, you can set the &lt;code&gt;$DO_NOT_USE_PREFIX&lt;/code&gt; variable to a true value, and &lt;code&gt;Archive::Tar&lt;/code&gt; will use an alternate way of dealing with paths over 100 characters by using the &lt;code&gt;GNU Extended Header&lt;/code&gt; feature.</source>
          <target state="translated">По умолчанию &lt;code&gt;Archive::Tar&lt;/code&gt; будет пытаться поместить пути длиной более 100 символов в поле &lt;code&gt;prefix&lt;/code&gt; вашего tar-заголовка, как определено в стандарте POSIX. Однако некоторые (более старые) программы tar не реализуют эту спецификацию. Чтобы сохранить совместимость с этими более ранними или несовместимыми с POSIX версиями, вы можете установить для переменной &lt;code&gt;$DO_NOT_USE_PREFIX&lt;/code&gt; истинное значение, а &lt;code&gt;Archive::Tar&lt;/code&gt; будет использовать альтернативный способ работы с путями длиной более 100 символов с помощью функции &lt;code&gt;GNU Extended Header&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca08f9f1e5aebac60920c9f0bab0c8d5475cdd53" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Sys::Syslog&lt;/code&gt; exports the symbols from the &lt;code&gt;:standard&lt;/code&gt; tag.</source>
          <target state="translated">По умолчанию &lt;code&gt;Sys::Syslog&lt;/code&gt; экспортирует символы из тега &lt;code&gt;:standard&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea04cfd93bdf64370c1cc20e848935f755855d27" translate="yes" xml:space="preserve">
          <source>By default, CJK unified ideographs are ordered in Unicode codepoint order, but those in the CJK Unified Ideographs block are less than those in the CJK Unified Ideographs Extension A etc.</source>
          <target state="translated">По умолчанию CJK унифицированные идеографы заказываются в кодовом порядке Unicode,но в блоке CJK унифицированных идеографов меньше,чем в CJK Unified Ideographs Extension A и т.д.</target>
        </trans-unit>
        <trans-unit id="c9fd4df55423b1ff0429c30297d024455fc09d6b" translate="yes" xml:space="preserve">
          <source>By default, CPAN will install the latest non-developer release of a module. If you want to install a dev release, you have to specify the partial path starting with the author id to the tarball you wish to install, like so:</source>
          <target state="translated">По умолчанию CPAN установит последнюю версию модуля,не предназначенную для разработчиков.Если вы хотите установить релиз dev,вам нужно указать частичный путь,начинающийся с id автора и заканчивающийся tarball,который вы хотите установить:</target>
        </trans-unit>
        <trans-unit id="d31a5f0a0e7ac5c54379eb4d64385f193a7c7e78" translate="yes" xml:space="preserve">
          <source>By default, Data::Dumper builds up the &quot;seen&quot; hash of scalars that it has encountered during serialization. This is very expensive. This seen hash is necessary to support and even just detect circular references. It is exposed to the user via the &lt;code&gt;Seen()&lt;/code&gt; call both for writing and reading.</source>
          <target state="translated">По умолчанию Data :: Dumper создает &amp;laquo;видимый&amp;raquo; хэш скаляров, с которым он столкнулся во время сериализации. Это очень дорого. Этот видимый хэш необходим для поддержки и даже просто обнаружения циклических ссылок. Он предоставляется пользователю через вызов &lt;code&gt;Seen()&lt;/code&gt; как для записи, так и для чтения.</target>
        </trans-unit>
        <trans-unit id="cd1b6853947249bceb85a960748d4561e30fc8ae" translate="yes" xml:space="preserve">
          <source>By default, GetOptions parses the options that are present in the global array &lt;code&gt;@ARGV&lt;/code&gt; . A special entry &lt;code&gt;GetOptionsFromArray&lt;/code&gt; can be used to parse options from an arbitrary array.</source>
          <target state="translated">По умолчанию GetOptions анализирует параметры, присутствующие в глобальном массиве &lt;code&gt;@ARGV&lt;/code&gt; . Специальная запись &lt;code&gt;GetOptionsFromArray&lt;/code&gt; может использоваться для анализа параметров из произвольного массива.</target>
        </trans-unit>
        <trans-unit id="96d8266281e8d2795ccf65d39f9f3a28ecacdd25" translate="yes" xml:space="preserve">
          <source>By default, HP-UX comes configured with a maximum data segment size of 64MB. This is too small to correctly compile Perl with the maximum optimization levels. You can increase the size of the maxdsiz kernel parameter through the use of SAM.</source>
          <target state="translated">По умолчанию HP-UX поставляется с максимальным размером сегмента данных 64 Мб.Это слишком мало для корректной компиляции Perl с максимальными уровнями оптимизации.Размер параметра ядра maxdsiz можно увеличить с помощью SAM.</target>
        </trans-unit>
        <trans-unit id="137732db42e50a8e0a9c182ecd242a32825b115f" translate="yes" xml:space="preserve">
          <source>By default, Hangul syllables are decomposed into Hangul Jamo, even if &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; . But the mapping of Hangul syllables may be overridden.</source>
          <target state="translated">По умолчанию слоги хангыль раскладываются на хангыль джамо, даже если &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; . Но отображение слогов хангыля может быть отменено.</target>
        </trans-unit>
        <trans-unit id="41b45806d57c8440d5ef81fe98a720868522060d" translate="yes" xml:space="preserve">
          <source>By default, Perl assumes that it must do most of its arithmetic in floating point. But by saying</source>
          <target state="translated">По умолчанию Perl предполагает,что он должен делать большую часть своей арифметики с плавающей точкой.Но,говоря</target>
        </trans-unit>
        <trans-unit id="4de9fffb0ae0d357c4fcb6328d235687ad4441ca" translate="yes" xml:space="preserve">
          <source>By default, Perl does a depth-first left-to-right search for a method. That means it starts with the first parent in the &lt;code&gt;@ISA&lt;/code&gt; array, and then searches all of its parents, grandparents, etc. If it fails to find the method, it then goes to the next parent in the original class's &lt;code&gt;@ISA&lt;/code&gt; array and searches from there.</source>
          <target state="translated">По умолчанию Perl выполняет поиск метода слева направо в глубину. Это означает, что он начинается с первого родителя в массиве &lt;code&gt;@ISA&lt;/code&gt; , а затем ищет всех своих родителей, бабушек и дедушек и т. Д. Если ему не удается найти метод, он переходит к следующему родителю в массиве &lt;code&gt;@ISA&lt;/code&gt; исходного класса и выполняет поиск оттуда.</target>
        </trans-unit>
        <trans-unit id="b268ca20b85e7cb3d549ac0ab2d0251384881b6c" translate="yes" xml:space="preserve">
          <source>By default, Perl itself (outside the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module) ignores the current locale. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma tells Perl to use the current locale for some operations. Starting in v5.16, there are optional parameters to this pragma, described below, which restrict which operations are affected by it.</source>
          <target state="translated">По умолчанию сам Perl (вне модуля &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; ) игнорирует текущую локаль. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; Прагма говорит Perl использовать текущую локаль для некоторых операций. Начиная с v5.16, в этой прагме есть необязательные параметры, описанные ниже, которые ограничивают операции, на которые она влияет.</target>
        </trans-unit>
        <trans-unit id="d3796ef67591d4f35614b1eaeb5b1f668ac93c4c" translate="yes" xml:space="preserve">
          <source>By default, Perl's built-in OO system is very minimal, leaving you to do most of the work. This minimalism made a lot of sense in 1994, but in the years since Perl 5.0 we've seen a number of common patterns emerge in Perl OO. Fortunately, Perl's flexibility has allowed a rich ecosystem of Perl OO systems to flourish.</source>
          <target state="translated">По умолчанию,встроенная в Perl система OO очень минимальна,оставляя вам большую часть работы.Этот минимализм имел большой смысл в 1994 году,но за годы,прошедшие после Perl 5.0,в Perl OO появилось несколько общих паттернов.К счастью,гибкость Perl позволила процветать богатой экосистеме систем Perl OO.</target>
        </trans-unit>
        <trans-unit id="fcb268259208b983d01ebd2fb8ea62f828af5570" translate="yes" xml:space="preserve">
          <source>By default, Pod::Escapes exports none of its symbols. But you can request any of them to be exported. Either request them individually, as with &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(symbolname symbolname2...);&lt;/code&gt; , or you can do &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(:ALL);&lt;/code&gt; to get all exportable symbols.</source>
          <target state="translated">По умолчанию Pod :: Escapes не экспортирует ни один из своих символов. Но вы можете запросить экспорт любого из них. Либо запрашивайте их индивидуально, как в случае &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(symbolname symbolname2...);&lt;/code&gt; , или вы можете &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(:ALL);&lt;/code&gt; чтобы получить все экспортируемые символы.</target>
        </trans-unit>
        <trans-unit id="a42f3e93e67354db749eedfb3803802a7a1b163f" translate="yes" xml:space="preserve">
          <source>By default, Pod::Man produces the most conservative possible *roff output to try to ensure that it will work with as many different *roff implementations as possible. Many *roff implementations cannot handle non-ASCII characters, so this means all non-ASCII characters are converted either to a *roff escape sequence that tries to create a properly accented character (at least for troff output) or to &lt;code&gt;X&lt;/code&gt; .</source>
          <target state="translated">По умолчанию Pod :: Man производит максимально консервативный вывод * roff, чтобы убедиться, что он будет работать с как можно большим количеством различных реализаций * roff. Многие реализации * РОФФ не может обрабатывать не-ASCII символов, так что это означает , что все символы не-ASCII которые преобразуются либо в * ROFF последовательности побега , который пытается создать правильно акцентировано характер (по крайней мере , для вывода TROFF) или &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98107783dba2f8c87d2092a6ced42a0827ce5268" translate="yes" xml:space="preserve">
          <source>By default, Pod::Text uses the same output encoding as the input encoding of the POD source (provided that Perl was built with PerlIO; otherwise, it doesn't encode its output). If this option is given, the output encoding is forced to UTF-8.</source>
          <target state="translated">По умолчанию Pod::Text использует ту же выходную кодировку,что и входная кодировка источника POD (при условии,что Perl был собран с PerlIO;в противном случае,он не кодирует свой вывод).Если эта опция включена,то выходная кодировка принудительно будет в UTF-8.</target>
        </trans-unit>
        <trans-unit id="607468b061542c5fb308ea35e966138c590f5abc" translate="yes" xml:space="preserve">
          <source>By default, Pod::Usage will call &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; when -verbose &amp;gt;= 2 is specified. This does not work well e.g. if the script was packed with &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;. The -noperldoc option suppresses the external call to &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; and uses the simple text formatter (&lt;a href=&quot;text&quot;&gt;Pod::Text&lt;/a&gt;) to output the POD.</source>
          <target state="translated">По умолчанию Pod :: Usage будет вызывать &lt;a href=&quot;../perldoc&quot;&gt;perldoc,&lt;/a&gt; если указано -verbose &amp;gt; = 2. Это не работает, например, если сценарий был упакован с &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt; . Параметр -noperldoc подавляет внешний вызов &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; и использует простое средство форматирования текста ( &lt;a href=&quot;text&quot;&gt;Pod :: Text&lt;/a&gt; ) для вывода POD.</target>
        </trans-unit>
        <trans-unit id="7aaf9130ce3cc364b8ff0d6d870dfc5f5e3ff5d9" translate="yes" xml:space="preserve">
          <source>By default, a quantified subpattern is &quot;greedy&quot;, that is, it will match as many times as possible (given a particular starting location) while still allowing the rest of the pattern to match. If you want it to match the minimum number of times possible, follow the quantifier with a &quot;?&quot;. Note that the meanings don't change, just the &quot;greediness&quot;:</source>
          <target state="translated">По умолчанию квантифицированная подмаска-&quot;жадная&quot;,т.е.она будет совпадать как можно больше раз (при определенном начальном положении),позволяя при этом остальным подмаскам совпадать.Если вы хотите,чтобы она совпадала минимально возможное количество раз,следуйте за квантификатором со знаком &quot;?&quot;.Обратите внимание,что значения не меняются,а только &quot;жадность&quot;:</target>
        </trans-unit>
        <trans-unit id="b48a9b04f7e394f8ae5c84a6badf024eee518a01" translate="yes" xml:space="preserve">
          <source>By default, all ftp connections are done in passive mode. To change that, see the &lt;code&gt;$FTP_PASSIVE&lt;/code&gt; variable further down.</source>
          <target state="translated">По умолчанию все ftp-соединения выполняются в пассивном режиме. Чтобы изменить это, просмотрите переменную &lt;code&gt;$FTP_PASSIVE&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="7f80a56139fac5d67611619acae3e63a365a4381" translate="yes" xml:space="preserve">
          <source>By default, attribute handlers are called at the end of the compilation phase (in a &lt;code&gt;CHECK&lt;/code&gt; block). This seems to be optimal in most cases because most things that can be defined are defined by that point but nothing has been executed.</source>
          <target state="translated">По умолчанию обработчики атрибутов вызываются в конце фазы компиляции (в блоке &lt;code&gt;CHECK&lt;/code&gt; ). Это кажется оптимальным в большинстве случаев, потому что большинство вещей, которые можно определить, определяются этой точкой, но ничего не было выполнено.</target>
        </trans-unit>
        <trans-unit id="d92e033ccee030ae17ccf241ebba25503e925cbf" translate="yes" xml:space="preserve">
          <source>By default, but can be redefined.</source>
          <target state="translated">По умолчанию,но может быть переопределена.</target>
        </trans-unit>
        <trans-unit id="9f90d660b6b88d20d5a032c88e00b0f974301c2b" translate="yes" xml:space="preserve">
          <source>By default, case-sensitive comparison (that is level 3 difference) won't ignore accents (that is level 2 difference).</source>
          <target state="translated">По умолчанию регистрозависимое сравнение (т.е.разница 3 уровня)не игнорирует акценты (т.е.разница 2 уровня).</target>
        </trans-unit>
        <trans-unit id="b957d395a8a7eedebb03724489ebfa7e55174b9c" translate="yes" xml:space="preserve">
          <source>By default, classes in Perl only perform the &lt;code&gt;UNIVERSAL&lt;/code&gt; role, as well as the role of all classes in their inheritance. In other words, by default &lt;code&gt;DOES&lt;/code&gt; responds identically to &lt;code&gt;isa&lt;/code&gt; .</source>
          <target state="translated">По умолчанию классы в Perl выполняют только &lt;code&gt;UNIVERSAL&lt;/code&gt; роль, а также роль всех классов в их наследовании. Другими словами, по умолчанию &lt;code&gt;DOES&lt;/code&gt; идентично реагирует на &lt;code&gt;isa&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a09751b6a3dd219cd03f615c311b1588c0433a01" translate="yes" xml:space="preserve">
          <source>By default, each time the CPAN module is started, cache scanning is performed to keep the cache size in sync ('atstart'). Alternatively, scanning and cleanup can happen when CPAN exits ('atexit'). To prevent any cache cleanup, answer 'never'.</source>
          <target state="translated">По умолчанию,каждый раз при запуске CPAN модуля,сканирование кэша выполняется для синхронизации размера кэша ('atstart').В качестве альтернативы,сканирование и очистка могут происходить при выходе CPAN ('atexit').Чтобы предотвратить любую очистку кэша,ответьте 'никогда'.</target>
        </trans-unit>
        <trans-unit id="a04a99ac495330cd07b871fc7a9618f7082ee169" translate="yes" xml:space="preserve">
          <source>By default, every base class needs to live in a file of its own. If you want to have a subclass and its parent class in the same file, you can tell &lt;code&gt;parent&lt;/code&gt; not to load any modules by using the &lt;code&gt;-norequire&lt;/code&gt; switch:</source>
          <target state="translated">По умолчанию каждый базовый класс должен находиться в собственном файле. Если вы хотите иметь подкласс и его родительский класс в одном файле, вы можете указать &lt;code&gt;parent&lt;/code&gt; не загружать какие-либо модули с помощью переключателя &lt;code&gt;-norequire&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="009314417d0e225d96e9c70c4f8a61f37cbd61fb" translate="yes" xml:space="preserve">
          <source>By default, file names are assumed to be case sensitive; this flag makes bsd_glob() treat case differences as not significant.</source>
          <target state="translated">По умолчанию имена файлов считаются чувствительными к регистру;этот флаг заставляет bsd_glob()считать разницу в регистре несущественной.</target>
        </trans-unit>
        <trans-unit id="6e050dc7d694db5e9597e9b5666a97cb998c6670" translate="yes" xml:space="preserve">
          <source>By default, hiragana is before katakana. If the parameter is made true, this is reversed.</source>
          <target state="translated">По умолчанию хирагана до катаканы.Если параметр становится истинным,то он меняется на обратный.</target>
        </trans-unit>
        <trans-unit id="a68b6a00ff07db87e5b4fca637ec784a918f2f88" translate="yes" xml:space="preserve">
          <source>By default, if a redispatch attempt fails to find another method elsewhere in the objects class hierarchy, it quietly gives up and does nothing (but see &lt;a href=&quot;#Enforcing-redispatch&quot;&gt;Enforcing redispatch&lt;/a&gt;). This gracious acquiescence is also unlike the (generally annoying) behaviour of &lt;code&gt;SUPER&lt;/code&gt; , which throws an exception if it cannot redispatch.</source>
          <target state="translated">По умолчанию, если попытка повторной отправки не может найти другой метод в другом месте в иерархии классов объектов, она незаметно сдается и ничего не делает (но см. &amp;laquo; &lt;a href=&quot;#Enforcing-redispatch&quot;&gt;Принудительное повторное обновление&amp;raquo;&lt;/a&gt; ). Это милостивое согласие также отличается от (обычно раздражающего) поведения &lt;code&gt;SUPER&lt;/code&gt; , который выдает исключение, если не может повторно отправить.</target>
        </trans-unit>
        <trans-unit id="622748004543277cac1eed24641a5d626b92e074" translate="yes" xml:space="preserve">
          <source>By default, it checks only ascii, utf8 and UTF-16/32 with BOM.</source>
          <target state="translated">По умолчанию проверяется только ascii,utf8 и UTF-16/32 с BOM.</target>
        </trans-unit>
        <trans-unit id="7d795357eb0370d795216bc893725d71f457449f" translate="yes" xml:space="preserve">
          <source>By default, it exports the functions cwd(), getcwd(), fastcwd(), and fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.</source>
          <target state="translated">По умолчанию он экспортирует функции cwd(),getcwd(),fastcwd()и fastgetcwd()(а в Win32-getdcwd())в пространство имён вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="bd57ef383f01461a26729aaf5bda1caeec29a44b" translate="yes" xml:space="preserve">
          <source>By default, lowercase is before uppercase. If the parameter is made true, this is reversed.</source>
          <target state="translated">По умолчанию нижний регистр перед верхним.Если параметр становится значением true,то это значение меняется на обратное.</target>
        </trans-unit>
        <trans-unit id="bd52b1e53c314fe3c4b656aedbdea4b06daed47d" translate="yes" xml:space="preserve">
          <source>By default, no comment field is written to the zip file.</source>
          <target state="translated">По умолчанию в zip-файл не записывается поле для комментариев.</target>
        </trans-unit>
        <trans-unit id="5d5b6fb015586b3864b9f25cf4e1c4322f8f41ee" translate="yes" xml:space="preserve">
          <source>By default, optional warnings are disabled, so any legacy code that doesn't attempt to control the warnings will work unchanged.</source>
          <target state="translated">По умолчанию опциональные предупреждения отключены,поэтому любой унаследованный код,который не пытается контролировать предупреждения,будет работать без изменений.</target>
        </trans-unit>
        <trans-unit id="56744be38bf9987fcb8b98dab67cef731ba84ab1" translate="yes" xml:space="preserve">
          <source>By default, perl handles file globbing using the File::Glob extension, which provides portable globbing.</source>
          <target state="translated">По умолчанию,perl обрабатывает глобус файлов с помощью расширения File::Glob,которое обеспечивает глобус для портативных устройств.</target>
        </trans-unit>
        <trans-unit id="b252359c438a3c8369c5cbca58632d9664dd0131" translate="yes" xml:space="preserve">
          <source>By default, perl uses the large file compilation environment and relies on Solaris to do the underlying mapping of interfaces.</source>
          <target state="translated">По умолчанию perl использует среду компиляции больших файлов и полагается на Solaris для выполнения основного отображения интерфейсов.</target>
        </trans-unit>
        <trans-unit id="95ea6d685281e6fc9b1246edd3de6ccbfbf85ecd" translate="yes" xml:space="preserve">
          <source>By default, perl will be compiled as a 32-bit application. Unless you want to allocate more than ~ 4GB of memory inside perl, or unless you need more than 255 open file descriptors, you probably don't need perl to be a 64-bit app.</source>
          <target state="translated">По умолчанию perl будет скомпилирован как 32-битное приложение.Если только вы не хотите выделить более ~ 4 ГБ памяти внутри perl,или если вам не нужно более 255 открытых файловых дескрипторов,то вам,скорее всего,не нужно,чтобы perl был 64-битным приложением.</target>
        </trans-unit>
        <trans-unit id="8beb3118174cbb4befcc9218c3e11ee8559a67ed" translate="yes" xml:space="preserve">
          <source>By default, perl-5.6.0 (or later) is compiled as a 32-bit application with largefile and long-long support.</source>
          <target state="translated">По умолчанию perl-5.6.0 (или более поздняя версия)скомпилирована как 32-битное приложение с поддержкой больших файлов и длинных версий.</target>
        </trans-unit>
        <trans-unit id="c1d7d31b73907dcda6cd3ad0857aee8de05a33a3" translate="yes" xml:space="preserve">
          <source>By default, running out of memory is an untrappable, fatal error. However, if suitably built, Perl can use the contents of &lt;code&gt;$^M&lt;/code&gt; as an emergency memory pool after &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;ing. Suppose that your Perl were compiled with &lt;code&gt;-DPERL_EMERGENCY_SBRK&lt;/code&gt; and used Perl's malloc. Then</source>
          <target state="translated">По умолчанию нехватка памяти является неустранимой фатальной ошибкой. Однако при надлежащей сборке Perl может использовать содержимое &lt;code&gt;$^M&lt;/code&gt; как пул аварийной памяти после &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; ing. Предположим, что ваш Perl был скомпилирован с помощью &lt;code&gt;-DPERL_EMERGENCY_SBRK&lt;/code&gt; и использовал Perl malloc. затем</target>
        </trans-unit>
        <trans-unit id="4190ef76a4299cfe3e352f5cfeb999b38851b5f5" translate="yes" xml:space="preserve">
          <source>By default, section 1 will be used unless the file ends in &lt;code&gt;.pm&lt;/code&gt; in which case section 3 will be selected.</source>
          <target state="translated">По умолчанию будет использоваться раздел 1, если только файл не заканчивается на &lt;code&gt;.pm&lt;/code&gt; , в этом случае будет выбран раздел 3.</target>
        </trans-unit>
        <trans-unit id="8d9133733d7f7dcd376ecd3cd224e4dddd523774" translate="yes" xml:space="preserve">
          <source>By default, section 1 will be used unless the file ends in &lt;code&gt;.pm&lt;/code&gt;, in which case section 3 will be selected.</source>
          <target state="translated">По умолчанию будет использоваться раздел 1, если файл не заканчивается на &lt;code&gt;.pm&lt;/code&gt; , и в этом случае будет выбран раздел 3.</target>
        </trans-unit>
        <trans-unit id="961a8c7a3d78a4ba111b92d292c8ae5c80f7c1a1" translate="yes" xml:space="preserve">
          <source>By default, semaphores behave like locks, letting only one thread &lt;code&gt;down()&lt;/code&gt; them at a time. However, there are other uses for semaphores.</source>
          <target state="translated">По умолчанию семафоры ведут себя как блокировки, позволяя выполнять их только одному потоку &lt;code&gt;down()&lt;/code&gt; за раз. Однако есть и другие варианты использования семафоров.</target>
        </trans-unit>
        <trans-unit id="fed769cd67eb1346af1f13055d0984c3c18e8ed3" translate="yes" xml:space="preserve">
          <source>By default, strings whose weights are equal should be equal, even though their code points are not equal. Completely ignorable characters are ignored.</source>
          <target state="translated">По умолчанию строки,веса которых равны,должны быть равны,даже если их точки кода не равны.Совершенно незнакомые символы игнорируются.</target>
        </trans-unit>
        <trans-unit id="4a36fa72282c7563bf7e21fc24cf3c3c9ea04d1b" translate="yes" xml:space="preserve">
          <source>By default, the</source>
          <target state="translated">По умолчанию</target>
        </trans-unit>
        <trans-unit id="56921ea3749d0afb26fde19f34e5cd700c2dac28" translate="yes" xml:space="preserve">
          <source>By default, the &quot;^&quot; character is guaranteed to match only the beginning of the string, the &quot;$&quot; character only the end (or before the newline at the end), and Perl does certain optimizations with the assumption that the string contains only one line. Embedded newlines will not be matched by &quot;^&quot; or &quot;$&quot;. You may, however, wish to treat a string as a multi-line buffer, such that the &quot;^&quot; will match after any newline within the string (except if the newline is the last character in the string), and &quot;$&quot; will match before any newline. At the cost of a little more overhead, you can do this by using the /m modifier on the pattern match operator. (Older programs did this by setting &lt;code&gt;$*&lt;/code&gt; , but this option was removed in perl 5.10.)</source>
          <target state="translated">По умолчанию, символ &amp;laquo;^&amp;raquo; гарантированно соответствует только началу строки, символ &amp;laquo;$&amp;raquo; - только концу (или перед новой строкой в ​​конце), и Perl выполняет определенные оптимизации с предположением, что строка содержит только одна линия. Встроенные символы новой строки не будут отмечены знаком &amp;laquo;^&amp;raquo; или &amp;laquo;$&amp;raquo;. Однако вы можете рассматривать строку как многострочный буфер, так что &quot;^&quot; будет соответствовать после любого символа новой строки в строке (кроме случаев, когда новая строка является последним символом в строке), а &quot;$&quot; будет соответствует перед любой новой строкой. За счет дополнительных накладных расходов вы можете сделать это, используя модификатор / m в операторе сопоставления с образцом. (Старые программы делали это, устанавливая &lt;code&gt;$*&lt;/code&gt; , но эта опция была удалена в Perl 5.10.)</target>
        </trans-unit>
        <trans-unit id="a1a870bf9d52ad0a2c1a90186336492c4ae0aed3" translate="yes" xml:space="preserve">
          <source>By default, the function is &lt;a href=&quot;#ck_entersub_args_proto_or_list&quot;&gt;Perl_ck_entersub_args_proto_or_list&lt;/a&gt;, and the SV parameter is</source>
          <target state="translated">По умолчанию это функция &lt;a href=&quot;#ck_entersub_args_proto_or_list&quot;&gt;Perl_ck_entersub_args_proto_or_list&lt;/a&gt; , а параметр SV -</target>
        </trans-unit>
        <trans-unit id="beeed48a59ea18c1b18a6cfda68d25973cd743b6" translate="yes" xml:space="preserve">
          <source>By default, the installed filter only filters up to a line consisting of one of the three standard source &quot;terminators&quot;:</source>
          <target state="translated">По умолчанию установленный фильтр фильтрует только до строки,состоящей из одного из трех стандартных &quot;терминаторов&quot; источника:</target>
        </trans-unit>
        <trans-unit id="e79e890007f8b504a54617ddbf05ff93a90734ba" translate="yes" xml:space="preserve">
          <source>By default, the only variables shared with compartments are the &quot;underscore&quot; variables $_ and @_ (and, technically, the less frequently used %_, the _ filehandle and so on). This is because otherwise perl operators which default to $_ will not work and neither will the assignment of arguments to @_ on subroutine entry.</source>
          <target state="translated">По умолчанию единственными переменными,разделяемыми с отсеками,являются переменные &quot;подчеркивания&quot; $_и @_(и,технически,менее часто используемые %_,_файл-хэндл и т.д.).Это связано с тем,что в противном случае операторы perl,которые по умолчанию равны $_,не будут работать и не будут присваивать аргументы @_в подпрограммной записи.</target>
        </trans-unit>
        <trans-unit id="4eebbb2dfa043331a8ced51ef018a956d406180e" translate="yes" xml:space="preserve">
          <source>By default, the pathnames are sorted in ascending ASCII order; this flag prevents that sorting (speeding up bsd_glob()).</source>
          <target state="translated">По умолчанию пути сортируются в возрастающем ASCII порядке;этот флаг предотвращает такую сортировку (ускорение bsd_glob()).</target>
        </trans-unit>
        <trans-unit id="cd52d7b7234ea4b8c1ee0272333575fae9c9ac61" translate="yes" xml:space="preserve">
          <source>By default, the string appended is assumed to be valid UTF-8 if the SV has the UTF-8 status set, and a string of bytes otherwise. One can force the appended string to be interpreted as UTF-8 by supplying the &lt;code&gt;SV_CATUTF8&lt;/code&gt; flag, and as bytes by supplying the &lt;code&gt;SV_CATBYTES&lt;/code&gt; flag; the SV or the string appended will be upgraded to UTF-8 if necessary.</source>
          <target state="translated">По умолчанию предполагается, что добавленная строка является допустимой UTF-8, если для SV установлен статус UTF-8, и строкой байтов в противном случае. Можно принудительно интерпретировать добавленную строку как UTF-8, &lt;code&gt;SV_CATUTF8&lt;/code&gt; флаг SV_CATUTF8 , и как байты, &lt;code&gt;SV_CATBYTES&lt;/code&gt; флаг SV_CATBYTES ; SV или добавленная строка будут обновлены до UTF-8 при необходимости.</target>
        </trans-unit>
        <trans-unit id="8d41f8d85e7a977c1704e0b6aa0d1e3446f200e7" translate="yes" xml:space="preserve">
          <source>By default, this module creates an &lt;code&gt;::I18N&lt;/code&gt; subclass under the caller's package (or the package specified by &lt;code&gt;Class&lt;/code&gt; ), and stores lexicon data in its subclasses. You can assign a name other than &lt;code&gt;I18N&lt;/code&gt; via this option.</source>
          <target state="translated">По умолчанию этот модуль создает подкласс &lt;code&gt;::I18N&lt;/code&gt; в пакете вызывающей стороны (или пакете, заданном &lt;code&gt;Class&lt;/code&gt; ), и сохраняет данные лексики в своих подклассах. &lt;code&gt;I18N&lt;/code&gt; помощью этой опции вы можете присвоить имя, отличное от I18N .</target>
        </trans-unit>
        <trans-unit id="5949c007c079cc7a10f34781de30c09a225b6eca" translate="yes" xml:space="preserve">
          <source>By default, this module exports a single function, &lt;code&gt;loc&lt;/code&gt; , into its caller's namespace. You can set it to another name, or set it to an empty string to disable exporting.</source>
          <target state="translated">По умолчанию этот модуль экспортирует одну функцию &lt;code&gt;loc&lt;/code&gt; в пространство имен вызывающей стороны. Вы можете установить для него другое имя или установить пустую строку, чтобы отключить экспорт.</target>
        </trans-unit>
        <trans-unit id="8ad4115958f94effa9746305a9b0cb4cffc6bd7c" translate="yes" xml:space="preserve">
          <source>By default, this module uses the &lt;code&gt;maketext&lt;/code&gt; style of &lt;code&gt;[_1]&lt;/code&gt; and &lt;code&gt;[quant,_1]&lt;/code&gt; for interpolation. Alternatively, you can specify the &lt;code&gt;gettext&lt;/code&gt; style, which uses &lt;code&gt;%1&lt;/code&gt; and &lt;code&gt;%quant(%1)&lt;/code&gt; for interpolation.</source>
          <target state="translated">По умолчанию этот модуль использует стиль &lt;code&gt;maketext&lt;/code&gt; &lt;code&gt;[_1]&lt;/code&gt; и &lt;code&gt;[quant,_1]&lt;/code&gt; для интерполяции. Как вариант, вы можете указать стиль &lt;code&gt;gettext&lt;/code&gt; , который использует для интерполяции &lt;code&gt;%1&lt;/code&gt; и &lt;code&gt;%quant(%1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="252a3c80bb1e3517a1330d8a71715773619ce9ac" translate="yes" xml:space="preserve">
          <source>By default, variables are private to each thread, and each newly created thread gets a private copy of each existing variable. This module allows you to share variables across different threads (and pseudo-forks on Win32). It is used together with the &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; module.</source>
          <target state="translated">По умолчанию переменные являются частными для каждого потока, и каждый вновь созданный поток получает частную копию каждой существующей переменной. Этот модуль позволяет вам совместно использовать переменные в разных потоках (и псевдоразветвлениях в Win32). Он используется вместе с модулем &lt;a href=&quot;../threads&quot;&gt;потоков&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08d154b38941f09ce6557f839a81a8eafedac239" translate="yes" xml:space="preserve">
          <source>By default, when a new interpreter is created as a copy of an existing one (eg via &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; ), both interpreters share the same physical my_cxt_t structure. Calling &lt;code&gt;MY_CXT_CLONE&lt;/code&gt; (typically via the package's &lt;code&gt;CLONE()&lt;/code&gt; function), causes a byte-for-byte copy of the structure to be taken, and any future dMY_CXT will cause the copy to be accessed instead.</source>
          <target state="translated">По умолчанию, когда новый интерпретатор создается как копия существующего (например, через &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; ), оба интерпретатора используют одну и ту же физическую структуру my_cxt_t. Вызов &lt;code&gt;MY_CXT_CLONE&lt;/code&gt; (обычно через функцию пакета &lt;code&gt;CLONE()&lt;/code&gt; ) вызывает побайтовую копию структуры, а любой будущий dMY_CXT вызовет доступ к этой копии.</target>
        </trans-unit>
        <trans-unit id="1f023b47e4b490e5f3861a02400fb5ce0693a9fc" translate="yes" xml:space="preserve">
          <source>By default, your program starts in package &lt;code&gt;main&lt;/code&gt; , so you will always be in some package.</source>
          <target state="translated">По умолчанию ваша программа запускается в &lt;code&gt;main&lt;/code&gt; пакете , поэтому вы всегда будете в каком-то пакете.</target>
        </trans-unit>
        <trans-unit id="cc16f7e5e668d806fbde2fd531d2629a195bfd9c" translate="yes" xml:space="preserve">
          <source>By explicitly requiring a minimum Perl version number for your program, with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; construct. That is,</source>
          <target state="translated">Явно требуя минимальный номер версии Perl для вашей программы, с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; конструкции VERSION . То есть,</target>
        </trans-unit>
        <trans-unit id="b496b26c66a41bb8b28e0a2591cb8dda23a4871c" translate="yes" xml:space="preserve">
          <source>By far the easiest way to build Perl for OS/400 is to use the PASE (Portable Application Solutions Environment), for more information see &lt;a href=&quot;http://www.iseries.ibm.com/developer/factory/pase/index.html&quot;&gt;http://www.iseries.ibm.com/developer/factory/pase/index.html&lt;/a&gt; This environment allows one to use AIX APIs while programming, and it provides a runtime that allows AIX binaries to execute directly on the PowerPC iSeries.</source>
          <target state="translated">Самым простым способом создания Perl для OS / 400 является использование PASE (Portable Application Solutions Environment), для получения дополнительной информации см. &lt;a href=&quot;http://www.iseries.ibm.com/developer/factory/pase/index.html&quot;&gt;Http://www.iseries.ibm.com/developer/factory/pase/index.html&lt;/a&gt; Это Среда позволяет использовать API-интерфейсы AIX при программировании, а также предоставляет среду выполнения, которая позволяет исполнять двоичные файлы AIX непосредственно на PowerPC iSeries.</target>
        </trans-unit>
        <trans-unit id="90b268ad6928ce9b139ce0bfe20e0ab522c5a230" translate="yes" xml:space="preserve">
          <source>By far the most common reason is that the locale has characters in it that are represented by more than one byte. The only such locales that Perl can handle are the UTF-8 locales. Most likely the specified locale is a non-UTF-8 one for an East Asian language such as Chinese or Japanese. If the locale is a superset of ASCII, the ASCII portion of it may work in Perl.</source>
          <target state="translated">Самая распространенная причина заключается в том,что в локали есть символы,которые представлены более чем одним байтом.Единственные такие локали,с которыми Perl может справиться-это локали UTF-8.Скорее всего,указанная локаль не является UTF-8 для восточноазиатского языка,такого как китайский или японский.Если локаль является суперсетью ASCII,то часть ASCII может работать на Perl.</target>
        </trans-unit>
        <trans-unit id="5be86ce403211ab50be3b7ce1f4f87ec5b6bd179" translate="yes" xml:space="preserve">
          <source>By first converting the FOO-encoded byte string to a text string, and then the text string to a BAR-encoded byte string:</source>
          <target state="translated">Сначала преобразовывая FOO-кодированную байтовую строку в текстовую,а затем текстовую строку в BAR-кодированную байтовую строку:</target>
        </trans-unit>
        <trans-unit id="3456e5ab0f472be26a41623d10e3cc8ff953c769" translate="yes" xml:space="preserve">
          <source>By including Exporter in your &lt;code&gt;@ISA&lt;/code&gt; you inherit an Exporter's import() method but you also inherit several other helper methods which you probably don't want. To avoid this you can do:</source>
          <target state="translated">Включая Exporter в ваш &lt;code&gt;@ISA&lt;/code&gt; , вы наследуете метод Exporter import (), но вы также наследуете несколько других вспомогательных методов, которые вам, вероятно, не нужны. Чтобы этого избежать, вы можете:</target>
        </trans-unit>
        <trans-unit id="583ac2704011a6bdba33e0ae7763c40858b78828" translate="yes" xml:space="preserve">
          <source>By passing a reference to a hash you may set the configuration values. This works only for values that a marked with a &lt;code&gt;RW&lt;/code&gt; above, anything else is read-only.</source>
          <target state="translated">Передавая ссылку на хэш, вы можете установить значения конфигурации. Это работает только для значений, отмеченных &lt;code&gt;RW&lt;/code&gt; выше, все остальное доступно только для чтения.</target>
        </trans-unit>
        <trans-unit id="e30293ddc7efc1598420ad5a32ac1415cea4ba8a" translate="yes" xml:space="preserve">
          <source>By running &quot;&lt;code&gt;make test&lt;/code&gt; &quot;, you ensure that your Mytest.t script runs and uses the correct version of your extension. If you have many test cases, save your test files in the &quot;t&quot; directory and use the suffix &quot;.t&quot;. When you run &quot;&lt;code&gt;make test&lt;/code&gt; &quot;, all of these test files will be executed.</source>
          <target state="translated">Управляя &amp;laquo; &lt;code&gt;make test&lt;/code&gt; &amp;raquo;, вы убедитесь , что ваши прогонов сценария Mytest.t и использует правильную версию вашего расширения. Если у вас много тестовых примеров, сохраните тестовые файлы в каталоге &amp;laquo;t&amp;raquo; и используйте суффикс &amp;laquo;.t&amp;raquo;. Когда вы запустите &amp;laquo; &lt;code&gt;make test&lt;/code&gt; &amp;raquo;, все эти тестовые файлы будут выполнены.</target>
        </trans-unit>
        <trans-unit id="49d2ff2073c166abecd08a90ef566dc2e86a7f38" translate="yes" xml:space="preserve">
          <source>By setting and then using &lt;code&gt;$var&lt;/code&gt; in this way relieves you from having to worry about exactly which numbered set of parentheses they are.</source>
          <target state="translated">Установка и последующее использование &lt;code&gt;$var&lt;/code&gt; таким образом избавляет вас от необходимости беспокоиться о том, какой именно нумерованный набор скобок они представляют.</target>
        </trans-unit>
        <trans-unit id="265fb107c25a0f703500d08dbe4e8f2787903896" translate="yes" xml:space="preserve">
          <source>By setting it to an empty string you can generate a Makefile that prints all commands. Mainly used in debugging MakeMaker itself.</source>
          <target state="translated">Установив его в пустую строку,вы можете сгенерировать Makefile,который будет печатать все команды.В основном используется при отладке самого MakeMaker.</target>
        </trans-unit>
        <trans-unit id="619bd2bab7e99a9933fcadbbac647cbc3917a48b" translate="yes" xml:space="preserve">
          <source>By specifying &lt;code&gt;:loose&lt;/code&gt; , Unicode's &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44%23Matching_Rules&quot;&gt;loose character name matching&lt;/a&gt; rules are selected instead of the strict exact match used otherwise. That means that</source>
          <target state="translated">При указании &lt;code&gt;:loose&lt;/code&gt; выбираются правила &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44%23Matching_Rules&quot;&gt;сопоставления имен&lt;/a&gt; символов в Юникоде вместо строгого точного совпадения, используемого в противном случае. Что означает, что</target>
        </trans-unit>
        <trans-unit id="4173811273acdfc3b518c06a8c9add11d80be073" translate="yes" xml:space="preserve">
          <source>By subclassing, you may end up overriding undocumented methods. That's not a bad thing per se, but be forewarned that undocumented methods may change without warning from one release to the next - we cannot guarantee backwards compatibility. If any</source>
          <target state="translated">Подклассификация может привести к тому,что вы перейдете к недокументированным методам.Само по себе это неплохо,но учтите,что недокументированные методы могут изменяться без предупреждения из одного релиза в другой-мы не можем гарантировать обратную совместимость.Если таковые имеются</target>
        </trans-unit>
        <trans-unit id="7963af28b4afe4fecf3771e6be636d3a37450528" translate="yes" xml:space="preserve">
          <source>By the time Perl 5 rolled around, we were already stuck with this design: Hash values must be scalars. The solution to this is references.</source>
          <target state="translated">К тому времени,как Perl 5 прокатился,мы уже застряли с этим дизайном:Хэш-значения должны быть скалярами.Решением является ссылка.</target>
        </trans-unit>
        <trans-unit id="92f8d8ab799211d118cdd3b80bc6282c36c18e07" translate="yes" xml:space="preserve">
          <source>By the time each of the &lt;code&gt;SaveSub1&lt;/code&gt; statements above has been executed, the SV*s which corresponded to the parameters will no longer exist. Expect an error message from Perl of the form</source>
          <target state="translated">К моменту выполнения каждого из &lt;code&gt;SaveSub1&lt;/code&gt; выше операторов SaveSub1 SV *, соответствующие параметрам, больше не будут существовать. Ожидайте сообщения об ошибке от Perl формы</target>
        </trans-unit>
        <trans-unit id="334c1508a5d779cb0c1040092154fbe0583ab19f" translate="yes" xml:space="preserve">
          <source>By the time the comp callback is called, some of these flags have already had effect (noted below where applicable). However most of their effect occurs after the comp callback has run, in routines that read the &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; field which it populates.</source>
          <target state="translated">К тому времени, когда вызывается обратный вызов comp, некоторые из этих флагов уже действуют (указано ниже, где это применимо). Однако большая часть их эффекта происходит после запуска обратного вызова comp в подпрограммах, которые читают поле &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; , которое он заполняет.</target>
        </trans-unit>
        <trans-unit id="72795a79e31e2518cbd921d2bc0697a1bdbd6144" translate="yes" xml:space="preserve">
          <source>By tuning the stack size to more accurately reflect your application's needs, you may significantly reduce your application's memory usage, and increase the number of simultaneously running threads.</source>
          <target state="translated">Настраивая размер стека для более точного отражения потребностей приложения,Вы можете значительно сократить использование памяти приложения и увеличить количество одновременно выполняющихся потоков.</target>
        </trans-unit>
        <trans-unit id="bd379fb72b0b513ca230e24dca7f155e46117288" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;NEXT::ACTUAL&lt;/code&gt; , if there is no other &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the method call, an exception will be thrown (as usually happens in the absence of a suitable &lt;code&gt;AUTOLOAD&lt;/code&gt; ).</source>
          <target state="translated">При использовании &lt;code&gt;NEXT::ACTUAL&lt;/code&gt; , если нет другого &lt;code&gt;AUTOLOAD&lt;/code&gt; для обработки вызова метода, будет выдано исключение (как обычно происходит при отсутствии подходящего &lt;code&gt;AUTOLOAD&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f260eb29b6f0673bfdb6b907d310d5d3920f6717" translate="yes" xml:space="preserve">
          <source>By using the &lt;code&gt;-E&lt;/code&gt; switch on the Perl command-line instead of &lt;code&gt;-e&lt;/code&gt; . That will enable the feature bundle for that version of Perl in the main compilation unit (that is, the one-liner that follows &lt;code&gt;-E&lt;/code&gt; ).</source>
          <target state="translated">Используя переключатель &lt;code&gt;-E&lt;/code&gt; в командной строке Perl вместо &lt;code&gt;-e&lt;/code&gt; . Это включит набор функций для этой версии Perl в основном модуле компиляции (то есть однострочном, который следует за &lt;code&gt;-E&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9dfef463e4e713cbb716245b6be6a4856999a34d" translate="yes" xml:space="preserve">
          <source>By using the WWW interface you can ask the Upload Server to mirror your modules from your ftp or WWW site into your own directory on CPAN!</source>
          <target state="translated">С помощью WWW-интерфейса вы можете попросить Upload Server зеркалировать ваши модули с вашего ftp или WWW-сайта в вашу собственную директорию на CPAN!</target>
        </trans-unit>
        <trans-unit id="4f37c6bc860992a71dc03ba0a6eb8583644d0eac" translate="yes" xml:space="preserve">
          <source>By using the backslash operator on a variable, subroutine, or value. (This works much like the &amp;amp; (address-of) operator in C.) This typically creates</source>
          <target state="translated">С помощью оператора обратной косой черты для переменной, подпрограммы или значения. (Это работает так же, как оператор &amp;amp; (адрес) в C.) Обычно это создает</target>
        </trans-unit>
        <trans-unit id="4fea865bf2bc7c769f8247d0ffedba42a3ee67f2" translate="yes" xml:space="preserve">
          <source>By way of demonstration, we present below a laborious listing resulting from setting your &lt;code&gt;PERLDB_OPTS&lt;/code&gt; environment variable to the value &lt;code&gt;f=n N&lt;/code&gt; , and running</source>
          <target state="translated">В качестве демонстрации ниже представлен трудоемкий листинг, полученный в результате установки &lt;code&gt;PERLDB_OPTS&lt;/code&gt; среды PERLDB_OPTS на значение &lt;code&gt;f=n N&lt;/code&gt; и выполнения</target>
        </trans-unit>
        <trans-unit id="05ff92e836fe1c104b327e3d41d6f42c1c2f68cf" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getgr*() functions</source>
          <target state="translated">По-имя интерфейса к встроенным функциям Perl getgr*()</target>
        </trans-unit>
        <trans-unit id="8701f0c6760ad255897a2adbc246d9e8608c8d7a" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in gethost*() functions</source>
          <target state="translated">Именной интерфейс к встроенным функциям gethost*()Perl.</target>
        </trans-unit>
        <trans-unit id="8edbac978dbd72904307e2cc9662b26a10b3bd66" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getnet*() functions</source>
          <target state="translated">Именной интерфейс к встроенным функциям Perl getnet*().</target>
        </trans-unit>
        <trans-unit id="905cb97e8ed297dc43dcd08d2a9db1d9958b4ddc" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getproto*() functions</source>
          <target state="translated">Именной интерфейс к встроенным функциям getproto*()Perl</target>
        </trans-unit>
        <trans-unit id="7980958e534d59fc2ef012727304a32f6778bc74" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getpw*() functions</source>
          <target state="translated">Именной интерфейс для встроенных функций getpw*()Perl.</target>
        </trans-unit>
        <trans-unit id="8c13e6c841eee178cc9c90b3ec31731fb7b6e9d6" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getserv*() functions</source>
          <target state="translated">Именной интерфейс к встроенным функциям Perl geterv*().</target>
        </trans-unit>
        <trans-unit id="10bacc859a37b5cb2457a9867f2de200be21a6bd" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in gmtime() function</source>
          <target state="translated">Интерфейс с именем для встроенной в Perl функции gmtime().</target>
        </trans-unit>
        <trans-unit id="827cbeee072a43490f322081b175fcaabf1286c6" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in localtime() function</source>
          <target state="translated">Интерфейс с именем для встроенной функции Perl localtime()</target>
        </trans-unit>
        <trans-unit id="34a637e08658f8356d26a5052ced9a5575ccaa48" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in stat() functions</source>
          <target state="translated">Именной интерфейс к встроенным функциям stat()Perl.</target>
        </trans-unit>
        <trans-unit id="00a7465e9ae8fc45cdd85380909fc57080f23c9d" translate="yes" xml:space="preserve">
          <source>Bypass shell script and produce qualifiers for CC directly (but warn user if a shell script for this extension exists). Fold multiple /Defines into one, since some C compilers pay attention to only one instance of this qualifier on the command line.</source>
          <target state="translated">Обходим скрипт оболочки и создаем квалификаторы для CC напрямую (но предупреждаем пользователя,если скрипт оболочки для этого расширения существует).Сложите несколько /Defines в один,так как некоторые компиляторы C обращают внимание только на один экземпляр этого квалификатора в командной строке.</target>
        </trans-unit>
        <trans-unit id="9f9d63573452a4bd55326feb5fe5283989ad472d" translate="yes" xml:space="preserve">
          <source>Byte and Character Semantics</source>
          <target state="translated">Семантика байтов и характера</target>
        </trans-unit>
        <trans-unit id="1e6a3eac8ab6b01ca95c7c44eb60befc42854a50" translate="yes" xml:space="preserve">
          <source>Byte order is not compatible</source>
          <target state="translated">Байт-ордер не совместим</target>
        </trans-unit>
        <trans-unit id="635424c9374984012107c0dd02fd2041e999753a" translate="yes" xml:space="preserve">
          <source>Byte-order modifiers</source>
          <target state="translated">Модификаторы байт-заказа</target>
        </trans-unit>
        <trans-unit id="b0cb8dbe3d4ffe27cb86b68da21fae1475b9d341" translate="yes" xml:space="preserve">
          <source>Byteorders &lt;code&gt;&quot;1234&quot;&lt;/code&gt; and &lt;code&gt;&quot;12345678&quot;&lt;/code&gt; are little-endian; &lt;code&gt;&quot;4321&quot;&lt;/code&gt; and &lt;code&gt;&quot;87654321&quot;&lt;/code&gt; are big-endian. Systems with multiarchitecture binaries will have &lt;code&gt;&quot;ffff&quot;&lt;/code&gt; , signifying that static information doesn't work, one must use runtime probing.</source>
          <target state="translated">Байтеры &lt;code&gt;&quot;1234&quot;&lt;/code&gt; и &lt;code&gt;&quot;12345678&quot;&lt;/code&gt; имеют прямой порядок байтов; &lt;code&gt;&quot;4321&quot;&lt;/code&gt; и &lt;code&gt;&quot;87654321&quot;&lt;/code&gt; имеют прямой порядок байтов. Системы с бинарными файлами с многоархитектурой будут иметь &lt;code&gt;&quot;ffff&quot;&lt;/code&gt; , означающее, что статическая информация не работает, необходимо использовать проверку во время выполнения.</target>
        </trans-unit>
        <trans-unit id="7bf6c5677e50bfc87de6c08c11b4d2bd476a1535" translate="yes" xml:space="preserve">
          <source>Bytes in the source text that have their high-bit set will be treated as being part of a literal UTF-X sequence. This includes most literals such as identifier names, string constants, and constant regular expression patterns.</source>
          <target state="translated">Байты в исходном тексте,которые имеют свой высокоразрядный набор,будут рассматриваться как часть буквальной последовательности UTF-X.Сюда входит большинство литералов,таких как имена идентификаторов,строковые константы и шаблоны константных регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="c380132bd13732c2a4492b58e8089f6c672f3148" translate="yes" xml:space="preserve">
          <source>C API</source>
          <target state="translated">C API</target>
        </trans-unit>
        <trans-unit id="129226dbff7ac0a26641ae86a93a3ce3ab2b8aca" translate="yes" xml:space="preserve">
          <source>C Operators Missing From Perl</source>
          <target state="translated">C Пропавшие операторы с Перла</target>
        </trans-unit>
        <trans-unit id="b810a5ecd150e1d0012428a848e5d769f60fea9b" translate="yes" xml:space="preserve">
          <source>C RTL</source>
          <target state="translated">C RTL</target>
        </trans-unit>
        <trans-unit id="17a5304c5884fe220f513c1c918ef7adab324995" translate="yes" xml:space="preserve">
          <source>C backtrace</source>
          <target state="translated">C обратная дорога</target>
        </trans-unit>
        <trans-unit id="a16bcf14a78c44b6bfc6c36207ff504cb459f2ef" translate="yes" xml:space="preserve">
          <source>C code</source>
          <target state="translated">C-код</target>
        </trans-unit>
        <trans-unit id="ebcfbca1a38de887c4893368cd463906e0bbe7b3" translate="yes" xml:space="preserve">
          <source>C code to place between the assignment of value (to a temporary) and the return from the function. This allows you to clear up anything in</source>
          <target state="translated">C-код,который необходимо разместить между присвоением значения (временному)и возвращением из функции.Это позволяет прояснить что-либо в</target>
        </trans-unit>
        <trans-unit id="538185c3d7f303f06af9140ec0da107705c84d52" translate="yes" xml:space="preserve">
          <source>C code to use before the assignment of the value of the constant. This allows you to use temporary variables to extract a value from part of a &lt;code&gt;struct&lt;/code&gt; and return this as</source>
          <target state="translated">Код C, используемый перед присвоением значения константе. Это позволяет использовать временные переменные для извлечения значения из части &lt;code&gt;struct&lt;/code&gt; и возврата его как</target>
        </trans-unit>
        <trans-unit id="0d6da997067e1b793fb43677b57abb70e6d14673" translate="yes" xml:space="preserve">
          <source>C doesn't have a concept of local scope, so perl provides one. We've seen that &lt;code&gt;ENTER&lt;/code&gt; and &lt;code&gt;LEAVE&lt;/code&gt; are used as scoping braces; the save stack implements the C equivalent of, for example:</source>
          <target state="translated">В C нет концепции локальной области видимости, поэтому ее предоставляет Perl. Мы видели, что &lt;code&gt;ENTER&lt;/code&gt; и &lt;code&gt;LEAVE&lt;/code&gt; используются в качестве скобок области видимости; стек сохранения реализует эквивалент C, например:</target>
        </trans-unit>
        <trans-unit id="062ffdd22a0d9502c039f8528f8150dbe0714cfe" translate="yes" xml:space="preserve">
          <source>C function parameters are normally initialized with their values from the argument stack (which in turn contains the parameters that were passed to the XSUB from Perl). The typemaps contain the code segments which are used to translate the Perl values to the C parameters. The programmer, however, is allowed to override the typemaps and supply alternate (or additional) initialization code. Initialization code starts with the first &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; on a line in the INPUT: section. The only exception happens if this &lt;code&gt;;&lt;/code&gt; terminates the line, then this &lt;code&gt;;&lt;/code&gt; is quietly ignored.</source>
          <target state="translated">Параметры функции C обычно инициализируются их значениями из стека аргументов (который, в свою очередь, содержит параметры, переданные в XSUB из Perl). Карты типов содержат сегменты кода, которые используются для преобразования значений Perl в параметры C. Однако программисту разрешено переопределить карты типов и предоставить альтернативный (или дополнительный) код инициализации. Код инициализации начинается с первым &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;;&lt;/code&gt; или &lt;code&gt;+&lt;/code&gt; в строке в разделе INPUT :. Единственное исключение случается, если это &lt;code&gt;;&lt;/code&gt; завершает строку, затем это &lt;code&gt;;&lt;/code&gt; незаметно игнорируется.</target>
        </trans-unit>
        <trans-unit id="33ca94bf1de4049e4f9bdaa005b019e6d57ed90a" translate="yes" xml:space="preserve">
          <source>C header file. This file contains a series of macros and, if explicitly requested, functions that allow XS modules to be built using older versions of Perl. Currently, Perl versions from 5.003 to 5.20 are supported.</source>
          <target state="translated">Заголовочный файл C.Этот файл содержит серию макросов и,при наличии явного запроса,функции,позволяющие собирать модули XS с использованием старых версий Perl.В настоящее время поддерживаются версии Perl от 5.003 до 5.20.</target>
        </trans-unit>
        <trans-unit id="a90cbbad6ac1bd0dbc637e8984710d08b0d07f9c" translate="yes" xml:space="preserve">
          <source>C header file.)</source>
          <target state="translated">Заголовочный файл C).</target>
        </trans-unit>
        <trans-unit id="6475b4e6bb646eb3e0b6202577ce4b2fb0cd180d" translate="yes" xml:space="preserve">
          <source>C keyword introducing a structure definition or name.</source>
          <target state="translated">Ключевое слово на языке C,вводящее определение структуры или имя.</target>
        </trans-unit>
        <trans-unit id="0a4b78bc2d00244d4f2291c70d25ad9ed10ec746" translate="yes" xml:space="preserve">
          <source>C preprocessor directives are allowed within BOOT:, PREINIT: INIT:, CODE:, PPCODE:, POSTCALL:, and CLEANUP: blocks, as well as outside the functions. Comments are allowed anywhere after the MODULE keyword. The compiler will pass the preprocessor directives through untouched and will remove the commented lines. POD documentation is allowed at any point, both in the C and XS language sections. POD must be terminated with a &lt;code&gt;=cut&lt;/code&gt; command; &lt;code&gt;xsubpp&lt;/code&gt; will exit with an error if it does not. It is very unlikely that human generated C code will be mistaken for POD, as most indenting styles result in whitespace in front of any line starting with &lt;code&gt;=&lt;/code&gt; . Machine generated XS files may fall into this trap unless care is taken to ensure that a space breaks the sequence &quot;\n=&quot;.</source>
          <target state="translated">Директивы препроцессора C разрешены в блоках BOOT :, PREINIT: INIT :, CODE:, PPCODE:, POSTCALL: и CLEANUP:, а также вне функций. Комментарии разрешены в любом месте после ключевого слова MODULE. Компилятор пропустит директивы препроцессора в нетронутом виде и удалит закомментированные строки. Документация POD разрешена в любой момент, как в языковых разделах C, так и в XS. POD должен заканчиваться командой &lt;code&gt;=cut&lt;/code&gt; ; &lt;code&gt;xsubpp&lt;/code&gt; выйдет с ошибкой, если этого не произойдет. Очень маловероятно, что созданный человеком код C будет ошибочно принят за POD, поскольку большинство стилей отступов приводят к появлению пробелов перед любой строкой, начинающейся с &lt;code&gt;=&lt;/code&gt; . Сгенерированные машиной файлы XS могут попасть в эту ловушку, если не позаботиться о том, чтобы пробел нарушал последовательность &quot;\ n =&quot;.</target>
        </trans-unit>
        <trans-unit id="8b72786c4e2763e287b454e5689b07155e0cdb40" translate="yes" xml:space="preserve">
          <source>C&amp;lt;_pc_chown_restricted&amp;gt; symbol (for example, Windows NT) it is assumed that ``chown() giveaway'' is possible and the recursive test is performed.</source>
          <target state="translated">C символа &amp;lt;_pc_chown_restricted&amp;gt; (например, Windows NT) предполагается, что возможна раздача chown (), и выполняется рекурсивный тест.</target>
        </trans-unit>
        <trans-unit id="d682623210c6b24f8d8f68ce43a83783f1b6c8af" translate="yes" xml:space="preserve">
          <source>C-style Logical And</source>
          <target state="translated">С-стиль Логический И</target>
        </trans-unit>
        <trans-unit id="468d5b286c1316bc4a6baa7daaefae5e90272197" translate="yes" xml:space="preserve">
          <source>C-style Logical Or</source>
          <target state="translated">В стиле С Логический Или</target>
        </trans-unit>
        <trans-unit id="0403ad1f3298e7e9e68a2636bf42146ffa41b4ae" translate="yes" xml:space="preserve">
          <source>C. BUILD</source>
          <target state="translated">C.СТРОИТЕЛЬСТВО</target>
        </trans-unit>
        <trans-unit id="624f656f2b44769e8027ab2f2c47b638fe6eea88" translate="yes" xml:space="preserve">
          <source>C/C++ Traps</source>
          <target state="translated">C/C++Ловушки</target>
        </trans-unit>
        <trans-unit id="633490a93f1c6b59da0e4592f3c36f5d9d5fc276" translate="yes" xml:space="preserve">
          <source>C3 is the name of an algorithm which aims to provide a sane method resolution order under multiple inheritance. It was first introduced in the language Dylan (see links in the &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; section), and then later adopted as the preferred MRO (Method Resolution Order) for the new-style classes in Python 2.3. Most recently it has been adopted as the &quot;canonical&quot; MRO for Perl 6 classes, and the default MRO for Parrot objects as well.</source>
          <target state="translated">C3 - это имя алгоритма, цель которого - обеспечить разумный порядок разрешения методов при множественном наследовании. Впервые он был представлен на языке Dylan (см. Ссылки в разделе &lt;a href=&quot;#SEE-ALSO&quot;&gt;СМОТРИ ТАКЖЕ&lt;/a&gt; ), а затем принят как предпочтительный MRO (Порядок разрешения методов) для классов нового стиля в Python 2.3. Совсем недавно он был принят как &amp;laquo;канонический&amp;raquo; MRO для классов Perl 6, а также как MRO по умолчанию для объектов Parrot.</target>
        </trans-unit>
        <trans-unit id="4aa8a8fa5eacc54ba9f8a4e755d8440833ba62a6" translate="yes" xml:space="preserve">
          <source>C3 works by always preserving local precedence ordering. This essentially means that no class will appear before any of its subclasses. Take, for instance, the classic diamond inheritance pattern:</source>
          <target state="translated">C3 работает,всегда сохраняя местный порядок очередности.Это,по сути,означает,что ни один класс не появится ни перед одним из своих подклассов.Возьмем,к примеру,классическую модель наследования бриллиантов:</target>
        </trans-unit>
        <trans-unit id="7a382120912440ea350318c064061d0e6ea8184a" translate="yes" xml:space="preserve">
          <source>C:/emx.add/bin/bash.exe</source>
          <target state="translated">C:/emx.add/bin/bash.exe</target>
        </trans-unit>
        <trans-unit id="519c5bd785564af1dec76cf3a5edc1bf3e894ac6" translate="yes" xml:space="preserve">
          <source>C:/emx/bin/foo.cmd</source>
          <target state="translated">C:/emx/bin/foo.cmd</target>
        </trans-unit>
        <trans-unit id="f6665c2627be2b969dcd410132185e0dd599f37b" translate="yes" xml:space="preserve">
          <source>CALLBACKS</source>
          <target state="translated">CALLBACKS</target>
        </trans-unit>
        <trans-unit id="3991ab584fec70130dcdb49fb4dbe4638d6f1b90" translate="yes" xml:space="preserve">
          <source>CALLING FROM PERL</source>
          <target state="translated">ЗВОНОК С ПЕРЛА</target>
        </trans-unit>
        <trans-unit id="5f0a327136ac9e42e9905406e9cf6ed2f2b8cdbf" translate="yes" xml:space="preserve">
          <source>CALLING FROM THE COMMAND LINE</source>
          <target state="translated">ВЫЗОВ С КОМАНДНОЙ СТРОКИ</target>
        </trans-unit>
        <trans-unit id="aa884ac53759d984488c656f65f21f650359027e" translate="yes" xml:space="preserve">
          <source>CAN</source>
          <target state="translated">CAN</target>
        </trans-unit>
        <trans-unit id="5f05bf320ccd994a5b4376cbf772126d72a752e5" translate="yes" xml:space="preserve">
          <source>CANONICAL REPRESENTATION</source>
          <target state="translated">КАНОНИЧЕСКОЕ ПРЕДСТАВЛЕНИЕ</target>
        </trans-unit>
        <trans-unit id="ed877e5c7f10c31f466df09c23df16788f087cc2" translate="yes" xml:space="preserve">
          <source>CANONICAL_NAME</source>
          <target state="translated">CANONICAL_NAME</target>
        </trans-unit>
        <trans-unit id="e520869852c82bbce05b6c5dc47274d3b3a11987" translate="yes" xml:space="preserve">
          <source>CATEGORIES</source>
          <target state="translated">CATEGORIES</target>
        </trans-unit>
        <trans-unit id="980aeb7f8f581c6b66ed59bbbed49733515b10e6" translate="yes" xml:space="preserve">
          <source>CAVEAT</source>
          <target state="translated">CAVEAT</target>
        </trans-unit>
        <trans-unit id="6567e0b0a7daf3c098913aa924483cfe44852131" translate="yes" xml:space="preserve">
          <source>CAVEAT FOR GREAT CIRCLE FORMULAS</source>
          <target state="translated">ПРЕДОСТЕРЕЖЕНИЕ ДЛЯ ФОРМУЛ БОЛЬШОГО КРУГА</target>
        </trans-unit>
        <trans-unit id="8ae97560e6c967ffcb76f6cd835c75b45c6b2d57" translate="yes" xml:space="preserve">
          <source>CAVEAT ON PRECEDENCE</source>
          <target state="translated">ПРЕДОСТЕРЕЖЕНИЕ В ОТНОШЕНИИ СТАРШИНСТВА</target>
        </trans-unit>
        <trans-unit id="1c968ba436040f2ef7532a90991da165ff0512dd" translate="yes" xml:space="preserve">
          <source>CAVEAT: The thread signalling capability provided by this module does not actually send signals via the OS. It</source>
          <target state="translated">CAVEAT:Потоковая сигнализация,предоставляемая этим модулем,на самом деле не посылает сигналы через операционную систему.Это .</target>
        </trans-unit>
        <trans-unit id="ce611c3a23df37ff734feee69c06233d5c9abfb4" translate="yes" xml:space="preserve">
          <source>CAVEAT: Though BOM in utf8 (\xEF\xBB\xBF) is valid, it is meaningless and as of this writing Encode suite just leave it as is (\x{FeFF}).</source>
          <target state="translated">КАВЕАТ:Несмотря на то,что запоминающее устройство в utf8 (\xEF\xBB\xBF)является действительным,оно бессмысленно,и с момента написания этого набора Encode Suite просто оставьте его как есть (\x{FeFF}).</target>
        </trans-unit>
        <trans-unit id="5ea0a6fefc9f66fb07ad0567375a2c4308c1f112" translate="yes" xml:space="preserve">
          <source>CAVEAT: Unlike UTF-(16|32), BOM in utf8 is NOT AUTOMATICALLY STRIPPED.</source>
          <target state="translated">КАВЕАТ:В отличие от UTF-(16|32),запоминающее устройство в utf8 не является АВТОМАТИЧЕСКИМ СТРИПППИРОВЕДЕННЫМ.</target>
        </trans-unit>
        <trans-unit id="0852d6090cb36f8c92fc678e7c0ed0101951986e" translate="yes" xml:space="preserve">
          <source>CAVEATS</source>
          <target state="translated">CAVEATS</target>
        </trans-unit>
        <trans-unit id="afa50a96d52c4af6173a5b3dcf9e10a0a47c02ab" translate="yes" xml:space="preserve">
          <source>CAVEATS AND LIMITATIONS</source>
          <target state="translated">ПРЕДУПРЕЖДЕНИЯ И ОГРАНИЧЕНИЯ</target>
        </trans-unit>
        <trans-unit id="8db2d4672c0bb6f4ea12967ef5822987358da334" translate="yes" xml:space="preserve">
          <source>CAVEATS and NOTES</source>
          <target state="translated">ОТВЕТСТВЕННОСТИ и ПРИМЕЧАНИЯ</target>
        </trans-unit>
        <trans-unit id="422f720e7d72716b7017e69268406be073cfc7c1" translate="yes" xml:space="preserve">
          <source>CGI</source>
          <target state="translated">CGI</target>
        </trans-unit>
        <trans-unit id="41a4605be9cd5708c0812fcf96a67b02ae213ace" translate="yes" xml:space="preserve">
          <source>CGI.pm</source>
          <target state="translated">CGI.pm</target>
        </trans-unit>
        <trans-unit id="313c83d1d2e8c998d1416c76ceb327085bafcc5a" translate="yes" xml:space="preserve">
          <source>CHANGED IN PERL 5.6</source>
          <target state="translated">ИЗМЕНЁННЫЙ В PERL 5.6</target>
        </trans-unit>
        <trans-unit id="15a7fa79c2e880d7c668e6f0bb63190d52852647" translate="yes" xml:space="preserve">
          <source>CHANGED in 3.18</source>
          <target state="translated">ИЗМЕНЕННЫЙ в 3.18</target>
        </trans-unit>
        <trans-unit id="a2feb6ed0257c21c6672793ee2f94eaadc10c72c" translate="yes" xml:space="preserve">
          <source>CHANGES</source>
          <target state="translated">CHANGES</target>
        </trans-unit>
        <trans-unit id="77e515bcbeea42a381522b3f02fc083d411a62f5" translate="yes" xml:space="preserve">
          <source>CHARACTER CLASSES</source>
          <target state="translated">ХАРАКТЕРНЫЕ КЛАССЫ</target>
        </trans-unit>
        <trans-unit id="a375cca9c609e8591d1c22cf8e8a8c4bbd0e6f6f" translate="yes" xml:space="preserve">
          <source>CHARMAP starts the character map section. Each line has a form as follows:</source>
          <target state="translated">CHARMAP запускает раздел карты символов.Каждая строка имеет следующую форму:</target>
        </trans-unit>
        <trans-unit id="1fbd3cbf6697996c51d6a64a08ee8b874fefe67b" translate="yes" xml:space="preserve">
          <source>CHARNAME</source>
          <target state="translated">CHARNAME</target>
        </trans-unit>
        <trans-unit id="d37267cb2995cccac2283009e1ea4f3a6dd37db3" translate="yes" xml:space="preserve">
          <source>CHECK</source>
          <target state="translated">CHECK</target>
        </trans-unit>
        <trans-unit id="0a228e95208b8ea7acb00589cdd0f311e92f3483" translate="yes" xml:space="preserve">
          <source>CHECKSUM FUNCTIONS</source>
          <target state="translated">ФУНКЦИИ КОНТРОЛЬНОЙ СУММЫ</target>
        </trans-unit>
        <trans-unit id="0d2dc3d6989d0491c087fdf8b26389f6609dba54" translate="yes" xml:space="preserve">
          <source>CLASS METHODS</source>
          <target state="translated">МЕТОДЫ КЛАССА</target>
        </trans-unit>
        <trans-unit id="3a8f000aa3840296550580880a88660b74717610" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;safe_quote ITEM</source>
          <target state="translated">КЛАСС-&amp;gt; safe_quote ПУНКТ</target>
        </trans-unit>
        <trans-unit id="2a5520b8514a16a64037e86c211cbd6b6bfdc1cb" translate="yes" xml:space="preserve">
          <source>CLASSES</source>
          <target state="translated">CLASSES</target>
        </trans-unit>
        <trans-unit id="eb2ed6b6d36f266377a9e30f6e145c7fdae07a3f" translate="yes" xml:space="preserve">
          <source>CLONEf_CLONE_HOST - This is a win32 thing, it is ignored on unix, it tells perls win32host code (which is c++) to clone itself, this is needed on win32 if you want to run two threads at the same time, if you just want to do some stuff in a separate perl interpreter and then throw it away and return to the original one, you don't need to do anything.</source>
          <target state="translated">CLONEf_CLONE_HOST-это вещь win32,она игнорируется на unix,она говорит perls win32host-коду (который является c++)клонировать себя,это нужно на win32,если вы хотите запустить два потока одновременно,если вы просто хотите сделать некоторые вещи в отдельном интерпретаторе perl,а затем выбросить его и вернуться к исходному,вам не нужно ничего делать.</target>
        </trans-unit>
        <trans-unit id="5dd06954f8504852be625e8b13f9f38ba4df5c2d" translate="yes" xml:space="preserve">
          <source>CLONEf_COPY_STACKS - is used to, well, copy the stacks also, without it we only clone the data and zero the stacks, with it we copy the stacks and the new perl interpreter is ready to run at the exact same point as the previous one. The pseudo-fork code uses COPY_STACKS while the threads-&amp;gt;create doesn't.</source>
          <target state="translated">CLONEf_COPY_STACKS - используется для того, чтобы копировать и стеки, без него мы только клонируем данные и обнуляем стеки, с его помощью мы копируем стеки, и новый интерпретатор perl готов к запуску в той же точке, что и предыдущий. Код псевдоразветвления использует COPY_STACKS, а потоки-&amp;gt; create - нет.</target>
        </trans-unit>
        <trans-unit id="496d69294e21b9e9459d9ae5f134da2961a69331" translate="yes" xml:space="preserve">
          <source>CLONEf_KEEP_PTR_TABLE - perl_clone keeps a ptr_table with the pointer of the old variable as a key and the new variable as a value, this allows it to check if something has been cloned and not clone it again but rather just use the value and increase the refcount. If KEEP_PTR_TABLE is not set then perl_clone will kill the ptr_table using the function &lt;code&gt;ptr_table_free(PL_ptr_table); PL_ptr_table = NULL;&lt;/code&gt; , reason to keep it around is if you want to dup some of your own variable who are outside the graph perl scans, example of this code is in threads.xs create.</source>
          <target state="translated">CLONEf_KEEP_PTR_TABLE - perl_clone сохраняет ptr_table с указателем старой переменной в качестве ключа и новой переменной в качестве значения, это позволяет ему проверять, было ли что-то клонировано, и не клонировать его снова, а просто использовать значение и увеличивать счетчик ссылок. Если KEEP_PTR_TABLE не установлен, perl_clone уничтожит ptr_table с помощью функции &lt;code&gt;ptr_table_free(PL_ptr_table); PL_ptr_table = NULL;&lt;/code&gt; , причина сохранить его в том, что если вы хотите дублировать некоторые из ваших собственных переменных, которые находятся за пределами сканирования графа Perl, пример этого кода находится в threads.xs create.</target>
        </trans-unit>
        <trans-unit id="439fbcbebff5d3e18e9cd1652b960a8b5958c8fb" translate="yes" xml:space="preserve">
          <source>CMD.EXE</source>
          <target state="translated">CMD.EXE</target>
        </trans-unit>
        <trans-unit id="b7f8b1aaa4e3518d65a63cc4b574d3a502b21354" translate="yes" xml:space="preserve">
          <source>CMD_ERROR</source>
          <target state="translated">CMD_ERROR</target>
        </trans-unit>
        <trans-unit id="b9c1aaaf65573c7e15b93b6d826729e7711cf242" translate="yes" xml:space="preserve">
          <source>CNAME</source>
          <target state="translated">CNAME</target>
        </trans-unit>
        <trans-unit id="8a81c4f5d7ebf0af1540db862699627a91092359" translate="yes" xml:space="preserve">
          <source>CODE EXAMPLES</source>
          <target state="translated">КОДИРОВЫЕ ЭКЗАМПЛИ</target>
        </trans-unit>
        <trans-unit id="e00c531b83778b8e9867578bc4976f46546c5a61" translate="yes" xml:space="preserve">
          <source>CODE REFERENCES</source>
          <target state="translated">КОДОВЫЕ ССЫЛКИ</target>
        </trans-unit>
        <trans-unit id="440677eb0b9f2ced4b57b4cf4a1f2a4041acaf2f" translate="yes" xml:space="preserve">
          <source>CODE reference. The subroutine should return a hash reference. The hash may contain further attributes, e.g. {LIBS =&amp;gt; ...}, that have to be determined by some evaluation method.</source>
          <target state="translated">Ссылка на КОД. Подпрограмма должна возвращать хеш-ссылку. Хэш может содержать дополнительные атрибуты, например {LIBS =&amp;gt; ...}, которые должны быть определены каким-либо методом оценки.</target>
        </trans-unit>
        <trans-unit id="2f975202aa1b4783c29e4937429d2b66fab5169e" translate="yes" xml:space="preserve">
          <source>CODE: directive is used which sets ST(0) explicitly.</source>
          <target state="translated">CODE:используется директива,которая явно задает ST(0).</target>
        </trans-unit>
        <trans-unit id="3a38ee1d9bd08c8be0112c20a3c4f3c5309ce957" translate="yes" xml:space="preserve">
          <source>COMMAND.COM</source>
          <target state="translated">COMMAND.COM</target>
        </trans-unit>
        <trans-unit id="c13bbfcc6932afed8045a8c6d2be122bbea2f4a3" translate="yes" xml:space="preserve">
          <source>COMMON CHARACTER CODE SETS</source>
          <target state="translated">НАБОРЫ ОБЩИХ СИМВОЛОВ</target>
        </trans-unit>
        <trans-unit id="3565dc34b7a16c1ebb52c1be4a3b9554d589b634" translate="yes" xml:space="preserve">
          <source>COMMON MISTAKES</source>
          <target state="translated">РАСПРОСТРАНЁННЫЕ ОШИБКИ</target>
        </trans-unit>
        <trans-unit id="d3bd9328431af889713253c0fe82cf459fd62fdd" translate="yes" xml:space="preserve">
          <source>COMMON PITFALLS</source>
          <target state="translated">ОБЩИЕ ОШИБКИ</target>
        </trans-unit>
        <trans-unit id="3b75e36fb6f8799ec17d763957648965ceb0bf19" translate="yes" xml:space="preserve">
          <source>COMMON PROBLEMS</source>
          <target state="translated">ОБЩИЕ ПРОБЛЕМЫ</target>
        </trans-unit>
        <trans-unit id="3631d60b3c3dad75e7023cf75ede2d8db90dced0" translate="yes" xml:space="preserve">
          <source>COMMON QUESTIONS</source>
          <target state="translated">ОБЫЧНЫЕ ВОПРОСЫ.</target>
        </trans-unit>
        <trans-unit id="5931c475df95ba4c0e69e8680b4b2746d7dcadbd" translate="yes" xml:space="preserve">
          <source>COMPATIBILITY</source>
          <target state="translated">COMPATIBILITY</target>
        </trans-unit>
        <trans-unit id="1b93c2f6af1a728937d801492e8514e231fe859d" translate="yes" xml:space="preserve">
          <source>COMPILING AND INSTALLING PERL ON PLAN 9</source>
          <target state="translated">СБОРКА И УСТАНОВКА ПЕРЛАМУТРА ПО ПЛАНУ 9</target>
        </trans-unit>
        <trans-unit id="a3dbb0f2d743369125c33547e4a98f6e69c718ea" translate="yes" xml:space="preserve">
          <source>COMPRESS/UNCOMPRESS</source>
          <target state="translated">COMPRESS/UNCOMPRESS</target>
        </trans-unit>
        <trans-unit id="dbbd6e677093ab33626116ddbe95a8116b822da0" translate="yes" xml:space="preserve">
          <source>CONCEPTS</source>
          <target state="translated">CONCEPTS</target>
        </trans-unit>
        <trans-unit id="ce2288334f1137f427c025bf4db30086aa2e6ccd" translate="yes" xml:space="preserve">
          <source>CONCLUSION</source>
          <target state="translated">CONCLUSION</target>
        </trans-unit>
        <trans-unit id="54b45ea0b830c111f200238254cbe142d992ceb9" translate="yes" xml:space="preserve">
          <source>CONCURRENT ACCESS TO FILES</source>
          <target state="translated">ОДНОВРЕМЕННЫЙ ДОСТУП К ФАЙЛАМ</target>
        </trans-unit>
        <trans-unit id="b6e52e4d80314fc8a5ba1a7faeb4aa6cd672bec0" translate="yes" xml:space="preserve">
          <source>CONFIGURATION</source>
          <target state="translated">CONFIGURATION</target>
        </trans-unit>
        <trans-unit id="0bcdf5cc47cad9c41938edcc7524d271413daa98" translate="yes" xml:space="preserve">
          <source>CONFIGURE PERL ON CYGWIN</source>
          <target state="translated">НАСТРОИТЬ ПЕРЛ НА ЦИГВИН</target>
        </trans-unit>
        <trans-unit id="86446751ae319594b5e453b782ebdfc8c4bf543b" translate="yes" xml:space="preserve">
          <source>CONFIGURING</source>
          <target state="translated">CONFIGURING</target>
        </trans-unit>
        <trans-unit id="65df4be803801cf76d0b33102b49347c0f49a265" translate="yes" xml:space="preserve">
          <source>CONSTANTS</source>
          <target state="translated">CONSTANTS</target>
        </trans-unit>
        <trans-unit id="9d4cd9e346a27cff016ae855f03e070521487596" translate="yes" xml:space="preserve">
          <source>CONSTRUCT</source>
          <target state="translated">CONSTRUCT</target>
        </trans-unit>
        <trans-unit id="6ed66fd18a1b175704db533d3865fa2679863e6d" translate="yes" xml:space="preserve">
          <source>CONSTRUCTOR</source>
          <target state="translated">CONSTRUCTOR</target>
        </trans-unit>
        <trans-unit id="740fabb870d6ed652cd56a6f6b4cabc2048431f9" translate="yes" xml:space="preserve">
          <source>CONTACT</source>
          <target state="translated">CONTACT</target>
        </trans-unit>
        <trans-unit id="6eb1660530253dbbb9bc0adce6c7c2db98f6c11e" translate="yes" xml:space="preserve">
          <source>CONTRIBUTED MODULES</source>
          <target state="translated">МОДУЛИ С ВКЛАДЫШАМИ</target>
        </trans-unit>
        <trans-unit id="c00c0afca84109e3fb2b98c8209ef559a912b256" translate="yes" xml:space="preserve">
          <source>CONTRIBUTORS</source>
          <target state="translated">CONTRIBUTORS</target>
        </trans-unit>
        <trans-unit id="3c270e7e648d60e989f665180ac5841d2f501b46" translate="yes" xml:space="preserve">
          <source>CONTROLLING LOOKUP FAILURE</source>
          <target state="translated">УПРАВЛЯЮЩИЙ СБОЙ ПОИСКА</target>
        </trans-unit>
        <trans-unit id="56e1ec5824af8dff3fb44acbb1f5889b6031d924" translate="yes" xml:space="preserve">
          <source>CONVENTIONS</source>
          <target state="translated">CONVENTIONS</target>
        </trans-unit>
        <trans-unit id="bb5de08378fdc79cf1e8f681e4066f1cb85bb028" translate="yes" xml:space="preserve">
          <source>CONVERSIONS</source>
          <target state="translated">CONVERSIONS</target>
        </trans-unit>
        <trans-unit id="e1146aff355e08a86787f760b889571c858e8593" translate="yes" xml:space="preserve">
          <source>COOKBOOK</source>
          <target state="translated">COOKBOOK</target>
        </trans-unit>
        <trans-unit id="9510141c24a403496c1dfba8b0ab986988f95879" translate="yes" xml:space="preserve">
          <source>COORDINATE SYSTEMS</source>
          <target state="translated">КООРДИНАТНЫЕ СИСТЕМЫ</target>
        </trans-unit>
        <trans-unit id="c51ce576d0d85de4e554620a3b7e0dd309045090" translate="yes" xml:space="preserve">
          <source>COP Hint Hashes</source>
          <target state="translated">Хэшс намека КС</target>
        </trans-unit>
        <trans-unit id="22ad88b10bee537423c13139a4d2b08d579efc3e" translate="yes" xml:space="preserve">
          <source>COP Hint Reading</source>
          <target state="translated">Чтение подсказок КС</target>
        </trans-unit>
        <trans-unit id="e352fc138c5e488dc34254c3ee2e99e3e9aaf288" translate="yes" xml:space="preserve">
          <source>COPYRIGHT</source>
          <target state="translated">COPYRIGHT</target>
        </trans-unit>
        <trans-unit id="9c7e4e94b44caac6a4f40ca3467d6883ed67cf24" translate="yes" xml:space="preserve">
          <source>COPYRIGHT &amp;amp; LICENSE</source>
          <target state="translated">АВТОРСКИЕ ПРАВА И ЛИЦЕНЗИЯ</target>
        </trans-unit>
        <trans-unit id="fd93171470739cb1a4e64e6ea953d8c1dd9e7c3a" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND DISCLAIMER</source>
          <target state="translated">АВТОРСКОЕ ПРАВО И ОТКАЗ ОТ ОТВЕТСТВЕННОСТИ</target>
        </trans-unit>
        <trans-unit id="aed47af09308ae3a4fa8a24efc25bc20b8d6091d" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND DISCLAIMERS</source>
          <target state="translated">АВТОРСКИЕ ПРАВА И ОГОВОРКИ</target>
        </trans-unit>
        <trans-unit id="0524ce058903ad04ed18326112dd9695f4ac4f56" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND LICENCE</source>
          <target state="translated">АВТОРСКОЕ ПРАВО И ЛИЦЕНЗИЯ</target>
        </trans-unit>
        <trans-unit id="d7f1de266854e2b8d4c927372f1242e7739925ed" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND LICENSE</source>
          <target state="translated">АВТОРСКОЕ ПРАВО И ЛИЦЕНЗИЯ</target>
        </trans-unit>
        <trans-unit id="8c9b991a9d45dee993d0ee634ba8eafd7815c6a3" translate="yes" xml:space="preserve">
          <source>COPYRIGHT and LICENSE</source>
          <target state="translated">КОПИРИРОВАНИЕ и ЛИЦЕНЗИЯ</target>
        </trans-unit>
        <trans-unit id="6d917c2df32bb3f8fb6b5f8e529bb779c3dca6f7" translate="yes" xml:space="preserve">
          <source>CORE</source>
          <target state="translated">CORE</target>
        </trans-unit>
        <trans-unit id="9f2a7e4446d753ffa86ebd32d2855d851f9cf12a" translate="yes" xml:space="preserve">
          <source>CORE - Namespace for Perl's core routines</source>
          <target state="translated">CORE-пространство имён для основных процедур Perl.</target>
        </trans-unit>
        <trans-unit id="ea0b6538392d829d8b749d944b7acd94dee0ddb6" translate="yes" xml:space="preserve">
          <source>CPAN</source>
          <target state="translated">CPAN</target>
        </trans-unit>
        <trans-unit id="a6110e98d6d5509cfa9c7e73794ab71e46a695de" translate="yes" xml:space="preserve">
          <source>CPAN - query, download and build perl modules from CPAN sites</source>
          <target state="translated">CPAN-запрос,загрузка и сборка perl модулей с CPAN сайтов</target>
        </trans-unit>
        <trans-unit id="f5cb991183e9576ae99c7af8774c4d59270235f0" translate="yes" xml:space="preserve">
          <source>CPAN TESTERS AND PERL SMOKERS</source>
          <target state="translated">ТЕСТИРОВЩИКИ ТАБЛЕТОК И КУРИЛЬЩИКИ НА PERL</target>
        </trans-unit>
        <trans-unit id="b04380d2ad945f75e3aa967dafb36ed58ba766cd" translate="yes" xml:space="preserve">
          <source>CPAN Testers</source>
          <target state="translated">CPAN-тестеры</target>
        </trans-unit>
        <trans-unit id="01505e76b90321ebd4493c61034cb8a884911e63" translate="yes" xml:space="preserve">
          <source>CPAN also keeps track of what it has done within the current session and doesn't try to build a package a second time regardless of whether it succeeded or not. It does not repeat a test run if the test has been run successfully before. Same for install runs.</source>
          <target state="translated">CPAN также следит за тем,что он сделал в течение текущей сессии,и не пытается собрать пакет второй раз,независимо от того,удалось это или нет.Он не повторяет тестовый запуск,если тест был успешно выполнен ранее.То же самое происходит и при запуске установки.</target>
        </trans-unit>
        <trans-unit id="d978419581e9be6ec9c55f53ba43e4e7f68766bd" translate="yes" xml:space="preserve">
          <source>CPAN can now help you select a &quot;good&quot; mirror, based on which ones have the lowest 'ping' round-trip times. From the shell, use the command 'o conf init urllist' and allow CPAN to automatically select mirrors for you.</source>
          <target state="translated">Теперь CPAN может помочь вам выбрать &quot;хорошее&quot; зеркало,в зависимости от того,какое из них имеет наименьшее &quot;ping&quot; время прохождения круга.В оболочке используйте команду 'o conf init urllist' и позвольте CPAN автоматически выбрать зеркала для вас.</target>
        </trans-unit>
        <trans-unit id="9f419c26e2ea47eba870171b0304a0f12d770bcb" translate="yes" xml:space="preserve">
          <source>CPAN can provide the best examples. &lt;a href=&quot;simple&quot;&gt;Test::Simple&lt;/a&gt;, &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Exception&quot;&gt;Test::Exception&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Differences&quot;&gt;Test::Differences&lt;/a&gt; all use Test::Builder.</source>
          <target state="translated">CPAN может предоставить лучшие примеры. &lt;a href=&quot;simple&quot;&gt;Test :: Simple&lt;/a&gt; , &lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Exception&quot;&gt;Test :: Exception&lt;/a&gt; и &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Differences&quot;&gt;Test :: Differences&lt;/a&gt; используют Test :: Builder.</target>
        </trans-unit>
        <trans-unit id="9b25cd0f5375c5eab72f3ffe3e62897e52e03cea" translate="yes" xml:space="preserve">
          <source>CPAN checks whether an install is needed and prints</source>
          <target state="translated">CPAN проверяет необходимость установки и распечатывает</target>
        </trans-unit>
        <trans-unit id="d5ac7dd05001d7d37e2f43d1797c997c4df20e68" translate="yes" xml:space="preserve">
          <source>CPAN has several JAPH programs at &lt;a href=&quot;http://www.cpan.org/misc/japh&quot;&gt;http://www.cpan.org/misc/japh&lt;/a&gt;.</source>
          <target state="translated">У CPAN есть несколько программ JAPH по адресу &lt;a href=&quot;http://www.cpan.org/misc/japh&quot;&gt;http://www.cpan.org/misc/japh&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73829bcf0ad0c4b896f34810c840c5f0243a137e" translate="yes" xml:space="preserve">
          <source>CPAN module &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Regex::Set&quot;&gt;Unicode::Regex::Set&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Модуль CPAN &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Regex::Set&quot;&gt;Unicode::Regex::Set&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec0e8e76dd47186c4a257a69793cc4b0fbd9812e" translate="yes" xml:space="preserve">
          <source>CPAN packages can be digitally signed by authors and thus verified with the security provided by strong cryptography. The exact mechanism is defined in the Module::Signature module. While this is generally considered a good thing, it is not always convenient to the end user to install modules that are signed incorrectly or where the key of the author is not available or where some prerequisite for Module::Signature has a bug and so on.</source>
          <target state="translated">CPAN пакеты могут быть подписаны авторами в цифровом виде и,таким образом,проверены на безопасность,предоставляемую сильной криптографией.Точный механизм определяется в модуле Module::Signature.Хотя это обычно считается хорошей вещью,конечному пользователю не всегда удобно устанавливать модули,которые подписаны неправильно,или в которых ключ автора недоступен,или в которых какая-то предпосылка для Module::Signature содержит ошибку и так далее.</target>
        </trans-unit>
        <trans-unit id="b51337fb370844b9eff5cf2f0d2334791161629e" translate="yes" xml:space="preserve">
          <source>CPAN stands for Comprehensive Perl Archive Network, a multi-gigabyte archive replicated on hundreds of machines all over the world. CPAN contains tens of thousands of modules and extensions, source code and documentation, designed for</source>
          <target state="translated">CPAN обозначает Comprehensive Perl Archive Network,многогигабайтный архив,реплицируемый на сотнях машин по всему миру.CPAN содержит десятки тысяч модулей и расширений,исходный код и документацию,предназначенную для</target>
        </trans-unit>
        <trans-unit id="4a083d1c70360c499c212a22f42c02ebc10a2b7e" translate="yes" xml:space="preserve">
          <source>CPAN stands for Comprehensive Perl Archive Network; it's a globally replicated trove of Perl materials, including documentation, style guides, tricks and traps, alternate ports to non-Unix systems and occasional binary distributions for these. Search engines for CPAN can be found at &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;</source>
          <target state="translated">CPAN означает Комплексную сеть архивов Perl; это глобально копируемый кладезь материалов Perl, включая документацию, руководства по стилю, уловки и ловушки, альтернативные порты для систем, отличных от Unix, и случайные двоичные дистрибутивы для них. Поисковые системы для CPAN можно найти на &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11b7513cf5ed0783e222931555703c39249404ca" translate="yes" xml:space="preserve">
          <source>CPAN uses ExtUtils::MakeMaker's prompt() function to ask its questions, so if you set the PERL_MM_USE_DEFAULT environment variable, you shouldn't be asked any questions at all (assuming the modules you are installing are nice about obeying that variable as well):</source>
          <target state="translated">CPAN использует функцию prompt()ExtUtils::MakeMaker,чтобы задавать вопросы,поэтому если вы установите переменную окружения PERL_MM_USE_DEFAULT,то вам вообще не следует задавать никаких вопросов (если предположить,что устанавливаемые вами модули тоже хорошо умеют подчиняться этой переменной):</target>
        </trans-unit>
        <trans-unit id="763ab2cd14f13622b64f1d364ae89ff5e930c5e0" translate="yes" xml:space="preserve">
          <source>CPAN version is currently maintained by S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;sebastien@aperghis.net&amp;gt;.</source>
          <target state="translated">Версия CPAN в настоящее время поддерживается Себастьяном Апергис-Трамони &amp;lt;sebastien@aperghis.net&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="d022fca84f913595d0e465957aa3ec07aa26e29a" translate="yes" xml:space="preserve">
          <source>CPAN version produced by Jerry D. Hedden &amp;lt;jdhedden AT cpan DOT org&amp;gt;</source>
          <target state="translated">Версия CPAN, созданная Джерри Д. Хедденом &amp;lt;jdhedden AT cpan DOT org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="df1b7ad617e594d1fcea7ef95394577f7d4285ee" translate="yes" xml:space="preserve">
          <source>CPAN version produced by Jerry D. Hedden &amp;lt;jdhedden AT cpan DOT org&amp;gt;.</source>
          <target state="translated">Версия CPAN, созданная Джерри Д. Хедденом &amp;lt;jdhedden AT cpan DOT org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="a3c7ec93761c4b99669cfe3abe56f987f4d86e7b" translate="yes" xml:space="preserve">
          <source>CPAN, or the Comprehensive Perl Archive Network &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;, is a replicated, worldwide repository of Perl software. See &lt;a href=&quot;#What-modules-and-extensions-are-available-for-Perl%3f-What-is-CPAN%3f&quot;&gt;What is CPAN?&lt;/a&gt;.</source>
          <target state="translated">CPAN, или Комплексная сеть архивов Perl &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; , является реплицированным всемирным репозиторием программного обеспечения Perl. См. &lt;a href=&quot;#What-modules-and-extensions-are-available-for-Perl%3f-What-is-CPAN%3f&quot;&gt;Что такое CPAN? &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d24df83c42548921d5e891bad0ec265b58c5632b" translate="yes" xml:space="preserve">
          <source>CPAN.pm</source>
          <target state="translated">CPAN.pm</target>
        </trans-unit>
        <trans-unit id="df07d81df98f66bb5cc686dd3a7b7369a164da96" translate="yes" xml:space="preserve">
          <source>CPAN.pm can introduce some randomness when using hosts for download that are configured in the urllist parameter. Enter a numeric value between 0 and 1 to indicate how often you want to let CPAN.pm try a random host from the urllist. A value of one specifies to always use a random host as the first try. A value of zero means no randomness at all. Anything in between specifies how often, on average, a random host should be tried first.</source>
          <target state="translated">CPAN.pm может ввести некоторую случайность при использовании хостов для загрузки,которые настроены в параметре urllist.Введите числовое значение между 0 и 1,чтобы указать,как часто вы хотите позволить CPAN.pm пробовать случайный хост из списка рассылки.Значение единицы указывает всегда использовать случайный узел в качестве первой попытки.Значение ноль означает отсутствие случайности вообще.Любое промежуточное значение определяет,как часто,в среднем,следует сначала пробовать случайный узел.</target>
        </trans-unit>
        <trans-unit id="8be548e1857808a4c33f06e8483679790bde10ef" translate="yes" xml:space="preserve">
          <source>CPAN.pm can limit the size of the disk area for keeping the build directories with all the intermediate files.</source>
          <target state="translated">CPAN.pm может ограничить размер области диска для хранения каталогов сборки со всеми промежуточными файлами.</target>
        </trans-unit>
        <trans-unit id="f21743f9fae507577e1ebe77ee42077c588936ab" translate="yes" xml:space="preserve">
          <source>CPAN.pm can store customized build environments based on regular expressions for distribution names. These are YAML files where the default options for CPAN.pm and the environment can be overridden and dialog sequences can be stored that can later be executed by an Expect.pm object. The CPAN.pm distribution comes with some prefab YAML files that cover sample distributions that can be used as blueprints to store your own prefs. Please check out the distroprefs/ directory of the CPAN.pm distribution to get a quick start into the prefs system.</source>
          <target state="translated">CPAN.pm может хранить настраиваемые среды сборки,основанные на регулярных выражениях для имен дистрибутивов.Это YAML файлы,где стандартные опции для CPAN.pm и окружения могут быть переопределены,а также могут храниться диалоговые последовательности,которые позже могут быть выполнены объектом Expect.pm.Дистрибутив CPAN.pm поставляется с некоторыми сборными YAML файлами,которые охватывают примерные дистрибутивы,которые могут быть использованы в качестве чертежей для хранения ваших собственных префиксов.Пожалуйста,ознакомьтесь с каталогом distroprefs/дистрибутива CPAN.pm,чтобы получить быстрый старт в систему префисов.</target>
        </trans-unit>
        <trans-unit id="fe8999832e8cb3e24c5ee5786438c2eb7045f528" translate="yes" xml:space="preserve">
          <source>CPAN.pm changes the current working directory often and needs to determine its own current working directory. By default it uses Cwd::cwd, but if for some reason this doesn't work on your system, configure alternatives according to the following table:</source>
          <target state="translated">CPAN.pm часто изменяет текущую рабочую директорию и должен определить свою собственную текущую рабочую директорию.По умолчанию он использует Cwd::cwd,но если по какой-то причине это не работает в вашей системе,настройте альтернативы согласно следующей таблице:</target>
        </trans-unit>
        <trans-unit id="110953d17daedc5ab884b800e79aa6017f230c3c" translate="yes" xml:space="preserve">
          <source>CPAN.pm changes the current working directory often and needs to determine its own current working directory. Per default it uses Cwd::cwd but if this doesn't work on your system for some reason, alternatives can be configured according to the following table:</source>
          <target state="translated">CPAN.pm часто изменяет текущую рабочую директорию и должен определить свою собственную текущую рабочую директорию.По умолчанию он использует Cwd::cwd,но если по какой-то причине это не работает в вашей системе,альтернативы могут быть сконфигурированы в соответствии со следующей таблицей:</target>
        </trans-unit>
        <trans-unit id="316ae9b3e749a01c06c792f2cfcc80c4846f19f6" translate="yes" xml:space="preserve">
          <source>CPAN.pm ignores SIGPIPE. If the user sets &lt;code&gt;inactivity_timeout&lt;/code&gt; , a SIGALRM is used during the run of the &lt;code&gt;perl Makefile.PL&lt;/code&gt; or &lt;code&gt;perl
Build.PL&lt;/code&gt; subprocess. A SIGALRM is also used during module version parsing, and is controlled by &lt;code&gt;version_timeout&lt;/code&gt; .</source>
          <target state="translated">CPAN.pm игнорирует SIGPIPE. Если пользователь устанавливает &lt;code&gt;inactivity_timeout&lt;/code&gt; , во время выполнения подпроцесса &lt;code&gt;perl Makefile.PL&lt;/code&gt; или &lt;code&gt;perl Build.PL&lt;/code&gt; . SIGALRM также используется во время синтаксического анализа версии модуля и управляется &lt;code&gt;version_timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="190c010b5387bba4ea2b42cb563bd4dbf19face7" translate="yes" xml:space="preserve">
          <source>CPAN.pm installs signal handlers for SIGINT and SIGTERM. While you are in the cpan-shell, it is intended that you can press &lt;code&gt;^C&lt;/code&gt; anytime and return to the cpan-shell prompt. A SIGTERM will cause the cpan-shell to clean up and leave the shell loop. You can emulate the effect of a SIGTERM by sending two consecutive SIGINTs, which usually means by pressing &lt;code&gt;^C&lt;/code&gt; twice.</source>
          <target state="translated">CPAN.pm устанавливает обработчики сигналов для SIGINT и SIGTERM. Предполагается, что пока вы находитесь в cpan-shell, вы можете нажать &lt;code&gt;^C&lt;/code&gt; любое время и вернуться к приглашению cpan-shell. SIGTERM заставит cpan-shell очиститься и покинуть цикл оболочки. Вы можете имитировать эффект SIGTERM, посылая два последовательных SIGINTs, что обычно означает, нажав &lt;code&gt;^C&lt;/code&gt; дважды.</target>
        </trans-unit>
        <trans-unit id="74c9de97c18d0f26d42b5dbeeae85623299ae97e" translate="yes" xml:space="preserve">
          <source>CPAN.pm is regularly tested to run under 5.005 and assorted newer versions. It is getting more and more difficult to get the minimal prerequisites working on older perls. It is close to impossible to get the whole Bundle::CPAN working there. If you're in the position to have only these old versions, be advised that CPAN is designed to work fine without the Bundle::CPAN installed.</source>
          <target state="translated">CPAN.pm регулярно тестируется на работу под 5.005 и различные более новые версии.Становится все труднее получить минимальные предпосылки для работы над старыми перлами.Почти невозможно заставить работать весь пакет::CPAN.Если у вас есть возможность работать только со старыми версиями,советуем вам обратить внимание на то,что CPAN спроектирован так,чтобы отлично работать без установки Bundle::CPAN.</target>
        </trans-unit>
        <trans-unit id="9dede3b8abe89d4a573f74c512265cae8a956106" translate="yes" xml:space="preserve">
          <source>CPAN.pm will then fetch the index files from one of the CPAN sites that come at the beginning of urllist. It will later check for each module to see whether there is a local copy of the most recent version.</source>
          <target state="translated">CPAN.pm затем получит файлы индекса с одного из CPAN сайтов,которые приходят в начале urllist'a.Позже он проверит для каждого модуля,есть ли локальная копия последней версии.</target>
        </trans-unit>
        <trans-unit id="2867ea997c1ecbeaa882b9d340cc76b94bdae145" translate="yes" xml:space="preserve">
          <source>CPAN.pm works nicely without network access, too. If you maintain machines that are not networked at all, you should consider working with &lt;code&gt;file:&lt;/code&gt; URLs. You'll have to collect your modules somewhere first. So you might use CPAN.pm to put together all you need on a networked machine. Then copy the $CPAN::Config-&amp;gt;{keep_source_where} (but not $CPAN::Config-&amp;gt;{build_dir}) directory on a floppy. This floppy is kind of a personal CPAN. CPAN.pm on the non-networked machines works nicely with this floppy. See also below the paragraph about CD-ROM support.</source>
          <target state="translated">CPAN.pm прекрасно работает и без доступа к сети. Если вы обслуживаете машины, которые вообще не подключены к сети, вам следует подумать о работе с URL-адресами &lt;code&gt;file:&lt;/code&gt; . Вам сначала нужно будет где-нибудь собрать свои модули. Таким образом, вы можете использовать CPAN.pm, чтобы собрать все, что вам нужно, на сетевой машине. Затем скопируйте каталог $ CPAN :: Config -&amp;gt; {keep_source_where} (но не $ CPAN :: Config -&amp;gt; {build_dir}) на дискету. Эта дискета - своего рода личный CPAN. CPAN.pm на машинах, не подключенных к сети, прекрасно работает с этой дискетой. См. Также ниже абзац о поддержке CD-ROM.</target>
        </trans-unit>
        <trans-unit id="64b36001560d3fac13b876398b3f1a59def99f26" translate="yes" xml:space="preserve">
          <source>CPAN::Author, CPAN::Bundle, CPAN::Module, and CPAN::Distribution inherit this method. It prints the data structure associated with an object. Useful for debugging. Note: the data structure is considered internal and thus subject to change without notice.</source>
          <target state="translated">CPAN::Автор,CPAN::Пакет,CPAN::Модуль,и CPAN::Распределение наследует этот метод.Он печатает структуру данных,связанную с объектом.Полезен для отладки.Замечание:структура данных считается внутренней и поэтому может быть изменена без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="2446a32cd0ff78f16b4c1f3133beeac56c5f5898" translate="yes" xml:space="preserve">
          <source>CPAN::Debug</source>
          <target state="translated">CPAN::Debug</target>
        </trans-unit>
        <trans-unit id="3cc1933835ca0280363968e304f73c0a15112e4c" translate="yes" xml:space="preserve">
          <source>CPAN::Debug - internal debugging for CPAN.pm</source>
          <target state="translated">CPAN::Отладка-внутренняя отладка для CPAN.pm</target>
        </trans-unit>
        <trans-unit id="8d7cc75d89d8c3bb9bd4511533d5eed2ec9484af" translate="yes" xml:space="preserve">
          <source>CPAN::Distroprefs</source>
          <target state="translated">CPAN::Distroprefs</target>
        </trans-unit>
        <trans-unit id="80ea37d944a5515b88dd77f972d31b6df3134129" translate="yes" xml:space="preserve">
          <source>CPAN::Distroprefs -- read and match distroprefs</source>
          <target state="translated">Дистро-транскрипторы-читать и сопоставлять дистро-транскрипторы...</target>
        </trans-unit>
        <trans-unit id="5bcd04a88f701c432b5a1ff104f6c8a0d02960ee" translate="yes" xml:space="preserve">
          <source>CPAN::Distroprefs::Pref objects represent individual distroprefs documents. They are constructed automatically as part of &lt;code&gt;success&lt;/code&gt; results from &lt;code&gt;find()&lt;/code&gt; .</source>
          <target state="translated">Объекты CPAN :: Distroprefs :: Pref представляют отдельные документы distroprefs. Они создаются автоматически как часть результатов &lt;code&gt;success&lt;/code&gt; &lt;code&gt;find()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2f3edd9da9fa97ece6eafd83608b4b243b452a0" translate="yes" xml:space="preserve">
          <source>CPAN::FirstTime</source>
          <target state="translated">CPAN::FirstTime</target>
        </trans-unit>
        <trans-unit id="78dc35292a9ffa84e8778b2bc228974b2a98a06d" translate="yes" xml:space="preserve">
          <source>CPAN::FirstTime - Utility for CPAN::Config file Initialization</source>
          <target state="translated">CPAN::FirstTime-Утилита для CPAN::Config file Initialization (Инициализация конфигурационного файла)</target>
        </trans-unit>
        <trans-unit id="e737cd6e08d40b3a667635e5cb83727e8679bd6f" translate="yes" xml:space="preserve">
          <source>CPAN::FirstTime::init()</source>
          <target state="translated">CPAN::FirstTime::init()</target>
        </trans-unit>
        <trans-unit id="85ea935cb2e14666fd64cb017917705b1d6fede5" translate="yes" xml:space="preserve">
          <source>CPAN::HandleConfig</source>
          <target state="translated">CPAN::HandleConfig</target>
        </trans-unit>
        <trans-unit id="24310cde90de0fb64790326e96a727677d4e7601" translate="yes" xml:space="preserve">
          <source>CPAN::HandleConfig - internal configuration handling for CPAN.pm</source>
          <target state="translated">CPAN::HandleConfig-внутренняя обработка конфигурации для CPAN.pm</target>
        </trans-unit>
        <trans-unit id="64057ceb28c792089f8152cbd3da3bcade5223e9" translate="yes" xml:space="preserve">
          <source>CPAN::Kwalify</source>
          <target state="translated">CPAN::Kwalify</target>
        </trans-unit>
        <trans-unit id="a2e5f91adff087cfa00a37e97d84ee7727243629" translate="yes" xml:space="preserve">
          <source>CPAN::Kwalify - Interface between CPAN.pm and Kwalify.pm</source>
          <target state="translated">CPAN::Kwalify-интерфейс между CPAN.pm и Kwalify.pm</target>
        </trans-unit>
        <trans-unit id="8dcc2e6edc3eadab9e78355482bf7252fe18e3ff" translate="yes" xml:space="preserve">
          <source>CPAN::Nox</source>
          <target state="translated">CPAN::Nox</target>
        </trans-unit>
        <trans-unit id="0b944fc036709f45e2abf674dd21a2de916a71a8" translate="yes" xml:space="preserve">
          <source>CPAN::Nox - Wrapper around CPAN.pm without using any XS module</source>
          <target state="translated">CPAN::Nox-обертка вокруг CPAN.pm без использования какого-либо модуля XS</target>
        </trans-unit>
        <trans-unit id="cff38ba28ab3cfea4d0464d49309db8969faf6ef" translate="yes" xml:space="preserve">
          <source>CPAN::Queue</source>
          <target state="translated">CPAN::Queue</target>
        </trans-unit>
        <trans-unit id="e3a09726a6ba57409ab3f10ea87af46541484c9f" translate="yes" xml:space="preserve">
          <source>CPAN::Queue - internal queue support for CPAN.pm</source>
          <target state="translated">CPAN::Очередь-поддержка внутренней очереди для CPAN.pm</target>
        </trans-unit>
        <trans-unit id="349e923ec9cc993c3c5c400728886a4cd805bc87" translate="yes" xml:space="preserve">
          <source>CPAN::SQLite is a layer between the index files that are downloaded from the CPAN and CPAN.pm that speeds up metadata queries and reduces memory consumption of CPAN.pm considerably.</source>
          <target state="translated">CPAN::SQLite-это прослойка между индексными файлами,которые загружаются с CPAN и CPAN.pm,которая ускоряет запросы метаданных и значительно уменьшает потребление памяти CPAN.pm.</target>
        </trans-unit>
        <trans-unit id="b47dcd8919f1f65cec06b9c2d7f965e75c2b1219" translate="yes" xml:space="preserve">
          <source>CPAN::Shell</source>
          <target state="translated">CPAN::Shell</target>
        </trans-unit>
        <trans-unit id="23798a7b15a5d75dd8c6bdfc98d7078c277c16e8" translate="yes" xml:space="preserve">
          <source>CPAN::Tarzip</source>
          <target state="translated">CPAN::Tarzip</target>
        </trans-unit>
        <trans-unit id="814fdd5396978409421856089181c07c58c4c4cf" translate="yes" xml:space="preserve">
          <source>CPAN::Tarzip - internal handling of tar archives for CPAN.pm</source>
          <target state="translated">CPAN::Tarzip-внутренняя обработка смоляных архивов для CPAN.pm</target>
        </trans-unit>
        <trans-unit id="4901e7156541948e262f8f5d98071d2c7b3b87e3" translate="yes" xml:space="preserve">
          <source>CPAN::Version</source>
          <target state="translated">CPAN::Version</target>
        </trans-unit>
        <trans-unit id="30cd4b0821f4765c0d8295e7726cfae9b7fab40e" translate="yes" xml:space="preserve">
          <source>CPAN::Version - utility functions to compare CPAN versions</source>
          <target state="translated">CPAN::Версия-функции утилиты для сравнения версий CPAN</target>
        </trans-unit>
        <trans-unit id="ec4a1634792e6ece098aa09e476bc1d9ef4268d0" translate="yes" xml:space="preserve">
          <source>CPAN::anycwd($path): Note on config variable getcwd</source>
          <target state="translated">CPAN::anycwd($path):Обратите внимание на config-переменную getcwd</target>
        </trans-unit>
        <trans-unit id="6bf4457df819c8d2b082c5c17c609ae27bb6a63b" translate="yes" xml:space="preserve">
          <source>CPAN::shell([$prompt, $command]) Starting Interactive Mode</source>
          <target state="translated">CPAN::shell([$prompt,$command])Запуск интерактивного режима</target>
        </trans-unit>
        <trans-unit id="4ffdbed7690fc2f38db76dd54cf504d79c06ee88" translate="yes" xml:space="preserve">
          <source>CPANMINUS</source>
          <target state="translated">CPANMINUS</target>
        </trans-unit>
        <trans-unit id="0300a08f28f15d52b8c0f31d868e80fadb408109" translate="yes" xml:space="preserve">
          <source>CPANPLUS</source>
          <target state="translated">CPANPLUS</target>
        </trans-unit>
        <trans-unit id="4a2648ee2c7cdfe4f04963290c94c0f73b1a0296" translate="yes" xml:space="preserve">
          <source>CPU seconds is, in UNIX terms, the user time plus the system time of the process itself, as opposed to the real (wallclock) time and the time spent by the child processes. Less than 0.1 seconds is not accepted (-0.01 as the count, for example, will cause a fatal runtime exception).</source>
          <target state="translated">Процессорные секунды-это,с точки зрения UNIX,время пользователя плюс системное время самого процесса,в отличие от реального (настенного)времени и времени,затрачиваемого дочерними процессами.Меньше 0.1 секунды не принимается (-0.01,так как счет,например,приведет к фатальному исключению времени выполнения).</target>
        </trans-unit>
        <trans-unit id="8eabeaf9c51703b78032cab60996509e2a9fbc29" translate="yes" xml:space="preserve">
          <source>CPU time</source>
          <target state="translated">процессорное время</target>
        </trans-unit>
        <trans-unit id="ceae75038d81d55818f9c7099cc499bef29e500c" translate="yes" xml:space="preserve">
          <source>CREATING A SOURCE FILTER AS A SEPARATE EXECUTABLE</source>
          <target state="translated">СОЗДАНИЕ ИСХОДНОГО ФИЛЬТРА В ВИДЕ ОТДЕЛЬНОГО ИСПОЛНЯЕМОГО ФАЙЛА</target>
        </trans-unit>
        <trans-unit id="8f5fc61f95a802dc2f2c87590b81afa3dc2d9f36" translate="yes" xml:space="preserve">
          <source>CREATION</source>
          <target state="translated">CREATION</target>
        </trans-unit>
        <trans-unit id="338f52baadf832c435e6693a6b1e770c010b5681" translate="yes" xml:space="preserve">
          <source>CREDITS</source>
          <target state="translated">CREDITS</target>
        </trans-unit>
        <trans-unit id="4b79357f1f7c4a8b8c01c419e8cd32de82816fa7" translate="yes" xml:space="preserve">
          <source>CROSS-COMPILATION</source>
          <target state="translated">CROSS-COMPILATION</target>
        </trans-unit>
        <trans-unit id="5ff3994b10db2ad29d009f4ea60878f1dbf5c21e" translate="yes" xml:space="preserve">
          <source>CURRENT BUILD INSTRUCTIONS</source>
          <target state="translated">ТЕКУЩИЕ ИНСТРУКЦИИ ПО СТРОИТЕЛЬСТВУ</target>
        </trans-unit>
        <trans-unit id="f132b454c07ac52e508f217f0add8bd7ce5fa710" translate="yes" xml:space="preserve">
          <source>CUSTOM ALIASES</source>
          <target state="translated">КЛЮЧЕВЫЕ АЛИЗЫ</target>
        </trans-unit>
        <trans-unit id="566216bf858af2148e9f96bcf3257d2d54bc9983" translate="yes" xml:space="preserve">
          <source>CUSTOM TRANSLATORS</source>
          <target state="translated">ЗАКАЗНЫЕ ПЕРЕВОДЧИКИ</target>
        </trans-unit>
        <trans-unit id="095d16308375c60700e556f5b8f5796ca1925951" translate="yes" xml:space="preserve">
          <source>CV Manipulation Functions</source>
          <target state="translated">CV-функции манипуляции</target>
        </trans-unit>
        <trans-unit id="2b943e6acf60a6fb581a6a5d00e315120f0f582e" translate="yes" xml:space="preserve">
          <source>CV reference counts and CvOUTSIDE</source>
          <target state="translated">Количество ссылок на резюме и CVOUTSIDE</target>
        </trans-unit>
        <trans-unit id="0c42c13d714fd16e36f14c85f7c7898781594d12" translate="yes" xml:space="preserve">
          <source>CV's can have CvPADLIST(cv) set to point to a PADLIST. This is the CV's scratchpad, which stores lexical variables and opcode temporary and per-thread values.</source>
          <target state="translated">CV могут иметь CvPADLIST(cv),заданный в качестве точки для PADLIST.Это блокнот CV,в котором хранятся лексические переменные и опкодовые временные и потокодовые значения.</target>
        </trans-unit>
        <trans-unit id="ddb00c36c6d4c35daa72fdd0b44d9c728b39bcfa" translate="yes" xml:space="preserve">
          <source>C_FILE</source>
          <target state="translated">C_FILE</target>
        </trans-unit>
        <trans-unit id="575569dbcc2f1973e29e715e813fbf5f343f083a" translate="yes" xml:space="preserve">
          <source>C_SUBNAME</source>
          <target state="translated">C_SUBNAME</target>
        </trans-unit>
        <trans-unit id="49dd0ee71a9f8c8e59007d14c22f8f02a232442a" translate="yes" xml:space="preserve">
          <source>Cache Manager</source>
          <target state="translated">менеджер кэша</target>
        </trans-unit>
        <trans-unit id="a9fca3e43fd40d529fa1de2b124c4181a70bcb17" translate="yes" xml:space="preserve">
          <source>Cache metadata (yes/no)?</source>
          <target state="translated">Кэшировать метаданные (да/нет)?</target>
        </trans-unit>
        <trans-unit id="36e2cd82188ed6fa0e4b613f6e68c50033b4f7eb" translate="yes" xml:space="preserve">
          <source>Cache size for build directory (in MB)?</source>
          <target state="translated">Размер кэша для каталога сборки (в мегабайтах)?</target>
        </trans-unit>
        <trans-unit id="60790f7c84170a8b87051d7e857118ffeb0465ee" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="translated">Caching</target>
        </trans-unit>
        <trans-unit id="4216adaca29295eaea61f0fa24c35227b02c6845" translate="yes" xml:space="preserve">
          <source>Caching and deferred writing are inappropriate if you want the same file to be accessed simultaneously from more than one process. Other optimizations performed internally by this module are also incompatible with concurrent access. A future version of this module will support a &lt;code&gt;concurrent =&amp;gt; 1&lt;/code&gt; option that enables safe concurrent access.</source>
          <target state="translated">Кэширование и отложенная запись неуместны, если вы хотите, чтобы к одному и тому же файлу можно было обращаться одновременно из более чем одного процесса. Другие оптимизации, выполняемые внутри этого модуля, также несовместимы с одновременным доступом. В будущей версии этого модуля будет поддерживаться опция &lt;code&gt;concurrent =&amp;gt; 1&lt;/code&gt; , обеспечивающая безопасный одновременный доступ.</target>
        </trans-unit>
        <trans-unit id="66d425679370669a060d7b12eda4e17f2fb01bea" translate="yes" xml:space="preserve">
          <source>Caching is off by default, as it can (usually slightly) decrease accuracy and does not usually noticeably affect runtimes.</source>
          <target state="translated">Кэширование отключено по умолчанию,так как оно может (обычно слегка)снизить точность и обычно не оказывает заметного влияния на время выполнения.</target>
        </trans-unit>
        <trans-unit id="81c8c72b5e27066945946d422a802165663f5930" translate="yes" xml:space="preserve">
          <source>Caesarean ciphers</source>
          <target state="translated">кесаревы шифры</target>
        </trans-unit>
        <trans-unit id="f76942716d4c2528f7cd94b85c359f606e3e15f5" translate="yes" xml:space="preserve">
          <source>Calculate PI to N digits (including the 3 before the dot). The result is rounded according to the current rounding mode, which defaults to &quot;even&quot;.</source>
          <target state="translated">Рассчитайте от PI до N цифр (включая 3 перед точкой).Результат округляется в соответствии с текущим режимом округления,который по умолчанию имеет значение &quot;равномерный&quot;.</target>
        </trans-unit>
        <trans-unit id="ba16d2dfddf095e54ae25bc218255c71ce5afa48" translate="yes" xml:space="preserve">
          <source>Calculate digests of files</source>
          <target state="translated">Рассчитать дайджесты файлов</target>
        </trans-unit>
        <trans-unit id="6edac12b6f864eee888f0c08f462e84fff153f20" translate="yes" xml:space="preserve">
          <source>Calculate the N'th root of $x.</source>
          <target state="translated">Вычислите N'th корень $x.</target>
        </trans-unit>
        <trans-unit id="f7dc98fbb7b43c855859dedd630f45c56ad2bc12" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tangens of $x, modifying $x in place.</source>
          <target state="translated">Вычислите касательные дуги $x,изменяя $x на месте.</target>
        </trans-unit>
        <trans-unit id="49fd3457ed632359ca2520e72d6632cb278658b7" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tangens of &lt;code&gt;$y&lt;/code&gt; divided by &lt;code&gt;$x&lt;/code&gt; , modifying $y in place.</source>
          <target state="translated">Вычислите касательную дугу &lt;code&gt;$y&lt;/code&gt; разделенную на &lt;code&gt;$x&lt;/code&gt; , изменяя $ y на месте.</target>
        </trans-unit>
        <trans-unit id="4f94eb38f838a42af1307713af2f7a6e7542c447" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tanges of $x, modifying $x in place. See also &lt;a href=&quot;#batan2()&quot;&gt;batan2()&lt;/a&gt;.</source>
          <target state="translated">Вычислите дугу $ x, изменив $ x на месте. См. Также &lt;a href=&quot;#batan2()&quot;&gt;batan2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="982777a50f0c3516dc7b84208808f54a3e72dbea" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tanges of &lt;code&gt;$y&lt;/code&gt; divided by &lt;code&gt;$x&lt;/code&gt; , modifying $y in place. See also &lt;a href=&quot;#batan()&quot;&gt;batan()&lt;/a&gt;.</source>
          <target state="translated">Вычислите дугу &lt;code&gt;$y&lt;/code&gt; разделенную на &lt;code&gt;$x&lt;/code&gt; , изменив $ y на месте. См. Также &lt;a href=&quot;#batan()&quot;&gt;batan ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8312c24fc6c367f7ba0626e0df9859355b1ba267" translate="yes" xml:space="preserve">
          <source>Calculate the cosinus of $x, modifying $x in place.</source>
          <target state="translated">Рассчитайте косинус $x,изменяя $x на месте.</target>
        </trans-unit>
        <trans-unit id="01c8c185c9d12673e45f702a2f9d36653ab1f38e" translate="yes" xml:space="preserve">
          <source>Calculate the sinus of $x, modifying $x in place.</source>
          <target state="translated">Рассчитайте синус $x,изменяя $x на месте.</target>
        </trans-unit>
        <trans-unit id="049cf6157b6ee1c242c2800800be8ef0165625bc" translate="yes" xml:space="preserve">
          <source>Calculate the square root of $x.</source>
          <target state="translated">Вычислите квадратный корень из $x.</target>
        </trans-unit>
        <trans-unit id="d5c08bd3d571674414934d46e315d05c1e757d23" translate="yes" xml:space="preserve">
          <source>Calculates the N'th root of &lt;code&gt;$x&lt;/code&gt; .</source>
          <target state="translated">Вычисляет корень N-й степени из &lt;code&gt;$x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2470f12a5e304e7422bd1a2f8c0e1abfd2982a1d" translate="yes" xml:space="preserve">
          <source>Calculates the binomial coefficient n over k, also called the &quot;choose&quot; function. The result is equivalent to:</source>
          <target state="translated">Вычисляет биномиальный коэффициент n поверх k,также называемый функцией &quot;выбора&quot;.Результат эквивалентен:</target>
        </trans-unit>
        <trans-unit id="34e97fbd408b8eed5635c834b2854c0be8cb6dbf" translate="yes" xml:space="preserve">
          <source>Calculates the expression &lt;code&gt;e ** $x&lt;/code&gt; where &lt;code&gt;e&lt;/code&gt; is Euler's number.</source>
          <target state="translated">Вычисляет выражение &lt;code&gt;e ** $x&lt;/code&gt; где &lt;code&gt;e&lt;/code&gt; - число Эйлера.</target>
        </trans-unit>
        <trans-unit id="416b7a310945db184afb57b971e8e098dac1fa18" translate="yes" xml:space="preserve">
          <source>Calculates the factorial of $x. For instance:</source>
          <target state="translated">Вычисляет факториал в $x.Например:</target>
        </trans-unit>
        <trans-unit id="62fb105cdba4cb5918fb1ee8f5656956e6874fed" translate="yes" xml:space="preserve">
          <source>Calculates the maximum command size the OS can exec. Effectively, this is the max size of a shell command line.</source>
          <target state="translated">Вычисляет максимальный размер команды,которую может выполнить операционная система.По сути,это максимальный размер командной строки оболочки.</target>
        </trans-unit>
        <trans-unit id="fd42bdc4343d55afb259e24e240b92c18465e03e" translate="yes" xml:space="preserve">
          <source>Calculates two integers A and B so that A/B is equal to &lt;code&gt;e ** $x&lt;/code&gt; , where &lt;code&gt;e&lt;/code&gt; is Euler's number.</source>
          <target state="translated">Вычисляет два целых числа A и B так, чтобы A / B было равно &lt;code&gt;e ** $x&lt;/code&gt; , где &lt;code&gt;e&lt;/code&gt; - число Эйлера.</target>
        </trans-unit>
        <trans-unit id="0037c314d771bc8eaa4953dbcb986cc7bf547ac0" translate="yes" xml:space="preserve">
          <source>Calendar of Perl Events</source>
          <target state="translated">Календарь Перл событий</target>
        </trans-unit>
        <trans-unit id="afd632ce2019ef9ec38232fb5195ec297239dcfa" translate="yes" xml:space="preserve">
          <source>Calendar time for December 12, 1995, at 10:30 am.</source>
          <target state="translated">Календарное время 12 декабря 1995 года,в 10:30 утра.</target>
        </trans-unit>
        <trans-unit id="a7a5d5cba867fa341140666997ab9bfd6cadc129" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;&lt;a href=&quot;../functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; and return a list of two sockets created, or an empty list on failure.</source>
          <target state="translated">Вызовите &lt;code&gt;&lt;a href=&quot;../functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; и верните список из двух созданных сокетов или пустой список в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="6b6b5d06a5f85554364bcd897b8c29e92093294d" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;start&lt;/code&gt; immediately before adding any results to the aggregator. Among other times it records the start time for the test run.</source>
          <target state="translated">Вызовите &lt;code&gt;start&lt;/code&gt; непосредственно перед добавлением результатов в агрегатор. Среди прочего, он записывает время начала тестового прогона.</target>
        </trans-unit>
        <trans-unit id="bab90a1ca7bed318a773f1cd868353d680619794" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;stop&lt;/code&gt; immediately after adding all test results to the aggregator.</source>
          <target state="translated">Вызов &lt;code&gt;stop&lt;/code&gt; сразу после добавления всех результатов тестирования в агрегатор.</target>
        </trans-unit>
        <trans-unit id="e0f1fdfb2231f4e8ba5ad2172306eb394d414cf5" translate="yes" xml:space="preserve">
          <source>Call all the registered block hooks for type</source>
          <target state="translated">Вызовите все зарегистрированные блок-крючки для типа</target>
        </trans-unit>
        <trans-unit id="d63876fa9d1b98c3c63563764cf54bc05c244034" translate="yes" xml:space="preserve">
          <source>Call the system level poll routine. If TIMEOUT is not specified then the call will block. Returns the number of handles which had events happen, or -1 on error.</source>
          <target state="translated">Позвоните в программу опроса на системном уровне.Если TIMEOUT не указан,вызов будет заблокирован.Возвращает количество дескрипторов,на которых произошли события,или -1 по ошибке.</target>
        </trans-unit>
        <trans-unit id="707d41981449a7ac1f49727761a071399e9047fa" translate="yes" xml:space="preserve">
          <source>Call this function to signal to a stash that it has been assigned to another spot in the stash hierarchy. &lt;code&gt;stash&lt;/code&gt; is the stash that has been assigned. &lt;code&gt;oldstash&lt;/code&gt; is the stash it replaces, if any. &lt;code&gt;gv&lt;/code&gt; is the glob that is actually being assigned to.</source>
          <target state="translated">Вызовите эту функцию, чтобы сообщить тайнику, что он был назначен другому месту в иерархии тайника. &lt;code&gt;stash&lt;/code&gt; - это тайник, который был назначен. &lt;code&gt;oldstash&lt;/code&gt; - это тайник, который он заменяет, если таковой имеется. &lt;code&gt;gv&lt;/code&gt; - это глобус, которому фактически назначается.</target>
        </trans-unit>
        <trans-unit id="897a2466922f6de52dc65c0d77a98544c7fb349a" translate="yes" xml:space="preserve">
          <source>CallSubPV</source>
          <target state="translated">CallSubPV</target>
        </trans-unit>
        <trans-unit id="ade75b74553b436dc4fbae17ff916436ba41a1b5" translate="yes" xml:space="preserve">
          <source>CallSubSV</source>
          <target state="translated">CallSubSV</target>
        </trans-unit>
        <trans-unit id="9c55daf6e61f9dc1556f1ec913e0ca99b7e0ea38" translate="yes" xml:space="preserve">
          <source>Callback Functions</source>
          <target state="translated">Функции обратного вызова</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="e2492d7f90f5ff291923cb9e3820556cd26e7081" translate="yes" xml:space="preserve">
          <source>Callbacks may also be added like this:</source>
          <target state="translated">Обратные вызовы также могут быть добавлены вот так:</target>
        </trans-unit>
        <trans-unit id="0b30b959e54d6077a0087fde2fbe95f232d8abe1" translate="yes" xml:space="preserve">
          <source>Called after debug API inits itself.</source>
          <target state="translated">Вызывается после отладочного API.</target>
        </trans-unit>
        <trans-unit id="7ce9b93a40160290fff58c32f9bc646588fa275b" translate="yes" xml:space="preserve">
          <source>Called before &lt;code&gt;process_args&lt;/code&gt; to prepend the contents of an rc file to the options.</source>
          <target state="translated">Вызывается перед &lt;code&gt;process_args&lt;/code&gt; для добавления содержимого файла rc к параметрам.</target>
        </trans-unit>
        <trans-unit id="712b31fe99457d34e411f45757dac056dcd534cd" translate="yes" xml:space="preserve">
          <source>Called by &lt;a href=&quot;htmlbatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt; so that the class has a chance to initialize the converter. Internally it sets the &lt;code&gt;batch_mode&lt;/code&gt; property to true and sets &lt;code&gt;batch_mode_current_level()&lt;/code&gt; , but Pod::Simple::XHTML does not currently use those features. Subclasses might, though.</source>
          <target state="translated">Вызывается &lt;a href=&quot;htmlbatch&quot;&gt;Pod :: Simple :: HTMLBatch,&lt;/a&gt; чтобы у класса была возможность инициализировать преобразователь. Внутренне он устанавливает для свойства &lt;code&gt;batch_mode&lt;/code&gt; значение true и устанавливает &lt;code&gt;batch_mode_current_level()&lt;/code&gt; , но Pod :: Simple :: XHTML в настоящее время не использует эти функции. Однако подклассы могут.</target>
        </trans-unit>
        <trans-unit id="d44d9ba6e8c865877532df9753c9657e69186427" translate="yes" xml:space="preserve">
          <source>Called by &lt;code&gt;close_test&lt;/code&gt; to clear the line showing test progress, or the parallel test ruler, prior to printing the final test result.</source>
          <target state="translated">Вызывается &lt;code&gt;close_test&lt;/code&gt; для очистки строки, показывающей ход теста, или параллельной линейки теста перед печатью окончательного результата теста.</target>
        </trans-unit>
        <trans-unit id="83de9bce1b7b2bd7be455db4ac0ff451b79c596a" translate="yes" xml:space="preserve">
          <source>Called by Perl when it is freeing a regexp pattern so that the engine can release any resources pointed to by the &lt;code&gt;pprivate&lt;/code&gt; member of the &lt;code&gt;regexp&lt;/code&gt; structure. This is only responsible for freeing private data; Perl will handle releasing anything else contained in the &lt;code&gt;regexp&lt;/code&gt; structure.</source>
          <target state="translated">Вызывается Perl, когда он освобождает шаблон регулярного выражения, чтобы механизм мог освободить любые ресурсы, на которые &lt;code&gt;pprivate&lt;/code&gt; член pprivate структуры &lt;code&gt;regexp&lt;/code&gt; . Это отвечает только за освобождение личных данных; Perl будет обрабатывать освобождение всего остального, что содержится в структуре &lt;code&gt;regexp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="192f5069ea69d61876f992ae04cbfebd42365fdf" translate="yes" xml:space="preserve">
          <source>Called by Test::Harness before any test output is generated.</source>
          <target state="translated">Вызывается Test::Harness до того,как будет сгенерирован любой результат теста.</target>
        </trans-unit>
        <trans-unit id="252637df9babf3148f5feaeda72912f2045c6976" translate="yes" xml:space="preserve">
          <source>Called by init_main.</source>
          <target state="translated">Вызывается init_main.</target>
        </trans-unit>
        <trans-unit id="4cdb9b50857f3ef3652ef325b6cf3d72fa3622a7" translate="yes" xml:space="preserve">
          <source>Called by init_main. Initializes PERL_*</source>
          <target state="translated">Вызывается init_main.Инициализирует PERL_*</target>
        </trans-unit>
        <trans-unit id="803f7311292b6dbe520d9001028a74a3740ad58e" translate="yes" xml:space="preserve">
          <source>Called by init_main. Sets up ABSPERL, PERL, FULLPERL and all the *PERLRUN* permutations.</source>
          <target state="translated">Вызывается init_main.Устанавливает ABSPERL,PERL,FULLPERL и все перестановки *PERLRUN*.</target>
        </trans-unit>
        <trans-unit id="3f68bdd2c8090ffda024fb7a301dcec75150221e" translate="yes" xml:space="preserve">
          <source>Called by init_main. Sets up all INSTALL_* variables (except INSTALLDIRS) and *PREFIX.</source>
          <target state="translated">Вызывается init_main.Устанавливает все переменные INSTALL_*(кроме INSTALLDIRS)и *PREFIX.</target>
        </trans-unit>
        <trans-unit id="e5e9ec66a22e81bfffe8ba34ae133177fa3495b6" translate="yes" xml:space="preserve">
          <source>Called by init_main. Sets up all INST_* variables except those related to XS code. Those are handled in init_xs.</source>
          <target state="translated">Вызывается init_main.Устанавливает все переменные INST_*,кроме тех,которые относятся к коду XS.Они обрабатываются в init_xs.</target>
        </trans-unit>
        <trans-unit id="1f0c75a0f13f487e51a8d6aa8f296a671eded4fd" translate="yes" xml:space="preserve">
          <source>Called by init_others, and calls ext ExtUtils::Liblist. See &lt;a href=&quot;liblist&quot;&gt;ExtUtils::Liblist&lt;/a&gt; for details.</source>
          <target state="translated">Вызывается init_others и вызывает ext ExtUtils :: Liblist. См. Подробности в &lt;a href=&quot;liblist&quot;&gt;ExtUtils :: Liblist&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa989d1b35e9dfa1af106d6dbfbb5e0924c7a182" translate="yes" xml:space="preserve">
          <source>Called by staticmake. Defines how to write the Makefile to produce a static new perl.</source>
          <target state="translated">Вызывается статическим мастером.Определяет,как записать Makefile,чтобы получить новый статический perl.</target>
        </trans-unit>
        <trans-unit id="a7da98d82f41c03c342a989f11faab94693c6c57" translate="yes" xml:space="preserve">
          <source>Called by the harness for each line of TAP it receives.</source>
          <target state="translated">Вызывается жгутом для каждой линии TAP,которую он получает.</target>
        </trans-unit>
        <trans-unit id="567cd3e87bf8931281fcaa23e35e2da3fe139b11" translate="yes" xml:space="preserve">
          <source>Called by the harness when it needs to create a &lt;a href=&quot;parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;. Override in a subclass to provide an alternative scheduler. &lt;code&gt;make_scheduler&lt;/code&gt; is passed the list of tests that was passed to &lt;code&gt;aggregate_tests&lt;/code&gt; .</source>
          <target state="translated">Вызывается жгутом, когда ему нужно создать &lt;a href=&quot;parser/scheduler&quot;&gt;TAP :: Parser :: Scheduler&lt;/a&gt; . Переопределить в подклассе, чтобы предоставить альтернативный планировщик. &lt;code&gt;make_scheduler&lt;/code&gt; передается список тестов, который был передан в &lt;code&gt;aggregate_tests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="496f62a4d27b344cea2367c44afc046f7d3e616c" translate="yes" xml:space="preserve">
          <source>Called in list context, returns a list consisting of all the keys of the named hash, or in Perl 5.12 or later only, the indices of an array. Perl releases prior to 5.12 will produce a syntax error if you try to use an array argument. In scalar context, returns the number of keys or indices.</source>
          <target state="translated">Вызывается в контексте списка,возвращает список,состоящий из всех ключей именованного хэша,или только в Perl 5.12 или более поздней версии,индексов массива.Релизы на Perl до версии 5.12 приведут к синтаксической ошибке,если вы попытаетесь использовать аргумент массива.В скалярном контексте возвращает количество ключей или индексов.</target>
        </trans-unit>
        <trans-unit id="467bfe2c2b5fcadd2c658d71f62e583886879a81" translate="yes" xml:space="preserve">
          <source>Called just before exit.</source>
          <target state="translated">Звонили прямо перед выходом.</target>
        </trans-unit>
        <trans-unit id="56f111d681d8f9bb2b8ea3bbe2cb68fe1cbd1b6b" translate="yes" xml:space="preserve">
          <source>Called to close a test session.</source>
          <target state="translated">Призвано закрыть тестовый сеанс.</target>
        </trans-unit>
        <trans-unit id="0fea40ea6e66a6d129222181dca9ffffa1dc50aa" translate="yes" xml:space="preserve">
          <source>Called to create a new test session. A test session looks like this:</source>
          <target state="translated">Призван для создания нового тестового сеанса.Тестовый сеанс выглядит вот так:</target>
        </trans-unit>
        <trans-unit id="bec535037f1a075b8ca545622477cf0f336b95f2" translate="yes" xml:space="preserve">
          <source>Called to get/set the value of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and their named equivalents, ${^PREMATCH}, ${^POSTMATCH} and ${^MATCH}, as well as the numbered capture groups (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ...).</source>
          <target state="translated">Вызывается для получения / установки значений &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; и их именованных эквивалентов, $ {^ PREMATCH}, $ {^ POSTMATCH} и $ {^ MATCH}, а также пронумерованных групп захвата ( &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="f05cab34d068a722bc12f2e226cde25cd9659c30" translate="yes" xml:space="preserve">
          <source>Called to get/set the value of &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; , as well as by some utility functions in &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;.</source>
          <target state="translated">Вызывается для получения / установки значений &lt;code&gt;%+&lt;/code&gt; и &lt;code&gt;%-&lt;/code&gt; , а также некоторыми служебными функциями в &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ca1fbe0a0f38d437dca54b642d9f31c3ccb8f90" translate="yes" xml:space="preserve">
          <source>Called when API must show a message (warnings, errors etc.).</source>
          <target state="translated">Вызывается,когда API должен выдать сообщение (предупреждения,ошибки и т.д.).</target>
        </trans-unit>
        <trans-unit id="f94cf1c0617789052abd6d872abe927053b4b0cd" translate="yes" xml:space="preserve">
          <source>Called when a job is complete to unlock it. If a callback has been registered with &lt;code&gt;on_finish&lt;/code&gt; , it calls it. Otherwise, it does nothing.</source>
          <target state="translated">Вызывается, когда задание выполнено, чтобы разблокировать его. Если обратный вызов был зарегистрирован в &lt;code&gt;on_finish&lt;/code&gt; , он его вызывает. В противном случае ничего не происходит.</target>
        </trans-unit>
        <trans-unit id="c5516c9265ba63c86e3ef82397e79274838607cf" translate="yes" xml:space="preserve">
          <source>Called when execution stops (w/ args file, line).</source>
          <target state="translated">Вызывается при остановке выполнения (w/args файл,строка).</target>
        </trans-unit>
        <trans-unit id="145748d07108bcdb9c427172d1270877727239ed" translate="yes" xml:space="preserve">
          <source>Called when the layer is popped from the stack. A layer will normally be popped after &lt;code&gt;Close()&lt;/code&gt; is called. But a layer can be popped without being closed if the program is dynamically managing layers on the stream. In such cases &lt;code&gt;Popped()&lt;/code&gt; should free any resources (buffers, translation tables, ...) not held directly in the layer's struct. It should also &lt;code&gt;Unread()&lt;/code&gt; any unconsumed data that has been read and buffered from the layer below back to that layer, so that it can be re-provided to what ever is now above.</source>
          <target state="translated">Вызывается, когда слой извлекается из стека. Слой обычно появляется после вызова &lt;code&gt;Close()&lt;/code&gt; . Но слой можно открыть, не закрывая его, если программа динамически управляет слоями в потоке. В таких случаях &lt;code&gt;Popped()&lt;/code&gt; должен освободить любые ресурсы (буферы, таблицы трансляции и т. Д.), Не хранящиеся непосредственно в структуре уровня. Он также должен &lt;code&gt;Unread()&lt;/code&gt; любых неиспользованных данных, которые были прочитаны и буферизованы из уровня ниже обратно на этот уровень, чтобы их можно было повторно предоставить тому, что когда-либо было сейчас выше.</target>
        </trans-unit>
        <trans-unit id="939127156e81551fd5a7e818b4482a513aebb0f8" translate="yes" xml:space="preserve">
          <source>Called while stopped (can be a client event loop).</source>
          <target state="translated">Вызывается во время остановки (может быть циклом обработки клиентских событий).</target>
        </trans-unit>
        <trans-unit id="aac1bcb8d7dddba4603f778cf3da3d2bb22b9d64" translate="yes" xml:space="preserve">
          <source>Called without parameters, or with the first argument false, hash marks are suppressed. If the first argument is true but not a reference to a file handle glob, then \*STDERR is used. The second argument is the number of bytes per hash mark printed, and defaults to 1024. In all cases the return value is a reference to an array of two: the filehandle glob reference and the bytes per hash mark.</source>
          <target state="translated">Вызываемые без параметров или с первым аргументом false,хэш-знаки подавляются.Если первый аргумент истинен,но не ссылка на глобус файлового дескриптора,то используется \*STDERR.Вторым аргументом является количество напечатанных байт на метку хэша,по умолчанию 1024.Во всех случаях возвращаемое значение-это ссылка на массив из двух:ссылка на глобус файлового дескриптора и байт на метку хэша.</target>
        </trans-unit>
        <trans-unit id="e216eb70c5a18b158cc8c755c284c444b41dcf38" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;functions/exit&quot;&gt;exit EXPR&lt;/a&gt; inside a thread causes the whole application to terminate. Because of this, the use of &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; inside threaded code, or in modules that might be used in threaded applications, is strongly discouraged.</source>
          <target state="translated">Вызов &lt;a href=&quot;functions/exit&quot;&gt;exit EXPR&lt;/a&gt; внутри потока приводит к завершению работы всего приложения. Из-за этого использование &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; внутри многопоточного кода или в модулях, которые могут использоваться в многопоточных приложениях, настоятельно не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="9e1f81bd75479e40b9c0318383b0b5ea0cddb02d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;-&amp;gt;flush&lt;/code&gt; returns the array to immediate-write mode. If you wish to discard the deferred writes, you may call &lt;code&gt;-&amp;gt;discard&lt;/code&gt; instead of &lt;code&gt;-&amp;gt;flush&lt;/code&gt; . Note that in some cases, some of the data will have been written already, and it will be too late for &lt;code&gt;-&amp;gt;discard&lt;/code&gt; to discard all the changes. Support for &lt;code&gt;-&amp;gt;discard&lt;/code&gt; may be withdrawn in a future version of &lt;code&gt;Tie::File&lt;/code&gt; .</source>
          <target state="translated">Вызов &lt;code&gt;-&amp;gt;flush&lt;/code&gt; возвращает массив в режим немедленной записи. Если вы хотите отменить отложенные записи, вы можете вызвать &lt;code&gt;-&amp;gt;discard&lt;/code&gt; вместо &lt;code&gt;-&amp;gt;flush&lt;/code&gt; . Обратите внимание, что в некоторых случаях некоторые данные уже были записаны, и для &lt;code&gt;-&amp;gt;discard&lt;/code&gt; будет слишком поздно отменить все изменения. Поддержка &lt;code&gt;-&amp;gt;discard&lt;/code&gt; может быть прекращена в будущей версии &lt;code&gt;Tie::File&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b218ac14d28e4eba90c2438d62379a52be6547e9" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; on an already detached thread will cause an error to be thrown.</source>
          <target state="translated">Вызов &lt;code&gt;-&amp;gt;join()&lt;/code&gt; или &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; в уже отсоединенном потоке вызовет ошибку.</target>
        </trans-unit>
        <trans-unit id="66b0f01a2dc8c4ec0ab9ed2203d7fa7fc14d740a" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; on an already joined thread will cause an error to be thrown.</source>
          <target state="translated">Вызов &lt;code&gt;-&amp;gt;join()&lt;/code&gt; или &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; в уже объединенном потоке вызовет ошибку.</target>
        </trans-unit>
        <trans-unit id="5013e17c5c2bf4d76b64a60f93a3e6d87ce580e9" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; in a thread indicates an abnormal exit for the thread. Any &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler in the thread will be called first, and then the thread will exit with a warning message that will contain any arguments passed in the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">Вызов &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; в потоке указывает на ненормальный выход из потока. Любой обработчик &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; в потоке будет вызван первым, а затем поток завершится с предупреждением, которое будет содержать любые аргументы, переданные в вызове &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="432a891f5fe2a318db5e9ee1a582e0b88a0dccd1" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;attributes::get()&lt;/code&gt; from within the scope of a null package declaration &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt; ;&lt;/code&gt; for an unblessed variable reference will not provide any starting package name for the 'fetch' method lookup. Thus, this circumstance will not result in a method call for package-defined attributes. A named subroutine knows to which symbol table entry it belongs (or originally belonged), and it will use the corresponding package. An anonymous subroutine knows the package name into which it was compiled (unless it was also compiled with a null package declaration), and so it will use that package name.</source>
          <target state="translated">Вызов &lt;code&gt;attributes::get()&lt;/code&gt; из области действия нулевого пакета объявления &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt; ;&lt;/code&gt; ссылка на переменную без благословения не предоставит никакого имени начального пакета для поиска метода 'fetch'. Таким образом, это обстоятельство не приведет к вызову метода для атрибутов, определенных пакетом. Именованная подпрограмма знает, к какой записи таблицы символов она принадлежит (или изначально принадлежала), и будет использовать соответствующий пакет. Анонимная подпрограмма знает имя пакета, в который она была скомпилирована (если она также не была скомпилирована с нулевым объявлением пакета), и поэтому она будет использовать это имя пакета.</target>
        </trans-unit>
        <trans-unit id="33bb3644bf1e13b2cbec6a1bd85b13b8d5473401" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;finalize&lt;/code&gt; on a child with open children will &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">Призыв &lt;code&gt;finalize&lt;/code&gt; ребенка с открытыми детьми будет &lt;code&gt;croak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a05e36379b2d12e2a61d8dca60e3236620cfbdd1" translate="yes" xml:space="preserve">
          <source>Calling Configure</source>
          <target state="translated">Настройка вызова</target>
        </trans-unit>
        <trans-unit id="858cb737d2c8f0a72b951ab4ea78b7b78f817737" translate="yes" xml:space="preserve">
          <source>Calling Conventions and Magic Autogeneration</source>
          <target state="translated">Вызывные конвенции и магическая автогенерация</target>
        </trans-unit>
        <trans-unit id="5a077d29f5340a5b715ff2d0b7446d09abed736c" translate="yes" xml:space="preserve">
          <source>Calling Perl Routines from within C Programs</source>
          <target state="translated">Вызов Perl Рутины из программ на языке С</target>
        </trans-unit>
        <trans-unit id="da4bd907e548514c9e5225dea46a70baeae7e05d" translate="yes" xml:space="preserve">
          <source>Calling PerlIO_releaseFILE informs PerlIO that all use of FILE * is complete. It is removed from the list of 'exported' FILE *s, and the associated PerlIO * should revert to its original behaviour.</source>
          <target state="translated">Вызов PerlIO_releaseFILE информирует PerlIO о том,что все использование FILE*завершено.Он удаляется из списка 'экспортированных' FILE *s,и связанный с ним PerlIO*должен вернуться к своему исходному поведению.</target>
        </trans-unit>
        <trans-unit id="4f10f9c81f6874964032fb54a94909bb2041ccaa" translate="yes" xml:space="preserve">
          <source>Calling Pod::Simple::Search-&amp;gt;find(...) is short for Pod::Simple::Search-&amp;gt;new-&amp;gt;find(...). That is, a throwaway object with default attribute values is used.</source>
          <target state="translated">Вызов Pod :: Simple :: Search-&amp;gt; find (...) является сокращением от Pod :: Simple :: Search-&amp;gt; new-&amp;gt; find (...). То есть используется одноразовый объект со значениями атрибутов по умолчанию.</target>
        </trans-unit>
        <trans-unit id="63b53fa8f0a187ed1ffd0c16a376efb544cfcb62" translate="yes" xml:space="preserve">
          <source>Calling Pod::Simple::Search-&amp;gt;search(...) is short for Pod::Simple::Search-&amp;gt;new-&amp;gt;search(...). That is, a throwaway object with default attribute values is used.</source>
          <target state="translated">Вызов Pod :: Simple :: Search-&amp;gt; search (...) является сокращением от Pod :: Simple :: Search-&amp;gt; new-&amp;gt; search (...). То есть используется одноразовый объект со значениями атрибутов по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ae570393756fa33aae649a93468e74ad3aa690b1" translate="yes" xml:space="preserve">
          <source>Calling a Perl method from C is fairly straightforward. The following things are required:</source>
          <target state="translated">Называть метод Perl из C довольно просто.Требуются следующие вещи:</target>
        </trans-unit>
        <trans-unit id="4f751357fb4ae38f84e904fc36d9db5113b5aaaf" translate="yes" xml:space="preserve">
          <source>Calling a Perl subroutine from your C program</source>
          <target state="translated">Вызов подпрограмм на Perl из вашей программы на C.</target>
        </trans-unit>
        <trans-unit id="c40cbac274b56e1beac728d697b23cc2ad8b3e30" translate="yes" xml:space="preserve">
          <source>Calling a method on an object is written as &lt;code&gt;$object-&amp;gt;method&lt;/code&gt; .</source>
          <target state="translated">Вызов метода для объекта записывается как &lt;code&gt;$object-&amp;gt;method&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="effd5ea5d1271fcf8d367de7457fffef004c2411" translate="yes" xml:space="preserve">
          <source>Calling a subroutine as &lt;code&gt;&amp;amp;foo&lt;/code&gt; with no trailing parentheses ignores the prototype of &lt;code&gt;foo&lt;/code&gt; and passes it the current value of the argument list, &lt;code&gt;@_&lt;/code&gt; . Here's an example; the &lt;code&gt;bar&lt;/code&gt; subroutine calls &lt;code&gt;&amp;amp;foo&lt;/code&gt; , which prints its arguments list:</source>
          <target state="translated">Вызов подпрограммы как &lt;code&gt;&amp;amp;foo&lt;/code&gt; без закрывающих круглых скобок игнорирует прототип &lt;code&gt;foo&lt;/code&gt; и передает ему текущее значение списка аргументов, &lt;code&gt;@_&lt;/code&gt; . Вот пример; &lt;code&gt;bar&lt;/code&gt; вызовов подпрограмм &lt;code&gt;&amp;amp;foo&lt;/code&gt; , который печатает список аргументов:</target>
        </trans-unit>
        <trans-unit id="83a5a40c5745b90b08565729f9c8b41d859bfba5" translate="yes" xml:space="preserve">
          <source>Calling an overloaded filetest operator does not affect the stat value associated with the special filehandle &lt;code&gt;_&lt;/code&gt; . It still refers to the result of the last &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; or unoverloaded filetest.</source>
          <target state="translated">Вызов перегруженного оператора filetest не влияет на значение stat, связанное со специальным дескриптором файла &lt;code&gt;_&lt;/code&gt; . Он по-прежнему относится к результату последнего &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; или непогруженного filetest.</target>
        </trans-unit>
        <trans-unit id="013392383aeb8f3aaeaada77da8e78bbc103974c" translate="yes" xml:space="preserve">
          <source>Calling either function on a string that already is in the desired state is a no-op.</source>
          <target state="translated">Вызов любой из функций на строке,которая уже находится в желаемом состоянии,является &quot;нет-оп&quot;.</target>
        </trans-unit>
        <trans-unit id="ac9d89d6b846180f08777572deb7332f87bf19f8" translate="yes" xml:space="preserve">
          <source>Calling exec() within a pseudo-process actually spawns the requested executable in a separate process and waits for it to complete before exiting with the same exit status as that process. This means that the process ID reported within the running executable will be different from what the earlier Perl fork() might have returned. Similarly, any process manipulation functions applied to the ID returned by fork() will affect the waiting pseudo-process that called exec(), not the real process it is waiting for after the exec().</source>
          <target state="translated">Вызов exec()внутри псевдо-процесса на самом деле порождает запрашиваемый исполняемый файл в отдельном процессе и ждет его завершения,прежде чем выйти с тем же самым статусом выхода,что и этот процесс.Это означает,что идентификатор процесса,сообщаемый внутри запущенного исполняемого файла,будет отличаться от того,что могло быть возвращено ранее функцией Perl fork().Аналогично,любые манипуляционные функции процесса,применяемые к идентификатору,возвращенному функцией fork(),будут влиять на ожидающий псевдо-процесс,который вызвал функцию exec(),а не на реальный процесс,которого он ждет после функции exec().</target>
        </trans-unit>
        <trans-unit id="40ade94f7a99e61011be8ace5918982f9630cfc9" translate="yes" xml:space="preserve">
          <source>Calling the Debugger</source>
          <target state="translated">Звонок отладчику</target>
        </trans-unit>
        <trans-unit id="2ca81641ec6217e87de3fa52de37358174c935e6" translate="yes" xml:space="preserve">
          <source>Calling the subroutine with trailing parentheses, with or without arguments, does not use the current &lt;code&gt;@_&lt;/code&gt; . Changing the example to put parentheses after the call to &lt;code&gt;foo&lt;/code&gt; changes the program:</source>
          <target state="translated">Вызов подпрограммы с завершающими круглыми скобками, с аргументами или без них, не использует текущий &lt;code&gt;@_&lt;/code&gt; . Если в примере поставить скобки после вызова &lt;code&gt;foo&lt;/code&gt; , программа изменится:</target>
        </trans-unit>
        <trans-unit id="492d320490c0c1bea0a0670c56d499e8b857ba1c" translate="yes" xml:space="preserve">
          <source>Calling this function repeatedly will create a FILE * on each call (and will push an :stdio layer each time as well).</source>
          <target state="translated">При многократном вызове этой функции при каждом вызове будет создаваться ФАЙЛ*(а также будет каждый раз нажиматься слой :stdio).</target>
        </trans-unit>
        <trans-unit id="bc6008c1e7f7d9345b7132b8abf50b8ba6fadc50" translate="yes" xml:space="preserve">
          <source>Calling this function will cause any temp files or temp directories that are registered for removal to be removed. This happens automatically when the process exits but can be triggered manually if the caller is sure that none of the temp files are required. This method can be registered as an Apache callback.</source>
          <target state="translated">Вызов этой функции приведет к удалению любых временных файлов или временных каталогов,которые зарегистрированы для удаления.Это происходит автоматически при выходе из процесса,но может быть вызвано вручную,если вызывающий абонент уверен,что ни один из временных файлов не требуется.Этот метод может быть зарегистрирован как обратный вызов Apache.</target>
        </trans-unit>
        <trans-unit id="b2c554dbf8d391703907c916da0c8b2d2b667cbb" translate="yes" xml:space="preserve">
          <source>Calling this on the root builder is a no-op.</source>
          <target state="translated">Называть это на корневом сборщике-это &quot;нет-оп&quot;.</target>
        </trans-unit>
        <trans-unit id="2e765d5d5aa54eb2d852bc799f3a264f32d02c18" translate="yes" xml:space="preserve">
          <source>Calling with ampersand syntax and through references does not work for the following functions, as they have special syntax that cannot always be translated into a simple list (e.g., &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">Вызов с синтаксисом амперсанда и по ссылкам не работает для следующих функций, поскольку они имеют особый синтаксис, который не всегда может быть преобразован в простой список (например, &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="fd4f026ec1a5607feec9a1e107752900730638f9" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Test::Builder-&amp;gt;no_ending&lt;/code&gt; turning off the ending tests. This is needed as otherwise it will trip out because we've run more tests than we strictly should have and it'll register any failures we had that we were testing for as real failures.</source>
          <target state="translated">Вызывает &lt;code&gt;Test::Builder-&amp;gt;no_ending&lt;/code&gt; отключая завершающие тесты. Это необходимо, так как в противном случае он выйдет из строя, потому что мы выполнили больше тестов, чем нам строго следовало бы провести, и он будет регистрировать любые сбои, которые мы тестировали, как настоящие.</target>
        </trans-unit>
        <trans-unit id="590c7d6e88adb5bddf3d8f642e0126b6c862bc26" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;sv_setsv&lt;/code&gt; if dsv is not the same as ssv. May evaluate arguments more than once. Does not handle 'set' magic on the destination SV.</source>
          <target state="translated">Вызывает &lt;code&gt;sv_setsv&lt;/code&gt; , если dsv не совпадает с ssv. Может оценивать аргументы более одного раза. Не обрабатывает магию &quot;установки&quot; на SV назначения.</target>
        </trans-unit>
        <trans-unit id="ecc1c1a42047512bf4698d979850ea62424810ba" translate="yes" xml:space="preserve">
          <source>Calls Cwd::cwd</source>
          <target state="translated">Звонки Cwd::cwd</target>
        </trans-unit>
        <trans-unit id="c904982ef90b628587f5e1c223b066f40097484e" translate="yes" xml:space="preserve">
          <source>Calls Cwd::fastcwd</source>
          <target state="translated">Звонки Cwd::fastcwd</target>
        </trans-unit>
        <trans-unit id="8c1ba5cb44af7e4a4c20a5047a781fc7e8a8fc22" translate="yes" xml:space="preserve">
          <source>Calls Cwd::getcwd</source>
          <target state="translated">Звонки Cwd::getcwd</target>
        </trans-unit>
        <trans-unit id="206e7aa2eb36edf2b309bbc5748aac00256c2321" translate="yes" xml:space="preserve">
          <source>Calls Cwd::getdcwd</source>
          <target state="translated">Звонки Cwd::getdcwd</target>
        </trans-unit>
        <trans-unit id="780a41207facdbbb71db04db90d90ec1fa2163f5" translate="yes" xml:space="preserve">
          <source>Calls a non-destructive version of &lt;code&gt;sv_setsv&lt;/code&gt; if dsv is not the same as ssv. May evaluate arguments more than once.</source>
          <target state="translated">Вызывает неразрушающую версию &lt;code&gt;sv_setsv&lt;/code&gt; , если dsv не совпадает с ssv. Может оценивать аргументы более одного раза.</target>
        </trans-unit>
        <trans-unit id="4ff2ef8b2188043c87a9c12a3c9cbf04635b332b" translate="yes" xml:space="preserve">
          <source>Calls flock(2), or an emulation of it, on FILEHANDLE. Returns true for success, false on failure. Produces a fatal error if used on a machine that doesn't implement flock(2), fcntl(2) locking, or lockf(3). &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; is Perl's portable file-locking interface, although it locks entire files only, not records.</source>
          <target state="translated">Вызывает flock (2) или его эмуляцию на FILEHANDLE. Возвращает истину в случае успеха и ложь в случае неудачи. Выдает фатальную ошибку, если используется на машине, которая не реализует блокировку flock (2), fcntl (2) или lockf (3). &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; - это переносимый интерфейс Perl для блокировки файлов, хотя он блокирует только файлы целиком, а не записи.</target>
        </trans-unit>
        <trans-unit id="bb35c1fa57137cad992f4edf7e56c85897367e17" translate="yes" xml:space="preserve">
          <source>Calls flock(2), or an emulation of it, on FILEHANDLE. Returns true for success, false on failure. Produces a fatal error if used on a machine that doesn't implement flock(2), fcntl(2) locking, or lockf(3). &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; is Perl's portable file-locking interface, although it locks entire files only, not records.</source>
          <target state="translated">Вызывает flock (2) или его эмуляцию на FILEHANDLE. Возвращает истину в случае успеха и ложь в случае неудачи. Выдает фатальную ошибку, если используется на машине, которая не реализует блокировку flock (2), fcntl (2) или lockf (3). &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; - это переносимый интерфейс Perl для блокировки файлов, хотя он блокирует только файлы целиком, а не записи.</target>
        </trans-unit>
        <trans-unit id="773f4cafc0f3777dd34c2b664ecf08fdcad62645" translate="yes" xml:space="preserve">
          <source>Calls install() with arguments to copy a module from blib/ to the default site installation location.</source>
          <target state="translated">Вызывает install()с аргументами для копирования модуля из blib/в место установки по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f72e847b0819bcbc3ab49dbf4b9ab2bb349a665c" translate="yes" xml:space="preserve">
          <source>Calls makeaperl.</source>
          <target state="translated">Звонит Скорректировщик.</target>
        </trans-unit>
        <trans-unit id="37943b6a726d9d0c50758cce3c190484f78dfe2c" translate="yes" xml:space="preserve">
          <source>Calls the Perl subroutine in a list context.</source>
          <target state="translated">Звонит в подпрограмму Perl в контексте списка.</target>
        </trans-unit>
        <trans-unit id="bb7f57720f3817b40ff0bbe8ea59e47c2d2ab29e" translate="yes" xml:space="preserve">
          <source>Calls the Perl subroutine in a scalar context. This is the default context flag setting for all the</source>
          <target state="translated">Звонит подпрограмма Perl в скалярном контексте.Это настройка флага контекста по умолчанию для всех подпрограмм</target>
        </trans-unit>
        <trans-unit id="73962f3f75b41688efacfc0da40dee4461b9fec3" translate="yes" xml:space="preserve">
          <source>Calls the Perl subroutine in a void context.</source>
          <target state="translated">Вызывает подпрограмму Perl в пустом контексте.</target>
        </trans-unit>
        <trans-unit id="f29d60ee63be0b6e387efbeaa174ef5a3adf4ba4" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgctl(2). You'll probably have to say</source>
          <target state="translated">Вызов функции System V IPC msgctl(2).Вероятно,вам придется сказать</target>
        </trans-unit>
        <trans-unit id="be9988a6d42da7c4020e6a5f954992f1c4491de0" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgget(2). Returns the message queue id, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::Msg&lt;/code&gt; .</source>
          <target state="translated">Вызывает функцию msgget (2) IPC System V. Возвращает идентификатор очереди сообщений или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в случае ошибки. См. Также &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC в perlipc&lt;/a&gt; и документацию по &lt;code&gt;IPC::SysV&lt;/code&gt; и &lt;code&gt;IPC::Msg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98b9f73da86e0e6b472bbcb69f309820842a2666" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgget(2). Returns the message queue id, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::Msg&lt;/code&gt; .</source>
          <target state="translated">Вызывает функцию msgget (2) IPC System V. Возвращает идентификатор очереди сообщений или &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в случае ошибки. См. Также &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC в perlipc&lt;/a&gt; и документацию по &lt;code&gt;IPC::SysV&lt;/code&gt; и &lt;code&gt;IPC::Msg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc2abfdb7a6e8deeeb37c01f08b5371f84b9260b" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgrcv to receive a message from message queue ID into variable VAR with a maximum message size of SIZE. Note that when a message is received, the message type as a native long integer will be the first thing in VAR, followed by the actual message. This packing may be opened with &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; . Taints the variable. Returns true if successful, false on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; .</source>
          <target state="translated">Вызывает функцию msgrcv IPC System V для получения сообщения из очереди сообщений с идентификатором в переменную VAR с максимальным размером сообщения SIZE. Обратите внимание, что когда сообщение получено, тип сообщения как длинное целое число будет первым в VAR, а затем фактическое сообщение. Эту упаковку можно открыть &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; . Портит переменную. Возвращает true в случае успеха и false в случае ошибки. См. Также &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC в perlipc&lt;/a&gt; и документацию для &lt;code&gt;IPC::SysV&lt;/code&gt; и &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="948f348f6fa98a8010bd8fc9ae4ccc04726f6c57" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgrcv to receive a message from message queue ID into variable VAR with a maximum message size of SIZE. Note that when a message is received, the message type as a native long integer will be the first thing in VAR, followed by the actual message. This packing may be opened with &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; . Taints the variable. Returns true if successful, false on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; .</source>
          <target state="translated">Вызывает функцию msgrcv IPC System V для получения сообщения из очереди сообщений с идентификатором в переменную VAR с максимальным размером сообщения SIZE. Обратите внимание, что когда сообщение получено, тип сообщения как длинное целое число будет первым в VAR, а затем фактическое сообщение. Эту упаковку можно открыть &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; . Портит переменную. Возвращает true в случае успеха и false в случае ошибки. См. Также &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC в perlipc&lt;/a&gt; и документацию для &lt;code&gt;IPC::SysV&lt;/code&gt; и &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5afcee05064a60e928b37ea8427c6294d37aba0" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgsnd to send the message MSG to the message queue ID. MSG must begin with the native long integer message type, be followed by the length of the actual message, and then finally the message itself. This kind of packing can be achieved with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; . Returns true if successful, false on error. See also the &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; documentation.</source>
          <target state="translated">Вызывает функцию msgsnd IPC System V для отправки сообщения MSG с идентификатором очереди сообщений. MSG должна начинаться с собственного типа сообщения &amp;laquo;длинное целое число&amp;raquo;, за которым следует длина фактического сообщения и, наконец, само сообщение. Такой вид упаковки может быть достигнут с помощью &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; . Возвращает true в случае успеха и false в случае ошибки. См. Также документацию &lt;code&gt;IPC::SysV&lt;/code&gt; и &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11394b0f70e6027e810e867a48b7248721c79467" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgsnd to send the message MSG to the message queue ID. MSG must begin with the native long integer message type, be followed by the length of the actual message, and then finally the message itself. This kind of packing can be achieved with &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; . Returns true if successful, false on error. See also the &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; documentation.</source>
          <target state="translated">Вызывает функцию msgsnd IPC System V для отправки сообщения MSG с идентификатором очереди сообщений. MSG должна начинаться с собственного типа сообщения &amp;laquo;длинное целое число&amp;raquo;, за которым следует длина фактического сообщения и, наконец, само сообщение. Такой вид упаковки может быть достигнут с помощью &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; . Возвращает true в случае успеха и false в случае ошибки. См. Также документацию &lt;code&gt;IPC::SysV&lt;/code&gt; и &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6019e00f804cda82d4ccc726e831f656c990eb13" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semctl(2). You'll probably have to say</source>
          <target state="translated">Вызовите функцию System V IPC semctl(2).Вероятно,вам придется сказать</target>
        </trans-unit>
        <trans-unit id="5f610b5b4eaf02b0f729a98fdbc4342fbee172a9" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semget(2). Returns the semaphore id, or the undefined value on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">Вызывает функцию semget (2) IPC System V. Возвращает идентификатор семафора или неопределенное значение при ошибке. См. Также документацию &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC в perlipc&lt;/a&gt; , &lt;code&gt;IPC::SysV&lt;/code&gt; , &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="315be1c7490d0b06d562bb984c8930c31052ce5c" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semget(2). Returns the semaphore id, or the undefined value on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">Вызывает функцию semget (2) IPC System V. Возвращает идентификатор семафора или неопределенное значение при ошибке. См. Также документацию &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC в perlipc&lt;/a&gt; , &lt;code&gt;IPC::SysV&lt;/code&gt; , &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef274fb91ef606897494225538343bd9782c7288" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semop(2) for semaphore operations such as signalling and waiting. OPSTRING must be a packed array of semop structures. Each semop structure can be generated with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; . The length of OPSTRING implies the number of semaphore operations. Returns true if successful, false on error. As an example, the following code waits on semaphore $semnum of semaphore id $semid:</source>
          <target state="translated">Вызывает функцию semop (2) IPC System V для семафорных операций, таких как сигнализация и ожидание. OPSTRING должен быть упакованным массивом структур semop. Каждую структуру semop можно сгенерировать с помощью &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; . Длина OPSTRING подразумевает количество операций с семафором. Возвращает true в случае успеха и false в случае ошибки. В качестве примера следующий код ожидает семафора $ semnum идентификатора семафора $ semid:</target>
        </trans-unit>
        <trans-unit id="e0c44ed833fa28db0acecadac8e6a6c1fb4ee6ed" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semop(2) for semaphore operations such as signalling and waiting. OPSTRING must be a packed array of semop structures. Each semop structure can be generated with &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; . The length of OPSTRING implies the number of semaphore operations. Returns true if successful, false on error. As an example, the following code waits on semaphore $semnum of semaphore id $semid:</source>
          <target state="translated">Вызывает функцию semop (2) IPC System V для семафорных операций, таких как сигнализация и ожидание. OPSTRING должен быть упакованным массивом структур semop. Каждую структуру semop можно сгенерировать с помощью &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; . Длина OPSTRING подразумевает количество операций с семафором. Возвращает true в случае успеха и false в случае ошибки. В качестве примера следующий код ожидает семафора $ semnum идентификатора семафора $ semid:</target>
        </trans-unit>
        <trans-unit id="c7ffce30c16d2adb19634cb73edd07b139d51d58" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function shmctl. You'll probably have to say</source>
          <target state="translated">Вызов функции System V IPC shmctl.Наверное,вам придется сказать.</target>
        </trans-unit>
        <trans-unit id="b0bc62f7fa862b27b2de307fc455c072f03da35c" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function shmget. Returns the shared memory segment id, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and &lt;code&gt;IPC::SysV&lt;/code&gt; documentation.</source>
          <target state="translated">Вызывает функцию shmget IPC System V. Возвращает идентификатор сегмента разделяемой памяти или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в случае ошибки. См. Также &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC в документации perlipc&lt;/a&gt; и &lt;code&gt;IPC::SysV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c305f2b321c34aa679da0caad314dcb3d11fcda" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function shmget. Returns the shared memory segment id, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and &lt;code&gt;IPC::SysV&lt;/code&gt; documentation.</source>
          <target state="translated">Вызывает функцию shmget IPC System V. Возвращает идентификатор сегмента разделяемой памяти или &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в случае ошибки. См. Также &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC в документации perlipc&lt;/a&gt; и &lt;code&gt;IPC::SysV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="171e1908f8052943b22ba1224601d2782bb8861e" translate="yes" xml:space="preserve">
          <source>Calls the external command cwd.</source>
          <target state="translated">Вызывает внешнюю команду cwd.</target>
        </trans-unit>
        <trans-unit id="3c0dfe2a93186d77d26e8574e4df98dbb4f6b11b" translate="yes" xml:space="preserve">
          <source>Calls the reports() method on the associated distribution object.</source>
          <target state="translated">Вызов метода reports()на связанном с ним объекте распределения.</target>
        </trans-unit>
        <trans-unit id="e80219f44739d96f5e20c3cf29ed7bd7ff8e792b" translate="yes" xml:space="preserve">
          <source>Calls the system call specified as the first element of the list, passing the remaining elements as arguments to the system call. If unimplemented, raises an exception. The arguments are interpreted as follows: if a given argument is numeric, the argument is passed as an int. If not, the pointer to the string value is passed. You are responsible to make sure a string is pre-extended long enough to receive any result that might be written into a string. You can't use a string literal (or other read-only string) as an argument to &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; because Perl has to assume that any string pointer might be written through. If your integer arguments are not literals and have never been interpreted in a numeric context, you may need to add &lt;code&gt;0&lt;/code&gt; to them to force them to look like numbers. This emulates the &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function (or vice versa):</source>
          <target state="translated">Вызывает системный вызов, указанный как первый элемент списка, передавая оставшиеся элементы в качестве аргументов системному вызову. Если не реализовано, вызывает исключение. Аргументы интерпретируются следующим образом: если заданный аргумент числовой, аргумент передается как int. Если нет, то передается указатель на строковое значение. Вы несете ответственность за то, чтобы строка была предварительно расширена достаточно длинной, чтобы получить любой результат, который может быть записан в строку. Вы не можете использовать строковый литерал (или другую строку, &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; только для чтения) в качестве аргумента для системного вызова, потому что Perl должен предполагать, что любой строковый указатель может быть записан. Если ваши целочисленные аргументы не являются литералами и никогда не интерпретировались в числовом контексте, вам может потребоваться добавить &lt;code&gt;0&lt;/code&gt; им, чтобы заставить их выглядеть как числа. Это имитирует функцию &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; (или наоборот):</target>
        </trans-unit>
        <trans-unit id="14adf48ff5b79cf02eb35e0df8ee02d1dedea8a0" translate="yes" xml:space="preserve">
          <source>Calls the system call specified as the first element of the list, passing the remaining elements as arguments to the system call. If unimplemented, raises an exception. The arguments are interpreted as follows: if a given argument is numeric, the argument is passed as an int. If not, the pointer to the string value is passed. You are responsible to make sure a string is pre-extended long enough to receive any result that might be written into a string. You can't use a string literal (or other read-only string) as an argument to &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; because Perl has to assume that any string pointer might be written through. If your integer arguments are not literals and have never been interpreted in a numeric context, you may need to add &lt;code&gt;0&lt;/code&gt; to them to force them to look like numbers. This emulates the &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function (or vice versa):</source>
          <target state="translated">Вызывает системный вызов, указанный как первый элемент списка, передавая оставшиеся элементы в качестве аргументов системному вызову. Если не реализовано, вызывает исключение. Аргументы интерпретируются следующим образом: если заданный аргумент числовой, аргумент передается как int. Если нет, то передается указатель на строковое значение. Вы несете ответственность за то, чтобы строка была предварительно расширена достаточно длинной, чтобы получить любой результат, который может быть записан в строку. Вы не можете использовать строковый литерал (или другую строку, &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; только для чтения) в качестве аргумента для системного вызова, потому что Perl должен предполагать, что любой строковый указатель может быть записан. Если ваши целочисленные аргументы не являются литералами и никогда не интерпретировались в числовом контексте, вам может потребоваться добавить &lt;code&gt;0&lt;/code&gt; им, чтобы заставить их выглядеть как числа. Это имитирует функцию &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; (или наоборот):</target>
        </trans-unit>
        <trans-unit id="4689606e99f2e0dc6a1ba0af906a041a8988cfda" translate="yes" xml:space="preserve">
          <source>Calls to external programs</source>
          <target state="translated">Звонки во внешние программы</target>
        </trans-unit>
        <trans-unit id="b9f578265a3254a0619351c53e86631e90149c66" translate="yes" xml:space="preserve">
          <source>Calls user-supplied functions for conversion. For &lt;code&gt;OUTPUT&lt;/code&gt; (XSUB to Perl), a function named &lt;code&gt;XS_pack_$ntype&lt;/code&gt; is called with the output Perl scalar and the C variable to convert from. &lt;code&gt;$ntype&lt;/code&gt; is the normalized C type that is to be mapped to Perl. Normalized means that all &lt;code&gt;*&lt;/code&gt; are replaced by the string &lt;code&gt;Ptr&lt;/code&gt; . The return value of the function is ignored.</source>
          <target state="translated">Вызывает пользовательские функции для преобразования. Для &lt;code&gt;OUTPUT&lt;/code&gt; (из XSUB в Perl) &lt;code&gt;XS_pack_$ntype&lt;/code&gt; функция с именем XS_pack_ $ ntype с выходным скаляром Perl и переменной C для преобразования. &lt;code&gt;$ntype&lt;/code&gt; - это нормализованный тип C, который должен быть отображен в Perl. Нормализованный означает, что все &lt;code&gt;*&lt;/code&gt; заменяются строкой &lt;code&gt;Ptr&lt;/code&gt; . Возвращаемое значение функции игнорируется.</target>
        </trans-unit>
        <trans-unit id="adb92c1608308898a1811cd12d916df49f9c32f4" translate="yes" xml:space="preserve">
          <source>CamelBones ( &lt;a href=&quot;http://camelbones.sourceforge.net&quot;&gt;http://camelbones.sourceforge.net&lt;/a&gt; ) is a Perl interface to Mac OS X's Cocoa GUI toolkit, and as such can be used to produce native GUIs on Mac OS X. It's not on CPAN, as it requires frameworks that CPAN.pm doesn't know how to install, but installation is via the standard OSX package installer. The Perl API is, again, very close to the ObjC API it's wrapping, and the documentation just tells you how to translate from one to the other.</source>
          <target state="translated">CamelBones ( &lt;a href=&quot;http://camelbones.sourceforge.net&quot;&gt;http://camelbones.sourceforge.net&lt;/a&gt; ) - это Perl-интерфейс для набора инструментов Mac OS X Cocoa GUI, и поэтому его можно использовать для создания собственных графических интерфейсов в Mac OS X. Его нет на CPAN, так как для него требуются фреймворки, которые CPAN .pm не знает, как установить, но установка осуществляется через стандартный установщик пакетов OSX. Perl API, опять же, очень близок к ObjC API, который он упаковывает, и документация просто говорит вам, как переводить с одного на другой.</target>
        </trans-unit>
        <trans-unit id="80701e22e30b3906cffd903f13b0b88b4269184d" translate="yes" xml:space="preserve">
          <source>CamelGrayBig.BMP</source>
          <target state="translated">CamelGrayBig.BMP</target>
        </trans-unit>
        <trans-unit id="e06a2487ce9da8707485d167c86e4cec108412be" translate="yes" xml:space="preserve">
          <source>Can I do [task] in Perl?</source>
          <target state="translated">Могу я сделать [задание]на Перле?</target>
        </trans-unit>
        <trans-unit id="17260f8bf54a1e0a6921ffbe29352d30c7eb0d7e" translate="yes" xml:space="preserve">
          <source>Can I get a BNF/yacc/RE for the Perl language?</source>
          <target state="translated">Могу ли я получить BNF/yacc/RE для языка Perl?</target>
        </trans-unit>
        <trans-unit id="3a800859ea9403fd88df5aa63fab2b1ed9bba4be" translate="yes" xml:space="preserve">
          <source>Can I use Perl regular expressions to match balanced text?</source>
          <target state="translated">Могу ли я использовать регулярные выражения Perl для соответствия сбалансированного текста?</target>
        </trans-unit>
        <trans-unit id="2289a974ae52b9e29f0b401490ee2c25637b7437" translate="yes" xml:space="preserve">
          <source>Can I use Unicode in my Perl sources?</source>
          <target state="translated">Могу ли я использовать Юникод в своих Perl-источниках?</target>
        </trans-unit>
        <trans-unit id="32e50e864db1746776899a01caf14e13d2d4a291" translate="yes" xml:space="preserve">
          <source>Can I use perl to run a telnet or ftp session?</source>
          <target state="translated">Могу ли я использовать perl для запуска сеанса telnet или ftp?</target>
        </trans-unit>
        <trans-unit id="14d0ae1165be9b8566f8406ca14230c7961f4848" translate="yes" xml:space="preserve">
          <source>Can I write useful Perl programs on the command line?</source>
          <target state="translated">Могу ли я писать полезные программы на Perl в командной строке?</target>
        </trans-unit>
        <trans-unit id="35df49ce9c972c29af7bf8e861531cb5efb30472" translate="yes" xml:space="preserve">
          <source>Can also be called as an instance method.</source>
          <target state="translated">Может также называться методом экземпляра.</target>
        </trans-unit>
        <trans-unit id="4ba8c255d770ca0f7b72beded6916ada06108fbe" translate="yes" xml:space="preserve">
          <source>Can also be used to set &lt;code&gt;$TODO&lt;/code&gt; to a new value while returning the old value:</source>
          <target state="translated">Также может использоваться для установки нового значения &lt;code&gt;$TODO&lt;/code&gt; при возврате старого значения:</target>
        </trans-unit>
        <trans-unit id="91cc357ede21e8f86848e6eae7e811a215ba08ce" translate="yes" xml:space="preserve">
          <source>Can be constructed using &lt;code&gt;pod2latex&lt;/code&gt; .</source>
          <target state="translated">Может быть сконструирован с использованием &lt;code&gt;pod2latex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa58e7bcf2882cbd00cc88fa0dc03c0cd52468bb" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to control whether code references are turned into perl source code. If set to a true value, &lt;code&gt;B::Deparse&lt;/code&gt; will be used to get the source of the code reference. Using this option will force using the Perl implementation of the dumper, since the fast XSUB implementation doesn't support it.</source>
          <target state="translated">Может быть установлено в логическое значение, чтобы управлять преобразованием ссылок кода в исходный код Perl. Если установлено истинное значение, &lt;code&gt;B::Deparse&lt;/code&gt; будет использоваться для получения ссылки на исходный код. Использование этой опции приведет к принудительному использованию Perl-реализации дампера, поскольку быстрая реализация XSUB не поддерживает ее.</target>
        </trans-unit>
        <trans-unit id="6c627856437742bf2a91768641f29dacbba9c49e" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to control whether hash keys are dumped in sorted order. A true value will cause the keys of all hashes to be dumped in Perl's default sort order. Can also be set to a subroutine reference which will be called for each hash that is dumped. In this case &lt;code&gt;Data::Dumper&lt;/code&gt; will call the subroutine once for each hash, passing it the reference of the hash. The purpose of the subroutine is to return a reference to an array of the keys that will be dumped, in the order that they should be dumped. Using this feature, you can control both the order of the keys, and which keys are actually used. In other words, this subroutine acts as a filter by which you can exclude certain keys from being dumped. Default is 0, which means that hash keys are not sorted.</source>
          <target state="translated">Может быть установлено в логическое значение, чтобы контролировать, сбрасываются ли хеш-ключи в отсортированном порядке. Истинное значение приведет к тому, что ключи всех хэшей будут сброшены в порядке сортировки Perl по умолчанию. Также может быть установлена ​​ссылка на подпрограмму, которая будет вызываться для каждого сбрасываемого хэша. В этом случае &lt;code&gt;Data::Dumper&lt;/code&gt; будет вызывать подпрограмму один раз для каждого хэша, передавая ей ссылку на хэш. Цель подпрограммы - вернуть ссылку на массив ключей, которые будут сброшены, в том порядке, в котором они должны быть сброшены. Используя эту функцию, вы можете контролировать как порядок клавиш, так и то, какие клавиши фактически используются. Другими словами, эта подпрограмма действует как фильтр, с помощью которого вы можете исключить определенные ключи из дампа. По умолчанию 0, что означает, что хеш-ключи не сортируются.</target>
        </trans-unit>
        <trans-unit id="7fb27ddb4917ba511f5c8620ff526bf1f7bf1e63" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to control whether hash keys are quoted. A defined false value will avoid quoting hash keys when it looks like a simple string. Default is 1, which will always enclose hash keys in quotes.</source>
          <target state="translated">Может быть установлено значение булева,чтобы контролировать,будут ли хэш-клавиши цитироваться.Определенное ложное значение позволит избежать кавычек хэш-ключей,когда это выглядит как простая строка.По умолчанию 1,которое всегда будет заключать хэш-ключи в кавычки.</target>
        </trans-unit>
        <trans-unit id="88c46add64294e8210c672da2183abe0ed447bfc" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to enable deep copies of structures. Cross-referencing will then only be done when absolutely essential (i.e., to break reference cycles). Default is 0.</source>
          <target state="translated">Может быть установлено булевое значение для включения глубоких копий структур.В этом случае перекрестные ссылки будут делаться только тогда,когда это абсолютно необходимо (т.е.для разрыва циклов ссылок).По умолчанию 0.</target>
        </trans-unit>
        <trans-unit id="67a33f1bf6a1de539cc6aeb590a56729f0fa737c" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value which controls whether the pure Perl implementation of &lt;code&gt;Data::Dumper&lt;/code&gt; is used. The &lt;code&gt;Data::Dumper&lt;/code&gt; module is a dual implementation, with almost all functionality written in both pure Perl and also in XS ('C'). Since the XS version is much faster, it will always be used if possible. This option lets you override the default behavior, usually for testing purposes only. Default is 0, which means the XS implementation will be used if possible.</source>
          <target state="translated">Может быть установлено в логическое значение, которое контролирует использование чистой Perl-реализации &lt;code&gt;Data::Dumper&lt;/code&gt; . Модуль &lt;code&gt;Data::Dumper&lt;/code&gt; представляет собой двойную реализацию, почти все функции которой написаны как на чистом Perl, так и на XS ('C'). Поскольку версия XS намного быстрее, она всегда будет использоваться, если это возможно. Этот параметр позволяет переопределить поведение по умолчанию, обычно только для целей тестирования. По умолчанию 0, что означает, что по возможности будет использоваться реализация XS.</target>
        </trans-unit>
        <trans-unit id="cb22428de8a3ede5e563a5e4f65611da085b8c2a" translate="yes" xml:space="preserve">
          <source>Can be set to a method name, or to an empty string to disable the feature. Data::Dumper will emit a method call for any objects that are to be dumped using the syntax &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;(DATA, CLASS)-&amp;gt;METHOD()&lt;/code&gt; . Note that this means that the method specified will have to perform any modifications required on the object (like creating new state within it, and/or reblessing it in a different package) and then return it. The client is responsible for making sure the method can be called via the object, and that it returns a valid object. Defaults to an empty string.</source>
          <target state="translated">Можно указать имя метода или пустую строку, чтобы отключить функцию. Data :: Dumper произведет вызов метода для любых объектов, которые должны быть сброшены, используя синтаксис &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;(DATA, CLASS)-&amp;gt;METHOD()&lt;/code&gt; . Обратите внимание, что это означает, что указанный метод должен будет выполнить любые изменения, необходимые для объекта (например, создать новое состояние в нем и / или повторно активировать его в другом пакете), а затем вернуть его. Клиент отвечает за то, чтобы метод мог быть вызван через объект и что он возвращает допустимый объект. По умолчанию пустая строка.</target>
        </trans-unit>
        <trans-unit id="585673e874a0b17703c1a10f7dfc47aff5c9f0ec" translate="yes" xml:space="preserve">
          <source>Can be set to a method name, or to an empty string to disable the feature. Data::Dumper will invoke that method via the object before attempting to stringify it. This method can alter the contents of the object (if, for instance, it contains data allocated from C), and even rebless it in a different package. The client is responsible for making sure the specified method can be called via the object, and that the object ends up containing only perl data types after the method has been called. Defaults to an empty string.</source>
          <target state="translated">Может быть задано имя метода или пустая строка для отключения функции.Data::Дампер будет вызывать этот метод через объект перед попыткой его строковой модификации.Этот метод может изменить содержимое объекта (если,например,он содержит данные,выделенные из C),и даже переоформить его в другом пакете.Клиент отвечает за то,чтобы указанный метод мог быть вызван через объект,и чтобы объект после вызова метода содержал только perl-типы данных.По умолчанию пустая строка.</target>
        </trans-unit>
        <trans-unit id="6ee2759a6426aff4b67b4db8b27a81f5748f17a4" translate="yes" xml:space="preserve">
          <source>Can be set to a positive integer that specifies the depth beyond which recursion into a structure will throw an exception. This is intended as a security measure to prevent perl running out of stack space when dumping an excessively deep structure. Can be set to 0 to remove the limit. Default is 1000.</source>
          <target state="translated">Может быть установлено в положительное целое число,определяющее глубину,за пределами которой рекурсия в структуру будет бросать исключение.Это предназначено в качестве меры безопасности для предотвращения исчерпания perl пространства стека при демпинге слишком глубокой структуры.Может быть установлено в 0,чтобы снять ограничение.По умолчанию-1000.</target>
        </trans-unit>
        <trans-unit id="4bf42f1af137c40c87a30e672fa92d800507f75f" translate="yes" xml:space="preserve">
          <source>Can be set to a positive integer that specifies the depth beyond which we don't venture into a structure. Has no effect when &lt;code&gt;Data::Dumper::Purity&lt;/code&gt; is set. (Useful in debugger when we often don't want to see more than enough). Default is 0, which means there is no maximum depth.</source>
          <target state="translated">Может быть установлено положительное целое число, определяющее глубину, за которую мы не углубляемся в структуру. Не действует, если установлено &lt;code&gt;Data::Dumper::Purity&lt;/code&gt; . (Полезно в отладчике, когда мы часто не хотим видеть больше, чем достаточно). По умолчанию 0, что означает отсутствие максимальной глубины.</target>
        </trans-unit>
        <trans-unit id="1b8ab4925558b8a13bc55bec7e3f47e1da66a3e2" translate="yes" xml:space="preserve">
          <source>Can be set to a regular expression. Only files with names that match the expression will be read.</source>
          <target state="translated">Может быть установлено регулярное выражение.Будут прочитаны только файлы с именами,которые соответствуют выражению.</target>
        </trans-unit>
        <trans-unit id="b4c1fc7bc4091447e126bb9cbc6311ac8f682f2f" translate="yes" xml:space="preserve">
          <source>Can be set to a string that specifies an alternative to the &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; builtin operator used to create objects. A function with the specified name should exist, and should accept the same arguments as the builtin. Default is &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Может быть установлен в строку, определяющую альтернативу встроенному оператору &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; , используемому для создания объектов. Функция с указанным именем должна существовать и принимать те же аргументы, что и встроенная функция. По умолчанию &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a994c4b88b43caa5b752fd46ef7324627d9d83c6" translate="yes" xml:space="preserve">
          <source>Can be set to a string that specifies the separator between hash keys and values. To dump nested hash, array and scalar values to JavaScript, use: &lt;code&gt;$Data::Dumper::Pair = ' : ';&lt;/code&gt; . Implementing &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; in JavaScript is left as an exercise for the reader. A function with the specified name exists, and accepts the same arguments as the builtin.</source>
          <target state="translated">Может быть установлен в строку, определяющую разделитель между хеш-ключами и значениями. Чтобы выгрузить вложенные хеш-значения, массивы и скалярные значения в JavaScript, используйте: &lt;code&gt;$Data::Dumper::Pair = ' : ';&lt;/code&gt; . Реализация &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; в JavaScript оставлена ​​в качестве упражнения для читателя. Функция с указанным именем существует и принимает те же аргументы, что и встроенная функция.</target>
        </trans-unit>
        <trans-unit id="9e933a47e6aaf6dd73210fa86f1269378f8318bc" translate="yes" xml:space="preserve">
          <source>Can be trimmed if you compile for one access method.</source>
          <target state="translated">Может быть обрезан,если вы скомпилируете для одного метода доступа.</target>
        </trans-unit>
        <trans-unit id="717d201646a10747b3a920b5eaa1592483e5445b" translate="yes" xml:space="preserve">
          <source>Can call croak() if an error occurs.</source>
          <target state="translated">Может вызвать функцию croak()при возникновении ошибки.</target>
        </trans-unit>
        <trans-unit id="610ece97ddb84d598c6d8556f131f1844efd48bc" translate="yes" xml:space="preserve">
          <source>Can call croak() if there is a security anomaly during the stat() comparison.</source>
          <target state="translated">Может вызвать croak(),если во время сравнения stat()есть аномалия безопасности.</target>
        </trans-unit>
        <trans-unit id="512d893f80ec4605f408cd9d8d3b090f641b1bc5" translate="yes" xml:space="preserve">
          <source>Can only be applied to process handles returned for processes spawned using &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, ...)&lt;/code&gt; or pseudo processes created with &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;. (Win32)</source>
          <target state="translated">Может применяться только к дескрипторам процесса, возвращаемым для процессов, порожденных с помощью &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, ...)&lt;/code&gt; или псевдопроцессов, созданных с помощью &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; . (Win32)</target>
        </trans-unit>
        <trans-unit id="acc17adc87dae58e0d71e7b8a46715c51db69dd0" translate="yes" xml:space="preserve">
          <source>Can use any of the methods described above but for further customization one needs to override some of the methods:</source>
          <target state="translated">Можно использовать любой из описанных выше методов,но для дальнейшей настройки необходимо переопределить некоторые из них:</target>
        </trans-unit>
        <trans-unit id="6e5e0a8f8265c585a4f386242ed86595f0f740c3" translate="yes" xml:space="preserve">
          <source>Can we do the same with an XSUB</source>
          <target state="translated">Можем ли мы сделать то же самое с XSUB.</target>
        </trans-unit>
        <trans-unit id="d71b162349ad8d3cc1b62ad26a21aad2924ff2d2" translate="yes" xml:space="preserve">
          <source>Can't move directories between directories on different logical volumes. (Win32)</source>
          <target state="translated">Не может перемещать каталоги между каталогами на разных логических томах.(Win32)</target>
        </trans-unit>
        <trans-unit id="d5c61e930ba2ace5562dbc01d87ff2dccd871bad" translate="yes" xml:space="preserve">
          <source>Cancel output to the file handle. Any POD read by the &lt;code&gt;$parser&lt;/code&gt; is not effected.</source>
          <target state="translated">Отменить вывод в дескриптор файла. Любые POD, прочитанные &lt;code&gt;$parser&lt;/code&gt; не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="56c9d54018682f033ce26d5d28cbd53bef40aa76" translate="yes" xml:space="preserve">
          <source>Cancel output to the output string. Any POD read by the &lt;code&gt;$parser&lt;/code&gt; is not effected.</source>
          <target state="translated">Отменить вывод в строку вывода. Любые POD, прочитанные &lt;code&gt;$parser&lt;/code&gt; не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="cf5ab48928c6227aa52c3d012c2701389449d7d8" translate="yes" xml:space="preserve">
          <source>Canned Filters</source>
          <target state="translated">Консервированные фильтры</target>
        </trans-unit>
        <trans-unit id="1bbd1f5144cc25ff3e79e713323aaa5805fc1bb3" translate="yes" xml:space="preserve">
          <source>Cannot start &lt;code&gt;find.exe &quot;pattern&quot; file&lt;/code&gt;</source>
          <target state="translated">Не &lt;code&gt;find.exe &quot;pattern&quot; file&lt;/code&gt; запустить файл &quot;шаблон&quot; find.exe</target>
        </trans-unit>
        <trans-unit id="4f9378da13e876924853515ac330a0589ab874eb" translate="yes" xml:space="preserve">
          <source>Cannot start find.exe &quot;pattern&quot; file</source>
          <target state="translated">Не могу запустить файл find.exe &quot;шаблон&quot;.</target>
        </trans-unit>
        <trans-unit id="07f4ae991f88e569288a303eea482424b54e133d" translate="yes" xml:space="preserve">
          <source>Canonical Equivalence in Applications - UTN #5</source>
          <target state="translated">Каноническое эквивалентность в приложениях-UTN #5</target>
        </trans-unit>
        <trans-unit id="b8dabeba508ec88a0783430634fb6a91f3d06c7d" translate="yes" xml:space="preserve">
          <source>Canonical order does not imply network order; those are two orthogonal settings.</source>
          <target state="translated">Канонический порядок не подразумевает сетевой порядок;это две ортогональные настройки.</target>
        </trans-unit>
        <trans-unit id="747ae3c9036b2b9d0c1bdc3f6a1c392c7794eed3" translate="yes" xml:space="preserve">
          <source>Capture group contents are dynamically scoped and available to you outside the pattern until the end of the enclosing block or until the next successful match, whichever comes first. (See &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.) You can refer to them by absolute number (using &lt;code&gt;&quot;$1&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , etc); or by name via the &lt;code&gt;%+&lt;/code&gt; hash, using &lt;code&gt;&quot;$+{&lt;i&gt;name&lt;/i&gt;}&quot;&lt;/code&gt;.</source>
          <target state="translated">Содержимое группы захвата динамически ограничено и доступно за пределами шаблона до конца включающего блока или до следующего успешного совпадения, в зависимости от того, что наступит раньше. (См. &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;Составные операторы в perlsyn&lt;/a&gt; .) Вы можете ссылаться на них по абсолютным числам (используя &lt;code&gt;&quot;$1&quot;&lt;/code&gt; вместо &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; и т. Д.); или по имени через хэш &lt;code&gt;%+&lt;/code&gt; , используя &lt;code&gt;&quot;$+{&lt;i&gt;name&lt;/i&gt;}&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="311dff8ce71dc0b4b0666e7280ad010d93e7918a" translate="yes" xml:space="preserve">
          <source>Capture groups</source>
          <target state="translated">Захватные группы</target>
        </trans-unit>
        <trans-unit id="17d5baafa6da919c16c090df56e9fd9d7a565715" translate="yes" xml:space="preserve">
          <source>Capture groups are numbered from left to right, but inside this construct the numbering is restarted for each branch.</source>
          <target state="translated">Группы захвата нумеруются слева направо,но внутри этой конструкции нумерация перезапускается для каждой ветви.</target>
        </trans-unit>
        <trans-unit id="ee0771c31053343949dda6efc584e44e5297b9a9" translate="yes" xml:space="preserve">
          <source>Captured groups are numbered according to their</source>
          <target state="translated">Захваченные группы пронумерованы в соответствии с их</target>
        </trans-unit>
        <trans-unit id="f7b4920b8aa7c1586544c28d9c8886e52d98ca56" translate="yes" xml:space="preserve">
          <source>Capturing parenthesis that work just like perl</source>
          <target state="translated">Захват скобок,которые работают как перл.</target>
        </trans-unit>
        <trans-unit id="4ea8cbac41ff9a96e8d9db8e075354ecd6a9f99e" translate="yes" xml:space="preserve">
          <source>Care must be taken when making changes to make sure that you handle UTF-8 properly, both at compile time and at execution time, including when the string and pattern are mismatched.</source>
          <target state="translated">При внесении изменений необходимо следить за правильной обработкой UTF-8,как во время компиляции,так и во время исполнения,в том числе при несовпадении строки и шаблона.</target>
        </trans-unit>
        <trans-unit id="04617e457add86a7b016a256cae6724b67e05962" translate="yes" xml:space="preserve">
          <source>Care should be taken when using the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. It is</source>
          <target state="translated">Следует соблюдать осторожность при использовании &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; формы &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; . это</target>
        </trans-unit>
        <trans-unit id="f12898eb208465f617f9b5c3dd913e72b7c63a92" translate="yes" xml:space="preserve">
          <source>Care should be taken when using the &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. It is</source>
          <target state="translated">Следует соблюдать осторожность при использовании &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; формы &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; . это</target>
        </trans-unit>
        <trans-unit id="d00ed6d0c5ac45de00f179782815edeefadfc67b" translate="yes" xml:space="preserve">
          <source>Carp</source>
          <target state="translated">Carp</target>
        </trans-unit>
        <trans-unit id="d88a6c87d4e1376b298c703f4fc38df13d24c117" translate="yes" xml:space="preserve">
          <source>Carp - alternative warn and die for modules</source>
          <target state="translated">Карп-альтернативное предупреждение и штамповка для модулей</target>
        </trans-unit>
        <trans-unit id="4cac758eff9ae8b1951cfa88daf6efd8e4c9f9dd" translate="yes" xml:space="preserve">
          <source>Carp gives two ways to control this.</source>
          <target state="translated">Карп дает два способа контролировать это.</target>
        </trans-unit>
        <trans-unit id="bca0e3c0ab768e90d91b7158f9afa5173ab39d46" translate="yes" xml:space="preserve">
          <source>Case 2 is also deceptive in that you're accessing a variable called %hashref, not dereferencing through $hashref to the hash it's presumably referencing. That would be case 3.</source>
          <target state="translated">Случай 2 также обманчив в том,что вы получаете доступ к переменной под названием %hashref,а не разыменовываете ее через $hashref на хэш,на который она предположительно ссылается.Это был бы случай 3.</target>
        </trans-unit>
        <trans-unit id="298d6337ccd66315823554fe2294fb2258cef971" translate="yes" xml:space="preserve">
          <source>Case Mappings/SpecialCasing</source>
          <target state="translated">Картины корпуса/спецкорпуса</target>
        </trans-unit>
        <trans-unit id="12c50192a130e9814d8ea8606bd466ad9981e92e" translate="yes" xml:space="preserve">
          <source>Case and abbreviations</source>
          <target state="translated">Дело и аббревиатуры</target>
        </trans-unit>
        <trans-unit id="71820be5979516bbf68abefb91861f6a5f447350" translate="yes" xml:space="preserve">
          <source>Case translation operators use the Unicode case translation tables.</source>
          <target state="translated">Операторы перевода кейсов используют таблицы перевода кейсов Unicode.</target>
        </trans-unit>
        <trans-unit id="9fc0b2fddd3396951a95310fbd8003b367dba5dd" translate="yes" xml:space="preserve">
          <source>Case, white space, hyphens, and underscores are ignored in the input parameters (except for the trailing underscore in the old-form grandfathered-in general category property value &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; ).</source>
          <target state="translated">Регистр, пробелы, дефисы и подчеркивания игнорируются во входных параметрах (за исключением завершающего подчеркивания в значении свойства &lt;code&gt;&quot;L_&quot;&lt;/code&gt; старой формы, унаследованном от общей категории , которое лучше записать как &lt;code&gt;&quot;LC&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c97ea35c0c010d6bc3fa3e2766ca1eeed20cb95" translate="yes" xml:space="preserve">
          <source>Case, white space, hyphens, and underscores are ignored in the input property name (except for the trailing underscore in the old-form grandfathered-in general category property value &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; ).</source>
          <target state="translated">Регистр, пробелы, дефисы и символы подчеркивания игнорируются в имени входного свойства (за исключением конечного подчеркивания в старом значении свойства &lt;code&gt;&quot;L_&quot;&lt;/code&gt; в общей категории , которое лучше записывается как &lt;code&gt;&quot;LC&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5913a3e508c3f58147c3a7ea4922d97aeb2d10bc" translate="yes" xml:space="preserve">
          <source>Casefolding is the process of mapping strings to a form where case differences are erased; comparing two strings in their casefolded form is effectively a way of asking if two strings are equal, regardless of case.</source>
          <target state="translated">Casefolding-это процесс сопоставления строк с формой,в которой различия в регистре стираются;сравнение двух строк в их casefolded форме фактически является способом спросить,равны ли две строки,независимо от случая.</target>
        </trans-unit>
        <trans-unit id="3efae3773aea3e6418118bae37722e49dd2d43fd" translate="yes" xml:space="preserve">
          <source>Cases 1 and 2 above behave identically: they run the code contained in the variable $x. (Although case 2 has misleading double quotes making the reader wonder what else might be happening (nothing is).) Cases 3 and 4 likewise behave in the same way: they run the code &lt;code&gt;'$x'&lt;/code&gt; , which does nothing but return the value of $x. (Case 4 is preferred for purely visual reasons, but it also has the advantage of compiling at compile-time instead of at run-time.) Case 5 is a place where normally you</source>
          <target state="translated">Случаи 1 и 2, приведенные выше, ведут себя одинаково: они запускают код, содержащийся в переменной $ x. (Хотя в случае 2 есть вводящие в заблуждение двойные кавычки, заставляющие читателя задуматься, что еще может происходить (ничего не происходит).) Случаи 3 и 4 ведут себя аналогичным образом: они запускают код &lt;code&gt;'$x'&lt;/code&gt; , который ничего не делает, кроме как возвращает значение из $ x. (Вариант 4 предпочтителен по чисто визуальным причинам, но он также имеет преимущество компиляции во время компиляции, а не во время выполнения.) Случай 5 - это место, где обычно вы</target>
        </trans-unit>
        <trans-unit id="fce28c3834b46c5817fa1ba652ddba28baf2570f" translate="yes" xml:space="preserve">
          <source>Casting between function pointers and data pointers</source>
          <target state="translated">Литье между указателями функций и указателями данных</target>
        </trans-unit>
        <trans-unit id="6f9e423b5bc8680aa5b16ed1908f25312d66ad7e" translate="yes" xml:space="preserve">
          <source>Casting pointers to integers or casting integers to pointers</source>
          <target state="translated">Бросание указателей в целые числа или бросание целых чисел в указатели</target>
        </trans-unit>
        <trans-unit id="499253af5f67ae889bc3aabf24d35d8ba82de0e2" translate="yes" xml:space="preserve">
          <source>Casts I to the internal I32 type used by that perl.</source>
          <target state="translated">Отбрасывает I на внутренний тип I32,используемый этим perl.</target>
        </trans-unit>
        <trans-unit id="c174d6be41280356a91ddfdde65f079878120639" translate="yes" xml:space="preserve">
          <source>Catch stopped child processes.</source>
          <target state="translated">Ловите остановленные детские процессы.</target>
        </trans-unit>
        <trans-unit id="c2d335ad7e81fdf6a55a7304c8fd31f60f0fc162" translate="yes" xml:space="preserve">
          <source>Catchall routine to clean up problem MM[SK]/Make macros. Expands macros in any directory specification, in order to avoid juxtaposing two VMS-syntax directories when MM[SK] is run. Also expands expressions which are all macro, so that we can tell how long the expansion is, and avoid overrunning DCL's command buffer when MM[KS] is running.</source>
          <target state="translated">Catchall рутина для очистки проблемы MM[SK]/Сделать макросы.Расширяет макросы в любой спецификации каталога,чтобы избежать сопоставления двух синтаксических каталогов VMS при запуске MM[SK].Также разворачивает выражения,которые являются всеми макросами,чтобы можно было определить длительность разворачивания и избежать переполнения буфера команд DCL при запуске MM[KS].</target>
        </trans-unit>
        <trans-unit id="6b5024a9f7f3c46574351ad45dcdeceef2016767" translate="yes" xml:space="preserve">
          <source>Categories of modules range from text manipulation to network protocols to database integration to graphics. A categorized list of modules is also available from CPAN.</source>
          <target state="translated">Категории модулей варьируются от манипуляций с текстом до сетевых протоколов,от интеграции баз данных до графики.Категоризированный список модулей также доступен в CPAN.</target>
        </trans-unit>
        <trans-unit id="337a8f7bd3bdbf4fe42f0b9d4b42a95657d8e9f9" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_COLLATE&lt;/code&gt; : Collation</source>
          <target state="translated">Категория &lt;code&gt;LC_COLLATE&lt;/code&gt; : сопоставление</target>
        </trans-unit>
        <trans-unit id="beec9c5a8a3b1200e13a31c08cab20f387038371" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_CTYPE&lt;/code&gt; : Character Types</source>
          <target state="translated">Категория &lt;code&gt;LC_CTYPE&lt;/code&gt; : Типы символов</target>
        </trans-unit>
        <trans-unit id="38233af031be21177bea3a81f92c8363621b4861" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_MONETARY&lt;/code&gt; : Formatting of monetary amounts</source>
          <target state="translated">Категория &lt;code&gt;LC_MONETARY&lt;/code&gt; : Форматирование денежных сумм</target>
        </trans-unit>
        <trans-unit id="19550402e5a1f045b848054b7a9e298b524aa833" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_NUMERIC&lt;/code&gt; : Numeric Formatting</source>
          <target state="translated">Категория &lt;code&gt;LC_NUMERIC&lt;/code&gt; : числовое форматирование</target>
        </trans-unit>
        <trans-unit id="d6caa2ce2c0ba347d49ead269d4ac916346dc572" translate="yes" xml:space="preserve">
          <source>Category Hierarchy</source>
          <target state="translated">Категориальная иерархия</target>
        </trans-unit>
        <trans-unit id="ad6f8c0088808eee492b45306c0d1b94608c6f08" translate="yes" xml:space="preserve">
          <source>Category LC_COLLATE: Collation</source>
          <target state="translated">Категория LC_COLLATE:Сопоставление</target>
        </trans-unit>
        <trans-unit id="a51fd3f6ab56831c7fdec8dd63db4d84c5e5ddfb" translate="yes" xml:space="preserve">
          <source>Category LC_CTYPE: Character Types</source>
          <target state="translated">Категория LC_CTYPE:Типы символов</target>
        </trans-unit>
        <trans-unit id="7682ad4955d10f9cf4cc9354213c179454f72007" translate="yes" xml:space="preserve">
          <source>Category LC_MONETARY: Formatting of monetary amounts</source>
          <target state="translated">Категория LC_MONETARY:Форматирование денежных сумм</target>
        </trans-unit>
        <trans-unit id="07571e7937ae3f96671e4cd556a4abc903111a57" translate="yes" xml:space="preserve">
          <source>Category LC_NUMERIC: Numeric Formatting</source>
          <target state="translated">Категория LC_NUMERIC:Числовое форматирование</target>
        </trans-unit>
        <trans-unit id="85dc017dda24f39d24e2b45c927b49e37ad2e173" translate="yes" xml:space="preserve">
          <source>Causes symbolic links to be followed. Since directory trees with symbolic links (followed) may contain files more than once and may even have cycles, a hash has to be built up with an entry for each file. This might be expensive both in space and time for a large directory tree. See &lt;a href=&quot;#follow_fast&quot;&gt;follow_fast&lt;/a&gt; and &lt;a href=&quot;#follow_skip&quot;&gt;follow_skip&lt;/a&gt; below. If either</source>
          <target state="translated">Заставляет переходить по символическим ссылкам. Поскольку деревья каталогов с символическими ссылками (по которым следуют) могут содержать файлы более одного раза и могут даже иметь циклы, необходимо создать хэш с записью для каждого файла. Для большого дерева каталогов это может быть затратно как по пространству, так и по времени. См. &lt;a href=&quot;#follow_fast&quot;&gt;Follow_fast&lt;/a&gt; и &lt;a href=&quot;#follow_skip&quot;&gt;follow_skip&lt;/a&gt; ниже. Если либо</target>
        </trans-unit>
        <trans-unit id="d8a6af2ce96fea0e83364432bebd24ee2a299a63" translate="yes" xml:space="preserve">
          <source>Causes the script to sleep for (integer) EXPR seconds, or forever if no argument is given. Returns the integer number of seconds actually slept.</source>
          <target state="translated">Заставляет скрипт спать на (целые)EXPR секунды,или навсегда,если не задан ни один аргумент.Возвращает целое число фактически уснувших секунд.</target>
        </trans-unit>
        <trans-unit id="adc5b4e7301cfc17b319d4424a90aed30a644658" translate="yes" xml:space="preserve">
          <source>Causes this module to use Time::HiRes module, allowing milliseconds to be returned by subsequent calls to ping().</source>
          <target state="translated">Заставляет этот модуль использовать модуль Time::HiRes,позволяющий возвращать миллисекунды при последующих вызовах ping().</target>
        </trans-unit>
        <trans-unit id="37cbf6da85f81293291a3c0f70bd83d035bcf72f" translate="yes" xml:space="preserve">
          <source>Causing infinite loops etc.</source>
          <target state="translated">Вызывает бесконечные циклы и т.д.</target>
        </trans-unit>
        <trans-unit id="b643ecf0f138f7f21c8987e5e43245e6d526028e" translate="yes" xml:space="preserve">
          <source>Causing signals (especially SIGFPE and SIGALARM) to affect your process.</source>
          <target state="translated">Вызывающие сигналы (особенно SIGFPE и SIGALARM),которые влияют на Ваш процесс.</target>
        </trans-unit>
        <trans-unit id="f78acd3020c7919c3876959d6358cd31ff6af003" translate="yes" xml:space="preserve">
          <source>Caution : use this option only if you know that your coderefs will be properly reconstructed by &lt;code&gt;B::Deparse&lt;/code&gt; .</source>
          <target state="translated">Внимание: используйте эту опцию только в том случае, если вы знаете, что ваши ссылки на код будут правильно реконструированы &lt;code&gt;B::Deparse&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09dbd187de708ee21b01806ae5b0ca883102654a" translate="yes" xml:space="preserve">
          <source>Caveat</source>
          <target state="translated">Caveat</target>
        </trans-unit>
        <trans-unit id="6c45fe1a67bfe92ba6c4b2119ad5a8061d201ed7" translate="yes" xml:space="preserve">
          <source>Caveat: this is a bit of a kludge. In particular note that if anything that appears on STDERR looks like a test result the test harness will get confused. Use this option only if you understand the consequences and can live with the risk.</source>
          <target state="translated">Кэвит:это немного похоже на клешню.В частности,обратите внимание,что если что-то,что появится на STDERR,будет выглядеть как результат теста,то тестовый жгут будет сбит с толку.Используйте эту опцию только в том случае,если вы понимаете последствия и можете жить с риском.</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="ff751acd8ebba60eb35fa0124046207c1b17cdf6" translate="yes" xml:space="preserve">
          <source>Caveats mentioned in the description of &lt;code&gt;$!&lt;/code&gt; generally apply to &lt;code&gt;$^E&lt;/code&gt; , also.</source>
          <target state="translated">Предостережения, упомянутые в описании &lt;code&gt;$!&lt;/code&gt; как правило , относятся к &lt;code&gt;$^E&lt;/code&gt; , а также.</target>
        </trans-unit>
        <trans-unit id="2480f4a426ee72a3f6daf975f41b3976cd3d2933" translate="yes" xml:space="preserve">
          <source>Caveats:</source>
          <target state="translated">Caveats:</target>
        </trans-unit>
        <trans-unit id="f904f3f198a1560f6503e45c25c6ea2281d83a7a" translate="yes" xml:space="preserve">
          <source>Central America</source>
          <target state="translated">Центральная Америка</target>
        </trans-unit>
        <trans-unit id="09fe478d9ba3d71f7c5e36ee02ee955b6c719e87" translate="yes" xml:space="preserve">
          <source>Centralized management of resources</source>
          <target state="translated">Централизованное управление ресурсами</target>
        </trans-unit>
        <trans-unit id="e7fb0f6eb972f6f903d5d8421fe8c063e2da1bee" translate="yes" xml:space="preserve">
          <source>Cerebral C and C++ programmers should take note of the following:</source>
          <target state="translated">Программистам на Церебральных Си и Си++следует обратить внимание на следующее:</target>
        </trans-unit>
        <trans-unit id="098ac784d3c3bb2be5336c055d431de5a978080e" translate="yes" xml:space="preserve">
          <source>Certain Perl operations that are set-up within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; retain that effect even outside the scope. These include:</source>
          <target state="translated">Определенные операции Perl, которые настраиваются в пределах области &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; сохраняют этот эффект даже за пределами области действия. Это включает:</target>
        </trans-unit>
        <trans-unit id="e445bdfbac84e85f57db984a7caae903e4414a5a" translate="yes" xml:space="preserve">
          <source>Certain SV types are considered 'special'. They're represented by B::SPECIAL and are referred to by a number from the specialsv_list. This array maps that number back to the name of the SV (like 'Nullsv' or '&amp;amp;PL_sv_undef').</source>
          <target state="translated">Некоторые типы SV считаются &amp;laquo;особыми&amp;raquo;. Они представлены B :: SPECIAL и упоминаются числом из specialsv_list. Этот массив отображает это число обратно на имя SV (например, &amp;laquo;Nullsv&amp;raquo; или &amp;laquo;&amp;amp; PL_sv_undef&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="8edd6c5378e389e68c51d5a29d8332712fb8e453" translate="yes" xml:space="preserve">
          <source>Certain Win32 programs called from cygwin programs might need some environment variable, such as e.g. ADODB needs %COMMONPROGRAMFILES%. Call Cygwin::sync_winenv() to copy all Win32 environment variables to your process and note that cygwin will warn on every encounter of non-POSIX paths.</source>
          <target state="translated">Некоторым Win32-программам,вызываемым из cygwin-программ,может понадобиться некоторая переменная окружения,например,ADODB нужны %COMMONPROGRAMFILES%.Вызовите Cygwin::sync_winenv(),чтобы скопировать все переменные окружения Win32 в ваш процесс и заметьте,что cygwin будет предупреждать о каждой встрече не-POSIX путей.</target>
        </trans-unit>
        <trans-unit id="0c5660d59e9ee01e56352c20048bf93f027e41cc" translate="yes" xml:space="preserve">
          <source>Certain built-in Unix features help prevent this most of the time. For instance, filehandles have a &quot;close on exec&quot; flag, which is set</source>
          <target state="translated">Определенные встроенные функции Unix помогают предотвратить это в большинстве случаев.Например,файловые дескрипторы имеют флаг &quot;Закрыть при выполнении&quot;,который установлен</target>
        </trans-unit>
        <trans-unit id="fd014b85703f4f23ce05ad07fc9ca7afcd931605" translate="yes" xml:space="preserve">
          <source>Certain code points are considered problematic. These are Unicode surrogates, Unicode non-characters, and code points above the Unicode maximum of 0x10FFFF. By default these are considered regular code points, but certain situations warrant special handling for them. If &lt;code&gt;flags&lt;/code&gt; contains UTF8_DISALLOW_ILLEGAL_INTERCHANGE, all three classes are treated as malformations and handled as such. The flags UTF8_DISALLOW_SURROGATE, UTF8_DISALLOW_NONCHAR, and UTF8_DISALLOW_SUPER (meaning above the legal Unicode maximum) can be set to disallow these categories individually.</source>
          <target state="translated">Определенные кодовые точки считаются проблемными. Это суррогаты Unicode, несимволы Unicode и кодовые точки выше максимального значения Unicode, равного 0x10FFFF. По умолчанию они считаются обычными кодовыми точками, но некоторые ситуации требуют особого обращения с ними. Если &lt;code&gt;flags&lt;/code&gt; содержит UTF8_DISALLOW_ILLEGAL_INTERCHANGE, все три класса рассматриваются как дефекты и обрабатываются как таковые. Флаги UTF8_DISALLOW_SURROGATE, UTF8_DISALLOW_NONCHAR и UTF8_DISALLOW_SUPER (то есть выше допустимого максимума Unicode) могут быть установлены, чтобы запретить эти категории по отдельности.</target>
        </trans-unit>
        <trans-unit id="b02926fb30feba66eb4b4ce45a0942f1b38d9143" translate="yes" xml:space="preserve">
          <source>Certain file systems have a limited ability to store the times on a file at the expected level of precision. For example, the FAT and HPFS filesystem are unable to create dates on files with a finer granularity than two seconds. This is a limitation of the filesystems, not of utime().</source>
          <target state="translated">Некоторые файловые системы имеют ограниченную возможность хранить время в файле с ожидаемым уровнем точности.Например,файловая система FAT и HPFS не могут создавать даты на файлах с более высокой детализацией,чем две секунды.Это ограничение файловых систем,а не функция utime().</target>
        </trans-unit>
        <trans-unit id="37d5dc51bb3f3e8f5f3c6c97dff5e509bb4e1f21" translate="yes" xml:space="preserve">
          <source>Certain glyph variations for character display are standardized. This lists the non-Unihan ones; the Unihan ones are also not used by Perl, and are in a separate Unicode data base &lt;a href=&quot;http://www.unicode.org/ivd&quot;&gt;http://www.unicode.org/ivd&lt;/a&gt;</source>
          <target state="translated">Некоторые варианты глифов для отображения символов стандартизированы. Здесь перечислены не-Unihan; Unihan также не используются Perl и находятся в отдельной базе данных Unicode &lt;a href=&quot;http://www.unicode.org/ivd&quot;&gt;http://www.unicode.org/ivd&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0b6cb7913f706e7a5eacb52a20195ab75fdb53c" translate="yes" xml:space="preserve">
          <source>Certain internal algorithms used in the implementation of Perl can be attacked by choosing the input carefully to consume large amounts of either time or space or both. This can lead into the so-called</source>
          <target state="translated">Некоторые внутренние алгоритмы,используемые в реализации Perl,могут быть атакованы тщательным выбором входа,потребляющего большое количество либо времени,либо пространства,либо и того,и другого.Это может привести к так называемому</target>
        </trans-unit>
        <trans-unit id="96a386c331a35cc383e0fb0a983cc8532170d5c8" translate="yes" xml:space="preserve">
          <source>Certain internal hooks can be also set using the &lt;code&gt;%SIG&lt;/code&gt; hash. The routine indicated by &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; is called when a warning message is about to be printed. The warning message is passed as the first argument. The presence of a &lt;code&gt;__WARN__&lt;/code&gt; hook causes the ordinary printing of warnings to &lt;code&gt;STDERR&lt;/code&gt; to be suppressed. You can use this to save warnings in a variable, or turn warnings into fatal errors, like this:</source>
          <target state="translated">Некоторые внутренние перехватчики также могут быть установлены с помощью хэша &lt;code&gt;%SIG&lt;/code&gt; . Подпрограмма, обозначенная &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; вызывается, когда должно быть напечатано предупреждающее сообщение. Предупреждение передается как первый аргумент. Наличие &lt;code&gt;__WARN__&lt;/code&gt; приводит к подавлению обычной печати предупреждений в &lt;code&gt;STDERR&lt;/code&gt; . Вы можете использовать это, чтобы сохранить предупреждения в переменной или превратить предупреждения в фатальные ошибки, например:</target>
        </trans-unit>
        <trans-unit id="b64cf21b984a47fe95b3c69dcb71d4d0db67b02a" translate="yes" xml:space="preserve">
          <source>Certain properties are accessible also via core function calls. These are:</source>
          <target state="translated">Определенные свойства доступны также через вызовы основных функций.Это:</target>
        </trans-unit>
        <trans-unit id="d27dc694c4a5fbe7b1d7b9b68b009abd079b8811" translate="yes" xml:space="preserve">
          <source>Certain signals like SEGV, ILL, and BUS are generated by virtual memory addressing errors and similar &quot;faults&quot;. These are normally fatal: there is little a Perl-level handler can do with them. So Perl delivers them immediately rather than attempting to defer them.</source>
          <target state="translated">Некоторые сигналы,такие как SEGV,ILL и BUS,генерируются ошибками адресации виртуальной памяти и похожими &quot;ошибками&quot;.Обычно они фатальны:с ними мало что может сделать Perl-обработчик.Поэтому Perl доставляет их немедленно,а не пытается их отложить.</target>
        </trans-unit>
        <trans-unit id="536f525355145c06eb27b43dd05eceed140e4f71" translate="yes" xml:space="preserve">
          <source>Cf. &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">Ср. &lt;a href=&quot;#Prerequisites&quot;&gt;Предпосылки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33b90248a63c8f592d9dd961a96f1170c6b169a4" translate="yes" xml:space="preserve">
          <source>Ch. 15 of &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; by Larry Wall, Tom Christiansen, Jon Orwant; O'Reilly &amp;amp; Associates; ISBN 0-596-00027-8</source>
          <target state="translated">Гл. 15 из &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; Ларри Уолла, Тома Кристиансена, Джона Орванта; O'Reilly &amp;amp; Associates; ISBN 0-596-00027-8</target>
        </trans-unit>
        <trans-unit id="9fe7a1219b8f1fb95786f557bb47edce5064d4db" translate="yes" xml:space="preserve">
          <source>Ch. 15, pp. 403 of &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; by Larry Wall, Tom Christiansen, Jon Orwant; O'Reilly &amp;amp; Associates; ISBN 0-596-00027-8</source>
          <target state="translated">Гл. 15, стр. 403 &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; Ларри Уолла, Тома Кристиансена, Джона Орванта; O'Reilly &amp;amp; Associates; ISBN 0-596-00027-8</target>
        </trans-unit>
        <trans-unit id="d493056c1da57a03b23c818e0ed106583a75e9df" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for meta data about the source. This defaults to an empty hashref. See &lt;a href=&quot;#assemble_meta&quot;&gt;assemble_meta&lt;/a&gt; for more info.</source>
          <target state="translated">Привязка геттеров / сеттеров к метаданным об источнике. По умолчанию это пустой хэш-адрес. См. &lt;a href=&quot;#assemble_meta&quot;&gt;Assembly_meta&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="d37cf9e27bcdb9224f76d171f3ec04e137833197" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the configuration of the available source handlers. This is a hashref keyed on handler class whose values contain config to be passed onto the handlers during detection &amp;amp; creation. Class names may be fully qualified or abbreviated, eg:</source>
          <target state="translated">Привязка геттера / сеттера к конфигурации доступных исходных обработчиков. Это хэш-ссылка, привязанная к классу обработчика, значения которого содержат конфигурацию, которая будет передана обработчикам во время обнаружения и создания. Имена классов могут быть полными или сокращенными, например:</target>
        </trans-unit>
        <trans-unit id="b8e3ffd2df81751de57a2fcbade1ad6be4b71309" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the flag that dictates whether STDOUT and STDERR should be merged (where appropriate). Defaults to undef.</source>
          <target state="translated">Цепочки геттер/установщик для флага,который диктует,должны ли STDOUT и STDERR быть объединены (где это уместно).По умолчанию-undef.</target>
        </trans-unit>
        <trans-unit id="fa3fa390f5b11b8da2cbd991e38fe6758bc14f24" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the list of command-line arguments that should be passed to the source (where appropriate). Defaults to undef.</source>
          <target state="translated">Цепочки getter/setter для списка аргументов командной строки,которые должны быть переданы источнику (при необходимости).По умолчанию-undef.</target>
        </trans-unit>
        <trans-unit id="6875662647c6f1815155ad787b4b2ddda071cbb4" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the list of command-line switches that should be passed to the source (where appropriate). Defaults to undef.</source>
          <target state="translated">Цепочка getter/setter для списка переключателей командной строки,которые должны быть переданы источнику (при необходимости).По умолчанию-undef.</target>
        </trans-unit>
        <trans-unit id="484c910049e12d13347861a5be23f00c8321a0d6" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the raw TAP source. This is a reference, as it may contain large amounts of data (eg: raw TAP).</source>
          <target state="translated">Цепочки приёма/установки для источника TAP-сырца.Это ссылка,так как она может содержать большое количество данных (например:необработанный TAP).</target>
        </trans-unit>
        <trans-unit id="74174c42fd62072d6ee5d0a7398fa78f44559dff" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the source's configuration, if any has been provided by the user. How it's used is up to you. This defaults to an empty hashref. See &lt;a href=&quot;#config_for&quot;&gt;config_for&lt;/a&gt; for more info.</source>
          <target state="translated">Привязка геттера / сеттера к конфигурации источника, если таковая была предоставлена ​​пользователем. Как его использовать - решать вам. По умолчанию это пустой хэш-адрес. См. &lt;a href=&quot;#config_for&quot;&gt;Config_for&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="930947c88d29b6f085064df238c19e6c783d2627" translate="yes" xml:space="preserve">
          <source>Change and/or examine calling process's signal mask. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;sigset&lt;/code&gt; and &lt;code&gt;oldsigset&lt;/code&gt; arguments. Consult your system's &lt;code&gt;sigprocmask&lt;/code&gt; manpage for details.</source>
          <target state="translated">Измените и / или изучите сигнальную маску вызывающего процесса. Это использует объекты &lt;code&gt;POSIX::SigSet&lt;/code&gt; для аргументов &lt;code&gt;sigset&lt;/code&gt; и &lt;code&gt;oldsigset&lt;/code&gt; . За подробностями &lt;code&gt;sigprocmask&lt;/code&gt; к странице руководства sigprocmask вашей системы .</target>
        </trans-unit>
        <trans-unit id="47d396cd087a5a418e7353a4c45e6745ef5c9209" translate="yes" xml:space="preserve">
          <source>Change directory to /</source>
          <target state="translated">Изменить каталог на /</target>
        </trans-unit>
        <trans-unit id="6b35e50e6231ecd47c51f9d0f60727b3553c64b4" translate="yes" xml:space="preserve">
          <source>Change directory to the parent of the current directory.</source>
          <target state="translated">Изменить директорию на родительскую для текущей директории.</target>
        </trans-unit>
        <trans-unit id="6eba8b030681c63dbaca5c083fcb141f12c78bec" translate="yes" xml:space="preserve">
          <source>Change mode of $file to $mode.</source>
          <target state="translated">Изменить режим $файла на $-режим.</target>
        </trans-unit>
        <trans-unit id="61d995589ae611e0f4742d3a0cee92270e9ce91b" translate="yes" xml:space="preserve">
          <source>Change mode of $file to $mode. The mode can be a string or a number which is interpreted as octal whether or not a leading 0 is given.</source>
          <target state="translated">Изменить режим $файла на $-режим.Режим может быть строкой или числом,которое интерпретируется как восьмеричное,независимо от того,задан ли ведущий 0 или нет.</target>
        </trans-unit>
        <trans-unit id="3a726567b511b7efb1456c7410856f0769212a35" translate="yes" xml:space="preserve">
          <source>Change owner $file to $uname and $gname.</source>
          <target state="translated">Изменить владельца $файла на $uname и $gname.</target>
        </trans-unit>
        <trans-unit id="c8ee54b2a4c58db1f595c468254073b721477b33" translate="yes" xml:space="preserve">
          <source>Change owner of $file to $user. If a $group is given that is changed as well. You can also pass a single parameter with a colon separating the use and group as in 'root:wheel'.</source>
          <target state="translated">Смените владельца $файла на $пользователя.Если дана группа $,то и она тоже будет изменена.Вы также можете передать один параметр с двоеточием,разделяющим использование и группу,как в 'root:wheel'.</target>
        </trans-unit>
        <trans-unit id="aad1746f9b9be805d4a6fb33e7166d4914a6f334" translate="yes" xml:space="preserve">
          <source>Change settings for the deflate object &lt;code&gt;$d&lt;/code&gt; .</source>
          <target state="translated">Измените настройки для объекта deflate &lt;code&gt;$d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6d7824dc2aeadd89378b9289a40f5baa46baf4c" translate="yes" xml:space="preserve">
          <source>Change settings for the deflate stream &lt;code&gt;$d&lt;/code&gt; .</source>
          <target state="translated">Измените настройки для дефляционного потока &lt;code&gt;$d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f11138eabf6401374fb6ae86928421d28ef54011" translate="yes" xml:space="preserve">
          <source>Change settings for the deflate stream &lt;code&gt;$gz&lt;/code&gt; .</source>
          <target state="translated">Измените настройки для дефляционного потока &lt;code&gt;$gz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc239982b98cfe5d4bf5a6e97925df8bb9b66869" translate="yes" xml:space="preserve">
          <source>Change style of array and hash dump. If true, short array may be printed on one line.</source>
          <target state="translated">Изменение стиля массива и хэш-дампа.Если переменная имеет значение true,то короткий массив может быть выведен на одну строку.</target>
        </trans-unit>
        <trans-unit id="fc31075534bc4e1f585b7495788835ad53a5ed8b" translate="yes" xml:space="preserve">
          <source>Change style of string dump. Default value of &lt;code&gt;tick&lt;/code&gt; is &lt;code&gt;auto&lt;/code&gt; , one can enable either double-quotish dump, or single-quotish by setting it to &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;. By default, characters with high bit set are printed</source>
          <target state="translated">Изменить стиль дампа строки. По умолчанию &lt;code&gt;tick&lt;/code&gt; установлена &lt;code&gt;auto&lt;/code&gt; , можно включить дамп в двойных или одинарных кавычках, установив для него значение &lt;code&gt;&quot;&lt;/code&gt; или &lt;code&gt;'&lt;/code&gt; . По умолчанию печатаются символы с установленным старшим битом.</target>
        </trans-unit>
        <trans-unit id="f62e18a300604c2d0b5ad8fe35bb69d2aa22ab89" translate="yes" xml:space="preserve">
          <source>Change the line reading:</source>
          <target state="translated">Измените показания линии:</target>
        </trans-unit>
        <trans-unit id="0d5ba9e028e71b7c3b6cfe8c3482bc252c2e3c53" translate="yes" xml:space="preserve">
          <source>Change the size of code list window (default is 10 lines).</source>
          <target state="translated">Изменить размер окна списка кодов (по умолчанию 10 строк).</target>
        </trans-unit>
        <trans-unit id="569c8a1e53a15c2ffb329e7aa5e5500846bb9b87" translate="yes" xml:space="preserve">
          <source>Change the style of array and hash output. If &lt;code&gt;compactDump&lt;/code&gt; , short array may be printed on one line.</source>
          <target state="translated">Измените стиль вывода массива и хэша. Если &lt;code&gt;compactDump&lt;/code&gt; , короткий массив может быть напечатан в одну строку.</target>
        </trans-unit>
        <trans-unit id="1ddcd6267b5132268c1d3a6f92ad7c15283dd197" translate="yes" xml:space="preserve">
          <source>Change the style of string dump. The default value for &lt;code&gt;quote&lt;/code&gt; is &lt;code&gt;auto&lt;/code&gt; ; one can enable double-quotish or single-quotish format by setting it to &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;, respectively. By default, characters with their high bit set are printed verbatim.</source>
          <target state="translated">Измените стиль дампа строки. Значение по умолчанию для &lt;code&gt;quote&lt;/code&gt; - &lt;code&gt;auto&lt;/code&gt; ; можно включить формат двойных или одинарных кавычек, установив для него значение &lt;code&gt;&quot;&lt;/code&gt; или &lt;code&gt;'&lt;/code&gt; соответственно. По умолчанию символы с их старшим битом печатаются дословно.</target>
        </trans-unit>
        <trans-unit id="38de6175abf6da26b6853e84b1888d7d917d0994" translate="yes" xml:space="preserve">
          <source>Change this to</source>
          <target state="translated">Изменить это на</target>
        </trans-unit>
        <trans-unit id="0558571d851a8433aad3815610abfaf16dab150e" translate="yes" xml:space="preserve">
          <source>Change to an empty directory, and create a placeholder &amp;lt;Makefile.PL&amp;gt;:</source>
          <target state="translated">Перейдите в пустой каталог и создайте заполнитель &amp;lt;Makefile.PL&amp;gt;:</target>
        </trans-unit>
        <trans-unit id="bbbe466cbb3d9bd600f9492fe6485ab273c48d8c" translate="yes" xml:space="preserve">
          <source>Change to the &lt;code&gt;./pod&lt;/code&gt; directory of the build tree, download the Perl logo</source>
          <target state="translated">Перейдите в каталог &lt;code&gt;./pod&lt;/code&gt; дерева сборки, загрузите логотип Perl</target>
        </trans-unit>
        <trans-unit id="862ce088bc8e3f533e4bd14af7a6130330f00504" translate="yes" xml:space="preserve">
          <source>Change to the directory of extraction.</source>
          <target state="translated">Изменение в каталог извлечения.</target>
        </trans-unit>
        <trans-unit id="1a08104f60eb079d49d12cd925f4ebbd076f6abd" translate="yes" xml:space="preserve">
          <source>Change to the extension directory where its source files are present.</source>
          <target state="translated">Переход в каталог расширений,в котором находятся его исходные файлы.</target>
        </trans-unit>
        <trans-unit id="622a8441b6e400617adf70d8d715f1f671124897" translate="yes" xml:space="preserve">
          <source>Change to the installation directory (most probably ADE:), and extract the binary distribution:</source>
          <target state="translated">Перейдите в установочный каталог (скорее всего ADE:)и распакуйте бинарный дистрибутив:</target>
        </trans-unit>
        <trans-unit id="8aa57de6dce6ee1c35c6aba7426503281876b258" translate="yes" xml:space="preserve">
          <source>Changes</source>
          <target state="translated">Changes</target>
        </trans-unit>
        <trans-unit id="d82ce619d11521a894a962f613af5bfbbfd623ad" translate="yes" xml:space="preserve">
          <source>Changes / enhancements you plan to make in the future.</source>
          <target state="translated">Изменения/улучшения,которые вы планируете внести в будущем.</target>
        </trans-unit>
        <trans-unit id="4371a5117e6fef40651394dbe58dc03dbb87745b" translate="yes" xml:space="preserve">
          <source>Changes EQUALIZE_TIMESTAMP to set revision date of target file to one second later than source file, since MMK interprets precisely equal revision dates for a source and target file as a sign that the target needs to be updated.</source>
          <target state="translated">Изменяет EQUALIZE_TIMESTAMP,чтобы установить дату ревизии целевого файла на одну секунду позже,чем исходный файл,так как MMK интерпретирует точно равные даты ревизий для исходного и целевого файла как признак того,что целевой файл нуждается в обновлении.</target>
        </trans-unit>
        <trans-unit id="4d2ce6a709b5b2cac8d8c837247b977c30d65233" translate="yes" xml:space="preserve">
          <source>Changes are always applied directly to the main development branch, called &quot;blead&quot;. Some patches may be backported to a maintenance branch. If you think your patch is appropriate for the maintenance branch (see &lt;a href=&quot;perlpolicy#MAINTENANCE-BRANCHES&quot;&gt;MAINTENANCE BRANCHES in perlpolicy&lt;/a&gt;), please explain why when you submit it.</source>
          <target state="translated">Изменения всегда применяются непосредственно к основной ветке разработки, называемой &amp;laquo;blead&amp;raquo;. Некоторые исправления могут быть перенесены в ветку обслуживания. Если вы считаете, что ваш патч подходит для обслуживающей ветви (см. &lt;a href=&quot;perlpolicy#MAINTENANCE-BRANCHES&quot;&gt;ПОДРАЗДЕЛЕНИЯ ОБСЛУЖИВАНИЯ в perlpolicy&lt;/a&gt; ), пожалуйста, объясните почему, когда вы его отправляете.</target>
        </trans-unit>
        <trans-unit id="1aa5832c7b70a5878149d5b5588b7d55b7c3bff5" translate="yes" xml:space="preserve">
          <source>Changes for h2xs as of Perl 5.8.x by Renee Baecker</source>
          <target state="translated">Изменения для h2xs на Perl 5.8.x от Renee Baecker</target>
        </trans-unit>
        <trans-unit id="62a553e5ccf5c46fdfc0ab8ea84db2a7f76cbebc" translate="yes" xml:space="preserve">
          <source>Changes how to run the linker.</source>
          <target state="translated">Изменения в запуске компоновщика.</target>
        </trans-unit>
        <trans-unit id="f786f1f1a07415a1d8f2db0065ca900fcd53b8f6" translate="yes" xml:space="preserve">
          <source>Changes in code reference aliasing</source>
          <target state="translated">Изменения кодовых ссылок на псевдонимы</target>
        </trans-unit>
        <trans-unit id="be9cab3f4b47428605082907ec95e1b8c3df99df" translate="yes" xml:space="preserve">
          <source>Changes that might break existing code, either on the perl or C level</source>
          <target state="translated">Изменения,которые могут нарушить существующий код,либо на уровне perl,либо на уровне C</target>
        </trans-unit>
        <trans-unit id="db0ec37c30cf600ec53fc96678818cec2782658c" translate="yes" xml:space="preserve">
          <source>Changes the access and modification times on each file of a list of files. The first two elements of the list must be the NUMERIC access and modification times, in that order. Returns the number of files successfully changed. The inode change time of each file is set to the current time. For example, this code has the same effect as the Unix touch(1) command when the files</source>
          <target state="translated">Изменяет время доступа и модификации каждого файла списка файлов.Первые два элемента списка должны быть ЧИСЛОВЫМИ ВРЕМЯМИ доступа и модификации в этом порядке.Возвращает количество успешно измененных файлов.Время модификации каждого файла устанавливается на текущее время.Например,этот код имеет тот же эффект,что и команда Unix touch(1),когда файлы</target>
        </trans-unit>
        <trans-unit id="4b4b4c86467333f8b7a7b80f4a01e7d1918a1a32" translate="yes" xml:space="preserve">
          <source>Changes the name of a file; an existing file NEWNAME will be clobbered. Returns true for success, false otherwise.</source>
          <target state="translated">Изменяет имя файла;существующий файл Новое имя будет забито.Возвращает true для успеха,false иначе.</target>
        </trans-unit>
        <trans-unit id="e8b1fed7eb953f32d4b671261c0f298f432b77d6" translate="yes" xml:space="preserve">
          <source>Changes the owner (and group) of a list of files. The first two elements of the list must be the</source>
          <target state="translated">Изменение владельца (и группы)списка файлов.Первыми двумя элементами списка должны быть</target>
        </trans-unit>
        <trans-unit id="1c7b4f13f0f9f250ad54a523828fe1dadc6bd8b6" translate="yes" xml:space="preserve">
          <source>Changes the path separator with .</source>
          <target state="translated">Изменяет разделитель путей с помощью кнопки .</target>
        </trans-unit>
        <trans-unit id="2250a43272b4d912fcb35a54a90fbad3a0416b17" translate="yes" xml:space="preserve">
          <source>Changes the permissions of a list of files. The first element of the list must be the numeric mode, which should probably be an octal number, and which definitely should</source>
          <target state="translated">Изменяет права доступа к списку файлов.Первым элементом списка должен быть цифровой режим,который,вероятно,должен быть восьмеричным числом,и который,безусловно,должен</target>
        </trans-unit>
        <trans-unit id="9bd248973528630e1bf213ec672fc9ef7ebeb306" translate="yes" xml:space="preserve">
          <source>Changes the style of printout of strings. Possible values are &lt;code&gt;unctrl&lt;/code&gt; and &lt;code&gt;quote&lt;/code&gt; .</source>
          <target state="translated">Изменяет стиль распечатки строк. Возможные значения: &lt;code&gt;unctrl&lt;/code&gt; и &lt;code&gt;quote&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e08e00af7afee19133f68fcfa5c4f8c0f8fe0ac1" translate="yes" xml:space="preserve">
          <source>Changes the value of specified keys and returns the changed part.</source>
          <target state="translated">Изменяет значение указанных клавиш и возвращает измененную часть.</target>
        </trans-unit>
        <trans-unit id="3647bf8ac5df1429e21c0b23760ce2722ca59762" translate="yes" xml:space="preserve">
          <source>Changes the working directory to EXPR, if possible. If EXPR is omitted, changes to the directory specified by &lt;code&gt;$ENV{HOME}&lt;/code&gt; , if set; if not, changes to the directory specified by &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; . (Under VMS, the variable &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; is also checked, and used if it is set.) If neither is set, &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; does nothing. It returns true on success, false otherwise. See the example under &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если возможно, меняет рабочий каталог на EXPR. Если EXPR опущен, изменяется в каталог, указанный в &lt;code&gt;$ENV{HOME}&lt;/code&gt; , если он установлен; в противном случае переходит в каталог, указанный в &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; . (В VMS переменная &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; также проверяется и используется, если она установлена.) Если ни одна из них не установлена, &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; ничего не делает. В случае успеха возвращает true, в противном случае - false. См. Пример под &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1086b5985822b0db7454ba706dee00d51c0ece8" translate="yes" xml:space="preserve">
          <source>Changes the working directory to EXPR, if possible. If EXPR is omitted, changes to the directory specified by &lt;code&gt;$ENV{HOME}&lt;/code&gt; , if set; if not, changes to the directory specified by &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; . (Under VMS, the variable &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; is also checked, and used if it is set.) If neither is set, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; does nothing. It returns true on success, false otherwise. See the example under &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если возможно, меняет рабочий каталог на EXPR. Если EXPR опущен, изменяется в каталог, указанный в &lt;code&gt;$ENV{HOME}&lt;/code&gt; , если он установлен; в противном случае переходит в каталог, указанный в &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; . (В VMS переменная &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; также проверяется и используется, если она установлена.) Если ни одна из них не установлена, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; ничего не делает. В случае успеха возвращает true, в противном случае - false. См. Пример под &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fabf30bdd6213704e83eeade8922d6faf64b5fd" translate="yes" xml:space="preserve">
          <source>Changes to the array are reflected in the file immediately.</source>
          <target state="translated">Изменения в массиве сразу же отражаются в файле.</target>
        </trans-unit>
        <trans-unit id="6803890e536e93e672442636eafadf71854a5e67" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution associated with this module has been unpacked and opens a subshell there. Exiting the subshell returns.</source>
          <target state="translated">Изменения в директории,в которой был распакован дистрибутив,связанный с этим модулем,и открывается там подоболочка.Возвращается выход из подоболочки.</target>
        </trans-unit>
        <trans-unit id="e4202a82c344d58c60462a8105e61b62b6fab966" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and opens a subshell there. Exiting the subshell returns.</source>
          <target state="translated">Изменения в каталоге,в котором был распакован дистрибутив,и открытие там оболочки.Возвращается выход из подоболочки.</target>
        </trans-unit>
        <trans-unit id="b8731050a8a7a9f8df1483a6a44fb58459c692c8" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs &lt;code&gt;make clean&lt;/code&gt; there.</source>
          <target state="translated">Переходит в каталог, в который распакован дистрибутив, и запускает там &lt;code&gt;make clean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cf85dcec97c298d42a66cbcf92705947c20dbb8" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs &lt;code&gt;make test&lt;/code&gt; there.</source>
          <target state="translated">Переходит в каталог, в который был распакован дистрибутив, и запускает там &lt;code&gt;make test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce66a23f208dbab005ac63aadf6ed1d3fdec95de" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs something like</source>
          <target state="translated">Изменения в каталоге,в котором дистрибутив был распакован и выполняет что-то вроде</target>
        </trans-unit>
        <trans-unit id="936a954c5967e4fb0f809c16524179a6172e7265" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs the external command &lt;code&gt;make install&lt;/code&gt; there. If &lt;code&gt;make&lt;/code&gt; has not yet been run, it will be run first. A &lt;code&gt;make test&lt;/code&gt; is issued in any case and if this fails, the install is cancelled. The cancellation can be avoided by letting &lt;code&gt;force&lt;/code&gt; run the &lt;code&gt;install&lt;/code&gt; for you.</source>
          <target state="translated">Переходит в каталог, в который распакован дистрибутив, и запускает там внешнюю команду &lt;code&gt;make install&lt;/code&gt; . Если &lt;code&gt;make&lt;/code&gt; еще не был запущен, он будет запущен первым. В любом случае выполняется &lt;code&gt;make test&lt;/code&gt; и если это не удается, установка отменяется. Отмены можно избежать, позволив &lt;code&gt;force&lt;/code&gt; запустить &lt;code&gt;install&lt;/code&gt; за вас.</target>
        </trans-unit>
        <trans-unit id="3d3b3f1bc0445ad3c7b600875f43d2f0c065a2c3" translate="yes" xml:space="preserve">
          <source>Changing parts of a string via the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator. (We avoid use of this term to mean &lt;b&gt;variable interpolation&lt;/b&gt;.)</source>
          <target state="translated">Изменение частей строки с помощью оператора &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; . (Мы избегаем использования этого термина для обозначения &lt;b&gt;интерполяции переменных&lt;/b&gt; .)</target>
        </trans-unit>
        <trans-unit id="d7a71579d5e34f224f4b7a44cf8dcd2dbcaa9c26" translate="yes" xml:space="preserve">
          <source>Changing the BTREE sort order</source>
          <target state="translated">Изменение порядка сортировки BTREE</target>
        </trans-unit>
        <trans-unit id="e17474358ec9689585fdd62efb80f2dbb797c7f5" translate="yes" xml:space="preserve">
          <source>Changing the case of a scalar, that is, using &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\l&lt;/code&gt; in double-quotish contexts, such as regular expression substitutions.</source>
          <target state="translated">Изменение регистра скаляра, то есть использование &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; и &lt;code&gt;\l&lt;/code&gt; в контекстах, заключенных в двойные кавычки, таких как регулярное выражение замены.</target>
        </trans-unit>
        <trans-unit id="df6f7a30e2f621822d21b001b70407e472b19e52" translate="yes" xml:space="preserve">
          <source>Changing the program's locale should be avoided by XS code. Nevertheless, certain non-Perl libraries called from XS, such as &lt;code&gt;Gtk&lt;/code&gt; do so. When this happens, Perl needs to be told that the locale has changed. Use this function to do so, before returning to Perl.</source>
          <target state="translated">Следует избегать изменения локали программы с помощью кода XS. Тем не менее, некоторые библиотеки, не относящиеся к Perl, вызываемые из XS, например &lt;code&gt;Gtk&lt;/code&gt; , делают это. Когда это происходит, Perl нужно сообщить, что языковой стандарт изменился. Используйте для этого эту функцию, прежде чем вернуться к Perl.</target>
        </trans-unit>
        <trans-unit id="c8e1948c28b77c30e8fb57b5aff7a3dda34db561" translate="yes" xml:space="preserve">
          <source>Character Class Tests</source>
          <target state="translated">Тесты на определение характера</target>
        </trans-unit>
        <trans-unit id="09d5ec3fa8dfa6626f64711e08afb866161e2c4e" translate="yes" xml:space="preserve">
          <source>Character Classes and other Special Escapes</source>
          <target state="translated">Классы персонажей и другие специальные пейзажи</target>
        </trans-unit>
        <trans-unit id="34a9fd5b966d1c074e2cee0432c22ae8d6ad1a1d" translate="yes" xml:space="preserve">
          <source>Character Data</source>
          <target state="translated">Характеристики Данные</target>
        </trans-unit>
        <trans-unit id="f710e107c2984efab355453a12a4c6ea080f5d29" translate="yes" xml:space="preserve">
          <source>Character Encoding Scheme</source>
          <target state="translated">Схема кодирования символов</target>
        </trans-unit>
        <trans-unit id="4cf0ae92275a457503e6f1502570311bf8750725" translate="yes" xml:space="preserve">
          <source>Character Encodings for Input and Output</source>
          <target state="translated">Кодировка символов для входа и выхода</target>
        </trans-unit>
        <trans-unit id="20ec21ca7596ab8473642f9e0c8182b338e1d924" translate="yes" xml:space="preserve">
          <source>Character Escapes</source>
          <target state="translated">Пейзажи персонажей</target>
        </trans-unit>
        <trans-unit id="70a24f05bd3a1beeddb3d790c2d17711c420ebac" translate="yes" xml:space="preserve">
          <source>Character Ranges</source>
          <target state="translated">Диапазоны характеров</target>
        </trans-unit>
        <trans-unit id="d2f44b6bf2d1636aa1643ea45ee60f381bdc2aa5" translate="yes" xml:space="preserve">
          <source>Character Ranges and Classes</source>
          <target state="translated">Диапазоны и классы персонажей</target>
        </trans-unit>
        <trans-unit id="def6212f0e6caec39a85ca7bef2c8e9c647d0bd2" translate="yes" xml:space="preserve">
          <source>Character and block devices. devmajor and devminor should specify the major and minor device numbers.</source>
          <target state="translated">Символ и блок устройства.девайсор и девайсор должны указывать основной и второстепенный номера устройства.</target>
        </trans-unit>
        <trans-unit id="fae5ab4ae64b19dd3884a0674108f420e439509e" translate="yes" xml:space="preserve">
          <source>Character case changing</source>
          <target state="translated">Изменение регистра символов</target>
        </trans-unit>
        <trans-unit id="5c948c7ed34065b8008d26ee3576913d72d9cc02" translate="yes" xml:space="preserve">
          <source>Character class.</source>
          <target state="translated">Класс персонажей.</target>
        </trans-unit>
        <trans-unit id="bf238be65bb5e7ebb05fdca2c63f71cc0a076a1a" translate="yes" xml:space="preserve">
          <source>Character classes</source>
          <target state="translated">Классы характера</target>
        </trans-unit>
        <trans-unit id="b8d7eaa1fb86bcd30ed62dcabd2cca16ff64d891" translate="yes" xml:space="preserve">
          <source>Character classes also have ordinary and special characters, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; and are matched using an escape:</source>
          <target state="translated">Классы символов также имеют обычные и специальные символы, но наборы обычных и специальных символов внутри класса символов отличаются от наборов вне класса символов. Специальные символы для класса символов &lt;code&gt;-]\^$&lt;/code&gt; они сопоставляются с помощью escape- символа :</target>
        </trans-unit>
        <trans-unit id="334bc0b92c2c74eb72d0f1cbef4062f7de8fe371" translate="yes" xml:space="preserve">
          <source>Character classes in regular expressions match based on the character properties specified in the Unicode properties database.</source>
          <target state="translated">Классы символов в регулярных выражениях совпадают на основе свойств символов,указанных в базе данных свойств Юникода.</target>
        </trans-unit>
        <trans-unit id="11a965778572465b297760373bc0ab9a5fe50dd4" translate="yes" xml:space="preserve">
          <source>Character classification</source>
          <target state="translated">Классификация символов</target>
        </trans-unit>
        <trans-unit id="0c5cbf9ae05984cb96206744590414bbd855ee84" translate="yes" xml:space="preserve">
          <source>Character code set ID 0037 is a mapping of the ASCII plus Latin-1 characters (i.e. ISO 8859-1) to an EBCDIC set. 0037 is used in North American English locales on the OS/400 operating system that runs on AS/400 computers. CCSID 0037 differs from ISO 8859-1 in 236 places; in other words they agree on only 20 code point values.</source>
          <target state="translated">Набор символов ID 0037 представляет собой сопоставление символов ASCII плюс латинских-1 (т.е.ISO 8859-1)с набором EBCDIC.0037 используется в североамериканских английских локалях на операционной системе OS/400,которая работает на компьютерах AS/400.CCSID 0037 отличается от ISO 8859-1 236 местами;другими словами,они согласовывают только 20 значений кодовых точек.</target>
        </trans-unit>
        <trans-unit id="40746c1bc8caca4e8597fe4115baf09938eb4d04" translate="yes" xml:space="preserve">
          <source>Character code set ID 1047 is also a mapping of the ASCII plus Latin-1 characters (i.e. ISO 8859-1) to an EBCDIC set. 1047 is used under Unix System Services for OS/390 or z/OS, and OpenEdition for VM/ESA. CCSID 1047 differs from CCSID 0037 in eight places, and from ISO 8859-1 in 236.</source>
          <target state="translated">Набор символов ID 1047 также представляет собой сопоставление символов ASCII plus Latin-1 (т.е.ISO 8859-1)с набором EBCDIC.1047 используется в системных службах Unix для OS/390 или z/OS и OpenEdition для VM/ESA.CCSID 1047 отличается от CCSID 0037 на восемь позиций,и от ISO 8859-1 на 236.</target>
        </trans-unit>
        <trans-unit id="d32256dddf94c58de00208fb12aedf2f63688834" translate="yes" xml:space="preserve">
          <source>Character encodings in Perl</source>
          <target state="translated">Кодировка символов на Perl</target>
        </trans-unit>
        <trans-unit id="704c519e45bb20896b1cac037d9dc1f99d2661e9" translate="yes" xml:space="preserve">
          <source>Character ranges in regular expression bracketed character classes ( e.g., &lt;code&gt;/[a-z]/&lt;/code&gt; ) and in the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (also known as &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) operator are not magically Unicode-aware. What this means is that &lt;code&gt;[A-Za-z]&lt;/code&gt; will not magically start to mean &quot;all alphabetic letters&quot; (not that it does mean that even for 8-bit characters; for those, if you are using locales (&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), use &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; ; and if not, use the 8-bit-aware property &lt;code&gt;\p{alpha}&lt;/code&gt; ).</source>
          <target state="translated">Диапазоны символов в классах символов в квадратных скобках регулярных выражений (например, &lt;code&gt;/[a-z]/&lt;/code&gt; ) и в операторе &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (также известном как &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ) магическим образом не поддерживают Unicode. Это означает, что &lt;code&gt;[A-Za-z]&lt;/code&gt; не начнет волшебным образом означать &quot;все буквы алфавита&quot; (не то чтобы это означает, что даже для 8-битных символов; для них, если вы используете локали ( &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; ), используйте &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; ; в противном случае используйте 8-битное свойство &lt;code&gt;\p{alpha}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="562694c8fa3ccd4702e9b5a3b83e76744b7e6c8c" translate="yes" xml:space="preserve">
          <source>Character set modifier behavior prior to Perl 5.14</source>
          <target state="translated">Поведение модификатора набора символов до Perl 5.14</target>
        </trans-unit>
        <trans-unit id="e156811acff779a0efdf0149cf0ae9a427195a9d" translate="yes" xml:space="preserve">
          <source>Character set modifiers</source>
          <target state="translated">Модификаторы набора символов</target>
        </trans-unit>
        <trans-unit id="5b676207ec8a3106cd8805847b93ca527620baf4" translate="yes" xml:space="preserve">
          <source>Character sets and character encoding</source>
          <target state="translated">Наборы символов и кодировка символов</target>
        </trans-unit>
        <trans-unit id="0dd9c6f6d08e52935fa08236378969d99f092384" translate="yes" xml:space="preserve">
          <source>Characters in Pod documents may be conveyed either as literals, or by number in E&amp;lt;n&amp;gt; codes, or by an equivalent mnemonic, as in E&amp;lt;eacute&amp;gt; which is exactly equivalent to E&amp;lt;233&amp;gt;. The numbers are the Latin1/Unicode values, even on EBCDIC platforms.</source>
          <target state="translated">Символы в документах Pod могут передаваться либо как литералы, либо по номерам в кодах E &amp;lt;n&amp;gt;, либо с помощью эквивалентной мнемоники, как в E &amp;lt;eacute&amp;gt;, что в точности эквивалентно E &amp;lt;233&amp;gt;. Цифры представляют собой значения Latin1 / Unicode даже на платформах EBCDIC.</target>
        </trans-unit>
        <trans-unit id="dcec8944860f789b80b281bc04ffb139e54ea11c" translate="yes" xml:space="preserve">
          <source>Characters may be literals or any of the escape sequences accepted in double-quoted strings. But there is no interpolation, so &lt;code&gt;&quot;$&quot;&lt;/code&gt; and &lt;code&gt;&quot;@&quot;&lt;/code&gt; are treated as literals. A hyphen at the beginning or end, or preceded by a backslash is considered a literal. Escape sequence details are in &lt;a href=&quot;#Quote-and-Quote-like-Operators&quot;&gt;the table near the beginning of this section&lt;/a&gt;. It is a bug in Perl v5.22 that something like</source>
          <target state="translated">Символы могут быть литералами или любой из управляющих последовательностей, допускаемых в строках с двойными кавычками. Но здесь нет интерполяции, поэтому &lt;code&gt;&quot;$&quot;&lt;/code&gt; и &lt;code&gt;&quot;@&quot;&lt;/code&gt; обрабатываются как литералы. Дефис в начале или конце, или перед ним стоит обратная косая черта, считается буквальным. Детали escape-последовательности находятся в &lt;a href=&quot;#Quote-and-Quote-like-Operators&quot;&gt;таблице в начале этого раздела&lt;/a&gt; . Это ошибка в Perl v5.22, что-то вроде</target>
        </trans-unit>
        <trans-unit id="9963f5cdbae1775d9f83906b3a5cbef411c1ebf6" translate="yes" xml:space="preserve">
          <source>Characters may be specified using a metacharacter syntax much like that used in C: &quot;\n&quot; matches a newline, &quot;\t&quot; a tab, &quot;\r&quot; a carriage return, &quot;\f&quot; a form feed, etc. More generally, \</source>
          <target state="translated">Символы могут быть заданы с использованием синтаксиса мета-символов,аналогичного синтаксису,используемому в языке C:&quot;\n&quot; соответствует новой строке,&quot;\t&quot;-закладке,&quot;\r&quot;-возврату каретки,&quot;\f&quot;-подаче формы и т.д.В более общем плане,&quot;\&quot;.</target>
        </trans-unit>
        <trans-unit id="6677fa2bd945e79a1181804df0a34874fe2d47f6" translate="yes" xml:space="preserve">
          <source>Characters that are not coded in logical order and to be rearranged. If &lt;code&gt;UCA_Version&lt;/code&gt; is equal to or less than 11, default is:</source>
          <target state="translated">Символы, которые не закодированы в логическом порядке и подлежат изменению. Если &lt;code&gt;UCA_Version&lt;/code&gt; равно или меньше 11, значение по умолчанию:</target>
        </trans-unit>
        <trans-unit id="87ac5130c826b6e80d3a59535b9d6400acad5f5d" translate="yes" xml:space="preserve">
          <source>Characters that may carry a special meaning inside a character class are: &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, and are discussed below. They can be escaped with a backslash, although this is sometimes not needed, in which case the backslash may be omitted.</source>
          <target state="translated">Символы, которые могут иметь особое значение внутри класса символов: &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; и &lt;code&gt;]&lt;/code&gt; , обсуждаются ниже. Их можно экранировать с помощью обратной косой черты, хотя иногда в этом нет необходимости, и в этом случае обратную косую черту можно опустить.</target>
        </trans-unit>
        <trans-unit id="d4dafb52fa02eb41cdb895328b5e1fe67da8f211" translate="yes" xml:space="preserve">
          <source>Charles Bailey</source>
          <target state="translated">Чарльз Бейли</target>
        </trans-unit>
        <trans-unit id="5e62c89e7209c56822c7a94ca2800f8e7a4f3ee5" translate="yes" xml:space="preserve">
          <source>Charles Bailey bailey@cor.newman.upenn.edu Craig Berry craigberry@mac.com Dan Sugalski dan@sidhe.org John Malmberg wb8tyw@qsl.net</source>
          <target state="translated">Чарльз Бейли bailey@cor.newman.upenn.edu Крейг Берри craigberry@mac.com Дэн Шугальский dan@sidhe.org Джон Мальмберг wb8tyw@qsl.net</target>
        </trans-unit>
        <trans-unit id="22cb7bacebab63abf9230cfeb35ec01ffa449880" translate="yes" xml:space="preserve">
          <source>Charles Wilson &amp;lt;cwilson@ece.gatech.edu&amp;gt;, Eric Fifer &amp;lt;egf7@columbia.edu&amp;gt;, alexander smishlajev &amp;lt;als@turnhere.com&amp;gt;, Steven Morlock &amp;lt;newspost@morlock.net&amp;gt;, Sebastien Barre &amp;lt;Sebastien.Barre@utc.fr&amp;gt;, Teun Burgers &amp;lt;burgers@ecn.nl&amp;gt;, Gerrit P. Haase &amp;lt;gp@familiehaase.de&amp;gt;, Reini Urban &amp;lt;rurban@cpan.org&amp;gt;, Jan Dubois &amp;lt;jand@activestate.com&amp;gt;, Jerry D. Hedden &amp;lt;jdhedden@cpan.org&amp;gt;.</source>
          <target state="translated">Чарльз Уилсон &amp;lt;cwilson@ece.gatech.edu&amp;gt;, Эрик Файфер &amp;lt;egf7@columbia.edu&amp;gt;, Александр Смишлаев &amp;lt;als@turnhere.com&amp;gt;, Стивен Морлок &amp;lt;newspost@morlock.net&amp;gt;, Себастьян Барре &amp;lt;Sebastien.Barre@utc .fr&amp;gt;, Теун Бургерс &amp;lt;burgers@ecn.nl&amp;gt;, Геррит П. Хаасе &amp;lt;gp@familiehaase.de&amp;gt;, Рейни Урбан &amp;lt;rurban@cpan.org&amp;gt;, Ян Дюбуа &amp;lt;jand@activestate.com&amp;gt;, Джерри Д. Хедден &amp;lt;jdhedden@cpan.org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="7f45f4145d31345768a09969013e2d6f185c06a1" translate="yes" xml:space="preserve">
          <source>Chdir to the djgpp subdirectory of perl toplevel and type the following commands:</source>
          <target state="translated">Chdir в подкаталог djgpp верхнего уровня perl и введите следующие команды:</target>
        </trans-unit>
        <trans-unit id="8940df58b96cd7c07fc9ea07120c785f6f8a4a5c" translate="yes" xml:space="preserve">
          <source>Check a remote host for reachability</source>
          <target state="translated">Проверьте удаленный хост на доступность</target>
        </trans-unit>
        <trans-unit id="d7a845256cebed69e9f121b044f6c493f63a9f2a" translate="yes" xml:space="preserve">
          <source>Check for correct syntax of hyperlinks &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; . See &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; for details.</source>
          <target state="translated">Проверьте правильность синтаксиса гиперссылок &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; . См. Подробности в &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abb3f832fd190f3b3ed53530b24afb5eea0c92cc" translate="yes" xml:space="preserve">
          <source>Check for duplicate declarations: report any of:</source>
          <target state="translated">Проверьте наличие дубликатов деклараций:сообщите о любом из них:</target>
        </trans-unit>
        <trans-unit id="958d7ef30eb1cb4c2c9bdb613326b0eabb0fd9a1" translate="yes" xml:space="preserve">
          <source>Check for malformed or non-existing entities &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">Проверить наличие уродливых или несуществующих сущностей &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e9bacd3ffc2516115599a71ea7b04dc011ace75" translate="yes" xml:space="preserve">
          <source>Check for proper balancing of &lt;code&gt;=begin&lt;/code&gt; and &lt;code&gt;=end&lt;/code&gt; . The contents of such a block are generally ignored, i.e. no syntax checks are performed.</source>
          <target state="translated">Проверьте правильность балансировки &lt;code&gt;=begin&lt;/code&gt; и &lt;code&gt;=end&lt;/code&gt; . Содержимое такого блока обычно игнорируется, т.е. проверка синтаксиса не выполняется.</target>
        </trans-unit>
        <trans-unit id="4cf90762a2de5be38eed8acc089a711c78e01421" translate="yes" xml:space="preserve">
          <source>Check for proper nesting and balancing of &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; and &lt;code&gt;=back&lt;/code&gt; .</source>
          <target state="translated">Проверьте правильность размещения и балансировки &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; и &lt;code&gt;=back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bb965418973274267147c8cc4fc0522a33ac593" translate="yes" xml:space="preserve">
          <source>Check for same nested interior-sequences (e.g. &lt;code&gt;L&amp;lt;...L&amp;lt;...&amp;gt;...&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">Проверьте наличие одинаковых вложенных внутренних последовательностей (например, &lt;code&gt;L&amp;lt;...L&amp;lt;...&amp;gt;...&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="eacd44b00e12dfbcc0672a7ce6d8176f78df3437" translate="yes" xml:space="preserve">
          <source>Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.</source>
          <target state="translated">Проверьте случаи 0 или 3 из cur_env.je_ret,используемые только в контексте eval.</target>
        </trans-unit>
        <trans-unit id="cb0d6f75515a999669b8c1d54704fc6c80c44584" translate="yes" xml:space="preserve">
          <source>Check for unresolved document-internal links. This check may also reveal misspelled links that seem to be internal links but should be links to something else.</source>
          <target state="translated">Проверьте наличие нерассмотренных документов-внутренних ссылок.Эта проверка может также выявить неправильно написанные ссылки,которые кажутся внутренними,но должны быть ссылками на что-то другое.</target>
        </trans-unit>
        <trans-unit id="d6fabbaa68065f92237c60138ecddb521d11db66" translate="yes" xml:space="preserve">
          <source>Check if all required arguments have been provided</source>
          <target state="translated">Проверьте,все ли необходимые аргументы были представлены</target>
        </trans-unit>
        <trans-unit id="f79df82175c5eb3e95e2c6cd96c98c735fe9a6fb" translate="yes" xml:space="preserve">
          <source>Check if the archive contains a certain file. It will return true if the file is in the archive, false otherwise.</source>
          <target state="translated">Проверьте,содержит ли архив определенный файл.Если файл находится в архиве,то возвращается true,в противном случае false.</target>
        </trans-unit>
        <trans-unit id="1a3059c728f920e1399329e5c1ad9c928030d581" translate="yes" xml:space="preserve">
          <source>Check out the MLDBM module, available on CPAN in the directory</source>
          <target state="translated">Проверьте модуль MLDBM,доступный на CPAN в каталоге</target>
        </trans-unit>
        <trans-unit id="ca159b8d6ca8bc89a6d10a26dae1e203c859a67d" translate="yes" xml:space="preserve">
          <source>Check that a hash is in an internally consistent state.</source>
          <target state="translated">Убедитесь,что гашиш находится во внутреннем состоянии.</target>
        </trans-unit>
        <trans-unit id="6c679ad8ca10d169e6a7df72723849d47a11c40b" translate="yes" xml:space="preserve">
          <source>Check that some temporary files did not make into the perl install tree. Run something like this</source>
          <target state="translated">Убедитесь,что некоторые временные файлы не попали в дерево установки perl.Запустите что-нибудь подобное</target>
        </trans-unit>
        <trans-unit id="9defd6564bb9099fa189d5588407b66bb7555daa" translate="yes" xml:space="preserve">
          <source>Check that you have &lt;b&gt;BSD&lt;/b&gt; libraries and headers installed, and - optionally - Berkeley DB headers and libraries, and crypt.</source>
          <target state="translated">Убедитесь, что у вас установлены библиотеки и заголовки &lt;b&gt;BSD&lt;/b&gt; , и - необязательно - заголовки и библиотеки Berkeley DB, а также crypt.</target>
        </trans-unit>
        <trans-unit id="1cfcc4548a2343eadc2629dda5508ccfded48bd5" translate="yes" xml:space="preserve">
          <source>Check that you have link386 installed. It comes standard with OS/2, but may be not installed due to customization. If typing</source>
          <target state="translated">Убедитесь,что у вас установлена link386.Он поставляется в стандартной комплектации с OS/2,но может не быть установлен из-за настройки.Если вы набираете</target>
        </trans-unit>
        <trans-unit id="79d08dd23471c409ed3ca7645ef7d274508c7b47" translate="yes" xml:space="preserve">
          <source>Check the &lt;code&gt;Benchmark&lt;/code&gt; docs for further useful techniques.</source>
          <target state="translated">Ознакомьтесь с документацией по &lt;code&gt;Benchmark&lt;/code&gt; для получения дополнительных полезных методов.</target>
        </trans-unit>
        <trans-unit id="14e9adf4a018a86aa09ce8983af2c630914d716c" translate="yes" xml:space="preserve">
          <source>Check the CPAN Testers if a module should work with your platform but it doesn't behave as you'd expect, or you aren't sure whether or not a module will work under your platform. If the module you want isn't listed there, you can test it yourself and let CPAN Testers know, you can join CPAN Testers, or you can request it be tested.</source>
          <target state="translated">Проверьте CPAN тестеры,должен ли модуль работать с Вашей платформой,но он ведет себя не так,как Вы ожидаете,или Вы не уверены,будет ли модуль работать под Вашей платформой.Если нужного модуля там нет,Вы можете протестировать его самостоятельно и сообщить CPAN тестировщикам,Вы можете присоединиться к CPAN тестировщикам,или Вы можете запросить,чтобы он был протестирован.</target>
        </trans-unit>
        <trans-unit id="5173a90532c2701f8f8cdb88adc2b6f4e6723f22" translate="yes" xml:space="preserve">
          <source>Check the PerlIO::via:: namespace on CPAN for examples of PerlIO layers implemented in Perl. To give you an idea how simple the implementation of a PerlIO layer can look, a simple example is included here.</source>
          <target state="translated">Проверьте PerlIO::via::пространство имен на CPAN для примеров слоев PerlIO,реализованных на Perl.Чтобы дать вам представление о том,как может выглядеть простая реализация слоя PerlIO,здесь приведен простой пример.</target>
        </trans-unit>
        <trans-unit id="1c7b70cf85fde5d10a4d6750e595901816be3c74" translate="yes" xml:space="preserve">
          <source>Check the Pod syntax of a document</source>
          <target state="translated">Проверить синтаксис Pod документа</target>
        </trans-unit>
        <trans-unit id="f91480d26f728c8f70780347d46c3882a8821adf" translate="yes" xml:space="preserve">
          <source>Check the contents of the distribution. Read the module's documentation, looking for reasons why you might have trouble using it with MacPerl. Look for</source>
          <target state="translated">Проверьте содержимое дистрибутива.Ознакомьтесь с документацией модуля и узнайте о причинах,по которым у вас могут возникнуть проблемы с использованием MacPerl.Ищите</target>
        </trans-unit>
        <trans-unit id="9e48cf52c63c2d0f64a711912719de261c9edcba" translate="yes" xml:space="preserve">
          <source>Check the validity of the stream if</source>
          <target state="translated">Проверьте действительность потока,если</target>
        </trans-unit>
        <trans-unit id="e9e8967b00a81a9d723ab21648f7d0d7f4c57338" translate="yes" xml:space="preserve">
          <source>Checkcc.U</source>
          <target state="translated">Checkcc.U</target>
        </trans-unit>
        <trans-unit id="82a2acac5750a7cb12b97634f29af8ec944c5757" translate="yes" xml:space="preserve">
          <source>Checking the environment entails either looking ahead on the trail, looking behind, or both. &lt;code&gt;^&lt;/code&gt; looks behind, to see that there are no characters before. &lt;code&gt;$&lt;/code&gt; looks ahead, to see that there are no characters after. &lt;code&gt;\b&lt;/code&gt; looks both ahead and behind, to see if the characters on either side differ in their &quot;word-ness&quot;.</source>
          <target state="translated">Чтобы проверить окружающую среду, нужно либо смотреть вперед на тропу, либо назад, либо и то, и другое. &lt;code&gt;^&lt;/code&gt; оглядывается назад, чтобы убедиться, что раньше не было персонажей. &lt;code&gt;$&lt;/code&gt; смотрит вперед, чтобы убедиться, что после него нет символов. &lt;code&gt;\b&lt;/code&gt; смотрит вперед и назад, чтобы увидеть, отличаются ли символы с обеих сторон своей &amp;laquo;словесностью&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="223804327875b075a53dd25f4221175abf389942" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt;. Tests:</source>
          <target state="translated">Проверяет &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; . Тесты:</target>
        </trans-unit>
        <trans-unit id="3a60535c47ae3686d1195136cbe426251f2f931d" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate()&lt;/a&gt;&lt;/code&gt; on a filehandle just opened for write - I do not know why this should or should not work.</source>
          <target state="translated">Проверяет &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate()&lt;/a&gt;&lt;/code&gt; на только что открытом дескрипторе файла на запись - я не знаю, почему это должно или не должно работать.</target>
        </trans-unit>
        <trans-unit id="564e49285a0398ab07e0e7063594b4b39a5abcbe" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;atime&lt;/code&gt; and &lt;code&gt;mtime&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; - unfortunately, HPFS provides only 2sec time granularity (for compatibility with FAT?).</source>
          <target state="translated">Проверки &lt;code&gt;atime&lt;/code&gt; и &lt;code&gt;mtime&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; - (? Для совместимости с FAT) , к сожалению, HPFS обеспечивает только 2SEC время зернистость.</target>
        </trans-unit>
        <trans-unit id="e7aa1e4bbcb9ef8e50cbb1ca2e0aa94d40c33e10" translate="yes" xml:space="preserve">
          <source>Checks for VMS directory spec as well as Unix separators.</source>
          <target state="translated">Проверка спецификации каталога VMS,а также Unix-разделителей.</target>
        </trans-unit>
        <trans-unit id="3af941bd688efd7585a7f0e144f9af47e846d7a5" translate="yes" xml:space="preserve">
          <source>Checks for the perl program under several common perl extensions.</source>
          <target state="translated">Проверяет perl программу в нескольких общих расширениях perl.</target>
        </trans-unit>
        <trans-unit id="f3d96161e784b66068319a1db708dc0748d310a2" translate="yes" xml:space="preserve">
          <source>Checks if a group with the given name has matched something.</source>
          <target state="translated">Проверяет,подходит ли группа с заданным именем.</target>
        </trans-unit>
        <trans-unit id="1b64ff69951ab67fee8d9d86a7a4cf97007ecbf7" translate="yes" xml:space="preserve">
          <source>Checks if the expression has been evaluated inside of recursion.</source>
          <target state="translated">Проверяет,было ли выражение оценено внутри рекурсии.</target>
        </trans-unit>
        <trans-unit id="c6dad515448c742f2dc10676e5ccdb019e7a0c22" translate="yes" xml:space="preserve">
          <source>Checks if the expression has been evaluated while executing directly inside of the n-th capture group. This check is the regex equivalent of</source>
          <target state="translated">Проверяет,было ли выражение вычислено при выполнении непосредственно внутри n-ой группы захвата.Эта проверка является регекс-эквивалентом</target>
        </trans-unit>
        <trans-unit id="29b9caf4fecb2c45031e3e282976736db6a59c9c" translate="yes" xml:space="preserve">
          <source>Checks if the numbered capturing group has matched something.</source>
          <target state="translated">Проверяет,соответствует ли пронумерованная группа захвата чему-то.</target>
        </trans-unit>
        <trans-unit id="7915221a7e3c9b01fb693fd7e47a678921143862" translate="yes" xml:space="preserve">
          <source>Checks if two arrays are equivalent. This is a deep check, so multi-level structures are handled correctly.</source>
          <target state="translated">Проверяет,эквивалентны ли два массива.Это глубокая проверка,поэтому многоуровневые структуры обрабатываются правильно.</target>
        </trans-unit>
        <trans-unit id="e40bfce6a6d81449f234a025589a2a5b020bf9fa" translate="yes" xml:space="preserve">
          <source>Checks to make sure the $module or $object can do these @methods (works with functions, too).</source>
          <target state="translated">Проверяет,может ли $модуль или $объект выполнять эти @методы (работает и с функциями).</target>
        </trans-unit>
        <trans-unit id="55b2f57a95767c489c56b01d1268c9dfc91fb618" translate="yes" xml:space="preserve">
          <source>Checks to see if an SV is tainted. Returns TRUE if it is, FALSE if not.</source>
          <target state="translated">Проверяет,не испорчен ли SV.Возвращает TRUE,если он загрязнен,FALSE,если нет.</target>
        </trans-unit>
        <trans-unit id="d3c0b5dd82119b45805bc8cb1d101b8d9a91fd41" translate="yes" xml:space="preserve">
          <source>Checks to see if the current operating system is one of the given flavors.</source>
          <target state="translated">Проверяет,является ли текущая операционная система одним из заданных вкусов.</target>
        </trans-unit>
        <trans-unit id="963de9ea3a8bb874b459828c02df2b61c6ee5c78" translate="yes" xml:space="preserve">
          <source>Checks to see if the given &lt;code&gt;$object-&amp;gt;isa($class)&lt;/code&gt; . Also checks to make sure the object was defined in the first place. Handy for this sort of thing:</source>
          <target state="translated">Проверяет, является ли данный &lt;code&gt;$object-&amp;gt;isa($class)&lt;/code&gt; . Также проверяет, был ли объект определен изначально. Подходит для таких вещей:</target>
        </trans-unit>
        <trans-unit id="ac6373448a4e97de67ddcff713361ab246705ca8" translate="yes" xml:space="preserve">
          <source>Checks whether the pattern matches (or does not match, for the '!' variants).</source>
          <target state="translated">Проверяет,совпадает ли шаблон (или не совпадает,для вариантов '!').</target>
        </trans-unit>
        <trans-unit id="acfac0fe5ba60bfef12b9f1265f8a0428c3029f8" translate="yes" xml:space="preserve">
          <source>Checksum field for the tar header</source>
          <target state="translated">Контрольное поле для заголовка смолы</target>
        </trans-unit>
        <trans-unit id="607b7fc55b056c24f1c8cacc3987ff9e25b1dcc5" translate="yes" xml:space="preserve">
          <source>Children's times are only included for terminated children.</source>
          <target state="translated">Детское время учитывается только для уволенных детей.</target>
        </trans-unit>
        <trans-unit id="189da622f3fbd822d1e732459ee0eddbbb7cd8ef" translate="yes" xml:space="preserve">
          <source>China-based Chinese Encodings</source>
          <target state="translated">китайское кодирование</target>
        </trans-unit>
        <trans-unit id="d48a6b368170de01eb1a86e009fcbab8bf75cbe6" translate="yes" xml:space="preserve">
          <source>Chip Salzenberg &amp;lt;</source>
          <target state="translated">Чип Зальценберг &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f92e3f195464d519a284541bb4d50a0a8112bfbe" translate="yes" xml:space="preserve">
          <source>Choose a sensible and consistent version numbering scheme (X.YY is the common Perl module numbering scheme)</source>
          <target state="translated">Выберите разумную и последовательную схему нумерации версий (X.YY-общая схема нумерации модулей Perl).</target>
        </trans-unit>
        <trans-unit id="26d5375b27ee62ca78bfa742d3f1dc585cc2baa3" translate="yes" xml:space="preserve">
          <source>Choose an appropriate license (GPL/Artistic is a good default)</source>
          <target state="translated">Выберите подходящую лицензию (по умолчанию GPL/Художественная лицензия хороша).</target>
        </trans-unit>
        <trans-unit id="80fb4b6e80ff447b460548828bfa4306c5610812" translate="yes" xml:space="preserve">
          <source>Choose an appropriate name</source>
          <target state="translated">Выберите подходящее имя</target>
        </trans-unit>
        <trans-unit id="d82893eb0e9cc35f7e43c5d3e352d8ca738e05ba" translate="yes" xml:space="preserve">
          <source>Choose mnemonic identifiers. If you can't remember what mnemonic means, you've got a problem.</source>
          <target state="translated">Выберите мнемонические идентификаторы.Если ты не можешь вспомнить,что значит мнемонический,у тебя проблема.</target>
        </trans-unit>
        <trans-unit id="ed88e1b0d9bb812c4891cf57f9140a2970de186a" translate="yes" xml:space="preserve">
          <source>Choose wisely.</source>
          <target state="translated">Выбирай с умом.</target>
        </trans-unit>
        <trans-unit id="f68f3e0f920c046e7af5038b0261d7ac2b4646da" translate="yes" xml:space="preserve">
          <source>Chops off the last character of a string and returns the character chopped. It is much more efficient than &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; because it neither scans nor copies the string. If VARIABLE is omitted, chops &lt;code&gt;$_&lt;/code&gt; . If VARIABLE is a hash, it chops the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">Отрезает последний символ строки и возвращает нарезанный символ. Он намного более эффективен, чем &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; поскольку не сканирует и не копирует строку. Если ПЕРЕМЕННАЯ опущена, отбрасывает &lt;code&gt;$_&lt;/code&gt; . Если VARIABLE является хешем, он обрезает значения хеша, но не его ключи, сбрасывая &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; итератор в процессе.</target>
        </trans-unit>
        <trans-unit id="06caa54c979ede41f81e5b2bef50565e9d2ae230" translate="yes" xml:space="preserve">
          <source>Chops off the last character of a string and returns the character chopped. It is much more efficient than &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; because it neither scans nor copies the string. If VARIABLE is omitted, chops &lt;code&gt;$_&lt;/code&gt; . If VARIABLE is a hash, it chops the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">Отрезает последний символ строки и возвращает нарезанный символ. Он намного более эффективен, чем &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; поскольку не сканирует и не копирует строку. Если ПЕРЕМЕННАЯ опущена, отбрасывает &lt;code&gt;$_&lt;/code&gt; . Если VARIABLE является хешем, он обрезает значения хеша, но не его ключи, сбрасывая &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; итератор в процессе.</target>
        </trans-unit>
        <trans-unit id="26d10419c85d39f36202cd562489c0cca977e3fc" translate="yes" xml:space="preserve">
          <source>Circular References</source>
          <target state="translated">Круглые ссылки</target>
        </trans-unit>
        <trans-unit id="29285dd5c7a27e978de25c300eb6e17434a810c3" translate="yes" xml:space="preserve">
          <source>Civility is simple: stick to the facts while avoiding demeaning remarks and sarcasm. It is not enough to be factual. You must also be civil. Responding in kind to incivility is not acceptable.</source>
          <target state="translated">Цивилизованность проста:придерживайтесь фактов,избегая при этом унизительных замечаний и сарказма.Недостаточно быть фактом.Вы также должны быть вежливы.Реакция в натуральной форме на бесцеремонность неприемлема.</target>
        </trans-unit>
        <trans-unit id="41ff354b2b330bd1f8a0587675e43cb32a731f33" translate="yes" xml:space="preserve">
          <source>Class</source>
          <target state="translated">Class</target>
        </trans-unit>
        <trans-unit id="1e7fb31960aaba1258b4feeaa688fcb9336dfe6f" translate="yes" xml:space="preserve">
          <source>Class Creation at Compile Time</source>
          <target state="translated">Создание класса во время компиляции</target>
        </trans-unit>
        <trans-unit id="3d9f77136533c6ff7b7e86c9e68a8e0e99ad867e" translate="yes" xml:space="preserve">
          <source>Class Methods</source>
          <target state="translated">Классовые методы</target>
        </trans-unit>
        <trans-unit id="3fda1907fb10f41774bfaecce153bd2dcb1991b7" translate="yes" xml:space="preserve">
          <source>Class Names as Strings</source>
          <target state="translated">Названия классов как строки</target>
        </trans-unit>
        <trans-unit id="f3e7ba90394996375a075b54692b14d58b442ff0" translate="yes" xml:space="preserve">
          <source>Class method for use inside a thread to change its own behavior for &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Метод класса для использования внутри потока, чтобы изменить его собственное поведение для &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a38175b54007e6872fad46c411f63af989070306" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to detach itself.</source>
          <target state="translated">Метод класса,позволяющий отделить поток.</target>
        </trans-unit>
        <trans-unit id="0e0095b85b575f8ed03afeaf1d333c819ad78615" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to determine whether or not it is detached.</source>
          <target state="translated">Метод класса,позволяющий определить,отсоединен поток или нет.</target>
        </trans-unit>
        <trans-unit id="e73d227a516617a6441904d7cb0de003fa8faaff" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to obtain its own</source>
          <target state="translated">Метод класса,позволяющий потоку получить свой собственный</target>
        </trans-unit>
        <trans-unit id="4898ddb7865314fdb26c20ddf401c39b5082833c" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to obtain its own ID.</source>
          <target state="translated">Метод класса,позволяющий потоку получить свой собственный идентификатор.</target>
        </trans-unit>
        <trans-unit id="fddf8c93c0000670b5cdf682b97e468968024e66" translate="yes" xml:space="preserve">
          <source>Class method to return the current thread's context. This returns the same value as running &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt; inside the current thread's entry point function.</source>
          <target state="translated">Метод класса для возврата контекста текущего потока. Это возвращает то же значение, что и запуск &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt; внутри функции точки входа текущего потока.</target>
        </trans-unit>
        <trans-unit id="61e8fdd13a105e0002eef0663431494746684737" translate="yes" xml:space="preserve">
          <source>Class::Accessor</source>
          <target state="translated">Class::Accessor</target>
        </trans-unit>
        <trans-unit id="394e591256dfedee8ffcd71362b2ad76a446733c" translate="yes" xml:space="preserve">
          <source>Class::C3</source>
          <target state="translated">Class::C3</target>
        </trans-unit>
        <trans-unit id="6d45f04ee3b770e5707c62b830d994b42f571d44" translate="yes" xml:space="preserve">
          <source>Class::Struct</source>
          <target state="translated">Class::Struct</target>
        </trans-unit>
        <trans-unit id="2ea8699f7b748850b0a3f5be8865468e94f1fe28" translate="yes" xml:space="preserve">
          <source>Class::Struct - declare struct-like datatypes as Perl classes</source>
          <target state="translated">Класс::Структура-объявите структуроподобные типы данных как классы Perl.</target>
        </trans-unit>
        <trans-unit id="eabd5b700d02e72052a5dba7a49163d27d89c51a" translate="yes" xml:space="preserve">
          <source>Class::Tiny</source>
          <target state="translated">Class::Tiny</target>
        </trans-unit>
        <trans-unit id="77e7593f3ad030d22758c56fb1b2215a3db2ee44" translate="yes" xml:space="preserve">
          <source>Classes and inherited methods.</source>
          <target state="translated">Занятия и унаследованные методы.</target>
        </trans-unit>
        <trans-unit id="1161f577bbba62479b9f81c878cce8a1b390e9a9" translate="yes" xml:space="preserve">
          <source>Classes based on the &lt;code&gt;id()&lt;/code&gt; function (and hence classes based on &lt;code&gt;idhash()&lt;/code&gt; and &lt;code&gt;fieldhash()&lt;/code&gt; ) show a peculiar behavior in that the class name can be used like an object. Specifically, methods that set or read data associated with an object continue to work as class methods, just as if the class name were an object, distinct from all other objects, with its own data. This object may be called the</source>
          <target state="translated">Классы, основанные на функции &lt;code&gt;id()&lt;/code&gt; (и, следовательно, классы, основанные на &lt;code&gt;idhash()&lt;/code&gt; и &lt;code&gt;fieldhash()&lt;/code&gt; ), демонстрируют своеобразное поведение в том смысле, что имя класса может использоваться как объект. В частности, методы, которые устанавливают или читают данные, связанные с объектом, продолжают работать как методы класса, как если бы имя класса было объектом, отличным от всех других объектов, со своими собственными данными. Этот объект можно назвать</target>
        </trans-unit>
        <trans-unit id="6fe3306e3ca4485e41a1374bad73dbf1cbd32c97" translate="yes" xml:space="preserve">
          <source>Clean out some extra dll.{base,exp} files which might be generated by gcc. Otherwise, take out all *.pdb files.</source>
          <target state="translated">Очистите некоторые дополнительные dll.{base,exp}файлы,которые могут быть сгенерированы gcc.В противном случае,удалите все *.pdb файлы.</target>
        </trans-unit>
        <trans-unit id="44fff3c8b56cfdff2a4b1fd6a798cd0eef5df63b" translate="yes" xml:space="preserve">
          <source>Clean package to evaluate code in</source>
          <target state="translated">Чистый пакет для оценки кода в</target>
        </trans-unit>
        <trans-unit id="10cfbcf1f47828bf537936a130691a497387fb6d" translate="yes" xml:space="preserve">
          <source>Clean up some OS specific files. Plus the temp file used to shorten a lot of commands. And the name mangler database.</source>
          <target state="translated">Очистите некоторые файлы,специфичные для ОС.Плюс временный файл,который использовался для сокращения множества команд.И база данных имен.</target>
        </trans-unit>
        <trans-unit id="81ba7eebd7e241b8a0d3ee0f0dc83f6dcb213ac0" translate="yes" xml:space="preserve">
          <source>Cleaning Up Your Path</source>
          <target state="translated">Очистка вашего пути</target>
        </trans-unit>
        <trans-unit id="c39c68e4f213f84f2b2c6b1480b516f413b3ce6f" translate="yes" xml:space="preserve">
          <source>Cleanup VOS core files</source>
          <target state="translated">Очистка основных файлов VOS</target>
        </trans-unit>
        <trans-unit id="89d75847cf7d1968a70859baea6df0822891a7f0" translate="yes" xml:space="preserve">
          <source>Cleanup at end of scope during compilation: set the max seq number for lexicals in this scope and warn of any lexicals that never got introduced.</source>
          <target state="translated">Очистка в конце scope во время компиляции:установите максимальный номер seq для лексики в этом scope и предупреждайте о любых лексиках,которые никогда не были введены.</target>
        </trans-unit>
        <trans-unit id="090755b1798e39d1824b0b1af3f46d5a518ba79a" translate="yes" xml:space="preserve">
          <source>Clear (remove, delete, ...) all values from the tied array associated with object</source>
          <target state="translated">Очистить (удалить,удалить,...)все значения из связанного массива,связанного с объектом.</target>
        </trans-unit>
        <trans-unit id="f3388c6c3c8ea1834f8402fd24982f91fd19df77" translate="yes" xml:space="preserve">
          <source>Clear all cached times.</source>
          <target state="translated">Очистить все кэшированные времена.</target>
        </trans-unit>
        <trans-unit id="d49faf737a36f02abafb6ec88b142fb354d6f3ff" translate="yes" xml:space="preserve">
          <source>Clear all values from the tied hash</source>
          <target state="translated">Очистите все значения от завязанного хэша</target>
        </trans-unit>
        <trans-unit id="716a5cc3044dab9309ffffc76efde99c4966f639" translate="yes" xml:space="preserve">
          <source>Clear an SV: call any destructors, free up any memory used by the body, and free the body itself. The SV's head is</source>
          <target state="translated">Очистить SV:вызовите любые деструкторы,освободите любую память,используемую телом,и освободите само тело.Голова SV</target>
        </trans-unit>
        <trans-unit id="1f45c3303d209b593f661cc5395c426e8611e2fe" translate="yes" xml:space="preserve">
          <source>Clear end-of-file and error indicators. Should call &lt;code&gt;PerlIOBase_clearerr()&lt;/code&gt; to set the &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; flags, which may suffice.</source>
          <target state="translated">Очистить индикаторы конца файла и ошибки. Следует вызвать &lt;code&gt;PerlIOBase_clearerr()&lt;/code&gt; для установки флагов &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; , чего может хватить.</target>
        </trans-unit>
        <trans-unit id="c704c7949a89c5080ffdb34efe24fd104216362a" translate="yes" xml:space="preserve">
          <source>Clear out all the active components of a CV. This can happen either by an explicit &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; , or by the reference count going to zero. In the former case, we keep the CvOUTSIDE pointer, so that any anonymous children can still follow the full lexical scope chain.</source>
          <target state="translated">Очистите все активные компоненты резюме. Это может произойти либо при явном &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; , либо при обнулении счетчика ссылок. В первом случае мы сохраняем указатель CvOUTSIDE, так что любые анонимные дочерние элементы могут по-прежнему следовать всей цепочке лексической области видимости.</target>
        </trans-unit>
        <trans-unit id="8b91d04ce711fbc4bae58028f0e5981dcdbd67ba" translate="yes" xml:space="preserve">
          <source>Clear something magical that the SV represents. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">Ясно что-нибудь волшебное, что представляет SV. См. &lt;code&gt;sv_magic&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b01d4c4067d3dfce27d55a2e8d3ed5071a36b77" translate="yes" xml:space="preserve">
          <source>Clear the cached time for COUNT rounds of the null loop.</source>
          <target state="translated">Очистите кэшированное время для циклов COUNT в нулевом цикле.</target>
        </trans-unit>
        <trans-unit id="46dd73c2f90db1a664404bb49713a30b15f4ee3a" translate="yes" xml:space="preserve">
          <source>Clear the default .SUFFIXES and put in our own list.</source>
          <target state="translated">Очистите .SUFFIXES по умолчанию и внесите в наш собственный список.</target>
        </trans-unit>
        <trans-unit id="1b8e52e2f767f085e79c243fc87322fea735897b" translate="yes" xml:space="preserve">
          <source>Clear the given handle's error indicator. Returns -1 if the handle is invalid, 0 otherwise.</source>
          <target state="translated">Очистите индикатор ошибки рукоятки.Возвращает -1,если рукоятка недействительна,0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="c4550ae4c0426155ad5abb566d892619b67766b1" translate="yes" xml:space="preserve">
          <source>Clear the pointed to pad value on scope exit. (i.e. the runtime action of 'my')</source>
          <target state="translated">Очистите указанное значение подушки на выходе из прицела.(т.е.действие во время выполнения &quot;моего&quot;).</target>
        </trans-unit>
        <trans-unit id="57a12ccd13dcf014dfc25137bea182ded0f98ac8" translate="yes" xml:space="preserve">
          <source>Clears a slot in the current scratchpad which corresponds to &lt;code&gt;sv&lt;/code&gt; at the end of</source>
          <target state="translated">Очищает слот в текущем блокноте, который соответствует &lt;code&gt;sv&lt;/code&gt; в конце</target>
        </trans-unit>
        <trans-unit id="3ef31da8d602e77684482123705889bd007979e0" translate="yes" xml:space="preserve">
          <source>Clears an array, making it empty. Does not free the memory the av uses to store its list of scalars. If any destructors are triggered as a result, the av itself may be freed when this function returns.</source>
          <target state="translated">Очищает массив,делая его пустым.Не освобождает память,используемую av для хранения списка скаляров.Если в результате сработают деструкторы,то при возвращении этой функции может быть освобождено само av.</target>
        </trans-unit>
        <trans-unit id="8cd338daf3e28d8a698a54a756c5a2c73cce2208" translate="yes" xml:space="preserve">
          <source>Clears any placeholders from a hash. If a restricted hash has any of its keys marked as readonly and the key is subsequently deleted, the key is not actually deleted but is marked by assigning it a value of &amp;amp;PL_sv_placeholder. This tags it so it will be ignored by future operations such as iterating over the hash, but will still allow the hash to have a value reassigned to the key at some future point. This function clears any such placeholder keys from the hash. See Hash::Util::lock_keys() for an example of its use.</source>
          <target state="translated">Удаляет из хеша все заполнители. Если какой-либо из ключей ограниченного хэша помечен как доступный только для чтения, и ключ впоследствии удаляется, ключ фактически не удаляется, а помечается путем присвоения ему значения &amp;amp; PL_sv_placeholder. Это помечает его, поэтому он будет игнорироваться будущими операциями, такими как итерация по хешу, но все же позволит хешу переназначить значение для ключа в какой-то момент в будущем. Эта функция удаляет любые такие ключи-заполнители из хеша. См. Hash :: Util :: lock_keys () для примера его использования.</target>
        </trans-unit>
        <trans-unit id="8694e0be1c305fe59f17048c06b457a918bbcd82" translate="yes" xml:space="preserve">
          <source>Clears the internal table of &quot;seen&quot; references and returns the object itself.</source>
          <target state="translated">Очищает внутреннюю таблицу от &quot;увиденных&quot; ссылок и возвращает сам объект.</target>
        </trans-unit>
        <trans-unit id="47b31851c74e0f5ebbb3dfaea28b4822609aa2b8" translate="yes" xml:space="preserve">
          <source>Client Callback Methods</source>
          <target state="translated">Методы обратного вызова клиентов</target>
        </trans-unit>
        <trans-unit id="37da5860354a7f86a5ca376c0d24243e5da20032" translate="yes" xml:space="preserve">
          <source>Clients of &lt;b&gt;Pod::Parser&lt;/b&gt; should use the following methods to access instance data fields:</source>
          <target state="translated">Клиенты &lt;b&gt;Pod :: Parser&lt;/b&gt; должны использовать следующие методы для доступа к полям данных экземпляра:</target>
        </trans-unit>
        <trans-unit id="b6d24920f2b48bf829e8a23e9a90dfdd3440760d" translate="yes" xml:space="preserve">
          <source>Clone a CV, making a lexical closure.</source>
          <target state="translated">Клонируй резюме,делая лексическое закрытие.</target>
        </trans-unit>
        <trans-unit id="5f979b64a2e1385f3005f3cb2103d9f2baf2955c" translate="yes" xml:space="preserve">
          <source>Clone the state variables associated with running and compiling pads.</source>
          <target state="translated">Клонирование переменных состояния,связанных с запуском и компиляцией колодок.</target>
        </trans-unit>
        <trans-unit id="8a76336a32c405fad8ce65baf95c160bc7bd1714" translate="yes" xml:space="preserve">
          <source>Cloning an interpreter</source>
          <target state="translated">Клонирование переводчика</target>
        </trans-unit>
        <trans-unit id="4b55eaddcc64cc03fb97cb5cfdc6e4a0b7e1eab8" translate="yes" xml:space="preserve">
          <source>Close the data connection and get a response from the FTP server. Returns</source>
          <target state="translated">Закройте соединение для передачи данных и получите ответ от FTP-сервера.Возвращает</target>
        </trans-unit>
        <trans-unit id="1c0a792433b635cbfbf3a9fa1132f2f138428c0e" translate="yes" xml:space="preserve">
          <source>Close the file associated with the object and disassociate the file from the handle. Done automatically on destroy.</source>
          <target state="translated">Закройте файл,связанный с объектом,и отделите файл от дескриптора.Готово автоматически при уничтожении.</target>
        </trans-unit>
        <trans-unit id="19ff0b1a9c29ac2abd677ef11d03ad865001d751" translate="yes" xml:space="preserve">
          <source>Close the file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">Закройте файл. При этом используются файловые дескрипторы, например, полученные при вызове &lt;code&gt;POSIX::open&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6557bfb4a242f6c8d48bf95461a4833d7849fd1a" translate="yes" xml:space="preserve">
          <source>Close the handle</source>
          <target state="translated">Закройте ручку</target>
        </trans-unit>
        <trans-unit id="bb4472090f184d3ee362c8c35a0ec02ede037401" translate="yes" xml:space="preserve">
          <source>Close the network connection for this ping object. The network connection is also closed by &quot;undef $p&quot;. The network connection is automatically closed if the ping object goes out of scope (e.g. $p is local to a subroutine and you leave the subroutine).</source>
          <target state="translated">Закройте сетевое соединение для этого объекта ping.Сетевое подключение также закрывается по команде &quot;undef $p&quot;.Сетевое соединение автоматически закрывается,если ping-объект выходит за рамки видимости (например,$p локален для подпрограмм и вы выходите из подпрограмм).</target>
        </trans-unit>
        <trans-unit id="190ae3f86d0557b4127e04bcfb326cc6d030a90a" translate="yes" xml:space="preserve">
          <source>Close the stream. Should normally call &lt;code&gt;PerlIOBase_close()&lt;/code&gt; to flush itself and close layers below, and then deallocate any data structures (buffers, translation tables, ...) not held directly in the data structure.</source>
          <target state="translated">Закройте поток. Обычно следует вызывать &lt;code&gt;PerlIOBase_close()&lt;/code&gt; чтобы очистить себя и закрыть слои ниже, а затем освободить все структуры данных (буферы, таблицы трансляции, ...), не содержащиеся непосредственно в структуре данных.</target>
        </trans-unit>
        <trans-unit id="31da48802b39a62004814937a9e31811a752be6b" translate="yes" xml:space="preserve">
          <source>Closely associated with the &lt;code&gt;//g&lt;/code&gt; modifier is the &lt;code&gt;\G&lt;/code&gt; anchor. The &lt;code&gt;\G&lt;/code&gt; anchor matches at the point where the previous &lt;code&gt;//g&lt;/code&gt; match left off. &lt;code&gt;\G&lt;/code&gt; allows us to easily do context-sensitive matching:</source>
          <target state="translated">С модификатором &lt;code&gt;//g&lt;/code&gt; тесно связан якорь &lt;code&gt;\G&lt;/code&gt; В &lt;code&gt;\G&lt;/code&gt; анкерные матчи в точке , где предыдущий &lt;code&gt;//g&lt;/code&gt; матч прервали. &lt;code&gt;\G&lt;/code&gt; позволяет нам легко выполнять контекстно-зависимое сопоставление:</target>
        </trans-unit>
        <trans-unit id="ed2c86b22aa0e19fdc594e6bdac3be5d440f77af" translate="yes" xml:space="preserve">
          <source>Closely associated with the matching variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... are the</source>
          <target state="translated">С соответствующими переменными &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... тесно связаны</target>
        </trans-unit>
        <trans-unit id="4c6e55c513c3700cb482b5228ee114dea0eb2014" translate="yes" xml:space="preserve">
          <source>Closes a directory opened by &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; and returns the success of that system call.</source>
          <target state="translated">Закрывает каталог, открытый &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; , и возвращает успешное выполнение этого системного вызова.</target>
        </trans-unit>
        <trans-unit id="1718bbd298f85e4f92aa5e14dbae95e752272e78" translate="yes" xml:space="preserve">
          <source>Closes a directory opened by &lt;code&gt;&lt;a href=&quot;opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; and returns the success of that system call.</source>
          <target state="translated">Закрывает каталог, открытый &lt;code&gt;&lt;a href=&quot;opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; , и возвращает успешное выполнение этого системного вызова.</target>
        </trans-unit>
        <trans-unit id="c738bf1c5aeadafd66d4f3177f0ec53c7a05eef3" translate="yes" xml:space="preserve">
          <source>Closes the compressed file. Any pending data is flushed to the file before it is closed.</source>
          <target state="translated">Закрывает сжатый файл.Любые отложенные данные прошиваются в файл перед его закрытием.</target>
        </trans-unit>
        <trans-unit id="b1d528fd6e4e57f9b4f4824f906e152d2b52aa44" translate="yes" xml:space="preserve">
          <source>Closes the current compressed data stream and starts a new one.</source>
          <target state="translated">Закрывает текущий сжатый поток данных и запускает новый.</target>
        </trans-unit>
        <trans-unit id="51e188a428b2b9dba319c461ba18765571b8c558" translate="yes" xml:space="preserve">
          <source>Closes the file or pipe associated with the filehandle, flushes the IO buffers, and closes the system file descriptor. Returns true if those operations succeed and if no error was reported by any PerlIO layer. Closes the currently selected filehandle if the argument is omitted.</source>
          <target state="translated">Закрывает файл или трубку,связанную с файловой рукояткой,промывает буферы ввода-вывода и закрывает дескриптор системного файла.Возвращает true,если эти операции прошли успешно,и если ни один слой PerlIO не сообщил об ошибке.Закрывает текущий выбранный файловый дескриптор,если аргумент опущен.</target>
        </trans-unit>
        <trans-unit id="fea628f203f0d9f7135eed7983ec3d8792beb442" translate="yes" xml:space="preserve">
          <source>Closes the log file and returns true on success.</source>
          <target state="translated">Закрывает лог-файл и возвращает true on success.</target>
        </trans-unit>
        <trans-unit id="d2bbc309bbe5a51ba61bf619d197d1239e2eb8ce" translate="yes" xml:space="preserve">
          <source>Closes the output file/buffer.</source>
          <target state="translated">Закрывает выходной файл/буфер.</target>
        </trans-unit>
        <trans-unit id="ba43eac7b65017fd2089f1e6bc015f1ec8c511e2" translate="yes" xml:space="preserve">
          <source>Closing any piped filehandle causes the parent process to wait for the child to finish, then returns the status value in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</source>
          <target state="translated">Закрытие любого обработчика файла по конвейеру заставляет родительский процесс ждать завершения дочернего процесса, а затем возвращает значение статуса в &lt;code&gt;$?&lt;/code&gt; и &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4dcf08fb56e6d72fb32ed7e1eabe87691436e56" translate="yes" xml:space="preserve">
          <source>Closing bracket for XSUB arguments. This is usually handled by &lt;code&gt;xsubpp&lt;/code&gt; . See &lt;code&gt;PUSHMARK&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; for other uses.</source>
          <target state="translated">Закрывающая скобка для аргументов XSUB. Обычно этим занимается &lt;code&gt;xsubpp&lt;/code&gt; . См. &lt;code&gt;PUSHMARK&lt;/code&gt; и &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; для других целей.</target>
        </trans-unit>
        <trans-unit id="737b7e3ad0d2423ad5a8db0c5d04ee20b1d52475" translate="yes" xml:space="preserve">
          <source>Closing bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;LIGHTWEIGHT CALLBACKS in perlcall&lt;/a&gt;.</source>
          <target state="translated">Закрывающая скобка для облегченного обратного вызова. См. &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;ОБЛЕГЧЕННЫЕ ОТВЕТЫ в perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2745a4c8776a0e5fafe11f0f22ec70fe0d72258" translate="yes" xml:space="preserve">
          <source>Closing bracket for temporaries on a callback. See &lt;code&gt;SAVETMPS&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">Закрывающая скобка для временных конструкций при обратном вызове. Смотрите &lt;code&gt;SAVETMPS&lt;/code&gt; и &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ba349d3ba72088b84c46b90a7f642094300bd0d" translate="yes" xml:space="preserve">
          <source>Closing bracket on a callback. See &lt;code&gt;ENTER&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">Закрывающая скобка при обратном вызове. Смотрите &lt;code&gt;ENTER&lt;/code&gt; и &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23a4c843ad3bbdd040a62a1e5a6170f0fcb264c5" translate="yes" xml:space="preserve">
          <source>Closing the read end of a pipe before the process writing to it at the other end is done writing results in the writer receiving a SIGPIPE. If the other end can't handle that, be sure to read all the data before closing the pipe.</source>
          <target state="translated">Закрытие прочитанного конца трубы до того,как процесс записи на другой конец будет завершен,приводит к тому,что записывающее устройство получит СИГНАЛ.Если другой конец не может с этим справиться,обязательно прочитайте все данные перед тем,как закрывать трубу.</target>
        </trans-unit>
        <trans-unit id="84e77ec95c5a92eb909c6ac217e1a65e9bf9d350" translate="yes" xml:space="preserve">
          <source>Closure</source>
          <target state="translated">Closure</target>
        </trans-unit>
        <trans-unit id="b6d86b58c6ea474356b305c2ad2f3387941bd459" translate="yes" xml:space="preserve">
          <source>Closures are documented in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">Замыкания задокументированы в &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07e50ba612fbe1c93f394383c8388d370e33f827" translate="yes" xml:space="preserve">
          <source>Closures are most often used in programming languages where you can have the return value of a function be itself a function, as you can in Perl. Note that some languages provide anonymous functions but are not capable of providing proper closures: the Python language, for example. For more information on closures, check out any textbook on functional programming. Scheme is a language that not only supports but encourages closures.</source>
          <target state="translated">Закрытия чаще всего используются в языках программирования,где возвращаемое значение функции может быть само по себе функцией,как это можно сделать на Perl.Обратите внимание,что некоторые языки предоставляют анонимные функции,но не способны обеспечить надлежащее закрытие:например,язык Python.Дополнительную информацию о закрытии можно найти в любом учебнике по функциональному программированию.Scheme-это язык,который не только поддерживает,но и поощряет закрытие.</target>
        </trans-unit>
        <trans-unit id="625dad30655b90e54e26f3f025084dbfc6f7497b" translate="yes" xml:space="preserve">
          <source>Closures are often used for less esoteric purposes. For example, when you want to pass in a bit of code into a function:</source>
          <target state="translated">Закрытия часто используются для менее эзотерических целей.Например,когда нужно передать немного кода в функцию:</target>
        </trans-unit>
        <trans-unit id="5161af4a1cac3a1b9b45f56c8dea0b53f7bfbecc" translate="yes" xml:space="preserve">
          <source>Co-existence with stdio</source>
          <target state="translated">Сосуществование с stdio</target>
        </trans-unit>
        <trans-unit id="6517f8be2c6a95c643a9a9b5bb9a2d69ac206184" translate="yes" xml:space="preserve">
          <source>Cocoa</source>
          <target state="translated">Cocoa</target>
        </trans-unit>
        <trans-unit id="95c99c8aeaa2e8fc96be370bcb2d2ba452daba68" translate="yes" xml:space="preserve">
          <source>Code &lt;code&gt;x&lt;/code&gt; skips a byte, since we don't need the count yet. Code &lt;code&gt;n&lt;/code&gt; takes care of the 16-bit big-endian integer address, and &lt;code&gt;C&lt;/code&gt; unpacks the record type. Being at offset 4, where the data begins, we need the count. &lt;code&gt;X4&lt;/code&gt; brings us back to square one, which is the byte at offset 0. Now we pick up the count, and zoom forth to offset 4, where we are now fully furnished to extract the exact number of data bytes, leaving the trailing checksum byte alone.</source>
          <target state="translated">Код &lt;code&gt;x&lt;/code&gt; пропускает байт, так как нам еще не нужен счетчик. Код &lt;code&gt;n&lt;/code&gt; заботится о 16-битном целочисленном адресе с прямым порядком байтов, а &lt;code&gt;C&lt;/code&gt; распаковывает тип записи. Находясь на смещении 4, где начинаются данные, нам нужен счетчик. &lt;code&gt;X4&lt;/code&gt; возвращает нас к квадрату один, который является байтом со смещением 0. Теперь мы поднимаем счетчик и приближаемся к смещению 4, где теперь мы полностью готовы извлечь точное количество байтов данных, оставив завершающий байт контрольной суммы. в одиночестве.</target>
        </trans-unit>
        <trans-unit id="88ed008dc7a2ff797ab17a3de73dfdb055a98c4d" translate="yes" xml:space="preserve">
          <source>Code blocks such as &lt;code&gt;(?{BLOCK})&lt;/code&gt; are handled by temporarily passing control back to the perl parser, in a similar way that an interpolated array subscript expression such as &lt;code&gt;&quot;foo$array[1+f(&quot;[xyz&quot;)]bar&quot;&lt;/code&gt; would be.</source>
          <target state="translated">Блоки кода, такие как &lt;code&gt;(?{BLOCK})&lt;/code&gt; , обрабатываются путем временной передачи управления обратно парсеру perl аналогично интерполированному выражению индекса массива, например &lt;code&gt;&quot;foo$array[1+f(&quot;[xyz&quot;)]bar&quot;&lt;/code&gt; было бы.</target>
        </trans-unit>
        <trans-unit id="762d66380b843da111702ccfbb2c67a26389d7e3" translate="yes" xml:space="preserve">
          <source>Code evaluation</source>
          <target state="translated">Оценка кода</target>
        </trans-unit>
        <trans-unit id="37d37b9a8d116d9e1ae5c945c68e058e2feb14aa" translate="yes" xml:space="preserve">
          <source>Code expressions are zero-width assertions, and the value they return depends on their environment. There are two possibilities: either the code expression is used as a conditional in a conditional expression &lt;code&gt;(?(condition)...)&lt;/code&gt;, or it is not. If the code expression is a conditional, the code is evaluated and the result (i.e., the result of the last statement) is used to determine truth or falsehood. If the code expression is not used as a conditional, the assertion always evaluates true and the result is put into the special variable &lt;code&gt;$^R&lt;/code&gt; . The variable &lt;code&gt;$^R&lt;/code&gt; can then be used in code expressions later in the regexp. Here are some silly examples:</source>
          <target state="translated">Кодовые выражения представляют собой утверждения нулевой ширины, и возвращаемое ими значение зависит от их среды. Есть две возможности: либо кодовое выражение используется как условное в условном выражении &lt;code&gt;(?(condition)...)&lt;/code&gt; , либо нет. Если кодовое выражение является условным, код оценивается, и результат (т. Е. Результат последнего оператора) используется для определения истинности или ложности. Если выражение код не используются как условные, утверждение всегда оценивает истинное и результат помещается в специальные переменных &lt;code&gt;$^R&lt;/code&gt; . Затем переменную &lt;code&gt;$^R&lt;/code&gt; можно будет использовать в кодовых выражениях позже в регулярном выражении. Вот несколько глупых примеров:</target>
        </trans-unit>
        <trans-unit id="16588d7ea09d6c8a62bccdc2d6ce591ced66cdbf" translate="yes" xml:space="preserve">
          <source>Code expressions, conditional expressions, and independent expressions are</source>
          <target state="translated">Кодовыми выражениями,условными выражениями и независимыми выражениями являются</target>
        </trans-unit>
        <trans-unit id="0d4a4669a2b66538a054bb02710d7250ecbe4161" translate="yes" xml:space="preserve">
          <source>Code for &lt;code&gt;constant()&lt;/code&gt; s regenerated by Nicholas Clark &amp;lt;</source>
          <target state="translated">Код для &lt;code&gt;constant()&lt;/code&gt; восстановленный Николасом Кларком &amp;lt;</target>
        </trans-unit>
        <trans-unit id="d3cbaac4d40358f731935693702135f199e63c95" translate="yes" xml:space="preserve">
          <source>Code is executed in the caller's package.</source>
          <target state="translated">Код выполняется в пакете вызывающего абонента.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
