<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="a60da6ae1477278e788b56dd12901cf6a9b5b818" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">Примените &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; к значению, возвращаемому &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; если вам нужны случайные целые числа вместо случайных дробных чисел. Например,</target>
        </trans-unit>
        <trans-unit id="974cf6b03d0010e4742b565eeb776443fe41243e" translate="yes" xml:space="preserve">
          <source>Apply Perl-specific heuristics to find the correct PODs. This includes stripping Perl-like extensions, omitting subdirectories that are numeric but do</source>
          <target state="translated">Применить перл-специфическую эвристику,чтобы найти правильные POD.Это включает удаление Perl-подобных расширений,опускание подкаталогов,которые являются числовыми,но делают</target>
        </trans-unit>
        <trans-unit id="baaa234761c2eef7e15c7c661df9bd832e32f420" translate="yes" xml:space="preserve">
          <source>Apply a list of switch options to the state, updating the internal object state as a result. Nothing is returned.</source>
          <target state="translated">Применить список опций коммутатора к состоянию,в результате чего обновляется состояние внутреннего объекта.Ничего не возвращается.</target>
        </trans-unit>
        <trans-unit id="c72c1cee8e4b08228a22dc9c5e025abf27a61b14" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;autodie&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; causes the exotic forms &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; to be considered a syntax error until the end of the lexical scope. If you really need to use the exotic form, you can call &lt;code&gt;CORE::system&lt;/code&gt; or &lt;code&gt;CORE::exec&lt;/code&gt; instead, or use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; before calling the exotic form.</source>
          <target state="translated">Применение &lt;code&gt;autodie&lt;/code&gt; к &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; приводит к тому, что экзотические формы &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; будут считаться синтаксической ошибкой до конца лексической области видимости. Если вам действительно нужно использовать экзотическую форму, вы можете вызвать &lt;code&gt;CORE::system&lt;/code&gt; или &lt;code&gt;CORE::exec&lt;/code&gt; вместо этого, или не использовать &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; перед вызовом экзотической формы.</target>
        </trans-unit>
        <trans-unit id="7b6bbaf0846e0f6542bb5b50d36df38212d67922" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; .</source>
          <target state="translated">Приблизительный эквивалент Perl: &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="255706027acb3bbb6c23a2beab5baa7da2561792" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; .</source>
          <target state="translated">Приблизительный эквивалент Perl: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7d5efdfeaa09de6b4d853375871c9207032b5a" translate="yes" xml:space="preserve">
          <source>April 04-07th, 1997: by Jarkko Hietaniemi, added the run-for-some-time functionality.</source>
          <target state="translated">04-07 апреля 1997 года:Jarkko Hietaniemi добавил функциональность исполнения на время выполнения.</target>
        </trans-unit>
        <trans-unit id="5383ba59b7a51b492dcc518df7e4190d4cdf46a1" translate="yes" xml:space="preserve">
          <source>Arbitrary big rational numbers</source>
          <target state="translated">Произвольные большие рациональные числа</target>
        </trans-unit>
        <trans-unit id="d355876ea51e167fe43014294b56e66adbafd342" translate="yes" xml:space="preserve">
          <source>Arbitrary size floating point math package</source>
          <target state="translated">Пакет математических расчетов с плавающей запятой произвольного размера</target>
        </trans-unit>
        <trans-unit id="94977ff2a6f2fcf0486458c46c172275ed7d1a6e" translate="yes" xml:space="preserve">
          <source>Arbitrary size integer/float math package</source>
          <target state="translated">Произвольный размер целочисленный/плавающий математический пакет</target>
        </trans-unit>
        <trans-unit id="f96ddf323d8050458b6f5da00e7d15254e6e51f7" translate="yes" xml:space="preserve">
          <source>Arch</source>
          <target state="translated">Arch</target>
        </trans-unit>
        <trans-unit id="ba6c5bbd1305838d356b1a16f613e5175253fc77" translate="yes" xml:space="preserve">
          <source>Archive::Tar</source>
          <target state="translated">Archive::Tar</target>
        </trans-unit>
        <trans-unit id="57cc32f42ad2d2bee580d99c3d374961c6559947" translate="yes" xml:space="preserve">
          <source>Archive::Tar - module for manipulations of tar archives</source>
          <target state="translated">Архив::Tar-модуль для манипуляций с таровыми архивами</target>
        </trans-unit>
        <trans-unit id="987b760cdf9eb8e8f22f82c621b2dbe3ee552aeb" translate="yes" xml:space="preserve">
          <source>Archive::Tar provides an object oriented mechanism for handling tar files. It provides class methods for quick and easy files handling while also allowing for the creation of tar file objects for custom manipulation. If you have the IO::Zlib module installed, Archive::Tar will also support compressed or gzipped tar files.</source>
          <target state="translated">Archive::Tar предоставляет объектно-ориентированный механизм для работы с tar-файлами.Он предоставляет методы классов для быстрой и простой работы с файлами,а также позволяет создавать объекты tar-файлов для пользовательских манипуляций.Если у вас установлен модуль IO::Zlib,Archive::Tar также будет поддерживать сжатые или gzipped tar-файлы.</target>
        </trans-unit>
        <trans-unit id="7c0d8b6a96eeaeee2b14e15f99110273c20f8435" translate="yes" xml:space="preserve">
          <source>Archive::Tar will warn if you try to pass a bzip2 compressed file and the IO::Zlib / IO::Uncompress::Bunzip2 modules are not available and simply return.</source>
          <target state="translated">Архив::Tar предупредит,если вы попытаетесь передать сжатый bzip2 файл,а модули IO::Zlib/IO::Uncompress::Bunzip2 будут недоступны и просто вернутся.</target>
        </trans-unit>
        <trans-unit id="ccbf19882dacfbec62ca802f4c207f93b26aac20" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;can_handle_compressed_files</source>
          <target state="translated">Archive::Tar-&amp;gt;can_handle_compressed_files</target>
        </trans-unit>
        <trans-unit id="3b7da738f6421ea5f244ab2a75337cb19a765083" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;create_archive($file, $compressed, @filelist)</source>
          <target state="translated">Архив :: Tar-&amp;gt; create_archive ($ file, $ compressed, @filelist)</target>
        </trans-unit>
        <trans-unit id="1dcbd289acf336b4bc9986937face374b8265d16" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;extract_archive($file, $compressed)</source>
          <target state="translated">Архив :: Tar-&amp;gt; extract_archive ($ файл, $ сжатый)</target>
        </trans-unit>
        <trans-unit id="8336b53d325ea70cb860e4292e999b5eb8ccc20b" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;iter( $filename, [ $compressed, {opt =&amp;gt; $val} ] )</source>
          <target state="translated">Archive :: Tar-&amp;gt; iter ($ filename, [$ compressed, {opt =&amp;gt; $ val}])</target>
        </trans-unit>
        <trans-unit id="7b5db2965e54185ceb8a82cfef6b3bcf83d67256" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;list_archive($file, $compressed, [\@properties])</source>
          <target state="translated">Архив :: Tar-&amp;gt; list_archive ($ file, $ compressed, [\ @properties])</target>
        </trans-unit>
        <trans-unit id="2b89433003c5207f03c7ec11ee01b11e8497bdb8" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;new( [$file, $compressed] )</source>
          <target state="translated">Архив :: Tar-&amp;gt; новый ([$ file, $ compressed])</target>
        </trans-unit>
        <trans-unit id="3fdd79ccbef7cb27b73af9645a51c4748537632a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File</source>
          <target state="translated">Archive::Tar::File</target>
        </trans-unit>
        <trans-unit id="e4450126317363219e2891fd96c92d67bb8fdb14" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File - a subclass for in-memory extracted file from Archive::Tar</source>
          <target state="translated">Архив::Tar::Файл-подкласс для внутрипамятного извлеченного файла из архива::Tar</target>
        </trans-unit>
        <trans-unit id="9bb643189669555fb8fc9a5ad660a12af02d7c6a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( chunk =&amp;gt; $chunk )</source>
          <target state="translated">Архив :: Tar :: File-&amp;gt; new (chunk =&amp;gt; $ chunk)</target>
        </trans-unit>
        <trans-unit id="ba9618dfc7889be15218e3ccacc09c8bf242756f" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( data =&amp;gt; $path, $data, $opt )</source>
          <target state="translated">Archive :: Tar :: File-&amp;gt; new (данные =&amp;gt; $ path, $ data, $ opt)</target>
        </trans-unit>
        <trans-unit id="a50e4ac8ad32b339e1eb6dee5ec96a58d21300c3" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( file =&amp;gt; $path )</source>
          <target state="translated">Архив :: Tar :: Файл-&amp;gt; новый (файл =&amp;gt; $ путь)</target>
        </trans-unit>
        <trans-unit id="752ab891c175e9890243ad0568d1b63da7b75555" translate="yes" xml:space="preserve">
          <source>Archive::Tar::Files provides a neat little object layer for in-memory extracted files. It's mostly used internally in Archive::Tar to tidy up the code, but there's no reason users shouldn't use this API as well.</source>
          <target state="translated">Архив::Tar::Файлы обеспечивают аккуратный маленький объектный слой для извлекаемых в памяти файлов.В основном он используется внутри Archive::Tar для приведения кода в порядок,но нет причин,по которым пользователи не должны использовать и это API.</target>
        </trans-unit>
        <trans-unit id="2fa2e509f071fa28e01ed08cd42d1e6a982c1c93" translate="yes" xml:space="preserve">
          <source>Archiving and Compression</source>
          <target state="translated">Архивирование и сжатие</target>
        </trans-unit>
        <trans-unit id="470ed7908583fc807812b6f6f1c733d168001e41" translate="yes" xml:space="preserve">
          <source>Are Perl regexes DFAs or NFAs? Are they POSIX compliant?</source>
          <target state="translated">Перл регексы DFA или NFA? Соответствуют ли они стандарту POSIX?</target>
        </trans-unit>
        <trans-unit id="eb00fa046e6f0e29e318d2fe47833f95b6115931" translate="yes" xml:space="preserve">
          <source>Are These Threads The Same?</source>
          <target state="translated">Это те же самые нити?</target>
        </trans-unit>
        <trans-unit id="4b1b74d280a485e3d6be58ac5945ac8cbddc5958" translate="yes" xml:space="preserve">
          <source>Are not yet implemented.</source>
          <target state="translated">еще не реализованы.</target>
        </trans-unit>
        <trans-unit id="1c7b6fd019a3db8f66c106580e36cbc2e27fdf91" translate="yes" xml:space="preserve">
          <source>Are you running Windows, and did you write</source>
          <target state="translated">Ты работаешь под Windows,и ты написал</target>
        </trans-unit>
        <trans-unit id="9835fff08898bf6d47cdf47b75c3d5a32e54abb7" translate="yes" xml:space="preserve">
          <source>Are you using a really old version of Perl?</source>
          <target state="translated">Вы используете действительно старую версию Perl?</target>
        </trans-unit>
        <trans-unit id="6fa0e4cab9d0443ef8c9e6c56e4240cbc1230cdb" translate="yes" xml:space="preserve">
          <source>Arguably, these are the only routines you'll ever need to execute snippets of Perl code from within your C program. Your code can be as long as you wish; it can contain multiple statements; it can employ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;, and &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; to include external Perl files.</source>
          <target state="translated">Возможно, это единственные процедуры, которые вам когда-либо понадобятся для выполнения фрагментов кода Perl из вашей программы C. Ваш код может быть сколь угодно длинным; он может содержать несколько операторов; он может использовать &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; , &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; и &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; для включения внешних файлов Perl.</target>
        </trans-unit>
        <trans-unit id="068c4f93ca844add9151394d87be6f0eff5098cb" translate="yes" xml:space="preserve">
          <source>Argument callback</source>
          <target state="translated">обратный звонок по аргументам</target>
        </trans-unit>
        <trans-unit id="becc16f3f9567f706b791b0867003075aa38f700" translate="yes" xml:space="preserve">
          <source>Argument stack</source>
          <target state="translated">стопка аргументов</target>
        </trans-unit>
        <trans-unit id="9acc1ee24f849a6b6943c3856e23bafeb8ea115e" translate="yes" xml:space="preserve">
          <source>Argument stack manipulation in the core is exactly the same as it is in XSUBs - see &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for a longer description of the macros used in stack manipulation.</source>
          <target state="translated">Управление стеком аргументов в ядре точно такое же, как и в XSUB - см. &lt;a href=&quot;perlxstut&quot;&gt;Perlxstut&lt;/a&gt; , &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; и &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; для более подробного описания макросов, используемых при манипулировании стеком.</target>
        </trans-unit>
        <trans-unit id="1e682d21a155016274d4c0edada169602cf2db63" translate="yes" xml:space="preserve">
          <source>Arguments are case insensitive.</source>
          <target state="translated">Аргументы нечувствительны к регистру.</target>
        </trans-unit>
        <trans-unit id="f350823ca978137e84ceb658074c062e77adbc5a" translate="yes" xml:space="preserve">
          <source>Arguments are forced into the integer format if not strings.</source>
          <target state="translated">Аргументы принудительно переводятся в целочисленный формат,если не строки.</target>
        </trans-unit>
        <trans-unit id="e574a112087c49e835619f8e2053ef81199f3165" translate="yes" xml:space="preserve">
          <source>Arguments are passed to PP code and returned from PP code using the argument stack, &lt;code&gt;ST&lt;/code&gt; . The typical way to handle arguments is to pop them off the stack, deal with them how you wish, and then push the result back onto the stack. This is how, for instance, the cosine operator works:</source>
          <target state="translated">Аргументы передаются в код PP и возвращаются из кода PP с использованием стека аргументов &lt;code&gt;ST&lt;/code&gt; . Типичный способ обработки аргументов - вытащить их из стека, обработать их так, как вы хотите, а затем отправить результат обратно в стек. Так работает, например, оператор косинуса:</target>
        </trans-unit>
        <trans-unit id="5fccb02bffe9af13a6b48fc881c2035657ec7bff" translate="yes" xml:space="preserve">
          <source>Arguments are usually formatted to be only as wide as required to display the given value. You can override the width by putting a number here, or get the width from the next argument (with &lt;code&gt;*&lt;/code&gt; ) or from a specified argument (e.g., with &lt;code&gt;*2$&lt;/code&gt;):</source>
          <target state="translated">Аргументы обычно форматируются так, чтобы иметь ширину, необходимую для отображения данного значения. Вы можете переопределить ширину, поместив здесь число, или получить ширину из следующего аргумента (с &lt;code&gt;*&lt;/code&gt; ) или из указанного аргумента (например, с &lt;code&gt;*2$&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="4fb3861e253aa9c040fd66d90deafd1a6d71292f" translate="yes" xml:space="preserve">
          <source>Arguments of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive are (key, value) pairs. For the full set of legal keys, see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; below.</source>
          <target state="translated">Аргументами директивы &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; являются пары (ключ, значение). Полный набор допустимых ключей см. В разделе &amp;laquo; &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Перегружаемые операции&amp;raquo;&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="5141dae339b17f35a7a4380f8f719ce252ef43f8" translate="yes" xml:space="preserve">
          <source>Arguments that don't start with a hyphen are taken to be the names of subroutines or formats to render; if no such functions are specified, the main body of the program (outside any subroutines, and not including use'd or require'd files) is rendered. Passing &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , or &lt;code&gt;END&lt;/code&gt; will cause all of the corresponding special blocks to be printed. Arguments must follow options.</source>
          <target state="translated">Аргументы, которые не начинаются с дефиса, считаются именами подпрограмм или форматов для рендеринга; если такие функции не указаны, отображается основная часть программы (вне каких-либо подпрограмм, за исключением используемых или требуемых файлов). Передача &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; или &lt;code&gt;END&lt;/code&gt; приведет к печати всех соответствующих специальных блоков. Аргументы должны следовать за вариантами.</target>
        </trans-unit>
        <trans-unit id="ce73d1bc99ee20ea72fd21908b3617e55e0813cc" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; checked for taintedness.</source>
          <target state="translated">Аргументы для &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; которые &lt;b&gt;не&lt;/b&gt; проверяются на taintedness.</target>
        </trans-unit>
        <trans-unit id="5b24aafc030974a768212046c7dad5ef0c74d247" translate="yes" xml:space="preserve">
          <source>Arguments to Tests</source>
          <target state="translated">Аргументы в пользу испытаний</target>
        </trans-unit>
        <trans-unit id="253657f116857073367b6474bc4203deb4236cb2" translate="yes" xml:space="preserve">
          <source>Arguments to be added to the command line</source>
          <target state="translated">Аргументы,которые будут добавлены в командную строку</target>
        </trans-unit>
        <trans-unit id="ef74aa3554ce37f3e92c7ca867fc499504f0b195" translate="yes" xml:space="preserve">
          <source>Arguments to these commands are either strings exactly matching the identification string of an object, or regular expressions matched case-insensitively against various attributes of the objects. The parser only recognizes a regular expression when you enclose it with slashes.</source>
          <target state="translated">Аргументами к этим командам являются либо строки,точно соответствующие идентификационной строке объекта,либо регулярные выражения,нечувствительные к регистру различных атрибутов объектов.Синтаксический анализатор распознает регулярное выражение только в том случае,если оно заключено в косую черту.</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="2007b9d426cd74d2705e9cb985a4b287291d5413" translate="yes" xml:space="preserve">
          <source>Arguments: COUNT is the number of times to run the loop, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">Аргументы:COUNT-это количество раз,которое необходимо выполнить цикл,а CODE-это код,который необходимо выполнить.CODE может быть как кодовой ссылкой,так и строкой для оценки;в любом случае он будет запущен в пакете вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="504073c25d9741031e514c8e9e91bef33965e548" translate="yes" xml:space="preserve">
          <source>Arguments: TIME is the minimum length of time to run CODE for, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">Аргументы:ВРЕМЯ-это минимальное время,в течение которого должен быть запущен КОД,а КОД-это код,который должен быть запущен.КОД может быть как кодовой ссылкой,так и строкой для оценки;в любом случае он будет запущен в пакете вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="2dd1feda95af0eae16b44852b3e991a7320b9877" translate="yes" xml:space="preserve">
          <source>Arnold, Ken and James Gosling. The Java Programming Language, 2nd ed. Addison-Wesley, 1998, ISBN 0-201-31006-6.</source>
          <target state="translated">Арнольд,Кен и Джеймс Гослинг.Язык программирования Java,2-е изд.Эддисон-Уэсли,1998,ISBN 0-201-31006-6.</target>
        </trans-unit>
        <trans-unit id="41b85d47773b3148f4f3a1e9d404f9d2d3175fa5" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">Обеспечивает чтение или запись FILEHANDLE в &amp;laquo;двоичном&amp;raquo; или &amp;laquo;текстовом&amp;raquo; режиме в системах, где библиотеки времени выполнения различают двоичные и текстовые файлы. Если FILEHANDLE является выражением, значение принимается как имя дескриптора файла. Возвращает true в случае успеха, в противном случае возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; и устанавливает &lt;code&gt;$!&lt;/code&gt; (эррно).</target>
        </trans-unit>
        <trans-unit id="1ffbadba9c3dce1044ad3f375a7830b9eb0ed44f" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">Обеспечивает чтение или запись FILEHANDLE в &amp;laquo;двоичном&amp;raquo; или &amp;laquo;текстовом&amp;raquo; режиме в системах, где библиотеки времени выполнения различают двоичные и текстовые файлы. Если FILEHANDLE является выражением, значение принимается как имя дескриптора файла. Возвращает true в случае успеха, в противном случае возвращает &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; и устанавливает &lt;code&gt;$!&lt;/code&gt; (эррно).</target>
        </trans-unit>
        <trans-unit id="343c9f92b2508f5809b499c36c6237ee53dad8e9" translate="yes" xml:space="preserve">
          <source>Arranges for a mutual exclusion lock to be obtained on sv if a suitable module has been loaded.</source>
          <target state="translated">Устанавливает блокировку взаимного исключения на sv,если загружен подходящий модуль.</target>
        </trans-unit>
        <trans-unit id="a5173bbe458c53871d9b1f27fa09a96bfb62b86e" translate="yes" xml:space="preserve">
          <source>Arranges for sv to be shared between threads if a suitable module has been loaded.</source>
          <target state="translated">Упорядочивает распределение sv между потоками,если загружен подходящий модуль.</target>
        </trans-unit>
        <trans-unit id="5e55b4fcd8dbc2fd2ba6c045d961bacb9e292142" translate="yes" xml:space="preserve">
          <source>Arranges to have a SIGALRM delivered to this process after the specified number of wallclock seconds has elapsed. If SECONDS is not specified, the value stored in &lt;code&gt;$_&lt;/code&gt; is used. (On some machines, unfortunately, the elapsed time may be up to one second less or more than you specified because of how seconds are counted, and process scheduling may delay the delivery of the signal even further.)</source>
          <target state="translated">Устанавливает доставку SIGALRM этому процессу по истечении заданного количества секунд настенных часов. Если SECONDS не указан, используется значение, хранящееся в &lt;code&gt;$_&lt;/code&gt; . (На некоторых машинах, к сожалению, прошедшее время может быть на одну секунду меньше или больше, чем вы указали из-за того, как подсчитываются секунды, а планирование процессов может задержать доставку сигнала еще больше.)</target>
        </trans-unit>
        <trans-unit id="fc39e6a09e8f437b433c2957e8745936c343df43" translate="yes" xml:space="preserve">
          <source>Array Interpolation</source>
          <target state="translated">Массивная интерполяция</target>
        </trans-unit>
        <trans-unit id="946f892404632d1e1ef312d460522dbcef0e5ca6" translate="yes" xml:space="preserve">
          <source>Array Manipulation Functions</source>
          <target state="translated">Функции манипуляции массивом</target>
        </trans-unit>
        <trans-unit id="e55ce1c88c52594e868f7dcd4b7c1bf4e8ab55e6" translate="yes" xml:space="preserve">
          <source>Array of extension names to be included when doing a static build. MakeMaker will normally build with all of the installed extensions when doing a static build, and that is usually the desired behavior. If INCLUDE_EXT is present then MakeMaker will build only with those extensions which are explicitly mentioned. (e.g. [ qw( Socket POSIX ) ])</source>
          <target state="translated">Массив имен расширений для включения при статической сборке.При статической сборке MakeMaker обычно собирается со всеми установленными расширениями,и это обычно является желаемым поведением.Если присутствует INCLUDE_EXT,то MakeMaker будет собирать только с теми расширениями,которые явно упомянуты.(например,[qw(Socket POSIX)])).</target>
        </trans-unit>
        <trans-unit id="1a8fc45517962d9406be17b19c25fe3aa87b4fd8" translate="yes" xml:space="preserve">
          <source>Array of extension names to exclude when doing a static build. This is ignored if INCLUDE_EXT is present. Consult INCLUDE_EXT for more details. (e.g. [ qw( Socket POSIX ) ] )</source>
          <target state="translated">Массив имен расширений для исключения при статической сборке.Это игнорируется,если присутствует INCLUDE_EXT.За более подробной информацией обратитесь к INCLUDE_EXT.(например,[qw(Socket POSIX)])).</target>
        </trans-unit>
        <trans-unit id="ab0eedcb736c58c9e1bf3d9da5ea7d522b690f73" translate="yes" xml:space="preserve">
          <source>Array of strings containing name (and email address) of package author(s). Is used in CPAN Meta files (META.yml or META.json) and PPD (Perl Package Description) files for PPM (Perl Package Manager).</source>
          <target state="translated">Массив строк,содержащих имя (и адрес электронной почты)автора(ов)пакета.Используется в файлах CPAN Meta (META.yml или META.json)и PPD (Perl Package Description)для PPM (Perl Package Manager).</target>
        </trans-unit>
        <trans-unit id="c57f3a7023d5d1d3793f2eb3d27a157609936e28" translate="yes" xml:space="preserve">
          <source>Array of symbol names for variables to be made available as universal symbols. Used only under AIX, OS/2, VMS and Win32 at present. Defaults to []. (e.g. [ qw(Foo_version Foo_numstreams Foo_tree ) ])</source>
          <target state="translated">Массив имен символов для переменных,которые будут доступны как универсальные символы.В настоящее время используется только под AIX,OS/2,VMS и Win32.По умолчанию установлено значение [].(например,[qw(Foo_version Foo_numstreams Foo_tree)])).</target>
        </trans-unit>
        <trans-unit id="9ab44c94b1ea31feff632108e9870b5e1654c616" translate="yes" xml:space="preserve">
          <source>Array operations, which change the scalars, rearrange them, or add or subtract some scalars, only work on arrays. These can't work on a list, which is fixed. Array operations include &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Операции с массивами, которые изменяют скаляры, переупорядочивают их, добавляют или вычитают некоторые скаляры, работают только с массивами. Они не могут работать со списком, который исправлен. Массивы операция включает в себя &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70c97244599437a3af8dc620ee670c18edb6906b" translate="yes" xml:space="preserve">
          <source>Array size can be obtained by doing:</source>
          <target state="translated">Размер массива можно получить,сделав это:</target>
        </trans-unit>
        <trans-unit id="4958f544bd9596999a8c5e79c668a1a1962b374e" translate="yes" xml:space="preserve">
          <source>Array, indexed by opcode, of functions that will be called for the &quot;check&quot; phase of optree building during compilation of Perl code. For most (but not all) types of op, once the op has been initially built and populated with child ops it will be filtered through the check function referenced by the appropriate element of this array. The new op is passed in as the sole argument to the check function, and the check function returns the completed op. The check function may (as the name suggests) check the op for validity and signal errors. It may also initialise or modify parts of the ops, or perform more radical surgery such as adding or removing child ops, or even throw the op away and return a different op in its place.</source>
          <target state="translated">Массив,индексируемый по опкоду,функций,которые будут вызываться для &quot;проверки&quot; фазы сборки опций при компиляции Perl кода.Для большинства (но не для всех)типов оп,после первоначальной сборки и заполнения дочерними опциями,она будет отфильтровываться через функцию проверки,на которую ссылается соответствующий элемент этого массива.Новый оп передается в качестве единственного аргумента в функцию проверки,а функция проверки возвращает завершенный оп.Функция проверки может (как следует из названия)проверять операцию на достоверность и ошибки сигнала.Она также может инициализировать или изменять части оп,или выполнять более радикальные операции,такие как добавление или удаление дочерних оп,или даже выбрасывать опцию и возвращать на ее место другую операцию.</target>
        </trans-unit>
        <trans-unit id="7622ad2f459420f8cf1278b446072cfedac9e366" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(archname manext)] defines ARCHNAME &amp;amp; MANEXT from config.sh. MakeMaker will add to CONFIG the following values anyway: ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</source>
          <target state="translated">Arrayref. Например, [qw (archname manext)] определяет ARCHNAME и MANEXT из config.sh. MakeMaker в любом случае добавит к CONFIG следующие значения: ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</target>
        </trans-unit>
        <trans-unit id="ac3c8cf1aba574321bc1f66afd6baee7d74ccdb5" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(name1 name2)] skip (do not write) sections of the Makefile. Caution! Do not use the SKIP attribute for the negligible speedup. It may seriously damage the resulting Makefile. Only use it if you really need it.</source>
          <target state="translated">Массив.Например,[qw(name1 name2)]пропустить (не писать)секции Makefile.Внимание! Не используйте атрибут SKIP для незначительного ускорения.Это может серьезно повредить Makefile.Используйте его только в том случае,если он вам действительно нужен.</target>
        </trans-unit>
        <trans-unit id="065b62648ae15e66467cb649a0f78784ebc20d69" translate="yes" xml:space="preserve">
          <source>Arrays and slices are interpolated into double-quoted strings by joining the elements with the delimiter specified in the &lt;code&gt;$&quot;&lt;/code&gt; variable (&lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; if &quot;use English;&quot; is specified), space by default. The following are equivalent:</source>
          <target state="translated">Массивы и фрагменты интерполируются в строки, заключенные в двойные кавычки, путем соединения элементов с разделителем, указанным в переменной &lt;code&gt;$&quot;&lt;/code&gt; ( &lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; если указано &quot; use English; &quot;), по умолчанию пробел. Следующие элементы эквивалентны:</target>
        </trans-unit>
        <trans-unit id="015aea03d19c4f5404b14d2e291f0bb807a559b3" translate="yes" xml:space="preserve">
          <source>Arrays are zero-indexed. Here's how you get at elements in an array:</source>
          <target state="translated">Массивы не индексированы.Вот как получить элементы в массиве:</target>
        </trans-unit>
        <trans-unit id="62a56f74931523c8c6be523e0f4189cd13f83348" translate="yes" xml:space="preserve">
          <source>Arrays index from 0. Likewise string positions in substr() and index().</source>
          <target state="translated">Индекс массивов от 0.Аналогично позиции строк в substr()и index().</target>
        </trans-unit>
        <trans-unit id="c6d4028b66a4b9402be627f34603725a671721e9" translate="yes" xml:space="preserve">
          <source>Arrays:</source>
          <target state="translated">Arrays:</target>
        </trans-unit>
        <trans-unit id="d88829ea9618170c7e2c7635ccc9b881ef3d9e85" translate="yes" xml:space="preserve">
          <source>Arrow Rule</source>
          <target state="translated">Правило стрелки</target>
        </trans-unit>
        <trans-unit id="59f3e01c7f1fff089e4fc72d78498e369ebc8aba" translate="yes" xml:space="preserve">
          <source>Article about software localization</source>
          <target state="translated">Статья о локализации программного обеспечения</target>
        </trans-unit>
        <trans-unit id="7c422841b7e3951946583038790545c4ed38481b" translate="yes" xml:space="preserve">
          <source>Articles</source>
          <target state="translated">Articles</target>
        </trans-unit>
        <trans-unit id="c2be5dffac8f664ad6e121cb0e6596d1cc2f8c20" translate="yes" xml:space="preserve">
          <source>Articles that are either about &lt;b&gt;DB_File&lt;/b&gt; or make use of it.</source>
          <target state="translated">Статьи, которые либо посвящены &lt;b&gt;DB_File,&lt;/b&gt; либо используют его.</target>
        </trans-unit>
        <trans-unit id="5ec201db4d2d3c7be7bb34f8e626f24de679e0d7" translate="yes" xml:space="preserve">
          <source>Artur Bergman &amp;lt;sky AT crucially DOT net&amp;gt;</source>
          <target state="translated">Артур Бергман &amp;lt;небо в сети DOT&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8abf83e588a6f8dbd23df54124d573a8d6e50b02" translate="yes" xml:space="preserve">
          <source>Artur Bergman, &quot;Where Wizards Fear To Tread&quot;, June 11, 2002, &lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http://www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</source>
          <target state="translated">Артур Бергман, &amp;laquo;Где волшебники боятся ступить&amp;raquo;, 11 июня 2002 г., &lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http://www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d31985fda87b26d6554bcfbfe7dbc398b51917e" translate="yes" xml:space="preserve">
          <source>As</source>
          <target state="translated">As</target>
        </trans-unit>
        <trans-unit id="47c29ec0c3f7f05bae80de5283a0b030f441a291" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt; or &lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt; but with the access/modify/change file timestamps in subsecond resolution, if the operating system and the filesystem both support such timestamps. To override the standard stat():</source>
          <target state="translated">Как &lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt; или &lt;a href=&quot;../functions/lstat&quot;&gt;lstat,&lt;/a&gt; но с временными метками доступа / изменения / изменения в субсекундном разрешении, если и операционная система, и файловая система поддерживают такие временные метки. Чтобы переопределить стандартный stat ():</target>
        </trans-unit>
        <trans-unit id="02b2b57eecbbd649395f996ef53060747f75fc9c" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-nok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">Как &lt;b&gt;-nok,&lt;/b&gt; за исключением того, что он сообщает о старых системах.</target>
        </trans-unit>
        <trans-unit id="4859922e8f70272693e823f3867ed24a92199eaa" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-ok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">Как &lt;b&gt;-ok,&lt;/b&gt; за исключением того, что он сообщает о старых системах.</target>
        </trans-unit>
        <trans-unit id="11468a3ea9b3583c1d2e6860cce82a44a9b04f63" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;$form_name&lt;/code&gt; , one of the following names must be given.</source>
          <target state="translated">В качестве &lt;code&gt;$form_name&lt;/code&gt; должно быть указано одно из следующих имен.</target>
        </trans-unit>
        <trans-unit id="2779b0caf565b7a913bad43d8e6bc994f2a3b086" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;-Dm&lt;/code&gt; is using the PerlIO layer for output, it will by itself allocate quite a bunch of SVs, which are hidden to avoid recursion. You can bypass the PerlIO layer if you use the SV logging provided by &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; instead.</source>
          <target state="translated">Поскольку &lt;code&gt;-Dm&lt;/code&gt; использует слой PerlIO для вывода, он сам по себе будет выделять довольно много SV, которые скрыты, чтобы избежать рекурсии. Вы можете обойти уровень PerlIO, если вместо этого используете ведение журнала SV, предоставляемое &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67afac02f586f9bebcefbfe5f3e2ccc5758a2739" translate="yes" xml:space="preserve">
          <source>As Perl is developed by a global team of volunteers, our documentation often contains spellings which look funny to</source>
          <target state="translated">Поскольку Perl разрабатывается глобальной командой волонтеров,наша документация часто содержит заклинания,которые выглядят забавно,чтобы</target>
        </trans-unit>
        <trans-unit id="56f06af6196a2958b2b24cc234e03f482b95a8e2" translate="yes" xml:space="preserve">
          <source>As Storable neither knows nor cares about character sets (although it does know that characters may be more than eight bits wide), any difference in the interpretation of character codes between a host and a target system is your problem. In particular, if host and target use different code points to represent the characters used in the text representation of floating-point numbers, you will not be able be able to exchange floating-point data, even with nstore().</source>
          <target state="translated">Поскольку Storable не знает и не заботится о наборах символов (хотя и знает,что ширина символов может превышать восемь бит),любая разница в интерпретации кодов символов между хостом и целевой системой-это ваша проблема.В частности,если хост и целевая система используют разные точки кода для представления символов,используемых в текстовом представлении чисел с плавающей точкой,вы не сможете обмениваться данными с плавающей точкой,даже с помощью nstore().</target>
        </trans-unit>
        <trans-unit id="4eb26264176ff313034cbea4b1e32ac9ca4ff4be" translate="yes" xml:space="preserve">
          <source>As a beginning Perl programmer, your most common use of OO Perl will be in using third-party modules, which are documented below.</source>
          <target state="translated">Как начинающий Perl программист,ваше самое распространенное использование OO Perl будет заключаться в использовании модулей сторонних производителей,которые описаны ниже.</target>
        </trans-unit>
        <trans-unit id="c668c33e20c8d7992e509e03d3adf2ab76f6474b" translate="yes" xml:space="preserve">
          <source>As a consequence of the fact that &lt;code&gt;:raw&lt;/code&gt; normally pops layers, it usually only makes sense to have it as the only or first element in a layer specification. When used as the first element it provides a known base on which to build e.g.</source>
          <target state="translated">Как следствие того факта, что &lt;code&gt;:raw&lt;/code&gt; обычно выводит слои, обычно имеет смысл использовать его только как единственный или первый элемент в спецификации слоя. При использовании в качестве первого элемента он обеспечивает известную основу для построения, например</target>
        </trans-unit>
        <trans-unit id="85a48b10d40e66cd4a8aedc3b80bf9f3898c7f18" translate="yes" xml:space="preserve">
          <source>As a consequence, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ignores any number or &lt;code&gt;*&lt;/code&gt; after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">Как следствие, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; игнорирует любое число или &lt;code&gt;*&lt;/code&gt; после &lt;code&gt;P&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af58dfe35e68f1702e8805a513e543501b556b2f" translate="yes" xml:space="preserve">
          <source>As a consequence, the behavior of the operator % agrees with the behavior of Perl's built-in % operator (as documented in the perlop manpage), and the equation</source>
          <target state="translated">Как следствие,поведение оператора % согласуется с поведением встроенного в Perl оператора % (как документировано в manpage perlop),а также с уравнением</target>
        </trans-unit>
        <trans-unit id="8ed20c41e94e838dcaa1f2e890809ac53aaadc11" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;io/socket&quot;&gt;IO::Socket&lt;/a&gt;'s setsockopt() method will convert a number into a packed byte buffer, and getsockopt() will unpack a byte buffer of the correct size back into a number.</source>
          <target state="translated">Для удобства метод setsockopt () &lt;a href=&quot;io/socket&quot;&gt;IO :: Socket&lt;/a&gt; преобразует число в упакованный байтовый буфер, а getsockopt () распакует байтовый буфер правильного размера обратно в число.</target>
        </trans-unit>
        <trans-unit id="39dd3ca26236e47c7f0b84b7220b02b39c4ce6f1" translate="yes" xml:space="preserve">
          <source>As a convenience, if only one argument is passed then this argument is assumed to be the name of the test (as in the above examples.)</source>
          <target state="translated">Для удобства,если передается только один аргумент,то этот аргумент принимается за название теста (как в вышеприведенных примерах).</target>
        </trans-unit>
        <trans-unit id="1cb03824a7a51fc71299760a7d72ef70c9f7d1d1" translate="yes" xml:space="preserve">
          <source>As a debugging aid, you can force Carp to treat a croak as a confess and a carp as a cluck across</source>
          <target state="translated">Как отладочное средство,вы можете заставить Карпа обращаться с крокодилой как с признанием,а карпа-как с кулаком.</target>
        </trans-unit>
        <trans-unit id="5de9c4f1738c3fbc65c8014410d9308c0bceec73" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Parser, Pod::PlainText supports the same methods and interfaces. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; and then calls either parse_from_filehandle() or parse_from_file().</source>
          <target state="translated">Как производный класс от Pod :: Parser, Pod :: PlainText поддерживает те же методы и интерфейсы. См. &lt;a href=&quot;parser&quot;&gt;Pod :: Parser&lt;/a&gt; для всех подробностей; вкратце, создается новый парсер с помощью &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; а затем вызывается либо parse_from_filehandle (), либо parse_from_file ().</target>
        </trans-unit>
        <trans-unit id="f6ec952fc34afc28085390c8d52daf19e0a80643" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Man supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details.</source>
          <target state="translated">Как производный класс от Pod :: Simple, Pod :: Man поддерживает те же методы и интерфейсы. См. Все подробности в &lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e4fc5bdbe388e6ddf3cda0d8bc20220f607ea7d" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Text supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; and then normally calls parse_file().</source>
          <target state="translated">Как производный класс от Pod :: Simple, Pod :: Text поддерживает те же методы и интерфейсы. См. Все подробности в &lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt; ; вкратце, создается новый парсер с помощью &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; а затем обычно вызывается parse_file ().</target>
        </trans-unit>
        <trans-unit id="b23f74daa8f57475a4ba46fd4485f5b745823a7e" translate="yes" xml:space="preserve">
          <source>As a final remark, note that one can fill %subr by</source>
          <target state="translated">В качестве последнего замечания,обратите внимание,что можно заполнить %subr посредством</target>
        </trans-unit>
        <trans-unit id="4cc64b626e2a5166499114ddf2d5328e019929e3" translate="yes" xml:space="preserve">
          <source>As a final thought, remember that it's not (at the time of writing) possible to produce a useful program which will run in zero or negative time and this basic principle can be written as:</source>
          <target state="translated">В качестве заключительной мысли помните,что невозможно (на момент написания статьи)создать полезную программу,которая будет выполняться в нулевое или отрицательное время,и этот основной принцип можно записать как:</target>
        </trans-unit>
        <trans-unit id="c76d7d0ab08773eceae9495e1336acd5bdc1e071" translate="yes" xml:space="preserve">
          <source>As a further example, this means that if you wanted to put these bits of code in &lt;code&gt;C&lt;/code&gt; (code) style:</source>
          <target state="translated">В качестве следующего примера это означает, что если вы хотите поместить эти фрагменты кода в стиль &lt;code&gt;C&lt;/code&gt; (код):</target>
        </trans-unit>
        <trans-unit id="a5d5c5dbed3ae73f59f4d512802a9cfe627521f0" translate="yes" xml:space="preserve">
          <source>As a further example: At time of writing, no &quot;biblio&quot; identifier is supported, but suppose some processor were written to recognize it as a way of (say) denoting a bibliographic reference (necessarily containing formatting codes in ordinary paragraphs). The fact that &quot;biblio&quot; paragraphs were meant for ordinary processing would be indicated by prefacing each &quot;biblio&quot; identifier with a colon:</source>
          <target state="translated">В качестве еще одного примера:На момент написания статьи идентификатор &quot;библиографии&quot; не поддерживается,но предположим,что какой-то процессор был написан для того,чтобы распознать его как способ (скажем)обозначения библиографической ссылки (обязательно содержащей коды форматирования в обычных параграфах).Тот факт,что абзацы &quot;библиографии&quot; предназначены для обычной обработки,будет указываться путем указания двоеточия перед каждым идентификатором &quot;библиографии&quot;:</target>
        </trans-unit>
        <trans-unit id="32e712936b7f11c5ab2eb3ed80fcfadcc776b710" translate="yes" xml:space="preserve">
          <source>As a further optimisation, on exit from the eval block in the &lt;code&gt;FETCH&lt;/code&gt; , execution of the code following the block is still carried on in the inner loop. When an exception is raised, &lt;code&gt;docatch&lt;/code&gt; compares the &lt;code&gt;JMPENV&lt;/code&gt; level of the &lt;code&gt;CxEVAL&lt;/code&gt; with &lt;code&gt;PL_top_env&lt;/code&gt; and if they differ, just re-throws the exception. In this way any inner loops get popped.</source>
          <target state="translated">В качестве дополнительной оптимизации при выходе из блока eval в &lt;code&gt;FETCH&lt;/code&gt; выполнение кода, следующего за блоком, все еще продолжается во внутреннем цикле. Когда возбуждается исключение, &lt;code&gt;docatch&lt;/code&gt; сравнивает &lt;code&gt;JMPENV&lt;/code&gt; уровень &lt;code&gt;CxEVAL&lt;/code&gt; с &lt;code&gt;PL_top_env&lt;/code&gt; и если они отличаются, просто повторно бросает исключение. Таким образом появляются любые внутренние петли.</target>
        </trans-unit>
        <trans-unit id="23702715810537d7f01f041b430e67e396dff672" translate="yes" xml:space="preserve">
          <source>As a general rule of thumb, your commit message should help a programmer who knows the Perl core quickly understand what you were trying to do, how you were trying to do it, and why the change matters to Perl.</source>
          <target state="translated">Как правило,ваше сообщение о коммите должно помочь программисту,который знает ядро Perl,быстро понять,что вы пытались сделать,как вы пытались это сделать,и почему изменение имеет значение для Perl.</target>
        </trans-unit>
        <trans-unit id="4e47a1601663426f056fd202a23442a94b37a934" translate="yes" xml:space="preserve">
          <source>As a general rule you should</source>
          <target state="translated">Как правило,вы должны</target>
        </trans-unit>
        <trans-unit id="f1a7ae8ef2fbb4b6cb7127db887caa429f079e93" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then &lt;code&gt;@EXPORT_OK&lt;/code&gt; anything but use &lt;code&gt;@EXPORT&lt;/code&gt; with caution. For function and method names use barewords in preference to names prefixed with ampersands for the export lists.</source>
          <target state="translated">Как правило, если модуль пытается быть объектно-ориентированным, ничего не экспортируется. Если это просто набор функций, тогда &lt;code&gt;@EXPORT_OK&lt;/code&gt; что угодно, но используйте &lt;code&gt;@EXPORT&lt;/code&gt; с осторожностью. Для имен функций и методов используйте голые слова вместо имен с префиксом амперсанда для списков экспорта.</target>
        </trans-unit>
        <trans-unit id="e17549d186f2cd9b2973080585cd98536cba2f89" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then @EXPORT_OK anything but use @EXPORT with caution.</source>
          <target state="translated">Как правило,если модуль пытается быть объектно-ориентированным,то экспортировать ничего не надо.Если это просто набор функций,то @EXPORT_OK все что угодно,но используйте @EXPORT с осторожностью.</target>
        </trans-unit>
        <trans-unit id="433c99eba76250876af9c971ad06d88a2549474f" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object-oriented then don't export anything. If it's just a collection of functions and variables, then you can export them via another array, called &lt;code&gt;@EXPORT_OK&lt;/code&gt; . This array does not automatically place its subroutine and variable names into the namespace unless the user specifically requests that this be done.</source>
          <target state="translated">Как правило, если модуль пытается быть объектно-ориентированным, ничего не экспортируйте. Если это просто набор функций и переменных, вы можете экспортировать их через другой массив, называемый &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Этот массив не помещает автоматически свои подпрограммы и имена переменных в пространство имен, если только пользователь специально этого не требует.</target>
        </trans-unit>
        <trans-unit id="a207991a7d026174ee51a8481f0b776cbc48b6ea" translate="yes" xml:space="preserve">
          <source>As a last resort, however:</source>
          <target state="translated">Однако,в крайнем случае:</target>
        </trans-unit>
        <trans-unit id="3ab2161dda92a73d5893b103484d832131038b70" translate="yes" xml:space="preserve">
          <source>As a last resort, you can use the perl one-liner:</source>
          <target state="translated">В крайнем случае,вы можете использовать перл-однолинейный:</target>
        </trans-unit>
        <trans-unit id="9a117b27b5618d5856aaaf26d908e957a310a377" translate="yes" xml:space="preserve">
          <source>As a last resort, you could also use &lt;code&gt;PERL5DB&lt;/code&gt; to customize the debugger by directly setting internal variables or calling debugger functions.</source>
          <target state="translated">В крайнем случае вы также можете использовать &lt;code&gt;PERL5DB&lt;/code&gt; для настройки отладчика, напрямую задав внутренние переменные или вызывая функции отладчика.</target>
        </trans-unit>
        <trans-unit id="46efdbcc9fcabaefc1ffd7ba61888d42081d0818" translate="yes" xml:space="preserve">
          <source>As a noun, a piece of syntax made up of smaller pieces. As a transitive verb, to create an &lt;b&gt;object&lt;/b&gt; using a &lt;b&gt;constructor&lt;/b&gt;.</source>
          <target state="translated">Как существительное, часть синтаксиса, состоящая из более мелких частей. Как переходный глагол, создать &lt;b&gt;объект&lt;/b&gt; с помощью &lt;b&gt;конструктора&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="3f0cb7718076aa901719a5347944ab158c02cce2" translate="yes" xml:space="preserve">
          <source>As a result of these problems, starting in v5.20, what Perl does is to treat non-Unicode code points as just typical unassigned Unicode characters, and matches accordingly. (Note: Unicode has atypical unassigned code points. For example, it has noncharacter code points, and ones that, when they do get assigned, are destined to be written Right-to-left, as Arabic and Hebrew are. Perl assumes that no non-Unicode code point has any atypical properties.)</source>
          <target state="translated">В результате этих проблем,начиная с версии v5.20,Perl делает то,что рассматривает точки,не относящиеся к коду Юникода,как типичные неприсвоенные символы Юникода,и соответствует им.(Примечание:Юникод имеет нетипичные неприсвоенные точки кода.Например,у него есть несимвольные точки кода,а те,которые,когда им присваивают,предназначены для написания справа налево,как на арабском и иврите.Perl предполагает,что ни одна не-некодовая точка кода не имеет нетипичных свойств).</target>
        </trans-unit>
        <trans-unit id="dd723ff09f0dfd75022fcfe75451c37784da18b7" translate="yes" xml:space="preserve">
          <source>As a result, &lt;code&gt;$?&lt;/code&gt; will always be zero if the subprocess's exit status indicated successful completion, and non-zero if a warning or error occurred or a program compliant with encoding _POSIX_EXIT values was run and set a status.</source>
          <target state="translated">В итоге &lt;code&gt;$?&lt;/code&gt; всегда будет нулевым, если статус выхода подпроцесса указывает на успешное завершение, и ненулевым, если возникло предупреждение или ошибка или была запущена программа, соответствующая кодировке значений _POSIX_EXIT, и установила статус.</target>
        </trans-unit>
        <trans-unit id="c26b5ebaa65b4ac15b7d233c58e1a9bb61162748" translate="yes" xml:space="preserve">
          <source>As a scalar operator:</source>
          <target state="translated">Как скалярный оператор:</target>
        </trans-unit>
        <trans-unit id="8274ec69a734737beb00f3f5313b731efea1dc76" translate="yes" xml:space="preserve">
          <source>As a shortcut &lt;code&gt;(*MARK:NAME)&lt;/code&gt; can be written &lt;code&gt;(*:NAME)&lt;/code&gt;.</source>
          <target state="translated">В качестве ярлыка &lt;code&gt;(*MARK:NAME)&lt;/code&gt; можно написать &lt;code&gt;(*:NAME)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b9a135b5dd5e3840c9d7b2126bd8f1513618105" translate="yes" xml:space="preserve">
          <source>As a shortcut a one-argument call takes the filename from the global scalar variable of the same name as the filehandle:</source>
          <target state="translated">В качестве ярлыка однопараметрический вызов принимает имя файла из глобальной скалярной переменной с тем же именем,что и ручка файла:</target>
        </trans-unit>
        <trans-unit id="9baecd622ad6ae8ccb368a1f47c6a9f4ae3fac55" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can use the module &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;:</source>
          <target state="translated">В качестве ярлыка вы можете использовать модуль &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5b3e1134bf3b8109ecb5762080e2eff8e1996cc6" translate="yes" xml:space="preserve">
          <source>As a side effect, as &lt;code&gt;_&lt;/code&gt; doesn't work, stacked filetest operators (&lt;code&gt;-f -w $file&lt;/code&gt; ) won't work either.</source>
          <target state="translated">В качестве побочного эффекта, поскольку &lt;code&gt;_&lt;/code&gt; не работает, операторы стекового тестирования файлов ( &lt;code&gt;-f -w $file&lt;/code&gt; ) также не будут работать.</target>
        </trans-unit>
        <trans-unit id="e67c2575fdaa4cadca39640f540c5c1c25ff2b7b" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">В качестве побочного эффекта вызов keys () сбрасывает внутренний итератор HASH или ARRAY (см. &lt;a href=&quot;#each&quot;&gt;Каждый&lt;/a&gt; ). В частности, вызов keys () в контексте void сбрасывает итератор без дополнительных затрат.</target>
        </trans-unit>
        <trans-unit id="c7b3fa9f58a42d510ccd961956edd3b53e1d0c57" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">В качестве побочного эффекта вызов keys () сбрасывает внутренний итератор HASH или ARRAY (см. &lt;a href=&quot;each&quot;&gt;Каждый&lt;/a&gt; ). В частности, вызов keys () в контексте void сбрасывает итератор без дополнительных затрат.</target>
        </trans-unit>
        <trans-unit id="aa184b78eeef36fa29a1577f9bf8458234354229" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">В качестве побочного эффекта вызов values ​​() сбрасывает внутренний итератор HASH или ARRAY, см. &lt;a href=&quot;#each&quot;&gt;Каждый&lt;/a&gt; . (В частности, вызов values ​​() в контексте void сбрасывает итератор без каких-либо дополнительных затрат. Помимо сброса итератора, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; в контексте списка такие же, как и простой &lt;code&gt;@array&lt;/code&gt; . (Мы рекомендуем использовать &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; пустого контекста @array для этого, но рассудил, что получение &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out потребует больше документации, чем оставление его внутри.)</target>
        </trans-unit>
        <trans-unit id="a91a0923e5abea890fdc2bd22bb84126ade104fe" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">В качестве побочного эффекта вызов values ​​() сбрасывает внутренний итератор HASH или ARRAY, см. &lt;a href=&quot;each&quot;&gt;Каждый&lt;/a&gt; . (В частности, вызов values ​​() в контексте void сбрасывает итератор без каких-либо дополнительных затрат. Помимо сброса итератора, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; в контексте списка такие же, как и простой &lt;code&gt;@array&lt;/code&gt; . (Мы рекомендуем использовать &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; пустого контекста @array для этого, но рассудил, что получение &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out потребует больше документации, чем оставление его внутри.)</target>
        </trans-unit>
        <trans-unit id="e8e57a1c04bdc517b9206bb149b8d52cd1b60750" translate="yes" xml:space="preserve">
          <source>As a special case</source>
          <target state="translated">В качестве особого случая</target>
        </trans-unit>
        <trans-unit id="17ea6c6f4727b11c2b48648599d60dd30f72b5e8" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">В качестве особого случая для &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; пустой шаблон, указанный в синтаксисе &lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;оператора сопоставления&lt;/a&gt; ( &lt;code&gt;//&lt;/code&gt; ), конкретно соответствует пустой строке, что противоречит его обычной интерпретации как последнее успешное сопоставление.</target>
        </trans-unit>
        <trans-unit id="59db895ceb1feffbf61c972fbfef8ae7b61e3fff" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">В качестве особого случая для &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; пустой шаблон, указанный в синтаксисе &lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;оператора сопоставления&lt;/a&gt; ( &lt;code&gt;//&lt;/code&gt; ), конкретно соответствует пустой строке, что противоречит его обычной интерпретации как последнее успешное сопоставление.</target>
        </trans-unit>
        <trans-unit id="527a25823c5b741d3ca1303c6cacef3dfa61f467" translate="yes" xml:space="preserve">
          <source>As a special case if the overload returns the object itself then it will be used directly. An overloaded conversion returning the object is probably a bug, because you're likely to get something that looks like &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; .</source>
          <target state="translated">В качестве особого случая, если перегрузка возвращает сам объект, он будет использоваться напрямую. Перегруженное преобразование, возвращающее объект, вероятно, является ошибкой, потому что вы, вероятно, получите что-то похожее на &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="898fa8e40ea8bbaf82f7657e12c724a39a6b933a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">В качестве особого случая форма с тремя аргументами с режимом чтения / записи и третьим аргументом &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bfe8944e96951a5268014155bb5ff3707aad862a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">В качестве особого случая форма с тремя аргументами с режимом чтения / записи и третьим аргументом &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="39d0f95cc62f9b7d251ca80f498d915dd0b1187f" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;\(@foo)&lt;/code&gt; returns a list of references to the contents of &lt;code&gt;@foo&lt;/code&gt; , not a reference to &lt;code&gt;@foo&lt;/code&gt; itself. Likewise for &lt;code&gt;%foo&lt;/code&gt; , except that the key references are to copies (since the keys are just strings rather than full-fledged scalars).</source>
          <target state="translated">В качестве особого случая &lt;code&gt;\(@foo)&lt;/code&gt; возвращает список ссылок на содержимое &lt;code&gt;@foo&lt;/code&gt; , а не ссылку на сам &lt;code&gt;@foo&lt;/code&gt; . То же самое для &lt;code&gt;%foo&lt;/code&gt; , за исключением того, что ключевые ссылки относятся к копиям (поскольку ключи - это просто строки, а не полноценные скаляры).</target>
        </trans-unit>
        <trans-unit id="9d3b4ecbd7d509c41643f820908fd45c356bb919" translate="yes" xml:space="preserve">
          <source>As a special case, if the test in the &lt;code&gt;for&lt;/code&gt; loop (or the corresponding &lt;code&gt;while&lt;/code&gt; loop) is empty, it is treated as true. That is, both</source>
          <target state="translated">В особом случае, если тест в &lt;code&gt;for&lt;/code&gt; цикла (или соответствующий во &lt;code&gt;while&lt;/code&gt; цикла) пусто, оно рассматривается как верно. То есть оба</target>
        </trans-unit>
        <trans-unit id="07d1fa15ef1af04fe7ac16e1712ceb861430b28a" translate="yes" xml:space="preserve">
          <source>As a special case, if the value of this variable is space-separated, the tail might be used to disable the ornaments by setting the tail to be &lt;code&gt;o=0&lt;/code&gt; or &lt;code&gt;ornaments=0&lt;/code&gt; . The head should be as described above, say</source>
          <target state="translated">В качестве особого случая, если значение этой переменной разделено пробелами, хвост можно использовать для отключения орнаментов, установив для него значение &lt;code&gt;o=0&lt;/code&gt; или &lt;code&gt;ornaments=0&lt;/code&gt; . Голова должна быть такой, как описано выше, скажем</target>
        </trans-unit>
        <trans-unit id="0fde23ad411d5b9ebf1966fbf214f46640cb22f9" translate="yes" xml:space="preserve">
          <source>As a special case, if you specify the module name &lt;code&gt;Unicode&lt;/code&gt; , you'll get the version number of the Unicode Character Database bundled with the requested perl versions.</source>
          <target state="translated">В качестве особого случая, если вы укажете имя модуля &lt;code&gt;Unicode&lt;/code&gt; , вы получите номер версии базы данных символов Unicode в комплекте с запрошенными версиями Perl.</target>
        </trans-unit>
        <trans-unit id="03f58faea796a1077f97500a4e213c983487f04c" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with a hash reference as the sole argument, this causes an assignment of the whole hash element. The object reference is returned.</source>
          <target state="translated">В особом случае,когда аксессуар вызывается со ссылкой на хэш в качестве единственного аргумента,это приводит к присвоению всего хэш-элемента.Возвращается ссылка на объект.</target>
        </trans-unit>
        <trans-unit id="d80964d39654d27c73a60223b4ebc15d6e6b2f91" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with an array reference as the sole argument, this causes an assignment of the whole array element. The object reference is returned.</source>
          <target state="translated">В особом случае,когда аксессуар вызывается со ссылкой на массив в качестве единственного аргумента,это приводит к присвоению всему элементу массива.Возвращается объектная ссылка.</target>
        </trans-unit>
        <trans-unit id="261536d85ff532107bd0e6c855c28c78277c6b3c" translate="yes" xml:space="preserve">
          <source>As a special exception, when you slice a list (but not an array or a hash), if the list evaluates to empty, then taking a slice of that empty list will always yield the empty list in turn. Thus:</source>
          <target state="translated">В качестве особого исключения,когда вы режете список (но не массив или хэш),если список оценивает как пустой,то,взяв кусочек этого пустого списка,вы всегда получите пустой список по очереди.Таким образом:</target>
        </trans-unit>
        <trans-unit id="267a52b216bf364239047183b439e3e80275f9ef" translate="yes" xml:space="preserve">
          <source>As a vendor, you may have a requirement to backport security fixes beyond our 3 year support commitment. We can provide limited support and advice to you as you do so and, where possible will try to apply those patches to the relevant -maint branches in git, though we may or may not choose to make numbered releases or &quot;official&quot; patches available. Contact us at &amp;lt;perl5-security-report@perl.org&amp;gt; to begin that process.</source>
          <target state="translated">Как поставщик, вам может потребоваться выполнить резервное копирование исправлений безопасности после того, как мы предоставим поддержку в течение 3 лет. Мы можем предоставить вам ограниченную поддержку и советы, когда вы это сделаете, и, где это возможно, попытаемся применить эти исправления к соответствующим веткам -maint в git, хотя мы можем или не можем сделать доступными нумерованные выпуски или &amp;laquo;официальные&amp;raquo; исправления. Свяжитесь с нами по адресу &amp;lt;perl5-security-report@perl.org&amp;gt;, чтобы начать этот процесс.</target>
        </trans-unit>
        <trans-unit id="6b767e1ab5bdc22f58c69583808a39ce8aa5393a" translate="yes" xml:space="preserve">
          <source>As a volunteer organization, the commitments we make are heavily dependent on the goodwill and hard work of individuals who have no obligation to contribute to Perl.</source>
          <target state="translated">Как добровольческая организация,обязательства,которые мы берем на себя,в значительной степени зависят от доброй воли и упорного труда людей,которые не обязаны вносить свой вклад в Perl.</target>
        </trans-unit>
        <trans-unit id="b55a4625fdc844badd446c13482f0c20c8caa1b5" translate="yes" xml:space="preserve">
          <source>As above, but the destination node text of the link.</source>
          <target state="translated">Как и выше,но текст узла назначения ссылки.</target>
        </trans-unit>
        <trans-unit id="07731660b460e18f03465884e08d802967534966" translate="yes" xml:space="preserve">
          <source>As all values evaluate to true, a simple &lt;code&gt;if&lt;/code&gt; test is good enough to determine whether an extension is present.</source>
          <target state="translated">Поскольку все значения истинны, простого теста &lt;code&gt;if&lt;/code&gt; достаточно, чтобы определить, присутствует ли расширение.</target>
        </trans-unit>
        <trans-unit id="049e8d249c3ad3a2a8b180055568baa12252b047" translate="yes" xml:space="preserve">
          <source>As alluded to earlier you can also declare inlined subs dynamically at BEGIN time if their body consists of a lexically-scoped scalar which has no other references. Only the first example here will be inlined:</source>
          <target state="translated">Как уже упоминалось ранее,вы также можете объявить inlined subs динамически в BEGIN время,если их тело состоит из лексически описанного скаляра,который не имеет других ссылок.Только первый пример здесь будет inlined:</target>
        </trans-unit>
        <trans-unit id="40622c1595c0e7b33c82f810ddadd26599013393" translate="yes" xml:space="preserve">
          <source>As alternatives to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; when used for control flow, Perl provides the &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators (see below). The short-circuit behavior is identical. The precedence of &lt;code&gt;&quot;and&quot;&lt;/code&gt; and &lt;code&gt;&quot;or&quot;&lt;/code&gt; is much lower, however, so that you can safely use them after a list operator without the need for parentheses:</source>
          <target state="translated">В качестве альтернативы &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; при использовании для потока управления Perl предоставляет операторы &lt;code&gt;and&lt;/code&gt; и &lt;code&gt;or&lt;/code&gt; (см. ниже). Поведение при коротком замыкании идентично. Однако приоритет &lt;code&gt;&quot;and&quot;&lt;/code&gt; и &lt;code&gt;&quot;or&quot;&lt;/code&gt; намного ниже, так что вы можете безопасно использовать их после оператора списка без скобок:</target>
        </trans-unit>
        <trans-unit id="c44b3a4add0c470afd83290fbaea5d47d3bf3bcb" translate="yes" xml:space="preserve">
          <source>As always with Perl there is more than one way to do it. Below are a few examples of approaches to making common conversions between number representations. This is intended to be representational rather than exhaustive.</source>
          <target state="translated">Как всегда с Перлом,есть не один способ сделать это.Ниже приведены несколько примеров подходов к выполнению общих преобразований между числовыми представлениями.Это должно быть репрезентативным,а не исчерпывающим.</target>
        </trans-unit>
        <trans-unit id="a27e8bc51d6a9b14b4e2235fdc7ebedf28d134bc" translate="yes" xml:space="preserve">
          <source>As always, if any of these are ever officially declared as bugs, they'll be fixed and removed.</source>
          <target state="translated">Как всегда,если кто-то из них когда-нибудь будет официально объявлен дефектом,он будет исправлен и удален.</target>
        </trans-unit>
        <trans-unit id="43d8cae7f79fc634e42b4fbb6869d40983003e1e" translate="yes" xml:space="preserve">
          <source>As always, setting up a server is little bit more involved than running a client. The model is that the server creates a special kind of socket that does nothing but listen on a particular port for incoming connections. It does this by calling the &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; method with slightly different arguments than the client did.</source>
          <target state="translated">Как всегда, настройка сервера немного сложнее, чем запуск клиента. Модель состоит в том, что сервер создает особый вид сокета, который ничего не делает, кроме как прослушивает определенный порт для входящих соединений. Для этого он вызывает метод &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; с аргументами, немного отличающимися от аргументов клиента.</target>
        </trans-unit>
        <trans-unit id="90ed318055b1f6119d9ba187aa6944aea5c29dbe" translate="yes" xml:space="preserve">
          <source>As an added convenience, the Digest::SHA module offers routines to calculate keyed hashes using the HMAC-SHA-1/224/256/384/512 algorithms. These services exist in functional form only, and mimic the style and behavior of the</source>
          <target state="translated">В качестве дополнительного удобства,модуль Digest::SHA предлагает подпрограммы для вычисления кешированных хэшей с использованием алгоритмов HMAC-SHA-1/224/256/384/512.Эти сервисы существуют только в функциональной форме,и имитируют стиль и поведение</target>
        </trans-unit>
        <trans-unit id="d0e4684ebfef4659c7147a264548f0d1e61303df" translate="yes" xml:space="preserve">
          <source>As an aid in resetting colors, colored() takes a scalar as the first argument and any number of attribute strings as the second argument and returns the scalar wrapped in escape codes so that the attributes will be set as requested before the string and reset to normal after the string. Alternately, you can pass a reference to an array as the first argument, and then the contents of that array will be taken as attributes and color codes and the remainder of the arguments as text to colorize.</source>
          <target state="translated">В качестве помощи в сбросе цветов функция color()принимает скаляр в качестве первого аргумента и любое количество строк атрибутов в качестве второго аргумента и возвращает скаляр,обёрнутый в экранирующие коды,так что атрибуты будут установлены,как было запрошено до строки и сброшены в нормальное состояние после строки.В качестве первого аргумента можно передать ссылку на массив,а затем содержимое этого массива будет принято за атрибуты и цветовые коды,а остальные аргументы-за текст для раскрашивания.</target>
        </trans-unit>
        <trans-unit id="9c1670ab0bb7042a354367f8f6979cab460d9b35" translate="yes" xml:space="preserve">
          <source>As an alternative to the above, you may prefer to throw exceptions using the Error module.</source>
          <target state="translated">В качестве альтернативы,вы можете предпочесть бросать исключения,используя модуль Error.</target>
        </trans-unit>
        <trans-unit id="782eb5f652231f0fff9e780cbf2fef47e3527def" translate="yes" xml:space="preserve">
          <source>As an alternative, overloaded constants (see &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;) provide a simple way to extend the functionality of the RE engine, by substituting one pattern for another.</source>
          <target state="translated">В качестве альтернативы перегруженные константы (см. &lt;a href=&quot;overload&quot;&gt;Раздел &amp;laquo;Перегрузка&amp;raquo;&lt;/a&gt; ) предоставляют простой способ расширить функциональные возможности механизма RE путем замены одного шаблона другим.</target>
        </trans-unit>
        <trans-unit id="18772395363d0e88e55df307a43fbfe2be745eba" translate="yes" xml:space="preserve">
          <source>As an alternative, specify a number instead of list of letters (e.g., &lt;b&gt;-D14&lt;/b&gt; is equivalent to &lt;b&gt;-Dtls&lt;/b&gt;):</source>
          <target state="translated">В качестве альтернативы укажите число вместо списка букв (например, &lt;b&gt;-D14&lt;/b&gt; эквивалентно &lt;b&gt;-Dtls&lt;/b&gt; ):</target>
        </trans-unit>
        <trans-unit id="8f4ba5d9ceee180216d44c33a248904b28bf93a4" translate="yes" xml:space="preserve">
          <source>As an alternative, to keep the case of the replacement word if it is longer than the original, you can use this code, by Jeff Pinyan:</source>
          <target state="translated">В качестве альтернативы,чтобы сохранить регистр заменяющего слова,если оно длиннее оригинала,можно воспользоваться этим кодом,по словам Джеффа Пиняна:</target>
        </trans-unit>
        <trans-unit id="edc86b424441622df9f0c07df7eb59f80cab5da3" translate="yes" xml:space="preserve">
          <source>As an example of something that is caught under &lt;code&gt;&quot;strict'&lt;/code&gt; , but not otherwise, is the pattern</source>
          <target state="translated">Примером того, что попадает в категорию &lt;code&gt;&quot;strict'&lt;/code&gt; , но не иначе, является шаблон</target>
        </trans-unit>
        <trans-unit id="52b1b17f0c5a778dad149ae64ff9d232a5d6120e" translate="yes" xml:space="preserve">
          <source>As an example of this case, this code prints the message &quot;Perl exited with active threads: 2 running and unjoined&quot;:</source>
          <target state="translated">В качестве примера приведен код,который печатает сообщение &quot;Perl exited with active threads:2 работает и не работает&quot;:</target>
        </trans-unit>
        <trans-unit id="fd8cd6983452bdbcd828fbbb431f9c0eaf4c793d" translate="yes" xml:space="preserve">
          <source>As an example where a possessive quantifier is suitable we consider matching a quoted string, as it appears in several programming languages. The backslash is used as an escape character that indicates that the next character is to be taken literally, as another character for the string. Therefore, after the opening quote, we expect a (possibly empty) sequence of alternatives: either some character except an unescaped quote or backslash or an escaped character.</source>
          <target state="translated">В качестве примера,для которого подходит притягательный квантификатор,рассмотрим соответствие строки,приведенной в кавычках,как это бывает в нескольких языках программирования.Обратный слеш используется как экранирующий символ,который указывает на то,что следующий символ должен восприниматься буквально,как еще один символ для строки.Поэтому,после вступительной кавычки,мы ожидаем (возможно,пустую)последовательность альтернатив:либо какой-то символ за исключением нецифровой кавычки,либо обратный слеш,либо экранированный символ.</target>
        </trans-unit>
        <trans-unit id="82731324b346859b9bccf9603560116021199d53" translate="yes" xml:space="preserve">
          <source>As an example, when Perl sees &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; , it encodes the character in UTF-8 and stores it in $x. Then it is marked as character data, so, for instance, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt; . However, in the scope of the &lt;code&gt;bytes&lt;/code&gt; pragma, $x is treated as a series of bytes - the bytes that make up the UTF8 encoding - and &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt; :</source>
          <target state="translated">Например, когда Perl видит &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; , он кодирует символ в UTF-8 и сохраняет его в $ x. Затем он помечается как символьные данные, поэтому, например, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; возвращает &lt;code&gt;1&lt;/code&gt; . Однако в области прагмы &lt;code&gt;bytes&lt;/code&gt; $ x рассматривается как последовательность байтов - байтов, составляющих кодировку UTF8, - а &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; возвращает &lt;code&gt;2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c313609d4ce2bde8a8cf3d1a920bc018f88eebaa" translate="yes" xml:space="preserve">
          <source>As an interim measure, you may either change the #! line of your scripts to specifically refer to the old perl version, e.g. on Solaris 9 use #!/usr/perl5/5.00503/bin/perl to use the perl version that was the default for Solaris 8, or if you have a large number of scripts it may be more convenient to make the old version of perl the default on your system. You can do this by changing the appropriate symlinks under /usr/perl5 as follows (example for Solaris 9):</source>
          <target state="translated">В качестве временной меры,вы можете либо изменить строку #! в ваших скриптах,чтобы она конкретно ссылалась на старую версию perl,например,в Solaris 9 использовать #!/usr/perl5/5.00503/bin/perl,чтобы использовать версию perl,которая была по умолчанию для Solaris 8,или,если у вас есть большое количество скриптов,может быть более удобно сделать старую версию perl по умолчанию в вашей системе.Вы можете сделать это,изменив соответствующие сим-ссылки в /usr/perl5 следующим образом (пример для Solaris 9):</target>
        </trans-unit>
        <trans-unit id="373576f861e30b7c81e25bff74bee6e23c15298c" translate="yes" xml:space="preserve">
          <source>As an optimization, may not call the command shell specified in &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; spawns an external process and immediately returns its process designator, without waiting for it to terminate. Return value may be used subsequently in &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;. Failure to &lt;code&gt;spawn()&lt;/code&gt; a subprocess is indicated by setting &lt;code&gt;$?&lt;/code&gt; to &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; . &lt;code&gt;$?&lt;/code&gt; is set in a way compatible with Unix (i.e. the exitstatus of the subprocess is obtained by &lt;code&gt;&quot;$?&lt;/code&gt; 8&quot;&amp;gt;&amp;gt;, as described in the documentation). (Win32)</source>
          <target state="translated">В &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; оптимизации нельзя вызывать командную оболочку, указанную в $ ENV {PERL5SHELL} . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; порождает внешний процесс и немедленно возвращает его обозначение процесса, не дожидаясь его завершения. Возвращаемое значение может быть впоследствии использовано в &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; . Невозможность &lt;code&gt;spawn()&lt;/code&gt; подпроцесса указывается установкой &lt;code&gt;$?&lt;/code&gt; на &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; . &lt;code&gt;$?&lt;/code&gt; устанавливается способом, совместимым с Unix (т.е. статус выхода подпроцесса получается с помощью &lt;code&gt;&quot;$?&lt;/code&gt; 8&amp;raquo; &amp;gt;&amp;gt;, как описано в документации). (Win32)</target>
        </trans-unit>
        <trans-unit id="38474bdd192558dcfa688dfaf6e45817a6f595ea" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">В качестве другого особого случая &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; имитирует поведение инструмента командной строки &lt;b&gt;awk&lt;/b&gt; по умолчанию, когда ШАБЛОН либо опущен, либо</target>
        </trans-unit>
        <trans-unit id="aab9f2eadc04a37e669ffc31217a1ec91df2a94d" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">В качестве другого особого случая &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; имитирует поведение инструмента командной строки &lt;b&gt;awk&lt;/b&gt; по умолчанию, когда ШАБЛОН либо опущен, либо</target>
        </trans-unit>
        <trans-unit id="46ab5c6135652ee2c4d494e00004b3edd1c35481" translate="yes" xml:space="preserve">
          <source>As another workaround for this problem, Perl 5.10.0 introduced &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , which are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , &lt;b&gt;except&lt;/b&gt; that they are only guaranteed to be defined after a successful match that was executed with the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier. The use of these variables incurs no global performance penalty, unlike their punctuation char equivalents, however at the trade-off that you have to tell perl when you want to use them. As of Perl 5.20, these three variables are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , and &lt;code&gt;/p&lt;/code&gt; is ignored.</source>
          <target state="translated">В качестве другого обходного пути для этой проблемы Perl 5.10.0 представил &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; и &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , которые эквивалентны &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; и &lt;code&gt;$'&lt;/code&gt; , &lt;b&gt;за исключением того,&lt;/b&gt; что они только гарантируют быть определенным после успешного совпадения, которое было выполнено с модификатором &lt;code&gt;/p&lt;/code&gt; (сохранение). Использование этих переменных не влечет за собой глобального снижения производительности, в отличие от их эквивалентов знаков препинания, однако с компромиссом, заключающимся в том, что вы должны указать Perl, когда вы хотите их использовать. Начиная с Perl 5.20, эти три переменные эквивалентны &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; и &lt;code&gt;$'&lt;/code&gt; и &lt;code&gt;/p&lt;/code&gt; игнорируется.</target>
        </trans-unit>
        <trans-unit id="faf1880e6e4e5e1670571e23b070295ae744c1fc" translate="yes" xml:space="preserve">
          <source>As described &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;above&lt;/a&gt;, Perl may call methods for operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in the course of implementing missing operations like &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; , and &lt;code&gt;&amp;amp;=&lt;/code&gt; . While these methods may detect this usage by testing the definedness of the third argument, they should in all cases avoid changing their operands. This is because Perl does not call the copy constructor before invoking these methods.</source>
          <target state="translated">Как описано &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;выше&lt;/a&gt; , Perl может вызывать методы для таких операторов, как &lt;code&gt;+&lt;/code&gt; и &lt;code&gt;&amp;amp;&lt;/code&gt; , в ходе реализации отсутствующих операций, таких как &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; и &lt;code&gt;&amp;amp;=&lt;/code&gt; . Хотя эти методы могут обнаруживать такое использование, проверяя определенность третьего аргумента, они во всех случаях должны избегать изменения своих операндов. Это потому, что Perl не вызывает конструктор копирования перед вызовом этих методов.</target>
        </trans-unit>
        <trans-unit id="6ff132deadaac51720c9e117548f044618ad0a39" translate="yes" xml:space="preserve">
          <source>As discussed elsewhere, Perl has one foot (two hooves?) planted in each of two worlds: the old world of ASCII and single-byte locales, and the new world of Unicode, upgrading when necessary. If your legacy code does not explicitly use Unicode, no automatic switch-over to Unicode should happen.</source>
          <target state="translated">Как уже говорилось,у Perl есть одна нога (два копыта?),посаженная в каждом из двух миров:старый мир ASCII и однобайтовые локали,и новый мир Unicode,модернизирующийся по мере необходимости.Если ваш старый код не использует Юникод в явном виде,автоматического перехода на Юникод не должно произойти.</target>
        </trans-unit>
        <trans-unit id="3a28f6e945d7b1d8cd9440551fcd17f03dc59837" translate="yes" xml:space="preserve">
          <source>As explained above, an anonymous function with access to the lexical variables visible when that function was compiled, creates a closure. It retains access to those variables even though it doesn't get run until later, such as in a signal handler or a Tk callback.</source>
          <target state="translated">Как объяснялось выше,анонимная функция с доступом к лексическим переменным,видимым при компиляции этой функции,создает закрытие.Она сохраняет доступ к этим переменным,несмотря на то,что запускается только позже,например,в обработчике сигнала или обратном вызове Tk.</target>
        </trans-unit>
        <trans-unit id="de6278f8e877d258b1f62760a70228a073ba24fd" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules&lt;/a&gt;, under ASCII rules, they are considered to be unassigned characters.</source>
          <target state="translated">Как объясняется в разделе &amp;laquo; &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;Правила ASCII по сравнению с правилами Юникода&amp;raquo;&lt;/a&gt; , в соответствии с правилами ASCII они считаются неназначенными символами.</target>
        </trans-unit>
        <trans-unit id="8ffaa22d40c8f644f2c59a68a07b28bdf08a1f8a" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist()&lt;/a&gt;, whether a code point is in the list or not depends on if the index is even (in) or odd (not in). And as explained in &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap()&lt;/a&gt;, the index is used with the returned parallel array to find the mapping.</source>
          <target state="translated">Как объяснено в &lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist ()&lt;/a&gt; , то, находится ли кодовая точка в списке или нет, зависит от того, является ли индекс четным (в) или нечетным (нет). И как объясняется в &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap ()&lt;/a&gt; , индекс используется с возвращенным параллельным массивом для поиска сопоставления.</target>
        </trans-unit>
        <trans-unit id="c53e475afb32fdd8296f1c9a917ef2e75b376078" translate="yes" xml:space="preserve">
          <source>As for other operations, the subroutine implementing '=' is passed three arguments, though the last two are always &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;''&lt;/code&gt; .</source>
          <target state="translated">Что касается других операций, подпрограмме, реализующей '=', передаются три аргумента, хотя последние два всегда &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;''&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f54bd3297d1b4b8911e3de6ffd9e1ee35795e3c" translate="yes" xml:space="preserve">
          <source>As if all those classes weren't enough, Perl also defines POSIX-style character classes. These have the form &lt;code&gt;[:name:]&lt;/code&gt;, with &lt;code&gt;name&lt;/code&gt; the name of the POSIX class. The POSIX classes are &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , and &lt;code&gt;xdigit&lt;/code&gt; , and two extensions, &lt;code&gt;word&lt;/code&gt; (a Perl extension to match &lt;code&gt;\w&lt;/code&gt; ), and &lt;code&gt;blank&lt;/code&gt; (a GNU extension). The &lt;code&gt;//a&lt;/code&gt; modifier restricts these to matching just in the ASCII range; otherwise they can match the same as their corresponding Perl Unicode classes: &lt;code&gt;[:upper:]&lt;/code&gt; is the same as &lt;code&gt;\p{IsUpper}&lt;/code&gt; , etc. (There are some exceptions and gotchas with this; see &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; for a full discussion.) The &lt;code&gt;[:digit:]&lt;/code&gt;, &lt;code&gt;[:word:]&lt;/code&gt;, and &lt;code&gt;[:space:]&lt;/code&gt; correspond to the familiar &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , and &lt;code&gt;\s&lt;/code&gt; character classes. To negate a POSIX class, put a &lt;code&gt;^&lt;/code&gt; in front of the name, so that, e.g., &lt;code&gt;[:^digit:]&lt;/code&gt; corresponds to &lt;code&gt;\D&lt;/code&gt; and, under Unicode, &lt;code&gt;\P{IsDigit}&lt;/code&gt; . The Unicode and POSIX character classes can be used just like &lt;code&gt;\d&lt;/code&gt; , with the exception that POSIX character classes can only be used inside of a character class:</source>
          <target state="translated">Как будто всех этих классов было недостаточно, Perl также определяет классы символов в стиле POSIX. Они имеют форму &lt;code&gt;[:name:]&lt;/code&gt; , с &lt;code&gt;name&lt;/code&gt; имя класса POSIX. Классы POSIX - это &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; и &lt;code&gt;xdigit&lt;/code&gt; , а также два расширения, &lt;code&gt;word&lt;/code&gt; (расширение Perl для соответствия &lt;code&gt;\w&lt;/code&gt; ) и &lt;code&gt;blank&lt;/code&gt; (расширение GNU ). &lt;code&gt;//a&lt;/code&gt; модификатор ограничивает их совпадением только в диапазоне ASCII; в противном случае они могут совпадать с соответствующими классами Perl Unicode: &lt;code&gt;[:upper:]&lt;/code&gt; совпадает с &lt;code&gt;\p{IsUpper}&lt;/code&gt; и т. д. (Здесь есть некоторые исключения и подводные камни; см. &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; для полного обсуждения.) &lt;code&gt;[:digit:]&lt;/code&gt; , &lt;code&gt;[:word:]&lt;/code&gt; и &lt;code&gt;[:space:]&lt;/code&gt; соответствуют знакомым классам символов &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; и &lt;code&gt;\s&lt;/code&gt; . Чтобы отменить класс POSIX, поместите &lt;code&gt;^&lt;/code&gt; перед именем, чтобы, например, &lt;code&gt;[:^digit:]&lt;/code&gt; соответствовал &lt;code&gt;\D&lt;/code&gt; а в Unicode - &lt;code&gt;\P{IsDigit}&lt;/code&gt; . Классы символов Unicode и POSIX могут использоваться так же, как &lt;code&gt;\d&lt;/code&gt; , за исключением того, что классы символов POSIX могут использоваться только внутри класса символов:</target>
        </trans-unit>
        <trans-unit id="460ff6781c9a7b0d42e2f096c304dc01b5296e55" translate="yes" xml:space="preserve">
          <source>As implied above, the environment accessed through &lt;code&gt;%ENV&lt;/code&gt; is global, and the convention is that program specific environment variables are of the form &lt;code&gt;Program$Name&lt;/code&gt; . Each filesystem maintains a current directory, and the current filesystem's current directory is the &lt;b&gt;global&lt;/b&gt; current directory. Consequently, sociable programs don't change the current directory but rely on full pathnames, and programs (and Makefiles) cannot assume that they can spawn a child process which can change the current directory without affecting its parent (and everyone else for that matter).</source>
          <target state="translated">Как подразумевается выше, среда, доступ к которой осуществляется через &lt;code&gt;%ENV&lt;/code&gt; является глобальной, и существует соглашение, что переменные среды, специфичные для программы, имеют форму &lt;code&gt;Program$Name&lt;/code&gt; . Каждая файловая система поддерживает текущий каталог, а текущий каталог текущей файловой системы является &lt;b&gt;глобальным&lt;/b&gt; текущим каталогом. Следовательно, общительные программы не изменяют текущий каталог, а полагаются на полные пути, а программы (и Makefiles) не могут предполагать, что они могут порождать дочерний процесс, который может изменять текущий каталог, не затрагивая его родительский (и всех остальных в этом отношении) .</target>
        </trans-unit>
        <trans-unit id="9cfe8ec9bce67c19def3a159ea6c0eb1d6dbe31c" translate="yes" xml:space="preserve">
          <source>As in some shells, you can enclose the variable name in braces to disambiguate it from following alphanumerics (and underscores). You must also do this when interpolating a variable into a string to separate the variable name from a following double-colon or an apostrophe, since these would be otherwise treated as a package separator:</source>
          <target state="translated">Как и в некоторых оболочках,имя переменной можно заключить в фигурные скобки,чтобы отличить ее от следующих буквенно-цифровых (и подчеркивающих).Вы также должны сделать это при интерполяции переменной в строку,чтобы отделить имя переменной от следующего двойного столбца или апострофа,так как в противном случае они будут рассматриваться как разделитель пакетов:</target>
        </trans-unit>
        <trans-unit id="f260d12b5b1b7a497f5733dde8f966ff0dea7a60" translate="yes" xml:space="preserve">
          <source>As it stands it predates version.pm but has the same goal: make version strings visible and comparable.</source>
          <target state="translated">Как он есть,он предшествует версии version.pm,но имеет ту же цель:сделать строки версий видимыми и сопоставимыми.</target>
        </trans-unit>
        <trans-unit id="e22bdaf7af0b55a0257fbf249cc6b2acfdfc9220" translate="yes" xml:space="preserve">
          <source>As its name suggests, if your code tripped a mandatory warning, you would get a warning whether you wanted it or not. For example, the code below would always produce an &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; warning about the &quot;2:&quot;.</source>
          <target state="translated">Как следует из названия, если ваш код выдал обязательное предупреждение, вы получите предупреждение, хотите вы этого или нет. Например, приведенный ниже код всегда будет выдавать предупреждение &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; относительно &amp;laquo;2:&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="299f8da88c7d33c41fa9b9da7b25493959ed6b3c" translate="yes" xml:space="preserve">
          <source>As just mentioned, all variables are, by default, thread local. To use shared variables, you need to also load &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;:</source>
          <target state="translated">Как уже упоминалось, все переменные по умолчанию являются локальными для потока. Чтобы использовать общие переменные, вам также необходимо загрузить &lt;a href=&quot;threads/shared&quot;&gt;потоки :: shared&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1b2545d2ff62a227583262bedb22954e6e8e3fc3" translate="yes" xml:space="preserve">
          <source>As locks are advisory, they do not prevent data access or modification by another thread that does not itself attempt to obtain a lock on the variable.</source>
          <target state="translated">Поскольку блокировки являются рекомендательными,они не препятствуют доступу к данным или их модификации другим потоком,который сам по себе не пытается получить блокировку переменной.</target>
        </trans-unit>
        <trans-unit id="81ff74ffe73c98f024294d6b4b3ccdb104adb917" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2man&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2man&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2man&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">Пока все обработанные документы приводят к некоторому выводу, даже если этот вывод содержит ошибки ( раздел &lt;code&gt;POD ERRORS&lt;/code&gt; &lt;code&gt;--errors=pod&lt;/code&gt; созданный с помощью --errors = pod ), &lt;b&gt;pod2man&lt;/b&gt; выйдет со статусом 0. Если какой-либо из обрабатываемых документов не приведет к &lt;b&gt;ошибке&lt;/b&gt; выходной документ, &lt;b&gt;pod2man&lt;/b&gt; завершит работу со статусом 1. Если в обрабатываемом документе POD есть синтаксические ошибки и для стиля обработки ошибок установлено значение по умолчанию &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , &lt;b&gt;pod2man&lt;/b&gt; немедленно &lt;b&gt;прервется&lt;/b&gt; со статусом выхода 255.</target>
        </trans-unit>
        <trans-unit id="00a3a680bcee6a61521d2a5ef5058ff99a76856b" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2text&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2text&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2text&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">Пока все обработанные документы приводят к некоторому выводу, даже если этот вывод содержит ошибки ( раздел &lt;code&gt;POD ERRORS&lt;/code&gt; &lt;code&gt;--errors=pod&lt;/code&gt; созданный с помощью --errors = pod ), &lt;b&gt;pod2text&lt;/b&gt; завершит работу со статусом 0. Если какой-либо из обрабатываемых документов не приведет к &lt;b&gt;ошибке&lt;/b&gt; выходной документ, &lt;b&gt;pod2text&lt;/b&gt; выйдет со статусом 1. Если есть синтаксические ошибки в обрабатываемом документе POD и стиль обработки ошибок установлен на &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; по умолчанию , &lt;b&gt;pod2text&lt;/b&gt; немедленно &lt;b&gt;прервется&lt;/b&gt; со статусом выхода 255.</target>
        </trans-unit>
        <trans-unit id="95c1aea5304f4de3806c6769617146a8ffc159e5" translate="yes" xml:space="preserve">
          <source>As long as the reference is never returned by any function within the module, no outside module can see the subroutine, because its name is not in any package's symbol table. Remember that it's not</source>
          <target state="translated">До тех пор,пока ссылка не будет возвращена ни одной из функций внутри модуля,ни один внешний модуль не сможет увидеть подпрограмму,так как его имени нет ни в одной из таблиц символов пакета.Помните,что это не</target>
        </trans-unit>
        <trans-unit id="958bb5f65d2f4962aaa4f5dd2b31857927db841a" translate="yes" xml:space="preserve">
          <source>As mentioned &lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;above&lt;/a&gt;, this operation is called when a mutator is applied to a reference that shares its object with some other reference. For example, if &lt;code&gt;$b&lt;/code&gt; is mathemagical, and &lt;code&gt;'++'&lt;/code&gt; is overloaded with &lt;code&gt;'incr'&lt;/code&gt; , and &lt;code&gt;'='&lt;/code&gt; is overloaded with &lt;code&gt;'clone'&lt;/code&gt; , then the code</source>
          <target state="translated">Как упоминалось &lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;выше&lt;/a&gt; , эта операция вызывается, когда мутатор применяется к ссылке, которая разделяет свой объект с какой-либо другой ссылкой. Например, если &lt;code&gt;$b&lt;/code&gt; является математическим, а &lt;code&gt;'++'&lt;/code&gt; перегружено &lt;code&gt;'incr'&lt;/code&gt; , а &lt;code&gt;'='&lt;/code&gt; перегружено &lt;code&gt;'clone'&lt;/code&gt; , тогда код</target>
        </trans-unit>
        <trans-unit id="6db309618dd0587d20027a36c5759130977518d4" translate="yes" xml:space="preserve">
          <source>As mentioned above under &lt;a href=&quot;#ALIASES&quot;&gt;ALIASES&lt;/a&gt;, Unicode 6.1 defines extra names (synonyms or aliases) for some code points, most of which were already available as Perl extensions. All these are accepted by &lt;code&gt;\N{...}&lt;/code&gt; and the other functions in this module, but &lt;code&gt;viacode&lt;/code&gt; has to choose which one name to return for a given input code point, so it returns the &quot;best&quot; name. To understand how this works, it is helpful to know more about the Unicode name properties. All code points actually have only a single name, which (starting in Unicode 2.0) can never change once a character has been assigned to the code point. But mistakes have been made in assigning names, for example sometimes a clerical error was made during the publishing of the Standard which caused words to be misspelled, and there was no way to correct those. The Name_Alias property was eventually created to handle these situations. If a name was wrong, a corrected synonym would be published for it, using Name_Alias. &lt;code&gt;viacode&lt;/code&gt; will return that corrected synonym as the &quot;best&quot; name for a code point. (It is even possible, though it hasn't happened yet, that the correction itself will need to be corrected, and so another Name_Alias can be created for that code point; &lt;code&gt;viacode&lt;/code&gt; will return the most recent correction.)</source>
          <target state="translated">Как упоминалось выше в разделе &lt;a href=&quot;#ALIASES&quot;&gt;АЛИАСЫ&lt;/a&gt; , Unicode 6.1 определяет дополнительные имена (синонимы или псевдонимы) для некоторых кодовых точек, большинство из которых уже были доступны как расширения Perl. Все это принимается &lt;code&gt;\N{...}&lt;/code&gt; и другими функциями в этом модуле, но через &lt;code&gt;viacode&lt;/code&gt; должен выбрать, какое имя возвращать для данной точки кода ввода, поэтому оно возвращает &amp;laquo;лучшее&amp;raquo; имя. Чтобы понять, как это работает, полезно узнать больше о свойствах имени Unicode. Все кодовые точки фактически имеют только одно имя, которое (начиная с Unicode 2.0) никогда не может измениться после того, как символ был назначен кодовой точке. Но были допущены ошибки при присвоении имен, например, иногда во время публикации Стандарта делалась техническая ошибка, из-за которой слова были написаны с ошибками, и не было возможности исправить их. Свойство Name_Alias ​​было в конечном итоге создано для обработки таких ситуаций. Если имя было неправильным, для него будет опубликован исправленный синоним с использованием Name_Alias. &lt;code&gt;viacode&lt;/code&gt; вернет этот исправленный синоним как &amp;laquo;лучшее&amp;raquo; имя для кодовой точки. (Возможно даже, хотя этого еще не произошло, что сама поправка должна быть исправлена, и поэтому для этой кодовой точки может быть создан другой Name_Alias; &lt;code&gt;viacode&lt;/code&gt; вернет самое последнее исправление.)</target>
        </trans-unit>
        <trans-unit id="aa5ef151af9bb6073935edbcfff85b0147b33678" translate="yes" xml:space="preserve">
          <source>As mentioned above, UTF-8 uses a variable number of bytes to store a character. Characters with values 0...127 are stored in one byte, just like good ol' ASCII. Character 128 is stored as &lt;code&gt;v194.128&lt;/code&gt; ; this continues up to character 191, which is &lt;code&gt;v194.191&lt;/code&gt; . Now we've run out of bits (191 is binary &lt;code&gt;10111111&lt;/code&gt; ) so we move on; character 192 is &lt;code&gt;v195.128&lt;/code&gt; . And so it goes on, moving to three bytes at character 2048. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;Unicode Encodings in perlunicode&lt;/a&gt; has pictures of how this works.</source>
          <target state="translated">Как упоминалось выше, UTF-8 использует переменное количество байтов для хранения символа. Символы со значениями 0 ... 127 хранятся в одном байте, как и старый добрый ASCII. 128-й символ сохраняется как &lt;code&gt;v194.128&lt;/code&gt; ; это продолжается до символа 191, то есть &lt;code&gt;v194.191&lt;/code&gt; . Теперь у нас закончились биты (191 - это двоичное &lt;code&gt;10111111&lt;/code&gt; ), поэтому мы идем дальше; символ 192 - &lt;code&gt;v195.128&lt;/code&gt; . И так далее, перейдя к трем байтам &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;в символе&lt;/a&gt; 2048. Unicode Encodings в perlunicode показывает , как это работает.</target>
        </trans-unit>
        <trans-unit id="b80f86706a5e778489f2084a741a86389a8e67cd" translate="yes" xml:space="preserve">
          <source>As mentioned above, you can determine the context of the currently executing subroutine in Perl with</source>
          <target state="translated">Как упоминалось выше,вы можете определить контекст выполняемой в настоящее время подпрограммы на Perl с помощью параметра</target>
        </trans-unit>
        <trans-unit id="00501a67a82ec0513abc29055abfbad02a55f669" translate="yes" xml:space="preserve">
          <source>As mentioned at the top of this document, if you are having problems with these example extensions, you might see if any of these help you.</source>
          <target state="translated">Как упоминалось в верхней части этого документа,если у вас возникли проблемы с этими примерами расширений,вы можете увидеть,не поможет ли вам что-нибудь из этих расширений.</target>
        </trans-unit>
        <trans-unit id="2746f2e141da00d82feca97a110b834cca59fd6d" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, Perl can store a number in any one of three formats, but most operators typically understand only one of those formats. When a numeric value is passed as an argument to such an operator, it will be converted to the format understood by the operator.</source>
          <target state="translated">Как упоминалось ранее,Perl может хранить число в любом из трех форматов,но большинство операторов обычно понимают только один из этих форматов.Когда числовое значение передаётся в качестве аргумента такому оператору,оно преобразуется в формат,понятный оператору.</target>
        </trans-unit>
        <trans-unit id="77154bb24a38474664192f3ea13c3d83da99f57f" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, a &quot;callback&quot; key may be added to the &lt;code&gt;TAP::Parser&lt;/code&gt; constructor. If present, each callback corresponding to a given result type will be called with the result as the argument if the &lt;code&gt;run&lt;/code&gt; method is used. The callback is expected to be a subroutine reference (or anonymous subroutine) which is invoked with the parser result as its argument.</source>
          <target state="translated">Как упоминалось ранее, в конструктор &lt;code&gt;TAP::Parser&lt;/code&gt; может быть добавлен &amp;laquo;обратный вызов&amp;raquo; . Если присутствует, каждый обратный вызов, соответствующий данному типу результата, будет вызываться с результатом в качестве аргумента, если &lt;code&gt;run&lt;/code&gt; метод run . Ожидается, что обратный вызов будет ссылкой на подпрограмму (или анонимной подпрограммой), которая вызывается с результатом синтаксического анализа в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="4ebe40c302b03d332e451ead97b5b34c4f2894b9" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, in the case of the default engines, the &lt;code&gt;pprivate&lt;/code&gt; will be a pointer to a regexp_internal structure which holds the compiled program and any additional data that is private to the regex engine implementation.</source>
          <target state="translated">Как упоминалось ранее, в случае механизмов по умолчанию &lt;code&gt;pprivate&lt;/code&gt; будет указателем на структуру regexp_internal, которая содержит скомпилированную программу и любые дополнительные данные, которые являются частными для реализации механизма регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="05bef95fb25bb75da2eac006c647172d0c563725" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;, encodings are (in the current implementation at least) defined as objects. The mapping of encoding name to object is via the &lt;code&gt;%Encode::Encoding&lt;/code&gt; hash. Though you can directly manipulate this hash, it is strongly encouraged to use this base class module and add encode() and decode() methods.</source>
          <target state="translated">Как упоминалось в &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt; , кодировки (по крайней мере, в текущей реализации) определены как объекты. Сопоставление имени кодировки с объектом осуществляется с помощью хэша &lt;code&gt;%Encode::Encoding&lt;/code&gt; . Хотя вы можете напрямую управлять этим хешем, настоятельно рекомендуется использовать этот модуль базового класса и добавлять методы encode () и decode ().</target>
        </trans-unit>
        <trans-unit id="83fbfdaddc2272e65e0714e5d0f69ab35b42f974" translate="yes" xml:space="preserve">
          <source>As mentioned in the previous item, this still doesn't work when using socket I/O between Unix and Macintosh. You'll need to hard code your line terminators, in that case.</source>
          <target state="translated">Как упоминалось в предыдущем пункте,это до сих пор не работает при использовании сокетного ввода/вывода между Unix и Macintosh.В таком случае,вам нужно будет жестко закодировать свои терминаторы строки.</target>
        </trans-unit>
        <trans-unit id="ed52abb82f45ac71a451aad1bb7530a654fe2ad3" translate="yes" xml:space="preserve">
          <source>As mentioned previously, dynamic loading isn't currently available nor is MakeMaker. Both are high-priority items.</source>
          <target state="translated">Как упоминалось ранее,в настоящее время динамическая загрузка недоступна и отсутствует MakeMaker.Оба элемента являются высокоприоритетными.</target>
        </trans-unit>
        <trans-unit id="9fbc47f4ab04b1b192086c459c88acf77887350f" translate="yes" xml:space="preserve">
          <source>As mentioned, the function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no name is known for the code point. In Unicode the proper name for these is the empty string, which &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; stringifies to. (If you ask for a code point past the legal Unicode maximum of U+10FFFF that you haven't assigned an alias to, you get &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; plus a warning.)</source>
          <target state="translated">Как упоминалось, функция возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если имя кодовой точки неизвестно. В Юникоде их собственное имя - пустая строка, в которую &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . (Если вы запросите кодовую точку за допустимым максимумом Unicode U + 10FFFF, которому вы не назначили псевдоним, вы получите &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; плюс предупреждение.)</target>
        </trans-unit>
        <trans-unit id="651eca43c6e2d73bc740fcae1016d17e36d82316" translate="yes" xml:space="preserve">
          <source>As most of the remaining expected output to the error stream will be created by &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;'s &lt;code&gt;diag&lt;/code&gt; function, &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; provides a convenience function &lt;code&gt;test_diag&lt;/code&gt; that you can use instead of &lt;code&gt;test_err&lt;/code&gt; .</source>
          <target state="translated">Поскольку большая часть оставшегося ожидаемого выхода на поток ошибок будет создан &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; &amp;laquo;s &lt;code&gt;diag&lt;/code&gt; функции &lt;a href=&quot;tester&quot;&gt;Test :: Builder :: Тестер&lt;/a&gt; обеспечивает функцию удобства &lt;code&gt;test_diag&lt;/code&gt; , которые вы можете использовать вместо &lt;code&gt;test_err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3938aef953ff6d9fa864efd013ef275f9aaeca4" translate="yes" xml:space="preserve">
          <source>As noted above, if the file does not already exist, then the append-mode open will create it for you. But if the file does already exist, its contents are safe from harm because you will be adding your new text past the end of the old text.</source>
          <target state="translated">Как было отмечено выше,если файл еще не существует,то открытый режим append-mode создаст его для вас.Но если файл уже существует,его содержимое не причинит вреда,так как вы будете добавлять новый текст после окончания старого.</target>
        </trans-unit>
        <trans-unit id="aa50c7a75f631655fc7d60c7b218e502c8aba3fb" translate="yes" xml:space="preserve">
          <source>As noted earlier in this document, the scalar sense of list assignment is the number of elements on the right-hand side of the assignment. The null list contains no elements, so when the password file is exhausted, the result is 0, not 2.</source>
          <target state="translated">Как отмечалось ранее в этом документе,скалярное значение задания списка-это количество элементов справа от задания.Нулевой список не содержит элементов,поэтому,когда файл паролей исчерпан,результат равен 0,а не 2.</target>
        </trans-unit>
        <trans-unit id="c32dd8a34a2658e1d2e1869aeb4cec0307b6493f" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES&lt;/a&gt;, &lt;code&gt;cmp&lt;/code&gt; compares according to the current collation locale when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, but falls back to a char-by-char comparison for strings that the locale says are equal. You can use &lt;code&gt;POSIX::strcoll()&lt;/code&gt; if you don't want this fall-back:</source>
          <target state="translated">Как отмечено в &lt;a href=&quot;#USING-LOCALES&quot;&gt;ИСПОЛЬЗОВАНИИ ЛОКАЛОВ&lt;/a&gt; , &lt;code&gt;cmp&lt;/code&gt; сравнивает в соответствии с текущим языковым стандартом сопоставления, когда &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , но возвращается к сравнению символов по символам для строк, которые, согласно языку, равны. Вы можете использовать &lt;code&gt;POSIX::strcoll()&lt;/code&gt; если вам не нужен этот откат:</target>
        </trans-unit>
        <trans-unit id="eda06429df1073940e96ea523060e042021aeec8" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;perlhack#TESTING&quot;&gt;TESTING in perlhack&lt;/a&gt;, when writing test scripts, the file</source>
          <target state="translated">Как отмечалось в &lt;a href=&quot;perlhack#TESTING&quot;&gt;разделе ТЕСТИРОВАНИЕ в perlhack&lt;/a&gt; , при написании тестовых скриптов файл</target>
        </trans-unit>
        <trans-unit id="716cc3d3aff35fc6629ccc256677b64774af14df" translate="yes" xml:space="preserve">
          <source>As of 1.37_02 install() supports the use of a list of patterns to filter out files that shouldn't be installed. If $skip is omitted or undefined then install will try to read the list from INSTALL.SKIP in the CWD. This file is a list of regular expressions and is just like the MANIFEST.SKIP file used by &lt;a href=&quot;manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt;.</source>
          <target state="translated">Начиная с версии 1.37_02 install () поддерживает использование списка шаблонов для фильтрации файлов, которые не следует устанавливать. Если $ skip опущен или не определен, то программа установки попытается прочитать список из INSTALL.SKIP в CWD. Этот файл представляет собой список регулярных выражений и похож на файл MANIFEST.SKIP, используемый &lt;a href=&quot;manifest&quot;&gt;ExtUtils :: Manifest&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f828a6d861469c7d75db52b836c69689c1760b7" translate="yes" xml:space="preserve">
          <source>As of 3.10, the internal data for all types of codes can be modified.</source>
          <target state="translated">Начиная с 3.10,внутренние данные для всех типов кодов могут быть изменены.</target>
        </trans-unit>
        <trans-unit id="1d399ef50aa4f86fbc538d8e5d435b672ada57b9" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">Начиная с версии 5.14, ни один из них не вызывает исключения, если они не поддерживаются на вашей платформе. Однако, если предупреждения включены, предупреждение класса предупреждений &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; выдается при неподдерживаемом флаге преобразования. Если вы предпочитаете исключение, сделайте следующее:</target>
        </trans-unit>
        <trans-unit id="fd9213ca43980debccb984d13f9caaa2e79748be" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">Начиная с версии 5.14, ни один из них не вызывает исключения, если они не поддерживаются на вашей платформе. Однако, если предупреждения включены, предупреждение класса предупреждений &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; выдается при неподдерживаемом флаге преобразования. Если вы предпочитаете исключение, сделайте следующее:</target>
        </trans-unit>
        <trans-unit id="6791199e3f80fe4bbb43c0eaff9608d527ada74b" translate="yes" xml:space="preserve">
          <source>As of 5.14, that can also be written this way:</source>
          <target state="translated">Начиная с 5.14,это также может быть написано таким образом:</target>
        </trans-unit>
        <trans-unit id="b37d45aa3fafa285df8c8611054589c583244ea5" translate="yes" xml:space="preserve">
          <source>As of 5.19.9 setting &lt;code&gt;$/&lt;/code&gt; to any other form of reference will throw a fatal exception. This is in preparation for supporting new ways to set &lt;code&gt;$/&lt;/code&gt; in the future.</source>
          <target state="translated">Начиная с 5.19.9 установка &lt;code&gt;$/&lt;/code&gt; для любой другой формы ссылки вызовет фатальное исключение. Это подготовка к поддержке новых способов установки &lt;code&gt;$/&lt;/code&gt; в будущем.</target>
        </trans-unit>
        <trans-unit id="5090edb4c78c4b281b3a889d093a1c4d0aac43d2" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, long doubles are working if you use the Sun compilers (needed for additional math routines not included in libm).</source>
          <target state="translated">Начиная с версии 5.8.1,длинные двойники работают,если вы используете компиляторы Sun (необходимые для дополнительных математических процедур,не включенных в libm).</target>
        </trans-unit>
        <trans-unit id="f508ee41697726e1567be3f0dd308006b0a11bbd" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, the &lt;b&gt;-C&lt;/b&gt; can be followed either by a number or a list of option letters. The letters, their numeric values, and effects are as follows; listing the letters is equal to summing the numbers.</source>
          <target state="translated">Начиная с версии 5.8.1, за &lt;b&gt;-C&lt;/b&gt; может следовать номер или список букв опций. Буквы, их числовые значения и эффекты следующие: перечисление букв равносильно суммированию чисел.</target>
        </trans-unit>
        <trans-unit id="45cfda1b1b7f6423e5dd7ec6647effcbf0d30173" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as are the other directives. However they have both compile-time and run-time effects.</source>
          <target state="translated">Начиная с 5.9.5, директива &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; и ее эквиваленты имеют лексическую область видимости, как и другие директивы. Однако они имеют эффекты как во время компиляции, так и во время выполнения.</target>
        </trans-unit>
        <trans-unit id="d51f5d10f6eede269e073b2d28e8411b4b049f81" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as the other directives are. However they have both compile-time and run-time effects.</source>
          <target state="translated">Начиная с 5.9.5, директива &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; и ее эквиваленты имеют лексическую область видимости, как и другие директивы. Однако они имеют эффекты как во время компиляции, так и во время выполнения.</target>
        </trans-unit>
        <trans-unit id="8b5a3958e4abf52ef71b991a4f025f997262e7e8" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; 2.12, &lt;code&gt;CHECK&lt;/code&gt; can also be a code reference which takes the ordinal value of the unmapped character as an argument and returns octets that represent the fallback character. For instance:</source>
          <target state="translated">Начиная с &lt;code&gt;Encode&lt;/code&gt; 2.12, &lt;code&gt;CHECK&lt;/code&gt; также может быть ссылкой на код, которая принимает порядковое значение неотображенного символа в качестве аргумента и возвращает октеты, представляющие резервный символ. Например:</target>
        </trans-unit>
        <trans-unit id="b411b3efc2bae2399e243c4103628c18af471dad" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; version 2.21, a new method &lt;code&gt;mime_name()&lt;/code&gt; is therefore added.</source>
          <target state="translated">Начиная с версии &lt;code&gt;Encode&lt;/code&gt; 2.21, поэтому добавлен новый метод &lt;code&gt;mime_name()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="703e152d6b7fb820f5c3dbc21f352bf9bc7a9e95" translate="yes" xml:space="preserve">
          <source>As of CPAN 1.9463, if you do not have permission to write the default perl library directories, CPAN's configuration process will ask you whether you want to bootstrap &amp;lt;local::lib&amp;gt;, which makes keeping a personal perl library directory easy.</source>
          <target state="translated">Начиная с CPAN 1.9463, если у вас нет разрешения на запись в каталоги библиотеки Perl по умолчанию, процесс настройки CPAN спросит вас, хотите ли вы загрузить &amp;lt;local :: lib&amp;gt;, что упрощает сохранение каталога личной библиотеки Perl.</target>
        </trans-unit>
        <trans-unit id="07aaeb2f2c75fecbde3c90f6c2e907a83c502842" translate="yes" xml:space="preserve">
          <source>As of Encode 1.87, the older form</source>
          <target state="translated">Начиная с кодировки 1.87,старая форма</target>
        </trans-unit>
        <trans-unit id="b09ae12c2db054fb655cbb26f548a82db4c390c0" translate="yes" xml:space="preserve">
          <source>As of July 2002 (the Perl release 5.8.0), the following platforms were able to build Perl from the standard source code distribution available at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;</source>
          <target state="translated">По состоянию на июль 2002 года (выпуск Perl 5.8.0) следующие платформы могли собирать Perl из стандартного дистрибутива исходного кода, доступного на &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fcab0673d5c88e7554da234165f977684b228be3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, the &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables may be used. These are only set if the &lt;code&gt;/p&lt;/code&gt; modifier is present. Consequently they do not penalize the rest of the program. In Perl 5.20, &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; are available whether the &lt;code&gt;/p&lt;/code&gt; has been used or not (the modifier is ignored), and &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; and &lt;code&gt;$&amp;amp;&lt;/code&gt; do not cause any speed difference.</source>
          <target state="translated">Начиная с Perl 5.10, можно использовать переменные &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; и &lt;code&gt;${^POSTMATCH}&lt;/code&gt; . Они устанавливаются, только если присутствует модификатор &lt;code&gt;/p&lt;/code&gt; . Следовательно, они не наказывают остальную часть программы. В Perl 5.20 &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; и &lt;code&gt;${^POSTMATCH}&lt;/code&gt; доступны вне зависимости от того, использовался ли &lt;code&gt;/p&lt;/code&gt; (модификатор игнорируется), а &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; и &lt;code&gt;$&amp;amp;&lt;/code&gt; нет вызвать разницу в скорости.</target>
        </trans-unit>
        <trans-unit id="eafa84154e8f8c3596803a7b5e3904a497adc460" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, this pragma is lexically scoped and takes effect at compile time. In earlier versions its effect was global and took effect at run-time; the documentation suggested using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; to change the behaviour:</source>
          <target state="translated">Начиная с Perl 5.10, эта прагма имеет лексическую область видимости и вступает в силу во время компиляции. В более ранних версиях его эффект был глобальным и действовал во время выполнения; в документации предлагается использовать &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; для изменения поведения:</target>
        </trans-unit>
        <trans-unit id="86d4d0145ccce27050aa6a59ab5275c8b3a0cdb0" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, you can match balanced text with regular expressions using recursive patterns. Before Perl 5.10, you had to resort to various tricks such as using Perl code in &lt;code&gt;(??{})&lt;/code&gt; sequences.</source>
          <target state="translated">Начиная с Perl 5.10, вы можете сопоставлять сбалансированный текст с регулярными выражениями, используя рекурсивные шаблоны. До Perl 5.10 вам приходилось прибегать к различным уловкам, таким как использование кода Perl в &lt;code&gt;(??{})&lt;/code&gt; последовательностях.</target>
        </trans-unit>
        <trans-unit id="eea5149372feb11e1db38e07d50576f276a6c743" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, Perl supports several Python/PCRE-specific extensions to the regex syntax. While Perl programmers are encouraged to use the Perl-specific syntax, the following are also accepted:</source>
          <target state="translated">Начиная с версии Perl 5.10.0,Perl поддерживает несколько специфических для Python/PCRE расширений синтаксиса регекса.Хотя Perl-программистам рекомендуется использовать специфический для Perl синтаксис,принимаются также и следующие:</target>
        </trans-unit>
        <trans-unit id="793e424fe5bef6967b0c0b6751f2a3b12bcf501f" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, as a form of purely syntactic sugar, you can stack file test operators, in a way that &lt;code&gt;-f -w -x $file&lt;/code&gt; is equivalent to &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; . (This is only fancy syntax: if you use the return value of &lt;code&gt;-f $file&lt;/code&gt; as an argument to another filetest operator, no special magic will happen.)</source>
          <target state="translated">Начиная с Perl 5.10.0, как форма чисто синтаксического сахара, вы можете складывать операторы проверки файлов таким образом, что &lt;code&gt;-f -w -x $file&lt;/code&gt; эквивалентно &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; . (Это всего лишь причудливый синтаксис: если вы используете возвращаемое значение &lt;code&gt;-f $file&lt;/code&gt; в качестве аргумента для другого оператора filetest, особого волшебства не произойдет.)</target>
        </trans-unit>
        <trans-unit id="4eb7e07d934fae953d19f8161458d55420e41446" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, one can create custom regular expression engines. This is not for the faint of heart, as they have to plug in at the C level. See &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; for more details.</source>
          <target state="translated">Начиная с Perl 5.10.0, можно создавать собственные механизмы регулярных выражений. Это не для слабонервных, так как они должны подключаться на уровне C. См. &lt;a href=&quot;perlreapi&quot;&gt;Perlreapi&lt;/a&gt; для получения более подробной информации.</target>
        </trans-unit>
        <trans-unit id="0c7a09399a8f27b12757a6f71f279fa17b42fdfd" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, you can also use the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers to force big- or little-endian byte-order. This is useful if you want to store signed integers or 64-bit integers, for example.</source>
          <target state="translated">Начиная с Perl 5.10.0, вы также можете использовать модификаторы &lt;code&gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;&lt;/code&gt; для принудительного порядка байтов с прямым или обратным порядком байтов. Это полезно, например, если вы хотите хранить целые числа со знаком или 64-битные целые числа.</target>
        </trans-unit>
        <trans-unit id="835734cf27f076a5a1e9340fb76782ceeb1a149b" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.1 there is a new interface for plugging and using method resolution orders other than the default (linear depth first search). The C3 method resolution order added in 5.10.0 has been re-implemented as a plugin, without changing its Perl-space interface.</source>
          <target state="translated">Начиная с версии Perl 5.10.1 появился новый интерфейс для подключения и использования ордеров на разрешение методов,отличных от стандартных (линейный поиск глубины сначала).Приказ на разрешение метода C3,добавленный в версии 5.10.0,был заново реализован в виде плагина,без изменения его интерфейса Perl-space.</target>
        </trans-unit>
        <trans-unit id="4ca2607d4b8da91c9aab14d61ac0b65b288bfff7" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">На Perl 5.12 вы можете использовать голую &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;while&lt;/code&gt; петля, которая будет устанавливать &lt;code&gt;$_&lt;/code&gt; на каждой итерации.</target>
        </trans-unit>
        <trans-unit id="7ef4b7baf6bbb1a8636644643a30ec84c9a4f514" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">На Perl 5.12 вы можете использовать голую &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;while&lt;/code&gt; петля, которая будет устанавливать &lt;code&gt;$_&lt;/code&gt; на каждой итерации.</target>
        </trans-unit>
        <trans-unit id="9aad368f35112b0ebb60af7e4b6035d03ee10832" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12, deprecated features and modules warn the user as they're used. When a module is deprecated, it will also be made available on CPAN. Installing it from CPAN will silence deprecation warnings for that module.</source>
          <target state="translated">Начиная с версии Perl 5.12,устаревшие функции и модули предупреждают пользователя об их использовании.Когда модуль устарел,он также будет доступен в CPAN.Установка его из CPAN заставит замолчать предупреждения об устаревшем модуле.</target>
        </trans-unit>
        <trans-unit id="7bc75da6cf8214f9a49a145ca7f1ff6dd1976a38" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 every hash has its own hash traversal order, and this order changes every time a new element is inserted into the hash. This functionality is provided by maintaining an unsigned integer mask (U32) which is xor'ed with the actual bucket id during a traversal of the hash buckets using keys(), values() or each().</source>
          <target state="translated">Начиная с версии Perl 5.18 каждый хэш имеет свой собственный порядок прохождения хэша,и этот порядок меняется каждый раз,когда в хэш вставляется новый элемент.Эта функциональность обеспечивается поддержанием беззнаковой целочисленной маски (U32),которая является xor'ed с фактическим идентификатором хэша во время обхода хэш-букетов с помощью keys(),values()или each().</target>
        </trans-unit>
        <trans-unit id="a8b875400d906734f1b4f9f29eb27503d8a35f16" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">На Perl 5.18 вы можете использовать обнажить &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;while&lt;/code&gt; петля, которая будет устанавливать &lt;code&gt;$_&lt;/code&gt; на каждой итерации.</target>
        </trans-unit>
        <trans-unit id="211e0f721f82a57a3e303b9bd4a37e7c878adb86" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">На Perl 5.18 вы можете использовать обнажить &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;while&lt;/code&gt; петля, которая будет устанавливать &lt;code&gt;$_&lt;/code&gt; на каждой итерации.</target>
        </trans-unit>
        <trans-unit id="c33c32e4c4b133822c39af8f8540bc2360a9b3e1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.20, instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; you can use:</source>
          <target state="translated">Начиная с Perl 5.20, вместо &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;используйте&lt;/a&gt; FATAL =&amp;gt; 'all'; ты можешь использовать:</target>
        </trans-unit>
        <trans-unit id="c35a63f8082ff3fbb7b2bded313d23f6fdc3cfd9" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, there is an experimental variant of this loop that accepts a variable preceded by a backslash for VAR, in which case the items in the LIST must be references. The backslashed variable will become an alias to each referenced item in the LIST, which must be of the correct type. The variable needn't be a scalar in this case, and the backslash may be followed by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. To use this form, you must enable the &lt;code&gt;refaliasing&lt;/code&gt; feature via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. See also &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">Начиная с Perl 5.22, существует экспериментальный вариант этого цикла, который принимает переменную, которой предшествует обратная косая черта для VAR, и в этом случае элементы в LIST должны быть ссылками. Переменная с обратной косой чертой станет псевдонимом для каждого элемента, на который имеется ссылка, в СПИСКЕ, который должен иметь правильный тип. В этом случае переменная не обязательно должна быть скаляром, а за обратной косой чертой может следовать &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; . Чтобы использовать эту форму, вы должны включить функцию &lt;code&gt;refaliasing&lt;/code&gt; помощью &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; . (См &lt;a href=&quot;feature&quot;&gt;функции&lt;/a&gt; См. Также &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Присвоение Ссылки в perlref&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="df42579e1cb5e3f110d0c1cf4c3bbc08eda67128" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, this buggy behavior, while preserved for backward compatibility, is detected and emits a deprecation warning. If you want the subroutine to be inlined (with no warning), make sure the variable is not used in a context where it could be modified aside from where it is declared.</source>
          <target state="translated">Начиная с версии Perl 5.22,эта ошибка,хотя и сохранена для обратной совместимости,обнаруживается и выдает предупреждение об утечке.Если вы хотите,чтобы подпрограмма была вложена (без предупреждения),убедитесь,что переменная не используется в контексте,в котором она может быть изменена,кроме того места,где она объявлена.</target>
        </trans-unit>
        <trans-unit id="b18e8f64ae6fd8a43ee4372bec94f73e67d74058" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, you can also use &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . (You can also do &lt;code&gt;($x) x 2&lt;/code&gt; , which is less useful, because it assigns to the same variable twice, clobbering the first value assigned.)</source>
          <target state="translated">Начиная с Perl 5.22, вы также можете использовать &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; вместо &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . (Вы также можете сделать &lt;code&gt;($x) x 2&lt;/code&gt; , что менее полезно, потому что оно дважды присваивает одну и ту же переменную, затирая первое назначенное значение.)</target>
        </trans-unit>
        <trans-unit id="6f3aa7e1697ed4bbe63edb4cde5bc634c7d4943e" translate="yes" xml:space="preserve">
          <source>As of Perl 5.6, you can represent filehandles with scalar variables which you treat as any other scalar.</source>
          <target state="translated">Начиная с версии Perl 5.6,вы можете представлять файловые хэндлы со скалярными переменными,которые вы рассматриваете как любой другой скаляр.</target>
        </trans-unit>
        <trans-unit id="90e7536680dcd18ada661ef157609a74a6cebee3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0 after using this module you cannot use the implicit &lt;code&gt;$_&lt;/code&gt; or the special filehandle &lt;code&gt;_&lt;/code&gt; with stat() or lstat(), trying to do so leads into strange errors. The workaround is for &lt;code&gt;$_&lt;/code&gt; to be explicit</source>
          <target state="translated">Начиная с Perl 5.8.0, после использования этого модуля вы не можете использовать неявный &lt;code&gt;$_&lt;/code&gt; или специальный дескриптор файла &lt;code&gt;_&lt;/code&gt; с stat () или lstat (), попытка сделать это приводит к странным ошибкам. Обходной путь - явное указание &lt;code&gt;$_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fd0a9a99a09c2a713ff60adbdf886450b68308c" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, the &quot;Full&quot; case-folding of</source>
          <target state="translated">Начиная с версии Perl 5.8.0,&quot;Полное&quot; складывание дела из</target>
        </trans-unit>
        <trans-unit id="444326d8d5a5982dc22e2a52147d982ac07eb8e8" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with multiple arguments. Just like the list forms of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;, no shell escapes happen.</source>
          <target state="translated">Начиная с Perl 5.8.0, вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; с несколькими аргументами. Как и в случае со списками &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; , экранирования оболочки не происходит.</target>
        </trans-unit>
        <trans-unit id="a68a3c591a49e26bfd6e1872f3f7a653d522ef71" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1 the dynamic loading of libraries (DynaLoader, XSLoader) also seems to have become broken in in SunOS 4.x. Therefore the default is to build Perl statically.</source>
          <target state="translated">Начиная с версии Perl 5.8.1,динамическая загрузка библиотек (DynaLoader,XSLoader),похоже,также прервалась в SunOS 4.x.Поэтому по умолчанию Perl собирается статически.</target>
        </trans-unit>
        <trans-unit id="ef5cb6c37e267f59227533f0250c84c8718b7076" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1, &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; also has the &lt;code&gt;utf8::is_utf8&lt;/code&gt; function.</source>
          <target state="translated">Начиная с Perl 5.8.1, &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; также имеет функцию &lt;code&gt;utf8::is_utf8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab205322181f94cdf41d5eaaf572850bb63def33" translate="yes" xml:space="preserve">
          <source>As of Perl 5.9.5 there is a new interface for plugging and using regular expression engines other than the default one.</source>
          <target state="translated">Начиная с версии Perl 5.9.5 появился новый интерфейс для подключения и использования движков регулярных выражений,отличных от тех,что используются по умолчанию.</target>
        </trans-unit>
        <trans-unit id="02c3c3ae5c3a1698c2091dbb44ff1c48ff7a71dd" translate="yes" xml:space="preserve">
          <source>As of Perl Symbian port version 0.4.1 any part of Perl's standard regression test suite has not been run on a real Symbian device using the ported Perl, so innumerable bugs may lie in wait. Therefore there is absolutely no warranty.</source>
          <target state="translated">Начиная с версии 0.4.1 для порта Perl Symbian,любая часть стандартного набора регрессионных тестов Perl не была запущена на реальном устройстве Symbian с использованием перенесенного Perl,поэтому бесчисленные ошибки могут лежать в ожидании.Поэтому нет абсолютно никакой гарантии.</target>
        </trans-unit>
        <trans-unit id="2a7301a461e47b0be61be125749323ecdfc5a92a" translate="yes" xml:space="preserve">
          <source>As of Perl v5.16.0, it is implemented by the &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module. See &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; for more details on its behaviour.</source>
          <target state="translated">Начиная с Perl v5.16.0, это реализовано модулем &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; . Подробнее о его поведении см. В &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f7c19e511eae81348e03d06d3194e0d82d15184" translate="yes" xml:space="preserve">
          <source>As of R2.5 of USS for OS/390 and Version 2.3 of VM/ESA these Unix sub-systems do not support the &lt;code&gt;#!&lt;/code&gt; shebang trick for script invocation. Hence, on OS/390 and VM/ESA Perl scripts can be executed with a header similar to the following simple script:</source>
          <target state="translated">Начиная с версии R2.5 USS для OS / 390 и версии 2.3 VM / ESA, эти подсистемы Unix не поддерживают &lt;code&gt;#!&lt;/code&gt; трюк shebang для вызова скрипта. Следовательно, в OS / 390 и VM / ESA Perl-скрипты могут выполняться с заголовком, подобным следующему простому скрипту:</target>
        </trans-unit>
        <trans-unit id="4e29546f04e5cfe2122e46676161bb58e8a9f171" translate="yes" xml:space="preserve">
          <source>As of Unicode 6.0, this is always empty.</source>
          <target state="translated">Начиная с Юникода 6.0,он всегда пуст.</target>
        </trans-unit>
        <trans-unit id="6be62dadd6bbd6b8a9fe9bd5f460bd2ea3dfc014" translate="yes" xml:space="preserve">
          <source>As of VERSION 1.18 all IO::Socket objects have autoflush turned on by default. This was not the case with earlier releases.</source>
          <target state="translated">Начиная с версии 1.18 все объекты IO::Socket по умолчанию имеют включенную автопромывку.В предыдущих релизах этого не было.</target>
        </trans-unit>
        <trans-unit id="9b18b6d1424b74e3d0360d9f0334585a766708d3" translate="yes" xml:space="preserve">
          <source>As of db-4.2.x it is no longer needed to do this by hand. Sleepycat has changed the configuration process to add +z on HP-UX automatically.</source>
          <target state="translated">Начиная с db-4.2.x,больше нет необходимости делать это вручную.Sleepycat изменил процесс конфигурирования на автоматическое добавление +z на HP-UX.</target>
        </trans-unit>
        <trans-unit id="ddb5b154eee158ecabd0abbac4ff1eab5e92e45f" translate="yes" xml:space="preserve">
          <source>As of perl 5.14 it is possible to hook into the compile-time lexical scope mechanism using &lt;code&gt;Perl_blockhook_register&lt;/code&gt; . This is used like this:</source>
          <target state="translated">Начиная с Perl 5.14, можно подключиться к механизму лексической области во время компиляции, используя &lt;code&gt;Perl_blockhook_register&lt;/code&gt; . Это используется так:</target>
        </trans-unit>
        <trans-unit id="283446be77b5c5650a7aade52dfb5d3e56c4e299" translate="yes" xml:space="preserve">
          <source>As of perl 5.9.5 're' debug contains a number of utility functions that may be optionally exported into the caller's namespace. They are listed below.</source>
          <target state="translated">Начиная с версии 5.9.5 're' отладка содержит ряд функций утилиты,которые могут быть опционально экспортированы в пространство имен вызывающего абонента.Они перечислены ниже.</target>
        </trans-unit>
        <trans-unit id="5916c6705e19aa4737c1eaecb1fdda26e7395e63" translate="yes" xml:space="preserve">
          <source>As of perl5.6, open() autovivifies file and directory handles as references if you pass it an uninitialized scalar variable. You can then pass these references just like any other scalar, and use them in the place of named handles.</source>
          <target state="translated">Начиная с версии perl5.6,open()autovivifies file and directory handleles as references if you pass it an uninitialized scalar variable.Затем вы можете передать эти ссылки так же,как и любой другой скаляр,и использовать их вместо именованных дескрипторов.</target>
        </trans-unit>
        <trans-unit id="0d06e02fdc69f862d76b045e6be72fc487c78e0b" translate="yes" xml:space="preserve">
          <source>As of perl5.7.2 all tests pass under:</source>
          <target state="translated">Согласно пункту 5.7.2 все тесты проходят в соответствии с требованиями:</target>
        </trans-unit>
        <trans-unit id="e7ebc726132cf88aa72c90598602d1b0ee48a664" translate="yes" xml:space="preserve">
          <source>As of perl5.8.1 there is at least one test still failing.</source>
          <target state="translated">По состоянию на 5.8.1 есть,по крайней мере,один тест,который все еще не прошел.</target>
        </trans-unit>
        <trans-unit id="1b82fd373dbd0883f99d276e806ca9d5f0a6e144" translate="yes" xml:space="preserve">
          <source>As of release 5 of Perl, assignment to &lt;code&gt;$[&lt;/code&gt; is treated as a compiler directive, and cannot influence the behavior of any other file. (That's why you can only assign compile-time constants to it.) Its use is highly discouraged.</source>
          <target state="translated">Начиная с версии Perl 5, присвоение &lt;code&gt;$[&lt;/code&gt; рассматривается как директива компилятора и не может влиять на поведение любого другого файла. (Вот почему вы можете назначать ему только константы времени компиляции.) Его использование крайне не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="1e2bbc98f0506e501d121cbf3463e0bb77e718b4" translate="yes" xml:space="preserve">
          <source>As of release 5.003_01 perl is linked to multithreaded C RTL DLL. If perl itself is not compiled multithread-enabled, so will not be perl's malloc(). However, extensions may use multiple thread on their own risk.</source>
          <target state="translated">С версии 5.003_01 perl связана с многопоточной C RTL DLL.Если сам perl не скомпилирован с поддержкой многопоточности,то не будет использоваться malloc()perl.Тем не менее,расширения могут использовать многопоточную библиотеку на свой страх и риск.</target>
        </trans-unit>
        <trans-unit id="5dbdb753a9581b45c8e16e8caa7ad1fc9cd73184" translate="yes" xml:space="preserve">
          <source>As of right now, this returns 2 if the path is absolute with a volume, 1 if it's absolute with no volume, 0 otherwise.</source>
          <target state="translated">На данный момент возвращается 2,если путь абсолютный с громкостью,1,если абсолютный без громкости,0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="cedde28f0889c00006609cd1f4e0ab992b6b315c" translate="yes" xml:space="preserve">
          <source>As of the date of this document's last update, the following systems contain PA-RISC 2.0 chips:</source>
          <target state="translated">На дату последнего обновления настоящего документа следующие системы содержат чипы PA-RISC 2.0:</target>
        </trans-unit>
        <trans-unit id="361f300829fa013b44d60226e2c65866392ff21f" translate="yes" xml:space="preserve">
          <source>As of the date of this document, Perl is fully 64-bit compliant on HP-UX 11.00 and up for both cc- and gcc builds. If you are about to build a 64-bit perl with GNU gcc, please read the gcc section carefully.</source>
          <target state="translated">На момент написания данного документа Perl полностью 64-битный на HP-UX 11.00 и подходит как для сборки cc-,так и для gcc.Если вы собираетесь собирать 64-битный Perl с помощью GNU gcc,пожалуйста,внимательно прочитайте раздел gcc.</target>
        </trans-unit>
        <trans-unit id="6087654ae9665e2974920201f81ba084c4838564" translate="yes" xml:space="preserve">
          <source>As of the time this document was last revised, the following Perl functions were implemented in the VMS port of Perl (functions marked with * are discussed in more detail below):</source>
          <target state="translated">На момент последней редакции данного документа в порту VMS на Perl были реализованы следующие Perl-функции (функции,помеченные *,более подробно рассматриваются ниже):</target>
        </trans-unit>
        <trans-unit id="2f434753b82171852395258695f5260796bd3e54" translate="yes" xml:space="preserve">
          <source>As of v5.14, Perl distinguishes three subclasses of UTF‑8 warnings.</source>
          <target state="translated">Начиная с версии 5.14,Perl выделяет три подкласса предупреждений UTF-8.</target>
        </trans-unit>
        <trans-unit id="3687eac7ed0d3e9a3819b6d8b59ffbbce6f96ce7" translate="yes" xml:space="preserve">
          <source>As of v5.18.0, both keys and values stored in &lt;code&gt;%ENV&lt;/code&gt; are stringified.</source>
          <target state="translated">Начиная с версии 5.18.0, ключи и значения, хранящиеся в &lt;code&gt;%ENV&lt;/code&gt; , преобразованы в строки .</target>
        </trans-unit>
        <trans-unit id="068ae70c04574cc37cc34db842b7ac8d0c145fb6" translate="yes" xml:space="preserve">
          <source>As of version 1.01 of the AutoSplit module it is possible to have multiple packages within a single file. Both of the following cases are supported:</source>
          <target state="translated">Начиная с версии 1.01 модуля AutoSplit возможно иметь несколько пакетов в одном файле.Поддерживаются оба следующих случая:</target>
        </trans-unit>
        <trans-unit id="4d09237d697a620472d98ca9564ba252e7440a3a" translate="yes" xml:space="preserve">
          <source>As of version 1.02 (provided with perl 5.12) the object provides &lt;code&gt;&quot;-X&quot;&lt;/code&gt; overloading, so you can call filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on) on it. It also provides a &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method, called like</source>
          <target state="translated">Начиная с версии 1.02 (поставляется с perl 5.12) объект обеспечивает перегрузку &lt;code&gt;&quot;-X&quot;&lt;/code&gt; , поэтому вы можете вызывать на нем операторы проверки файлов ( &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; и т. Д.). Он также предоставляет метод &lt;code&gt;-&amp;gt;cando&lt;/code&gt; , называемый как</target>
        </trans-unit>
        <trans-unit id="39c91a8aec6b3b91e09f6a8bd53c1515a32cc61b" translate="yes" xml:space="preserve">
          <source>As of version 1.04 (Perl 5.10), strict verifies that it is used as &quot;strict&quot; to avoid the dreaded Strict trap on case insensitive file systems.</source>
          <target state="translated">Начиная с версии 1.04 (Perl 5.10),строгая проверка используется как &quot;строгая&quot;,чтобы избежать страшной строгой ловушки на нечувствительных к регистру файловых системах.</target>
        </trans-unit>
        <trans-unit id="5750d09d680a68ca093b8cb502caecf523fc46de" translate="yes" xml:space="preserve">
          <source>As of version 1.32 of this module, constants can be defined in packages other than the caller, by including the package name in the name of the constant:</source>
          <target state="translated">Начиная с версии 1.32 данного модуля,константы могут быть определены в пакетах,отличных от вызывающего,путем включения имени пакета в имя константы:</target>
        </trans-unit>
        <trans-unit id="a9966baeb16dc71d9782450ad1960be303770497" translate="yes" xml:space="preserve">
          <source>As of version 1.47 the following additions were made to the install interface. Note that the new argument style and use of the %result hash is recommended.</source>
          <target state="translated">Начиная с версии 1.47,были внесены следующие дополнения в установочный интерфейс.Обратите внимание,что рекомендуется новый стиль аргументов и использование хэша %result.</target>
        </trans-unit>
        <trans-unit id="e47319fd89f8639b4c6dc3d1dee645f4e3217716" translate="yes" xml:space="preserve">
          <source>As of version 2.12, &lt;code&gt;Encode&lt;/code&gt; supports coderef values for &lt;code&gt;CHECK&lt;/code&gt; ; see below.</source>
          <target state="translated">Начиная с версии 2.12, &lt;code&gt;Encode&lt;/code&gt; поддерживает значения coderef для &lt;code&gt;CHECK&lt;/code&gt; ; увидеть ниже.</target>
        </trans-unit>
        <trans-unit id="feaefe7da5a3f173789e3bc38d1cc052b48f0697" translate="yes" xml:space="preserve">
          <source>As of version 2.32 Getopt::Long provides auto-help, a quick and easy way to add the options --help and -? to your program, and handle them.</source>
          <target state="translated">Начиная с версии 2.32 Getopt::Long предоставляет автопомощь,быстрый и простой способ добавить опции --help и -? в вашу программу,и обрабатывать их.</target>
        </trans-unit>
        <trans-unit id="4961ac95a03fe72cd95305ebd10cd56767e6cd2e" translate="yes" xml:space="preserve">
          <source>As of version 5.00305, OS/2 perl binary distribution comes split into 11 components. Unfortunately, to enable configurable binary installation, the file paths in the zip files are not absolute, but relative to some directory.</source>
          <target state="translated">Начиная с версии 5.00305,бинарный дистрибутив OS/2 perl разделен на 11 компонентов.К сожалению,чтобы включить настраиваемую двоичную установку,пути к файлам в zip-файлах не абсолютные,а относительные к некоторому каталогу.</target>
        </trans-unit>
        <trans-unit id="c5ef8d96f6d787f0f3cc3fb69a33144b75f432e6" translate="yes" xml:space="preserve">
          <source>As of version 5.12.0, perl has stopped using the underlying time library of the operating system it's running on and has its own implementation of those routines with a safe range of at least +/ 2**52 (about 142 million years).</source>
          <target state="translated">Начиная с версии 5.12.0,perl перестал использовать базовую библиотеку времени операционной системы,на которой он работает,и имеет свою собственную реализацию этих процедур с безопасным диапазоном не менее +/2**52 (около 142 миллионов лет).</target>
        </trans-unit>
        <trans-unit id="ede48005eab24777f4cf1c1c51404cc14a546bbe" translate="yes" xml:space="preserve">
          <source>As of writing (2010-09) only the</source>
          <target state="translated">На момент написания статьи (2010-09)только</target>
        </trans-unit>
        <trans-unit id="53d68ae04ea90208ac09617d93481673c81dae0c" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;, in scalar context it should return the next line, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for no more data. In list context it should return all remaining lines, or an empty list for no more data. The strings returned should include the input record separator &lt;code&gt;$/&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), unless it is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (which means &quot;slurp&quot; mode).</source>
          <target state="translated">Согласно строке &lt;a href=&quot;functions/readline&quot;&gt;чтения&lt;/a&gt; , в скалярном контексте она должна возвращать следующую строку или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , чтобы больше данных не было. В контексте списка он должен возвращать все оставшиеся строки или пустой список, если больше нет данных. Возвращаемые строки должны включать разделитель входных записей &lt;code&gt;$/&lt;/code&gt; (см. &lt;a href=&quot;perlvar&quot;&gt;Perlvar&lt;/a&gt; ), если он не является &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (что означает режим &quot;slurp&quot;).</target>
        </trans-unit>
        <trans-unit id="35db6e6083bf8853a0d7a773700bfc53f4f3833e" translate="yes" xml:space="preserve">
          <source>As per get(), but returns a tied filehandle. Reading from this filehandle returns the requested message. The filehandle will return EOF at the end of the message and should not be reused.</source>
          <target state="translated">В соответствии с функцией get(),но возвращает привязанную файловую ручку.Чтение из этой файловой папки возвращает запрошенное сообщение.Ручка файлов возвращает EOF в конце сообщения и не должна использоваться повторно.</target>
        </trans-unit>
        <trans-unit id="f8d3cabb86865ec30b2f81b742c043bb4dfa0006" translate="yes" xml:space="preserve">
          <source>As perl does not use it, it is not well tested.</source>
          <target state="translated">Поскольку perl не использует его,он плохо протестирован.</target>
        </trans-unit>
        <trans-unit id="04f2eace94f5ec9fb309f7ef275b1f53f5b18652" translate="yes" xml:space="preserve">
          <source>As pragmata are implemented as modules, like any other module, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; becomes</source>
          <target state="translated">Поскольку прагматы реализованы в виде модулей, как и любой другой модуль, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; становится</target>
        </trans-unit>
        <trans-unit id="6ff69505257da499d009f94993a8c36d403bc517" translate="yes" xml:space="preserve">
          <source>As previously mentioned, the &quot;switch&quot; feature is considered highly experimental; it is subject to change with little notice. In particular, &lt;code&gt;when&lt;/code&gt; has tricky behaviours that are expected to change to become less tricky in the future. Do not rely upon its current (mis)implementation. Before Perl 5.18, &lt;code&gt;given&lt;/code&gt; also had tricky behaviours that you should still beware of if your code must run on older versions of Perl.</source>
          <target state="translated">Как упоминалось ранее, функция &amp;laquo;переключения&amp;raquo; считается в высшей степени экспериментальной; он может быть изменен без предварительного уведомления. В частности, &lt;code&gt;when&lt;/code&gt; имеет сложное поведение, которое, как ожидается, изменится, чтобы стать менее сложным в будущем. Не полагайтесь на его текущую (неправильную) реализацию. До Perl 5.18 у &lt;code&gt;given&lt;/code&gt; также было сложное поведение, которого вы все равно должны остерегаться, если ваш код должен работать на более старых версиях Perl.</target>
        </trans-unit>
        <trans-unit id="d4ddd43c6028587c10020a05414bb6d70c1790ee" translate="yes" xml:space="preserve">
          <source>As previously noted, individual entries (as opposed to the whole hash) are settable. Perl only cares about Boolean true here, although the values used by</source>
          <target state="translated">Как уже отмечалось ранее,отдельные записи (в отличие от хэша целиком)являются настраиваемыми.Perl заботится только о булевом истине здесь,хотя значения,используемые для</target>
        </trans-unit>
        <trans-unit id="40863db850a5e2446412cc32d982d2e85c0c2a70" translate="yes" xml:space="preserve">
          <source>As setup, consider this (admittedly rather contrived) example of a tie; all it does is use a file to keep a log of the values assigned to a scalar.</source>
          <target state="translated">В качестве примера установки рассмотрим этот (хотя и довольно надуманный)пример привязки;все,что он делает,это использует файл для ведения журнала значений,назначенных скаляру.</target>
        </trans-unit>
        <trans-unit id="d5e7901b05cd99e70f1eb4d22405e5ec5c43c73a" translate="yes" xml:space="preserve">
          <source>As shipped, the only command-line history supplied is a simplistic one that checks for leading exclamation points. However, if you install the Term::ReadKey and Term::ReadLine modules from CPAN (such as Term::ReadLine::Gnu, Term::ReadLine::Perl, ...) you will have full editing capabilities much like those GNU</source>
          <target state="translated">В поставке единственная история командной строки-это упрощенная история,которая проверяет наличие ведущих восклицательных знаков.Однако,если вы установите модули Term::ReadKey и Term::ReadLine из CPAN (такие как Term::ReadLine::Gnu,Term::ReadLine::Perl,....),у вас будут полные возможности редактирования,подобные тем,что GNU</target>
        </trans-unit>
        <trans-unit id="3c7b29c9acaba84b5dfa9d94a08362e636c880e4" translate="yes" xml:space="preserve">
          <source>As shown above, Perl creates the backup file whether or not any output is actually changed. So this is just a fancy way to copy files:</source>
          <target state="translated">Как показано выше,Perl создает файл резервной копии,независимо от того,был ли на самом деле изменен выходной файл.Таким образом,это просто причудливый способ копирования файлов:</target>
        </trans-unit>
        <trans-unit id="cf827d39576175b49dc1a1c39fee2ddfa72908f4" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">Как показано в этом примере, на &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; не действует правило &amp;laquo;выглядит как функция&amp;raquo;. Пара скобок, следующая за ним, не (обязательно) ограничивает аргумент. &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; эквивалентно &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Кроме того, в отличие от большинства именованных операторов, это имеет тот же приоритет, что и присваивание.</target>
        </trans-unit>
        <trans-unit id="a246c967f8c44d960de455229b31b368ecdb7f4c" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">Как показано в этом примере, на &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; не действует правило &amp;laquo;выглядит как функция&amp;raquo;. Пара скобок, следующая за ним, не (обязательно) ограничивает аргумент. &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; эквивалентно &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Кроме того, в отличие от большинства именованных операторов, это имеет тот же приоритет, что и присваивание.</target>
        </trans-unit>
        <trans-unit id="6d2e840402d6fc0f9fee1fa99ab3b3ed1f5042e9" translate="yes" xml:space="preserve">
          <source>As such, signals that would normally not be appropriate to use in the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; command (e.g., &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ) are okay to use with the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; method (again, as illustrated above).</source>
          <target state="translated">Таким образом, сигналы, которые обычно не подходят для использования в команде &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; (например, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ), можно использовать с методом &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; (опять же, как показано выше) .</target>
        </trans-unit>
        <trans-unit id="a44ff5fd296684850a7eea8453ca8654e5ea2769" translate="yes" xml:space="preserve">
          <source>As system libraries (most notably glibc) are also triggering errors, valgrind allows to suppress such errors using suppression files. The default suppression file that comes with valgrind already catches a lot of them. Some additional suppressions are defined in</source>
          <target state="translated">Так как системные библиотеки (прежде всего glibc)также являются триггерами ошибок,valgrind позволяет подавлять такие ошибки с помощью файлов подавления.Файл подавления по умолчанию,который поставляется с valgrind,уже ловит многие из них.Некоторые дополнительные подавления определены в</target>
        </trans-unit>
        <trans-unit id="e1a99808d733ec0659b941748add22eaba940233" translate="yes" xml:space="preserve">
          <source>As that is multiple C statements it is quite common so see this idiom instead:</source>
          <target state="translated">Так как это несколько выражений на языке C,то они довольно распространены,поэтому вместо этого посмотрите на эту идиому:</target>
        </trans-unit>
        <trans-unit id="ac882702a8c758004edc0489caa0c38829169f81" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;'IGNORE'&lt;/code&gt; hook is not supported by &lt;code&gt;__WARN__&lt;/code&gt; , you can disable warnings using the empty subroutine:</source>
          <target state="translated">Поскольку ловушка &lt;code&gt;'IGNORE'&lt;/code&gt; не поддерживается &lt;code&gt;__WARN__&lt;/code&gt; , вы можете отключить предупреждения с помощью пустой подпрограммы:</target>
        </trans-unit>
        <trans-unit id="481d1ba67f45c383e883a88846da2edc2a1775aa" translate="yes" xml:space="preserve">
          <source>As the Perl interpreter looks at signal flags only when it is about to execute a new opcode, a signal that arrives during a long-running opcode (e.g. a regular expression operation on a very large string) will not be seen until the current opcode completes.</source>
          <target state="translated">Так как интерпретатор Perl смотрит на сигнальные флаги только тогда,когда собирается выполнить новый опкод,сигнал,который поступает во время долгого опкода (например,операция регулярного выражения на очень большой строке),не будет виден до тех пор,пока текущий опкод не завершится.</target>
        </trans-unit>
        <trans-unit id="f849d9355eec2f51b5cef2814ee106c18c309122" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO (bytes) internally, all this totally ignores things like the type of your filesystem (ASCII or EBCDIC).</source>
          <target state="translated">Так как PerlIO слой использует исходный IO (байты)внутри,все это полностью игнорирует такие вещи,как тип вашей файловой системы (ASCII или EBCDIC).</target>
        </trans-unit>
        <trans-unit id="ef5f3ccf5711fff6ab130d18e6106225adf61f56" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO internally, all this totally ignores the type of your filesystem (ASCII or EBCDIC) and the IO_CONVERSION environment variable. If you want to get the old behavior, that the BS2000 IO functions determine conversion depending on the filesystem PerlIO still is your friend. You use IO_CONVERSION as usual and tell Perl, that it should use the native IO layer:</source>
          <target state="translated">Так как PerlIO слой использует исходный IO внутри,все это полностью игнорирует тип вашей файловой системы (ASCII или EBCDIC)и переменную окружения IO_CONVERSION.Если вы хотите получить старое поведение,то то то,что IO функции BS2000 определяют преобразование в зависимости от файловой системы,PerlIO все равно является вашим другом.Вы используете IO_CONVERSION как обычно и говорите Perl,что он должен использовать родной IO слой:</target>
        </trans-unit>
        <trans-unit id="20b8fc20101f3d438a32270dc2621c0dd14971b3" translate="yes" xml:space="preserve">
          <source>As the comment says, this is not a good way to implement accessors. It's slow and too clever by far. However, you may see this as a way to provide accessors in older Perl code. See &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for recommendations on OO coding in Perl.</source>
          <target state="translated">Как говорится в комментарии, это не лучший способ реализовать аксессоры. Это очень медленно и слишком умно. Однако вы можете рассматривать это как способ предоставления средств доступа в старом коде Perl. См. &lt;a href=&quot;perlootut&quot;&gt;Perlootut&lt;/a&gt; для рекомендаций по объектно- ориентированному кодированию на Perl.</target>
        </trans-unit>
        <trans-unit id="4fca5f01eab824b22bb6b1905a8d483f37ad2ed6" translate="yes" xml:space="preserve">
          <source>As the example shows, if the second argument is an empty string, the category's locale is returned to the default specified by the corresponding environment variables. Generally, this results in a return to the default that was in force when Perl started up: changes to the environment made by the application after startup may or may not be noticed, depending on your system's C library.</source>
          <target state="translated">Как видно из примера,если второй аргумент-пустая строка,то локаль категории возвращается по умолчанию,указанному соответствующими переменными окружения.Обычно это приводит к возврату к значениям по умолчанию,которые действовали при запуске Perl:изменения в окружении,внесенные приложением после запуска,могут быть замечены или не замечены,в зависимости от библиотеки C вашей системы.</target>
        </trans-unit>
        <trans-unit id="0a3da7dd18a3b2da7c7f36441b50e2eab858828a" translate="yes" xml:space="preserve">
          <source>As the final two examples above show, you can achieve portablity to non-ASCII platforms by using the &lt;code&gt;\N{...}&lt;/code&gt; form for the range endpoints. These indicate that the specified range is to be interpreted using Unicode values, so &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; means to match &lt;code&gt;\N{U+27}&lt;/code&gt; , &lt;code&gt;\N{U+28}&lt;/code&gt; , &lt;code&gt;\N{U+29}&lt;/code&gt; , ..., &lt;code&gt;\N{U+3D}&lt;/code&gt; , &lt;code&gt;\N{U+3E}&lt;/code&gt; , and &lt;code&gt;\N{U+3F}&lt;/code&gt; , whatever the native code point versions for those are. These are called &quot;Unicode&quot; ranges. If either end is of the &lt;code&gt;\N{...}&lt;/code&gt; form, the range is considered Unicode. A &lt;code&gt;regexp&lt;/code&gt; warning is raised under &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; if the other endpoint is specified non-portably:</source>
          <target state="translated">Как показывают два последних примера выше, вы можете достичь переносимости на не-ASCII-платформы, используя форму &lt;code&gt;\N{...}&lt;/code&gt; для конечных точек диапазона. Они указывают на то, что указанный диапазон должен интерпретироваться с использованием значений Unicode, поэтому &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; означает соответствие &lt;code&gt;\N{U+27}&lt;/code&gt; , &lt;code&gt;\N{U+28}&lt;/code&gt; , &lt;code&gt;\N{U+29}&lt;/code&gt; , ..., &lt;code&gt;\N{U+3D}&lt;/code&gt; , &lt;code&gt;\N{U+3E}&lt;/code&gt; и &lt;code&gt;\N{U+3F}&lt;/code&gt; , вне зависимости от версии собственного кода для них. Это диапазоны &quot;Unicode&quot;. Если любой конец имеет форму &lt;code&gt;\N{...}&lt;/code&gt; , диапазон считается Unicode. &lt;code&gt;regexp&lt;/code&gt; предупреждение возникает при &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; если другая конечная точка указана без возможности переноса:</target>
        </trans-unit>
        <trans-unit id="17c70cf277254845a8ce88c971a047564a105d87" translate="yes" xml:space="preserve">
          <source>As the last character of a prototype, or just before a semicolon, a &lt;code&gt;@&lt;/code&gt; or a &lt;code&gt;%&lt;/code&gt; , you can use &lt;code&gt;_&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt; : if this argument is not provided, &lt;code&gt;$_&lt;/code&gt; will be used instead.</source>
          <target state="translated">В качестве последнего символа прототипа или непосредственно перед точкой с запятой, &lt;code&gt;@&lt;/code&gt; или &lt;code&gt;%&lt;/code&gt; вы можете использовать &lt;code&gt;_&lt;/code&gt; вместо &lt;code&gt;$&lt;/code&gt; : если этот аргумент не указан, вместо него будет использоваться &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b123b1845e08fc58170e4c4c4ab5952b56ae816" translate="yes" xml:space="preserve">
          <source>As the last example indicates, a handler may be set up to be (re)called in two or more phases. The phase name is passed as the handler's final argument.</source>
          <target state="translated">Как показывает последний пример,обработчик может быть настроен на (повторный)вызов в две или более фаз.Имя фазы передается в качестве последнего аргумента обработчика.</target>
        </trans-unit>
        <trans-unit id="776d16ae4f440b015655f81050641c0ec6c3a0f2" translate="yes" xml:space="preserve">
          <source>As the parser reads the second and subsequent lines from the source stream, it feeds those lines through the &lt;code&gt;cpp&lt;/code&gt; source filter before processing them. The &lt;code&gt;cpp&lt;/code&gt; filter simply passes each line through the real C preprocessor. The output from the C preprocessor is then inserted back into the source stream by the filter.</source>
          <target state="translated">Когда синтаксический анализатор считывает вторую и последующие строки из исходного потока, он пропускает эти строки через исходный фильтр &lt;code&gt;cpp&lt;/code&gt; перед их обработкой. &lt;code&gt;cpp&lt;/code&gt; фильтр просто проходит каждую линию через реальный C препроцессор. Выходные данные препроцессора C затем вставляются фильтром обратно в исходный поток.</target>
        </trans-unit>
        <trans-unit id="b29477c3662cd388380e5f2f7edde392d4aa47d3" translate="yes" xml:space="preserve">
          <source>As the parser understands a Perl program, it builds up a tree of operations for the interpreter to perform during execution. The routines which construct and link together the various operations are to be found in</source>
          <target state="translated">Поскольку синтаксический анализатор понимает программу на Perl,он строит дерево операций,которые интерпретатор должен выполнять во время выполнения.Процедуры,которые строят и связывают между собой различные операции,можно найти в следующих разделах</target>
        </trans-unit>
        <trans-unit id="059620d29d96cd6f5eb8cd327a9137c1f47169b5" translate="yes" xml:space="preserve">
          <source>As there are various Make programs with incompatible syntax, which use operating system shells, again with incompatible syntax, it is important for users of this module to know which flavour of Make a Makefile has been written for so they'll use the correct one and won't have to face the possibly bewildering errors resulting from using the wrong one.</source>
          <target state="translated">Так как существуют различные Make программы с несовместимым синтаксисом,использующие оболочки операционной системы,опять же с несовместимым синтаксисом,то пользователям этого модуля важно знать,для какого вкуса был написан Make a Makefile,поэтому они будут использовать правильный и им не придётся сталкиваться с возможными запутанными ошибками,возникающими в результате использования неправильного синтаксиса.</target>
        </trans-unit>
        <trans-unit id="036fd1e2507560ce47135587c83032ff17f1287e" translate="yes" xml:space="preserve">
          <source>As there is an overlap between the error numbers used by</source>
          <target state="translated">Так как существует перекрытие между номерами ошибок,используемыми для</target>
        </trans-unit>
        <trans-unit id="c2c40011ac031fbcf62ae0096c0f70fe3f04f6d4" translate="yes" xml:space="preserve">
          <source>As told above, Perl 5.6.1 was still good in AmigaOS, as was 5.7.2. After Perl 5.7.2 (change #11423, see the Changes file, and the file pod/perlhack.pod for how to get the individual changes) Perl dropped its internal support for vfork(), and that was very probably the step that broke AmigaOS (since the ixemul library has only vfork). The build finally fails when the ext/DynaLoader is being built, and PERL ends up as &quot;0&quot; in the produced Makefile, trying to run &quot;0&quot; does not quite work. Also, executing miniperl in backticks seems to generate nothing: very probably related to the (v)fork problems. &lt;b&gt;Fixing the breakage requires someone quite familiar with the ixemul library, and how one is supposed to run external commands in AmigaOS without fork().&lt;/b&gt;</source>
          <target state="translated">Как было сказано выше, Perl 5.6.1 все еще был хорош в AmigaOS, как и 5.7.2. После Perl 5.7.2 (изменение # 11423, см. Файл изменений и файл pod / perlhack.pod, чтобы узнать, как получить отдельные изменения) Perl отказался от своей внутренней поддержки vfork (), и, скорее всего, это был шаг, который сломал AmigaOS (поскольку в библиотеке ixemul есть только vfork). В конечном итоге сборка завершается неудачей, когда создается ext / DynaLoader, и PERL заканчивается как &amp;laquo;0&amp;raquo; в созданном Makefile, попытка запустить &amp;laquo;0&amp;raquo; не совсем работает. Кроме того, выполнение miniperl в обратных кавычках, похоже, ничего не генерирует: очень вероятно, связано с проблемами (v) fork. &lt;b&gt;Для исправления поломки нужен кто-то, хорошо знакомый с библиотекой ixemul и с тем, как следует запускать внешние команды в AmigaOS без fork ().&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7df201bc839d821d3a7ec829e521380838b10cef" translate="yes" xml:space="preserve">
          <source>As usual, &lt;code&gt;PL_restartop&lt;/code&gt; is extracted from the &lt;code&gt;CxEVAL&lt;/code&gt; , and a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; done, which pops the C stack back to the docatch:</source>
          <target state="translated">Как обычно, &lt;code&gt;PL_restartop&lt;/code&gt; извлекается из &lt;code&gt;CxEVAL&lt;/code&gt; и выполняется &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; , который возвращает стек C обратно в документ:</target>
        </trans-unit>
        <trans-unit id="43f8dfff8ebd277fcb05688b6c5164a9ecb709ab" translate="yes" xml:space="preserve">
          <source>As usual, run</source>
          <target state="translated">Как обычно,бегите</target>
        </trans-unit>
        <trans-unit id="6a12281792622fa54248b5b0512161ae986d73ec" translate="yes" xml:space="preserve">
          <source>As we have seen above, Principle 0 overrides the others. The regexp will be matched as early as possible, with the other principles determining how the regexp matches at that earliest character position.</source>
          <target state="translated">Как мы видели выше,принцип 0 отменяет остальные.Регеxp будет соответствовать как можно раньше,остальные принципы определяют,как регеxp будет соответствовать на самой ранней позиции персонажа.</target>
        </trans-unit>
        <trans-unit id="f24d0557480129d0bec98f1d07b3bc35225e11b2" translate="yes" xml:space="preserve">
          <source>As we mentioned before, Perl's built-in OO system is very minimal, but also quite flexible. Over the years, many people have developed systems which build on top of Perl's built-in system to provide more features and convenience.</source>
          <target state="translated">Как мы уже упоминали,встроенная система OOO Perl очень минимальна,но в то же время достаточно гибка.На протяжении многих лет многие люди разрабатывали системы,которые строились на основе встроенной системы Perl,чтобы обеспечить больше возможностей и удобства.</target>
        </trans-unit>
        <trans-unit id="09f78df2a986a05b74a05b4840bd77f0745f303d" translate="yes" xml:space="preserve">
          <source>As we mentioned before, roles provide an alternative to inheritance, but Perl does not have any built-in role support. If you choose to use Moose, it comes with a full-fledged role implementation. However, if you use one of our other recommended OO modules, you can still use roles with &lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role::Tiny&lt;/a&gt;</source>
          <target state="translated">Как мы упоминали ранее, роли предоставляют альтернативу наследованию, но Perl не имеет встроенной поддержки ролей. Если вы решите использовать Moose, он будет иметь полноценную реализацию роли. Однако, если вы используете один из других рекомендованных нами OO-модулей, вы все равно можете использовать роли с &lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role :: Tiny.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f8a13dd0293aebd2b1466f31d349be90b2e062e" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, Perl provides no special constructor syntax. This means that a class must implement its own constructor. A constructor is simply a class method that returns a reference to a new object.</source>
          <target state="translated">Как мы уже упоминали ранее,Perl не предоставляет специального синтаксиса конструктора.Это означает,что класс должен реализовать свой собственный конструктор.Конструктор-это просто метод класса,который возвращает ссылку на новый объект.</target>
        </trans-unit>
        <trans-unit id="34cb600e9a3f6e5e075e857de4110b1ef2b3324a" translate="yes" xml:space="preserve">
          <source>As we return an empty list, everything is fine.</source>
          <target state="translated">Пока мы возвращаем пустой список,все в порядке.</target>
        </trans-unit>
        <trans-unit id="1bc0081962e83c9753eb5550755ad42af088433e" translate="yes" xml:space="preserve">
          <source>As we said before, Perl's minimal OO system has led to a profusion of OO systems on CPAN. While you can still drop down to the bare metal and write your classes by hand, there's really no reason to do that with modern Perl.</source>
          <target state="translated">Как мы уже говорили ранее,система минимального OOO Perl привела к изобилию систем OO на CPAN.Несмотря на то,что Вы все еще можете опускаться на голый металл и писать уроки от руки,на самом деле нет никаких причин делать это с современным Perl.</target>
        </trans-unit>
        <trans-unit id="7867c988c2c06b2c05fdddd86e23a3f47b3a2862" translate="yes" xml:space="preserve">
          <source>As we said earlier, most Perl objects are hashes, but an object can be an instance of any Perl data type (scalar, array, etc.). Turning a plain data structure into an object is done by &lt;b&gt;blessing&lt;/b&gt; that data structure using Perl's &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Как мы сказали ранее, большинство объектов Perl являются хешами, но объект может быть экземпляром любого типа данных Perl (скаляр, массив и т. Д.). Превращение простой структуры данных в объект осуществляется путем &lt;b&gt;благословения&lt;/b&gt; этой структуры данных с помощью функции Perl &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="504d4df94aa612d7624624e4944523fc3497d648" translate="yes" xml:space="preserve">
          <source>As we saw earlier, an object is simply a data structure that has been blessed into a class via the &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function. The &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function can take either one or two arguments:</source>
          <target state="translated">Как мы видели ранее, объект - это просто структура данных, которая была добавлена ​​в класс с помощью функции &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; . Функция &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; может принимать один или два аргумента:</target>
        </trans-unit>
        <trans-unit id="a1d3a4a5afeb3f9e63b11e0b6c656dbcfa8f18b8" translate="yes" xml:space="preserve">
          <source>As we've already shown, &lt;code&gt;call_sv&lt;/code&gt; can be used to invoke an anonymous subroutine. However, our example showed a Perl script invoking an XSUB to perform this operation. Let's see how it can be done inside our C code:</source>
          <target state="translated">Как мы уже показали, &lt;code&gt;call_sv&lt;/code&gt; можно использовать для вызова анонимной подпрограммы. Однако в нашем примере показан сценарий Perl, вызывающий XSUB для выполнения этой операции. Давайте посмотрим, как это можно сделать внутри нашего кода на C:</target>
        </trans-unit>
        <trans-unit id="96d58f32e93788e5dbef34c03d0df80dbd089dab" translate="yes" xml:space="preserve">
          <source>As well as accessing Berkeley DB using a tied hash or array, it is also possible to make direct use of most of the API functions defined in the Berkeley DB documentation.</source>
          <target state="translated">Помимо доступа к БД Беркли с помощью связанного хэша или массива,можно также напрямую использовать большинство функций API,определенных в документации к БД Беркли.</target>
        </trans-unit>
        <trans-unit id="749b97b56149a492eb18a4cb65f04d306a596132" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the hash (like hv_clear()), this also frees any auxiliary data and storage associated with the hash.</source>
          <target state="translated">Помимо освобождения всех элементов хэша (например,hv_clear()),это также освобождает любые вспомогательные данные и хранилища,связанные с хэшем.</target>
        </trans-unit>
        <trans-unit id="2e0710bbe12c8de0ee3e47fce586245cf49652f2" translate="yes" xml:space="preserve">
          <source>As well as grouping, parentheses serve a second purpose. They can be used to capture the results of parts of the regexp match for later use. The results end up in &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; and so on.</source>
          <target state="translated">Круглые скобки служат не только для группировки, но и для другой цели. Их можно использовать для сбора результатов совпадений регулярных выражений для дальнейшего использования. Результаты в конечном итоге в &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="7365f5053276b5ccb78d102d8d65d8a7cbb5a47c" translate="yes" xml:space="preserve">
          <source>As well as these two, there is another converter:</source>
          <target state="translated">Как и эти двое,есть еще один преобразователь:</target>
        </trans-unit>
        <trans-unit id="5f09c013a494b22fb2c5704b9b33f8690cdb78ae" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairfirst&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">Как и в случае с &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; псевдонимом &lt;code&gt;$_&lt;/code&gt; для перечисления элементов, &lt;code&gt;pairfirst&lt;/code&gt; псевдонимы &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; для элементов данного списка. Любые модификации этого блока кода будут видны вызывающему.</target>
        </trans-unit>
        <trans-unit id="6ccb264713980d688f5b35e3f78e5d8bcc1b34f2" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairgrep&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">Как и в случае с &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; псевдонимом &lt;code&gt;$_&lt;/code&gt; для перечисления элементов, &lt;code&gt;pairgrep&lt;/code&gt; присваивает псевдонимы &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; элементам данного списка. Любые модификации этого блока кода будут видны вызывающему.</target>
        </trans-unit>
        <trans-unit id="0e0ea04c8e6030abec75f8b13970784d2a0b7c8f" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairmap&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">Как и в случае &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; псевдонимов &lt;code&gt;$_&lt;/code&gt; для элементов списка, &lt;code&gt;pairmap&lt;/code&gt; псевдонимов &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; для элементов данного списка. Любые модификации этого блока кода будут видны вызывающему.</target>
        </trans-unit>
        <trans-unit id="852273f60001fb5cfcfc3f59c366b8a418d217ac" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;gzerror()&lt;/code&gt; it returns an error number in numeric context and an error message in string context. Unlike &lt;code&gt;gzerror()&lt;/code&gt; though, the error message will correspond to the</source>
          <target state="translated">Как и &lt;code&gt;gzerror()&lt;/code&gt; он возвращает номер ошибки в числовом контексте и сообщение об ошибке в строковом контексте. Однако, в отличие от &lt;code&gt;gzerror()&lt;/code&gt; , сообщение об ошибке будет соответствовать</target>
        </trans-unit>
        <trans-unit id="89fce7a719c0828fb9010451c52ebed3b12f2d8d" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;mro::get_linear_isa&lt;/code&gt; above, &lt;code&gt;UNIVERSAL&lt;/code&gt; is special. &lt;code&gt;UNIVERSAL&lt;/code&gt; (and parents') isarev lists do not include every class in existence, even though all classes are effectively descendants for method inheritance purposes.</source>
          <target state="translated">Как и в случае с &lt;code&gt;mro::get_linear_isa&lt;/code&gt; выше, &lt;code&gt;UNIVERSAL&lt;/code&gt; особенный. &lt;code&gt;UNIVERSAL&lt;/code&gt; (и родительские) списки isarev не включают все существующие классы, хотя все классы фактически являются потомками для целей наследования методов.</target>
        </trans-unit>
        <trans-unit id="1bfc8628cde1b50356023884cf039103db9706d2" translate="yes" xml:space="preserve">
          <source>As with G_SCALAR, this flag has 2 effects:</source>
          <target state="translated">Как и G_SCALAR,этот флаг имеет 2 эффекта:</target>
        </trans-unit>
        <trans-unit id="56fcac1f27b0d72bf38ecab8e2bf923c1135ad6d" translate="yes" xml:space="preserve">
          <source>As with GetOptionsFromArray, a first argument hash reference now becomes the second argument.</source>
          <target state="translated">Как и в случае с GetOptionsFromArray,первый аргумент,ссылающийся на хэш-функцию,теперь становится вторым аргументом.</target>
        </trans-unit>
        <trans-unit id="f5b2adb567968a40150b99a2b38e37687da34625" translate="yes" xml:space="preserve">
          <source>As with all &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directives, defining a constant happens at compile time. Thus, it's probably not correct to put a constant declaration inside of a conditional statement (like &lt;code&gt;if ($foo)
{ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ).</source>
          <target state="translated">Как и в случае со всеми директивами &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , определение константы происходит во время компиляции. Таким образом, вероятно, неправильно помещать объявление константы внутри условного оператора (например, &lt;code&gt;if ($foo) { &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a9e166bc9c2d17d86e12b7d5456a5dc29e6460a0" translate="yes" xml:space="preserve">
          <source>As with all compiler backend options, these must follow directly after the '-MO=Deparse', separated by a comma but not any white space.</source>
          <target state="translated">Как и во всех опциях бэкенда компилятора,они должны следовать непосредственно после '-MO=Deparse',разделенного запятой,но не любым белым пробелом.</target>
        </trans-unit>
        <trans-unit id="dec6818f5ac3b2a14f0cdaa20965c7cdeed80414" translate="yes" xml:space="preserve">
          <source>As with all standard commands, a single-character switch may be clustered with the following switch, if any.</source>
          <target state="translated">Как и все стандартные команды,односимвольный переключатель может быть скомпонован со следующим переключателем,если таковой имеется.</target>
        </trans-unit>
        <trans-unit id="3f95467f687ea8e2cde45cd2aae56d762c10d52a" translate="yes" xml:space="preserve">
          <source>As with all things in Perl,</source>
          <target state="translated">Как и все вещи в Перле,</target>
        </trans-unit>
        <trans-unit id="d4bf4ba0005710853f921b26431dc8a4fd4165e9" translate="yes" xml:space="preserve">
          <source>As with any advisory locking scheme, the protection only works if you systematically use &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_retrieve&lt;/code&gt; . If one side of your application uses &lt;code&gt;store&lt;/code&gt; whilst the other uses &lt;code&gt;lock_retrieve&lt;/code&gt; , you will get no protection at all.</source>
          <target state="translated">Как и в случае любой рекомендательной схемы блокировки, защита работает, только если вы систематически используете &lt;code&gt;lock_store&lt;/code&gt; и &lt;code&gt;lock_retrieve&lt;/code&gt; . Если одна сторона вашего приложения использует &lt;code&gt;store&lt;/code&gt; , а другая - &lt;code&gt;lock_retrieve&lt;/code&gt; , вы вообще не получите защиты.</target>
        </trans-unit>
        <trans-unit id="dfdecc72a46325c982361e944a60a5cc48397fb3" translate="yes" xml:space="preserve">
          <source>As with constructors, Perl provides no special accessor declaration syntax, so classes must provide explicitly written accessor methods. There are two common types of accessors, read-only and read-write.</source>
          <target state="translated">Как и в случае с конструкторами,Perl не предоставляет специального синтаксиса объявления доступа,поэтому классы должны предоставлять явно написанные методы доступа.Существует два общих типа доступа-доступ только для чтения и чтение-запись.</target>
        </trans-unit>
        <trans-unit id="5d06ccd4ce0505718d0adf18033c22a5ca1bc63e" translate="yes" xml:space="preserve">
          <source>As with many unix ports, this one depends on a few &quot;standard&quot; unix utilities which are not necessarily standard for QNX4.</source>
          <target state="translated">Как и в случае со многими unix-портами,этот порт зависит от нескольких &quot;стандартных&quot; утилит unix,которые не обязательно являются стандартными для QNX4.</target>
        </trans-unit>
        <trans-unit id="522d69b5bf4a752ac2eed134a3a3d90b973940bc" translate="yes" xml:space="preserve">
          <source>As with normal Perl arrays, a RECNO array can be accessed using negative indexes. The index -1 refers to the last element of the array, -2 the second last, and so on. Attempting to access an element before the start of the array will raise a fatal run-time error.</source>
          <target state="translated">Как и в случае с обычными Perl-массивами,доступ к массиву RECNO можно получить с помощью отрицательных индексов.Индекс -1 относится к последнему элементу массива,-2-ко второму последнему и так далее.Попытка получить доступ к элементу до начала работы массива приведет к фатальной ошибке во время выполнения.</target>
        </trans-unit>
        <trans-unit id="4f5b532a80f5e05a1cc6284ddbfce49edaec9bba" translate="yes" xml:space="preserve">
          <source>As with postfix array, postfix value slice dereferencing</source>
          <target state="translated">Как и в случае с постфиксным массивом,разыменование среза постфиксного значения</target>
        </trans-unit>
        <trans-unit id="5f2a0ee0b6d450a60b564dbded3394cc767489a2" translate="yes" xml:space="preserve">
          <source>As with subroutines, the type of value returned from a thread's entry point function may be determined by the thread's</source>
          <target state="translated">Как и в подпрограммном обеспечении,тип значения,возвращаемого из функции точки входа потока,может быть определен по типу значения потока</target>
        </trans-unit>
        <trans-unit id="b1cab3e1a5ac11251ae5d77c854023eac88d9ffb" translate="yes" xml:space="preserve">
          <source>As with the</source>
          <target state="translated">Как и в случае с</target>
        </trans-unit>
        <trans-unit id="cd7300c50635cef829928b369e4af967b57015fd" translate="yes" xml:space="preserve">
          <source>As with the DB_HASH format, it is possible to provide a user defined Perl routine to perform the comparison of keys. By default, though, the keys are stored in lexical order.</source>
          <target state="translated">Как и в формате DB_HASH,для выполнения сравнения ключей можно предусмотреть рутину Perl,заданную пользователем.Однако по умолчанию ключи хранятся в лексическом порядке.</target>
        </trans-unit>
        <trans-unit id="69ca9bf5a86e0011eab25710aa599ffe7224ff94" translate="yes" xml:space="preserve">
          <source>As with the append mode, when you open a file in write-only mode, you can now write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Как и в режиме добавления, когда вы открываете файл в режиме только для записи, теперь вы можете писать в этот дескриптор файла, используя любой из &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a73b99d56aa400ec87ca02454010bfda953deea" translate="yes" xml:space="preserve">
          <source>As with the match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regexp and replacement are treated as single-quoted strings and there are no variable substitutions. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; in list context returns the same thing as in scalar context, i.e., the number of matches.</source>
          <target state="translated">Как и в случае с оператором match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; может использовать другие разделители, например &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt; , и даже &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt; . Если используются одинарные кавычки &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; , то регулярное выражение и замена обрабатываются как строки в одинарных кавычках и подстановки переменных отсутствуют. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; в контексте списка возвращает то же самое, что и в скалярном контексте, то есть количество совпадений.</target>
        </trans-unit>
        <trans-unit id="9cd8fd98a0003315162b3999969a156676702a25" translate="yes" xml:space="preserve">
          <source>As with the matching operator, the regexp quote can use different delimiters, e.g., &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt;. Apostrophes as delimiters (&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt;) inhibit any interpolation.</source>
          <target state="translated">Как и в случае с оператором сопоставления, в цитате регулярного выражения могут использоваться разные разделители, например &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt; . Апострофы как разделители ( &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt; ) запрещают любую интерполяцию.</target>
        </trans-unit>
        <trans-unit id="e11bb01f2bd8c076a80300f6980985d85bb41c1a" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. It may be appropriate to &quot;auto CLOSE&quot; when this occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">Как и в случае с другими типами привязок, этот метод будет вызываться, когда произойдет &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; . В этом случае может быть целесообразно &amp;laquo;автоматическое закрытие&amp;raquo;. См. &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;Раздел &amp;laquo;Развязка Gotcha&amp;raquo;&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="4d1c8cd71dac7105bd6440effb2807ea501bbea1" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when the tied handle is about to be destroyed. This is useful for debugging and possibly cleaning up.</source>
          <target state="translated">Как и в случае с другими типами связей,этот метод будет вызван,когда связанная рукоятка вот-вот будет уничтожена.Это полезно для отладки и возможной очистки.</target>
        </trans-unit>
        <trans-unit id="c8628e08c07475c8f2b1e6b9f5f0e7ba611079bf" translate="yes" xml:space="preserve">
          <source>As with the return stack, it would be possible (and a small performance win) to pre-extend the return array before pushing data into it, since we know how many elements we will return:</source>
          <target state="translated">Как и в случае со стеком возвратов,можно было бы (и небольшой выигрыш в производительности)предварительно расширить массив возвратов,прежде чем вставлять в него данные,так как мы знаем,сколько элементов мы вернем:</target>
        </trans-unit>
        <trans-unit id="3d4c99ea11e7c5fcd5dc736377914de3be4bac49" translate="yes" xml:space="preserve">
          <source>As with the shell, in Perl the &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; is used to open the file in read-only mode. If it succeeds, Perl allocates a brand new filehandle for you and fills in your previously undefined &lt;code&gt;$handle&lt;/code&gt; argument with a reference to that handle.</source>
          <target state="translated">Как и в случае с оболочкой, в Perl символ &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; используется для открытия файла в режиме только для чтения. Если это удается, Perl выделяет для вас новый дескриптор файла и заполняет ранее неопределенный аргумент &lt;code&gt;$handle&lt;/code&gt; ссылкой на этот дескриптор.</target>
        </trans-unit>
        <trans-unit id="7fd1e1a58893cf268ad48b11d78449c12dc31c5c" translate="yes" xml:space="preserve">
          <source>As you can see 3 records have been successfully created with key &lt;code&gt;Wall&lt;/code&gt; - the only thing is, when they are retrieved from the database they</source>
          <target state="translated">Как видите, 3 записи были успешно созданы с помощью key &lt;code&gt;Wall&lt;/code&gt; - единственное, что когда они извлекаются из базы данных, они</target>
        </trans-unit>
        <trans-unit id="07a24c035647250238dd385e01e0859319d79ee5" translate="yes" xml:space="preserve">
          <source>As you can see both modules have a broadly similar structure. They both make use of the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module and both have an &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method. The difference between them is that the</source>
          <target state="translated">Как видите, оба модуля имеют в целом похожую структуру. Оба они используют модуль &lt;code&gt;Filter::Util::Call&lt;/code&gt; и оба имеют метод &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; . Разница между ними в том, что</target>
        </trans-unit>
        <trans-unit id="8f994dc63d7341f367ad1cc1ffc63c6ff1af1973" translate="yes" xml:space="preserve">
          <source>As you can see in the synopsis, based on your template, the arguments provided will be validated.</source>
          <target state="translated">Как вы можете видеть в резюме,на основе вашего шаблона,предоставленные аргументы будут проверены.</target>
        </trans-unit>
        <trans-unit id="fc43df7357cab99ebecef48bb020a483deb5469e" translate="yes" xml:space="preserve">
          <source>As you can see,</source>
          <target state="translated">Как видите,</target>
        </trans-unit>
        <trans-unit id="ba5fcb84fa73471a91e0f59090740d9676a886a8" translate="yes" xml:space="preserve">
          <source>As you can see, a new stream has been created for reading the source from &lt;code&gt;Fred.pm&lt;/code&gt; . This stream will remain active until all of &lt;code&gt;Fred.pm&lt;/code&gt; has been parsed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; will still exist, but is inactive. Once the parser has finished reading Fred.pm, the source stream associated with it will be destroyed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; then becomes active again and the parser reads line 4 and subsequent lines from &lt;code&gt;cpp_test&lt;/code&gt; .</source>
          <target state="translated">Как вы можете видеть, новый поток был создан для чтения источника от &lt;code&gt;Fred.pm&lt;/code&gt; . Этот поток будет оставаться активным до тех пор, &lt;code&gt;Fred.pm&lt;/code&gt; не будет проанализирован весь Fred.pm. Исходный поток для &lt;code&gt;cpp_test&lt;/code&gt; все еще существует, но неактивен. Как только синтаксический анализатор закончит читать Fred.pm, связанный с ним исходный поток будет уничтожен. Исходный поток для &lt;code&gt;cpp_test&lt;/code&gt; затем снова становится активным, и анализатор читает строку 4 и последующие строки из &lt;code&gt;cpp_test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="413492c2aba459a109ff8cf8bd650d35b867bf30" translate="yes" xml:space="preserve">
          <source>As you can see, even though we parsed out a branch and a piece, it was ultimately only an atom. The final program shows us how things work. We have an &lt;code&gt;EXACT&lt;/code&gt; regop, followed by an &lt;code&gt;END&lt;/code&gt; regop. The number in parens indicates where the &lt;code&gt;regnext&lt;/code&gt; of the node goes. The &lt;code&gt;regnext&lt;/code&gt; of an &lt;code&gt;END&lt;/code&gt; regop is unused, as &lt;code&gt;END&lt;/code&gt; regops mean we have successfully matched. The number on the left indicates the position of the regop in the regnode array.</source>
          <target state="translated">Как видите, даже если мы разобрали ветвь и кусок, в конечном итоге это был всего лишь атом. Последняя программа показывает нам, как все работает. У нас есть &lt;code&gt;EXACT&lt;/code&gt; regop, а затем с помощью &lt;code&gt;END&lt;/code&gt; regop. Число в скобках указывает, куда &lt;code&gt;regnext&lt;/code&gt; узла. &lt;code&gt;regnext&lt;/code&gt; из &lt;code&gt;END&lt;/code&gt; regop не используется, так как &lt;code&gt;END&lt;/code&gt; regops означает , что мы успешно согласованы. Число слева указывает позицию regop в массиве regnode.</target>
        </trans-unit>
        <trans-unit id="a413e2eb7d932038f9ab1ac09695763b902b4d80" translate="yes" xml:space="preserve">
          <source>As you can see, it's getting a bit complicated. That's why sometimes is easier to take a temporary on your way through:</source>
          <target state="translated">Как видите,все немного усложняется.Вот почему иногда легче взять временный на себя:</target>
        </trans-unit>
        <trans-unit id="3fa1293b0c00ad3a76c1e01bf182a9e2122f9fdc" translate="yes" xml:space="preserve">
          <source>As you can see, the &quot;big end&quot; of the arrow touches the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is a nice way to remember that &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier. The same obviously works for &lt;code&gt;&amp;lt;&lt;/code&gt; , where the &quot;little end&quot; touches the code.</source>
          <target state="translated">Как видите, &amp;laquo;большой конец&amp;raquo; стрелки касается символа &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , что является хорошим способом запомнить, что &lt;code&gt;&amp;gt;&lt;/code&gt; - это модификатор прямого порядка байтов. То же самое, очевидно, работает для &lt;code&gt;&amp;lt;&lt;/code&gt; , где &quot;конец&quot; касается кода.</target>
        </trans-unit>
        <trans-unit id="8d3da9040412695027bfa4b6fb728646046f3571" translate="yes" xml:space="preserve">
          <source>As you can see, the continuation bytes all begin with &lt;code&gt;&quot;10&quot;&lt;/code&gt; , and the leading bits of the start byte tell how many bytes there are in the encoded character.</source>
          <target state="translated">Как вы можете видеть, все байты продолжения начинаются с &lt;code&gt;&quot;10&quot;&lt;/code&gt; , а ведущие биты начального байта говорят, сколько байтов содержится в закодированном символе.</target>
        </trans-unit>
        <trans-unit id="3abefb49e57cec4dd056d885964fc7e8cddbabc0" translate="yes" xml:space="preserve">
          <source>As you can see, we've stored the path and file data in the object itself. Remember, under the hood, this object is still just a hash. Later, we'll write accessors to manipulate this data.</source>
          <target state="translated">Как видите,мы сохранили данные о пути и файле в самом объекте.Помните,что под капотом этот объект все еще просто хэш.Позже мы запишем аксессуары,чтобы манипулировать этими данными.</target>
        </trans-unit>
        <trans-unit id="5a6344bf7b33dbff5320cfc2c10a629a29808655" translate="yes" xml:space="preserve">
          <source>As you can tell from a glance at &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;, the L&amp;lt;...&amp;gt; code is the most complex of the Pod formatting codes. The points below will hopefully clarify what it means and how processors should deal with it.</source>
          <target state="translated">Как вы можете понять с &lt;a href=&quot;perlpod&quot;&gt;первого&lt;/a&gt; взгляда на perlpod , код L &amp;lt;...&amp;gt; является наиболее сложным из кодов форматирования Pod. Мы надеемся, что приведенные ниже пункты прояснят, что это означает и как обработчики должны с этим справляться.</target>
        </trans-unit>
        <trans-unit id="9261097e2916c2cc0f66dd44d4a942cdcbac0f6d" translate="yes" xml:space="preserve">
          <source>As you craft each patch you intend to submit to the Perl core, it's important to write a good commit message. This is especially important if your submission will consist of a series of commits.</source>
          <target state="translated">По мере того,как вы создаёте каждый патч,который вы собираетесь отправить в ядро Perl,важно написать хорошее сообщение о коммите.Это особенно важно,если ваша заявка будет состоять из серии коммитов.</target>
        </trans-unit>
        <trans-unit id="585d50527e778d78ffa867804e8d6039ce87d004" translate="yes" xml:space="preserve">
          <source>As you may have inferred from the above documentation and examples, &lt;code&gt;ok&lt;/code&gt; 's prototype is &lt;code&gt;($;$$)&lt;/code&gt; (and, incidentally, &lt;code&gt;skip&lt;/code&gt; 's is &lt;code&gt;($;$$$)&lt;/code&gt;). This means, for example, that you can do &lt;code&gt;ok @foo, @bar&lt;/code&gt; to compare the</source>
          <target state="translated">Как вы могли догадаться из приведенной выше документации и примеров, прототип &lt;code&gt;ok&lt;/code&gt; - &lt;code&gt;($;$$)&lt;/code&gt; (и, кстати, &lt;code&gt;skip&lt;/code&gt; - &lt;code&gt;($;$$$)&lt;/code&gt; ). Это означает, например, что вы можете сделать &lt;code&gt;ok @foo, @bar&lt;/code&gt; чтобы сравнить</target>
        </trans-unit>
        <trans-unit id="d3a79c79e4e5a9fafc42ddaaf88736c1e2cc7621" translate="yes" xml:space="preserve">
          <source>As you may have noticed, the name of the FETCH method (et al.) is the same for all accesses, even though the constructors differ in names (TIESCALAR vs TIEARRAY). While in theory you could have the same class servicing several tied types, in practice this becomes cumbersome, and it's easiest to keep them at simply one tie type per class.</source>
          <target state="translated">Как вы,возможно,заметили,название метода FETCH (и др.)одинаково для всех обращений,даже несмотря на то,что конструкторы различаются названиями (TIESCALAR vs TIEARRAY).В то время как в теории можно было бы иметь один и тот же класс,обслуживающий несколько связанных типов,на практике это становится громоздким,и проще всего удержать их на одном связанном типе в каждом классе.</target>
        </trans-unit>
        <trans-unit id="e80271d1fdc3feb0460f1e3a1704fc272e31f101" translate="yes" xml:space="preserve">
          <source>As you might know this calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function of &lt;code&gt;attributes&lt;/code&gt; at compile time with these parameters: 'attributes', the caller's package name, the reference to the code and 'method'.</source>
          <target state="translated">Как вы, возможно, знаете, это вызывает функцию &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; &lt;code&gt;attributes&lt;/code&gt; во время компиляции со следующими параметрами: &amp;laquo;атрибуты&amp;raquo;, имя пакета вызывающей стороны, ссылка на код и &amp;laquo;метод&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0f14d6a62a3d5dfc412b082b83700a2aa2b31479" translate="yes" xml:space="preserve">
          <source>As you see from those examples, &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt; are output handles, and &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;ARGV&lt;/code&gt; are input handles. They are in all capital letters because they are reserved to Perl, much like the &lt;code&gt;@ARGV&lt;/code&gt; array and the &lt;code&gt;%ENV&lt;/code&gt; hash are. Their external associations were set up by your shell.</source>
          <target state="translated">Как видно из этих примеров, &lt;code&gt;STDOUT&lt;/code&gt; и &lt;code&gt;STDERR&lt;/code&gt; - дескрипторы вывода, а &lt;code&gt;STDIN&lt;/code&gt; и &lt;code&gt;ARGV&lt;/code&gt; - дескрипторы ввода. Они &lt;code&gt;@ARGV&lt;/code&gt; заглавными буквами, потому что они зарезервированы для Perl, как и массив @ARGV и хеш &lt;code&gt;%ENV&lt;/code&gt; . Их внешние ассоциации были созданы вашей оболочкой.</target>
        </trans-unit>
        <trans-unit id="e27f616d9e27793d35d5e898cb0fead7ca633114" translate="yes" xml:space="preserve">
          <source>As you see, it's quite easy to become confused. While some small portion of the blame for this can be attributed to the reference-based implementation, it's really more due to a lack of existing documentation with examples designed for the beginner.</source>
          <target state="translated">Как видите,довольно легко запутаться.Хотя небольшая часть вины за это может быть приписана реализации,основанной на ссылках,на самом деле это в большей степени связано с отсутствием существующей документации с примерами,разработанными для новичка.</target>
        </trans-unit>
        <trans-unit id="512c5953fca52adf9fe503c69215e4eb2353e34b" translate="yes" xml:space="preserve">
          <source>As you see, it's remarkably similar to the Internet domain TCP server, so much so, in fact, that we've omitted several duplicate functions--spawn(), logmsg(), ctime(), and REAPER()--which are the same as in the other server.</source>
          <target state="translated">Как видите,он удивительно похож на TCP-сервер домена Интернет,настолько,что мы опустили несколько дублирующих функций -spawn(),logmsg(),ctime()и REAPER()-которые такие же,как и на другом сервере.</target>
        </trans-unit>
        <trans-unit id="ea8178cd8e63a3e66a311fade3362af15d43aa5f" translate="yes" xml:space="preserve">
          <source>As you see, the name of the package is the name of the structure. Regular fields are just their own names. Plus the following accessor functions are provided for your convenience:</source>
          <target state="translated">Как видите,название пакета-это название структуры.Обычные поля-это только их собственные имена.Кроме того,для вашего удобства предусмотрены следующие функции аксессуара:</target>
        </trans-unit>
        <trans-unit id="b457b60332a38dcdc3bc2fb765fda15f087f9402" translate="yes" xml:space="preserve">
          <source>As you see, there is one exception: in ASCII. That way you can assume Goal #1. And with &lt;code&gt;Encode&lt;/code&gt; , Goal #2 is assumed but you still have to be careful in the cases mentioned in the &lt;b&gt;CAVEAT&lt;/b&gt; paragraphs above.</source>
          <target state="translated">Как видите, есть одно исключение: в ASCII. Таким образом, вы можете принять цель №1. А с &lt;code&gt;Encode&lt;/code&gt; предполагается цель №2, но вы все равно должны быть осторожны в случаях, упомянутых в параграфах &lt;b&gt;CAVEAT&lt;/b&gt; выше.</target>
        </trans-unit>
        <trans-unit id="7cc089f777993943781491fc9a72f85a9a2f245b" translate="yes" xml:space="preserve">
          <source>As you see, this can be a bit tricky. It's important to realize that a regular expression is merely a set of assertions that gives a definition of success. There may be 0, 1, or several different ways that the definition might succeed against a particular string. And if there are multiple ways it might succeed, you need to understand backtracking to know which variety of success you will achieve.</source>
          <target state="translated">Как видите,это может быть немного сложно.Важно понимать,что регулярное выражение-это всего лишь набор утверждений,дающих определение успеху.Может быть 0,1,или несколько различных способов,чтобы определение могло иметь успех в отношении конкретной строки.А если есть несколько способов,то для того,чтобы понять,какое разнообразие будет иметь успех,нужно понимать,что нужно идти на попятную.</target>
        </trans-unit>
        <trans-unit id="f1ce088efa2db68e2d881f71961d1904be5d37ad" translate="yes" xml:space="preserve">
          <source>As you would expect, this modifier causes, for example, &lt;code&gt;\D&lt;/code&gt; to mean the same thing as &lt;code&gt;[^0-9]&lt;/code&gt; ; in fact, all non-ASCII characters match &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , and &lt;code&gt;\W&lt;/code&gt; . &lt;code&gt;\b&lt;/code&gt; still means to match at the boundary between &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\W&lt;/code&gt; , using the &lt;code&gt;/a&lt;/code&gt; definitions of them (similarly for &lt;code&gt;\B&lt;/code&gt; ).</source>
          <target state="translated">Как и следовало ожидать, этот модификатор приводит, например, к тому, что &lt;code&gt;\D&lt;/code&gt; означает то же, что и &lt;code&gt;[^0-9]&lt;/code&gt; ; на самом деле, все символы не-ASCII соответствует &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , и &lt;code&gt;\W&lt;/code&gt; . &lt;code&gt;\b&lt;/code&gt; прежнему означает совпадение на границе между &lt;code&gt;\w&lt;/code&gt; и &lt;code&gt;\W&lt;/code&gt; , используя &lt;code&gt;/a&lt;/code&gt; определения / a (аналогично для &lt;code&gt;\B&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="26154301b1350500c1d0c8c752bea63ea6529192" translate="yes" xml:space="preserve">
          <source>As you're writing an application, you decide as you go what messages you need to emit. Normally you'd go to write this:</source>
          <target state="translated">По мере написания приложения вы решаете,какие сообщения вам нужно отправить.Обычно вы идете,чтобы написать это:</target>
        </trans-unit>
        <trans-unit id="94a73ad4a31e87483d1616b8954f4b6c0ff428df" translate="yes" xml:space="preserve">
          <source>As you've seen, you can force &lt;code&gt;catdir()&lt;/code&gt; to create an absolute path by passing either an empty string or a path that begins with a volume name as the first argument. However, you are strongly encouraged not to do so, since this is done only for backward compatibility. Newer versions of File::Spec come with a method called &lt;code&gt;catpath()&lt;/code&gt; (see below), that is designed to offer a portable solution for the creation of absolute paths. It takes volume, directory and file portions and returns an entire path. While &lt;code&gt;catdir()&lt;/code&gt; is still suitable for the concatenation of</source>
          <target state="translated">Как вы видели, вы можете заставить &lt;code&gt;catdir()&lt;/code&gt; создать абсолютный путь, передав либо пустую строку, либо путь, который начинается с имени тома в качестве первого аргумента. Однако настоятельно рекомендуется не делать этого, поскольку это сделано только для обратной совместимости. Новые версии File :: Spec поставляются с методом &lt;code&gt;catpath()&lt;/code&gt; (см. Ниже), который разработан, чтобы предложить переносимое решение для создания абсолютных путей. Он берет части тома, каталога и файла и возвращает полный путь. Хотя &lt;code&gt;catdir()&lt;/code&gt; по-прежнему подходит для конкатенации</target>
        </trans-unit>
        <trans-unit id="a173e725607d0f98c78ebac0b31138d8d136aa84" translate="yes" xml:space="preserve">
          <source>Asia</source>
          <target state="translated">Asia</target>
        </trans-unit>
        <trans-unit id="f22fac8ac4e191689a82159394064af8e931487a" translate="yes" xml:space="preserve">
          <source>Aside from an experimental facility (see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below), Perl does not have named formal parameters. In practice all you do is assign to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; list of these. Variables that aren't declared to be private are global variables. For gory details on creating private variables, see &lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;Private Variables via my()&lt;/a&gt; and &lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;Temporary Values via local()&lt;/a&gt;. To create protected environments for a set of functions in a separate package (and probably a separate file), see &lt;a href=&quot;perlmod#Packages&quot;&gt;Packages in perlmod&lt;/a&gt;.</source>
          <target state="translated">Помимо экспериментальной установки (см. &lt;a href=&quot;#Signatures&quot;&gt;Сигнатуры&lt;/a&gt; ниже), Perl не имеет именованных формальных параметров. На практике все, что вам нужно сделать, это назначить их списку &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; . Переменные, которые не объявлены как частные, являются глобальными переменными. Подробные сведения о создании частных переменных см. &lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;В разделах &amp;laquo;Частные переменные через my ()&amp;raquo;&lt;/a&gt; и &amp;laquo; &lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;Временные значения через local ()&amp;raquo;&lt;/a&gt; . Чтобы создать защищенную среду для набора функций в отдельном пакете (и, возможно, в отдельном файле), см. &lt;a href=&quot;perlmod#Packages&quot;&gt;Пакеты в perlmod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0befd0a8afa8c19a870d175a4fdb840002143042" translate="yes" xml:space="preserve">
          <source>Ask it to create new Perl executable:</source>
          <target state="translated">Попросите его создать новый исполняемый файл Perl:</target>
        </trans-unit>
        <trans-unit id="06d5ff26b7db3df6b27e4da48afc0d8940af7b07" translate="yes" xml:space="preserve">
          <source>Ask the current maintainer to make you a co-maintainer or transfer the module to you.</source>
          <target state="translated">Попросите текущего мейнтейнера сделать вас со-монтажником или передать модуль вам.</target>
        </trans-unit>
        <trans-unit id="640918b79c5c24d060028d2fd27fecdba24558af" translate="yes" xml:space="preserve">
          <source>Ask the server for &quot;helpful information&quot; (that's what the RFC says) on the commands it accepts.</source>
          <target state="translated">Спросите у сервера &quot;полезную информацию&quot; (так говорит КСФ)о командах,которые он принимает.</target>
        </trans-unit>
        <trans-unit id="29957267ee0cac223134add5f2b52ea620705c23" translate="yes" xml:space="preserve">
          <source>Ask them for it. There are so many email providers available that it's unlikely the local system has any idea how to determine a user's email address.</source>
          <target state="translated">Спроси их об этом.Доступно столько провайдеров электронной почты,что вряд ли локальная система имеет представление о том,как определить адрес электронной почты пользователя.</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="00331b7ae6edef1dff40c7175d1e39fd7f33aa69" translate="yes" xml:space="preserve">
          <source>Assertions are conditions that have to be true; they don't actually match parts of the substring. There are six assertions that are written as backslash sequences.</source>
          <target state="translated">Утверждения являются условиями,которые должны быть правдой;на самом деле они не соответствуют части подстроки.Существует шесть утверждений,которые записываются как последовательности обратного слеша.</target>
        </trans-unit>
        <trans-unit id="bc266cdcbb6ece4821fb3ad4912b26e12d68bda4" translate="yes" xml:space="preserve">
          <source>Assigning Magic</source>
          <target state="translated">Назначение Магия</target>
        </trans-unit>
        <trans-unit id="5758c53717d47b26aecb2f1e95a4e608692a5e69" translate="yes" xml:space="preserve">
          <source>Assigning and Dereferencing Variables.</source>
          <target state="translated">Назначение и разыменование переменных.</target>
        </trans-unit>
        <trans-unit id="d524a6069dcf850237db76c5b77de165e1b358ee" translate="yes" xml:space="preserve">
          <source>Assigning to References</source>
          <target state="translated">Назначение на Ссылки</target>
        </trans-unit>
        <trans-unit id="c279a061dbc31dc7bee97d46022b90f62667a4ac" translate="yes" xml:space="preserve">
          <source>Assigning to a list of private variables to name your arguments:</source>
          <target state="translated">Присвоение списка приватных переменных для именования ваших аргументов:</target>
        </trans-unit>
        <trans-unit id="5095fe9fb68e9a62edc8c9686322a7856091bd87" translate="yes" xml:space="preserve">
          <source>Assigning to an entry in the hash will cause the time stamps of the file to be modified. If the file does not exist then it will be created. Assigning a single integer to a hash element will cause both the access and modification times to be changed to that value. Alternatively a reference to an array of two values can be passed. The first array element will be used to set the access time and the second element will be used to set the modification time.</source>
          <target state="translated">Присвоение записи в хэше приведет к изменению временных меток файла.Если файл не существует,то он будет создан.Присвоение одному целому числу элемента хэша приведет к изменению как времени доступа,так и времени модификации на это значение.В качестве альтернативы может быть передана ссылка на массив из двух значений.Первый элемент массива будет использоваться для установки времени доступа,а второй элемент-для установки времени модификации.</target>
        </trans-unit>
        <trans-unit id="7ca1018fbacf1aa9c5974935df5ed892f5691b8b" translate="yes" xml:space="preserve">
          <source>Assigning to the special variable $[</source>
          <target state="translated">Присвоение специальной переменной $[</target>
        </trans-unit>
        <trans-unit id="7bec00ae67953bf63f8b1b3f8ddf8f9255f79d82" translate="yes" xml:space="preserve">
          <source>Assignment Operators</source>
          <target state="translated">Назначенные операторы</target>
        </trans-unit>
        <trans-unit id="91becff514df4bb52422a8c72ad2fa7e138a09c4" translate="yes" xml:space="preserve">
          <source>Assignment is a little bit special in that it uses its left argument to determine the context for the right argument. Assignment to a scalar evaluates the right-hand side in scalar context, while assignment to an array or hash evaluates the righthand side in list context. Assignment to a list (or slice, which is just a list anyway) also evaluates the right-hand side in list context.</source>
          <target state="translated">Присвоение немного особенное в том,что оно использует свой левый аргумент для определения контекста для правого аргумента.Присвоение скаляру оценивает правую сторону в контексте скаляра,в то время как присвоение массиву или хэшу оценивает правую сторону в контексте списка.Присвоение списку (или срезу,который в любом случае является просто списком)также оценивает правую сторону в контексте списка.</target>
        </trans-unit>
        <trans-unit id="eeb7b7ef33aeb4c3b9e41b0d3c8c37efe141de32" translate="yes" xml:space="preserve">
          <source>Assignment operators work as in C. That is,</source>
          <target state="translated">Назначенные операторы работают как в C.То есть..,</target>
        </trans-unit>
        <trans-unit id="e44ee3c1149f2c21100b91bdf4ef60fbcf7575f3" translate="yes" xml:space="preserve">
          <source>Assignment to a typeglob performs an aliasing operation, i.e.,</source>
          <target state="translated">Назначение на печатный шрифт выполняет операцию наложения псевдонима,т.е,</target>
        </trans-unit>
        <trans-unit id="101d3fe15227197bfb043f8902c240196099b710" translate="yes" xml:space="preserve">
          <source>Assignment to references and non-references may be combined in lists and conditional ternary expressions, as long as the values on the right-hand side are the right type for each element on the left, though this may make for obfuscated code:</source>
          <target state="translated">Присвоение ссылок и не ссылок может быть объединено в списках и условных тернарных выражениях,при условии,что значения справа являются правым типом для каждого элемента слева,хотя это может привести к обфусцированному коду:</target>
        </trans-unit>
        <trans-unit id="38be444e6e51033245feebeecd19c780a4190e4e" translate="yes" xml:space="preserve">
          <source>Associated with the matching variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... are the &lt;b&gt;backreferences&lt;/b&gt;&lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; , ... Backreferences are matching variables that can be used</source>
          <target state="translated">Связанный с переменным соответствием &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... являются &lt;b&gt;обратные_связь &lt;/b&gt; &lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; , ... Обратные являются соответствующим переменными , которые могут быть использованы</target>
        </trans-unit>
        <trans-unit id="6addecb62c84d829e48e459ba05882e03a175023" translate="yes" xml:space="preserve">
          <source>Assume &lt;b&gt;anything&lt;/b&gt; about structs (especially the ones you don't control, like the ones coming from the system headers)</source>
          <target state="translated">Предполагайте &lt;b&gt;что-нибудь&lt;/b&gt; о структурах (особенно о тех, которые вы не контролируете, например о тех, которые поступают из системных заголовков)</target>
        </trans-unit>
        <trans-unit id="9e766ffb9a2f9804774162774bb465b7a888d65a" translate="yes" xml:space="preserve">
          <source>Assume each sentence ends with two spaces and try to preserve that spacing. Without this option, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space.</source>
          <target state="translated">Предположим,что каждое предложение заканчивается двумя пробелами и постараемся сохранить это расстояние.Без этой опции все последовательные пробелы в невербатичных абзацах сжимаются в один пробел.</target>
        </trans-unit>
        <trans-unit id="eb29cb4a3a64a3e55d8f8b66fc5429f33cc90a54" translate="yes" xml:space="preserve">
          <source>Assume four classes, A,B,C &amp;amp; D.</source>
          <target state="translated">Предположим, что четыре класса: A, B, C и D.</target>
        </trans-unit>
        <trans-unit id="900f642b83bb773e589683695c3e83ec1e64d87c" translate="yes" xml:space="preserve">
          <source>Assume nothing about numerical values (&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;) of characters. Do not use explicit code point ranges (like &lt;code&gt;\xHH-\xHH)&lt;/code&gt; . However, starting in Perl v5.22, regular expression pattern bracketed character class ranges specified like &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; are portable. You can portably use symbolic character classes like &lt;code&gt;[:print:]&lt;/code&gt;.</source>
          <target state="translated">Ничего не предполагайте о числовых значениях ( &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ) символов. Не используйте явные диапазоны кодовых точек (например, &lt;code&gt;\xHH-\xHH)&lt;/code&gt; . Однако, начиная с Perl v5.22, диапазоны классов символов в квадратных скобках шаблона регулярного выражения, указанные как &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; , переносимы. Вы можете переносимо использовать символьные классы символов, такие как &lt;code&gt;[:print:]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d225542d9c39b42f29197a0ce47f62fa7382a5c0" translate="yes" xml:space="preserve">
          <source>Assume that an integer cannot take less than 20 bytes of memory, a float cannot take less than 24 bytes, a string cannot take less than 32 bytes (all these examples assume 32-bit architectures, the result are quite a bit worse on 64-bit architectures). If a variable is accessed in two of three different ways (which require an integer, a float, or a string), the memory footprint may increase yet another 20 bytes. A sloppy malloc(3) implementation can inflate these numbers dramatically.</source>
          <target state="translated">Предположим,что целое число не может занимать менее 20 байт памяти,флот не может занимать менее 24 байт,строка не может занимать менее 32 байт (все эти примеры предполагают 32-битные архитектуры,на 64-битных архитектурах результат значительно хуже).Если доступ к переменной осуществляется двумя из трех различных способов (для чего требуется целое число,плавающий диск или строка),то объем памяти может увеличиться еще на 20 байт.Неаккуратная реализация malloc(3)может резко раздуть эти числа.</target>
        </trans-unit>
        <trans-unit id="5cf62705d74f3464ae65764bb487f8249da94d46" translate="yes" xml:space="preserve">
          <source>Assume that the old DLL is named</source>
          <target state="translated">Предположим,что старую DLL называют</target>
        </trans-unit>
        <trans-unit id="2605c8584b04c7bf0a2b7cc3badf48edb3bf06d0" translate="yes" xml:space="preserve">
          <source>Assume that you are a seasoned porter, so are sure that all the necessary tools are already present on your system, and you know how to get the Perl source distribution. Untar it, change to the extract directory, and</source>
          <target state="translated">Предположим,что вы опытный портер,так что будьте уверены,что все необходимые инструменты уже есть в вашей системе,и вы знаете,как получить дистрибутив исходников Perl.Используйте его,перейдите в каталог извлечения,и</target>
        </trans-unit>
        <trans-unit id="aa1c680a74a55225e27707c2ac5fffa720c70f93" translate="yes" xml:space="preserve">
          <source>Assume this TAP version for &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; instead of default TAP version 12.</source>
          <target state="translated">Предположим, что эта версия TAP для &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; вместо версии TAP по умолчанию 12.</target>
        </trans-unit>
        <trans-unit id="7fc8664d84c1446907ca24dadecd0bd664e1d82d" translate="yes" xml:space="preserve">
          <source>Assume very little about character sets.</source>
          <target state="translated">Очень мало думайте о наборах персонажей.</target>
        </trans-unit>
        <trans-unit id="2b3c42e666c3f46061cf3e08ae5f736db9c6b58e" translate="yes" xml:space="preserve">
          <source>Assumes that PL_op is the op that originally triggered the error, and that PL_comppad/PL_curpad points to the currently executing pad.</source>
          <target state="translated">Предположительно,PL_op является операцией,которая изначально спровоцировала ошибку,и что PL_comppad/PL_curpad указывает на текущий исполняющий блокнот.</target>
        </trans-unit>
        <trans-unit id="85a92465c7801a7593ae125acb124d7a78d00d62" translate="yes" xml:space="preserve">
          <source>Assuming one can dereference any type of pointer for any type of data</source>
          <target state="translated">Предполагая,что для любого типа данных можно разыменовать любой тип указателя.</target>
        </trans-unit>
        <trans-unit id="3eba801518ac20c3e71b66588e69e8412d142226" translate="yes" xml:space="preserve">
          <source>Assuming sizeof(int) == sizeof(long)</source>
          <target state="translated">Предположим sizeof(int)==sizeof(long)</target>
        </trans-unit>
        <trans-unit id="3b4336515b2aaf87ea7abdf5569d5fbbc17ae08d" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;man&lt;/code&gt; -files were put on an appropriate location, this completes the installation of minimal Perl system. (The binary distribution contains also a lot of additional modules, and the documentation in INF format.)</source>
          <target state="translated">Если предположить, что файлы &lt;code&gt;man&lt;/code&gt; были размещены в соответствующем месте, это завершает установку минимальной системы Perl. (Бинарный дистрибутив также содержит множество дополнительных модулей и документацию в формате INF.)</target>
        </trans-unit>
        <trans-unit id="1b3d48dcc2393b6165f22e974c8fe37cb11cfa92" translate="yes" xml:space="preserve">
          <source>Assuming that we have to match calendar dates which may be given in one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write three suitable patterns where we use 'd', 'm' and 'y' respectively as the names of the groups capturing the pertaining components of a date. The matching operation combines the three patterns as alternatives:</source>
          <target state="translated">Предполагая,что мы должны сопоставить календарные даты,которые могут быть даны в одном из трех форматов yyyy-mm-dd,mm/dd/yyyy или dd.mm.yyyy,мы можем написать три подходящих шаблона,в которых мы используем 'd','m' и 'y' соответственно в качестве названий групп,захватывающих соответствующие компоненты даты.Операция совмещения объединяет эти три шаблона в качестве альтернативы:</target>
        </trans-unit>
        <trans-unit id="0518d034f096809ab863fb80241126fe45a3c2bb" translate="yes" xml:space="preserve">
          <source>Assuming that you don't care about IEEE notations like &quot;NaN&quot; or &quot;Infinity&quot;, you probably just want to use a regular expression:</source>
          <target state="translated">Если предположить,что вас не волнуют такие нотации IEEE,как &quot;NaN&quot; или &quot;Infinity&quot;,вы,вероятно,просто хотите использовать регулярное выражение:</target>
        </trans-unit>
        <trans-unit id="c5c2ab31ddb2d4e68552f61633bf186e98613579" translate="yes" xml:space="preserve">
          <source>Assuming the character set is ASCIIish</source>
          <target state="translated">Предположим,что набор символов ASCIIish</target>
        </trans-unit>
        <trans-unit id="657e33b27d387873c824a6e9282e0d4e22ed782e" translate="yes" xml:space="preserve">
          <source>Assuming the character set is just ASCII</source>
          <target state="translated">Предполагая,что набор символов просто ASCII.</target>
        </trans-unit>
        <trans-unit id="7e0c2159a115b592c79f24b1d84f43c005948de3" translate="yes" xml:space="preserve">
          <source>Assuming the contents of static memory pointed to by the return values of Perl wrappers for C library functions doesn't change. Many C library functions return pointers to static storage that can be overwritten by subsequent calls to the same or related functions. Perl has light-weight wrappers for some of these functions, and which don't make copies of the static memory. A good example is the interface to the environment variables that are in effect for the program. Perl has &lt;code&gt;PerlEnv_getenv&lt;/code&gt; to get values from the environment. But the return is a pointer to static memory in the C library. If you are using the value to immediately test for something, that's fine, but if you save the value and expect it to be unchanged by later processing, you would be wrong, but perhaps you wouldn't know it because different C library implementations behave differently, and the one on the platform you're testing on might work for your situation. But on some platforms, a subsequent call to &lt;code&gt;PerlEnv_getenv&lt;/code&gt; or related function WILL overwrite the memory that your first call points to. This has led to some hard-to-debug problems. Do a &lt;a href=&quot;perlapi#savepv&quot;&gt;savepv in perlapi&lt;/a&gt; to make a copy, thus avoiding these problems. You will have to free the copy when you're done to avoid memory leaks. If you don't have control over when it gets freed, you'll need to make the copy in a mortal scalar, like so:</source>
          <target state="translated">Предполагая, что содержимое статической памяти, на которую указывают возвращаемые значения оболочек Perl для функций библиотеки C, не изменяется. Многие функции библиотеки C возвращают указатели на статическое хранилище, которое может быть перезаписано последующими вызовами тех же или связанных функций. Perl имеет легкие оболочки для некоторых из этих функций, которые не создают копий статической памяти. Хорошим примером является интерфейс переменных среды, действующих в программе. Perl имеет &lt;code&gt;PerlEnv_getenv&lt;/code&gt; получать ценности из окружающей среды. Но возврат - это указатель на статическую память в библиотеке C. Если вы используете значение для немедленной проверки чего-либо, это нормально, но если вы сохраните значение и ожидаете, что оно не изменится при последующей обработке, вы ошибетесь, но, возможно, вы этого не узнаете, потому что разные реализации библиотеки C ведут себя по-другому, и тот, который находится на платформе, на которой вы тестируете, может работать в вашей ситуации. Но на некоторых платформах последующий вызов &lt;code&gt;PerlEnv_getenv&lt;/code&gt; или связанной функции БУДЕТ перезаписывать память, на которую указывает ваш первый вызов. Это привело к возникновению некоторых трудных для отладки проблем. Сделайте &lt;a href=&quot;perlapi#savepv&quot;&gt;сохранение pv в perlapi&lt;/a&gt;сделать копию, чтобы избежать этих проблем. Когда вы закончите, вам придется освободить копию, чтобы избежать утечки памяти. Если у вас нет контроля над тем, когда он будет освобожден, вам нужно будет сделать копию в смертном скаляре, например:</target>
        </trans-unit>
        <trans-unit id="3368b5431ec704ea21f8185fe92770b3b042af71" translate="yes" xml:space="preserve">
          <source>Assuming the database from the previous example:</source>
          <target state="translated">Предполагая базу данных из предыдущего примера:</target>
        </trans-unit>
        <trans-unit id="37f2465394b9cbdd91947c6e4e077a7d4b7dde8a" translate="yes" xml:space="preserve">
          <source>Assuming they are to behave analogously to Perl's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; , overloaded implementations of these operators are required to mutate their operands.</source>
          <target state="translated">Предполагая, что они должны вести себя аналогично Perl &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; , перегруженные реализации этих операторов должны изменять свои операнды.</target>
        </trans-unit>
        <trans-unit id="23383c34471c75b25927cfad7162ad1979bea49b" translate="yes" xml:space="preserve">
          <source>Assuming you call your class Projname::L10N, create a class consisting minimally of:</source>
          <target state="translated">Предположив,что вы называете свой класс Projname::L10N,создайте класс,состоящий минимально из:</target>
        </trans-unit>
        <trans-unit id="a8c3ccec4be1ea177d36a955790696ae747518f7" translate="yes" xml:space="preserve">
          <source>Assuming you have good test coverage, your tests should fail with missing dependencies informing the user more strongly that something is wrong. You can write a</source>
          <target state="translated">Если предположить,что у вас хорошее тестовое покрытие,то ваши тесты должны давать сбой с отсутствующими зависимостями,сообщающими пользователю сильнее о том,что что-то не так.Вы можете написать</target>
        </trans-unit>
        <trans-unit id="562091b17215c5d2dabd5a6d27106f5a063623cd" translate="yes" xml:space="preserve">
          <source>Assuming you know you're dealing with a UTF-8 string, you can find out how long the first character in it is with the &lt;code&gt;UTF8SKIP&lt;/code&gt; macro:</source>
          <target state="translated">Предполагая, что вы знаете, что имеете дело со строкой UTF-8, вы можете узнать, какой длины первый символ в ней, с &lt;code&gt;UTF8SKIP&lt;/code&gt; макроса UTF8SKIP :</target>
        </trans-unit>
        <trans-unit id="9da798a9d5da7f2f9d9ef9e1b52ebf21c8c17dc7" translate="yes" xml:space="preserve">
          <source>Assuming you're running under sufficient permissions, you should be able to set the system-wide date and time by running the &lt;code&gt;date(1)&lt;/code&gt; program. (There is no way to set the time and date on a per-process basis.) This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">Предполагая, что вы работаете с достаточными разрешениями, вы сможете установить общесистемную дату и время, запустив программу &lt;code&gt;date(1)&lt;/code&gt; . (Невозможно установить время и дату для каждого процесса.) Этот механизм будет работать для Unix, MS-DOS, Windows и NT; эквивалент VMS - &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a50f834fa5c7b73ada293aca740d6156afc09752" translate="yes" xml:space="preserve">
          <source>Assuming your system supports such things, just send an appropriate signal to the process (see &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;). It's common to first send a TERM signal, wait a little bit, and then send a KILL signal to finish it off.</source>
          <target state="translated">Предполагая, что ваша система поддерживает такие вещи, просто отправьте соответствующий сигнал процессу (см. &lt;a href=&quot;functions/kill&quot;&gt;Kill&lt;/a&gt; ). Обычно сначала отправляют сигнал TERM, немного подождите, а затем отправляют сигнал KILL, чтобы завершить его.</target>
        </trans-unit>
        <trans-unit id="a34c6deba477e26d8810a3f5cd4114d33aa1e300" translate="yes" xml:space="preserve">
          <source>At 10:23, this function generates the 10th line of a data file; at 3:45 PM it generates the 15th line instead. By default, &lt;code&gt;Memoize&lt;/code&gt; will only see the $problem_type argument. To fix this, include the current hour in the normalizer:</source>
          <target state="translated">В 10:23 эта функция генерирует 10-ю строку файла данных; в 15:45 вместо этого генерируется 15-я строка. По умолчанию &lt;code&gt;Memoize&lt;/code&gt; будет видеть только аргумент $ problem_type. Чтобы исправить это, включите текущий час в нормализатор:</target>
        </trans-unit>
        <trans-unit id="0d3035d43f34a8f68a2af535ff4afe837cc1bf23" translate="yes" xml:space="preserve">
          <source>At a given character position, the first alternative that allows the regex match to succeed will be the one that matches. Here, all the alternatives match at the first string position, so the first matches.</source>
          <target state="translated">При заданной позиции персонажа первым вариантом,позволяющим успешно провести регекс-матч,будет тот,который совпадает.Здесь все альтернативы совпадают на первой позиции строки,то есть первые совпадают.</target>
        </trans-unit>
        <trans-unit id="fa1efd2d4349c6ea79b9b9fc2089c111f8b1ca40" translate="yes" xml:space="preserve">
          <source>At any given time, exactly one of these modifiers is in effect. Their existence allows Perl to keep the originally compiled behavior of a regular expression, regardless of what rules are in effect when it is actually executed. And if it is interpolated into a larger regex, the original's rules continue to apply to it, and only it.</source>
          <target state="translated">В любой момент времени действует именно один из этих модификаторов.Их наличие позволяет Perl сохранять изначально скомпилированное поведение регулярного выражения,независимо от того,какие правила действуют в момент его фактического выполнения.И если оно интерполировано в более крупный регекс,то правила оригинала продолжают к нему применяться,и только к нему.</target>
        </trans-unit>
        <trans-unit id="7593f9fb00e51f006212d276b2834d5cb1e7bd4c" translate="yes" xml:space="preserve">
          <source>At any rate, the very use of &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; is questionable when it comes to unicode characters since you have to consider such things as character width (i.e. double-width for ideographs) and directions (i.e. BIDI for Arabic and Hebrew).</source>
          <target state="translated">В любом случае, само использование &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; вызывает сомнения, когда дело касается символов Юникода, поскольку вы должны учитывать такие вещи, как ширина символа (т.е. двойная ширина для идеограмм) и направления (например, BIDI для арабского и иврита).</target>
        </trans-unit>
        <trans-unit id="40530b4cf9ab5b3f6391788f6f588ae031f72498" translate="yes" xml:space="preserve">
          <source>At deserialization time, you will be given back the same LIST, but all the extra references will be pointing into the deserialized structure.</source>
          <target state="translated">Во время десериализации вам будет возвращен тот же СПИСОК,но все дополнительные ссылки будут указывать на десериализованную структуру.</target>
        </trans-unit>
        <trans-unit id="2359fa76d13a340de35eda7f896e38293fc5d5aa" translate="yes" xml:space="preserve">
          <source>At each stack level, the subroutine's name is displayed along with its parameters. For simple scalars, this is sufficient. For complex data types, such as objects and other references, this can simply display &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; .</source>
          <target state="translated">На каждом уровне стека отображается имя подпрограммы вместе с ее параметрами. Для простых скаляров этого достаточно. Для сложных типов данных, таких как объекты и другие ссылки, это может просто отобразить &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="396433f01b9bc30bd1dc987a608f2db8a7b54ded" translate="yes" xml:space="preserve">
          <source>At entry points to perl, such as &lt;code&gt;perl_parse()&lt;/code&gt; , &lt;code&gt;perl_run()&lt;/code&gt; and &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; each does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; , then enter a runops loop or whatever, and handle possible exception returns. For a 2 return, final cleanup is performed, such as popping stacks and calling &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; blocks. Amongst other things, this is how scope cleanup still occurs during an &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В точках входа в perl, таких как &lt;code&gt;perl_parse()&lt;/code&gt; , &lt;code&gt;perl_run()&lt;/code&gt; и &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; каждый выполняет &lt;code&gt;JMPENV_PUSH&lt;/code&gt; , затем входит в цикл runops или что-то еще и обрабатывает возможные возвраты исключения. Для возврата 2 выполняется окончательная очистка, такая как выталкивание стеков и вызов блоков &lt;code&gt;CHECK&lt;/code&gt; или &lt;code&gt;END&lt;/code&gt; . Среди прочего, это то, как очистка области все еще происходит во время &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b52a6611c3d532a492a587178e19cf7d8fea481" translate="yes" xml:space="preserve">
          <source>At first glance, you'd think that it shouldn't print, because obviously the &lt;code&gt;ddd&lt;/code&gt; isn't going to match the target string. But look at this example:</source>
          <target state="translated">На первый взгляд может показаться, что он не должен печатать, потому что, очевидно, &lt;code&gt;ddd&lt;/code&gt; не будет соответствовать целевой строке. Но посмотрите на этот пример:</target>
        </trans-unit>
        <trans-unit id="a20d2e5d0ab73a1c97b3463749bc6385228a9028" translate="yes" xml:space="preserve">
          <source>At least for consistency with WinNT, you should keep the recommended value.</source>
          <target state="translated">По крайней мере,для соответствия WinNT,вы должны сохранить рекомендуемое значение.</target>
        </trans-unit>
        <trans-unit id="27bd45d9389cf551091228f338420922ea6613d9" translate="yes" xml:space="preserve">
          <source>At least in Unix you may be able to get past this by increasing your process datasize limits: in csh/tcsh use &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;limit datasize n&lt;/code&gt; (where &lt;code&gt;n&lt;/code&gt; is the number of kilobytes) to check the current limits and change them, and in ksh/bash/zsh use &lt;code&gt;ulimit -a&lt;/code&gt; and &lt;code&gt;ulimit -d n&lt;/code&gt; , respectively.</source>
          <target state="translated">По крайней мере, в Unix вы можете обойти это, увеличив пределы размера данных процесса: в csh / tcsh используйте &lt;code&gt;limit&lt;/code&gt; и &lt;code&gt;limit datasize n&lt;/code&gt; (где &lt;code&gt;n&lt;/code&gt; - количество килобайт), чтобы проверить текущие ограничения и изменить их, а в ksh / bash / zsh используйте &lt;code&gt;ulimit -a&lt;/code&gt; и &lt;code&gt;ulimit -d n&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="be275e2a07874324b642ea6224748e1cc7c92b91" translate="yes" xml:space="preserve">
          <source>At least it's backwards compatible in not doing much.</source>
          <target state="translated">По крайней мере,она обратно совместима,не делая многого.</target>
        </trans-unit>
        <trans-unit id="9e14e0bb06602e8d806ecd5603df3d1331d55d06" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; must have a goal (at least one of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; must be non-zero), and if both do, both have to be reached for a successful match. Also, if the fold of a character is multiple characters, all of them must be matched (see tr21 reference below for 'folding').</source>
          <target state="translated">По крайней мере, один из &lt;code&gt;s1&lt;/code&gt; и &lt;code&gt;s2&lt;/code&gt; должен иметь цель (хотя бы один из &lt;code&gt;l1&lt;/code&gt; и &lt;code&gt;l2&lt;/code&gt; должен быть ненулевым), и если оба имеют, то для успешного совпадения должны быть достигнуты оба. Кроме того, если складка символа состоит из нескольких символов, все они должны быть сопоставлены (см. Ссылку на tr21 ниже для &amp;laquo;складывания&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="9972c1cfc00f54bc3d4bf6854c0d9453527f2493" translate="yes" xml:space="preserve">
          <source>At least the three builtin functions &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt;. We might someday add more of these later if we think of them.</source>
          <target state="translated">По крайней мере, три встроенные функции: &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt; . Мы могли бы когда-нибудь добавить их позже, если мы подумаем о них.</target>
        </trans-unit>
        <trans-unit id="dc8bf4c3c86adf3ceb8a466491ba399fbc2b4c86" translate="yes" xml:space="preserve">
          <source>At line number 4 is a helpful pointer, that tells you where you are now. To see more code, type 'v' again:</source>
          <target state="translated">В строке под номером 4 находится полезный указатель,который сообщает вам,где вы сейчас находитесь.Чтобы увидеть больше кода,снова наберите 'v':</target>
        </trans-unit>
        <trans-unit id="3706bce960e08579e2a93b26085ef7458b3bba0d" translate="yes" xml:space="preserve">
          <source>At present that list is: weaken, isweak, dualvar, isvstring, set_prototype</source>
          <target state="translated">В настоящее время этот список:ослабленный,сдвинутый,dualvar,isvstring,set_prototype</target>
        </trans-unit>
        <trans-unit id="a9a7ccc891020b1abe97ef7e238b5077a99ae99b" translate="yes" xml:space="preserve">
          <source>At present three compression methods are supported by IO::Compress::Zip, namely Store (no compression at all), Deflate, Bzip2 and LZMA.</source>
          <target state="translated">В настоящее время поддерживаются три метода сжатия IO::Compress::Zip,а именно Store (сжатие отсутствует вообще),Deflate,Bzip2 и LZMA.</target>
        </trans-unit>
        <trans-unit id="c6f3b56326d807044d12f7fa90b19c7ea2469f7b" translate="yes" xml:space="preserve">
          <source>At present, the first time you iterate over %ENV using &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, you will incur a time penalty as all logical names are read, in order to fully populate %ENV. Subsequent iterations will not reread logical names, so they won't be as slow, but they also won't reflect any changes to logical name tables caused by other programs.</source>
          <target state="translated">В настоящее время, когда вы впервые перебираете% ENV с использованием &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; , вы понесете штраф по времени, так как все логические имена будут прочитаны, чтобы полностью заполнить% ENV. Последующие итерации не будут перечитывать логические имена, поэтому они не будут такими медленными, но они также не будут отражать никаких изменений в таблицах логических имен, вызванных другими программами.</target>
        </trans-unit>
        <trans-unit id="25d8707372413087d65e69b61d9a6dc703b71cf2" translate="yes" xml:space="preserve">
          <source>At run time, each listed plugin is instantiated as a singleton object by running the equivalent of this pseudo code:</source>
          <target state="translated">Во время выполнения,каждый из перечисленных плагинов инстанцируется как однокнопочный объект,запуская эквивалент этого псевдокода:</target>
        </trans-unit>
        <trans-unit id="0346a8b0d676351a6882db32e2f71fe2cd6612af" translate="yes" xml:space="preserve">
          <source>At run-time you can use:</source>
          <target state="translated">Во время работы вы можете использовать:</target>
        </trans-unit>
        <trans-unit id="14c311a97bb302da658b5d5c146d94913481c6a7" translate="yes" xml:space="preserve">
          <source>At some moment the built may die, reporting a</source>
          <target state="translated">В какой-то момент построенный может умереть,сообщая,что</target>
        </trans-unit>
        <trans-unit id="8f94eca0c2d56d19683ad85c3b3f54fed0ab0893" translate="yes" xml:space="preserve">
          <source>At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agrees to use the CPAN Meta format to communicate post-configuration requirements between toolchain components. These files,</source>
          <target state="translated">На выставке QA Hackathon 2008 в Осло сопровождающие модулей Perl согласились использовать формат CPAN Meta для передачи пост-конфигурационных требований между компонентами инструментальной цепочки.Эти файлы,</target>
        </trans-unit>
        <trans-unit id="86950d72bad1114392fd499fea36a75e7faf16d6" translate="yes" xml:space="preserve">
          <source>At the cost of a slight header overhead, you may store to an already opened file descriptor using the &lt;code&gt;store_fd&lt;/code&gt; routine, and retrieve from a file via &lt;code&gt;fd_retrieve&lt;/code&gt; . Those names aren't imported by default, so you will have to do that explicitly if you need those routines. The file descriptor you supply must be already opened, for read if you're going to retrieve and for write if you wish to store.</source>
          <target state="translated">За счет небольших накладных расходов на заголовок вы можете сохранить в уже открытый дескриптор файла с &lt;code&gt;store_fd&lt;/code&gt; процедуры store_fd и получить из файла с помощью &lt;code&gt;fd_retrieve&lt;/code&gt; . Эти имена не импортируются по умолчанию, поэтому вам придется сделать это явно, если вам нужны эти процедуры. Предоставленный вами файловый дескриптор должен быть уже открыт для чтения, если вы собираетесь получить, и для записи, если вы хотите сохранить.</target>
        </trans-unit>
        <trans-unit id="5655f269f9dae667811a30ef2f8f926fc9530ad6" translate="yes" xml:space="preserve">
          <source>At the end of</source>
          <target state="translated">В конце</target>
        </trans-unit>
        <trans-unit id="9572ac86c1b1da5c7ab83dd35ce00912ee7e613d" translate="yes" xml:space="preserve">
          <source>At the end of all &lt;code&gt;when&lt;/code&gt; blocks, there is an implicit &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;. You can override that with an explicit &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; if you're interested in only the first match alone.</source>
          <target state="translated">В конце всех блоков &lt;code&gt;when&lt;/code&gt; идет неявный &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; . Вы можете переопределить это с помощью явного &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; если вас интересует только первое совпадение.</target>
        </trans-unit>
        <trans-unit id="ca6a702d6cdcdadecdbaeb43444eca515cc146c7" translate="yes" xml:space="preserve">
          <source>At the end of the parse, call &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; to get the tree's top node.</source>
          <target state="translated">В конце анализа вызовите &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; чтобы получить верхний узел дерева.</target>
        </trans-unit>
        <trans-unit id="07a9cc69765068861817ec41e4a7228bd113195b" translate="yes" xml:space="preserve">
          <source>At the lowest level, the macros new_SV() and del_SV() grab and free an SV head. (If debugging with -DD, del_SV() calls the function S_del_sv() to return the SV to the free list with error checking.) new_SV() calls more_sv() / sv_add_arena() to add an extra arena if the free list is empty. SVs in the free list have their SvTYPE field set to all ones.</source>
          <target state="translated">На самом низком уровне макросы new_SV()и del_SV()захватывают и освобождают голову SV.(При отладке с помощью -DD,del_SV()вызывает функцию S_del_sv()для возврата SV в свободный список с проверкой на ошибки)new_SV()вызывает more_sv()/sv_add_arena()для добавления дополнительной арены,если свободный список пуст.SV в свободном списке имеют поле SvTYPE,установленное для всех.</target>
        </trans-unit>
        <trans-unit id="6089cbc08fb43732445842a261366b161cee7872" translate="yes" xml:space="preserve">
          <source>At the moment of writing, AIX supports two different native C compilers, for which you have to pay: &lt;b&gt;xlC&lt;/b&gt; and &lt;b&gt;vac&lt;/b&gt;. If you decide to use either of these two (which is quite a lot easier than using gcc), be sure to upgrade to the latest available patch level. Currently:</source>
          <target state="translated">На момент написания, AIX поддерживает два различных нативные компиляторы, для которых вы должны платить: &lt;b&gt;XLC&lt;/b&gt; и &lt;b&gt;VAC&lt;/b&gt; . Если вы решите использовать любой из этих двух (что намного проще, чем использование gcc), обязательно обновитесь до последнего доступного уровня исправления. В настоящее время:</target>
        </trans-unit>
        <trans-unit id="af7b9b33fafaf83f9420acb89bb16618e9123d52" translate="yes" xml:space="preserve">
          <source>At the risk of stating the obvious, modules are intended to be modular. A Perl developer should be able to use modules to put together the building blocks of their application. However, it's important that the blocks are the right shape, and that the developer shouldn't have to use a big block when all they need is a small one.</source>
          <target state="translated">Рискуя заявить очевидное,модули предназначены для модульной установки.Разработчик на Perl должен иметь возможность использовать модули для компоновки строительных блоков своего приложения.Тем не менее,важно,чтобы блоки имели правильную форму,и чтобы разработчику не приходилось использовать большой блок,когда все,что им нужно,это маленький блок.</target>
        </trans-unit>
        <trans-unit id="d2c548d72452435d78a5e713661472ad87fa3347" translate="yes" xml:space="preserve">
          <source>At the time of this writing (2009-03) there are three YAML implementations working: YAML, YAML::Syck, and YAML::XS. The latter two are faster but need a C compiler installed on your system. There may be more alternative YAML conforming modules. When I tried two other players, YAML::Tiny and YAML::Perl, they seemed not powerful enough to work with CPAN.pm. This may have changed in the meantime.</source>
          <target state="translated">На момент написания данной статьи (2009-03)работало три реализации YAML:YAML,YAML::Syck и YAML::XS.Последние две быстрее,но требуют установки компилятора C на вашей системе.Модулей,соответствующих YAML,может быть больше.Когда я попробовал два других проигрывателя,YAML::Tiny и YAML::Perl,они казались недостаточно мощными для работы с CPAN.pm.Возможно,за это время ситуация изменилась.</target>
        </trans-unit>
        <trans-unit id="7ea634c02baa48b31e81ed3a00831f7dcbb2e678" translate="yes" xml:space="preserve">
          <source>At the time of this writing (June 2002), there is a known bug in the Tru64 libc printing of long doubles when not using &quot;e&quot; notation. The values are correct and usable, but you only get a limited number of digits displayed unless you force the issue by using &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;
&quot;%.33e&quot;,$num&lt;/code&gt; or the like. For Tru64 versions V5.0A through V5.1A, a patch is expected sometime after perl 5.8.0 is released. If your libc has not yet been patched, you'll get a warning from Configure when selecting long doubles.</source>
          <target state="translated">На момент написания этой статьи (июнь 2002 г.) в Tru64 libc при печати длинных дубликатов без использования нотации &amp;laquo;e&amp;raquo; была известная ошибка. Значения верны и пригодны для использования, но вы получите только ограниченное количество отображаемых цифр, если вы не &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; &quot;%.33e&quot;,$num&lt;/code&gt; проблему с помощью &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; &quot;% .33e&quot;, $ num или подобных. Для версий Tru64 от V5.0A до V5.1A патч ожидается через некоторое время после выпуска perl 5.8.0. Если ваша библиотека libc еще не была исправлена, вы получите предупреждение от Configure при выборе длинных двойников.</target>
        </trans-unit>
        <trans-unit id="1867a801fe6f9af5a7aceadb824f2be69014eb61" translate="yes" xml:space="preserve">
          <source>At the time of this writing, Perl 5.18.0 is considered to be well-hardened against algorithmic complexity attacks on its hash implementation. This is largely owed to the following measures mitigate attacks:</source>
          <target state="translated">На момент написания данной статьи Perl 5.18.0 считался хорошо защищенным от атак на его алгоритмическую сложность реализации хэша.Это в значительной степени обусловлено следующими мерами по смягчению атак:</target>
        </trans-unit>
        <trans-unit id="8a33c676d1f79e763827316ea86000a157f0da7a" translate="yes" xml:space="preserve">
          <source>At the time of very final cleanup, sv_free_arenas() is called from perl_destruct() to physically free all the arenas allocated since the start of the interpreter.</source>
          <target state="translated">Во время очень финальной очистки вызывается sv_free_arenas()из функции perl_destruct(),чтобы физически освободить все арены,выделенные с момента запуска интерпретатора.</target>
        </trans-unit>
        <trans-unit id="4ad7685293e30733157e0b0115df9c2bbc818321" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current &quot;a&quot; sub, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">На момент создания f она не может захватить текущую подпрограмму &quot;a&quot;,так как анонимная подпрограмма еще не создана.И наоборот,следующее не выдаст предупреждение,так как анонимная подпрограмма уже создана и работает в реальном времени:</target>
        </trans-unit>
        <trans-unit id="c7f753fb79bacf696f44e6edc3ce403746b9d93b" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current value of $a, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">На момент создания f она не может захватить текущее значение $a,так как анонимная подпрограмма еще не создана.И наоборот,предупреждение не будет выдано,так как анонимная подпрограмма уже создана и находится в прямом эфире:</target>
        </trans-unit>
        <trans-unit id="9d72f28fef349b76a0adf7f5f7156e5e3f38d89f" translate="yes" xml:space="preserve">
          <source>At the time this document was last updated, Cygwin 1.7.16 was current.</source>
          <target state="translated">На момент последнего обновления этого документа,Cygwin 1.7.16 был действующим.</target>
        </trans-unit>
        <trans-unit id="568132008f8ee29811084c20ba8f801b1aedb463" translate="yes" xml:space="preserve">
          <source>At the very least, this is useful to see what the SelfLoader thinks are stubs - in order to ensure future versions of the SelfStubber remain in step with the SelfLoader, the SelfStubber actually uses the SelfLoader to determine which stubs are needed.</source>
          <target state="translated">По крайней мере,это полезно для того,чтобы увидеть,что SelfLoader считает шлейфами-для того,чтобы будущие версии SelfStubber не отставали от SelfLoader,SelfStubber фактически использует SelfLoader,чтобы определить,какие шлейфы нужны.</target>
        </trans-unit>
        <trans-unit id="4c88d3fd177dc36a169a0f390f88ed358e376c27" translate="yes" xml:space="preserve">
          <source>At the very minimum, any subclass will need to provide its own &lt;code&gt;new()&lt;/code&gt; and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:</source>
          <target state="translated">Как минимум, любой подкласс должен предоставить свой собственный &lt;code&gt;new()&lt;/code&gt; и может хранить дополнительные хеш-ключи в объекте. Также необходимо определить некоторые глобальные переменные пакетов, например:</target>
        </trans-unit>
        <trans-unit id="edcf8fa241edee8ba6be389a9320a43680a858f9" translate="yes" xml:space="preserve">
          <source>At this point, if you're using the</source>
          <target state="translated">На данный момент,если ты используешь</target>
        </trans-unit>
        <trans-unit id="5a6511c6f50957ea6c619917499bccc60b76c492" translate="yes" xml:space="preserve">
          <source>At this point, we have all the basic regexp concepts covered, so let's give a more involved example of a regular expression. We will build a regexp that matches numbers.</source>
          <target state="translated">На данный момент мы рассмотрели все основные понятия реге Exp,поэтому давайте приведем более увлекательный пример регулярного выражения.Мы построим регеxp,который будет соответствовать числам.</target>
        </trans-unit>
        <trans-unit id="370a5cf660692a42903691231af5dc8e0071bc25" translate="yes" xml:space="preserve">
          <source>At this point, xsubpp is doing very little work - the differences between Mytest.xs and Mytest.c are minimal.</source>
          <target state="translated">На данный момент xsubpp делает очень мало работы-различия между Mytest.xs и Mytest.c минимальны.</target>
        </trans-unit>
        <trans-unit id="6e93ae94dda2105286d8d2c3c0189888d8aa45b7" translate="yes" xml:space="preserve">
          <source>At time of writing, &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; values are of two types: either the name of a Pod page like &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (which might be a real Perl module or program in an @INC / PATH directory, or a .pod file in those places); or the name of a Unix man page, like &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; . In theory, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; in ambiguous between a Pod page called &quot;chmod&quot;, or the Unix man page &quot;chmod&quot; (in whatever man-section). However, the presence of a string in parens, as in &quot;crontab(5)&quot;, is sufficient to signal that what is being discussed is not a Pod page, and so is presumably a Unix man page. The distinction is of no importance to many Pod processors, but some processors that render to hypertext formats may need to distinguish them in order to know how to render a given &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; code.</source>
          <target state="translated">На момент написания значения &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; были двух типов: либо имя страницы Pod, например &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (которое может быть настоящим модулем Perl или программой в каталоге @INC / PATH, либо .pod файл в тех местах); или имя страницы руководства Unix, например &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; . Теоретически, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; неоднозначен между страницей модуля под названием &amp;laquo;chmod&amp;raquo; и страницей руководства Unix &amp;laquo;chmod&amp;raquo; (в любом разделе man). Однако наличие строки в скобках, как в &amp;laquo;crontab (5)&amp;raquo;, является достаточным, чтобы сигнализировать, что обсуждаемая страница не является страницей Pod, а значит, предположительно, страницей руководства Unix. Это различие не имеет значения для многих процессоров Pod,но некоторым процессорам, выполняющим рендеринг в гипертекстовые форматы, может потребоваться различать их, чтобы знать, как рендерить данный &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; Код L &amp;lt;foo&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="d759da54d18d185bb5ccfc037b889a6ccc296532" translate="yes" xml:space="preserve">
          <source>Attach the shared memory segment identified by ID to the address space of the calling process. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;.</source>
          <target state="translated">Присоедините сегмент разделяемой памяти, идентифицированный идентификатором, к адресному пространству вызывающего процесса. См. &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;Шмат&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="225d31a7a030cd02427cb0b7456aa1f815b2914d" translate="yes" xml:space="preserve">
          <source>Attaching &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; to arrays is permissible but has no effect.</source>
          <target state="translated">Присоединение &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; к массивам допустимо , но не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="d423c0cfec188bd6ee98e700b49e9beb58a1ac55" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication.</source>
          <target state="translated">Попытка SASL-аутентификации.</target>
        </trans-unit>
        <trans-unit id="a57d83a2b0e335a567209ea75d9a6f7c18c72eb5" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication. Requires Authen::SASL module.</source>
          <target state="translated">Попытка SASL-аутентификации.Требуется аутентификация::SASL модуля.</target>
        </trans-unit>
        <trans-unit id="0bfa31d2d4671313bd0af54f4bb1d33e8b3d1352" translate="yes" xml:space="preserve">
          <source>Attempt to change directory to the directory given in &lt;code&gt;$dir&lt;/code&gt; . If &lt;code&gt;$dir&lt;/code&gt; is &lt;code&gt;&quot;..&quot;&lt;/code&gt; , the FTP &lt;code&gt;CDUP&lt;/code&gt; command is used to attempt to move up one directory. If no directory is given then an attempt is made to change the directory to the root directory.</source>
          <target state="translated">Попытка сменить каталог на каталог, указанный в &lt;code&gt;$dir&lt;/code&gt; . Если &lt;code&gt;$dir&lt;/code&gt; - &lt;code&gt;&quot;..&quot;&lt;/code&gt; , команда FTP &lt;code&gt;CDUP&lt;/code&gt; используется для попытки перехода на один каталог вверх. Если каталог не указан, делается попытка изменить каталог на корневой каталог.</target>
        </trans-unit>
        <trans-unit id="f1a553fb01152c680db2f1ac04b66addb3e1a32b" translate="yes" xml:space="preserve">
          <source>Attempt to convert an absolute file specification to a relative specification.</source>
          <target state="translated">Попытайтесь преобразовать абсолютную спецификацию файла в относительную спецификацию.</target>
        </trans-unit>
        <trans-unit id="c6a6104d31483a82798cc43a56c3040f5b0e5915" translate="yes" xml:space="preserve">
          <source>Attempt to destroy all objects not yet freed.</source>
          <target state="translated">Попытка уничтожить все объекты,которые еще не освобождены.</target>
        </trans-unit>
        <trans-unit id="fe99a6ee8775c38ae61fdc7b8491eb15dc3ce181" translate="yes" xml:space="preserve">
          <source>Attempt to evaluate the current host's internet name and domain</source>
          <target state="translated">Попытка оценить текущее имя хоста и его домен.</target>
        </trans-unit>
        <trans-unit id="078cb982d4d92298b47355c08e74e2f224c181c7" translate="yes" xml:space="preserve">
          <source>Attempt to print summary information if run is interrupted by SIGINT (Ctrl-C).</source>
          <target state="translated">Попытайтесь распечатать сводную информацию,если запуск прерван SIGINT (Ctrl-C).</target>
        </trans-unit>
        <trans-unit id="b914600bb82ac0ae87b3e9ab97d2d1c2f3efb3a8" translate="yes" xml:space="preserve">
          <source>Attempt to produce color output.</source>
          <target state="translated">Попробуйте произвести цветной вывод.</target>
        </trans-unit>
        <trans-unit id="efb3613b13587fe1f93cf60bf899f24390374124" translate="yes" xml:space="preserve">
          <source>Attempt to read &lt;code&gt;$length&lt;/code&gt; bytes of uncompressed data into &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">Попытка прочитать &lt;code&gt;$length&lt;/code&gt; байт несжатых данных в &lt;code&gt;$buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b92f951c7fd86ee7f7ec9db2ae7b702bd512a11" translate="yes" xml:space="preserve">
          <source>Attempting to inherit from yourself generates a warning.</source>
          <target state="translated">Попытка унаследовать от себя порождает предупреждение.</target>
        </trans-unit>
        <trans-unit id="940068c4484917346e58cd849ab63ab658a04374" translate="yes" xml:space="preserve">
          <source>Attempting to pack the special floating point values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity, also in negative, and not-a-number) into packed integer values (like &lt;code&gt;&quot;L&quot;&lt;/code&gt; ) is a fatal error. The reason for this is that there simply isn't any sensible mapping for these special values into integers.</source>
          <target state="translated">Попытка упаковать специальные значения с плавающей запятой &lt;code&gt;Inf&lt;/code&gt; и &lt;code&gt;NaN&lt;/code&gt; (бесконечность, также отрицательные и не числовые) в упакованные целочисленные значения (например, &lt;code&gt;&quot;L&quot;&lt;/code&gt; ) является фатальной ошибкой. Причина этого в том, что для этих специальных значений просто не существует разумного преобразования в целые числа.</target>
        </trans-unit>
        <trans-unit id="6015d4f519177c33ba06ab08404701540b4f2048" translate="yes" xml:space="preserve">
          <source>Attempting to reopen a database without closing it.</source>
          <target state="translated">Попытка снова открыть базу данных,не закрывая ее.</target>
        </trans-unit>
        <trans-unit id="0bedf74043c203b86c1b5363d305f57a4b0c5fcb" translate="yes" xml:space="preserve">
          <source>Attempts several methods of getting the system hostname and then caches the result. It tries the first available of the C library's gethostname(), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; , uname(2), &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;`hostname`&lt;/code&gt; , &lt;code&gt;`uname -n`&lt;/code&gt; , and the file</source>
          <target state="translated">Пытается несколькими способами получить имя хоста системы, а затем кэширует результат. Он пробует первый доступный из библиотеки C gethostname (), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; , uname (2), &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;`hostname`&lt;/code&gt; , &lt;code&gt;`uname -n`&lt;/code&gt; и файл</target>
        </trans-unit>
        <trans-unit id="f998d3cd38777ee213006cd15fb0e0f6d2ddc7f7" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Попытки подключиться к удаленному сокету, как и connect (2). Возвращает true в случае успеха и false в противном случае. ИМЯ должно быть упакованным адресом соответствующего типа для сокета. См. Примеры в &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client / Server Communication in perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64769a075153327a39fd4f2723d3853f980fe471" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Попытки подключиться к удаленному сокету, как и connect (2). Возвращает true в случае успеха и false в противном случае. ИМЯ должно быть упакованным адресом соответствующего типа для сокета. См. Примеры в &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client / Server Communication in perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a0ddb935c0376b494edd76deb21d2e9aa4a1612" translate="yes" xml:space="preserve">
          <source>Attempts to convert in-place the octet sequence encoded as</source>
          <target state="translated">Попытки преобразовать на месте октетную последовательность,закодированную как</target>
        </trans-unit>
        <trans-unit id="bd9b4f39078d108026008c73a3d153cb14bae4bd" translate="yes" xml:space="preserve">
          <source>Attempts to convert the PV of an SV from characters to bytes. If the PV contains a character that cannot fit in a byte, this conversion will fail; in this case, either returns false or, if &lt;code&gt;fail_ok&lt;/code&gt; is not true, croaks.</source>
          <target state="translated">Попытки преобразовать PV SV из символов в байты. Если PV содержит символ, который не может поместиться в байт, это преобразование завершится ошибкой; в этом случае либо возвращает false, либо, если &lt;code&gt;fail_ok&lt;/code&gt; не истинно, хрипит.</target>
        </trans-unit>
        <trans-unit id="64d7ec66819a9007136707554fdc8dbbef9567aa" translate="yes" xml:space="preserve">
          <source>Attempts to determine if a given host is outside your firewall. Possible return values are.</source>
          <target state="translated">Попытки определить,находится ли данный узел за пределами вашего брандмауэра.Возможные возвращаемые значения.</target>
        </trans-unit>
        <trans-unit id="015e99d4e0b5f5661a89b0c851595de01de6cc85" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH</source>
          <target state="translated">Попытки прочитать ЛЕНГТ</target>
        </trans-unit>
        <trans-unit id="623d8fbf82dc2fdc9694f6bbe91f1257bb25f69a" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">Пытается прочитать LENGTH байтов данных в переменную SCALAR из указанного FILEHANDLE, используя read (2). Он обходит буферное IO, поэтому смешивание это с другими видами чтения, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; , или &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; может вызвать путаницу , поскольку PerlIO или STDIO слоев , как правило , буфера данных. Возвращает количество фактически прочитанных байтов, &lt;code&gt;0&lt;/code&gt; в конце файла или undef, если произошла ошибка (в последнем случае также устанавливается &lt;code&gt;$!&lt;/code&gt; ). SCALAR будет увеличиваться или уменьшаться так, чтобы последний фактически прочитанный байт был последним байтом скаляра после чтения.</target>
        </trans-unit>
        <trans-unit id="321c64867646f812228d15e7d459f8fc1a5c1183" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">Пытается прочитать LENGTH байтов данных в переменную SCALAR из указанного FILEHANDLE, используя read (2). Он обходит буферное IO, поэтому смешивание это с другими видами чтения, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; , или &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; может вызвать путаницу , поскольку PerlIO или STDIO слоев , как правило , буфера данных. Возвращает количество фактически прочитанных байтов, &lt;code&gt;0&lt;/code&gt; в конце файла или undef, если произошла ошибка (в последнем случае также устанавливается &lt;code&gt;$!&lt;/code&gt; ). SCALAR будет увеличиваться или уменьшаться так, чтобы последний фактически прочитанный байт был последним байтом скаляра после чтения.</target>
        </trans-unit>
        <trans-unit id="056c7c4b49d09bfb10b608aa560ae7f329c94639" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">Пытается записать LENGTH байтов данных из переменной SCALAR в указанный FILEHANDLE, используя write (2). Если ДЛИНА не указана, записывается весь СКАЛЯР. Он обходит буферное IO, так что смешивание это с читает (кроме &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; , или &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; может вызвать путаницу , поскольку PerlIO и STDIO слоев , как правило , буфер данных. Возвращает количество фактически записанных байтов или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если произошла ошибка (в этом случае также устанавливается переменная errno &lt;code&gt;$!&lt;/code&gt; ). Если ДЛИНА больше, чем данные, доступные в СКАЛЯРЕ после СМЕЩЕНИЯ, будет записано столько данных, сколько доступно.</target>
        </trans-unit>
        <trans-unit id="bf935c85345c3169ffc0b395c956f17c45a9fe82" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">Пытается записать LENGTH байтов данных из переменной SCALAR в указанный FILEHANDLE, используя write (2). Если ДЛИНА не указана, записывается весь СКАЛЯР. Он обходит буферное IO, так что смешивание это с читает (кроме &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; , или &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; может вызвать путаницу , поскольку PerlIO и STDIO слоев , как правило , буфер данных. Возвращает количество фактически записанных байтов или &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если произошла ошибка (в этом случае также устанавливается переменная errno &lt;code&gt;$!&lt;/code&gt; ). Если ДЛИНА больше, чем данные, доступные в СКАЛЯРЕ после СМЕЩЕНИЯ, будет записано столько данных, сколько доступно.</target>
        </trans-unit>
        <trans-unit id="cf2ad2263d9deded93137fc6e93270ce22633fb0" translate="yes" xml:space="preserve">
          <source>Attempts word completion. Cannot be changed.</source>
          <target state="translated">Попытки завершить слово.Не может быть изменено.</target>
        </trans-unit>
        <trans-unit id="402319da749127eab7373ce69945d35452ea82aa" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers</source>
          <target state="translated">Attribute::Handlers</target>
        </trans-unit>
        <trans-unit id="ab429cb97f17abf9bda7af427a4ab75a270a8eee" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers - Simpler definition of attribute handlers</source>
          <target state="translated">Атрибут::Обработчики-более простое определение обработчиков атрибутов</target>
        </trans-unit>
        <trans-unit id="1c8c525e5ee86dfc71e9832b4cad7c5124dad809" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers makes strenuous efforts to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler (but see &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;Non-interpretive attribute handlers&lt;/a&gt;). If those efforts succeed, the interpreted data is passed in an array reference; if they fail, the raw data is passed as a string. For example, all of these:</source>
          <target state="translated">Attribute :: Handlers прилагает большие усилия для преобразования аргумента данных ( &lt;code&gt;$_[4]&lt;/code&gt; ) в пригодную для использования форму перед передачей его обработчику (но см. &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;Неинтерпретативные обработчики атрибутов&lt;/a&gt; ). Если эти попытки увенчаются успехом, интерпретированные данные передаются в виде ссылки на массив; если они терпят неудачу, необработанные данные передаются в виде строки. Например, все это:</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="7096373d5156eb6bd0032a6f3f3f6f2306181c31" translate="yes" xml:space="preserve">
          <source>Attributes are often stored in the object itself. For example, if the object is an anonymous hash, we can store the attribute values in the hash using the attribute name as the key.</source>
          <target state="translated">Атрибуты часто хранятся в самом объекте.Например,если объект является анонимным хэшем,мы можем хранить значения атрибутов в хэше,используя имя атрибута в качестве ключа.</target>
        </trans-unit>
        <trans-unit id="1ec0e5f9458a3d0b7666b49e580f1e144a9409de" translate="yes" xml:space="preserve">
          <source>Attributes are typically defined as read-only or read-write. Read-only attributes can only be set when the object is first created, while read-write attributes can be altered at any time.</source>
          <target state="translated">Атрибуты обычно определяются как &quot;только для чтения&quot; или &quot;только для чтения-записи&quot;.Атрибуты,доступные только для чтения,могут быть установлены только при первом создании объекта,в то время как атрибуты,доступные для чтения и записи,могут быть изменены в любое время.</target>
        </trans-unit>
        <trans-unit id="e7c79e72c9cbf686713260fcf1aae8a2f9a1a49e" translate="yes" xml:space="preserve">
          <source>Attributes as &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; interfaces</source>
          <target state="translated">Атрибуты как &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; интерфейсы</target>
        </trans-unit>
        <trans-unit id="6e1c2a2200f4dc51bc987e61b1d0f256256aa8d5" translate="yes" xml:space="preserve">
          <source>Attributes as tie interfaces</source>
          <target state="translated">Атрибуты как интерфейсы связи</target>
        </trans-unit>
        <trans-unit id="5d582f3d2d463609c927f60d4eb884597e89efea" translate="yes" xml:space="preserve">
          <source>Attributes make an excellent and intuitive interface through which to tie variables. For example:</source>
          <target state="translated">Атрибуты делают отличный и интуитивно понятный интерфейс,через который можно связывать переменные.Например:</target>
        </trans-unit>
        <trans-unit id="508a5aa4d3d540c30ef29d403ada44bf44ff7142" translate="yes" xml:space="preserve">
          <source>Attributes, once set, last until they are unset (by printing the attribute &lt;code&gt;clear&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt;). Be careful to do this, or otherwise your attribute will last after your script is done running, and people get very annoyed at having their prompt and typing changed to weird colors.</source>
          <target state="translated">Атрибуты, однажды установленные, действуют до тех пор, пока они не будут сняты (путем печати атрибута &lt;code&gt;clear&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; ). Будьте осторожны при этом, иначе ваш атрибут будет работать после того, как ваш скрипт будет запущен, и люди будут очень раздражены тем, что их подсказка и ввод изменяются на странные цвета.</target>
        </trans-unit>
        <trans-unit id="1874e0336adde0a00ba3a60dae1dc775409600bd" translate="yes" xml:space="preserve">
          <source>Audrey Tang &amp;lt;cpan@audreyt.org&amp;gt;</source>
          <target state="translated">Одри Танг &amp;lt;cpan@audreyt.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="21c24cd01488e77938199d2e43d1c1e07248317d" translate="yes" xml:space="preserve">
          <source>Authenticate with the server identifying as &lt;code&gt;USER&lt;/code&gt; with password &lt;code&gt;PASS&lt;/code&gt; . Similar to &lt;a href=&quot;#login&quot;&gt;login&lt;/a&gt;, but the password is not sent in clear text.</source>
          <target state="translated">Выполните аутентификацию на сервере, идентифицированном как &lt;code&gt;USER&lt;/code&gt; с паролем &lt;code&gt;PASS&lt;/code&gt; . Аналогично &lt;a href=&quot;#login&quot;&gt;логину&lt;/a&gt; , но пароль не передается в виде открытого текста.</target>
        </trans-unit>
        <trans-unit id="507f24ee32e393058ec2717e7ff642ddf8b1dd65" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the original AUTHINFO USER / AUTHINFO PASS form, defined in RFC2980) using the supplied username and password. Please note that the password is sent in clear text to the server. This command should not be used with valuable passwords unless the connection to the server is somehow protected.</source>
          <target state="translated">Аутентифицируется на сервере (используя оригинальную форму AUTHINFO USER/AUTHINFO PASS,определенную в RFC2980),используя предоставленные имя пользователя и пароль.Обратите внимание,что пароль отправляется на сервер открытым текстом.Эту команду не следует использовать с ценными паролями,если только соединение с сервером не защищено каким-либо образом.</target>
        </trans-unit>
        <trans-unit id="6f9130bcae1a2dee757ab825f2972f22149b8d0e" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE form, defined and deprecated in RFC2980) using the supplied username and password. As with &lt;a href=&quot;#authinfo&quot;&gt;authinfo&lt;/a&gt; the password is sent in clear text.</source>
          <target state="translated">Аутентифицируется на сервере (с использованием предложенной формы NNTP V2 AUTHINFO SIMPLE, определенной и устаревшей в RFC2980) с использованием предоставленных имени пользователя и пароля. Как и в случае с &lt;a href=&quot;#authinfo&quot;&gt;authinfo,&lt;/a&gt; пароль отправляется открытым текстом.</target>
        </trans-unit>
        <trans-unit id="561e59b47284192d792d6315e83a8df1bb4623e9" translate="yes" xml:space="preserve">
          <source>Authentication, Security, and Encryption</source>
          <target state="translated">Аутентификация,безопасность и шифрование</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="fd140dad60fa77aa1adfbcd64d1e9ea4bc89ff62" translate="yes" xml:space="preserve">
          <source>Author and Maintainer: The Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</source>
          <target state="translated">Автор и сопровождающий: Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e41e820954a6b297983a7b6986adfdc7c083ed60" translate="yes" xml:space="preserve">
          <source>Author and Modification History</source>
          <target state="translated">История автора и изменений</target>
        </trans-unit>
        <trans-unit id="dc4e711f40af1fee4327bcbd34d91d11e1b38a81" translate="yes" xml:space="preserve">
          <source>Author of this software makes no claim whatsoever about suitability, reliability, edability, editability or usability of this product, and should not be kept liable for any damage resulting from the use of it. If you can use it, you are in luck, if not, I should not be kept responsible. Keep a handy copy of your backup tape at hand.</source>
          <target state="translated">Автор данного программного обеспечения не претендует на пригодность,надежность,возможность редактирования или использования данного продукта,и не несет ответственности за любой ущерб,возникший в результате его использования.Если вы можете использовать его,вам повезло,если нет,то я не должен нести за это ответственность.Держите под рукой удобную копию своей ленты для резервного копирования.</target>
        </trans-unit>
        <trans-unit id="75a1f723a2c00ab3f9e540ebe5e3b630e531e2c3" translate="yes" xml:space="preserve">
          <source>Author: Mark Jason Dominus, Plover Systems (&lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; )</source>
          <target state="translated">Автор: Марк Джейсон Доминус, Plover Systems ( &lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="4e4bc3d81e572248f45b55f87eb6a695cc5d7e17" translate="yes" xml:space="preserve">
          <source>Authors must not nest L&amp;lt;...&amp;gt; codes. For example, &quot;L&amp;lt;The L&amp;lt;Foo::Bar&amp;gt; man page&amp;gt;&quot; should be treated as an error.</source>
          <target state="translated">Авторы не должны вкладывать L &amp;lt;...&amp;gt; коды. Например, &quot;L &amp;lt;The L &amp;lt;Foo :: Bar&amp;gt; man page&amp;gt;&quot; следует рассматривать как ошибку.</target>
        </trans-unit>
        <trans-unit id="9a1f2888146e0b82120ccf28bf4584779813130b" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters are reminded that &quot;=over&quot; ... &quot;=back&quot; may map to several different constructs in your output format. For example, in converting Pod to (X)HTML, it can map to any of &amp;lt;ul&amp;gt;...&amp;lt;/ul&amp;gt;, &amp;lt;ol&amp;gt;...&amp;lt;/ol&amp;gt;, &amp;lt;dl&amp;gt;...&amp;lt;/dl&amp;gt;, or &amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;. Similarly, &quot;=item&quot; can map to &amp;lt;li&amp;gt; or &amp;lt;dt&amp;gt;.</source>
          <target state="translated">Напоминаем авторам средств форматирования Pod, что &quot;= over&quot; ... &quot;= back&quot; может соответствовать нескольким различным конструкциям в вашем выходном формате. Например, при преобразовании Pod в (X) HTML он может отображаться на любой из &amp;lt;ul&amp;gt; ... &amp;lt;/ul&amp;gt;, &amp;lt;ol&amp;gt; ... &amp;lt;/ol&amp;gt;, &amp;lt;dl&amp;gt; ... &amp;lt;/dl&amp;gt; , или &amp;lt;blockquote&amp;gt; ... &amp;lt;/blockquote&amp;gt;. Точно так же &quot;= item&quot; может отображаться на &amp;lt;li&amp;gt; или &amp;lt;dt&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="80bad0a974c0d7ed8e69ae0a2451cf949509d806" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters should note that this construct:</source>
          <target state="translated">Авторы форматоров Pod должны обратить внимание на эту конструкцию:</target>
        </trans-unit>
        <trans-unit id="0772af8ca884a475bc6c000e8a2e7ecd3771d821" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters/processors should make every effort to avoid writing their own Pod parser. There are already several in CPAN, with a wide range of interface styles -- and one of them, Pod::Parser, comes with modern versions of Perl.</source>
          <target state="translated">Авторы форматеров/процессоров Pod должны приложить все усилия,чтобы избежать написания собственного парсера Pod.В CPAN уже есть несколько,с широким диапазоном стилей интерфейса --и один из них,Pod::Parser,поставляется с современными версиями Perl.</target>
        </trans-unit>
        <trans-unit id="5f5a6b2c86d1c842fb78879cb9847a9b86de0e1d" translate="yes" xml:space="preserve">
          <source>Authors of formatter subclasses might find these methods useful to call on a parser object that you haven't started pulling tokens from yet:</source>
          <target state="translated">Авторы подклассов форматирования могут посчитать эти методы полезными для вызова объекта парсера,с которого вы еще не начали вытаскивать токены:</target>
        </trans-unit>
        <trans-unit id="ba749f31a8ceaa34419e1f1f52af7da1b1065181" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">Автоматическое уменьшение значения в SV,при необходимости выполняя преобразование строки в числовую.Обрабатывает магию 'get' и перегрузку оператора.</target>
        </trans-unit>
        <trans-unit id="cabef034701dc195b619657e11c47b3b4c7ed2cb" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">Автоматическое уменьшение значения в SV,при необходимости выполняя преобразование строки в числовую.Обрабатывает перегрузку оператора.Пропускает обработку магии 'get'.</target>
        </trans-unit>
        <trans-unit id="f8df54de50b8630f73dd7c3210d2ed53c7051734" translate="yes" xml:space="preserve">
          <source>Auto-increment and Auto-decrement</source>
          <target state="translated">Авто-инкремент и авто-декремент</target>
        </trans-unit>
        <trans-unit id="9c2549c4f8e7b5156ddcd16c47fe624753b70037" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">Автоматическое добавление значения в SV,при необходимости делая строковое преобразование в числовое.Обрабатывает магию 'get' и перегрузку оператора.</target>
        </trans-unit>
        <trans-unit id="11123412c221a7c2bf77f34ba93ea1498be1bd77" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">Автоматическое добавление значения в SV,при необходимости делая строковое преобразование в числовое.Обрабатывает перегрузку оператора.Пропускает обработку магии 'get'.</target>
        </trans-unit>
        <trans-unit id="95b64723d9f40505396f5971cbc44d69372e59a7" translate="yes" xml:space="preserve">
          <source>Auto-upgrade</source>
          <target state="translated">Auto-upgrade</target>
        </trans-unit>
        <trans-unit id="57a4f42cae4d12771bda9f458a5b76498da8ce37" translate="yes" xml:space="preserve">
          <source>AutoLoader</source>
          <target state="translated">AutoLoader</target>
        </trans-unit>
        <trans-unit id="4bbd7ae289ef059e5890696f9cb149721a7b8e69" translate="yes" xml:space="preserve">
          <source>AutoLoader - load subroutines only on demand</source>
          <target state="translated">Автопогрузчик-загрузка подпрограммы только по требованию</target>
        </trans-unit>
        <trans-unit id="6851ab5ce9e022d9cc5797875048cf4a3f08af3e" translate="yes" xml:space="preserve">
          <source>AutoLoader may fail to find the autosplit files (or even find the wrong ones) in cases where &lt;code&gt;@INC&lt;/code&gt; contains relative paths, &lt;b&gt;and&lt;/b&gt; the program does &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">AutoLoader может не найти файлы авторазбивки (или даже найти неправильные) в тех случаях, когда &lt;code&gt;@INC&lt;/code&gt; содержит относительные пути, &lt;b&gt;а&lt;/b&gt; программа выполняет &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a635037412af6ace383fa21d0d50db8f0393e57" translate="yes" xml:space="preserve">
          <source>AutoLoaders prior to Perl 5.002 had a slightly different interface. Any old modules which use &lt;b&gt;AutoLoader&lt;/b&gt; should be changed to the new calling style. Typically this just means changing a require to a use, adding the explicit &lt;code&gt;'AUTOLOAD'&lt;/code&gt; import if needed, and removing &lt;b&gt;AutoLoader&lt;/b&gt; from &lt;code&gt;@ISA&lt;/code&gt; .</source>
          <target state="translated">Автозагрузчики до Perl 5.002 имели немного другой интерфейс. Любые старые модули, использующие &lt;b&gt;AutoLoader,&lt;/b&gt; должны быть изменены на новый стиль вызова. Как правило , это просто означает , изменяющих требуют к использованию, добавив явную &lt;code&gt;'AUTOLOAD'&lt;/code&gt; импорта , если это необходимо, и удаления &lt;b&gt;AutoLoader&lt;/b&gt; из &lt;code&gt;@ISA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56be52307d7f516628d0435d04dbf15ef2be8e1c" translate="yes" xml:space="preserve">
          <source>AutoSplit</source>
          <target state="translated">AutoSplit</target>
        </trans-unit>
        <trans-unit id="141ac9ea73e406af3a95ffd453d7845aea91bee3" translate="yes" xml:space="preserve">
          <source>AutoSplit - split a package for autoloading</source>
          <target state="translated">AutoSplit-разделить пакет для автозагрузки</target>
        </trans-unit>
        <trans-unit id="68a652cb711d8eb8f8b2dadb0dc16bdffbba498d" translate="yes" xml:space="preserve">
          <source>Autocreating constants</source>
          <target state="translated">Автосоздание констант</target>
        </trans-unit>
        <trans-unit id="52fe0335e51acfb62f3dfd3073b3227b5b8c4846" translate="yes" xml:space="preserve">
          <source>Autodeferring</source>
          <target state="translated">Autodeferring</target>
        </trans-unit>
        <trans-unit id="f3589c4e74b1463fb3c579cd588ce9598fdbe87e" translate="yes" xml:space="preserve">
          <source>Autodie uses a simple set of categories to group together similar built-ins. Requesting a category type (starting with a colon) will enable autodie for all built-ins beneath that category. For example, requesting &lt;code&gt;:file&lt;/code&gt; will enable autodie for &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Autodie использует простой набор категорий для группировки похожих встроенных функций. Запрос типа категории (начинающийся с двоеточия) включит автозапуск для всех встроенных модулей ниже этой категории. Например, запрос &lt;code&gt;:file&lt;/code&gt; включит autodie для &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f410fe9b046b8c8a478048e83efc2672d42d3c9c" translate="yes" xml:space="preserve">
          <source>Autodying &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; will generate an exception if &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns false with any other error.</source>
          <target state="translated">Autodying &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; сгенерирует исключение, если &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; вернет false с любой другой ошибкой.</target>
        </trans-unit>
        <trans-unit id="3fa81ba949fafdad4688aed6d9380f82976ca9d7" translate="yes" xml:space="preserve">
          <source>Autoloading</source>
          <target state="translated">Autoloading</target>
        </trans-unit>
        <trans-unit id="a71f8461a563c747e56f2cb5fb124e64328506d5" translate="yes" xml:space="preserve">
          <source>Autoloading and package lexicals</source>
          <target state="translated">Автозагрузка и пакетная лексика</target>
        </trans-unit>
        <trans-unit id="24023d5e4bccdad4a40c403d058e7c856f75ea71" translate="yes" xml:space="preserve">
          <source>Autoloading with XSUBs</source>
          <target state="translated">Автозагрузка с XSUB</target>
        </trans-unit>
        <trans-unit id="ea5735f59ad896a38c6b806f8d8b02abba9762e7" translate="yes" xml:space="preserve">
          <source>Automatic binary installation</source>
          <target state="translated">Автоматическая бинарная установка</target>
        </trans-unit>
        <trans-unit id="b890d9b67b4f885e928a5dbcadc3dec7cd34f3ad" translate="yes" xml:space="preserve">
          <source>Automatically generate XSUBs basing on function declarations in the header file. The package &lt;code&gt;C::Scan&lt;/code&gt; should be installed. If this option is specified, the name of the header file may look like &lt;code&gt;NAME1,NAME2&lt;/code&gt; . In this case NAME1 is used instead of the specified string, but XSUBs are emitted only for the declarations included from file NAME2.</source>
          <target state="translated">Автоматически создавать XSUB на основе объявлений функций в файле заголовка. Пакет &lt;code&gt;C::Scan&lt;/code&gt; должен быть установлен. Если указана эта опция, имя файла заголовка может выглядеть как &lt;code&gt;NAME1,NAME2&lt;/code&gt; . В этом случае NAME1 используется вместо указанной строки, но XSUB генерируются только для объявлений, включенных из файла NAME2.</target>
        </trans-unit>
        <trans-unit id="974a6c8e46a4b4db1ad3a13139d3950f13a09a91" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--help&lt;/b&gt; and &lt;b&gt;-?&lt;/b&gt; options if the application did not specify a handler for this option itself.</source>
          <target state="translated">Автоматически предоставлять поддержку &lt;b&gt;--help&lt;/b&gt; и &lt;b&gt;-? &lt;/b&gt;options, если приложение не указало обработчик для самой этой опции.</target>
        </trans-unit>
        <trans-unit id="909a15529b11dbad33480554d0c112bc56821029" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--version&lt;/b&gt; option if the application did not specify a handler for this option itself.</source>
          <target state="translated">Автоматически предоставлять поддержку опции &lt;b&gt;--version,&lt;/b&gt; если приложение не указало обработчик для самой этой опции.</target>
        </trans-unit>
        <trans-unit id="859ddcc1d54c8f56f6fc79d681322ff6800ab918" translate="yes" xml:space="preserve">
          <source>Autoties are most commonly used in the module to which they actually tie, and need to export their attributes to any module that calls them. To facilitate this, Attribute::Handlers recognizes a special &quot;pseudo-class&quot; -- &lt;code&gt;__CALLER__&lt;/code&gt; , which may be specified as the qualifier of an attribute:</source>
          <target state="translated">Автоотношения чаще всего используются в модуле, к которому они фактически привязаны, и им необходимо экспортировать их атрибуты в любой модуль, который их вызывает. Чтобы облегчить это, Attribute :: Handlers распознает специальный &amp;laquo;псевдокласс&amp;raquo; - &lt;code&gt;__CALLER__&lt;/code&gt; , который может быть указан как квалификатор атрибута:</target>
        </trans-unit>
        <trans-unit id="c275699a9fcc5b1df221a4afe6ee0192241a51b8" translate="yes" xml:space="preserve">
          <source>Available Plugins</source>
          <target state="translated">Доступные плагины</target>
        </trans-unit>
        <trans-unit id="a1689bbab8d96444cb240ecc94b27e3bd6e1fa9d" translate="yes" xml:space="preserve">
          <source>Available Subroutines</source>
          <target state="translated">Доступные подпрограммы</target>
        </trans-unit>
        <trans-unit id="f8f5117038c185bf68b0bd33b349f9405e133955" translate="yes" xml:space="preserve">
          <source>Available exports</source>
          <target state="translated">Доступный экспорт</target>
        </trans-unit>
        <trans-unit id="00239624abff2fe9a2fd406296f776638259fff8" translate="yes" xml:space="preserve">
          <source>Available in Perls 5.8.1 and later. If set to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; , the pre-Perl-5.8.0 signal behaviour (which is immediate but unsafe) is restored. If set to &lt;code&gt;safe&lt;/code&gt; , then safe (but deferred) signals are used. See &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals) in perlipc&lt;/a&gt;.</source>
          <target state="translated">Доступно в Perls 5.8.1 и новее. Если установлено значение &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; , поведение сигнала до Perl-5.8.0 (которое является немедленным, но небезопасным) восстанавливается. Если установлено значение &lt;code&gt;safe&lt;/code&gt; , используются безопасные (но отложенные) сигналы. См. &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;Отложенные сигналы (безопасные сигналы) в perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06d7ad8e1c503f30109967f01a5055e60c428ad2" translate="yes" xml:space="preserve">
          <source>Available in version 2.22 and above.</source>
          <target state="translated">Доступно в версии 2.22 и выше.</target>
        </trans-unit>
        <trans-unit id="ca47c0994a656fab74100d8043c17430984bfc08" translate="yes" xml:space="preserve">
          <source>Available in version 2.32 and above</source>
          <target state="translated">Доступно в версии 2.32 и выше</target>
        </trans-unit>
        <trans-unit id="6a2ef8d70aa0a54d8ffae1859cac80b4b3ca0c60" translate="yes" xml:space="preserve">
          <source>Available in version 2.66 and above.</source>
          <target state="translated">Доступно в версии 2.66 и выше.</target>
        </trans-unit>
        <trans-unit id="46f1e6d4a99c839646d86f37c67e8ce5c790c2f7" translate="yes" xml:space="preserve">
          <source>Available in version 2.77 and above.</source>
          <target state="translated">Доступно в версии 2.77 и выше.</target>
        </trans-unit>
        <trans-unit id="1ee0ed3a84dce710c7a16f8db82978050c4d2850" translate="yes" xml:space="preserve">
          <source>Available in version 2.99 and above.</source>
          <target state="translated">Доступно в версии 2.99 и выше.</target>
        </trans-unit>
        <trans-unit id="d74a27e4b35b5f01b8ce5c3169c1b5a135f15fe4" translate="yes" xml:space="preserve">
          <source>Available in version 3.00 and above.</source>
          <target state="translated">Доступно в версии 3.00 и выше.</target>
        </trans-unit>
        <trans-unit id="eb07b303f6d617426c6371968300dfb4f3ae0614" translate="yes" xml:space="preserve">
          <source>Available in version 6.31 and above.</source>
          <target state="translated">Доступно в версии 6.31 и выше.</target>
        </trans-unit>
        <trans-unit id="e2eb2ee2a8a2421e0f16491afdee27929c55a640" translate="yes" xml:space="preserve">
          <source>Available in version 6.46 and above.</source>
          <target state="translated">Доступно в версии 6.46 и выше.</target>
        </trans-unit>
        <trans-unit id="7b80e477803719c627e591ee3d93e9c48ad902d2" translate="yes" xml:space="preserve">
          <source>Available in version 6.48 and above.</source>
          <target state="translated">Доступно в версии 6.48 и выше.</target>
        </trans-unit>
        <trans-unit id="aec275cec443caa644465799fc156b88fcadd8ce" translate="yes" xml:space="preserve">
          <source>Available in version 6.52 and above.</source>
          <target state="translated">Доступно в версии 6.52 и выше.</target>
        </trans-unit>
        <trans-unit id="4c5736820a885b4b84bf41953dc520dbc9201d97" translate="yes" xml:space="preserve">
          <source>Available in version 6.5503 and above.</source>
          <target state="translated">Доступно в версии 6.5503 и выше.</target>
        </trans-unit>
        <trans-unit id="608b36cf2b4b343801fc146cfc4244281c6223d0" translate="yes" xml:space="preserve">
          <source>Available in version 6.64 and above.</source>
          <target state="translated">Доступно в версии 6.64 и выше.</target>
        </trans-unit>
        <trans-unit id="0d6ce3bbbc75b8e9071a24da666baed09d9b758d" translate="yes" xml:space="preserve">
          <source>Available on 64 bit OpenVMS 8.2 and later. (VMS)</source>
          <target state="translated">Доступно на 64-битной OpenVMS 8.2 и более поздних версиях.(VMS)</target>
        </trans-unit>
        <trans-unit id="61cd670e85d7eb394067cdccaf9865a921e8dfe4" translate="yes" xml:space="preserve">
          <source>Available only for socket handles, and it does what the &lt;code&gt;ioctlsocket()&lt;/code&gt; call in the Winsock API does. (Win32)</source>
          <target state="translated">Доступно только для дескрипторов сокетов, и он выполняет то же самое, что и &lt;code&gt;ioctlsocket()&lt;/code&gt; в Winsock API. (Win32)</target>
        </trans-unit>
        <trans-unit id="7ff7a29d7d279f81c65111e3969b0de8be5b1d10" translate="yes" xml:space="preserve">
          <source>Available only for socket handles. (RISC OS)</source>
          <target state="translated">Доступно только для ручек-розеток.(RISC OS)</target>
        </trans-unit>
        <trans-unit id="9f1e3ff1138fe80a24c7ddf73407362168941db0" translate="yes" xml:space="preserve">
          <source>Available only under threaded builds, this function allocates an entry in &lt;code&gt;PL_stashpad&lt;/code&gt; for the stash passed to it.</source>
          <target state="translated">Доступная только в многопоточных сборках, эта функция выделяет запись в &lt;code&gt;PL_stashpad&lt;/code&gt; для переданного ей тайника .</target>
        </trans-unit>
        <trans-unit id="e829311778d72727fd390df6d086e72d016b6e9b" translate="yes" xml:space="preserve">
          <source>Avoid /usr/ucb/cc.</source>
          <target state="translated">Избегайте /usr/ucb/cc.</target>
        </trans-unit>
        <trans-unit id="20382d66f57ab5b9e0eec4292fa20991e9ee50cf" translate="yes" xml:space="preserve">
          <source>Avoid &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; where using &lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; and &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; would work.</source>
          <target state="translated">Избегайте использования &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; где можно использовать &lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; и &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="653557f5998e677614fe1c110b44a8530b1a3295" translate="yes" xml:space="preserve">
          <source>Avoid assignments in conditionals, but if they're unavoidable, use extra paren, e.g. &quot;if (a &amp;amp;&amp;amp; (b = c)) ...&quot;</source>
          <target state="translated">Избегайте присвоений в условных выражениях, но если они неизбежны, используйте дополнительный парен, например, &amp;laquo;if (a &amp;amp;&amp;amp; (b = c)) ...&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="12cd7881c58cc2ba233002bb3f616c6a3c8332a8" translate="yes" xml:space="preserve">
          <source>Avoid barewords if you can, especially all lowercase ones. You can't tell by just looking at it whether a bareword is a function or a string. By using quotes on strings and parentheses on function calls, you won't ever get them confused.</source>
          <target state="translated">Избегайте пустых слов,если можете,особенно всех строчных.Вы не можете определить,является ли голое слово функцией или строкой.Используя кавычки на строках и круглые скобки на вызовах функций,вы никогда не запутаете их.</target>
        </trans-unit>
        <trans-unit id="a2c60caa765bc1191575d1eafdff1bfe2d3195d5" translate="yes" xml:space="preserve">
          <source>Avoid class name tests like: &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; . Generally you can delete the &lt;code&gt;eq 'FOO'&lt;/code&gt; part with no harm at all. Let the objects look after themselves! Generally, avoid hard-wired class names as far as possible.</source>
          <target state="translated">Избегайте проверки имени класса, например: &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; . Как правило, вы можете удалить часть &lt;code&gt;eq 'FOO'&lt;/code&gt; без всякого вреда. Пусть предметы позаботятся о себе! Как правило, по возможности избегайте зашитых имен классов.</target>
        </trans-unit>
        <trans-unit id="98206b093bcf40d6e074eb698543fd4b6a25d539" translate="yes" xml:space="preserve">
          <source>Avoid keeping any state information in your packages. It makes it difficult for multiple other packages to use yours. Keep state information in objects.</source>
          <target state="translated">Избегайте хранения любой государственной информации в ваших посылках.Это затрудняет использование вашего пакета несколькими другими пакетами.Хранить информацию о состоянии в объектах.</target>
        </trans-unit>
        <trans-unit id="b40cce256d04ce45459ded87307f5f3e8ae2760b" translate="yes" xml:space="preserve">
          <source>Avoid libucb.</source>
          <target state="translated">Избегайте либукба.</target>
        </trans-unit>
        <trans-unit id="b3ba9403766f60fa8e210155287efa18e1a9e739" translate="yes" xml:space="preserve">
          <source>Avoid starting a new top-level hierarchy, especially if a suitable hierarchy already exists under which you could place your module.</source>
          <target state="translated">Избегайте запуска новой иерархии верхнего уровня,особенно если уже существует подходящая иерархия,под которую можно разместить модуль.</target>
        </trans-unit>
        <trans-unit id="fd4b693367a701b3345901dbd6d82b5f0d6ce929" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt;) or `backticks` in a void context, that is, when you just throw away their return values. Those functions all have return values, so use them. Otherwise use a &lt;code&gt;foreach()&lt;/code&gt; loop or the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; function instead.</source>
          <target state="translated">Избегайте использования &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; (или &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; ) или `обратных кавычек` в пустом контексте, то есть когда вы просто отбрасываете их возвращаемые значения. Все эти функции имеют возвращаемые значения, поэтому используйте их. В противном случае используйте вместо этого цикл &lt;code&gt;foreach()&lt;/code&gt; или функцию &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="342c7154cb2c0ee3ba1afbccab12770600c98259" translate="yes" xml:space="preserve">
          <source>Avoid using hardcoded test numbers whenever possible (the EXPECTED/GOT found in t/op/tie.t is much more maintainable, and gives better failure reports).</source>
          <target state="translated">По возможности избегайте использования жестко закодированных номеров тестов (EXPECTED/GOT,найденный в t/op/tie.t,гораздо более удобен в обслуживании и дает лучшие отчеты о сбоях).</target>
        </trans-unit>
        <trans-unit id="67de3787b457172bffd90b9f3faae7435e0dae2f" translate="yes" xml:space="preserve">
          <source>Avoid using qx// and system() unless you are testing for them. If you do use them, make sure that you cover _all_ perl platforms.</source>
          <target state="translated">Избегайте использования qx//и system(),если только вы не тестируете их.Если вы используете их,убедитесь,что вы покрываете _all_perl платформы.</target>
        </trans-unit>
        <trans-unit id="0e92b74d5a979c26e7eb18be8603b8359a1d07fd" translate="yes" xml:space="preserve">
          <source>Avoiding Pipe Deadlocks</source>
          <target state="translated">Избегание трубных тупиков</target>
        </trans-unit>
        <trans-unit id="6e3313e507db79bbbaea78fb241509ccc328aba1" translate="yes" xml:space="preserve">
          <source>Avoiding repetitions</source>
          <target state="translated">Предотвращение повторений</target>
        </trans-unit>
        <trans-unit id="3721e8be2f4b8bf2c63f63312cdfa53888d8430d" translate="yes" xml:space="preserve">
          <source>Awk Traps</source>
          <target state="translated">Оук Ловушки</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="bd2b125cd8de6e0701cdac6ee17fd331ce4a27c2" translate="yes" xml:space="preserve">
          <source>B - The Perl Compiler Backend</source>
          <target state="translated">Б-Бэкэнд компилятора на Perl</target>
        </trans-unit>
        <trans-unit id="b918b0aa2af36ef03dc69f56d877870ae5fd0aee" translate="yes" xml:space="preserve">
          <source>B-regex</source>
          <target state="translated">B-regex</target>
        </trans-unit>
        <trans-unit id="4995b54293f85c5bb7976c9e655accd8fbd573ea" translate="yes" xml:space="preserve">
          <source>B. UNPACK</source>
          <target state="translated">B.UNPACK</target>
        </trans-unit>
        <trans-unit id="52b9020e3a04e67bbf5d1e8e1b850a5ce003849b" translate="yes" xml:space="preserve">
          <source>B::AV Methods</source>
          <target state="translated">В:::AV Методы</target>
        </trans-unit>
        <trans-unit id="dc2dfb25dd4ed2146470cd57ee95edac91f0306b" translate="yes" xml:space="preserve">
          <source>B::BINOP Method</source>
          <target state="translated">В::Биноп Метод</target>
        </trans-unit>
        <trans-unit id="d151bd0866d55b4bfc156b14f486f63bf8d29ea8" translate="yes" xml:space="preserve">
          <source>B::BM Methods</source>
          <target state="translated">В::БМ Методы</target>
        </trans-unit>
        <trans-unit id="9055e894e201b212c293a29798f1091ff6d20491" translate="yes" xml:space="preserve">
          <source>B::COP Methods</source>
          <target state="translated">В::Методы КС</target>
        </trans-unit>
        <trans-unit id="ad1f22ba3c95252a59969a1a218e1111bb139542" translate="yes" xml:space="preserve">
          <source>B::CV Methods</source>
          <target state="translated">В::CV Методы</target>
        </trans-unit>
        <trans-unit id="c5987daa2aa6d7fac584555a51956a3b445f0843" translate="yes" xml:space="preserve">
          <source>B::Concise</source>
          <target state="translated">B::Concise</target>
        </trans-unit>
        <trans-unit id="0e99aa1c3be052d8105291584d6f4ee6b16f397c" translate="yes" xml:space="preserve">
          <source>B::Concise - Walk Perl syntax tree, printing concise info about ops</source>
          <target state="translated">B::Краткое-Пройдитесь по синтаксическому дереву Perl,распечатав краткую информацию об операторах.</target>
        </trans-unit>
        <trans-unit id="d98d2c8e235d9494074cb2fd60569e8b9c12b5d6" translate="yes" xml:space="preserve">
          <source>B::Concise::reset_sequence()</source>
          <target state="translated">B::Concise::reset_sequence()</target>
        </trans-unit>
        <trans-unit id="553185e97d716b58f74fa982526081cbc642ddf4" translate="yes" xml:space="preserve">
          <source>B::Debug</source>
          <target state="translated">B::Debug</target>
        </trans-unit>
        <trans-unit id="7b2b543f6bc70176bf812e6ac813955a4e8d32ab" translate="yes" xml:space="preserve">
          <source>B::Debug - Walk Perl syntax tree, printing debug info about ops</source>
          <target state="translated">B::Отладка-Прогулка по синтаксическому дереву Perl,печать отладочной информации об операционных системах</target>
        </trans-unit>
        <trans-unit id="b2fba5e2c554e2a4492f4d6c8ba33e2e0b6a2475" translate="yes" xml:space="preserve">
          <source>B::Deparse</source>
          <target state="translated">B::Deparse</target>
        </trans-unit>
        <trans-unit id="45e0d250a6312bd5838511c6a45d0f47e7a90193" translate="yes" xml:space="preserve">
          <source>B::Deparse - Perl compiler backend to produce perl code</source>
          <target state="translated">B::Deparse-Бэкэнд компилятора Perl для генерации perl кода</target>
        </trans-unit>
        <trans-unit id="ef79da6fd85d8fa02ee778f0544d6ba33e8b3b18" translate="yes" xml:space="preserve">
          <source>B::Deparse can also be used on a sub-by-sub basis from other perl programs.</source>
          <target state="translated">B::Депарсив также может быть использован на суб-субподоснове из других программ perl.</target>
        </trans-unit>
        <trans-unit id="187ec0fb4a4a04196e808c398a93708ba9275615" translate="yes" xml:space="preserve">
          <source>B::Deparse is a backend module for the Perl compiler that generates perl source code, based on the internal compiled structure that perl itself creates after parsing a program. The output of B::Deparse won't be exactly the same as the original source, since perl doesn't keep track of comments or whitespace, and there isn't a one-to-one correspondence between perl's syntactical constructions and their compiled form, but it will often be close. When you use the &lt;b&gt;-p&lt;/b&gt; option, the output also includes parentheses even when they are not required by precedence, which can make it easy to see if perl is parsing your expressions the way you intended.</source>
          <target state="translated">B :: Deparse - это внутренний модуль для компилятора Perl, который генерирует исходный код perl на основе внутренней скомпилированной структуры, которую сам perl создает после синтаксического анализа программы. Вывод B :: Deparse не будет в точности таким же, как исходный исходный код, поскольку perl не отслеживает комментарии или пробелы, и нет однозначного соответствия между синтаксическими конструкциями perl и их скомпилированными форма, но часто будет близко. Когда вы используете опцию &lt;b&gt;-p&lt;/b&gt; , вывод также включает круглые скобки, даже если они не требуются по приоритету, что может помочь увидеть, анализирует ли Perl ваши выражения так, как вы планировали.</target>
        </trans-unit>
        <trans-unit id="fc31dbbc2ee8c07aa355011d5f82b2d63c5b6c00" translate="yes" xml:space="preserve">
          <source>B::GV Methods</source>
          <target state="translated">В::GV методы</target>
        </trans-unit>
        <trans-unit id="f507161ede02e20a9575d2189eb0e0194566355a" translate="yes" xml:space="preserve">
          <source>B::HV Methods</source>
          <target state="translated">В::HV методы</target>
        </trans-unit>
        <trans-unit id="e300bd8b4c95a3624e2aa219bf974f0118cef860" translate="yes" xml:space="preserve">
          <source>B::IO Methods</source>
          <target state="translated">В::IO Методы</target>
        </trans-unit>
        <trans-unit id="35a3e95640c426b65cf8d850194a4f17b3215f07" translate="yes" xml:space="preserve">
          <source>B::IO objects derive from IO objects and you will get more information from the IO object itself.</source>
          <target state="translated">B::Объекты IO производятся от объектов IO,и вы получите больше информации от самого объекта IO.</target>
        </trans-unit>
        <trans-unit id="9329448ffaface57d41ef2b007c24eb18197a68b" translate="yes" xml:space="preserve">
          <source>B::IV Methods</source>
          <target state="translated">В::IV Методы</target>
        </trans-unit>
        <trans-unit id="41ae1a755811beebf8ac2f49c8c1656753f2209c" translate="yes" xml:space="preserve">
          <source>B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM (5.9.5 and earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO. These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;. For the 5.10.x branch, (</source>
          <target state="translated">В::IV,В::NV,В::RV,В::PV,В::PVIV,В::PVNV,В::PVMG,В::BM (5.9.5 и ранее),В::PVLV,В::AV,В::HV,В::CV,В::GV,В::FM,В::IO.Эти классы в явном виде соответствуют лежащим в основе C структурам с похожими именами.Иерархия наследования имитирует лежащее в основе С &quot;наследование&quot;.Для ветви 5.10.x,(</target>
        </trans-unit>
        <trans-unit id="47e3586b1ed7a7d56d8afab1073b55905757ce29" translate="yes" xml:space="preserve">
          <source>B::LISTOP Method</source>
          <target state="translated">В::Метод LISTOP</target>
        </trans-unit>
        <trans-unit id="04688acb0cbf70d25c11e0314b06463ce4bde512" translate="yes" xml:space="preserve">
          <source>B::LOGOP Method</source>
          <target state="translated">В::Метод ЛОГОПа</target>
        </trans-unit>
        <trans-unit id="7263ed2af022568be1b85d473eacf000486dd697" translate="yes" xml:space="preserve">
          <source>B::LOOP Methods</source>
          <target state="translated">В::Методы LOOP</target>
        </trans-unit>
        <trans-unit id="83ceb8c6feb2e3fc2f3bf822a42dbcd07ff89ff2" translate="yes" xml:space="preserve">
          <source>B::MAGIC Methods</source>
          <target state="translated">В::MAGIC Методы</target>
        </trans-unit>
        <trans-unit id="69a559c9b6f1bb1dde02c8b48310f4be42a91370" translate="yes" xml:space="preserve">
          <source>B::METHOP Methods (Since Perl 5.22)</source>
          <target state="translated">В::Методы Метода Метода (с версии Perl 5.22)</target>
        </trans-unit>
        <trans-unit id="ce0314b7717adf8f5e71d17e31bd593c95324507" translate="yes" xml:space="preserve">
          <source>B::NV Methods</source>
          <target state="translated">В::NV Методы</target>
        </trans-unit>
        <trans-unit id="c0b4baaa7ca50074884462d7620fd16447077eec" translate="yes" xml:space="preserve">
          <source>B::OP Methods</source>
          <target state="translated">В::ОП Методы</target>
        </trans-unit>
        <trans-unit id="5409024a3cb7db3e3ab0625fc65de3e420057bb4" translate="yes" xml:space="preserve">
          <source>B::PADLIST Methods</source>
          <target state="translated">В::Методы ПАДЛИСТА</target>
        </trans-unit>
        <trans-unit id="7aa1d371fde2d45d24f6903c528b83b6becc77cd" translate="yes" xml:space="preserve">
          <source>B::PADNAME Methods</source>
          <target state="translated">В::ПАДНАМИ Методы</target>
        </trans-unit>
        <trans-unit id="f042ef0bca656a3a3db2a47dca50963fab567b10" translate="yes" xml:space="preserve">
          <source>B::PADNAMELIST Methods</source>
          <target state="translated">В::Методы ПАДНАМЕЛИСТА</target>
        </trans-unit>
        <trans-unit id="7fc794e6266342d3b9c5605f5dd3acf7f99c4eaf" translate="yes" xml:space="preserve">
          <source>B::PADOP Method</source>
          <target state="translated">В::Метод PADOP</target>
        </trans-unit>
        <trans-unit id="3cfe6d3792643bf75e3768c357ceb15d1fcc2896" translate="yes" xml:space="preserve">
          <source>B::PMOP Methods</source>
          <target state="translated">В::PMOP Методы</target>
        </trans-unit>
        <trans-unit id="935c8ee8b93bca030ffae3839fe2dd9b63ef8ee4" translate="yes" xml:space="preserve">
          <source>B::PV Methods</source>
          <target state="translated">В::PV методы</target>
        </trans-unit>
        <trans-unit id="2ae17602fe4096f70c3f88f15eb8e459f9c75ea9" translate="yes" xml:space="preserve">
          <source>B::PVLV Methods</source>
          <target state="translated">В:::PVLV Методы</target>
        </trans-unit>
        <trans-unit id="974a328507349d20edd58996d04366d5388a2f7c" translate="yes" xml:space="preserve">
          <source>B::PVMG Methods</source>
          <target state="translated">В:::PVMG методы</target>
        </trans-unit>
        <trans-unit id="7210fef12d9bb7c60c3dee3ae3350db4f7b9f9ab" translate="yes" xml:space="preserve">
          <source>B::PVOP Method</source>
          <target state="translated">В::PVOP Метод</target>
        </trans-unit>
        <trans-unit id="6455c3fb933990f5652e2d49c591cb379eb4bf8a" translate="yes" xml:space="preserve">
          <source>B::REGEXP Methods</source>
          <target state="translated">В::REGEXP Методы</target>
        </trans-unit>
        <trans-unit id="5fb9902660751871b51829ac2f4124c1e0f71d1f" translate="yes" xml:space="preserve">
          <source>B::RV Methods</source>
          <target state="translated">В::RV Методы</target>
        </trans-unit>
        <trans-unit id="1bc231286052c317542f678d841b72c83eca59c7" translate="yes" xml:space="preserve">
          <source>B::SV Methods</source>
          <target state="translated">В::SV методы</target>
        </trans-unit>
        <trans-unit id="ba72f1a9a3b75ef02445cdb3be5e5dfd9e626d0a" translate="yes" xml:space="preserve">
          <source>B::SVOP Methods</source>
          <target state="translated">В::SVOP методы</target>
        </trans-unit>
        <trans-unit id="6d49788efca655ce69693e7fc4afeb14e70c0677" translate="yes" xml:space="preserve">
          <source>B::Showlex</source>
          <target state="translated">B::Showlex</target>
        </trans-unit>
        <trans-unit id="950f98354a0be3d4d89c912c00828150ec365f96" translate="yes" xml:space="preserve">
          <source>B::Showlex - Show lexical variables used in functions or files</source>
          <target state="translated">B::Showlex-Показать лексические переменные,используемые в функциях или файлах</target>
        </trans-unit>
        <trans-unit id="fdd28b59d6f44b83715e2f882acc2a2a5588e605" translate="yes" xml:space="preserve">
          <source>B::Terse</source>
          <target state="translated">B::Terse</target>
        </trans-unit>
        <trans-unit id="c493225f0157e4f61a98bb3974699f2af44cb46f" translate="yes" xml:space="preserve">
          <source>B::Terse - Walk Perl syntax tree, printing terse info about ops</source>
          <target state="translated">B::Территория-Прогулка по синтаксическому дереву Perl,печать территориальной информации об операторах.</target>
        </trans-unit>
        <trans-unit id="9f6685ca28bcfea09300907f0826a8f9a2c91850" translate="yes" xml:space="preserve">
          <source>B::UNOP Method</source>
          <target state="translated">В::ЮНОП Метод</target>
        </trans-unit>
        <trans-unit id="69effd3b7e8802f540cc9b9e50328608e6736463" translate="yes" xml:space="preserve">
          <source>B::UNOP_AUX Methods (since 5.22)</source>
          <target state="translated">В::UNOP_AUX Методы (начиная с 5.22)</target>
        </trans-unit>
        <trans-unit id="c85e7a03e5bbe49c04256621164986ed11cb37ba" translate="yes" xml:space="preserve">
          <source>B::Xref</source>
          <target state="translated">B::Xref</target>
        </trans-unit>
        <trans-unit id="651c8208adb3fd49f31423f94f8ac43c0733aa36" translate="yes" xml:space="preserve">
          <source>B::Xref - Generates cross reference reports for Perl programs</source>
          <target state="translated">B::Xref-Генерирует отчеты по перекрёстным ссылкам для программ на Perl.</target>
        </trans-unit>
        <trans-unit id="a61d2719382da67e2a1a2dbd76dd400accca9187" translate="yes" xml:space="preserve">
          <source>BACKWARD COMPATIBILITY AND DEPRECATION</source>
          <target state="translated">ОБРАТНАЯ СОВМЕСТИМОСТЬ И ОБЕСЦЕНИВАНИЕ</target>
        </trans-unit>
        <trans-unit id="e5b45b4fc983ac2702f9e777eee2ac1b1e5f0f20" translate="yes" xml:space="preserve">
          <source>BACKWARDS COMPATIBILITY</source>
          <target state="translated">ОБРАТНАЯ СОВМЕСТИМОСТЬ</target>
        </trans-unit>
        <trans-unit id="bef6eec96c16ae54f978beec72807557ca3a9eaf" translate="yes" xml:space="preserve">
          <source>BASIC METHODS</source>
          <target state="translated">ОСНОВНЫЕ МЕТОДЫ</target>
        </trans-unit>
        <trans-unit id="8cf5cb57c99d3bbd6c48033a11d198c341ee5329" translate="yes" xml:space="preserve">
          <source>BEFORE YOU START WRITING A MODULE</source>
          <target state="translated">ПЕРЕД НАЧАЛОМ НАПИСАНИЯ МОДУЛЯ</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="ed0ab3055b45605d8d3bfeee9675e3115e25dd63" translate="yes" xml:space="preserve">
          <source>BEGIN, UNITCHECK, CHECK, INIT and END</source>
          <target state="translated">Начало,УНИТЧЕК,ЧЕК,ИНИТ и КОНЕЦ</target>
        </trans-unit>
        <trans-unit id="82587c5990d27962027bcd8f44009a394aa03c6d" translate="yes" xml:space="preserve">
          <source>BENCHMARKS</source>
          <target state="translated">BENCHMARKS</target>
        </trans-unit>
        <trans-unit id="3eb8dc2707d319cff39e903c8f9e907ffde6faaa" translate="yes" xml:space="preserve">
          <source>BEST PRACTICE</source>
          <target state="translated">ЛУЧШАЯ ПРАКТИКА</target>
        </trans-unit>
        <trans-unit id="d6b920160b07e6d8ef62aeb966afe0559c1c4da6" translate="yes" xml:space="preserve">
          <source>BINMODE</source>
          <target state="translated">BINMODE</target>
        </trans-unit>
        <trans-unit id="9afa89ba4b3340d7bc1c3e18c656cfc5abf6d9a7" translate="yes" xml:space="preserve">
          <source>BOOLEAN = less-&amp;gt;of( FEATURE )</source>
          <target state="translated">BOOLEAN = меньше-&amp;gt; из (ФУНКЦИЯ)</target>
        </trans-unit>
        <trans-unit id="247befebedd2ed6823933439f49eb30a07d09dca" translate="yes" xml:space="preserve">
          <source>BRACKET NOTATION</source>
          <target state="translated">УСЛОВНЫЕ ЗНАКИ</target>
        </trans-unit>
        <trans-unit id="e7772b5b926c191f6bd98767963948f3ffc93baa" translate="yes" xml:space="preserve">
          <source>BS2000 POSIX doesn't support the shebang notation (&lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; ), so you have to use the following lines instead:</source>
          <target state="translated">BS2000 POSIX не поддерживает нотацию shebang ( &lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; ), поэтому вместо этого вам нужно использовать следующие строки:</target>
        </trans-unit>
        <trans-unit id="664c8d2ddb2e4dc2ea085ed16d6df4504ec03ee2" translate="yes" xml:space="preserve">
          <source>BSD::Resource on Solaris</source>
          <target state="translated">BSD::Ресурс на Солярисе</target>
        </trans-unit>
        <trans-unit id="df51adc50ecdca424b6145ec6164f8c39197a14c" translate="yes" xml:space="preserve">
          <source>BSD::Resource versions earlier than 1.09 do not compile on Solaris with perl 5.6.0 and higher, for the same reasons as Proc::ProcessTable. BSD::Resource versions starting from 1.09 have a workaround for the problem.</source>
          <target state="translated">BSD::Resource версии ранее 1.09 не компилируются на Solaris с perl 5.6.0 и выше,по тем же причинам,что и Proc::ProcessTable.BSD::Resource версии начиная с 1.09 имеют обходной путь.</target>
        </trans-unit>
        <trans-unit id="d7fe8d7ec43bafda1404b3733deb73b25528fcbd" translate="yes" xml:space="preserve">
          <source>BSLOADLIBS</source>
          <target state="translated">BSLOADLIBS</target>
        </trans-unit>
        <trans-unit id="502dbddd3b35610af6911c0fbc9ca3be4bfe6d63" translate="yes" xml:space="preserve">
          <source>BTW. Beware too of pressure from managers who see you speed a program up by 50% of the runtime once, only to get a request one month later to do the same again (true story) - you'll just have to point out you're only human, even if you are a Perl programmer, and you'll see what you can do...</source>
          <target state="translated">КСТАТИ.Остерегайтесь слишком большого давления со стороны менеджеров,которые видят,что вы один раз ускоряете программу на 50% от времени выполнения,только для того,чтобы через месяц получить просьбу сделать то же самое снова (правдивая история)-вы просто должны будете указать,что вы всего лишь человек,даже если вы программист на Perl,и вы увидите,что вы можете сделать....</target>
        </trans-unit>
        <trans-unit id="8b9146b4f38600ca0e41fb96135f743cfdb11eec" translate="yes" xml:space="preserve">
          <source>BUG REPORTING</source>
          <target state="translated">ДОКЛАД ОТЧЕТА О БУГЕ</target>
        </trans-unit>
        <trans-unit id="664f572fef857b1dfc7d6e286d22026a2508e1e5" translate="yes" xml:space="preserve">
          <source>BUG REPORTS</source>
          <target state="translated">БУГ-ОТЧЕТЫ</target>
        </trans-unit>
        <trans-unit id="5dda8c520f4fbfda1830a8a497556d722a3fd113" translate="yes" xml:space="preserve">
          <source>BUGS</source>
          <target state="translated">BUGS</target>
        </trans-unit>
        <trans-unit id="9f989473548a594a947b969757db7fc06ca6a262" translate="yes" xml:space="preserve">
          <source>BUGS AND CAVEATS</source>
          <target state="translated">ОШИБКИ И ПРЕДОСТЕРЕЖЕНИЯ</target>
        </trans-unit>
        <trans-unit id="fe771929835192040a55c6b146d4bbdcf0038546" translate="yes" xml:space="preserve">
          <source>BUGS AND IRRITATIONS</source>
          <target state="translated">ОШИБКИ И РАЗДРАЖЕНИЯ</target>
        </trans-unit>
        <trans-unit id="affef23bcfe821a649489c10e4d45ae3607b1ccb" translate="yes" xml:space="preserve">
          <source>BUGS AND LIMITATIONS</source>
          <target state="translated">ОШИБКИ И ОГРАНИЧЕНИЯ</target>
        </trans-unit>
        <trans-unit id="118a34d613c11c790c196c946968113aa8bc32aa" translate="yes" xml:space="preserve">
          <source>BUGS AND PITFALLS</source>
          <target state="translated">ОШИБКИ И ПОДВОДНЫЕ КАМНИ</target>
        </trans-unit>
        <trans-unit id="a16fd7f9de623a809defab1d94048e0eded9677b" translate="yes" xml:space="preserve">
          <source>BUGS AND WARNINGS</source>
          <target state="translated">ОШИБКИ И ПРЕДУПРЕЖДЕНИЯ</target>
        </trans-unit>
        <trans-unit id="2f8e6e225c82badf6f8a92aed6ef242d4dc4d03b" translate="yes" xml:space="preserve">
          <source>BUGS ON CYGWIN</source>
          <target state="translated">БУГГЫ НА ЦИГВИНЕ</target>
        </trans-unit>
        <trans-unit id="11f69a17d772a3f0d39aa116f097397dc1dac971" translate="yes" xml:space="preserve">
          <source>BUGS and CAVEATS</source>
          <target state="translated">БУГИ и КАВЕАТЫ</target>
        </trans-unit>
        <trans-unit id="ccf8d27dca59cf8914b7de42279bcf54b381c80d" translate="yes" xml:space="preserve">
          <source>BUGS is an email or url to post bug reports. For modules with UPSTREAM =&amp;gt; 'blead', use perl5-porters@perl.org. rt.cpan.org appears to automatically provide a URL for CPAN modules; any value given here overrides the default: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=&lt;/a&gt;$ModuleName</source>
          <target state="translated">BUGS - это электронная почта или URL-адрес для публикации отчетов об ошибках. Для модулей с UPSTREAM =&amp;gt; 'blead' используйте perl5-porters@perl.org. Кажется, что rt.cpan.org автоматически предоставляет URL для модулей CPAN; любое значение, указанное здесь, отменяет значение по умолчанию: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=&lt;/a&gt; $ ModuleName</target>
        </trans-unit>
        <trans-unit id="4fa4a173033ffa9b27f16cd2d7b309c255617591" translate="yes" xml:space="preserve">
          <source>BUGS/CAVEATS/etc</source>
          <target state="translated">BUGS/CAVEATS/etc</target>
        </trans-unit>
        <trans-unit id="9b8dfdff736c5b1dbf956b89d8a9d4fd925dacd2" translate="yes" xml:space="preserve">
          <source>BUILD</source>
          <target state="translated">BUILD</target>
        </trans-unit>
        <trans-unit id="0e162e98df920882beaaa37c9fd3fd9860be2bff" translate="yes" xml:space="preserve">
          <source>BUILD AND INSTALL</source>
          <target state="translated">СБОРКА И УСТАНОВКА</target>
        </trans-unit>
        <trans-unit id="80ef3501d89bb441f42a9aac769a351966bde435" translate="yes" xml:space="preserve">
          <source>BUILD NEW EXTENSIONS</source>
          <target state="translated">СОЗДАВАТЬ НОВЫЕ РАСШИРЕНИЯ</target>
        </trans-unit>
        <trans-unit id="a5d9fc029fc161e583884fa605ea5dd4bf5b0226" translate="yes" xml:space="preserve">
          <source>BUILDING AND INSTALLING MODULES ON DOS</source>
          <target state="translated">ПОСТРОЕНИЕ И УСТАНОВКА МОДУЛЕЙ ПО ДОЗИРОВКЕ</target>
        </trans-unit>
        <trans-unit id="68c9d11aacf08e68cf9222616220471f55a4230e" translate="yes" xml:space="preserve">
          <source>BUILDING PERL FOR OPENVOS</source>
          <target state="translated">СТРОИТЕЛЬНЫЙ ПЕРЛ ДЛЯ OPENVOS</target>
        </trans-unit>
        <trans-unit id="b603dd0f789cea0b71cf17b9cadf6a885369ee6d" translate="yes" xml:space="preserve">
          <source>BUILDING PERL ON AMIGAOS</source>
          <target state="translated">ПЕРЛ НА АМИГАЯХ</target>
        </trans-unit>
        <trans-unit id="d5bdc31108d4219c97e8c1b7e29e0629da746aa9" translate="yes" xml:space="preserve">
          <source>BUNDLES</source>
          <target state="translated">BUNDLES</target>
        </trans-unit>
        <trans-unit id="92b48cc3d13ac12b362038111cf08e5cf8b03696" translate="yes" xml:space="preserve">
          <source>Back before Perl had the XS system for connecting with C libraries, programmers used to get library constants by reading through the C header files. You may still see &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; or similar around - the</source>
          <target state="translated">Еще до того, как в Perl появилась система XS для соединения с библиотеками C, программисты получали константы библиотеки путем чтения файлов заголовков C. Вы можете по-прежнему видеть &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; или аналогичный -</target>
        </trans-unit>
        <trans-unit id="4a3e95e64a0aa298ba1dcd060974643f7be2839b" translate="yes" xml:space="preserve">
          <source>Back then, the range 0xD800-0xDFFF was not allocated. Let's split that range in half and use the first half to represent the &lt;code&gt;upper
half of a character&lt;/code&gt; and the second half to represent the &lt;code&gt;lower
half of a character&lt;/code&gt; . That way, you can represent 1024 * 1024 = 1048576 more characters. Now we can store character ranges up to \x{10ffff} even with 16-bit encodings. This pair of half-character is now called a</source>
          <target state="translated">Тогда диапазон 0xD800-0xDFFF не выделялся. Давайте разделим этот диапазон пополам и используем первую половину для представления &lt;code&gt;upper half of a character&lt;/code&gt; а вторую половину - для представления &lt;code&gt;lower half of a character&lt;/code&gt; . Таким образом, вы можете представить 1024 * 1024 = 1048576 дополнительных символов. Теперь мы можем хранить диапазоны символов до \ x {10ffff} даже с 16-битными кодировками. Эта пара полусимволов теперь называется</target>
        </trans-unit>
        <trans-unit id="1f9a2a8bbfa8f04b97f0739e8cee87c19e9a7b1a" translate="yes" xml:space="preserve">
          <source>Back to converting data. If you have (or want) data in your system's native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use pack/unpack to convert to/from Unicode.</source>
          <target state="translated">Возвращаемся к преобразованию данных.Если у вас есть (или вы хотите)данные в родной 8-битной кодировке вашей системы (например,Latin-1,EBCDIC и т.д.),вы можете использовать pack/unpack для конвертирования в/из Unicode.</target>
        </trans-unit>
        <trans-unit id="917eb438525299e66d70b4deb11770f40a27eeaa" translate="yes" xml:space="preserve">
          <source>Backend for building test libraries</source>
          <target state="translated">Бэкэнд для создания тестовых библиотек</target>
        </trans-unit>
        <trans-unit id="60865a55d575470308929e5970d44edcbdb31366" translate="yes" xml:space="preserve">
          <source>Background Processes</source>
          <target state="translated">Фоновые процессы</target>
        </trans-unit>
        <trans-unit id="777d367a0813af1945dd6a57f416558fa99c5a72" translate="yes" xml:space="preserve">
          <source>Background and PERL_IMPLICIT_CONTEXT</source>
          <target state="translated">Фон и PERL_IMPLICIT_CONTEXT</target>
        </trans-unit>
        <trans-unit id="82139f465e7bfd51be69bcd2ba2252de65152f38" translate="yes" xml:space="preserve">
          <source>Background yourself like this:</source>
          <target state="translated">Сделай себе такую подоплеку:</target>
        </trans-unit>
        <trans-unit id="1c7bd776caf410341796f267d0b5a33a3e4a0364" translate="yes" xml:space="preserve">
          <source>Backreference to a named capture group. Equivalent to &lt;code&gt;\g{NAME}&lt;/code&gt; .</source>
          <target state="translated">Обратная ссылка на именованную группу захвата. Эквивалентно &lt;code&gt;\g{NAME}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b67830d6a194880657acd61864c65e3027fb02e" translate="yes" xml:space="preserve">
          <source>Backreferences</source>
          <target state="translated">Backreferences</target>
        </trans-unit>
        <trans-unit id="89d9017aad56d057f4819297fea6ec35a3d1c796" translate="yes" xml:space="preserve">
          <source>Backreferences in substitutions use &quot;$&quot; rather than &quot;\&quot;.</source>
          <target state="translated">Ссылки в заменах используют &quot;$&quot;,а не &quot;\&quot;.</target>
        </trans-unit>
        <trans-unit id="c5cf510bfb36856574ecae34fa00822be8b9c589" translate="yes" xml:space="preserve">
          <source>Backslash Sequences</source>
          <target state="translated">Секвенции обратной связи</target>
        </trans-unit>
        <trans-unit id="db35629fab3798cdd79f1bf42fa413127bebc425" translate="yes" xml:space="preserve">
          <source>Backslash is used, as usual, to escape the next character.</source>
          <target state="translated">Обратная косая черта,как обычно,используется,чтобы избежать следующего персонажа.</target>
        </trans-unit>
        <trans-unit id="046c786ef212957156a16429eb6f369b2064b79d" translate="yes" xml:space="preserve">
          <source>Backslash sequence character classes cannot form one of the endpoints of a range. Thus, you can't say:</source>
          <target state="translated">Классы символов обратной последовательности не могут образовывать одну из конечных точек диапазона.Таким образом,вы не можете сказать:</target>
        </trans-unit>
        <trans-unit id="9900e3acb0e0a2eba6b592f80668e5cc6828f6c1" translate="yes" xml:space="preserve">
          <source>Backslash sequences</source>
          <target state="translated">последовательности обратного слеша</target>
        </trans-unit>
        <trans-unit id="c61c0b16c1836e4070c1986f40a121b830a65cf5" translate="yes" xml:space="preserve">
          <source>Backslashed characters are either replaced with corresponding literal strings (as with &lt;code&gt;\{&lt;/code&gt;), or else they generate special nodes in the finite automaton (as with &lt;code&gt;\b&lt;/code&gt; ). Characters special to the RE engine (such as &lt;code&gt;|&lt;/code&gt;) generate corresponding nodes or groups of nodes. &lt;code&gt;(?#...)&lt;/code&gt; comments are ignored. All the rest is either converted to literal strings to match, or else is ignored (as is whitespace and &lt;code&gt;#&lt;/code&gt; -style comments if &lt;code&gt;/x&lt;/code&gt; is present).</source>
          <target state="translated">Символы с обратной косой чертой либо заменяются соответствующими буквенными строками (как с &lt;code&gt;\{&lt;/code&gt; ), либо генерируют специальные узлы в конечном автомате (как с &lt;code&gt;\b&lt;/code&gt; ). Специальные символы для механизма RE (такие как &lt;code&gt;|&lt;/code&gt; ) создают соответствующие узлы или группы узлов. &lt;code&gt;(?#...)&lt;/code&gt; комментарии игнорируются. Все остальное либо преобразуется в буквальные строки для сопоставления, либо игнорируется (как пробелы и комментарии в стиле &lt;code&gt;#&lt;/code&gt; , если присутствует &lt;code&gt;/x&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="396b0c95d21c97a92647624c67163f81645740c9" translate="yes" xml:space="preserve">
          <source>Backslashed metacharacters in Perl are alphanumeric, such as &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; . Unlike some other regular expression languages, there are no backslashed symbols that aren't alphanumeric. So anything that looks like \\, \(, \), \[, \], \{, or \} is always interpreted as a literal character, not a metacharacter. This was once used in a common idiom to disable or quote the special meanings of regular expression metacharacters in a string that you want to use for a pattern. Simply quote all non-&quot;word&quot; characters:</source>
          <target state="translated">Метасимволы с обратной косой чертой в Perl являются буквенно-цифровыми, например &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; . В отличие от некоторых других языков регулярных выражений, здесь нет буквенно-цифровых символов с обратной косой чертой. Таким образом, все, что выглядит как \\, \ (, \), \ [, \], \ {или \}, всегда интерпретируется как буквальный символ, а не как метасимвол. Когда-то это использовалось в общей идиоме для отключения или цитирования специальных значений метасимволов регулярного выражения в строке, которую вы хотите использовать для шаблона. Просто заключайте в кавычки все символы, не являющиеся словами:</target>
        </trans-unit>
        <trans-unit id="5ad3bd6856b2f78166ba432a9cdf4da8413a4090" translate="yes" xml:space="preserve">
          <source>Backslashes parentheses &lt;code&gt;()&lt;/code&gt; in command line arguments. Doesn't handle recursive Makefile &lt;code&gt;$(...)&lt;/code&gt; constructs, but handles simple ones.</source>
          <target state="translated">В аргументах командной строки используется обратная косая черта &lt;code&gt;()&lt;/code&gt; . Не обрабатывает рекурсивные конструкции Makefile &lt;code&gt;$(...)&lt;/code&gt; , но обрабатывает простые.</target>
        </trans-unit>
        <trans-unit id="8ef1c0d1318e1460dedacce3731d309fc7ffbb8a" translate="yes" xml:space="preserve">
          <source>Backticks &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="translated">Обратные кавычки &lt;code&gt;``&lt;/code&gt; (см. &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;Операторы ввода-вывода в perlop&lt;/a&gt; ) с командой, содержащей метасимволы перенаправления или оболочки;</target>
        </trans-unit>
        <trans-unit id="6e2b605f65ba36a3d929c62881915b96a794f8f1" translate="yes" xml:space="preserve">
          <source>Backticks create a subprocess, and pass the enclosed string to it for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified.</source>
          <target state="translated">Обратные кавычки создают подпроцесс и передают ему заключенную строку для выполнения как DCL-команду. Поскольку подпроцесс создается напрямую через &lt;code&gt;lib$spawn()&lt;/code&gt; , можно указать любую допустимую командную строку DCL.</target>
        </trans-unit>
        <trans-unit id="34532d18ad2d0f70e2d7b957fabc96ee06bc62fe" translate="yes" xml:space="preserve">
          <source>Backtracking</source>
          <target state="translated">Backtracking</target>
        </trans-unit>
        <trans-unit id="6e522c194b60635ece31d387544d1195051e629c" translate="yes" xml:space="preserve">
          <source>Backtracking control verbs</source>
          <target state="translated">Управляющие глаголы обратного хода</target>
        </trans-unit>
        <trans-unit id="14496432005368ea983df3ea81b1252443b8ee8b" translate="yes" xml:space="preserve">
          <source>Backtracking during the relentless search for a match may be a waste of time, particularly when the match is bound to fail. Consider the simple pattern</source>
          <target state="translated">Отслеживание во время беспощадного поиска матча может быть пустой тратой времени,особенно когда матч будет неудачным.Рассмотрим простой шаблон</target>
        </trans-unit>
        <trans-unit id="0bce7971052281b2bb5edb4f3a21f79dd6904b31" translate="yes" xml:space="preserve">
          <source>Backtracking is more efficient than repeated tries with different regular expressions. If there are several regular expressions and a match with any of them is acceptable, then it is possible to combine them into a set of alternatives. If the individual expressions are input data, this can be done by programming a join operation. We'll exploit this idea in an improved version of the &lt;code&gt;simple_grep&lt;/code&gt; program: a program that matches multiple patterns:</source>
          <target state="translated">Поиск с возвратом более эффективен, чем повторные попытки с разными регулярными выражениями. Если существует несколько регулярных выражений и соответствие любому из них допустимо, то их можно объединить в набор альтернатив. Если отдельные выражения являются входными данными, это можно сделать, запрограммировав операцию соединения. Мы будем использовать эту идею в улучшенной версии программы &lt;code&gt;simple_grep&lt;/code&gt; : программы, которая соответствует нескольким шаблонам:</target>
        </trans-unit>
        <trans-unit id="fd4a1f65749d89056abcaeac3722a7b7a8fe75a1" translate="yes" xml:space="preserve">
          <source>Backward Compatibility</source>
          <target state="translated">Обратная совместимость</target>
        </trans-unit>
        <trans-unit id="23a7808b48afc84b0dceb9136590ca7bfdbb9b77" translate="yes" xml:space="preserve">
          <source>Backward compatibility</source>
          <target state="translated">Обратная совместимость</target>
        </trans-unit>
        <trans-unit id="ec09211f4889a2c8a77bac08067eb8783a4cd974" translate="yes" xml:space="preserve">
          <source>Backward compatible boilerplate</source>
          <target state="translated">обратно совместимая шаблонная плита</target>
        </trans-unit>
        <trans-unit id="8fd78925dba59eef91afba0cdabe923520e5ee69" translate="yes" xml:space="preserve">
          <source>Backwards compatibility</source>
          <target state="translated">Обратная совместимость</target>
        </trans-unit>
        <trans-unit id="9cec2366e742bda57450610acf903181d2989bf8" translate="yes" xml:space="preserve">
          <source>Bad example:</source>
          <target state="translated">Плохой пример:</target>
        </trans-unit>
        <trans-unit id="55cc23ba5301ba2564daa62213188ebb8c917e57" translate="yes" xml:space="preserve">
          <source>Bailout result token.</source>
          <target state="translated">Жетон результата спасения.</target>
        </trans-unit>
        <trans-unit id="c9c7caaefe38d5bc0e42cffe87236c93a6e055ee" translate="yes" xml:space="preserve">
          <source>Bal&amp;aacute;zs Szab&amp;oacute; (dLux), dlux@kapu.hu</source>
          <target state="translated">Балаж Сабо (dLux), dlux@kapu.hu</target>
        </trans-unit>
        <trans-unit id="528dadc6eada08b37b8564a84bbd615fedfa3a6d" translate="yes" xml:space="preserve">
          <source>Bar.pm</source>
          <target state="translated">Bar.pm</target>
        </trans-unit>
        <trans-unit id="991cc000e0ed51287d06994419ec5b5150b2fbbf" translate="yes" xml:space="preserve">
          <source>Bar.xs</source>
          <target state="translated">Bar.xs</target>
        </trans-unit>
        <trans-unit id="4d1ae41c7e90ad9133f0cec4b012d051f81574f4" translate="yes" xml:space="preserve">
          <source>Barewords</source>
          <target state="translated">Barewords</target>
        </trans-unit>
        <trans-unit id="6be542a3a79d103a3744357ed20ec40db010c97c" translate="yes" xml:space="preserve">
          <source>Barewords are not covered by overloaded string constants.</source>
          <target state="translated">Голые слова не покрываются перегруженными строковыми константами.</target>
        </trans-unit>
        <trans-unit id="a58b8ede3c3c15995119146605014af774c7bcd7" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Compress modules</source>
          <target state="translated">Базовый класс для IO::Компрессорные модули</target>
        </trans-unit>
        <trans-unit id="1aecc52f6145193c99cc41e745488c8d94f4db0b" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Uncompress modules</source>
          <target state="translated">Базовый класс для модулей ввода-вывода::Некомпрессионные модули</target>
        </trans-unit>
        <trans-unit id="9410f6a2867439548603d6c52d5c59ef4562fa7b" translate="yes" xml:space="preserve">
          <source>Base Structures</source>
          <target state="translated">Базовые конструкции</target>
        </trans-unit>
        <trans-unit id="082fae7b28f65e5cb911e0f3f3f15b07bb66cbb1" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied handles</source>
          <target state="translated">Определения базового класса для связанных ручек</target>
        </trans-unit>
        <trans-unit id="007ee9121a8b9e57fcd866ceebd36b23a00f0fde" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied hashes</source>
          <target state="translated">Определения базового класса для связанных хешей</target>
        </trans-unit>
        <trans-unit id="b6b455ad8f579493b53af2265bc184f2ba6c6cbb" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied scalars</source>
          <target state="translated">Определения базового класса для связанных скаляров</target>
        </trans-unit>
        <trans-unit id="9cae4a150d12d8ffc0b3fa77692959a6c4bfb799" translate="yes" xml:space="preserve">
          <source>Base class for ALL classes (blessed references)</source>
          <target state="translated">Базовый класс для ВСЕХ классов (благословенные ссылки)</target>
        </trans-unit>
        <trans-unit id="35cd310da77bd29a53a2d4932d2eb92ae62a2b7e" translate="yes" xml:space="preserve">
          <source>Base class for CPAN shell extensions</source>
          <target state="translated">Базовый класс для расширений оболочки CPAN</target>
        </trans-unit>
        <trans-unit id="c3e0f91a5e302404f6913115b1263f4db4575024" translate="yes" xml:space="preserve">
          <source>Base class for ExtUtils::Constant objects</source>
          <target state="translated">Базовый класс для ExtUtils::Постоянные объекты</target>
        </trans-unit>
        <trans-unit id="5ce69fa0ba6f632f7e9c5c2e2e7602e063a7c7a9" translate="yes" xml:space="preserve">
          <source>Base class for TAP source iterators</source>
          <target state="translated">Базовый класс для итераторов источника TAP</target>
        </trans-unit>
        <trans-unit id="37eb343993cd16220ab0f185a716f5c376429394" translate="yes" xml:space="preserve">
          <source>Base class for TAP::Parser output objects</source>
          <target state="translated">Базовый класс для TAP::Объекты вывода парсера</target>
        </trans-unit>
        <trans-unit id="b8befc5059605409ade42b4d099e397b207c906b" translate="yes" xml:space="preserve">
          <source>Base class for creating POD filters and translators</source>
          <target state="translated">Базовый класс для создания фильтров POD и трансляторов</target>
        </trans-unit>
        <trans-unit id="78eefd2e412b4d4df740ff4fbfcce92bad174022" translate="yes" xml:space="preserve">
          <source>Base class for different TAP source handlers</source>
          <target state="translated">Базовый класс для различных обработчиков TAP источников</target>
        </trans-unit>
        <trans-unit id="e4dfc8dbeda31aa613f1ab98bcf6af5cdb80223d" translate="yes" xml:space="preserve">
          <source>Base class for harness output delegates</source>
          <target state="translated">Базовый класс для делегатов по выходу на жгут</target>
        </trans-unit>
        <trans-unit id="7a74e67740b1a1d00bee0be3088f31fbc10821ea" translate="yes" xml:space="preserve">
          <source>Base class for test modules</source>
          <target state="translated">Базовый класс для тестовых модулей</target>
        </trans-unit>
        <trans-unit id="78996d2c61d5e3e13d981dd6371495a7dc1b0695" translate="yes" xml:space="preserve">
          <source>Base class for tied arrays</source>
          <target state="translated">Базовый класс для привязанных массивов</target>
        </trans-unit>
        <trans-unit id="8811ba419e75aa7afad3c58a4392ff34e2f70b65" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to &lt;a href=&quot;tap/parser&quot;&gt;TAP::Parser&lt;/a&gt;</source>
          <target state="translated">Базовый класс, обеспечивающий общие функции &lt;a href=&quot;tap/parser&quot;&gt;TAP :: Parser&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0808d28ca43c79c7220c0b66b8832ca8877ecfdc" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">Базовый класс, обеспечивающий общие функции для всех модулей &lt;code&gt;TAP::*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a76be2c1588f2035fb74a3a61c2be909fdefa70" translate="yes" xml:space="preserve">
          <source>Base for Pod::Perldoc formatters</source>
          <target state="translated">База для форматоров Pod::Perldoc</target>
        </trans-unit>
        <trans-unit id="2291e71c9ac6320d0a4640a773f789651e805f6a" translate="yes" xml:space="preserve">
          <source>Based on Stevan Little's &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class::C3&lt;/a&gt;</source>
          <target state="translated">На основе &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;класса&lt;/a&gt; Стевана Литтла :: C3</target>
        </trans-unit>
        <trans-unit id="560c120ffa51ce8d2dc3b95d35311dd465a3c278" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text()&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">На основе кода для &lt;b&gt;Pod :: Text :: pod2text (),&lt;/b&gt; написанного Томом Кристиансеном &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="25b805dbff71baab76550b6af4db1656526ccb89" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">На основе кода для &lt;b&gt;Pod :: Text :: pod2text (1),&lt;/b&gt; написанного Томом Кристиансеном &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b781efd9c14a9bf17ea0a940b2c65ad0a21bc5c6" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">На основе кода для &lt;b&gt;Pod :: Текст,&lt;/b&gt; написанный Томом Кристиансеном &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d91768d646bf2b1ba37683cf7ff89c9b306d5b4f" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">На основе кода для &lt;b&gt;pod2text (1),&lt;/b&gt; написанного Томом Кристиансеном &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e809a71bc55e573d735398064fa73868c841b25e" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">На основе кода для &lt;b&gt;pod2text,&lt;/b&gt; написанного Томом Кристиансеном &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="23082a2ee1ef553f8b8e9cc56e439b97636f01bf" translate="yes" xml:space="preserve">
          <source>Based on code written by Shigio Yamaguchi.</source>
          <target state="translated">На основе кода,написанного Сигио Ямагути.</target>
        </trans-unit>
        <trans-unit id="8e0d5bb83e47c2192346afc47fe774052eb51e39" translate="yes" xml:space="preserve">
          <source>Based on example that was initially added to MIME::QuotedPrint.pm for the 5.8.0 distribution of Perl.</source>
          <target state="translated">На основе примера,который был изначально добавлен в MIME::QuotedPrint.pm для дистрибутива 5.8.0 для Perl.</target>
        </trans-unit>
        <trans-unit id="a800ab4559098c87aba7a8e90188704683d129b8" translate="yes" xml:space="preserve">
          <source>Based on ideas from Tim Bunce &amp;lt;&lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt; and</source>
          <target state="translated">На основе идей Тима &lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;lt; Tim.Bunce@ig.co.uk &amp;gt; и</target>
        </trans-unit>
        <trans-unit id="ef4b57022699f0d3f5da98a8d57cddc66db361df" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;:perlio&lt;/code&gt; layer.</source>
          <target state="translated">На основе слоя &lt;code&gt;:perlio&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6189eca4d6c06b60af97bb9ce0c1f1fc615c134d" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; code by Larry Wall and the Perl 5 Porters, which was released under the same license terms.</source>
          <target state="translated">На основе &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; Ларри Уолла и Perl 5 Porters, который был выпущен на тех же условиях лицензии.</target>
        </trans-unit>
        <trans-unit id="da8636da22477810e470724d83ddc721d3335da8" translate="yes" xml:space="preserve">
          <source>Based on the Glossary of</source>
          <target state="translated">На основании Глоссария</target>
        </trans-unit>
        <trans-unit id="f28c9a8ac3d744f82801c7cfbb9de24801e7c563" translate="yes" xml:space="preserve">
          <source>Based on xsubpp code, written by Larry Wall.</source>
          <target state="translated">На основе кода xsubpp,написанного Ларри Уоллом.</target>
        </trans-unit>
        <trans-unit id="02905231fdcd4472df63f80b291fb153344c31cd" translate="yes" xml:space="preserve">
          <source>Basic BLOCKs</source>
          <target state="translated">Базовые БЛОКИРОВКИ</target>
        </trans-unit>
        <trans-unit id="901e56ace2d31ac4485efe2aa588116787957443" translate="yes" xml:space="preserve">
          <source>Basic IO operations</source>
          <target state="translated">Основные операции ввода-вывода</target>
        </trans-unit>
        <trans-unit id="8422cb1795fcef709d3e089320f56308fec39046" translate="yes" xml:space="preserve">
          <source>Basic Multilingual Plane</source>
          <target state="translated">Базовая многоязычная плоскость</target>
        </trans-unit>
        <trans-unit id="ccecd116866361404babdb87c039096fbb71e99c" translate="yes" xml:space="preserve">
          <source>Basic Structure</source>
          <target state="translated">Базовая структура</target>
        </trans-unit>
        <trans-unit id="39bbc4bee9f4a75c10797a6d328f733ea1124880" translate="yes" xml:space="preserve">
          <source>Basic Thread Support</source>
          <target state="translated">Поддержка основных потоков</target>
        </trans-unit>
        <trans-unit id="17f89c170a632afd0c0b0383dacf728c05a89851" translate="yes" xml:space="preserve">
          <source>Basic Utilities for Programmers</source>
          <target state="translated">Базовые утилиты для программистов</target>
        </trans-unit>
        <trans-unit id="148d2121cd077901af2d5cbf9aa363677304a06b" translate="yes" xml:space="preserve">
          <source>Basic commands:</source>
          <target state="translated">Основные команды:</target>
        </trans-unit>
        <trans-unit id="7308cb8418c068204c128968b5967fdf3606cc09" translate="yes" xml:space="preserve">
          <source>Basic methods</source>
          <target state="translated">Основные методы</target>
        </trans-unit>
        <trans-unit id="874d9df75ebdafc19870b90059bb69c04cb1fce7" translate="yes" xml:space="preserve">
          <source>Basic read operation.</source>
          <target state="translated">Основная операция чтения.</target>
        </trans-unit>
        <trans-unit id="c4901220ad10be08f037f204182ab7f0bb55ef8b" translate="yes" xml:space="preserve">
          <source>Basic semaphores</source>
          <target state="translated">Основные семафоры</target>
        </trans-unit>
        <trans-unit id="cf61d93532db2a473529a2856c70f230829513f8" translate="yes" xml:space="preserve">
          <source>Basic syntax overview</source>
          <target state="translated">Обзор синтаксиса на основных языках</target>
        </trans-unit>
        <trans-unit id="ce7944aa05e48b110f9c5b8903d70aed90358355" translate="yes" xml:space="preserve">
          <source>Basic utilities for writing tests.</source>
          <target state="translated">Основные утилиты для написания тестов.</target>
        </trans-unit>
        <trans-unit id="62b9ac85afbcfa7bd7a8e867b1f51756e30ca7d7" translate="yes" xml:space="preserve">
          <source>Basic write operation.</source>
          <target state="translated">Основная операция записи.</target>
        </trans-unit>
        <trans-unit id="04e2b1373d1c985716d261c139c35de4bc421d62" translate="yes" xml:space="preserve">
          <source>Basically, Intel and VAX CPUs are little-endian, while everybody else, including Motorola m68k/88k, PPC, Sparc, HP PA, Power, and Cray, are big-endian. Alpha and MIPS can be either: Digital/Compaq uses (well, used) them in little-endian mode, but SGI/Cray uses them in big-endian mode.</source>
          <target state="translated">В основном,процессоры Intel и VAX являются little-endian,в то время как все остальные,включая Motorola m68k/88k,PPC,Sparc,HP PA,Power и Cray,являются big-endian.Альфа и MIPS тоже могут быть:Digital/Compaq использует (хорошо,используется)их в режиме little-endian,но SGI/Cray использует их в режиме big-endian.</target>
        </trans-unit>
        <trans-unit id="1f10fe5797c3d1f7733a7eb604c9de17cf9d91ac" translate="yes" xml:space="preserve">
          <source>Basically, you fetch individual results from the TAP. The six types, with examples of each, are as follows:</source>
          <target state="translated">В основном,вы получаете индивидуальные результаты из TAP.Шесть типов с примерами каждого из них следующие:</target>
        </trans-unit>
        <trans-unit id="3764ce6b277261088796ef6723dbaafdda0e32f0" translate="yes" xml:space="preserve">
          <source>Be aware of two important points:</source>
          <target state="translated">Имейте в виду два важных момента:</target>
        </trans-unit>
        <trans-unit id="e4436a305cd04dc72f8078b037e6c2a662f1fa1d" translate="yes" xml:space="preserve">
          <source>Be aware that all filenames returned from File::Glob are tainted.</source>
          <target state="translated">Имейте в виду,что все имена,возвращенные из файла::Glob,испорчены.</target>
        </trans-unit>
        <trans-unit id="60f217633ac67f75e40713203caa69acc0ee5347" translate="yes" xml:space="preserve">
          <source>Be aware that setting &lt;code&gt;@DB::args&lt;/code&gt; is</source>
          <target state="translated">Имейте в виду , что установка &lt;code&gt;@DB::args&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="667b9a553537bba23ef30dd15f8a2bf40c9a72d6" translate="yes" xml:space="preserve">
          <source>Be aware that the digest routines silently convert UTF-8 input into its equivalent byte sequence in the native encoding (cf. utf8::downgrade). This side effect influences only the way Perl stores the data internally, but otherwise leaves the actual value of the data intact.</source>
          <target state="translated">Имейте в виду,что подпрограммы дайджеста бесшумно преобразуют вход UTF-8 в эквивалентную ему последовательность байт в родной кодировке (ср.utf8::downgrade).Этот побочный эффект влияет только на то,как Perl хранит данные внутри себя,но в остальном оставляет фактическое значение данных нетронутым.</target>
        </trans-unit>
        <trans-unit id="167d28f752fc336f0724d4becf42fb8c17cf60ad" translate="yes" xml:space="preserve">
          <source>Be aware that the file's type/creator and resource fork will be lost, which is usually what you want in cross-platform archives.</source>
          <target state="translated">Имейте в виду,что тип/создатель и ресурсная развилка файла будут потеряны,что обычно и требуется в кроссплатформенных архивах.</target>
        </trans-unit>
        <trans-unit id="2a627d6aeb5bb9832269cd11d71094ebccabe8d0" translate="yes" xml:space="preserve">
          <source>Be aware that the main value of this module is its simplicity. Note that there are already more ambitious modules out there, such as &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test::Unit&lt;/a&gt;.</source>
          <target state="translated">Имейте в виду, что главная ценность этого модуля - его простота. Обратите внимание, что уже существуют более амбициозные модули, такие как &lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt; и &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test :: Unit&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31de5d87ee0c0608b86806f39ac15e28011be167" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">Имейте в виду, что оптимизатор мог оптимизировать кадры вызова до того, как &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; получил возможность получить информацию. Это означает, что &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; может не вернуть информацию о ожидаемом кадре вызова при &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . В частности, &lt;code&gt;@DB::args&lt;/code&gt; может содержать информацию о предыдущем вызове &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="956f008e111339a547685e28f223bd6fbcba83d9" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">Имейте в виду, что оптимизатор мог оптимизировать кадры вызова до того, как &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; получил возможность получить информацию. Это означает, что &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; может не вернуть информацию о ожидаемом кадре вызова при &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . В частности, &lt;code&gt;@DB::args&lt;/code&gt; может содержать информацию о предыдущем вызове &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd6d74606bcc17d1eb7f4b9d0cbb233b2fce04be" translate="yes" xml:space="preserve">
          <source>Be aware that the option to follow symbolic links can be dangerous. Depending on the structure of the directory tree (including symbolic links to directories) you might traverse a given (physical) directory more than once (only if &lt;code&gt;follow_fast&lt;/code&gt; is in effect). Furthermore, deleting or changing files in a symbolically linked directory might cause very unpleasant surprises, since you delete or change files in an unknown directory.</source>
          <target state="translated">Имейте в виду, что переход по символическим ссылкам может быть опасным. В зависимости от структуры дерева каталогов (включая символические ссылки на каталоги) вы можете пройти по заданному (физическому) каталогу более одного раза (только если &lt;code&gt;follow_fast&lt;/code&gt; ). Более того, удаление или изменение файлов в символически связанном каталоге может вызвать очень неприятные сюрпризы, поскольку вы удаляете или изменяете файлы в неизвестном каталоге.</target>
        </trans-unit>
        <trans-unit id="b81ba14d3ce3de8180275845ca38e42a572b2c9a" translate="yes" xml:space="preserve">
          <source>Be aware that these operations are full Unix forks, which means they may not be correctly implemented on all alien systems.</source>
          <target state="translated">Имейте в виду,что эти операции являются полными вилками Unix,что означает,что они могут быть неправильно реализованы на всех инопланетных системах.</target>
        </trans-unit>
        <trans-unit id="6dac6d64c1feff1fddea48f799c315f06283805b" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source must be properly declared unless it is US-ASCII or Latin-1. POD input without an &lt;code&gt;=encoding&lt;/code&gt; command will be assumed to be in Latin-1, and if it's actually in UTF-8, the output will be double-encoded. See</source>
          <target state="translated">Имейте в виду, что при использовании этой опции входная кодировка вашего источника POD должна быть правильно объявлена, если это не US-ASCII или Latin-1. Предполагается, что ввод POD без команды &lt;code&gt;=encoding&lt;/code&gt; находится в Latin-1, а если он действительно в UTF-8, вывод будет дважды закодирован. Видеть</target>
        </trans-unit>
        <trans-unit id="8e54fdab18656cd50e15f88c4bd2cd505cbcafa9" translate="yes" xml:space="preserve">
          <source>Be aware, moreover, that even among Unix-ish systems there are variations.</source>
          <target state="translated">Более того,имейте в виду,что даже среди Unix-систем есть вариации.</target>
        </trans-unit>
        <trans-unit id="56eaa37568b649078a87e40ea7bc8697501ac281" translate="yes" xml:space="preserve">
          <source>Be careful about the syntax,</source>
          <target state="translated">Будь осторожен с синтаксисом,</target>
        </trans-unit>
        <trans-unit id="b3f347eeb5e9dd5ad6442952b1aeb5c318d4fa11" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">Будьте осторожны, если вы заключите изображение в двойные кавычки, потому что символ &lt;code&gt;@&lt;/code&gt; может означать начало имени массива. &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; всегда возвращает true. См. Другие примеры в &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6906a7867a27a79ea2a227d91624d262e203f04e" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">Будьте осторожны, если вы заключите изображение в двойные кавычки, потому что символ &lt;code&gt;@&lt;/code&gt; может означать начало имени массива. &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; всегда возвращает true. См. Другие примеры в &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9293d7623c3a63a2528c6144b0e2f16fd9c21b7" translate="yes" xml:space="preserve">
          <source>Be careful in the tests you supply with your module or programs. Module code may be fully portable, but its tests might not be. This often happens when tests spawn off other processes or call external programs to aid in the testing, or when (as noted above) the tests assume certain things about the filesystem and paths. Be careful not to depend on a specific output style for errors, such as when checking &lt;code&gt;$!&lt;/code&gt; after a failed system call. Using &lt;code&gt;$!&lt;/code&gt; for anything else than displaying it as output is doubtful (though see the &lt;code&gt;Errno&lt;/code&gt; module for testing reasonably portably for error value). Some platforms expect a certain output format, and Perl on those platforms may have been adjusted accordingly. Most specifically, don't anchor a regex when testing an error value.</source>
          <target state="translated">Будьте осторожны с тестами, которые вы поставляете с вашим модулем или программами. Код модуля может быть полностью переносимым, но его тесты - нет. Это часто происходит, когда тесты порождаются другими процессами или вызывают внешние программы для помощи в тестировании, или когда (как указано выше) тесты предполагают определенные вещи о файловой системе и путях. Будьте осторожны, чтобы не зависеть от конкретного стиля вывода ошибок, например, при проверке &lt;code&gt;$!&lt;/code&gt; после неудачного системного вызова. Используя &lt;code&gt;$!&lt;/code&gt; для чего-либо другого, кроме отображения его в качестве вывода, сомнительно (хотя см. модуль &lt;code&gt;Errno&lt;/code&gt; для тестирования разумной переносимости для значения ошибки). Некоторые платформы ожидают определенного формата вывода, и Perl на этих платформах мог быть соответствующим образом скорректирован. В частности, не привязывайте регулярное выражение при проверке значения ошибки.</target>
        </trans-unit>
        <trans-unit id="ae93e14e0d1be510a7665d0a55ac6aa4f668df14" translate="yes" xml:space="preserve">
          <source>Be careful to check that what you pass to chdir() is defined and not blank, else you might find yourself in your home directory.</source>
          <target state="translated">Будьте осторожны,чтобы проверить,что то,что вы передаете в chdir(),определено и не пусто,иначе вы можете оказаться в вашем домашнем каталоге.</target>
        </trans-unit>
        <trans-unit id="c85ebb348de7431489e7e78b8e62158b4eaa9740" translate="yes" xml:space="preserve">
          <source>Be careful to check the return values from both open() and close(). If you're</source>
          <target state="translated">Будьте внимательны при проверке возвращаемых значений как из функции open(),так и из функции close().Если вы</target>
        </trans-unit>
        <trans-unit id="aee2df458bcc4bef02091d782f8436bc138473c7" translate="yes" xml:space="preserve">
          <source>Be careful to repeat this procedure every time you recompile an extension, unless you are sure the AFS installation directories are still valid.</source>
          <target state="translated">Будьте осторожны,повторяйте эту процедуру каждый раз,когда перекомпилируете расширение,если только вы не уверены,что установочные каталоги AFS все еще действительны.</target>
        </trans-unit>
        <trans-unit id="fe76e94f1a35b852ed4a509f3683ff3f6a306181" translate="yes" xml:space="preserve">
          <source>Be careful when using the branch reset pattern in combination with named captures. Named captures are implemented as being aliases to numbered groups holding the captures, and that interferes with the implementation of the branch reset pattern. If you are using named captures in a branch reset pattern, it's best to use the same names, in the same order, in each of the alternations:</source>
          <target state="translated">Будьте осторожны при использовании шаблона сброса ветви в сочетании с именованными захватами.Именованные захваты реализуются в виде псевдонимов пронумерованных групп,удерживающих захваты,что препятствует реализации шаблона сброса ветви.Если вы используете именованные захваты в шаблоне сброса ответвления,то лучше всего использовать одинаковые имена,в том же порядке,в каждом из изменений:</target>
        </trans-unit>
        <trans-unit id="8f8df673aaa9f753cd8e9cf23c8cbbd3b2574c49" translate="yes" xml:space="preserve">
          <source>Be careful, though, to never combine text strings with binary strings. If you need text in a binary stream, encode your text strings first using the appropriate encoding, then join them with binary strings. See also: &quot;What if I don't encode?&quot;.</source>
          <target state="translated">Но будьте осторожны,никогда не комбинируйте текстовые строки с двоичными.Если вам нужен текст в двоичном потоке,кодируйте сначала свои текстовые строки в соответствующей кодировке,а затем соединяйте их с двоичными строками.См.также:&quot;Что,если я не кодирую?&quot;.</target>
        </trans-unit>
        <trans-unit id="cef4ef62c32e58e84f80436ec819bfd5a7afa02c" translate="yes" xml:space="preserve">
          <source>Be careful: qx(), system(), and some modules for calling external commands do a fork(), then wait() for the result. Thus, your signal handler will be called. Because wait() was already called by system() or qx(), the wait() in the signal handler will see no more zombies and will therefore block.</source>
          <target state="translated">Будьте осторожны:qx(),system(),и некоторые модули для вызова внешних команд делают fork(),затем ждут результата.Таким образом,будет вызван обработчик вашего сигнала.Так как функция wait()уже вызывалась system()или qx(),то функция wait()в обработчике сигнала больше не будет видеть зомби и поэтому будет блокироваться.</target>
        </trans-unit>
        <trans-unit id="02350f9e1a884f10cacbddf6be8d623a44b68fcb" translate="yes" xml:space="preserve">
          <source>Be consistent with existing modules.</source>
          <target state="translated">Соответствовать существующим модулям.</target>
        </trans-unit>
        <trans-unit id="8f9f60dfc3f60d9409a16936419f8f9c34030221" translate="yes" xml:space="preserve">
          <source>Be consistent.</source>
          <target state="translated">Будь последователен.</target>
        </trans-unit>
        <trans-unit id="0657b8fedf171a48206a6318d37358a77e53c6fb" translate="yes" xml:space="preserve">
          <source>Be descriptive (i.e. accurately describes the purpose of the module).</source>
          <target state="translated">Будьте описательны (т.е.точно опишите назначение модуля).</target>
        </trans-unit>
        <trans-unit id="4866ce84e5913e3bbf14d1ef419eb24f1d72a52e" translate="yes" xml:space="preserve">
          <source>Be it &lt;code&gt;Compress::Zlib&lt;/code&gt; , &lt;code&gt;Apache::Request&lt;/code&gt; or any extension that has no mention of Unicode in the manpage, you need to make sure that the UTF8 flag is stripped off. Note that at the time of this writing (January 2012) the mentioned modules are not UTF-8-aware. Please check the documentation to verify if this is still true.</source>
          <target state="translated">Будь то &lt;code&gt;Compress::Zlib&lt;/code&gt; , &lt;code&gt;Apache::Request&lt;/code&gt; или любое расширение, которое не упоминает Unicode в справочной странице, вам необходимо убедиться, что флаг UTF8 отключен. Обратите внимание, что на момент написания этой статьи (январь 2012 г.) упомянутые модули не поддерживают UTF-8. Пожалуйста, проверьте документацию, чтобы убедиться, что это все еще правда.</target>
        </trans-unit>
        <trans-unit id="fec8bd9db93426cc5f677cbbc44d58f990b4ce4f" translate="yes" xml:space="preserve">
          <source>Be nice.</source>
          <target state="translated">Будь вежлив.</target>
        </trans-unit>
        <trans-unit id="455d700825e4b9a7601c1ce54b47786ce81ebe18" translate="yes" xml:space="preserve">
          <source>Be sure not to use a bareword as the name of a signal handler, lest you inadvertently call it.</source>
          <target state="translated">Не используйте пустое слово в качестве имени обработчика сигналов,чтобы случайно его не назвать.</target>
        </trans-unit>
        <trans-unit id="adcfe790c3214b8902aa2d9bdbc7f166d3aa2497" translate="yes" xml:space="preserve">
          <source>Be sure that your yacc installation is in place including any necessary parser template files. If you have not already done so then be sure to:</source>
          <target state="translated">Убедитесь,что ваш yacc установлен,включая все необходимые файлы шаблонов парсера.Если вы еще этого не сделали,убедитесь в этом:</target>
        </trans-unit>
        <trans-unit id="7a2fea634f3d3c3b87d0ddfbb5348eeeda046aad" translate="yes" xml:space="preserve">
          <source>Be sure to adequately comment your code. While commenting every line is unnecessary, anything that takes advantage of side effects of operators, that creates changes that will be felt outside of the function being patched, or that others may find confusing should be documented. If you are going to err, it is better to err on the side of adding too many comments than too few.</source>
          <target state="translated">Не забудьте адекватно прокомментировать свой код.Хотя комментировать каждую строку не нужно,все,что использует побочные эффекты операторов,что создает изменения,которые будут ощущаться за пределами исправляемой функции,или что другие могут найти путаницу,должно быть задокументировано.Если вы собираетесь ошибаться,лучше ошибиться,добавив слишком много комментариев,чем слишком мало.</target>
        </trans-unit>
        <trans-unit id="df103353e12184ad2bab2c528d00c711c155c484" translate="yes" xml:space="preserve">
          <source>Be sure to include the &lt;b&gt;exact&lt;/b&gt; error messages, if any. &quot;Perl gave an error&quot; is not an exact error message.</source>
          <target state="translated">Не забудьте указать &lt;b&gt;точные&lt;/b&gt; сообщения об ошибках, если таковые имеются. &amp;laquo;Perl выдал ошибку&amp;raquo; не является точным сообщением об ошибке.</target>
        </trans-unit>
        <trans-unit id="b5cbd612657dfbf7a92d6606e16853c43b77addf" translate="yes" xml:space="preserve">
          <source>Be sure to read &lt;a href=&quot;#ENCODING&quot;&gt;ENCODING&lt;/a&gt; if your Pod contains non-ASCII characters.</source>
          <target state="translated">Обязательно прочтите &lt;a href=&quot;#ENCODING&quot;&gt;КОДИРОВАНИЕ,&lt;/a&gt; если ваш Pod содержит символы, отличные от ASCII.</target>
        </trans-unit>
        <trans-unit id="2984603dd54138b13d352a1e3fd61b6408be6b9f" translate="yes" xml:space="preserve">
          <source>Be sure to read the instructions near the top of the makefiles carefully.</source>
          <target state="translated">Внимательно ознакомьтесь с инструкциями,расположенными в верхней части макияжа.</target>
        </trans-unit>
        <trans-unit id="7f00ff2068b10342c9156aa44f6e62fb9656c3bb" translate="yes" xml:space="preserve">
          <source>Be sure to specify Perl version requirements both in Makefile.PL or Build.PL and with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; or similar. See the section on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; of &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for details.</source>
          <target state="translated">Обязательно укажите требования к версии Perl как в Makefile.PL или Build.PL, так и в &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; или аналогичном. См. Подробности в разделе, посвященном &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; of &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c733e8a30868a3838b1dfa41af03cf511ee097ca" translate="yes" xml:space="preserve">
          <source>Be sure to use a tar program compiled under Solaris (not SunOS 4.x) to extract the perl-5.x.x.tar.gz file. Do not use GNU tar compiled for SunOS4 on Solaris. (GNU tar compiled for Solaris should be fine.) When you run SunOS4 binaries on Solaris, the run-time system magically alters pathnames matching m#lib/locale# so that when tar tries to create lib/locale.pm, a file named lib/oldlocale.pm gets created instead. If you found this advice too late and used a SunOS4-compiled tar anyway, you must find the incorrectly renamed file and move it back to lib/locale.pm.</source>
          <target state="translated">Для извлечения файла perl-5.x.x.x.tar.gz обязательно используйте программу tar,скомпилированную под Solaris (а не под SunOS 4.x).Не используйте GNU tar,скомпилированный под SunOS4 на Solaris.(GNU tar,скомпилированный для Solaris,должен быть в порядке.)Когда вы запускаете исполняемые файлы SunOS4 на Solaris,система запуска волшебным образом изменяет патнамы,соответствующие m#lib/locale#,так что когда tar пытается создать lib/locale.pm,вместо него создается файл с именем lib/oldlocale.pm.Если вы нашли эту рекомендацию слишком поздно и все равно использовали tar,скомпилированный в SunOS4,вы должны найти неверно переименованный файл и перенести его обратно на lib/locale.pm.</target>
        </trans-unit>
        <trans-unit id="5d818ab86968387d2a89aaa4ecb39ab429064672" translate="yes" xml:space="preserve">
          <source>Be sure to use the libraries and modules shipped with the version being tested, not those that were already installed.</source>
          <target state="translated">Обязательно используйте библиотеки и модули,поставляемые с тестируемой версией,а не те,которые уже были установлены.</target>
        </trans-unit>
        <trans-unit id="e3d356b4e65052f33c752664cb97b29222d4870b" translate="yes" xml:space="preserve">
          <source>Be very careful with Perl operations that change the value of the variable. Appending something to the variable, for instance, might require reallocation of its storage, leaving you with a pointer into no-man's land.</source>
          <target state="translated">Будьте очень осторожны с операциями Perl,которые изменяют значение переменной.Добавление чего-либо к переменной,например,может потребовать перераспределения ее хранения,оставив вам указатель в чужой земле.</target>
        </trans-unit>
        <trans-unit id="a9df705eca9ff235f56efac76a8ae2aff600e09f" translate="yes" xml:space="preserve">
          <source>Be warned that neither creation nor deletion of files is guaranteed to be an atomic operation over NFS. That is, two processes might both successfully create or unlink the same file! Therefore O_EXCL isn't as exclusive as you might wish.</source>
          <target state="translated">Предупреждаем,что ни создание,ни удаление файлов не гарантируется как атомарная операция над NFS.То есть два процесса могут успешно создать или удалить один и тот же файл! Поэтому O_EXCL не является таким эксклюзивным,как вы могли бы пожелать.</target>
        </trans-unit>
        <trans-unit id="7184ad30ab6a73d32aaec035835bc55ad15b3389" translate="yes" xml:space="preserve">
          <source>Be warned that some formatters cannot reliably render characters outside 32-126; and many are able to handle 32-126 and 160-255, but nothing above 255.</source>
          <target state="translated">Предупреждаем,что некоторые форматоры не могут надежно отображать символы за пределами 32-126;и многие из них способны обрабатывать 32-126 и 160-255,но не более 255.</target>
        </trans-unit>
        <trans-unit id="8235118c9cdc1cd037bd4ff9c8b6234c4eceb334" translate="yes" xml:space="preserve">
          <source>Be warned that this feature is considered experimental, and may be changed without notice.</source>
          <target state="translated">Предупреждаем,что эта функция считается экспериментальной и может быть изменена без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="f60dd616afaa8860904852bce46c16c4c9385db0" translate="yes" xml:space="preserve">
          <source>Be warned, though, that unlike regular expressions, if the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; template doesn't match the incoming data, Perl will scream and die.</source>
          <target state="translated">Однако &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; виду, что в отличие от регулярных выражений, если шаблон распаковки не соответствует входящим данным, Perl закричит и умрет.</target>
        </trans-unit>
        <trans-unit id="f34bea745032a10b52d62f12a9de185a88d00d76" translate="yes" xml:space="preserve">
          <source>Be warned: just as the C-preprocessor doesn't know C, the Debug filter doesn't know Perl. It can be fooled quite easily:</source>
          <target state="translated">Предупреждаю:так же как C-препроцессор не знает C,фильтр отладки не знает Perl.Его легко обмануть:</target>
        </trans-unit>
        <trans-unit id="29bff63d2a655090d41ce27755886c450bf1e989" translate="yes" xml:space="preserve">
          <source>BeOS is BeOS.</source>
          <target state="translated">BeOS-это BeOS.</target>
        </trans-unit>
        <trans-unit id="7127634cd20ce1300143c5a508c993ef4fdbd8f4" translate="yes" xml:space="preserve">
          <source>Because &quot;perlio.h&quot; is a thin layer (for efficiency) the semantics of these functions are somewhat dependent on the underlying implementation. Where these variations are understood they are noted below.</source>
          <target state="translated">Поскольку &quot;perlio.h&quot; является тонким слоем (для эффективности),семантика этих функций в некоторой степени зависит от базовой реализации.Там,где эти вариации понимаются,они отмечены ниже.</target>
        </trans-unit>
        <trans-unit id="b63ce495f650d704c02d64d23b111efdfe40cd61" translate="yes" xml:space="preserve">
          <source>Because &lt;b&gt;perldoc&lt;/b&gt; does not run properly tainted, and is known to have security issues, when run as the superuser it will attempt to drop privileges by setting the effective and real IDs to nobody's or nouser's account, or -2 if unavailable. If it cannot relinquish its privileges, it will not run.</source>
          <target state="translated">Поскольку &lt;b&gt;perldoc&lt;/b&gt; не запускается должным образом и, как известно, имеет проблемы с безопасностью, при запуске от имени суперпользователя он попытается сбросить привилегии, установив эффективные и реальные идентификаторы для чьей-либо учетной записи или учетной записи пользователя, или -2, если недоступен. Если он не может отказаться от своих привилегий, он не будет работать.</target>
        </trans-unit>
        <trans-unit id="400d81a8582d02a7d364c167bb3655c111853cb4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; trigger interpolation, you'll need to use something like &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; to match them literally.</source>
          <target state="translated">Поскольку интерполяция триггера &lt;code&gt;$&lt;/code&gt; или &lt;code&gt;@&lt;/code&gt; , вам нужно будет использовать что-то вроде &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; чтобы сопоставить их буквально.</target>
        </trans-unit>
        <trans-unit id="b667c475fa92312c7083687d2886a12150dc73b8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$sv&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when the &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; operator is applied to it, the transliteration won't actually execute and the program won't &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then; now they'll just die when assigned to in the default engine.</source>
          <target state="translated">Поскольку &lt;code&gt;$sv&lt;/code&gt; имеет &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; когда к нему применяется оператор &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; , транслитерация фактически не выполняется, и программа не &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . Это отличается от поведения 5.8 и более ранних версий, поскольку тогда переменные захвата были переменными ТОЛЬКО ДЛЯ ЧТЕНИЯ; теперь они просто умрут, когда назначены в движке по умолчанию.</target>
        </trans-unit>
        <trans-unit id="5addc5234910932f591ed79ef1118cfac8717e21" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">Поскольку &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если любой из операндов имеет значение &lt;code&gt;NaN&lt;/code&gt; (не число), будьте осторожны при сортировке с помощью функции сравнения, такой как &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; любых списков, которые могут содержать &lt;code&gt;NaN&lt;/code&gt; . В следующем примере используется &lt;code&gt;NaN != NaN&lt;/code&gt; для исключения любых &lt;code&gt;NaN&lt;/code&gt; из входного списка.</target>
        </trans-unit>
        <trans-unit id="dbfd747a0cfe35cb8ad11b2926956f99d4f77a54" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">Поскольку &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если любой из операндов имеет значение &lt;code&gt;NaN&lt;/code&gt; (не число), будьте осторожны при сортировке с помощью функции сравнения, такой как &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; любых списков, которые могут содержать &lt;code&gt;NaN&lt;/code&gt; . В следующем примере используется &lt;code&gt;NaN != NaN&lt;/code&gt; для исключения любых &lt;code&gt;NaN&lt;/code&gt; из входного списка.</target>
        </trans-unit>
        <trans-unit id="89d0f8e67a21f5d12b3d2f9f3bbfa73cf7cb9115" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; is special in regular expressions, and can match any single character, the regex &lt;code&gt;P.&lt;/code&gt; here has matched the &amp;lt;Pl&amp;gt; in the original string.</source>
          <target state="translated">Потому что &lt;code&gt;.&lt;/code&gt; является специальным в регулярных выражениях и может соответствовать любому одиночному символу, регулярное выражение &lt;code&gt;P.&lt;/code&gt; здесь соответствует &amp;lt;Pl&amp;gt; в исходной строке.</target>
        </trans-unit>
        <trans-unit id="19a20b9f3a218df5a7c84d8e40e3cdca6928cac3" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; was in use as a directory separator and filenames could not be assumed to be unique after 10 characters, Acorn implemented the C compiler to strip the trailing &lt;code&gt;.c&lt;/code&gt;&lt;code&gt;.h&lt;/code&gt;&lt;code&gt;.s&lt;/code&gt; and &lt;code&gt;.o&lt;/code&gt; suffix from filenames specified in source code and store the respective files in subdirectories named after the suffix. Hence files are translated:</source>
          <target state="translated">Потому что &lt;code&gt;.&lt;/code&gt; использовался в качестве разделителя каталогов, и имена файлов не могли считаться уникальными после 10 символов, Acorn реализовал компилятор C для удаления конечных суффиксов &lt;code&gt;.c&lt;/code&gt; &lt;code&gt;.h&lt;/code&gt; &lt;code&gt;.s&lt;/code&gt; и &lt;code&gt;.o&lt;/code&gt; из имен файлов, указанных в исходном коде, и сохранения соответствующих файлов в подкаталогах, названных по суффиксу. Следовательно файлы переводятся:</target>
        </trans-unit>
        <trans-unit id="daf7ef166b9a7929b988f6a60b2c3afc2523b46d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; is a run-time operator, it gets executed each time through a loop. Consequently, it's more efficient to localize your variables outside the loop.</source>
          <target state="translated">Поскольку &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; - это оператор времени выполнения, он выполняется каждый раз в цикле. Следовательно, более эффективно локализовать переменные вне цикла.</target>
        </trans-unit>
        <trans-unit id="2f69348654d069c347e7c5732088634fa13b4fd6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">Поскольку &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; является унарным оператором, если вы случайно используете список в скобках для EXPR, это ведет себя как выражение скалярной запятой, оценивая все элементы, кроме последнего, в пустом контексте и возвращая последний элемент, оцененный в скалярном контексте. Это редко то, что вам нужно.</target>
        </trans-unit>
        <trans-unit id="f2af4d959eb62b1a9bf83d9e5254d41aa11be74b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">Поскольку &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; вступает в силу во время компиляции, оно не соблюдает обычное управление потоком компилируемого кода. В частности, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; внутри ложной ветви условного выражения не препятствует его обработке. Если модуль или прагму нужно загрузить только условно, это можно сделать с помощью прагмы &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4bb9a434db491939507421e019d5c81a08c7de9d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">Поскольку &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; является унарным оператором, если вы случайно используете список в скобках для EXPR, это ведет себя как выражение скалярной запятой, оценивая все элементы, кроме последнего, в пустом контексте и возвращая последний элемент, оцененный в скалярном контексте. Это редко то, что вам нужно.</target>
        </trans-unit>
        <trans-unit id="c409d5f2e3bc5948e94957a82aeec5c28556f99d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">Поскольку &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; вступает в силу во время компиляции, оно не соблюдает обычное управление потоком компилируемого кода. В частности, &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; внутри ложной ветви условного выражения не препятствует его обработке. Если модуль или прагму нужно загрузить только условно, это можно сделать с помощью прагмы &lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f7ea34c50bf47a71dd29a5e22af22a7376e9666b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;DESTROY&lt;/code&gt; methods can be called at any time, you should localize any global variables you might update in your &lt;code&gt;DESTROY&lt;/code&gt; . In particular, if you use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; you should localize &lt;code&gt;$@&lt;/code&gt; , and if you use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or backticks you should localize &lt;code&gt;$?&lt;/code&gt; .</source>
          <target state="translated">Поскольку методы &lt;code&gt;DESTROY&lt;/code&gt; могут быть вызваны в любое время, вам следует локализовать любые глобальные переменные, которые вы можете обновить в своем &lt;code&gt;DESTROY&lt;/code&gt; . В частности, если вы используете &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , вам следует локализовать &lt;code&gt;$@&lt;/code&gt; , а если вы используете &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; или обратные кавычки, вы должны локализовать &lt;code&gt;$?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b1a7e8c9b3926d0057e1f91a59eec1bca6ac0fe" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt; prove passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even when prove is run in taint mode.</source>
          <target state="translated">Поскольку &lt;code&gt;PERL5LIB&lt;/code&gt; часто используется во время тестирования для добавления каталогов сборки в &lt;code&gt;@INC&lt;/code&gt; , доказывается, что имена любых каталогов, найденных в &lt;code&gt;PERL5LIB&lt;/code&gt; ,передаются в качестве ключей -I. &lt;code&gt;PERL5LIB&lt;/code&gt; результатом этого является то, что PERL5LIB соблюдается, даже когда доказательство выполняется в режиме заражения.</target>
        </trans-unit>
        <trans-unit id="8d8b86b2aa791fa81fa4a800514b6911cd4cea09" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt;&lt;code&gt;Test::Harness&lt;/code&gt; passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even in taint mode.</source>
          <target state="translated">Поскольку &lt;code&gt;PERL5LIB&lt;/code&gt; часто используется во время тестирования для добавления каталогов сборки в &lt;code&gt;@INC&lt;/code&gt; , &lt;code&gt;Test::Harness&lt;/code&gt; передает имена любых каталогов, найденных в &lt;code&gt;PERL5LIB&lt;/code&gt; , как переключатели -I. &lt;code&gt;PERL5LIB&lt;/code&gt; результатом этого является то, что PERL5LIB соблюдается даже в режиме заражения.</target>
        </trans-unit>
        <trans-unit id="528ed40a74786c9daeb579970bad493df64c4a75" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PL_restartop&lt;/code&gt; is non-null, &lt;code&gt;run_body&lt;/code&gt; starts a new runops loop and execution continues.</source>
          <target state="translated">Поскольку &lt;code&gt;PL_restartop&lt;/code&gt; не равен нулю, &lt;code&gt;run_body&lt;/code&gt; запускает новый цикл runops и выполнение продолжается.</target>
        </trans-unit>
        <trans-unit id="add12825d3665c5532bcf2a78d2469e31a8a7e9f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;STORABLE_attach&lt;/code&gt; is passed the class (rather than an object), it also returns the object directly, rather than modifying the passed object.</source>
          <target state="translated">Поскольку &lt;code&gt;STORABLE_attach&lt;/code&gt; передается классу (а не объекту), он также возвращает объект напрямую, а не изменяет переданный объект.</target>
        </trans-unit>
        <trans-unit id="308ec40cfa786d712d62a1e76733c4c3028b3e68" translate="yes" xml:space="preserve">
          <source>Because Acorns use ASCII with newlines (&lt;code&gt;\n&lt;/code&gt; ) in text files as &lt;code&gt;\012&lt;/code&gt; like Unix, and because Unix filename emulation is turned on by default, most simple scripts will probably work &quot;out of the box&quot;. The native filesystem is modular, and individual filesystems are free to be case-sensitive or insensitive, and are usually case-preserving. Some native filesystems have name length limits, which file and directory names are silently truncated to fit. Scripts should be aware that the standard filesystem currently has a name length limit of &lt;b&gt;10&lt;/b&gt; characters, with up to 77 items in a directory, but other filesystems may not impose such limitations.</source>
          <target state="translated">Поскольку Acorns использует ASCII с новой строкой ( &lt;code&gt;\n&lt;/code&gt; ) в текстовых файлах как &lt;code&gt;\012&lt;/code&gt; как в Unix, и поскольку эмуляция имени файла в Unix включена по умолчанию, большинство простых сценариев, вероятно, будут работать &amp;laquo;из коробки&amp;raquo;. Собственная файловая система является модульной, и отдельные файловые системы могут быть чувствительны к регистру или нечувствительны, и обычно с сохранением регистра. Некоторые собственные файловые системы имеют ограничения на длину имен, при этом имена файлов и каталогов автоматически усекаются, чтобы соответствовать. Сценарии должны знать, что стандартная файловая система в настоящее время имеет ограничение на длину имени в &lt;b&gt;10&lt;/b&gt; символов и до 77 элементов в каталоге, но другие файловые системы могут не накладывать таких ограничений.</target>
        </trans-unit>
        <trans-unit id="828cb90cec8613e5d83ab546b1c59479cecb4072" translate="yes" xml:space="preserve">
          <source>Because C has no builtin function for integer exponentiation, let's make Perl's ** operator available to it (this is less useful than it sounds, because Perl implements ** with C's</source>
          <target state="translated">Поскольку в Си нет встроенной функции для целочисленного выражения,давайте сделаем оператор Perl's **доступным для него (это менее полезно,чем кажется,потому что Perl реализует **с помощью C's</target>
        </trans-unit>
        <trans-unit id="9459aa14a3cec514837284733b6c7f9c5dcb8910" translate="yes" xml:space="preserve">
          <source>Because Perl allows you to use barewords for package names and subroutine names, it sometimes interprets a bareword's meaning incorrectly. For example, the construct &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; can be interpreted as either &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; or &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; . In English, that second interpretation reads as &quot;call a subroutine named Class(), then call new() as a method on the return value of Class()&quot;. If there is a subroutine named &lt;code&gt;Class()&lt;/code&gt; in the current namespace, Perl will always interpret &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; as the second alternative: a call to &lt;code&gt;new()&lt;/code&gt; on the object returned by a call to &lt;code&gt;Class()&lt;/code&gt;</source>
          <target state="translated">Поскольку Perl позволяет вам использовать голые слова для имен пакетов и имен подпрограмм, он иногда неправильно интерпретирует их значение. Например, конструкция &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; может интерпретироваться как &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; или как &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; . На английском языке эта вторая интерпретация читается как &amp;laquo;вызвать подпрограмму с именем Class (), затем вызвать new () как метод для возвращаемого значения Class ()&amp;raquo;. Если в текущем пространстве имен есть подпрограмма с именем &lt;code&gt;Class()&lt;/code&gt; , Perl всегда будет интерпретировать &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; как вторую альтернативу: вызов &lt;code&gt;new()&lt;/code&gt; для объекта, возвращенного вызовом &lt;code&gt;Class()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aadc88ee4df674055a8e46229f25dab587fc29ec" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;../overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">Поскольку Perl преобразует сообщения о неперехваченных исключениях перед отображением, вы, вероятно, захотите перегрузить операции строкового преобразования для объектов исключений. Подробнее об этом см. &lt;a href=&quot;../overload&quot;&gt;Перегрузка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1c5024f83c23d4c6dafd0e63d9f2e92824de07b" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">Поскольку Perl преобразует сообщения о неперехваченных исключениях перед отображением, вы, вероятно, захотите перегрузить операции строкового преобразования для объектов исключений. Подробнее об этом см. &lt;a href=&quot;overload&quot;&gt;Перегрузка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2faaff7512cd20cbdff5d0e25efe8bfe139f7156" translate="yes" xml:space="preserve">
          <source>Because Perl uses doubles (or long doubles, if configured) internally for all numeric calculation, converting from double into float and thence to double again loses precision, so &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt;) will not in general equal $foo.</source>
          <target state="translated">Поскольку Perl использует внутри себя числа типа double (или long double, если настроено) для всех числовых вычислений, преобразование из double в float, а затем в double снова теряет точность, поэтому &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt; ) не будет в общем равно $ foo.</target>
        </trans-unit>
        <trans-unit id="398f8b38f72125ad882bed6f196a0775e260d2ad" translate="yes" xml:space="preserve">
          <source>Because UTF-8 is one of Perl's internal formats, you can often just skip the encoding or decoding step, and manipulate the UTF8 flag directly.</source>
          <target state="translated">Поскольку UTF-8 является одним из внутренних форматов Perl,часто можно просто пропустить шаг кодирования или декодирования и напрямую манипулировать флагом UTF8.</target>
        </trans-unit>
        <trans-unit id="6847617d71c84ec40d27c1365086ed8c20f1449c" translate="yes" xml:space="preserve">
          <source>Because UTF-EBCDIC is so similar to UTF-8, the differences are mostly hidden from you; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; (and NOT something like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; ) declares the the script is in the platform's &quot;native&quot; 8-bit encoding of Unicode. (Similarly for the &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; layer.)</source>
          <target state="translated">Поскольку UTF-EBCDIC очень похож на UTF-8, различия в основном скрыты от вас; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; (а НЕ что-то вроде &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; ) объявляет, что сценарий находится в &amp;laquo;родной&amp;raquo; 8-битной кодировке Unicode платформы. (Аналогично для слоя &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="237849b1b007b545cf9244e10de8226da0ca3773" translate="yes" xml:space="preserve">
          <source>Because VMS's exit codes are much, much different than the rest of the universe, and perl does horrible mangling to them that gets in my way, it works like this on VMS.</source>
          <target state="translated">Потому что коды выхода VMS очень,очень отличаются от остальных частей вселенной,и Perl делает ужасные калечащие их,которые попадаются на моем пути,он работает так на VMS.</target>
        </trans-unit>
        <trans-unit id="815d9b38e08d4ff6dad9bd30fba64b1ec6e8aeb8" translate="yes" xml:space="preserve">
          <source>Because XS modules require re-linking of the perl binary, you need both the perl binary distribution and the perl source distribution to build an XS extension module. In addition, you will have to have built your perl binary from the source distribution so that all of the components of the perl binary are available for the required link step.</source>
          <target state="translated">Поскольку модули XS требуют перекомпоновки бинарного файла perl,для сборки модуля расширения XS вам понадобится как бинарное распределение perl,так и распределение исходных текстов perl.Кроме того,вам нужно будет собрать двоичный файл perl из дистрибутива исходных текстов таким образом,чтобы все компоненты двоичного файла perl были доступны на требуемом этапе компоновки.</target>
        </trans-unit>
        <trans-unit id="b57c6e3153bc9c89950406d1bdb5e4a01632a292" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">Поскольку неудачное совпадение &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; не сбрасывает смещение, возврат из &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; также не изменится в этом случае. См. &lt;a href=&quot;perlre&quot;&gt;Perlre&lt;/a&gt; и &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aac46af0a65c30c1278fb04116da06849260131d" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">Поскольку неудачное совпадение &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; не сбрасывает смещение, возврат из &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; также не изменится в этом случае. См. &lt;a href=&quot;../perlre&quot;&gt;Perlre&lt;/a&gt; и &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9eb2a05168485f04f9e352bc656013c7106c3b67" translate="yes" xml:space="preserve">
          <source>Because a list of potential candidates is returned, the &lt;code&gt;while&lt;/code&gt; loop tries each in turn until it finds one that succeeds both the socket() and connect() calls.</source>
          <target state="translated">Поскольку список потенциальных кандидатов вернулись, в &lt;code&gt;while&lt;/code&gt; цикл пытается каждый , в свою очередь , пока не найдет ту , которая преуспевает как сокет () и Connect () звонки.</target>
        </trans-unit>
        <trans-unit id="93bb95979fc3bb902bf7566626913de80d560dcc" translate="yes" xml:space="preserve">
          <source>Because a name correction may be added in future Unicode releases, the name that &lt;code&gt;viacode&lt;/code&gt; returns may change as a result. This is a rare event, but it does happen.</source>
          <target state="translated">Поскольку в будущих выпусках Unicode может быть добавлено исправление имени, имя, &lt;code&gt;viacode&lt;/code&gt; возвращает viacode, может в результате измениться. Это редкое событие, но оно случается.</target>
        </trans-unit>
        <trans-unit id="284e0db6a72cf3c4c7c4890513562109eb2a9995" translate="yes" xml:space="preserve">
          <source>Because a period is a metacharacter, it needs to be escaped to match as an ordinary period. Because, for example, &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; are sets of characters, it is incorrect to think of &lt;code&gt;[^\d\w]&lt;/code&gt; as &lt;code&gt;[\D\W]&lt;/code&gt; ; in fact &lt;code&gt;[^\d\w]&lt;/code&gt; is the same as &lt;code&gt;[^\w]&lt;/code&gt;, which is the same as &lt;code&gt;[\W]&lt;/code&gt; . Think DeMorgan's laws.</source>
          <target state="translated">Поскольку точка является метасимволом, ее необходимо экранировать, чтобы она соответствовала обычной точке. Так как, например, &lt;code&gt;\d&lt;/code&gt; и &lt;code&gt;\w&lt;/code&gt; являются наборами символов, неправильно думать о &lt;code&gt;[^\d\w]&lt;/code&gt; как о &lt;code&gt;[\D\W]&lt;/code&gt; ; на самом деле &lt;code&gt;[^\d\w]&lt;/code&gt; то же самое, что &lt;code&gt;[^\w]&lt;/code&gt; , что то же самое, что и &lt;code&gt;[\W]&lt;/code&gt; . Подумайте о законах ДеМоргана.</target>
        </trans-unit>
        <trans-unit id="934c60da6f18a9def8d944b8bcb6ee8755c35fe6" translate="yes" xml:space="preserve">
          <source>Because access() does not invoke stat() (at least not in a way visible to Perl), &lt;b&gt;the stat result cache &quot;_&quot; is not set&lt;/b&gt;. This means that the outcome of the following two tests is different. The first has the stat bits of</source>
          <target state="translated">Поскольку access () не вызывает stat () (по крайней мере, не видимым для Perl способом), &lt;b&gt;кэш результатов stat &quot;_&quot; не установлен&lt;/b&gt; . Это означает, что результаты следующих двух тестов различаются. Первый имеет биты статистики</target>
        </trans-unit>
        <trans-unit id="390a39256a176624bc85b17cecc4ce28e0fc7e67" translate="yes" xml:space="preserve">
          <source>Because assignment of a reference to a typeglob creates an alias, this can be used to create what is effectively a local function, or at least, a local alias.</source>
          <target state="translated">Поскольку назначение ссылки на печатный шрифт создает псевдоним,это может быть использовано для создания того,что фактически является локальной функцией или,по крайней мере,локальным псевдонимом.</target>
        </trans-unit>
        <trans-unit id="0fe40d9c5df21e57c6ec455bae627177153c51cf" translate="yes" xml:space="preserve">
          <source>Because backticks do not affect standard error, use shell file descriptor syntax (assuming the shell supports this) if you care to address this. To capture a command's STDERR and STDOUT together:</source>
          <target state="translated">Поскольку обратные ссылки не влияют на стандартную ошибку,используйте синтаксис дескрипторов файлов оболочки (предполагая,что оболочка поддерживает это),если вы хотите решить эту проблему.Для захвата STDERR и STDOUT команды вместе:</target>
        </trans-unit>
        <trans-unit id="58a3a4b137a2ac3042f5ce6d5ed31ccf52919b18" translate="yes" xml:space="preserve">
          <source>Because both CRLF and LF end in LF, the input record separator can be set to LF and any CR stripped later. Better to write:</source>
          <target state="translated">Так как CRLF и LF заканчиваются в LF,сепаратор входной записи может быть установлен в LF и любая CR снимается позже.Лучше писать:</target>
        </trans-unit>
        <trans-unit id="a49e08801e09e4ade1a0feed4948dfc00925efc8" translate="yes" xml:space="preserve">
          <source>Because curly brackets (braces) are used for several other things including BLOCKs, you may occasionally have to disambiguate braces at the beginning of a statement by putting a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in front so that Perl realizes the opening brace isn't starting a BLOCK. The economy and mnemonic value of using curlies is deemed worth this occasional extra hassle.</source>
          <target state="translated">Поскольку фигурные скобки (фигурные скобки) используются для нескольких других вещей, включая БЛОКИ, иногда вам может потребоваться устранять неоднозначность фигурных скобок в начале оператора, помещая &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; вперед, чтобы Perl понимал, что открывающая фигурная скобка не запускает БЛОК . Экономия и мнемоническая ценность использования завитушек оправдывают эти периодические дополнительные хлопоты.</target>
        </trans-unit>
        <trans-unit id="b7b830bba46d3c56bd91aa88ed2e25a2ca316287" translate="yes" xml:space="preserve">
          <source>Because depending on a directory to just ensure it exists doesn't work too well (the modified time changes too often) dir_target() creates a .exists file in the created directory. It is this you should depend on. For portability purposes you should use the $(DIRFILESEP) macro rather than a '/' to separate the directory from the file.</source>
          <target state="translated">Потому что в зависимости от каталога,чтобы просто убедиться,что он существует,не работает слишком хорошо (измененное время меняется слишком часто)dir_target()создает файл .exists в созданном каталоге.Именно от этого вы должны зависеть.В целях переносимости вы должны использовать макрос $(DIRFILESEP),а не '/',чтобы отделить каталог от файла.</target>
        </trans-unit>
        <trans-unit id="e43a24b825ab27b01432c41cd607e2f4d3328c51" translate="yes" xml:space="preserve">
          <source>Because each operand is evaluated in integer form, &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will return two elements in list context.</source>
          <target state="translated">Поскольку каждый операнд оценивается в целочисленной форме, &lt;code&gt;2.18 .. 3.14&lt;/code&gt; вернет два элемента в контексте списка.</target>
        </trans-unit>
        <trans-unit id="d594331311925ecf9da3e16eb2cdc66b10c06327" translate="yes" xml:space="preserve">
          <source>Because even on non-Unix ports, Perl's glob function follows standard Unix globbing semantics. You'll need &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; to get all (non-hidden) files. This makes glob() portable even to legacy systems. Your port may include proprietary globbing functions as well. Check its documentation for details.</source>
          <target state="translated">Потому что даже на портах, отличных от Unix, функция glob в Perl следует стандартной семантике подстановки Unix. Вам понадобится &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; чтобы получить все (не скрытые) файлы. Это делает glob () переносимым даже в устаревшие системы. Ваш порт также может включать проприетарные функции подстановки. Подробности смотрите в документации.</target>
        </trans-unit>
        <trans-unit id="2981f551145cc9ed169b464d8c0a095e7cf58a72" translate="yes" xml:space="preserve">
          <source>Because historically some operating systems silently chopped off kernel interpretation of the &lt;code&gt;#!&lt;/code&gt; line after 32 characters, some switches may be passed in on the command line, and some may not; you could even get a &quot;-&quot; without its letter, if you're not careful. You probably want to make sure that all your switches fall either before or after that 32-character boundary. Most switches don't actually care if they're processed redundantly, but getting a &quot;-&quot; instead of a complete switch could cause Perl to try to execute standard input instead of your program. And a partial &lt;b&gt;-I&lt;/b&gt; switch could also cause odd results.</source>
          <target state="translated">Поскольку исторически некоторые операционные системы молча отключили интерпретацию ядра &lt;code&gt;#!&lt;/code&gt; строка после 32 символов, некоторые ключи могут быть переданы в командной строке, а некоторые нет; вы даже можете получить знак &amp;laquo;-&amp;raquo; без буквы, если не будете осторожны. Вы, вероятно, захотите убедиться, что все ваши переключатели упали до или после этой 32-символьной границы. Большинство переключателей на самом деле не заботятся о том, обрабатываются ли они избыточно, но получение &amp;laquo;-&amp;raquo; вместо полного переключателя может привести к тому, что Perl попытается выполнить стандартный ввод вместо вашей программы. И частичный переключатель &lt;b&gt;-I&lt;/b&gt; также может привести к странным результатам.</target>
        </trans-unit>
        <trans-unit id="0e93d867e0e61a9f65c5551095616b09fa36af42" translate="yes" xml:space="preserve">
          <source>Because if _1 is one, you get &quot;1 document &lt;b&gt;were&lt;/b&gt; matched&quot;. An acceptable hack here is to do something like this:</source>
          <target state="translated">Потому что , если _1 это один, вы получите &amp;laquo;1 документы &lt;b&gt;были&lt;/b&gt; согласованы&amp;raquo;. Приемлемый способ взлома - сделать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="14e83724617636cdff52bc89c9135eb24a32b2c3" translate="yes" xml:space="preserve">
          <source>Because it is not possible to reliably tell UTF-8 from native 8 bit encodings, you need either a Byte Order Mark at the beginning of your source code, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; , to instruct perl.</source>
          <target state="translated">Поскольку невозможно надежно отличить UTF-8 от собственных 8-битных кодировок, вам понадобится либо отметка порядка байтов в начале исходного кода, либо &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; , чтобы проинструктировать perl.</target>
        </trans-unit>
        <trans-unit id="8c9a76f6de0976ec0aec1cbf80b933b451074248" translate="yes" xml:space="preserve">
          <source>Because it's a module, not an integral part of the interpreter, NEXT.pm has to guess where the surrounding call was found in the method look-up sequence. In the presence of diamond inheritance patterns it occasionally guesses wrong.</source>
          <target state="translated">Поскольку это модуль,а не неотъемлемая часть интерпретатора,NEXT.pm должен угадать,где был найден окружающий вызов в последовательности поиска метода.При наличии алмазных паттернов наследования он иногда угадывает неправильно.</target>
        </trans-unit>
        <trans-unit id="1b07afd521e75a07298e5e250bb27a3b27578dea" translate="yes" xml:space="preserve">
          <source>Because loading in the &lt;code&gt;IO::Handle&lt;/code&gt; class is an expensive operation, you should learn how to use the regular built-in variables.</source>
          <target state="translated">Поскольку загрузка в класс &lt;code&gt;IO::Handle&lt;/code&gt; - дорогостоящая операция, вам следует научиться использовать обычные встроенные переменные.</target>
        </trans-unit>
        <trans-unit id="fb1b328dbd0a94624aa3c89dafc392fc30581afd" translate="yes" xml:space="preserve">
          <source>Because many operating systems permit anyone with read access to the Perl program file to make a copy of it, patch the copy, and then execute the copy, the security-conscious Perl programmer should take care to invoke the installed copy of perl, not the copy referenced by &lt;code&gt;$^X&lt;/code&gt; . The following statements accomplish this goal, and produce a pathname that can be invoked as a command or referenced as a file.</source>
          <target state="translated">Поскольку многие операционные системы разрешают любому, у кого есть доступ для чтения к программному файлу Perl, делать его копию, исправлять копию, а затем выполнять копию, программист Perl, заботящийся о безопасности, должен позаботиться о том, чтобы вызвать установленную копию perl, а не копия ссылается &lt;code&gt;$^X&lt;/code&gt; . Следующие ниже операторы достигают этой цели и создают путь, который можно вызывать как команду или ссылаться как на файл.</target>
        </trans-unit>
        <trans-unit id="9fda5ef27e15d5bae07e31ec0802921ed805374c" translate="yes" xml:space="preserve">
          <source>Because native operating system filehandles are global and are currently allocated down from 255, with 0 being a reserved value, the Unix emulation library emulates Unix filehandles. Consequently, you can't rely on passing &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , or &lt;code&gt;STDERR&lt;/code&gt; to your children.</source>
          <target state="translated">Поскольку собственные дескрипторы файлов операционной системы являются глобальными и в настоящее время выделяются меньше 255, где 0 является зарезервированным значением, библиотека эмуляции Unix эмулирует дескрипторы файлов Unix. Следовательно, вы не можете полагаться на передачу &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; или &lt;code&gt;STDERR&lt;/code&gt; своим детям.</target>
        </trans-unit>
        <trans-unit id="f5e62ec9329120e24ef0d8c20f22f5389de7c7e2" translate="yes" xml:space="preserve">
          <source>Because objects in Perl are implemented as references, it's possible to have circular references with objects as well. Imagine a TreeNode class where each node references its parent and child nodes. Any node with a parent will be part of a circular reference.</source>
          <target state="translated">Поскольку объекты в Perl реализованы в виде ссылок,можно иметь и круговые ссылки с объектами.Представьте себе класс TreeNode,в котором каждый узел ссылается на свои родительские и дочерние узлы.Любой узел с родительскими ссылками будет частью круговой ссылки.</target>
        </trans-unit>
        <trans-unit id="0bd5958f518c949c2219a905e834fb00df87ae4a" translate="yes" xml:space="preserve">
          <source>Because of DST changes, there are many time zones where the same local time occurs for two different GMT times on the same day. For example, in the &quot;Europe/Paris&quot; time zone, the local time of 2001-10-28 02:30:00 can represent either 2001-10-28 00:30:00 GMT, &lt;b&gt;or&lt;/b&gt; 2001-10-28 01:30:00 GMT.</source>
          <target state="translated">Из-за смены летнего времени существует много часовых поясов, в которых одно и то же местное время происходит в два разных времени по Гринвичу в один и тот же день. Например, в часовом поясе &quot;Европа / Париж&quot; местное время 2001-10-28 02:30:00 может представлять либо 2001-10-28 00:30:00 GMT, &lt;b&gt;либо&lt;/b&gt; 2001-10-28 01: 30:00 по Гринвичу.</target>
        </trans-unit>
        <trans-unit id="65864a7a85dc93ea309cdec582c118e5dd979f14" translate="yes" xml:space="preserve">
          <source>Because of a bug in perl (#19213), at least in version 5.6.1, we have to hardcode the path separator for a require on Win32 to be &lt;code&gt;/&lt;/code&gt;, like on Unix rather than the Win32 &lt;code&gt;\&lt;/code&gt; . Otherwise perl will not read its own %INC accurately double load files if they are required again, or in the worst case, core dump.</source>
          <target state="translated">Из-за ошибки в perl (# 19213), по крайней мере, в версии 5.6.1, мы должны жестко запрограммировать разделитель путей для требования в Win32, чтобы он был &lt;code&gt;/&lt;/code&gt; , как в Unix, а не в Win32 &lt;code&gt;\&lt;/code&gt; . В противном случае Perl не будет читать свой собственный% INC, точно дважды загружая файлы, если они потребуются снова, или, в худшем случае, дамп ядра.</target>
        </trans-unit>
        <trans-unit id="4f334a2266086aa81e3afdad8578b63a9a352bf3" translate="yes" xml:space="preserve">
          <source>Because of a lack of anything better, this module uses its own routines to pack and unpack ICMP packets. It would be better for a separate module to be written which understands all of the different kinds of ICMP packets.</source>
          <target state="translated">Из-за отсутствия чего-либо лучшего,данный модуль использует свои собственные процедуры для упаковки и распаковки ICMP-пакетов.Лучше написать отдельный модуль,который понимает всевозможные виды ICMP-пакетов.</target>
        </trans-unit>
        <trans-unit id="c50ff3946dd738899f690c4bd5e562356a6223d1" translate="yes" xml:space="preserve">
          <source>Because of all these problems, starting in v5.22, Perl will raise a warning if a multi-byte (hence Unicode) code point is used when a single-byte locale is in effect. (Although it doesn't check for this if doing so would unreasonably slow execution down.)</source>
          <target state="translated">Из-за всех этих проблем,начиная с версии v5.22,Perl выдаст предупреждение,если используется многобайтовая (отсюда и Юникод)точка кода,когда действует однобайтовая локаль.(Хотя он не проверяет на это,если это приведет к неоправданному замедлению выполнения).</target>
        </trans-unit>
        <trans-unit id="7eca024239d85bdb38cb09ea249ea5b41add05bc" translate="yes" xml:space="preserve">
          <source>Because of backward compatibility with legacy encodings, the &quot;a unique number for every character&quot; idea breaks down a bit: instead, there is &quot;at least one number for every character&quot;. The same character could be represented differently in several legacy encodings. The converse is not true: some code points do not have an assigned character. Firstly, there are unallocated code points within otherwise used blocks. Secondly, there are special Unicode control characters that do not represent true characters.</source>
          <target state="translated">Из-за обратной совместимости с унаследованными кодировками,идея &quot;уникального числа для каждого символа&quot; немного ломается:вместо этого есть &quot;по крайней мере,одна цифра для каждого символа&quot;.Один и тот же символ может быть представлен по-разному в нескольких старых кодировках.Обратное не верно:некоторые точки кода не имеют назначенного символа.Во-первых,внутри иначе используемых блоков есть нераспределенные точки кода.Во-вторых,существуют специальные символы управления Unicode,которые не представляют собой истинные символы.</target>
        </trans-unit>
        <trans-unit id="6c5cc2c32fa019382bf3152d3598a8ccd6be4473" translate="yes" xml:space="preserve">
          <source>Because of being able to omit the curlies for the simple case of &lt;code&gt;$$x&lt;/code&gt; , people often make the mistake of viewing the dereferencing symbols as proper operators, and wonder about their precedence. If they were, though, you could use parentheses instead of braces. That's not the case. Consider the difference below; case 0 is a short-hand version of case 1,</source>
          <target state="translated">Из-за возможности опустить фигурные скобки в простом случае &lt;code&gt;$$x&lt;/code&gt; , люди часто делают ошибку, рассматривая символы разыменования как правильные операторы, и задаются вопросом об их приоритете. Если бы это было так, вы могли бы использовать круглые скобки вместо фигурных скобок. Это не так. Обратите внимание на разницу ниже; case 0 - это сокращенная версия case 1,</target>
        </trans-unit>
        <trans-unit id="e900a4e123821bf1949cbdd4fb9b5da407117914" translate="yes" xml:space="preserve">
          <source>Because of clock granularity, expiration times may occur up to one second sooner than you expect. For example, suppose you store a value with a lifetime of ten seconds, and you store it at 12:00:00.998 on a certain day. Memoize will look at the clock and see 12:00:00. Then 9.01 seconds later, at 12:00:10.008 you try to read it back. Memoize will look at the clock and see 12:00:10 and conclude that the value has expired. This will probably not occur if you have &lt;code&gt;Time::HiRes&lt;/code&gt; installed.</source>
          <target state="translated">Из-за детализации часов время истечения может наступить на одну секунду раньше, чем вы ожидаете. Например, предположим, что вы сохраняете значение со временем жизни в десять секунд, и вы сохраняете его в 12: 00: 00.998 определенного дня. Memoize посмотрит на часы и увидит 12:00:00. Затем через 9,01 секунды, в 12: 00: 10.008 вы пытаетесь прочитать его. Memoize посмотрит на часы, увидит 12:00:10 и сделает вывод, что значение истекло. Вероятно, этого не произойдет, если у вас установлен &lt;code&gt;Time::HiRes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6e7a0449744f95f7025dc0e8c4838b8d0860c99" translate="yes" xml:space="preserve">
          <source>Because of idiosyncrasies of OS/2 one cannot have all the eggs in the same basket (though EMX environment tries hard to overcome this limitations, so the situation may somehow improve). There are 4 executables for Perl provided by the distribution:</source>
          <target state="translated">Из-за идиосинкразии OS/2 нельзя иметь все яйца в одной корзине (хотя среда EMX изо всех сил пытается преодолеть эти ограничения,так что ситуация может как-то улучшить).В дистрибутиве есть 4 исполняемых файла для Perl:</target>
        </trans-unit>
        <trans-unit id="38b54108e9558724b240349ad9589f54bf027fa2" translate="yes" xml:space="preserve">
          <source>Because of its global effect, this setting should not be used inside modules or the like.</source>
          <target state="translated">Из-за своего глобального эффекта эта настройка не должна использоваться внутри модулей и тому подобное.</target>
        </trans-unit>
        <trans-unit id="cc4be6e39aa524fd29878685a03b1168c2bf5d9f" translate="yes" xml:space="preserve">
          <source>Because of our problems with the native yacc we used GNU bison to generate a pure (=reentrant) parser for perly.y. So our yacc is really the following script:</source>
          <target state="translated">Из-за наших проблем с родным yacc мы использовали GNU bison,чтобы сгенерировать чистый (=reentrant)парсер для perly.y.Так что наш yacc-это действительно следующий сценарий:</target>
        </trans-unit>
        <trans-unit id="9835e5c9cd0a637bdd223f60f76a72232d5d4783" translate="yes" xml:space="preserve">
          <source>Because of the &quot;text&quot; mode translation, DOSish perls have limitations in using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; on a file accessed in &quot;text&quot; mode. Stick to &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;-ing to locations you got from &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; (and no others), and you are usually free to use &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; even in &quot;text&quot; mode. Using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; or other file operations may be non-portable. If you use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; on a file, however, you can usually &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; with arbitrary values safely.</source>
          <target state="translated">Из-за &amp;laquo;текст&amp;raquo; режим перевода, DOSish Перлз имеют ограничения в использовании &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; о файле , доступ в режиме &amp;laquo;текст&amp;raquo;. Придерживайтесь &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; мест, которые вы получили от &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; (и никаких других), и вы обычно можете использовать &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; даже в &amp;laquo;текстовом&amp;raquo; режиме. Использование &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; или другие файловые операции могут быть непереносимой. Однако, если вы используете &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; в файле, вы обычно можете безопасно &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; произвольные значения.</target>
        </trans-unit>
        <trans-unit id="86b041b8cdbf2e2a44b563d3f9086435ec867343" translate="yes" xml:space="preserve">
          <source>Because of the 16-bitness, UTF-16 is byte-order dependent. UTF-16 itself can be used for in-memory computations, but if storage or transfer is required either UTF-16BE (big-endian) or UTF-16LE (little-endian) encodings must be chosen.</source>
          <target state="translated">Из-за 16-битности,UTF-16 зависит от порядка байт.Сама по себе кодировка UTF-16 может использоваться для вычислений в памяти,но если требуется хранение или передача,необходимо выбрать кодировку UTF-16BE (big-endian)или UTF-16LE (little-endian).</target>
        </trans-unit>
        <trans-unit id="ddcee3f7b2710d631ab7d25c7c6ccf7f643a3fe9" translate="yes" xml:space="preserve">
          <source>Because of the algorithm used, ISO-8859 series and other single-byte encodings do not work well unless either one of ISO-8859 is the only one suspect (besides ascii and utf8).</source>
          <target state="translated">Из-за используемого алгоритма серия ISO-8859 и другие однобайтовые кодировки не работают хорошо,если только ни одна из кодировок ISO-8859 не является единственной подозреваемой (кроме ascii и utf8).</target>
        </trans-unit>
        <trans-unit id="11b9a9053f80eaf386518a04692ab13e4782146b" translate="yes" xml:space="preserve">
          <source>Because of the unexpected behaviors associated with this modifier, you probably should only use it to maintain weird backward compatibilities.</source>
          <target state="translated">Из-за неожиданного поведения,связанного с этим модификатором,вероятно,следует использовать его только для поддержания странных обратных совместимостей.</target>
        </trans-unit>
        <trans-unit id="033d419ed47a31e5b1999d8b2e6265eaff662dc3" translate="yes" xml:space="preserve">
          <source>Because of their special use by sort(), the variables $a and $b are exempted from this check.</source>
          <target state="translated">Из-за их специального использования функцией sort(),переменные $a и $b освобождаются от этой проверки.</target>
        </trans-unit>
        <trans-unit id="b4c8809b3046a08b3452bb5931521fe0616806ce" translate="yes" xml:space="preserve">
          <source>Because of this mechanism it is important that &lt;b&gt;AutoLoader&lt;/b&gt; is always &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d and not &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d.</source>
          <target state="translated">Из-за этого механизма важно, чтобы &lt;b&gt;AutoLoader&lt;/b&gt; всегда &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; d и не &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; d.</target>
        </trans-unit>
        <trans-unit id="cf9b61922d31b09cb33aab7bed1a50c499c2933e" translate="yes" xml:space="preserve">
          <source>Because of those two, the code paging approach used use in ucm-based Encoding SOMETIMES fails so this module was written.</source>
          <target state="translated">Из-за этих двух факторов,подход к кодированию,используемый в ucm-based Encoding SOMETIMES,не работает,поэтому этот модуль был написан.</target>
        </trans-unit>
        <trans-unit id="4732978c8da8f3cf527ff9f22b157a0776b9721a" translate="yes" xml:space="preserve">
          <source>Because patterns are processed as double-quoted strings, the following also work:</source>
          <target state="translated">Поскольку шаблоны обрабатываются как строки в двойных кавычках,работают и следующие:</target>
        </trans-unit>
        <trans-unit id="e94cf9546dd5c84d3c599b01ef4e83754d69c340" translate="yes" xml:space="preserve">
          <source>Because perl needs to parse the script before applying this pragma, such encodings as Shift_JIS and Big-5 that may contain &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt; ) in the second byte fail because the second byte may accidentally escape the quoting character that follows.</source>
          <target state="translated">Поскольку perl должен проанализировать скрипт перед применением этой прагмы, такие кодировки, как Shift_JIS и Big-5, которые могут содержать &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt; ) во втором байте, терпят неудачу, потому что второй байт может случайно ускользнуть от следующего за ним символа кавычек .</target>
        </trans-unit>
        <trans-unit id="00d20d737f3e8559e674f183083581c5bd074a26" translate="yes" xml:space="preserve">
          <source>Because pointer size does not necessarily equal integer size, use the follow macros to do it right.</source>
          <target state="translated">Поскольку размер указателя не обязательно равен целочисленному размеру,используйте следующие макросы,чтобы сделать это правильно.</target>
        </trans-unit>
        <trans-unit id="1ab7d92c18b253929d90277eb1a2787d5ea83ae7" translate="yes" xml:space="preserve">
          <source>Because scripts differ in their directionality (Hebrew and Arabic are written right to left, for example) Unicode supplies a &lt;code&gt;Bidi_Class&lt;/code&gt; property. Some of the values this property can have are:</source>
          <target state="translated">Поскольку скрипты различаются по своей направленности (например, иврит и арабский пишутся справа налево), Unicode предоставляет свойство &lt;code&gt;Bidi_Class&lt;/code&gt; . Это свойство может иметь следующие значения:</target>
        </trans-unit>
        <trans-unit id="5783acfed14f8a18cb2ce82232df112d8f4b39d0" translate="yes" xml:space="preserve">
          <source>Because taintedness is associated with each scalar value, some elements of an array or hash can be tainted and others not. The keys of a hash are &lt;b&gt;never&lt;/b&gt; tainted.</source>
          <target state="translated">Поскольку испорченность связана с каждым скалярным значением, некоторые элементы массива или хэша могут быть испорчены, а другие нет. Ключи хеша &lt;b&gt;никогда не&lt;/b&gt; испорчены.</target>
        </trans-unit>
        <trans-unit id="43efff829e58f5a1345657268ce9125ae02a8e64" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;ed value will have the separator reattached when it is written back to the file. There is no way to create a file whose trailing record separator string is missing.</source>
          <target state="translated">Потому что значение &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; ed будет иметь разделитель, когда оно будет записано обратно в файл. Невозможно создать файл, в котором отсутствует конечная строка разделителя записей.</target>
        </trans-unit>
        <trans-unit id="1a39cf872a3f7b6aa066ba9c7802115aead55d6e" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; at end of file or upon error, you will sometimes see it used this way:</source>
          <target state="translated">Поскольку функция &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в конце файла или при ошибке, иногда вы можете увидеть, что она используется следующим образом:</target>
        </trans-unit>
        <trans-unit id="2d7cdbb67a74f8d2c9c047551149590e9752d672" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement implies a &lt;code&gt;BEGIN&lt;/code&gt; block, the importing of semantics happens as soon as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement is compiled, before the rest of the file is compiled. This is how it is able to function as a pragma mechanism, and also how modules are able to declare subroutines that are then visible as list or unary operators for the rest of the current file. This will not work if you use &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;. With &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you can get into this problem:</source>
          <target state="translated">Поскольку оператор &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; подразумевает блок &lt;code&gt;BEGIN&lt;/code&gt; , импорт семантики происходит, как только оператор &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; компилируется, до компиляции остальной части файла. Вот как он может функционировать как механизм прагмы, а также как модули могут объявлять подпрограммы, которые затем отображаются в виде списка или унарных операторов для остальной части текущего файла. Это не сработает, если вы используете &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; вместо &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; . С помощью &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; вы можете столкнуться с этой проблемой:</target>
        </trans-unit>
        <trans-unit id="af2ba8c1f36d75fd963bdb6706751e36d03bae43" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;here&lt;/code&gt; is before the &lt;code&gt;.*&lt;/code&gt; in the pattern, its position can be determined exactly. That's not true, however, for the &lt;code&gt;there&lt;/code&gt; ; it could appear at any point after where the anchored string appeared. Perl uses both for its optimisations, preferring the longer, or, if they are equal, the floating.</source>
          <target state="translated">Поскольку &lt;code&gt;here&lt;/code&gt; перед &lt;code&gt;.*&lt;/code&gt; В шаблоне, его положение можно определить точно. Однако это не так для &lt;code&gt;there&lt;/code&gt; ; он мог появиться в любой момент после того, как появилась закрепленная строка. Perl использует оба варианта для оптимизации, предпочитая более длинный или, если они равны, плавающий.</target>
        </trans-unit>
        <trans-unit id="77f9c95f62f2ca8f51dfcabf085dd8aa40d54fc6" translate="yes" xml:space="preserve">
          <source>Because the assignment copies the values, this also has the effect of turning call-by-reference into call-by-value. Otherwise a function is free to do in-place modifications of &lt;code&gt;@_&lt;/code&gt; and change its caller's values.</source>
          <target state="translated">Поскольку присвоение копирует значения, это также приводит к превращению вызова по ссылке в вызов по значению. В противном случае функция может &lt;code&gt;@_&lt;/code&gt; изменения в @_ на месте и изменять значения вызывающей стороны.</target>
        </trans-unit>
        <trans-unit id="6c5cdf7c11299fa442df7b9179d8baed60991f7f" translate="yes" xml:space="preserve">
          <source>Because the conversion happens in place, the data to be converted cannot be a string constant: it must be a scalar variable.</source>
          <target state="translated">Поскольку преобразование происходит на месте,данные,которые должны быть преобразованы,не могут быть строковой константой:это должна быть скалярная переменная.</target>
        </trans-unit>
        <trans-unit id="9be0ebeeed384a0006842b7e5b00f870be61a55a" translate="yes" xml:space="preserve">
          <source>Because the current implementation uses the table and key sizes for the hashing algorithm, there is no means by which to dynamically change the value of any of the initialization parameters.</source>
          <target state="translated">Поскольку в текущей реализации используется таблица и размеры ключей для алгоритма хэширования,то нет средств,с помощью которых можно динамически изменять значение любого из параметров инициализации.</target>
        </trans-unit>
        <trans-unit id="a16d069c72d0455b6bbcd09050d9c581b9a31d6b" translate="yes" xml:space="preserve">
          <source>Because the intent of this feature is primarily to let you define subroutines that work like built-in functions, here are prototypes for some other functions that parse almost exactly like the corresponding built-in.</source>
          <target state="translated">Так как цель этой функции в первую очередь заключается в том,чтобы позволить вам определять подпрограммы,которые работают как встроенные функции,вот прототипы некоторых других функций,которые анализируют почти точно так же,как и соответствующие встроенные функции.</target>
        </trans-unit>
        <trans-unit id="286b10724045d4807f7e79831cdfb01b70d2bd21" translate="yes" xml:space="preserve">
          <source>Because the internal format is often UTF-8, these bugs are hard to spot, because UTF-8 is usually the encoding you wanted! But don't be lazy, and don't use the fact that Perl's internal format is UTF-8 to your advantage. Encode explicitly to avoid weird bugs, and to show to maintenance programmers that you thought this through.</source>
          <target state="translated">Поскольку внутренний формат часто бывает UTF-8,эти ошибки трудно обнаружить,потому что UTF-8-это обычно та кодировка,которую вы хотели! Но не ленитесь и не используйте в своих интересах тот факт,что внутренний формат Perl-UTF-8.Кодируйте явно,чтобы избежать странных ошибок и показать обслуживающему программисту,что вы все продумали.</target>
        </trans-unit>
        <trans-unit id="2a9f9af112f672f597ba8d8590f5548d9330b12e" translate="yes" xml:space="preserve">
          <source>Because the mode contains both the file type and its permissions, you should mask off the file type portion and (s)printf using a &lt;code&gt;&quot;%o&quot;&lt;/code&gt; if you want to see the real permissions.</source>
          <target state="translated">Поскольку режим содержит как тип файла, так и его разрешения, вы должны замаскировать часть типа файла и (-ы) printf, используя &lt;code&gt;&quot;%o&quot;&lt;/code&gt; если вы хотите увидеть реальные разрешения.</target>
        </trans-unit>
        <trans-unit id="f2423ea47c406258a59791ed602061d34ce7d19b" translate="yes" xml:space="preserve">
          <source>Because the result of &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; has all metacharacters quoted, there is no way to insert a literal &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; inside a &lt;code&gt;\Q\E&lt;/code&gt; pair. If protected by &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; will be quoted to become &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ; if not, it is interpreted as the start of an interpolated scalar.</source>
          <target state="translated">Поскольку в результате &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; все метасимволы заключены в кавычки, нет возможности вставить литерал &lt;code&gt;$&lt;/code&gt; или &lt;code&gt;@&lt;/code&gt; внутри пары &lt;code&gt;\Q\E&lt;/code&gt; Если защищено &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; будет заключено в кавычки, чтобы стать &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ; в противном случае он интерпретируется как начало интерполированного скаляра.</target>
        </trans-unit>
        <trans-unit id="d152f048af7d90769fe2fc306e54559a9ec00ef1" translate="yes" xml:space="preserve">
          <source>Because the smartmatch operator recurses on nested arrays, this will still report that &quot;red&quot; is in the array.</source>
          <target state="translated">Так как оператор smartmatch возвращается на вложенные массивы,он все равно будет сообщать,что &quot;красный&quot; находится в массиве.</target>
        </trans-unit>
        <trans-unit id="2efc41902e93fe5cc4de4d763dfe32a371a96fe2" translate="yes" xml:space="preserve">
          <source>Because the standard failure message that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; produces whenever a test fails will be a common occurrence in your test error output, and because it has changed between Test::Builder versions, rather than forcing you to call &lt;code&gt;test_err&lt;/code&gt; with the string all the time like so</source>
          <target state="translated">Поскольку стандартное сообщение об ошибке, которое &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; выдает всякий раз, когда тест терпит неудачу, будет обычным явлением в вашем выводе ошибок теста, и поскольку оно изменилось между версиями Test :: Builder, вместо того, чтобы заставлять вас вызывать &lt;code&gt;test_err&lt;/code&gt; со строкой, такое время</target>
        </trans-unit>
        <trans-unit id="4ad62b1bf690da795c5cc2f593aa204a22c3e54b" translate="yes" xml:space="preserve">
          <source>Because the target is reused, you must be careful when pushing multiple values on the stack. The following code will not do what you think:</source>
          <target state="translated">Так как цель используется повторно,вы должны быть осторожны при выталкивании нескольких значений в стеке.Следующий код не будет делать то,что вы думаете:</target>
        </trans-unit>
        <trans-unit id="bdc28270d2ca87731131681df34d184cd0aea361" translate="yes" xml:space="preserve">
          <source>Because the transliteration table is built at compile time, neither the</source>
          <target state="translated">Поскольку таблица транслитерации строится во время компиляции,ни</target>
        </trans-unit>
        <trans-unit id="2e5bc19b54b9930fd5e2dcb3e6dfb795d20462ff" translate="yes" xml:space="preserve">
          <source>Because the value of &lt;code&gt;$Config{archname}&lt;/code&gt; may depend on the hardware architecture, it can vary more than the value of &lt;code&gt;$^O&lt;/code&gt; .</source>
          <target state="translated">Поскольку значение &lt;code&gt;$Config{archname}&lt;/code&gt; может зависеть от архитектуры аппаратных средств, она может изменяться более чем значение &lt;code&gt;$^O&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e90ed527002ad403540a55eb78d4c5ab847fcd41" translate="yes" xml:space="preserve">
          <source>Because the values line may contain arbitrary expressions (for at fields, not caret fields), you can farm out more sophisticated processing to other functions, like sprintf() or one of your own. For example:</source>
          <target state="translated">Поскольку строка значений может содержать произвольные выражения (для полей,а не для каретных полей),вы можете передать более сложную обработку в другие функции,такие как sprintf()или одну из ваших собственных.Например:</target>
        </trans-unit>
        <trans-unit id="d8bc8ec23c88de9efd45beeefb8be0639f500936" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">Поскольку переменная становится допустимой сразу после &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , до тех пор, пока в области нет переменной с таким именем, вы можете снова ссылаться на переменную пакета даже в том же операторе.</target>
        </trans-unit>
        <trans-unit id="da44b03f12b50aea312686ca3a3d0b93a5cee3d2" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">Поскольку переменная становится допустимой сразу после &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , до тех пор, пока в области нет переменной с таким именем, вы можете снова ссылаться на переменную пакета даже в том же операторе.</target>
        </trans-unit>
        <trans-unit id="1213676c8b2ebcfdeacd60c8eeb78e070a8906e8" translate="yes" xml:space="preserve">
          <source>Because there are more than three arguments to open(), forks the ps(1) command</source>
          <target state="translated">Так как существует более трех аргументов для функции open(),вилки команды ps(1)</target>
        </trans-unit>
        <trans-unit id="63c371b01d835f1b3e60dfea4284b4178cc48a57" translate="yes" xml:space="preserve">
          <source>Because there are people who have their precise expectations about who may install where in the @INC path and who uses which @INC array. In fine tuned environments &lt;code&gt;UNINST=1&lt;/code&gt; can cause damage.</source>
          <target state="translated">Потому что есть люди, у которых есть свои точные ожидания относительно того, кто может устанавливать где в пути @INC и кто использует какой массив @INC. В точно настроенной среде &lt;code&gt;UNINST=1&lt;/code&gt; может вызвать повреждение.</target>
        </trans-unit>
        <trans-unit id="b691163394a932e3f6d352ebd6e7cd633110d322" translate="yes" xml:space="preserve">
          <source>Because these resource objects are considered to be owned by the entire process/system, and not the &quot;property&quot; of whatever is being serialized, no references underneath the object should be included in the serialized string. Thus, in any class that implements &lt;code&gt;STORABLE_attach&lt;/code&gt; , the &lt;code&gt;STORABLE_freeze&lt;/code&gt; method cannot return any references, and &lt;code&gt;Storable&lt;/code&gt; will throw an error if &lt;code&gt;STORABLE_freeze&lt;/code&gt; tries to return references.</source>
          <target state="translated">Поскольку считается, что эти объекты ресурсов принадлежат всему процессу / системе, а не &amp;laquo;свойству&amp;raquo; того, что сериализуется, никакие ссылки под объектом не должны включаться в сериализованную строку. Таким образом, в любом классе, реализующем &lt;code&gt;STORABLE_attach&lt;/code&gt; , метод &lt;code&gt;STORABLE_freeze&lt;/code&gt; не может возвращать никаких ссылок, а &lt;code&gt;Storable&lt;/code&gt; выдаст ошибку, если &lt;code&gt;STORABLE_freeze&lt;/code&gt; попытается вернуть ссылки.</target>
        </trans-unit>
        <trans-unit id="e58a7f2a84e13b9fada5ed77ade53adda8ab6513" translate="yes" xml:space="preserve">
          <source>Because this command is in some senses new, a warning is issued if you appear to have accidentally entered a block instead. If that's what you mean to do, write it as with &lt;code&gt;;{ ... }&lt;/code&gt; or even &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; .</source>
          <target state="translated">Поскольку эта команда в некотором смысле является новой, выдается предупреждение, если вместо этого вы случайно вошли в блок. Если это то, что вы хотите сделать, напишите это как с &lt;code&gt;;{ ... }&lt;/code&gt; или даже &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efa88e36be50b169e959caa4254fea74155063be" translate="yes" xml:space="preserve">
          <source>Because this function uses mktemp(), it can suffer from race conditions.</source>
          <target state="translated">Поскольку эта функция использует mktemp(),она может страдать от гоночных условий.</target>
        </trans-unit>
        <trans-unit id="2478181856508c1cc91e32c539a156e07c17eb63" translate="yes" xml:space="preserve">
          <source>Because this information is not stored within the perl executable itself it is possible (but unlikely) that the information does not relate to the actual perl binary which is being used to access it.</source>
          <target state="translated">Поскольку эта информация не хранится в самом исполняемом файле perl,возможно (но маловероятно),что она не относится к фактическому двоичному файлу perl,который используется для доступа к нему.</target>
        </trans-unit>
        <trans-unit id="ad52e097251691a48fd57b8bdbc852cffc9bb5f6" translate="yes" xml:space="preserve">
          <source>Because this is a wide-open interface, pragmas (compiler directives) are also implemented this way. Currently implemented pragmas are:</source>
          <target state="translated">Поскольку это широко открытый интерфейс,таким же образом реализуются прагмы (директивы компилятора).В настоящее время реализованы прагмы:</target>
        </trans-unit>
        <trans-unit id="e8055a645160d58d1aa3758824d7f3046e3cd0a9" translate="yes" xml:space="preserve">
          <source>Because this operator produces an assignable result, using assignments without parentheses will get you in trouble. For example, this:</source>
          <target state="translated">Поскольку этот оператор выдает присваиваемый результат,использование присваиваний без круглых скобок приведет к неприятностям.Например,это:</target>
        </trans-unit>
        <trans-unit id="cda353c8b2d143f02b4da6818d79c64f57fb0765" translate="yes" xml:space="preserve">
          <source>Because this promotes action at a distance, this counterintuitive behavior may be fixed in a future release.</source>
          <target state="translated">Так как это способствует действиям на расстоянии,это антиинтуитивное поведение может быть исправлено в будущем релизе.</target>
        </trans-unit>
        <trans-unit id="ece57b9cb9008cd6f8ed94726d6205b9428981dc" translate="yes" xml:space="preserve">
          <source>Because thread creation and thread joining may occur in different contexts, it may be desirable to state the context explicitly to the thread's entry point function. This may be done by calling &lt;code&gt;-&amp;gt;create()&lt;/code&gt; with a hash reference as the first argument:</source>
          <target state="translated">Поскольку создание потока и присоединение к потоку могут происходить в разных контекстах, может быть желательно указать контекст явно для функции точки входа потока. Это можно сделать, вызвав &lt;code&gt;-&amp;gt;create()&lt;/code&gt; с хеш-ссылкой в ​​качестве первого аргумента:</target>
        </trans-unit>
        <trans-unit id="a311abdd84d17ec36b9f35316e74bcbefa1ccdb8" translate="yes" xml:space="preserve">
          <source>Because variable references always start with '$', '@', or '%', the &quot;reserved&quot; words aren't in fact reserved with respect to variable names. They</source>
          <target state="translated">Поскольку ссылки на переменные всегда начинаются с '$','@' или '%',то слова &quot;зарезервированы&quot; в отношении имен переменных на самом деле не зарезервированы.Они .</target>
        </trans-unit>
        <trans-unit id="0ac64477279b51b2f8ca41484de7b49285b3815c" translate="yes" xml:space="preserve">
          <source>Because we are now concerned with the return value from</source>
          <target state="translated">Потому что сейчас нас беспокоит возвратное значение из</target>
        </trans-unit>
        <trans-unit id="9befd612f9b4e3c124f9ec128a96394cb71cf6fb" translate="yes" xml:space="preserve">
          <source>Because we are using an SV to call</source>
          <target state="translated">Потому что мы используем SV,чтобы позвонить</target>
        </trans-unit>
        <trans-unit id="ded04a0cee8ca9e46b88306d00153b5faa51a410" translate="yes" xml:space="preserve">
          <source>Because we created temporary values (by means of sv_2mortal() calls) we will have to tidy up the Perl stack and dispose of mortal SVs.</source>
          <target state="translated">Так как мы создали временные значения (с помощью вызовов sv_2mortal()),нам придется привести в порядок стек Perl и утилизировать смертельные SV.</target>
        </trans-unit>
        <trans-unit id="aa34046474e322c81f9b04585e1a1d3d975224ac" translate="yes" xml:space="preserve">
          <source>Because we specified G_DISCARD, it is not necessary to check the value returned from</source>
          <target state="translated">Так как мы указали G_DISCARD,нет необходимости проверять значение,возвращаемое с</target>
        </trans-unit>
        <trans-unit id="941fe97debd1bfb6b702aacc07a44435ca4e56b7" translate="yes" xml:space="preserve">
          <source>Because when &lt;code&gt;autochomp&lt;/code&gt; is disabled, &lt;code&gt;$a[10]&lt;/code&gt; will read back as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (or whatever the record separator string is.)</source>
          <target state="translated">Потому что, когда &lt;code&gt;autochomp&lt;/code&gt; отключен, &lt;code&gt;$a[10]&lt;/code&gt; будет считываться как &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (или как там есть строка разделителя записей.)</target>
        </trans-unit>
        <trans-unit id="b0a17ee4f4c080e1c09fd835e1c924855560fcaf" translate="yes" xml:space="preserve">
          <source>Because you just moved the existing &lt;b&gt;stdout&lt;/b&gt; to somewhere else.</source>
          <target state="translated">Потому что вы только что переместили существующий стандартный &lt;b&gt;вывод&lt;/b&gt; в другое место.</target>
        </trans-unit>
        <trans-unit id="aa628e92b3c4d485e932ec48525c963ebb2f9c63" translate="yes" xml:space="preserve">
          <source>Because you're using something like this, which truncates the file</source>
          <target state="translated">Потому что ты используешь нечто подобное,что усекает файл.</target>
        </trans-unit>
        <trans-unit id="973ca6acb768a5dd6330a5eade0b5d4dbc53ee84" translate="yes" xml:space="preserve">
          <source>Before Perl 5.10.0 and 5.8.8, PERL5SHELL was not taint checked when running external commands. It is recommended that you explicitly set (or delete) &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; when running in taint mode under Windows.</source>
          <target state="translated">До Perl 5.10.0 и 5.8.8, PERL5SHELL не проверялся на заражение при запуске внешних команд. Рекомендуется явно установить (или удалить) &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; при работе в режиме заражения под Windows.</target>
        </trans-unit>
        <trans-unit id="36d386f00504590e35abdcaf1bc115cbe7c02503" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the assignment to &lt;code&gt;$@&lt;/code&gt; occurred before restoration of localized variables, which means that for your code to run on older versions, a temporary is required if you want to mask some but not all errors:</source>
          <target state="translated">До Perl 5.14 присвоение &lt;code&gt;$@&lt;/code&gt; происходило перед восстановлением локализованных переменных, что означает, что для запуска вашего кода в более старых версиях требуется временное значение, если вы хотите замаскировать некоторые, но не все ошибки:</target>
        </trans-unit>
        <trans-unit id="512488ae279d498c1ee81f682f1f53229da4c6e2" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the relation between overloading and tie()ing was broken. Overloading was triggered or not based on the</source>
          <target state="translated">До версии Perl 5.14 связь между перегрузкой и привязкой была нарушена.Перегрузка была спровоцирована или не спровоцирована по принципу</target>
        </trans-unit>
        <trans-unit id="b34cea36bce317a875588bd1ba293a621fd141d4" translate="yes" xml:space="preserve">
          <source>Before Perl 5.18, &lt;code&gt;given(EXPR)&lt;/code&gt; assigned the value of</source>
          <target state="translated">До Perl 5.18 &lt;code&gt;given(EXPR)&lt;/code&gt; присваивалось значение</target>
        </trans-unit>
        <trans-unit id="54445efd0dc2c1e8891bd0fe2ff854e28637df1f" translate="yes" xml:space="preserve">
          <source>Before Perl 5.6, you had to use the &lt;code&gt;*FH&lt;/code&gt; or &lt;code&gt;\*FH&lt;/code&gt; notations. These are &quot;typeglobs&quot;--see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs and Filehandles in perldata&lt;/a&gt; and especially &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference in perlsub&lt;/a&gt; for more information.</source>
          <target state="translated">До Perl 5.6 вам приходилось использовать нотацию &lt;code&gt;*FH&lt;/code&gt; или &lt;code&gt;\*FH&lt;/code&gt; . Это &amp;laquo;typeglobs&amp;raquo; - см. &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs и Filehandles в perldata&lt;/a&gt; и особенно &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference в perlsub&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="2df4fb0a98f840a2555a3347deeff121cc142591" translate="yes" xml:space="preserve">
          <source>Before Perl 5.8.0, installing Perl code to deal with signals exposed you to danger from two things. First, few system library functions are re-entrant. If the signal interrupts while Perl is executing one function (like malloc(3) or printf(3)), and your signal handler then calls the same function again, you could get unpredictable behavior--often, a core dump. Second, Perl isn't itself re-entrant at the lowest levels. If the signal interrupts Perl while Perl is changing its own internal data structures, similarly unpredictable behavior may result.</source>
          <target state="translated">Перед установкой Perl 5.8.0 установите Perl-код для работы с сигналами,подвергающими Вас опасности двух вещей.Во-первых,лишь немногие функции системной библиотеки возвращаются в систему.Если сигнал прерывается во время выполнения Perl одной функции (например,malloc(3)или printf(3)),а затем Ваш обработчик сигнала снова вызывает ту же самую функцию,Вы можете получить непредсказуемое поведение-часто дамп ядра.Во-вторых,Perl сам по себе не возвращается на самых низких уровнях.Если сигнал прерывает Perl в то время,когда Perl изменяет свои собственные внутренние структуры данных,это может привести к такому же непредсказуемому поведению.</target>
        </trans-unit>
        <trans-unit id="870cc998eebf778ddd06bc7ed2f1805b37f31d55" translate="yes" xml:space="preserve">
          <source>Before Perl v5.8.0, the use of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; was used to declare that operations in the current block or file would be Unicode-aware. This model was found to be wrong, or at least clumsy: the &quot;Unicodeness&quot; is now carried with the data, instead of being attached to the operations. Starting with Perl v5.8.0, only one case remains where an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
utf8&lt;/code&gt; is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8 in your identifier names, and in string and regular expression literals, by saying &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; . This is not the default because scripts with legacy 8-bit data in them would break. See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">До Perl v5.8.0 использование &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; использовалось для объявления того, что операции в текущем блоке или файле будут поддерживать Unicode. Эта модель оказалась ошибочной или, по крайней мере, неуклюжей: &amp;laquo;Уникальность&amp;raquo; теперь переносится с данными, а не с операциями. Начиная с Perl v5.8.0, остается только один случай, когда требуется явное &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; : если сам сценарий Perl закодирован в UTF-8, вы можете использовать UTF-8 в именах идентификаторов, а также в литералах строк и регулярных выражений, говоря, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; . Это не по умолчанию, потому что скрипты с устаревшими 8-битными данными могут сломаться. См. &lt;a href=&quot;utf8&quot;&gt;Utf8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04e04ef0cf482846e31d6720b49ae41928208ea3" translate="yes" xml:space="preserve">
          <source>Before Unicode, most encodings used 8 bits (a single byte) to encode each character. Thus a character was a byte, and a byte was a character, and there could be only 256 or fewer possible characters. &quot;Byte Semantics&quot; in the title of this section refers to this behavior. There was no need to distinguish between &quot;Byte&quot; and &quot;Character&quot;.</source>
          <target state="translated">До появления Юникода большинство кодировок использовали 8 бит (один байт)для кодирования каждого символа.Таким образом,символ был байтом,а байт-символом,а возможных символов могло быть только 256 или меньше.&quot;Семантика байтов&quot; в заголовке этого раздела относится к такому поведению.Нет необходимости различать &quot;байт&quot; и &quot;персонаж&quot;.</target>
        </trans-unit>
        <trans-unit id="290d67ae3ee387c5e4e99c79148af4efc4e204f2" translate="yes" xml:space="preserve">
          <source>Before Unicode, when a character was a byte was a character, Perl knew only about the 128 characters defined by ASCII, code points 0 through 127 (except for under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ). That left the code points 128 to 255 as unassigned, and available for whatever use a program might want. The only semantics they have is their ordinal numbers, and that they are members of none of the non-negative character classes. None are considered to match &lt;code&gt;\w&lt;/code&gt; for example, but all match &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">До Unicode, когда символ был байтом, Perl знал только о 128 символах, определенных ASCII, кодовых точках от 0 до 127 (за исключением &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ). Это оставило кодовые точки со 128 по 255 как неназначенные и доступные для любого использования, которое может потребоваться программе. Единственная семантика, которую они имеют, - это их порядковые номера и то, что они не являются членами ни одного из классов неотрицательных символов. Никто не считается , чтобы соответствовать &lt;code&gt;\w&lt;/code&gt; , например, но весь матч &lt;code&gt;\W&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d690a12b540a565baadfa57c599d5a868691200d" translate="yes" xml:space="preserve">
          <source>Before any command has executed or if an unexpected error occurs &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return undef.</source>
          <target state="translated">Перед выполнением любой команды или в случае возникновения непредвиденной ошибки &lt;code&gt;code()&lt;/code&gt; вернет &amp;laquo;421&amp;raquo; (временный сбой соединения), а &lt;code&gt;message()&lt;/code&gt; вернет undef.</target>
        </trans-unit>
        <trans-unit id="752f8552c1f4e0b002a40cffe2d75752a7a074d6" translate="yes" xml:space="preserve">
          <source>Before anything else, you need a testing plan. This basically declares how many tests your script is going to run to protect against premature failure.</source>
          <target state="translated">Прежде чем что-то еще,тебе нужен план тестирования.Он,по сути,объявляет,сколько тестов ваш скрипт будет выполнять для защиты от преждевременного отказа.</target>
        </trans-unit>
        <trans-unit id="4bb0c278106c5fac84e8a238d47e490b85a41fa5" translate="yes" xml:space="preserve">
          <source>Before installing the patches to the IBM C-compiler you need to know the level of patching for the Operating System. IBM's command 'oslevel' will show the base, but is not always complete (in this example oslevel shows 4.3.NULL, whereas the system might run most of 4.3.THREE):</source>
          <target state="translated">Перед установкой патчей на С-компилятор IBM необходимо знать уровень патча для операционной системы.Команда IBM 'oslevel' покажет базу,но не всегда является полной (в данном примере oslevel показывает 4.3.NULL,в то время как система может работать большую часть 4.3.THREE):</target>
        </trans-unit>
        <trans-unit id="b46ac14ab9ac97916ee87fb2735b65fa3bcb3084" translate="yes" xml:space="preserve">
          <source>Before perl5.6, you had to deal with various typeglob idioms which you may see in older code.</source>
          <target state="translated">До версии perl5.6 приходилось иметь дело с различными идиомами типографских шрифтов,которые можно увидеть в старом коде.</target>
        </trans-unit>
        <trans-unit id="4d24253ab2fd2c805f0d6bcaca41ee8bd8627285" translate="yes" xml:space="preserve">
          <source>Before release 5 of Perl it was difficult to represent complex data structures, because all references had to be symbolic--and even then it was difficult to refer to a variable instead of a symbol table entry. Perl now not only makes it easier to use symbolic references to variables, but also lets you have &quot;hard&quot; references to any piece of data or code. Any scalar may hold a hard reference. Because arrays and hashes contain scalars, you can now easily build arrays of arrays, arrays of hashes, hashes of arrays, arrays of hashes of functions, and so on.</source>
          <target state="translated">До версии 5 Perl было сложно представить сложные структуры данных,потому что все ссылки должны были быть символическими-и даже тогда было трудно ссылаться на переменную вместо записи в таблице символов.Теперь Perl не только упрощает использование символьных ссылок на переменные,но и позволяет иметь &quot;жесткие&quot; ссылки на любой фрагмент данных или кода.Любой скаляр может содержать жесткую ссылку.Поскольку массивы и хэши содержат скаляры,теперь можно легко строить массивы массивов,массивы хэшей,хэши массивов,массивы хэшей функций и так далее.</target>
        </trans-unit>
        <trans-unit id="ef266fb9e8f6dafd9b23077a1b88d8327a3a9667" translate="yes" xml:space="preserve">
          <source>Before submitting a bug, please make sure that the traditional method of building a Perl module package from a shell by following the installation instructions of that package still works in your environment.</source>
          <target state="translated">Перед отправкой сообщения об ошибке убедитесь,что традиционный метод сборки пакета модуля Perl из оболочки,следуя инструкциям по установке этого пакета,все еще работает в вашем окружении.</target>
        </trans-unit>
        <trans-unit id="852a62fb5185caad446c6f66da79350d77dac37e" translate="yes" xml:space="preserve">
          <source>Before terminating, the &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function must explicitly install the filter by calling &lt;code&gt;filter_add&lt;/code&gt; .</source>
          <target state="translated">Перед завершением функция &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; должна явно установить фильтр, вызвав &lt;code&gt;filter_add&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f512253f81c2fd706ba28a9ad84dc13dc48c3eb8" translate="yes" xml:space="preserve">
          <source>Before the Perl interpreter can execute a Perl script, it must first read it from a file into memory for parsing and compilation. If that script itself includes other scripts with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement, then each of those scripts will have to be read from their respective files as well.</source>
          <target state="translated">Прежде чем интерпретатор Perl сможет выполнить сценарий Perl, он должен сначала прочитать его из файла в память для анализа и компиляции. Если этот сценарий сам включает в себя другие сценарии с инструкциями &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , то каждый из этих сценариев также должен быть прочитан из соответствующих файлов.</target>
        </trans-unit>
        <trans-unit id="7056378ac690eaab80565ece696557496384c5bd" translate="yes" xml:space="preserve">
          <source>Before the introduction of Unicode support in Perl, The &lt;code&gt;eq&lt;/code&gt; operator just compared the strings represented by two scalars. Beginning with Perl 5.8, &lt;code&gt;eq&lt;/code&gt; compares two strings with simultaneous consideration of</source>
          <target state="translated">До появления поддержки Unicode в Perl оператор &lt;code&gt;eq&lt;/code&gt; просто сравнивал строки, представленные двумя скалярами. Начиная с Perl 5.8, &lt;code&gt;eq&lt;/code&gt; сравнивает две строки с одновременным учетом</target>
        </trans-unit>
        <trans-unit id="07d7d02c48129829b963f0f9c3efb3625c646877" translate="yes" xml:space="preserve">
          <source>Before the introduction of lexical warnings, Perl had two classes of warnings: mandatory and optional.</source>
          <target state="translated">До введения лексических предупреждений Perl имел два класса предупреждений:обязательные и необязательные.</target>
        </trans-unit>
        <trans-unit id="759cf8f89c69b1e5d0ddf3e544f843b8c5c70ae3" translate="yes" xml:space="preserve">
          <source>Before we even start scraping out the code, there are a few things we'll want to do in advance.</source>
          <target state="translated">Еще до того,как мы начнем соскребать код,есть несколько вещей,которые мы захотим сделать заранее.</target>
        </trans-unit>
        <trans-unit id="a2896a2a84e6fb1618d5a02150eb4f976c910264" translate="yes" xml:space="preserve">
          <source>Before we go any further, you'll want to know how to quit the debugger: use just the letter '&lt;b&gt;q&lt;/b&gt;', not the words 'quit' or 'exit':</source>
          <target state="translated">Прежде чем мы пойдем дальше, вы захотите узнать, как выйти из отладчика: используйте только букву &amp;laquo; &lt;b&gt;q&lt;/b&gt; &amp;raquo;, а не слова &amp;laquo;выйти&amp;raquo; или &amp;laquo;выйти&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="8a4b62fae1d0e77e031397754824b30119b2b62a" translate="yes" xml:space="preserve">
          <source>Before writing XS, read the &lt;a href=&quot;#CAVEATS&quot;&gt;CAVEATS&lt;/a&gt; section below.</source>
          <target state="translated">Прежде чем писать XS, прочтите раздел &lt;a href=&quot;#CAVEATS&quot;&gt;ПРЕДОСТЕРЕЖЕНИЯ&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="1b5bba6a088484e3f244c7ed2d3c63206cbf13d5" translate="yes" xml:space="preserve">
          <source>Before you consider posting a bug report, please consult, and possibly post a message to the discussion forum to see if what you've encountered is a known problem.</source>
          <target state="translated">Перед тем,как рассматривать возможность отправки сообщения об ошибке,пожалуйста,проконсультируйтесь и,возможно,отправьте сообщение на дискуссионный форум,чтобы узнать,является ли то,с чем вы столкнулись,известной проблемой.</target>
        </trans-unit>
        <trans-unit id="528e582d94b55449ac3523f64dd0d0e5c7486531" translate="yes" xml:space="preserve">
          <source>Before you continue, note the sort order for variables. In general, we first list the variables in case-insensitive, almost-lexigraphical order (ignoring the &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt; preceding words, as in &lt;code&gt;${^UNICODE}&lt;/code&gt; or &lt;code&gt;$^T&lt;/code&gt; ), although &lt;code&gt;$_&lt;/code&gt; and &lt;code&gt;@_&lt;/code&gt; move up to the top of the pile. For variables with the same identifier, we list it in order of scalar, array, hash, and bareword.</source>
          <target state="translated">Прежде чем продолжить, обратите внимание на порядок сортировки переменных. Обычно мы сначала перечисляем переменные в почти лексиграфическом порядке без учета регистра (игнорируя предшествующие слова &lt;code&gt;{&lt;/code&gt; или &lt;code&gt;^&lt;/code&gt; , как в &lt;code&gt;${^UNICODE}&lt;/code&gt; или &lt;code&gt;$^T&lt;/code&gt; ), хотя &lt;code&gt;$_&lt;/code&gt; и &lt;code&gt;@_&lt;/code&gt; перемещаются вверх из сваи. Для переменных с одним и тем же идентификатором мы перечисляем его в порядке скаляра, массива, хэша и голого слова.</target>
        </trans-unit>
        <trans-unit id="29b11945139a380af16d5d49212f0306507606fb" translate="yes" xml:space="preserve">
          <source>Before you decide to merge two hashes, you have to decide what to do if both hashes contain keys that are the same and if you want to leave the original hashes as they were.</source>
          <target state="translated">Перед тем,как вы решите объединить два хэша,вы должны решить,что делать,если оба хэша содержат одинаковые ключи,и если вы хотите оставить оригинальные хэши такими,какими они были.</target>
        </trans-unit>
        <trans-unit id="7b25edaa05329b202d8bbb719df130a305f9a0e7" translate="yes" xml:space="preserve">
          <source>Before you do anything else, you can help yourself by ensuring that you let Perl tell you about problem areas in your code. By turning on warnings and strictures, you can head off many problems before they get too big. You can find out more about these in &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">Прежде чем делать что-либо еще, вы можете помочь себе, убедившись, что Perl сообщит вам о проблемных областях вашего кода. Включив предупреждения и ограничения, вы можете предотвратить многие проблемы, прежде чем они станут слишком большими. Вы можете узнать больше об этом в &lt;a href=&quot;strict&quot;&gt;разделе &amp;laquo;Строгие правила&lt;/a&gt; и &lt;a href=&quot;warnings&quot;&gt;предупреждения&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="054a146795bb49c5d92e2d968e739a1f63c7604c" translate="yes" xml:space="preserve">
          <source>Before you do that, first make sure the alias is nonexistent using &lt;code&gt;resolve_alias()&lt;/code&gt; , which returns the canonical name thereof. For example:</source>
          <target state="translated">Перед тем как сделать это, сначала убедитесь, что псевдоним не существует, с помощью &lt;code&gt;resolve_alias()&lt;/code&gt; , который возвращает его каноническое имя. Например:</target>
        </trans-unit>
        <trans-unit id="ea4eb9d8b93fbec8607b4df5d4d1083567318fe5" translate="yes" xml:space="preserve">
          <source>Before you launch yourself head first into the rest of this document, it would be a good idea to have read the following two documents--&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">Прежде чем приступить к &lt;a href=&quot;perlxs&quot;&gt;изучению&lt;/a&gt; остальной части этого документа, было бы неплохо прочитать следующие два документа - perlxs и &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dde9d3bcf2359cbba92e26ac6718964bcaacd3c3" translate="yes" xml:space="preserve">
          <source>Before you panic, know that many people do use &lt;code&gt;Moose&lt;/code&gt; for command-line tools and other startup-sensitive code. We encourage you to try &lt;code&gt;Moose&lt;/code&gt; out first before worrying about startup speed.</source>
          <target state="translated">Прежде чем паниковать, знайте, что многие люди действительно используют &lt;code&gt;Moose&lt;/code&gt; для инструментов командной строки и другого кода, чувствительного к запуску. Мы рекомендуем вам сначала попробовать &lt;code&gt;Moose&lt;/code&gt; , прежде чем беспокоиться о скорости запуска.</target>
        </trans-unit>
        <trans-unit id="2c445dd5994fd48a7f879efa85cd15aa5394f95f" translate="yes" xml:space="preserve">
          <source>Before you start</source>
          <target state="translated">Прежде чем вы начнете</target>
        </trans-unit>
        <trans-unit id="fa35a8236ca3aecdca56f64d9f3832c8bf9e0996" translate="yes" xml:space="preserve">
          <source>Before you start, it's important to know a few things:</source>
          <target state="translated">Прежде чем вы начнете,важно кое-что узнать:</target>
        </trans-unit>
        <trans-unit id="85435e88ea012cea6ee5f0e38fd4d12329633e18" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory to which the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">Перед тем,как начать,необходимо просмотреть файл README,находящийся в каталоге верхнего уровня,в который был извлечен дистрибутив Perl.Убедитесь,что вы прочитали и поняли условия,на которых распространяется это программное обеспечение.</target>
        </trans-unit>
        <trans-unit id="82f236c12f0a7b2bfa05bcc6c77fce0d5554f74c" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory where the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">Перед тем,как начать,вы должны просмотреть файл README,находящийся в каталоге верхнего уровня,где был извлечен дистрибутив Perl.Убедитесь,что вы прочитали и поняли условия,на которых распространяется это программное обеспечение.</target>
        </trans-unit>
        <trans-unit id="e6dc5aa054869bdc5776548930fba90056a049b5" translate="yes" xml:space="preserve">
          <source>Begin the retrieval of a file called &lt;code&gt;FILE&lt;/code&gt; from the remote server.</source>
          <target state="translated">Начните получение файла с именем &lt;code&gt;FILE&lt;/code&gt; с удаленного сервера.</target>
        </trans-unit>
        <trans-unit id="d1bae729fa6ba19a84ae13329bfa79bbfaf77e9b" translate="yes" xml:space="preserve">
          <source>Beginner note: In example 2, above &lt;code&gt;$columns&lt;/code&gt; is imported into the local namespace, and set locally. In example 3, &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; is set in its own namespace without importing it.</source>
          <target state="translated">Примечание для новичков: в примере 2 указанные выше &lt;code&gt;$columns&lt;/code&gt; импортируются в локальное пространство имен и устанавливаются локально. В примере 3 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; устанавливается в собственном пространстве имен без его импорта.</target>
        </trans-unit>
        <trans-unit id="8c50d29cf088569a469311ef83bf39d51d30a011" translate="yes" xml:space="preserve">
          <source>Beginners often think they want to have a variable contain the name of a variable.</source>
          <target state="translated">Новичкам часто кажется,что они хотят,чтобы переменная содержала имя переменной.</target>
        </trans-unit>
        <trans-unit id="ddd5e0ea97f5ceda3171fdb3abe535bc421229c3" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.12, Perl accepts an ellipsis, &quot;&lt;code&gt;...&lt;/code&gt; &quot;, as a placeholder for code that you haven't implemented yet. This form of ellipsis, the unimplemented statement, should not be confused with the binary flip-flop &lt;code&gt;...&lt;/code&gt; operator. One is a statement and the other an operator. (Perl doesn't usually confuse them because usually Perl can tell whether it wants an operator or a statement, but see below for exceptions.)</source>
          <target state="translated">Начиная с Perl 5.12, Perl принимает многоточие &amp;laquo; &lt;code&gt;...&lt;/code&gt; &amp;raquo; в качестве заполнителя для кода, который вы еще не реализовали. Эту форму многоточия, нереализованного оператора, не следует путать с оператором двоичного триггера &lt;code&gt;...&lt;/code&gt; Один - это оператор, а другой - оператор. (Perl обычно не путает их, потому что обычно Perl может сказать, хочет ли он оператор или инструкцию, но см. Ниже исключения.)</target>
        </trans-unit>
        <trans-unit id="82d48c3b20d2f80bac7595523990a9132ad0e311" translate="yes" xml:space="preserve">
          <source>Beginning in v5.20.0, a postfix syntax for using references is available. It behaves as described in &lt;a href=&quot;#Using-References&quot;&gt;Using References&lt;/a&gt;, but instead of a prefixed sigil, a postfixed sigil-and-star is used.</source>
          <target state="translated">Начиная с v5.20.0, доступен постфиксный синтаксис для использования ссылок. Он ведет себя, как описано в &lt;a href=&quot;#Using-References&quot;&gt;разделе &amp;laquo;Использование ссылок&amp;raquo;&lt;/a&gt; , но вместо сигилы с префиксом используется сигил со звездочкой с префиксом.</target>
        </trans-unit>
        <trans-unit id="e4fd9d1748abdc28d0efb1f242a157236c1c9529" translate="yes" xml:space="preserve">
          <source>Beginning in v5.22.0, the referencing operator can be assigned to. It performs an aliasing operation, so that the variable name referenced on the left-hand side becomes an alias for the thing referenced on the right-hand side:</source>
          <target state="translated">Начиная с версии v5.22.0,можно назначить оператор ссылки.Он выполняет операцию наложения псевдонима,так что имя переменной,на которую делается ссылка с левой стороны,становится псевдонимом для вещи,на которую делается ссылка с правой стороны:</target>
        </trans-unit>
        <trans-unit id="54f7bcfa82e1deb0e3342e8510b04a376681f2a5" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX 11.00, programs compiled under HP-UX can take advantage of the LP64 programming environment (LP64 means Longs and Pointers are 64 bits wide), in which scalar variables will be able to hold numbers larger than 2^32 with complete precision. Perl has proven to be consistent and reliable in 64bit mode since 5.8.1 on all HP-UX 11.xx.</source>
          <target state="translated">Начиная с HP-UX 11.00,программы,скомпилированные под HP-UX,могут использовать преимущества среды программирования LP64 (LP64 означает Longs и Pointers шириной 64 бита),в которой скалярные переменные смогут с полной точностью удерживать числа,превышающие 2^32.Perl доказал свою последовательность и надежность в 64-битном режиме начиная с версии 5.8.1 на всех HP-UX 11.xx.</target>
        </trans-unit>
        <trans-unit id="7f252bceac885ebc51d1278ef820d426befd060f" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX version 10.20, files larger than 2GB (2^31 bytes) may be created and manipulated. Three separate methods of doing this are available. Of these methods, the best method for Perl is to compile using the -Duselargefiles flag to Configure. This causes Perl to be compiled using structures and functions in which these are 64 bits wide, rather than 32 bits wide. (Note that this will only work with HP's ANSI C compiler. If you want to compile Perl using gcc, you will have to get a version of the compiler that supports 64-bit operations. See above for where to find it.)</source>
          <target state="translated">Начиная с версии HP-UX 10.20,можно создавать файлы размером более 2 ГБ (2^31 байт)и манипулировать ими.Для этого доступны три отдельных метода.Из этих методов лучшим для Perl является компиляция с использованием флага -Duselargefiles to Configure.Это приводит к тому,что Perl компилируется с использованием структур и функций,в которых они имеют ширину 64 бита,а не 32 бита.(Заметим,что это будет работать только с ANSI C компилятором HP.Если вы хотите скомпилировать Perl,используя gcc,то вам потребуется версия компилятора,поддерживающая 64-битные операции.Смотрите выше,где его найти).</target>
        </trans-unit>
        <trans-unit id="7b1997a711dcb385772e62932a24b63be2ca5162" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.10.0, you can declare variables with the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword in place of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. For that to work, though, you must have enabled that feature beforehand, either by using the &lt;code&gt;feature&lt;/code&gt; pragma, or by using &lt;code&gt;-E&lt;/code&gt; on one-liners (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;). Beginning with Perl 5.16, the &lt;code&gt;CORE::state&lt;/code&gt; form does not require the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">Начиная с Perl 5.10.0, вы можете объявлять переменные с ключевым словом &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; вместо &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; . Однако для того, чтобы это работало, вы должны включить эту функцию заранее, либо с помощью прагмы &lt;code&gt;feature&lt;/code&gt; , либо с помощью &lt;code&gt;-E&lt;/code&gt; для однострочных строк (см. &lt;a href=&quot;feature&quot;&gt;Функцию&lt;/a&gt; ). Начиная с Perl 5.16, форма &lt;code&gt;CORE::state&lt;/code&gt; не требует прагмы &lt;code&gt;feature&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd848af5e7c989b28a26cc1aec55564025fc4af9" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.18, you can declare a private subroutine with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. As with state variables, the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword is only available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; or higher.</source>
          <target state="translated">Начиная с Perl 5.18, вы можете объявить частную подпрограмму с помощью &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; . Как и в случае с переменными &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; ключевое слово состояния доступно только при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; или при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; или выше.</target>
        </trans-unit>
        <trans-unit id="2eca9f03e4044bf99d10838840f25a5c4ae464b9" translate="yes" xml:space="preserve">
          <source>Beginning with perl 5.10.0, you can also use &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables to have lexicals that are initialized only once (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;):</source>
          <target state="translated">Начиная с Perl 5.10.0, вы можете также использовать &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; переменные имеют лексические, которые инициализируются только один раз (см &lt;a href=&quot;feature&quot;&gt;функции&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="d269396692530a4c995cb59a2555fae5ff4dd172" translate="yes" xml:space="preserve">
          <source>Beginning with version 5.004, the following functions are also supported:</source>
          <target state="translated">Начиная с версии 5.004,поддерживаются также следующие функции:</target>
        </trans-unit>
        <trans-unit id="34133685a790f2f2b5caab0cdf19417a300c4bef" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">В вашей системе действует аналогично wait (2): он ожидает завершения дочернего процесса и возвращает pid умершего процесса или &lt;code&gt;-1&lt;/code&gt; , если дочерних процессов нет. Статус возвращается в &lt;code&gt;$?&lt;/code&gt; и &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Обратите внимание, что возвращаемое значение &lt;code&gt;-1&lt;/code&gt; может означать, что дочерние процессы выполняются автоматически, как описано в &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f0c5491ce914759629c95815e914e921b25062e" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">В вашей системе действует аналогично wait (2): он ожидает завершения дочернего процесса и возвращает pid умершего процесса или &lt;code&gt;-1&lt;/code&gt; , если дочерних процессов нет. Статус возвращается в &lt;code&gt;$?&lt;/code&gt; и &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Обратите внимание, что возвращаемое значение &lt;code&gt;-1&lt;/code&gt; может означать, что дочерние процессы выполняются автоматически, как описано в &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0be599b479dc1a9d62fd33cd4b25ae6147cf1069" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">Ведет себя так же, как &lt;a href=&quot;#croak&quot;&gt;кваканье&lt;/a&gt; , за исключением возвращаемого типа. Его следует использовать только там, где требуется возвращаемый тип &lt;code&gt;OP *&lt;/code&gt; . Функция никогда не возвращается.</target>
        </trans-unit>
        <trans-unit id="4c49c08082a231774a342ac5391eebbc26cb4596" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">Ведет себя так же, как &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt; , за исключением возвращаемого типа. Его следует использовать только там, где требуется возвращаемый тип &lt;code&gt;OP *&lt;/code&gt; . Функция никогда не возвращается.</target>
        </trans-unit>
        <trans-unit id="fbf9c5863d4bbe3bd2490f1ad8ab93b461cdea43" translate="yes" xml:space="preserve">
          <source>Behavior of other Perl features in forked pseudo-processes</source>
          <target state="translated">Поведение других функций Perl в вилочных псевдо-процессах</target>
        </trans-unit>
        <trans-unit id="546fd299e317f0cfab072f158d53c6046d080ef9" translate="yes" xml:space="preserve">
          <source>Behavior of this function varies wildly depending on your system implementation. For example, it will usually not work across file system boundaries, even though the system</source>
          <target state="translated">Поведение этой функции сильно варьируется в зависимости от реализации вашей системы.Например,она обычно не будет работать через границы файловой системы,даже если система</target>
        </trans-unit>
        <trans-unit id="6296c0acaf0c68b8a708c260d5e620e45c188c21" translate="yes" xml:space="preserve">
          <source>Behaviour since version 2.11</source>
          <target state="translated">Поведение с версии 2.11</target>
        </trans-unit>
        <trans-unit id="fc99a03494d30ac32472278376507c26adfb39ce" translate="yes" xml:space="preserve">
          <source>Behind The Scenes</source>
          <target state="translated">За кулисами</target>
        </trans-unit>
        <trans-unit id="8e234f329fb33ee94403565f619b16d72bc67919" translate="yes" xml:space="preserve">
          <source>Behind the scenes the &lt;code&gt;globmap&lt;/code&gt; function does a combination of a file glob to match existing filenames followed by a substitute to create the new filenames.</source>
          <target state="translated">За кулисами функция &lt;code&gt;globmap&lt;/code&gt; выполняет комбинацию файла glob для сопоставления существующих имен файлов с последующей заменой для создания новых имен файлов.</target>
        </trans-unit>
        <trans-unit id="4f88b0aecf2344cf177fb22c2c1e4809d60f491d" translate="yes" xml:space="preserve">
          <source>Being Perl-specific, this function has evolved along time. It can currently be called as follow:</source>
          <target state="translated">Будучи перл-специфической,эта функция эволюционировала во времени.В настоящее время ее можно назвать следующим образом:</target>
        </trans-unit>
        <trans-unit id="0fc303a764ff6b60a94ad6969ea173a3382e1620" translate="yes" xml:space="preserve">
          <source>Being a mechanical process pl2pm is not bullet proof. The converted code will need careful checking, especially any package statements. Don't delete the original .pl file till the new .pm one works!</source>
          <target state="translated">Механический процесс pl2pm не является пуленепробиваемым.Преобразованный код нуждается в тщательной проверке,особенно это касается любых утверждений о пакетах.Не удаляйте оригинальный .pl файл до тех пор,пока не заработает новый .pm один!</target>
        </trans-unit>
        <trans-unit id="e98f301c8128b87a5492d5177997df433005bc22" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">Экономия файловых дескрипторов также полезна (помимо экономии), например, когда что-то зависит от файловых дескрипторов, например, блокировка с помощью flock (). Если вы просто &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , дескриптор файла A не будет иметь тот же дескриптор файла, что и B, и поэтому flock (A) не будет flock (B), и наоборот. Но с &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; дескрипторы файлов будут использовать один и тот же базовый файловый дескриптор.</target>
        </trans-unit>
        <trans-unit id="eb7d6ff0d012000fe6eccb3c989a4ceae1efb833" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">Экономия файловых дескрипторов также полезна (помимо экономии), например, когда что-то зависит от файловых дескрипторов, например, блокировка с помощью flock (). Если вы просто &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , дескриптор файла A не будет иметь тот же дескриптор файла, что и B, и поэтому flock (A) не будет flock (B), и наоборот. Но с &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; дескрипторы файлов будут использовать один и тот же базовый файловый дескриптор.</target>
        </trans-unit>
        <trans-unit id="1b8a9f965c18d647b7a7bff03b9e0c4a68361224" translate="yes" xml:space="preserve">
          <source>Bell sounds when word completion fails.</source>
          <target state="translated">Колокольчик звучит,когда слово заканчивается неудачно.</target>
        </trans-unit>
        <trans-unit id="74d2e1c77a10412bd2a923bb84c1c65e97a50e55" translate="yes" xml:space="preserve">
          <source>Below are a few examples of globmaps</source>
          <target state="translated">Ниже приведены несколько примеров глобусов.</target>
        </trans-unit>
        <trans-unit id="d6238547f660d516d0fdf40f8de1337807f2955e" translate="yes" xml:space="preserve">
          <source>Below is a</source>
          <target state="translated">Ниже приведена</target>
        </trans-unit>
        <trans-unit id="eab1a70d36b9d2b495b3781776947aeb4b2fc004" translate="yes" xml:space="preserve">
          <source>Below is a list of a few frameworks with comments which might help you in making a decision, depending on your specific requirements. Start by reading the docs, then ask questions on the relevant mailing list or IRC channel.</source>
          <target state="translated">Ниже приведен список нескольких фреймворков с комментариями,которые могут помочь вам в принятии решения в зависимости от ваших конкретных требований.Начните с чтения документации,затем задайте вопросы по соответствующему списку рассылки или IRC-каналу.</target>
        </trans-unit>
        <trans-unit id="1f47cec9db1010fb960d67042b7e30d1824cca4b" translate="yes" xml:space="preserve">
          <source>Below is a list of the files in the Unicode data base that Perl doesn't currently use, along with very brief descriptions of their purposes. Some of the names of the files have been shortened from those that Unicode uses, in order to allow them to be distinguishable from similarly named files on file systems for which only the first 8 characters of a name are significant.</source>
          <target state="translated">Ниже приведен список файлов в базе данных Unicode,которые Perl в настоящее время не использует,а также очень краткое описание их назначения.Некоторые из названий файлов были сокращены по сравнению с теми,что используются в Юникоде,чтобы их можно было отличить от одноименных файлов на файловых системах,для которых значимы только первые 8 символов названия.</target>
        </trans-unit>
        <trans-unit id="80905719173a37bfcc2cab267e8366cac44b82fa" translate="yes" xml:space="preserve">
          <source>Below is a list of the methods available.</source>
          <target state="translated">Ниже приведен список доступных методов.</target>
        </trans-unit>
        <trans-unit id="a5ddbb5a4ded78a58dd050a0a7bd8f09a53b44f8" translate="yes" xml:space="preserve">
          <source>Below is a list of the valid options:</source>
          <target state="translated">Ниже приведен список действительных вариантов:</target>
        </trans-unit>
        <trans-unit id="f51c6d51b727cf7e1f4d3849980abd064bedf568" translate="yes" xml:space="preserve">
          <source>Below is a mapping of what utilities will be used in what order for what schemes, if available:</source>
          <target state="translated">Ниже представлено отображение того,какие утилиты будут использоваться в каком порядке для каких схем,если таковые имеются:</target>
        </trans-unit>
        <trans-unit id="beba98866f16c9dd2863b4a3ebd6b7ee815c3c45" translate="yes" xml:space="preserve">
          <source>Below is a possible implementation of a script to carry out the rename (error cases have been omitted)</source>
          <target state="translated">Ниже приведена возможная реализация скрипта для выполнения переименования (случаи ошибок пропущены)</target>
        </trans-unit>
        <trans-unit id="58a01ebfbc11cd115ad51487cc4a5f70ba63da00" translate="yes" xml:space="preserve">
          <source>Below is a script which makes use of &lt;code&gt;gzreadline&lt;/code&gt; . It implements a very simple</source>
          <target state="translated">Ниже приведен сценарий, использующий &lt;code&gt;gzreadline&lt;/code&gt; . Он реализует очень простой</target>
        </trans-unit>
        <trans-unit id="7ffed42afdfaf25df4c7e5e8645b31ce92ca54e6" translate="yes" xml:space="preserve">
          <source>Below is a simple &quot;rename&quot; script that uses &lt;code&gt;globmap&lt;/code&gt; to determine the source and destination filenames.</source>
          <target state="translated">Ниже приведен простой сценарий &quot;переименования&quot;, который использует &lt;code&gt;globmap&lt;/code&gt; для определения имен файлов источника и назначения.</target>
        </trans-unit>
        <trans-unit id="1ec37797cdff4399757b58637d8bd54b7066dfec" translate="yes" xml:space="preserve">
          <source>Below is an example module that makes use of the macros.</source>
          <target state="translated">Ниже приведен пример модуля,использующего макросы.</target>
        </trans-unit>
        <trans-unit id="2be2899025a1fe4d200821c4ccbd79eabb3ab414" translate="yes" xml:space="preserve">
          <source>Below is an example program, &lt;code&gt;cpp_test&lt;/code&gt; , which makes use of this filter. Line numbers have been added to allow specific lines to be referenced easily.</source>
          <target state="translated">Ниже приведен пример программы &lt;code&gt;cpp_test&lt;/code&gt; , в которой используется этот фильтр. Номера строк были добавлены, чтобы можно было легко ссылаться на конкретные строки.</target>
        </trans-unit>
        <trans-unit id="4e2cc23005bf69f272f1f19d9851308543cafdff" translate="yes" xml:space="preserve">
          <source>Below is just one example, illustrating the control verb &lt;code&gt;(*FAIL)&lt;/code&gt; , which may be abbreviated as &lt;code&gt;(*F)&lt;/code&gt; . If this is inserted in a regexp it will cause it to fail, just as it would at some mismatch between the pattern and the string. Processing of the regexp continues as it would after any &quot;normal&quot; failure, so that, for instance, the next position in the string or another alternative will be tried. As failing to match doesn't preserve capture groups or produce results, it may be necessary to use this in combination with embedded code.</source>
          <target state="translated">Ниже приведен только один пример, иллюстрирующий глагол управления &lt;code&gt;(*FAIL)&lt;/code&gt; , который может быть сокращен как &lt;code&gt;(*F)&lt;/code&gt; . Если это будет вставлено в регулярное выражение, оно приведет к сбою, так же как это было бы при некотором несоответствии между шаблоном и строкой. Обработка регулярного выражения продолжается, как и после любого &amp;laquo;нормального&amp;raquo; сбоя, так что, например, будет проверена следующая позиция в строке или другая альтернатива. Поскольку несоответствие не сохраняет группы захвата и не дает результатов, может потребоваться использовать это в сочетании со встроенным кодом.</target>
        </trans-unit>
        <trans-unit id="994ae30ab39b91782977e3601a4b1c5958c55b6d" translate="yes" xml:space="preserve">
          <source>Below is the sample of what to do to reproduce the configuration on my machine. In</source>
          <target state="translated">Ниже приведен пример того,что нужно сделать,чтобы воспроизвести конфигурацию на моей машине.На сайте</target>
        </trans-unit>
        <trans-unit id="8d0833a6280a2357c9ec993c9c38bf06fc8a81e8" translate="yes" xml:space="preserve">
          <source>Below is typical code that shows how to use &lt;code&gt;LimitOutput&lt;/code&gt; .</source>
          <target state="translated">Ниже приведен типичный код, показывающий, как использовать &lt;code&gt;LimitOutput&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f28ac791ee08fb184476e4de12d634a0a1d7498" translate="yes" xml:space="preserve">
          <source>Ben Tilly</source>
          <target state="translated">Бен Тилли</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="9a552526ddac8fc37648130a16d1381a6f9ad6fb" translate="yes" xml:space="preserve">
          <source>Benchmark - benchmark running times of Perl code</source>
          <target state="translated">Эталон-эталон времени работы Perl-кода</target>
        </trans-unit>
        <trans-unit id="c6133998f601e0eb9b2fbe0a853d3f9116d43ce3" translate="yes" xml:space="preserve">
          <source>Benchmark Object</source>
          <target state="translated">объект тестирования</target>
        </trans-unit>
        <trans-unit id="0ff60c3e395ce6dcfa9869e330a91fa3d0e1a335" translate="yes" xml:space="preserve">
          <source>Benchmark inherits from no other class, except of course from Exporter.</source>
          <target state="translated">Бенчмарк наследуется ни от какого другого класса,кроме,конечно же,от Exporter.</target>
        </trans-unit>
        <trans-unit id="bf40ff62878fab85612abb7b1055df933f606399" translate="yes" xml:space="preserve">
          <source>Benchmark running times of Perl code</source>
          <target state="translated">Время выполнения кода Perl</target>
        </trans-unit>
        <trans-unit id="4b02607a2ea9a6953d07f941016201f155b468af" translate="yes" xml:space="preserve">
          <source>Benjamin Holzman contributed the tied variable support, Andrew Ford contributed the canonical order for hashes, and Gisle Aas fixed a few misunderstandings of mine regarding the perl internals, and optimized the emission of &quot;tags&quot; in the output streams by simply counting the objects instead of tagging them (leading to a binary incompatibility for the Storable image starting at version 0.6--older images are, of course, still properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann added overloading and references to tied items support. Benjamin Holzman added a performance improvement for overloaded classes; thanks to Grant Street Group for footing the bill.</source>
          <target state="translated">Бенджамин Хольцман (Benjamin Holzman)предоставил поддержку связанных переменных,Эндрю Форд (Andrew Ford)-канонический порядок для хэшей,а Жизель Аас (Gisle Aas)исправил несколько моих недоразумений относительно внутренних perl,а также оптимизировал излучение &quot;тегов&quot; в выходных потоках,просто считая объекты,а не тегируя их (что привело к бинарной несовместимости для образа Storable,начиная с версии 0.6-изображения держателя,конечно же,все еще правильно поняты).Мюррей Несбит (Murray Nesbitt)сделал Storable потокобезопасным.Марк Леманн добавил перегрузку и ссылки на поддержку связанных элементов.Бенджамин Хольцман добавил улучшение производительности для перегруженных классов;спасибо Grant Street Group за поддержку счета.</target>
        </trans-unit>
        <trans-unit id="75fc540bc0a50aa81831bc474ec860350d0bca6e" translate="yes" xml:space="preserve">
          <source>Berkeley DB allows the creation of in-memory databases by using NULL (that is, a &lt;code&gt;(char *)0&lt;/code&gt; in C) in place of the filename. &lt;b&gt;DB_File&lt;/b&gt; uses &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of NULL to provide this functionality.</source>
          <target state="translated">Berkeley DB позволяет создавать базы данных в памяти, используя NULL (то есть &lt;code&gt;(char *)0&lt;/code&gt; в C) вместо имени файла. &lt;b&gt;DB_File&lt;/b&gt; использует &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; вместо NULL для обеспечения этой функциональности.</target>
        </trans-unit>
        <trans-unit id="9268b246582cb1f8cd7166d3bdd75afc5afe74a7" translate="yes" xml:space="preserve">
          <source>Berkeley DB is a C library which provides a consistent interface to a number of database formats. &lt;b&gt;DB_File&lt;/b&gt; provides an interface to all three of the database types currently supported by Berkeley DB.</source>
          <target state="translated">Berkeley DB - это библиотека C, которая обеспечивает согласованный интерфейс для ряда форматов баз данных. &lt;b&gt;DB_File&lt;/b&gt; предоставляет интерфейс для всех трех типов баз данных, которые в настоящее время поддерживаются Berkeley DB.</target>
        </trans-unit>
        <trans-unit id="434964490ac8a77af87035de9e77b760d4b578ea" translate="yes" xml:space="preserve">
          <source>Berkeley DB uses the function dbopen() to open or create a database. Here is the C prototype for dbopen():</source>
          <target state="translated">БД Беркли использует функцию dbopen()для открытия или создания БД.Вот прототип функции dbopen()на языке C:</target>
        </trans-unit>
        <trans-unit id="cbcc04a4e53af70d968fb1854369b92c28068d53" translate="yes" xml:space="preserve">
          <source>BerkeleyDB is available for Cygwin.</source>
          <target state="translated">BerkeleyDB доступен для Cygwin.</target>
        </trans-unit>
        <trans-unit id="994ccae3d03329e5f7c9f11ecf6157dc38d89408" translate="yes" xml:space="preserve">
          <source>Beside import() and AUTOLOAD() there are only a few other methods.</source>
          <target state="translated">Кроме import()и AUTOLOAD()есть только несколько других методов.</target>
        </trans-unit>
        <trans-unit id="0cc3e4e79500c47fb5b02fd6bd36bb30830d4b93" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#decode&quot;&gt;decode&lt;/a&gt; and &lt;a href=&quot;#encode&quot;&gt;encode&lt;/a&gt;, other methods are available as well. For instance, &lt;code&gt;name()&lt;/code&gt; returns the canonical name of the encoding object.</source>
          <target state="translated">Помимо &lt;a href=&quot;#decode&quot;&gt;декодирования&lt;/a&gt; и &lt;a href=&quot;#encode&quot;&gt;кодирования&lt;/a&gt; , доступны и другие методы. Например, &lt;code&gt;name()&lt;/code&gt; возвращает каноническое имя объекта кодирования.</target>
        </trans-unit>
        <trans-unit id="a7e42697322af6c9745acd371b634a7d3de7f9ce" translate="yes" xml:space="preserve">
          <source>Besides checking existing XS code, the script can also be used to retrieve compatibility information for various API calls using the &lt;code&gt;--api-info&lt;/code&gt; command line switch. For example:</source>
          <target state="translated">Помимо проверки существующего кода XS, сценарий также можно использовать для получения информации о совместимости для различных вызовов API с помощью &lt;code&gt;--api-info&lt;/code&gt; командной строки --api-info . Например:</target>
        </trans-unit>
        <trans-unit id="38c540b359fe4177c8733f2554f7c8aac1cf7755" translate="yes" xml:space="preserve">
          <source>Besides many other tests, it will test every locale it finds on your system to see if they conform to the POSIX standard. If any have errors, it will include a summary near the end of the output of which locales passed all its tests, and which failed, and why.</source>
          <target state="translated">Кроме многих других тестов,он проверит каждую локаль,которую найдет на вашей системе,на соответствие стандарту POSIX.Если у кого-то из них есть ошибки,он включит в себя сводку,в конце вывода которой локали прошли все свои тесты,и какая из них провалилась,и почему.</target>
        </trans-unit>
        <trans-unit id="eaf1b9544c43d438f9e6f77acb1ab9f9247ce8b8" translate="yes" xml:space="preserve">
          <source>Besides putting the cross-compiler and the rest of the toolchain in your PATH, this will also provide the QNX_TARGET variable, which we will pass to Configure through -Dsysroot.</source>
          <target state="translated">Кроме помещения кросс-компилятора и остального инструментария в PATH,это также обеспечит переменную QNX_TARGET,которую мы передадим в команду Configure через -Dsysroot.</target>
        </trans-unit>
        <trans-unit id="8731a27dfb4cb7bb97f8e5e387722a8377af9b68" translate="yes" xml:space="preserve">
          <source>Besides saving these hashes as the hashref attributes &lt;code&gt;name2path&lt;/code&gt; and &lt;code&gt;path2name&lt;/code&gt; , calling this function also returns these hashrefs. In list context, the return value of &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; is the list &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; . In scalar context, the return value is &lt;code&gt;\%name2path&lt;/code&gt; . Or you can just call this in void context.</source>
          <target state="translated">Помимо сохранения этих хэшей в качестве атрибутов хэш-ссылки &lt;code&gt;name2path&lt;/code&gt; и &lt;code&gt;path2name&lt;/code&gt; , вызов этой функции также возвращает эти хеш-ссылки. В контексте списка возвращаемое значение &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; - это список &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; . В скалярном контексте возвращаемое значение - &lt;code&gt;\%name2path&lt;/code&gt; . Или вы можете просто назвать это в пустом контексте.</target>
        </trans-unit>
        <trans-unit id="d17cf41d34eb6f4b37b1b9cc872817585f3b1ca4" translate="yes" xml:space="preserve">
          <source>Besides the &lt;code&gt;$|&lt;/code&gt; special variable, you can use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to give your filehandle a &lt;code&gt;:unix&lt;/code&gt; layer, which is unbuffered:</source>
          <target state="translated">Помимо &lt;code&gt;$|&lt;/code&gt; специальной переменной, вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; , чтобы присвоить дескриптору файла слой &lt;code&gt;:unix&lt;/code&gt; , который не буферизуется:</target>
        </trans-unit>
        <trans-unit id="c874def12573a04b6982ff2c45bf57742f038615" translate="yes" xml:space="preserve">
          <source>Besides the NBSP character discussed above, implementors are reminded of the existence of the other &quot;special&quot; character in Latin-1, the &quot;soft hyphen&quot; character, also known as &quot;discretionary hyphen&quot;, i.e. &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ). This character expresses an optional hyphenation point. That is, it normally renders as nothing, but may render as a &quot;-&quot; if a formatter breaks the word at that point. Pod formatters should, as appropriate, do one of the following: 1) render this with a code with the same meaning (e.g., &quot;\-&quot; in RTF), 2) pass it through in the expectation that the formatter understands this character as such, or 3) delete it.</source>
          <target state="translated">Помимо описанного выше символа NBSP, разработчикам напоминается о существовании другого &amp;laquo;специального&amp;raquo; символа в Latin-1, символа &amp;laquo;мягкий дефис&amp;raquo;, также известного как &amp;laquo;дискреционный дефис&amp;raquo;, то есть &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ). Этот символ обозначает необязательную точку переноса. То есть обычно он отображается как ничего, но может отображаться как &quot;-&quot;, если средство форматирования прерывает слово в этой точке. Средства форматирования Pod должны, при необходимости, выполнить одно из следующих действий: 1) отобразить это с помощью кода с тем же значением (например, &quot;\ -&quot; в RTF), 2) передать его, ожидая, что средство форматирования понимает этот символ как такие, или 3) удалить.</target>
        </trans-unit>
        <trans-unit id="383f64e6a803d40e90542694df252e926486880e" translate="yes" xml:space="preserve">
          <source>Besides the normal array index looping, &lt;code&gt;for&lt;/code&gt; can lend itself to many other interesting applications. Here's one that avoids the problem you get into if you explicitly test for end-of-file on an interactive file descriptor causing your program to appear to hang.</source>
          <target state="translated">Помимо обычного зацикливания индекса массива, &lt;code&gt;for&lt;/code&gt; может использоваться во многих других интересных приложениях. Вот тот, который позволяет избежать проблемы, с которой вы столкнетесь, если вы явно протестируете конец файла в интерактивном файловом дескрипторе, из-за чего ваша программа будет зависать.</target>
        </trans-unit>
        <trans-unit id="b788aba9c107e5a4eaba0767ff3be57caf43c88d" translate="yes" xml:space="preserve">
          <source>Besides the obvious documents, source code can be instructive. Some pathological examples of the use of references can be found in the</source>
          <target state="translated">Кроме очевидных документов,исходный код может быть поучительным.Некоторые патологические примеры использования ссылок можно найти в разделе</target>
        </trans-unit>
        <trans-unit id="3cd8fe6552552b50530c70ff871d9df229c4d203" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man also takes care of formatting func(), func(3), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; makes C++ look right, puts a little space between double underscores, makes ALLCAPS a teeny bit smaller in &lt;b&gt;troff&lt;/b&gt;, and escapes stuff that *roff treats as special so that you don't have to.</source>
          <target state="translated">Помимо очевидных преобразований подов, Pod :: Man также заботится о форматировании func (), func (3) и простых ссылок на переменные, таких как $ foo или @bar, поэтому вам не нужно использовать для них экранирование кода; сложные выражения, такие как &lt;code&gt;$fred{'stuff'}&lt;/code&gt; все равно придется экранировать. Он также переводит тире, которые не используются в качестве дефисов, в короткие тире, превращает длинные тире - как это - в правильные длинные тире, исправляет &quot;парные кавычки&quot;, заставляет C ++ выглядеть правильно, помещает небольшой промежуток между двойными подчеркиваниями, делает ALLCAPS немного меньше в &lt;b&gt;troff&lt;/b&gt; и избегает вещей, которые * roff рассматривает как особые, так что вам не нужно.</target>
        </trans-unit>
        <trans-unit id="a063aa374e8d2e7cef3baa1877fd812efaeadbc4" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man, and therefore pod2man also takes care of formatting func(), func(n), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; and takes care of several other troff-specific tweaks. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for complete information.</source>
          <target state="translated">Помимо очевидных преобразований подов, Pod :: Man и, следовательно, pod2man также заботятся о форматировании func (), func (n) и простых ссылок на переменные, таких как $ foo или @bar, поэтому вам не нужно использовать для них экранирование кода. ; сложные выражения, такие как &lt;code&gt;$fred{'stuff'}&lt;/code&gt; все равно придется экранировать. Он также переводит тире, которые не используются в качестве дефисов, в короткие тире, превращает длинные тире - как это - в правильные длинные тире, исправляет &amp;laquo;парные кавычки&amp;raquo; и заботится о некоторых других настройках, связанных с troff. См. &lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt; для полной информации.</target>
        </trans-unit>
        <trans-unit id="2b7e5467e3e0ec9a6b2fff1ef3ee081c7b986017" translate="yes" xml:space="preserve">
          <source>Besides the well-known &quot;E&amp;lt;lt&amp;gt;&quot; and &quot;E&amp;lt;gt&amp;gt;&quot; codes for less-than and greater-than, Pod parsers must understand &quot;E&amp;lt;sol&amp;gt;&quot; for &quot;/&quot; (solidus, slash), and &quot;E&amp;lt;verbar&amp;gt;&quot; for &quot;|&quot; (vertical bar, pipe). Pod parsers should also understand &quot;E&amp;lt;lchevron&amp;gt;&quot; and &quot;E&amp;lt;rchevron&amp;gt;&quot; as legacy codes for characters 171 and 187, i.e., &quot;left-pointing double angle quotation mark&quot; = &quot;left pointing guillemet&quot; and &quot;right-pointing double angle quotation mark&quot; = &quot;right pointing guillemet&quot;. (These look like little &quot;&amp;lt;&amp;lt;&quot; and &quot;&amp;gt;&amp;gt;&quot;, and they are now preferably expressed with the HTML/XHTML codes &quot;E&amp;lt;laquo&amp;gt;&quot; and &quot;E&amp;lt;raquo&amp;gt;&quot;.)</source>
          <target state="translated">Помимо хорошо известных кодов &amp;laquo;E &amp;lt;lt&amp;gt;&amp;raquo; и &amp;laquo;E &amp;lt;gt&amp;gt;&amp;raquo; для значений &amp;laquo;меньше и больше&amp;raquo;, парсеры Pod должны понимать &amp;laquo;E &amp;lt;sol&amp;gt;&amp;raquo; для &amp;laquo;/&amp;raquo; (косая черта, косая черта) и &amp;laquo; E &amp;lt;verbar&amp;gt; &quot;для&quot; | &quot; (вертикальная полоса, труба). Парсеры Pod также должны понимать &quot;E &amp;lt;lchevron&amp;gt;&quot; и &quot;E &amp;lt;rchevron&amp;gt;&quot; как устаревшие коды для символов 171 и 187, т. Е. &quot;Двойная угловая кавычка, указывающая влево&quot; = &quot;гильмета, указывающая влево&quot; и &quot;двойная угловая кавычка, указывающая вправо&quot; угловая кавычка &quot;=&quot; игла, указывающая вправо &quot;. (Они выглядят как маленькие &amp;laquo;&amp;lt;&amp;lt;&amp;raquo; и &amp;laquo;&amp;gt;&amp;gt;&amp;raquo;, и теперь они предпочтительно выражаются кодами HTML / XHTML &amp;laquo;E &amp;lt;laquo&amp;gt;&amp;raquo; и &amp;laquo;E &amp;lt;raquo&amp;gt;&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="5b2158802b148a274c615dff49ad8ceaf2fe4a86" translate="yes" xml:space="preserve">
          <source>Besides these, all the Unicode character properties mentioned above (except for those marked as for internal use by Perl) are also accessible by &lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;prop_invlist() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Помимо этого, все свойства символов Юникода, упомянутые выше (за исключением тех, которые помечены как предназначенные для внутреннего использования Perl), также доступны через &lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;prop_invlist () в Unicode :: UCD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="708a3f784c168edb7cbbe1a181dbe5bffd40a3cc" translate="yes" xml:space="preserve">
          <source>Besides whole phrases meant for output, anything language-dependent should be put into the class Projname::L10N::en_us, whether as methods, or as lexicon entries -- this is discussed in the section &quot;Entries in Each Lexicon&quot;, above.</source>
          <target state="translated">Кроме целых фраз,предназначенных для вывода,в класс Projname::L10N::en_us должно быть помещено все,что зависит от языка,будь то методы или записи в лексиконе-это обсуждается в разделе &quot;Записи в каждом лексиконе&quot;,выше.</target>
        </trans-unit>
        <trans-unit id="cd7916b96afe381cf04fb2aeca341eed5cca3a69" translate="yes" xml:space="preserve">
          <source>Best practices for making a new module.</source>
          <target state="translated">Передовой опыт создания нового модуля.</target>
        </trans-unit>
        <trans-unit id="5f9760622e022594213ec306985fb05bd7325740" translate="yes" xml:space="preserve">
          <source>Between Mac OS X 10.3 &quot;Panther&quot; and 10.6 &quot;Snow Leopard&quot;, the 'Command Line Tools' bundle was called 'unix tools', and was usually supplied with Mac OS install DVDs.</source>
          <target state="translated">Между Mac OS X 10.3 &quot;Panther&quot; и 10.6 &quot;Snow Leopard&quot;,&quot;Command Line Tools&quot; набор назывался &quot;unix инструменты&quot;,и обычно поставлялся с установочными DVD-дисками Mac OS.</target>
        </trans-unit>
        <trans-unit id="6249e6fb239ee6aed11ccf460f154f4ff6f24738" translate="yes" xml:space="preserve">
          <source>Between the &lt;code&gt;%&lt;/code&gt; and the format letter, you may specify several additional attributes controlling the interpretation of the format. In order, these are:</source>
          <target state="translated">Между &lt;code&gt;%&lt;/code&gt; и буквой формата вы можете указать несколько дополнительных атрибутов, управляющих интерпретацией формата. По порядку это:</target>
        </trans-unit>
        <trans-unit id="b8011f36b2088bc97398915695cf8abfb01b5b1d" translate="yes" xml:space="preserve">
          <source>Beware also of the order of more complicated expressions like:</source>
          <target state="translated">Остерегайтесь также порядка более сложных выражений типа:</target>
        </trans-unit>
        <trans-unit id="6c100dc724a3253ddc31a97cdb43e9fdb264b604" translate="yes" xml:space="preserve">
          <source>Beware of simple &quot;casting&quot; the entire expression, this would only convert the already computed result:</source>
          <target state="translated">Остерегайтесь простого &quot;кастинга&quot; всего выражения,это приведет только к преобразованию уже вычисленного результата:</target>
        </trans-unit>
        <trans-unit id="c8bc77265aea976e7b646f3af43c05662f7e17da" translate="yes" xml:space="preserve">
          <source>Beware of:</source>
          <target state="translated">Остерегайся:</target>
        </trans-unit>
        <trans-unit id="6bac55531c21ad380bc95de89addf1faea92b643" translate="yes" xml:space="preserve">
          <source>Beware that if you put literal backslashes (those not inside interpolated variables) between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; , double-quotish backslash interpolation may lead to confusing results. If you</source>
          <target state="translated">Помните, что если вы поместите буквальную обратную косую черту (те, которые не находятся внутри интерполированных переменных) между &lt;code&gt;\Q&lt;/code&gt; и &lt;code&gt;\E&lt;/code&gt; , интерполяция обратной косой черты в двойных кавычках может привести к запутанным результатам. если ты</target>
        </trans-unit>
        <trans-unit id="6ca66f864461fdc36869edeb4abd6935993616b0" translate="yes" xml:space="preserve">
          <source>Beware that some command shells may place restrictions on the length of the command line. You must ensure your strings don't exceed this limit after any necessary interpolations. See the platform-specific release notes for more details about your particular environment.</source>
          <target state="translated">Остерегайтесь,что некоторые командные оболочки могут накладывать ограничения на длину командной строки.Вы должны убедиться,что ваши строки не превышают этот предел после любых необходимых интерполяций.Более подробную информацию о вашей конкретной среде см.в примечаниях к версии для конкретной платформы.</target>
        </trans-unit>
        <trans-unit id="1bd1204f447158c3ff1bfbe82d9a707a81d4fa56" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;#split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">Помните, что, в отличие от &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; не принимает шаблон в качестве первого аргумента. Сравните &lt;a href=&quot;#split&quot;&gt;сплит&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc2144e8f71ac4bf9140995eea7dc924e6bdda59" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">Помните, что, в отличие от &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; не принимает шаблон в качестве первого аргумента. Сравните &lt;a href=&quot;split&quot;&gt;сплит&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c39aa460c8cfb8c3295132732d48ee06e763b200" translate="yes" xml:space="preserve">
          <source>Beware: This feature is not fully implemented yet.</source>
          <target state="translated">Берегись:Эта функция еще не полностью реализована.</target>
        </trans-unit>
        <trans-unit id="d3f2ff6e4b3a254c248f8c186f3f0868a1b1e7b1" translate="yes" xml:space="preserve">
          <source>Beware: This list is not complete.</source>
          <target state="translated">Берегись:Этот список не полный.</target>
        </trans-unit>
        <trans-unit id="85c248dc6ba19bfc8397a2d612c997c46ad24985" translate="yes" xml:space="preserve">
          <source>Beware: after this function returns, &lt;code&gt;ptr&lt;/code&gt; and SvPVX_const(sv) may no longer refer to the same chunk of data.</source>
          <target state="translated">Осторожно: после возврата из этой функции &lt;code&gt;ptr&lt;/code&gt; и SvPVX_const (sv) больше не могут ссылаться на один и тот же фрагмент данных.</target>
        </trans-unit>
        <trans-unit id="40ca4e03748bbc6d9d8fdf7c985dd464c29b4a02" translate="yes" xml:space="preserve">
          <source>Beyond Unicode code points</source>
          <target state="translated">За пределами точек кода Юникода</target>
        </trans-unit>
        <trans-unit id="8d2086dee2d46aa5a491374a05ac5325e10530d7" translate="yes" xml:space="preserve">
          <source>Beyond make test</source>
          <target state="translated">Beyond make test</target>
        </trans-unit>
        <trans-unit id="7071855c582934ec0ec68ba51cead15591289a64" translate="yes" xml:space="preserve">
          <source>Beyond that help, the urllist config parameter is yours. You can add and remove sites at will. You should find out which sites have the best up-to-dateness, bandwidth, reliability, etc. and are topologically close to you. Some people prefer fast downloads, others up-to-dateness, others reliability. You decide which to try in which order.</source>
          <target state="translated">Помимо этой справки,параметр urllist config-ваш.Вы можете добавлять и удалять сайты по своему усмотрению.Вы должны выяснить,какие сайты имеют наибольшую актуальность,пропускную способность,надежность и т.д.и находятся в топологической близости к вам.Некоторые люди предпочитают быструю загрузку,другие-актуальность,третьи-надежность.Вы решаете,что попробовать в каком порядке.</target>
        </trans-unit>
        <trans-unit id="3f05839b089d755d215e2ff3af4aafe1ec68679d" translate="yes" xml:space="preserve">
          <source>Beyond that, the simplest debugger is the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function. Use it to look at values as you run your program:</source>
          <target state="translated">Кроме того, самый простой отладчик - это функция &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; . Используйте его для просмотра значений при запуске вашей программы:</target>
        </trans-unit>
        <trans-unit id="3981fa65dd4a5a67077c84cbcab0e6d7e62ef4b1" translate="yes" xml:space="preserve">
          <source>Beyond that, you have to consider several things and decide which is best for you.</source>
          <target state="translated">Кроме того,вы должны рассмотреть несколько вещей и решить,что лучше для вас.</target>
        </trans-unit>
        <trans-unit id="44d69eda49b459248ce90b6917e4f918be54d8d4" translate="yes" xml:space="preserve">
          <source>Beyond the normal measures described to make general Perl programs faster or smaller, a CGI program has additional issues. It may be run several times per second. Given that each time it runs it will need to be re-compiled and will often allocate a megabyte or more of system memory, this can be a killer. Compiling into C &lt;b&gt;isn't going to help you&lt;/b&gt; because the process start-up overhead is where the bottleneck is.</source>
          <target state="translated">Помимо обычных мер, описанных для ускорения или уменьшения размеров обычных Perl-программ, у CGI-программы есть дополнительные проблемы. Он может запускаться несколько раз в секунду. Учитывая, что каждый раз, когда он запускается, его нужно будет перекомпилировать и часто будет выделять мегабайт или больше системной памяти, это может быть убийственным. Компиляция в C вам &lt;b&gt;не поможет,&lt;/b&gt; потому что узкое место - это накладные расходы на запуск процесса.</target>
        </trans-unit>
        <trans-unit id="213d672c8ec1c5c132adb8f810eb6a5d6ae1c84f" translate="yes" xml:space="preserve">
          <source>Beyond the obvious problems that stem from giving special privileges to systems as flexible as scripts, on many versions of Unix, set-id scripts are inherently insecure right from the start. The problem is a race condition in the kernel. Between the time the kernel opens the file to see which interpreter to run and when the (now-set-id) interpreter turns around and reopens the file to interpret it, the file in question may have changed, especially if you have symbolic links on your system.</source>
          <target state="translated">Помимо очевидных проблем,связанных с предоставлением специальных привилегий таким гибким системам,как скрипты,во многих версиях Unix скрипты set-id изначально небезопасны.Проблема заключается в состоянии гонки в ядре.Между тем,как ядро открывает файл,чтобы увидеть,какой интерпретатор нужно запустить,и когда интерпретатор (now-set-id)разворачивается и заново открывает файл,чтобы интерпретировать его,файл,о котором идет речь,мог измениться,особенно если у вас в системе есть символические ссылки.</target>
        </trans-unit>
        <trans-unit id="619d65e1ae1a2704aa306451ac2a75a0cde345a8" translate="yes" xml:space="preserve">
          <source>Bibliography</source>
          <target state="translated">Bibliography</target>
        </trans-unit>
        <trans-unit id="b4412d2ae1aa691608b316e9ad2227f4c8f05c5f" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Another Process</source>
          <target state="translated">Двунаправленная связь с другим процессом</target>
        </trans-unit>
        <trans-unit id="20453df9f611f7ce81199fe2171f3b15f7db6ba1" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Yourself</source>
          <target state="translated">Двунаправленная связь с самим собой</target>
        </trans-unit>
        <trans-unit id="aaec1a206ed8540735d6653165ead4690d690a5c" translate="yes" xml:space="preserve">
          <source>BigInt's bcmp() routine currently returns undef to signal that a NaN was involved in a comparison. However, the overload code turns that into either 1 or '' and thus operations like &lt;code&gt;NaN != NaN&lt;/code&gt; might return wrong values.</source>
          <target state="translated">Подпрограмма bcmp () BigInt в настоящее время возвращает undef, чтобы сигнализировать о том, что в сравнении участвовало NaN. Однако код перегрузки превращает это значение в 1 или '', и поэтому такие операции, как &lt;code&gt;NaN != NaN&lt;/code&gt; могут возвращать неправильные значения.</target>
        </trans-unit>
        <trans-unit id="b68a65a4af953b7e6ff32f4e519ad10e0c7af47b" translate="yes" xml:space="preserve">
          <source>Bigger Numbers</source>
          <target state="translated">Большие Числа</target>
        </trans-unit>
        <trans-unit id="98032da695f3e799620752e98882e414e0196f49" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!=&quot;&lt;/code&gt; returns true if the left argument is numerically not equal to the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;!=&quot;&lt;/code&gt; Возвращает истину, если левый аргумент численно не равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="0806ad998452d5851f139bbe3f01d7066c39cefd" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; is just like &lt;code&gt;&quot;=~&quot;&lt;/code&gt; except the return value is negated in the logical sense.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;!~&quot;&lt;/code&gt; Аналогичен &lt;code&gt;&quot;=~&quot;&lt;/code&gt; за исключением того, что возвращаемое значение инвертируется в логическом смысле.</target>
        </trans-unit>
        <trans-unit id="958b8a1169468f4a63917c7ca8496d2c631c8da0" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; with a non-destructive substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;) or transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt;) is a syntax error.</source>
          <target state="translated">Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; С неразрушающим замещения ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; ) или транслитерации ( &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt; ) является синтаксической ошибкой.</target>
        </trans-unit>
        <trans-unit id="f26c16627064dbaf94b2accf763da8c7ea571aa3" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;%&quot;&lt;/code&gt; is the modulo operator, which computes the division remainder of its first argument with respect to its second argument. Given integer operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; : If &lt;code&gt;$n&lt;/code&gt; is positive, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the largest multiple of &lt;code&gt;$n&lt;/code&gt; less than or equal to &lt;code&gt;$m&lt;/code&gt; . If &lt;code&gt;$n&lt;/code&gt; is negative, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the smallest multiple of &lt;code&gt;$n&lt;/code&gt; that is not less than &lt;code&gt;$m&lt;/code&gt; (that is, the result will be less than or equal to zero). If the operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; are floating point values and the absolute value of &lt;code&gt;$n&lt;/code&gt; (that is &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is less than &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , only the integer portion of &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; will be used in the operation (Note: here &lt;code&gt;UV_MAX&lt;/code&gt; means the maximum of the unsigned integer type). If the absolute value of the right operand (&lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is greater than or equal to &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; computes the floating-point remainder &lt;code&gt;$r&lt;/code&gt; in the equation &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; where &lt;code&gt;$i&lt;/code&gt; is a certain integer that makes &lt;code&gt;$r&lt;/code&gt; have the same sign as the right operand &lt;code&gt;$n&lt;/code&gt; (&lt;b&gt;not&lt;/b&gt; as the left operand &lt;code&gt;$m&lt;/code&gt; like C function &lt;code&gt;fmod()&lt;/code&gt; ) and the absolute value less than that of &lt;code&gt;$n&lt;/code&gt; . Note that when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; is in scope, &lt;code&gt;&quot;%&quot;&lt;/code&gt; gives you direct access to the modulo operator as implemented by your C compiler. This operator is not as well defined for negative operands, but it will execute faster.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;%&quot;&lt;/code&gt; - это оператор по модулю, который вычисляет остаток от деления первого аргумента относительно второго аргумента. Для целочисленных операндов &lt;code&gt;$m&lt;/code&gt; и &lt;code&gt;$n&lt;/code&gt; : если &lt;code&gt;$n&lt;/code&gt; положительно, то &lt;code&gt;$m % $n&lt;/code&gt; равно &lt;code&gt;$m&lt;/code&gt; минус наибольшее кратное для &lt;code&gt;$n&lt;/code&gt; меньшее или равное &lt;code&gt;$m&lt;/code&gt; . Если &lt;code&gt;$n&lt;/code&gt; отрицательно, тогда &lt;code&gt;$m % $n&lt;/code&gt; равно &lt;code&gt;$m&lt;/code&gt; минус наименьшее кратное &lt;code&gt;$n&lt;/code&gt; , которое не меньше &lt;code&gt;$m&lt;/code&gt; (то есть результат будет меньше или равен нулю). Если операнды &lt;code&gt;$m&lt;/code&gt; и &lt;code&gt;$n&lt;/code&gt; являются значениями с плавающей запятой, а абсолютное значение &lt;code&gt;$n&lt;/code&gt; (то есть &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; ) меньше &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , в операции будет использоваться только целая часть &lt;code&gt;$m&lt;/code&gt; и &lt;code&gt;$n&lt;/code&gt; (Примечание: здесь &lt;code&gt;UV_MAX&lt;/code&gt; означает максимум целого типа без знака). Если абсолютное значение правого операнда ( &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; ) больше или равно &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; вычисляет остаток &lt;code&gt;$r&lt;/code&gt; с плавающей запятой в уравнении &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; где &lt;code&gt;$i&lt;/code&gt; - некоторое целое число, при котором &lt;code&gt;$r&lt;/code&gt; имеет тот же знак, что и правый операнд &lt;code&gt;$n&lt;/code&gt; ( &lt;b&gt;не&lt;/b&gt; как левый операнд &lt;code&gt;$m&lt;/code&gt; как функция C &lt;code&gt;fmod()&lt;/code&gt; ) и абсолютное значение меньше, чем у &lt;code&gt;$n&lt;/code&gt; . Обратите внимание, что когда в области видимости &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; дает вам прямой доступ к оператору по модулю, реализованному вашим компилятором C. Этот оператор не так хорошо определен для отрицательных операндов, но он будет выполняться быстрее.</target>
        </trans-unit>
        <trans-unit id="68ed9e30d3d6543dd0a9f75b291cbc79357b65a9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; returns its operands ANDed together bit by bit. Although no warning is currently raised, the result is not well defined when this operation is performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; возвращает свои операнды, соединенные вместе бит за битом. Хотя в настоящее время не возникает никаких предупреждений, результат не определен должным образом, когда эта операция выполняется с операндами, которые не являются ни числами (см. &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Целочисленную арифметику&lt;/a&gt; ), ни битовыми строками (см. &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Побитовые строковые операторы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c0937405123294a033856c6fea7344af89470f86" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; performs a short-circuit logical AND operation. That is, if the left operand is false, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; выполняет короткое замыкание логической операции И. То есть, если левый операнд ложен, правый операнд даже не оценивается. Скалярный контекст или контекст списка распространяется вниз до правого операнда, если он вычислен.</target>
        </trans-unit>
        <trans-unit id="1f3f00bc4d3f1107e73b1aeb90803d21d2f7f5a5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; returns true if the left argument is numerically greater than the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; возвращает истину, если левый аргумент численно больше правого аргумента.</target>
        </trans-unit>
        <trans-unit id="6a8e5f64ce960724d668657e4a1ad5261d933577" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; returns the value of its left argument shifted right by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; возвращает значение своего левого аргумента, сдвинутое вправо на количество битов, заданное правым аргументом. Аргументы должны быть целыми числами. (См. Также &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Целочисленную арифметику&lt;/a&gt; .)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
