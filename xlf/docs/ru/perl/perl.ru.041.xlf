<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d7a3ea6043299cfce500bdda50fb23f6cbea5c5c" translate="yes" xml:space="preserve">
          <source>Initialize MAKE from either a MAKE environment variable or $Config{make}.</source>
          <target state="translated">Инициализируйте MAKE либо из переменной окружения MAKE,либо из $Config{make}.</target>
        </trans-unit>
        <trans-unit id="8a7c7a1b384ad47d60773edd82ad26376d621207" translate="yes" xml:space="preserve">
          <source>Initialize any macros which are for platform specific use only.</source>
          <target state="translated">Инициализируйте любые макросы,которые предназначены только для платформы.</target>
        </trans-unit>
        <trans-unit id="4476040d6adc770412cdb2150cb39c32735c92d5" translate="yes" xml:space="preserve">
          <source>Initialize macros representing versions of MakeMaker and other tools</source>
          <target state="translated">Инициализируйте макросы,представляющие версии MakeMaker и другие инструменты.</target>
        </trans-unit>
        <trans-unit id="fa2a269c8bcaa8f7394ce2454e1f32bd30c51822" translate="yes" xml:space="preserve">
          <source>Initialize macros which have to do with linking.</source>
          <target state="translated">Инициализируйте макросы,которые имеют отношение к связыванию.</target>
        </trans-unit>
        <trans-unit id="cf8b76ad5759b00cf83505f7cf706fcbd53a36ab" translate="yes" xml:space="preserve">
          <source>Initialize the SigSet object to be empty.</source>
          <target state="translated">Инициализируйте объект SigSet как пустой.</target>
        </trans-unit>
        <trans-unit id="553a04fdd695ae3cee805a386f6c72d5ee7c6e5d" translate="yes" xml:space="preserve">
          <source>Initialize the SigSet object to include all signals.</source>
          <target state="translated">Инициализируйте объект SigSet для включения всех сигналов.</target>
        </trans-unit>
        <trans-unit id="7ff28902a2edd7a86041272b550eea681cfd2a0b" translate="yes" xml:space="preserve">
          <source>Initializes AR, AR_STATIC_ARGS, BASEEXT, CONFIG, DISTNAME, DLBASE, EXE_EXT, FULLEXT, FULLPERL, FULLPERLRUN, FULLPERLRUNINST, INST_*, INSTALL*, INSTALLDIRS, LIB_EXT, LIBPERL_A, MAP_TARGET, NAME, OBJ_EXT, PARENT_NAME, PERL, PERL_ARCHLIB, PERL_INC, PERL_LIB, PERL_SRC, PERLRUN, PERLRUNINST, PREFIX, VERSION, VERSION_SYM, XS_VERSION.</source>
          <target state="translated">Инициализирует AR,AR_STATIC_ARGS,BASEEXT,CONFIG,DISTNAME,DLBASE,EXE_EXT,FULLEXT,FULLPERL,FULLPERLRUN,FULLPERLRUNINST,INST_*,INSTALL*,INSTALLDIRS,LIB_EXT,LIBPERL_A,MAP_TARGET,ИМЯ,OBJ_EXT,PARENT_NAME,PERL,PERL_ARCHLIB,PERL_INC,PERL_LIB,PERL_SRC,PERLRUN,PERLRUNINST,ПРЕФИКС,ВЕРСИЯ,VERSION_SYM,XS_VERSION.</target>
        </trans-unit>
        <trans-unit id="9b0af4794c1652a453537aa4d31bc51217044cfb" translate="yes" xml:space="preserve">
          <source>Initializes MAN1PODS from the list of EXE_FILES.</source>
          <target state="translated">Инициализирует MAN1PODS из списка EXE_FILES.</target>
        </trans-unit>
        <trans-unit id="9908a02e0ec97a9887147642e25f6d00ba2bba87" translate="yes" xml:space="preserve">
          <source>Initializes MAN3PODS from the list of PM files.</source>
          <target state="translated">Инициализирует MAN3PODS из списка файлов PM.</target>
        </trans-unit>
        <trans-unit id="78aa0c8b31d0aa9e4f082b472e25049793a28d4c" translate="yes" xml:space="preserve">
          <source>Initializes PMLIBDIRS and PM from PMLIBDIRS.</source>
          <target state="translated">Инициализирует PMLIBDIRS и PM из PMLIBDIRS.</target>
        </trans-unit>
        <trans-unit id="f52193e05865340eb9150e274aa92320b071b3c6" translate="yes" xml:space="preserve">
          <source>Initializes a new Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">Инициализирует новый интерпретатор Perl. См. &lt;a href=&quot;perlembed&quot;&gt;Perlembed&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d157e4855cf1cd1f0584d861b76b87bbd1430bbd" translate="yes" xml:space="preserve">
          <source>Initializes a new object. This method is a stub by default, you should override it as appropriate.</source>
          <target state="translated">Инициализирует новый объект.По умолчанию этот метод является заглушкой,его следует переопределить соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="9cf6c0c33242d2abf005967a6623b3ae8501f304" translate="yes" xml:space="preserve">
          <source>Initializes the DIRFILESEP macro which is the separator between the directory and filename in a filepath. ie. / on Unix, \ on Win32 and nothing on VMS.</source>
          <target state="translated">Инициализирует макрос DIRFILESEP,который является разделителем между каталогом и именем файла в файловом пути.т.е./на Unix,\ на Win32 и ничего на VMS.</target>
        </trans-unit>
        <trans-unit id="1f6be944d9e52d97024d9034508b4cacc682c441" translate="yes" xml:space="preserve">
          <source>Initializes the macro definitions having to do with compiling and linking used by tools_other() and places them in the $MM object.</source>
          <target state="translated">Инициализирует макроопределения,связанные с компиляцией и линковкой,используемые функцией tools_other(),и помещает их в объект $MM.</target>
        </trans-unit>
        <trans-unit id="e775d4b4b0bd3712f9f514299a1d05c1a00cf523" translate="yes" xml:space="preserve">
          <source>Initializes the simple macro definitions used by tools_other() and places them in the $MM object. These use conservative cross platform versions and should be overridden with platform specific versions for performance.</source>
          <target state="translated">Инициализирует простые макроопределения,используемые функцией tools_other()и помещает их в объект $MM.Они используют консервативные кроссплатформенные версии и должны быть переопределены для производительности специфическими для платформы версиями.</target>
        </trans-unit>
        <trans-unit id="282f9af1f24130bc9182b79671b3debcbe420b2a" translate="yes" xml:space="preserve">
          <source>Initializes tools to use their common (and faster) Unix commands.</source>
          <target state="translated">Инициализирует инструменты для использования их общих (и более быстрых)Unix-команд.</target>
        </trans-unit>
        <trans-unit id="7a196e34c731e5f3af1e31be4705513bd9e1800a" translate="yes" xml:space="preserve">
          <source>Initializing Function Parameters</source>
          <target state="translated">Параметры инициализирующей функции</target>
        </trans-unit>
        <trans-unit id="f762e2df9b5c50638aa3c3cbbaf63d08b1a096ce" translate="yes" xml:space="preserve">
          <source>Initializing with &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">Инициализация с &lt;code&gt;new&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5374c9bb7d82a306aff38df30638934a3bedb34d" translate="yes" xml:space="preserve">
          <source>Initializing with new</source>
          <target state="translated">Инициализация с новым</target>
        </trans-unit>
        <trans-unit id="16e4c7e9d2fa46d1492e494337cfb9b14642fd7d" translate="yes" xml:space="preserve">
          <source>Initiate the sending of the data from the current message.</source>
          <target state="translated">Инициировать отправку данных из текущего сообщения.</target>
        </trans-unit>
        <trans-unit id="b6b3360634a6df83161df89335cce0e40b6cc3dd" translate="yes" xml:space="preserve">
          <source>Initiates a TCP connection, for a tcp ping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe9280fcef1f95066c459792b601f0a568c68ff3" translate="yes" xml:space="preserve">
          <source>Inplace editing &lt;code&gt;perl -i&lt;/code&gt; of files doesn't work without doing a backup of the file being edited &lt;code&gt;perl -i.bak&lt;/code&gt; because of windowish restrictions, therefore Perl adds the suffix &lt;code&gt;.bak&lt;/code&gt; automatically if you use &lt;code&gt;perl -i&lt;/code&gt; without specifying a backup extension.</source>
          <target state="translated">Редактирование на месте &lt;code&gt;perl -i&lt;/code&gt; файлов не работает без создания резервной копии редактируемого файла &lt;code&gt;perl -i.bak&lt;/code&gt; из-за оконных ограничений, поэтому Perl автоматически добавляет суффикс &lt;code&gt;.bak&lt;/code&gt; , если вы используете &lt;code&gt;perl -i&lt;/code&gt; без указания расширения резервной копии.</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="f2166976e1182028cf4a602c00df0206990e4b61" translate="yes" xml:space="preserve">
          <source>Input File Glob</source>
          <target state="translated">Входной файл Глобус</target>
        </trans-unit>
        <trans-unit id="b6852c995fba635b92f942abb161a06e4a4f682b" translate="yes" xml:space="preserve">
          <source>Input and Output Layers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc35a576a410b10bc60ae6d2130c68130a12559" translate="yes" xml:space="preserve">
          <source>Input and Output Parameters</source>
          <target state="translated">Входные и выходные параметры</target>
        </trans-unit>
        <trans-unit id="c77783bb0c7d4d2f9b2b8bd6478b069981c0866f" translate="yes" xml:space="preserve">
          <source>Input and output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d4856593d1efd1c0cd8430882cae3851f3f706" translate="yes" xml:space="preserve">
          <source>Input and output functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca6ebb3af2e2ddf731c9ba341152d5ee6d08083" translate="yes" xml:space="preserve">
          <source>Input and output pipes to Perl filehandles are supported; the &quot;file name&quot; is passed to lib$spawn() for asynchronous execution. You should be careful to close any pipes you have opened in a Perl script, lest you leave any &quot;orphaned&quot; subprocesses around when Perl exits.</source>
          <target state="translated">Поддерживаются входные и выходные каналы к файловым дескрипторам Perl;&quot;имя файла&quot; передается в lib$spawn()для асинхронного выполнения.Вы должны быть осторожны,чтобы закрыть все каналы,которые вы открыли в Perl скрипте,чтобы не оставить вокруг себя &quot;осиротевших&quot; подпроцессов при выходе из Perl.</target>
        </trans-unit>
        <trans-unit id="25e7b83bd15298faf6fd8f002de9128fb08ea38f" translate="yes" xml:space="preserve">
          <source>Input from, or output to, a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;device&lt;/b&gt;.</source>
          <target state="translated">Ввод или вывод в &lt;b&gt;файл&lt;/b&gt; или &lt;b&gt;устройство&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="78a923bcd93c4171316cc3a1bc09d0aa6f07ef83" translate="yes" xml:space="preserve">
          <source>Input given as scalar numbers might lose precision. Quote your input to ensure that no digits are lost:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6047072eebf842c882d2d1ca55ea7667206a889" translate="yes" xml:space="preserve">
          <source>Input library and path specifications are accepted with or without the &lt;code&gt;-l&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; prefixes used by Unix linkers.</source>
          <target state="translated">Входная библиотека и спецификации пути принимаются с префиксами &lt;code&gt;-l&lt;/code&gt; и &lt;code&gt;-L&lt;/code&gt; , используемыми компоновщиками Unix, или без них .</target>
        </trans-unit>
        <trans-unit id="db35c0f2c45290c19fd136029a213ad284b80e55" translate="yes" xml:space="preserve">
          <source>Input library and path specifications are accepted with or without the &lt;code&gt;-l&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; prefixes used by Unix linkers. If neither prefix is present, a token is considered a directory to search if it is in fact a directory, and a library to search for otherwise. Authors who wish their extensions to be portable to Unix or OS/2 should use the Unix prefixes, since the Unix-OS/2 version of ext() requires them.</source>
          <target state="translated">Входная библиотека и спецификации пути принимаются с префиксами &lt;code&gt;-l&lt;/code&gt; и &lt;code&gt;-L&lt;/code&gt; , используемыми компоновщиками Unix, или без них . Если ни один из префиксов не указан, токен считается каталогом для поиска, если это на самом деле каталог, и библиотекой для поиска в противном случае. Авторы, которые хотят, чтобы их расширения были переносимы в Unix или OS / 2, должны использовать префиксы Unix, поскольку они требуются для версии ext () для Unix-OS / 2.</target>
        </trans-unit>
        <trans-unit id="a1f8b7d0598aac2b8e4ba4b9244e4a933dc9e6b4" translate="yes" xml:space="preserve">
          <source>Input strings are decode()d then encode()d. A straight two-step implementation.</source>
          <target state="translated">Входные строки декодируются с помощью функции decode()d,а затем с помощью функции encode()d.Прямая двухступенчатая реализация.</target>
        </trans-unit>
        <trans-unit id="ff3057c52ba4da6e1ddf88eb538e9f34e59f7ee9" translate="yes" xml:space="preserve">
          <source>Input to these routines are either BigFloat objects, or strings of the following four forms:</source>
          <target state="translated">Входными данными для этих процедур являются либо объекты BigFloat,либо строки следующих четырех форм:</target>
        </trans-unit>
        <trans-unit id="84961be9b7c2809d89e0848f01fd0ffc9df02327" translate="yes" xml:space="preserve">
          <source>Input values to these routines may be any scalar number or string that looks like a number and represents a floating point number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2156929b7310422c8528b3fc6dfc3918a5f73f99" translate="yes" xml:space="preserve">
          <source>Input values to these routines may be any scalar number or string that looks like a number and represents an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0281be753361164d1d0fc4c9f4d612cf39dd2d" translate="yes" xml:space="preserve">
          <source>Input values to these routines may be any string, that looks like a number and results in an integer, including hexadecimal and binary numbers.</source>
          <target state="translated">Входными значениями для этих подпрограмм могут быть любые строки,которые выглядят как число и приводят к целому числу,включая шестнадцатеричные и двоичные числа.</target>
        </trans-unit>
        <trans-unit id="ff508ce692e1254966736e47898113545150b2ac" translate="yes" xml:space="preserve">
          <source>Insecure $ENV{%s} while running %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f2e8a9a0eb4ece5b87faf1da95aff5e83b5fa4" translate="yes" xml:space="preserve">
          <source>Insecure dependency in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931ce1c7f1f13e481922a26677a26bb4773219c6" translate="yes" xml:space="preserve">
          <source>Insecure directory in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb11eae387cd5cce06293624d01344e1072d48a" translate="yes" xml:space="preserve">
          <source>Insecure user-defined property %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ede375a150e967e64e7e2d887a232d51f368fa" translate="yes" xml:space="preserve">
          <source>Insert LIST elements at the beginning of the array, moving existing elements up to make room.</source>
          <target state="translated">Вставьте элементы СПИСКА в начало массива,перемещая существующие элементы вверх,чтобы освободить место.</target>
        </trans-unit>
        <trans-unit id="8b5af2a8ac2266ac1fdb8694203bf8a7b5999fb5" translate="yes" xml:space="preserve">
          <source>Insert LIST elements at the beginning of the array, moving existing elements up to make room. For example:</source>
          <target state="translated">Вставьте элементы СПИСКА в начало массива,перемещая существующие элементы вверх,чтобы освободить место.Например:</target>
        </trans-unit>
        <trans-unit id="065f57756426a11d3de09e3d897a1322f51a5123" translate="yes" xml:space="preserve">
          <source>Insert characters into the lexer buffer (&lt;a href=&quot;#PL_parser-%3Elinestr&quot;&gt;&quot;PL_parser-&amp;gt;linestr&quot;&lt;/a&gt;), immediately after the current lexing point (&lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&quot;PL_parser-&amp;gt;bufptr&quot;&lt;/a&gt;), reallocating the buffer if necessary. This means that lexing code that runs later will see the characters as if they had appeared in the input. It is not recommended to do this as part of normal parsing, and most uses of this facility run the risk of the inserted characters being interpreted in an unintended manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c8d991df77bf00e29c21cb93175839fa481ea2b" translate="yes" xml:space="preserve">
          <source>Insert characters into the lexer buffer (&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;), immediately after the current lexing point (&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt;), reallocating the buffer if necessary. This means that lexing code that runs later will see the characters as if they had appeared in the input. It is not recommended to do this as part of normal parsing, and most uses of this facility run the risk of the inserted characters being interpreted in an unintended manner.</source>
          <target state="translated">&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;Вставлять&lt;/a&gt; символы в буфер лексического анализатора ( PL_parser-&amp;gt; linestr ) сразу после текущей точки &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;лексирования&lt;/a&gt; ( PL_parser-&amp;gt; bufptr ), при необходимости перераспределяя буфер. Это означает, что код лексирования, который запускается позже, будет видеть символы, как если бы они были введены. Не рекомендуется делать это как часть обычного синтаксического анализа, и в большинстве случаев использование этого средства сопряжено с риском непреднамеренной интерпретации вставленных символов.</target>
        </trans-unit>
        <trans-unit id="d46d273f43c1298f3a09e3049502d6b87af98707" translate="yes" xml:space="preserve">
          <source>Inserting POD, Comments and C Preprocessor Directives</source>
          <target state="translated">Вставка POD,комментариев и C Директив для препроцессора</target>
        </trans-unit>
        <trans-unit id="3ddc278de0a82017be1546343c053adba747b534" translate="yes" xml:space="preserve">
          <source>Inserting records that</source>
          <target state="translated">Вставка записей,которые</target>
        </trans-unit>
        <trans-unit id="762d7f10b7a5cbbfbd3a51bba1f8d6e37c660a81" translate="yes" xml:space="preserve">
          <source>Inserts a string at the specified offset/length within the SV. Similar to the Perl substr() function. Handles get magic.</source>
          <target state="translated">Вставляет строку с заданным смещением/длиной внутри SV.Аналогично функции подстроки Perl.Ручки получают магию.</target>
        </trans-unit>
        <trans-unit id="0ae14887402eb591db68a2439f3f3fdfb3b0176f" translate="yes" xml:space="preserve">
          <source>Inserts and/or replaces a string at the specified offset/length within the SV. Similar to the Perl &lt;code&gt;substr()&lt;/code&gt; function, with &lt;code&gt;littlelen&lt;/code&gt; bytes starting at &lt;code&gt;little&lt;/code&gt; replacing &lt;code&gt;len&lt;/code&gt; bytes of the string in &lt;code&gt;bigstr&lt;/code&gt; starting at &lt;code&gt;offset&lt;/code&gt;. Handles get magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3e05759f66cf1dafff1c764cc8c3b6a42a2c61" translate="yes" xml:space="preserve">
          <source>Inserts the sharpbang or equivalent magic number to a set of @files.</source>
          <target state="translated">Вставляет резкий удар или эквивалентное ему магическое число в набор @-файлов.</target>
        </trans-unit>
        <trans-unit id="bfb7a36a7ca33fb28f326fe5eacde6cacf000521" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;(?{...})&lt;/code&gt; block, &lt;code&gt;$_&lt;/code&gt; refers to the string the regular expression is matching against. You can also use &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; to know what is the current position of matching within this string.</source>
          <target state="translated">Внутри блока &lt;code&gt;(?{...})&lt;/code&gt; &lt;code&gt;$_&lt;/code&gt; относится к строке, с которой сопоставляется регулярное выражение. Вы также можете использовать &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; чтобы узнать текущую позицию соответствия в этой строке.</target>
        </trans-unit>
        <trans-unit id="9e74660978326d8205b1966918b272dc20370085" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;(?{...})&lt;/code&gt; block, &lt;code&gt;$_&lt;/code&gt; refers to the string the regular expression is matching against. You can also use &lt;code&gt;pos()&lt;/code&gt; to know what is the current position of matching within this string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56e96c79858e86c827cc4e174ee077ce93a7306" translate="yes" xml:space="preserve">
          <source>Inside a Perl program, you can use the &lt;a href=&quot;ExtUtils::Installed&quot;&gt;ExtUtils::Installed&lt;/a&gt; module to show all installed distributions, although it can take awhile to do its magic. The standard library which comes with Perl just shows up as &quot;Perl&quot; (although you can get those with &lt;a href=&quot;Module::CoreList&quot;&gt;Module::CoreList&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f1ba3b99ef99e8ed328c9a98bf927d5f0a5518" translate="yes" xml:space="preserve">
          <source>Inside a Perl program, you can use the &lt;a href=&quot;extutils/installed&quot;&gt;ExtUtils::Installed&lt;/a&gt; module to show all installed distributions, although it can take awhile to do its magic. The standard library which comes with Perl just shows up as &quot;Perl&quot; (although you can get those with &lt;a href=&quot;module/corelist&quot;&gt;Module::CoreList&lt;/a&gt;).</source>
          <target state="translated">Внутри программы на Perl вы можете использовать модуль &lt;a href=&quot;extutils/installed&quot;&gt;ExtUtils :: Installed,&lt;/a&gt; чтобы показать все установленные дистрибутивы, хотя это может занять некоторое время. Стандартная библиотека, поставляемая с Perl, просто отображается как &amp;laquo;Perl&amp;raquo; (хотя вы можете получить ее с помощью &lt;a href=&quot;module/corelist&quot;&gt;Module :: CoreList&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ac6e4915bcad5900cd6401a5966f997e137a0c9" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; code block, &lt;code&gt;$?&lt;/code&gt; contains the value that the program is going to pass to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; to change the exit value of the program. Beware of changing &lt;code&gt;$?&lt;/code&gt; by accident (e.g. by running something via &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Внутри блока кода &lt;code&gt;END&lt;/code&gt; &lt;code&gt;$?&lt;/code&gt; содержит значение, которое программа собирается передать функции &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; . Вы можете изменить &lt;code&gt;$?&lt;/code&gt; для изменения значения выхода из программы. Остерегайтесь менять &lt;code&gt;$?&lt;/code&gt; случайно (например, запустив что-то через &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bf5fff32ec45447a013d87f1e68934fda177610e" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; code block, &lt;code&gt;$?&lt;/code&gt; contains the value that the program is going to pass to &lt;code&gt;exit()&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; to change the exit value of the program. Beware of changing &lt;code&gt;$?&lt;/code&gt; by accident (e.g. by running something via &lt;code&gt;system&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3aa49ae51d12807c062f5debba3be515ca72cb" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; subroutine &lt;code&gt;$?&lt;/code&gt; contains the value that is going to be given to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; in an &lt;code&gt;END&lt;/code&gt; subroutine to change the exit status of your program. For example:</source>
          <target state="translated">Внутри подпрограммы &lt;code&gt;END&lt;/code&gt; &lt;code&gt;$?&lt;/code&gt; содержит значение, которое будет присвоено &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; . Вы можете изменить &lt;code&gt;$?&lt;/code&gt; в подпрограмме &lt;code&gt;END&lt;/code&gt; , чтобы изменить статус выхода вашей программы. Например:</target>
        </trans-unit>
        <trans-unit id="ad96dc469c005e6c9269282065dbe2d978332531" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; subroutine &lt;code&gt;$?&lt;/code&gt; contains the value that is going to be given to &lt;code&gt;exit()&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; in an &lt;code&gt;END&lt;/code&gt; subroutine to change the exit status of your program. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a3aafbb284a68739c4fb1ae1f60eb5141dcdda7" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;CHECK&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt; .</source>
          <target state="translated">Внутри блока &lt;code&gt;CHECK&lt;/code&gt; значение &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; будет &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67ca3322bfb1e33afbca0ac9de2636f604c7b47b" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;CHECK&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77fd9286042f60d2513d71db2f202e6d15711855" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;END&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;END&quot;&lt;/code&gt; .</source>
          <target state="translated">Внутри блока &lt;code&gt;END&lt;/code&gt; значение &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; будет &lt;code&gt;&quot;END&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40747b8f72c39fcb02dd5eb53c21ee80332129f2" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;END&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;END&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a193b063515ab15da965bd3478de34c4b7d0830" translate="yes" xml:space="preserve">
          <source>Inside of an &lt;code&gt;INIT&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;INIT&quot;&lt;/code&gt; .</source>
          <target state="translated">Внутри блока &lt;code&gt;INIT&lt;/code&gt; значение &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; будет &lt;code&gt;&quot;INIT&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dee2a938cbad68208b1a78048519d4dcb40a2614" translate="yes" xml:space="preserve">
          <source>Inside of an &lt;code&gt;INIT&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;INIT&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24121a7266e78f12986b250ed98974d9cfcc24b" translate="yes" xml:space="preserve">
          <source>Inside such a</source>
          <target state="translated">Внутри такого</target>
        </trans-unit>
        <trans-unit id="f7a01b93c52f9dee6e4b496cdb9ca5fafa7aa5b5" translate="yes" xml:space="preserve">
          <source>Inside the Perl core (&lt;code&gt;PERL_CORE&lt;/code&gt; defined), you can get at the functions either with or without the &lt;code&gt;Perl_&lt;/code&gt; prefix, thanks to a bunch of defines that live in</source>
          <target state="translated">Внутри ядра Perl ( определенного &lt;code&gt;PERL_CORE&lt;/code&gt; ) вы можете получить &lt;code&gt;Perl_&lt;/code&gt; к функциям с префиксом Perl_ или без него , благодаря множеству определений, которые находятся в</target>
        </trans-unit>
        <trans-unit id="0daafc0685af0d01e22cebc44846559b24d94dc9" translate="yes" xml:space="preserve">
          <source>Inside your block, you can use a &lt;code&gt;;&lt;/code&gt; before the ellipsis to denote that the &lt;code&gt;{ ... }&lt;/code&gt; is a block and not a hash reference constructor. Now the ellipsis works:</source>
          <target state="translated">Внутри вашего блока вы можете использовать &lt;code&gt;;&lt;/code&gt; перед многоточием, чтобы обозначить, что &lt;code&gt;{ ... }&lt;/code&gt; является блоком, а не конструктором ссылки на хэш. Теперь многоточие работает:</target>
        </trans-unit>
        <trans-unit id="c37269c429f2ad22959db0e60ac4d8827e7e42ce" translate="yes" xml:space="preserve">
          <source>Inside-Out objects</source>
          <target state="translated">Внутренние объекты</target>
        </trans-unit>
        <trans-unit id="7a4af927ec1e221d9c738e75cdfca5e119205956" translate="yes" xml:space="preserve">
          <source>Inside-out classes give us freedom of inheritance, but as usual there is a price.</source>
          <target state="translated">Классы &quot;изнутри&quot; дают нам свободу наследования,но,как обычно,есть цена.</target>
        </trans-unit>
        <trans-unit id="ec3c84ba848d8b0d780dabe6d5db65999ccfe2b2" translate="yes" xml:space="preserve">
          <source>Inside-out implementation based on the &lt;code&gt;id()&lt;/code&gt; function with explicit object registry. No destructor is needed and objects are thread safe.</source>
          <target state="translated">Реализация наизнанку на основе функции &lt;code&gt;id()&lt;/code&gt; с явным реестром объектов. Деструктор не требуется, а объекты потокобезопасны.</target>
        </trans-unit>
        <trans-unit id="093639ed82951fb2c05d82fa61065038c4a3f59b" translate="yes" xml:space="preserve">
          <source>Inside-out implementation based on the &lt;code&gt;id()&lt;/code&gt; function. It needs a &lt;code&gt;DESTROY&lt;/code&gt; method. For thread support a &lt;code&gt;CLONE&lt;/code&gt; method (not shown) would also be needed. Instead of &lt;code&gt;Hash::Util::FieldHash::id()&lt;/code&gt; the function &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; could be used with very little functional difference. This is the basic pattern of an inside-out class.</source>
          <target state="translated">Реализация наизнанку на основе функции &lt;code&gt;id()&lt;/code&gt; . Ему нужен метод &lt;code&gt;DESTROY&lt;/code&gt; . Для поддержки потока также потребуется метод &lt;code&gt;CLONE&lt;/code&gt; (не показан). Вместо &lt;code&gt;Hash::Util::FieldHash::id()&lt;/code&gt; использовать функцию &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; с очень небольшой функциональной разницей. Это основной паттерн вывернутого наизнанку класса.</target>
        </trans-unit>
        <trans-unit id="1c8b1c8f4d7d36ee82d3ac919c5d208501a0c13b" translate="yes" xml:space="preserve">
          <source>Insisting on hints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516f54aa115effcfaabedad668e70675fab3e3bf" translate="yes" xml:space="preserve">
          <source>Insisting on hints is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f7dff6871418123fc5bf54019b9bfae13765ed" translate="yes" xml:space="preserve">
          <source>Inspecting &lt;code&gt;$UTF8{Euro}&lt;/code&gt; shows that it contains 3 bytes: &quot;\xe2\x82\xac&quot;. However, it contains only 1 character, number 0x20AC. The round trip can be completed with &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Проверка &lt;code&gt;$UTF8{Euro}&lt;/code&gt; показывает, что он содержит 3 байта: &quot;\ xe2 \ x82 \ xac&quot;. Однако он содержит только 1 символ, номер 0x20AC. Туда и обратно можно завершить &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2b88041bde7425827d8e1b77e408079f51dbc6c2" translate="yes" xml:space="preserve">
          <source>Inspecting &lt;code&gt;$UTF8{Euro}&lt;/code&gt; shows that it contains 3 bytes: &quot;\xe2\x82\xac&quot;. However, it contains only 1 character, number 0x20AC. The round trip can be completed with &lt;code&gt;unpack&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59207d175da65683910680d9c040a0c388fa1f23" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2005 first, then the Platform SDK. Setup your environment as follows (assuming default installation locations were chosen):</source>
          <target state="translated">Сначала установите Visual C++2005,затем Platform SDK.Настройте ваше окружение следующим образом (предполагая,что были выбраны места установки по умолчанию):</target>
        </trans-unit>
        <trans-unit id="33cbab1690c07ca74d0ff29dfe5b56b37a842899" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2008-2013 Express, then setup your environment using, e.g.</source>
          <target state="translated">Установите Visual C++2008-2013 Express,затем настройте ваше окружение,например,с помощью</target>
        </trans-unit>
        <trans-unit id="64c681793c05d20d47748a1c4848dd27ecc92478" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2008-2019 Express/Community, then setup your environment using, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f196edb7ca2b342cfc8b1c8d1c16c051256d43c" translate="yes" xml:space="preserve">
          <source>Install a callback for a named event.</source>
          <target state="translated">Установите обратный вызов для именованного события.</target>
        </trans-unit>
        <trans-unit id="098146decab9cf9682dd20a4b2bc8c4001fb20aa" translate="yes" xml:space="preserve">
          <source>Install a signal mask and suspend process until signal arrives. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;signal_mask&lt;/code&gt; argument. Consult your system's &lt;code&gt;sigsuspend&lt;/code&gt; manpage for details.</source>
          <target state="translated">Установите маску сигнала и приостановите процесс до получения сигнала. Это использует объекты &lt;code&gt;POSIX::SigSet&lt;/code&gt; для аргумента &lt;code&gt;signal_mask&lt;/code&gt; . За подробностями &lt;code&gt;sigsuspend&lt;/code&gt; к странице руководства sigsuspend вашей системы .</target>
        </trans-unit>
        <trans-unit id="5064d1cdb752ce928134eb0a4e8326765bed0d5e" translate="yes" xml:space="preserve">
          <source>Install all distributions that have been tested successfully but have not yet been installed. See also &lt;code&gt;is_tested&lt;/code&gt; .</source>
          <target state="translated">Установите все дистрибутивы, которые были успешно протестированы, но еще не установлены. См. Также &lt;code&gt;is_tested&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30bb41e456f55898b9a816d97d83d13570e789d0" translate="yes" xml:space="preserve">
          <source>Install files from here to there</source>
          <target state="translated">Устанавливать файлы отсюда и до туда</target>
        </trans-unit>
        <trans-unit id="be838642bc4439dddc0a654f23d9ebf8387685d2" translate="yes" xml:space="preserve">
          <source>Install my_handler() as the handler for the &lt;b&gt;normal-signals&lt;/b&gt;:</source>
          <target state="translated">Установите my_handler () как обработчик &lt;b&gt;обычных сигналов&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="f8eeec02705f1ef8eb9bf0619d6a4de1e15c32de" translate="yes" xml:space="preserve">
          <source>Install my_handler() as the handler for the normal-signals, provide a Perl stack trace on receipt of one of the error-signals:</source>
          <target state="translated">Установите my_handler()в качестве обработчика нормальных сигналов,предоставьте трассу стека Perl при получении одного из сигналов об ошибке:</target>
        </trans-unit>
        <trans-unit id="e64dce2583dfe013eb849f3d2d103a519b4f693d" translate="yes" xml:space="preserve">
          <source>Install the Toolkit first, then the Platform SDK, then the .NET Framework SDK. Setup your environment as follows (assuming default installation locations were chosen):</source>
          <target state="translated">Установите сначала Комплект инструментов,затем Комплект SDK для платформы,затем Комплект SDK для .NET Framework.Настройте ваше окружение следующим образом (предполагая,что были выбраны места установки по умолчанию):</target>
        </trans-unit>
        <trans-unit id="cd990d98fdc32595b067d42fc715d5ce94d57be2" translate="yes" xml:space="preserve">
          <source>Install the bundle &lt;code&gt;Bundle::OS2_default&lt;/code&gt;</source>
          <target state="translated">Установить пакет &lt;code&gt;Bundle::OS2_default&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b20b73b1de67223c2bd9207fae1a1e9b72c2233d" translate="yes" xml:space="preserve">
          <source>Install the bundle file you produced in the first step with something like</source>
          <target state="translated">Установите файл пакета,который вы произвели в первом шаге с чем-то вроде</target>
        </trans-unit>
        <trans-unit id="b2a00c681671c3322d47892ed0695f73370a27ed" translate="yes" xml:space="preserve">
          <source>Install the specified modules. With no other switches, this switch is implied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a972b5a9d813b2528044bfdb606fb493e85bedb6" translate="yes" xml:space="preserve">
          <source>Install will copy the files into the Windows machine where NetWare Perl is installed and these files may have to be copied to the NetWare server manually. Alternatively, pass</source>
          <target state="translated">Install скопирует файлы на машину под управлением Windows,на которой установлен NetWare Perl,и эти файлы,возможно,придется скопировать на сервер NetWare вручную.В качестве альтернативы,перейдите</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="5170591ca8711f15e1b20c47f412774e19b0fe70" translate="yes" xml:space="preserve">
          <source>Installation Anomalies with Perl on OS/390</source>
          <target state="translated">Аномалии при установке с Perl на OS/390</target>
        </trans-unit>
        <trans-unit id="8744a89757a103643f2c85c220b914d085ffdf88" translate="yes" xml:space="preserve">
          <source>Installation Prefix</source>
          <target state="translated">Префикс установки</target>
        </trans-unit>
        <trans-unit id="a45aaea883d55053b401f0d2cdd7b7f6799182e8" translate="yes" xml:space="preserve">
          <source>Installation of &lt;code&gt;Unicode::Collate::Locale&lt;/code&gt; requires</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180cc178e07c1743ecf9dbe37bab2bf2dabe5bb5" translate="yes" xml:space="preserve">
          <source>Installation of Perl on DOS</source>
          <target state="translated">Установка Perl на DOS</target>
        </trans-unit>
        <trans-unit id="cfb2e768feadc8837cc7fc759954e96ac60a95b5" translate="yes" xml:space="preserve">
          <source>Installation of Perl on Windows</source>
          <target state="translated">Установка Perl на Windows</target>
        </trans-unit>
        <trans-unit id="4ca02b48dd8aa7c8862ef964b8ef23527a77760c" translate="yes" xml:space="preserve">
          <source>Installing Perl Documentation on Plan 9</source>
          <target state="translated">Установка документации на Perl на плане 9</target>
        </trans-unit>
        <trans-unit id="2ae981a52ea5c2d2aafd4355287d2406dc0ef314" translate="yes" xml:space="preserve">
          <source>Installing Perl in OS/400 PASE</source>
          <target state="translated">Установка Perl в OS/400 PASE</target>
        </trans-unit>
        <trans-unit id="b61a365b42d75d8e047fa9fe92ff65b4f60e9701" translate="yes" xml:space="preserve">
          <source>Installing Perl on BS2000</source>
          <target state="translated">Установка Perl на BS2000</target>
        </trans-unit>
        <trans-unit id="0417ed1ca822a227853883f689e9fa61b7253133" translate="yes" xml:space="preserve">
          <source>Installing dynamic extensions</source>
          <target state="translated">Установка динамических расширений</target>
        </trans-unit>
        <trans-unit id="d551e6ba21a76c8b829c9fd66b0f82cb57a2e6c1" translate="yes" xml:space="preserve">
          <source>Installing handlers into UNIVERSAL, makes them...err..universal. For example:</source>
          <target state="translated">Установка обработчиков в УНИВЕРСАЛ,делает их...универсальными.Например:</target>
        </trans-unit>
        <trans-unit id="0cfc88ee57d518bf7af556a12ced2b10a8287ca8" translate="yes" xml:space="preserve">
          <source>Installing static extensions</source>
          <target state="translated">Установка статических удлинителей</target>
        </trans-unit>
        <trans-unit id="257dd2466c69ad9b24149fb3bc3f1813543ba72a" translate="yes" xml:space="preserve">
          <source>Installing the built Perl on AmigaOS</source>
          <target state="translated">Установка встроенного Perl на AmigaOS</target>
        </trans-unit>
        <trans-unit id="db29ef231e31119424ca9f0f93b9223b833e4152" translate="yes" xml:space="preserve">
          <source>Installing the built perl</source>
          <target state="translated">Установка встроенного perl</target>
        </trans-unit>
        <trans-unit id="d904df04db30e9f6033f6ecb3f32eb4c2b0e5b70" translate="yes" xml:space="preserve">
          <source>Installing your Extension</source>
          <target state="translated">Установка расширения</target>
        </trans-unit>
        <trans-unit id="0f18cd63862f3975ca1e7ab7bda9fc335b20e2f1" translate="yes" xml:space="preserve">
          <source>Installs a source filter that substitutes &quot;e&quot; for &quot;o&quot; (witheut regard fer what it might be medifying).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd4a61ab3dc44ab9b5a205303724a68f74a735a7" translate="yes" xml:space="preserve">
          <source>Instance Methods</source>
          <target state="translated">Экстраординарные методы</target>
        </trans-unit>
        <trans-unit id="8d64e2312c9072080b4302e3445829998f7c6a99" translate="yes" xml:space="preserve">
          <source>Instance method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e18280b32ffbeebedfcc0fc6dbe9b749315b6ea6" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt; , we can write &lt;code&gt;$a[1][2]&lt;/code&gt; ; it means the same thing. Instead of &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt; , we can write &lt;code&gt;$a[0][1] = 23&lt;/code&gt; ; it means the same thing.</source>
          <target state="translated">Вместо &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt; мы можем написать &lt;code&gt;$a[1][2]&lt;/code&gt; ; это означает то же самое. Вместо &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt; мы можем написать &lt;code&gt;$a[0][1] = 23&lt;/code&gt; ; это означает то же самое.</target>
        </trans-unit>
        <trans-unit id="593a1adb7d7043c40428f2f6f11f755e1eb8603d" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt;, we can write &lt;code&gt;$a[1][2]&lt;/code&gt;; it means the same thing. Instead of &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt;, we can write &lt;code&gt;$a[0][1] = 23&lt;/code&gt;; it means the same thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba491ba1ec8ef4be8f85786b6a781edf6fccddb7" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; , you can simply use &lt;code&gt;:utf8&lt;/code&gt; , which skips the encoding step if the data was already represented as UTF8 internally. This is widely accepted as good behavior when you're writing, but it can be dangerous when reading, because it causes internal inconsistency when you have invalid byte sequences. Using &lt;code&gt;:utf8&lt;/code&gt; for input can sometimes result in security breaches, so please use &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; instead.</source>
          <target state="translated">Вместо &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; вы можете просто использовать &lt;code&gt;:utf8&lt;/code&gt; , который пропускает этап кодирования, если данные уже были представлены как UTF8 внутри. Это широко считается хорошим поведением при написании, но может быть опасным при чтении, поскольку вызывает внутреннюю несогласованность, когда у вас есть неправильные последовательности байтов. Использование &lt;code&gt;:utf8&lt;/code&gt; для ввода иногда может привести к нарушениям безопасности, поэтому используйте вместо этого &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bfad6bde5b470a60206db3866234b6dfd103110" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;:encoding(UTF-8)&lt;/code&gt;, you can simply use &lt;code&gt;:utf8&lt;/code&gt;, which skips the encoding step if the data was already represented as UTF8 internally. This is widely accepted as good behavior when you're writing, but it can be dangerous when reading, because it causes internal inconsistency when you have invalid byte sequences. Using &lt;code&gt;:utf8&lt;/code&gt; for input can sometimes result in security breaches, so please use &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ad0b5725694a222d6ac24da3bbb122aa3a958a" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;encode&lt;/code&gt; , you could use &lt;code&gt;_utf8_on&lt;/code&gt; and &lt;code&gt;_utf8_off&lt;/code&gt; , but this is considered bad style. Especially &lt;code&gt;_utf8_on&lt;/code&gt; can be dangerous, for the same reason that &lt;code&gt;:utf8&lt;/code&gt; can.</source>
          <target state="translated">Вместо &lt;code&gt;decode&lt;/code&gt; и &lt;code&gt;encode&lt;/code&gt; вы можете использовать &lt;code&gt;_utf8_on&lt;/code&gt; и &lt;code&gt;_utf8_off&lt;/code&gt; , но это считается плохим стилем. Особенно &lt;code&gt;_utf8_on&lt;/code&gt; по той же причине, что и &lt;code&gt;:utf8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdb3493ce203f52a331d6d2854f96ffed217a38c" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;encode&lt;/code&gt;, you could use &lt;code&gt;_utf8_on&lt;/code&gt; and &lt;code&gt;_utf8_off&lt;/code&gt;, but this is considered bad style. Especially &lt;code&gt;_utf8_on&lt;/code&gt; can be dangerous, for the same reason that &lt;code&gt;:utf8&lt;/code&gt; can.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f30761f7bbd31f759ef384a9ad19f6187329e7a" translate="yes" xml:space="preserve">
          <source>Instead of a filename, you can also pass it an existing &lt;code&gt;Archive::Tar::File&lt;/code&gt; object from, for example, another archive. The object will be clone, and effectively be a copy of the original, not an alias.</source>
          <target state="translated">Вместо имени файла вы также можете передать ему существующий объект &lt;code&gt;Archive::Tar::File&lt;/code&gt; , например, из другого архива. Объект будет клонирован и фактически будет копией оригинала, а не псевдонимом.</target>
        </trans-unit>
        <trans-unit id="124160cac15a4b540f3a3a995eeb45e15636d682" translate="yes" xml:space="preserve">
          <source>Instead of a filename, you may specify an external command (plus an optional argument list) or a scalar reference, in order to open filehandles on commands or in-memory scalars, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d7794c8d2e8209f9cf8a080564bc83932d1de0d" translate="yes" xml:space="preserve">
          <source>Instead of a number, you can use &lt;code&gt;*&lt;/code&gt; to mean &quot;consume everything else left&quot;.</source>
          <target state="translated">Вместо числа вы можете использовать &lt;code&gt;*&lt;/code&gt; для обозначения &amp;laquo;потреблять все, что осталось&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2d5ef8b3223bf8e72260629cb76365a1c7d119c3" translate="yes" xml:space="preserve">
          <source>Instead of an actual C function that has to fetch the thread context using &lt;code&gt;dTHX&lt;/code&gt; , you can define macros of the same name and avoid the overhead. Also, keep in mind to possibly free the memory allocated by &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt; .</source>
          <target state="translated">Вместо реальной функции C, которая должна &lt;code&gt;dTHX&lt;/code&gt; контекст потока с помощью dTHX , вы можете определить макросы с тем же именем и избежать накладных расходов. Также не забывайте о возможном освобождении памяти, выделенной &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a07eba34499fa5596b47d75d14fe92d0d0178dc4" translate="yes" xml:space="preserve">
          <source>Instead of an actual C function that has to fetch the thread context using &lt;code&gt;dTHX&lt;/code&gt;, you can define macros of the same name and avoid the overhead. Also, keep in mind to possibly free the memory allocated by &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efec145a63aada8917ea862470d1c559b417d5a8" translate="yes" xml:space="preserve">
          <source>Instead of it, do like this:</source>
          <target state="translated">Вместо этого делай вот так:</target>
        </trans-unit>
        <trans-unit id="18bf50916f725e20e492e415ffe30f1d8deec329" translate="yes" xml:space="preserve">
          <source>Instead of loading feature bundles by name, it is easier to let Perl do implicit loading of a feature bundle for you.</source>
          <target state="translated">Вместо того,чтобы загружать наборы функций по имени,проще позволить Perl сделать неявную загрузку набора функций за вас.</target>
        </trans-unit>
        <trans-unit id="19636d7e449d8e4352801adbe196c0e695eced0d" translate="yes" xml:space="preserve">
          <source>Instead of reading the Unicode Database directly from files, as you were able to do for a long time, you are encouraged to use the supplied functions. So, instead of reading &lt;code&gt;Name.pl&lt;/code&gt; directly, which changed formats in 5.32, and may do so again without notice in the future or even disappear, you ought to use &lt;a href=&quot;#prop_invmap%28%29&quot;&gt;&quot;prop_invmap()&quot;&lt;/a&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4549985addea58856a2589a95661e1f3d1246c4e" translate="yes" xml:space="preserve">
          <source>Instead of setting &lt;code&gt;$SIG{ALRM}&lt;/code&gt; :</source>
          <target state="translated">Вместо установки &lt;code&gt;$SIG{ALRM}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="109c505d57edc356474583bd538981b34aae6661" translate="yes" xml:space="preserve">
          <source>Instead of setting &lt;code&gt;$SIG{ALRM}&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4cf4072b6ecd93f69baec56cef0a223f95f5666" translate="yes" xml:space="preserve">
          <source>Instead of specifying the VERSION in the Makefile.PL you can let MakeMaker parse a file to determine the version number. The parsing routine requires that the file named by VERSION_FROM contains one single line to compute the version number. The first line in the file that contains something like a $VERSION assignment or &lt;code&gt;package Name
VERSION&lt;/code&gt; will be used. The following lines will be parsed o.k.:</source>
          <target state="translated">Вместо указания ВЕРСИИ в Makefile.PL вы можете позволить MakeMaker проанализировать файл для определения номера версии. Процедура синтаксического анализа требует, чтобы файл с именем VERSION_FROM содержал одну единственную строку для вычисления номера версии. Будет использоваться первая строка в файле, которая содержит что-то вроде назначения $ VERSION или имени &lt;code&gt;package Name VERSION&lt;/code&gt; . Следующие строки будут проанализированы нормально:</target>
        </trans-unit>
        <trans-unit id="c9d067c5eb0ad6111602fcfc2b4a14a7fd5906ed" translate="yes" xml:space="preserve">
          <source>Instead of the</source>
          <target state="translated">Вместо</target>
        </trans-unit>
        <trans-unit id="52ef12851a02520ecdc1bb50b94ab80ca32cf34d" translate="yes" xml:space="preserve">
          <source>Instead of the above process, with Filter::Simple the task of setting up a source code filter is reduced to:</source>
          <target state="translated">Вместо вышеописанного процесса,с помощью Filter::Простая задача настройки фильтра исходного кода сводится к следующему:</target>
        </trans-unit>
        <trans-unit id="08d78413d66ea6fc10e343adae82dd66dad36d77" translate="yes" xml:space="preserve">
          <source>Instead of the shell's &lt;code&gt;expand&lt;/code&gt; command, use:</source>
          <target state="translated">Вместо команды &lt;code&gt;expand&lt;/code&gt; оболочки используйте:</target>
        </trans-unit>
        <trans-unit id="c97f35f08c784710202f7afd89947e84d996ff4b" translate="yes" xml:space="preserve">
          <source>Instead of the shell's &lt;code&gt;unexpand -a&lt;/code&gt; command, use:</source>
          <target state="translated">Вместо команды оболочки &lt;code&gt;unexpand -a&lt;/code&gt; используйте:</target>
        </trans-unit>
        <trans-unit id="6ba67eec9e92df05acdf46af85244d2e3cb47ac2" translate="yes" xml:space="preserve">
          <source>Instead of this:</source>
          <target state="translated">Вместо этого:</target>
        </trans-unit>
        <trans-unit id="f550302de10f6528309a1269c83c4106b886739f" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;$*&lt;/code&gt; you should use the &lt;code&gt;/m&lt;/code&gt; (and maybe &lt;code&gt;/s&lt;/code&gt;) regexp modifiers. You can enable &lt;code&gt;/m&lt;/code&gt; for a lexical scope (even a whole file) with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/m'&lt;/code&gt; . (In older versions: when &lt;code&gt;$*&lt;/code&gt; was set to a true value then all regular expressions behaved as if they were written using &lt;code&gt;/m&lt;/code&gt;.)</source>
          <target state="translated">Вместо использования &lt;code&gt;$*&lt;/code&gt; вы должны использовать модификаторы регулярного выражения &lt;code&gt;/m&lt;/code&gt; (и, возможно, &lt;code&gt;/s&lt;/code&gt; ). Вы можете включить &lt;code&gt;/m&lt;/code&gt; для лексической области видимости (даже для всего файла) с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/m'&lt;/code&gt; . (В более старых версиях: когда &lt;code&gt;$*&lt;/code&gt; было установлено истинное значение, все регулярные выражения вели себя так, как если бы они были написаны с использованием &lt;code&gt;/m&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="d1566aff196e46eef40b411b3e40f33b2eca1868" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;$*&lt;/code&gt; you should use the &lt;code&gt;/m&lt;/code&gt; (and maybe &lt;code&gt;/s&lt;/code&gt;) regexp modifiers. You can enable &lt;code&gt;/m&lt;/code&gt; for a lexical scope (even a whole file) with &lt;code&gt;use re '/m'&lt;/code&gt;. (In older versions: when &lt;code&gt;$*&lt;/code&gt; was set to a true value then all regular expressions behaved as if they were written using &lt;code&gt;/m&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1168108b163850f03f0e7b84e90e2a3b75e09dc" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;$Level&lt;/code&gt; to perform a backtrace, Test2 uses a context object. In this sample you create a context object and store it. This locks the context (errors report 1 level up from here) for all wrapped tools to find. You do not need to use the context object, but you do need to store it in a variable. Once the sub ends the &lt;code&gt;$ctx&lt;/code&gt; variable is destroyed which lets future tools find their own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1ae30c884ab234189c910ec5202733bc2390ed" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;given()&lt;/code&gt; , you can use a &lt;code&gt;foreach()&lt;/code&gt; loop. For example, here's one way to count how many times a particular string occurs in an array:</source>
          <target state="translated">Вместо использования &lt;code&gt;given()&lt;/code&gt; вы можете использовать цикл &lt;code&gt;foreach()&lt;/code&gt; . Например, вот один из способов подсчитать, сколько раз конкретная строка встречается в массиве:</target>
        </trans-unit>
        <trans-unit id="825297ab548b22ab92e503372aa9e1350b6ae1f8" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;given()&lt;/code&gt;, you can use a &lt;code&gt;foreach()&lt;/code&gt; loop. For example, here's one way to count how many times a particular string occurs in an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaff3d1d72214bb8cea47592fb5e3c306e475c28" translate="yes" xml:space="preserve">
          <source>Instead of writing an overloaded interface using pure Perl, you can also use the OVERLOAD keyword to define additional Perl names for your functions (like the ALIAS: keyword above). However, the overloaded functions must be defined in such a way as to accept the number of parameters supplied by perl's overload system. For most overload methods, it will be three parameters; for the &lt;code&gt;nomethod&lt;/code&gt; function it will be four. However, the bitwise operators &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt; may be called with three</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf329df99c7b872b2b1eb49834514d53120f89e" translate="yes" xml:space="preserve">
          <source>Instead of writing an overloaded interface using pure Perl, you can also use the OVERLOAD keyword to define additional Perl names for your functions (like the ALIAS: keyword above). However, the overloaded functions must be defined with three parameters (except for the nomethod() function which needs four parameters). If any function has the OVERLOAD: keyword, several additional lines will be defined in the c file generated by xsubpp in order to register with the overload magic.</source>
          <target state="translated">Вместо того,чтобы писать перегруженный интерфейс с использованием чистого Perl,вы можете также использовать ключевое слово OVERLOAD для определения дополнительных имен Perl для ваших функций (например,ALIAS:ключевое слово выше).Однако,перегруженные функции должны быть определены с тремя параметрами (за исключением функции nomethod(),которая нуждается в четырех параметрах).Если какая-либо функция имеет ключевое слово OVERLOAD:,то в файле c,генерируемом xsubpp,будет определено несколько дополнительных строк,чтобы зарегистрироваться с магической перегрузкой.</target>
        </trans-unit>
        <trans-unit id="638fcabfcb5cd72cef4275780294bf41068d5ea4" translate="yes" xml:space="preserve">
          <source>Instead of writing multiple &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; statements, you may define multiple constants in a single statement by giving, instead of the constant name, a reference to a hash where the keys are the names of the constants to be defined. Obviously, all constants defined using this method must have a single value.</source>
          <target state="translated">Вместо написания операторов многократного &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; вы можете определить несколько констант в одном операторе, указав вместо имени константы ссылку на хэш, где ключи - это имена констант, которые должны быть определены. Очевидно, что все константы, определенные с помощью этого метода, должны иметь одно значение.</target>
        </trans-unit>
        <trans-unit id="df4a7dbc731cad321f60bc3be4e6304404421661" translate="yes" xml:space="preserve">
          <source>Instead of writing multiple &lt;code&gt;use constant&lt;/code&gt; statements, you may define multiple constants in a single statement by giving, instead of the constant name, a reference to a hash where the keys are the names of the constants to be defined. Obviously, all constants defined using this method must have a single value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6782b252ab0c32bd42d86fbd7b3f79af4ff565e5" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toFOLD_utf8&quot;&gt;toFOLD_utf8&lt;/a&gt;.</source>
          <target state="translated">Вместо этого используйте &lt;a href=&quot;#toFOLD_utf8&quot;&gt;toFOLD_utf8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1f6743fcc3e6286f6e367f0b73ab61c02242a50" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toLOWER_utf8&quot;&gt;toLOWER_utf8&lt;/a&gt;.</source>
          <target state="translated">Вместо этого используйте &lt;a href=&quot;#toLOWER_utf8&quot;&gt;toLOWER_utf8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef6bd3b06361be7e68d9b7223a3d403afc7f30fb" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toTITLE_utf8&quot;&gt;toTITLE_utf8&lt;/a&gt;.</source>
          <target state="translated">Вместо этого используйте &lt;a href=&quot;#toTITLE_utf8&quot;&gt;toTITLE_utf8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f68321016539906487e3d1b25d1d9b7700cb63a1" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toUPPER_utf8&quot;&gt;toUPPER_utf8&lt;/a&gt;.</source>
          <target state="translated">Вместо этого используйте &lt;a href=&quot;#toUPPER_utf8&quot;&gt;toUPPER_utf8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8ee82e6fa25bfd2bc478049adfc2e72d633951e" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;, or rarely, &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt;.</source>
          <target state="translated">Вместо этого используйте &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; или, реже, &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5da1022fb23560c08ccb2175ba3ed7594365a4b" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;perlapi#utf8_to_uvchr_buf&quot;&gt;&quot;utf8_to_uvchr_buf&quot; in perlapi&lt;/a&gt;, or rarely, &lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1e3be314ffd2bc3abc3de781de1fea85191bb5" translate="yes" xml:space="preserve">
          <source>Instead you almost certainly want to use &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; or &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;.</source>
          <target state="translated">Вместо этого вы почти наверняка захотите использовать &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; или &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c1ab72749459dc4de544fac6868597b605f1005" translate="yes" xml:space="preserve">
          <source>Instead you almost certainly want to use &lt;a href=&quot;perlapi#uvchr_to_utf8&quot;&gt;&quot;uvchr_to_utf8&quot; in perlapi&lt;/a&gt; or &lt;a href=&quot;perlapi#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c61a7798941b565eb0ca8902a985ea083443b8b" translate="yes" xml:space="preserve">
          <source>Instead, &lt;code&gt;bytes_to_utf8&lt;/code&gt; will give you a UTF-8-encoded &lt;b&gt;copy&lt;/b&gt; of its string argument. This is useful for having the data available for comparisons and so on, without harming the original SV. There's also &lt;code&gt;utf8_to_bytes&lt;/code&gt; to go the other way, but naturally, this will fail if the string contains any characters above 255 that can't be represented in a single byte.</source>
          <target state="translated">Вместо этого &lt;code&gt;bytes_to_utf8&lt;/code&gt; предоставит вам &lt;b&gt;копию&lt;/b&gt; своего строкового аргумента в кодировке UTF-8 . Это полезно для того, чтобы данные были доступны для сравнения и так далее, без ущерба для исходного SV. Также существует &lt;code&gt;utf8_to_bytes&lt;/code&gt; , чтобы пойти другим путем, но, естественно, это не удастся, если строка содержит какие-либо символы выше 255, которые не могут быть представлены в одном байте.</target>
        </trans-unit>
        <trans-unit id="1d682bf7489c4d815717f3faba809d2c01f4ea4b" translate="yes" xml:space="preserve">
          <source>Instead, all available methods to execute plain text files on Windows rely on the file &quot;extension&quot;. There are three methods to use this to execute perl scripts:</source>
          <target state="translated">Вместо этого все доступные методы выполнения простых текстовых файлов в Windows полагаются на файл &quot;расширения&quot;.Есть три метода,которые можно использовать для выполнения perl-скриптов:</target>
        </trans-unit>
        <trans-unit id="1b6f6bc21ad6a818717c640ad98e7196014d29c9" translate="yes" xml:space="preserve">
          <source>Instead, have it like this:</source>
          <target state="translated">Вместо этого,пусть будет так:</target>
        </trans-unit>
        <trans-unit id="c21043f535759255fae7da396e1a74414adc0df4" translate="yes" xml:space="preserve">
          <source>Instead, it's recommended one uses &lt;code&gt;state&lt;/code&gt; variables to achieve the same effect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0ab28444eeb1a3b5d5448f3e8b2d9f9844879d" translate="yes" xml:space="preserve">
          <source>Instead, switch from &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; to &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;. &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; does everything &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; does, and more! In fact, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; does things</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767f1cd6299c67c930c8d9fe765261f308e05da4" translate="yes" xml:space="preserve">
          <source>Instead, the following solution works rather well. The nice things about it are 1) you can start using it right away; 2) it is more powerful, because it will do the right thing with a pattern like */*/*.c; 3) you can decide whether you do/don't want to use it; and 4) you can extend the method to add any customizations (or even entirely different kinds of wildcard expansion).</source>
          <target state="translated">Вместо этого,следующее решение работает довольно хорошо.Приятно то,что 1)вы можете начать использовать его сразу же;2)оно более мощное,потому что оно будет делать правильные вещи с шаблоном типа */*/*.c;3)вы можете решить,будете ли вы делать/не хотите использовать его;и 4)вы можете расширить метод для добавления любых настроек (или даже совершенно разных видов расширения wildcard).</target>
        </trans-unit>
        <trans-unit id="029f2d96c54611243fd4f7123ebf76a0e7725aa0" translate="yes" xml:space="preserve">
          <source>Instead, the stack stores information in a variable-length encoding of &lt;code&gt;ANY&lt;/code&gt; structures. The final value pushed is stored in the &lt;code&gt;UV&lt;/code&gt; field which encodes the kind of item held by the preceeding items; the count and types of which will depend on what kind of item is being stored. The kind field is pushed last because that will be the first field to be popped when unwinding items from the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3e6ac1b90019684415c1dbba6b4a76bfa88d1e" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;blessed&lt;/code&gt; (in the &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module) for boolean checks, &lt;code&gt;isa&lt;/code&gt; for specific class checks and &lt;code&gt;reftype&lt;/code&gt; (also from &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;) for type checks. (See &lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt; for details and a &lt;code&gt;blessed/isa&lt;/code&gt; example.)</source>
          <target state="translated">Вместо этого используйте &lt;code&gt;blessed&lt;/code&gt; (в модуле &lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; ) для логических проверок, &lt;code&gt;isa&lt;/code&gt; для проверок конкретных классов и &lt;code&gt;reftype&lt;/code&gt; (также из &lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; ) для проверок типов. (См. Подробности в &lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt; и пример &lt;code&gt;blessed/isa&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="ff6123faf0e0d43395bbeea664d72b0be06f73ad" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;blessed&lt;/code&gt; (in the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module) for boolean checks, &lt;code&gt;isa&lt;/code&gt; for specific class checks and &lt;code&gt;reftype&lt;/code&gt; (also from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;) for type checks. (See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for details and a &lt;code&gt;blessed/isa&lt;/code&gt; example.)</source>
          <target state="translated">Вместо этого используйте &lt;code&gt;blessed&lt;/code&gt; (в модуле &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; ) для логических проверок, &lt;code&gt;isa&lt;/code&gt; для проверок конкретных классов и &lt;code&gt;reftype&lt;/code&gt; (также из &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; ) для проверок типов. (См. Подробности в &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; и пример &lt;code&gt;blessed/isa&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="88561bf4f68d300fba6b47877d2e1d88be295371" translate="yes" xml:space="preserve">
          <source>Instead, use a temporary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b239d64a76a8342f4a5e3f91a8ae44b81bce472" translate="yes" xml:space="preserve">
          <source>Instead, use double-quotes with a single backslash:</source>
          <target state="translated">Вместо этого используйте двойные кавычки с одним обратным слешем:</target>
        </trans-unit>
        <trans-unit id="d6975d2303b579219cd1ad4ae114ac6792c64260" translate="yes" xml:space="preserve">
          <source>Instead, use the definitions IV, UV, IVSIZE, I32SIZE, and so forth. Avoid things like I32 because they are &lt;b&gt;not&lt;/b&gt; guaranteed to be</source>
          <target state="translated">Вместо этого используйте определения IV, UV, IVSIZE, I32SIZE и т. Д. Избегайте таких вещей, как I32, потому что они &lt;b&gt;не&lt;/b&gt; гарантируются.</target>
        </trans-unit>
        <trans-unit id="f29af992c4a56bb38b3dfd00c903703bc13b8ea4" translate="yes" xml:space="preserve">
          <source>Instead, write this using a lexical variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08114352d8e01718b9f4310cee2e4e9e17e09b27" translate="yes" xml:space="preserve">
          <source>Instructions on how to install your module along with any dependencies. Suggested information to include here:</source>
          <target state="translated">Инструкции по установке модуля вместе с любыми зависимостями.Предлагаемая информация должна быть включена сюда:</target>
        </trans-unit>
        <trans-unit id="ecdea140cf34e5fdf5440492ab0f9ef1743393d2" translate="yes" xml:space="preserve">
          <source>Insure that colons marking targets are preceded by space, in order to distinguish the target delimiter from a colon appearing as part of a filespec.</source>
          <target state="translated">Убедитесь,что двоеточиям,обозначающим цели,предшествует пробел,чтобы отличить разделитель целей от двоеточия,появляющегося в составе файловой системы.</target>
        </trans-unit>
        <trans-unit id="683987ee4aeb538cfdf37663a8c0ab7ac90a2019" translate="yes" xml:space="preserve">
          <source>Integer Arithmetic</source>
          <target state="translated">Целостная арифметика</target>
        </trans-unit>
        <trans-unit id="efbf94ff9c1725858eeaef5462e64f2f9beabf82" translate="yes" xml:space="preserve">
          <source>Integer binary logarithm [C99]</source>
          <target state="translated">Целочисленный двоичный логарифм [C99]</target>
        </trans-unit>
        <trans-unit id="0bbddfa82bfc58cb4fa39eff708183ee398ca07e" translate="yes" xml:space="preserve">
          <source>Integer binary logarithm [C99].</source>
          <target state="translated">Целочисленный двоичный логарифм [C99].</target>
        </trans-unit>
        <trans-unit id="e9aa0af9187fd5006e57aa5fe9340c513694f8b0" translate="yes" xml:space="preserve">
          <source>Integer overflow in %s number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6b479cc505431a4dd13a180ea73dec5d1ae03c" translate="yes" xml:space="preserve">
          <source>Integer overflow in format string for %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411c0a34661530dce26957f99bd67035b369dd12" translate="yes" xml:space="preserve">
          <source>Integer overflow in srand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e060e7583c7facbbad20094c9d4fc91b279e279" translate="yes" xml:space="preserve">
          <source>Integer overflow in version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0952c0d0ac1f6d4efaf83d1bb17a2ea9130956b" translate="yes" xml:space="preserve">
          <source>Integer overflow in version %d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e40742eb38c2f7d8587ad34912b36536447d35" translate="yes" xml:space="preserve">
          <source>Integer. An optional leading plus or minus sign, followed by a sequence of digits.</source>
          <target state="translated">Целостный.Дополнительный ведущий знак плюс или минус,за которым следует последовательность цифр.</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="4b35a75e337792a14859048b5fe4c1f4a2d46a86" translate="yes" xml:space="preserve">
          <source>Integrating local directories</source>
          <target state="translated">Интеграция локальных каталогов</target>
        </trans-unit>
        <trans-unit id="1c339f566d96dc4be124c8a012dc09ff7ba394ec" translate="yes" xml:space="preserve">
          <source>Intel C++ Compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a43fe57e64c611c07e7f0722fcf5e81fd02d7e" translate="yes" xml:space="preserve">
          <source>Intel HEX</source>
          <target state="translated">Intel HEX</target>
        </trans-unit>
        <trans-unit id="283a7688f976826bc81b0d15b139b8fb7bc39125" translate="yes" xml:space="preserve">
          <source>Intel HEX is a file format for representing binary data, mostly for programming various chips, as a text file. (See &lt;a href=&quot;http://en.wikipedia.org/wiki/.hex&quot;&gt;http://en.wikipedia.org/wiki/.hex&lt;/a&gt; for a detailed description, and &lt;a href=&quot;http://en.wikipedia.org/wiki/SREC_&quot;&gt;http://en.wikipedia.org/wiki/SREC_&lt;/a&gt;(file_format) for the Motorola S-record format, which can be unravelled using the same technique.) Each line begins with a colon (':') and is followed by a sequence of hexadecimal characters, specifying a byte count</source>
          <target state="translated">Intel HEX - это формат файла для представления двоичных данных, в основном для программирования различных микросхем, в виде текстового файла. (См. &lt;a href=&quot;http://en.wikipedia.org/wiki/.hex&quot;&gt;Http://en.wikipedia.org/wiki/.hex&lt;/a&gt; для подробного описания и &lt;a href=&quot;http://en.wikipedia.org/wiki/SREC_&quot;&gt;http://en.wikipedia.org/wiki/SREC_&lt;/a&gt; (file_format) для формата Motorola S-записи, который можно распутать используя ту же технику.) Каждая строка начинается с двоеточия (':') и сопровождается последовательностью шестнадцатеричных символов, определяющих количество байтов.</target>
        </trans-unit>
        <trans-unit id="a856ee1a019faac6da0b8db428273065b2de2b57" translate="yes" xml:space="preserve">
          <source>Intel HEX is a file format for representing binary data, mostly for programming various chips, as a text file. (See &lt;a href=&quot;https://en.wikipedia.org/wiki/.hex&quot;&gt;https://en.wikipedia.org/wiki/.hex&lt;/a&gt; for a detailed description, and &lt;a href=&quot;https://en.wikipedia.org/wiki/SREC_(file_format)&quot;&gt;https://en.wikipedia.org/wiki/SREC_(file_format)&lt;/a&gt; for the Motorola S-record format, which can be unravelled using the same technique.) Each line begins with a colon (':') and is followed by a sequence of hexadecimal characters, specifying a byte count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da544d1418799d25bfd09546e06754d3e5b1aeb3" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380d7ac3123e0e68ffb5963fc34784cfb9731163" translate="yes" xml:space="preserve">
          <source>Intended for use on command line with &lt;b&gt;-M&lt;/b&gt; option as a way of testing arbitrary scripts against an uninstalled version of a package.</source>
          <target state="translated">Предназначен для использования в командной строке с параметром &lt;b&gt;-M&lt;/b&gt; как способ тестирования произвольных скриптов на удаленной версии пакета.</target>
        </trans-unit>
        <trans-unit id="d75d6528effe0d95b951e2f70179256a5a75c5b0" translate="yes" xml:space="preserve">
          <source>Interacting with Perl from the Digital Command Language (DCL) shell often requires a different set of quotation marks than Unix shells do. For example:</source>
          <target state="translated">Взаимодействие с Perl из оболочки цифрового командного языка (DCL)часто требует другого набора кавычек,чем в оболочке Unix.Например:</target>
        </trans-unit>
        <trans-unit id="39c574bcdb6de6c0029ded259821021591e578be" translate="yes" xml:space="preserve">
          <source>Interaction with Extensions</source>
          <target state="translated">Взаимодействие с расширениями</target>
        </trans-unit>
        <trans-unit id="36743263147e4579bf65378679da63cd8385f8a2" translate="yes" xml:space="preserve">
          <source>Interactive Client with IO::Socket</source>
          <target state="translated">Интерактивный клиент с IO::Socket</target>
        </trans-unit>
        <trans-unit id="a16954cde7a599ddba4d577acd1b685762317ea3" translate="yes" xml:space="preserve">
          <source>Interactive mode:</source>
          <target state="translated">Интерактивный режим:</target>
        </trans-unit>
        <trans-unit id="bdcd0f2bf481dc531fd0fd8a96b470b347913b64" translate="yes" xml:space="preserve">
          <source>Interactive sessions maintain a lockfile, by default &lt;code&gt;~/.cpan/.&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; . Batch jobs can run without a lockfile and not disturb each other.</source>
          <target state="translated">В интерактивных сеансах сохраняется &lt;code&gt;~/.cpan/.&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; блокировки, по умолчанию ~ / .cpan /. замок . Пакетные задания могут выполняться без файла блокировки и не мешать друг другу.</target>
        </trans-unit>
        <trans-unit id="4049be05b318660a87d35f9664cb17d1ca51f690" translate="yes" xml:space="preserve">
          <source>Interactively supply an arbitrary &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;-e&lt;/code&gt; .</source>
          <target state="translated">В интерактивном режиме укажите произвольное &lt;code&gt;expression&lt;/code&gt; с помощью &lt;code&gt;-e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9612d7e5106a7533f6eeeb596274a84b741fb5b" translate="yes" xml:space="preserve">
          <source>Interactively supply an arbitrary &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;-e&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216f7ef95315bf7807890aa65847604f1201542d" translate="yes" xml:space="preserve">
          <source>Interal Utilities for autodie and Fatal! This module is not a part of autodie's public API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f4333051573407ec799c7bafee1c6ca09470f1b" translate="yes" xml:space="preserve">
          <source>Interestingly we get slightly different results, which is mostly because the algorithm which generates the report is different, even though the output file format was allegedly identical. The elapsed, user and system times are clearly showing the time it took for &lt;code&gt;Devel::Profiler&lt;/code&gt; to execute its own run, but the column listings feel more accurate somehow than the ones we had earlier from &lt;code&gt;Devel::DProf&lt;/code&gt; . The 102% figure has disappeared, for example. This is where we have to use the tools at our disposal, and recognise their pros and cons, before using them. Interestingly, the numbers of calls for each subroutine are identical in the two reports, it's the percentages which differ. As the author of &lt;code&gt;Devel::Proviler&lt;/code&gt; writes:</source>
          <target state="translated">Интересно, что мы получаем немного разные результаты, в основном потому, что алгоритм, который генерирует отчет, отличается, хотя формат выходного файла якобы был идентичным. Прошедшее, пользовательское и системное время ясно показывают время, которое потребовалось &lt;code&gt;Devel::Profiler&lt;/code&gt; для выполнения собственного прогона, но списки столбцов кажутся более точными, чем те, которые мы имели ранее из &lt;code&gt;Devel::DProf&lt;/code&gt; . Например, исчез показатель 102%. Именно здесь мы должны использовать имеющиеся в нашем распоряжении инструменты и распознавать их плюсы и минусы, прежде чем использовать их. Интересно, что количество вызовов для каждой подпрограммы в двух отчетах идентично, отличаются только проценты. Как пишет автор &lt;code&gt;Devel::Proviler&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="80ae20ece05d487021ccd9de0a68139efa803e3c" translate="yes" xml:space="preserve">
          <source>Interestingly we get slightly different results, which is mostly because the algorithm which generates the report is different, even though the output file format was allegedly identical. The elapsed, user and system times are clearly showing the time it took for &lt;code&gt;Devel::Profiler&lt;/code&gt; to execute its own run, but the column listings feel more accurate somehow than the ones we had earlier from &lt;code&gt;Devel::DProf&lt;/code&gt;. The 102% figure has disappeared, for example. This is where we have to use the tools at our disposal, and recognise their pros and cons, before using them. Interestingly, the numbers of calls for each subroutine are identical in the two reports, it's the percentages which differ. As the author of &lt;code&gt;Devel::Proviler&lt;/code&gt; writes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe9cc8d59c908d2dfc528838b1b4b5192a00c09" translate="yes" xml:space="preserve">
          <source>Interface Strategy</source>
          <target state="translated">Стратегия интерфейса</target>
        </trans-unit>
        <trans-unit id="e9bdbdb9fc26f525c1a8ecbeb7cc8ceb768f4d54" translate="yes" xml:space="preserve">
          <source>Interface between CPAN.pm and Kwalify.pm</source>
          <target state="translated">Интерфейс между CPAN.pm и Kwalify.pm</target>
        </trans-unit>
        <trans-unit id="7481e39dedf2d2f4c332b82f6502c28043c6929e" translate="yes" xml:space="preserve">
          <source>Interface to Berkeley DB</source>
          <target state="translated">Интерфейс к БД Беркли</target>
        </trans-unit>
        <trans-unit id="8e2ccff2c57048b71f1d307b6edb8f11b2c43b05" translate="yes" xml:space="preserve">
          <source>Interface to cwd from EMX. Used by &lt;code&gt;Cwd::cwd&lt;/code&gt; .</source>
          <target state="translated">Интерфейс к cwd из EMX. Используется &lt;code&gt;Cwd::cwd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5554dd630fd9035ebceb918f102c567832d75cf6" translate="yes" xml:space="preserve">
          <source>Interface to cwd from EMX. Used by &lt;code&gt;Cwd::cwd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6adf7d5cbdb0f3010f3086f3f294d7023f460422" translate="yes" xml:space="preserve">
          <source>Interface to get/set environment variables. Returns the current value as a Unicode string. The $uni_key and $uni_value arguments are expected to be Unicode strings as well. Passing &lt;code&gt;undef&lt;/code&gt; as $uni_value deletes the environment variable named $uni_key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae2466aff78641921461ec62c4d4ef5f0f5b074" translate="yes" xml:space="preserve">
          <source>Interface to zlib compression library</source>
          <target state="translated">Интерфейс к библиотеке сжатия zlib</target>
        </trans-unit>
        <trans-unit id="e346886e4b9cdfd6ef396ff466a7b37cd952cc6d" translate="yes" xml:space="preserve">
          <source>Interfaces to / Emulations of Other Programming Languages</source>
          <target state="translated">Интерфейсы/Эмуляции других языков программирования</target>
        </trans-unit>
        <trans-unit id="2188689d5ae5f33a21007d13b3dcb52813873257" translate="yes" xml:space="preserve">
          <source>Interfaces to some Win32 API Functions</source>
          <target state="translated">Интерфейсы к некоторым функциям Win32 API</target>
        </trans-unit>
        <trans-unit id="79cc6bbe2327c1551d1e5d40f07d9b83bc80ae14" translate="yes" xml:space="preserve">
          <source>Interleaving STDOUT/STDERR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033764585e80fa1ca47c0451c08faf861b72f44d" translate="yes" xml:space="preserve">
          <source>Intermediary representation of a table for use in specialized &lt;a href=&quot;Test::API::Context&quot;&gt;Test::API::Context&lt;/a&gt; methods which generate &lt;a href=&quot;Test2::EventFacet::Info&quot;&gt;Test2::EventFacet::Info&lt;/a&gt; facets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3fe500d640cf31fd9a657a78f2b102d9181133" translate="yes" xml:space="preserve">
          <source>Intermediary representation of a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20643cb83b71e3458cd8974c42d3daa3e1288a1" translate="yes" xml:space="preserve">
          <source>Internal Format</source>
          <target state="translated">Внутренний формат</target>
        </trans-unit>
        <trans-unit id="61d67a4869b5e28886ef542cee4befaab340cf82" translate="yes" xml:space="preserve">
          <source>Internal Functions</source>
          <target state="translated">Внутренние функции</target>
        </trans-unit>
        <trans-unit id="0cef48f59f7e2f51840fc46f9024c24cc33d8ed0" translate="yes" xml:space="preserve">
          <source>Internal Utility subroutines for autodie and Fatal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af8acca69afbd9c6d39218e0bb28d32d199f366" translate="yes" xml:space="preserve">
          <source>Internal configuration handling for CPAN.pm</source>
          <target state="translated">Внутренняя обработка конфигурации для CPAN.pm</target>
        </trans-unit>
        <trans-unit id="0806883110f04db9f91191aca94f31996b0d72ea" translate="yes" xml:space="preserve">
          <source>Internal debugging for CPAN.pm</source>
          <target state="translated">Внутренняя отладка для CPAN.pm</target>
        </trans-unit>
        <trans-unit id="4c898c3410ed0ae8d99f5b87b9783ee59e1feeaf" translate="yes" xml:space="preserve">
          <source>Internal debugging messages are enabled when $dl_debug is set true. Currently setting $dl_debug only affects the Perl side of the DynaLoader. These messages should help an application developer to resolve any DynaLoader usage problems.</source>
          <target state="translated">Внутренние отладочные сообщения включаются,когда для $dl_debug установлено значение true.В настоящее время установка $dl_debug влияет только на Perl-сторону DynaLoader.Эти сообщения должны помочь разработчику приложения решить любые проблемы использования DynaLoader.</target>
        </trans-unit>
        <trans-unit id="c2682bb60ef046fd0af9a65133fafcb74ba078ce" translate="yes" xml:space="preserve">
          <source>Internal disaster in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49405ebb7fde7f417d0e5c600dc6fa4e232257c1" translate="yes" xml:space="preserve">
          <source>Internal error: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d873f4a2f97ab05d24f6fa0f06cef45d8aeae3b7" translate="yes" xml:space="preserve">
          <source>Internal format</source>
          <target state="translated">Внутренний формат</target>
        </trans-unit>
        <trans-unit id="a7b06547359f2b157e33961f9b748082a4eb9b46" translate="yes" xml:space="preserve">
          <source>Internal function Hash::Util::FieldHash::_fieldhash</source>
          <target state="translated">Внутренняя функция Хэш::Util::FieldHash::_fieldhash</target>
        </trans-unit>
        <trans-unit id="5f0c27e8b0c0bee621d0e3ce9073f2744d23dd75" translate="yes" xml:space="preserve">
          <source>Internal function which adds the filter, based on the &lt;a href=&quot;filter_add&quot;&gt;filter_add&lt;/a&gt; argument type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b9dd26770184bcb91b7be8acd8ff5db510c8df" translate="yes" xml:space="preserve">
          <source>Internal function which adds the filter, based on the &lt;a href=&quot;http://search.cpan.org/perldoc/filter_add&quot;&gt;filter_add&lt;/a&gt; argument type.</source>
          <target state="translated">Внутренняя функция, которая добавляет фильтр на &lt;a href=&quot;http://search.cpan.org/perldoc/filter_add&quot;&gt;основе&lt;/a&gt; типа аргумента filter_add .</target>
        </trans-unit>
        <trans-unit id="5fee2b9c80ad50aec00177a91487a9d17942074f" translate="yes" xml:space="preserve">
          <source>Internal handling of tar archives for CPAN.pm</source>
          <target state="translated">Внутренняя обработка смоляных архивов для CPAN.pm</target>
        </trans-unit>
        <trans-unit id="8e0c690a448500e398abe5fb8a070cf47a50330b" translate="yes" xml:space="preserve">
          <source>Internal inconsistency in tracking vforks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7017225658a0f9fba19af865f848f427597c31a" translate="yes" xml:space="preserve">
          <source>Internal method for printing errors and warnings. If no options are given, simply prints &quot;@_&quot;. The following options are recognized and used to form the output:</source>
          <target state="translated">Внутренний способ печати ошибок и предупреждений.Если опции не заданы,просто распечатайте &quot;@_&quot;.Следующие опции распознаются и используются для формирования вывода:</target>
        </trans-unit>
        <trans-unit id="d524d9cfc678704c162c4cb4460355871a08ade5" translate="yes" xml:space="preserve">
          <source>Internal object used by Time::gmtime and Time::localtime</source>
          <target state="translated">Внутренний объект,используемый Time::gmtime и Time::localtime</target>
        </trans-unit>
        <trans-unit id="dec6a2c45a2bdd64a3ec8fcc2511727cc99b5b26" translate="yes" xml:space="preserve">
          <source>Internal queue support for CPAN.pm</source>
          <target state="translated">Поддержка внутренней очереди для CPAN.pm</target>
        </trans-unit>
        <trans-unit id="237da84ead8405b42fa85a7e388ec997365ff6da" translate="yes" xml:space="preserve">
          <source>Internal urp in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e13d391ba568ec11cf915e5927275eb2d03a56" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; are implemented with a real tied interface via &lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt;. The methods in that package will call back into these functions. However the usage of &lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; for this purpose might change in future releases. For instance this might be implemented by magic instead (would need an extension to mgvtbl).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de0eedbd92548d18bf918a068ea4b60732f9cf3" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; are implemented with a real tied interface via &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt;. The methods in that package will call back into these functions. However the usage of &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; for this purpose might change in future releases. For instance this might be implemented by magic instead (would need an extension to mgvtbl).</source>
          <target state="translated">Внутренне &lt;code&gt;%+&lt;/code&gt; и &lt;code&gt;%-&lt;/code&gt; реализованы с помощью реального связанного интерфейса через &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt; . Методы в этом пакете будут вызывать эти функции. Однако использование &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt; для этой цели может измениться в будущих выпусках. Например, вместо этого это может быть реализовано с помощью магии (потребуется расширение для mgvtbl).</target>
        </trans-unit>
        <trans-unit id="1b09ff7b696f900f84f4dabc94d78d0ec9f89714" translate="yes" xml:space="preserve">
          <source>Internally CPAN.pm uses the UTF-8 charset. If your terminal is expecting ISO-8859-1 charset, a converter can be activated by setting term_is_latin to a true value in your config file. One way of doing so would be</source>
          <target state="translated">Внутренний CPAN.pm использует кодовую таблицу UTF-8.Если ваш терминал ожидает кодовую таблицу ISO-8859-1,то преобразователь можно активировать,установив в вашем конфигурационном файле значение переменной term_is_latin в true.Одним из способов сделать это будет</target>
        </trans-unit>
        <trans-unit id="80378d1e7d2da0cf424eca7e07458848627808d4" translate="yes" xml:space="preserve">
          <source>Internally Encoding -&amp;gt; Unicode and Unicode -&amp;gt; Encoding Map looks like this;</source>
          <target state="translated">Внутреннее кодирование -&amp;gt; Юникод и Юникод -&amp;gt; Карта кодирования выглядит так;</target>
        </trans-unit>
        <trans-unit id="0270a1a0f07e6453af1ad3d10386c0ad1d3a4e99" translate="yes" xml:space="preserve">
          <source>Internally the Benchmark object holds timing values, described in &lt;a href=&quot;#NOTES&quot;&gt;&quot;NOTES&quot;&lt;/a&gt; below. The following methods can be used to access them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac21d3e9553672475ffa22a2c6fb0c3420e3cc6" translate="yes" xml:space="preserve">
          <source>Internally the Benchmark object holds timing values, described in &lt;a href=&quot;#NOTES&quot;&gt;NOTES&lt;/a&gt; below. The following methods can be used to access them:</source>
          <target state="translated">Внутри объекта Benchmark хранятся значения времени, описанные в &lt;a href=&quot;#NOTES&quot;&gt;ПРИМЕЧАНИЯХ&lt;/a&gt; ниже. Для доступа к ним можно использовать следующие методы:</target>
        </trans-unit>
        <trans-unit id="a523262f74789d99cb822f252d727c1f77360575" translate="yes" xml:space="preserve">
          <source>Internally this is set to &lt;code&gt;NULL&lt;/code&gt; unless a custom engine is specified in &lt;code&gt;$^H{regcomp}&lt;/code&gt; , Perl's own set of callbacks can be accessed in the struct pointed to by &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt; .</source>
          <target state="translated">Внутренне он установлен в &lt;code&gt;NULL&lt;/code&gt; , если пользовательский механизм не указан в &lt;code&gt;$^H{regcomp}&lt;/code&gt; , собственный набор обратных вызовов Perl может быть доступен в структуре, на которую указывает &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3120174b4db905355a8c95bdaa9494f155c0435" translate="yes" xml:space="preserve">
          <source>Internally this is set to &lt;code&gt;NULL&lt;/code&gt; unless a custom engine is specified in &lt;code&gt;$^H{regcomp}&lt;/code&gt;, Perl's own set of callbacks can be accessed in the struct pointed to by &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d5951d905f459e1665d8721f731d5fdbea427b7" translate="yes" xml:space="preserve">
          <source>Internally used by Encode</source>
          <target state="translated">Используется внутри компании Encode</target>
        </trans-unit>
        <trans-unit id="e76ceb49e27718344d5ee1ece08b4b732be4cccc" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::??::ISO_2022_*</source>
          <target state="translated">Внутренне используется Encode::??::ISO_2022_*.</target>
        </trans-unit>
        <trans-unit id="2bebc443d25f2caf9161712ece027e6af3e9145b" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::CN</source>
          <target state="translated">Внутренне используется Encode::CN</target>
        </trans-unit>
        <trans-unit id="449dbdf27f0aebf5b3ec15f606b3cbc5adf19193" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::JP</source>
          <target state="translated">Внутренне используется Encode::JP</target>
        </trans-unit>
        <trans-unit id="c43fcf4d81bc5dc37c2f1693cf4046ad46e8bf06" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::JP::2022_JP*</source>
          <target state="translated">Внутренне используется Encode::JP::2022_JP*.</target>
        </trans-unit>
        <trans-unit id="b7211781b63a5b485cff3f483aa4493e62335113" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::KR</source>
          <target state="translated">Внутренне используется Encode::KR</target>
        </trans-unit>
        <trans-unit id="87865024ef8da5f651d4b8f2dfd42f62371e839c" translate="yes" xml:space="preserve">
          <source>Internally, Perl currently uses either whatever the native eight-bit character set of the platform (for example Latin-1) is, defaulting to UTF-8, to encode Unicode strings. Specifically, if all code points in the string are &lt;code&gt;0xFF&lt;/code&gt; or less, Perl uses the native eight-bit character set. Otherwise, it uses UTF-8.</source>
          <target state="translated">Внутри Perl в настоящее время для кодирования строк Unicode использует любой восьмибитный набор символов платформы (например, Latin-1), по умолчанию UTF-8. В частности, если все кодовые точки в строке равны &lt;code&gt;0xFF&lt;/code&gt; или меньше, Perl использует собственный восьмибитный набор символов. В противном случае он использует UTF-8.</target>
        </trans-unit>
        <trans-unit id="5c9c0562b20651bd210573c4a3cd205f4716cb6a" translate="yes" xml:space="preserve">
          <source>Internally, native integer arithmetic (as provided by your C compiler) is used. This means that Perl's own semantics for arithmetic operations may not be preserved. One common source of trouble is the modulus of negative numbers, which Perl does one way, but your hardware may do another.</source>
          <target state="translated">Внутри используется нативная целочисленная арифметика (предоставляемая Вашим компилятором Си).Это означает,что собственная семантика Perl для арифметических операций может не сохраниться.Одним из распространенных источников неприятностей является модуль отрицательных чисел,который Perl делает в одном направлении,но ваше аппаратное обеспечение может делать в другом.</target>
        </trans-unit>
        <trans-unit id="b7fbfab5bd07346d2a0d188d0642fad2cf67e914" translate="yes" xml:space="preserve">
          <source>Internally, we often set this to an object of class Pod::Simple::Progress. That class is probably undocumented, but you may wish to look at its source.</source>
          <target state="translated">Внутри мы часто устанавливаем это в объект класса Pod::Simple::Progress.Вероятно,этот класс недокументирован,но вы можете захотеть взглянуть на его источник.</target>
        </trans-unit>
        <trans-unit id="4e1f47a6ca884b2242a2daaec979f4c9e4628f25" translate="yes" xml:space="preserve">
          <source>Internally, your computer represents floating-point numbers in binary. Digital (as in powers of two) computers cannot store all numbers exactly. Some real numbers lose precision in the process. This is a problem with how computers store numbers and affects all computer languages, not just Perl.</source>
          <target state="translated">Внутренне ваш компьютер представляет числа с плавающей точкой в двоичном виде.Цифровые (как в полномочиях двух)компьютеры не могут хранить все числа точно.Некоторые реальные числа теряют точность в процессе.Это проблема,связанная с тем,как компьютеры хранят числа,и затрагивает все компьютерные языки,а не только Perl.</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="5b92377b87e725e0dd0672bfd114d434b8fa7df8" translate="yes" xml:space="preserve">
          <source>Internals - Reserved special namespace for internals related functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3272f534c54bc991446f61c8eb13e09347dc7ac" translate="yes" xml:space="preserve">
          <source>Internals and C Language Interface</source>
          <target state="translated">Интернациональный и языковой интерфейс C</target>
        </trans-unit>
        <trans-unit id="221f3b6d81d4077e193de47fb71efa7ac821cbb0" translate="yes" xml:space="preserve">
          <source>International Organization for Standardization &lt;a href=&quot;http://www.iso.ch/&quot;&gt;http://www.iso.ch/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e7980ec1f234461f5c5cc8a7f141d36197c7ac" translate="yes" xml:space="preserve">
          <source>Internationalisation</source>
          <target state="translated">Internationalisation</target>
        </trans-unit>
        <trans-unit id="8f2a515a6b360e659af1aa0a2bbe7a1464bcd610" translate="yes" xml:space="preserve">
          <source>Internationalization (I18N) and localization (L10N) are supported at least in principle even on EBCDIC platforms. The details are system-dependent and discussed under the &lt;a href=&quot;#OS-ISSUES&quot;&gt;&quot;OS ISSUES&quot;&lt;/a&gt; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31cadca51461dbf1ea6607e7802c11fbe6ff93d3" translate="yes" xml:space="preserve">
          <source>Internationalization (I18N) and localization (L10N) are supported at least in principle even on EBCDIC platforms. The details are system-dependent and discussed under the &lt;a href=&quot;#OS-ISSUES&quot;&gt;OS ISSUES&lt;/a&gt; section below.</source>
          <target state="translated">Интернационализация (I18N) и локализация (L10N) поддерживаются по крайней мере в принципе даже на платформах EBCDIC. Детали зависят от системы и обсуждаются ниже в разделе &lt;a href=&quot;#OS-ISSUES&quot;&gt;ПРОБЛЕМЫ ОС&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06442c59ec9f24811c5d9eb359e2f21b42d4c792" translate="yes" xml:space="preserve">
          <source>Internationalization and Locale</source>
          <target state="translated">Интернационализация и локализация</target>
        </trans-unit>
        <trans-unit id="46c7578271b4ab36db28528f49822a53c8afcb81" translate="yes" xml:space="preserve">
          <source>Internationalization, as defined in the C and POSIX standards, can be criticized as incomplete and ungainly. They also have a tendency, like standards groups, to divide the world into nations, when we all know that the world can equally well be divided into bankers, bikers, gamers, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7421cfdcae4df82cd94a16e9b01d52930cf4a8c" translate="yes" xml:space="preserve">
          <source>Internationalization, as defined in the C and POSIX standards, can be criticized as incomplete, ungainly, and having too large a granularity. (Locales apply to a whole process, when it would arguably be more useful to have them apply to a single thread, window group, or whatever.) They also have a tendency, like standards groups, to divide the world into nations, when we all know that the world can equally well be divided into bankers, bikers, gamers, and so on.</source>
          <target state="translated">Интернационализация,как она определена в стандартах С и POSIX,может быть подвергнута критике как неполная,непривлекательная и имеющая слишком большую гранулометричность.(Локализации применимы ко всему процессу,когда,вероятно,было бы более полезным,чтобы они применялись к одному потоку,группе окон или чему-либо еще).Они также имеют тенденцию,как и стандартные группы,делить мир на нации,когда все мы знаем,что мир можно в равной степени разделить на банкиров,байкеров,геймеров и так далее.</target>
        </trans-unit>
        <trans-unit id="c150f55df149b9e7642e03589abcd3eb462548e7" translate="yes" xml:space="preserve">
          <source>Internet Assigned Numbers Authority &lt;a href=&quot;http://www.iana.org/&quot;&gt;http://www.iana.org/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e18cc52391003fa5303fbdac90ff76add1db9f3" translate="yes" xml:space="preserve">
          <source>Internet Line Terminators</source>
          <target state="translated">Линейные интернет-терминаторы</target>
        </trans-unit>
        <trans-unit id="1ace89f6b9c54bf536f959a6a92a52a0f9188777" translate="yes" xml:space="preserve">
          <source>Internet Protocol, or Intellectual Property.</source>
          <target state="translated">Интернет-протокол,или Интеллектуальная собственность.</target>
        </trans-unit>
        <trans-unit id="6aafd8134caf0f288faa302a3a8189c60711fc0c" translate="yes" xml:space="preserve">
          <source>Internet TCP Clients and Servers</source>
          <target state="translated">Клиенты и серверы TCP Интернета</target>
        </trans-unit>
        <trans-unit id="f4a9147272ff83f2cf2d940d5441a60e554132ae" translate="yes" xml:space="preserve">
          <source>Internet language tags, as defined in RFC 3066, are a formalism for denoting human languages. The two-letter ISO 639-1 language codes are well known (as &quot;en&quot; for English), as are their forms when qualified by a country code (&quot;en-US&quot;). Less well-known are the arbitrary-length non-ISO codes (like &quot;i-mingo&quot;), and the recently (in 2001) introduced three-letter ISO-639-2 codes.</source>
          <target state="translated">Языковые теги Интернета,как они определены в RFC 3066,являются формализмом для обозначения человеческих языков.Двубуквенные коды языков ИСО 639-1 хорошо известны (как &quot;en&quot; для английского языка),так же как и их формы,когда они квалифицируются кодом страны (&quot;en-US&quot;).Менее известны не-ISO коды произвольной длины (например,&quot;i-mingo&quot;),а недавно (в 2001 году)были введены трехбуквенные коды ИСО-639-2.</target>
        </trans-unit>
        <trans-unit id="d1f27df0b0f458a0b4241c741d83baaaba6cee55" translate="yes" xml:space="preserve">
          <source>Interoperating with Pbzip2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645bb0cb3effc0c464d1fa2ee02c7473d9c16ab6" translate="yes" xml:space="preserve">
          <source>Interpolated scalars and arrays are converted internally to the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;.&quot;&lt;/code&gt; catenation operations. Thus, &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; becomes:</source>
          <target state="translated">Интерполированные скаляры и массивы внутренне преобразуются в &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&quot;.&quot;&lt;/code&gt; цепные операции. Таким образом, &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; становится:</target>
        </trans-unit>
        <trans-unit id="7b7796550c9a05d4af98c0f9b17a2e334cf3e552" translate="yes" xml:space="preserve">
          <source>Interpolated scalars and arrays are converted internally to the &lt;code&gt;join&lt;/code&gt; and &lt;code&gt;&quot;.&quot;&lt;/code&gt; catenation operations. Thus, &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; becomes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc8312ce8a1d5c2a7ed5ed38a0c5c565ab477c8" translate="yes" xml:space="preserve">
          <source>Interpolating an array or slice interpolates the elements in order, separated by the value of &lt;code&gt;$&quot;&lt;/code&gt; , so is equivalent to interpolating &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; $&quot;, @array&lt;/code&gt; . &quot;Punctuation&quot; arrays such as &lt;code&gt;@*&lt;/code&gt; are usually interpolated only if the name is enclosed in braces &lt;code&gt;@{*}&lt;/code&gt;, but the arrays &lt;code&gt;@_&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; , and &lt;code&gt;@-&lt;/code&gt; are interpolated even without braces.</source>
          <target state="translated">Интерполяция массива или среза интерполирует элементы по порядку, разделенные значением &lt;code&gt;$&quot;&lt;/code&gt; , что эквивалентно интерполяции &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; $&quot;, @array&lt;/code&gt; . Массивы &amp;laquo;знаков препинания&amp;raquo;, такие как &lt;code&gt;@*&lt;/code&gt; , обычно интерполируются только в том случае, если имя заключено в фигурные скобки &lt;code&gt;@{*}&lt;/code&gt; , а массивы &lt;code&gt;@_&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; и &lt;code&gt;@-&lt;/code&gt; интерполируются даже без фигурных скобок.</target>
        </trans-unit>
        <trans-unit id="c89b1d270440efce1fe96c18e4bb21c6ce7e1f28" translate="yes" xml:space="preserve">
          <source>Interpolating an array or slice interpolates the elements in order, separated by the value of &lt;code&gt;$&quot;&lt;/code&gt;, so is equivalent to interpolating &lt;code&gt;join $&quot;, @array&lt;/code&gt;. &quot;Punctuation&quot; arrays such as &lt;code&gt;@*&lt;/code&gt; are usually interpolated only if the name is enclosed in braces &lt;code&gt;@{*}&lt;/code&gt;, but the arrays &lt;code&gt;@_&lt;/code&gt;, &lt;code&gt;@+&lt;/code&gt;, and &lt;code&gt;@-&lt;/code&gt; are interpolated even without braces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="938c8acd8c9d50a2d8734d4eebce781a661d4c88" translate="yes" xml:space="preserve">
          <source>Interpolation in patterns has several quirks: &lt;code&gt;$|&lt;/code&gt; , &lt;code&gt;$(&lt;/code&gt; , &lt;code&gt;$)&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; and &lt;code&gt;@-&lt;/code&gt; are not interpolated, and constructs &lt;code&gt;$var[SOMETHING]&lt;/code&gt; are voted (by several different estimators) to be either an array element or &lt;code&gt;$var&lt;/code&gt; followed by an RE alternative. This is where the notation &lt;code&gt;${arr[$bar]}&lt;/code&gt; comes handy: &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; is interpreted as array element &lt;code&gt;-9&lt;/code&gt; , not as a regular expression from the variable &lt;code&gt;$arr&lt;/code&gt; followed by a digit, which would be the interpretation of &lt;code&gt;/$arr[0-9]/&lt;/code&gt; . Since voting among different estimators may occur, the result is not predictable.</source>
          <target state="translated">У интерполяции в паттернах есть несколько причуд: &lt;code&gt;$|&lt;/code&gt; , &lt;code&gt;$(&lt;/code&gt; , &lt;code&gt;$)&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; и &lt;code&gt;@-&lt;/code&gt; не интерполируются, и конструкции &lt;code&gt;$var[SOMETHING]&lt;/code&gt; признаны (несколькими разными оценщиками) либо элементом массива, либо &lt;code&gt;$var&lt;/code&gt; за которым следует альтернатива RE. Здесь пригодится обозначение &lt;code&gt;${arr[$bar]}&lt;/code&gt; : &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; интерпретируется как элемент массива &lt;code&gt;-9&lt;/code&gt; , а не как регулярное выражение из переменной &lt;code&gt;$arr&lt;/code&gt; за которым следует цифра, что будет интерпретацией &lt;code&gt;/$arr[0-9]/&lt;/code&gt; . Поскольку может происходить голосование между разными оценщиками, результат непредсказуем.</target>
        </trans-unit>
        <trans-unit id="39ed28583e84f6b41afb2ccf6f513cf965009d02" translate="yes" xml:space="preserve">
          <source>Interpolation in patterns has several quirks: &lt;code&gt;$|&lt;/code&gt;, &lt;code&gt;$(&lt;/code&gt;, &lt;code&gt;$)&lt;/code&gt;, &lt;code&gt;@+&lt;/code&gt; and &lt;code&gt;@-&lt;/code&gt; are not interpolated, and constructs &lt;code&gt;$var[SOMETHING]&lt;/code&gt; are voted (by several different estimators) to be either an array element or &lt;code&gt;$var&lt;/code&gt; followed by an RE alternative. This is where the notation &lt;code&gt;${arr[$bar]}&lt;/code&gt; comes handy: &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; is interpreted as array element &lt;code&gt;-9&lt;/code&gt;, not as a regular expression from the variable &lt;code&gt;$arr&lt;/code&gt; followed by a digit, which would be the interpretation of &lt;code&gt;/$arr[0-9]/&lt;/code&gt;. Since voting among different estimators may occur, the result is not predictable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b1ed4106cc19f9516b8700eff6b51f8a50bc7e" translate="yes" xml:space="preserve">
          <source>Interpret input as a hexadecimal string. A &quot;0x&quot; or &quot;x&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">Интерпретируйте ввод как шестнадцатеричную строку.Префикс &quot;0x&quot; или &quot;x&quot; необязателен.Символ подчеркивания может быть помещен сразу после префикса,если он присутствует,или между любыми двумя цифрами.Если ввод недействителен,возвращается NaN.</target>
        </trans-unit>
        <trans-unit id="e3c6ad2b94e17e8ed6ad8c9f4b49132292140f2b" translate="yes" xml:space="preserve">
          <source>Interpret input as a hexadecimal string. A prefix (&quot;0b&quot; or &quot;b&quot;, ignoring case) is optional. A single underscore character (&quot;_&quot;) may be placed between any two digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ae7a8b8abddae828432695e232afb3455b5e34" translate="yes" xml:space="preserve">
          <source>Interpret input as a hexadecimal string.A prefix (&quot;0x&quot;, &quot;x&quot;, ignoring case) is optional. A single underscore character (&quot;_&quot;) may be placed between any two digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72044a388d08d12a68e1993790c0be63bb048467" translate="yes" xml:space="preserve">
          <source>Interpret input as an octal string. A single underscore character (&quot;_&quot;) may be placed between any two digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a91bb371c7a5d73707f3bf850be5ff775864c2" translate="yes" xml:space="preserve">
          <source>Interpret results strictly.</source>
          <target state="translated">Строго интерпретируйте результаты.</target>
        </trans-unit>
        <trans-unit id="7bc19d89b05f97e1ecec77b1cd80333965f8eac8" translate="yes" xml:space="preserve">
          <source>Interpret the input as a binary string. A &quot;0b&quot; or &quot;b&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">Интерпретируйте вход как двоичную строку.Префикс &quot;0b&quot; или &quot;b&quot; необязателен.Символ подчеркивания может быть помещен сразу после префикса,если он присутствует,или между любыми двумя цифрами.Если вход является недействительным,возвращается NaN.</target>
        </trans-unit>
        <trans-unit id="d76880ffa69808c7f715164c615fdf27a78c1785" translate="yes" xml:space="preserve">
          <source>Interpret the input as a byte string, assuming big endian byte order. The output is always a non-negative, finite integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="453c8b8b13743efe964db57b55ed8957df8eedf7" translate="yes" xml:space="preserve">
          <source>Interpret the input as a value encoded as described in IEEE754-2008. The input can be given as a byte string, hex string or binary string. The input is assumed to be in big-endian byte-order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb708839bb76c97a78f59fb0d153db3bcac65ad" translate="yes" xml:space="preserve">
          <source>Interpret the input as an octal string and return the corresponding value. A &quot;0&quot; (zero) prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">Интерпретируйте ввод как восьмеричную строку и верните соответствующее значение.Префикс &quot;0&quot; (ноль)необязателен.Символ подчеркивания может быть помещен сразу после префикса,если он присутствует,или между любыми двумя цифрами.Если вход является недействительным,возвращается NaN.</target>
        </trans-unit>
        <trans-unit id="b29af10220daeb6f80d20ec4774b2643643e00f8" translate="yes" xml:space="preserve">
          <source>Interpretation of the &lt;code&gt;gecos&lt;/code&gt; field varies between systems, but traditionally holds 4 comma-separated fields containing the user's full name, office location, work phone number, and home phone number. An &lt;code&gt;&amp;amp;&lt;/code&gt; in the gecos field should be replaced by the user's properly capitalized login &lt;code&gt;name&lt;/code&gt; . The &lt;code&gt;shell&lt;/code&gt; field, if blank, must be assumed to be</source>
          <target state="translated">Интерпретация поля &lt;code&gt;gecos&lt;/code&gt; зависит от системы, но обычно содержит 4 поля, разделенных запятыми, которые содержат полное имя пользователя, местонахождение офиса, номер рабочего и домашнего телефона. &lt;code&gt;&amp;amp;&lt;/code&gt; в области GECOS должны быть заменено правильно капитализированным входом пользователя &lt;code&gt;name&lt;/code&gt; . Поле &lt;code&gt;shell&lt;/code&gt; , если оно пустое, должно рассматриваться как</target>
        </trans-unit>
        <trans-unit id="0976c6eb851bd29a7c13436a47fce586e64022a2" translate="yes" xml:space="preserve">
          <source>Interpretation of the &lt;code&gt;gecos&lt;/code&gt; field varies between systems, but traditionally holds 4 comma-separated fields containing the user's full name, office location, work phone number, and home phone number. An &lt;code&gt;&amp;amp;&lt;/code&gt; in the gecos field should be replaced by the user's properly capitalized login &lt;code&gt;name&lt;/code&gt;. The &lt;code&gt;shell&lt;/code&gt; field, if blank, must be assumed to be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="920aa278d5fde4bc26b94a177b294481884c28c0" translate="yes" xml:space="preserve">
          <source>Interpretation of the buffer's octets can be abstracted out by using the slightly higher-level functions &lt;a href=&quot;#lex_peek_unichar&quot;&gt;&quot;lex_peek_unichar&quot;&lt;/a&gt; and &lt;a href=&quot;#lex_read_unichar&quot;&gt;&quot;lex_read_unichar&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cfbb6233c7812b488cce8d6bd3af2af9ab5bc6" translate="yes" xml:space="preserve">
          <source>Interpretation of the buffer's octets can be abstracted out by using the slightly higher-level functions &lt;a href=&quot;#lex_peek_unichar&quot;&gt;lex_peek_unichar&lt;/a&gt; and &lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt;.</source>
          <target state="translated">Интерпретацию октетов буфера можно абстрагировать, используя функции чуть более высокого уровня &lt;a href=&quot;#lex_peek_unichar&quot;&gt;lex_peek_unichar&lt;/a&gt; и &lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92d3f8b03230be860eb13ba99ed5e322ec25a6b0" translate="yes" xml:space="preserve">
          <source>Interpreter</source>
          <target state="translated">Interpreter</target>
        </trans-unit>
        <trans-unit id="b588c5a0249a1b98f3880c0e5147ba7d315538dd" translate="yes" xml:space="preserve">
          <source>Interpreter embedded in larger application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e94340be7381aa50cefb2bdc5e7587b72758de" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding numeric value. If EXPR is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c7c558d92a61d6a4e1c001e4a147b288928483" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding value. (To convert strings that might start with either &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; , or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;#oct&quot;&gt;oct&lt;/a&gt;.) If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">Интерпретирует EXPR как шестнадцатеричную строку и возвращает соответствующее значение. (Чтобы преобразовать строки, которые могут начинаться с &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; или &lt;code&gt;0b&lt;/code&gt; , см. &lt;a href=&quot;#oct&quot;&gt;Окт&lt;/a&gt; .) Если EXPR опущен, используется &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80995a80c008a9c2a1eb866370afb34599cdd244" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding value. (To convert strings that might start with either &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; , or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;.) If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">Интерпретирует EXPR как шестнадцатеричную строку и возвращает соответствующее значение. (Чтобы преобразовать строки, которые могут начинаться с &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; или &lt;code&gt;0b&lt;/code&gt; , см. &lt;a href=&quot;oct&quot;&gt;Окт&lt;/a&gt; .) Если EXPR опущен, используется &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58710e925b06b5bcd617d0a02276a6d507de1826" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as an octal string and returns the corresponding value. (If EXPR happens to start off with &lt;code&gt;0x&lt;/code&gt; , interprets it as a hex string. If EXPR starts off with &lt;code&gt;0b&lt;/code&gt;, it is interpreted as a binary string. Leading whitespace is ignored in all three cases.) The following will handle decimal, binary, octal, and hex in standard Perl notation:</source>
          <target state="translated">Интерпретирует EXPR как восьмеричную строку и возвращает соответствующее значение. (Если EXPR начинается с &lt;code&gt;0x&lt;/code&gt; , интерпретируется как шестнадцатеричная строка. Если EXPR начинается с &lt;code&gt;0b&lt;/code&gt; , он интерпретируется как двоичная строка. Начальные пробелы игнорируются во всех трех случаях.) Следующее будет обрабатывать десятичные, двоичные, восьмеричный и шестнадцатеричный в стандартной нотации Perl:</target>
        </trans-unit>
        <trans-unit id="ae1424465a8d50534920bcc14b8cbe5ef86892ac" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as an octal string and returns the corresponding value. (If EXPR happens to start off with &lt;code&gt;0x&lt;/code&gt;, interprets it as a hex string. If EXPR starts off with &lt;code&gt;0b&lt;/code&gt;, it is interpreted as a binary string. Leading whitespace is ignored in all three cases.) The following will handle decimal, binary, octal, and hex in standard Perl notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d683f7db5d587ede8e14b4d88e6c417a5847d7" translate="yes" xml:space="preserve">
          <source>Interprocess Communication (IPC)</source>
          <target state="translated">Межпроцессное взаимодействие (IPC)</target>
        </trans-unit>
        <trans-unit id="1e11457cea032ab0c21c71c69e4211f081e8849e" translate="yes" xml:space="preserve">
          <source>Interprocess Communication.</source>
          <target state="translated">Межпроцессное взаимодействие.</target>
        </trans-unit>
        <trans-unit id="a5a495c9d0578a0494f49fc6ace5fd6e9fed4e9a" translate="yes" xml:space="preserve">
          <source>Interrupting IO</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58447a233c711f903a2587b91bb291042f4b45da" translate="yes" xml:space="preserve">
          <source>Intersection is used generally for getting the common characters matched by two (or more) classes. It's important to remember not to use &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; for the first set; that would be intersecting with nothing, resulting in an empty set.</source>
          <target state="translated">Пересечение обычно используется для сопоставления общих символов двумя (или более) классами. Важно помнить, что нельзя использовать &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; для первого набора; это будет ни с чем не пересекаться, что приведет к пустому множеству.</target>
        </trans-unit>
        <trans-unit id="d34174297460fdd67bf61d2f8749421841769688" translate="yes" xml:space="preserve">
          <source>Intersection is used generally for getting the common characters matched by two (or more) classes. It's important to remember not to use &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; for the first set; that would be intersecting with nothing, resulting in an empty set. (Similarly using &lt;code&gt;&quot;-&quot;&lt;/code&gt; for the first set does nothing).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4724a76d8bc17dfefb1daee3b6d5be588f4c613" translate="yes" xml:space="preserve">
          <source>Introduce the</source>
          <target state="translated">Представить</target>
        </trans-unit>
        <trans-unit id="dde62d185b627cf5b7ce046a41566f84e22267ed" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.005</source>
          <target state="translated">Введено в Perl 5.005</target>
        </trans-unit>
        <trans-unit id="25641bc26420a80c8ddbcf38615ca35ce5d7cb63" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.10.0</source>
          <target state="translated">Введено в Perl 5.10.0</target>
        </trans-unit>
        <trans-unit id="b91aad730399f200ac6a5b6dba6fed9c61c025f5" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.12</source>
          <target state="translated">Введено на Perl 5.12</target>
        </trans-unit>
        <trans-unit id="be57168adcd5cd07b75f1c9b6124df0daf76c3bd" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.14.0</source>
          <target state="translated">Введено в Perl 5.14.0</target>
        </trans-unit>
        <trans-unit id="b294ac0a4f8c5992774c8112441dc302d5816a1f" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.20.0</source>
          <target state="translated">Введено в Perl 5.20.0</target>
        </trans-unit>
        <trans-unit id="0c3a6017cbcf96eeafb4387eedc602152339297c" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.22.0</source>
          <target state="translated">Введено в Perl 5.22.0</target>
        </trans-unit>
        <trans-unit id="7993785cfbc9e7981dcd229895be4a20fdb9620c" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.6.0</source>
          <target state="translated">Введено в Perl 5.6.0</target>
        </trans-unit>
        <trans-unit id="31cd408fa26c1acb52eade6304b9c5ef7d3abe35" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.6.1</source>
          <target state="translated">Введено на Perl 5.6.1</target>
        </trans-unit>
        <trans-unit id="51378bbd1f0bc4027eee05ffb1e7f6b0f83420b0" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.8.0</source>
          <target state="translated">Введено в Perl 5.8.0</target>
        </trans-unit>
        <trans-unit id="79667c9718432940922f2e42f6facd3cdd4d3deb" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.9.0</source>
          <target state="translated">Введено в Perl 5.9.0</target>
        </trans-unit>
        <trans-unit id="bb8c7b3973c6116a9525785ab93801f9d4d4fd02" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.9.2</source>
          <target state="translated">Введено на Perl 5.9.2</target>
        </trans-unit>
        <trans-unit id="091f1001c9d6a40187930fa44574a4f653880f2a" translate="yes" xml:space="preserve">
          <source>Introduced in perl 5.25.12.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef8951301d241cbc829612e64580020e610d91f" translate="yes" xml:space="preserve">
          <source>Introduced in: 5.11.2</source>
          <target state="translated">Введен в:5.11.2</target>
        </trans-unit>
        <trans-unit id="a01d17d00de94eaa77554eca767e361f42130168" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.10</source>
          <target state="translated">Введен в:Perl 5.10</target>
        </trans-unit>
        <trans-unit id="1e5c7e1205af583a405c6c00903c26fad40a5e6a" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.11.2</source>
          <target state="translated">Введен в:Perl 5.11.2</target>
        </trans-unit>
        <trans-unit id="d272e647109f1769e2b49a3e24be3094dd708435" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.18</source>
          <target state="translated">Введен в:Perl 5.18</target>
        </trans-unit>
        <trans-unit id="a5210098032cc4bc65f6c8263851cc2d7666b61d" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.22.0</source>
          <target state="translated">Введен в:Perl 5.22.0</target>
        </trans-unit>
        <trans-unit id="5a3a1683287083d64acee02ab986003bcf802274" translate="yes" xml:space="preserve">
          <source>Introduced just after perl5.7.0, this is a re-implementation of the above abstraction which allows perl more control over how IO is done as it decouples IO from the way the operating system and C library choose to do things. For USE_PERLIO PerlIO * has an extra layer of indirection - it is a pointer-to-a-pointer. This allows the PerlIO * to remain with a known value while swapping the implementation around underneath</source>
          <target state="translated">Введенная сразу после версии perl5.7.0,это повторная реализация вышеприведенной абстракции,которая позволяет perl больше контроля над тем,как выполняется IO,так как она отделяет IO от того,как операционная система и библиотека C выбирают способ выполнения задач.Для USE_PERLIO PerlIO*имеет дополнительный слой индирекции-это указатель на указатель.Это позволяет PerlIO*оставаться с известным значением при замене реализации,расположенной под ним.</target>
        </trans-unit>
        <trans-unit id="bc2d2fa71d8eaea749023a72cddaf418fe1cb149" translate="yes" xml:space="preserve">
          <source>Introduces a catch block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;&quot;Exception Handling&quot; in perlguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df90fec901ab6b3e3c92b7090f061ccf2d6c4aa2" translate="yes" xml:space="preserve">
          <source>Introduces a catch block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">Вводит блок захвата. См. Раздел &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Обработка исключений в perlguts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c2f1d96cf5d9698341444cc5bc1eb344088014" translate="yes" xml:space="preserve">
          <source>Introducing (non-read-only) globals</source>
          <target state="translated">Представляющие (не предназначенные только для чтения)шаровидные шарики</target>
        </trans-unit>
        <trans-unit id="154cc0bb0700575719a65b65f0bfb0fc9a438358" translate="yes" xml:space="preserve">
          <source>Introducing read-only (const) globals is okay, as long as you verify with e.g. &lt;code&gt;nm libperl.a|egrep -v ' [TURtr] '&lt;/code&gt; (if your &lt;code&gt;nm&lt;/code&gt; has BSD-style output) that the data you added really is read-only. (If it is, it shouldn't show up in the output of that command.)</source>
          <target state="translated">Внедрение глобальных &lt;code&gt;nm libperl.a|egrep -v ' [TURtr] '&lt;/code&gt; только для чтения (const) - это нормально, если вы проверяете, например, с помощью nm libperl.a | egrep -v '[TURtr]' (если ваш &lt;code&gt;nm&lt;/code&gt; имеет вывод в стиле BSD), что добавленные вами данные действительно читаются - только. (Если это так, он не должен отображаться в выводе этой команды.)</target>
        </trans-unit>
        <trans-unit id="dcba11e20d56606a737ad2a86071e282fcf184cf" translate="yes" xml:space="preserve">
          <source>Introducing variables inside for()</source>
          <target state="translated">Введение переменных внутри функции for()</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="c3cbe25b5093a9e955ec87889df443c3c88a6700" translate="yes" xml:space="preserve">
          <source>Introduction to the context stack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad0875833b290c88f0275f52c45f410d897ca9f" translate="yes" xml:space="preserve">
          <source>Introductory Texts</source>
          <target state="translated">Вводные тексты</target>
        </trans-unit>
        <trans-unit id="35b4535865312e74cc4ee5fddabecf0f89eff7b1" translate="yes" xml:space="preserve">
          <source>Invalid %s attribute: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16e49525bf4e99622a920415ffb99daaab7bb8c" translate="yes" xml:space="preserve">
          <source>Invalid %s attributes: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f278621344da2113b386e7cf493f5b7effda7cb6" translate="yes" xml:space="preserve">
          <source>Invalid =encoding syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ccfdff90507fec490f3681db3843b0d6286ad3" translate="yes" xml:space="preserve">
          <source>Invalid [] range &quot;%s&quot; in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ca1b8b000c05ddca3141e99f4a127d6bf62783" translate="yes" xml:space="preserve">
          <source>Invalid \0 character in %s for %s: %s\0%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5167b1a82e18cf454d4bc0f759f3a654b3597c1" translate="yes" xml:space="preserve">
          <source>Invalid alias name %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2a343ef8d4bd75601d86b329b7a01d8c329447" translate="yes" xml:space="preserve">
          <source>Invalid alias name %s in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ab829daff8a5e5f6392ceed1cb4afa7bad1191" translate="yes" xml:space="preserve">
          <source>Invalid attribute name %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de5bc9920e09cfc5aa332c66ec4d5cfec265952" translate="yes" xml:space="preserve">
          <source>Invalid attribute name %s in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05e151899283ad3fa0d3b17b289c6f5652fe00d4" translate="yes" xml:space="preserve">
          <source>Invalid character in \N{...}; marked by &amp;lt;-- HERE in \N{%s}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2863c47889763b20775fa1947348a4c08ab6c002" translate="yes" xml:space="preserve">
          <source>Invalid character in charnames alias definition; marked by &amp;lt;-- HERE in '%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71b8ff5c88697d1a550d6673237e1107c606759" translate="yes" xml:space="preserve">
          <source>Invalid conversion in %s: &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da241ea775f4ffbb146ef9175cab747e1e17f61" translate="yes" xml:space="preserve">
          <source>Invalid errors setting &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88ec4ba5b78e52ef0ab2ed660f408ead1951cbe" translate="yes" xml:space="preserve">
          <source>Invalid escape in the specified encoding in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519c9635790d830978d5164b3ad7937b453ade67" translate="yes" xml:space="preserve">
          <source>Invalid hexadecimal number in \N{U+...}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4e943158cfd55f7caa089383100312254493ec" translate="yes" xml:space="preserve">
          <source>Invalid hexadecimal number in \N{U+...} in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87131ca7be09c630d75c4fef49d87656455519cb" translate="yes" xml:space="preserve">
          <source>Invalid module name %s with -%c option: contains single ':'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cafc147d5721e32ab438b2e1facd6104c69c8cdb" translate="yes" xml:space="preserve">
          <source>Invalid mro name: '%s'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="997bb1def2a65589fb34cef75e7877e3c194aa47" translate="yes" xml:space="preserve">
          <source>Invalid negative number (%s) in chr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ebf8d124c561f25f30e95ab6d9cc2965fe72ff" translate="yes" xml:space="preserve">
          <source>Invalid number '%s' for -C option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b24f046499eeb08ade4a703bdfb2ca0850444e" translate="yes" xml:space="preserve">
          <source>Invalid quantifier in {,} in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c55ed435afff8d41b70ade097c0698032d0c012" translate="yes" xml:space="preserve">
          <source>Invalid quote specification &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5c174cc04f03d39141a30a0cfc0c41bc31bb3f" translate="yes" xml:space="preserve">
          <source>Invalid range &quot;%s&quot; in transliteration operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7bf96d82c63323749d7987b1d0a19d37b194c78" translate="yes" xml:space="preserve">
          <source>Invalid reference to group in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b451f3135fd8389070687455f7342fb7a8b6308" translate="yes" xml:space="preserve">
          <source>Invalid separator character %s in PerlIO layer specification %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97ba0ffc9967cd5abf07936f7edcde4477f44be" translate="yes" xml:space="preserve">
          <source>Invalid separator character %s in attribute list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="132cab989b11d24a0daa70576a5563553614029c" translate="yes" xml:space="preserve">
          <source>Invalid strict version format (%s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac063110370f25128c7648841d4d47e40ca1a6f" translate="yes" xml:space="preserve">
          <source>Invalid type '%s' in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40fac60217e12bb0c9148c5e13124cc1ea622f52" translate="yes" xml:space="preserve">
          <source>Invalid version format (%s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a2b722bc1d83834529dc472a04775d93256603" translate="yes" xml:space="preserve">
          <source>Invalid version object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7111e9430dac55fd4a6c0b16ea2e92ba2187d8a" translate="yes" xml:space="preserve">
          <source>Invalidates method caching on any child classes of the given stash, so that they might notice the changes in this one.</source>
          <target state="translated">Недействительный метод кэширования на любых классах детей данного тайника,чтобы они могли заметить изменения в этом методе.</target>
        </trans-unit>
        <trans-unit id="6254374b19c61ff561460206a4f9194f4bcd1a52" translate="yes" xml:space="preserve">
          <source>Invalidates the method cache of any classes dependent on the given class. This is not normally necessary. The only known case where pure perl code can confuse the method cache is when you manually install a new constant subroutine by using a readonly scalar value, like the internals of &lt;a href=&quot;constant&quot;&gt;constant&lt;/a&gt; do. If you find another case, please report it so we can either fix it or document the exception here.</source>
          <target state="translated">Делает недействительным кеш методов любых классов, зависящих от данного класса. Обычно в этом нет необходимости. Единственный известный случай, когда чистый код Perl может запутать кеш метода, - это когда вы вручную устанавливаете новую подпрограмму константы, используя скалярное значение только для чтения, как это делают внутренние компоненты &lt;a href=&quot;constant&quot;&gt;константы&lt;/a&gt; . Если вы обнаружите другой случай, сообщите об этом, чтобы мы могли исправить его или задокументировать исключение здесь.</target>
        </trans-unit>
        <trans-unit id="c0df4881ff3f493d5106f68dbab35c513534aed4" translate="yes" xml:space="preserve">
          <source>Inventory management of installed modules</source>
          <target state="translated">Управление запасами установленных модулей</target>
        </trans-unit>
        <trans-unit id="14c5c3735ce54ff56e113f2608fb558c2d638a18" translate="yes" xml:space="preserve">
          <source>Inversion lists are a compact way of specifying Unicode property-value definitions. The 0th item in the list is the lowest code point that has the property-value. The next item (item [1]) is the lowest code point beyond that one that does NOT have the property-value. And the next item beyond that ([2]) is the lowest code point beyond that one that does have the property-value, and so on. Put another way, each element in the list gives the beginning of a range that has the property-value (for even numbered elements), or doesn't have the property-value (for odd numbered elements). The name for this data structure stems from the fact that each element in the list toggles (or inverts) whether the corresponding range is or isn't on the list.</source>
          <target state="translated">Инверсионные списки-это компактный способ определения свойств и значений Юникода.0-й элемент списка-это наименьшая точка кода,имеющая свойство-значение.Следующий пункт (пункт [1])является наименьшей кодовой точкой за пределами той,которая НЕ имеет значения свойства.А следующий за ним элемент ([2])-это наименьшая точка кода за пределами той,которая имеет значение свойства,и так далее.Другими словами,каждый элемент в списке дает начало диапазона,который имеет значение свойства (для четных элементов),или не имеет значения свойства (для нечетных элементов).Имя для этой структуры данных связано с тем,что каждый элемент списка переключает (или переворачивает),является ли соответствующий диапазон в списке или нет.</target>
        </trans-unit>
        <trans-unit id="65b853d505ac70a8422f3186ac06caa076307275" translate="yes" xml:space="preserve">
          <source>Inverting a character class which contains a multi-character sequence is illegal in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31204d44a5939448655207a55e393849306b131a" translate="yes" xml:space="preserve">
          <source>Investigate whether &lt;code&gt;POSIX::dup2&lt;/code&gt; upsets BSD's &lt;code&gt;kqueue&lt;/code&gt; watchers, and if so, consider what possible workarounds might be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e6379916ac816d709ea169dcdb0ea2c85538b2" translate="yes" xml:space="preserve">
          <source>Invocation requires the command to be executed or a coderef and optionally a hashref of options:</source>
          <target state="translated">Для вызова требуется выполнение команды или кодреф и,опционально,хэшреф опций:</target>
        </trans-unit>
        <trans-unit id="9866e55ebd73eaa4dfd6d462e055f3a88a4fa2b2" translate="yes" xml:space="preserve">
          <source>Invoke a magic method (like FETCH).</source>
          <target state="translated">Спровоцировать магический метод (как FETCH).</target>
        </trans-unit>
        <trans-unit id="729e0ead914d111524b46b874fed43976337fb94" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_comment&lt;/code&gt; returns true.</source>
          <target state="translated">Вызывается, если &lt;code&gt;$result-&amp;gt;is_comment&lt;/code&gt; возвращает true.</target>
        </trans-unit>
        <trans-unit id="b6d3760550f46e7b28bbf7a09042b6769acf3c7e" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_plan&lt;/code&gt; returns true.</source>
          <target state="translated">Вызывается, если &lt;code&gt;$result-&amp;gt;is_plan&lt;/code&gt; возвращает true.</target>
        </trans-unit>
        <trans-unit id="4d5c6b94ee048c918e4535240e958632aecb1a6d" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; returns true.</source>
          <target state="translated">Вызывается, если &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; возвращает true.</target>
        </trans-unit>
        <trans-unit id="136fe5e37a3fd848b78d877c253e754a822cac52" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_unknown&lt;/code&gt; returns true.</source>
          <target state="translated">Вызывается, если &lt;code&gt;$result-&amp;gt;is_unknown&lt;/code&gt; возвращает true.</target>
        </trans-unit>
        <trans-unit id="632983081cf348fad68b5fcc938bef7d785aa8ce" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_version&lt;/code&gt; returns true.</source>
          <target state="translated">Вызывается, если &lt;code&gt;$result-&amp;gt;is_version&lt;/code&gt; возвращает true.</target>
        </trans-unit>
        <trans-unit id="dab118fbd97b5abfc5d3df38d7cc4bb27d7a5389" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_yaml&lt;/code&gt; returns true.</source>
          <target state="translated">Вызывается, если &lt;code&gt;$result-&amp;gt;is_yaml&lt;/code&gt; возвращает true.</target>
        </trans-unit>
        <trans-unit id="ad610951e9b392fd2e2ceadbb198a63f8613f82d" translate="yes" xml:space="preserve">
          <source>Invoked when there are no more lines to be parsed. Since there is no accompanying &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object the &lt;code&gt;TAP::Parser&lt;/code&gt; object is passed instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4fc12fcbbbf739e9ecf3604f9dbc469d9a9587a" translate="yes" xml:space="preserve">
          <source>Invoked when there are no more lines to be parsed. Since there is no accompanying &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object the &lt;code&gt;TAP::Parser&lt;/code&gt; object is passed instead.</source>
          <target state="translated">Вызывается, когда больше нет строк для анализа. Поскольку сопутствующего объекта &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result нет,&lt;/a&gt; вместо него передается объект &lt;code&gt;TAP::Parser&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="430786511bff9aaafff5936e905ad653f2aebe92" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_get&lt;/code&gt; on an SV if it has 'get' magic. For example, this will call &lt;code&gt;FETCH&lt;/code&gt; on a tied variable. This macro evaluates its argument more than once.</source>
          <target state="translated">Вызывает &lt;code&gt;mg_get&lt;/code&gt; для SV, если у него есть магия get. Например, это вызовет &lt;code&gt;FETCH&lt;/code&gt; для связанной переменной. Этот макрос оценивает свой аргумент более одного раза.</target>
        </trans-unit>
        <trans-unit id="63770cbaa11ab2ed8431af406f1283f32bff5b08" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_set&lt;/code&gt; on an SV if it has 'set' magic. This is necessary after modifying a scalar, in case it is a magical variable like &lt;code&gt;$|&lt;/code&gt; or a tied variable (it calls &lt;code&gt;STORE&lt;/code&gt; ). This macro evaluates its argument more than once.</source>
          <target state="translated">Вызывает &lt;code&gt;mg_set&lt;/code&gt; для SV, если он имеет магию set. Это необходимо после изменения скаляра, если это магическая переменная вроде &lt;code&gt;$|&lt;/code&gt; или связанная переменная (она вызывает &lt;code&gt;STORE&lt;/code&gt; ). Этот макрос оценивает свой аргумент более одного раза.</target>
        </trans-unit>
        <trans-unit id="d8df026416b8e868f3c4d19bec4e4735f833a540" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_set&lt;/code&gt; on an SV if it has 'set' magic. This is necessary after modifying a scalar, in case it is a magical variable like &lt;code&gt;$|&lt;/code&gt; or a tied variable (it calls &lt;code&gt;STORE&lt;/code&gt;). This macro evaluates its argument more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6065fa2fda8beaeb12ea495b85a947dc1c32d666" translate="yes" xml:space="preserve">
          <source>Invokes VMS debugger. (VMS)</source>
          <target state="translated">Вызывает отладчик VMS.(VMS)</target>
        </trans-unit>
        <trans-unit id="4a48ee301f0abac2cf4e91d0e45258fd858ca888" translate="yes" xml:space="preserve">
          <source>Invokes debugging mode. Primarily for Encode hackers.</source>
          <target state="translated">Вызывает режим отладки.В основном для хакеров кодирования.</target>
        </trans-unit>
        <trans-unit id="24bad1e8c0ab13d7138af070e6f8fd5104a0af38" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce a library file from object files. In scalar context, the name of the library file is returned. In list context, the library file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The following parameters are optional:</source>
          <target state="translated">Вызывает компоновщик для создания файла библиотеки из объектных файлов. В скалярном контексте возвращается имя файла библиотеки. В контексте списка возвращаются файл библиотеки и все созданные временные файлы. Обязательный параметр &lt;code&gt;objects&lt;/code&gt; содержит имя объектных файлов для обработки либо в виде строки (для одного объектного файла), либо в виде ссылки на список (для одного или нескольких файлов). Следующие параметры необязательны:</target>
        </trans-unit>
        <trans-unit id="d6dc74aaf36821077c0007a98c7212fc4b3fa1fa" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce an executable file from object files. In scalar context, the name of the executable file is returned. In list context, the executable file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The optional parameters are the same as &lt;code&gt;&lt;a href=&quot;../functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; with exception for</source>
          <target state="translated">Вызывает компоновщик для создания исполняемого файла из объектных файлов. В скалярном контексте возвращается имя исполняемого файла. В контексте списка возвращаются исполняемый файл и все созданные временные файлы. Обязательный параметр &lt;code&gt;objects&lt;/code&gt; содержит имя объектных файлов для обработки либо в виде строки (для одного объектного файла), либо в виде ссылки на список (для одного или нескольких файлов). Необязательные параметры такие же, как &lt;code&gt;&lt;a href=&quot;../functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; за исключением</target>
        </trans-unit>
        <trans-unit id="79f933cf2af8919cd4f873f791c92f88082706ff" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce an executable file from object files. In scalar context, the name of the executable file is returned. In list context, the executable file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The optional parameters are the same as &lt;code&gt;link&lt;/code&gt; with exception for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b673c6a72896107ce4c1c1720830db2d7090b84b" translate="yes" xml:space="preserve">
          <source>Invoking</source>
          <target state="translated">Invoking</target>
        </trans-unit>
        <trans-unit id="96cd3dba8626073590cef0284f10ba68d27dc29f" translate="yes" xml:space="preserve">
          <source>Invoking C-style &lt;code&gt;open&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7d6999362a94f744230122565df0fb30cec02f" translate="yes" xml:space="preserve">
          <source>Invoking Class Methods</source>
          <target state="translated">Привлекательные классы Методы</target>
        </trans-unit>
        <trans-unit id="36b849bf1b11efdfda1ba9f83f6937c3f5f3d9b5" translate="yes" xml:space="preserve">
          <source>Invoking Perl</source>
          <target state="translated">Ссылка на Perl</target>
        </trans-unit>
        <trans-unit id="d893e9caa1e5c938c432bca17fd828ff27fd449c" translate="yes" xml:space="preserve">
          <source>Invoking all versions of a method with a single call</source>
          <target state="translated">Призыв ко всем версиям метода с одним вызовом</target>
        </trans-unit>
        <trans-unit id="24170ec2bba17eb099637b415016216327bba9b2" translate="yes" xml:space="preserve">
          <source>Invoking the test script via &quot;&lt;code&gt;make test&lt;/code&gt; &quot; did something very important. It invoked perl with all those &lt;code&gt;-I&lt;/code&gt; arguments so that it could find the various files that are part of the extension. It is</source>
          <target state="translated">Вызов тестового скрипта с помощью команды &lt;code&gt;make test&lt;/code&gt; сделал кое-что очень важное. Он вызвал perl со всеми этими аргументами &lt;code&gt;-I&lt;/code&gt; , чтобы он мог найти различные файлы, являющиеся частью расширения. это</target>
        </trans-unit>
        <trans-unit id="2ecba9a37fd38e5bf42e93fcbe6104f64a6dc5ac" translate="yes" xml:space="preserve">
          <source>Invoking the test script via &quot;&lt;code&gt;make test&lt;/code&gt;&quot; did something very important. It invoked perl with all those &lt;code&gt;-I&lt;/code&gt; arguments so that it could find the various files that are part of the extension. It is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5657593a133551a2130d25fd548705e5a0d18d8" translate="yes" xml:space="preserve">
          <source>IoFLAGS</source>
          <target state="translated">IoFLAGS</target>
        </trans-unit>
        <trans-unit id="3bb882aae446ce0088800e6387a83d4c1329eedf" translate="yes" xml:space="preserve">
          <source>IoTYPE</source>
          <target state="translated">IoTYPE</target>
        </trans-unit>
        <trans-unit id="889224e3fca24a6ab17d01fe47a45bc82244e938" translate="yes" xml:space="preserve">
          <source>Iran</source>
          <target state="translated">Iran</target>
        </trans-unit>
        <trans-unit id="eb2131ece0efe78ee8bb1ae98af6099114a8df09" translate="yes" xml:space="preserve">
          <source>Ireland</source>
          <target state="translated">Ireland</target>
        </trans-unit>
        <trans-unit id="5a017d9fae08fe8b742594c766cac2cd8dcf3595" translate="yes" xml:space="preserve">
          <source>Irish for the whole McGillicuddy. In Perl culture, a portmanteau of &amp;ldquo;sharp&amp;rdquo; and &amp;ldquo;bang&amp;rdquo;, meaning the &lt;code&gt;#!&lt;/code&gt; sequence that tells the system where to find the interpreter.</source>
          <target state="translated">Ирландский для всего Макгилликадди. В культуре Perl это сочетание слов &amp;laquo;острый&amp;raquo; и &amp;laquo;взрывной&amp;raquo;, означающее &lt;code&gt;#!&lt;/code&gt; последовательность, которая сообщает системе, где найти интерпретатор.</target>
        </trans-unit>
        <trans-unit id="15b9752e24986e0f7c7c5303acc5a2830fc9afd6" translate="yes" xml:space="preserve">
          <source>Irix (6.5. What else?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb88b49be9395cb953eb1205ce4b4ea6acad6f1e" translate="yes" xml:space="preserve">
          <source>Irix 5.3</source>
          <target state="translated">Ирикс 5.3</target>
        </trans-unit>
        <trans-unit id="280a8973708779722e3c6e60a42a133ed8d4613c" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples here are in the public domain. You are permitted and encouraged to use this code and any derivatives thereof in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit to the FAQ would be courteous but is not required.</source>
          <target state="translated">Независимо от его распространения,все примеры кода здесь являются общественным достоянием.Вам разрешается и рекомендуется использовать этот код и любые его производные в своих собственных программах для развлечения или получения прибыли по своему усмотрению.Простой комментарий в коде,отдающий должное часто задаваемым вопросам,был бы вежливым,но не обязательным.</target>
        </trans-unit>
        <trans-unit id="e6e987fe64dde20e286f30fd90c6b90ffeedb494" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples in these files are hereby placed into the public domain. You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit would be courteous but is not required.</source>
          <target state="translated">Независимо от его распространения,все примеры кода в этих файлах настоящим помещаются в общественное достояние.Вам разрешается и рекомендуется использовать этот код в своих собственных программах для развлечения или для получения прибыли по своему усмотрению.Простой комментарий в коде,дающий преимущество,был бы вежливым,но не является обязательным.</target>
        </trans-unit>
        <trans-unit id="16778fd5503d73f3e7cd989fda95007a4e44c18a" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples in this file are hereby placed into the public domain. You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit would be courteous but is not required.</source>
          <target state="translated">Независимо от его распространения,все примеры кода в этом файле настоящим помещаются в общественное достояние.Вам разрешается и рекомендуется использовать этот код в ваших собственных программах для развлечения или для получения прибыли по вашему усмотрению.Простой комментарий в коде,дающий преимущество,был бы вежливым,но не требуется.</target>
        </trans-unit>
        <trans-unit id="3b1335a849872557c30733349f1e4699d629a12c" translate="yes" xml:space="preserve">
          <source>Is Perl difficult to learn?</source>
          <target state="translated">Перлу трудно учиться?</target>
        </trans-unit>
        <trans-unit id="ac0736b6a42e76cbb8b7ea3d82d9347dd47ba779" translate="yes" xml:space="preserve">
          <source>Is better written:</source>
          <target state="translated">лучше написано:</target>
        </trans-unit>
        <trans-unit id="9f9ed743f2c1371f19760689c4a59cf333c563af" translate="yes" xml:space="preserve">
          <source>Is it possible to change the file permissions of a file on an FTP server ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32906667b7957f587634c3ad2cf7b982992ddda0" translate="yes" xml:space="preserve">
          <source>Is it safe to return a reference to local or lexical data?</source>
          <target state="translated">Безопасно ли возвращать ссылки на местные или лексические данные?</target>
        </trans-unit>
        <trans-unit id="a15088679e31d0c4822e89f1a281a86a46e94dee" translate="yes" xml:space="preserve">
          <source>Is it the same? Well, maybe so--and maybe not. The subtle difference is that when you assign something in square brackets, you know for sure it's always a brand new reference with a new</source>
          <target state="translated">Это то же самое? Ну,может быть,так,а может и нет.Тонкое различие в том,что когда вы назначаете что-то в квадратных скобках,вы знаете наверняка,что это всегда новая ссылка с новой</target>
        </trans-unit>
        <trans-unit id="c842dccd002c594c47398d7b81a3f350518d446b" translate="yes" xml:space="preserve">
          <source>Is not supported for process identification number of 0 or negative numbers. (VMS)</source>
          <target state="translated">Не поддерживается для идентификационного номера процесса 0 или отрицательного.(ЗИС)</target>
        </trans-unit>
        <trans-unit id="85e623ea793b61351aedc1f6283751b7266d3791" translate="yes" xml:space="preserve">
          <source>Is supposed to be superseded by &lt;code&gt;IOCTL_STORAGE_GET_MEDIA_TYPES&lt;/code&gt; but is still useful for determining the types of floppy diskette formats that can be produced by a given floppy drive. See</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed13e4ee416049073be2fb55253aff4db8cf0204" translate="yes" xml:space="preserve">
          <source>Is the disk signature, a unique number assigned by Disk Administrator [</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892d60f6405f23f25c6b3ae4379071e72ec47d11" translate="yes" xml:space="preserve">
          <source>Is the feature generic enough?</source>
          <target state="translated">Достаточно ли общая характеристика?</target>
        </trans-unit>
        <trans-unit id="21550a0f41b5f7c0792d01f174b9eb78bb2eb4ca" translate="yes" xml:space="preserve">
          <source>Is the implementation generic enough to be portable?</source>
          <target state="translated">Является ли внедрение достаточно общим,чтобы быть портативным?</target>
        </trans-unit>
        <trans-unit id="ef5914893715ffaab39210a601dc4f727d6ff4af" translate="yes" xml:space="preserve">
          <source>Is the implementation robust?</source>
          <target state="translated">Надежная ли реализация?</target>
        </trans-unit>
        <trans-unit id="78090775b623989661f8da8dfe386a79dbfa661d" translate="yes" xml:space="preserve">
          <source>Is the implementation tested?</source>
          <target state="translated">Проверено ли внедрение?</target>
        </trans-unit>
        <trans-unit id="7ff173c83692442c34b8acc41b270ff651c2392a" translate="yes" xml:space="preserve">
          <source>Is the scalar handle opened on something?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f6ff8d209700b0f72a5230b6fb85c97fcff80b" translate="yes" xml:space="preserve">
          <source>Is there a pretty-printer (formatter) for Perl?</source>
          <target state="translated">Есть симпатичный принтер (форматер)для Perl?</target>
        </trans-unit>
        <trans-unit id="4de697ef2e229f75e5104bfc892c512110a431a3" translate="yes" xml:space="preserve">
          <source>Is there a way to automatically decode or encode?</source>
          <target state="translated">Существует ли способ автоматического декодирования или кодирования?</target>
        </trans-unit>
        <trans-unit id="39ca1c79bbe21712b9201250f2255ac5dedb029e" translate="yes" xml:space="preserve">
          <source>Is there a way to hide perl's command line from programs such as &quot;ps&quot;?</source>
          <target state="translated">Есть ли способ скрыть командную строку perl от таких программ,как &quot;ps&quot;?</target>
        </trans-unit>
        <trans-unit id="3501dfd2cd1d66a0e5956cd00d200fac2bcfba23" translate="yes" xml:space="preserve">
          <source>Is there an IDE or Windows Perl Editor?</source>
          <target state="translated">Существует ли IDE или Windows Perl Editor?</target>
        </trans-unit>
        <trans-unit id="d38604e1470c164361620c8174e47b26e8405b57" translate="yes" xml:space="preserve">
          <source>Is there another way to do it?</source>
          <target state="translated">Есть другой способ сделать это?</target>
        </trans-unit>
        <trans-unit id="14fcbaecb1fe49a8bbbcabb376a8c49b63c6d0ee" translate="yes" xml:space="preserve">
          <source>Is there anything else I need to know?</source>
          <target state="translated">Есть что-нибудь еще,что мне нужно знать?</target>
        </trans-unit>
        <trans-unit id="3079a95c08daf3fbe9a6f4a2b3424c5019e5caa9" translate="yes" xml:space="preserve">
          <source>Is there enough documentation?</source>
          <target state="translated">Достаточно ли документации?</target>
        </trans-unit>
        <trans-unit id="a850886339587a195217b1d8cceb0d4cff588e20" translate="yes" xml:space="preserve">
          <source>Is this something that only the submitter wants added to the language, or is it broadly useful? Sometimes, instead of adding a feature with a tight focus, the porters might decide to wait until someone implements the more generalized feature.</source>
          <target state="translated">Это то,что только отправитель хочет добавить в язык,или это в целом полезно? Иногда,вместо того,чтобы добавлять возможность с узким фокусом,портеры могут решить подождать,пока кто-нибудь не реализует более обобщённую возможность.</target>
        </trans-unit>
        <trans-unit id="c6c3f322bd4a89ec99cd36027dacc62c0c50b0bf" translate="yes" xml:space="preserve">
          <source>Is this the document you were after?</source>
          <target state="translated">Это тот документ,за которым вы охотились?</target>
        </trans-unit>
        <trans-unit id="c801f4251dba57aee2f236238406c19df06e8971" translate="yes" xml:space="preserve">
          <source>Is this you? Is writing tests right up there with writing documentation and having your fingernails pulled out? Did you open up a test and read</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243aed46fb67b26a47f5f82cb478ce344d097065" translate="yes" xml:space="preserve">
          <source>Is your program EMX-compiled with &lt;code&gt;-Zmt -Zcrtdll&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af501c530066fe2526868f8de57f9ed976517fd9" translate="yes" xml:space="preserve">
          <source>IsContainerPartition</source>
          <target state="translated">IsContainerPartition</target>
        </trans-unit>
        <trans-unit id="c6193261c02de21aac043fe2d15ff95fc2e34dca" translate="yes" xml:space="preserve">
          <source>IsRecognizedPartition</source>
          <target state="translated">IsRecognizedPartition</target>
        </trans-unit>
        <trans-unit id="d95874ba2baf2aa8c816605d15eea330b17427d2" translate="yes" xml:space="preserve">
          <source>IsSTD</source>
          <target state="translated">IsSTD</target>
        </trans-unit>
        <trans-unit id="9f55afe53a666115430d24161c215ea18ed5b9a0" translate="yes" xml:space="preserve">
          <source>Isn't Archive::Tar heavier on memory than /bin/tar?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a285d7f91e6104f157a9d3d5748d7dac064dcf" translate="yes" xml:space="preserve">
          <source>Isn't Archive::Tar slow?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c197dfd67f1ed79d11a8b0218cc368bfcce6ccb" translate="yes" xml:space="preserve">
          <source>Israel</source>
          <target state="translated">Israel</target>
        </trans-unit>
        <trans-unit id="71a13751965545486650d22819d11cd32442498c" translate="yes" xml:space="preserve">
          <source>Issue a command as follows;</source>
          <target state="translated">Выдайте команду следующим образом;</target>
        </trans-unit>
        <trans-unit id="634b2e574e8681fa4bd024f62981fab9bb1e46c1" translate="yes" xml:space="preserve">
          <source>Issue a diagnostics message to STDERR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03592f61d67d4b9df2c210af49940f16e407a6d4" translate="yes" xml:space="preserve">
          <source>Issue a diagnostics message to STDOUT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e65cf3242e05b4d2c344ded5e0824a537ad64ec2" translate="yes" xml:space="preserve">
          <source>Issues a &lt;code&gt;ualarm&lt;/code&gt; call; the &lt;code&gt;$interval_useconds&lt;/code&gt; is optional and will be zero if unspecified, resulting in &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;-like behaviour.</source>
          <target state="translated">Выдает &lt;code&gt;ualarm&lt;/code&gt; вызов; параметр &lt;code&gt;$interval_useconds&lt;/code&gt; является необязательным и будет равен нулю, если не указан, что приведет к поведению, подобному &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="451bb20dde9f17b91d4ea56d923babf92e6ab559" translate="yes" xml:space="preserve">
          <source>Issues a &lt;code&gt;ualarm&lt;/code&gt; call; the &lt;code&gt;$interval_useconds&lt;/code&gt; is optional and will be zero if unspecified, resulting in &lt;code&gt;alarm&lt;/code&gt;-like behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f58a9877a43ede1a54c6d1cffca7950a04cb0e9" translate="yes" xml:space="preserve">
          <source>Issues the warning:</source>
          <target state="translated">Вызывает предупреждение:</target>
        </trans-unit>
        <trans-unit id="d7acc4a63bfa4b603392fb8adfd2d4ca89c11f46" translate="yes" xml:space="preserve">
          <source>It</source>
          <target state="translated">It</target>
        </trans-unit>
        <trans-unit id="38eb0bc8056860c92fb5c583bff73f1456dae838" translate="yes" xml:space="preserve">
          <source>It allows you to fetch any file pointed to by a &lt;code&gt;ftp&lt;/code&gt; , &lt;code&gt;http&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;rsync&lt;/code&gt; uri by a number of different means.</source>
          <target state="translated">Он позволяет получать любой файл, на который указывает &lt;code&gt;ftp&lt;/code&gt; , &lt;code&gt;http&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;git&lt;/code&gt; или &lt;code&gt;rsync&lt;/code&gt; uri, несколькими различными способами.</target>
        </trans-unit>
        <trans-unit id="5f7f3deaf6b10a7e4949b31b699d2af4c0c5c2a4" translate="yes" xml:space="preserve">
          <source>It allows you to fetch any file pointed to by a &lt;code&gt;ftp&lt;/code&gt;, &lt;code&gt;http&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;rsync&lt;/code&gt; uri by a number of different means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b28d021dc9b9966369f90f11dc74db9e607087c" translate="yes" xml:space="preserve">
          <source>It allows you to validate input via a template. The only requirement is that the arguments must be named.</source>
          <target state="translated">Это позволяет проверять введенные данные с помощью шаблона.Единственное требование заключается в том,что аргументы должны быть названы.</target>
        </trans-unit>
        <trans-unit id="b9dcbab629dab7b7bb8a9a5c305c5b7edec8fe86" translate="yes" xml:space="preserve">
          <source>It also causes &lt;code&gt;decode&lt;/code&gt; to parse such tagged JSON values and deserialise them via a call to the &lt;code&gt;THAW&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e1f97bb7137990bbbfbdc73b45154ab6a87edc2" translate="yes" xml:space="preserve">
          <source>It also flags things that need to behave specially in an lvalue context, such as &lt;code&gt;$$x = 5&lt;/code&gt; which might have to vivify a reference in &lt;code&gt;$x&lt;/code&gt; .</source>
          <target state="translated">Он также помечает вещи, которые должны вести себя особым образом в контексте lvalue, например &lt;code&gt;$$x = 5&lt;/code&gt; который, возможно, должен оживить ссылку в &lt;code&gt;$x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f46a706382c3e7f690244335b6067ef888c4bc96" translate="yes" xml:space="preserve">
          <source>It also flags things that need to behave specially in an lvalue context, such as &lt;code&gt;$$x = 5&lt;/code&gt; which might have to vivify a reference in &lt;code&gt;$x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908ce366021e2b55b694a1cc88f5df405de36e15" translate="yes" xml:space="preserve">
          <source>It also has embedded documentation, so you can use</source>
          <target state="translated">Она также имеет встроенную документацию,так что вы можете использовать</target>
        </trans-unit>
        <trans-unit id="2ac24af0ec1c7cfa5374898a3526976fbf4e475c" translate="yes" xml:space="preserve">
          <source>It also made it impossible to pass a perl filehandle that wasn't associated with a real filesystem file, like, say, an &lt;code&gt;IO::String&lt;/code&gt; .</source>
          <target state="translated">Это также сделало невозможным передачу дескриптора файла perl, который не был связан с реальным файлом файловой системы, например, например, &lt;code&gt;IO::String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="affbbcabd9e89330cd688705cb152f75ac31dcc5" translate="yes" xml:space="preserve">
          <source>It also made it impossible to pass a perl filehandle that wasn't associated with a real filesystem file, like, say, an &lt;code&gt;IO::String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50072e7f3665a297dafc9a98026d2ece625b9337" translate="yes" xml:space="preserve">
          <source>It also provides a convenient alias via the MM class (I didn't want MakeMaker modules outside of ExtUtils/).</source>
          <target state="translated">Он также обеспечивает удобный псевдоним через класс MM (я не хотел,чтобы модули MakeMaker находились вне ExtUtils/).</target>
        </trans-unit>
        <trans-unit id="915bbb1cff409394c98921945b825ccfd726cf97" translate="yes" xml:space="preserve">
          <source>It also provides a convenient alias via the MY class.</source>
          <target state="translated">Он также обеспечивает удобный псевдоним через класс MY.</target>
        </trans-unit>
        <trans-unit id="f7728ec4984f8aa9520af281a21430a4fa58511c" translate="yes" xml:space="preserve">
          <source>It also sets the effective names (&lt;code&gt;HvENAME&lt;/code&gt; ) on all the stashes as appropriate.</source>
          <target state="translated">Он также устанавливает соответствующие имена ( &lt;code&gt;HvENAME&lt;/code&gt; ) для всех тайников.</target>
        </trans-unit>
        <trans-unit id="fdd0b99c263719f6c7ac54250b06d02a9d280c92" translate="yes" xml:space="preserve">
          <source>It also sets the effective names (&lt;code&gt;HvENAME&lt;/code&gt;) on all the stashes as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b119a076af514e51ac37bcaf3aa61a59bc6514" translate="yes" xml:space="preserve">
          <source>It also supports tying via a win32 handle (for example, from &lt;code&gt;createFile()&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cefa68e3cb791475c8c4a04f377e9985e23ade2" translate="yes" xml:space="preserve">
          <source>It also turns out that EBCDIC has nearly precise equivalents for the ASCII/Latin1 C0 controls and the DELETE control. (The C0 controls are those whose ASCII code points are 0..0x1F; things like TAB, ACK, BEL, etc.) A mapping is set up between these ASCII/EBCDIC controls. There isn't such a precise mapping between the C1 controls on ASCII platforms and the remaining EBCDIC controls. What has been done is to map these controls, mostly arbitrarily, to some otherwise unmatched character in the other character set. Most of these are very very rarely used nowadays in EBCDIC anyway, and their names have been dropped, without much complaint. For example the EO (Eight Ones) EBCDIC control (consisting of eight one bits = 0xFF) is mapped to the C1 APC control (0x9F), and you can't use the name &quot;EO&quot;.</source>
          <target state="translated">Также выяснилось,что EBCDIC имеет почти точные эквиваленты для управления ASCII/Latin1 C0 и управления DELETE.(Элементы управления C0-это те,чьи ASCII кодовые точки равны 0...0x1F;такие вещи,как TAB,ACK,BEL и т.д.)Между этими элементами управления ASCII/EBCDIC настраивается отображение.Нет такого точного отображения между элементами управления C1 на ASCII платформах и оставшимися элементами управления EBCDIC.Что было сделано,так это нанесение этих элементов управления,в основном произвольно,на какой-то несопоставимый в противном случае символ в другом наборе символов.Большинство из них очень редко используются в настоящее время в EBCDIC в любом случае,и их имена были удалены,без особых претензий.Например,элемент управления EO (Eight Ones)EBCDIC (состоящий из восьми бит=0xFF)отображается на элемент управления C1 APC (0x9F),и вы не можете использовать имя &quot;EO&quot;.</target>
        </trans-unit>
        <trans-unit id="6e72af9b0783d77ee6316a243e984feea8033ad2" translate="yes" xml:space="preserve">
          <source>It assumes that pat has the same utf8-ness as sv. It's the caller's responsibility to ensure that this is so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff9e21d973b85a09332d5d3faae1a519ffea9ab5" translate="yes" xml:space="preserve">
          <source>It attempts to meet all &quot;MUST&quot; requirements of the specification, but does not implement all &quot;SHOULD&quot; requirements. (Note: it was developed against the earlier RFC 2616 specification and may not yet meet the revised RFC 7230-7235 spec.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd158a359289156ad701983e580703419c574eb4" translate="yes" xml:space="preserve">
          <source>It becomes more important for perl to know about all the possible locale categories on the platform, even if they aren't apparently used in your program. Perl knows all of the Linux ones. If your platform has others, you can submit an issue at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; for inclusion of it in the next release. In the meantime, it is possible to edit the Perl source to teach it about the category, and then recompile. Search for instances of, say, &lt;code&gt;LC_PAPER&lt;/code&gt; in the source, and use that as a template to add the omitted one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6076aff0ee21a62fd6a390261efc5e5f0afb16" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;croak&lt;/code&gt; on failure.</source>
          <target state="translated">Он вызывает &lt;code&gt;croak&lt;/code&gt; при неудаче.</target>
        </trans-unit>
        <trans-unit id="04dc7e22ec9e3426f178763cb4c63c8305c033ad" translate="yes" xml:space="preserve">
          <source>It calls several other routines, such as &lt;code&gt;fbm_instr()&lt;/code&gt; which does Fast Boyer Moore matching and &lt;code&gt;find_byclass()&lt;/code&gt; which is responsible for finding the start using the first mandatory regop in the program.</source>
          <target state="translated">Он вызывает несколько других подпрограмм, таких как &lt;code&gt;fbm_instr()&lt;/code&gt; который выполняет быстрое сопоставление по &lt;code&gt;find_byclass()&lt;/code&gt; Муру, и find_byclass (), который отвечает за поиск начала с использованием первого обязательного regop в программе.</target>
        </trans-unit>
        <trans-unit id="497f49c37ce971a4a73fa1723da212a9045a166f" translate="yes" xml:space="preserve">
          <source>It can also be extended to be an application from &lt;b&gt;C&lt;/b&gt; to &lt;b&gt;C&lt;/b&gt;, whilst its restriction to &lt;b&gt;R&lt;/b&gt; behaves as defined above by using the following definition:</source>
          <target state="translated">Его также можно расширить до приложения с &lt;b&gt;C&lt;/b&gt; до &lt;b&gt;C&lt;/b&gt; , в то время как его ограничение на &lt;b&gt;R&lt;/b&gt; ведет себя, как определено выше, с использованием следующего определения:</target>
        </trans-unit>
        <trans-unit id="037c189042a08e857fa9c25c861179516385e907" translate="yes" xml:space="preserve">
          <source>It can also be that long doubles and doubles are the same thing:</source>
          <target state="translated">Также может быть,что длинные удвоения и удвоения-это одно и то же:</target>
        </trans-unit>
        <trans-unit id="5a15f67a53851e31c8be84ee1922d871c9c74ea2" translate="yes" xml:space="preserve">
          <source>It can also store the resource directly in a file:</source>
          <target state="translated">Он также может хранить ресурс непосредственно в файле:</target>
        </trans-unit>
        <trans-unit id="2eb713583608cebc3ea2998759255bff9599a6ef" translate="yes" xml:space="preserve">
          <source>It can be called on an object or a class, of course.</source>
          <target state="translated">Конечно,его можно вызвать по объекту или классу.</target>
        </trans-unit>
        <trans-unit id="e5c905f1665a696bdc789794d07c2a84423a378d" translate="yes" xml:space="preserve">
          <source>It can be used in the regular procedural way by calling &lt;code&gt;store&lt;/code&gt; with a reference to the object to be stored, along with the file name where the image should be written.</source>
          <target state="translated">Его можно использовать обычным процедурным способом, вызывая &lt;code&gt;store&lt;/code&gt; со ссылкой на объект, который нужно сохранить, вместе с именем файла, в который должно быть записано изображение.</target>
        </trans-unit>
        <trans-unit id="1b6d3eb9169140a9a6274f80ff5e86670958b748" translate="yes" xml:space="preserve">
          <source>It can easily be defined like this:</source>
          <target state="translated">Его можно легко определить вот так:</target>
        </trans-unit>
        <trans-unit id="86ba6d37f32935701376ea8939425dea235ee2d1" translate="yes" xml:space="preserve">
          <source>It can load perl dynamic extensions, and it can fork().</source>
          <target state="translated">Он может загружать динамические расширения perl,и он может fork().</target>
        </trans-unit>
        <trans-unit id="5a3c2d30ca072f4084789964fe3766438b6284d3" translate="yes" xml:space="preserve">
          <source>It can lose track of whether something should be encoded as UTF-8 or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f9135ce7da4c20ac152391823b647cbbeb33a6" translate="yes" xml:space="preserve">
          <source>It can take one of the following forms:</source>
          <target state="translated">Это может принять одну из следующих форм:</target>
        </trans-unit>
        <trans-unit id="2f904ea9d1b7cc3495a54fb96cf0850f9e5fd878" translate="yes" xml:space="preserve">
          <source>It can, however, be used as a superclass for other classes. To facilitate this, the generated constructor method uses a two-argument blessing. Furthermore, if the class is hash-based, the key of each element is prefixed with the class name (see</source>
          <target state="translated">Однако он может быть использован в качестве суперкласса для других классов.Для облегчения этого в генерируемом методе конструктора используется благословение в виде двух знаков.Кроме того,если класс основан на хэшах,то ключ каждого элемента префиксом к имени класса (смотрите раздел</target>
        </trans-unit>
        <trans-unit id="09d8ef54917c31dc7c7e7dced0a11cfba194a124" translate="yes" xml:space="preserve">
          <source>It combines the features of the</source>
          <target state="translated">Он сочетает в себе черты</target>
        </trans-unit>
        <trans-unit id="6de2e6681db9e2aba6bd7eace100b8a569aebcfe" translate="yes" xml:space="preserve">
          <source>It constructs and returns a $treewalker coderef, which when invoked, traverses, or walks, and renders the optrees of the given arguments to STDOUT. You can reuse this, and can change the rendering style used each time; thereafter the coderef renders in the new style.</source>
          <target state="translated">Он конструирует и возвращает кодреф $treewalker,который при вызове,обходит или ходит,и передает опции данных аргументов в STDOUT.Вы можете использовать это повторно и изменять стиль рендеринга,используемый каждый раз;затем кодреф выводится в новом стиле.</target>
        </trans-unit>
        <trans-unit id="8ee601f689d3bf17ef24ff756daa44f51b167191" translate="yes" xml:space="preserve">
          <source>It creates a database of the profile information that you can turn into reports. The &lt;code&gt;nytprofhtml&lt;/code&gt; command turns the data into an HTML report similar to the &lt;a href=&quot;Devel::Cover&quot;&gt;Devel::Cover&lt;/a&gt; report:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b00062db32c6f6da9356b09e0e38ccf6b4650d6" translate="yes" xml:space="preserve">
          <source>It creates a database of the profile information that you can turn into reports. The &lt;code&gt;nytprofhtml&lt;/code&gt; command turns the data into an HTML report similar to the &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::Cover&quot;&gt;Devel::Cover&lt;/a&gt; report:</source>
          <target state="translated">Он создает базу данных профильной информации, которую вы можете превратить в отчеты. Команда &lt;code&gt;nytprofhtml&lt;/code&gt; превращает данные в отчет HTML, аналогичный отчету &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::Cover&quot;&gt;Devel :: Cover&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ea6e392f63285a19a0d452d50c54df585744488e" translate="yes" xml:space="preserve">
          <source>It currently does</source>
          <target state="translated">В настоящее время</target>
        </trans-unit>
        <trans-unit id="e547a28181c8513c90dab654ebd4bf8ae08d6f97" translate="yes" xml:space="preserve">
          <source>It delivers the correct results for the &lt;code&gt;RADIXCHAR&lt;/code&gt; and &lt;code&gt;THOUSEP&lt;/code&gt; items, without you having to write extra code. The reason for the extra code would be because these are from the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale category, which is normally kept set by Perl so that the radix is a dot, and the separator is the empty string, no matter what the underlying locale is supposed to be, and so to get the expected results, you have to temporarily toggle into the underlying locale, and later toggle back. (You could use plain &lt;code&gt;nl_langinfo&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&lt;/a&gt;&lt;/code&gt; for this but then you wouldn't get the other advantages of &lt;code&gt;Perl_langinfo()&lt;/code&gt;; not keeping &lt;code&gt;LC_NUMERIC&lt;/code&gt; in the C (or equivalent) locale would break a lot of CPAN, which is expecting the radix (decimal point) character to be a dot.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dad9241afc4fe54f1d9bdea5f00177fb19d962a" translate="yes" xml:space="preserve">
          <source>It depends just what you mean by &quot;escape&quot;. URL escapes are dealt with in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;. Shell escapes with the backslash (&lt;code&gt;\&lt;/code&gt; ) character are removed with</source>
          <target state="translated">Это зависит от того, что вы подразумеваете под &amp;laquo;побегом&amp;raquo;. &lt;a href=&quot;perlfaq9&quot;&gt;Преобразование&lt;/a&gt; URL-адресов обрабатывается в perlfaq9 . Экраны с обратной косой чертой ( &lt;code&gt;\&lt;/code&gt; ) удаляются с помощью</target>
        </trans-unit>
        <trans-unit id="cdac17a54a39be9556592ce5c191473c9ecfd72c" translate="yes" xml:space="preserve">
          <source>It depends just what you mean by &quot;escape&quot;. URL escapes are dealt with in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;. Shell escapes with the backslash (&lt;code&gt;\&lt;/code&gt;) character are removed with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c581007e3ef08adcb3306414f7f2463e871ac22e" translate="yes" xml:space="preserve">
          <source>It does have the drawback of putting the wrong thing in $-[0] and $+[0], but this usually can be worked around.</source>
          <target state="translated">Недостатком является помещение неправильной вещи в $-[0]и $+[0],но обычно это можно обработать.</target>
        </trans-unit>
        <trans-unit id="79d1a39f53aab3a73596d5fd9d9372e7a56d671b" translate="yes" xml:space="preserve">
          <source>It does implement the full UTS#18 grouping, intersection, union, and removal (subtraction) syntax.</source>
          <target state="translated">Он реализует полный синтаксис группировки,пересечения,объединения и удаления (вычитания)UTS#18.</target>
        </trans-unit>
        <trans-unit id="3283ccec35b62f9d69fc01d0b0127572cdbbfb86" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">Это похоже на &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt; . Обратите внимание, что &lt;code&gt;$unprocessed&lt;/code&gt; будет изменен как побочный эффект.</target>
        </trans-unit>
        <trans-unit id="25a28128ab3b4005d07e5b53db8c8141489e82c0" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781b506fec7893fd5e327ee69d14b0d379ec072d" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">Это похоже на &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt; . Обратите внимание, что &lt;code&gt;$unprocessed&lt;/code&gt; будет изменен как побочный эффект.</target>
        </trans-unit>
        <trans-unit id="053e3e1bd8bbb865867e84abe6ea50be636b0060" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98073979e598afdba9b1edfe5653068ff476e437" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">Это похоже на &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt; . Обратите внимание, что &lt;code&gt;$unprocessed&lt;/code&gt; будет изменен как побочный эффект.</target>
        </trans-unit>
        <trans-unit id="4bd843b35cf6f524d8898789fded24bf5b532aee" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a16bde88f189f6ad288e03cf560598f2698ec6" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">Это похоже на &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt; . Обратите внимание, что &lt;code&gt;$unprocessed&lt;/code&gt; будет изменен как побочный эффект.</target>
        </trans-unit>
        <trans-unit id="5cfa9126aa95883d132daa2d80bb8c833bb459ad" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23674d2d232acdb766b500c08327a83816f04c97" translate="yes" xml:space="preserve">
          <source>It does not protect &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; , so that variables can still be substituted.</source>
          <target state="translated">Он не защищает &lt;code&gt;$&lt;/code&gt; или &lt;code&gt;@&lt;/code&gt; , поэтому переменные все равно можно заменять.</target>
        </trans-unit>
        <trans-unit id="6c7a5ea655e7023099d39c28a9e780a041767575" translate="yes" xml:space="preserve">
          <source>It does not protect &lt;code&gt;'$'&lt;/code&gt; or &lt;code&gt;'@'&lt;/code&gt;, so that variables can still be substituted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b096762458cc1c67705fc722b1b5c19a799e9a" translate="yes" xml:space="preserve">
          <source>It doesn't handle all C constructs, but it does attempt to isolate definitions inside evals so that you can get at the definitions that it can translate.</source>
          <target state="translated">Он не обрабатывает все конструкции C,но пытается изолировать определения внутри evals,чтобы вы могли получить определения,которые он может перевести.</target>
        </trans-unit>
        <trans-unit id="661f04839377963b6531cde75241eb25f024872a" translate="yes" xml:space="preserve">
          <source>It doesn't matter whether those elements are already there or not: it'll gladly create them for you, setting intervening elements to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as need be.</source>
          <target state="translated">Не имеет значения, присутствуют ли эти элементы уже или нет: он с радостью создаст их для вас, при необходимости установив для промежуточных элементов &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fae5276d8d54bb235b88eecab0650a76f813b6ff" translate="yes" xml:space="preserve">
          <source>It doesn't matter whether those elements are already there or not: it'll gladly create them for you, setting intervening elements to &lt;code&gt;undef&lt;/code&gt; as need be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d56e0602580738fb050f4b637c11809b2b2552" translate="yes" xml:space="preserve">
          <source>It ensures that all items returned from the subroutine will be accessible when control returns from the</source>
          <target state="translated">Это гарантирует,что все предметы,возвращаемые из подпрограммы,будут доступны,когда управление возвращается из</target>
        </trans-unit>
        <trans-unit id="257a0d1f1aa9bffe5b6fec0d0193d78bda64cf97" translate="yes" xml:space="preserve">
          <source>It ensures that nothing is actually returned from the subroutine.</source>
          <target state="translated">Это гарантирует,что ничего не будет возвращено из подпрограммы.</target>
        </trans-unit>
        <trans-unit id="9073e4e615d570b658e9c1dc5b31fb9fbc2e51c4" translate="yes" xml:space="preserve">
          <source>It ensures that only a scalar is actually returned from the subroutine. The subroutine can, of course, ignore the</source>
          <target state="translated">Это гарантирует,что из подпрограммы возвращается только скаляр.Подпрограмма,конечно,может игнорировать</target>
        </trans-unit>
        <trans-unit id="c5a8cac5521955b5cf81a85b7f0157a0da48a8fd" translate="yes" xml:space="preserve">
          <source>It evaluates to TRUE if, besides those 4 words, any of the sequences &quot;feed&quot;, &quot;field&quot;, &quot;Defoe&quot;, &quot;fume&quot;, and many others are in &lt;code&gt;$foo&lt;/code&gt;. By judicious use of &lt;code&gt;\b&lt;/code&gt; (or better (because it is designed to handle natural language) &lt;code&gt;\b{wb}&lt;/code&gt;), we can make sure that only the Giant's words are matched:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce1e8c1dec22e7fcef7a08df4a73a6d708c188c" translate="yes" xml:space="preserve">
          <source>It exports the following variables:</source>
          <target state="translated">Он экспортирует следующие переменные:</target>
        </trans-unit>
        <trans-unit id="c5eede2c3ff2d6a126d9a37fe7b6a2f7c7fef7c9" translate="yes" xml:space="preserve">
          <source>It goes without saying that bundling can be quite confusing.</source>
          <target state="translated">Само собой разумеется,что комплектация может быть довольно запутанной.</target>
        </trans-unit>
        <trans-unit id="3dd9057379828dbfc73545c27db82f9785af3f5b" translate="yes" xml:space="preserve">
          <source>It has not been extensively tested yet and buffered I/O is not yet implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f1fa29899dc9be4d2a29da0c1ebb962d996294" translate="yes" xml:space="preserve">
          <source>It implements just a very simple class to manage an array. Apart from the constructor, &lt;code&gt;new&lt;/code&gt; , it declares methods, one static and one virtual. The static method, &lt;code&gt;PrintID&lt;/code&gt; , prints out simply the class name and a version number. The virtual method, &lt;code&gt;Display&lt;/code&gt; , prints out a single element of the array. Here is an all-Perl example of using it.</source>
          <target state="translated">Он реализует очень простой класс для управления массивом. Помимо конструктора &lt;code&gt;new&lt;/code&gt; , он объявляет методы, один статический и один виртуальный. Статический метод &lt;code&gt;PrintID&lt;/code&gt; выводит просто имя класса и номер версии. Виртуальный метод &lt;code&gt;Display&lt;/code&gt; распечатывает единственный элемент массива. Вот пример использования Perl.</target>
        </trans-unit>
        <trans-unit id="194ff250d804880fa7aa6c2644ae6036e2023968" translate="yes" xml:space="preserve">
          <source>It implements just a very simple class to manage an array. Apart from the constructor, &lt;code&gt;new&lt;/code&gt;, it declares methods, one static and one virtual. The static method, &lt;code&gt;PrintID&lt;/code&gt;, prints out simply the class name and a version number. The virtual method, &lt;code&gt;Display&lt;/code&gt;, prints out a single element of the array. Here is an all-Perl example of using it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4643eacc5a23fd6cfe7dbaa4ae9405cefd594ff8" translate="yes" xml:space="preserve">
          <source>It includes the TAP::Parser Cookbook:</source>
          <target state="translated">Она включает в себя TAP::Parser Cookbook:</target>
        </trans-unit>
        <trans-unit id="0b24215ad07cf4400cc22f004d70379859a91675" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a list context (if it executes</source>
          <target state="translated">Указывает вызываемой подпрограмме,что она выполняется в контексте списка (если выполняется</target>
        </trans-unit>
        <trans-unit id="fd952552f08ee5c64a4b5cd1472fcbc55f52ff32" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a scalar context (if it executes</source>
          <target state="translated">Указывает вызываемой подпрограмме,что она выполняется в скалярном контексте (если выполняется</target>
        </trans-unit>
        <trans-unit id="d334572d38ec1bf7625437e6802d9ceede41a62a" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a void context (if it executes</source>
          <target state="translated">Указывает вызываемой подпрограмме,что она выполняется в пустом контексте (если выполняется</target>
        </trans-unit>
        <trans-unit id="3dd5d5b49f19e1af8608ede7c4aa585a51f279cb" translate="yes" xml:space="preserve">
          <source>It is</source>
          <target state="translated">Да</target>
        </trans-unit>
        <trans-unit id="4593c265ea2a96fff8349127e24d6f8f64bc8930" translate="yes" xml:space="preserve">
          <source>It is a VIO application.</source>
          <target state="translated">Это VIO приложение.</target>
        </trans-unit>
        <trans-unit id="15edb9eea808da9feee1a21d84ef34931e249422" translate="yes" xml:space="preserve">
          <source>It is a common feature of applications (whether run directly, or via the Web) for them to be &quot;localized&quot; -- i.e., for them to a present an English interface to an English-speaker, a German interface to a German-speaker, and so on for all languages it's programmed with. Locale::Maketext is a framework for software localization; it provides you with the tools for organizing and accessing the bits of text and text-processing code that you need for producing localized applications.</source>
          <target state="translated">Это общая особенность приложений (запускаемых напрямую или через Интернет)для их &quot;локализации&quot;-т.е.для них в настоящее время английский интерфейс для англоговорящего,немецкий интерфейс для немецкоговорящего и т.д.для всех языков,на которых они запрограммированы.Locale::Maketext-это фреймворк для локализации программного обеспечения;он предоставляет вам инструменты для организации и доступа к битам текстового и текстового кода,который вам нужен для создания локализованных приложений.</target>
        </trans-unit>
        <trans-unit id="dd0c9650fee6ca5253a38ac00e6dc732d4f0e459" translate="yes" xml:space="preserve">
          <source>It is a common problem to want to detect what language(s) the user would prefer output in.</source>
          <target state="translated">Общей проблемой является желание определить,на каком языке(ах)пользователь предпочитает выводить данные.</target>
        </trans-unit>
        <trans-unit id="84d9ffe2b782da4eace968e860a68bb94a1236cb" translate="yes" xml:space="preserve">
          <source>It is a fatal error if an operand contains a character whose ordinal value is above 0xFF, and hence not expressible except in UTF-8. The operation is performed on a non-UTF-8 copy for other operands encoded in UTF-8. See &lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;&quot;Byte and Character Semantics&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c07216f6ed146b3d5f5f41f5151571003ed974c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1950 data stream.</source>
          <target state="translated">Попытка использовать эту опцию, если &lt;code&gt;$output&lt;/code&gt; не является потоком данных RFC 1950, является фатальной ошибкой .</target>
        </trans-unit>
        <trans-unit id="f26fad9b2ea8dad78ce0ae0159c499c446261e46" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1951 data stream.</source>
          <target state="translated">Попытка использовать эту опцию, если &lt;code&gt;$output&lt;/code&gt; не является потоком данных RFC 1951, является фатальной ошибкой .</target>
        </trans-unit>
        <trans-unit id="f52e23ce1b9c7d458b13fea7c76a357d80aa0ef3" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1952 data stream.</source>
          <target state="translated">Попытка использовать эту опцию, если &lt;code&gt;$output&lt;/code&gt; не является потоком данных RFC 1952, является фатальной ошибкой .</target>
        </trans-unit>
        <trans-unit id="951fc5c4a5b5cf258c0f54c435f4794f721e0f6c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to call this function except in list context.</source>
          <target state="translated">Вызов этой функции,кроме как в контексте списка,является фатальной ошибкой.</target>
        </trans-unit>
        <trans-unit id="84e04c4e01865ff456f52f410d5f957caeadfc3c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to register a non-reference $obj. Any non-hashrefs among the following arguments are silently ignored.</source>
          <target state="translated">Фатальной ошибкой является регистрация отсутствия ссылки на $obj.Любые не хэшрефы среди следующих аргументов молча игнорируются.</target>
        </trans-unit>
        <trans-unit id="62c55db6ed1bb1f62b509a530f9b2d3c904a4f20" translate="yes" xml:space="preserve">
          <source>It is a hash of hashes that is keyed on perl version. Each keyed hash will have the following keys:</source>
          <target state="translated">Это хэш из хэшей,который кешируется на perl версии.Каждый кешированный хэш будет иметь следующие ключи:</target>
        </trans-unit>
        <trans-unit id="25ddadae24c0653c00410eac3e43d9a6483af1b0" translate="yes" xml:space="preserve">
          <source>It is a little bit easier to do so while</source>
          <target state="translated">Это немного проще сделать,пока</target>
        </trans-unit>
        <trans-unit id="41ddae9f4920a415092a3be5fefb0262a7109fa2" translate="yes" xml:space="preserve">
          <source>It is a simple matter to expand out an inversion list to a full list of all code points that have the property-value:</source>
          <target state="translated">Простым делом является расширение списка инверсий до полного списка всех точек кода,имеющих свойство-значение:</target>
        </trans-unit>
        <trans-unit id="fa408a04e809363f2b269a35a2338df430b18e1f" translate="yes" xml:space="preserve">
          <source>It is a syntax error to use &lt;code&gt;\N{NAME}&lt;/code&gt; where &lt;code&gt;NAME&lt;/code&gt; is unknown.</source>
          <target state="translated">Использование &lt;code&gt;\N{NAME}&lt;/code&gt; где &lt;code&gt;NAME&lt;/code&gt; неизвестно, является синтаксической ошибкой .</target>
        </trans-unit>
        <trans-unit id="3189cdee5a11207a5d4b78afa8dc9c2b8ecc076f" translate="yes" xml:space="preserve">
          <source>It is able to load multiple modules at once or none at all if one of them was not able to load. It also takes care of any error checking and so forth.</source>
          <target state="translated">Он способен загрузить несколько модулей одновременно или вообще ни одного,если один из них не смог загрузиться.Он также берет на себя проверку на ошибки и так далее.</target>
        </trans-unit>
        <trans-unit id="5224d6c644e7d334b02295922c6a21bf88351e6e" translate="yes" xml:space="preserve">
          <source>It is advised that formatnames match the regexp &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/a&gt;&lt;/code&gt;. Everything following whitespace after the formatname is a parameter that may be used by the formatter when dealing with this region. This parameter must not be repeated in the &quot;=end&quot; paragraph. Implementors should anticipate future expansion in the semantics and syntax of the first parameter to &quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</source>
          <target state="translated">Рекомендуется, чтобы имена форматов соответствовали регулярному выражению &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/a&gt;&lt;/code&gt; . Все, что следует за пробелами после имени формата, является параметром, который может использоваться программой форматирования при работе с этой областью. Этот параметр не должен повторяться в абзаце &amp;laquo;= конец&amp;raquo;. Разработчики должны предвидеть будущее расширение семантики и синтаксиса первого параметра до &quot;= begin&quot; / &quot;= end&quot; / &quot;= for&quot;.</target>
        </trans-unit>
        <trans-unit id="e650500b6f0231025bf8e8986cda639228e156b4" translate="yes" xml:space="preserve">
          <source>It is advised that formatnames match the regexp &lt;code&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/code&gt;. Everything following whitespace after the formatname is a parameter that may be used by the formatter when dealing with this region. This parameter must not be repeated in the &quot;=end&quot; paragraph. Implementors should anticipate future expansion in the semantics and syntax of the first parameter to &quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bdc4a6dded231914c04e13e61b945f48f5268b4" translate="yes" xml:space="preserve">
          <source>It is also highly desirable that encoding classes inherit from &lt;code&gt;Encode::Encoding&lt;/code&gt; as a base class. This allows that class to define additional behaviour for all encoding objects.</source>
          <target state="translated">Также очень желательно, чтобы классы кодирования унаследовали от &lt;code&gt;Encode::Encoding&lt;/code&gt; в качестве базового класса. Это позволяет этому классу определять дополнительное поведение для всех объектов кодирования.</target>
        </trans-unit>
        <trans-unit id="04e94392102301dd0cfd3e0e0b7cc900aa1df8a8" translate="yes" xml:space="preserve">
          <source>It is also hoped that the interface will cover the needs of OS/2, NT etc and also allow pseudo-dynamic linking (using &lt;code&gt;ld -A&lt;/code&gt; at runtime).</source>
          <target state="translated">Также есть надежда, что интерфейс будет покрывать потребности OS / 2, NT и т.д., а также позволит псевдодинамическое связывание (с использованием &lt;code&gt;ld -A&lt;/code&gt; во время выполнения).</target>
        </trans-unit>
        <trans-unit id="c5a799ae9f844383ae213d6362def23a82f89603" translate="yes" xml:space="preserve">
          <source>It is also important to realize that these are default boundary definitions, and that implementations may wish to tailor the results for particular purposes and locales.</source>
          <target state="translated">Также важно понимать,что это определения границ по умолчанию,и что реализации могут захотеть приспособить результаты для конкретных целей и локалей.</target>
        </trans-unit>
        <trans-unit id="71ce07ae3818cf03055cfa783a2edee6c6d417e8" translate="yes" xml:space="preserve">
          <source>It is also important to realize that these are default boundary definitions, and that implementations may wish to tailor the results for particular purposes and locales. For example, some languages, such as Japanese and Thai, require dictionary lookup to accurately determine word boundaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04f0bafdb5580f449ee2f59e8c42ace66bb7312" translate="yes" xml:space="preserve">
          <source>It is also possible for the reverse to happen: &lt;code&gt;prop_aliases('isc')&lt;/code&gt; returns the list &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt; ; whereas &lt;code&gt;prop_aliases('c')&lt;/code&gt; returns &lt;code&gt;(C, Other)&lt;/code&gt; (the latter being a Perl extension meaning &lt;code&gt;General_Category=Other&lt;/code&gt; . &lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;Properties accessible through Unicode::UCD in perluniprops&lt;/a&gt; lists the available forms, including which ones are discouraged from use.</source>
          <target state="translated">Также возможно обратное: &lt;code&gt;prop_aliases('isc')&lt;/code&gt; возвращает список &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt; ; тогда как &lt;code&gt;prop_aliases('c')&lt;/code&gt; возвращает &lt;code&gt;(C, Other)&lt;/code&gt; (последнее является расширением Perl, означающим &lt;code&gt;General_Category=Other&lt;/code&gt; . &lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;Свойства, доступные через Unicode :: UCD в perluniprops,&lt;/a&gt; перечисляют доступные формы, включая те, которые не рекомендуется использовать.</target>
        </trans-unit>
        <trans-unit id="46b4ec4d35947f03a43a47b65cb8093dc3e99125" translate="yes" xml:space="preserve">
          <source>It is also possible for the reverse to happen: &lt;code&gt;prop_aliases('isc')&lt;/code&gt; returns the list &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt;; whereas &lt;code&gt;prop_aliases('c')&lt;/code&gt; returns &lt;code&gt;(C, Other)&lt;/code&gt; (the latter being a Perl extension meaning &lt;code&gt;General_Category=Other&lt;/code&gt;. &lt;a href=&quot;perluniprops#Properties-accessible-through-Unicode%3A%3AUCD&quot;&gt;&quot;Properties accessible through Unicode::UCD&quot; in perluniprops&lt;/a&gt; lists the available forms, including which ones are discouraged from use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8c00abb531749489f64809eab7af330894c553" translate="yes" xml:space="preserve">
          <source>It is also possible to generate Symbian executables for &quot;miniperl&quot; and &quot;perl&quot;, but since there is no standard command line interface for Symbian (nor full keyboards in the devices), these are useful mainly as demonstrations.</source>
          <target state="translated">Также возможно создавать Symbian исполняемые файлы для &quot;miniperl&quot; и &quot;perl&quot;,но так как нет стандартного интерфейса командной строки для Symbian (или полных клавиатур в устройствах),они полезны в основном в качестве демонстраций.</target>
        </trans-unit>
        <trans-unit id="fba88eaeb368c964f0dd8f74cbc321efcbbc3751" translate="yes" xml:space="preserve">
          <source>It is also possible to have a complex number as either argument of the &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; : the appropriate component of the argument will be used.</source>
          <target state="translated">Также возможно иметь комплексное число в качестве любого аргумента &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; и &lt;code&gt;cplxe&lt;/code&gt; : будет использоваться соответствующий компонент аргумента.</target>
        </trans-unit>
        <trans-unit id="5f695912980907c9e4ce8ee64fb36b966f74913d" translate="yes" xml:space="preserve">
          <source>It is also possible to have a complex number as either argument of the &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;emake&lt;/code&gt;, &lt;code&gt;cplx&lt;/code&gt;, and &lt;code&gt;cplxe&lt;/code&gt;: the appropriate component of the argument will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1daabab3a866899ef9c74e4b9b632751383e7e2" translate="yes" xml:space="preserve">
          <source>It is also possible to instead list the characters you do not want to match. You can do so by using a caret (&lt;code&gt;^&lt;/code&gt;) as the first character in the character class. For instance, &lt;code&gt;[^a-z]&lt;/code&gt; matches any character that is not a lowercase ASCII letter, which therefore includes more than a million Unicode code points. The class is said to be &quot;negated&quot; or &quot;inverted&quot;.</source>
          <target state="translated">Также можно вместо этого перечислить символы, которым вы не хотите соответствовать. Вы можете сделать это, используя курсор ( &lt;code&gt;^&lt;/code&gt; ) в качестве первого символа в классе символов. Например, &lt;code&gt;[^a-z]&lt;/code&gt; соответствует любому символу, не являющемуся строчной буквой ASCII, который, следовательно, включает более миллиона кодовых точек Unicode. Класс называется &amp;laquo;инвертированным&amp;raquo; или &amp;laquo;инвертированным&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d1b81a5a48e226bc85d367f9c052e3692ba4d679" translate="yes" xml:space="preserve">
          <source>It is also possible to just require Math::BigFloat:</source>
          <target state="translated">Также можно просто потребовать математику::BigFloat:</target>
        </trans-unit>
        <trans-unit id="3fa6ca91de346d776bfa7cb7677e64152ae10a28" translate="yes" xml:space="preserve">
          <source>It is also possible to keep &lt;code&gt;origin&lt;/code&gt; as a git remote, and add a new remote for ssh access:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f73d924849030d9c9bafff98a0dd19b4f629df" translate="yes" xml:space="preserve">
          <source>It is also possible to omit the filename parameter as well, so the call:</source>
          <target state="translated">Также можно опустить параметр имени файла,поэтому вызов:</target>
        </trans-unit>
        <trans-unit id="c92bd63c5290ef43a80924b5bd4775d90c01eb70" translate="yes" xml:space="preserve">
          <source>It is also possible to return values directly via the parameter list--whether it is actually desirable to do it is another matter entirely.</source>
          <target state="translated">Можно также возвращать значения непосредственно через список параметров-если это действительно желательно,то это совсем другое дело.</target>
        </trans-unit>
        <trans-unit id="50a5455e17306f508cbf1a77905bc1e3511b26df" translate="yes" xml:space="preserve">
          <source>It is also possible to specify the minimal and maximal number of arguments an option takes. &lt;code&gt;foo=s{2,4}&lt;/code&gt; indicates an option that takes at least two and at most 4 arguments. &lt;code&gt;foo=s{1,}&lt;/code&gt; indicates one or more values; &lt;code&gt;foo:s{,}&lt;/code&gt; indicates zero or more option values.</source>
          <target state="translated">Также можно указать минимальное и максимальное количество аргументов, которые принимает опция. &lt;code&gt;foo=s{2,4}&lt;/code&gt; указывает параметр, который принимает от двух до четырех аргументов. &lt;code&gt;foo=s{1,}&lt;/code&gt; указывает одно или несколько значений; &lt;code&gt;foo:s{,}&lt;/code&gt; указывает ноль или более значений параметра.</target>
        </trans-unit>
        <trans-unit id="b77bfd84df66369a6b31eeda1a74a3114d66c160" translate="yes" xml:space="preserve">
          <source>It is also possible to test whether the pre-defined warnings categories are set in the calling module with the &lt;code&gt;warnings::enabled&lt;/code&gt; function. Consider this snippet of code:</source>
          <target state="translated">Также можно проверить, установлены ли заранее определенные категории предупреждений в вызывающем модуле с помощью функции &lt;code&gt;warnings::enabled&lt;/code&gt; . Рассмотрим этот фрагмент кода:</target>
        </trans-unit>
        <trans-unit id="3db1f66552fc819722dedb12482e309bce26efa4" translate="yes" xml:space="preserve">
          <source>It is also unique in that all other Perl operators impose a context (usually string or numeric context) on their operands, autoconverting those operands to those imposed contexts. In contrast, smartmatch</source>
          <target state="translated">Уникальность заключается также в том,что все другие операторы Perl накладывают на свои операнды контекст (обычно строковый или числовой),автоматически преобразуя эти операнды в эти накладываемые контексты.В отличие от этого,смарт-матч</target>
        </trans-unit>
        <trans-unit id="fac8d72d737b1435638a2eef2e2bc6f98342f178" translate="yes" xml:space="preserve">
          <source>It is also worth noting that &lt;code&gt;nextStream&lt;/code&gt; can be called at any time -- you don't have to wait until you have exhausted a compressed data stream before skipping to the next one.</source>
          <target state="translated">Также стоит отметить, что &lt;code&gt;nextStream&lt;/code&gt; можно вызвать в любое время - вам не нужно ждать, пока вы исчерпаете поток сжатых данных, прежде чем переходить к следующему.</target>
        </trans-unit>
        <trans-unit id="fe6480e97532361598fcacd4a646c8dd90b848cc" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name not defined by a &lt;code&gt;(?&amp;lt;&lt;i&gt;NAME&lt;/i&gt;&amp;gt;)&lt;/code&gt; earlier in the pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc49eaced7d721523b5bd759190363e32250fa1" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name not defined by a &lt;code&gt;(?&amp;lt;NAME&amp;gt;)&lt;/code&gt; earlier in the pattern.</source>
          <target state="translated">Ссылка на имя, не определенное &lt;code&gt;(?&amp;lt;NAME&amp;gt;)&lt;/code&gt; ранее в шаблоне, является ошибкой .</target>
        </trans-unit>
        <trans-unit id="13ee6665661c6d90800f41308ee104afc7c23af8" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name that is not declared somewhere in the pattern.</source>
          <target state="translated">Ошибкой является ссылка на имя,которое нигде не объявлено в шаблоне.</target>
        </trans-unit>
        <trans-unit id="65cfdd54d892c74c51301f814a65bd9d932d410a" translate="yes" xml:space="preserve">
          <source>It is an error to try to</source>
          <target state="translated">Ошибкой является попытка</target>
        </trans-unit>
        <trans-unit id="2f0a90fe17f957e846e3b518ba860308d4237cf1" translate="yes" xml:space="preserve">
          <source>It is assumed that if a module name is supplied, that that name matches the file name. Pods are not opened to check for the 'NAME' entry.</source>
          <target state="translated">Предполагается,что если поставляется имя модуля,то это имя совпадает с именем файла.Поды не открываются для проверки записи 'NAME'.</target>
        </trans-unit>
        <trans-unit id="c5af0c152794fef2b12ee8e78572d2cb96b0bb53" translate="yes" xml:space="preserve">
          <source>It is at this stage that &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; silently optimizes &lt;code&gt;/^/&lt;/code&gt; to mean &lt;code&gt;/^/m&lt;/code&gt; .</source>
          <target state="translated">Именно на этом этапе &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; молча оптимизирует &lt;code&gt;/^/&lt;/code&gt; до значения &lt;code&gt;/^/m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f53779f0c0d37544de988c790844edfe4fdb773" translate="yes" xml:space="preserve">
          <source>It is at this stage that &lt;code&gt;split()&lt;/code&gt; silently optimizes &lt;code&gt;/^/&lt;/code&gt; to mean &lt;code&gt;/^/m&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c668d4a29eb47ae15a72aa4d1dd8cfb718abf5" translate="yes" xml:space="preserve">
          <source>It is at this step that &lt;code&gt;\1&lt;/code&gt; is begrudgingly converted to &lt;code&gt;$1&lt;/code&gt; in the replacement text of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, in order to correct the incorrigible</source>
          <target state="translated">Именно на этом этапе &lt;code&gt;\1&lt;/code&gt; неохотно конвертируется в &lt;code&gt;$1&lt;/code&gt; в тексте замены &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; , чтобы исправить неисправимый</target>
        </trans-unit>
        <trans-unit id="5668f9f099405dc43b82952ae4d9de3551af43ad" translate="yes" xml:space="preserve">
          <source>It is at this step that &lt;code&gt;\1&lt;/code&gt; is begrudgingly converted to &lt;code&gt;$1&lt;/code&gt; in the replacement text of &lt;code&gt;s///&lt;/code&gt;, in order to correct the incorrigible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4466ca0969a2662c5b072bf7cd93ebda9f966a8c" translate="yes" xml:space="preserve">
          <source>It is basically equivalent to:</source>
          <target state="translated">Это в основном эквивалентно:</target>
        </trans-unit>
        <trans-unit id="d3008b3fc272ebfbc9d46dd564fe851829fe13a2" translate="yes" xml:space="preserve">
          <source>It is better to restructure your code so the end pointer is passed down so that you know what it actually is at the point of this call, but if that isn't possible, &lt;a href=&quot;#UTF8_CHK_SKIP&quot;&gt;&quot;&lt;code&gt;UTF8_CHK_SKIP&lt;/code&gt;&quot;&lt;/a&gt; can minimize the chance of accessing beyond the end of the input buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77b015f95e7c8d0f9144f6b141dfe36a63eb292" translate="yes" xml:space="preserve">
          <source>It is clear that inline code is going to be faster than subroutine or method calls, because there is less overhead, but this approach has the disadvantage of being less maintainable and comes at the cost of greater memory usage - there is no such thing as a free lunch. If you are searching for an element in a list, it can be more efficient to store the data in a hash structure, and then simply look to see whether the key is defined, rather than to loop through the entire array using grep() for instance. substr() may be (a lot) faster than grep() but not as flexible, so you have another trade-off to access. Your code may contain a line which takes 0.01 of a second to execute which if you call it 1,000 times, quite likely in a program parsing even medium sized files for instance, you already have a 10 second delay, in just one single code location, and if you call that line 100,000 times, your entire program will slow down to an unbearable crawl.</source>
          <target state="translated">Понятно,что встроенный код будет быстрее,чем вызов подпрограмм или методов,потому что меньше накладных расходов,но у такого подхода есть и недостаток-он менее удобен в обслуживании и достигается за счет большего использования памяти-бесплатного обеда не бывает.Если вы ищете элемент в списке,то может быть более эффективно хранить данные в хэш-структуре,а затем просто посмотреть,определен ли ключ,вместо того,чтобы,например,циклически перебирать весь массив с помощью grep().substr()может быть (намного)быстрее,чем grep(),но не настолько гибкой,так что у вас есть еще один компромисс для доступа.Ваш код может содержать строку,которая занимает 0.01 секунды на выполнение,и если вы вызываете ее 1000 раз,скорее всего,в программе,которая разбирает даже файлы среднего размера,например,у вас уже есть 10-секундная задержка,только в одном месте кода,и если вы вызываете эту строку 100 000 раз,то вся ваша программа замедлится до невыносимого ползучести.</target>
        </trans-unit>
        <trans-unit id="f6122f662407715d120a73ec05bd2bbbf07e1b28" translate="yes" xml:space="preserve">
          <source>It is common to simply say &lt;code&gt;$filename = Pod::Simple::Search-&amp;gt; new
-&amp;gt;find(&quot;perlvar&quot;)&lt;/code&gt; so that just the @INC (well, and scriptdir) directories are searched. (This happens because the &lt;code&gt;inc&lt;/code&gt; attribute is true by default.)</source>
          <target state="translated">Обычно просто говорят &lt;code&gt;$filename = Pod::Simple::Search-&amp;gt; new -&amp;gt;find(&quot;perlvar&quot;)&lt;/code&gt; чтобы искать только каталоги @INC (ну и scriptdir). (Это происходит потому, что по умолчанию атрибут &lt;code&gt;inc&lt;/code&gt; имеет значение true.)</target>
        </trans-unit>
        <trans-unit id="94fd6736ac13c38aadc8d6ee40bf099cf30a2334" translate="yes" xml:space="preserve">
          <source>It is commonly thought that if a system does not have the capability to dynamically load a library, you cannot build XSUBs. This is incorrect. You</source>
          <target state="translated">Обычно считается,что если система не имеет возможности динамической загрузки библиотеки,вы не можете собрать XSUB.Это неправильно.Вы</target>
        </trans-unit>
        <trans-unit id="7b3776ce40b36ce2eb6604faa164797c0a666707" translate="yes" xml:space="preserve">
          <source>It is convenient to think that the indirection operator &lt;code&gt;*&lt;/code&gt; should be considered as a part of the type and the address operator &lt;code&gt;&amp;amp;&lt;/code&gt; should be considered part of the variable. See &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; for more info about handling qualifiers and unary operators in C types.</source>
          <target state="translated">Удобно думать, что оператор косвенного обращения &lt;code&gt;*&lt;/code&gt; следует рассматривать как часть типа, а оператор адреса &lt;code&gt;&amp;amp;&lt;/code&gt; следует рассматривать как часть переменной. См. &lt;a href=&quot;perlxstypemap&quot;&gt;Perlxstypemap&lt;/a&gt; для получения дополнительной информации об обработке квалификаторов и унарных операторов в типах C.</target>
        </trans-unit>
        <trans-unit id="e49556be27809812b1f952c88dbd0fb8ac73080a" translate="yes" xml:space="preserve">
          <source>It is conventional to start layer names with a colon (for example, &lt;code&gt;:perlio&lt;/code&gt; ) to emphasize their similarity to variable &quot;attributes&quot;. But the code that parses layer specification strings, which is also used to decode the PERLIO environment variable, treats the colon as a separator.</source>
          <target state="translated">Принято начинать имена слоев с двоеточия (например &lt;code&gt;:perlio&lt;/code&gt; ), чтобы подчеркнуть их сходство с переменными &amp;laquo;атрибутами&amp;raquo;. Но код, анализирующий строки спецификации уровня, который также используется для декодирования переменной среды PERLIO, обрабатывает двоеточие как разделитель.</target>
        </trans-unit>
        <trans-unit id="0a6add6b8448b0bfc8e6cd8b6eca23cb56fc1aa2" translate="yes" xml:space="preserve">
          <source>It is conventional to start layer names with a colon (for example, &lt;code&gt;:perlio&lt;/code&gt;) to emphasize their similarity to variable &quot;attributes&quot;. But the code that parses layer specification strings, which is also used to decode the PERLIO environment variable, treats the colon as a separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddbcb8555d7ffc2811c34458dc5e23aebe16a93" translate="yes" xml:space="preserve">
          <source>It is eagerly hoped that in the future, increasing numbers of formats (and formatters) will support Unicode characters directly (as (X)HTML does with &lt;code&gt;&amp;amp;infin;&lt;/code&gt; , &lt;code&gt;&amp;amp;#8734;&lt;/code&gt;, or &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt;), reducing the need for idiosyncratic mappings of Unicode-to-</source>
          <target state="translated">Он охотно выразил надежду , что в будущем все большее число форматов (и форматтеров) будет поддерживать символы Unicode непосредственно (как (X) HTML делает с &lt;code&gt;&amp;amp;infin;&lt;/code&gt; , &lt;code&gt;&amp;amp;#8734;&lt;/code&gt; или &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt; ), уменьшая потребность в своеобразных сопоставления Unicode-to-</target>
        </trans-unit>
        <trans-unit id="11bfea9ea83d9dc8ba6d1c8b2251fc92f5e63836" translate="yes" xml:space="preserve">
          <source>It is eagerly hoped that in the future, increasing numbers of formats (and formatters) will support Unicode characters directly (as (X)HTML does with &lt;code&gt;&amp;amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;amp;#8734;&lt;/code&gt;, or &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt;), reducing the need for idiosyncratic mappings of Unicode-to-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1feb840e61338fb8d69eab115197ceb6e4d8f195" translate="yes" xml:space="preserve">
          <source>It is easier to see with comments:</source>
          <target state="translated">Легче видеть с комментариями:</target>
        </trans-unit>
        <trans-unit id="deebd2bf2cb329548cf17163d065366c59ebd497" translate="yes" xml:space="preserve">
          <source>It is entirely possible for a subroutine to have both a prototype and a signature. They do different jobs: the prototype affects compilation of calls to the subroutine, and the signature puts argument values into lexical variables at runtime. You can therefore write</source>
          <target state="translated">Вполне возможно,что в подпрограмме есть и прототип,и подпись.Они выполняют разные задачи:прототип влияет на компиляцию обращений к подпрограмме,а сигнатура помещает значения аргументов в лексические переменные во время выполнения.Поэтому вы можете написать</target>
        </trans-unit>
        <trans-unit id="63ae6e7127f1e6349a2992ac6b857022220dd1af" translate="yes" xml:space="preserve">
          <source>It is even possible to give your own names to characters and character sequences by using the &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; module. These custom names are lexically scoped, and so a given code point may have different names in different scopes. The name used is what is in effect at the time the &lt;code&gt;\N{}&lt;/code&gt; is expanded. For patterns in double-quotish context, that means at the time the pattern is parsed. But for patterns that are delimitted by single quotes, the expansion is deferred until pattern compilation time, which may very well have a different &lt;code&gt;charnames&lt;/code&gt; translator in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8705c44d271d802e23ff6717b34393b3365f69d" translate="yes" xml:space="preserve">
          <source>It is even possible to give your own names to characters and character sequences. For details, see &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">Можно даже дать свои собственные имена символам и последовательностям символов. Подробнее см. &lt;a href=&quot;charnames&quot;&gt;Имена символов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c3622fe65f713ae38110b205b49d3188003c82c" translate="yes" xml:space="preserve">
          <source>It is expected that arguments to methods that are not explicitly supposed to be changed are constant (but this is not enforced).</source>
          <target state="translated">Предполагается,что аргументы к методам,которые явно не предполагается изменять,являются постоянными (но это не принудительно).</target>
        </trans-unit>
        <trans-unit id="776c3073c10966ce7532e508c1ba6620f8fcb74a" translate="yes" xml:space="preserve">
          <source>It is expected that what exactly &lt;code&gt;'strict'&lt;/code&gt; does will evolve over time as we gain experience with it. This means that programs that compile under it in today's Perl may not compile, or may have more or fewer warnings, in future Perls. There is no backwards compatibility promises with regards to it. Also there are already proposals for an alternate syntax for enabling it. For these reasons, using it will raise a &lt;code&gt;experimental::re_strict&lt;/code&gt; class warning, unless that category is turned off.</source>
          <target state="translated">Ожидается, что то, что именно делает &lt;code&gt;'strict'&lt;/code&gt; , будет со временем развиваться по мере того, как мы приобретаем с ним опыт. Это означает, что программы, которые компилируются под ним в сегодняшнем Perl, могут не компилироваться или могут иметь больше или меньше предупреждений в будущих Perl. В отношении него нет никаких обещаний обратной совместимости. Также уже есть предложения по альтернативному синтаксису для его включения. По этим причинам его использование вызовет &lt;code&gt;experimental::re_strict&lt;/code&gt; класса :: re_strict , если эта категория не отключена.</target>
        </trans-unit>
        <trans-unit id="743ffcd338b65d877bd2bc22191ffd5f5bc78800" translate="yes" xml:space="preserve">
          <source>It is exported upon request.</source>
          <target state="translated">Экспорт осуществляется по запросу.</target>
        </trans-unit>
        <trans-unit id="fc922ccc86e1ddfa603184a6c1df119e90d551a2" translate="yes" xml:space="preserve">
          <source>It is generally a bad idea to mix non-UTF-8 locales and Unicode, and this issue is one of the reasons why. This warning is raised when Unicode rules would normally cause the result of this operation to contain a character that is in the range specified by the locale, 0..255, and hence is subject to the locale's rules, not Unicode's.</source>
          <target state="translated">Обычно плохая идея смешивать неUTF-8 локали и Юникод,и эта проблема является одной из причин.Это предупреждение появляется,когда правила Юникода обычно приводят к тому,что результат этой операции будет содержать символ,находящийся в диапазоне,заданном локалью,0...255,и,следовательно,подчиняющийся правилам локали,а не Юникода.</target>
        </trans-unit>
        <trans-unit id="4425fdf4018e2e8fba242ccf31d9fb769e12dacd" translate="yes" xml:space="preserve">
          <source>It is guaranteed that</source>
          <target state="translated">Гарантируется,что</target>
        </trans-unit>
        <trans-unit id="a6f4741397b5a8e1cbfacb47c2230423a05f8010" translate="yes" xml:space="preserve">
          <source>It is guaranteed that an</source>
          <target state="translated">Гарантируется,что</target>
        </trans-unit>
        <trans-unit id="13b4603391d295cad7c663188ece67a47ecf1dc6" translate="yes" xml:space="preserve">
          <source>It is hard to understand without digging what exactly matches ranges other than subsets of &lt;code&gt;[A-Z]&lt;/code&gt; , &lt;code&gt;[a-z]&lt;/code&gt; , and &lt;code&gt;[0-9]&lt;/code&gt; . A sound principle is to use only ranges that begin from and end at either alphabetics of equal case ([a-e], [A-E]), or digits ([0-9]). Anything else is unsafe or unclear. If in doubt, spell out the range in full.</source>
          <target state="translated">Трудно понять, не копаясь, что именно соответствует диапазонам, кроме подмножеств &lt;code&gt;[A-Z]&lt;/code&gt; , &lt;code&gt;[a-z]&lt;/code&gt; и &lt;code&gt;[0-9]&lt;/code&gt; . Разумным принципом является использование только диапазонов, которые начинаются и заканчиваются либо алфавитом одинакового регистра ([ae], [AE]), либо цифрами ([0-9]). Все остальное небезопасно или непонятно. Если сомневаетесь, укажите полный диапазон.</target>
        </trans-unit>
        <trans-unit id="32102cc598d5c6f1883220e9be88e26b0126c4bb" translate="yes" xml:space="preserve">
          <source>It is highly recommended to use the new interface.</source>
          <target state="translated">Настоятельно рекомендуется использовать новый интерфейс.</target>
        </trans-unit>
        <trans-unit id="ca5fa5ba1e81b193ad6d8416f6d80a9e68a2d380" translate="yes" xml:space="preserve">
          <source>It is however guaranteed that backslash or escape sequences never have a punctuation character following the backslash, not now, and not in a future version of Perl 5. So it is safe to put a backslash in front of a non-word character.</source>
          <target state="translated">Однако гарантируется,что обратный слеш или экранирующие последовательности никогда не будут иметь знака препинания после обратного слеша,не сейчас,и не в будущей версии Perl 5.Поэтому безопасно ставить обратный слеш перед несловесным символом.</target>
        </trans-unit>
        <trans-unit id="77f0274e9c470893b80643add674cf709738754d" translate="yes" xml:space="preserve">
          <source>It is implemented using the standard perl TIEHASH interface. Please see the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; entry in perlfunc(1) and perltie(1) for more information.</source>
          <target state="translated">Это реализовано с использованием стандартного интерфейса Perl TIEHASH. Пожалуйста , смотрите &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; запись в perlfunc (1) и perltie (1) для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="af6e31eac027382e54503e05f6d0085165cacf75" translate="yes" xml:space="preserve">
          <source>It is implemented using the standard perl TIEHASH interface. Please see the &lt;code&gt;tie&lt;/code&gt; entry in perlfunc(1) and perltie(1) for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ed786f282bde3aa8de3b1b643efa3bb560a2fd" translate="yes" xml:space="preserve">
          <source>It is important that you read the &lt;a href=&quot;opcode&quot;&gt;Opcode&lt;/a&gt; module documentation for more information, especially for detailed definitions of opnames, optags and opsets.</source>
          <target state="translated">Для получения дополнительной информации, особенно для подробных определений имен операций, оптических тегов и наборов операций, важно прочитать документацию по модулю &lt;a href=&quot;opcode&quot;&gt;Opcode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2977106e878eb3427358dec08f1824351409ba37" translate="yes" xml:space="preserve">
          <source>It is important that you use a supported 'make' program, and ensure Config.pm knows about it. If you don't have nmake, you can either get dmake from the location mentioned earlier or get an old version of nmake reportedly available from:</source>
          <target state="translated">Важно,чтобы вы использовали поддерживаемую программу 'make' и убедились,что Config.pm знает о ней.Если у вас нет nmake,вы можете либо получить dmake из места,упомянутого ранее,либо получить старую версию nmake,доступную по сообщениям:</target>
        </trans-unit>
        <trans-unit id="ff64ea14bb1b01f98f924406ee57c3ed5e8b95d4" translate="yes" xml:space="preserve">
          <source>It is important to do &lt;code&gt;make dist&lt;/code&gt; as early as possible. This way you can easily merge(1) your changes to autogenerated files if you decide to edit your &lt;code&gt;.h&lt;/code&gt; files and rerun h2xs.</source>
          <target state="translated">Важно &lt;code&gt;make dist&lt;/code&gt; как можно раньше. Таким образом, вы можете легко объединить (1) свои изменения в автоматически сгенерированные файлы, если вы решите отредактировать свои файлы &lt;code&gt;.h&lt;/code&gt; и повторно запустить h2xs.</target>
        </trans-unit>
        <trans-unit id="a9a567c14d6791400f926d0994fcc8f3b056f648" translate="yes" xml:space="preserve">
          <source>It is important to know that these CLIs may behave different when the command line contains special characters, in particular quotes or backslashes. For example, with Unix shells you can use single quotes (&lt;code&gt;'&lt;/code&gt;) and double quotes (&lt;code&gt;&quot;&lt;/code&gt;) to group words together. The following alternatives are equivalent on Unix:</source>
          <target state="translated">Важно знать, что эти интерфейсы командной строки могут вести себя по-разному, когда командная строка содержит специальные символы, в частности кавычки или обратную косую черту. Например, в оболочках Unix вы можете использовать одинарные кавычки ( &lt;code&gt;'&lt;/code&gt; ) и двойные кавычки ( &lt;code&gt;&quot;&lt;/code&gt; ) для группировки слов вместе. Следующие альтернативы эквивалентны в Unix:</target>
        </trans-unit>
        <trans-unit id="dcb1aa33844e3457c736e676b2e42e15c5425cfa" translate="yes" xml:space="preserve">
          <source>It is important to note that the variable can be notified even if no thread &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; on the variable. It is therefore important to check the value of the variable and go back to waiting if the requirement is not fulfilled. For example, to pause until a shared counter drops to zero:</source>
          <target state="translated">Важно отметить, что переменная может быть уведомлена, даже если для переменной нет потока &lt;code&gt;cond_signal&lt;/code&gt; или &lt;code&gt;cond_broadcast&lt;/code&gt; . Поэтому важно проверить значение переменной и вернуться в режим ожидания, если требование не выполнено. Например, чтобы сделать паузу, пока общий счетчик не опустится до нуля:</target>
        </trans-unit>
        <trans-unit id="38610253c48ac1bf013b9d6e4c9a87cd05da4c30" translate="yes" xml:space="preserve">
          <source>It is important to note that when called with an item that is recovered by using &lt;code&gt;localeconv&lt;/code&gt;, the buffer from any previous explicit call to &lt;code&gt;localeconv&lt;/code&gt; will be overwritten. This means you must save that buffer's contents if you need to access them after a call to this function. (But note that you might not want to be using &lt;code&gt;localeconv()&lt;/code&gt; directly anyway, because of issues like the ones listed in the second item of this list (above) for &lt;code&gt;RADIXCHAR&lt;/code&gt; and &lt;code&gt;THOUSEP&lt;/code&gt;. You can use the methods given in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; to call &lt;a href=&quot;posix#localeconv&quot;&gt;&quot;localeconv&quot; in POSIX&lt;/a&gt; and avoid all the issues, but then you have a hash to unpack).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07be512ccc5c73682b884e92456cd275f3ff5ced" translate="yes" xml:space="preserve">
          <source>It is important to realize when you use these Unicode boundaries, that you are taking a risk that a future version of Perl which contains a later version of the Unicode Standard will not work precisely the same way as it did when your code was written. These rules are not considered stable and have been somewhat more subject to change than the rest of the Standard. Unicode reserves the right to change them at will, and Perl reserves the right to update its implementation to Unicode's new rules. In the past, some changes have been because new characters have been added to the Standard which have different characteristics than all previous characters, so new rules are formulated for handling them. These should not cause any backward compatibility issues. But some changes have changed the treatment of existing characters because the Unicode Technical Committee has decided that the change is warranted for whatever reason. This could be to fix a bug, or because they think better results are obtained with the new rule.</source>
          <target state="translated">Важно понимать,когда вы используете эти границы Юникода,что вы рискуете тем,что будущая версия Perl,которая содержит более позднюю версию Стандарта Юникода,не будет работать точно так же,как она работала,когда ваш код был написан.Эти правила не считаются стабильными и в несколько большей степени подвержены изменениям,чем остальная часть Стандарта.Юникод оставляет за собой право изменять их по своему усмотрению,а Perl оставляет за собой право обновлять свою реализацию в соответствии с новыми правилами Юникода.В прошлом некоторые изменения были вызваны тем,что в Стандарт были добавлены новые символы,которые имеют характеристики,отличные от всех предыдущих,поэтому для работы с ними формулируются новые правила.Это не должно вызывать проблем с обратной совместимостью.Но некоторые изменения изменили подход к существующим символам,потому что Технический Комитет Юникода решил,что изменение является оправданным по любой причине.Это может быть исправление ошибки или потому,что они думают,что новые правила дают лучшие результаты.</target>
        </trans-unit>
        <trans-unit id="6b377275b56d69ca0e60d3e0cbc10a16f405fe04" translate="yes" xml:space="preserve">
          <source>It is important to remember that &lt;code&gt;yield()&lt;/code&gt; is only a hint to give up the CPU, it depends on your hardware, OS and threading libraries what actually happens. &lt;b&gt;On many operating systems, yield() is a no-op.&lt;/b&gt; Therefore it is important to note that one should not build the scheduling of the threads around &lt;code&gt;yield()&lt;/code&gt; calls. It might work on your platform but it won't work on another platform.</source>
          <target state="translated">Важно помнить, что &lt;code&gt;yield()&lt;/code&gt; - это только намек на отказ от ЦП, это зависит от вашего оборудования, ОС и потоковых библиотек, что на самом деле происходит. &lt;b&gt;Во многих операционных системах yield () не работает. &lt;/b&gt;Поэтому важно отметить, что не следует строить планирование потоков вокруг вызовов &lt;code&gt;yield()&lt;/code&gt; . Он может работать на вашей платформе, но не будет работать на другой платформе.</target>
        </trans-unit>
        <trans-unit id="229373f44a4516dbdfee3cc1ec19491aa465bff2" translate="yes" xml:space="preserve">
          <source>It is intended mainly for use in assignments to references (see &lt;a href=&quot;#Assigning-to-References&quot;&gt;&quot;Assigning to References&quot;&lt;/a&gt;, above). It also allows the backslash to be used on just some items in a list of declared variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb902098169f8bf10c78af87761104595e279d51" translate="yes" xml:space="preserve">
          <source>It is intended to be called in this manner:</source>
          <target state="translated">Предполагается,что он будет называться так:</target>
        </trans-unit>
        <trans-unit id="c0729952a79f213dacf0ff4ae76e571d0559ed54" translate="yes" xml:space="preserve">
          <source>It is just like &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt; but it takes an extra parameter placed after all the others, &lt;code&gt;msgs&lt;/code&gt;. If this parameter is 0, this function behaves identically to &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise, &lt;code&gt;msgs&lt;/code&gt; should be a pointer to an &lt;code&gt;AV *&lt;/code&gt; variable, in which this function creates a new AV to contain any appropriate messages. The elements of the array are ordered so that the first message that would have been displayed is in the 0th element, and so on. Each element is a hash with three key-value pairs, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b304ade153185375df945a6e52ec74226ffc08" translate="yes" xml:space="preserve">
          <source>It is just like &lt;code&gt;&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;&lt;/code&gt; but it takes an extra parameter placed after all the others, &lt;code&gt;msgs&lt;/code&gt;. If this parameter is 0, this function behaves identically to &lt;code&gt;&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise, &lt;code&gt;msgs&lt;/code&gt; should be a pointer to an &lt;code&gt;HV *&lt;/code&gt; variable, in which this function creates a new HV to contain any appropriate messages. The hash has three key-value pairs, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c67b173e9f7ca15b0d9849fa732dc6b9c27b1b9" translate="yes" xml:space="preserve">
          <source>It is legal to intermix calls to &lt;code&gt;gzread&lt;/code&gt; and &lt;code&gt;gzreadline&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;gzread&lt;/code&gt; смешивать вызовы gzread и &lt;code&gt;gzreadline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="310546f36d0b89e4ca2512f6a8bbbc58b3213ebb" translate="yes" xml:space="preserve">
          <source>It is legal to intermix calls to &lt;code&gt;gzread&lt;/code&gt; and &lt;code&gt;gzreadline&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b081e40b0dd1e97c28fc968fc88db21c07110075" translate="yes" xml:space="preserve">
          <source>It is less confusing to either calculate the result fully, and afterwards round it explicitly, or use the additional parameters to the math functions like so:</source>
          <target state="translated">Менее запутанным является либо полное вычисление результата,а затем его явное округление,либо использование дополнительных параметров к математическим функциям вроде этого:</target>
        </trans-unit>
        <trans-unit id="1a0e27e331f66d429f8d776eb7eea1b1dc292c9e" translate="yes" xml:space="preserve">
          <source>It is like &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt; but it takes an extra parameter placed after all the others, &lt;code&gt;errors&lt;/code&gt;. If this parameter is 0, this function behaves identically to &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise, &lt;code&gt;errors&lt;/code&gt; should be a pointer to a &lt;code&gt;U32&lt;/code&gt; variable, which this function sets to indicate any errors found. Upon return, if &lt;code&gt;*errors&lt;/code&gt; is 0, there were no errors found. Otherwise, &lt;code&gt;*errors&lt;/code&gt; is the bit-wise &lt;code&gt;OR&lt;/code&gt; of the bits described in the list below. Some of these bits will be set if a malformation is found, even if the input &lt;code&gt;flags&lt;/code&gt; parameter indicates that the given malformation is allowed; those exceptions are noted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ac2033e4ba80b8d679681b08231b45a9481613f" translate="yes" xml:space="preserve">
          <source>It is more correct and more complete than &lt;a href=&quot;HTTP::Lite&quot;&gt;HTTP::Lite&lt;/a&gt;. It supports proxies and redirection. It also correctly resumes after EINTR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f913862bf185692af7e2eaaf2148c65356aec6" translate="yes" xml:space="preserve">
          <source>It is most convenient to use in a &lt;code&gt;foreach&lt;/code&gt; loop, for example:</source>
          <target state="translated">Удобнее всего использовать в цикле &lt;code&gt;foreach&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="69bffc928e3fa117d0fd3dd3376d4295ace44212" translate="yes" xml:space="preserve">
          <source>It is no longer possible to compile PA-RISC 1.0 executables on either the PA-RISC 1.1 or 2.0 platforms. The command-line flags are accepted, but the resulting executable will not run when transferred to a PA-RISC 1.0 system.</source>
          <target state="translated">Скомпилировать исполняемые файлы PA-RISC 1.0 на платформах PA-RISC 1.1 и 2.0 больше невозможно.Флаги командной строки принимаются,но результирующий исполняемый файл не будет запущен при передаче в систему PA-RISC 1.0.</target>
        </trans-unit>
        <trans-unit id="09c5f6dc5c28104c8b1496a7745505dfd0c3755b" translate="yes" xml:space="preserve">
          <source>It is no longer possible to link PA-RISC 1.0 shared libraries (even though the command-line flags are still present).</source>
          <target state="translated">Больше невозможно связать разделяемые библиотеки PA-RISC 1.0 (несмотря на то,что флаги командной строки все еще присутствуют).</target>
        </trans-unit>
        <trans-unit id="5e391513315c3abeec46220661da8fc25e5f09fd" translate="yes" xml:space="preserve">
          <source>It is not considered an error for &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to return false if it fails due to an &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (or equivalent) condition. This means one can still use the common convention of testing the return value of &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; when called with the &lt;code&gt;LOCK_NB&lt;/code&gt; option:</source>
          <target state="translated">Не считается ошибкой возвращение &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; false в случае сбоя из-за &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (или аналогичного) условия. Это означает, что можно по-прежнему использовать обычное соглашение о проверке возвращаемого значения &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; при вызове с параметром &lt;code&gt;LOCK_NB&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5203d22c8328a2d0b2cff53631202830f7dc2011" translate="yes" xml:space="preserve">
          <source>It is not considered an error for &lt;code&gt;flock&lt;/code&gt; to return false if it fails due to an &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (or equivalent) condition. This means one can still use the common convention of testing the return value of &lt;code&gt;flock&lt;/code&gt; when called with the &lt;code&gt;LOCK_NB&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb49901ab613cbcc1013bad05870bde6b73a1f49" translate="yes" xml:space="preserve">
          <source>It is not desirable to import the functions &lt;code&gt;fieldhash&lt;/code&gt; and/or &lt;code&gt;fieldhashes&lt;/code&gt; into every class that is going to use them. They are only used once to set up the class. When the class is up and running, these functions serve no more purpose.</source>
          <target state="translated">&lt;code&gt;fieldhash&lt;/code&gt; импортировать функции fieldhash и / или &lt;code&gt;fieldhashes&lt;/code&gt; в каждый класс, который будет их использовать. Они используются только один раз для создания класса. Когда класс запущен и работает, эти функции больше не служат.</target>
        </trans-unit>
        <trans-unit id="c5fbc8d597bc2a95fe72ba36ecdd3925f81ca3bb" translate="yes" xml:space="preserve">
          <source>It is not necessary for voting to be held on cherry-picking perldelta entries associated with changes that have already been cherry-picked, nor for the maint-pumpking to obtain votes on changes required by the</source>
          <target state="translated">Голосование не требуется ни для того,чтобы проголосовать по уже выбранным вишневым позициям perldelta,связанным с изменениями,ни для того,чтобы мейнстрит-прокачка получила голоса по изменениям,необходимым для</target>
        </trans-unit>
        <trans-unit id="27e3bb472e9cdfda94e8831e0977881e11fb42e5" translate="yes" xml:space="preserve">
          <source>It is not necessary to include every change meeting these criteria, and in general the focus should be on addressing security issues, crashing bugs, regressions and serious installation issues. The temptation to include a plethora of minor changes that don't affect the installation or execution of perl (e.g. spelling corrections in documentation) should be resisted in order to reduce the overall risk of overlooking something. The intention is to create maintenance releases which are both worthwhile and which users can have full confidence in the stability of. (A secondary concern is to avoid burning out the maint-pumpking or overwhelming other committers voting on changes to be included (see &lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;&quot;Getting changes into a maint branch&quot;&lt;/a&gt; below).)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee4bc3261e1d5762f4a782cbbcca1c13a9e84eb" translate="yes" xml:space="preserve">
          <source>It is not necessary to include every change meeting these criteria, and in general the focus should be on addressing security issues, crashing bugs, regressions and serious installation issues. The temptation to include a plethora of minor changes that don't affect the installation or execution of perl (e.g. spelling corrections in documentation) should be resisted in order to reduce the overall risk of overlooking something. The intention is to create maintenance releases which are both worthwhile and which users can have full confidence in the stability of. (A secondary concern is to avoid burning out the maint-pumpking or overwhelming other committers voting on changes to be included (see &lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;Getting changes into a maint branch&lt;/a&gt; below).)</source>
          <target state="translated">Нет необходимости включать все изменения, отвечающие этим критериям, и в целом следует сосредоточить внимание на устранении проблем безопасности, сбоев, ошибок, регрессий и серьезных проблем с установкой. Следует противостоять соблазну включить множество мелких изменений, не влияющих на установку или выполнение perl (например, исправления орфографии в документации), чтобы снизить общий риск чего-то пропустить. Намерение состоит в том, чтобы создать выпуски обслуживания, которые будут полезными и в стабильности которых пользователи могут быть полностью уверены. (Второстепенная задача состоит в том, чтобы не сжечь maint-pumpking или подавление других коммиттеров, голосующих за изменения, которые должны быть включены (см. &lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;Получение изменений в ветку maint&lt;/a&gt; ниже).)</target>
        </trans-unit>
        <trans-unit id="90bcb58fb92d14a7b685940a550af6acd8800f2a" translate="yes" xml:space="preserve">
          <source>It is not necessary to mention DynaLoader or the current extension when filling in INCLUDE_EXT. If the INCLUDE_EXT is mentioned but is empty then only DynaLoader and the current extension will be included in the build.</source>
          <target state="translated">При заполнении INCLUDE_EXT нет необходимости упоминать DynaLoader или текущее расширение.Если INCLUDE_EXT упомянута,но пуста,то в сборку будет включен только DynaLoader и текущее расширение.</target>
        </trans-unit>
        <trans-unit id="6c22235436c0d9c88ea34e3651dd185b541bd55a" translate="yes" xml:space="preserve">
          <source>It is not possible to have a subroutine or a keyword with the same name as a constant in the same package. This is probably a Good Thing.</source>
          <target state="translated">Невозможно иметь в одном пакете подпрограмму или ключевое слово с тем же именем,что и константа.Вероятно,это хорошая вещь.</target>
        </trans-unit>
        <trans-unit id="f4712dd85edea86a32c5bfd8ffd1fe49536a91d9" translate="yes" xml:space="preserve">
          <source>It is not possible to pack or unpack bit fields - just integral bytes. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; always starts at the next byte boundary and &quot;rounds up&quot; to the next multiple of 8 by adding zero bits as required. (If you do want bit fields, there is &lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;. Or you could implement bit field handling at the character string level, using split, substr, and concatenation on unpacked bit strings.)</source>
          <target state="translated">Битовые поля невозможно упаковать или распаковать - только целые байты. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; всегда начинается на границе следующего байта и &quot;округляется&quot; до следующего кратного 8 путем добавления нулевых битов по мере необходимости. (Если вам нужны битовые поля, есть &lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt; . Или вы можете реализовать обработку битовых полей на уровне символьной строки, используя split, substr и конкатенацию для распакованных битовых строк.)</target>
        </trans-unit>
        <trans-unit id="39a07790029fea0888a82dfcdbb3f4369b9da3f5" translate="yes" xml:space="preserve">
          <source>It is not possible to pack or unpack bit fields - just integral bytes. &lt;code&gt;pack&lt;/code&gt; always starts at the next byte boundary and &quot;rounds up&quot; to the next multiple of 8 by adding zero bits as required. (If you do want bit fields, there is &lt;a href=&quot;perlfunc#vec&quot;&gt;&quot;vec&quot; in perlfunc&lt;/a&gt;. Or you could implement bit field handling at the character string level, using split, substr, and concatenation on unpacked bit strings.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3efe75bc9ad9fbe460b3b9a87287e6aa69baa4d8" translate="yes" xml:space="preserve">
          <source>It is not safe to use the value of &lt;code&gt;$^X&lt;/code&gt; as a path name of a file, as some operating systems that have a mandatory suffix on executable files do not require use of the suffix when invoking a command. To convert the value of &lt;code&gt;$^X&lt;/code&gt; to a path name, use the following statements:</source>
          <target state="translated">Небезопасно использовать значение &lt;code&gt;$^X&lt;/code&gt; в качестве имени пути к файлу, поскольку некоторые операционные системы, которые имеют обязательный суффикс для исполняемых файлов, не требуют использования суффикса при вызове команды. Чтобы преобразовать значение &lt;code&gt;$^X&lt;/code&gt; в имя пути, используйте следующие операторы:</target>
        </trans-unit>
        <trans-unit id="17f49b3471db481f432117951bcb8866bb533894" translate="yes" xml:space="preserve">
          <source>It is not uncommon to want to match a range of characters. Luckily, instead of listing all characters in the range, one may use the hyphen (&lt;code&gt;-&lt;/code&gt; ). If inside a bracketed character class you have two characters separated by a hyphen, it's treated as if all characters between the two were in the class. For instance, &lt;code&gt;[0-9]&lt;/code&gt; matches any ASCII digit, and &lt;code&gt;[a-m]&lt;/code&gt; matches any lowercase letter from the first half of the ASCII alphabet.</source>
          <target state="translated">Нередко возникает желание сопоставить диапазон символов. К счастью, вместо перечисления всех символов в диапазоне можно использовать дефис ( &lt;code&gt;-&lt;/code&gt; ). Если внутри класса символов в квадратных скобках у вас есть два символа, разделенных дефисом, это обрабатывается так, как если бы все символы между ними находились в классе. Например, &lt;code&gt;[0-9]&lt;/code&gt; соответствует любой цифре ASCII, а &lt;code&gt;[a-m]&lt;/code&gt; соответствует любой строчной букве из первой половины алфавита ASCII.</target>
        </trans-unit>
        <trans-unit id="7607528bdce01b011f213f8ac77cd85f02fbbdd6" translate="yes" xml:space="preserve">
          <source>It is not uncommon to want to match a range of characters. Luckily, instead of listing all characters in the range, one may use the hyphen (&lt;code&gt;-&lt;/code&gt;). If inside a bracketed character class you have two characters separated by a hyphen, it's treated as if all characters between the two were in the class. For instance, &lt;code&gt;[0-9]&lt;/code&gt; matches any ASCII digit, and &lt;code&gt;[a-m]&lt;/code&gt; matches any lowercase letter from the first half of the ASCII alphabet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea195389d2ab8304dae6a2be37001201928a81bd" translate="yes" xml:space="preserve">
          <source>It is now being maintained separately from the Perl core by Dave Rolsky, &amp;lt;autarch@urth.org&amp;gt;.</source>
          <target state="translated">Сейчас он поддерживается отдельно от ядра Perl Дэйвом Рольски, &amp;lt;autarch@urth.org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="0a2d81d68cd0e192d7fee2715fc04989d662c22e" translate="yes" xml:space="preserve">
          <source>It is often more readable to use the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator between key/value pairs. The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is mostly just a more visually distinctive synonym for a comma, but it also arranges for its left-hand operand to be interpreted as a string if it's a bareword that would be a legal simple identifier. &lt;code&gt;=&amp;gt;&lt;/code&gt; doesn't quote compound identifiers, that contain double colons. This makes it nice for initializing hashes:</source>
          <target state="translated">Часто удобнее использовать оператор &lt;code&gt;=&amp;gt;&lt;/code&gt; между парами ключ / значение. Оператор &lt;code&gt;=&amp;gt;&lt;/code&gt; в основном является просто более визуально отличительным синонимом запятой, но он также обеспечивает интерпретацию своего левого операнда как строку, если это простое слово, которое было бы легальным простым идентификатором. &lt;code&gt;=&amp;gt;&lt;/code&gt; не цитирует составные идентификаторы, содержащие двойные двоеточия. Это удобно для инициализации хэшей:</target>
        </trans-unit>
        <trans-unit id="c425383e0dcd08da6401882b3bf5fc73ffa2b23f" translate="yes" xml:space="preserve">
          <source>It is often not wise to share an object unless the class itself has been written to support sharing. For example, a shared object's destructor may get called multiple times, once for each thread's scope exit, or may not get called at all if it is embedded inside another shared object. Another issue is that the contents of hash-based objects will be lost due to the above mentioned limitation. See</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5507a15a15ea470ddab20bdff08a946fb003e3" translate="yes" xml:space="preserve">
          <source>It is often not wise to share an object unless the class itself has been written to support sharing. For example, an object's destructor may get called multiple times, once for each thread's scope exit. Another danger is that the contents of hash-based objects will be lost due to the above mentioned limitation. See</source>
          <target state="translated">Часто неразумно делиться объектом,если только сам класс не был написан для поддержки совместного использования.Например,деструктор объекта может вызываться несколько раз,один раз для выхода из области видимости каждого потока.Другая опасность заключается в том,что содержимое хэш-объектов будет потеряно из-за вышеуказанного ограничения.См..</target>
        </trans-unit>
        <trans-unit id="c69ba08cbdace146eeaa3088aa2fbd7151747d45" translate="yes" xml:space="preserve">
          <source>It is okay for the lines starting at the &quot;CODE:&quot; line to not be indented. However, for readability purposes, it is suggested that you indent CODE: one level and the lines following one more level.</source>
          <target state="translated">Строки,начинающиеся в строке &quot;CODE:&quot;,не должны иметь отступов.Однако для удобочитаемости предлагается сделать отступ CODE:на один уровень и строки,следующие за еще одним уровнем.</target>
        </trans-unit>
        <trans-unit id="65df07e3fa6135b82df3a9d6866989ee7ae4d5d2" translate="yes" xml:space="preserve">
          <source>It is only used on OS/2 and Win32.</source>
          <target state="translated">Используется только на OS/2 и Win32.</target>
        </trans-unit>
        <trans-unit id="3ea8b006ce3e53db87407f2dbaa5815e87ff2f78" translate="yes" xml:space="preserve">
          <source>It is particularly important to have this graft line if any bisecting is done in the area of the &quot;merge&quot; in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6661787e0f495e149a6ee0b4ddf2a5d46d4df496" translate="yes" xml:space="preserve">
          <source>It is particularly important to note that neither the shell nor the C runtime do any wildcard expansions of command-line arguments (so wildcards need not be quoted). Also, the quoting behaviours of the shell and the C runtime are rudimentary at best (and may, if you are using a non-standard shell, be inconsistent). The only (useful) quote character is the double quote (&quot;). It can be used to protect spaces and other special characters in arguments.</source>
          <target state="translated">Особенно важно отметить,что ни оболочка,ни время выполнения C не делают никаких расширений аргументов командной строки с помощью шаблонов (поэтому шаблоны не обязательно приводить в кавычки).Кроме того,поведение оболочки и времени выполнения C в кавычках в лучшем случае рудиментарно (и может,если вы используете нестандартную оболочку,быть непоследовательным).Единственный (полезный)символ кавычки-двойная кавычка (&quot;).Она может быть использована для защиты пробелов и других специальных символов в аргументах.</target>
        </trans-unit>
        <trans-unit id="b08f708cd4767406ca484e1891baf6f457b1498f" translate="yes" xml:space="preserve">
          <source>It is possible for the Perl subroutine you are calling to terminate abnormally, e.g., by calling</source>
          <target state="translated">Подпрограмма Perl,которую Вы вызываете,может быть прервана аномально,например,по телефону</target>
        </trans-unit>
        <trans-unit id="68748e768505aa715cf11b4ae34ec36bb19593be" translate="yes" xml:space="preserve">
          <source>It is possible that, upon completion, not all arguments in the string have been processed. &lt;code&gt;GetOptionsFromString&lt;/code&gt; will, when called in list context, return both the return status and an array reference to any remaining arguments:</source>
          <target state="translated">Возможно, что после завершения не все аргументы в строке были обработаны. &lt;code&gt;GetOptionsFromString&lt;/code&gt; при вызове в контексте списка будет возвращать как статус возврата, так и ссылку на массив для любых оставшихся аргументов:</target>
        </trans-unit>
        <trans-unit id="67c5b12c61d00e32b42a8983e07a796133ebb6eb" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;a href=&quot;perlmod#BEGIN%2C-UNITCHECK%2C-CHECK%2C-INIT-and-END&quot;&gt;END blocks&lt;/a&gt; to threads by using &lt;a href=&quot;perlfunc#require-VERSION&quot;&gt;require&lt;/a&gt; or &lt;a href=&quot;perlfunc#eval-EXPR&quot;&gt;eval&lt;/a&gt; with the appropriate code. These &lt;code&gt;END&lt;/code&gt; blocks will then be executed when the thread's interpreter is destroyed (i.e., either during a &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call, or at program termination).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1fb645dee4eb2dcf81d78a3bbd52439eec6574" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;END blocks&lt;/a&gt; to threads by using &lt;a href=&quot;functions/require&quot;&gt;require VERSION&lt;/a&gt; or &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; with the appropriate code. These &lt;code&gt;END&lt;/code&gt; blocks will then be executed when the thread's interpreter is destroyed (i.e., either during a &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call, or at program termination).</source>
          <target state="translated">Можно добавлять &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;блоки END&lt;/a&gt; в потоки, используя &lt;a href=&quot;functions/require&quot;&gt;require VERSION&lt;/a&gt; или &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; с соответствующим кодом. Эти блоки &lt;code&gt;END&lt;/code&gt; будут затем выполняться, когда интерпретатор потока будет уничтожен (то есть либо во время вызова &lt;code&gt;-&amp;gt;join()&lt;/code&gt; , либо при завершении программы).</target>
        </trans-unit>
        <trans-unit id="103a4ec3966b9d4c47f8bb4d45cb27898db88b92" translate="yes" xml:space="preserve">
          <source>It is possible to ask for a different method resolution order with the &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma.</source>
          <target state="translated">Можно запросить другой порядок разрешения методов с помощью &lt;a href=&quot;mro&quot;&gt;прагмы mro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="214e8fa8e052ffd8fef627a3a69587c1d8000f20" translate="yes" xml:space="preserve">
          <source>It is possible to ask for such a statistic at arbitrary points in your execution using the mstat() function out of the standard Devel::Peek module.</source>
          <target state="translated">Подобную статистику можно запросить в произвольных точках исполнения,используя функцию mstat()из стандартного модуля Devel::Peek.</target>
        </trans-unit>
        <trans-unit id="b3c2ec1b334ee0d70dae2975648b13f78c06cb41" translate="yes" xml:space="preserve">
          <source>It is possible to build a threaded version of perl on Solaris. The entire perl thread implementation is still experimental, however, so beware.</source>
          <target state="translated">На Solaris можно построить потоковую версию perl.Вся реализация потока perl все еще является экспериментальной,поэтому будьте осторожны.</target>
        </trans-unit>
        <trans-unit id="5dcdcf19c7450b4c54b9304c481faacc66e7c2fc" translate="yes" xml:space="preserve">
          <source>It is possible to compile a version of threaded Perl on any version of HP-UX before 10.30, but it is strongly suggested that you be running on HP-UX 11.00 at least.</source>
          <target state="translated">Возможно скомпилировать потоковую Perl версию на любой версии HP-UX до 10.30,но настоятельно рекомендуется,чтобы вы работали как минимум на HP-UX 11.00.</target>
        </trans-unit>
        <trans-unit id="fda7319a695e60b7430ed01765a1f487df41c0cc" translate="yes" xml:space="preserve">
          <source>It is possible to control which characters terminate words by modifying &lt;code&gt;$Text::Wrap::break&lt;/code&gt; . Set this to a string such as &lt;code&gt;'[\s:]'&lt;/code&gt; (to break before spaces or colons) or a pre-compiled regexp such as &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/[\s']/&lt;/a&gt;&lt;/code&gt; (to break before spaces or apostrophes). The default is simply &lt;code&gt;'\s'&lt;/code&gt; ; that is, words are terminated by spaces. (This means, among other things, that trailing punctuation such as full stops or commas stay with the word they are &quot;attached&quot; to.) Setting &lt;code&gt;$Text::Wrap::break&lt;/code&gt; to a regular expression that doesn't eat any characters (perhaps just a forward look-ahead assertion) will cause warnings.</source>
          <target state="translated">Можно контролировать, какие символы завершают слова, изменив &lt;code&gt;$Text::Wrap::break&lt;/code&gt; . Задайте для него строку, такую ​​как &lt;code&gt;'[\s:]'&lt;/code&gt; (для разрыва перед пробелами или двоеточиями) или предварительно скомпилированное регулярное выражение, например &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/[\s']/&lt;/a&gt;&lt;/code&gt; (для разрыва перед пробелами или апострофами). По умолчанию просто &lt;code&gt;'\s'&lt;/code&gt; ; то есть слова заканчиваются пробелами. (Это означает, среди прочего, что конечные знаки препинания, такие как точки или запятые, остаются со словом, к которому они &amp;laquo;привязаны&amp;raquo;.) Установка &lt;code&gt;$Text::Wrap::break&lt;/code&gt; в регулярное выражение, которое не использует никаких символов ( возможно, просто утверждение упреждающего просмотра) вызовет предупреждения.</target>
        </trans-unit>
        <trans-unit id="4b27989d9b82508c46a4fe952eadfb7a10b89ae6" translate="yes" xml:space="preserve">
          <source>It is possible to control which characters terminate words by modifying &lt;code&gt;$Text::Wrap::break&lt;/code&gt;. Set this to a string such as &lt;code&gt;'[\s:]'&lt;/code&gt; (to break before spaces or colons) or a pre-compiled regexp such as &lt;code&gt;qr/[\s']/&lt;/code&gt; (to break before spaces or apostrophes). The default is simply &lt;code&gt;'\s'&lt;/code&gt;; that is, words are terminated by spaces. (This means, among other things, that trailing punctuation such as full stops or commas stay with the word they are &quot;attached&quot; to.) Setting &lt;code&gt;$Text::Wrap::break&lt;/code&gt; to a regular expression that doesn't eat any characters (perhaps just a forward look-ahead assertion) will cause warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe767cd6ad41a1bf2749df0593b7a56afc9ca68" translate="yes" xml:space="preserve">
          <source>It is possible to create a &quot;circular reference&quot; in Perl, which can lead to memory leaks. A circular reference occurs when two references contain a reference to each other, like this:</source>
          <target state="translated">В Perl можно создать &quot;круговую ссылку&quot;,которая может привести к утечке памяти.Циркулярная ссылка возникает,когда две ссылки содержат ссылку друг на друга:</target>
        </trans-unit>
        <trans-unit id="194e4ce07b732bc978b1694be34e6655ffc1b7f6" translate="yes" xml:space="preserve">
          <source>It is possible to determine which character set you are operating under. But first you need to be really really sure you need to do this. Your code will be simpler and probably just as portable if you don't have to test the character set and do different things, depending. There are actually only very few circumstances where it's not easy to write straight-line code portable to all character sets. See &lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;&quot;Unicode and EBCDIC&quot; in perluniintro&lt;/a&gt; for how to portably specify characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c791c22192baa95a06c328176e1b85eddd8c69ea" translate="yes" xml:space="preserve">
          <source>It is possible to determine which character set you are operating under. But first you need to be really really sure you need to do this. Your code will be simpler and probably just as portable if you don't have to test the character set and do different things, depending. There are actually only very few circumstances where it's not easy to write straight-line code portable to all character sets. See &lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;Unicode and EBCDIC in perluniintro&lt;/a&gt; for how to portably specify characters.</source>
          <target state="translated">Можно определить, с каким набором символов вы работаете. Но сначала вы должны быть действительно уверены, что вам это нужно. Ваш код будет проще и, вероятно, будет таким же переносимым, если вам не придется тестировать набор символов и делать разные вещи в зависимости от этого. На самом деле существует очень мало обстоятельств, при которых непросто написать прямой код, переносимый для всех наборов символов. См. &lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;Unicode и EBCDIC в perluniintro,&lt;/a&gt; чтобы узнать, как переносить символы.</target>
        </trans-unit>
        <trans-unit id="e0813f66fef4fb95209b9bd5234a37222cb817c4" translate="yes" xml:space="preserve">
          <source>It is possible to explicitly call a parent method from a child:</source>
          <target state="translated">Можно явно вызывать родительский метод у ребенка:</target>
        </trans-unit>
        <trans-unit id="c0da326565896926df8bd9bb48dde0df4c98d8f9" translate="yes" xml:space="preserve">
          <source>It is possible to forbid or warn on non-Unicode code points, or those that may be problematic by using &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19734113aaf232e977540f9be066f896f4d50e8" translate="yes" xml:space="preserve">
          <source>It is possible to get special treatment for a lone dash. This can be achieved by adding an option specification with an empty name, for example:</source>
          <target state="translated">Можно получить специальную обработку для одиночной штрихи.Этого можно добиться,добавив,например,спецификацию опции с пустым именем:</target>
        </trans-unit>
        <trans-unit id="0e645006456f020c2cb729a6c316a213de718eec" translate="yes" xml:space="preserve">
          <source>It is possible to import autodie into a different namespace by using &lt;a href=&quot;Import::Into&quot;&gt;Import::Into&lt;/a&gt;. However, you have to pass a &quot;caller depth&quot; (rather than a package name) for this to work correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484490759459d1a463406a9ec978f4abc6c5898b" translate="yes" xml:space="preserve">
          <source>It is possible to inspect both the string given to RE engine and the resulting finite automaton. See the arguments &lt;code&gt;debug&lt;/code&gt; /&lt;code&gt;debugcolor&lt;/code&gt; in the &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; pragma, as well as Perl's &lt;b&gt;-Dr&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Command Switches in perlrun&lt;/a&gt;.</source>
          <target state="translated">Можно проверить как строку, переданную механизму RE, так и конечный автомат. См. Аргументы &lt;code&gt;debug&lt;/code&gt; / &lt;code&gt;debugcolor&lt;/code&gt; в прагме &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; , а также &lt;b&gt;переключатель&lt;/b&gt; командной строки Perl &lt;b&gt;-Dr&lt;/b&gt; , &lt;b&gt;задокументированный&lt;/b&gt; в &lt;b&gt;разделе &lt;/b&gt;&lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Командные переключатели в perlrun&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2de0a7af99e757a8e8485b1376bbc31dd1cac31e" translate="yes" xml:space="preserve">
          <source>It is possible to inspect both the string given to RE engine and the resulting finite automaton. See the arguments &lt;code&gt;debug&lt;/code&gt;/&lt;code&gt;debugcolor&lt;/code&gt; in the &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; pragma, as well as Perl's &lt;b&gt;-Dr&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;&quot;Command Switches&quot; in perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4987e0746709787de44b276c954d3dc160982cc" translate="yes" xml:space="preserve">
          <source>It is possible to intermix print()s with write()s on the same output channel, but you'll have to handle &lt;code&gt;$-&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt; ) yourself.</source>
          <target state="translated">Можно смешивать print () с write () в том же выходном канале, но вам придется обрабатывать &lt;code&gt;$-&lt;/code&gt; ( &lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt; ) самостоятельно.</target>
        </trans-unit>
        <trans-unit id="17a6fb8a364afc4c2bb94e7dfbe0964a25366786" translate="yes" xml:space="preserve">
          <source>It is possible to intermix print()s with write()s on the same output channel, but you'll have to handle &lt;code&gt;$-&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt;) yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe4bd11a84db5fbf18822129f597065dac28979" translate="yes" xml:space="preserve">
          <source>It is possible to make &lt;code&gt;NEXT&lt;/code&gt; redispatch more demandingly (i.e. like &lt;code&gt;SUPER&lt;/code&gt; does), so that the redispatch throws an exception if it cannot find a &quot;next&quot; method to call.</source>
          <target state="translated">Можно сделать повторную отправку &lt;code&gt;NEXT&lt;/code&gt; более требовательной (например, как это делает &lt;code&gt;SUPER&lt;/code&gt; ), так что повторная отправка генерирует исключение, если не может найти &quot;следующий&quot; метод для вызова.</target>
        </trans-unit>
        <trans-unit id="41c5e618b60091d8c922ad7e0e5ebbcfaa2cb4df" translate="yes" xml:space="preserve">
          <source>It is possible to manually set &lt;code&gt;@ISA&lt;/code&gt; , and you may see this in older Perl code. Much older code also uses the &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; pragma. For new code, we recommend that you use the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma to declare your parents. This pragma will take care of setting &lt;code&gt;@ISA&lt;/code&gt; . It will also load the parent classes and make sure that the package doesn't inherit from itself.</source>
          <target state="translated">Можно вручную установить &lt;code&gt;@ISA&lt;/code&gt; , и вы можете увидеть это в более старом коде Perl. В гораздо более старом коде также используется &lt;a href=&quot;base&quot;&gt;базовая&lt;/a&gt; прагма. Для нового кода мы рекомендуем использовать прагму &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; для объявления своих родителей. Эта прагма позаботится о настройке &lt;code&gt;@ISA&lt;/code&gt; . Он также загрузит родительские классы и убедится, что пакет не наследуется от самого себя.</target>
        </trans-unit>
        <trans-unit id="0bf520fb97ddb7d66d056d630c6c0c7c679c7af2" translate="yes" xml:space="preserve">
          <source>It is possible to omit some or all of the final 4 parameters in the call to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; and let them take default values. As DB_HASH is the most common file format used, the call:</source>
          <target state="translated">Можно опустить некоторые или все последние 4 параметра в вызове &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; и позволить им принимать значения по умолчанию. Поскольку DB_HASH является наиболее распространенным используемым форматом файлов, вызов:</target>
        </trans-unit>
        <trans-unit id="d77ffc116f1345ae65bcfab7b549b42a9b2529d7" translate="yes" xml:space="preserve">
          <source>It is possible to omit some or all of the final 4 parameters in the call to &lt;code&gt;tie&lt;/code&gt; and let them take default values. As DB_HASH is the most common file format used, the call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4afc212139685087c461e85b80958ff6af0a50" translate="yes" xml:space="preserve">
          <source>It is possible to pass either a subroutine reference (recommended) or a fully qualified subroutine name as the first argument. This means you can set hints on modules that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7b6e646490b1b0de97fffd24d0c15d8fcfff05" translate="yes" xml:space="preserve">
          <source>It is possible to predeclare a lexical subroutine. The &lt;code&gt;sub foo {...}&lt;/code&gt; subroutine definition syntax respects any previous &lt;code&gt;my sub;&lt;/code&gt; or &lt;code&gt;state sub;&lt;/code&gt; declaration. Using this to define recursive subroutines is a bad idea, however:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c72d0292032af6dedc904ed64f2438fc661321" translate="yes" xml:space="preserve">
          <source>It is possible to provide aliases that will be displayed in place of the test name by supplying the test as a reference to an array containing &lt;code&gt;[ $test, $alias ]&lt;/code&gt; :</source>
          <target state="translated">Можно указать псевдонимы, которые будут отображаться вместо имени теста, указав тест как ссылку на массив, содержащий &lt;code&gt;[ $test, $alias ]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="47d1a50872b03930e2d6b45fee9f2467c56c1224" translate="yes" xml:space="preserve">
          <source>It is possible to provide aliases that will be displayed in place of the test name by supplying the test as a reference to an array containing &lt;code&gt;[ $test, $alias ]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25625bc71a3769321141057e7fb45e78f8f3581c" translate="yes" xml:space="preserve">
          <source>It is possible to replace such an alphanumeric name with an expression that returns a reference to the appropriate type. For a description of this, see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">Такое буквенно-цифровое имя можно заменить выражением, которое возвращает ссылку на соответствующий тип. Описание этого см. В &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f8a33f0d5f0df1acec3703c5fa0463900e9dcf6" translate="yes" xml:space="preserve">
          <source>It is possible to return a modifiable value from a subroutine. To do this, you have to declare the subroutine to return an lvalue.</source>
          <target state="translated">Из подпрограммы можно вернуть модифицируемое значение.Для этого необходимо объявить подпрограмму,чтобы вернуть значение l.</target>
        </trans-unit>
        <trans-unit id="deb2736fd66852d74a632f14d09ceb41fcda537d" translate="yes" xml:space="preserve">
          <source>It is possible to stack multiple here-docs in a row:</source>
          <target state="translated">Можно сложить несколько here-docs в ряд:</target>
        </trans-unit>
        <trans-unit id="3f9957642dc32b5a7c0c0eefbd7b6c39d5efef50" translate="yes" xml:space="preserve">
          <source>It is possible to strip the EXEs and DLLs created by the build process. The resulting binaries will be significantly smaller. If you want the binaries to be stripped, you can either add a &lt;b&gt;-s&lt;/b&gt; option when Configure prompts you,</source>
          <target state="translated">Можно удалить EXE и DLL, созданные в процессе сборки. Полученные двоичные файлы будут значительно меньше. Если вы хотите, чтобы двоичные файлы были удалены, вы можете либо добавить параметр &lt;b&gt;-s,&lt;/b&gt; когда вам будет предложено настроить,</target>
        </trans-unit>
        <trans-unit id="0ddc0840c422187183750aec88a33c70a57206b1" translate="yes" xml:space="preserve">
          <source>It is possible to supply arguments to tests. To do so separate them from prove's own arguments with the arisdottle, '::'. For example</source>
          <target state="translated">Можно предоставить аргументы в тесты.Для этого необходимо отделить их от собственных аргументов доказывания с помощью арисдотла &quot;::&quot;.Например</target>
        </trans-unit>
        <trans-unit id="843780a126a92b7260b78a50d262eb7d19529c37" translate="yes" xml:space="preserve">
          <source>It is possible to write custom layers in addition to the above builtin ones, both in C/XS and Perl, as a module named &lt;code&gt;PerlIO::&amp;lt;layer name&amp;gt;&lt;/code&gt;. Some custom layers come with the Perl distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6e659dc24039769282bd1c1079f9c11cd8c6ba" translate="yes" xml:space="preserve">
          <source>It is possible to write custom layers in addition to the above builtin ones, both in C/XS and Perl. Two such layers (and one example written in Perl using the latter) come with the Perl distribution.</source>
          <target state="translated">В дополнение к вышеперечисленным встроенным слоям можно писать пользовательские слои,как на C/XS,так и на Perl.Два таких слоя (и один пример,написанный на Perl с использованием последнего)поставляются с дистрибутивом Perl.</target>
        </trans-unit>
        <trans-unit id="af11e539efd7b5740f9d5c0eba044f8aebf92a4a" translate="yes" xml:space="preserve">
          <source>It is possible to write:</source>
          <target state="translated">Можно писать:</target>
        </trans-unit>
        <trans-unit id="3043edf54589d4a75af8ab5a83729379d66bb57a" translate="yes" xml:space="preserve">
          <source>It is possible, though hard to do, to call &lt;code&gt;POSIX::setlocale&lt;/code&gt; with a locale that it doesn't recognize as syntactically legal, but actually is legal on that system. This should happen only with embedded perls, or if you hand-craft a locale name yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d15f29d6da4dd3ad23f2444184a1dcb4a66f4b0" translate="yes" xml:space="preserve">
          <source>It is probably best to chose either the Decimal notation or the string notation and stick with it, to reduce confusion. Perl6 version objects &lt;b&gt;may&lt;/b&gt; only support Decimal comparisons. See also &lt;a href=&quot;#Quoting-Rules&quot;&gt;&quot;Quoting Rules&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b89c8d09aeaea53d5ae118db445020ec34e8b36" translate="yes" xml:space="preserve">
          <source>It is probably useful only when combined with &lt;code&gt;(?{})&lt;/code&gt; or &lt;code&gt;(??{})&lt;/code&gt; .</source>
          <target state="translated">Вероятно, это полезно только в сочетании с &lt;code&gt;(?{})&lt;/code&gt; Или &lt;code&gt;(??{})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afaea2dff924e16be833d549ac45ba57d1ea538b" translate="yes" xml:space="preserve">
          <source>It is probably useful only when combined with &lt;code&gt;(?{})&lt;/code&gt; or &lt;code&gt;(??{})&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf00d26aa745eb3ee05b04278f9eed1956a14d27" translate="yes" xml:space="preserve">
          <source>It is proposed to change this behavior in a future release of Perl so that whether or not Unicode rules are in effect would not change the behavior: Outside of locale, the POSIX classes would behave like their ASCII-range counterparts. If you wish to comment on this proposal, send email to &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; .</source>
          <target state="translated">Предлагается изменить это поведение в будущих версиях Perl, чтобы правила Unicode не меняли его поведение: вне локали классы POSIX будут вести себя так же, как их аналоги в диапазоне ASCII. Если вы хотите прокомментировать это предложение, отправьте электронное письмо по &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6c7a14017f055e8f9bd10d510eabf5bf071a9ca" translate="yes" xml:space="preserve">
          <source>It is recommended that for this usage you put the DEFINE block at the end of the pattern, and that you name any subpatterns defined within it.</source>
          <target state="translated">Для этого рекомендуется поместить блок DEFINE в конец шаблона и назвать любые подмаски,определенные в нем.</target>
        </trans-unit>
        <trans-unit id="b57d669e4107366ea65426a960e0887b522f0627" translate="yes" xml:space="preserve">
          <source>It is recommended that you enable this option unless you really need to create a non-standard Zip file.</source>
          <target state="translated">Рекомендуется включить эту опцию,если только вам действительно не нужно создавать нестандартный Zip-файл.</target>
        </trans-unit>
        <trans-unit id="b5a6bde3e661db2000d4d1c6b83211f16182f9b2" translate="yes" xml:space="preserve">
          <source>It is recommended to &lt;code&gt;use Win32;&lt;/code&gt; before any of these functions; however, for backwards compatibility, those marked as [CORE] will automatically do this for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe9f6b9b410e95d779e30fb9ae34ddfb1f7f1185" translate="yes" xml:space="preserve">
          <source>It is reported that the following archives contain enough utils to build perl:</source>
          <target state="translated">Сообщается,что следующие архивы содержат достаточно утилит для сборки perl:</target>
        </trans-unit>
        <trans-unit id="eb8af118e1b3c0f503fae4e488d7355647e3de10" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that applications using Opcode should use a leading capital letter on their tag names since lowercase names are reserved for use by the Opcode module. If using Opcode within a module you should prefix your tags names with the name of your module to ensure uniqueness and thus avoid clashes with other modules.</source>
          <target state="translated">Настоятельно рекомендуется,чтобы приложения,использующие Opcode,использовали ведущую заглавную букву в своих названиях тегов,так как строчные имена зарезервированы для использования модулем Opcode.При использовании Опкода внутри модуля вы должны префиксовать имена тегов с именем модуля,чтобы обеспечить уникальность и,таким образом,избежать столкновений с другими модулями.</target>
        </trans-unit>
        <trans-unit id="2739f66ac90ce9cc53c7717d098a81a175c0dbe7" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you enable threads via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; as early as possible in your script.</source>
          <target state="translated">Настоятельно рекомендуется включить темы с помощью &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; как можно раньше в сценарии.</target>
        </trans-unit>
        <trans-unit id="607d6dc00476120329bf70c7f37db42c62c363f4" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you enable threads via &lt;code&gt;use threads&lt;/code&gt; as early as possible in your script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23330295b88e2dfe22f823906399d30b69678a8c" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you use this flag when you run Configure. If you do not do this, but later answer the question about large files when Configure asks you, you may get a configuration that cannot be compiled, or that does not function as expected.</source>
          <target state="translated">Настоятельно рекомендуется использовать этот флаг при запуске программы Configure.Если вы этого не сделаете,но позже ответите на вопрос о больших файлах при запросе Configure,вы можете получить конфигурацию,которая не может быть скомпилирована или работает не так,как ожидалось.</target>
        </trans-unit>
        <trans-unit id="d4398ad9975e0145dd25fc7bc9a7058eb6696304" translate="yes" xml:space="preserve">
          <source>It is suggested that you enable the version of malloc that is distributed with Perl. It keeps pools of various sizes of unallocated memory in order to satisfy allocation requests more quickly. However, on some platforms, it may cause spurious malloc or free errors.</source>
          <target state="translated">Предлагается включить версию malloc,распространяемую с Perl.Он хранит пулы различного объема нераспределенной памяти,чтобы быстрее удовлетворять запросы на выделение.Однако на некоторых платформах это может привести к поддельному malloc или к свободным ошибкам.</target>
        </trans-unit>
        <trans-unit id="09d04d7278d56b78f672ffa08fd362fe3b4bb9cb" translate="yes" xml:space="preserve">
          <source>It is the appropriate method to use if you need to get the name of a lexical variable from a padname array. Lexical variable names are always stored with a null terminator, and the length field (CUR) is overloaded for other purposes and can't be relied on here.</source>
          <target state="translated">Это подходящий метод,если необходимо получить имя лексической переменной из массива имен.Имена лексических переменных всегда хранятся с нулевым терминатором,а поле длины (CUR)перегружено для других целей и на него нельзя положиться.</target>
        </trans-unit>
        <trans-unit id="6f04d78fbcc86fbb7196577b1692934e2955d725" translate="yes" xml:space="preserve">
          <source>It is therefore strongly recommended that these macros be used by all XS modules that make use of static data.</source>
          <target state="translated">Поэтому настоятельно рекомендуется,чтобы эти макросы использовались всеми модулями XS,использующими статические данные.</target>
        </trans-unit>
        <trans-unit id="6ddce18b6b5d6c4ef9a5cf7c34f05793b72112fd" translate="yes" xml:space="preserve">
          <source>It is typically used to add extra directories to perl's search path so that later &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statements will find modules which are not located on perl's default search path.</source>
          <target state="translated">Обычно он используется для добавления дополнительных каталогов в путь поиска perl, чтобы в дальнейшем операторы &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; находили модули, которые не расположены в пути поиска perl по умолчанию.</target>
        </trans-unit>
        <trans-unit id="231d3b33b22966aa08593496a49a29478f187fe4" translate="yes" xml:space="preserve">
          <source>It is typically used to add extra directories to perl's search path so that later &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statements will find modules which are not located on perl's default search path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fbfb42d30ce39230261b344f6acdd15e39f445" translate="yes" xml:space="preserve">
          <source>It is up to individual Pod formatter to display good judgement when confronted with an unrenderable character (which is distinct from an unknown E&amp;lt;thing&amp;gt; sequence that the parser couldn't resolve to anything, renderable or not). It is good practice to map Latin letters with diacritics (like &quot;E&amp;lt;eacute&amp;gt;&quot;/&quot;E&amp;lt;233&amp;gt;&quot;) to the corresponding unaccented US-ASCII letters (like a simple character 101, &quot;e&quot;), but clearly this is often not feasible, and an unrenderable character may be represented as &quot;?&quot;, or the like. In attempting a sane fallback (as from E&amp;lt;233&amp;gt; to &quot;e&quot;), Pod formatters may use the %Latin1Code_to_fallback table in &lt;a href=&quot;Pod::Escapes&quot;&gt;Pod::Escapes&lt;/a&gt;, or &lt;a href=&quot;Text::Unidecode&quot;&gt;Text::Unidecode&lt;/a&gt;, if available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7559da192e0561816f87fb94aa112a7e9ecc6d" translate="yes" xml:space="preserve">
          <source>It is up to individual Pod formatter to display good judgement when confronted with an unrenderable character (which is distinct from an unknown E&amp;lt;thing&amp;gt; sequence that the parser couldn't resolve to anything, renderable or not). It is good practice to map Latin letters with diacritics (like &quot;E&amp;lt;eacute&amp;gt;&quot;/&quot;E&amp;lt;233&amp;gt;&quot;) to the corresponding unaccented US-ASCII letters (like a simple character 101, &quot;e&quot;), but clearly this is often not feasible, and an unrenderable character may be represented as &quot;?&quot;, or the like. In attempting a sane fallback (as from E&amp;lt;233&amp;gt; to &quot;e&quot;), Pod formatters may use the %Latin1Code_to_fallback table in &lt;a href=&quot;pod/escapes&quot;&gt;Pod::Escapes&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Unidecode&quot;&gt;Text::Unidecode&lt;/a&gt;, if available.</source>
          <target state="translated">Отдельный модуль форматирования Pod должен проявлять здравый смысл при столкновении с необрабатываемым символом (который отличается от неизвестной последовательности E &amp;lt;thing&amp;gt;, которую синтаксический анализатор не может преобразовать ни в что, рендерируемый или нет). Рекомендуется сопоставить латинские буквы с диакритическими знаками (например, &quot;E &amp;lt;eacute&amp;gt;&quot; / &quot;E &amp;lt;233&amp;gt;&quot;) с соответствующими безударными буквами US-ASCII (например, простым символом 101, &quot;e&quot;), но очевидно, что это часто неосуществимо, и непередаваемый персонаж может быть представлен как &amp;laquo;?&amp;raquo; или тому подобное. При попытке разумного отката (от E &amp;lt;233&amp;gt; до &amp;laquo;e&amp;raquo;) форматеры Pod могут использовать таблицу% Latin1Code_to_fallback в &lt;a href=&quot;pod/escapes&quot;&gt;Pod :: Escapes&lt;/a&gt; или &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Unidecode&quot;&gt;Text :: Unidecode&lt;/a&gt; , если она доступна.</target>
        </trans-unit>
        <trans-unit id="d3fe171c1e178608bc5f92e9c9efc16598ce4a39" translate="yes" xml:space="preserve">
          <source>It is up to you to use this information to populate</source>
          <target state="translated">Вы сами должны использовать эту информацию,чтобы заполнить</target>
        </trans-unit>
        <trans-unit id="ce530e54cb38df50f2b9795b42ad1b0802239f94" translate="yes" xml:space="preserve">
          <source>It is usual to pass parameters using global variables (typically $_ for one parameter, or $a and $b for two parameters) rather than via @_. (It is possible to use the @_ mechanism if you know what you're doing, though there is as yet no supported API for it. It's also inherently slower.)</source>
          <target state="translated">Обычно параметры передаются с помощью глобальных переменных (обычно $_для одного параметра,или $a и $b для двух параметров),а не через @_.(Механизм @_можно использовать,если вы знаете,что делаете,хотя пока для этого нет поддерживаемого API.Также он по своей природе медленнее).</target>
        </trans-unit>
        <trans-unit id="91da970cd331ff859f8e77df6915a3ed4846b274" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;a href=&quot;#alarm-SECONDS&quot;&gt;&lt;code&gt;alarm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#sleep-EXPR&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt; calls, because &lt;a href=&quot;#sleep-EXPR&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt; may be internally implemented on your system with &lt;a href=&quot;#alarm-SECONDS&quot;&gt;&lt;code&gt;alarm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c5d14186ab57b1e0629e917b8215f824fb1b8c" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; may be internally implemented on your system with &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обычно ошибочно смешивать вызовы &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; , потому что &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; может быть встроен в вашу систему с &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18d1691040dfd4fd0aeb2ca9801dad0c1249aa8e" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; may be internally implemented on your system with &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обычно ошибочно смешивать вызовы &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; , потому что &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; может быть встроен в вашу систему с &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f94317c7d8a68b955ef8fad7379f1f684a3e243d" translate="yes" xml:space="preserve">
          <source>It is usually impossible to add new syntax to Perl without breaking some existing programs. This pragma provides a way to minimize that risk. New syntactic constructs, or new semantic meanings to older constructs, can be enabled by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'foo'&lt;/code&gt; , and will be parsed only when the appropriate feature pragma is in scope. (Nevertheless, the &lt;code&gt;CORE::&lt;/code&gt; prefix provides access to all Perl keywords, regardless of this pragma.)</source>
          <target state="translated">Обычно невозможно добавить новый синтаксис в Perl, не нарушив некоторые существующие программы. Эта прагма предоставляет способ минимизировать этот риск. Новые синтаксические конструкции или новые семантические значения старых конструкций могут быть включены с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'foo'&lt;/code&gt; и будут анализироваться только тогда, когда соответствующая прагма функции находится в области действия. (Тем не менее, префикс &lt;code&gt;CORE::&lt;/code&gt; обеспечивает доступ ко всем ключевым словам Perl, независимо от этой прагмы.)</target>
        </trans-unit>
        <trans-unit id="0f612a30494cb1971874c3ee4fc77442da7514cc" translate="yes" xml:space="preserve">
          <source>It is usually impossible to add new syntax to Perl without breaking some existing programs. This pragma provides a way to minimize that risk. New syntactic constructs, or new semantic meanings to older constructs, can be enabled by &lt;code&gt;use feature 'foo'&lt;/code&gt;, and will be parsed only when the appropriate feature pragma is in scope. (Nevertheless, the &lt;code&gt;CORE::&lt;/code&gt; prefix provides access to all Perl keywords, regardless of this pragma.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8825373ed061df5a7897772f25e6f03f473b0a3c" translate="yes" xml:space="preserve">
          <source>It is very common to want to do encoding transformations when reading or writing files, network connections, pipes etc. If Perl is configured to use the new 'perlio' IO system then &lt;code&gt;Encode&lt;/code&gt; provides a &quot;layer&quot; (see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;) which can transform data as it is read or written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60c64d5138091e34ac4e66a3176bc2904d419a6d" translate="yes" xml:space="preserve">
          <source>It is very common when filtering source to only want to apply the filter to the non-character-string parts of the code, or alternatively to</source>
          <target state="translated">Это очень распространено при фильтрации исходного текста,чтобы применить фильтр только к несимвольным частям кода,или альтернативно к</target>
        </trans-unit>
        <trans-unit id="7507ed7a14e59c863596321d293c86dd2f1471ac" translate="yes" xml:space="preserve">
          <source>It is very easy to dead-lock a process using this form of open(), or indeed with any use of pipe() with multiple subprocesses. The example above is &quot;safe&quot; because it is simple and calls exec(). See &lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;&quot;Avoiding Pipe Deadlocks&quot;&lt;/a&gt; for general safety principles, but there are extra gotchas with Safe Pipe Opens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df1696685d7983c694bb3c5409a0395bf0e003f" translate="yes" xml:space="preserve">
          <source>It is very easy to dead-lock a process using this form of open(), or indeed with any use of pipe() with multiple subprocesses. The example above is &quot;safe&quot; because it is simple and calls exec(). See &lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;Avoiding Pipe Deadlocks&lt;/a&gt; for general safety principles, but there are extra gotchas with Safe Pipe Opens.</source>
          <target state="translated">Очень легко заблокировать процесс, используя эту форму open (), или вообще любое использование pipe () с несколькими подпроцессами. Приведенный выше пример &amp;laquo;безопасен&amp;raquo;, потому что он прост и вызывает exec (). Общие принципы безопасности см. В разделе &lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;Избегание тупиковых&lt;/a&gt; ситуаций с трубами, но с безопасным открытием труб есть дополнительные подводные камни.</target>
        </trans-unit>
        <trans-unit id="1f2733d85a83af59b86ea7ca3eeb7a8a21d68e5a" translate="yes" xml:space="preserve">
          <source>It is very easy to get tripped up using a mixture of other programs, external utilities, and Perl scripts that are in varying states of being able to handle case preservation. For example, a file created by an older version of an archive utility or a build utility such as MMK or MMS may generate a filename in all upper case even on an ODS-5 volume. If this filename is later retrieved by a Perl script or module in a case preserving environment, that upper case name may not match the mixed-case or lower-case expectations of the Perl code. Your best bet is to follow an all-or-nothing approach to case preservation: either don't use it at all, or make sure your entire toolchain and application environment support and use it.</source>
          <target state="translated">Очень легко запутаться,используя смесь других программ,внешних утилит и Perl-скриптов,которые находятся в различных состояниях,чтобы справиться с сохранением кейса.Например,файл,созданный старой версией утилиты для работы с архивами,или утилита для сборки,такая как MMK или MMS,может генерировать имя файла во всех верхних регистрах даже на томе ODS-5.Если это имя файла позже будет получено скриптом или модулем Perl в среде сохранения регистров,то это имя в верхнем регистре может не соответствовать смешанному или нижнему регистру,ожидаемому от кода Perl.Лучше всего придерживаться подхода &quot;все или ничего&quot; к сохранению регистров:либо не используйте его вообще,либо убедитесь,что вся ваша инструментальная цепь и прикладная среда поддерживают и используют его.</target>
        </trans-unit>
        <trans-unit id="1057ac1e814cd9a3566a8fed96cf94293953ec7a" translate="yes" xml:space="preserve">
          <source>It is very easy to recover the source of Perl programs. You simply feed the program to the perl interpreter and use the modules in the B:: hierarchy. The B::Deparse module should be able to defeat most attempts to hide source. Again, this is not unique to Perl.</source>
          <target state="translated">Восстановить источник программ на Perl очень просто.Вы просто подаете программу в интерпретатор Perl и используете модули в иерархии B::.Модуль B::Deparse должен быть способен победить большинство попыток скрыть исходный текст.Опять же,это не уникально для Perl.</target>
        </trans-unit>
        <trans-unit id="d5b6f5cbb4ab2d2416457262d0018311cb6ac8d2" translate="yes" xml:space="preserve">
          <source>It is very possible that this document will fall far short of being useful to the casual reader. The reader is expected to understand the material in the first few sections of &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">Вполне возможно, что этот документ будет далек от того, чтобы быть полезным для обычного читателя. Ожидается, что читатель поймет материал первых нескольких разделов &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8bf9b3e35a922a415eaeb6feb2defbf0bc762198" translate="yes" xml:space="preserve">
          <source>It is very possible that this document will fall far short of being useful to the casual reader. The reader is expected to understand the material in the first few sections of &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055458523774899083238688c776d433516198d1" translate="yes" xml:space="preserve">
          <source>It is worth drawing particular attention to the expected ranges for the values provided. The value for the day of the month is the actual day (i.e. 1..31), while the month is the number of months since January (0..11). This is consistent with the values returned from &lt;code&gt;localtime()&lt;/code&gt; and &lt;code&gt;gmtime()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5424072f53b20136acc827f23a7b8403963d2596" translate="yes" xml:space="preserve">
          <source>It is worth drawing particular attention to the expected ranges for the values provided. The value for the day of the month is the actual day (ie 1..31), while the month is the number of months since January (0..11). This is consistent with the values returned from &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Особое внимание стоит обратить на ожидаемые диапазоны предоставленных значений. Значение дня месяца - это фактический день (например, 1..31), а месяц - это количество месяцев, прошедших с января (0..11). Это согласуется со значениями, возвращаемыми &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; и gmtime () .</target>
        </trans-unit>
        <trans-unit id="c12cfe0a130e1abce3e789227eb445dc3d70c311" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , etc, match single characters, not complete numbers or words. To match a number (that consists of digits), use &lt;code&gt;\d+&lt;/code&gt; ; to match a word, use &lt;code&gt;\w+&lt;/code&gt; . But be aware of the security considerations in doing so, as mentioned above.</source>
          <target state="translated">Стоит подчеркнуть, что &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; и т. Д. Соответствуют отдельным символам, а не полным числам или словам. Чтобы сопоставить число (состоящее из цифр), используйте &lt;code&gt;\d+&lt;/code&gt; ; чтобы найти слово, используйте &lt;code&gt;\w+&lt;/code&gt; . Но помните о соображениях безопасности при этом, как упоминалось выше.</target>
        </trans-unit>
        <trans-unit id="113a0e58d547793b729e9fa965a701228f317998" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, etc, match single characters, not complete numbers or words. To match a number (that consists of digits), use &lt;code&gt;\d+&lt;/code&gt;; to match a word, use &lt;code&gt;\w+&lt;/code&gt;. But be aware of the security considerations in doing so, as mentioned above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ab6d3ec3a28b829b407073297587d950173f49" translate="yes" xml:space="preserve">
          <source>It is worth noting that &lt;code&gt;\G&lt;/code&gt; improperly used can result in an infinite loop. Take care when using patterns that include &lt;code&gt;\G&lt;/code&gt; in an alternation.</source>
          <target state="translated">Стоит отметить, что неправильное использование &lt;code&gt;\G&lt;/code&gt; может привести к бесконечному циклу. Будьте осторожны при использовании шаблонов, которые включают &lt;code&gt;\G&lt;/code&gt; в чередовании.</target>
        </trans-unit>
        <trans-unit id="db9514e6a01f9d85b4ef7b0e350a06b34e756aba" translate="yes" xml:space="preserve">
          <source>It is worth stressing that there are several different sets of digits in Unicode that are equivalent to 0-9 and are matchable by &lt;code&gt;\d&lt;/code&gt; in a regular expression. If they are used in a single language only, they are in that language's &lt;code&gt;Script&lt;/code&gt; and &lt;code&gt;Script_Extension&lt;/code&gt; . If they are used in more than one script, they will be in &lt;code&gt;sc=Common&lt;/code&gt; , but only if they are used in many scripts should they be in &lt;code&gt;scx=Common&lt;/code&gt; .</source>
          <target state="translated">Стоит подчеркнуть, что в Юникоде есть несколько различных наборов цифр, которые эквивалентны 0&amp;ndash;9 и сопоставимы с помощью &lt;code&gt;\d&lt;/code&gt; в регулярном выражении. Если они используются только на одном языке, они находятся в &lt;code&gt;Script&lt;/code&gt; и &lt;code&gt;Script_Extension&lt;/code&gt; этого языка . Если они используются более чем в одном скрипте, они будут в &lt;code&gt;sc=Common&lt;/code&gt; , но только если они используются во многих скриптах, они должны быть в &lt;code&gt;scx=Common&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0195b5ac1ee6ed9e15cca2ca1c3622950d2b3cb" translate="yes" xml:space="preserve">
          <source>It is worth stressing that there are several different sets of digits in Unicode that are equivalent to 0-9 and are matchable by &lt;code&gt;\d&lt;/code&gt; in a regular expression. If they are used in a single language only, they are in that language's &lt;code&gt;Script&lt;/code&gt; and &lt;code&gt;Script_Extensions&lt;/code&gt;. If they are used in more than one script, they will be in &lt;code&gt;sc=Common&lt;/code&gt;, but only if they are used in many scripts should they be in &lt;code&gt;scx=Common&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb73a60f536c984fec748fd56250217ac857070f" translate="yes" xml:space="preserve">
          <source>It is, after all, just a guess. You should alway be explicit when it comes to encodings. But there are some, especially Japanese, environment that guess-coding is a must. Use this module with care.</source>
          <target state="translated">В конце концов,это всего лишь догадка.Вы должны всегда быть откровенны,когда речь идет о кодировках.Но есть некоторые,особенно японские,среды,в которых кодирование догадок является обязательным.Используйте этот модуль с осторожностью.</target>
        </trans-unit>
        <trans-unit id="b1fd4c29544df6031e0c7f381c345fa955c2ddef" translate="yes" xml:space="preserve">
          <source>It is, however, very simple, pure Perl, and it has no non-core dependencies. It also provides a &quot;Moose-like&quot; API on demand for the features it supports.</source>
          <target state="translated">Тем не менее,это очень простой,чистый Perl,и у него нет непрофильных зависимостей.Он также предоставляет &quot;Лосиный&quot; API по запросу на поддерживаемые им функции.</target>
        </trans-unit>
        <trans-unit id="358ba9c90802ce677d93df629a1697c0599e5843" translate="yes" xml:space="preserve">
          <source>It isn't possible to create a true reference to an IO handle (filehandle or dirhandle) using the backslash operator. The most you can get is a reference to a typeglob, which is actually a complete symbol table entry. But see the explanation of the &lt;code&gt;*foo{THING}&lt;/code&gt; syntax below. However, you can still use type globs and globrefs as though they were IO handles.</source>
          <target state="translated">Невозможно создать настоящую ссылку на дескриптор ввода-вывода (дескриптор файла или dirhandle) с помощью оператора обратной косой черты. Максимум, что вы можете получить, - это ссылка на typeglob, который на самом деле является полной записью таблицы символов. Но см. Объяснение синтаксиса &lt;code&gt;*foo{THING}&lt;/code&gt; ниже. Однако вы все равно можете использовать глобусы типов и глобрефы, как если бы они были дескрипторами ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="be4ec9fbbf231e40204d7019d3f997c286ceaaf0" translate="yes" xml:space="preserve">
          <source>It lets by &lt;code&gt;$(...)&lt;/code&gt;.</source>
          <target state="translated">Это позволяет &lt;code&gt;$(...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1272cce995365257b29707c07e056e98c158a0d6" translate="yes" xml:space="preserve">
          <source>It may also be useful to create a batch file called lib.bat in C:\Program Files\Microsoft Visual C++ Toolkit 2003\bin containing:</source>
          <target state="translated">Также может быть полезным создание пакетного файла под названием lib.bat в C:\Program Files\Microsoft Инструментарий Visual C++2003\bin:</target>
        </trans-unit>
        <trans-unit id="c3ee59300b49b89fa621ccf66f9ee189105bf2cd" translate="yes" xml:space="preserve">
          <source>It may also indicate a misspelled constant that has been interpreted as a bareword:</source>
          <target state="translated">Это также может указывать на неправильно написанную константу,которая была истолкована как пустое слово:</target>
        </trans-unit>
        <trans-unit id="fb79d7ce93f65d8007a6c3362149cd125568d552" translate="yes" xml:space="preserve">
          <source>It may be common (for example at your main lexicon) that the hash keys and values coincide. Like that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d71937f4e01c4691f8ad6115319d1b1a1cc17dc" translate="yes" xml:space="preserve">
          <source>It may be handy to add a function or method to retrieve the number. Use the number in announcements and archive file names when releasing the module (ModuleName-1.02.tar.Z). See perldoc ExtUtils::MakeMaker.pm for details.</source>
          <target state="translated">Может быть удобно добавить функцию или метод для получения номера.Используйте номер в объявлениях и имена архивных файлов при выпуске модуля (ModuleName-1.02.tar.Z).Подробности см.в perldoc ExtUtils::MakeMaker.pm.</target>
        </trans-unit>
        <trans-unit id="4aba7fcd954a7d79c58b4c5db5fcca156f49cb64" translate="yes" xml:space="preserve">
          <source>It may be helpful to always use the forked debugger so that script I/O is separated from debugger I/O. You can force the debugger to be forked by assigning a value to the logical name &amp;lt;PERLDB_PIDS&amp;gt; that is not a process identification number.</source>
          <target state="translated">Может быть полезно всегда использовать разветвленный отладчик, чтобы ввод-вывод сценария был отделен от ввода-вывода отладчика. Вы можете принудительно выполнить форк отладчика, присвоив логическому имени &amp;lt;PERLDB_PIDS&amp;gt; значение, которое не является идентификационным номером процесса.</target>
        </trans-unit>
        <trans-unit id="c878552ffbfe93e8fcd546e6ba5f54b617695a5d" translate="yes" xml:space="preserve">
          <source>It may be more portable to use the &lt;a href=&quot;File::Copy&quot;&gt;File::Copy&lt;/a&gt; module instead. You just copy to the new file to the new name (checking return values), then delete the old one. This isn't really the same semantically as a &lt;code&gt;rename()&lt;/code&gt;, which preserves meta-information like permissions, timestamps, inode info, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf5a525be6e13a9a7b1dd1dbd184cb474cd50ab" translate="yes" xml:space="preserve">
          <source>It may be more portable to use the &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt; module instead. You just copy to the new file to the new name (checking return values), then delete the old one. This isn't really the same semantically as a &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt;, which preserves meta-information like permissions, timestamps, inode info, etc.</source>
          <target state="translated">Вместо этого может быть более переносимым использовать модуль &lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt; . Вы просто копируете в новый файл с новым именем (проверяя возвращаемые значения), а затем удаляете старый. На самом деле это не то же самое семантически, что и &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; , которая сохраняет метаинформацию, такую ​​как разрешения, временные метки, информацию об индексах и т. Д.</target>
        </trans-unit>
        <trans-unit id="db6d5d1cd198cf53911efce9b9d95d5989e30fc0" translate="yes" xml:space="preserve">
          <source>It may be possible to code a simple workaround which would</source>
          <target state="translated">Может быть,возможно,удастся разработать простой обходной путь,который позволит</target>
        </trans-unit>
        <trans-unit id="2d1547ff72328148f73028b4bf53e65cca15e95b" translate="yes" xml:space="preserve">
          <source>It may be possible to use the Entropy Gathering Daemon (written in Perl!), available from &lt;a href=&quot;http://www.lothar.com/tech/crypto/&quot;&gt;http://www.lothar.com/tech/crypto/&lt;/a&gt;.</source>
          <target state="translated">Возможно, можно будет использовать демон Entropy Gathering Daemon (написанный на Perl!), Доступный по &lt;a href=&quot;http://www.lothar.com/tech/crypto/&quot;&gt;адресу http://www.lothar.com/tech/crypto/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea7e33e821e865ae246a0ffae0bdba930182de6b" translate="yes" xml:space="preserve">
          <source>It may seem obvious to say, but Perl is useful only when users can easily find it. When possible, it's good for both</source>
          <target state="translated">Может показаться очевидным,но Perl полезен только тогда,когда пользователи могут легко его найти.Когда это возможно,это хорошо для обоих</target>
        </trans-unit>
        <trans-unit id="fd3430c5befbd819886aa0fff01863d985392126" translate="yes" xml:space="preserve">
          <source>It might conceivably chdir() you out of a directory that it can't chdir() you back into. If fastcwd encounters a problem it will return undef but will probably leave you in a different directory. For a measure of extra security, if everything appears to have worked, the fastcwd() function will check that it leaves you in the same directory that it started in. If it has changed it will &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with the message &quot;Unstable directory path, current directory changed unexpectedly&quot;. That should never happen.</source>
          <target state="translated">Возможно, вы вышли из каталога с помощью chdir (), в который вы не можете вернуться обратно с помощью chdir (). Если fastcwd обнаружит проблему, он вернет undef, но, вероятно, оставит вас в другом каталоге. В целях дополнительной безопасности, если все работает, функция fastcwd () проверит, что она оставляет вас в том же каталоге, в котором была запущена. Если она изменилась, она &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; с сообщением &amp;laquo;Нестабильный путь к каталогу, текущий каталог неожиданно изменился &quot;. Такого никогда не должно быть.</target>
        </trans-unit>
        <trans-unit id="6269f7c0874b90d11b774dcb29c6ab77d94be05c" translate="yes" xml:space="preserve">
          <source>It might conceivably chdir() you out of a directory that it can't chdir() you back into. If fastcwd encounters a problem it will return undef but will probably leave you in a different directory. For a measure of extra security, if everything appears to have worked, the fastcwd() function will check that it leaves you in the same directory that it started in. If it has changed it will &lt;code&gt;die&lt;/code&gt; with the message &quot;Unstable directory path, current directory changed unexpectedly&quot;. That should never happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a597e04d91d3290c6b9fa9abe20a400d22f03ff" translate="yes" xml:space="preserve">
          <source>It might seem possible eliminate slab reference counts altogether, by having all ops implicitly attached to &lt;code&gt;PL_compcv&lt;/code&gt; when allocated and freed when the CV is freed. That would also allow &lt;code&gt;op_free&lt;/code&gt; to skip &lt;code&gt;FreeOp&lt;/code&gt; altogether, and thus free ops faster. But that doesn't work in those cases where ops need to survive beyond their CVs, such as re-evals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642edf6b6e0c22a6bf4368f6631f6fe45a077e55" translate="yes" xml:space="preserve">
          <source>It monkeypatches Test::Builder, and calls it &quot;black magic&quot; in the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="106694ead18b1135cc07d2ae597d50b20a4d8af6" translate="yes" xml:space="preserve">
          <source>It must be stressed that the DynaLoader, by itself, is practically useless for accessing non-Perl libraries because it provides almost no Perl-to-C 'glue'. There is, for example, no mechanism for calling a C library function or supplying arguments. A C::DynaLib module is available from CPAN sites which performs that function for some common system types. And since the year 2000, there's also Inline::C, a module that allows you to write Perl subroutines in C. Also available from your local CPAN site.</source>
          <target state="translated">Следует подчеркнуть,что DynaLoader сам по себе практически бесполезен для доступа к не-перловым библиотекам,так как практически не содержит &quot;клея&quot; Perl-to-C.Нет,например,механизма для вызова функции библиотеки Си или предоставления аргументов.Модуль C::DynaLib доступен с CPAN сайтов,которые выполняют эту функцию для некоторых распространенных типов систем.А с 2000 года существует также Inline::C,модуль,позволяющий писать подпрограммы на Perl на C.Также доступен с вашего локального сайта CPAN.</target>
        </trans-unit>
        <trans-unit id="8bc1cb6024aa942bd48b262d31d7cf7f97b8a25f" translate="yes" xml:space="preserve">
          <source>It occurs to you that this is not the prettiest code you've ever written, but this seems the way to go. You mail off to the translators asking for translations for these four cases. The Chinese guy replies with the one phrase that these all translate to in Chinese, and that phrase has two &quot;%g&quot;s in it, as it should -- but there's a problem. He translates it word-for-word back: &quot;In %g directories contains %g files match your query.&quot; The %g slots are in an order reverse to what they are in English. You wonder how you'll get gettext to handle that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04aa081b59ff3888239972218e3f56b3b6581f1f" translate="yes" xml:space="preserve">
          <source>It particular, it's important to &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize $_ in any routine that assigns to it. Look out for implicit assignments in &lt;code&gt;while&lt;/code&gt; conditionals.</source>
          <target state="translated">Это особенно важно для &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; Изи $ _ в любой программе , которая правопреемники к нему. Обратите внимание на неявные присваивания в условных выражениях &lt;code&gt;while&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9fad7940bb559b8eb57657aa029f3c734e1bf6b" translate="yes" xml:space="preserve">
          <source>It particular, it's important to &lt;code&gt;local&lt;/code&gt;ize $_ in any routine that assigns to it. Look out for implicit assignments in &lt;code&gt;while&lt;/code&gt; conditionals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd14db27f979e38e1e8d4c1576f9b693597877fa" translate="yes" xml:space="preserve">
          <source>It performs the following actions:</source>
          <target state="translated">Он выполняет следующие действия:</target>
        </trans-unit>
        <trans-unit id="3a77cf9922a9fef0374667dd7650f3414798d318" translate="yes" xml:space="preserve">
          <source>It prints (without so many line breaks)</source>
          <target state="translated">Он печатает (без такого количества разрывов строк).</target>
        </trans-unit>
        <trans-unit id="f4bd0cc34b746267dc944192fe3c01787ec4e363" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder since print calls &lt;code&gt;bdiv()&lt;/code&gt; in list context. Also, &lt;code&gt;bdiv()&lt;/code&gt; will modify $c, so be careful. You probably want to use</source>
          <target state="translated">Он печатает как частное, так и остаток, так как print вызывает &lt;code&gt;bdiv()&lt;/code&gt; в контексте списка. Кроме того, &lt;code&gt;bdiv()&lt;/code&gt; изменит $ c, так что будьте осторожны. Вы, вероятно, захотите использовать</target>
        </trans-unit>
        <trans-unit id="eeeedb6aa3743486c6e5b956ff78abba71960946" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder since print works in list context. Also, bdiv() will modify $c, so be careful. You probably want to use</source>
          <target state="translated">Он печатает как коэффициент,так и остаток,так как печать работает в контексте списка.Кроме того,bdiv()будет изменять $c,так что будьте осторожны.Вы,вероятно,захотите использовать</target>
        </trans-unit>
        <trans-unit id="f734db0d61221ca40b0fe2bebce3caa4e0b18089" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder, since print calls &lt;code&gt;brsft()&lt;/code&gt; in list context. Also, &lt;code&gt;$c-&amp;gt;brsft()&lt;/code&gt; will modify $c, so be careful. You probably want to use</source>
          <target state="translated">Он печатает как частное, так и остаток, поскольку print вызывает &lt;code&gt;brsft()&lt;/code&gt; в контексте списка. Кроме того, &lt;code&gt;$c-&amp;gt;brsft()&lt;/code&gt; изменит $ c, так что будьте осторожны. Вы, вероятно, захотите использовать</target>
        </trans-unit>
        <trans-unit id="ce7853179bda4d7415dfcdbc4fb24a48d915ca39" translate="yes" xml:space="preserve">
          <source>It prints both the number of digits in the number and in the fraction part since print calls &lt;code&gt;&lt;a href=&quot;../functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; in list context. Use something like:</source>
          <target state="translated">Он печатает как количество цифр в числе, так и в дробной части, поскольку print вызывает &lt;code&gt;&lt;a href=&quot;../functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; в контексте списка. Используйте что-то вроде:</target>
        </trans-unit>
        <trans-unit id="ae3e52e7991a13cb3327228cb99597bd25c0f239" translate="yes" xml:space="preserve">
          <source>It prints both the number of digits in the number and in the fraction part since print calls &lt;code&gt;length()&lt;/code&gt; in list context. Use something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29cdbd5e538c2f505e08e3d1eef02e06fd63d99d" translate="yes" xml:space="preserve">
          <source>It prints the sequence number of each subroutine call and the name of the called subroutine. Note that &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is being compiled into the package &lt;code&gt;DB&lt;/code&gt; through the use of the &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">Он печатает порядковый номер каждого вызова подпрограммы и имя вызываемой подпрограммы. Обратите внимание, что &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; компилируется в базу &lt;code&gt;DB&lt;/code&gt; пакета с помощью директивы &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9851cbd8d563f766b9710d226d03fcd351760c96" translate="yes" xml:space="preserve">
          <source>It prints the sequence number of each subroutine call and the name of the called subroutine. Note that &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is being compiled into the package &lt;code&gt;DB&lt;/code&gt; through the use of the &lt;code&gt;package&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc0745e2373dd8461369aabf029a5713236cbd6" translate="yes" xml:space="preserve">
          <source>It properly handles the locale radix character, meaning it expects a dot except when called from within the scope of &lt;code&gt;use locale&lt;/code&gt;, in which case the radix character should be that specified by the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb15b033b8c4d79b1e008f6b581eebb8e9cf4d5" translate="yes" xml:space="preserve">
          <source>It provides a number of mechanisms for querying this information.</source>
          <target state="translated">В нем предусмотрен ряд механизмов для запроса этой информации.</target>
        </trans-unit>
        <trans-unit id="b8c1724bc25d41f7c44c94651a6709f709b79e5f" translate="yes" xml:space="preserve">
          <source>It provides default implementations for the methods</source>
          <target state="translated">Он предоставляет реализации по умолчанию для методов</target>
        </trans-unit>
        <trans-unit id="991237cf5d3fbec5f0d4f7d308f07d6c33c5c843" translate="yes" xml:space="preserve">
          <source>It rarely happens, but sometimes a harness might encounter 'missing tests:</source>
          <target state="translated">Это редко случается,но иногда аркан может столкнуться с &quot;пропущенными тестами&quot;:</target>
        </trans-unit>
        <trans-unit id="58b94065e144f3ae0a0ee1916ab6d2ce54ccb558" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property Comp_Ex (Full_Composition_Exclusion). This property is generated from Composition Exclusions + Singletons + Non-Starter Decompositions.</source>
          <target state="translated">Возвращает логин производного свойства Comp_Ex (Full_Composition_Exclusion).Это свойство генерируется из Composition Exclusions+Singletons+Non-Starter Decompositions.</target>
        </trans-unit>
        <trans-unit id="2104ee6f115c01f93c99709b67d509e11442417d" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFC_MAYBE (NFC_Quick_Check=Maybe).</source>
          <target state="translated">Возвращает логин производного свойства NFC_MAYBE (NFC_Quick_Check=Maybe).</target>
        </trans-unit>
        <trans-unit id="8eddd31c0562defd83827f48a88a17884adf60ac" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFC_NO (NFC_Quick_Check=No).</source>
          <target state="translated">Возвращает логин производного свойства NFC_NO (NFC_Quick_Check=No).</target>
        </trans-unit>
        <trans-unit id="5a5415660523b78bb56fd5e9c17b5e348185ce86" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFD_NO (NFD_Quick_Check=No).</source>
          <target state="translated">Возвращает логин производного свойства NFD_NO (NFD_Quick_Check=No).</target>
        </trans-unit>
        <trans-unit id="670fe547c9b7a29b855ab5f7d41534d43d1e9f4c" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKC_MAYBE (NFKC_Quick_Check=Maybe).</source>
          <target state="translated">Возвращает логин производного свойства NFKC_MAYBE (NFKC_Quick_Check=Maybe).</target>
        </trans-unit>
        <trans-unit id="904cbf02d71113df93de970071185a11138630e4" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKC_NO (NFKC_Quick_Check=No).</source>
          <target state="translated">Возвращает логин производного свойства NFKC_NO (NFKC_Quick_Check=No).</target>
        </trans-unit>
        <trans-unit id="829ea5ef8a5200c844ee7c02042a32bc63c04771" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKD_NO (NFKD_Quick_Check=No).</source>
          <target state="translated">Возвращает логин производного свойства NFKD_NO (NFKD_Quick_Check=No).</target>
        </trans-unit>
        <trans-unit id="8784205d909df0b9a984780fc90733905a3103a1" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the character of the specified codepoint may be composed with the previous one in a certain composition (including Hangul Compositions, but excluding Composition Exclusions and Non-Starter Decompositions).</source>
          <target state="translated">Возвращает булевую информацию о том,может ли символ указанного кодового пункта быть составлен вместе с предыдущим в определенной композиции (включая Хангульские композиции,но исключая Композиционные Исключения и Не-Стартурные Декомпозиции).</target>
        </trans-unit>
        <trans-unit id="32fdbc7eddb18b1a419ce2d35092783f07d4af22" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point has Non-Starter Decomposition.</source>
          <target state="translated">Возвращает булевую информацию о том,имеет ли точка кода нестартовое разложение.</target>
        </trans-unit>
        <trans-unit id="05cafc23e99e3bc76eb241d5b7b7627390e2da71" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point is a composition exclusion.</source>
          <target state="translated">Возвращает булевую информацию о том,является ли точка кода исключающей композицию.</target>
        </trans-unit>
        <trans-unit id="53705043824b274a980c94b9c5b624aa7db18ac7" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point is a singleton</source>
          <target state="translated">Он возвращает булевую информацию о том,является ли точка кода одиночной кнопкой.</target>
        </trans-unit>
        <trans-unit id="3bdd6ab415e1d7803474768a9f82c375da3c7e8f" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$Bzip2Error&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">Он возвращает объект &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; в случае успеха и undef в случае неудачи. Переменная &lt;code&gt;$Bzip2Error&lt;/code&gt; будет содержать сообщение об ошибке при сбое.</target>
        </trans-unit>
        <trans-unit id="7b202b09f5eedc56f3eae8328563e18bb8bb267b" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$DeflateError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">Он возвращает объект &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; в случае успеха и undef в случае неудачи. Переменная &lt;code&gt;$DeflateError&lt;/code&gt; будет содержать сообщение об ошибке при сбое.</target>
        </trans-unit>
        <trans-unit id="0d7bf22968af56755cc48cf3e5eb1866df93fb4a" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$GzipError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">Он возвращает объект &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; в случае успеха и undef в случае неудачи. Переменная &lt;code&gt;$GzipError&lt;/code&gt; будет содержать сообщение об ошибке при сбое.</target>
        </trans-unit>
        <trans-unit id="e02c10ad441b5cb12d98ff7ac04d2bec29b76002" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$RawDeflateError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">Он возвращает объект &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; в случае успеха и undef в случае неудачи. Переменная &lt;code&gt;$RawDeflateError&lt;/code&gt; будет содержать сообщение об ошибке при сбое.</target>
        </trans-unit>
        <trans-unit id="733e2aec8845350fd889ee56ce6b2b1905e8c50e" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Zip&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$ZipError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">Он возвращает объект &lt;code&gt;IO::Compress::Zip&lt;/code&gt; в случае успеха и undef в случае неудачи. Переменная &lt;code&gt;$ZipError&lt;/code&gt; будет содержать сообщение об ошибке при сбое.</target>
        </trans-unit>
        <trans-unit id="55f5b32339878811a57c6c9adb8fddab3c155d6c" translate="yes" xml:space="preserve">
          <source>It returns an array of four or five scalar values: EXTRALIBS, BSLOADLIBS, LDLOADLIBS, LD_RUN_PATH, and, optionally, a reference to the array of the filenames of actual libraries. Some of these don't mean anything unless on Unix. See the details about those platform specifics below. The list of the filenames is returned only if $need_names argument is true.</source>
          <target state="translated">Возвращает массив из четырех или пяти скалярных значений:EXTRALIBS,BSLOADLIBS,LDLOADLIBS,LD_RUN_PATH и,опционально,ссылку на массив имен файлов актуальных библиотек.Некоторые из них ничего не значат,кроме как в Unix.Смотрите подробности о специфике этих платформ ниже.Список имен файлов возвращается только в том случае,если аргумент $need_names равен true.</target>
        </trans-unit>
        <trans-unit id="1b60723356123e31c4f819b7b57959bd345247e2" translate="yes" xml:space="preserve">
          <source>It returns falls if &lt;code&gt;PACKAGE&lt;/code&gt; has not been loaded yet and the location from where it is said to be loaded on success.</source>
          <target state="translated">Он возвращается, если &lt;code&gt;PACKAGE&lt;/code&gt; еще не был загружен и место, откуда он считается загруженным, в случае успеха.</target>
        </trans-unit>
        <trans-unit id="ab042aac65d23a49c795444acd76a148a334187c" translate="yes" xml:space="preserve">
          <source>It returns the FCC form (&quot;Fast C Contiguous&quot;; cf. UTN #5).</source>
          <target state="translated">Он возвращает форму FCC (&quot;Fast C Contiguous&quot;;ср.UTN #5).</target>
        </trans-unit>
        <trans-unit id="a80e6baf3c3b2c9535a05b4bf410d7b9c5dde971" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form C (formed by canonical decomposition followed by canonical composition).</source>
          <target state="translated">Она возвращает Форму Нормализации С (образованную каноническим разложением,за которым следует каноническая композиция).</target>
        </trans-unit>
        <trans-unit id="a2c5e52810047ee1962e46371ac68fc8dc9054e8" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form D (formed by canonical decomposition).</source>
          <target state="translated">Она возвращает Форму Нормализации D (образованную каноническим разложением).</target>
        </trans-unit>
        <trans-unit id="1383c6449aad07f7997fc3ec42b0ae3c98ca4a0b" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form KC (formed by compatibility decomposition followed by &lt;b&gt;canonical&lt;/b&gt; composition).</source>
          <target state="translated">Он возвращает форму нормализации KC (сформированную путем декомпозиции совместимости с последующей &lt;b&gt;канонической&lt;/b&gt; композицией).</target>
        </trans-unit>
        <trans-unit id="1d675fdcf5ef1f2056866497e81d752934809791" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form KD (formed by compatibility decomposition).</source>
          <target state="translated">Возвращает Форму Нормализации KD (образованную декомпозицией совместимости).</target>
        </trans-unit>
        <trans-unit id="4b300118aa94b87649f21e9834526f64818158d8" translate="yes" xml:space="preserve">
          <source>It returns the combining class (as an integer) of the character.</source>
          <target state="translated">Возвращает комбинированный класс (в виде целого числа)символа.</target>
        </trans-unit>
        <trans-unit id="eb22d3dace2d05fa601426312363eea62fa0226b" translate="yes" xml:space="preserve">
          <source>It returns the concatenation of the decomposition of each character in the string.</source>
          <target state="translated">Возвращает конкатенцию разложения каждого символа в строке.</target>
        </trans-unit>
        <trans-unit id="8a852534b28496d947f4c8e100a132748793361d" translate="yes" xml:space="preserve">
          <source>It returns the normalization form of &lt;code&gt;$form_name&lt;/code&gt; .</source>
          <target state="translated">Он возвращает форму нормализации &lt;code&gt;$form_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf3cd095961560034a7b6b2b8569541880d86696" translate="yes" xml:space="preserve">
          <source>It returns the normalization form of &lt;code&gt;$form_name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b49fbb316b9278a17d532265fe4cd4e754492934" translate="yes" xml:space="preserve">
          <source>It returns the remainder &lt;code&gt;$r = $x - $n*$y&lt;/code&gt; , where &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt; . The &lt;code&gt;$r&lt;/code&gt; has the same sign as &lt;code&gt;$x&lt;/code&gt; and magnitude (absolute value) less than the magnitude of &lt;code&gt;$y&lt;/code&gt; .</source>
          <target state="translated">Он возвращает остаток &lt;code&gt;$r = $x - $n*$y&lt;/code&gt; , где &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt; . &lt;code&gt;$r&lt;/code&gt; имеет тот же знак, что и &lt;code&gt;$x&lt;/code&gt; и величины (абсолютное значение) меньше , чем величина &lt;code&gt;$y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b96df5a323ccde59c4604283479ada0f880ece8b" translate="yes" xml:space="preserve">
          <source>It returns the remainder &lt;code&gt;$r = $x - $n*$y&lt;/code&gt;, where &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt;. The &lt;code&gt;$r&lt;/code&gt; has the same sign as &lt;code&gt;$x&lt;/code&gt; and magnitude (absolute value) less than the magnitude of &lt;code&gt;$y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837e320b920fba38b4782fb970e5ba4d1738747b" translate="yes" xml:space="preserve">
          <source>It returns the result of canonical composition without applying any decomposition.</source>
          <target state="translated">Он возвращает результат канонической композиции без применения какого-либо разложения.</target>
        </trans-unit>
        <trans-unit id="97c8ed595d7942de577ac5b60184bc3e70b57d00" translate="yes" xml:space="preserve">
          <source>It returns the result of reordering the combining characters according to Canonical Ordering Behavior.</source>
          <target state="translated">Возвращает результат переупорядочивания комбинированных символов в соответствии с Каноническим Поведением Порядка.</target>
        </trans-unit>
        <trans-unit id="0c7818f52644428114d7169367d50f2b1f7b0307" translate="yes" xml:space="preserve">
          <source>It returns the same values as run_tests, so you can further examine the test results if you need to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e13862ba07278e0519e9e4b0230517dc0328cb" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt; ) if &lt;code&gt;YES&lt;/code&gt; ; false (&lt;code&gt;empty string&lt;/code&gt; ) if &lt;code&gt;NO&lt;/code&gt; .</source>
          <target state="translated">Возвращает истину ( &lt;code&gt;1&lt;/code&gt; ), если &lt;code&gt;YES&lt;/code&gt; ; false ( &lt;code&gt;empty string&lt;/code&gt; ), если &lt;code&gt;NO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1aae34c500721c408b0788928293058d1fef3fa" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt; ) if &lt;code&gt;YES&lt;/code&gt; ; false (&lt;code&gt;empty string&lt;/code&gt; ) if &lt;code&gt;NO&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;MAYBE&lt;/code&gt; .</source>
          <target state="translated">Возвращает истину ( &lt;code&gt;1&lt;/code&gt; ), если &lt;code&gt;YES&lt;/code&gt; ; false ( &lt;code&gt;empty string&lt;/code&gt; ), если &lt;code&gt;NO&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если &lt;code&gt;MAYBE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e07cc039b9bc283952fe2e0a04d4a341d590f3e7" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt;) if &lt;code&gt;YES&lt;/code&gt;; false (&lt;code&gt;empty string&lt;/code&gt;) if &lt;code&gt;NO&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e00917cf3a6843e18b27b643db79b6a4b69a6e3c" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt;) if &lt;code&gt;YES&lt;/code&gt;; false (&lt;code&gt;empty string&lt;/code&gt;) if &lt;code&gt;NO&lt;/code&gt;; &lt;code&gt;undef&lt;/code&gt; if &lt;code&gt;MAYBE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a729a5529269a29252f3c2bf2eddc2d7ae807d5" translate="yes" xml:space="preserve">
          <source>It returns true if everything was ok. Otherwise it will &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; with one of the messages in the DIAGNOSTICS section.</source>
          <target state="translated">Возвращает истину, если все в порядке. В противном случае он &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; с одним из сообщений в разделе ДИАГНОСТИКА.</target>
        </trans-unit>
        <trans-unit id="7671ee7cfbfe57f504b6685d32d40a2c22391d50" translate="yes" xml:space="preserve">
          <source>It returns true if everything was ok. Otherwise it will &lt;code&gt;die()&lt;/code&gt; with one of the messages in the DIAGNOSTICS section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714b64110a6e486db425b221e1f3c962f9afdc59" translate="yes" xml:space="preserve">
          <source>It returns true if the key matched the criteria, or false otherwise.</source>
          <target state="translated">Он возвращает true,если ключ соответствовал критериям,или false иначе.</target>
        </trans-unit>
        <trans-unit id="cdfcc78500cdaa84a66edd629ca6a9d6469e030b" translate="yes" xml:space="preserve">
          <source>It returns two strings: the first one, &lt;code&gt;$processed&lt;/code&gt; , is a part before the last starter, and the second one, &lt;code&gt;$unprocessed&lt;/code&gt; is another part after the first part. A starter is a character having a combining class of zero (see UAX #15).</source>
          <target state="translated">Он возвращает две строки: первая, &lt;code&gt;$processed&lt;/code&gt; , является частью перед последним стартером, а вторая, &lt;code&gt;$unprocessed&lt;/code&gt; является частью после первой части. Стартер - это персонаж, имеющий нулевой класс комбинирования (см. UAX # 15).</target>
        </trans-unit>
        <trans-unit id="bcda37fdc9f0662d168c30c5cdca4733a8dcb549" translate="yes" xml:space="preserve">
          <source>It returns two strings: the first one, &lt;code&gt;$processed&lt;/code&gt;, is a part before the last starter, and the second one, &lt;code&gt;$unprocessed&lt;/code&gt; is another part after the first part. A starter is a character having a combining class of zero (see UAX #15).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d95a08ad814a7f6c58669c1b1316d305c90d5a" translate="yes" xml:space="preserve">
          <source>It sets up a class &lt;code&gt;Name&lt;/code&gt; that is a mirror of one of the implementation classes &lt;code&gt;Name_hash&lt;/code&gt; , &lt;code&gt;Name_id&lt;/code&gt; , ..., &lt;code&gt;Name_fieldhash&lt;/code&gt; . That determines which implementation is run.</source>
          <target state="translated">Он устанавливает &lt;code&gt;Name&lt;/code&gt; класса, которое является зеркалом одного из классов реализации &lt;code&gt;Name_hash&lt;/code&gt; , &lt;code&gt;Name_id&lt;/code&gt; , ..., &lt;code&gt;Name_fieldhash&lt;/code&gt; . Это определяет, какая реализация будет запущена.</target>
        </trans-unit>
        <trans-unit id="9e5fad0504d022f42c88d249188952052fecb50c" translate="yes" xml:space="preserve">
          <source>It sets up a class &lt;code&gt;Name&lt;/code&gt; that is a mirror of one of the implementation classes &lt;code&gt;Name_hash&lt;/code&gt;, &lt;code&gt;Name_id&lt;/code&gt;, ..., &lt;code&gt;Name_fieldhash&lt;/code&gt;. That determines which implementation is run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3f907f4536c2412455577e73bc09c598212b95" translate="yes" xml:space="preserve">
          <source>It should be noted that because of the double indirection in a &lt;code&gt;PerlIO *&lt;/code&gt; , a &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; &quot;is&quot; a &lt;code&gt;PerlIO *&lt;/code&gt; , and so to some degree at least one layer can use the &quot;standard&quot; API on the next layer down.</source>
          <target state="translated">Следует отметить, что из-за двойного косвенного &lt;code&gt;PerlIO *&lt;/code&gt; в PerlIO * , &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; &quot;является&quot; &lt;code&gt;PerlIO *&lt;/code&gt; , и поэтому до некоторой степени по крайней мере один уровень может использовать &quot;стандартный&quot; API на следующем уровне. вниз.</target>
        </trans-unit>
        <trans-unit id="c7a2a8bb586f925da0807a643800b85b4622cd20" translate="yes" xml:space="preserve">
          <source>It should be noted that because of the double indirection in a &lt;code&gt;PerlIO *&lt;/code&gt;, a &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; &quot;is&quot; a &lt;code&gt;PerlIO *&lt;/code&gt;, and so to some degree at least one layer can use the &quot;standard&quot; API on the next layer down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14a8d613d8259f6f9199d94a881c7c7dcdcf9aa" translate="yes" xml:space="preserve">
          <source>It should be noted that the</source>
          <target state="translated">Следует отметить,что</target>
        </trans-unit>
        <trans-unit id="a59ebc15941a0d3262901c5719fbfc123fcebf0b" translate="yes" xml:space="preserve">
          <source>It splits the task of generating the Makefile into several subroutines that can be individually overridden. Each subroutine returns the text it wishes to have written to the Makefile.</source>
          <target state="translated">Он разделяет задачу генерации Makefile на несколько подпрограмм,которые могут быть индивидуально переопределены.Каждая подпрограмма возвращает Makefile текст,который она хочет написать.</target>
        </trans-unit>
        <trans-unit id="82c9f4b13f690f80567f90ba2a27e3429f909ad9" translate="yes" xml:space="preserve">
          <source>It starts like a perl module with a package declaration and a $VERSION variable. After that the pod section looks like any other pod with the only difference being that</source>
          <target state="translated">Он начинается как модуль perl с объявлением пакета и переменной $VERSION.После этого секция pod выглядит как любой другой pod с той лишь разницей,что</target>
        </trans-unit>
        <trans-unit id="20eae6f6b825ab7ac7ea22eebe86fa7977d3df1a" translate="yes" xml:space="preserve">
          <source>It supports the following options, which are explained in &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt;: alt, indent, loose, quotes, sentence, width</source>
          <target state="translated">Он поддерживает следующие параметры, которые объясняются в &lt;a href=&quot;../text&quot;&gt;Pod :: Text&lt;/a&gt; : alt, отступ, свободный, кавычки, предложение, ширина.</target>
        </trans-unit>
        <trans-unit id="510b7b9b3f742ecce372251df0c084238337e534" translate="yes" xml:space="preserve">
          <source>It supports the following options, which are explained in &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt;: alt, indent, loose, quotes, sentence, width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41aba7727d2b065747551c63f609a3ed9ed9ee45" translate="yes" xml:space="preserve">
          <source>It suppresses duplicates in the column &lt;code&gt;in CPAN file&lt;/code&gt; such that distributions with many upgradeable modules are listed only once.</source>
          <target state="translated">Он подавляет дублирование в столбце &lt;code&gt;in CPAN file&lt;/code&gt; поэтому дистрибутивы с большим количеством обновляемых модулей отображаются только один раз.</target>
        </trans-unit>
        <trans-unit id="408685ef311dbc3599ddc558bce5925c12aacf23" translate="yes" xml:space="preserve">
          <source>It takes a Win32 native file handle and returns the size in bytes. Since the size can be a 64 bit value, on non 64 bit integer Perls the value returned will be an object of type &lt;code&gt;Math::BigInt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a26945a658df9dae641582923dd3754dc6d274" translate="yes" xml:space="preserve">
          <source>It takes a hash reference as an argument with two optional keys:</source>
          <target state="translated">В качестве аргумента используется хэш-ссылка с двумя необязательными ключами:</target>
        </trans-unit>
        <trans-unit id="b5a427be1727dabad24c941b3ce2ddc132315b17" translate="yes" xml:space="preserve">
          <source>It takes an optional hashref of options. Valid options include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0a17fd215b480661caff5f818c6d1a010f9c4c" translate="yes" xml:space="preserve">
          <source>It takes the same options as &lt;code&gt;new()&lt;/code&gt; but &lt;code&gt;lazy_validation&lt;/code&gt; defaults to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e1dcd4bfabeba9ef57034858eb07de6c007a236" translate="yes" xml:space="preserve">
          <source>It takes three arguments:</source>
          <target state="translated">Нужно три аргумента:</target>
        </trans-unit>
        <trans-unit id="a46a1b8abd0b80e91377ad517ddde11f2ad6f67d" translate="yes" xml:space="preserve">
          <source>It tells where the old configuration file was found (if found).</source>
          <target state="translated">Он сообщает,где был найден старый конфигурационный файл (если он был найден).</target>
        </trans-unit>
        <trans-unit id="316a78b3112e7d60b8f4b8e53c96f0951d499e19" translate="yes" xml:space="preserve">
          <source>It turns out that you can actually do this also:</source>
          <target state="translated">Оказывается,ты тоже можешь это сделать:</target>
        </trans-unit>
        <trans-unit id="674b7a92bd3974a32a6e0bc4ddce519662bb5c8a" translate="yes" xml:space="preserve">
          <source>It used to be legal to use &lt;code&gt;open()&lt;/code&gt; to associate both a filehandle and a dirhandle to the same symbol (glob or scalar). This idiom is likely to be confusing, and it was deprecated in Perl 5.10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c73ad695b4941117c2fa5c1a0fa146666ac448c3" translate="yes" xml:space="preserve">
          <source>It used to be possible to use &lt;code&gt;tie&lt;/code&gt;, &lt;code&gt;tied&lt;/code&gt; or &lt;code&gt;untie&lt;/code&gt; on a scalar while the scalar holds a typeglob. This caused its filehandle to be tied. It left no way to tie the scalar itself when it held a typeglob, and no way to untie a scalar that had had a typeglob assigned to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dce3c39f57e7aba5158e57e9f8e31a1b80c94a8" translate="yes" xml:space="preserve">
          <source>It used to hold the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59c80ea628e681a66374b04e2b703dd5af8c0f4" translate="yes" xml:space="preserve">
          <source>It uses the &lt;code&gt;getaddrinfo(3)&lt;/code&gt; function to convert hostnames and service names or port numbers into sets of possible addresses to connect to or listen on. This allows it to work for IPv6 where the system supports it, while still falling back to IPv4-only on systems which don't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="143c187acc40c6e4dc672359c95beead999d8959" translate="yes" xml:space="preserve">
          <source>It uses these values to set the extended timestamp field (ID is &quot;UT&quot;) in the local zip header using the three values, $atime, $mtime, $ctime. In addition it sets the extended timestamp field in the central zip header using &lt;code&gt;$mtime&lt;/code&gt; .</source>
          <target state="translated">Он использует эти значения для установки поля расширенной отметки времени (ID - &amp;laquo;UT&amp;raquo;) в локальном zip-заголовке с использованием трех значений: $ atime, $ mtime, $ ctime. Кроме того, он устанавливает расширенное поле временной метки в центральном заголовке zip-архива с помощью &lt;code&gt;$mtime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79a1b16fce6a4d25801f9ce9e038622522aac3da" translate="yes" xml:space="preserve">
          <source>It uses these values to set the extended timestamp field (ID is &quot;UT&quot;) in the local zip header using the three values, $atime, $mtime, $ctime. In addition it sets the extended timestamp field in the central zip header using &lt;code&gt;$mtime&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f46edc5cb632e7fccbb0705e4feec5f3263394" translate="yes" xml:space="preserve">
          <source>It was allowed to use a list of variables in a format, without separating them with commas. This usage has been deprecated for a long time, and as of Perl 5.28, this throws a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d084cee81998d6ff3982adc3ae633d6de17437" translate="yes" xml:space="preserve">
          <source>It was easy to write by having it call the Unix cat(1) command, but it would probably be more portable to open the file manually (and somewhat more efficient). Of course, because dot files are a Unixy concept, we're not that concerned.</source>
          <target state="translated">Было легко написать,вызвав команду Unix cat(1),но,вероятно,было бы более переносимо открывать файл вручную (и несколько более эффективно).Конечно,поскольку файлы с точками-это Unixy-концепция,нас это не так уж и беспокоит.</target>
        </trans-unit>
        <trans-unit id="c142dca333e2894efe138704aae3906df8914b33" translate="yes" xml:space="preserve">
          <source>It was extracted to dual-life on CPAN at version 1.95 by Paul Evans &amp;lt;leonerd@leonerd.org.uk&amp;gt;</source>
          <target state="translated">Он был извлечен для двойной жизни на CPAN в версии 1.95 Полом Эвансом &amp;lt;leonerd@leonerd.org.uk&amp;gt;</target>
        </trans-unit>
        <trans-unit id="166bbe1785a329a167c16e63945354e47d32b2c0" translate="yes" xml:space="preserve">
          <source>It was introduced to avoid the potential problems with the other form, available in all Perls. That form consists of a backslash followed by three octal digits. One problem with this form is that it can look exactly like an old-style backreference (see &lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;&quot;Disambiguation rules between old-style octal escapes and backreferences&quot;&lt;/a&gt; below.) You can avoid this by making the first of the three digits always a zero, but that makes \077 the largest code point specifiable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62846658b7b31f9fc5efa8815011f4172e2d224" translate="yes" xml:space="preserve">
          <source>It was introduced to avoid the potential problems with the other form, available in all Perls. That form consists of a backslash followed by three octal digits. One problem with this form is that it can look exactly like an old-style backreference (see &lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;Disambiguation rules between old-style octal escapes and backreferences&lt;/a&gt; below.) You can avoid this by making the first of the three digits always a zero, but that makes \077 the largest code point specifiable.</source>
          <target state="translated">Он был введен, чтобы избежать потенциальных проблем с другой формой, доступной во всех Perls. Эта форма состоит из обратной косой черты, за которой следуют три восьмеричные цифры. Одна из проблем с этой формой заключается в том, что она может выглядеть в точности как обратная ссылка в старом стиле (см. &lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;Ниже правила&lt;/a&gt; устранения неоднозначности между восьмеричным экранированием и обратными ссылками в старом стиле ). Вы можете избежать этого, сделав первую из трех цифр всегда равной нулю, но при этом делает \ 077 самой большой указываемой кодовой точкой.</target>
        </trans-unit>
        <trans-unit id="d3ee2a6714e3e6adf556faba68422a058c942c27" translate="yes" xml:space="preserve">
          <source>It will also use a default typemap installed as &lt;code&gt;ExtUtils::typemap&lt;/code&gt; .</source>
          <target state="translated">Он также будет использовать карту типов по умолчанию, установленную как &lt;code&gt;ExtUtils::typemap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0759e45d98bb4647a58253ee97ba7b77b47a644c" translate="yes" xml:space="preserve">
          <source>It will also use a default typemap installed as &lt;code&gt;ExtUtils::typemap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39ceb1fd2f53bed50ffdadfd8219def2a0114b8" translate="yes" xml:space="preserve">
          <source>It will also use the &lt;a href=&quot;Win32::Locale&quot;&gt;Win32::Locale&lt;/a&gt; module, if it's installed and IGNORE_WIN32_LOCALE is not set to a true value in the environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ab6ec702b4749c563dad7126fbebc3ad5a9050" translate="yes" xml:space="preserve">
          <source>It will also use the &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Locale&quot;&gt;Win32::Locale&lt;/a&gt; module, if it's installed.</source>
          <target state="translated">Он также будет использовать модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Locale&quot;&gt;Win32 :: Locale&lt;/a&gt; , если он установлен.</target>
        </trans-unit>
        <trans-unit id="eebcb44cc4b0d0bb319df0e9deccc15987032c7b" translate="yes" xml:space="preserve">
          <source>It will always have at least one parameter automatically passed by Perl - this corresponds to the name of the package. In the example above it will be &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt; .</source>
          <target state="translated">У него всегда будет хотя бы один параметр, автоматически передаваемый Perl - это соответствует имени пакета. В приведенном выше примере это будет &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5ac1faf8f9d59ddb0b6351807f16102144c68a8" translate="yes" xml:space="preserve">
          <source>It will always have at least one parameter automatically passed by Perl - this corresponds to the name of the package. In the example above it will be &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b05bb9d8d6cf0031940a72fb71a5bc98935f18a" translate="yes" xml:space="preserve">
          <source>It will default to the global setting of &lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt; , which by default is 0.</source>
          <target state="translated">По умолчанию используется глобальный параметр &lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt; , который по умолчанию равен 0.</target>
        </trans-unit>
        <trans-unit id="f9ce735c72f68600f9b73a9ad2fbc8f2efff3f41" translate="yes" xml:space="preserve">
          <source>It will default to the global setting of &lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt;, which by default is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5106e7131ba864011023c16e2d910c408243d8" translate="yes" xml:space="preserve">
          <source>It will exit with 255.</source>
          <target state="translated">Он выйдет с 255.</target>
        </trans-unit>
        <trans-unit id="cd3560715bcdcdb5a5493a3c2aa8a0baf196fb75" translate="yes" xml:space="preserve">
          <source>It will look in the environment for a</source>
          <target state="translated">Он будет искать в окружающей среде</target>
        </trans-unit>
        <trans-unit id="271dd95369c9033872c86c2ed2d28ba5b5a90105" translate="yes" xml:space="preserve">
          <source>It will not attempt to read beyond &lt;code&gt;e - 1&lt;/code&gt;, provided that the constraint &lt;code&gt;s &amp;lt; e&lt;/code&gt; is true (this is asserted for in &lt;code&gt;-DDEBUGGING&lt;/code&gt; builds). If the UTF-8 for the input character is malformed in some way, the program may croak, or the function may return the REPLACEMENT CHARACTER, at the discretion of the implementation, and subject to change in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ba08d3329959d8ccf0a41d4bc0caadee83aee8" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x (except overloaded operators) will modify $y, and vice versa. Or in other words, &lt;code&gt;=&lt;/code&gt; is only safe if you modify your BigInts only via overloaded math. As soon as you use a method call it breaks:</source>
          <target state="translated">Он не будет делать то, что вы думаете, например, делать копию $ x. Вместо этого он просто делает вторую ссылку на тот &lt;b&gt;же&lt;/b&gt; объект и сохраняет его в $ y. Таким образом, все, что изменяет $ x (кроме перегруженных операторов), изменяет $ y, и наоборот. Или, другими словами, &lt;code&gt;=&lt;/code&gt; безопасно, только если вы изменяете свои BigInts только с помощью перегруженной математики. Как только вы используете вызов метода, он прерывается:</target>
        </trans-unit>
        <trans-unit id="3da306523999d7f8b6c9832cd1c2497b109726eb" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x will modify $y (except overloaded math operators), and vice versa. See &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; for details and how to avoid that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef09ffb235f52f01cd3d25c0c384cab0806a14c" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x will modify $y (except overloaded math operators), and vice versa. See &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for details and how to avoid that.</source>
          <target state="translated">Он не будет делать то, что вы думаете, например, делать копию $ x. Вместо этого он просто делает вторую ссылку на тот &lt;b&gt;же&lt;/b&gt; объект и сохраняет его в $ y. Таким образом, все, что изменяет $ x, изменяет $ y (кроме перегруженных математических операторов), и наоборот. См. &lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt; для подробностей и того, как этого избежать.</target>
        </trans-unit>
        <trans-unit id="dd48a6ec2ae8cb512d05f750d53684c09ff6166d" translate="yes" xml:space="preserve">
          <source>It will print 'A' and then terminate, as it considers the match to be zero-width, and thus will not match at the same position twice in a row.</source>
          <target state="translated">Он выведет букву &quot;A&quot;,а затем завершит работу,так как считает,что совпадение будет нулевым,и,таким образом,не будет совпадать на одной и той же позиции дважды подряд.</target>
        </trans-unit>
        <trans-unit id="478635e0153852c95d172e95b14a9c73a7376ef9" translate="yes" xml:space="preserve">
          <source>It will produce output like this:</source>
          <target state="translated">Он будет производить продукцию вот так:</target>
        </trans-unit>
        <trans-unit id="033bdc255180f8b012ecc3dd8743f6cfc3998050" translate="yes" xml:space="preserve">
          <source>It will return undef if it was not able to find where the module was installed, or a hash reference with the following keys if it was able to find the file:</source>
          <target state="translated">Он вернет undef,если не смог найти место установки модуля,или хэш-ссылку со следующими ключами,если смог найти файл:</target>
        </trans-unit>
        <trans-unit id="8fd1f4b13738ec21f8b65433f2c797f00d69b112" translate="yes" xml:space="preserve">
          <source>It won't work across a sequence of &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;retrieve&lt;/code&gt; operations, however, because the addresses in the retrieved objects, which are part of the stringified references, will probably differ from the original addresses. The topology of your structure is preserved, but not hidden semantics like those.</source>
          <target state="translated">Однако он не будет работать в последовательности операций &lt;code&gt;store&lt;/code&gt; и &lt;code&gt;retrieve&lt;/code&gt; , поскольку адреса в извлеченных объектах, которые являются частью строковых ссылок, вероятно, будут отличаться от исходных адресов. Топология вашей структуры сохраняется, но не скрывается подобная семантика.</target>
        </trans-unit>
        <trans-unit id="d829aa608b7d822354368e8bc717a7f78948e864" translate="yes" xml:space="preserve">
          <source>It works on references, too:</source>
          <target state="translated">Он работает и по ссылкам:</target>
        </trans-unit>
        <trans-unit id="063657847573da8f9a48b2f56cfac7e5ef0c0bcc" translate="yes" xml:space="preserve">
          <source>It works this way as of Perl 5.18. Historically, it was inconsistent, and you would have to write</source>
          <target state="translated">Так работает на Perl 5.18.Исторически это было непоследовательно,и вы должны были бы написать...</target>
        </trans-unit>
        <trans-unit id="4c5e6eff5a06238d171586dbb35b0a88b0b974e6" translate="yes" xml:space="preserve">
          <source>It would be even more readable to write that this way:</source>
          <target state="translated">Было бы еще более читабельно так написать:</target>
        </trans-unit>
        <trans-unit id="bb356348d0e8eb250c8d665196d735d29e867b02" translate="yes" xml:space="preserve">
          <source>It would be much better if you could ignore the NULL terminations issue in the main application code and have a mechanism that automatically added the terminating NULL to all keys and values whenever you write to the database and have them removed when you read from the database. As I'm sure you have already guessed, this is a problem that DBM Filters can fix very easily.</source>
          <target state="translated">Было бы гораздо лучше,если бы вы могли игнорировать проблему окончания NULL в основном коде приложения и иметь механизм,который автоматически добавлял завершающий NULL ко всем ключам и значениям всякий раз,когда вы пишете в БД,и удалял их при чтении из БД.Как вы уже наверняка догадались,это проблема,которую DBM-фильтры могут легко исправить.</target>
        </trans-unit>
        <trans-unit id="664879d0a9a8a0187a85ff4778c8dc4aba203972" translate="yes" xml:space="preserve">
          <source>It would be much safer if the &lt;code&gt;upcase_in()&lt;/code&gt; function were written to return a copy of its parameters instead of changing them in place:</source>
          <target state="translated">Было бы намного безопаснее, если бы &lt;code&gt;upcase_in()&lt;/code&gt; была написана так, чтобы возвращать копию своих параметров, а не изменять их на месте:</target>
        </trans-unit>
        <trans-unit id="e4a501eefab1e263f175f9fb282fe6f38bf8d7a7" translate="yes" xml:space="preserve">
          <source>It would be nice if one could leave off the commas around the constants entirely and just say:</source>
          <target state="translated">Было бы неплохо,если бы можно было полностью оставить запятые вокруг констант и просто сказать:</target>
        </trans-unit>
        <trans-unit id="7a5b5ee29fb341a3488cf2301ee04c0c66aa8f82" translate="yes" xml:space="preserve">
          <source>It would be nice if we could do this in one fell swoop: unpack a short, back up a little, and then unpack 2 bytes. Since Perl</source>
          <target state="translated">Было бы неплохо,если бы мы могли сделать это одним махом:распаковать короткую,немного назад,а затем распаковать 2 байта.С тех пор как Perl</target>
        </trans-unit>
        <trans-unit id="aaa6174f1be6c791e8b304262469e518ba0d9df6" translate="yes" xml:space="preserve">
          <source>It would be nice to just write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcfbbfc45bc8f20d112951dc582ad08e297b4815" translate="yes" xml:space="preserve">
          <source>It would be nice to support encoding to non-UTF8, such as =?ISO-2022-JP? and =?ISO-8859-1?= but that makes the implementation too complicated. These days major mail agents all support =?UTF-8? so I think it is just good enough.</source>
          <target state="translated">Было бы неплохо поддержать кодировку неUTF8,например =?ISO-2022-JP? и =?ISO-8859-1?=,но это делает реализацию слишком сложной.В наши дни все основные почтовые агенты поддерживают =?UTF-8,так что я думаю,что это достаточно хорошо.</target>
        </trans-unit>
        <trans-unit id="33c0be04ddea1d5a74e0dccb69b13ad0c437b131" translate="yes" xml:space="preserve">
          <source>It would put the generated files into needed locations. Manually put</source>
          <target state="translated">Он поместит сгенерированные файлы в нужные места.Вручную</target>
        </trans-unit>
        <trans-unit id="79d53b44344312c7f974c895e0fb0eb2bd88118d" translate="yes" xml:space="preserve">
          <source>It's a Perl 4 style file defining values for system networking constants. Sometimes it is built using &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; when Perl is installed, but other times it is not. Modern programs should use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket;&lt;/code&gt; instead.</source>
          <target state="translated">Это файл в стиле Perl 4, определяющий значения системных сетевых констант. Иногда он &lt;a href=&quot;h2ph&quot;&gt;создается&lt;/a&gt; с использованием h2ph, когда установлен Perl, но иногда это не так. Современные программы должны &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket;&lt;/code&gt; вместо.</target>
        </trans-unit>
        <trans-unit id="2788c8ed5f3ec3bf8bed1e36ab8dd36690fbf752" translate="yes" xml:space="preserve">
          <source>It's a Perl 4 style file defining values for system networking constants. Sometimes it is built using &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; when Perl is installed, but other times it is not. Modern programs should use &lt;code&gt;use Socket;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4113134dec0bea10f51321538387f13a1da8743a" translate="yes" xml:space="preserve">
          <source>It's a cardinal sin to break existing Perl programs. New warnings can be contentious--some say that a program that emits warnings is not broken, while others say it is. Adding keywords has the potential to break programs, changing the meaning of existing token sequences or functions might break programs.</source>
          <target state="translated">Это кардинальный грех-ломать существующие программы Perl.Новые предупреждения могут быть довольны-скажем так,программа,выдающая предупреждения,не ломается,в то время как другие говорят,что ломается.Добавление ключевых слов может нарушить программы,изменение значения существующих токеновых последовательностей или функций может нарушить программы.</target>
        </trans-unit>
        <trans-unit id="3443bb54ef3fac59b8ef057b86f52fe4980fafa5" translate="yes" xml:space="preserve">
          <source>It's a little tricker with c2ph because you have to get the includes right. I can't know this for your system, but it's not usually too terribly difficult.</source>
          <target state="translated">Это маленький фокусник с c2ph,потому что ты должен получить правильные включения.Я не могу знать это для вашей системы,но обычно это не слишком сложно.</target>
        </trans-unit>
        <trans-unit id="110a6a21060fbfe67381c1323cb9f71073b9732c" translate="yes" xml:space="preserve">
          <source>It's also possible to get into trouble with other operations that don't care whether they use tainted values. Make judicious use of the file tests in dealing with any user-supplied filenames. When possible, do opens and such &lt;b&gt;after&lt;/b&gt; properly dropping any special user (or group!) privileges. Perl doesn't prevent you from opening tainted filenames for reading, so be careful what you print out. The tainting mechanism is intended to prevent stupid mistakes, not to remove the need for thought.</source>
          <target state="translated">Также возможны проблемы с другими операциями, которым все равно, используют ли они испорченные значения. Разумно используйте тесты файлов при работе с любыми пользовательскими именами файлов. Когда возможно, открывайте и т.п. &lt;b&gt;после&lt;/b&gt; правильного удаления каких-либо специальных привилегий пользователя (или группы!). Perl не мешает вам открывать испорченные имена файлов для чтения, поэтому будьте осторожны при распечатке. Механизм заражения предназначен для предотвращения глупых ошибок, а не для устранения необходимости думать.</target>
        </trans-unit>
        <trans-unit id="66317ba5ef9718c34fadba6cc4766d4c890f748d" translate="yes" xml:space="preserve">
          <source>It's also the source of a useful idiom for executing a function or performing an operation in list context and then counting the number of return values, by assigning to an empty list and then using that assignment in scalar context. For example, this code:</source>
          <target state="translated">Это также источник полезной идиомы для выполнения функции или операции в контексте списка,а затем подсчета количества возвращаемых значений,путем присвоения пустого списка и последующего использования этого присвоения в скалярном контексте.Например,этот код:</target>
        </trans-unit>
        <trans-unit id="fb0964e5585557a9c666044136d7fe7eaf45d2a2" translate="yes" xml:space="preserve">
          <source>It's also too slow (despite caching).</source>
          <target state="translated">Также слишком медленно (несмотря на кэширование).</target>
        </trans-unit>
        <trans-unit id="bfb78b8d261485bbdd288bb61ac4516df58d28f5" translate="yes" xml:space="preserve">
          <source>It's also useful in those cases where you are comparing numbers and &lt;code&gt;is()&lt;/code&gt; 's use of &lt;code&gt;eq&lt;/code&gt; will interfere:</source>
          <target state="translated">Это также полезно в тех случаях , когда вы сравниваете номер и &lt;code&gt;is()&lt;/code&gt; &amp;laquo;s использование &lt;code&gt;eq&lt;/code&gt; будет мешать:</target>
        </trans-unit>
        <trans-unit id="f80232728d1a0e850ad2f6c5b3fdccf6e503f004" translate="yes" xml:space="preserve">
          <source>It's also useful in those cases where you are comparing numbers and &lt;code&gt;is()&lt;/code&gt;'s use of &lt;code&gt;eq&lt;/code&gt; will interfere:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8752339d213c2f85078fabecb615c362db1828df" translate="yes" xml:space="preserve">
          <source>It's also worth taking a moment to explain what happens when you &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize a member of a composite type (i.e. an array or hash element). In this case, the element is &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized</source>
          <target state="translated">Также стоит взять время , чтобы объяснить , что происходит , когда вы &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; Изя элемента составного типа (т.е. массив или хэш - элемент). В этом случае элемент является &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; роскопией</target>
        </trans-unit>
        <trans-unit id="c2abe8691d5cb64abc6ccb815e6052901189c534" translate="yes" xml:space="preserve">
          <source>It's also worth taking a moment to explain what happens when you &lt;code&gt;local&lt;/code&gt;ize a member of a composite type (i.e. an array or hash element). In this case, the element is &lt;code&gt;local&lt;/code&gt;ized</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd541e8b6a88392365f934744a878ca9f6a497b7" translate="yes" xml:space="preserve">
          <source>It's better to have numerous simple routines than a few monolithic ones. If your routine changes its behaviour significantly based on its arguments, it's a sign that you should have two (or more) separate routines.</source>
          <target state="translated">Лучше иметь множество простых процедур,чем несколько монолитных.Если ваша рутина существенно меняет свое поведение,основываясь на аргументах,это означает,что вы должны иметь две (или более)отдельные рутины.</target>
        </trans-unit>
        <trans-unit id="f3b2de78648bbd7090bfe684b2c6827590ea2a26" translate="yes" xml:space="preserve">
          <source>It's designed to be used as a handy command line utility:</source>
          <target state="translated">Она предназначена для использования в качестве удобной утилиты командной строки:</target>
        </trans-unit>
        <trans-unit id="96439b3081e445faf2fae88934bbc314011a0c32" translate="yes" xml:space="preserve">
          <source>It's easy to notice the problem in such a short example, but in more complicated code you are looking for trouble if you don't localize changes to the special variables.</source>
          <target state="translated">Легко заметить проблему в таком коротком примере,но в более сложном коде вы ищете проблемы,если не локализовать изменения в специальных переменных.</target>
        </trans-unit>
        <trans-unit id="dde0b49167dc00c194116739ebbe7f23d5e20372" translate="yes" xml:space="preserve">
          <source>It's egg-eating all over again: Some think that as a bit string this should be written &quot;10001100&quot; i.e. beginning with the most significant bit, others insist on &quot;00110001&quot;. Well, Perl isn't biased, so that's why we have two bit string codes:</source>
          <target state="translated">Он снова ест яйца:Одни считают,что в качестве битовой строки должно быть написано &quot;10001100&quot;,т.е.начинаться с самого значимого бита,другие настаивают на &quot;00110001&quot;.Ну,Perl не предвзятый,поэтому у нас есть два битовых кода строк:</target>
        </trans-unit>
        <trans-unit id="f24807b6184833a23a70254e8f0aebceeb147f40" translate="yes" xml:space="preserve">
          <source>It's especially useful when comparing greater-than or smaller-than relation between values:</source>
          <target state="translated">Это особенно полезно при сравнении большего или меньшего соотношения между значениями:</target>
        </trans-unit>
        <trans-unit id="1e3a1b4314f9d6c52bc40629c2fb29defff528f6" translate="yes" xml:space="preserve">
          <source>It's essential to run any timing measurements a sufficient number of times so the numbers settle on a numerical average, otherwise each run will naturally fluctuate due to variations in the environment, to reduce the effect of contention for &lt;code&gt;CPU&lt;/code&gt; resources and network bandwidth for instance. Running the above code for one million iterations, we can take a look at the report output by the &lt;code&gt;Benchmark&lt;/code&gt; module, to see which approach is the most effective.</source>
          <target state="translated">Важно выполнять любые измерения времени достаточное количество раз, чтобы числа приходили к среднему числовому значению, в противном случае каждый запуск будет естественным образом колебаться из-за изменений в среде, например, для уменьшения эффекта конкуренции за ресурсы &lt;code&gt;CPU&lt;/code&gt; и пропускную способность сети. Запустив приведенный выше код для миллиона итераций, мы можем взглянуть на отчет, выводимый модулем &lt;code&gt;Benchmark&lt;/code&gt; , чтобы увидеть, какой подход является наиболее эффективным.</target>
        </trans-unit>
        <trans-unit id="7514b40c5333fb03e3aac77ea8c92f752cf5dd0e" translate="yes" xml:space="preserve">
          <source>It's for</source>
          <target state="translated">Это для</target>
        </trans-unit>
        <trans-unit id="b4b810adc86730679601de6a1493c2a23c259247" translate="yes" xml:space="preserve">
          <source>It's good idea to post an announcement of the availability of your module (or the module itself if small) to the comp.lang.perl.announce Usenet newsgroup. This will at least ensure very wide once-off distribution.</source>
          <target state="translated">Хорошей идеей будет разместить объявление о доступности вашего модуля (или самого модуля,если он мал)в новостной группе Usenet на сайте comp.lang.perl.announce.Это обеспечит по крайней мере очень широкий одноразовый дистрибутив.</target>
        </trans-unit>
        <trans-unit id="90af562410b60653a0aa18fd2da97246062921f5" translate="yes" xml:space="preserve">
          <source>It's good that you lost track, because you shouldn't depend on the internal format being any specific encoding. But since you asked: by default, the internal format is either ISO-8859-1 (latin-1), or utf8, depending on the history of the string. On EBCDIC platforms, this may be different even.</source>
          <target state="translated">Хорошо,что вы потеряли трек,потому что вы не должны зависеть от того,какой внутренний формат является какой-либо конкретной кодировкой.Но поскольку вы спросили:по умолчанию внутренний формат либо ISO-8859-1 (latin-1),либо utf8,в зависимости от истории строки.На платформах EBCDIC это может отличаться даже.</target>
        </trans-unit>
        <trans-unit id="d9d2e12c0d08cbda4c9a91e7d799364ca6410b91" translate="yes" xml:space="preserve">
          <source>It's important that $how_many accurately reflects the number of tests in the SKIP block so the # of tests run will match up with your plan. If your plan is &lt;code&gt;no_plan&lt;/code&gt; $how_many is optional and will default to 1.</source>
          <target state="translated">Важно, чтобы $ how_many точно отражала количество тестов в блоке SKIP, чтобы количество запускаемых тестов соответствовало вашему плану. Если ваш план &lt;code&gt;no_plan&lt;/code&gt; , $ how_many не является обязательным и по умолчанию будет равен 1.</target>
        </trans-unit>
        <trans-unit id="1e8b6f334f8979bc29ccd072552302ba947b27dc" translate="yes" xml:space="preserve">
          <source>It's important to know what custom operators won't do for you. They won't let you add new syntax to Perl, directly. They won't even let you add new keywords, directly. In fact, they won't change the way Perl compiles a program at all. You have to do those changes yourself, after Perl has compiled the program. You do this either by manipulating the op tree using a &lt;code&gt;CHECK&lt;/code&gt; block and the &lt;code&gt;B::Generate&lt;/code&gt; module, or by adding a custom peephole optimizer with the &lt;code&gt;optimize&lt;/code&gt; module.</source>
          <target state="translated">Важно знать, что пользовательские операторы вам не подойдут. Они не позволят вам напрямую добавить новый синтаксис в Perl. Они даже не позволят вам напрямую добавлять новые ключевые слова. Фактически, они вообще не изменят способ компиляции программы Perl. Вы должны внести эти изменения самостоятельно после того, как Perl скомпилирует программу. Это можно сделать либо путем манипулирования деревом &lt;code&gt;CHECK&lt;/code&gt; с помощью блока CHECK и модуля &lt;code&gt;B::Generate&lt;/code&gt; , либо путем добавления настраиваемого оптимизатора глазка с модулем &lt;code&gt;optimize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="885ff1b611d651161375b8dbd778f67a1c287d62" translate="yes" xml:space="preserve">
          <source>It's important to note that locks don't prevent access to the variable in question, only lock attempts. This is in keeping with Perl's longstanding tradition of courteous programming, and the advisory file locking that &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; gives you.</source>
          <target state="translated">Важно отметить, что блокировки не предотвращают доступ к рассматриваемой переменной, а только попытки блокировки. Это соответствует давней традиции вежливого программирования в Perl и блокировке файлов с рекомендациями, которую предоставляет &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7c0c2bd9c27ab14c34335de35804fff201f2533" translate="yes" xml:space="preserve">
          <source>It's important to note that locks don't prevent access to the variable in question, only lock attempts. This is in keeping with Perl's longstanding tradition of courteous programming, and the advisory file locking that &lt;code&gt;flock()&lt;/code&gt; gives you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b860229e93d14d8905681b2058fe74c37532fe8" translate="yes" xml:space="preserve">
          <source>It's important to note that specifying this parameter as non-null will cause any warnings this function would otherwise generate to be suppressed, and instead be placed in &lt;code&gt;*msgs&lt;/code&gt;. The caller can check the lexical warnings state (or not) when choosing what to do with the returned messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2459276db9d22fb9b53f0419f11fb94dbdc78be" translate="yes" xml:space="preserve">
          <source>It's important to note that the resulting string does &lt;b&gt;not&lt;/b&gt; contain the padding characters typical of Base64 encodings. This omission is deliberate, and is done to maintain compatibility with the family of CPAN Digest modules. See &lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;&quot;PADDING OF BASE64 DIGESTS&quot;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ddbbe7b1b79fc3086fea949fd8823cad9c01f9" translate="yes" xml:space="preserve">
          <source>It's important to note that the resulting string does &lt;b&gt;not&lt;/b&gt; contain the padding characters typical of Base64 encodings. This omission is deliberate, and is done to maintain compatibility with the family of CPAN Digest modules. See &lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;PADDING OF BASE64 DIGESTS&lt;/a&gt; for details.</source>
          <target state="translated">Важно отметить, что результирующая строка &lt;b&gt;не&lt;/b&gt; содержит символов заполнения, типичных для кодировок Base64. Это упущение является преднамеренным и сделано для обеспечения совместимости с семейством модулей CPAN Digest. Подробности см. В разделе &amp;laquo; &lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;ЗАПОЛНЕНИЕ BASE64 DIGESTS&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b1efa7406cffc0cec49027fa169f45a3bd427b6" translate="yes" xml:space="preserve">
          <source>It's important to point out that if you want your subclass to be automatically used by &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; you'll have to and make sure it gets loaded somehow. If you're using &lt;a href=&quot;prove&quot;&gt;prove&lt;/a&gt; you can write an &lt;a href=&quot;App::Prove&quot;&gt;App::Prove&lt;/a&gt; plugin. If you're using &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; or &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; directly (e.g. through a custom script, &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;, or &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt;) you can use the &lt;code&gt;config&lt;/code&gt; option which will cause &lt;a href=&quot;TAP::Parser::IteratorFactory#load_sources&quot;&gt;&quot;load_sources&quot; in TAP::Parser::IteratorFactory&lt;/a&gt; to load your subclass).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc53949ff6cd0c67b2204f9d9fce4d627aed693" translate="yes" xml:space="preserve">
          <source>It's important to realize that there are no bytes in a text string. Of course, Perl has its internal encoding to store the string in memory, but ignore that. If you have to do anything with the number of bytes, it's probably best to move that part to step 3, just after you've encoded the string. Then you know exactly how many bytes it will be in the destination string.</source>
          <target state="translated">Важно понимать,что в текстовой строке нет байтов.Конечно,Perl имеет свою внутреннюю кодировку для хранения строки в памяти,но игнорируйте это.Если вам нужно что-то сделать с количеством байт,то,наверное,лучше всего перенести эту часть на шаг 3,сразу после того,как вы закодировали строку.Тогда вы точно знаете,сколько байт будет в целевой строке.</target>
        </trans-unit>
        <trans-unit id="968be3dc629433b16258b1052384042ab95062a2" translate="yes" xml:space="preserve">
          <source>It's important to set a few things straight first. This is the most important part of this tutorial. This view may conflict with other information that you may have found on the web, but that's mostly because many sources are wrong.</source>
          <target state="translated">Важно сначала кое-что прояснить.Это самая важная часть этого учебника.Этот взгляд может противоречить другой информации,которую вы,возможно,нашли в Интернете,но это в основном потому,что многие источники ошибочны.</target>
        </trans-unit>
        <trans-unit id="6903f2d3d35327d3bebb7683e89ad822d6bff850" translate="yes" xml:space="preserve">
          <source>It's important to understand that we are specifically</source>
          <target state="translated">Важно понимать,что мы конкретно</target>
        </trans-unit>
        <trans-unit id="f9b3935d15d2be2d5136d58cf490c65310c19874" translate="yes" xml:space="preserve">
          <source>It's important you make sure to use the &lt;code&gt;[ ]&lt;/code&gt; array reference constructor. That's because this wouldn't work:</source>
          <target state="translated">Важно убедиться, что вы используете конструктор ссылок на массив &lt;code&gt;[ ]&lt;/code&gt; . Это потому, что это не сработает:</target>
        </trans-unit>
        <trans-unit id="9fbefe7e70d26e99bc2294921c0de37542709163" translate="yes" xml:space="preserve">
          <source>It's just a first step, but it's usually a good first step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="134dc1d9bd724d0238c1c1d4c4831e9e7f0b91b6" translate="yes" xml:space="preserve">
          <source>It's likely you'll have to add new data types later.</source>
          <target state="translated">Скорее всего,позже вам придется добавлять новые типы данных.</target>
        </trans-unit>
        <trans-unit id="4696eb464dfb95137de621144fb7f593ad6ebd66" translate="yes" xml:space="preserve">
          <source>It's not (not!) the boundary between whitespace and non-whitespace, and it's not the stuff between words we use to create sentences.</source>
          <target state="translated">Это не (не!)граница между пробелами и не-пробелами,и это не то,что мы используем между словами для создания предложений.</target>
        </trans-unit>
        <trans-unit id="6bef3566d208cec3b519ea92214ab4883f383173" translate="yes" xml:space="preserve">
          <source>It's not a good idea to split a construct in the middle like this, and it doesn't work here. Instead use the solution above.</source>
          <target state="translated">Плохая идея делить конструкцию посередине вот так,и здесь она не работает.Вместо этого используйте решение,описанное выше.</target>
        </trans-unit>
        <trans-unit id="ec66dac5bae6d199b4bd16298b91f74283fac7f8" translate="yes" xml:space="preserve">
          <source>It's not as easy a problem as it looks. How many words do you think are in there? Wait for it... wait for it.... If you answered 5 you're right. Perl words are groups of &lt;code&gt;\w+&lt;/code&gt; , but that's not what you want to capitalize. How is Perl supposed to know not to capitalize that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; after the apostrophe? You could try a regular expression:</source>
          <target state="translated">Это не так просто, как кажется. Как вы думаете, сколько слов там? Подожди ... подожди .... Если ты ответил 5, ты прав. Слова Perl представляют собой группы &lt;code&gt;\w+&lt;/code&gt; , но это не то, что вы хотите использовать с большой буквы. Как Perl должен знать, что буквы &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; после апострофа не используются? Вы можете попробовать регулярное выражение:</target>
        </trans-unit>
        <trans-unit id="4a8bd2e0723c73ceda4c03acccc160b0debe5557" translate="yes" xml:space="preserve">
          <source>It's not as easy a problem as it looks. How many words do you think are in there? Wait for it... wait for it.... If you answered 5 you're right. Perl words are groups of &lt;code&gt;\w+&lt;/code&gt;, but that's not what you want to capitalize. How is Perl supposed to know not to capitalize that &lt;code&gt;s&lt;/code&gt; after the apostrophe? You could try a regular expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3fa5386c065511869ec9dc4289bdbe2b8248c4" translate="yes" xml:space="preserve">
          <source>It's not enough to say: &quot;that will make it run faster&quot;, you have to check it. Rerun the code under control of the benchmarking or profiling modules, from the first step above, and check that the new code executed the &lt;b&gt;same task&lt;/b&gt; in</source>
          <target state="translated">Недостаточно сказать: &amp;laquo;это заставит его работать быстрее&amp;raquo;, надо это проверить. Повторите запуск кода под управлением модулей тестирования или профилирования, начиная с первого шага выше, и убедитесь, что новый код выполняет ту &lt;b&gt;же задачу&lt;/b&gt; в</target>
        </trans-unit>
        <trans-unit id="ac2ff02b85c831d3f4a6ab13ec2cd187eee43782" translate="yes" xml:space="preserve">
          <source>It's not possible to individually showcase all the performance related code for Perl here, naturally, but here's a short list of modules from the CPAN which deserve further attention.</source>
          <target state="translated">Естественно,здесь невозможно индивидуально показать весь код,связанный с производительностью Perl,но вот краткий список модулей из CPAN,которые заслуживают дальнейшего внимания.</target>
        </trans-unit>
        <trans-unit id="dd227a742cbf3f4b2811cdbf8769ec886d4ea747" translate="yes" xml:space="preserve">
          <source>It's not possible to use this module to embed formatting and color attributes using Perl formats. They replace the escape character with a space (as documented in</source>
          <target state="translated">Невозможно использовать этот модуль для встраивания атрибутов форматирования и цвета с использованием форматов Perl.Они заменяют экранирующий символ пробелом (как описано в документе</target>
        </trans-unit>
        <trans-unit id="535d143f61fad023b3aec2dac42bd177c0d8265b" translate="yes" xml:space="preserve">
          <source>It's not possible to use this module to embed formatting and color attributes using Perl formats. They replace the escape character with a space (as documented in &lt;a href=&quot;http://man.he.net/man1/perlform&quot;&gt;perlform(1)&lt;/a&gt;), resulting in garbled output from the unrecognized attribute. Even if there were a way around that problem, the format doesn't know that the non-printing escape sequence is zero-length and would incorrectly format the output. For formatted output using color or other attributes, either use sprintf() instead or use formline() and then add the color or other attributes after formatting and before output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf7485885d18503520503d1c1deed4967629127" translate="yes" xml:space="preserve">
          <source>It's not really a barrel of laughs, is it? In fact, it's worse than it may seem; the eagle-eyed may notice that the first field should only be 10 characters wide, and the error has propagated right through the other numbers - which we've had to count by hand. So it's error-prone as well as horribly unfriendly.</source>
          <target state="translated">Это ведь не бочка смеха,да? На самом деле,это хуже,чем может показаться;орлиный глаз может заметить,что первое поле должно быть всего 10 символов в ширину,а ошибка распространилась прямо через другие числа-которые нам пришлось считать от руки.Поэтому оно как подвержено ошибкам,так и ужасно недружелюбно.</target>
        </trans-unit>
        <trans-unit id="e0ac4f099ce1bc3e2ec1419213f4e20eba107331" translate="yes" xml:space="preserve">
          <source>It's not scary. Come, hold my hand. We're going to give an example of testing a module. For our example, we'll be testing a date library, &lt;a href=&quot;Date::ICal&quot;&gt;Date::ICal&lt;/a&gt;. It's on CPAN, so download a copy and follow along. [2]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d4e78b20b4ec5c47ad5e65cf852abb8251388b" translate="yes" xml:space="preserve">
          <source>It's ok for your test to change where STDOUT and STDERR point to, Test::Builder's default output settings will not be affected.</source>
          <target state="translated">Для вашего теста нормально изменить,где STDOUT и STDERR указывают на,Test::Builder's по умолчанию выходные параметры не будут затронуты.</target>
        </trans-unit>
        <trans-unit id="fa762fbbddcd8f0e9e5679cef69f64552f7bd006" translate="yes" xml:space="preserve">
          <source>It's ok. That's all gone now. We've done all the black magic for you. And here are the tricks...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c4906faf9dc43631913b5936b5f4e02175738c" translate="yes" xml:space="preserve">
          <source>It's only intended as a rough tool. You may need to dicker with the files produced.</source>
          <target state="translated">Он предназначен только как грубый инструмент.Возможно,вам понадобится поработать с созданными файлами.</target>
        </trans-unit>
        <trans-unit id="4ad5389b057242e5f2754208243d1e536ed13fdf" translate="yes" xml:space="preserve">
          <source>It's only written as a helper module for both CPAN.pm and CPANPLUS.pm.</source>
          <target state="translated">Он написан только как вспомогательный модуль как для CPAN.pm,так и для CPANPLUS.pm.</target>
        </trans-unit>
        <trans-unit id="ce38cb5abf7b4d320a0e699a61e26594815c5fdf" translate="yes" xml:space="preserve">
          <source>It's perfectly safe to nest SKIP blocks. Each SKIP block must have the label &lt;code&gt;SKIP&lt;/code&gt; , or Test::More can't work its magic.</source>
          <target state="translated">Вставлять блоки SKIP совершенно безопасно. Каждый блок SKIP должен иметь метку &lt;code&gt;SKIP&lt;/code&gt; , иначе Test :: More не сможет творить чудеса.</target>
        </trans-unit>
        <trans-unit id="391da5d64075501c64aecf0b13f021943f8e3a31" translate="yes" xml:space="preserve">
          <source>It's perfectly safe to nest SKIP blocks. Each SKIP block must have the label &lt;code&gt;SKIP&lt;/code&gt;, or Test::More can't work its magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23089c9252263a75014f4ca3ca447b38592d18ae" translate="yes" xml:space="preserve">
          <source>It's possible that not all modules listed below are installed on your system. For example, the GDBM_File module will not be installed if you don't have the gdbm library.</source>
          <target state="translated">Возможно,не все модули,перечисленные ниже,установлены в вашей системе.Например,модуль GDBM_File не будет установлен,если у вас нет библиотеки gdbm.</target>
        </trans-unit>
        <trans-unit id="9d7827a4cab49cd207c98c793d3174f1c8aaeda1" translate="yes" xml:space="preserve">
          <source>It's possible to change the MRO of a given class either by using &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
mro&lt;/code&gt; as shown in the synopsis, or by using the &lt;a href=&quot;#mro%3a%3aset_mro&quot;&gt;mro::set_mro&lt;/a&gt; function below.</source>
          <target state="translated">Можно изменить MRO данного класса либо с помощью &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; mro&lt;/code&gt; как показано в синопсисе, либо с помощью функции &lt;a href=&quot;#mro%3a%3aset_mro&quot;&gt;mro :: set_mro&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="bef95c6240b3ebd6ee3881a4772ff7b1a355b2ea" translate="yes" xml:space="preserve">
          <source>It's possible to change the MRO of a given class either by using &lt;code&gt;use mro&lt;/code&gt; as shown in the synopsis, or by using the &lt;a href=&quot;#mro%3A%3Aset_mro&quot;&gt;&quot;mro::set_mro&quot;&lt;/a&gt; function below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8141ee35a9c20672528ff17c177b18bb4b35dc61" translate="yes" xml:space="preserve">
          <source>It's possible to have a class that does not expose any publicly settable attributes. Not every class has attributes and methods.</source>
          <target state="translated">Возможно наличие класса,который не раскрывает атрибуты,доступные для публичной установки.Не каждый класс имеет атрибуты и методы.</target>
        </trans-unit>
        <trans-unit id="fdf6b6ef2b9e4a59b56ec7ba91fcecae99b94163" translate="yes" xml:space="preserve">
          <source>It's possible to load multiple features together, using a</source>
          <target state="translated">Можно загрузить несколько функций вместе,используя</target>
        </trans-unit>
        <trans-unit id="66c778a3281518c9b26558498194320e4725fef9" translate="yes" xml:space="preserve">
          <source>It's possible to take the previous idea a little further, by using a compile time &lt;code&gt;DEBUG&lt;/code&gt; constant.</source>
          <target state="translated">Можно развить предыдущую идею немного дальше, используя константу &lt;code&gt;DEBUG&lt;/code&gt; времени компиляции .</target>
        </trans-unit>
        <trans-unit id="30a0b506f4d59de09c1852a82f659060edd73925" translate="yes" xml:space="preserve">
          <source>It's possible to use simple addition and subtraction of objects:</source>
          <target state="translated">Можно использовать простое сложение и вычитание объектов:</target>
        </trans-unit>
        <trans-unit id="7c04330ddf6941f6fc338e6607920a6ccb70bb26" translate="yes" xml:space="preserve">
          <source>It's preferable to patch against the latest blead version, since this is where new development occurs for all changes other than critical bug fixes. Critical bug fix patches should be made against the relevant maint branches, or should be submitted with a note indicating all the branches where the fix should be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2798edf93af2bc08dca21c6c73367266b229901" translate="yes" xml:space="preserve">
          <source>It's probably best to copy one of the existing runops functions and change it to suit your needs. Then, in the BOOT section of your XS file, add the line:</source>
          <target state="translated">Наверное,лучше всего скопировать одну из существующих функций runops и изменить ее в соответствии с вашими потребностями.Затем,в разделе BOOT вашего XS-файла добавьте строку:</target>
        </trans-unit>
        <trans-unit id="b340d427890b7b2748a883b3fba121b10e7d2921" translate="yes" xml:space="preserve">
          <source>It's probably best to prototype new functions, not retrofit prototyping into older ones. That's because you must be especially careful about silent impositions of differing list versus scalar contexts. For example, if you decide that a function should take just one parameter, like this:</source>
          <target state="translated">Наверное,лучше прототипировать новые функции,а не переделывать прототипы в старые.Это потому,что вы должны быть особенно осторожны с молчаливыми наложениями различного списка в сравнении со скалярными контекстами.Например,если вы решили,что функция должна принимать только один параметр,как этот:</target>
        </trans-unit>
        <trans-unit id="91ff9edf126b862a4aaa943668bacea81314c045" translate="yes" xml:space="preserve">
          <source>It's probably better to always use commas after constant names in order to force the next error.</source>
          <target state="translated">Наверное,лучше всегда использовать запятые после постоянных имен,чтобы вызвать следующую ошибку.</target>
        </trans-unit>
        <trans-unit id="16dbf025d239b7a2bc2c7033417d6a18d06e2afb" translate="yes" xml:space="preserve">
          <source>It's probably worth mentioning that if you're going to filetest the return values out of a readdir, you'd better prepend the directory in question. Otherwise, because we didn't chdir() there, it would have been testing the wrong file.</source>
          <target state="translated">Наверное,стоит упомянуть,что если вы собираетесь извлечь возвращаемые значения из readdir,вам лучше подготовить соответствующую директорию.Иначе,так как мы не использовали chdir()там,он бы тестировал не тот файл.</target>
        </trans-unit>
        <trans-unit id="e6c512535456a00f2d66365aceea1ac2fa50945d" translate="yes" xml:space="preserve">
          <source>It's quite possible that the target system doesn't have a readily available /tmp, so it's generall safer to do something like this:</source>
          <target state="translated">Вполне возможно,что целевая система не имеет легкодоступного /tmp,так что вообще безопаснее делать что-то подобное:</target>
        </trans-unit>
        <trans-unit id="8748833136242804cdf06e42df13a982b1789766" translate="yes" xml:space="preserve">
          <source>It's recommended that you run &lt;code&gt;use_ok()&lt;/code&gt; inside a BEGIN block so its functions are exported at compile-time and prototypes are properly honored.</source>
          <target state="translated">Рекомендуется запускать &lt;code&gt;use_ok()&lt;/code&gt; внутри блока BEGIN, чтобы его функции экспортировались во время компиляции, а прототипы должным образом учитывались.</target>
        </trans-unit>
        <trans-unit id="fbc60c6d884b88a267926002dcaceb4adc822c67" translate="yes" xml:space="preserve">
          <source>It's safe, however, to P- or p-pack a string literal, because Perl simply allocates an anonymous variable.</source>
          <target state="translated">Однако,P-или p-pack строковый литерал безопасен,потому что Perl просто выделяет анонимную переменную.</target>
        </trans-unit>
        <trans-unit id="18b132707c62c569a28f6b436602a7bfbd864dfd" translate="yes" xml:space="preserve">
          <source>It's still not quite so clear as prose, but it is very useful for describing the meaning of each part of the pattern.</source>
          <target state="translated">Это еще не так понятно,как проза,но очень полезно для описания смысла каждой части узора.</target>
        </trans-unit>
        <trans-unit id="08057143a2d44a0a378f9cd365b42fe324a68a97" translate="yes" xml:space="preserve">
          <source>It's still up to you to seek out the actual changes, and there might not actually be any. Perhaps all of the changes since you last checked cancelled each other out and left the package in the state it was in before.</source>
          <target state="translated">Вы все еще можете искать реальные изменения,а на самом деле их может и не быть.Возможно,все изменения с момента последней проверки аннулировали друг друга и оставили пакет в том состоянии,в котором он был до этого.</target>
        </trans-unit>
        <trans-unit id="6aa1b5e370d6ab122fa013735d3b648f88f35f20" translate="yes" xml:space="preserve">
          <source>It's the double quotes, not the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, doing this. Whenever you interpolate an array in a double quote context, Perl joins the elements with spaces (or whatever is in &lt;code&gt;$&quot;&lt;/code&gt; , which is a space by default):</source>
          <target state="translated">Это делают двойные кавычки, а не &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; . Всякий раз, когда вы интерполируете массив в контексте двойных кавычек, Perl соединяет элементы с помощью пробелов (или того, что находится в &lt;code&gt;$&quot;&lt;/code&gt; , который по умолчанию является пробелом):</target>
        </trans-unit>
        <trans-unit id="7e186193135a9027584138d266cd6dc740e3d523" translate="yes" xml:space="preserve">
          <source>It's the double quotes, not the &lt;code&gt;print&lt;/code&gt;, doing this. Whenever you interpolate an array in a double quote context, Perl joins the elements with spaces (or whatever is in &lt;code&gt;$&quot;&lt;/code&gt;, which is a space by default):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faab5a6ebe5c2e1ecdb8d0e0f9a387f835a3623a" translate="yes" xml:space="preserve">
          <source>It's useful if you want to print out the name of a variable. If you restrict yourself to globs which exist at compile-time then the result ought to be unambiguous, because code like &lt;code&gt;${&quot;^G&quot;} = 1&lt;/code&gt; is compiled as two ops - a constant string and a dereference (rv2gv) - so that the glob is created at runtime.</source>
          <target state="translated">Это полезно, если вы хотите распечатать имя переменной. Если вы ограничиваетесь глобусами, которые существуют во время компиляции, то результат должен быть однозначным, потому что код вроде &lt;code&gt;${&quot;^G&quot;} = 1&lt;/code&gt; компилируется как две операции - постоянная строка и разыменование (rv2gv) - так что глобус создается во время выполнения.</target>
        </trans-unit>
        <trans-unit id="6fb10a58faaab36e9d6bfc07705548b7e33879f9" translate="yes" xml:space="preserve">
          <source>It's very simple to have your tests run under taint mode. Just throw a &lt;code&gt;-T&lt;/code&gt; into the &lt;code&gt;#!&lt;/code&gt; line. &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will read the switches in &lt;code&gt;#!&lt;/code&gt; and use them to run your tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57045aa0891a8e6164538ff7cbd090571f866c1f" translate="yes" xml:space="preserve">
          <source>It's well known that software developers usually fully document the software they write. If, however, the world is in urgent need of your software and there is not enough time to write the full documentation please at least provide a README file containing:</source>
          <target state="translated">Хорошо известно,что разработчики программ обычно полностью документируют программы,которые они пишут.Если,однако,мир срочно нуждается в Вашем программном обеспечении,и нет достаточного времени для написания полной документации,пожалуйста,по крайней мере,предоставьте файл README,содержащий такую документацию:</target>
        </trans-unit>
        <trans-unit id="485b57adcc80650a0f376fe516e0ea35fef68007" translate="yes" xml:space="preserve">
          <source>Italian</source>
          <target state="translated">Italian</target>
        </trans-unit>
        <trans-unit id="4198106b088c5bcb9774e212538d8c15169f58dc" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">Курсивная версия шрифта фиксированной ширины (на самом деле, что-то вроде неправильного названия, поскольку большинство шрифтов фиксированной ширины имеют только наклонную версию, а не курсивную версию). По умолчанию &lt;code&gt;CI&lt;/code&gt; . Имеет значение только для вывода &lt;b&gt;troff&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="583cdcdfd2a75305b35fba58a53f31af16e8fada" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">Курсивная версия шрифта фиксированной ширины (на самом деле, что-то вроде неправильного названия, поскольку большинство шрифтов фиксированной ширины имеют только наклонную версию, а не курсивную версию). По умолчанию &lt;code&gt;CI&lt;/code&gt; . Имеет значение только для вывода troff (1).</target>
        </trans-unit>
        <trans-unit id="a71960565a249a16493cbd47c7e62585cc7cdbc3" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt;. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d619f9e66322d8e23851c7238a0c1bf5b94557" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt;. Only matters for troff(1) output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad79ef0f076d3a686ab9738925f4dd2c7e69d7d1" translate="yes" xml:space="preserve">
          <source>Italy</source>
          <target state="translated">Italy</target>
        </trans-unit>
        <trans-unit id="b15ebe35e9c7b71db4b6f242bc6c861b7b404110" translate="yes" xml:space="preserve">
          <source>Itanium Processor Family (IPF) and HP-UX</source>
          <target state="translated">Семейство процессоров Itanium (IPF)и HP-UX</target>
        </trans-unit>
        <trans-unit id="e54d4abd34db02334ef2ceaf6dadfd1a53f1ce9b" translate="yes" xml:space="preserve">
          <source>Itanium, Itanium 2 &amp;amp; Madison 6</source>
          <target state="translated">Itanium, Itanium 2 и Madison 6</target>
        </trans-unit>
        <trans-unit id="2644b5ac3389091857c1fa06a99019df89bdf067" translate="yes" xml:space="preserve">
          <source>Item called without tag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e359180eb8ab875848335db708d277f8c6f86293" translate="yes" xml:space="preserve">
          <source>Item, over, and back require a little more explanation: &quot;=over&quot; starts a region specifically for the generation of a list using &quot;=item&quot; commands, or for indenting (groups of) normal paragraphs. At the end of your list, use &quot;=back&quot; to end it. The</source>
          <target state="translated">Пункт,конец и обратно требуют немного больше объяснений:&quot;=over&quot; начинает область специально для генерации списка с помощью команд &quot;=item&quot; или для отступов (групп)обычных абзацев.В конце списка используйте &quot;=зад&quot;.</target>
        </trans-unit>
        <trans-unit id="839a5a9f576aa03eb6484f3e36f4922e7b29ec1b" translate="yes" xml:space="preserve">
          <source>Items are popped from the stack by the &lt;code&gt;POPMARK&lt;/code&gt; macro. There is also a macro &lt;code&gt;TOPMARK&lt;/code&gt; that inspects the topmost item without removing it. These macros return I32 index values directly. There is also the &lt;code&gt;dMARK&lt;/code&gt; macro which declares a new SV double-pointer variable, called &lt;code&gt;mark&lt;/code&gt;, which points at the marked stack slot; this is the usual macro that C code will use when operating on lists given on the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042e4f40b0307417307709cb5473dc322f497e53" translate="yes" xml:space="preserve">
          <source>Items are popped from the stack by using the &lt;code&gt;POPs&lt;/code&gt; macro or its typed versions, There is also a macro &lt;code&gt;TOPs&lt;/code&gt; that inspects the topmost item without removing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2734858b1f6df00795c8577aa06b54f6e0816d" translate="yes" xml:space="preserve">
          <source>Items are pushed to the save stack by using the various &lt;code&gt;SAVE...()&lt;/code&gt; macros. Many of these macros take a variable and store both its address and current value on the save stack, ensuring that value gets restored on scope exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0e07dde86207db19bb7bb39fcc8f34c4917c7f" translate="yes" xml:space="preserve">
          <source>Items are pushed to the stack by using the &lt;code&gt;PUSHMARK()&lt;/code&gt; macro. Even though the stack itself stores (value) stack indices as integers, the &lt;code&gt;PUSHMARK&lt;/code&gt; macro should be given a stack pointer directly; it will calculate the index offset by comparing to the &lt;code&gt;PL_stack_sp&lt;/code&gt; variable. Thus almost always the code to perform this is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b956fed2d730024f43d841fa09eee15223cb553e" translate="yes" xml:space="preserve">
          <source>Items are pushed to the stack by using the &lt;code&gt;PUSHs()&lt;/code&gt; macro or its variants described above; &lt;code&gt;XPUSHs()&lt;/code&gt;, &lt;code&gt;mPUSHs()&lt;/code&gt;, &lt;code&gt;mXPUSHs()&lt;/code&gt; and the typed versions. Note carefully that the non-&lt;code&gt;X&lt;/code&gt; versions of these macros do not check the size of the stack and assume it to be big enough. These must be paired with a suitable check of the stack's size, such as the &lt;code&gt;EXTEND&lt;/code&gt; macro to ensure it is large enough. For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca788485b73309b9f1f94d8376ab88aa565b95b" translate="yes" xml:space="preserve">
          <source>Iterate raw input without applying any fixes for quirky input syntax.</source>
          <target state="translated">Итерация исходного ввода без применения каких-либо исправлений для причудливого синтаксиса ввода.</target>
        </trans-unit>
        <trans-unit id="880d0fdfaa731611203ad90b727f9ad0e4c9d1d5" translate="yes" xml:space="preserve">
          <source>Iterate through it, of course.</source>
          <target state="translated">Конечно же,проникать сквозь него.</target>
        </trans-unit>
        <trans-unit id="0c168efad25dad6474931abc9c9d01ef4bb67924" translate="yes" xml:space="preserve">
          <source>Iterate through the process output, of course.</source>
          <target state="translated">Конечно же,пропустите через процесс вывода.</target>
        </trans-unit>
        <trans-unit id="427ce88c1ea69b3f405aa4f0fa73689dcbd052f7" translate="yes" xml:space="preserve">
          <source>Iterates over necessary shared objects, calling &lt;code&gt;xs_make_dlsyms&lt;/code&gt; method for each with appropriate arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269b5437f5a208443de379288c68fd64af0840d2" translate="yes" xml:space="preserve">
          <source>Iterating over the PADNAMELIST iterates over all possible pad items. Pad slots for targets (&lt;code&gt;SVs_PADTMP&lt;/code&gt;) and GVs end up having &amp;amp;PL_padname_undef &quot;names&quot;, while slots for constants have &lt;code&gt;&amp;amp;PL_padname_const&lt;/code&gt; &quot;names&quot; (see &lt;code&gt;&lt;a href=&quot;#pad_alloc&quot;&gt;&quot;pad_alloc&quot;&lt;/a&gt;&lt;/code&gt;). That &lt;code&gt;&amp;amp;PL_padname_undef&lt;/code&gt; and &lt;code&gt;&amp;amp;PL_padname_const&lt;/code&gt; are used is an implementation detail subject to change. To test for them, use &lt;code&gt;!PadnamePV(name)&lt;/code&gt; and &lt;code&gt;PadnamePV(name) &amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92d8ec2d181e1d01333d9fb58638b2b85aed8c4" translate="yes" xml:space="preserve">
          <source>Iterating over the PADNAMELIST iterates over all possible pad items. Pad slots for targets (SVs_PADTMP) and GVs end up having &amp;amp;PL_padname_undef &quot;names&quot;, while slots for constants have &amp;amp;PL_padname_const &quot;names&quot; (see pad_alloc()). That &amp;amp;PL_padname_undef and &amp;amp;PL_padname_const are used is an implementation detail subject to change. To test for them, use &lt;code&gt;!PadnamePV(name)&lt;/code&gt; and &lt;code&gt;PadnamePV(name)
&amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt; , respectively.</source>
          <target state="translated">Обход PADNAMELIST перебирает все возможные элементы пэда. Слоты пэдов для целей (SVs_PADTMP) и GV в конечном итоге имеют &amp;amp; PL_padname_undef &quot;имена&quot;, а слоты для констант имеют &amp;amp; PL_padname_const &quot;имена&quot; (см. Pad_alloc ()). Использование &amp;amp; PL_padname_undef и &amp;amp; PL_padname_const является деталью реализации, которая может быть изменена. Чтобы проверить их, используйте &lt;code&gt;!PadnamePV(name)&lt;/code&gt; и &lt;code&gt;PadnamePV(name) &amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="ca668574626a9549ef81113edbe0269d243a6e70" translate="yes" xml:space="preserve">
          <source>Iterator for array-based TAP sources</source>
          <target state="translated">Итератор для источников TAP на основе массива</target>
        </trans-unit>
        <trans-unit id="e365acec52938bb4821137a9d3698525ef64c0e6" translate="yes" xml:space="preserve">
          <source>Iterator for filehandle-based TAP sources</source>
          <target state="translated">Итератор для TAP-источников на основе файловых рукояток</target>
        </trans-unit>
        <trans-unit id="608949e6615edc46b7788d7e5f71e396c783a95e" translate="yes" xml:space="preserve">
          <source>Iterator for process-based TAP sources</source>
          <target state="translated">Итератор для процессных TAP источников</target>
        </trans-unit>
        <trans-unit id="1fdccc2b2140fc0f61c8fa7efaf9cf9309d438ee" translate="yes" xml:space="preserve">
          <source>IteratorFactory</source>
          <target state="translated">IteratorFactory</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="e11cc17e61cacb91ddb22ab15b88e065056ee12e" translate="yes" xml:space="preserve">
          <source>Ithreads work by cloning the data tree so that no data is shared between different threads. These threads can be used by using the &lt;code&gt;threads&lt;/code&gt; module or by doing fork() on win32 (fake fork() support). When a thread is cloned all Perl data is cloned, however non-Perl data cannot be cloned automatically. Perl after 5.8.0 has support for the &lt;code&gt;CLONE&lt;/code&gt; special subroutine. In &lt;code&gt;CLONE&lt;/code&gt; you can do whatever you need to do, like for example handle the cloning of non-Perl data, if necessary. &lt;code&gt;CLONE&lt;/code&gt; will be called once as a class method for every package that has it defined (or inherits it). It will be called in the context of the new thread, so all modifications are made in the new area. Currently CLONE is called with no parameters other than the invocant package name, but code should not assume that this will remain unchanged, as it is likely that in future extra parameters will be passed in to give more information about the state of cloning.</source>
          <target state="translated">Ithreads работают путем клонирования дерева данных, так что никакие данные не разделяются между разными потоками. Эти потоки можно использовать с помощью модуля &lt;code&gt;threads&lt;/code&gt; или выполнения fork () в win32 (поддержка поддельной fork ()). Когда поток клонируется, все данные Perl клонируются, однако данные, не относящиеся к Perl, не могут быть клонированы автоматически. Perl после версии 5.8.0 поддерживает специальную подпрограмму &lt;code&gt;CLONE&lt;/code&gt; . В &lt;code&gt;CLONE&lt;/code&gt; вы можете делать все, что вам нужно, например, при необходимости обрабатывать клонирование данных, отличных от Perl. &lt;code&gt;CLONE&lt;/code&gt; будет вызываться один раз как метод класса для каждого пакета, в котором он определен (или наследует его). Он будет вызываться в контексте нового потока, поэтому все изменения производятся в новой области. В настоящее время CLONE вызывается без каких-либо параметров, кроме имени вызывающего пакета, но код не должен предполагать, что это останется неизменным, поскольку вполне вероятно, что в будущем будут переданы дополнительные параметры, чтобы предоставить дополнительную информацию о состоянии клонирования.</target>
        </trans-unit>
        <trans-unit id="1fc560e7e4efb5d974d128bd00c3dd33446589b6" translate="yes" xml:space="preserve">
          <source>Its &lt;code&gt;pprivate&lt;/code&gt; and &lt;code&gt;intflags&lt;/code&gt; fields contain data specific to each engine.</source>
          <target state="translated">Его &lt;code&gt;pprivate&lt;/code&gt; и &lt;code&gt;intflags&lt;/code&gt; содержат данные, специфичные для каждого движка.</target>
        </trans-unit>
        <trans-unit id="16c6982b7d6141952759d09a7076ec5f4dab57ab" translate="yes" xml:space="preserve">
          <source>Its address can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed. Make sure that you don't try to compare a random sv with &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; . For example when interfacing Perl code, it'll work correctly for:</source>
          <target state="translated">Его адрес можно использовать всякий раз, когда требуется &lt;code&gt;SV*&lt;/code&gt; . Убедитесь, что вы не пытаетесь сравнить случайный sv с &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; . Например, при взаимодействии кода Perl он будет правильно работать для:</target>
        </trans-unit>
        <trans-unit id="09d223f73a742d40d37e0069338730ea57d94138" translate="yes" xml:space="preserve">
          <source>Its address can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed. Make sure that you don't try to compare a random sv with &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt;. For example when interfacing Perl code, it'll work correctly for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0881b1abd4c8c0f2683196629616b2be066ab1e5" translate="yes" xml:space="preserve">
          <source>Its advantage over &lt;code&gt;ok()&lt;/code&gt; is when the test fails you'll know what $got and $expected were:</source>
          <target state="translated">Его преимущество перед &lt;code&gt;ok()&lt;/code&gt; том, что если тест не пройден, вы узнаете, какие $ got и $ ожидали:</target>
        </trans-unit>
        <trans-unit id="004b859afb711a2b891500dcf0aac6a8c2d2a9a8" translate="yes" xml:space="preserve">
          <source>Its advantages over &lt;code&gt;ok()&lt;/code&gt; are similar to that of &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; . Better diagnostics on failure.</source>
          <target state="translated">Его преимущества перед &lt;code&gt;ok()&lt;/code&gt; аналогичны преимуществам &lt;code&gt;is()&lt;/code&gt; и &lt;code&gt;isnt()&lt;/code&gt; . Лучшая диагностика отказа.</target>
        </trans-unit>
        <trans-unit id="0c8e5bbdfc16ed39f18dc0db649a1798bde0ff44" translate="yes" xml:space="preserve">
          <source>Its advantages over &lt;code&gt;ok()&lt;/code&gt; are similar to that of &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt;. Better diagnostics on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47f30ae9fc0af2d5174d1161686c5cb48a52d13" translate="yes" xml:space="preserve">
          <source>Its behaviour is identical to using an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; type in XS with T_IV.</source>
          <target state="translated">Его поведение идентично использованию типа &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; в XS с T_IV.</target>
        </trans-unit>
        <trans-unit id="78ff78bdd00c6e2cf21af3315183fda1a7d0aefd" translate="yes" xml:space="preserve">
          <source>Its behaviour is identical to using an &lt;code&gt;int&lt;/code&gt; type in XS with T_IV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae697da5b215cc5fb762242f2f9d970cf1a4185" translate="yes" xml:space="preserve">
          <source>Its currently very simple and may be expanded sometime in the figure to include more flexible code and switches.</source>
          <target state="translated">В настоящее время он очень прост и может быть расширен когда-нибудь на рисунке для включения более гибкого кода и переключателей.</target>
        </trans-unit>
        <trans-unit id="270729f2364ce03a3daacf9b717d32c8a85378b7" translate="yes" xml:space="preserve">
          <source>Its format is not guaranteed not to change over time.</source>
          <target state="translated">Его формат не гарантированно не изменится со временем.</target>
        </trans-unit>
        <trans-unit id="ab2643af88a544c3d8cf389888d3e8add44c6b63" translate="yes" xml:space="preserve">
          <source>Its name comes from the observation that this operation combined with the alternation operator (&lt;code&gt;&quot;|&quot;&lt;/code&gt;) can be used to create what is essentially a pattern-based if/then/else block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41db9b49c066a3eed741a13ffe63dcafc0bc1631" translate="yes" xml:space="preserve">
          <source>Its name comes from the observation that this operation combined with the alternation operator (&lt;code&gt;|&lt;/code&gt;) can be used to create what is essentially a pattern-based if/then/else block:</source>
          <target state="translated">Его название происходит от наблюдения, что эта операция в сочетании с оператором чередования ( &lt;code&gt;|&lt;/code&gt; ) может использоваться для создания того, что по сути является основанным на шаблоне блоком if / then / else:</target>
        </trans-unit>
        <trans-unit id="857df5ce623d367dca94803887ed2679c126a932" translate="yes" xml:space="preserve">
          <source>Its purpose was to allow your non-ASCII Perl scripts not to have to be written in UTF-8; this was useful before editors that worked on UTF-8 encoded text were common, but that was long ago. It caused problems, such as affecting the operation of other modules that weren't expecting it, causing general mayhem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f8c93b7e3928b82285ec3cb4baed8ba27c22ab" translate="yes" xml:space="preserve">
          <source>Its return buffer is per-thread, so it also is never overwritten by a call to this function from another thread; unlike the function it replaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a5e19377208f27c49b06cb17d4ed4cd4b998dc" translate="yes" xml:space="preserve">
          <source>Its use of \x1b (escape) is also very questionable.</source>
          <target state="translated">Его использование \x1b (побег)также очень сомнительно.</target>
        </trans-unit>
        <trans-unit id="439b82c22fda8042c3800152aa28934c765e39cf" translate="yes" xml:space="preserve">
          <source>Its value grows rapidly, even for small inputs. For example, A(4, 2) is an integer of 19729 decimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1782b37a47b28cba886190c0e7c9425d4b8409e" translate="yes" xml:space="preserve">
          <source>Its wrapping is done by &lt;a href=&quot;../../text/wrap&quot;&gt;Text::Wrap&lt;/a&gt;, so you can change &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; as you like.</source>
          <target state="translated">Его упаковка выполняется &lt;a href=&quot;../../text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt; , поэтому вы можете изменять &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8279d860cdcd8af715030eac4d6150f64676e6fe" translate="yes" xml:space="preserve">
          <source>Its wrapping is done by &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt;, so you can change &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; as you like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="d4ca6fbb7f638a8b6b39592979f862bfb9bd67d1" translate="yes" xml:space="preserve">
          <source>J. Nick Koston &amp;lt;nick@cpanel.net&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0769e7614be3e4e1822db4f1f3c8b1ae2f3201ca" translate="yes" xml:space="preserve">
          <source>JAPH</source>
          <target state="translated">JAPH</target>
        </trans-unit>
        <trans-unit id="d7060e173c0374cb8eae482e18306d094b4a274a" translate="yes" xml:space="preserve">
          <source>JAPH stands for &quot;Just another Perl hacker,&quot;, which Randal Schwartz used to sign email and usenet messages starting in the late 1980s. He previously used the phrase with many subjects (&quot;Just another x hacker,&quot;), so to distinguish his JAPH, he started to write them as Perl programs:</source>
          <target state="translated">JAPH расшифровывается как &quot;Просто еще один хакер Perl&quot;,который Рандал Шварц использовал для подписывания сообщений электронной почты и использования,начиная с конца 1980-х годов.Ранее он использовал эту фразу со многими темами (&quot;Просто еще один хакер x&quot;),поэтому,чтобы отличить свой JAPH,он начал писать их как программы на Perl:</target>
        </trans-unit>
        <trans-unit id="7f3a84b51622bff154d5971f3af29fa8785e389f" translate="yes" xml:space="preserve">
          <source>JIS has not endorsed the full Microsoft standard however. The official &lt;code&gt;Shift_JIS&lt;/code&gt; includes only JIS X 0201 and JIS X 0208 character sets, while Microsoft has always used &lt;code&gt;Shift_JIS&lt;/code&gt; to encode a wider character repertoire. See &lt;code&gt;IANA&lt;/code&gt; registration for &lt;code&gt;Windows-31J&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="ab81c25e1d8756ce41a1d0bd153f8a1a9cd26516" translate="yes" xml:space="preserve">
          <source>JSON -&amp;gt; PERL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="085bf9967f7db3a1e36f211bc12e97fc9c8726e2" translate="yes" xml:space="preserve">
          <source>JSON object. If that is successful, it will return this object, otherwise it will return &lt;code&gt;undef&lt;/code&gt;. If there is a parse error, this method will croak just as &lt;code&gt;decode&lt;/code&gt; would do (one can then use &lt;code&gt;incr_skip&lt;/code&gt; to skip the erroneous part). This is the most common way of using the method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca97a1ee6b474fcf8884b628a790828e390c7d4" translate="yes" xml:space="preserve">
          <source>JSON, &lt;a href=&quot;http://json.org/&quot;&gt;http://json.org/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c9214a804f5e0bb364aa23a074ce1bb72d3b90" translate="yes" xml:space="preserve">
          <source>JSON::PP</source>
          <target state="translated">JSON::PP</target>
        </trans-unit>
        <trans-unit id="bc2d16fc45f4fb15b4bd4ac1aaf8b68aeeba40dd" translate="yes" xml:space="preserve">
          <source>JSON::PP (and JSON::XS) trusts what you pass to &lt;code&gt;encode&lt;/code&gt; method (or &lt;code&gt;encode_json&lt;/code&gt; function) is a clean, validated data structure with values that can be represented as valid JSON values only, because it's not from an external data source (as opposed to JSON texts you pass to &lt;code&gt;decode&lt;/code&gt; or &lt;code&gt;decode_json&lt;/code&gt;, which JSON::PP considers tainted and doesn't trust). As JSON::PP doesn't know exactly what you and consumers of your JSON texts want the unexpected values to be (you may want to convert them into null, or to stringify them with or without normalisation (string representation of infinities/NaN may vary depending on platforms), or to croak without conversion), you're advised to do what you and your consumers need before you encode, and also not to numify values that may start with values that look like a number (including infinities/NaN), without validating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67000e5008a49c5764c9853d27cf57eee1416888" translate="yes" xml:space="preserve">
          <source>JSON::PP - JSON::XS compatible pure-Perl module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6a29e642ee039fc28b8f131cabd5029d088849" translate="yes" xml:space="preserve">
          <source>JSON::PP has been in the Perl core since Perl 5.14, mainly for CPAN toolchain modules to parse META.json.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aaa45ea1b22edf7987707428a94f3b9ee14d933" translate="yes" xml:space="preserve">
          <source>JSON::PP is a pure perl JSON decoder/encoder, and (almost) compatible to much faster &lt;a href=&quot;JSON::XS&quot;&gt;JSON::XS&lt;/a&gt; written by Marc Lehmann in C. JSON::PP works as a fallback module when you use &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; module without having installed JSON::XS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1d3eff2890dd7bf9ac851e6d34ec3c432fa2a0" translate="yes" xml:space="preserve">
          <source>JSON::PP will only attempt to parse the JSON text once it is sure it has enough text to get a decisive result, using a very simple but truly incremental parser. This means that it sometimes won't stop as early as the full parser, for example, it doesn't detect mismatched parentheses. The only thing it guarantees is that it starts decoding as soon as a syntactically valid JSON text has been seen. This means you need to set resource limits (e.g. &lt;code&gt;max_size&lt;/code&gt;) to ensure the parser will stop parsing in the presence if syntax errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4762c702bf2677205442e48ee83f7fae4356feaa" translate="yes" xml:space="preserve">
          <source>JSON::PP::Boolean</source>
          <target state="translated">JSON::PP::Boolean</target>
        </trans-unit>
        <trans-unit id="65c4433f9da239d7a8e60b68a81d180683b869c9" translate="yes" xml:space="preserve">
          <source>JSON::PP::Boolean - dummy module providing JSON::PP::Boolean</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a48e124df6419ac5c2d9d111fda43bf7f4a2ad" translate="yes" xml:space="preserve">
          <source>JSON::PP::is_bool</source>
          <target state="translated">JSON::PP::is_bool</target>
        </trans-unit>
        <trans-unit id="3dbefab7107beb14a9168d002d27c476d9979a2f" translate="yes" xml:space="preserve">
          <source>JSON::PP::null</source>
          <target state="translated">JSON::PP::null</target>
        </trans-unit>
        <trans-unit id="d245a16cb70b0da2f6ce2e1cc1b15f6f0108705d" translate="yes" xml:space="preserve">
          <source>JSON::PP::true, JSON::PP::false</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dced2aceecfe6edc6c5082affb4adef03ec116d9" translate="yes" xml:space="preserve">
          <source>JSON::XS compatible pure-Perl module.</source>
          <target state="translated">JSON::XS совместимый модуль pure-Perl.</target>
        </trans-unit>
        <trans-unit id="67cff807001c7900c13019d99056e3c2c5564617" translate="yes" xml:space="preserve">
          <source>JSON::XS indents with three spaces when you &lt;code&gt;encode&lt;/code&gt; (if requested by &lt;code&gt;indent&lt;/code&gt; or &lt;code&gt;pretty&lt;/code&gt;), and the number cannot be changed. JSON::PP allows you to change/get the number of indent spaces with these mutator/accessor. The default number of spaces is three (the same as JSON::XS), and the acceptable range is from &lt;code&gt;0&lt;/code&gt; (no indentation; it'd be better to disable indentation by &lt;code&gt;indent(0)&lt;/code&gt;) to &lt;code&gt;15&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0eeebe1b8d9c88c3dd6a874baff7c46254de947" translate="yes" xml:space="preserve">
          <source>Jacinta Richardson for translating much of my ideas into this documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ed50c6d4c26a90edb32bb01d8d5b13b356d708" translate="yes" xml:space="preserve">
          <source>James E Keenan &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc167be5863c0fa54ff8e14b6cf90200815632fb" translate="yes" xml:space="preserve">
          <source>James E. Keenan</source>
          <target state="translated">Джеймс И.Кинан</target>
        </trans-unit>
        <trans-unit id="fad8357eef2bb53d17336573edc650a4cf157cf3" translate="yes" xml:space="preserve">
          <source>James E. Keenan &amp;lt;jkeen@verizon.net&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cf1bbb2770fa0d885d542ddaca96bfea96011e" translate="yes" xml:space="preserve">
          <source>James Keenan, &amp;lt;jkeenan@cpan.org&amp;gt;</source>
          <target state="translated">Джеймс Кинан, &amp;lt;jkeenan@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2c916c2a6f4627fbe67be340b96ec2857597184a" translate="yes" xml:space="preserve">
          <source>James Raspass &amp;lt;jraspass@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e4cd2d086a80816fd0c59891fecee24ad1a4c4" translate="yes" xml:space="preserve">
          <source>Jamo_Short_Name</source>
          <target state="translated">Jamo_Short_Name</target>
        </trans-unit>
        <trans-unit id="dc05d77338b63072590a6f49b15e48ec83a7bd95" translate="yes" xml:space="preserve">
          <source>Jan Dubois &amp;lt;jand@activestate.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf29f6cad3232704b33e962ef5194fad3b6817b" translate="yes" xml:space="preserve">
          <source>Japan</source>
          <target state="translated">Japan</target>
        </trans-unit>
        <trans-unit id="6ce48d285e726d9be92e6bf68e171d9553e0896e" translate="yes" xml:space="preserve">
          <source>Japanese Encodings</source>
          <target state="translated">Японские кодировки</target>
        </trans-unit>
        <trans-unit id="f0fae5d9347791c2b844b690a046bfe7552e453c" translate="yes" xml:space="preserve">
          <source>Japheth Cleaver added the bits to allow a forced install (-f).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6422bf1002562f4885ccb3e7c11949b9fc2f34" translate="yes" xml:space="preserve">
          <source>Japheth Cleaver added the bits to allow a forced install (&lt;code&gt;-f&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7b561acfebbb2aad1864ab89f7d4e5285c6e22" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi</source>
          <target state="translated">Джаркко Хиетаниеми</target>
        </trans-unit>
        <trans-unit id="a9a4e186a4a793bc3fef06e8162fa8ae0f705095" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">Яркко Хиетаниеми &amp;lt;</target>
        </trans-unit>
        <trans-unit id="13ce73395e162a5533c6ace927e40c80d2cab8fd" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;</source>
          <target state="translated">Яркко Хиетаниеми &amp;lt;jhi@iki.fi&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7adef0fede1e52584837e3b9fe09cbb854d77894" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt; Bryan Logan &amp;lt;bryanlog@us.ibm.com&amp;gt; David Larson &amp;lt;larson1@us.ibm.com&amp;gt;</source>
          <target state="translated">Джаркко Хиетаниеми &amp;lt;jhi@iki.fi&amp;gt; Брайан Логан &amp;lt;bryanlog@us.ibm.com&amp;gt; Дэвид Ларсон &amp;lt;larson1@us.ibm.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="276f92ff10492dd51e70f45871039bf3b88b6a4b" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi's original</source>
          <target state="translated">Оригинал Джаркко Хиетаниеми</target>
        </trans-unit>
        <trans-unit id="04cfea13773f0ae1b7ac40ccd517f43dc7dcdad4" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, &amp;lt;jhi@hut.fi&amp;gt;</source>
          <target state="translated">Яркко Хиетаниеми, &amp;lt;jhi@hut.fi&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c6f1f3b8aba1c1fb078ca69f70f0d3a32db2b05e" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, &amp;lt;jhi@hut.fi&amp;gt;. Now maintained by Perl 5 porters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc2a5e3ff31736b8a57665e048886c573a122f3" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, conversion into libnetcfg for inclusion into Perl 5.8.</source>
          <target state="translated">Jarkko Hietaniemi,преобразование в libnetcfg для включения в Perl 5.8.</target>
        </trans-unit>
        <trans-unit id="692b885ac0ff146816113cee07c7dfe2ef0ba0a4" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi. Now maintained by perl5 porters.</source>
          <target state="translated">Джаркко Хиетаниеми.Теперь обслуживается perl5 носильщиками.</target>
        </trans-unit>
        <trans-unit id="f0bc884e41c8e0399ef072f3aad2d67eaa7fd5aa" translate="yes" xml:space="preserve">
          <source>JavaScript Traps</source>
          <target state="translated">JavaScript-ловушки</target>
        </trans-unit>
        <trans-unit id="f2ef0f46c9cd103d2be6f2673d4379b347904df1" translate="yes" xml:space="preserve">
          <source>Jean Delvare provided the following table of different common terminal emulators and their support for the various attributes and others have helped me flesh it out:</source>
          <target state="translated">Жан Дельвар предоставил следующую таблицу различных общих терминальных эмуляторов,и их поддержка различных атрибутов и других помогла мне наполнить ее содержанием:</target>
        </trans-unit>
        <trans-unit id="27f5b59f8afefe05a200ff5c9949b24e5ca9ea36" translate="yes" xml:space="preserve">
          <source>Jed</source>
          <target state="translated">Jed</target>
        </trans-unit>
        <trans-unit id="b63c65e75871d5c7820e4ea10cfd70f390f74d22" translate="yes" xml:space="preserve">
          <source>Jeff Okamoto &amp;lt;</source>
          <target state="translated">Джефф Окамото &amp;lt;</target>
        </trans-unit>
        <trans-unit id="7ec7c5d4610b8dd06ad086eed7d40f5d2aaef1a6" translate="yes" xml:space="preserve">
          <source>Jeff Okamoto, Tim Bunce, Nick Gianniotis, Steve Kelem, Gurusamy Sarathy and Larry Wall.</source>
          <target state="translated">Джефф Окамото,Тим Банс,Ник Джанниотис,Стив Келем,Гурусами Сарати и Ларри Уолл.</target>
        </trans-unit>
        <trans-unit id="2425ad3a84d8960ab9c2915a943fd7e28d7c0291" translate="yes" xml:space="preserve">
          <source>Jeremy Mates &amp;lt;jmates@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52232653f25fa8c0538602bfc7945ebf9d9b79a7" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden &amp;lt;jdhedden@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a656e0d05c4ded5764e8eee0b16063f85446f7" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden and Reini Urban provided greatly appreciated help to debug and polish &lt;code&gt;Sys::Syslog&lt;/code&gt; under Cygwin.</source>
          <target state="translated">Джерри Д. Хедден и Рейни Урбан оказали ценную помощь по отладке и полировке &lt;code&gt;Sys::Syslog&lt;/code&gt; под Cygwin.</target>
        </trans-unit>
        <trans-unit id="1a3cecc43a5465fa758b4f88b43cd646e6623b8f" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden, &amp;lt;jdhedden AT cpan DOT org&amp;gt;</source>
          <target state="translated">Джерри Д. Хедден, &amp;lt;jdhedden AT cpan DOT org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e5109d5f0b8672892d9cf43511b2568ff7ce2637" translate="yes" xml:space="preserve">
          <source>Jerry Gay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7ad312b85f19c8a09454b49798a0382227aa86" translate="yes" xml:space="preserve">
          <source>Jess Robinson &amp;lt;castaway@desert-island.me.uk&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f1b3fc35d7e705b8692294a866fb025bdc15b4" translate="yes" xml:space="preserve">
          <source>Jim Brandt suggest and provided the initial implementation for the up-to-date and Changes features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549b2243ef15345835dfd4eb22ac64d2df0ea3a8" translate="yes" xml:space="preserve">
          <source>Jim Keenan fixed up various issues with _download</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef645dbc725c293373ed9661992798b416e9b9b4" translate="yes" xml:space="preserve">
          <source>Joe Smith &amp;lt;Joe.Smith@inwap.com&amp;gt;, using the framework created by Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</source>
          <target state="translated">Джо Смит &amp;lt;Joe.Smith@inwap.com&amp;gt;, используя структуру, созданную Рассом Олбери &amp;lt;rra@stanford.edu&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="c865a479b23a538482933eec4ec96a06755b572a" translate="yes" xml:space="preserve">
          <source>Johan Vromans &amp;lt;jvromans@squirrel.nl&amp;gt;</source>
          <target state="translated">Йохан Вроманс &amp;lt;jvromans@squirrel.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="183447aad929b68cdb9a4bc6a0988222e172d912" translate="yes" xml:space="preserve">
          <source>Johan Vromans &amp;lt;jvromans@squirrel.nl&amp;gt; H. Merijn Brand &amp;lt;h.m.brand@xs4all.nl&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d401e67bf973d127449e78a2dab7a6e33bf82ed1" translate="yes" xml:space="preserve">
          <source>John Lightsey &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93554073e2a9ef40605d8eff344dac817dfa1a9" translate="yes" xml:space="preserve">
          <source>John Peacock &amp;lt;jpeacock@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdfcbe7345fa5c91aff66147710f3cfd01971e09" translate="yes" xml:space="preserve">
          <source>Joins the separate strings of LIST into a single string with fields separated by the value of EXPR, and returns that new string. Example:</source>
          <target state="translated">Соединяет отдельные строки СПИСКА в единую строку с полями,разделенными значением EXPR,и возвращает эту новую строку.Пример:</target>
        </trans-unit>
        <trans-unit id="8701a18a17d809f2f5e1d9461286d81392c749a1" translate="yes" xml:space="preserve">
          <source>Jon Orwant</source>
          <target state="translated">Джон Оруант</target>
        </trans-unit>
        <trans-unit id="9535723b8f84ea59122230a47649084f0880997b" translate="yes" xml:space="preserve">
          <source>Jon Orwant &amp;lt;</source>
          <target state="translated">Джон Орвант &amp;lt;</target>
        </trans-unit>
        <trans-unit id="e683318ce5a68c3c49c2481778c7d3eb5187cf39" translate="yes" xml:space="preserve">
          <source>Jonas B. Nielsen &amp;lt;jonasbn@hoarfrost.local&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b947fc83a952d44b7572b1e1134cb1af54db24" translate="yes" xml:space="preserve">
          <source>Josh Jore &amp;lt;jjore@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc19f76e720fe5e2b005501ad08de9eb7175b61" translate="yes" xml:space="preserve">
          <source>Joshua Chamas's Tie::Cache module may be useful as an expiration manager. (If you try this, let me know how it works out.)</source>
          <target state="translated">Модуль Tie::Cache Джошуа Чамаса может быть полезен в качестве менеджера по истечению срока действия.(Если вы попробуете,дайте мне знать,как это работает).</target>
        </trans-unit>
        <trans-unit id="272f944afb073e466e447521f217853887659759" translate="yes" xml:space="preserve">
          <source>Joshua ben Jore &amp;lt;jjore@cpan.org&amp;gt;</source>
          <target state="translated">Джошуа бен Джор &amp;lt;jjore@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f8f06875505d336c6444e4ca735af60cc7f95b69" translate="yes" xml:space="preserve">
          <source>Judicious JavaScript programmers should take note of the following:</source>
          <target state="translated">Внимательным JavaScript-программистам следует обратить внимание на следующее:</target>
        </trans-unit>
        <trans-unit id="829558e61eb4ee30d56d5ca3997b5726751317c0" translate="yes" xml:space="preserve">
          <source>Juerd Waalboer &amp;lt;#####@juerd.nl&amp;gt;</source>
          <target state="translated">Джурд Ваалбоер &amp;lt;##### @ juerd.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d89d24d0ba5d206a7a244711764b4287f3aa5c8f" translate="yes" xml:space="preserve">
          <source>Juerd Waalboer &amp;lt;#####@juerd.nl&amp;gt;, with the help of many Perl Monks.</source>
          <target state="translated">Juerd Waalboer &amp;lt;##### @ juerd.nl&amp;gt; с помощью многих монахов Perl.</target>
        </trans-unit>
        <trans-unit id="bd209361669e6039e2d46925b98964270ec9db84" translate="yes" xml:space="preserve">
          <source>July 26, 2005</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b31aa739648b445f7448224142630d141a4270e" translate="yes" xml:space="preserve">
          <source>June 12, 2007</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a23786af78acf626cd4573fa13a06ed0180b91" translate="yes" xml:space="preserve">
          <source>June 2008</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d4e067e5679c035c82b3463849e985c82217de" translate="yes" xml:space="preserve">
          <source>June 2017, for Synology DSM 5.1.5022 and DSM 6.1-15101-4.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
