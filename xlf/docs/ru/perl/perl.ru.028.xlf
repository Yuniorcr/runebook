<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="700d8f92e3038752feec96509274cbd7256d79dc" translate="yes" xml:space="preserve">
          <source>If you can't configure &lt;code&gt;TAP::Harness&lt;/code&gt; to do what you want, and you can't find an existing plugin, consider writing one.</source>
          <target state="translated">Если вы не можете настроить &lt;code&gt;TAP::Harness&lt;/code&gt; для выполнения того, что хотите, и не можете найти существующий плагин, подумайте о его написании.</target>
        </trans-unit>
        <trans-unit id="edcd365c3753fb0814dbbf4b5f1da5978fabe2e0" translate="yes" xml:space="preserve">
          <source>If you can't use &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt;, you'll have to do the work yourself: open the original file, open the destination file, then print to the destination file as you read the original. You also have to remember to copy the permissions, owner, and group to the new file.</source>
          <target state="translated">Если вы не можете использовать &lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt; , вам придется выполнить эту работу самостоятельно: открыть исходный файл, открыть целевой файл, а затем распечатать в целевой файл, когда вы читаете оригинал. Вы также должны не забыть скопировать разрешения, владельца и группу в новый файл.</target>
        </trans-unit>
        <trans-unit id="2431416836e7be159e91db05fdcbf62b13f365c1" translate="yes" xml:space="preserve">
          <source>If you cannot achieve the desired Makefile behaviour by specifying attributes you may define private subroutines in the Makefile.PL. Each subroutine returns the text it wishes to have written to the Makefile. To override a section of the Makefile you can either say:</source>
          <target state="translated">Если вы не можете добиться желаемого поведения Makefile путем указания атрибутов,вы можете определить приватные подпрограммы в Makefile.PL.Каждая подпрограмма возвращает Makefile текст,который она хочет написать.Чтобы переопределить раздел Makefile,вы можете сказать то же самое:</target>
        </trans-unit>
        <trans-unit id="069db45c3cccee54b16dacbbc26ce2a59fc37a49" translate="yes" xml:space="preserve">
          <source>If you cannot upgrade your Perl to 5.8.0 or later, you can still do some Unicode processing by using the modules &lt;code&gt;Unicode::String&lt;/code&gt; , &lt;code&gt;Unicode::Map8&lt;/code&gt; , and &lt;code&gt;Unicode::Map&lt;/code&gt; , available from CPAN. If you have the GNU recode installed, you can also use the Perl front-end &lt;code&gt;Convert::Recode&lt;/code&gt; for character conversions.</source>
          <target state="translated">Если вы не можете обновить Perl до версии 5.8.0 или более поздней, вы все равно можете выполнить некоторую обработку Unicode с помощью модулей &lt;code&gt;Unicode::String&lt;/code&gt; , &lt;code&gt;Unicode::Map8&lt;/code&gt; и &lt;code&gt;Unicode::Map&lt;/code&gt; , доступных на CPAN. Если у вас установлен GNU recode, вы также можете использовать Perl-интерфейс &lt;code&gt;Convert::Recode&lt;/code&gt; для преобразования символов.</target>
        </trans-unit>
        <trans-unit id="7f06f83624114fcf502e132fac57a686e4d7a4ee" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt;, you can make your own loop to do the same thing. Once you find the element, you stop the loop with last.</source>
          <target state="translated">Если вы не можете использовать &lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt; , вы можете создать свой собственный цикл, чтобы сделать то же самое. Как только вы найдете элемент, вы остановите цикл с помощью last.</target>
        </trans-unit>
        <trans-unit id="83e89259781d3b7bf972995b7c8dc74ef7aacff4" translate="yes" xml:space="preserve">
          <source>If you cannot use the git protocol for firewall reasons, you can also clone via http, though this is much slower:</source>
          <target state="translated">Если вы не можете использовать git-протокол по причинам брандмауэра,вы также можете клонировать через http,хотя это гораздо медленнее:</target>
        </trans-unit>
        <trans-unit id="794395d65809aff375720f1da63fe61351840429" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;$pattern&lt;/code&gt; after the first substitution happens, Perl will ignore it. If you don't want any substitutions at all, use the special delimiter &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Если вы измените &lt;code&gt;$pattern&lt;/code&gt; после первой замены, Perl проигнорирует это. Если вам совсем не нужны замены, используйте специальный разделитель &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bca560012b71cc8dce8e6a03ec54196daca3d350" translate="yes" xml:space="preserve">
          <source>If you check &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;, you'll see that several of the ways to call open() should do the trick. For example:</source>
          <target state="translated">Если вы отметите &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; , вы увидите, что несколько способов вызвать open () должны помочь. Например:</target>
        </trans-unit>
        <trans-unit id="e4dedfaceb9670f08b0798c739b80203032d536c" translate="yes" xml:space="preserve">
          <source>If you chomp a list, each element is chomped, and the total number of characters removed is returned.</source>
          <target state="translated">Если вы расплющиваете список,то каждый элемент расплющивается,и возвращается общее количество удаленных символов.</target>
        </trans-unit>
        <trans-unit id="716512a060dd3d5999bac2b4045e2b9123dc9b1b" translate="yes" xml:space="preserve">
          <source>If you choose XL C/C++ V11 you need the April 2010 PTF (or newer) installed otherwise you will not get a working Perl version.</source>
          <target state="translated">Если вы выберете XL C/C++V11,то вам необходимо установить PTF апреля 2010 (или более новую),иначе вы не получите рабочую Perl версию.</target>
        </trans-unit>
        <trans-unit id="c10052f207d29ada4465d2d73fcdfabf3621a0b6" translate="yes" xml:space="preserve">
          <source>If you choose XL C/C++ V9 you need APAR IZ35785 installed otherwise the integrated SDBM_File do not compile correctly due to an optimization bug. You can circumvent this problem by adding -qipa to the optimization flags (-Doptimize='-O -qipa'). The PTF for APAR IZ35785 which solves this problem is available from IBM (April 2009 PTF for XL C/C++ Enterprise Edition for AIX, V9.0).</source>
          <target state="translated">Если вы выберете XL C/C++V9,вам необходимо установить APAR IZ35785,иначе встроенный SDBM_File не скомпилируется корректно из-за ошибки оптимизации.Вы можете обойти эту проблему,добавив -qipa к флагам оптимизации (-Doptimize='-O -qipa').PTF для APAR IZ35785,который решает эту проблему,доступен в IBM (апрель 2009 PTF для XL C/C++Enterprise Edition для AIX,V9.0).</target>
        </trans-unit>
        <trans-unit id="fb54bcde599a5f03b31c1ac1b1fac745b31dc5b8" translate="yes" xml:space="preserve">
          <source>If you choose for the PTH package, use swinstall to install pth in the default location (/opt/pth), and then make symbolic links to the libraries from /usr/lib</source>
          <target state="translated">Если вы выберете пакет PTH,используйте swinstall,чтобы установить pth в месте по умолчанию (/opt/pth),а затем сделайте символические ссылки на библиотеки из /usr/lib.</target>
        </trans-unit>
        <trans-unit id="5ca7b309ef65dd317303754f8c4a5fd3689e4197" translate="yes" xml:space="preserve">
          <source>If you choose gcc to compile 64-bit Perl then you need to add the following option:</source>
          <target state="translated">Если вы выберете gcc для компиляции 64-битного Perl,то необходимо добавить следующую опцию:</target>
        </trans-unit>
        <trans-unit id="875c1fe2de9773e7e9366d0703f2a602deb9c197" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если вы разрежете список, каждый элемент будет разрезан. Возвращается только значение последнего &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03160d33f05c1b78628995f8692e16c5933ebe05" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если вы разрежете список, каждый элемент будет разрезан. Возвращается только значение последнего &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="caf1e734b10683713e7d496bb52630f5b34525d0" translate="yes" xml:space="preserve">
          <source>If you compile and run</source>
          <target state="translated">Если вы скомпилируете и запустите</target>
        </trans-unit>
        <trans-unit id="4359b9f0177138527f6b61e374c639bb3caf7642" translate="yes" xml:space="preserve">
          <source>If you completely hide the short forms of the Perl public API, add -DPERL_NO_SHORT_NAMES to the compilation flags. This means that for example instead of writing</source>
          <target state="translated">Если вы полностью скрываете короткие формы публичного Perl API,добавьте -DPERL_NO_SHORT_NAMES к флагам компиляции.Это означает,что,например,вместо того,чтобы писать</target>
        </trans-unit>
        <trans-unit id="7e117fe20aeb505e6fb3bd26d20ee9983d45c623" translate="yes" xml:space="preserve">
          <source>If you consult &lt;code&gt;perldoc -f &lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you will see that &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; will behave differently when given a bareword or a string.</source>
          <target state="translated">Если вы проконсультируетесь с &lt;code&gt;perldoc -f &lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , вы увидите, что &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; будет вести себя по-разному при задании простого слова или строки.</target>
        </trans-unit>
        <trans-unit id="e933e27b4b6affb17bacc2be8545945df23e47f1" translate="yes" xml:space="preserve">
          <source>If you create interpreters in one thread and then proceed to call them in another, you need to make sure perl's own Thread Local Storage (TLS) slot is initialized correctly in each of those threads.</source>
          <target state="translated">Если вы создаете интерпретаторы в одном потоке,а затем продолжаете вызывать их в другом,вам необходимо убедиться,что собственный слот Perl Thread Local Storage (TLS)корректно инициализирован в каждом из этих потоков.</target>
        </trans-unit>
        <trans-unit id="4e50c2bd9e835a3a7f1961b7856f6dac61424cbe" translate="yes" xml:space="preserve">
          <source>If you decide to ignore this advice and use the GNU versions anyway, then be sure that they are relatively recent. Versions newer than 2.7 are apparently new enough. Older versions may have trouble with dynamic loading.</source>
          <target state="translated">Если вы все равно решите проигнорировать этот совет и воспользоваться версиями GNU,то убедитесь,что они относительно недавние.Версии,более новые,чем 2.7,по-видимому,достаточно новые.Старые версии могут иметь проблемы с динамической загрузкой.</target>
        </trans-unit>
        <trans-unit id="ff55c7f7dfadd85537843d3b167612c0ffcaee31" translate="yes" xml:space="preserve">
          <source>If you decide to use a different version of the zlib library, you need to be aware of the following issues</source>
          <target state="translated">Если вы решили использовать другую версию библиотеки zlib,вы должны быть осведомлены о следующих вопросах</target>
        </trans-unit>
        <trans-unit id="dea32ebc2834b73dcbf2cbd2fdecffa9453ead2d" translate="yes" xml:space="preserve">
          <source>If you decide to use gcc, make sure your installation is recent and complete, and be sure to read the Perl INSTALL file for more gcc-specific details.</source>
          <target state="translated">Если вы решили использовать gcc,убедитесь,что ваша установка завершена,и обязательно прочитайте файл Perl INSTALL для получения более подробной информации о gcc.</target>
        </trans-unit>
        <trans-unit id="275ebe9364d1067d763d9e8ee83a9ef9cef15d89" translate="yes" xml:space="preserve">
          <source>If you decide to use gcc, make sure your installation is recent and complete, and be sure to read the Perl INSTALL file for more gcc-specific details. Please report any hoops you had to jump through to the development team.</source>
          <target state="translated">Если вы решили использовать gcc,убедитесь,что ваша установка завершена,и обязательно прочитайте файл Perl INSTALL для получения более подробной информации о gcc.Пожалуйста,сообщите обо всех обручах,через которые вам пришлось пройти,команде разработчиков.</target>
        </trans-unit>
        <trans-unit id="129ecc12b1557dd3798539452dbf9b9ea8476c0d" translate="yes" xml:space="preserve">
          <source>If you define an &lt;code&gt;AUTOLOAD&lt;/code&gt; in your class, then Perl will call your &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the &lt;code&gt;DESTROY&lt;/code&gt; method. You can prevent this by defining an empty &lt;code&gt;DESTROY&lt;/code&gt; , like we did in the autoloading example. You can also check the value of &lt;code&gt;$AUTOLOAD&lt;/code&gt; and return without doing anything when called to handle &lt;code&gt;DESTROY&lt;/code&gt; .</source>
          <target state="translated">Если вы определите &lt;code&gt;AUTOLOAD&lt;/code&gt; в своем классе, Perl вызовет ваш &lt;code&gt;AUTOLOAD&lt;/code&gt; для обработки метода &lt;code&gt;DESTROY&lt;/code&gt; . Вы можете предотвратить это, указав пустой &lt;code&gt;DESTROY&lt;/code&gt; , как мы сделали в примере с автозагрузкой. Вы также можете проверить значение &lt;code&gt;$AUTOLOAD&lt;/code&gt; и вернуться без каких-либо действий при вызове для обработки &lt;code&gt;DESTROY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94eb8ac68c4fb558c46d1ee64b3833ca570000ed" translate="yes" xml:space="preserve">
          <source>If you define more than one name for the code point, it is indeterminate which one will be returned.</source>
          <target state="translated">Если задать более одного имени для точки кода,то будет неопределено,какое из них будет возвращено.</target>
        </trans-unit>
        <trans-unit id="04b2ed76508ea6501a561cd368f25fd856dfc7e2" translate="yes" xml:space="preserve">
          <source>If you develop any useful expiration managers that you think should be distributed with Memoize, please let me know.</source>
          <target state="translated">Если вы разрабатываете какие-либо полезные менеджеры истечения срока действия,которые,по вашему мнению,должны распространяться с Memoize,пожалуйста,дайте мне знать.</target>
        </trans-unit>
        <trans-unit id="0cf4a8657eebfe97ba9c4e743bd983d09e5edaa6" translate="yes" xml:space="preserve">
          <source>If you didn't use &lt;code&gt;openlog()&lt;/code&gt; before using &lt;code&gt;syslog()&lt;/code&gt; , &lt;code&gt;syslog()&lt;/code&gt; will try to guess the &lt;code&gt;$ident&lt;/code&gt; by extracting the shortest prefix of &lt;code&gt;$format&lt;/code&gt; that ends in a &lt;code&gt;&quot;:&quot;&lt;/code&gt; .</source>
          <target state="translated">Если вы не использовали &lt;code&gt;openlog()&lt;/code&gt; до использования &lt;code&gt;syslog()&lt;/code&gt; , &lt;code&gt;syslog()&lt;/code&gt; попытается угадать &lt;code&gt;$ident&lt;/code&gt; , извлекая самый короткий префикс &lt;code&gt;$format&lt;/code&gt; который заканчивается на &lt;code&gt;&quot;:&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06ed1961687b0abd10e165d61c48cda9ac3ae785" translate="yes" xml:space="preserve">
          <source>If you discover some glitches, move directories of problematic modules to a different location; if these modules are non-XS modules, you may just ignore them - they are already installed; the remaining, XS, modules you need to install manually one by one.</source>
          <target state="translated">Если вы обнаружите некоторые глюки,переместите каталоги проблемных модулей в другое место;если эти модули не XS,вы можете просто проигнорировать их-они уже установлены;остальные,XS,модули нужно установить вручную по одному.</target>
        </trans-unit>
        <trans-unit id="43d56dedc7192e637755e1fdcd48fbf68cbff70a" translate="yes" xml:space="preserve">
          <source>If you do</source>
          <target state="translated">Если ты это сделаешь</target>
        </trans-unit>
        <trans-unit id="87ef7e6c621828b29eab79e96b5fb6269cd00a77" translate="yes" xml:space="preserve">
          <source>If you do not enter the shell, shell commands are available both as methods (&lt;code&gt;CPAN::Shell-&amp;gt;install(...)&lt;/code&gt; ) and as functions in the calling package (&lt;code&gt;install(...)&lt;/code&gt; ). Before calling low-level commands, it makes sense to initialize components of CPAN you need, e.g.:</source>
          <target state="translated">Если вы не входите в оболочку, команды оболочки доступны как как методы ( &lt;code&gt;CPAN::Shell-&amp;gt;install(...)&lt;/code&gt; ), так и как функции в вызывающем пакете ( &lt;code&gt;install(...)&lt;/code&gt; ). Перед вызовом низкоуровневых команд имеет смысл инициализировать необходимые вам компоненты CPAN, например:</target>
        </trans-unit>
        <trans-unit id="bc816a9fd08d7a00464780adbf72cc89737d7fde" translate="yes" xml:space="preserve">
          <source>If you do not have</source>
          <target state="translated">Если у вас нет</target>
        </trans-unit>
        <trans-unit id="69ced298dbf1c87fefd1662253cccc2e7a8bde7d" translate="yes" xml:space="preserve">
          <source>If you do not have a copy of the GNU General Public License write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</source>
          <target state="translated">Если у вас нет копии Стандартной общественной лицензии GNU,напишите по адресу:675 Mass Ave,Cambridge,MA 02139,USA.</target>
        </trans-unit>
        <trans-unit id="f9c124bac0783d0b5dcccc34a0dbf3566f426f11" translate="yes" xml:space="preserve">
          <source>If you do not have that module, you can do the same thing with &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt; which is part of the standard library:</source>
          <target state="translated">Если у вас нет этого модуля, вы можете сделать то же самое с &lt;a href=&quot;file/find&quot;&gt;File :: Find,&lt;/a&gt; который является частью стандартной библиотеки:</target>
        </trans-unit>
        <trans-unit id="bd07d5a5c26be6eca98f51764342db5783f35fa8" translate="yes" xml:space="preserve">
          <source>If you do not know what shell you have, consult your local helpdesk or the equivalent.</source>
          <target state="translated">Если вы не знаете,какая оболочка у вас есть,обратитесь в местную службу поддержки или эквивалентную службу.</target>
        </trans-unit>
        <trans-unit id="1de6e3279f2bd155e7f8bf6759e637927cce20be" translate="yes" xml:space="preserve">
          <source>If you do not set this flag then it is</source>
          <target state="translated">Если вы не установите этот флаг,то это будет</target>
        </trans-unit>
        <trans-unit id="926a166805dd3b0aef3dd1d472d192955fb1ec52" translate="yes" xml:space="preserve">
          <source>If you do not specify a package name, the variable is created in the current package.</source>
          <target state="translated">Если вы не указываете имя пакета,переменная создается в текущем пакете.</target>
        </trans-unit>
        <trans-unit id="3b6ac2382b8b465b26d1901487c44646a3e50e04" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">Если вы не хотите вызывать метод &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; пакета (например, чтобы предотвратить изменение пространства имен), явно укажите пустой список:</target>
        </trans-unit>
        <trans-unit id="ea10c1ff3a243c28f284c149e22c1d185c65b318" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">Если вы не хотите вызывать метод &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; пакета (например, чтобы предотвратить изменение пространства имен), явно укажите пустой список:</target>
        </trans-unit>
        <trans-unit id="8470234c0d68b289fd8da0f074a387fae1ae490f" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">Если вы не хотите использовать эти значения по умолчанию, их можно переопределить, явно &lt;code&gt;TextFlag&lt;/code&gt; параметры &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , TextFlag , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; и &lt;code&gt;exTime&lt;/code&gt; или установив параметр &lt;code&gt;Minimal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f15a287c32e6f66173e359fbddfbe362d18b693a" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">Если вы не хотите использовать эти значения по умолчанию, их можно переопределить, явно установив параметры &amp;laquo; &lt;code&gt;Name&lt;/code&gt; и &amp;laquo; &lt;code&gt;Time&lt;/code&gt; или установив параметр &amp;laquo; &lt;code&gt;Minimal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c647e4788bb29e5dcf3d258b1e0dc34c9ef54f62" translate="yes" xml:space="preserve">
          <source>If you do not wish this to happen, you should provide an array reference, where all parts of your command are already separated out. Note however, if there are extra or spurious whitespaces in these parts, the parser or underlying code may not interpret it correctly, and cause an error.</source>
          <target state="translated">Если вы не хотите,чтобы это произошло,вы должны предоставить ссылку на массив,где все части вашей команды уже отделены друг от друга.Однако обратите внимание,что если в этих частях есть лишние или поддельные белые пространства,то парсер или лежащий в его основе код могут неправильно интерпретировать его и привести к ошибке.</target>
        </trans-unit>
        <trans-unit id="1f09ee5e6b9af0c82c4326addc62e789f8443f5c" translate="yes" xml:space="preserve">
          <source>If you do not wish to install the &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module::Starter&lt;/a&gt; package from CPAN,</source>
          <target state="translated">Если вы не хотите устанавливать пакет &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module :: Starter&lt;/a&gt; из CPAN,</target>
        </trans-unit>
        <trans-unit id="0549310bae0dd74950be604da632c91876f7d8c0" translate="yes" xml:space="preserve">
          <source>If you do set &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 1, you will notice slow-downs.</source>
          <target state="translated">Если вы установите для &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; значение 1, вы заметите замедление.</target>
        </trans-unit>
        <trans-unit id="feef0b7ae2868ad2a4e1f83d30c63fb0d93e6be4" translate="yes" xml:space="preserve">
          <source>If you do this in a binary operator, you will actually change one of the strings that came into the operator, and, while it shouldn't be noticeable by the end user, it can cause problems in deficient code.</source>
          <target state="translated">Если Вы сделаете это в двоичном операторе,то на самом деле Вы измените одну из строк,которая попала в оператор,и,хотя она не должна быть заметна конечному пользователю,это может привести к проблемам в неполноценном коде.</target>
        </trans-unit>
        <trans-unit id="32f0578310d415019b09f619288e373d3b705f8d" translate="yes" xml:space="preserve">
          <source>If you do want this subroutine to be a closure that reflects future changes to the variable that it closes over, add an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите, чтобы эта подпрограмма была закрытием, отражающим будущие изменения переменной, которую она закрывает, добавьте явный &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7553259d39face4afb80ca316b04630713e25671" translate="yes" xml:space="preserve">
          <source>If you do want to work with large integers like under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; , try &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint;&lt;/code&gt; :</source>
          <target state="translated">Если вы хотите работать с большими целыми числами, например, при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; попробуйте &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a338314884729930813df6e4dec44b70118fce2d" translate="yes" xml:space="preserve">
          <source>If you don't ask for any feature, you get the list of features that the user requested you to be nice to. This has the nice side effect that if you don't respect anything in particular then you can just ask for it and use it like a boolean.</source>
          <target state="translated">Если вы не попросите ни об одной функции,вы получите список функций,которые пользователь просил вас использовать вежливо.Это имеет приятный побочный эффект,что если вы не уважаете ничего конкретного,то вы можете просто попросить об этом и использовать его как булевую.</target>
        </trans-unit>
        <trans-unit id="d5b6d156d7cf6f2a797778536a48c223724f9360" translate="yes" xml:space="preserve">
          <source>If you don't care about the order of the elements, you could just create the hash then extract the keys. It's not important how you create that hash: just that you use &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; to get the unique elements.</source>
          <target state="translated">Если вас не волнует порядок элементов, вы можете просто создать хеш, а затем извлечь ключи. Неважно, как вы создаете этот хеш: просто вы используете &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; для получения уникальных элементов.</target>
        </trans-unit>
        <trans-unit id="e21625178e6b6545fac5abe6f5027d91ef293d91" translate="yes" xml:space="preserve">
          <source>If you don't care about where digits and underscore sort to, you can do something like this</source>
          <target state="translated">Если тебя не волнует,куда деваются цифры и подчёркивания,ты можешь сделать что-то вроде этого.</target>
        </trans-unit>
        <trans-unit id="f92e493c5048826b06ef70fc4669cac080dfe915" translate="yes" xml:space="preserve">
          <source>If you don't care that one hash overwrites keys and values from the other, you could just use a hash slice to add one hash to another. In this case, values from &lt;code&gt;%hash2&lt;/code&gt; replace values from &lt;code&gt;%hash1&lt;/code&gt; when they have keys in common:</source>
          <target state="translated">Если вам все равно, что один хэш перезаписывает ключи и значения другого, вы можете просто использовать хеш-срез, чтобы добавить один хеш к другому. В этом случае значения из &lt;code&gt;%hash2&lt;/code&gt; заменяют значения из &lt;code&gt;%hash1&lt;/code&gt; если у них есть общие ключи:</target>
        </trans-unit>
        <trans-unit id="c43d001ee345c63043409156142b64f915867634" translate="yes" xml:space="preserve">
          <source>If you don't get a paragraph or two of expanded discussion, it might not be perl's message.</source>
          <target state="translated">Если вы не получите параграф или два расширенных обсуждения,это может быть не сообщение perl.</target>
        </trans-unit>
        <trans-unit id="7a12cb113cb2e2457200764dfd73d419fb8973d7" translate="yes" xml:space="preserve">
          <source>If you don't have File::Stream, you have to do a little more work.</source>
          <target state="translated">Если у вас нет File::Stream,вы должны сделать немного больше работы.</target>
        </trans-unit>
        <trans-unit id="ea4a8fbdbdee9b250414a6cc40a6c3e590cef92d" translate="yes" xml:space="preserve">
          <source>If you don't have data written with specific configuration of perl described above, then you do not and should not do anything. Don't set the flag - not only will Storable on an identically configured perl refuse to load them, but Storable a differently configured perl will load them believing them to be correct for it, and then may well fail or crash part way through reading them.</source>
          <target state="translated">Если у вас нет данных,написанных с определенной конфигурацией perl,описанной выше,то вы ничего не делаете и не должны делать.Не устанавливайте флаг-Storable на одинаково сконфигурированном perl не только откажется их загружать,но и загрузит Storable на другом perl,полагая,что они корректны,и тогда вполне может произойти сбой или падение отчасти из-за чтения.</target>
        </trans-unit>
        <trans-unit id="36289d77701a121889713d6277f544f12a871bb4" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; to trap the error.</source>
          <target state="translated">Если у вас нет доступа на запись в файл DBM, вы можете только читать хеш-переменные, но не устанавливать их. Если вы хотите проверить, можете ли вы писать, либо используйте файловые тесты, либо попробуйте установить фиктивную запись хэша внутри &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , чтобы перехватить ошибку.</target>
        </trans-unit>
        <trans-unit id="bdbbd37031df2f33535ed6549b499d32ea9aa9e5" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; to trap the error.</source>
          <target state="translated">Если у вас нет доступа на запись в файл DBM, вы можете только читать хеш-переменные, но не устанавливать их. Если вы хотите проверить, можете ли вы писать, либо используйте файловые тесты, либо попробуйте установить фиктивную запись хэша внутри &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , чтобы перехватить ошибку.</target>
        </trans-unit>
        <trans-unit id="8f4b767528b9f98c2858aad05fc8520eae2c1d33" translate="yes" xml:space="preserve">
          <source>If you don't import any of these functions, assume a &lt;code&gt;&amp;amp;I18N::LangTags::&lt;/code&gt; in front of all the function names in the following examples.</source>
          <target state="translated">Если вы не импортируете ни одну из этих функций, предположите, что &lt;code&gt;&amp;amp;I18N::LangTags::&lt;/code&gt; перед всеми именами функций в следующих примерах.</target>
        </trans-unit>
        <trans-unit id="107952179f7076da25aad77d14c209ced7df48df" translate="yes" xml:space="preserve">
          <source>If you don't know how many tests you're going to run, you can issue the plan when you're done running tests.</source>
          <target state="translated">Если вы не знаете,сколько тестов вы собираетесь запустить,вы можете выпустить план,когда закончите выполнять тесты.</target>
        </trans-unit>
        <trans-unit id="209c65929fc8bcea028a0c96cf1f684c89334602" translate="yes" xml:space="preserve">
          <source>If you don't know what license to use, dual licensing under the GPL and Artistic licenses (the same as Perl itself) is a good idea. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;.</source>
          <target state="translated">Если вы не знаете, какую лицензию использовать, хорошей идеей будет двойное лицензирование под GPL и Artistic (как и сам Perl). Смотрите &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt; и &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0afa056a783c1ff17e6396cee6d067cb1e22c33a" translate="yes" xml:space="preserve">
          <source>If you don't know whether a string contains YAML or JSON data, this method will use some heuristics and guess. If it can't tell, it assumes YAML.</source>
          <target state="translated">Если вы не знаете,содержит ли строка данные YAML или JSON,то этот метод использует некоторую эвристику и угадывает.Если он не может сказать,он предполагает YAML.</target>
        </trans-unit>
        <trans-unit id="d34593d2a30bd46dc846ad60717c333d071ef181" translate="yes" xml:space="preserve">
          <source>If you don't mind shelling out, the &lt;code&gt;wc&lt;/code&gt; command is usually the fastest, even with the extra interprocess overhead. Ensure that you have an untainted filename though:</source>
          <target state="translated">Если вы не возражаете против обстрела, команда &lt;code&gt;wc&lt;/code&gt; обычно самая быстрая, даже с дополнительными накладными расходами между процессами. Убедитесь, что у вас есть незапятнанное имя файла:</target>
        </trans-unit>
        <trans-unit id="ab42639abd5abd9367c12d1d0ad1d1482fb0d4b6" translate="yes" xml:space="preserve">
          <source>If you don't need the existing content of the SV, you can avoid some copying with:</source>
          <target state="translated">Если вам не нужно существующее содержимое SV,вы можете избежать некоторого копирования:</target>
        </trans-unit>
        <trans-unit id="bd9e10a2452b68c075fcb32cabd703d0209267ed" translate="yes" xml:space="preserve">
          <source>If you don't need to know the name of the file, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in place of the file name. In Perl 5.8 or later, the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function creates an anonymous temporary file:</source>
          <target state="translated">Если вам не нужно знать имя файла, вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; с &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; вместо имени файла. В Perl 5.8 или новее функция &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; создает анонимный временный файл:</target>
        </trans-unit>
        <trans-unit id="b260604ab4c441d85ae092e22c063810eb4d30c0" translate="yes" xml:space="preserve">
          <source>If you don't provide an exact inverse transformation, you will find that code like this will not behave as you expect.</source>
          <target state="translated">Если вы не предоставите точное обратное преобразование,вы обнаружите,что подобный код будет вести себя не так,как вы ожидаете.</target>
        </trans-unit>
        <trans-unit id="da9f240e2e4669201b3520ed7f3f5a0edd014292" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">Если вы действительно не хотите выполнять первый аргумент, но хотите солгать программе, которую вы выполняете, о ее собственном имени, вы можете указать программу, которую вы действительно хотите запустить, как &amp;laquo;косвенный объект&amp;raquo; (без запятой) в перед СПИСОК, как в &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (Это всегда приводит к интерпретации списка LIST как многозначного списка, даже если в списке есть только один скаляр.) Пример:</target>
        </trans-unit>
        <trans-unit id="90475a6e4998e8131a7d71a411d5204a133b0a81" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">Если вы действительно не хотите выполнять первый аргумент, но хотите солгать программе, которую вы выполняете, о ее собственном имени, вы можете указать программу, которую вы действительно хотите запустить, как &amp;laquo;косвенный объект&amp;raquo; (без запятой) в перед СПИСОК, как в &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (Это всегда приводит к интерпретации списка LIST как многозначного списка, даже если в списке есть только один скаляр.) Пример:</target>
        </trans-unit>
        <trans-unit id="1d09c87ff03423122d55e0fe04c7fdafafae320f" translate="yes" xml:space="preserve">
          <source>If you don't see an error message, you have the module. (If you do see an error message, it's still possible you have the module, but that it's not in your path, which you can display with &lt;code&gt;perl -e
&quot;print qq(@INC)&quot;&lt;/code&gt; .) For the remainder of this document, we'll assume that you really honestly truly lack an installed module, but have found it on the CPAN.</source>
          <target state="translated">Если вы не видите сообщение об ошибке, у вас есть модуль. (Если вы видите сообщение об ошибке, возможно, у вас есть модуль, но он не находится на вашем пути, который вы можете отобразить с помощью &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt; .) В оставшейся части этого документа, мы предположим, что вам действительно действительно не хватает установленного модуля, но вы нашли его на CPAN.</target>
        </trans-unit>
        <trans-unit id="22a71969f2b2e317963f5563c127a63079459334" translate="yes" xml:space="preserve">
          <source>If you don't specify a &lt;code&gt;dw_size&lt;/code&gt; , it defaults to the entire memory limit.</source>
          <target state="translated">Если вы не укажете &lt;code&gt;dw_size&lt;/code&gt; , по умолчанию будет использоваться весь лимит памяти.</target>
        </trans-unit>
        <trans-unit id="d559d6056536d78595c17d437dfe78484f93f47a" translate="yes" xml:space="preserve">
          <source>If you don't understand this question, just press ENTER.</source>
          <target state="translated">Если вы не понимаете этого вопроса,просто нажмите ENTER.</target>
        </trans-unit>
        <trans-unit id="e1a9da1b5f8c61c5b3d264532c0386f7656b5414" translate="yes" xml:space="preserve">
          <source>If you don't want &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; to change your original variable you can use the non-destructive substitute modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;. This changes the behavior so that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; returns the final substituted string (instead of the number of substitutions):</source>
          <target state="translated">Если вы не хотите, чтобы &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; изменяла исходную переменную, вы можете использовать модификатор неразрушающей замены, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; . Это изменяет поведение так, что &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; возвращает окончательную заменяемую строку (вместо количества замен):</target>
        </trans-unit>
        <trans-unit id="b63f96d379f7a46f61c3872f0a57972ef07d6947" translate="yes" xml:space="preserve">
          <source>If you don't want any output should all modules be up to date, parse the output of above command for the regular expression &lt;code&gt;/modules are up to date/&lt;/code&gt; and decide to mail the output only if it doesn't match.</source>
          <target state="translated">Если вам не нужен какой-либо вывод, если все модули обновлены, проанализируйте вывод вышеуказанной команды на предмет регулярного выражения &lt;code&gt;/modules are up to date/&lt;/code&gt; и решите отправить вывод по почте, только если он не совпадает.</target>
        </trans-unit>
        <trans-unit id="717adb67f10193acb40c16a22305c4dc8ba0e791" translate="yes" xml:space="preserve">
          <source>If you don't want to create a new hash, you can still use this looping technique; just change the &lt;code&gt;%new_hash&lt;/code&gt; to &lt;code&gt;%hash1&lt;/code&gt; .</source>
          <target state="translated">Если вы не хотите создавать новый хэш, вы все равно можете использовать эту технику цикла; просто измените &lt;code&gt;%new_hash&lt;/code&gt; на &lt;code&gt;%hash1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5861b9dcca59001a7ac94c68a3d243558acaf640" translate="yes" xml:space="preserve">
          <source>If you don't want to install the compiled Perl in AIX into /QOpenSys (for packaging it before copying it to PASE), you can use a Configure parameter: -Dinstallprefix=/tmp/QOpenSys/perl. This will cause the &quot;make install&quot; to install everything into that directory, while the installed files still think they are (will be) in /QOpenSys/perl.</source>
          <target state="translated">Если вы не хотите устанавливать скомпилированный Perl в AIX в /QOpenSys (для упаковки перед копированием в PASE),вы можете использовать параметр Configure:-Dinstallprefix=/tmp/QOpenSys/perl.Это приведет к тому,что &quot;make install&quot; установит все в этот каталог,в то время как установленные файлы все еще будут думать,что они (будут)в /QOpenSys/perl.</target>
        </trans-unit>
        <trans-unit id="ebe8a5460a3cd2a89a4ca3fccf1f4c546c9647e5" translate="yes" xml:space="preserve">
          <source>If you don't want to keep the defaults for the INSTALL* macros, MakeMaker helps you to minimize the typing needed: the usual relationship between INSTALLPRIVLIB and INSTALLARCHLIB is determined by Configure at perl compilation time. MakeMaker supports the user who sets INSTALLPRIVLIB. If INSTALLPRIVLIB is set, but INSTALLARCHLIB not, then MakeMaker defaults the latter to be the same subdirectory of INSTALLPRIVLIB as Configure decided for the counterparts in %Config, otherwise it defaults to INSTALLPRIVLIB. The same relationship holds for INSTALLSITELIB and INSTALLSITEARCH.</source>
          <target state="translated">Если вы не хотите сохранять настройки по умолчанию для макросов INSTALL*,MakeMaker поможет вам свести к минимуму необходимость набора текста:обычное соотношение между INSTALLPRIVLIB и INSTALLARCHLIB определяется с помощью функции Configure at perl compilation time (Настройка на время компиляции perl).MakeMaker поддерживает пользователя,который устанавливает INSTALLPRIVLIB.Если ИНСТАЛЛПРИВЛИБ установлен,а ИНСТАЛЛАРХЛИБ нет,то по умолчанию MakeMaker устанавливает для последней подкаталог ИНСТАЛПРИВЛИБ тот же подкаталог,что и для остальных подкаталогов в %Config,в противном случае по умолчанию он устанавливает для ИНСТАЛЛПРИВЛИБ.То же самое относится к ИНСТАЛЛЬНОЙ и ИНСТАЛЛИРУЮЩЕЙ директориям.</target>
        </trans-unit>
        <trans-unit id="5f0e1c4bb41a9dbee49413981e4f4536890ac2a6" translate="yes" xml:space="preserve">
          <source>If you don't want to modify your source code, but still have on-the-fly warnings, do this:</source>
          <target state="translated">Если вы не хотите изменять свой исходный код,но все еще имеете предупреждения &quot;на лету&quot;,сделайте это:</target>
        </trans-unit>
        <trans-unit id="883af52a64cbec821f8f52f9cf06fce4facdd6ad" translate="yes" xml:space="preserve">
          <source>If you don't want to use the objects, you may import the &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method into your namespace as a regular function called &lt;code&gt;stat_cando&lt;/code&gt; . This takes an arrayref containing the return values of &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; as its first argument, and interprets it for you.</source>
          <target state="translated">Если вы не хотите использовать объекты, вы можете импортировать метод &lt;code&gt;-&amp;gt;cando&lt;/code&gt; в свое пространство имен как обычную функцию &lt;code&gt;stat_cando&lt;/code&gt; . Он принимает в качестве первого аргумента ссылку на массив, содержащую возвращаемые значения &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; , и интерпретирует его за вас.</target>
        </trans-unit>
        <trans-unit id="8ca8817e625d3ffbecabec4b725646c93f6f8e36" translate="yes" xml:space="preserve">
          <source>If you don't wish to do this, set this variable to &lt;code&gt;false&lt;/code&gt; . Understand then that version comparisons are not possible, and Module::Load::Conditional can not tell you what module version you have installed. This may be desirable from a security or performance point of view. Note that &lt;code&gt;$FIND_VERSION&lt;/code&gt; code runs safely under &lt;code&gt;taint mode&lt;/code&gt; .</source>
          <target state="translated">Если вы не хотите этого делать, установите для этой переменной значение &lt;code&gt;false&lt;/code&gt; . Тогда поймите, что сравнение версий невозможно, и Module :: Load :: Conditional не может сказать вам, какую версию модуля вы установили. Это может быть желательно с точки зрения безопасности или производительности. Обратите внимание, что код &lt;code&gt;$FIND_VERSION&lt;/code&gt; безопасно работает в &lt;code&gt;taint mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1341f2f78549b1827b1d11fb4b0cc0463ec09d6c" translate="yes" xml:space="preserve">
          <source>If you don't, you may experience strange build errors.</source>
          <target state="translated">Если вы этого не сделаете,то можете столкнуться со странными ошибками при сборке.</target>
        </trans-unit>
        <trans-unit id="dae8c74471266a8218d010f2ece1eeec7e339df7" translate="yes" xml:space="preserve">
          <source>If you edit</source>
          <target state="translated">Если вы редактируете</target>
        </trans-unit>
        <trans-unit id="2fb01cc36906ab2ae202731906c27291970214ff" translate="yes" xml:space="preserve">
          <source>If you either have Perl 5.8.0 or later installed, or if you have Scalar-List-Utils 1.03 or later installed, you can say:</source>
          <target state="translated">Если у вас установлен Perl 5.8.0 или более поздняя версия,или если у вас установлен Scalar-List-Utils 1.03 или более поздняя версия,то вы можете сказать,что у вас установлен Perl 5.8.0 или более поздняя версия:</target>
        </trans-unit>
        <trans-unit id="b892a658ce0764f4b064036e5d8f58bd78f5e370" translate="yes" xml:space="preserve">
          <source>If you evaluate a hash in scalar context, it returns false if the hash is empty. If there are any key/value pairs, it returns true; more precisely, the value returned is a string consisting of the number of used buckets and the number of allocated buckets, separated by a slash. This is pretty much useful only to find out whether Perl's internal hashing algorithm is performing poorly on your data set. For example, you stick 10,000 things in a hash, but evaluating %HASH in scalar context reveals &lt;code&gt;&quot;1/16&quot;&lt;/code&gt; , which means only one out of sixteen buckets has been touched, and presumably contains all 10,000 of your items. This isn't supposed to happen. If a tied hash is evaluated in scalar context, the &lt;code&gt;SCALAR&lt;/code&gt; method is called (with a fallback to &lt;code&gt;FIRSTKEY&lt;/code&gt; ).</source>
          <target state="translated">Если вы оцениваете хэш в скалярном контексте, он возвращает false, если хеш пуст. Если есть какие-либо пары ключ / значение, он возвращает true; точнее, возвращаемое значение представляет собой строку, состоящую из количества использованных сегментов и количества выделенных сегментов, разделенных косой чертой. Это в значительной степени полезно только для того, чтобы выяснить, плохо ли работает внутренний алгоритм хеширования Perl с вашим набором данных. Например, вы вставляете 10 000 вещей в хэш, но оценка% HASH в скалярном контексте показывает &lt;code&gt;&quot;1/16&quot;&lt;/code&gt; , что означает, что затронута только одна из шестнадцати корзин, и предположительно содержит все 10 000 ваших элементов. Этого не должно быть. Если связанный хеш оценивается в скалярном контексте, &lt;code&gt;SCALAR&lt;/code&gt; метод SCALAR (с &lt;code&gt;FIRSTKEY&lt;/code&gt; к FIRSTKEY ).</target>
        </trans-unit>
        <trans-unit id="8b7212a78497ddedc16438e486691b2144fe7186" translate="yes" xml:space="preserve">
          <source>If you evaluate an array in scalar context, it returns the length of the array. (Note that this is not true of lists, which return the last value, like the C comma operator, nor of built-in functions, which return whatever they feel like returning.) The following is always true:</source>
          <target state="translated">Если вы оцениваете массив в скалярном контексте,то он возвращает длину массива.(Обратите внимание,что это не относится ни к спискам,которые возвращают последнее значение,как оператор C запятая,ни к встроенным функциям,которые возвращают все,что они хотят вернуть).Следующее всегда верно:</target>
        </trans-unit>
        <trans-unit id="ae75f4b9e5f451131a1e22cec2a555eb5370ed40" translate="yes" xml:space="preserve">
          <source>If you ever see a string that looks like this, you'll know you printed out a reference by mistake.</source>
          <target state="translated">Если вы когда-нибудь увидите строку,которая выглядит так,вы будете знать,что распечатали ссылку по ошибке.</target>
        </trans-unit>
        <trans-unit id="d2eae54bf1fbe9ae68c160098f500a78269b550c" translate="yes" xml:space="preserve">
          <source>If you execute the &lt;code&gt;T&lt;/code&gt; command from inside an active &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, the backtrace will contain both a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; frame and an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; frame.</source>
          <target state="translated">Если вы выполните команду &lt;code&gt;T&lt;/code&gt; из активного оператора &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , трассировка будет содержать как &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; кадр, так и кадр &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5fd5107f38bc928d4af20adedacdcf1cb44e019" translate="yes" xml:space="preserve">
          <source>If you expect characters to get to your device when you &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; them, you'll want to autoflush that filehandle. You can use &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;$|&lt;/code&gt; variable to control autoflushing (see</source>
          <target state="translated">Если вы ожидаете, что символы попадут на ваше устройство, когда вы их &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; , вам нужно будет автоматически очистить этот дескриптор файла. Вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;$|&lt;/code&gt; переменная для управления автоматической промывкой (см.</target>
        </trans-unit>
        <trans-unit id="b65a4bc3927cbd6d7618d76eb545351eb5d8a945" translate="yes" xml:space="preserve">
          <source>If you expect to use both read and write operations on the device, you'll have to open it for update (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for details). You may wish to open it without running the risk of blocking by using &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module (part of the standard perl distribution). See &lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt; for more on this approach.</source>
          <target state="translated">Если вы планируете использовать на устройстве операции чтения и записи, вам придется открыть его для обновления ( подробности см. В разделе &amp;laquo; &lt;a href=&quot;functions/open&quot;&gt;Открыть&amp;raquo;&lt;/a&gt; ). Вы можете открыть его без риска блокировки, используя &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; из модуля &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; (часть стандартного дистрибутива perl). См. &lt;a href=&quot;functions/sysopen&quot;&gt;Sysopen,&lt;/a&gt; чтобы узнать больше об этом подходе.</target>
        </trans-unit>
        <trans-unit id="086943bc39b9078514791bccbde5ea2eddf63045" translate="yes" xml:space="preserve">
          <source>If you fail more than 254 tests, it will be reported as 254.</source>
          <target state="translated">Если вы провалите более 254 тестов,это будет сообщено как 254.</target>
        </trans-unit>
        <trans-unit id="cba05a1f1e542bc35030ada7de3e6bf8ced79b98" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt; . Note that you will then need &lt;code&gt;IO::String&lt;/code&gt; installed to support writing stringified archives.</source>
          <target state="translated">Если вы сильно хотите его отключить, установите для этой переменной значение &lt;code&gt;false&lt;/code&gt; . Обратите внимание, что вам потребуется установить &lt;code&gt;IO::String&lt;/code&gt; для поддержки записи строковых архивов.</target>
        </trans-unit>
        <trans-unit id="0eb03812b9a06455d8a297e6d6e18c05b28becbc" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt; . Note that you will then need &lt;code&gt;perlio&lt;/code&gt; support from your perl to be able to write stringified archives.</source>
          <target state="translated">Если вы сильно хотите его отключить, установите для этой переменной значение &lt;code&gt;false&lt;/code&gt; . Обратите внимание, что тогда вам понадобится поддержка &lt;code&gt;perlio&lt;/code&gt; из вашего Perl, чтобы иметь возможность писать строковые архивы.</target>
        </trans-unit>
        <trans-unit id="8b50f7e3c982f4c5e423c530952e3d4ee9e5c5f1" translate="yes" xml:space="preserve">
          <source>If you feel the urge to write Perl modules, &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; will give you good advice.</source>
          <target state="translated">Если вы чувствуете &lt;a href=&quot;perlnewmod&quot;&gt;потребность&lt;/a&gt; писать модули Perl, perlnewmod даст вам хороший совет.</target>
        </trans-unit>
        <trans-unit id="1ab4e553b43f57ec6c364e3642fd9276b76ed300" translate="yes" xml:space="preserve">
          <source>If you fill comfortable with</source>
          <target state="translated">Если вы заполните удобный для вас</target>
        </trans-unit>
        <trans-unit id="d37bfff208b4893c857f8a0e5567752243d86aa9" translate="yes" xml:space="preserve">
          <source>If you find any bugs, &lt;code&gt;Devel::PPPort&lt;/code&gt; doesn't seem to build on your system, or any of its tests fail, please file an issue here: &lt;a href=&quot;https://github.com/mhx/Devel-PPPort/issues/&quot;&gt;https://github.com/mhx/Devel-PPPort/issues/&lt;/a&gt;</source>
          <target state="translated">Если вы обнаружите какие-либо ошибки, &lt;code&gt;Devel::PPPort&lt;/code&gt; , похоже, не работает в вашей системе, или какой-либо из его тестов завершился неудачно, сообщите о проблеме здесь: &lt;a href=&quot;https://github.com/mhx/Devel-PPPort/issues/&quot;&gt;https://github.com/mhx/Devel-PPPort/issues/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5ef4696f943b05c3aef9d5f207bfe62cada2927" translate="yes" xml:space="preserve">
          <source>If you find bugs in perl, you can run &lt;code&gt;perlbug&lt;/code&gt; to create a bug report (you may have to send it manually if &lt;code&gt;perlbug&lt;/code&gt; cannot find a mailer on your system).</source>
          <target state="translated">Если вы обнаружите ошибки в perl, вы можете запустить &lt;code&gt;perlbug&lt;/code&gt; , чтобы создать отчет об ошибке (вам может потребоваться отправить его вручную, если &lt;code&gt;perlbug&lt;/code&gt; не может найти почтовую программу в вашей системе).</target>
        </trans-unit>
        <trans-unit id="549be5a33ff1eaf5b330339ea140d5f50a8a508b" translate="yes" xml:space="preserve">
          <source>If you find bugs or if it does not work at all on your device, send mail to the address below. Please report the details of your device (processor, ceversion, devicetype (hpc/palm/pocket)) and the date of the downloaded files.</source>
          <target state="translated">Если вы обнаружили ошибку или если она вообще не работает на вашем устройстве,отправьте письмо по адресу,указанному ниже.Пожалуйста,сообщите подробности о вашем устройстве (процессор,eversion,devicetype (hpc/palm/pocket))и дату загрузки файлов.</target>
        </trans-unit>
        <trans-unit id="ce181ab3a1836691a411c40b59cfd6c2a33af266" translate="yes" xml:space="preserve">
          <source>If you find instances of this in the Perl distribution itself, please let us know, so we can try to work around them.</source>
          <target state="translated">Если вы найдете примеры этого в самом дистрибутиве Perl,пожалуйста,сообщите нам об этом,чтобы мы могли попробовать поработать над ними.</target>
        </trans-unit>
        <trans-unit id="a35b038d2558b01a66b6ce215ee08874b540cf15" translate="yes" xml:space="preserve">
          <source>If you find that you do need to update the system Perl, one issue worth keeping in mind is the question of static vs. dynamic libraries. If you upgrade using the default static libperl, you will find that the dynamic libperl supplied by Apple will not be deleted. If both libraries are present when an application that links against libperl is built, ld will link against the dynamic library by default. So, if you need to replace Apple's dynamic libperl with a static libperl, you need to be sure to delete the older dynamic library after you've installed the update.</source>
          <target state="translated">Если вы обнаружили,что вам действительно необходимо обновить систему Perl,то одна из проблем,о которой стоит помнить,это вопрос статических и динамических библиотек.Если вы обновите систему,используя статическую libperl по умолчанию,вы обнаружите,что динамическая libperl,поставляемая Apple,не будет удалена.Если обе библиотеки присутствуют при сборке приложения,линкующего против libperl,то по умолчанию ld будет линковать против динамической библиотеки.Поэтому,если вам нужно заменить динамическую libperl от Apple на статическую libperl,вам нужно убедиться,что старая динамическая библиотека удалена после установки обновления.</target>
        </trans-unit>
        <trans-unit id="8facfef28f917f827b51a8dc9cc5203934df7f46" translate="yes" xml:space="preserve">
          <source>If you find that you need to speed up a specific part of a Perl application (not something you often need) you may want to use C, but you can access this from your Perl code with &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;.</source>
          <target state="translated">Если вы обнаружите, что вам нужно ускорить определенную часть приложения Perl (а это не то, что вам часто нужно), вы можете использовать C, но вы можете получить к нему доступ из своего кода Perl с помощью &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d6f2d3762fd66cb49c45a26180601ab0ecbaf26" translate="yes" xml:space="preserve">
          <source>If you find the Calc module to slow, try to install any of the replacement modules and see if they help you.</source>
          <target state="translated">Если вы обнаружили,что модуль Calc работает медленно,попробуйте установить любой из заменяющих модулей и посмотрите,не помогут ли они вам.</target>
        </trans-unit>
        <trans-unit id="9507dd44f0fdbd974fde8543eaceef56a9bf59da" translate="yes" xml:space="preserve">
          <source>If you find the implementation document unclear or not sufficient, look at the existing PerlIO layer implementations, which include:</source>
          <target state="translated">Если вы обнаружите,что документ о реализации неясен или недостаточен,посмотрите на существующие реализации уровня PerlIO,которые включают в себя:</target>
        </trans-unit>
        <trans-unit id="bb1a29c843961bd016421afc69613b486ab41b5a" translate="yes" xml:space="preserve">
          <source>If you find this module useful, please consider rating it on the CPAN Ratings service at &lt;a href=&quot;http://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie&lt;/a&gt; .</source>
          <target state="translated">Если вы найдете этот модуль полезным, оцените его в службе рейтингов CPAN по адресу &lt;a href=&quot;http://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5afed98244534d5e7bd9f07d6f953a138ea4f8e9" translate="yes" xml:space="preserve">
          <source>If you find you need to provide custom functionality (as you would have using &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;), you're in luck: &lt;code&gt;TAP::Parser&lt;/code&gt; and friends are designed to be easily plugged-into and/or subclassed.</source>
          <target state="translated">Если вы обнаружите, что вам нужно предоставить настраиваемые функции (как если бы вы использовали &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test :: Harness :: Straps&lt;/a&gt; ), вам повезло: &lt;code&gt;TAP::Parser&lt;/code&gt; и его друзья разработаны так, чтобы их можно было легко подключить и / или создать подклассы.</target>
        </trans-unit>
        <trans-unit id="7eaae25128643ba9a8e9cd9fd035b84dc1c8a6c4" translate="yes" xml:space="preserve">
          <source>If you find you really need to use your own iterator factory you can still do so without sub-classing &lt;code&gt;TAP::Parser&lt;/code&gt; by setting &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt;.</source>
          <target state="translated">Если вы обнаружите, что вам действительно нужно использовать свою собственную фабрику итераторов, вы все равно можете сделать это без подкласса &lt;code&gt;TAP::Parser&lt;/code&gt; , установив &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef253d4b5355af7bdf0e5249c9becef0fb63f08e" translate="yes" xml:space="preserve">
          <source>If you for some reason (such as binary backward compatibility) really need to use perl's malloc, you can rebuild perl from the sources and Configure the build with</source>
          <target state="translated">Если вам по каким-то причинам (например,бинарная обратная совместимость)действительно нужно использовать perl's malloc,вы можете пересобрать perl из исходных текстов и настроить сборку с помощью команды</target>
        </trans-unit>
        <trans-unit id="a38ea3094c2349d48a8464c8b2ede590e7cc8393" translate="yes" xml:space="preserve">
          <source>If you forget &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , high bytes will be misunderstood as separate characters, and nothing will work right.</source>
          <target state="translated">Если вы забудете &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , старшие байты будут неправильно поняты как отдельные символы, и ничего не будет работать правильно.</target>
        </trans-unit>
        <trans-unit id="5c73cb5a6222b98080e0788ac4c8f896039ff111" translate="yes" xml:space="preserve">
          <source>If you forget to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you'll miss out entirely on the helpful diagnostic message:</source>
          <target state="translated">Если вы забудете &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , вы полностью упустите полезное диагностическое сообщение:</target>
        </trans-unit>
        <trans-unit id="4e4db242421a858aa14b9bcaa4e5f3862b8a23c5" translate="yes" xml:space="preserve">
          <source>If you get a core dump (or equivalent), you may use a debugger (&lt;b&gt;dbx&lt;/b&gt;, &lt;b&gt;gdb&lt;/b&gt;, etc) to produce a stack trace to include in the bug report.</source>
          <target state="translated">Если вы получили дамп ядра (или эквивалент), вы можете использовать отладчик ( &lt;b&gt;dbx&lt;/b&gt; , &lt;b&gt;gdb&lt;/b&gt; и т. Д.), Чтобы создать трассировку стека для включения в отчет об ошибке.</target>
        </trans-unit>
        <trans-unit id="722060cb13bfb62427a93bad15761822b6a7686d" translate="yes" xml:space="preserve">
          <source>If you get a message like &quot;perl: command not found&quot;, perl is not in your PATH, which might also mean that the location of perl is not where you expect it so you need to adjust your shebang line.</source>
          <target state="translated">Если вы получаете сообщение типа &quot;команда perl:не найдена&quot;,то perl не находится в вашем PATH,что также может означать,что местоположение perl не там,где вы ожидаете,поэтому вам нужно настроить вашу линию shebang.</target>
        </trans-unit>
        <trans-unit id="6bc5836fc16b720e6dc1a4fbf9bbeb14813f0dae" translate="yes" xml:space="preserve">
          <source>If you get an error like</source>
          <target state="translated">Если вы получите такую ошибку,как</target>
        </trans-unit>
        <trans-unit id="e71cc5ed2d43a688912302c22a7a0e3e08b5d7b1" translate="yes" xml:space="preserve">
          <source>If you get an error message</source>
          <target state="translated">Если вы получите сообщение об ошибке</target>
        </trans-unit>
        <trans-unit id="8b6135f8eeab8f4ac6ffe0b88df52abad52ae3b4" translate="yes" xml:space="preserve">
          <source>If you get complaints about so_locations then search in the file hints/irix_6.sh for &quot;lddflags&quot; and do the suggested adjustments. (David Billinghurst &amp;lt;David.Billinghurst@riotinto.com.au&amp;gt;)</source>
          <target state="translated">Если вы получаете жалобы на so_locations, поищите в файле hints / irix_6.sh &quot;lddflags&quot; и внесите предложенные корректировки. (Дэвид Биллингхерст &amp;lt;David.Billinghurst@riotinto.com.au&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="0d74278837310505aa97f12b787c58f0bb90e74c" translate="yes" xml:space="preserve">
          <source>If you get lots of errors of the form</source>
          <target state="translated">Если вы получите много ошибок в форме</target>
        </trans-unit>
        <trans-unit id="0e2cd49639ef6344568879d541e1a269a34ede3d" translate="yes" xml:space="preserve">
          <source>If you get the error</source>
          <target state="translated">Если вы получите ошибку</target>
        </trans-unit>
        <trans-unit id="91993b40c91822c3454671d4c8a24b32c3e646ba" translate="yes" xml:space="preserve">
          <source>If you get this message on SunOS or Solaris, and you're using gcc, it's probably the GNU as or GNU ld problem in the previous item &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as and GNU ld&lt;/a&gt;.</source>
          <target state="translated">Если вы получаете это сообщение в SunOS или Solaris и используете gcc, вероятно, это проблема GNU as или GNU ld из предыдущего пункта. &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as и GNU ld&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36f4dbd793640e550ca076d30024d627de795ab8" translate="yes" xml:space="preserve">
          <source>If you get tired of being subject to your platform's native integers, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; pragma neatly sidesteps the issue altogether:</source>
          <target state="translated">Если вы устали подчиняться родным целым числам вашей платформы, прагма &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; аккуратно решит эту проблему:</target>
        </trans-unit>
        <trans-unit id="a28e8a38182dc716f4c7bb3a2e2a63a098694e97" translate="yes" xml:space="preserve">
          <source>If you get tired of constantly saying &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $lh-&amp;gt;maketext&lt;/code&gt; , consider making a functional wrapper for it, like so:</source>
          <target state="translated">Если вы устали постоянно &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $lh-&amp;gt;maketext&lt;/code&gt; &lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $ lh-&amp;gt; maketext , подумайте о создании для него функциональной оболочки, например:</target>
        </trans-unit>
        <trans-unit id="693c393f75e992e3003bea94747936126a6b0327" translate="yes" xml:space="preserve">
          <source>If you get tired of remembering which element of the return list contains which return value, by-name interfaces are provided in standard modules: &lt;code&gt;File::stat&lt;/code&gt; , &lt;code&gt;Net::hostent&lt;/code&gt; , &lt;code&gt;Net::netent&lt;/code&gt; , &lt;code&gt;Net::protoent&lt;/code&gt; , &lt;code&gt;Net::servent&lt;/code&gt; , &lt;code&gt;Time::gmtime&lt;/code&gt; , &lt;code&gt;Time::localtime&lt;/code&gt; , and &lt;code&gt;User::grent&lt;/code&gt; . These override the normal built-ins, supplying versions that return objects with the appropriate names for each field. For example:</source>
          <target state="translated">Если вы устали вспоминать, какой элемент списка возврата содержит какое возвращаемое значение, интерфейсы по имени предоставляются в стандартных модулях: &lt;code&gt;File::stat&lt;/code&gt; , &lt;code&gt;Net::hostent&lt;/code&gt; , &lt;code&gt;Net::netent&lt;/code&gt; , &lt;code&gt;Net::protoent&lt;/code&gt; , &lt;code&gt;Net::servent&lt;/code&gt; , &lt;code&gt;Time::gmtime&lt;/code&gt; , &lt;code&gt;Time::localtime&lt;/code&gt; и &lt;code&gt;User::grent&lt;/code&gt; . Они отменяют обычные встроенные функции, предоставляя версии, возвращающие объекты с соответствующими именами для каждого поля. Например:</target>
        </trans-unit>
        <trans-unit id="b8e0fc194ad5e5c2cd16a3f242684fe425f3428b" translate="yes" xml:space="preserve">
          <source>If you get used to writing odd things like these:</source>
          <target state="translated">Если ты привыкнешь писать странные вещи вроде этих:</target>
        </trans-unit>
        <trans-unit id="0cd15dd92a142244892a9be7434b98670ff15dc6" translate="yes" xml:space="preserve">
          <source>If you had &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %Foo::Bar::QUUX&lt;/code&gt; to check whether such a package variable exists then that's never really been reliable, and isn't a good way to enquire about the features of a package, or whether it's loaded, etc.</source>
          <target state="translated">Если вы &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %Foo::Bar::QUUX&lt;/code&gt; чтобы проверить, существует ли такая переменная пакета, тогда это никогда не было действительно надежным и не было хорошим способом узнать о функциях пакета, о том, загружен ли он и т. Д.</target>
        </trans-unit>
        <trans-unit id="4ef8417488b5df9f33f3d1b38e3847657756981c" translate="yes" xml:space="preserve">
          <source>If you had to get a variable through, you could do this:</source>
          <target state="translated">Если бы тебе нужно было пропустить переменную,ты мог бы это сделать:</target>
        </trans-unit>
        <trans-unit id="67b4946ef744afdd9a1b21f685b5b8e140afa4b4" translate="yes" xml:space="preserve">
          <source>If you have</source>
          <target state="translated">Если у вас есть</target>
        </trans-unit>
        <trans-unit id="8ebbe151437cc5de6b126287c5035e996e85c741" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;http://search.cpan.org/perldoc/File::Stream&quot;&gt;File::Stream&lt;/a&gt;, this is easy.</source>
          <target state="translated">Если у вас есть &lt;a href=&quot;http://search.cpan.org/perldoc/File::Stream&quot;&gt;File :: Stream&lt;/a&gt; , это просто.</target>
        </trans-unit>
        <trans-unit id="8477c0614e083a37a8e560c57638a0b5f36ef52b" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module installed from CPAN, you can use it to fetch the width and height in characters and in pixels:</source>
          <target state="translated">Если у вас установлен модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt; из CPAN, вы можете использовать его для получения ширины и высоты в символах и пикселях:</target>
        </trans-unit>
        <trans-unit id="240e14e2dd47b4fb473147b6d297b2d7726b59cc" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;IPC::Run&lt;/code&gt; installed, and the variable &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; is set to true (See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section) use that to execute the command. You will have the full output available in buffers, interactive commands are sure to work and you are guaranteed to have your verbosity settings honored cleanly.</source>
          <target state="translated">Если у вас установлен &lt;code&gt;IPC::Run&lt;/code&gt; , а для переменной &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; установлено значение true (см. Раздел &amp;laquo; &lt;a href=&quot;#Global-Variables&quot;&gt;Глобальные переменные&lt;/a&gt; &amp;raquo;), используйте это для выполнения команды. У вас будет полный вывод, доступный в буферах, интерактивные команды обязательно будут работать, и вам гарантированно будут соблюдены ваши настройки детализации.</target>
        </trans-unit>
        <trans-unit id="b8acd2601ad065393113859c8a7e3855297ce5ac" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;man&lt;/code&gt; installed on your system, and you installed perl manpages, use something like this:</source>
          <target state="translated">Если у вас есть &lt;code&gt;man&lt;/code&gt; , установленные в вашей системе, и вы установили перл, использование Справочника что - то вроде этого:</target>
        </trans-unit>
        <trans-unit id="d6036be6bd4d2a23f70dfe8c9f989a5911198ccc" translate="yes" xml:space="preserve">
          <source>If you have Perl 5.10 or later, and you just want to store a value against the reference for lookup later, you can use the core Hash::Util::Fieldhash module. This will also handle renaming the keys if you use multiple threads (which causes all variables to be reallocated at new addresses, changing their stringification), and garbage-collecting the entries when the referenced variable goes out of scope.</source>
          <target state="translated">Если у вас есть Perl 5.10 или более поздняя версия,и вы просто хотите сохранить значение по ссылке для последующего поиска,вы можете использовать основной модуль Hash::Util::Fieldhash.Он также будет обрабатывать переименование ключей,если вы используете несколько потоков (что приводит к тому,что все переменные перераспределяются по новым адресам,изменяя их строковую спецификацию),и сбор мусора,когда ссылка на переменную выходит за пределы области видимости.</target>
        </trans-unit>
        <trans-unit id="1ff5e330b4023d9ffe19df36972bfcc73814fd9b" translate="yes" xml:space="preserve">
          <source>If you have Perl 5.10 or later, this is almost trivial. You just smart match against an array of regular expression objects:</source>
          <target state="translated">Если у вас есть Perl 5.10 или более поздняя версия,это почти тривиально.Вы просто умно сравниваете с массивом объектов регулярных выражений:</target>
        </trans-unit>
        <trans-unit id="2fe696e9056ea562cb89c9b2f102390c60db24f0" translate="yes" xml:space="preserve">
          <source>If you have Perl v5.16, the problems mentioned above go away if you use the &lt;code&gt;:not_characters&lt;/code&gt; parameter to the locale pragma (except for vendor bugs in the non-character portions). If you don't have v5.16, and you</source>
          <target state="translated">Если у вас Perl v5.16, проблемы, упомянутые выше, исчезнут, если вы используете параметр &lt;code&gt;:not_characters&lt;/code&gt; в прагме locale (за исключением ошибок поставщика в несимвольных частях). Если у вас нет v5.16, и вы</target>
        </trans-unit>
        <trans-unit id="6642f62c4bfdebf5e62452d5d72c26f1bd89b8ec" translate="yes" xml:space="preserve">
          <source>If you have YAML.pm (or some other YAML module configured in &lt;code&gt;yaml_module&lt;/code&gt; ) installed, CPAN.pm collects a few statistical data about recent downloads. You can view the statistics with the &lt;code&gt;hosts&lt;/code&gt; command or inspect them directly by looking into the &lt;code&gt;FTPstats.yml&lt;/code&gt; file in your &lt;code&gt;cpan_home&lt;/code&gt; directory.</source>
          <target state="translated">Если у вас установлен YAML.pm (или какой-либо другой модуль YAML, настроенный в &lt;code&gt;yaml_module&lt;/code&gt; ), CPAN.pm собирает некоторые статистические данные о последних загрузках. Вы можете просмотреть статистику с помощью команды &lt;code&gt;hosts&lt;/code&gt; или проверить ее напрямую, просмотрев файл &lt;code&gt;FTPstats.yml&lt;/code&gt; в каталоге &lt;code&gt;cpan_home&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="225c354ad980b0b7bb691380c5b2f0d3c2643a5a" translate="yes" xml:space="preserve">
          <source>If you have a ReadLine module installed, you can hit TAB at any point of the commandline and &lt;code&gt;o conf&lt;/code&gt; will offer you completion for the built-in subcommands and/or config variable names.</source>
          <target state="translated">Если у вас установлен модуль ReadLine, вы можете нажать TAB в любой точке командной строки, и &lt;code&gt;o conf&lt;/code&gt; предложит вам завершение для встроенных подкоманд и / или имен переменных конфигурации.</target>
        </trans-unit>
        <trans-unit id="86d2e902132f610059a158729cf105aa2e1d4e91" translate="yes" xml:space="preserve">
          <source>If you have a buffer allocated with Newx() and want to set that as the SV's value, you can use sv_usepvn_flags(). That has some requirements if you want to avoid perl re-allocating the buffer to fit the trailing NUL:</source>
          <target state="translated">Если у вас есть буфер,выделенный функцией Newx(),и вы хотите установить его в качестве значения SV,вы можете использовать функцию sv_usepvn_flags().Это имеет некоторые требования,если вы хотите избежать perl переопределения буфера для соответствия трейлинговому NUL:</target>
        </trans-unit>
        <trans-unit id="28b93e0d6dcdb9743374e046e2c50f7ec24b530d" translate="yes" xml:space="preserve">
          <source>If you have a burning desire to tell the world about your release, post an announcement to the moderated &lt;code&gt;comp.lang.perl.announce&lt;/code&gt; newsgroup.</source>
          <target state="translated">Если у вас есть горячее желание рассказать миру о своем выпуске, опубликуйте объявление в модерируемой группе новостей &lt;code&gt;comp.lang.perl.announce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ed22a427a030ed732816620f86f5c52ec466566" translate="yes" xml:space="preserve">
          <source>If you have a command-line program that does the job, you can call it in backticks to capture whatever it outputs so you can use it later:</source>
          <target state="translated">Если у вас есть программа командной строки,которая выполняет эту работу,вы можете вызывать ее на черных метках,чтобы захватить все,что она выдает,чтобы позже использовать ее:</target>
        </trans-unit>
        <trans-unit id="aabc7446c5d3e0c2ebc9233bf601a7899d673f9d" translate="yes" xml:space="preserve">
          <source>If you have a commit bit, please see &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; for more details on using git.</source>
          <target state="translated">Если у вас есть бит фиксации, см. &lt;a href=&quot;perlgit&quot;&gt;Perlgit&lt;/a&gt; для получения дополнительных сведений об использовании git.</target>
        </trans-unit>
        <trans-unit id="392daf22cd236f28ba9ceee336856176b759059d" translate="yes" xml:space="preserve">
          <source>If you have a complicated function needed to pull out the part you want to sort on, then don't do it inside the sort function. Pull it out first, because the sort BLOCK can be called many times for the same element. Here's an example of how to pull out the first word after the first number on each item, and then sort those words case-insensitively.</source>
          <target state="translated">Если у вас есть сложная функция,необходимая для извлечения детали,которую вы хотите отсортировать,то не делайте этого внутри функции сортировки.Вытяните его первым,потому что сортировка BLOCK может быть вызвана много раз для одного и того же элемента.Вот пример того,как вытащить первое слово после первого числа на каждом элементе,а затем сортировать эти слова без учета регистра.</target>
        </trans-unit>
        <trans-unit id="b0e6b3bda8c96c33f56e6b729af6c8286cbfdc17" translate="yes" xml:space="preserve">
          <source>If you have a legacy encoding, you can use the &lt;code&gt;:encoding(...)&lt;/code&gt; tag.</source>
          <target state="translated">Если у вас устаревшая кодировка, вы можете использовать тег &lt;code&gt;:encoding(...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01656c2b4f7ea5f69bae8d5caaac9ea48410bb3e" translate="yes" xml:space="preserve">
          <source>If you have a library that provides an API, you can make any component of it available as just another Perl function or variable using a Perl extension written in C or C++ and dynamically linked into your main perl interpreter. You can also go the other direction, and write your main program in C or C++, and then link in some Perl code on the fly, to create a powerful application. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">Если у вас есть библиотека, предоставляющая API, вы можете сделать любой ее компонент доступным как просто другую функцию или переменную Perl, используя расширение Perl, написанное на C или C ++ и динамически связанное с вашим основным интерпретатором Perl. Вы также можете пойти в другом направлении и написать свою основную программу на C или C ++, а затем &amp;laquo;на лету&amp;raquo; связать некоторый код Perl, чтобы создать мощное приложение. См. &lt;a href=&quot;perlembed&quot;&gt;Perlembed&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51f9e3f6122598346b767c490154d73f3d45b4f6" translate="yes" xml:space="preserve">
          <source>If you have a list of tests (or URLs, or anything else you want to test) in a file, you can add them to your tests by using a '-':</source>
          <target state="translated">Если у вас есть список тестов (или URL,или что-нибудь еще,что вы хотите проверить)в файле,вы можете добавить их в свои тесты,используя '-':</target>
        </trans-unit>
        <trans-unit id="a1add680b7e930dc8542127166a2c6922328bade" translate="yes" xml:space="preserve">
          <source>If you have a local mirror of CPAN and can access all files with &quot;file:&quot; URLs, then you only need a perl later than perl5.003 to run this module. Otherwise Net::FTP is strongly recommended. LWP may be required for non-UNIX systems, or if your nearest CPAN site is associated with a URL that is not &lt;code&gt;ftp:&lt;/code&gt; .</source>
          <target state="translated">Если у вас есть локальное зеркало CPAN и вы можете получить доступ ко всем файлам с URL-адресами &quot;file:&quot;, то для запуска этого модуля вам понадобится только Perl более поздняя, ​​чем perl5.003. В противном случае настоятельно рекомендуется использовать Net :: FTP. LWP может потребоваться для систем, отличных от UNIX, или если ваш ближайший сайт CPAN связан с URL-адресом, который не является &lt;code&gt;ftp:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c6b091f1c2f3916b6f982ec5d76127aba417742" translate="yes" xml:space="preserve">
          <source>If you have a question you'd like to see added to the FAQ (whether or not you have the answer) please send it to makemaker@perl.org.</source>
          <target state="translated">Если у вас есть вопрос,который вы хотели бы видеть добавленным в FAQ (независимо от того,есть ли у вас ответ),пожалуйста,отправьте его по адресу makemaker@perl.org.</target>
        </trans-unit>
        <trans-unit id="883ef441e28a9d839f80a61f11348168ebf17cd9" translate="yes" xml:space="preserve">
          <source>If you have a raw sequence of bytes that you know should be interpreted via a particular encoding, you can use &lt;code&gt;Encode&lt;/code&gt; :</source>
          <target state="translated">Если у вас есть необработанная последовательность байтов, которую, как вы знаете, следует интерпретировать с помощью определенной кодировки, вы можете использовать &lt;code&gt;Encode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4977b6a1b7796edc98abe66364bdbf5af8c6caa8" translate="yes" xml:space="preserve">
          <source>If you have a really hairy regular expression, use the &lt;code&gt;/x&lt;/code&gt; modifier and put in some whitespace to make it look a little less like line noise. Don't use slash as a delimiter when your regexp has slashes or backslashes.</source>
          <target state="translated">Если у вас действительно сложное регулярное выражение, используйте модификатор &lt;code&gt;/x&lt;/code&gt; и вставьте немного пробелов, чтобы оно выглядело менее похожим на линейный шум. Не используйте косую черту в качестве разделителя, если в вашем регулярном выражении есть косая черта или обратная косая черта.</target>
        </trans-unit>
        <trans-unit id="c4670adaa2657eda2badbded5180916956105a77" translate="yes" xml:space="preserve">
          <source>If you have a sequence of bytes you &lt;b&gt;know&lt;/b&gt; is valid UTF-8, but Perl doesn't know it yet, you can make Perl a believer, too:</source>
          <target state="translated">Если у вас есть последовательность байтов, которая, как вы &lt;b&gt;знаете,&lt;/b&gt; является допустимой UTF-8, но Perl ее еще не знает, вы также можете сделать Perl верующим:</target>
        </trans-unit>
        <trans-unit id="9756e7acda84539ead2e5f85f560f283b75aed93" translate="yes" xml:space="preserve">
          <source>If you have a single string that you want to check for &quot;equality in locale&quot; against several others, you might think you could gain a little efficiency by using &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; in conjunction with &lt;code&gt;eq&lt;/code&gt; :</source>
          <target state="translated">Если у вас есть одна строка, которую вы хотите проверить на &amp;laquo;равенство в локали&amp;raquo; с несколькими другими, вы можете подумать, что можете немного повысить эффективность, используя &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; в сочетании с &lt;code&gt;eq&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f645dc4bb8034c3799b831d6996356797ca7be48" translate="yes" xml:space="preserve">
          <source>If you have a small patch to submit, please submit it via perlbug. You can also send email directly to perlbug@perl.org. Please note that messages sent to perlbug may be held in a moderation queue, so you won't receive a response immediately.</source>
          <target state="translated">Если у вас есть небольшой патч,пожалуйста,отправьте его через perlbug.Вы также можете отправить его непосредственно по электронной почте по адресу perlbug@perl.org.Пожалуйста,обратите внимание,что сообщения,отправленные perlbug,могут находиться в очереди модерации,поэтому вы не получите ответа сразу же.</target>
        </trans-unit>
        <trans-unit id="42845d8c8c875f89de9dd2d1b7586e0d3ad16bc8" translate="yes" xml:space="preserve">
          <source>If you have a specific romanization scheme in mind, use the specific module:</source>
          <target state="translated">Если вы имеете в виду конкретную схему романтизации,используйте конкретный модуль:</target>
        </trans-unit>
        <trans-unit id="fb355db0f3f4b40524a1c3ff445d923be623d546" translate="yes" xml:space="preserve">
          <source>If you have a working &lt;code&gt;DynaLoader&lt;/code&gt; then there is rarely any need to statically link in any other extensions.</source>
          <target state="translated">Если у вас есть работающий &lt;code&gt;DynaLoader&lt;/code&gt; , то редко возникает необходимость в статической компоновке любых других расширений.</target>
        </trans-unit>
        <trans-unit id="fd5f81af8a4a7363d6132316fb90657fc9d4e232" translate="yes" xml:space="preserve">
          <source>If you have a zip file that contains multiple members and want to read a specific member from the file, say &lt;code&gt;&quot;data1&quot;&lt;/code&gt; , use the &lt;code&gt;Name&lt;/code&gt; option</source>
          <target state="translated">Если у вас есть почтовый файл , который содержит несколько членов и хотят , чтобы прочитать элемент конкретного из файла, скажем , &lt;code&gt;&quot;data1&quot;&lt;/code&gt; , используйте &lt;code&gt;Name&lt;/code&gt; опцию</target>
        </trans-unit>
        <trans-unit id="e8e60773a7086adcadd9997f1e4e60bf13f42c27" translate="yes" xml:space="preserve">
          <source>If you have an FTP proxy firewall (&lt;b&gt;NOT&lt;/b&gt; an HTTP or SOCKS firewall) then this value should be set to the firewall hostname. If your firewall does not listen to port 21, then this value should be set to &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; (eg &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; )</source>
          <target state="translated">Если у вас есть брандмауэр FTP-прокси ( &lt;b&gt;НЕ&lt;/b&gt; брандмауэр HTTP или SOCKS), тогда в этом значении должно быть указано имя хоста брандмауэра. Если ваш брандмауэр не прослушивает порт 21, тогда это значение должно быть установлено на &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; (например, &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3a37d9c6262b12c7aa2b49bfbcebb4a375757d2e" translate="yes" xml:space="preserve">
          <source>If you have an SV and want to know what kind of data Perl thinks is stored in it, you can use the following macros to check the type of SV you have.</source>
          <target state="translated">Если у вас есть SV и вы хотите знать,какие данные,по мнению Perl,хранятся в нем,вы можете использовать следующие макросы для проверки типа SV,который у вас есть.</target>
        </trans-unit>
        <trans-unit id="2bc4f67186bf30ca57f017f1cea8612b943dd146" translate="yes" xml:space="preserve">
          <source>If you have an array of &lt;code&gt;@string&lt;/code&gt; that should be concatenated and then normalized, you can do like this:</source>
          <target state="translated">Если у вас есть массив &lt;code&gt;@string&lt;/code&gt; , который нужно объединить , а затем нормализовать, вы можете сделать следующее:</target>
        </trans-unit>
        <trans-unit id="403ab04dd713d2cfe6f16d5487fb0193f691f18c" translate="yes" xml:space="preserve">
          <source>If you have an empty directory, you can use Perl's built-in &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt;. If the directory is not empty (so, no files or subdirectories), you either have to empty it yourself (a lot of work) or use a module to help you.</source>
          <target state="translated">Если у вас пустой каталог, вы можете использовать встроенный в Perl &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; . Если каталог не пустой (то есть нет файлов или подкаталогов), вам придется либо очистить его самостоятельно (много работы), либо использовать модуль, который вам поможет.</target>
        </trans-unit>
        <trans-unit id="6898ea8c69aa4a0ff2b81092a3457a58f7bdc010" translate="yes" xml:space="preserve">
          <source>If you have an existing inside-out class, simply making all hashes field hashes with no other change should make no difference. Through the calls to &lt;code&gt;refaddr&lt;/code&gt; or equivalent, the field hashes never get to see a reference and work like normal hashes. Your DESTROY (and CLONE) methods are still needed.</source>
          <target state="translated">Если у вас есть существующий класс наизнанку, простое создание хэшей всех полей без каких-либо других изменений не должно иметь никакого значения. Посредством вызовов &lt;code&gt;refaddr&lt;/code&gt; или аналогичного хэши полей никогда не видят ссылку и работают как обычные хэши. Ваши методы DESTROY (и CLONE) по-прежнему необходимы.</target>
        </trans-unit>
        <trans-unit id="03fcf475306c60d974596613b76c03a9f344e66a" translate="yes" xml:space="preserve">
          <source>If you have an older version of Perl, the &lt;code&gt;$^W&lt;/code&gt; variable (documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;) controls runtime warnings for a block:</source>
          <target state="translated">Если у вас более старая версия Perl, переменная &lt;code&gt;$^W&lt;/code&gt; (задокументированная в &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; ) управляет предупреждениями во время выполнения для блока:</target>
        </trans-unit>
        <trans-unit id="55ec04844d40449455953b5a185c6050647bf370" translate="yes" xml:space="preserve">
          <source>If you have any other characters you need to escape, please install the &lt;code&gt;URI::Escape&lt;/code&gt; module from CPAN, and pre-encode your URI before passing it to &lt;code&gt;File::Fetch&lt;/code&gt; . You can read about the details of URIs and URI encoding here:</source>
          <target state="translated">Если у вас есть другие символы, которые нужно экранировать, установите модуль &lt;code&gt;URI::Escape&lt;/code&gt; из CPAN и предварительно закодируйте свой URI перед его передачей в &lt;code&gt;File::Fetch&lt;/code&gt; . Вы можете прочитать о деталях URI и кодировки URI здесь:</target>
        </trans-unit>
        <trans-unit id="59ef038a12de814aa0cdf806e88e5a326fdaf2d5" translate="yes" xml:space="preserve">
          <source>If you have any suggested changes for this page, let me know. Please don't send me mail asking for help on how to install your modules. There are too many modules, and too few Orwants, for me to be able to answer or even acknowledge all your questions. Contact the module author instead, or post to comp.lang.perl.modules, or ask someone familiar with Perl on your operating system.</source>
          <target state="translated">Если у вас есть какие-нибудь предложенные изменения для этой страницы,дайте мне знать.Пожалуйста,не присылайте мне письма с просьбой о помощи в установке ваших модулей.Слишком много модулей и слишком мало Orwants,чтобы я мог ответить или даже подтвердить все ваши вопросы.Вместо этого свяжитесь с автором модуля,или отправьте сообщение по адресу comp.lang.perl.modules,или спросите кого-нибудь,кто знаком с Perl в вашей операционной системе.</target>
        </trans-unit>
        <trans-unit id="e2545920681caa56966e901dca47f4688bdb95ac" translate="yes" xml:space="preserve">
          <source>If you have built this module with zlib &amp;gt;= 1.2.0, the &lt;code&gt;$eof&lt;/code&gt; parameter is ignored. You can still set it if you want, but it won't be used behind the scenes.</source>
          <target state="translated">Если вы создали этот модуль с zlib&amp;gt; = 1.2.0, параметр &lt;code&gt;$eof&lt;/code&gt; игнорируется. Вы все равно можете установить его, если хотите, но он не будет использоваться за кадром.</target>
        </trans-unit>
        <trans-unit id="bd7c754383786ab750ba8d8b8b5b2710b62cfc9e" translate="yes" xml:space="preserve">
          <source>If you have built this module with zlib 1.2.3 or better, two more CRC-related functions are available.</source>
          <target state="translated">Если вы создали этот модуль с zlib 1.2.3 или лучше,то доступны еще две CRC-функции.</target>
        </trans-unit>
        <trans-unit id="b49d178439aabd6902535000d809a8c4d8c6c0d0" translate="yes" xml:space="preserve">
          <source>If you have compile-time executable statements (such as code within BEGIN, UNITCHECK and CHECK blocks or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statements), these will</source>
          <target state="translated">Если у вас есть исполняемые операторы времени компиляции (например, код в блоках BEGIN, UNITCHECK и CHECK или операторы &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ), они будут</target>
        </trans-unit>
        <trans-unit id="4a053828197d3de496e658e2f64e31f462c0e7ce" translate="yes" xml:space="preserve">
          <source>If you have experience with other thread implementations, you might find that things aren't quite what you expect. It's very important to remember when dealing with Perl threads that</source>
          <target state="translated">Если у вас есть опыт работы с другими потоковыми реализациями,вы можете обнаружить,что все не совсем так,как вы ожидали.Очень важно помнить,когда имеешь дело с потоками Perl,что</target>
        </trans-unit>
        <trans-unit id="0ffa35b58c4462159f2ea02872365ed984d54889" translate="yes" xml:space="preserve">
          <source>If you have found a bug with a non-standard port (one that was not part of the</source>
          <target state="translated">Если вы нашли ошибку с нестандартным портом (тот,который не был частью</target>
        </trans-unit>
        <trans-unit id="0e1af930aa8bf951949bff6fef33b900fd538735" translate="yes" xml:space="preserve">
          <source>If you have generated such a statically-linked executable by choice, then instead of saying &quot;&lt;code&gt;make test&lt;/code&gt; &quot;, you should say &quot;&lt;code&gt;make test_static&lt;/code&gt; &quot;. On systems that cannot build dynamically-loadable libraries at all, simply saying &quot;&lt;code&gt;make test&lt;/code&gt; &quot; is sufficient.</source>
          <target state="translated">Если вы по своему выбору сгенерировали такой статически связанный исполняемый файл, то вместо того, чтобы сказать &amp;laquo; &lt;code&gt;make test&lt;/code&gt; &amp;raquo;, вы должны сказать &amp;laquo; &lt;code&gt;make test_static&lt;/code&gt; &amp;raquo;. В системах, которые вообще не могут создавать динамически загружаемые библиотеки, достаточно просто сказать &amp;laquo; &lt;code&gt;make test&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ea57a23a75f969a9e5ed037d598a374a300583a4" translate="yes" xml:space="preserve">
          <source>If you have gotten this far into the tutorial, you can probably guess what the different parts of the debugging output tell you. The first part</source>
          <target state="translated">Если вы зашли так далеко в учебник,вы,вероятно,можете догадаться,о чем говорят различные части отладочного вывода.Первая часть</target>
        </trans-unit>
        <trans-unit id="9d264a66a026ef716495bcfe67d5b82c2fd75d79" translate="yes" xml:space="preserve">
          <source>If you have installed a signal handler for &lt;code&gt;SIGCHLD&lt;/code&gt; , the value of &lt;code&gt;$?&lt;/code&gt; will usually be wrong outside that handler.</source>
          <target state="translated">Если вы установили обработчик сигналов для &lt;code&gt;SIGCHLD&lt;/code&gt; , значение &lt;code&gt;$?&lt;/code&gt; обычно будет ошибаться вне этого обработчика.</target>
        </trans-unit>
        <trans-unit id="d59e8efecc586326d2ab32c89e976a471be555e8" translate="yes" xml:space="preserve">
          <source>If you have installed extra libraries such as GDBM through Fink (in other words, you have libraries under</source>
          <target state="translated">Если вы установили дополнительные библиотеки,такие как GDBM через Fink (другими словами,у вас есть библиотеки в разделе</target>
        </trans-unit>
        <trans-unit id="adf0535478f796f8c19ba9c98c90186d9fd4978f" translate="yes" xml:space="preserve">
          <source>If you have more than two files, this is the place where you should boot extra XS files from.</source>
          <target state="translated">Если у вас более двух файлов,то это место,откуда вы должны загрузить дополнительные XS-файлы.</target>
        </trans-unit>
        <trans-unit id="47f402ce95a3894708d131d4f57afb65a8408c3a" translate="yes" xml:space="preserve">
          <source>If you have neither Net::FTP nor LWP, there is a fallback mechanism implemented for an external ftp command or for an external lynx command.</source>
          <target state="translated">Если у вас нет Net::FTP или LWP,то существует механизм отката,реализованный для внешней команды ftp или для внешней команды lynx.</target>
        </trans-unit>
        <trans-unit id="24c715fba81da2278914f96579f9af2c125fe732" translate="yes" xml:space="preserve">
          <source>If you have never been to a hackathon, here are a few basic things you need to know before attending: have a working laptop and know how to use it; check out the involved projects beforehand; have the necessary version control client; and bring backup equipment (an extra LAN cable, additional power strips, etc.) because someone will forget.</source>
          <target state="translated">Если вы никогда не были в хакафоне,вот несколько основных вещей,которые вам нужно знать перед посещением:иметь рабочий ноутбук и знать,как им пользоваться;заранее проверять участвующие проекты;иметь необходимого клиента для контроля версий;приносить оборудование для резервного копирования (дополнительный LAN-кабель,дополнительные разветвители питания и т.д.),потому что кто-нибудь забудет.</target>
        </trans-unit>
        <trans-unit id="1eb2a3bd6bb2269e089bc5caced075f60ca01d0a" translate="yes" xml:space="preserve">
          <source>If you have never defined your own &lt;code&gt;urllist&lt;/code&gt; in your configuration then &lt;code&gt;CPAN.pm&lt;/code&gt; will be hesitant to use the built in default sites for downloading. It will ask you once per session if a connection to the internet is OK and only if you say yes, it will try to connect. But to avoid this question, you can choose your favorite download sites once and get away with it. Or, if you have no favorite download sites answer yes to the following question.</source>
          <target state="translated">Если вы никогда не определяли свой собственный &lt;code&gt;urllist&lt;/code&gt; в своей конфигурации, то &lt;code&gt;CPAN.pm&lt;/code&gt; не решится использовать встроенные сайты по умолчанию для загрузки. Он будет спрашивать вас один раз за сеанс, в порядке ли подключение к Интернету, и только если вы ответите &amp;laquo;да&amp;raquo;, он попытается подключиться. Но чтобы избежать этого вопроса, вы можете один раз выбрать свои любимые сайты для загрузки и уйти от этого. Или, если у вас нет любимых сайтов загрузки, ответьте утвердительно на следующий вопрос.</target>
        </trans-unit>
        <trans-unit id="7a84d97dce110800ef0a7f4d11d992d7a0415274" translate="yes" xml:space="preserve">
          <source>If you have never uploaded a module to CPAN before (and even if you have), you are strongly encouraged to get feedback on &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fprepan.org&quot;&gt;PrePAN&lt;/a&gt;. PrePAN is a site dedicated to discussing ideas for CPAN modules with other Perl developers and is a great resource for new (and experienced) Perl developers.</source>
          <target state="translated">Если вы никогда раньше не загружали модуль в CPAN (и даже если у вас есть), мы настоятельно рекомендуем вам получить отзывы о &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fprepan.org&quot;&gt;PrePAN&lt;/a&gt; . PrePAN - это сайт, посвященный обсуждению идей для модулей CPAN с другими разработчиками Perl, и это отличный ресурс для новых (и опытных) разработчиков Perl.</target>
        </trans-unit>
        <trans-unit id="eb6ae544b0243a12b93b26e3f0b3956b5515717f" translate="yes" xml:space="preserve">
          <source>If you have one of the readline packages (Term::ReadLine::Perl, Term::ReadLine::Gnu, possibly others) installed, the interactive CPAN shell will have history support. The next two questions deal with the filename of the history file and with its size. If you do not want to set this variable, please hit SPACE ENTER to the following question.</source>
          <target state="translated">Если у вас установлен один из пакетов readline (Term::ReadLine::Perl,Term::ReadLine::Gnu,возможно другие),интерактивная оболочка CPAN будет иметь поддержку истории.Следующие два вопроса касаются имени файла истории и его размера.Если вы не хотите задавать эту переменную,пожалуйста,нажмите SPACE ENTER в следующем вопросе.</target>
        </trans-unit>
        <trans-unit id="bb7b55bdb52c9b6a39041d0271244a521cb3ff47" translate="yes" xml:space="preserve">
          <source>If you have perl documentation in the source form, perl utilities installed, and GNU groff installed, you may use</source>
          <target state="translated">Если у вас установлена документация на perl в виде исходных текстов,утилиты на perl и GNU groff,вы можете использовать</target>
        </trans-unit>
        <trans-unit id="841004095d25b3d59f531a821f770d0871403ca9" translate="yes" xml:space="preserve">
          <source>If you have previously used &lt;code&gt;Compress::Zlib&lt;/code&gt; 1.x, the following enhancements/changes have been made to the &lt;code&gt;gzopen&lt;/code&gt; interface:</source>
          <target state="translated">Если вы ранее использовали &lt;code&gt;Compress::Zlib&lt;/code&gt; 1.x, в интерфейс &lt;code&gt;gzopen&lt;/code&gt; были внесены следующие улучшения / изменения :</target>
        </trans-unit>
        <trans-unit id="d2a37b8d2199c6cd81ec323e698311d35b1e6c13" translate="yes" xml:space="preserve">
          <source>If you have problems with dynamic loading using gcc on SunOS or Solaris, and you are using GNU as and GNU ld, see the section &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as and GNU ld&lt;/a&gt; above.</source>
          <target state="translated">Если у вас есть проблемы с динамической загрузкой с использованием gcc в SunOS или Solaris, и вы используете GNU as и GNU ld, см. Раздел &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as и GNU ld&lt;/a&gt; выше.</target>
        </trans-unit>
        <trans-unit id="ea5710225473b92c4d4337a393fa28ea045d7828" translate="yes" xml:space="preserve">
          <source>If you have questions about DJGPP, try posting to the DJGPP newsgroup: comp.os.msdos.djgpp, or use the email gateway djgpp@delorie.com.</source>
          <target state="translated">Если у вас есть вопросы по DJGPP,попробуйте отправить их в группу новостей DJGPP:comp.os.msdos.djgpp,или воспользуйтесь почтовым шлюзом djgpp@delorie.com.</target>
        </trans-unit>
        <trans-unit id="fe0f8d11e3dbd4746ff7b4eeb245a0d52d534f6e" translate="yes" xml:space="preserve">
          <source>If you have questions, I will be happy to answer them if you send them to mjd-perl-memoize+@plover.com.</source>
          <target state="translated">Если у вас есть вопросы,я буду рад ответить на них,если вы отправите их на mjd-perl-memoize+@plover.com.</target>
        </trans-unit>
        <trans-unit id="f26f03ce6e7bfe1cbb7f3ba37413ced07d1e0917" translate="yes" xml:space="preserve">
          <source>If you have read this far, congratulations! You now have all the basic tools needed to use regular expressions to solve a wide range of text processing problems. If this is your first time through the tutorial, why not stop here and play around with regexps a while.... Part 2 concerns the more esoteric aspects of regular expressions and those concepts certainly aren't needed right at the start.</source>
          <target state="translated">Если вы так далеко прочитали,поздравляю! Теперь у вас есть все основные инструменты,необходимые для использования регулярных выражений для решения широкого спектра задач по обработке текста.Если вы впервые читаете учебник,почему бы не остановиться на этом и не поиграть с регэкспо на время......Часть 2 касается более эзотерических аспектов регулярных выражений,и эти понятия,конечно же,не нужны с самого начала.</target>
        </trans-unit>
        <trans-unit id="75f3eda9f9b422ec46068b583597695f9e1e075d" translate="yes" xml:space="preserve">
          <source>If you have some WWW browser available, installed the Perl documentation in the source form, and Perl utilities, you can build HTML docs. Cd to directory with</source>
          <target state="translated">Если у вас есть какой-нибудь WWW-браузер,установлена Perl-документация в исходной форме,а также Perl-утилиты,вы можете собрать HTML-документы.Cd в каталог с</target>
        </trans-unit>
        <trans-unit id="15919d939102f998b0d1a3071b0bdc4ec9361810" translate="yes" xml:space="preserve">
          <source>If you have some WWW browser available, you can build &lt;b&gt;HTML&lt;/b&gt; docs. Cd to directory with</source>
          <target state="translated">Если у вас есть доступный WWW-браузер, вы можете создавать &lt;b&gt;HTML-&lt;/b&gt; документы. Cd в каталог с</target>
        </trans-unit>
        <trans-unit id="760a427c6aacab9e74e50c0e342e67f06ea0a89d" translate="yes" xml:space="preserve">
          <source>If you have some working code for &lt;code&gt;OS2::Cmd&lt;/code&gt; , please send it to me, I will include it into distribution. I have no need for such a module, so cannot test it.</source>
          <target state="translated">Если у вас есть рабочий код для &lt;code&gt;OS2::Cmd&lt;/code&gt; , пришлите его мне, я включу его в дистрибутив. Такой модуль мне не нужен, поэтому не могу его протестировать.</target>
        </trans-unit>
        <trans-unit id="c766c1d4e406f5a8fab49e64104f5bd544a7e67b" translate="yes" xml:space="preserve">
          <source>If you have test cases that fail, check for the existence of spool files. The test case may be trying to use a syscall that is not implemented in PASE. To avoid the SIGILL, try setting the PASE_SYSCALL_NOSIGILL environment variable or have a handler for the SIGILL. If you can compile programs for PASE, run the config script and edit config.sh when it gives you the option. If you want to remove fchdir(), which isn't implement in V5R1, simply change the line that says:</source>
          <target state="translated">Если у вас есть неудачные тестовые случаи,проверьте наличие катушечных файлов.Тестовым случаем может быть попытка использовать syscall,который не реализован в PASE.Чтобы избежать SIGILL,попробуйте установить переменную окружения PASE_SYSCALL_NOSIGILL или иметь обработчик для SIGILL.Если вы можете скомпилировать программы для PASE,запустите скрипт config и отредактируйте config.sh,когда он даст вам возможность.Если вы хотите удалить fchdir(),которая не реализована в V5R1,просто измените строку с надписью:</target>
        </trans-unit>
        <trans-unit id="c895956df28d2a0d520a665ed39e5054b694f69f" translate="yes" xml:space="preserve">
          <source>If you have the &lt;code&gt;Kwalify&lt;/code&gt; module installed (which is part of the Bundle::CPANxxl), then all your distroprefs files are checked for syntactic correctness.</source>
          <target state="translated">Если у вас установлен модуль &lt;code&gt;Kwalify&lt;/code&gt; (который является частью Bundle :: CPANxxl), то все ваши файлы distroprefs проверяются на синтаксическую корректность.</target>
        </trans-unit>
        <trans-unit id="310e2cf6fe93a96344e5f48617c55b650052b357" translate="yes" xml:space="preserve">
          <source>If you have the &lt;code&gt;uncompress&lt;/code&gt; program available, you can use this to read compressed files</source>
          <target state="translated">Если у вас есть программа &lt;code&gt;uncompress&lt;/code&gt; , вы можете использовать ее для чтения сжатых файлов.</target>
        </trans-unit>
        <trans-unit id="a48f13710ced892050924fc9519945fba0fac1d0" translate="yes" xml:space="preserve">
          <source>If you have the GNU's version of &lt;b&gt;emacs&lt;/b&gt; installed on your system, it can interact with the Perl debugger to provide an integrated software development environment reminiscent of its interactions with C debuggers.</source>
          <target state="translated">Если в вашей системе установлена версия &lt;b&gt;emacs&lt;/b&gt; от GNU , она может взаимодействовать с отладчиком Perl, чтобы обеспечить интегрированную среду разработки программного обеспечения, напоминающую ее взаимодействие с отладчиками C.</target>
        </trans-unit>
        <trans-unit id="831bd1aa0f0b4a83cdb4f8d8c798aaee5e24ba5d" translate="yes" xml:space="preserve">
          <source>If you have the LD_LIBRARY_PATH environment variable set, be sure that it does NOT include /lib or /usr/lib. If you will be building extensions that call third-party shared libraries (e.g. Berkeley DB) then make sure that your LD_LIBRARY_PATH environment variable includes the directory with that library (e.g. /usr/local/lib).</source>
          <target state="translated">Если у вас установлена переменная окружения LD_LIBRARY_PATH,убедитесь,что она НЕ включает /lib или /usr/lib.Если вы будете собирать расширения,вызывающие разделяемые библиотеки сторонних производителей (например,Berkeley DB),то убедитесь,что переменная окружения LD_LIBRARY_PATH включает каталог с этой библиотекой (например,/usr/local/lib).</target>
        </trans-unit>
        <trans-unit id="7b99419c67def721d2695cd48d34dc88cb8c781c" translate="yes" xml:space="preserve">
          <source>If you have to deal with a lot of C structures, and don't want to hack all your template strings manually, you'll probably want to have a look at the CPAN module &lt;code&gt;Convert::Binary::C&lt;/code&gt; . Not only can it parse your C source directly, but it also has built-in support for all the odds and ends described further on in this section.</source>
          <target state="translated">Если вам приходится иметь дело с большим количеством структур C, и не хотят , чтобы взломать все строки шаблонов вручную, вы , вероятно , хотите взглянуть на модуль CPAN &lt;code&gt;Convert::Binary::C&lt;/code&gt; . Он не только может анализировать ваш исходный код напрямую, но также имеет встроенную поддержку для всех нюансов, описанных далее в этом разделе.</target>
        </trans-unit>
        <trans-unit id="fedff50b6bdfc3eaf8ccc29c03df5c84e0ff6a06" translate="yes" xml:space="preserve">
          <source>If you have trouble compiling the scripts in this documentation, you're not alone. The cardinal rule: COMPILE THE PROGRAMS IN EXACTLY THE SAME WAY THAT YOUR PERL WAS COMPILED. (Sorry for yelling.)</source>
          <target state="translated">Если у вас возникли проблемы с компиляцией скриптов в этой документации,вы не одиноки.Главное правило:КОМПИЛИРУЙТЕ ПРОГРАММЫ ТОЧНО ТАК ЖЕ,КАК БЫЛ СКОМПИЛИРОВАН ВАШ ПЕРЛ.(Извините за крики.)</target>
        </trans-unit>
        <trans-unit id="899489485e48eb6acab0142eabbf325712e8b44a" translate="yes" xml:space="preserve">
          <source>If you have updated your Solaris version, you may also have to update your gcc. For example, if you are running Solaris 2.6 and your gcc is installed under /usr/local, check in /usr/local/lib/gcc-lib and make sure you have the appropriate directory, sparc-sun-solaris2.6/ or i386-pc-solaris2.6/. If gcc's directory is for a different version of Solaris than you are running, then you will need to rebuild gcc for your new version of Solaris.</source>
          <target state="translated">Если Вы обновили свою версию Solaris,возможно,Вам также придется обновить свой gcc.Например,если Вы используете Solaris 2.6 и Ваш gcc установлен в /usr/local,проверьте /usr/local/lib/gcc-lib и убедитесь,что у Вас есть соответствующий каталог,sparc-sun-solaris2.6/или i386-pc-solaris2.6/.Если каталог gcc для другой версии Solaris,чем Вы используете,то Вам нужно будет пересобрать gcc для Вашей новой версии Solaris.</target>
        </trans-unit>
        <trans-unit id="d44abb6ca108f95533f7bd86193633f514940a80" translate="yes" xml:space="preserve">
          <source>If you have your perl compiled for debugging (usually done with &lt;code&gt;-DDEBUGGING&lt;/code&gt; on the &lt;code&gt;Configure&lt;/code&gt; command line), you may examine the compiled tree by specifying &lt;code&gt;-Dx&lt;/code&gt; on the Perl command line. The output takes several lines per node, and for &lt;code&gt;$b+$c&lt;/code&gt; it looks like this:</source>
          <target state="translated">Если ваш perl скомпилирован для отладки (обычно это делается с помощью &lt;code&gt;-DDEBUGGING&lt;/code&gt; в командной строке &lt;code&gt;Configure&lt;/code&gt; ), вы можете проверить скомпилированное дерево, указав &lt;code&gt;-Dx&lt;/code&gt; в командной строке Perl. Вывод занимает несколько строк на узел, и для &lt;code&gt;$b+$c&lt;/code&gt; это выглядит так:</target>
        </trans-unit>
        <trans-unit id="4be3c9c74002e27258a38e4f113b05f31396c7de" translate="yes" xml:space="preserve">
          <source>If you haven't already guessed, the location string is stored with a terminating NULL. This means you need to be careful when accessing the database.</source>
          <target state="translated">Если вы еще не догадались,то строка расположения хранится с завершающим NULL.Это означает,что вы должны быть осторожны при доступе к базе данных.</target>
        </trans-unit>
        <trans-unit id="f0a36e2858858b02958d2f9bb2e7a02778b6e7c8" translate="yes" xml:space="preserve">
          <source>If you haven't already, before reading this document, you should become familiar with both &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; and &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">Если вы еще этого не сделали, перед чтением этого документа вам следует ознакомиться как с &lt;a href=&quot;perlunitut&quot;&gt;perlunitut, так&lt;/a&gt; и с &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f5cd5895b74e660a355a89bb89cfe0d64a65e68" translate="yes" xml:space="preserve">
          <source>If you haven't read &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; and &lt;a href=&quot;perlhacktut&quot;&gt;perlhacktut&lt;/a&gt; yet, you might want to do that first.</source>
          <target state="translated">Если вы еще не читали &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; и &lt;a href=&quot;perlhacktut&quot;&gt;perlhacktut&lt;/a&gt; , возможно, вы захотите это сделать в первую очередь.</target>
        </trans-unit>
        <trans-unit id="9d18cc6d1bb045c22ff75a5143e7edc7882d3f36" translate="yes" xml:space="preserve">
          <source>If you haven't read &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; yet, go do that first! You might also want to read through &lt;a href=&quot;perlsource&quot;&gt;perlsource&lt;/a&gt; too.</source>
          <target state="translated">Если вы еще не читали &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; , сделайте это в первую очередь! Вы также можете прочитать &lt;a href=&quot;perlsource&quot;&gt;perlsource&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c78c6e524a1994f83a33a6fe7a18f30be9a7fce" translate="yes" xml:space="preserve">
          <source>If you haven't used regular expressions before, a quick-start introduction is available in &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;, and a longer tutorial introduction is available in &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;.</source>
          <target state="translated">Если вы раньше не использовали регулярные выражения, в &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt; доступно краткое введение , а в perlretut - более &lt;a href=&quot;perlretut&quot;&gt;подробное введение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a7a1d83ca677617a38c3a7af6a10c7ed341f9e8" translate="yes" xml:space="preserve">
          <source>If you haven't yet moved &lt;code&gt;perl*.dll&lt;/code&gt; onto LIBPATH, do it now.</source>
          <target state="translated">Если вы еще не переместили &lt;code&gt;perl*.dll&lt;/code&gt; в LIBPATH, сделайте это сейчас.</target>
        </trans-unit>
        <trans-unit id="83593b846f63af31e001bdf82839b9a46da47025" translate="yes" xml:space="preserve">
          <source>If you ignore all the error checking that most of the code does, the essence of the filter is as follows:</source>
          <target state="translated">Если проигнорировать все проверки на ошибки,которые делает большинство кода,то суть фильтра заключается в следующем:</target>
        </trans-unit>
        <trans-unit id="4660b183b00b39c6b2b92484fb7503359beb8635" translate="yes" xml:space="preserve">
          <source>If you import &lt;code&gt;:constants256&lt;/code&gt; , you can use the following constants directly:</source>
          <target state="translated">Если вы импортируете &lt;code&gt;:constants256&lt;/code&gt; , вы можете напрямую использовать следующие константы:</target>
        </trans-unit>
        <trans-unit id="f87b608eeb1cdc6eb4d8977d4b889a03e6d083dd" translate="yes" xml:space="preserve">
          <source>If you intend making use of the object returned from either tie() or tied(), and if the tie's target class defines a destructor, there is a subtle gotcha you</source>
          <target state="translated">Если вы собираетесь использовать объект,возвращаемый либо из tie(),либо из tied(),и если целевой класс tie определяет деструктор,то есть тонкое замечание,что вы</target>
        </trans-unit>
        <trans-unit id="8bc6f9a7f0a4b90e4946e190029eff70ef889753" translate="yes" xml:space="preserve">
          <source>If you intend to manipulate the Zip64 zip files created with this module using an external zip/unzip, make sure that it supports Zip64.</source>
          <target state="translated">Если вы собираетесь манипулировать Zip64 zip-файлами,созданными с помощью этого модуля,используя внешний zip/unzip,убедитесь,что он поддерживает Zip64.</target>
        </trans-unit>
        <trans-unit id="fd3a1f6a190142b4a94b8f1071ccacb0e45694c8" translate="yes" xml:space="preserve">
          <source>If you intend to run only on FAT (or if using AnyDBM_File on FAT), run Configure with the -Ui_ndbm and -Ui_dbm options to prevent NDBM_File and ODBM_File being built.</source>
          <target state="translated">Если Вы собираетесь запускать только на FAT (или если Вы используете AnyDBM_File на FAT),запустите опции Configure с параметрами -Ui_ndbm и -Ui_dbm,чтобы предотвратить сборку NDBM_File и ODBM_File.</target>
        </trans-unit>
        <trans-unit id="3f04b70c5edf0d8a2ff6b52a2e5a3c4237fee493" translate="yes" xml:space="preserve">
          <source>If you intend using the Filter::Call functionality, I would strongly recommend that you check out Damian Conway's excellent Filter::Simple module. Damian's module provides a much cleaner interface than Filter::Util::Call. Although it doesn't allow the fine control that Filter::Util::Call does, it should be adequate for the majority of applications. It's available at</source>
          <target state="translated">Если вы собираетесь использовать функциональность Filter::Call,я настоятельно рекомендую вам обратить внимание на отличный модуль Filter::Simple от Damian Conway.Модуль Damian обеспечивает гораздо более чистый интерфейс,чем Filter::Util::Call.Хотя он не позволяет тонкого контроля,который делает Filter::Util::Call,он должен быть адекватен для большинства приложений.Он доступен по адресу</target>
        </trans-unit>
        <trans-unit id="e2cffac6976f9820e2e90021e812ad7d58d0f5b4" translate="yes" xml:space="preserve">
          <source>If you intended for the subroutine to be eligible for inlining, then make sure the variable is not referenced elsewhere, possibly by copying it:</source>
          <target state="translated">Если вы хотели,чтобы подпрограмма была пригодна для встраивания,то убедитесь,что на переменную нет ссылок в другом месте,возможно,скопировав ее:</target>
        </trans-unit>
        <trans-unit id="9dab4bde5120fee3a0a7f6db844ef859c18d4c68" translate="yes" xml:space="preserve">
          <source>If you invoke Concise more than once in a program, you should know that the options are 'sticky'. This means that the options you provide in the first call will be remembered for the 2nd call, unless you re-specify or change them.</source>
          <target state="translated">Если вы вызываете &quot;Краткость&quot; более одного раза в программе,вы должны знать,что опции &quot;липкие&quot;.Это означает,что опционы,которые вы предоставляете при первом вызове,будут запомнены при втором вызове,если вы их не укажете или не измените.</target>
        </trans-unit>
        <trans-unit id="50093622d9b6b20299be5b789440addca54eb16b" translate="yes" xml:space="preserve">
          <source>If you invoke Perl with the &lt;b&gt;-d&lt;/b&gt; switch, your script runs under the Perl source debugger. This works like an interactive Perl environment, prompting for debugger commands that let you examine source code, set breakpoints, get stack backtraces, change the values of variables, etc. This is so convenient that you often fire up the debugger all by itself just to test out Perl constructs interactively to see what they do. For example:</source>
          <target state="translated">Если вы вызываете Perl с ключом &lt;b&gt;-d&lt;/b&gt; , ваш скрипт запускается под отладчиком исходного кода Perl. Это работает как интерактивная среда Perl, предлагая команды отладчика, которые позволяют вам исследовать исходный код, устанавливать точки останова, получать трассировку стека, изменять значения переменных и т. Д. Это настолько удобно, что вы часто запускаете отладчик сам по себе, просто чтобы протестируйте конструкции Perl в интерактивном режиме, чтобы увидеть, что они делают. Например:</target>
        </trans-unit>
        <trans-unit id="5f165a45e66d1014a54e531d87cac35b6f25f848" translate="yes" xml:space="preserve">
          <source>If you iterate through the hash with each(), you can delete the key most recently returned without worrying about it. If you delete or add other keys, the iterator may skip or double up on them since perl may rearrange the hash table. See the entry for &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">Если вы перебираете хеш с помощью each (), вы можете удалить последний возвращенный ключ, не беспокоясь об этом. Если вы удаляете или добавляете другие ключи, итератор может пропустить или удвоить их, поскольку perl может изменить хэш-таблицу. См. Запись для &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; в &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96bb290aa78bc388524149987ffa684a6cd88006" translate="yes" xml:space="preserve">
          <source>If you just need to customize the objects on creation, subclass &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_iterator_factory&quot;&gt;make_iterator_factory&lt;/a&gt;.</source>
          <target state="translated">Если вам просто нужно настроить объекты при создании, &lt;a href=&quot;#make_iterator_factory&quot;&gt;создайте&lt;/a&gt; подкласс &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; и переопределите make_iterator_factory .</target>
        </trans-unit>
        <trans-unit id="1eae7a7eb8bcc1fc11d062386801944953ed61fe" translate="yes" xml:space="preserve">
          <source>If you just want to extract, use the &lt;code&gt;extract_archive&lt;/code&gt; class method instead. It will optimize and write to disk immediately.</source>
          <target state="translated">Если вы просто хотите извлечь, используйте вместо этого метод класса &lt;code&gt;extract_archive&lt;/code&gt; . Он будет оптимизирован и немедленно записан на диск.</target>
        </trans-unit>
        <trans-unit id="205b6c9376bdc41030a3ba0411b3c133175a1cfb" translate="yes" xml:space="preserve">
          <source>If you just want to know how to use the utilities described here,</source>
          <target state="translated">Если вы просто хотите знать,как пользоваться утилитами,описанными здесь,</target>
        </trans-unit>
        <trans-unit id="5ca84053d1241bb168ed3733abf9fe5fef328612" translate="yes" xml:space="preserve">
          <source>If you just want to load a module in a test, we recommend simply using &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directly. It will cause the test to stop.</source>
          <target state="translated">Если вы просто хотите загрузить модуль в тест, мы рекомендуем просто &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; напрямую. Это приведет к остановке теста.</target>
        </trans-unit>
        <trans-unit id="58d9e2fc3089c3ee91bde03c8a168aabda14adca" translate="yes" xml:space="preserve">
          <source>If you just want to submit a single small patch like a pod fix, a test for a bug, comment fixes, etc., it's easy! Here's how:</source>
          <target state="translated">Если вы просто хотите отправить один маленький патч,например,исправление под,тест на ошибку,исправление комментариев и т.д.,это просто! Вот как:</target>
        </trans-unit>
        <trans-unit id="a3962095233ae6bded8cb1555c84a52ea4fc9a0c" translate="yes" xml:space="preserve">
          <source>If you just want to test a module can be loaded, use &lt;code&gt;require_ok&lt;/code&gt; .</source>
          <target state="translated">Если вы просто хотите проверить, можно ли загрузить модуль, используйте &lt;code&gt;require_ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42e3b970aadb68ea3a8923d019f70d26e7a5a350" translate="yes" xml:space="preserve">
          <source>If you know</source>
          <target state="translated">Если вы знаете</target>
        </trans-unit>
        <trans-unit id="9c14b8eb60486ad1003f5f292ba8d0aaf7f2284e" translate="yes" xml:space="preserve">
          <source>If you know one name for a Unicode property, you can use &lt;code&gt;prop_aliases&lt;/code&gt; to find either the long name (when called in scalar context), or a list of all of the names, somewhat ordered so that the short name is in the 0th element, the long name in the next element, and any other synonyms are in the remaining elements, in no particular order.</source>
          <target state="translated">Если вы знаете одно имя для свойства Unicode, вы можете использовать &lt;code&gt;prop_aliases&lt;/code&gt; , чтобы найти либо длинное имя (при вызове в скалярном контексте), либо список всех имен, в некотором порядке упорядоченных так, чтобы короткое имя находилось в 0-м элементе, длинное имя в следующем элементе и любые другие синонимы в оставшихся элементах без определенного порядка.</target>
        </trans-unit>
        <trans-unit id="4a59a33095f0058eebdfd05ced2318493337053a" translate="yes" xml:space="preserve">
          <source>If you know the columns that contain the data, you can use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; to extract a single column.</source>
          <target state="translated">Если вы знаете столбцы, содержащие данные, вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; для извлечения одного столбца.</target>
        </trans-unit>
        <trans-unit id="9eb4c97e122131b8720d6a259fed14fb554c1b02" translate="yes" xml:space="preserve">
          <source>If you know the directory already, you can add it to &lt;code&gt;@INC&lt;/code&gt; as you would for any other directory. You might &amp;lt;use lib&amp;gt; if you know the directory at compile time:</source>
          <target state="translated">Если вы уже знаете каталог, вы можете добавить его в &lt;code&gt;@INC&lt;/code&gt; , как и любой другой каталог. Вы можете &amp;lt;использовать lib&amp;gt;, если знаете каталог во время компиляции:</target>
        </trans-unit>
        <trans-unit id="e98e61c08f8371d445ada91d42b0a6e31509fa7c" translate="yes" xml:space="preserve">
          <source>If you know the exact length in bits, it can be used in place of the &lt;code&gt;*&lt;/code&gt; .</source>
          <target state="translated">Если вам известна точная длина в битах, ее можно использовать вместо &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="927bf5e4096ddfb3b14c96fc89123708e7ddad90" translate="yes" xml:space="preserve">
          <source>If you know the length of the compressed data stream before you start uncompressing, you can avoid having to use &lt;code&gt;trailingData&lt;/code&gt; by setting the &lt;code&gt;InputLength&lt;/code&gt; option in the constructor.</source>
          <target state="translated">Если вы знаете длину потока сжатых данных до того, как начнете распаковку, вы можете избежать использования &lt;code&gt;trailingData&lt;/code&gt; , установив параметр &lt;code&gt;InputLength&lt;/code&gt; в конструкторе.</target>
        </trans-unit>
        <trans-unit id="f21638ec12744a0da920d55488938e9726007614" translate="yes" xml:space="preserve">
          <source>If you know the length of the compressed data stream before you start uncompressing, you can avoid having to use &lt;code&gt;trailingData&lt;/code&gt; by setting the &lt;code&gt;InputLength&lt;/code&gt; option.</source>
          <target state="translated">Если вы знаете длину потока сжатых данных до начала распаковки, вы можете избежать использования &lt;code&gt;trailingData&lt;/code&gt; , установив параметр &lt;code&gt;InputLength&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2ae57604fb0c858677a8a7bba0d622df68f1d53" translate="yes" xml:space="preserve">
          <source>If you know the name of a hash variable, you can get a pointer to its HV by using the following:</source>
          <target state="translated">Если вы знаете имя хэш-переменной,вы можете получить указатель на ее HV,используя следующее:</target>
        </trans-unit>
        <trans-unit id="eb63e6aa11dc04fb3c005505a5dc56980b836dee" translate="yes" xml:space="preserve">
          <source>If you know the name of a scalar variable, you can get a pointer to its SV by using the following:</source>
          <target state="translated">Если вы знаете имя скалярной переменной,вы можете получить указатель на ее SV,используя следующее:</target>
        </trans-unit>
        <trans-unit id="71cc5e317d663fb79a1bf1ed454222ec34ef184d" translate="yes" xml:space="preserve">
          <source>If you know the name of an array variable, you can get a pointer to its AV by using the following:</source>
          <target state="translated">Если вы знаете имя переменной массива,то вы можете получить указатель на ее AV,используя следующее:</target>
        </trans-unit>
        <trans-unit id="cd318c8126ae3cf5cfc9e3d9345bc2d0fc779cdb" translate="yes" xml:space="preserve">
          <source>If you know what you are doing you can turn off this warning by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'non_unicode';&lt;/code&gt; .</source>
          <target state="translated">Если вы знаете, что делаете, вы можете отключить это предупреждение &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'non_unicode';&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b884b7f1740fc7317e54fef08f2f9cd3cb14f5e3" translate="yes" xml:space="preserve">
          <source>If you know what you are doing you can turn off this warning by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'surrogate';&lt;/code&gt; .</source>
          <target state="translated">Если вы знаете , что вы делаете , вы можете отключить это предупреждение, без &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'surrogate';&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e7e8e09f3e73c52948b41c1fa2c3d1d138db3f3" translate="yes" xml:space="preserve">
          <source>If you know you are only going to use a system that does correctly implement appending (i.e. not Win32) then you can omit the &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; from the code in the previous answer.</source>
          <target state="translated">Если вы знаете, что собираетесь использовать только систему, которая правильно реализует добавление (то есть не Win32), вы можете опустить &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; в коде в предыдущем ответе.</target>
        </trans-unit>
        <trans-unit id="1148f14b2fe4053075a5db927cd2f992ce530c8c" translate="yes" xml:space="preserve">
          <source>If you know you are only writing code to run on an OS and filesystem that does implement append mode correctly (a local filesystem on a modern Unix for example), and you keep the file in block-buffered mode and you write less than one buffer-full of output between each manual flushing of the buffer then each bufferload is almost guaranteed to be written to the end of the file in one chunk without getting intermingled with anyone else's output. You can also use the &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function which is simply a wrapper around your system's &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write(2)&lt;/a&gt;&lt;/code&gt; system call.</source>
          <target state="translated">Если вы знаете, что пишете только код для запуска в ОС и файловой системе, которая правильно реализует режим добавления (например, локальная файловая система в современном Unix), и вы сохраняете файл в режиме блочной буферизации, и вы пишете менее одного буфера -полный вывод между каждой ручной очисткой буфера, тогда каждая загрузка буфера почти гарантированно будет записана в конец файла одним фрагментом, не смешиваясь с чьим-либо другим выводом. Вы также можете использовать функцию &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; , которая является просто оболочкой для системного вызова &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write(2)&lt;/a&gt;&lt;/code&gt; вашей системы .</target>
        </trans-unit>
        <trans-unit id="01c8e667e3ed1b51f8f2d44670f827394972704b" translate="yes" xml:space="preserve">
          <source>If you know your package, you can just mention it explicitly, as in $Some_Pack::var. Note that the notation $::var is &lt;b&gt;not&lt;/b&gt; the dynamic $var in the current package, but rather the one in the &quot;main&quot; package, as though you had written $main::var.</source>
          <target state="translated">Если вы знаете свой пакет, вы можете просто указать его явно, как в $ Some_Pack :: var. Обратите внимание, что обозначение $ :: var - это &lt;b&gt;не&lt;/b&gt; динамический $ var в текущем пакете, а, скорее, в &quot;основном&quot; пакете, как если бы вы написали $ main :: var.</target>
        </trans-unit>
        <trans-unit id="283a4b9fbff3cde02d8b49d7e007e0e9915125fc" translate="yes" xml:space="preserve">
          <source>If you like a more web-like approach, a good start point can be &lt;a href=&quot;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&quot;&gt;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&lt;/a&gt; and click &quot;C for AIX&quot;, and follow the instructions.</source>
          <target state="translated">Если вам нравится более веб-подход, хорошей отправной точкой может быть &lt;a href=&quot;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&quot;&gt;http://www14.software.ibm.com/webapp/download/downloadaz.jsp,&lt;/a&gt; нажать &amp;laquo;C для AIX&amp;raquo; и следовать инструкциям.</target>
        </trans-unit>
        <trans-unit id="b95d71103315a260f526ee0388cdf401d8ff3b71" translate="yes" xml:space="preserve">
          <source>If you like the &lt;code&gt;prove&lt;/code&gt; utility and &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; but you want your own harness, all you need to do is write one and provide &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;runtests&lt;/code&gt; methods. Then you can use the &lt;code&gt;prove&lt;/code&gt; utility like so:</source>
          <target state="translated">Если вы любите &lt;code&gt;prove&lt;/code&gt; полезность и &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; , но вы хотите иметь свой собственный ремень безопасности, все , что вам нужно сделать , это написать один и предоставить &lt;code&gt;new&lt;/code&gt; и &lt;code&gt;runtests&lt;/code&gt; методы. Затем вы можете использовать утилиту &lt;code&gt;prove&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="fbd3ba27ff3a08207feb966e075b2fa08e7cf809" translate="yes" xml:space="preserve">
          <source>If you like, you can store these filehandles in an array or a hash. If you access them directly, they aren't simple scalars and you need to give &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; a little help by placing the filehandle reference in braces. Perl can only figure it out on its own when the filehandle reference is a simple scalar.</source>
          <target state="translated">Если хотите, вы можете хранить эти дескрипторы файлов в массиве или хэше. Если вы обращаетесь к ним напрямую, это не простые скаляры, и вам нужно немного помочь &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , поместив ссылку на дескриптор файла в фигурные скобки. Perl может понять это самостоятельно, только если ссылка на дескриптор файла представляет собой простой скаляр.</target>
        </trans-unit>
        <trans-unit id="d730d69794a1a0d8df4bc0eb2edfe8040f78af15" translate="yes" xml:space="preserve">
          <source>If you localize a special variable, you'll be giving a new value to it, but its magic won't go away. That means that all side-effects related to this magic still work with the localized value.</source>
          <target state="translated">Если вы локализуете специальную переменную,вы придадите ей новое значение,но ее магия не исчезнет.Это означает,что все побочные эффекты,связанные с этой магией,все еще работают с локализованным значением.</target>
        </trans-unit>
        <trans-unit id="c90f343f24019c1da72c48d70c317941a7498b61" translate="yes" xml:space="preserve">
          <source>If you localize an exported variable in a module, its exported value will not change. The local name becomes an alias to a new value but the external name is still an alias for the original.</source>
          <target state="translated">При локализации экспортируемой переменной в модуле ее экспортируемое значение не изменится.Локальное имя становится псевдонимом к новому значению,а внешнее-псевдонимом к оригиналу.</target>
        </trans-unit>
        <trans-unit id="dafcf35a82f601b489cfb5dd0eef86e45cb1372b" translate="yes" xml:space="preserve">
          <source>If you look at its source, you'll see that open2() uses low-level primitives like the pipe() and exec() syscalls to create all the connections. Although it might have been more efficient by using socketpair(), this would have been even less portable than it already is. The open2() and open3() functions are unlikely to work anywhere except on a Unix system, or at least one purporting POSIX compliance.</source>
          <target state="translated">Если вы посмотрите на его исходники,вы увидите,что open2()использует низкоуровневые примитивы,такие как трубка()и исполнение()syscalls для создания всех соединений.Несмотря на то,что использование socketpair()могло бы быть более эффективным,это было бы еще менее переносимым,чем уже есть на самом деле.Функции open2()и open3()вряд ли будут работать где-либо,кроме как на Unix-системе,или,по крайней мере,на POSIX-совместимости.</target>
        </trans-unit>
        <trans-unit id="dba57ac6d2e87e59b7cd30bc2efe7662859d4f78" translate="yes" xml:space="preserve">
          <source>If you look at the contents of a database file created by DB_File, there can sometimes be part of a Perl script included in it.</source>
          <target state="translated">Если вы посмотрите на содержимое файла базы данных,созданного DB_File,то иногда в него может быть включена часть Perl скрипта.</target>
        </trans-unit>
        <trans-unit id="6e077c0b0a12316fa45027aa958a68eefe5eb38b" translate="yes" xml:space="preserve">
          <source>If you make use of the Berkeley DB API, it is</source>
          <target state="translated">Если вы используете API БД Беркли,то это</target>
        </trans-unit>
        <trans-unit id="044615c04770ac7a0002f5e8d4d8dd2908b76278" translate="yes" xml:space="preserve">
          <source>If you may assume POSIX (a rather large assumption), you may read more about the POSIX locale system from &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;. The locale system at least attempts to make things a little bit more portable, or at least more convenient and native-friendly for non-English users. The system affects character sets and encoding, and date and time formatting--amongst other things.</source>
          <target state="translated">Если вы можете предположить POSIX (довольно большое предположение), вы можете прочитать больше о системе языковых стандартов POSIX на &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; . Система локализации, по крайней мере, пытается сделать вещи немного более портативными или, по крайней мере, более удобными и понятными для пользователей, не владеющих английским языком. Система влияет на наборы символов и кодировку, а также на форматирование даты и времени - среди прочего.</target>
        </trans-unit>
        <trans-unit id="a25944da5356d5910252ea9238bbb196b425ee18" translate="yes" xml:space="preserve">
          <source>If you memoize &lt;code&gt;getusers&lt;/code&gt; here, it will work right exactly once. The reference to the users list will be stored in the memo table. &lt;code&gt;main&lt;/code&gt; will discard the first element from the referenced list. The next time you invoke &lt;code&gt;main&lt;/code&gt; , &lt;code&gt;Memoize&lt;/code&gt; will not call &lt;code&gt;getusers&lt;/code&gt; ; it will just return the same reference to the same list it got last time. But this time the list has already had its head removed; &lt;code&gt;main&lt;/code&gt; will erroneously remove another element from it. The list will get shorter and shorter every time you call &lt;code&gt;main&lt;/code&gt; .</source>
          <target state="translated">Если вы &lt;code&gt;getusers&lt;/code&gt; здесь, это сработает ровно один раз. Ссылка на список пользователей будет сохранена в таблице памяток. &lt;code&gt;main&lt;/code&gt; отбросит первый элемент из указанного списка. В следующий раз, когда вы &lt;code&gt;Memoize&lt;/code&gt; &lt;code&gt;main&lt;/code&gt; , Memoize не будет вызывать &lt;code&gt;getusers&lt;/code&gt; ; он просто вернет ту же ссылку на тот же список, что и в прошлый раз. Но на этот раз список уже убран; &lt;code&gt;main&lt;/code&gt; по ошибке удалит из него другой элемент. Список будет становиться все короче и короче каждый раз, когда вы вызываете &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="babf77ebcd09b5b6b24f3181921a88c6ea58626a" translate="yes" xml:space="preserve">
          <source>If you need a copy of the string, see &lt;a href=&quot;#bytes_from_utf8&quot;&gt;bytes_from_utf8&lt;/a&gt;.</source>
          <target state="translated">Если вам нужна копия строки, см. &lt;a href=&quot;#bytes_from_utf8&quot;&gt;Bytes_from_utf8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e5f94b7a22fe122cef06ac242e6fea05a7455fe1" translate="yes" xml:space="preserve">
          <source>If you need a notation that's that powerful, use normal Perl:</source>
          <target state="translated">Если вам нужна такая мощная нотация,используйте нормальный Perl:</target>
        </trans-unit>
        <trans-unit id="d3c247b2226d86ce39340fe5128412de0478e397" translate="yes" xml:space="preserve">
          <source>If you need an empty attribute list, for example in a code generator, add a space before the &lt;code&gt;=&lt;/code&gt; .</source>
          <target state="translated">Если вам нужен пустой список атрибутов, например, в генераторе кода, добавьте пробел перед &lt;code&gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82f75e54b3d41cd48a9f47dcdc6a65f36e63ccd0" translate="yes" xml:space="preserve">
          <source>If you need more advanced management of what runs in parallel vs in sequence, see the associated 'rules' documentation in &lt;a href=&quot;tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; and &lt;a href=&quot;tap/parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;. If what's possible directly through &lt;code&gt;prove&lt;/code&gt; is not sufficient, you can write your own harness to access these features directly.</source>
          <target state="translated">Если вам нужно более продвинутое управление тем, что выполняется параллельно или последовательно, см. Соответствующую документацию по &amp;laquo;правилам&amp;raquo; в &lt;a href=&quot;tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt; и &lt;a href=&quot;tap/parser/scheduler&quot;&gt;TAP :: Parser :: Scheduler&lt;/a&gt; . Если того, что возможно напрямую через &lt;code&gt;prove&lt;/code&gt; недостаточно, вы можете написать свою собственную привязь для прямого доступа к этим функциям.</target>
        </trans-unit>
        <trans-unit id="bcc2262a79a5dbdf9359e3765fbc56f15e34b33f" translate="yes" xml:space="preserve">
          <source>If you need more fine-grained control over shared variable access, see &lt;a href=&quot;../thread/semaphore&quot;&gt;Thread::Semaphore&lt;/a&gt;.</source>
          <target state="translated">Если вам нужен более детальный контроль над доступом к разделяемым переменным, см. &lt;a href=&quot;../thread/semaphore&quot;&gt;Thread :: Semaphore&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06a1402305f2d5c348929119dfbe7d1b16bea038" translate="yes" xml:space="preserve">
          <source>If you need more memory (larger data segment) for your Perl programs you can set:</source>
          <target state="translated">Если Вам нужно больше памяти (больший сегмент данных)для Ваших программ на Perl,Вы можете установить:</target>
        </trans-unit>
        <trans-unit id="a733f66f7ebcddfc5bced382948b822560f8102b" translate="yes" xml:space="preserve">
          <source>If you need non-ASCII characters in your source code, make it a UTF-8 encoded file and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; .</source>
          <target state="translated">Если вам нужны символы, отличные от ASCII, в исходном коде, сделайте его файлом в кодировке UTF-8 и &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de2791275bc33103874a494cba3668a34d497a88" translate="yes" xml:space="preserve">
          <source>If you need not it (say, in the case when you need not handle any combining characters), assign &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; explicitly.</source>
          <target state="translated">Если вам это не нужно (скажем, в случае, когда вам не нужно обрабатывать какие-либо комбинирующие символы), явно назначьте &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d24eea4a069716d3cfb8ce322b04914e0b52151" translate="yes" xml:space="preserve">
          <source>If you need something like this functionality, you should use the &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma, which is also deprecated, but has fewer nasty side effects.</source>
          <target state="translated">Если вам нужна что-то вроде этой функции, вы должны использовать прагму &lt;a href=&quot;encoding&quot;&gt;кодирования&lt;/a&gt; , которая также устарела, но имеет меньше неприятных побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="74399fe1ce7a1f4f506a06b60ded39ec27cea334" translate="yes" xml:space="preserve">
          <source>If you need something much more sophisticated and controllable, Leon Brocard's &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::ebug&quot;&gt;Devel::ebug&lt;/a&gt; (which you can call with the &lt;code&gt;-D&lt;/code&gt; switch as &lt;code&gt;-Debug&lt;/code&gt; ) gives you the programmatic hooks into everything you need to write your own (without too much pain and suffering).</source>
          <target state="translated">Если вам нужно что-то гораздо более сложное и управляемое, &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::ebug&quot;&gt;Devel :: ebug&lt;/a&gt; Леона Брокарда (который вы можете вызвать с помощью переключателя &lt;code&gt;-D&lt;/code&gt; как &lt;code&gt;-Debug&lt;/code&gt; ) дает вам программные перехватчики для всего, что вам нужно, чтобы написать свое собственное (без особой боли и страданий. ).</target>
        </trans-unit>
        <trans-unit id="77f3f2631a368e380813c177575d4bf78bb0f7fd" translate="yes" xml:space="preserve">
          <source>If you need the string representation of a character that doesn't have a mnemonic name in C, you should add it to the list in</source>
          <target state="translated">Если вам нужно строковое представление символа,не имеющего мнемонического имени на C,то вы должны добавить его в список на</target>
        </trans-unit>
        <trans-unit id="c2b8ba636abce4657c8c0f922660904cfc7228c1" translate="yes" xml:space="preserve">
          <source>If you need to be able to read a block which has an exact size, you can use the function &lt;code&gt;filter_read_exact&lt;/code&gt; . It works identically to &lt;code&gt;filter_read&lt;/code&gt; in block mode, except it will try to read a block which is exactly &lt;code&gt;$size&lt;/code&gt; bytes in length. The only circumstances when it will not return a block which is &lt;code&gt;$size&lt;/code&gt; bytes long is on EOF or error.</source>
          <target state="translated">Если вам нужно прочитать блок, имеющий точный размер, вы можете использовать функцию &lt;code&gt;filter_read_exact&lt;/code&gt; . Он работает идентично &lt;code&gt;filter_read&lt;/code&gt; в блочном режиме, за исключением того, что он пытается прочитать блок, длина которого равна точно &lt;code&gt;$size&lt;/code&gt; байтах. Единственные обстоятельства, когда он не вернет блок длиной &lt;code&gt;$size&lt;/code&gt; байтах, - это EOF или ошибка.</target>
        </trans-unit>
        <trans-unit id="18a6ebad8222234ffca6c9871e53dc4619a2ca40" translate="yes" xml:space="preserve">
          <source>If you need to bless or re-bless an object you can use the following function:</source>
          <target state="translated">Если Вам необходимо благословить или переоформить объект,Вы можете воспользоваться следующей функцией:</target>
        </trans-unit>
        <trans-unit id="d70c6e2df233bb6ffd0181bcff94f18d3b389825" translate="yes" xml:space="preserve">
          <source>If you need to customize the objects on creation, subclass &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_grammar&quot;&gt;make_grammar&lt;/a&gt;</source>
          <target state="translated">Если вам нужно настроить объекты при создании, &lt;a href=&quot;#make_grammar&quot;&gt;создайте&lt;/a&gt; подкласс &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; и переопределите make_grammar</target>
        </trans-unit>
        <trans-unit id="28d9937fb82713ba1f2c783a5af6bd5ed96f1469" translate="yes" xml:space="preserve">
          <source>If you need to customize the objects on creation, subclass &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_result&quot;&gt;make_result&lt;/a&gt;.</source>
          <target state="translated">Если вам нужно настроить объекты при создании, &lt;a href=&quot;#make_result&quot;&gt;создайте&lt;/a&gt; подкласс &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; и переопределите make_result .</target>
        </trans-unit>
        <trans-unit id="9bf36336c456165d1f557c63d917cf367e24c8a2" translate="yes" xml:space="preserve">
          <source>If you need to distinguish between endian architectures you could use either of the variables set like so:</source>
          <target state="translated">Если вам нужно различать архитектуры на языке эндианов,вы можете использовать любую из установленных переменных:</target>
        </trans-unit>
        <trans-unit id="a6c8b4493aa37d00a1808e45469530aac89fd5c8" translate="yes" xml:space="preserve">
          <source>If you need to do something more complicated, you can use &lt;a href=&quot;http://search.cpan.org/perldoc/LWP::UserAgent&quot;&gt;LWP::UserAgent&lt;/a&gt; module to create your own user-agent (e.g. browser) to get the job done. If you want to simulate an interactive web browser, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt; module.</source>
          <target state="translated">Если вам нужно сделать что-то более сложное, вы можете использовать модуль &lt;a href=&quot;http://search.cpan.org/perldoc/LWP::UserAgent&quot;&gt;LWP :: UserAgent,&lt;/a&gt; чтобы создать свой собственный пользовательский агент (например, браузер) для выполнения этой работы. Если вы хотите смоделировать интерактивный веб-браузер, вы можете использовать модуль &lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW :: Mechanize&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7852e983dc45b1c4fb37cf3f05367219e6ca843" translate="yes" xml:space="preserve">
          <source>If you need to do this check often, define your own macro like this:</source>
          <target state="translated">Если вам нужно делать эту проверку часто,определите свой собственный макрос так:</target>
        </trans-unit>
        <trans-unit id="6466ffd2aaaebc3946b351828c459bde58bed891" translate="yes" xml:space="preserve">
          <source>If you need to include C code or C library interfaces use h2xs. h2xs will create the module distribution structure and the initial interface files. &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; explain the details.</source>
          <target state="translated">Если вам нужно включить код C или интерфейсы библиотеки C, используйте h2xs. h2xs создаст структуру распределения модуля и исходные файлы интерфейса. &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; и &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; объясняют детали.</target>
        </trans-unit>
        <trans-unit id="132d01927536564513220be940287f0a7e0711cd" translate="yes" xml:space="preserve">
          <source>If you need to make sure your diagnostics are displayed in the correct order relative to test results you can use the &lt;code&gt;--merge&lt;/code&gt; option to merge the test scripts' STDERR into their STDOUT.</source>
          <target state="translated">Если вам нужно убедиться, что ваша диагностика отображается в правильном порядке относительно результатов тестирования, вы можете использовать параметр &lt;code&gt;--merge&lt;/code&gt; , чтобы объединить STDERR тестовых скриптов в их STDOUT.</target>
        </trans-unit>
        <trans-unit id="f121bbe2a75e4529feda5970b07f0e59291a1000" translate="yes" xml:space="preserve">
          <source>If you need to pad with a character other than blank or zero you can use one of the following methods. They all generate a pad string with the &lt;code&gt;x&lt;/code&gt; operator and combine that with &lt;code&gt;$text&lt;/code&gt; . These methods do not truncate &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">Если вам нужно заполнить символом, отличным от пробела или нуля, вы можете использовать один из следующих методов. Все они генерируют строку заполнения с оператором &lt;code&gt;x&lt;/code&gt; и комбинируют ее с &lt;code&gt;$text&lt;/code&gt; . Эти методы не усекают &lt;code&gt;$text&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5db19b81a16545df9a2691c134fe238aff01db6b" translate="yes" xml:space="preserve">
          <source>If you need to pass the handle to something that expects a filename then on a unix system you can use C for arbitrary programs. Perl code that uses the 2-argument version of C&amp;lt;&amp;lt; open &amp;gt;&amp;gt; can be passed C&amp;lt;&amp;lt; &quot;+&amp;lt;=&amp;amp;&quot; . fileno($fh) &amp;gt;&amp;gt;. Otherwise you will need to pass the filename. You will have to clear the close-on-exec bit on that file descriptor before passing it to another process.</source>
          <target state="translated">Если вам нужно передать дескриптор чему-то, что ожидает имя файла, тогда в системе unix вы можете использовать C для произвольных программ. Коду Perl, который использует версию C &amp;lt;&amp;lt; open &amp;gt;&amp;gt; с двумя аргументами, можно передать C &amp;lt;&amp;lt; &quot;+ &amp;lt;= &amp;amp;&quot;. fileno ($ fh) &amp;gt;&amp;gt;. В противном случае вам нужно будет передать имя файла. Вам нужно будет очистить бит закрытия при выполнении этого файлового дескриптора, прежде чем передавать его другому процессу.</target>
        </trans-unit>
        <trans-unit id="a1479a86a7c4f92b2a893038ca84d0e7634155ed" translate="yes" xml:space="preserve">
          <source>If you need to perform any preprocessing of input before it is parsed you may want to override one or more of &lt;b&gt;preprocess_line()&lt;/b&gt; and/or &lt;b&gt;preprocess_paragraph()&lt;/b&gt;.</source>
          <target state="translated">Если вам нужно выполнить какую-либо предварительную обработку ввода перед его синтаксическим анализом, вы можете переопределить один или несколько из &lt;b&gt;preprocess_line ()&lt;/b&gt; и / или &lt;b&gt;preprocess_paragraph ()&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="6fb6f27c51e4262718886f54bfa50ac616a6eb28" translate="yes" xml:space="preserve">
          <source>If you need to push multiple different values then you should either use the &lt;code&gt;(X)PUSHs&lt;/code&gt; macros, or else use the new &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; macros, none of which make use of &lt;code&gt;TARG&lt;/code&gt; . The &lt;code&gt;(X)PUSHs&lt;/code&gt; macros simply push an SV* on the stack, which, as noted under &lt;a href=&quot;#XSUBs-and-the-Argument-Stack&quot;&gt;XSUBs and the Argument Stack&lt;/a&gt;, will often need to be &quot;mortal&quot;. The new &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; macros make this a little easier to achieve by creating a new mortal for you (via &lt;code&gt;(X)PUSHmortal&lt;/code&gt;), pushing that onto the stack (extending it if necessary in the case of the &lt;code&gt;mXPUSH[iunp]&lt;/code&gt; macros), and then setting its value. Thus, instead of writing this to &quot;fix&quot; the example above:</source>
          <target state="translated">Если вам нужно передать несколько разных значений, вы должны либо использовать макросы &lt;code&gt;(X)PUSHs&lt;/code&gt; , либо использовать новые макросы &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; , ни один из которых не использует &lt;code&gt;TARG&lt;/code&gt; . &lt;code&gt;(X)PUSHs&lt;/code&gt; макросы просто вытолкнуть SV * в стеке, который, как уже отмечалось при &lt;a href=&quot;#XSUBs-and-the-Argument-Stack&quot;&gt;XSUBs и Аргумента Stack&lt;/a&gt; , часто нужно быть &amp;laquo;смертный&amp;raquo;. Новые макросы &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; эту задачу, создавая для вас нового смертного (через &lt;code&gt;(X)PUSHmortal&lt;/code&gt; ), помещая его в стек (при необходимости расширяя его в случае &lt;code&gt;mXPUSH[iunp]&lt;/code&gt; ), а затем установив его значение. Таким образом, вместо того, чтобы писать это, чтобы &amp;laquo;исправить&amp;raquo; приведенный выше пример:</target>
        </trans-unit>
        <trans-unit id="b45e0c901cd619f7527093c4d9dc59b922de91c4" translate="yes" xml:space="preserve">
          <source>If you need to run code under taint mode, updating to the latest L&amp;lt;:spec&amp;gt; is highly recommended.</source>
          <target state="translated">Если вам нужно запустить код в режиме заражения, настоятельно рекомендуется обновить его до последней версии L &amp;lt;: spec&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="0a26debdab35f4d9006770f7ff9dd97352bd60fc" translate="yes" xml:space="preserve">
          <source>If you need to set the encoding for STDIN, STDOUT, and STDERR, for example based on the user's locale, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">Если вам нужно установить кодировку для STDIN, STDOUT и STDERR, например, на основе языкового стандарта пользователя, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6d6ae28c61f9ab4be958ec28b43ea876d12f0ac" translate="yes" xml:space="preserve">
          <source>If you need to sort on several fields, the following paradigm is useful.</source>
          <target state="translated">Если вам нужно отсортировать по нескольким полям,то вам пригодится следующая парадигма.</target>
        </trans-unit>
        <trans-unit id="bcb30e833a46ba05085b508093073afbb52be3c6" translate="yes" xml:space="preserve">
          <source>If you need to use</source>
          <target state="translated">Если вам нужно использовать</target>
        </trans-unit>
        <trans-unit id="dd52c7b44ac55aa77cc0e377ad21781b36b65218" translate="yes" xml:space="preserve">
          <source>If you need to use Perl in the ILE environment, you may want to consider using Qp2RunPase() to call the PASE version of Perl.</source>
          <target state="translated">Если вам нужно использовать Perl в окружении ILE,вы можете подумать об использовании Qp2RunPase()для вызова PASE версии Perl.</target>
        </trans-unit>
        <trans-unit id="b4808d5e77c37aaf035853f43eef1fd731c05497" translate="yes" xml:space="preserve">
          <source>If you need to, your program can pass parameters to the subroutine as part of the thread startup. Just include the list of parameters as part of the &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; call, like this:</source>
          <target state="translated">Если вам нужно, ваша программа может передать параметры подпрограмме как часть запуска потока. Просто &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; список параметров как часть вызова thread-&amp;gt; create () , например:</target>
        </trans-unit>
        <trans-unit id="1710a33b911c663eb696834835df2f1e23df21c3" translate="yes" xml:space="preserve">
          <source>If you needed to know the length of the string in bytes, now's the perfect time for that. Because &lt;code&gt;$body&lt;/code&gt; is now a byte string, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; will report the number of bytes, instead of the number of characters. The number of characters is no longer known, because characters only exist in text strings.</source>
          <target state="translated">Если вам нужно было узнать длину строки в байтах, сейчас самое подходящее время для этого. Поскольку &lt;code&gt;$body&lt;/code&gt; теперь является байтовой строкой, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; будет указывать количество байтов, а не количество символов. Количество символов больше не известно, потому что символы существуют только в текстовых строках.</target>
        </trans-unit>
        <trans-unit id="be13b7e49abdf9671c1c203318c86c5b390da880" translate="yes" xml:space="preserve">
          <source>If you now say</source>
          <target state="translated">Если ты сейчас скажешь.</target>
        </trans-unit>
        <trans-unit id="4e07afe42e8e4906b74c8de7f97562b41c673c72" translate="yes" xml:space="preserve">
          <source>If you only have to do this once, you can print individually to each filehandle.</source>
          <target state="translated">Если вам нужно сделать это только один раз,вы можете распечатать каждый файл по отдельности.</target>
        </trans-unit>
        <trans-unit id="ef4f1155d60201a5a642377c105def023a28c8a3" translate="yes" xml:space="preserve">
          <source>If you open a pipe on the command &lt;code&gt;-&lt;/code&gt; (that is, specify either &lt;code&gt;|-&lt;/code&gt; or &lt;code&gt;-|&lt;/code&gt; with the one- or two-argument forms of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;), an implicit &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is done, so &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; returns twice: in the parent process it returns the pid of the child process, and in the child process it returns (a defined) &lt;code&gt;0&lt;/code&gt; . Use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;//&lt;/code&gt; to determine whether the open was successful.</source>
          <target state="translated">Если вы открываете канал по команде &lt;code&gt;-&lt;/code&gt; (то есть указываете &lt;code&gt;|-&lt;/code&gt; или &lt;code&gt;-|&lt;/code&gt; с одним или двумя аргументами &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ), неявная &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; выполняется, поэтому &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; возвращается дважды: в родительском процессе он возвращает pid дочернего процесса, а в дочернем процессе он возвращает (определенный) &lt;code&gt;0&lt;/code&gt; . Используйте &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;//&lt;/code&gt; , чтобы определить, было ли открытие успешным.</target>
        </trans-unit>
        <trans-unit id="3ae4797a620c0cf454989f9d7b82f21950740479" translate="yes" xml:space="preserve">
          <source>If you open a pipe on the command &lt;code&gt;-&lt;/code&gt; (that is, specify either &lt;code&gt;|-&lt;/code&gt; or &lt;code&gt;-|&lt;/code&gt; with the one- or two-argument forms of &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;), an implicit &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is done, so &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; returns twice: in the parent process it returns the pid of the child process, and in the child process it returns (a defined) &lt;code&gt;0&lt;/code&gt; . Use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;//&lt;/code&gt; to determine whether the open was successful.</source>
          <target state="translated">Если вы открываете канал по команде &lt;code&gt;-&lt;/code&gt; (то есть указываете &lt;code&gt;|-&lt;/code&gt; или &lt;code&gt;-|&lt;/code&gt; с одним или двумя аргументами &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ), неявная &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; выполняется, поэтому &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; возвращается дважды: в родительском процессе он возвращает pid дочернего процесса, а в дочернем процессе он возвращает (определенный) &lt;code&gt;0&lt;/code&gt; . Используйте &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;//&lt;/code&gt; , чтобы определить, было ли открытие успешным.</target>
        </trans-unit>
        <trans-unit id="b60263df2e1568250aacc0155390b54bbc574b26" translate="yes" xml:space="preserve">
          <source>If you opted to uncomment &lt;code&gt;INST_VER&lt;/code&gt; and &lt;code&gt;INST_ARCH&lt;/code&gt; in the makefile then the installation structure is a little more complicated and you will need to add two new PATH components instead: &lt;code&gt;$INST_TOP\$INST_VER\bin&lt;/code&gt; and &lt;code&gt;$INST_TOP\$INST_VER\bin\$ARCHNAME&lt;/code&gt; , e.g.</source>
          <target state="translated">Если вы решили раскомментировать &lt;code&gt;INST_VER&lt;/code&gt; и &lt;code&gt;INST_ARCH&lt;/code&gt; в make- файле, тогда структура установки будет немного сложнее, и вместо этого вам нужно будет добавить два новых компонента PATH: &lt;code&gt;$INST_TOP\$INST_VER\bin&lt;/code&gt; и &lt;code&gt;$INST_TOP\$INST_VER\bin\$ARCHNAME&lt;/code&gt; , например</target>
        </trans-unit>
        <trans-unit id="3281995d9866c6fc2125672694920f44e26bcb98" translate="yes" xml:space="preserve">
          <source>If you override this method, it should never throw an exception.</source>
          <target state="translated">Если вы отмените этот метод,он никогда не должен делать исключений.</target>
        </trans-unit>
        <trans-unit id="a202baf38183d44995c2fcf3449035cd37813ae8" translate="yes" xml:space="preserve">
          <source>If you pass a perl version you get the release date for that version only.</source>
          <target state="translated">Если вы пройдете perl версию,то получите дату выпуска только этой версии.</target>
        </trans-unit>
        <trans-unit id="1538bf7a76ecb948f65bf6e3cd597e0fef6beddd" translate="yes" xml:space="preserve">
          <source>If you pass a version argument (value of &lt;code&gt;$]&lt;/code&gt; , like &lt;code&gt;5.00503&lt;/code&gt; or &lt;code&gt;5.008008&lt;/code&gt; ), you get a list of all the modules and their respective versions. (If you have the &lt;code&gt;version&lt;/code&gt; module, you can also use new-style version numbers, like &lt;code&gt;5.8.8&lt;/code&gt; .)</source>
          <target state="translated">Если вы передадите аргумент версии (значение &lt;code&gt;$]&lt;/code&gt; , например &lt;code&gt;5.00503&lt;/code&gt; или &lt;code&gt;5.008008&lt;/code&gt; ), вы получите список всех модулей и их соответствующих версий. (Если у вас есть модуль &lt;code&gt;version&lt;/code&gt; , вы также можете использовать номера версий в новом стиле, например &lt;code&gt;5.8.8&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="93bac64f7444e2412e1719cee4ee931ff2c82b7b" translate="yes" xml:space="preserve">
          <source>If you pass the &lt;code&gt;-q&lt;/code&gt; option to the module, then the STDOUT filehandle will be redirected into the variable &lt;code&gt;$O::BEGIN_output&lt;/code&gt; during compilation. This has the effect that any output printed to STDOUT by BEGIN blocks or use'd modules will be stored in this variable rather than printed. It's useful with those backends which produce output themselves (&lt;code&gt;Deparse&lt;/code&gt; , &lt;code&gt;Concise&lt;/code&gt; etc), so that their output is not confused with that generated by the code being compiled.</source>
          <target state="translated">Если вы передадите модулю параметр &lt;code&gt;-q&lt;/code&gt; , то дескриптор файла STDOUT будет перенаправлен в переменную &lt;code&gt;$O::BEGIN_output&lt;/code&gt; во время компиляции. Это приводит к тому, что любой вывод, выводимый в STDOUT блоками BEGIN или используемыми модулями, будет сохранен в этой переменной, а не распечатан. Это полезно для тех бэкэндов, которые сами производят вывод ( &lt;code&gt;Deparse&lt;/code&gt; , &lt;code&gt;Concise&lt;/code&gt; и т. Д.), Чтобы их вывод не путался с выводом, генерируемым компилируемым кодом.</target>
        </trans-unit>
        <trans-unit id="eb6ebb2e5d7084d0bbbc51b71dbc71d3b131a896" translate="yes" xml:space="preserve">
          <source>If you perform a new installation, then (a newer) Perl will be installed automatically. Pre-installed HP-UX systems now have more recent versions of Perl and the updated modules.</source>
          <target state="translated">Если вы выполните новую установку,то (более новая)Perl будет установлен автоматически.Предварительно установленные системы HP-UX теперь имеют более свежие версии Perl и обновленные модули.</target>
        </trans-unit>
        <trans-unit id="3e9cb6c101da46aadecf5f8c5c109de4412a1005" translate="yes" xml:space="preserve">
          <source>If you pick the right test function, you'll usually get a good idea of what went wrong when it failed. But sometimes it doesn't work out that way. So here we have ways for you to write your own diagnostic messages which are safer than just &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; STDERR&lt;/code&gt; .</source>
          <target state="translated">Если вы выберете правильную функцию тестирования, вы обычно получите представление о том, что пошло не так, когда она не прошла. Но иногда так не получается. Итак, здесь у нас есть способы написать свои собственные диагностические сообщения, которые безопаснее, чем просто &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; STDERR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1f8c3042df990d0caf7e15fec6410a8229928ec" translate="yes" xml:space="preserve">
          <source>If you plan on doing serious C hacking, make sure to read this.</source>
          <target state="translated">Если ты планируешь сделать серьезный взлом C,обязательно прочитай это.</target>
        </trans-unit>
        <trans-unit id="ea674be45f6eda0998926e34d1adb1941baadfc8" translate="yes" xml:space="preserve">
          <source>If you plan to link Perl to any module that requires thread-support, like DBD::Oracle, it is better to use the _r version of the compiler. This will not build a threaded Perl, but a thread-enabled Perl. See also &lt;a href=&quot;#Threaded-Perl&quot;&gt;Threaded Perl&lt;/a&gt; later on.</source>
          <target state="translated">Если вы планируете связать Perl с любым модулем, который требует поддержки потоков, например DBD :: Oracle, лучше использовать _r-версию компилятора. Это не создаст Perl с поддержкой потоков, а будет Perl с поддержкой потоков. См. Также &lt;a href=&quot;#Threaded-Perl&quot;&gt;Потоковый Perl&lt;/a&gt; позже.</target>
        </trans-unit>
        <trans-unit id="a59862b4b635be40786928d6e580b97f5fccb229" translate="yes" xml:space="preserve">
          <source>If you prefer 'regex' over 'regexp' in this tutorial, you could use the following program to replace it:</source>
          <target state="translated">Если вы предпочитаете в этом учебном пособии 'регекс',а не 'регэкспресс',то для его замены можно использовать следующую программу:</target>
        </trans-unit>
        <trans-unit id="e975a86edf7cf3f2a85267ea19c5e7fb97348443" translate="yes" xml:space="preserve">
          <source>If you prefer &lt;code&gt;CPANPLUS&lt;/code&gt; , it's just as easy:</source>
          <target state="translated">Если вы предпочитаете &lt;code&gt;CPANPLUS&lt;/code&gt; , это так же просто:</target>
        </trans-unit>
        <trans-unit id="88b2286238e8c1ea0536c07d5d33ab84bc86bbaa" translate="yes" xml:space="preserve">
          <source>If you prefer not to import these routines into your namespace, you can call them as:</source>
          <target state="translated">Если вы предпочитаете не импортировать эти процедуры в ваше пространство имен,вы можете назвать их как:</target>
        </trans-unit>
        <trans-unit id="02b429d0fbb0524681e65be7d6f8ab7830a0723a" translate="yes" xml:space="preserve">
          <source>If you prefer something more legible, use the File::stat module (part of the standard distribution in version 5.004 and later):</source>
          <target state="translated">Если вы предпочитаете что-то более понятное,используйте модуль File::stat (часть стандартного дистрибутива в версии 5.004 и выше):</target>
        </trans-unit>
        <trans-unit id="f0813e4f27c28bf6e883076eecebd37913fd5b51" translate="yes" xml:space="preserve">
          <source>If you prefer to do it more in a programmerish style in one single process, something like this may better suit you:</source>
          <target state="translated">Если вы предпочитаете делать это больше в программистском стиле за один процесс,то что-то подобное может вам больше подойти:</target>
        </trans-unit>
        <trans-unit id="ec90d5c6994006bb5fd89f190c78b5cdc340ee30" translate="yes" xml:space="preserve">
          <source>If you prefer to run your program first and look at its problem afterwards, do this:</source>
          <target state="translated">Если вы предпочитаете сначала запустить свою программу,а потом посмотреть на ее проблему,сделайте это:</target>
        </trans-unit>
        <trans-unit id="3870b14accf24c65cf812dc3594ebf250f4f78e6" translate="yes" xml:space="preserve">
          <source>If you properly encode your strings for output, none of this is of your concern, and you can just &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; dumped data as always.</source>
          <target state="translated">Если вы правильно кодируете свои строки для вывода, вас это не касается, и вы можете просто &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; выгруженные данные, как всегда.</target>
        </trans-unit>
        <trans-unit id="065fd2bf37d0cb46e6971e495f8f9b0d94012ccb" translate="yes" xml:space="preserve">
          <source>If you provide a $name, that will be printed along with the &quot;ok/not ok&quot; to make it easier to find your test when if fails (just search for the name). It also makes it easier for the next guy to understand what your test is for. It's highly recommended you use test names.</source>
          <target state="translated">Если вы предоставите имя $,оно будет напечатано вместе с &quot;ok/not ok&quot;,чтобы облегчить поиск вашего теста в случае неудачи (просто найдите имя).Это также облегчает задачу для следующего парня,чтобы понять,для чего нужен ваш тест.Настоятельно рекомендуется использовать имена тестов.</target>
        </trans-unit>
        <trans-unit id="b7880cf2049cee53a05bb2b9ece1c4d6f2c66f65" translate="yes" xml:space="preserve">
          <source>If you put a &lt;code&gt;\&lt;/code&gt; in front of a variable, you get a reference to that variable.</source>
          <target state="translated">Если вы поставите &lt;code&gt;\&lt;/code&gt; перед переменной, вы получите ссылку на эту переменную.</target>
        </trans-unit>
        <trans-unit id="34b57973357474bb06b6216c6a1396c52f47b8be" translate="yes" xml:space="preserve">
          <source>If you put extensions in unusual places, you can set PERL5LIB to a list of paths separated by semicolons where you want perl to look for libraries. Look for descriptions of other environment variables you can set in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">Если вы размещаете расширения в необычных местах, вы можете задать для PERL5LIB список путей, разделенных точкой с запятой, где вы хотите, чтобы Perl искал библиотеки. Поищите описания других переменных среды, которые вы можете установить в &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4498166e1dac5738a547d2b9e86da7f11d00c4e8" translate="yes" xml:space="preserve">
          <source>If you put two contiguous tilde characters &quot;~~&quot; anywhere into a line, the line will be repeated until all the fields on the line are exhausted, i.e. undefined. For special (caret) text fields this will occur sooner or later, but if you use a text field of the at variety, the expression you supply had better not give the same value every time forever! (&lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@f)&lt;/a&gt;&lt;/code&gt; is a simple example that would work.) Don't use a regular (at) numeric field in such lines, because it will never go blank.</source>
          <target state="translated">Если вы поместите два смежных символа тильды &amp;laquo;~~&amp;raquo; где-нибудь в строке, строка будет повторяться до тех пор, пока все поля в строке не будут исчерпаны, т.е. не будут определены. Для специальных текстовых полей (каретки) это произойдет рано или поздно, но если вы используете текстовое поле из разнообразия at, лучше не давать каждому выражению одно и то же значение каждый раз навсегда! ( &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@f)&lt;/a&gt;&lt;/code&gt; - простой пример, который будет работать.) Не используйте обычное числовое поле (at) в таких строках, потому что оно никогда не станет пустым.</target>
        </trans-unit>
        <trans-unit id="a6608312c76270dd048459022213c207db61db43" translate="yes" xml:space="preserve">
          <source>If you really do mean it, explicitly numify your reference, like so: &lt;code&gt;$array[0+$ref]&lt;/code&gt; . This warning is not given for overloaded objects, however, because you can overload the numification and stringification operators and then you presumably know what you are doing.</source>
          <target state="translated">Если вы действительно это имеете в виду, явно укажите номер своей ссылки, например: &lt;code&gt;$array[0+$ref]&lt;/code&gt; . Однако это предупреждение не выдается для перегруженных объектов, потому что вы можете перегрузить операторы нумификации и строкового преобразования, и тогда вы, вероятно, знаете, что делаете.</target>
        </trans-unit>
        <trans-unit id="2e6ee3c0e5f77f2901d0e16f7c2a62b5dc496ad9" translate="yes" xml:space="preserve">
          <source>If you really need to see whether the change has been accepted simply examine the return value of C</source>
          <target state="translated">Если вам действительно нужно увидеть,было ли принято изменение,просто проверьте возвращаемое значение C</target>
        </trans-unit>
        <trans-unit id="dd150284dfc14b1b33a794d882418a56b32b28b6" translate="yes" xml:space="preserve">
          <source>If you really want a subroutine with a &lt;code&gt;()&lt;/code&gt; prototype that returns a lexical variable you can easily force it to not be inlined by adding an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Если вам действительно нужна подпрограмма с прототипом &lt;code&gt;()&lt;/code&gt; , которая возвращает лексическую переменную, вы можете легко заставить ее не быть встроенной, добавив явный &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f0166a5725d2770573e3a305750b9dd3edf5c05f" translate="yes" xml:space="preserve">
          <source>If you really want comments, build your list the old-fashioned way, with quotes and commas:</source>
          <target state="translated">Если вы действительно хотите получить комментарии,построите свой список старомодным способом,с помощью кавычек и запятых:</target>
        </trans-unit>
        <trans-unit id="eb99b666d9e169ba81737784680da343f375dd69" translate="yes" xml:space="preserve">
          <source>If you really want just plain byte strings, use my_snprintf() and my_vsnprintf() instead, which will try to use snprintf() and vsnprintf() if those safer APIs are available. If you want something fancier than a plain byte string, use &lt;a href=&quot;perlapi#form&quot;&gt;Perl_form ()&lt;/a&gt; or SVs and &lt;a href=&quot;perlapi#sv_catpvf&quot;&gt;Perl_sv_catpvf() &lt;/a&gt;.</source>
          <target state="translated">Если вам действительно нужны простые байтовые строки, используйте вместо них my_snprintf () и my_vsnprintf (), которые попытаются использовать snprintf () и vsnprintf (), если доступны эти более безопасные API. Если вам нужно что-то более красивое, чем обычная байтовая строка, используйте &lt;a href=&quot;perlapi#form&quot;&gt;Perl_form ()&lt;/a&gt; или SV и &lt;a href=&quot;perlapi#sv_catpvf&quot;&gt;Perl_sv_catpvf ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c2d9e52e0617d90849665511b4fb2b333643750" translate="yes" xml:space="preserve">
          <source>If you really want to be international, you should consider Unicode. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for more information.</source>
          <target state="translated">Если вы действительно хотите быть международным, вам следует рассмотреть Unicode. См. &lt;a href=&quot;perluniintro&quot;&gt;Perluniintro&lt;/a&gt; и &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="7a1586770541996a5a05c7da504fe6b4a6bdef4c" translate="yes" xml:space="preserve">
          <source>If you really want to do this, you can use &lt;code&gt;ExtUtils::Manifest::manifind()&lt;/code&gt; to read the MANIFEST and File::Find to delete the files. But you have to be careful. Here's a script to do that. Use at your own risk. Have fun blowing holes in your foot.</source>
          <target state="translated">Если вы действительно хотите это сделать, вы можете использовать &lt;code&gt;ExtUtils::Manifest::manifind()&lt;/code&gt; для чтения MANIFEST и File :: Find для удаления файлов. Но нужно быть осторожным. Вот сценарий для этого. Используйте на свой риск. Удачи, протыкая ногу.</target>
        </trans-unit>
        <trans-unit id="bd0128791efed65e3bbb8d082044be49dfce046e" translate="yes" xml:space="preserve">
          <source>If you really want to, you can use the standard open2() from the &lt;code&gt;IPC::Open2&lt;/code&gt; module to catch both ends. There's also an open3() in &lt;code&gt;IPC::Open3&lt;/code&gt; for tridirectional I/O so you can also catch your child's STDERR, but doing so would then require an awkward select() loop and wouldn't allow you to use normal Perl input operations.</source>
          <target state="translated">Если вы действительно хотите, вы можете использовать стандартный open2 () из модуля &lt;code&gt;IPC::Open2&lt;/code&gt; чтобы поймать оба конца. В &lt;code&gt;IPC::Open3&lt;/code&gt; также есть open3 () для трехстороннего ввода-вывода, поэтому вы также можете поймать STDERR вашего ребенка, но для этого потребуется неудобный цикл select () и не позволит вам использовать обычные операции ввода Perl.</target>
        </trans-unit>
        <trans-unit id="53be29d9aa606768bcbe9e3309afe9ba5b57da03" translate="yes" xml:space="preserve">
          <source>If you recognized the quote about the Road above, you're in luck.</source>
          <target state="translated">Если вы узнали цитату о Дороге выше,вам повезло.</target>
        </trans-unit>
        <trans-unit id="39a2ad311b79ed3072c37af199bf41f9f9aebf15" translate="yes" xml:space="preserve">
          <source>If you redefine a subroutine that was eligible for inlining, you'll get a warning by default. You can use this warning to tell whether or not a particular subroutine is considered inlinable, since it's different than the warning for overriding non-inlined subroutines:</source>
          <target state="translated">Если вы переопределите подпрограмму,которая имела право на вставку,вы получите предупреждение по умолчанию.Вы можете использовать это предупреждение,чтобы определить,считается ли конкретная подпрограмма вложенной или нет,так как она отличается от предупреждения для не вложенных подпрограмм:</target>
        </trans-unit>
        <trans-unit id="432e76406abd8db96136b5a2df1a568bbdde9d3f" translate="yes" xml:space="preserve">
          <source>If you resize the array with deferred writing enabled, the file will be resized immediately, but deferred records will not be written. This has a surprising consequence: &lt;code&gt;@a = (...)&lt;/code&gt; erases the file immediately, but the writing of the actual data is deferred. This might be a bug. If it is a bug, it will be fixed in a future version.</source>
          <target state="translated">Если вы измените размер массива с включенной отложенной записью, размер файла будет изменен немедленно, но отложенные записи не будут записаны. Это приводит к удивительным последствиям: &lt;code&gt;@a = (...)&lt;/code&gt; немедленно стирает файл, но запись фактических данных откладывается. Это могло быть ошибкой. Если это ошибка, она будет исправлена ​​в будущей версии.</target>
        </trans-unit>
        <trans-unit id="b95da308b81d0840cacd6821e3c3f91e04b82e8a" translate="yes" xml:space="preserve">
          <source>If you run Perl with the &lt;b&gt;-w&lt;/b&gt; switch it can warn you about this. For example, the third line above produces:</source>
          <target state="translated">Если вы запустите Perl с ключом &lt;b&gt;-w,&lt;/b&gt; он может предупредить вас об этом. Например, третья строка выше производит:</target>
        </trans-unit>
        <trans-unit id="1983e4f73a942cb1a7c7741631cd3c3e344c8e03" translate="yes" xml:space="preserve">
          <source>If you run the script with the &lt;code&gt;-w&lt;/code&gt; flag the error message becomes:</source>
          <target state="translated">Если вы запустите сценарий с флагом &lt;code&gt;-w&lt;/code&gt; , появится сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="a9ad6a9bb0a2be45f4030cad900647a4bc2c1db1" translate="yes" xml:space="preserve">
          <source>If you run this code twice, the contents of the</source>
          <target state="translated">Если вы запустите этот код дважды,содержимое</target>
        </trans-unit>
        <trans-unit id="80dfce6f2a878c8f488ddf11e051d8fa78b7f75e" translate="yes" xml:space="preserve">
          <source>If you run your program with the &lt;code&gt;-w&lt;/code&gt; switch, or if you use the &lt;code&gt;warnings&lt;/code&gt; pragma, File::Find will report warnings for several weird situations. You can disable these warnings by putting the statement</source>
          <target state="translated">Если запустить программу с &lt;code&gt;-w&lt;/code&gt; переключателем, или при использовании &lt;code&gt;warnings&lt;/code&gt; прагмы, File :: Find будет сообщать предупреждения о нескольких странных ситуациях. Вы можете отключить эти предупреждения, поставив оператор</target>
        </trans-unit>
        <trans-unit id="84e83e7869cb30f17fc9ab2b3dafef8f917abf86" translate="yes" xml:space="preserve">
          <source>If you say yes to the following question, CPAN will try to store enough information about the build process so that it can pick up in future sessions at the same state of affairs as it left a previous session.</source>
          <target state="translated">Если вы ответите &quot;да&quot; на следующий вопрос,CPAN постарается сохранить достаточно информации о процессе сборки,чтобы в последующих сессиях он мог забрать информацию в том же состоянии,в котором он покинул предыдущий сеанс.</target>
        </trans-unit>
        <trans-unit id="3a116108872049154f6c27d6353e551d6d6917b4" translate="yes" xml:space="preserve">
          <source>If you see &quot;bad interpreter - no such file or directory&quot;, the first line in your perl script (the &quot;shebang&quot; line) does not contain the right path to perl (or any other program capable of running scripts). Sometimes this happens when you move the script from one machine to another and each machine has a different path to perl--/usr/bin/perl versus /usr/local/bin/perl for instance. It may also indicate that the source machine has CRLF line terminators and the destination machine has LF only: the shell tries to find /usr/bin/perl&amp;lt;CR&amp;gt;, but can't.</source>
          <target state="translated">Если вы видите &amp;laquo;плохой интерпретатор - нет такого файла или каталога&amp;raquo;, первая строка в вашем сценарии perl (строка &amp;laquo;shebang&amp;raquo;) не содержит правильного пути к perl (или любой другой программе, способной запускать сценарии). Иногда это происходит, когда вы перемещаете сценарий с одной машины на другую, и каждая машина имеет свой путь к perl - например, / usr / bin / perl, а не / usr / local / bin / perl. Это также может указывать на то, что исходный компьютер имеет терминаторы строки CRLF, а конечный компьютер имеет только LF: оболочка пытается найти / usr / bin / perl &amp;lt;CR&amp;gt;, но не может.</target>
        </trans-unit>
        <trans-unit id="2f85a9726440183decd897c1fff5988cce63ccf9" translate="yes" xml:space="preserve">
          <source>If you see &quot;bad interpreter: Permission denied&quot;, you need to make your script executable.</source>
          <target state="translated">Если вы видите &quot;плохого переводчика&quot;:Разрешение отклонено&quot;,вам нужно сделать ваш сценарий исполняемым.</target>
        </trans-unit>
        <trans-unit id="8de6b12e8e3d869536fad39850a1db08fd9bac7f" translate="yes" xml:space="preserve">
          <source>If you see in a debugger a memory area mysteriously full of 0xABABABAB or 0xEFEFEFEF, you may be seeing the effect of the Poison() macros, see &lt;a href=&quot;perlclib&quot;&gt;perlclib&lt;/a&gt;.</source>
          <target state="translated">Если вы видите в отладчике область памяти, таинственным образом заполненную 0xABABABAB или 0xEFEFEFEF, возможно, вы видите эффект макроса Poison (), см. &lt;a href=&quot;perlclib&quot;&gt;Perlclib&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d3df616229a0ebfcb7922d24bec233001d332f4" translate="yes" xml:space="preserve">
          <source>If you see right after &quot;make&quot; this</source>
          <target state="translated">Если вы видите сразу после &quot;сделать&quot; это</target>
        </trans-unit>
        <trans-unit id="d8e7a131ddc6c256b7162ac7f1766e22fd038d65" translate="yes" xml:space="preserve">
          <source>If you see that you're leaking memory at runtime, but neither valgrind nor &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; will find anything, you're probably leaking SVs that are still reachable and will be properly cleaned up during destruction of the interpreter. In such cases, using the &lt;code&gt;-Dm&lt;/code&gt; switch can point you to the source of the leak. If the executable was built with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; , &lt;code&gt;-Dm&lt;/code&gt; will output SV allocations in addition to memory allocations. Each SV allocation has a distinct serial number that will be written on creation and destruction of the SV. So if you're executing the leaking code in a loop, you need to look for SVs that are created, but never destroyed between each cycle. If such an SV is found, set a conditional breakpoint within &lt;code&gt;new_SV()&lt;/code&gt; and make it break only when &lt;code&gt;PL_sv_serial&lt;/code&gt; is equal to the serial number of the leaking SV. Then you will catch the interpreter in exactly the state where the leaking SV is allocated, which is sufficient in many cases to find the source of the leak.</source>
          <target state="translated">Если вы видите, что происходит утечка памяти во время выполнения, но ни valgrind, ни &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; ничего не найдут, вероятно, утечка SV, которые все еще доступны и будут должным образом очищены во время уничтожения интерпретатора. В таких случаях использование переключателя &lt;code&gt;-Dm&lt;/code&gt; может указать вам источник утечки. Если исполняемый файл был &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; с -DDEBUG_LEAKING_SCALARS , &lt;code&gt;-Dm&lt;/code&gt; будет выводить распределения SV в дополнение к распределению памяти. Каждое выделение SV имеет отдельный серийный номер, который будет записан при создании и уничтожении SV. Поэтому, если вы выполняете код утечки в цикле, вам нужно искать SV, которые создаются, но никогда не уничтожаются между каждым циклом. Если такой SV найден, установите условную &lt;code&gt;new_SV()&lt;/code&gt; останова в new_SV () и сделайте &lt;code&gt;PL_sv_serial&lt;/code&gt; только тогда, когда PL_sv_serial равен серийному номеру текущего SV. Тогда вы поймаете интерпретатор именно в том состоянии, в котором выделен текущий SV, чего во многих случаях достаточно, чтобы найти источник утечки.</target>
        </trans-unit>
        <trans-unit id="2bbf4110deb94dbc624ccee947cca19c596a9010" translate="yes" xml:space="preserve">
          <source>If you see this</source>
          <target state="translated">Если вы видите это</target>
        </trans-unit>
        <trans-unit id="4203dc6863ea2ff3c77a2428ddc46eaf1f7849d3" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;$DB::single&lt;/code&gt; to 2, it's equivalent to having just typed the &lt;code&gt;n&lt;/code&gt; command, whereas a value of 1 means the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; command. The &lt;code&gt;$DB::trace&lt;/code&gt; variable should be set to 1 to simulate having typed the &lt;code&gt;t&lt;/code&gt; command.</source>
          <target state="translated">Если вы установите для &lt;code&gt;$DB::single&lt;/code&gt; значение 2, это эквивалентно простому вводу команды &lt;code&gt;n&lt;/code&gt; , тогда как значение 1 означает команду &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;$DB::trace&lt;/code&gt; переменной должен быть установлен в 1 для имитации набрав в &lt;code&gt;t&lt;/code&gt; команду.</target>
        </trans-unit>
        <trans-unit id="a5d30ba8967fd6c8924240ee40d5a140a986b280" translate="yes" xml:space="preserve">
          <source>If you set a value for this attribute, the value is expected to be an object (probably of a class that you define) that has a &lt;code&gt;reach&lt;/code&gt; method and a &lt;code&gt;done&lt;/code&gt; method. This is meant for reporting progress during the search, if you don't want to use a simple callback.</source>
          <target state="translated">Если вы установите значение для этого атрибута, ожидается, что значение будет объектом (возможно, определенного вами класса), у которого есть метод &lt;code&gt;reach&lt;/code&gt; метод &lt;code&gt;done&lt;/code&gt; . Это предназначено для отчета о ходе поиска, если вы не хотите использовать простой обратный вызов.</target>
        </trans-unit>
        <trans-unit id="bcde195e379d8e8445763e6616418aa0a7c91d66" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;parse_characters&lt;/code&gt; option to a true value the parser will expect characters rather than octets; will ignore any &lt;code&gt;=encoding&lt;/code&gt; ; and will make no attempt to decode the input.</source>
          <target state="translated">Если вы установите для параметра &lt;code&gt;parse_characters&lt;/code&gt; значение true, синтаксический анализатор будет ожидать символов, а не октетов; игнорирует любую &lt;code&gt;=encoding&lt;/code&gt; ; и не будет пытаться декодировать ввод.</target>
        </trans-unit>
        <trans-unit id="24318749936760c8c43beac827cb9d11fbd59672" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, it will send reports of parsing errors to STDERR. By default, this attribute's value is false, meaning that no output is sent to STDERR.</source>
          <target state="translated">Если вы установите этот атрибут в значение true,то он будет посылать отчеты об ошибках парсинга в STDERR.По умолчанию значение этого атрибута равно false,что означает,что в STDERR не будет отправлено ни одного вывода.</target>
        </trans-unit>
        <trans-unit id="b5b8252659bce51d0b80d2e62f37a533a1cac341" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, you will stop the parser from generating a &quot;POD ERRORS&quot; section at the end of the document. By default, this attribute's value is false, meaning that an errata section will be generated, as necessary.</source>
          <target state="translated">Если вы установите этот атрибут в истинное значение,то парсер не будет генерировать раздел &quot;ОШИБКИ POD&quot; в конце документа.По умолчанию значение этого атрибута равно false,что означает,что при необходимости будет сгенерирован раздел &quot;ОШИБКИ ПОД&quot;.</target>
        </trans-unit>
        <trans-unit id="551f3a0a87736ea2dc54ed40fd31f1fb500e9541" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, you will suppress the parser's complaints about irregularities in the Pod coding. By default, this attribute's value is false, meaning that irregularities will be reported.</source>
          <target state="translated">Если вы установите этот атрибут в истинное значение,вы подавите жалобы парсера на нарушения в кодировке Pod.По умолчанию значение этого атрибута ложное,что означает,что о нарушениях будет сообщаться.</target>
        </trans-unit>
        <trans-unit id="e0f5cb1c277b98516d80bdfac1209f73af95fdc5" translate="yes" xml:space="preserve">
          <source>If you set this flag, all keys passed in the following manner:</source>
          <target state="translated">Если установить этот флаг,то все ключи будут передаваться следующим образом:</target>
        </trans-unit>
        <trans-unit id="90adec0aabd8555567c00e54faf42cc1c5fd95da" translate="yes" xml:space="preserve">
          <source>If you set this flag, unknown options will still be present in the return value, rather than filtered out. This is useful if your subroutine is only interested in a few arguments, and wants to pass the rest on blindly to perhaps another subroutine.</source>
          <target state="translated">Если вы установите этот флаг,неизвестные опции все равно будут присутствовать в возвращаемом значении,а не отфильтрованы.Это полезно,если ваша подпрограмма интересуется только несколькими аргументами и хочет передать остальное вслепую,возможно,в другую подпрограмму.</target>
        </trans-unit>
        <trans-unit id="71c1c224b5079dff6437c4c296c3882a0dbe0842" translate="yes" xml:space="preserve">
          <source>If you set this value to 0, these processes will wait forever. This is the default and recommended setting.</source>
          <target state="translated">Если вы установите это значение в 0,эти процессы будут ждать вечно.Это настройка по умолчанию и рекомендуется.</target>
        </trans-unit>
        <trans-unit id="57bb7a66b14f683a002bf6e9ed419bdbfaba4540" translate="yes" xml:space="preserve">
          <source>If you simply need to check quickly to see if a module is available, you can check for its documentation. If you can read the documentation the module is most likely installed. If you cannot read the documentation, the module might not have any (in rare cases):</source>
          <target state="translated">Если вам просто нужно быстро проверить,доступен ли модуль,вы можете проверить его документацию.Если вы можете прочитать документацию,то,скорее всего,модуль установлен.Если вы не можете прочитать документацию,модуль может отсутствовать (в редких случаях):</target>
        </trans-unit>
        <trans-unit id="8217a1604a7e6dedea6a0a5e3eee8fea23c61b15" translate="yes" xml:space="preserve">
          <source>If you simply want &lt;code&gt;TAP::Parser&lt;/code&gt; to handle a new source of TAP you probably don't need to subclass &lt;code&gt;TAP::Parser&lt;/code&gt; itself. Rather, you'll need to create a new &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; class, and just plug it into the parser using the</source>
          <target state="translated">Если вы просто хотите, чтобы &lt;code&gt;TAP::Parser&lt;/code&gt; обрабатывал новый источник TAP, вам, вероятно, не нужно создавать подкласс самого &lt;code&gt;TAP::Parser&lt;/code&gt; . Вместо этого вам нужно создать новый класс &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; и просто подключить его к парсеру с помощью</target>
        </trans-unit>
        <trans-unit id="bccc23097030849c37e4990da975ad564b128d6e" translate="yes" xml:space="preserve">
          <source>If you simply want to check that a variable contains an object reference, we recommend that you use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; blessed($object)&lt;/code&gt; , since &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; returns true values for all references, not just objects.</source>
          <target state="translated">Если вы просто хотите проверить, что переменная содержит ссылку на объект, мы рекомендуем использовать &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; blessed($object)&lt;/code&gt; , поскольку &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; возвращает истинные значения для всех ссылок, а не только для объектов.</target>
        </trans-unit>
        <trans-unit id="538504cf71c29fca71496cb30f3e2c1293640623" translate="yes" xml:space="preserve">
          <source>If you simply want to do a little tweaking of how the tests behave, you can access the underlying &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; object like so:</source>
          <target state="translated">Если вы просто хотите немного настроить поведение тестов, вы можете получить доступ к базовому объекту &lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="e8d0959c4e3749a28ef9e062bf2ea64f531c9a4d" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;'&amp;lt;&amp;amp;=X'&lt;/code&gt; , where &lt;code&gt;X&lt;/code&gt; is a file descriptor number or a filehandle, then Perl will do an equivalent of C's &lt;code&gt;fdopen&lt;/code&gt; of that file descriptor (and not call &lt;code&gt;dup(2)&lt;/code&gt; ); this is more parsimonious of file descriptors. For example:</source>
          <target state="translated">Если вы укажете &lt;code&gt;'&amp;lt;&amp;amp;=X'&lt;/code&gt; , где &lt;code&gt;X&lt;/code&gt; - номер дескриптора файла или дескриптор файла, тогда Perl выполнит эквивалент &lt;code&gt;fdopen&lt;/code&gt; C этого дескриптора файла (а не вызовет &lt;code&gt;dup(2)&lt;/code&gt; ); это более экономный дескриптор файлов. Например:</target>
        </trans-unit>
        <trans-unit id="180f2fd51c0d498482504f1f96654a60c731b6ff" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;NUM_USES&lt;/code&gt; with an argument of</source>
          <target state="translated">Если вы укажете &lt;code&gt;NUM_USES&lt;/code&gt; с аргументом</target>
        </trans-unit>
        <trans-unit id="8d4306b9666c2a3ba16744fba22e147888a1f901" translate="yes" xml:space="preserve">
          <source>If you specify COMPRESS, then SUFFIX should also be altered, as it is needed to tell make the target file of the compression. Setting DIST_CP to ln can be useful, if you need to preserve the timestamps on your files. DIST_CP can take the values 'cp', which copies the file, 'ln', which links the file, and 'best' which copies symbolic links and links the rest. Default is 'best'.</source>
          <target state="translated">Если вы укажите COMPRESS,то SUFFIX тоже нужно изменить,так как это нужно сказать,чтобы сделать целевой файл сжатия.Установка DIST_CP в ln может быть полезна,если вам нужно сохранить временные метки на ваших файлах.DIST_CP может принимать значения 'cp',который копирует файл,'ln',который связывает файл,и 'best',который копирует символические ссылки и связывает остальные.По умолчанию это 'best'.</target>
        </trans-unit>
        <trans-unit id="fc451ad5db1446b8366614b6922be5421ce289a8" translate="yes" xml:space="preserve">
          <source>If you specify LIB or any INSTALL* variables they will not be affected by the PREFIX.</source>
          <target state="translated">Если вы укажете LIB или любые переменные INSTALL*,они не будут затронуты PREFIX.</target>
        </trans-unit>
        <trans-unit id="9241abdeaef157dc233bd737d1c5964fbf4c453e" translate="yes" xml:space="preserve">
          <source>If you specify both arguments, data will be discarded from the cache when either expiration condition holds.</source>
          <target state="translated">Если вы укажете оба аргумента,данные будут удалены из кэша при выполнении любого из условий истечения срока действия.</target>
        </trans-unit>
        <trans-unit id="ec224c3d56f48a286860fa26eb84c5ac4d399f4c" translate="yes" xml:space="preserve">
          <source>If you start with bullets or numbers, stick with them, as formatters use the first &quot;=item&quot; type to decide how to format the list.</source>
          <target state="translated">Если вы начинаете с пуль или цифр,придерживайтесь их,так как форматировщики используют первый тип &quot;=элемент&quot;,чтобы решить,как форматировать список.</target>
        </trans-unit>
        <trans-unit id="583108dc3c7ca5413e3c465d6f2c5b41f57d07b1" translate="yes" xml:space="preserve">
          <source>If you still need a different solution, try to develop another subroutine that fits your needs and submit the diffs to &lt;code&gt;makemaker@perl.org&lt;/code&gt;</source>
          <target state="translated">Если вам все еще нужно другое решение, попробуйте разработать другую подпрограмму, которая соответствует вашим потребностям, и отправьте &lt;code&gt;makemaker@perl.org&lt;/code&gt; по адресу makemaker@perl.org.</target>
        </trans-unit>
        <trans-unit id="a47b80b17f146bdd2f697c181154024073445f0f" translate="yes" xml:space="preserve">
          <source>If you still need commercial support &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActiveState&lt;/a&gt; offers this.</source>
          <target state="translated">Если вам все еще нужна коммерческая поддержка, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActiveState&lt;/a&gt; предлагает это.</target>
        </trans-unit>
        <trans-unit id="5b1b0c04cf56825c214a1e0c17a804ce5039d636" translate="yes" xml:space="preserve">
          <source>If you supply a code reference the subroutine will be called once for each line of output with the line as its only argument. Passed lines will have no trailing newline.</source>
          <target state="translated">Если вы дадите кодовую ссылку,то подпрограмма будет вызываться один раз для каждой строки вывода со строкой в качестве единственного аргумента.Пропущенные строки не будут иметь ни одной пропущенной новой строки.</target>
        </trans-unit>
        <trans-unit id="9c870447a33109e08d6ac4807e8b39152cd8060a" translate="yes" xml:space="preserve">
          <source>If you supply a function name with &lt;code&gt;INSTALL&lt;/code&gt; , memoize will install the new, memoized version of the function under the name you give. For example,</source>
          <target state="translated">Если вы укажете имя функции с помощью &lt;code&gt;INSTALL&lt;/code&gt; , memoize установит новую, мемоизированную версию функции под заданным вами именем. Например,</target>
        </trans-unit>
        <trans-unit id="f6165205f1f599d384067c9f25ff1f7dd1d17430" translate="yes" xml:space="preserve">
          <source>If you supply data which is not valid (month 27, second 1,000) the results will be unpredictable (so don't do that).</source>
          <target state="translated">Если вы предоставите данные,которые недействительны (27 месяц,вторая тысяча),результаты будут непредсказуемыми (поэтому не делайте этого).</target>
        </trans-unit>
        <trans-unit id="f2f171e34560b51f24a2295b658a384f71202d5b" translate="yes" xml:space="preserve">
          <source>If you think geographically the</source>
          <target state="translated">Если вы думаете,что географически</target>
        </trans-unit>
        <trans-unit id="50a6625675c788b39661b9a604d74414a739f593" translate="yes" xml:space="preserve">
          <source>If you think that you want to add a new command to Pod (like, say, a &quot;=biblio&quot; command), consider whether you could get the same effect with a for or begin/end sequence: &quot;=for biblio ...&quot; or &quot;=begin biblio&quot; ... &quot;=end biblio&quot;. Pod processors that don't understand &quot;=for biblio&quot;, etc, will simply ignore it, whereas they may complain loudly if they see &quot;=biblio&quot;.</source>
          <target state="translated">Если вы думаете,что хотите добавить новую команду в Pod (например,команду &quot;=biblio&quot;),подумайте,можно ли получить тот же эффект с помощью последовательности for или start/end:&quot;=для библиотеки...&quot; или &quot;=начальная библиотека&quot;...&quot;=для библиотеки&quot;.Процессоры Pod,которые не понимают &quot;=для библиотеки&quot; и т.д.,просто проигнорируют это,в то время как они могут громко пожаловаться,если увидят &quot;=библио&quot;.</target>
        </trans-unit>
        <trans-unit id="0dc7def89e2edc18a212cddb050ecfe26b36c107" translate="yes" xml:space="preserve">
          <source>If you trust the archive, or have other reasons to allow the archive to write files outside your current working directory, set this variable to &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">Если вы доверяете архиву или у вас есть другие причины, позволяющие архиву записывать файлы вне вашего текущего рабочего каталога, установите для этой переменной значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6aec72dc70a1ee4a43ad060e5bdfa6e98825b4f" translate="yes" xml:space="preserve">
          <source>If you try &lt;code&gt;Moose&lt;/code&gt; and find that one of these issues is preventing you from using &lt;code&gt;Moose&lt;/code&gt; , we encourage you to consider &lt;a href=&quot;http://search.cpan.org/perldoc/Moo&quot;&gt;Moo&lt;/a&gt; next. &lt;code&gt;Moo&lt;/code&gt; implements a subset of &lt;code&gt;Moose&lt;/code&gt; 's functionality in a simpler package. For most features that it does implement, the end-user API is</source>
          <target state="translated">Если вы попробуете &lt;code&gt;Moose&lt;/code&gt; и обнаружите, что одна из этих проблем мешает вам использовать &lt;code&gt;Moose&lt;/code&gt; , мы рекомендуем вам в следующий раз подумать о &lt;a href=&quot;http://search.cpan.org/perldoc/Moo&quot;&gt;Moo&lt;/a&gt; . &lt;code&gt;Moo&lt;/code&gt; реализует подмножество функций &lt;code&gt;Moose&lt;/code&gt; в более простом пакете. Для большинства функций, которые он реализует, API конечного пользователя</target>
        </trans-unit>
        <trans-unit id="ce64d2eb6b26fca2ba64557ff812899e21e2cf8b" translate="yes" xml:space="preserve">
          <source>If you try to add a file to @INC as follows:</source>
          <target state="translated">Если вы попытаетесь добавить файл в @INC следующим образом:</target>
        </trans-unit>
        <trans-unit id="e1047e2245ed732ddd158d44ef63171c1040f4d7" translate="yes" xml:space="preserve">
          <source>If you try to dereference the key, it won't do a hard dereference, and you won't accomplish what you're attempting. You might want to do something more like</source>
          <target state="translated">Если вы попытаетесь разыменовать ключ,он не сделает сложного разыменования,и вы не выполните то,что пытаетесь сделать.Возможно,вы захотите сделать что-то более похожее на</target>
        </trans-unit>
        <trans-unit id="b64e549b9d0f70c710cd7ee8a843df08eb7e123c" translate="yes" xml:space="preserve">
          <source>If you try to do something insecure, you will get a fatal error saying something like &quot;Insecure dependency&quot; or &quot;Insecure $ENV{PATH}&quot;.</source>
          <target state="translated">Если вы попытаетесь сделать что-то небезопасное,вы получите фатальную ошибку,говоря что-то вроде &quot;Небезопасная зависимость&quot; или &quot;Небезопасный $ENV{PATH}&quot;.</target>
        </trans-unit>
        <trans-unit id="baaf467929bddd8fa5b7aa6c26404c219da0153b" translate="yes" xml:space="preserve">
          <source>If you try to do the same thing with what you think is a list, you get a quite different result. Although it looks like you have a list on the righthand side, Perl actually sees a bunch of scalars separated by a comma:</source>
          <target state="translated">Если вы попытаетесь сделать то же самое с тем,что вы считаете списком,вы получите совершенно другой результат.Хотя это выглядит так,как будто у вас есть список справа,Perl на самом деле видит кучу скаляров,разделенных запятой:</target>
        </trans-unit>
        <trans-unit id="e39b81693bb33881d5354ed40ab1aa5e5e421f38" translate="yes" xml:space="preserve">
          <source>If you try to import an unimplemented function in the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement it will fail at compile time.</source>
          <target state="translated">Если вы попытаетесь импортировать нереализованную функцию в операторе &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; она завершится ошибкой во время компиляции.</target>
        </trans-unit>
        <trans-unit id="ce84b9139b9e943d624385f2da9d34f42bd6117a" translate="yes" xml:space="preserve">
          <source>If you try to read from the child's stdout writer and their stderr writer, you'll have problems with blocking, which means you'll want to use select() or the IO::Select, which means you'd best use sysread() instead of readline() for normal stuff.</source>
          <target state="translated">Если вы попытаетесь читать из дочернего stdout writer и их stderr writeer,у вас будут проблемы с блокировкой,что означает,что вы захотите использовать select()или IO::Select,что означает,что для обычных вещей лучше всего использовать sysread()вместо readline().</target>
        </trans-unit>
        <trans-unit id="8629095d12898edeef813ea5adb0d8466406ccc7" translate="yes" xml:space="preserve">
          <source>If you try to use a reference like a string, you get strings like</source>
          <target state="translated">Если вы попытаетесь использовать ссылку как строку,вы получите строки типа</target>
        </trans-unit>
        <trans-unit id="39dd9c9407d1478c40154f713c3d3db1f745db97" translate="yes" xml:space="preserve">
          <source>If you try to use an alphanumeric sequence in a prototype you will generate an optional warning - &quot;Illegal character in prototype...&quot;. Unfortunately earlier versions of Perl allowed the prototype to be used as long as its prefix was a valid prototype. The warning may be upgraded to a fatal error in a future version of Perl once the majority of offending code is fixed.</source>
          <target state="translated">Если вы попытаетесь использовать буквенно-цифровую последовательность в прототипе,то сгенерируете необязательное предупреждение-&quot;Незаконный символ в прототипе...&quot;.К сожалению,более ранние версии Perl позволяли использовать прототип до тех пор,пока его префикс был действительным прототипом.Предупреждение может быть обновлено до фатальной ошибки в будущей версии Perl,как только будет исправлено большинство ошибочного кода.</target>
        </trans-unit>
        <trans-unit id="fe9a752d3dfb5ae4ddbce9b50462b1f6d85d68b3" translate="yes" xml:space="preserve">
          <source>If you try to use code expressions where the code text is contained within an interpolated variable, rather than appearing literally in the pattern, Perl may surprise you:</source>
          <target state="translated">Если попытаться использовать выражения кода,в которых текст кода содержится в интерполированной переменной,а не появляется буквально в шаблоне,Perl может удивить вас:</target>
        </trans-unit>
        <trans-unit id="b74ccad2ea9ca8d857dc7afb6d54fa03395dd0f9" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; in your handler for $SIG{CHLD}, it may accidentally wait for the child created by qx() or system(). See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">Если вы используете &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; в своем обработчике для $ SIG {CHLD}, он может случайно дождаться дочернего элемента, созданного qx () или system (). См. Подробности в &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f489bb10b3438e3010da06cd3b95ce427029dc2" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; in your handler for $SIG{CHLD}, it may accidentally wait for the child created by qx() or system(). See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">Если вы используете &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; в своем обработчике для $ SIG {CHLD}, он может случайно дождаться дочернего элемента, созданного qx () или system (). См. Подробности в &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46bb44efb62948225ccf4e92dee64ae61f103a13" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;FilterName&lt;/code&gt; to modify the filename, it is your responsibility to keep the filename in Unix format.</source>
          <target state="translated">Если вы используете &lt;code&gt;FilterName&lt;/code&gt; для изменения имени файла, вы обязаны сохранить имя файла в формате Unix.</target>
        </trans-unit>
        <trans-unit id="16f11d3777f6f8b6ecfda56c2150f1df3c1a440a" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;harness&lt;/code&gt; for testing, you have several command line options available to you. The arguments are as follows, and are in the order that they must appear if used together.</source>
          <target state="translated">Если вы используете &lt;code&gt;harness&lt;/code&gt; для тестирования, вам доступны несколько параметров командной строки. Аргументы приведены ниже в том порядке, в котором они должны появляться при совместном использовании.</target>
        </trans-unit>
        <trans-unit id="5dace6a8fabe0f3fff4268587985038c8aa60a8e" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;man&lt;/code&gt; , either move the installed</source>
          <target state="translated">Если вы используете &lt;code&gt;man&lt;/code&gt; , либо переместите установленный</target>
        </trans-unit>
        <trans-unit id="f77d31c25362c9be9687e6ee59543d3904970c3a" translate="yes" xml:space="preserve">
          <source>If you use Sun's C compiler, make sure the correct directory (usually /opt/SUNWspro/bin/) is in your PATH (before /usr/ucb/).</source>
          <target state="translated">Если Вы используете компилятор С Sun,убедитесь,что правильный каталог (обычно /opt/SUNWspro/bin/)находится в Вашем PATH (до /usr/ucb/).</target>
        </trans-unit>
        <trans-unit id="694a362a82c6e3cfa50f1318ad85b6fb37d17685" translate="yes" xml:space="preserve">
          <source>If you use a Unicode editor to edit your program, Unicode characters may occur directly within the literal strings in UTF-8 encoding, or UTF-16. (The former requires a &lt;code&gt;BOM&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , the latter requires a &lt;code&gt;BOM&lt;/code&gt; .)</source>
          <target state="translated">Если вы используете редактор Unicode для редактирования своей программы, символы Unicode могут встречаться непосредственно в литеральных строках в кодировке UTF-8 или UTF-16. (Для первого требуется &lt;code&gt;BOM&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , для второго требуется &lt;code&gt;BOM&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="87cf615c227432610de49accfafc5d497f5d3f61" translate="yes" xml:space="preserve">
          <source>If you use a deprecated feature or module and believe that its removal from the Perl core would be a mistake, please contact the perl5-porters mailinglist and plead your case. We don't deprecate things without a good reason, but sometimes there's a counterargument we haven't considered. Historically, we did not distinguish between &quot;deprecated&quot; and &quot;discouraged&quot; features.</source>
          <target state="translated">Если вы используете устаревшую функцию или модуль и считаете,что его удаление из ядра Perl было бы ошибкой,пожалуйста,свяжитесь с почтовым списком perl5-портеров и аргументируйте свое решение.Мы не делаем изъятий без уважительной причины,но иногда есть контраргумент,который мы не рассмотрели.Исторически мы не делали различия между &quot;депрессивными&quot; и &quot;обескураженными&quot; признаками.</target>
        </trans-unit>
        <trans-unit id="5dd282c0cc211cebd60be34d73466e199fdff472" translate="yes" xml:space="preserve">
          <source>If you use a here-doc within a delimited construct, such as in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///eg&lt;/a&gt;&lt;/code&gt;, the quoted material must still come on the line following the &lt;code&gt;&amp;lt;&amp;lt;FOO&lt;/code&gt; marker, which means it may be inside the delimited construct:</source>
          <target state="translated">Если вы используете документ here-doc в конструкции с разделителями, например, в &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///eg&lt;/a&gt;&lt;/code&gt; , цитируемый материал все равно должен находиться в строке, следующей за маркером &lt;code&gt;&amp;lt;&amp;lt;FOO&lt;/code&gt; , что означает, что он может находиться внутри конструкции с разделителями:</target>
        </trans-unit>
        <trans-unit id="6ae0c0867250fd5a479e543aea928a9a77d11b83" translate="yes" xml:space="preserve">
          <source>If you use deferred writing (See &lt;a href=&quot;#Deferred-Writing&quot;&gt;Deferred Writing&lt;/a&gt;, below) then data you write into the array will not be written directly to the file; instead, it will be saved in the</source>
          <target state="translated">Если вы используете отложенную запись (см. &amp;laquo; &lt;a href=&quot;#Deferred-Writing&quot;&gt;Отложенная запись&amp;raquo;&lt;/a&gt; ниже), то данные, которые вы записываете в массив, не будут записываться непосредственно в файл; вместо этого он будет сохранен в</target>
        </trans-unit>
        <trans-unit id="4f2793be84e03f881815cfd6cbd437f560ace728" translate="yes" xml:space="preserve">
          <source>If you use either the R_IAFTER or R_IBEFORE flags, the &lt;code&gt;$key&lt;/code&gt; parameter will have the record number of the inserted key/value pair set.</source>
          <target state="translated">Если вы используете флаги R_IAFTER или R_IBEFORE, параметр &lt;code&gt;$key&lt;/code&gt; будет иметь номер записи вставленной пары ключ / значение.</target>
        </trans-unit>
        <trans-unit id="7804e89f419dfb4afe57d175e577f649678035a8" translate="yes" xml:space="preserve">
          <source>If you use gcc, make sure your installation is recent and complete. perl versions since 5.6.0 build fine with gcc &amp;gt; 2.8.1 on Solaris &amp;gt;= 2.6.</source>
          <target state="translated">Если вы используете gcc, убедитесь, что ваша установка выполнена недавно и завершена. Версии perl, начиная с 5.6.0, отлично собираются с gcc&amp;gt; 2.8.1 на Solaris&amp;gt; = 2.6.</target>
        </trans-unit>
        <trans-unit id="c133e612772c5c91ca38653bb618cdde5ecf7eea" translate="yes" xml:space="preserve">
          <source>If you use one of the undocumented functions below, you may wish to consider creating and submitting documentation for it. If your patch is accepted, this will indicate that the interface is stable (unless it is explicitly marked otherwise).</source>
          <target state="translated">Если вы используете одну из недокументированных ниже функций,вы можете рассмотреть вопрос о создании и подаче документации для нее.Если ваш патч принят,это будет означать,что интерфейс стабилен (если только он не отмечен явным образом).</target>
        </trans-unit>
        <trans-unit id="97a1d75ada82bbf9f654420e7c70ad3899b98121" translate="yes" xml:space="preserve">
          <source>If you use preprocessor directives to choose one of two versions of a function, use</source>
          <target state="translated">Если вы используете директивы препроцессора для выбора одной из двух версий функции,то используйте</target>
        </trans-unit>
        <trans-unit id="32e7fdaa4b2e816b8b9a792f2d7c56bbe0d52ad7" translate="yes" xml:space="preserve">
          <source>If you use the 4DOS/NT or similar command shell, note that &quot;pl2bat&quot; uses the &quot;%*&quot; variable in the generated batch file to refer to all the command line arguments, so you may need to make sure that construct works in batch files. As of this writing, 4DOS/NT users will need a &quot;ParameterChar = *&quot; statement in their 4NT.INI file or will need to execute &quot;setdos /p*&quot; in the 4DOS/NT startup file to enable this to work.</source>
          <target state="translated">Если вы используете 4DOS/NT или аналогичную командную оболочку,обратите внимание,что &quot;pl2bat&quot; использует переменную &quot;%*&quot; в генерируемом пакетном файле для ссылки на все аргументы командной строки,поэтому вам может потребоваться убедиться,что конструкция работает в пакетных файлах.На момент написания этой статьи пользователям 4DOS/NT понадобится оператор &quot;ParameterChar=*&quot; в их файле 4DOS/NT,или нужно будет выполнить &quot;setdos /p*&quot; в загрузочном файле 4DOS/NT,чтобы это сработало.</target>
        </trans-unit>
        <trans-unit id="91300f437c633a42a75ef31ebaae0d2065c281bd" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; PerlIO layer for input, invalid byte sequences are handled gracefully, but if you use &lt;code&gt;:utf8&lt;/code&gt; , the flag is set without validating the data, possibly resulting in this error message.</source>
          <target state="translated">Если вы используете слой PerlIO &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; для ввода, недопустимые последовательности байтов обрабатываются корректно, но если вы используете &lt;code&gt;:utf8&lt;/code&gt; , флаг устанавливается без проверки данных, что может привести к появлению этого сообщения об ошибке.</target>
        </trans-unit>
        <trans-unit id="3eecf6412d7114c8844a3dfb8554c44c0eb8598c" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;SA_SIGINFO&lt;/code&gt; flag, the signal handler will in addition to the first argument, the signal name, also receive a second argument, a hash reference, inside which are the following keys with the following semantics, as defined by POSIX/SUSv3:</source>
          <target state="translated">Если вы используете флаг &lt;code&gt;SA_SIGINFO&lt;/code&gt; , обработчик сигнала в дополнение к первому аргументу, имени сигнала, также получит второй аргумент, хеш-ссылку, внутри которой находятся следующие ключи со следующей семантикой, как определено в POSIX / SUSv3:</target>
        </trans-unit>
        <trans-unit id="dc06c253841f15b9de0c355618356ed5550da10d" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\G&lt;/code&gt; anchor, you force the match after &lt;code&gt;22&lt;/code&gt; to start with the &lt;code&gt;a&lt;/code&gt; . The regular expression cannot match there since it does not find a digit, so the next match fails and the match operator returns the pairs it already found.</source>
          <target state="translated">Если вы используете &lt;code&gt;\G&lt;/code&gt; , вы заставляете совпадение после &lt;code&gt;22&lt;/code&gt; начинаться с &lt;code&gt;a&lt;/code&gt; . Регулярное выражение не может соответствовать там, поскольку оно не находит цифру, поэтому следующее сопоставление не удается, и оператор сопоставления возвращает пары, которые он уже нашел.</target>
        </trans-unit>
        <trans-unit id="fbb20a66ed661494874fa5e98a73f246a9cc34cc" translate="yes" xml:space="preserve">
          <source>If you use the English module, you can even read the variable names:</source>
          <target state="translated">Если вы используете английский модуль,вы даже можете читать имена переменных:</target>
        </trans-unit>
        <trans-unit id="abbbac8010fcf4e1f8177dc8b18103356d7c1579" translate="yes" xml:space="preserve">
          <source>If you use the form &lt;code&gt;\N{&lt;i&gt;character name&lt;/i&gt;}&lt;/code&gt;, the &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; module gets automatically loaded. This may not be suitable for the test level you are doing.</source>
          <target state="translated">Если вы используете форму &lt;code&gt;\N{&lt;i&gt;character name&lt;/i&gt;}&lt;/code&gt; , модуль &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; загружается автоматически. Это может не подходить для вашего уровня тестирования.</target>
        </trans-unit>
        <trans-unit id="b6639f5cfc711b71b35423e81c784a209aabfc93" translate="yes" xml:space="preserve">
          <source>If you use the hash syntax, you have no control over the order in which the ExtraSubFields are stored, plus you cannot have SubFields with duplicate ID.</source>
          <target state="translated">Если вы используете синтаксис хэша,вы не можете контролировать порядок,в котором хранятся ExtraSubFields,плюс вы не можете иметь SubFields с дубликатом ID.</target>
        </trans-unit>
        <trans-unit id="cf9048b3298377c86c20ad5d8b5d02655bc3f8b6" translate="yes" xml:space="preserve">
          <source>If you use the raw format, and the &lt;code&gt;Strict&lt;/code&gt; option is enabled, &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; will check that &lt;code&gt;$rawdata&lt;/code&gt; consists of zero or more conformant sub-fields. When &lt;code&gt;Strict&lt;/code&gt; is disabled, &lt;code&gt;$rawdata&lt;/code&gt; can consist of any arbitrary byte stream.</source>
          <target state="translated">Если вы используете необработанный формат и включена опция &lt;code&gt;Strict&lt;/code&gt; , &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; проверит, что &lt;code&gt;$rawdata&lt;/code&gt; состоит из нуля или более соответствующих подполей. Когда &lt;code&gt;Strict&lt;/code&gt; отключено, &lt;code&gt;$rawdata&lt;/code&gt; может состоять из любого произвольного байтового потока.</target>
        </trans-unit>
        <trans-unit id="c067123fb137430de0f256b297d516b2001d264a" translate="yes" xml:space="preserve">
          <source>If you use utf8 or other non-ASCII characters with Test::More you might get a &quot;Wide character in print&quot; warning. Using &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt; STDOUT, &quot;:utf8&quot;&lt;/code&gt; will not fix it. &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; (which powers Test::More) duplicates STDOUT and STDERR. So any changes to them, including changing their output disciplines, will not be seem by Test::More.</source>
          <target state="translated">Если вы используете utf8 или другие символы, отличные от ASCII, с Test :: More, вы можете получить предупреждение &amp;laquo;Широкий символ при печати&amp;raquo;. Использование &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt; STDOUT, &quot;:utf8&quot;&lt;/code&gt; не исправит это. &lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt; (который поддерживает Test :: More) дублирует STDOUT и STDERR. Таким образом, любые изменения в них, включая изменение их дисциплин вывода, Test :: More не будут видны.</target>
        </trans-unit>
        <trans-unit id="630840ae944c06429550447e9540c0ca707dbc1a" translate="yes" xml:space="preserve">
          <source>If you used WinZip, this was already done for you.</source>
          <target state="translated">Если вы использовали WinZip,это уже было сделано за вас.</target>
        </trans-unit>
        <trans-unit id="8c53b3ef6362ad03c7dbea52d0c4786e608f8e77" translate="yes" xml:space="preserve">
          <source>If you used git to check out the Perl source, then using &lt;code&gt;git
format-patch&lt;/code&gt; will produce a patch in a style suitable for Perl. The &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format-patch&lt;/a&gt;&lt;/code&gt; command produces one patch file for each commit you made. If you prefer to send a single patch for all commits, you can use &lt;code&gt;git diff&lt;/code&gt; .</source>
          <target state="translated">Если вы использовали git для проверки исходного кода Perl, то при использовании &lt;code&gt;git format-patch&lt;/code&gt; будет создан патч в стиле, подходящем для Perl. Команда &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format-patch&lt;/a&gt;&lt;/code&gt; создает один файл исправления для каждой сделанной вами фиксации. Если вы предпочитаете отправлять один патч для всех коммитов, вы можете использовать &lt;code&gt;git diff&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bc21e512fb418bd39c6e536f3bdd95478cb7d3c" translate="yes" xml:space="preserve">
          <source>If you want $x to have a certain sign, use one of the following methods:</source>
          <target state="translated">Если вы хотите,чтобы у $x был определенный знак,используйте один из следующих методов:</target>
        </trans-unit>
        <trans-unit id="1553678828e2328fa0aa14746ccfdd7229ce26f6" translate="yes" xml:space="preserve">
          <source>If you want *.ucm installed together with the modules, do as follows;</source>
          <target state="translated">Если вы хотите,чтобы *.ucm был установлен вместе с модулями,сделайте следующее;</target>
        </trans-unit>
        <trans-unit id="791324333537699862b9ce903fa1af5980ed496f" translate="yes" xml:space="preserve">
          <source>If you want a &quot;real&quot; C &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; (see</source>
          <target state="translated">Если вы хотите &quot;настоящий&quot; C &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; (см.</target>
        </trans-unit>
        <trans-unit id="c13df57b95397c5f1d723459f0b855e899e41a8a" translate="yes" xml:space="preserve">
          <source>If you want a &quot;real&quot; C &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; (see</source>
          <target state="translated">Если вы хотите &quot;настоящий&quot; C &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; (см.</target>
        </trans-unit>
        <trans-unit id="cb1d7bd468d379f255df6d0a8a45090fecae8882" translate="yes" xml:space="preserve">
          <source>If you want a Perl application to process and present your data according to a particular locale, the application code should include the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma (see &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma&lt;/a&gt;) where appropriate, and &lt;b&gt;at least one&lt;/b&gt; of the following must be true:</source>
          <target state="translated">Если вы хотите, чтобы приложение Perl обрабатывало и представляло ваши данные в соответствии с определенной локалью, код приложения должен включать прагму &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (см &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;. Прагму use locale&lt;/a&gt; ), где это необходимо, и &lt;b&gt;хотя бы одно&lt;/b&gt; из следующего должно быть истинным:</target>
        </trans-unit>
        <trans-unit id="dc8f1faa6c36903ecd5d1abeecfdbd92380ab3a3" translate="yes" xml:space="preserve">
          <source>If you want a better approximation of the square root, then use:</source>
          <target state="translated">Если вы хотите получить лучшее приближение квадратного корня,то используйте:</target>
        </trans-unit>
        <trans-unit id="409579e935815d3f9b1b191e4808eba939430e40" translate="yes" xml:space="preserve">
          <source>If you want a completely new Test::Builder object different from the singleton, use &lt;code&gt;create&lt;/code&gt; .</source>
          <target state="translated">Если вам нужен совершенно новый объект Test :: Builder, отличный от синглтона, используйте &lt;code&gt;create&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="364287807494857e0923c716161b8323aaaa85ad" translate="yes" xml:space="preserve">
          <source>If you want a list of all of the Perl module filenames, you can use &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt;:</source>
          <target state="translated">Если вам нужен список всех имен файлов модулей Perl, вы можете использовать &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File :: Find :: Rule&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="20d03f9f8d59c035c39fd85e8955d33568507a9f" translate="yes" xml:space="preserve">
          <source>If you want a real Perl scalar, use &lt;code&gt;numify()&lt;/code&gt; :</source>
          <target state="translated">Если вам нужен настоящий скаляр Perl, используйте &lt;code&gt;numify()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9309fd012fc6beaef72da428ac578230d08f400e" translate="yes" xml:space="preserve">
          <source>If you want a supported version of perl for OpenVOS, purchase the OpenVOS GNU Tools product from Stratus Technologies, along with a support contract (or from anyone else who will sell you support).</source>
          <target state="translated">Если вам нужна поддерживаемая версия perl для OpenVOS,купите продукт OpenVOS GNU Tools у Stratus Technologies,вместе с контрактом на поддержку (или у любого,кто продаст вам поддержку).</target>
        </trans-unit>
        <trans-unit id="6584c0a384e584f13abe302cec979af6b67c1d61" translate="yes" xml:space="preserve">
          <source>If you want a true copy of $x, use:</source>
          <target state="translated">Если вам нужна настоящая копия $x,используйте:</target>
        </trans-unit>
        <trans-unit id="2bd3ed425ef919c14360d525b51cc98be9af477c" translate="yes" xml:space="preserve">
          <source>If you want access to threads, you must &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; before you &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; will emit a warning if you use it after &lt;a href=&quot;shared&quot;&gt;threads::shared&lt;/a&gt;.</source>
          <target state="translated">Если вам нужен доступ к потокам, вы должны &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; перед тем, как &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . &lt;a href=&quot;../threads&quot;&gt;потоки&lt;/a&gt; выдадут предупреждение, если вы используете его после &lt;a href=&quot;shared&quot;&gt;потоков :: shared&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ffb4d0fb6b209221b80f1da704496ad8ce1ebe0" translate="yes" xml:space="preserve">
          <source>If you want an IDE, check the following (in alphabetical order, not order of preference):</source>
          <target state="translated">Если вы хотите IDE,проверьте следующее (в алфавитном порядке,а не в порядке предпочтений):</target>
        </trans-unit>
        <trans-unit id="fe93301108d8dca54392bf8f900a5e24a5258416" translate="yes" xml:space="preserve">
          <source>If you want anything fancier, consider overriding this with something that uses &lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number::Format&lt;/a&gt;, or does something else entirely.</source>
          <target state="translated">Если вам нужно что-то более интересное, подумайте о том, чтобы заменить это чем-то, что использует &lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number :: Format&lt;/a&gt; или делает что-то совсем другое.</target>
        </trans-unit>
        <trans-unit id="03e2f095ee9c1b96484a23c04f5e5dfef232e04c" translate="yes" xml:space="preserve">
          <source>If you want build some core extensions statically into perl's dll, specify them in the STATIC_EXT macro.</source>
          <target state="translated">Если вы хотите собрать некоторые расширения ядра статически в perl's dll,укажите их в макросе STATIC_EXT.</target>
        </trans-unit>
        <trans-unit id="18b0e9b36c2f4eaca25552fa7c7631a4398f6336" translate="yes" xml:space="preserve">
          <source>If you want finer granularity than the 1 second that the &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; function provides, the easiest way is to use the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; function as documented in &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;. Try the &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; and the &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Itimer&quot;&gt;BSD::Itimer&lt;/a&gt; modules (available from CPAN, and starting from Perl 5.8 &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; is part of the standard distribution).</source>
          <target state="translated">Если вам нужна более тонкая детализация, чем 1 секунда, которую предоставляет функция &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; , самый простой способ - использовать функцию &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; как описано в &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; . Попробуйте модули &lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt; и &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Itimer&quot;&gt;BSD :: Itimer&lt;/a&gt; (доступны на CPAN, а начиная с Perl 5.8 &lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt; является частью стандартного дистрибутива).</target>
        </trans-unit>
        <trans-unit id="e14afa459a95e2ee1097bdb5d465fc670f04bf72" translate="yes" xml:space="preserve">
          <source>If you want it to be a Unicode string (because you want character semantics with operations like regular expression matching), you need to decode the UTF8-encoded content and have Perl convert it into a Unicode string:</source>
          <target state="translated">Если вы хотите,чтобы это была строка Юникода (потому что вам нужна семантика символов с такими операциями,как сравнение регулярных выражений),вам нужно декодировать содержимое в кодировке UTF8 и заставить Perl преобразовать его в строку Юникода:</target>
        </trans-unit>
        <trans-unit id="b68288a6982fc2b55a1d1fa4ad5b3ecc68be5d47" translate="yes" xml:space="preserve">
          <source>If you want more flexibility, you need to configure your CPAN client for your particular situation.</source>
          <target state="translated">Если Вы хотите больше гибкости,Вам необходимо настроить CPAN клиента для Вашей конкретной ситуации.</target>
        </trans-unit>
        <trans-unit id="212545de9d894bed7fa89be5bf884693fe7c603b" translate="yes" xml:space="preserve">
          <source>If you want no headers or footers output in the HTML, set these options to the empty string.</source>
          <target state="translated">Если вы хотите,чтобы в HTML не выводились заголовки или колонтитулы,установите эти опции на пустую строку.</target>
        </trans-unit>
        <trans-unit id="2be3f922578397a2f9698c9c71abc2a55e6ed43d" translate="yes" xml:space="preserve">
          <source>If you want perl to use globbing that emulates the quirks of DOS filename conventions, you might want to consider using File::DosGlob to override the internal glob() implementation. See &lt;a href=&quot;file/dosglob&quot;&gt;File::DosGlob&lt;/a&gt; for details.</source>
          <target state="translated">Если вы хотите, чтобы в Perl использовалась подстановка имен, имитирующая особенности соглашений об именах файлов DOS, вы можете рассмотреть возможность использования File :: DosGlob для переопределения внутренней реализации glob (). Подробнее см. &lt;a href=&quot;file/dosglob&quot;&gt;File :: DosGlob&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08c46a24da2bb06c6e1c6ef38a1abe76f47d9a13" translate="yes" xml:space="preserve">
          <source>If you want read lines, you must read in list context.</source>
          <target state="translated">Если вы хотите читать строки,вы должны читать в контексте списка.</target>
        </trans-unit>
        <trans-unit id="9bfb8a43a2ce5fcca125d20e873c4c7b11aed7e7" translate="yes" xml:space="preserve">
          <source>If you want the &lt;code&gt;atexit()&lt;/code&gt; syntax (and an &lt;code&gt;rmexit()&lt;/code&gt; as well), try the &lt;code&gt;AtExit&lt;/code&gt; module available from CPAN.</source>
          <target state="translated">Если вам нужен синтаксис &lt;code&gt;atexit()&lt;/code&gt; (а также &lt;code&gt;rmexit()&lt;/code&gt; ), попробуйте модуль &lt;code&gt;AtExit&lt;/code&gt; , доступный на CPAN.</target>
        </trans-unit>
        <trans-unit id="124ea0ab66186e4216274d303cbf33e4b47044f9" translate="yes" xml:space="preserve">
          <source>If you want the array index, use the &lt;code&gt;firstidx()&lt;/code&gt; function from &lt;code&gt;List::MoreUtils&lt;/code&gt; :</source>
          <target state="translated">Если вам нужен индекс массива, используйте &lt;code&gt;firstidx()&lt;/code&gt; из &lt;code&gt;List::MoreUtils&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7615fa2a66b55733775cb5d887a00d84846653ee" translate="yes" xml:space="preserve">
          <source>If you want the code to die instead of falling back, use &lt;code&gt;only&lt;/code&gt; instead:</source>
          <target state="translated">Если вы хотите, чтобы код умер вместо отката, используйте &lt;code&gt;only&lt;/code&gt; вместо этого:</target>
        </trans-unit>
        <trans-unit id="5f643e51c29ad1dcf8382df154f107e9e891d49b" translate="yes" xml:space="preserve">
          <source>If you want the code to die instead, replace &quot;try&quot; with &quot;only&quot;:</source>
          <target state="translated">Если вы хотите,чтобы код умер вместо этого,замените &quot;try&quot; на &quot;only&quot;:</target>
        </trans-unit>
        <trans-unit id="444d833c4fe34c4ebf55ce0643031f3aa4615d34" translate="yes" xml:space="preserve">
          <source>If you want the equivalent of &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Foo ()&lt;/code&gt; , use a module but not import anything, use &lt;code&gt;require_ok&lt;/code&gt; .</source>
          <target state="translated">Если вам нужен эквивалент &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Foo ()&lt;/code&gt; , используйте модуль, но ничего не импортируйте, используйте &lt;code&gt;require_ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ebff181122cf920b540aa12f6f2468119acea8d" translate="yes" xml:space="preserve">
          <source>If you want the old signal behavior back despite possible memory corruption, set the environment variable &lt;code&gt;PERL_SIGNALS&lt;/code&gt; to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; . This feature first appeared in Perl 5.8.1.</source>
          <target state="translated">Если вы хотите вернуть прежнее поведение сигнала, несмотря на возможное повреждение памяти, установите для переменной среды &lt;code&gt;PERL_SIGNALS&lt;/code&gt; значение &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; . Эта функция впервые появилась в Perl 5.8.1.</target>
        </trans-unit>
        <trans-unit id="35e2e89a1af9e4f4ab883e1fb265f28d997edb48" translate="yes" xml:space="preserve">
          <source>If you want these output in a sorted order, see &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;: &quot;How do I sort a hash (optionally by value instead of key)?&quot;.</source>
          <target state="translated">Если вы хотите, чтобы эти выходные данные были отсортированы, см. &lt;a href=&quot;perlfaq4&quot;&gt;Perlfaq4&lt;/a&gt; : &amp;laquo;Как мне отсортировать хеш (необязательно по значению вместо ключа)?&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="1340d84f704d5f6a74163cc5fe06ae9be150fb8b" translate="yes" xml:space="preserve">
          <source>If you want to &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; into a string, you just have to &amp;lt;open&amp;gt; a filehandle to a string, which Perl has been able to do since Perl 5.6:</source>
          <target state="translated">Если вы хотите &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; в строку, вам просто нужно &amp;lt;открыть&amp;gt; дескриптор файла для строки, что Perl может делать начиная с Perl 5.6:</target>
        </trans-unit>
        <trans-unit id="7953e238f104e2cdb7abf22e43568bf172380a8b" translate="yes" xml:space="preserve">
          <source>If you want to CLONE all objects you will need to keep track of them per package. This is simply done using a hash and Scalar::Util::weaken().</source>
          <target state="translated">Если вы хотите CLONE все объекты,вам нужно будет отслеживать их по каждому пакету.Это просто делается с помощью хэша и Scalar::Util::weaken().</target>
        </trans-unit>
        <trans-unit id="8a750f90ba1cfc2d81f044342057667c6ac1726e" translate="yes" xml:space="preserve">
          <source>If you want to actually extract the matching elements, simply use grep in list context.</source>
          <target state="translated">Если вы хотите извлечь соответствующие элементы,просто используйте grep в контексте списка.</target>
        </trans-unit>
        <trans-unit id="d026b5d2f0b8d0ebf6352db336c8a293bea0fac9" translate="yes" xml:space="preserve">
          <source>If you want to add your encoding to Encode's demand-loading list (so you don't have to &quot;use Encode::YourEncoding&quot;), run</source>
          <target state="translated">Если вы хотите добавить свою кодировку в список запросов Encode (чтобы вам не приходилось &quot;использовать Encode::YourEncoding&quot;),запустите команду</target>
        </trans-unit>
        <trans-unit id="3ceac82578bb19fb50532d7256faa44ce8c265df" translate="yes" xml:space="preserve">
          <source>If you want to append something to the end of string stored in an &lt;code&gt;SV*&lt;/code&gt; , you can use the following functions:</source>
          <target state="translated">Если вы хотите добавить что-то в конец строки, хранящейся в &lt;code&gt;SV*&lt;/code&gt; , вы можете использовать следующие функции:</target>
        </trans-unit>
        <trans-unit id="5fbae8e9319ec5948bcc63aa24cae46d2c786676" translate="yes" xml:space="preserve">
          <source>If you want to be sure that you're calling &lt;code&gt;isa&lt;/code&gt; as a method, not a class, check the invocand with &lt;code&gt;blessed&lt;/code&gt; from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; first:</source>
          <target state="translated">Если вы хотите быть уверенным, что вызываете &lt;code&gt;isa&lt;/code&gt; как метод, а не как класс, сначала проверьте invocand с помощью &lt;code&gt;blessed&lt;/code&gt; из &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="363081145dde14f7c8fd4e2bf011a936ad34c73a" translate="yes" xml:space="preserve">
          <source>If you want to break apart an entire line of fixed columns, you can use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the A (ASCII) format. By using a number after the format specifier, you can denote the column width. See the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; entries in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="translated">Если вы хотите разбить целую строку фиксированных столбцов, вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; в формате A (ASCII). Используя число после спецификатора формата, вы можете обозначить ширину столбца. Для получения более подробной информации &lt;a href=&quot;perlfunc&quot;&gt;смотрите&lt;/a&gt; записи &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; в perlfunc .</target>
        </trans-unit>
        <trans-unit id="10e8c447f2a79196fb827a87399f6352fddeb35d" translate="yes" xml:space="preserve">
          <source>If you want to build the docs yourself, and have</source>
          <target state="translated">Если ты хочешь построить доктора самостоятельно,и иметь</target>
        </trans-unit>
        <trans-unit id="3016ac8f3431196221d3334c73f10b4a58c7afce" translate="yes" xml:space="preserve">
          <source>If you want to call C from Perl, start with &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, moving on to &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;, &lt;a href=&quot;xsubpp&quot;&gt;xsubpp&lt;/a&gt;, and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;. If you want to call Perl from C, then read &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;, &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;, and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;. Don't forget that you can learn a lot from looking at how the authors of existing extension modules wrote their code and solved their problems.</source>
          <target state="translated">Если вы хотите вызвать C из Perl, начните с &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; , переходя к &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; , &lt;a href=&quot;xsubpp&quot;&gt;xsubpp&lt;/a&gt; и &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; . Если вы хотите вызвать Perl из C, прочтите &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt; , &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; и &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; . Не забывайте, что вы можете многому научиться, глядя на то, как авторы существующих модулей расширения писали свой код и решали свои проблемы.</target>
        </trans-unit>
        <trans-unit id="548a69c6108c24555301c111e716c92968ea1230" translate="yes" xml:space="preserve">
          <source>If you want to check exactly, compare the string with its NFC/NFKC/FCC.</source>
          <target state="translated">Если вы хотите точно проверить,сравните строку с ее NFC/NFKC/FCC.</target>
        </trans-unit>
        <trans-unit id="59c2fb7af17b706fe9c70e8baa09126e5a3d250b" translate="yes" xml:space="preserve">
          <source>If you want to compress all</source>
          <target state="translated">Если вы хотите сжать все</target>
        </trans-unit>
        <trans-unit id="6bcfdbb5379f221cca1d97f7787d1bc312424003" translate="yes" xml:space="preserve">
          <source>If you want to control warnings on the fly, do something like this. Make sure you do the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; first, or you won't be able to get at the enable() or disable() methods.</source>
          <target state="translated">Если вы хотите контролировать предупреждения на лету, сделайте что-нибудь вроде этого. Сначала убедитесь, что вы &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , иначе вы не сможете использовать методы enable () или disable ().</target>
        </trans-unit>
        <trans-unit id="a42c1db2cee198b239c3cde06a946cab4e064353" translate="yes" xml:space="preserve">
          <source>If you want to control what functions Test::More will export, you have to use the 'import' option. For example, to import everything but 'fail', you'd do:</source>
          <target state="translated">Если вы хотите контролировать,какие функции Test::More будет экспортировать,вы должны использовать опцию 'импорта'.Например,чтобы импортировать все,кроме &quot;fail&quot;,вы бы сделали:</target>
        </trans-unit>
        <trans-unit id="be1e5234b80eb1f923a376bc3491ec3ca6b109b2" translate="yes" xml:space="preserve">
          <source>If you want to convert the returned map to entirely scalar numbers, you can use something like this:</source>
          <target state="translated">Если вы хотите преобразовать возвращенную карту в полностью скалярные числа,вы можете использовать нечто подобное:</target>
        </trans-unit>
        <trans-unit id="5ba04eeea7231f6480afed51584cd45a160a944a" translate="yes" xml:space="preserve">
          <source>If you want to convert to UTF-8 from encodings other than the native (Latin1 or EBCDIC), see &lt;a href=&quot;#sv_recode_to_utf8&quot;&gt;sv_recode_to_utf8&lt;/a&gt;().</source>
          <target state="translated">Если вы хотите преобразовать в UTF-8 из кодировок, отличных от собственных (Latin1 или EBCDIC), см. &lt;a href=&quot;#sv_recode_to_utf8&quot;&gt;Sv_recode_to_utf8&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="53c24008e3ed2beeee61bb3c00b23e9cec000bd1" translate="yes" xml:space="preserve">
          <source>If you want to create many anonymous handles, you should check out the Symbol or IO::Handle modules.</source>
          <target state="translated">Если вы хотите создать много анонимных дескрипторов,вам следует обратить внимание на модули Symbol или IO::Handle.</target>
        </trans-unit>
        <trans-unit id="d3f92af00462a48927ab51881cd3156c2dfab08a" translate="yes" xml:space="preserve">
          <source>If you want to create the file if it does not already exist then bitwise-OR (&lt;code&gt;|&lt;/code&gt;) &lt;code&gt;O_CREAT&lt;/code&gt; too. If you omit &lt;code&gt;O_CREAT&lt;/code&gt; and the database does not already exist then the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call will fail.</source>
          <target state="translated">Если вы хотите создать файл, если он еще не существует, используйте побитовое ИЛИ ( &lt;code&gt;|&lt;/code&gt; ) &lt;code&gt;O_CREAT&lt;/code&gt; . Если опустить &lt;code&gt;O_CREAT&lt;/code&gt; и база данных не существует , то &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; вызов потерпит неудачу.</target>
        </trans-unit>
        <trans-unit id="a116b633c8c619c49052dbd9a5c72113a8975d85" translate="yes" xml:space="preserve">
          <source>If you want to create the file if it does not exist, add &lt;code&gt;O_CREAT&lt;/code&gt; to any of these, as in the example. If you omit &lt;code&gt;O_CREAT&lt;/code&gt; and the file does not already exist, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call will fail.</source>
          <target state="translated">Если вы хотите создать файл, если он не существует, добавьте &lt;code&gt;O_CREAT&lt;/code&gt; к любому из них, как в примере. Если опустить &lt;code&gt;O_CREAT&lt;/code&gt; и файл не существует, то &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; вызов потерпит неудачу.</target>
        </trans-unit>
        <trans-unit id="0e3b712f48285cffa7900ceeb1af82270cd7a609" translate="yes" xml:space="preserve">
          <source>If you want to cycle through an array endlessly, you can increment the index modulo the number of elements in the array:</source>
          <target state="translated">Если вы хотите бесконечно перемещаться по массиву,вы можете увеличить индекс по модулю на количество элементов в массиве:</target>
        </trans-unit>
        <trans-unit id="6cfb6d26bc5df670c402213d4036f3bf58558df4" translate="yes" xml:space="preserve">
          <source>If you want to debug some other testfile, set the &lt;code&gt;TEST_FILE&lt;/code&gt; variable thusly:</source>
          <target state="translated">Если вы хотите отладить какой-либо другой тестовый файл, установите переменную &lt;code&gt;TEST_FILE&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="b931492f8ba265d923d9e6b394913c2adf2d8e1f" translate="yes" xml:space="preserve">
          <source>If you want to disallow any rearrangement, pass &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;[]&lt;/code&gt; (a reference to empty list) as the value for this key.</source>
          <target state="translated">Если вы хотите запретить любую перестановку, передайте &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;[]&lt;/code&gt; (ссылка на пустой список) в качестве значения для этого ключа.</target>
        </trans-unit>
        <trans-unit id="e399c3f8eff9b2e3be1dfd1cb3c6e184f3c80005" translate="yes" xml:space="preserve">
          <source>If you want to do something when the object is destroyed, you can define a &lt;code&gt;DESTROY&lt;/code&gt; method in your class. This method will always be called by Perl at the appropriate time, unless the method is empty.</source>
          <target state="translated">Если вы хотите что-то сделать, когда объект уничтожен, вы можете определить метод &lt;code&gt;DESTROY&lt;/code&gt; в своем классе. Этот метод всегда будет вызываться Perl в подходящее время, если только метод не пуст.</target>
        </trans-unit>
        <trans-unit id="028499023abecf52141490b3dc52996a2e6540e8" translate="yes" xml:space="preserve">
          <source>If you want to do something with the REGEXP* later use SvRX instead and check for NULL.</source>
          <target state="translated">Если вы хотите сделать что-нибудь с REGEXP*позже используйте SvRX и проверьте NULL.</target>
        </trans-unit>
        <trans-unit id="5bec0b0d71b7e3b535fad4f2a98d0fdea0b5611d" translate="yes" xml:space="preserve">
          <source>If you want to do the same thing to modify the values of the hash, you can use the &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; function. As of Perl 5.6 the values are not copied, so if you modify $orbit (in this case), you modify the value.</source>
          <target state="translated">Если вы хотите сделать то же самое для изменения значений хэша, вы можете использовать функцию &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; . Начиная с Perl 5.6 значения не копируются, поэтому, если вы изменяете $ orbit (в данном случае), вы изменяете значение.</target>
        </trans-unit>
        <trans-unit id="1befe6f0c8cce90a523721cdcb6a3e759a8bf613" translate="yes" xml:space="preserve">
          <source>If you want to downgrade a warning that has been escalated into a fatal error back to a normal warning, you can use the &quot;NONFATAL&quot; keyword. For example, the code below will promote all warnings into fatal errors, except for those in the &quot;syntax&quot; category.</source>
          <target state="translated">Если вы хотите понизить рейтинг предупреждения,которое было превращено в фатальную ошибку,обратно в нормальное предупреждение,вы можете использовать ключевое слово &quot;NONFATAL&quot;.Например,код,приведенный ниже,переведет все предупреждения в категорию фатальных ошибок,за исключением тех,которые относятся к категории &quot;синтаксис&quot;.</target>
        </trans-unit>
        <trans-unit id="aaac7464ef1e41e8e3656bb3c9f1373b9810c3d2" translate="yes" xml:space="preserve">
          <source>If you want to encode a large file, you should encode it in chunks that are a multiple of 57 bytes. This ensures that the base64 lines line up and that you do not end up with padding in the middle. 57 bytes of data fills one complete base64 line (76 == 57*4/3):</source>
          <target state="translated">Если вы хотите кодировать большой файл,вы должны кодировать его в куски,кратные 57 байтам.Это гарантирует,что base64 строки выстроятся в линию,и что вы не закончите с подкладкой посередине.57 байт данных заполняет одну полную строку base64 (76 ==57*4/3):</target>
        </trans-unit>
        <trans-unit id="526764856cb11f1625c51adabbc0827d170cf65b" translate="yes" xml:space="preserve">
          <source>If you want to enter a multi-line command, such as a subroutine definition with several statements or a format, escape the newline that would normally end the debugger command with a backslash. Here's an example:</source>
          <target state="translated">Если вы хотите ввести многострочную команду,например,определение подпрограмм с несколькими операторами или формат,экранируйте новую строку,которая обычно заканчивается командой отладчика обратным слешем.Вот пример:</target>
        </trans-unit>
        <trans-unit id="1c27e6ce335738d835ec3fdd82f6c0809ffefc5e" translate="yes" xml:space="preserve">
          <source>If you want to find out how many characters are waiting, there's also the FIONREAD ioctl call to be looked at. The</source>
          <target state="translated">Если вы хотите узнать,сколько символов ждут,есть также вызов FIONREAD ioctl,на который следует обратить внимание.</target>
        </trans-unit>
        <trans-unit id="1da1084e18df9224120de5015e0f47b55cae04d1" translate="yes" xml:space="preserve">
          <source>If you want to find out how many entries have a defined value, that's a bit different. You have to check each value. A &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; is handy:</source>
          <target state="translated">Если вы хотите узнать, сколько записей имеют определенное значение, это немного другое. Вы должны проверить каждое значение. &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; удобно:</target>
        </trans-unit>
        <trans-unit id="308cd4ff0bf951ae1c4968d0825997ff4ae0e702" translate="yes" xml:space="preserve">
          <source>If you want to find the package calling your code, perhaps to give better diagnostics as &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; does, use the &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; built-in:</source>
          <target state="translated">Если вы хотите найти пакет, вызывающий ваш код, возможно, чтобы лучше диагностировать, как это делает &lt;a href=&quot;carp&quot;&gt;Карп&lt;/a&gt; , используйте встроенный &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e1f109680f15bd3886268c0dd93d91471450a599" translate="yes" xml:space="preserve">
          <source>If you want to get at a slice (part of a row) in a multidimensional array, you're going to have to do some fancy subscripting. That's because while we have a nice synonym for single elements via the pointer arrow for dereferencing, no such convenience exists for slices.</source>
          <target state="translated">Если вы хотите попасть на кусок (часть строки)в многомерном массиве,вам придется сделать какую-нибудь причудливую подписку.Это потому,что хотя у нас есть хороший синоним для одиночных элементов через стрелку-индикатор для разыменования,для фрагментов такого удобства не существует.</target>
        </trans-unit>
        <trans-unit id="ac8d06c0714514adee4900ccc907acf01c17734d" translate="yes" xml:space="preserve">
          <source>If you want to get warned when the fallback occurs, replace &quot;try&quot; with &quot;lib&quot;:</source>
          <target state="translated">Если вы хотите,чтобы вас предупредили при падении,замените &quot;try&quot; на &quot;lib&quot;:</target>
        </trans-unit>
        <trans-unit id="c34f1861cd969edfd158d72b53e2b8bf861c0838" translate="yes" xml:space="preserve">
          <source>If you want to have arrays of constant strings, note carefully the right combination of &lt;code&gt;const&lt;/code&gt; s:</source>
          <target state="translated">Если вы хотите иметь массивы постоянных строк, внимательно обратите внимание на правильную комбинацию &lt;code&gt;const&lt;/code&gt; s:</target>
        </trans-unit>
        <trans-unit id="cc85c01bbb2e5546a912901548bde68e7f312959" translate="yes" xml:space="preserve">
          <source>If you want to have static strings, make them constant:</source>
          <target state="translated">Если вы хотите иметь статические строки,сделайте их постоянными:</target>
        </trans-unit>
        <trans-unit id="5f28aad16a41ad668dc6d2a20ee81e5f9b0af321" translate="yes" xml:space="preserve">
          <source>If you want to have your cake and eat it too, you need a more complicated boilerplate.</source>
          <target state="translated">Если вы хотите получить свой торт и съесть его тоже,вам нужна более сложная шаблонная плита.</target>
        </trans-unit>
        <trans-unit id="732754bf3b16a13d947b836156896a3b2cedc031" translate="yes" xml:space="preserve">
          <source>If you want to indent the text in the here document, you can do this:</source>
          <target state="translated">Если вы хотите сделать отступ от текста в этом документе,вы можете сделать это:</target>
        </trans-unit>
        <trans-unit id="d6b9e98bf75fad13fa324d37df3fb0822a303c98" translate="yes" xml:space="preserve">
          <source>If you want to influence compilation of calls to a specific subroutine, then use &lt;a href=&quot;#cv_set_call_checker&quot;&gt;cv_set_call_checker&lt;/a&gt; rather than hooking checking of all &lt;code&gt;entersub&lt;/code&gt; ops.</source>
          <target state="translated">Если вы хотите повлиять на компиляцию вызовов определенной подпрограммы, используйте &lt;a href=&quot;#cv_set_call_checker&quot;&gt;cv_set_call_checker,&lt;/a&gt; а не подключайте проверку всех &lt;code&gt;entersub&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="168d6eb05b72021bb2cefd5586f5642721fb25b0" translate="yes" xml:space="preserve">
          <source>If you want to install a distribution from the current directory, you can tell &lt;code&gt;CPAN.pm&lt;/code&gt; to install &lt;code&gt;.&lt;/code&gt; (the full stop):</source>
          <target state="translated">Если вы хотите установить дистрибутив из текущего каталога, вы можете указать &lt;code&gt;CPAN.pm&lt;/code&gt; для установки &lt;code&gt;.&lt;/code&gt; (точка):</target>
        </trans-unit>
        <trans-unit id="33e2d2f8b434b4a1cc7c6346d405264c8380bf51" translate="yes" xml:space="preserve">
          <source>If you want to install modules for your own use, the easiest way might be &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt;, which you can download from CPAN. It sets various installation settings for you, and uses those same settings within your programs.</source>
          <target state="translated">Если вы хотите установить модули для собственного использования, самым простым способом может быть &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local :: lib&lt;/a&gt; , который вы можете скачать с CPAN. Он устанавливает для вас различные параметры установки и использует те же параметры в ваших программах.</target>
        </trans-unit>
        <trans-unit id="58d2dc539671f427bbae58845aceababd0159c6c" translate="yes" xml:space="preserve">
          <source>If you want to know as little about Perl as possible but need to add a new encoding, just read this chapter and forget the rest.</source>
          <target state="translated">Если вы хотите узнать как можно меньше о Perl,но вам нужно добавить новую кодировку,просто прочитайте эту главу и забудьте об остальном.</target>
        </trans-unit>
        <trans-unit id="56e1fbcaca6130206229f6c3c8cb0c2d52fb54b7" translate="yes" xml:space="preserve">
          <source>If you want to know how Perl OO works under the hood, the &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; document explains the nitty gritty details.</source>
          <target state="translated">Если вы хотите узнать, как Perl OO работает под капотом, документ &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; объясняет мельчайшие подробности.</target>
        </trans-unit>
        <trans-unit id="9f23a106d53e80c8c0f8d1f2b0c84d08d1054140" translate="yes" xml:space="preserve">
          <source>If you want to know how to handle automated testing for your distribution, you can check the environment. The CPAN Testers, for instance, set the value of &lt;code&gt;AUTOMATED_TESTING&lt;/code&gt; :</source>
          <target state="translated">Если вы хотите знать, как проводить автоматическое тестирование вашего дистрибутива, вы можете проверить среду. Например, тестеры CPAN устанавливают значение &lt;code&gt;AUTOMATED_TESTING&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a57ed6abdc67a27c928054414c38fcc1c565d58" translate="yes" xml:space="preserve">
          <source>If you want to know if the scalar value is TRUE, you can use:</source>
          <target state="translated">Если Вы хотите знать,является ли скалярное значение TRUE,Вы можете его использовать:</target>
        </trans-unit>
        <trans-unit id="f0f2be398a4f429a704b8881af39ff31858188bb" translate="yes" xml:space="preserve">
          <source>If you want to know if this variable (or any other SV) is actually &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;, you can call:</source>
          <target state="translated">Если вы хотите узнать, действительно ли &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; эта переменная (или любой другой SV) , вы можете вызвать:</target>
        </trans-unit>
        <trans-unit id="4282549729bb35373ef94d2e2b64ea8af51a5d06" translate="yes" xml:space="preserve">
          <source>If you want to know whether a particular scalar refers to an object, you can use the &lt;code&gt;blessed&lt;/code&gt; function exported by &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;, which is shipped with the Perl core.</source>
          <target state="translated">Если вы хотите знать, относится ли конкретный скаляр к объекту, вы можете использовать &lt;code&gt;blessed&lt;/code&gt; функцию, экспортируемую &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; , которая поставляется с ядром Perl.</target>
        </trans-unit>
        <trans-unit id="056d8ddf16a11d708261878d4f200cc28e75de75" translate="yes" xml:space="preserve">
          <source>If you want to learn more about Perl 6, or have a desire to help in the crusade to make Perl a better place then read the Perl 6 developers page at &lt;a href=&quot;http://www.perl6.org/&quot;&gt;http://www.perl6.org/&lt;/a&gt; and get involved.</source>
          <target state="translated">Если вы хотите узнать больше о Perl 6 или хотите помочь в крестовом походе, чтобы сделать Perl лучше, прочитайте страницу разработчиков Perl 6 по адресу &lt;a href=&quot;http://www.perl6.org/&quot;&gt;http://www.perl6.org/&lt;/a&gt; и примите участие.</target>
        </trans-unit>
        <trans-unit id="00255f60e5cd77d55f44acd05aa25f0d59366611" translate="yes" xml:space="preserve">
          <source>If you want to learn the basics of Perl, you might start with the Llama book, which assumes that you already know a little about programming:</source>
          <target state="translated">Если вы хотите изучить основы Perl,вы можете начать с книги Llama,которая предполагает,что вы уже немного знаете о программировании:</target>
        </trans-unit>
        <trans-unit id="859f839c744c136d7bdf5037e58bd0e9887e2618" translate="yes" xml:space="preserve">
          <source>If you want to load a subclass from a file that &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; would not consider an eligible filename (that is, it does not end in either &lt;code&gt;.pm&lt;/code&gt; or &lt;code&gt;.pmc&lt;/code&gt;), use the following code:</source>
          <target state="translated">Если вы хотите загрузить подкласс из файла, который &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; чтобы не учитывалось подходящее имя файла (то есть, он не заканчивается ни на &lt;code&gt;.pm&lt;/code&gt; , ни на &lt;code&gt;.pmc&lt;/code&gt; ), используйте следующий код:</target>
        </trans-unit>
        <trans-unit id="63bacba7c0db3c9f406fbf3ba9dec50a07c74303" translate="yes" xml:space="preserve">
          <source>If you want to load the entire file, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Path::Tiny&quot;&gt;Path::Tiny&lt;/a&gt; module to do it in one simple and efficient step:</source>
          <target state="translated">Если вы хотите загрузить весь файл, вы можете использовать модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Path::Tiny&quot;&gt;Path :: Tiny,&lt;/a&gt; чтобы сделать это за один простой и эффективный шаг:</target>
        </trans-unit>
        <trans-unit id="b17927939e60f1cedd222b2461104e02f72f02d9" translate="yes" xml:space="preserve">
          <source>If you want to make a real copy, use the following:</source>
          <target state="translated">Если вы хотите сделать настоящую копию,используйте следующее:</target>
        </trans-unit>
        <trans-unit id="011cab076badf929a664e79819f2251ac21c5335" translate="yes" xml:space="preserve">
          <source>If you want to make the SV drop its string buffer, use &lt;code&gt;sv_force_normal_flags(sv, SV_COW_DROP_PV)&lt;/code&gt; or simply &lt;code&gt;sv_setsv(sv, NULL)&lt;/code&gt; .</source>
          <target state="translated">Если вы хотите, чтобы SV &lt;code&gt;sv_force_normal_flags(sv, SV_COW_DROP_PV)&lt;/code&gt; свой строковый буфер, используйте sv_force_normal_flags (sv, SV_COW_DROP_PV) или просто &lt;code&gt;sv_setsv(sv, NULL)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b7523637fc2645186f899696d73931e051d6c52" translate="yes" xml:space="preserve">
          <source>If you want to make use of the new features available in Berkeley DB 2.x or greater, use the Perl module &lt;b&gt;BerkeleyDB&lt;/b&gt; instead.</source>
          <target state="translated">Если вы хотите использовать новые функции, доступные в Berkeley DB 2.x или выше, используйте вместо этого Perl-модуль &lt;b&gt;BerkeleyDB&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="610bb38fb99d325c8e7fefe0a23a02b343634382" translate="yes" xml:space="preserve">
          <source>If you want to modify the debugger, copy</source>
          <target state="translated">Если вы хотите изменить отладчик,скопируйте</target>
        </trans-unit>
        <trans-unit id="68a89277cf24a3194f901f3f723f1840c4c2f27b" translate="yes" xml:space="preserve">
          <source>If you want to open either STDIN or STDOUT with &lt;code&gt;gzopen&lt;/code&gt; , you can now optionally use the special filename &quot;&lt;code&gt;-&lt;/code&gt; &quot; as a synonym for &lt;code&gt;\*STDIN&lt;/code&gt; and &lt;code&gt;\*STDOUT&lt;/code&gt; .</source>
          <target state="translated">Если вы хотите открыть либо STDIN, либо STDOUT с помощью &lt;code&gt;gzopen&lt;/code&gt; , теперь вы можете дополнительно использовать специальное имя файла &amp;laquo; &lt;code&gt;-&lt;/code&gt; &amp;raquo; в качестве синонима для &lt;code&gt;\*STDIN&lt;/code&gt; и &lt;code&gt;\*STDOUT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e41fd5af244837759f6e880c0fa8c36bc7f07f26" translate="yes" xml:space="preserve">
          <source>If you want to overload a Perl operator, such as &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;**&lt;/code&gt; , then you'll want to use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; pragma, documented in &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите перегрузить оператор Perl, такой как &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;**&lt;/code&gt; , вы захотите &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; прагму use overload , задокументированную в &lt;a href=&quot;overload&quot;&gt;перегрузке&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="945aa8bcea0076aea35d4a81e4ba840ff11ec82e" translate="yes" xml:space="preserve">
          <source>If you want to override a predefined function, such as open(), then you'll have to import the new definition from a different module. See &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;Overriding Built-in Functions in perlsub&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите переопределить предопределенную функцию, такую ​​как open (), вам придется импортировать новое определение из другого модуля. См. &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;Переопределение встроенных функций в perlsub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa48921f25a631295f915526fc8a70c73af7fbf8" translate="yes" xml:space="preserve">
          <source>If you want to override the mapping of Hangul syllables, NFD and NFKD are not appropriate, since NFD and NFKD will decompose Hangul syllables before overriding. FCD may decompose Hangul syllables as the case may be.</source>
          <target state="translated">Если вы хотите переопределить отображение слогов Хангуля,NFD и NFKD не подходят,так как NFD и NFKD будут разлагать слоги Хангуля перед переопределением.FCD может разлагать ангальские слоги в зависимости от ситуации.</target>
        </trans-unit>
        <trans-unit id="5c827c3a5508b73a4c675d093f91220233b7dc11" translate="yes" xml:space="preserve">
          <source>If you want to pass arguments to the Perl subroutine, you can add strings to the &lt;code&gt;NULL&lt;/code&gt; -terminated &lt;code&gt;args&lt;/code&gt; list passed to</source>
          <target state="translated">Если вы хотите , чтобы передать аргументы подпрограммы на Perl, вы можете добавить строки в &lt;code&gt;NULL&lt;/code&gt; -завершённый &lt;code&gt;args&lt;/code&gt; перечени передается</target>
        </trans-unit>
        <trans-unit id="5c0b08e235edf0d26d308eb349b59ea3ef72cb9d" translate="yes" xml:space="preserve">
          <source>If you want to pass more than one array or hash into a function--or return them from it--and have them maintain their integrity, then you're going to have to use an explicit pass-by-reference. Before you do that, you need to understand references as detailed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. This section may not make much sense to you otherwise.</source>
          <target state="translated">Если вы хотите передать в функцию более одного массива или хеша - или вернуть их из нее - и сохранить их целостность, тогда вам придется использовать явную передачу по ссылке. Прежде чем вы это сделаете, вам необходимо понять ссылки, подробно описанные в &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; . В противном случае этот раздел может не иметь для вас особого смысла.</target>
        </trans-unit>
        <trans-unit id="c8a70766df71ba2d4b4ce04954ec69dff30a7c0f" translate="yes" xml:space="preserve">
          <source>If you want to pass switches into your script, you can use one of the &lt;code&gt;Getopts&lt;/code&gt; modules or put a loop on the front like this:</source>
          <target state="translated">Если вы хотите передать переключатели в свой скрипт, вы можете использовать один из модулей &lt;code&gt;Getopts&lt;/code&gt; или поместить цикл вперед, например:</target>
        </trans-unit>
        <trans-unit id="f4bd2c5192aedd065d255be14f3583448bb4e171" translate="yes" xml:space="preserve">
          <source>If you want to port your own favourite c-lib for big numbers to the Math::BigInt interface, you can take any of the already existing modules as a rough guideline. You should really wrap up the latest BigInt and BigFloat testsuites with your module, and replace in them any of the following:</source>
          <target state="translated">Если вы хотите перенести свой любимый c-lib для больших чисел в интерфейс Math::BigInt,вы можете взять любой из уже существующих модулей в качестве примерного руководства.Вы действительно должны завернуть последние тестовые модули BigInt и BigFloat с вашим модулем,и заменить в них любое из следующего:</target>
        </trans-unit>
        <trans-unit id="376b22a241cce9ba252fd1c8a6df064f6b6eac08" translate="yes" xml:space="preserve">
          <source>If you want to position the file for &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;, don't use &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, because buffering makes its effect on the file's read-write position unpredictable and non-portable. Use &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Если вы хотите позиционировать файл для &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; , не используйте &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , потому что буферизация оказывает непредсказуемое и непереносимое влияние на позицию файла для чтения и записи . &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; этого используйте sysseek .</target>
        </trans-unit>
        <trans-unit id="ab53baa73269bc54f793e2d56860c5115ebd11f4" translate="yes" xml:space="preserve">
          <source>If you want to position the file for &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;, don't use &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, because buffering makes its effect on the file's read-write position unpredictable and non-portable. Use &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Если вы хотите позиционировать файл для &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; , не используйте &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , потому что буферизация оказывает непредсказуемое и непереносимое влияние на позицию файла для чтения и записи . &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; этого используйте sysseek .</target>
        </trans-unit>
        <trans-unit id="a0c3e6b22044730d55d9a0c06443157660dba6ef" translate="yes" xml:space="preserve">
          <source>If you want to preserve any existing contents, then you want to open the file in append mode. As in the shell, in Perl you use &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; to open an existing file in append mode. &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; creates the file if it does not already exist.</source>
          <target state="translated">Если вы хотите сохранить какое-либо существующее содержимое, тогда вы хотите открыть файл в режиме добавления. Как и в оболочке, в Perl вы используете &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; , чтобы открыть существующий файл в режиме добавления. &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; создает файл, если он еще не существует.</target>
        </trans-unit>
        <trans-unit id="17bd731415d5d66dc3d1ddceae18e6e16a628145" translate="yes" xml:space="preserve">
          <source>If you want to preserve the original hashes, copy one hash (&lt;code&gt;%hash1&lt;/code&gt; ) to a new hash (&lt;code&gt;%new_hash&lt;/code&gt; ), then add the keys from the other hash (&lt;code&gt;%hash2&lt;/code&gt; to the new hash. Checking that the key already exists in &lt;code&gt;%new_hash&lt;/code&gt; gives you a chance to decide what to do with the duplicates:</source>
          <target state="translated">Если вы хотите сохранить исходные хеши, скопируйте один хеш ( &lt;code&gt;%hash1&lt;/code&gt; ) в новый хеш ( &lt;code&gt;%new_hash&lt;/code&gt; ), затем добавьте ключи из другого хеша ( &lt;code&gt;%hash2&lt;/code&gt; в новый хеш. Проверка того, что ключ уже существует в &lt;code&gt;%new_hash&lt;/code&gt; дает вам возможность решить, что делать с дубликатами:</target>
        </trans-unit>
        <trans-unit id="50f7b3c025841bfcdb1aab514c8e2d8e36fbc766" translate="yes" xml:space="preserve">
          <source>If you want to print the whole thing, though, you can't say</source>
          <target state="translated">Если ты хочешь напечатать все это,ты не можешь сказать.</target>
        </trans-unit>
        <trans-unit id="93f1e3a9ebfe45627e0241306de345142f514db8" translate="yes" xml:space="preserve">
          <source>If you want to provide config to the source you can use:</source>
          <target state="translated">Если вы хотите предоставить конфигурацию для источника,который вы можете использовать:</target>
        </trans-unit>
        <trans-unit id="9f3a66952ab51429c329502faae26a704977a338" translate="yes" xml:space="preserve">
          <source>If you want to read a gzip file a line at a time and have it respect the &lt;code&gt;$/&lt;/code&gt; variable (or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; , or &lt;code&gt;$RS&lt;/code&gt; when &lt;code&gt;English&lt;/code&gt; is in use) see &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите читать файл gzip построчно и &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; переменную &lt;code&gt;$/&lt;/code&gt; (или $ INPUT_RECORD_SEPARATOR , или &lt;code&gt;$RS&lt;/code&gt; когда используется &lt;code&gt;English&lt;/code&gt; ), см. &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO :: Uncompress :: Gunzip&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d31f53859a4168c72e90a2128210958319d4f50" translate="yes" xml:space="preserve">
          <source>If you want to read from a text file, first open it in read-only mode like this:</source>
          <target state="translated">Если вы хотите читать из текстового файла,сначала откройте его в режиме только для чтения:</target>
        </trans-unit>
        <trans-unit id="d4ab6b15624972e8c18a42d8d83c1cd6a30cfb30" translate="yes" xml:space="preserve">
          <source>If you want to release a 'beta' or 'alpha' version of a module but don't want CPAN.pm to list it as most recent use an '_' after the regular version number followed by at least 2 digits, eg. 1.20_01. If you do this, the following idiom is recommended:</source>
          <target state="translated">Если вы хотите выпустить 'beta' или 'alpha' версию модуля,но не хотите,чтобы CPAN.pm перечислял ее как последнюю,используйте '_' после номера обычной версии,а затем как минимум 2 цифры,например 1.20_01.Если вы сделаете это,рекомендуется использовать следующую идиому:</target>
        </trans-unit>
        <trans-unit id="aec7d886a6e5c93bd394402ec290052fc195c585" translate="yes" xml:space="preserve">
          <source>If you want to remove the line terminator from your here-docs, use &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите удалить терминатор строки из документации, используйте &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db615c188722d8560c52e776e317416a34e011c1" translate="yes" xml:space="preserve">
          <source>If you want to report a bug in Perl, you must use the</source>
          <target state="translated">Если вы хотите сообщить об ошибке в Perl,вы должны использовать</target>
        </trans-unit>
        <trans-unit id="f2154f64aff6e9940c9fb796b1289c8d854d7ca5" translate="yes" xml:space="preserve">
          <source>If you want to represent quotation marks inside a quotation-mark-delimited field, escape them with backslashes (eg, &lt;code&gt;&quot;like \&quot;this\&quot;&quot;&lt;/code&gt; .</source>
          <target state="translated">Если вы хотите представить кавычки внутри поля, разделенного кавычками, экранируйте их обратной косой чертой (например, &lt;code&gt;&quot;like \&quot;this\&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="824f7654e0ed811f4acc48396871cdac5a94cdda" translate="yes" xml:space="preserve">
          <source>If you want to retain the UTF-x code points then in script form you might want to write:</source>
          <target state="translated">Если вы хотите сохранить пункты UTF-x кода,то в скриптовой форме вы можете захотеть написать:</target>
        </trans-unit>
        <trans-unit id="2c2c9c1a65a810709ccd4ab8e9bc83e0091df0bc" translate="yes" xml:space="preserve">
          <source>If you want to retrieve the time at which the file was last read, written, or had its meta-data (owner, etc) changed, you use the &lt;b&gt;-A&lt;/b&gt;, &lt;b&gt;-M&lt;/b&gt;, or &lt;b&gt;-C&lt;/b&gt; file test operations as documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. These retrieve the age of the file (measured against the start-time of your program) in days as a floating point number. Some platforms may not have all of these times. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for details. To retrieve the &quot;raw&quot; time in seconds since the epoch, you would call the stat function, then use &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;POSIX::strftime()&lt;/code&gt; to convert this into human-readable form.</source>
          <target state="translated">Если вы хотите получить время последнего чтения, записи или изменения метаданных файла (владельца и т. Д.), Используйте операции проверки файла &lt;b&gt;-A&lt;/b&gt; , &lt;b&gt;-M&lt;/b&gt; или &lt;b&gt;-C,&lt;/b&gt; как &lt;a href=&quot;perlfunc&quot;&gt;описано&lt;/a&gt; в perlfunc . Они извлекают возраст файла (измеренный относительно времени запуска вашей программы) в днях в виде числа с плавающей запятой. Некоторые платформы могут не иметь всех этих времен. См. Подробности в &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; . Чтобы получить &quot;сырое&quot; время в секундах с начала эпохи, вы должны вызвать функцию stat, а затем использовать &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;POSIX::strftime()&lt;/code&gt; чтобы преобразовать это в удобочитаемую форму.</target>
        </trans-unit>
        <trans-unit id="ea86bc2e0842c32d086b82e0b936c78284136301" translate="yes" xml:space="preserve">
          <source>If you want to run an external command and still keep your Perl process going, look at a piped &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите запустить внешнюю команду и по-прежнему поддерживать процесс Perl, посмотрите на &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; канал , &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ec243e8883915ce98e61a2fb629a6bec35df46c" translate="yes" xml:space="preserve">
          <source>If you want to run any of the tests yourself manually using e.g. valgrind, please note that by default perl &lt;b&gt;does not&lt;/b&gt; explicitly cleanup all the memory it has allocated (such as global memory arenas) but instead lets the exit() of the whole program &quot;take care&quot; of such allocations, also known as &quot;global destruction of objects&quot;.</source>
          <target state="translated">Если вы хотите запустить какой-либо из тестов вручную, например, с помощью valgrind, обратите внимание, что по умолчанию perl &lt;b&gt;не&lt;/b&gt; очищает явно всю выделенную им память (например, области глобальной памяти), а вместо этого позволяет exit () всей программы &quot; позаботьтесь о таком распределении, также известном как &amp;laquo;глобальное уничтожение объектов&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c579d4f4691b7da6dbe69f3dde05c84842ed87a2" translate="yes" xml:space="preserve">
          <source>If you want to run particular test files, set the &lt;code&gt;TEST_FILES&lt;/code&gt; variable. It is possible to use globbing with this mechanism.</source>
          <target state="translated">Если вы хотите запустить определенные тестовые файлы, установите переменную &lt;code&gt;TEST_FILES&lt;/code&gt; . С этим механизмом можно использовать подстановку.</target>
        </trans-unit>
        <trans-unit id="cab446873fde6bc4766b7caa4c1c83cdf5ad957d" translate="yes" xml:space="preserve">
          <source>If you want to see the command History, type an '&lt;b&gt;H&lt;/b&gt;':</source>
          <target state="translated">Если вы хотите увидеть историю команд, введите &amp;laquo; &lt;b&gt;H&lt;/b&gt; &amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="852c71f5265989b791fcb0bad50a31c13ad56ee6" translate="yes" xml:space="preserve">
          <source>If you want to see what perl is doing when parsing/lexing your code, you can use &lt;code&gt;BEGIN {}&lt;/code&gt; :</source>
          <target state="translated">Если вы хотите увидеть, что делает perl при синтаксическом анализе / лексировании вашего кода, вы можете использовать &lt;code&gt;BEGIN {}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3175d2c86530c83d13669e65994d9eb74402053d" translate="yes" xml:space="preserve">
          <source>If you want to see what the parser/lexer is doing inside of &lt;code&gt;if&lt;/code&gt; blocks and the like you need to be a little trickier:</source>
          <target state="translated">Если вы хотите увидеть, что делает парсер / лексер внутри блоков &lt;code&gt;if&lt;/code&gt; и т.п., вам нужно быть немного сложнее:</target>
        </trans-unit>
        <trans-unit id="8bca41d076fff99126cd66f621ea4770f98d22fe" translate="yes" xml:space="preserve">
          <source>If you want to select on many filehandles, you may wish to write a subroutine like this:</source>
          <target state="translated">Если вы хотите выбрать из множества файловых ручек,вы можете записать подпрограмму,подобную этой:</target>
        </trans-unit>
        <trans-unit id="933790916a521b582a0514fa93b65b7620fb02f6" translate="yes" xml:space="preserve">
          <source>If you want to separate your lines with something other than &lt;code&gt;\n&lt;/code&gt; then set &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; to your preference. This replaces all newlines with &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; . If you just want to preserve existing newlines but add new breaks with something else, set &lt;code&gt;$Text::Wrap::separator2&lt;/code&gt; instead.</source>
          <target state="translated">Если вы хотите разделить свои строки чем-то другим, кроме &lt;code&gt;\n&lt;/code&gt; установите &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; по своему усмотрению. Это заменяет все символы новой строки на &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; . Если вы просто хотите сохранить существующие символы новой строки, но добавить новые разрывы с чем-то еще, установите вместо этого &lt;code&gt;$Text::Wrap::separator2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f22c0f1a9c1e2e9b3f3593f17d9d5d341e79a144" translate="yes" xml:space="preserve">
          <source>If you want to set &lt;code&gt;@ARGV&lt;/code&gt; to your own list of files, go right ahead. This sets &lt;code&gt;@ARGV&lt;/code&gt; to all plain text files if no &lt;code&gt;@ARGV&lt;/code&gt; was given:</source>
          <target state="translated">Если вы хотите установить &lt;code&gt;@ARGV&lt;/code&gt; в свой собственный список файлов, продолжайте. Это устанавливает &lt;code&gt;@ARGV&lt;/code&gt; для всех текстовых файлов, если &lt;code&gt;@ARGV&lt;/code&gt; не было задано:</target>
        </trans-unit>
        <trans-unit id="c597fab938b142e9f257da003c8529a2b550cc0b" translate="yes" xml:space="preserve">
          <source>If you want to set your encoding layers based on your locale environment variables, you can use the &lt;code&gt;:locale&lt;/code&gt; tag. For example:</source>
          <target state="translated">Если вы хотите установить уровни кодирования на основе переменных среды вашего языкового стандарта, вы можете использовать тег &lt;code&gt;:locale&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="f93a5a664c0fedc0848a47a9e0bdfdba8a57c6b9" translate="yes" xml:space="preserve">
          <source>If you want to specify perl options &lt;code&gt;-my_opts&lt;/code&gt; to the perl itself (as opposed to your program), use</source>
          <target state="translated">Если вы хотите указать параметры perl &lt;code&gt;-my_opts&lt;/code&gt; для самого perl (в отличие от вашей программы), используйте</target>
        </trans-unit>
        <trans-unit id="16a2b27e854284e5624b52325615871e56858329" translate="yes" xml:space="preserve">
          <source>If you want to specify the version of Perl, but don't care about the version of the module, pass &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for the module version:</source>
          <target state="translated">Если вы хотите указать версию Perl, но не заботитесь о версии модуля, передайте &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; для версии модуля:</target>
        </trans-unit>
        <trans-unit id="4170c2908419d9f1f4a325cd881e413a4558b490" translate="yes" xml:space="preserve">
          <source>If you want to suppress man page installation for all modules you have to reconfigure Perl and tell it 'none' when it asks where to install man pages.</source>
          <target state="translated">Если вы хотите запретить установку man-страниц для всех модулей,вы должны перенастроить Perl и сказать ему &quot;нет&quot;,когда он спросит,где установить man-страницы.</target>
        </trans-unit>
        <trans-unit id="73be2d5223229972e63c46363d25a8b4ecd5d388" translate="yes" xml:space="preserve">
          <source>If you want to take advantage of this new implicit dereferencing behavior, go right ahead: it makes code easier on the eye and wrist. Just understand that older releases will choke on it during compilation. Whenever you make use of something that works only in some given release of Perl and later, but not earlier, you should place a prominent</source>
          <target state="translated">Если вы хотите воспользоваться этим новым неявным поведением разыменования,идите прямо вперед:оно делает код легче для глаза и запястья.Просто поймите,что старые релизы подавятся во время компиляции.Всякий раз,когда вы используете что-то,что работает только в каком-нибудь данном выпуске Perl и позже,но не раньше,вы должны ставить заметный</target>
        </trans-unit>
        <trans-unit id="e1677e0d939fbca31e3c5c86eaef838b1e761cee" translate="yes" xml:space="preserve">
          <source>If you want to take into account the &lt;a href=&quot;bytes&quot;&gt;bytes&lt;/a&gt; pragma, use &lt;code&gt;&lt;a href=&quot;#DO_UTF8&quot;&gt;DO_UTF8&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Если вы хотите принять во внимание &lt;code&gt;&lt;a href=&quot;#DO_UTF8&quot;&gt;DO_UTF8&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;bytes&quot;&gt; bytes&lt;/a&gt; , используйте вместо нее DO_UTF8 .</target>
        </trans-unit>
        <trans-unit id="be8af06e2253191bf1cfa1761503b16d4281bf21" translate="yes" xml:space="preserve">
          <source>If you want to trap errors when loading an XS module, some problems with the binary interface (such as Perl version skew) may be fatal even with &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; unless &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; is set. See &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите отлавливать ошибки при загрузке модуля XS, некоторые проблемы с двоичным интерфейсом (например, перекос версии Perl) могут быть фатальными даже с &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , если не установлен &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; . См. &lt;a href=&quot;../perlrun&quot;&gt;Perlrun&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7dc2a0aef2f5b8c2b438b365b49a4c2f0d40f6ac" translate="yes" xml:space="preserve">
          <source>If you want to trap errors when loading an XS module, some problems with the binary interface (such as Perl version skew) may be fatal even with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; unless &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; is set. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите отлавливать ошибки при загрузке модуля XS, некоторые проблемы с двоичным интерфейсом (например, перекос версии Perl) могут быть фатальными даже с &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , если не установлен &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; . См. &lt;a href=&quot;perlrun&quot;&gt;Perlrun&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6ffd07b12749a1692d47d579873dc74d6c4dfaf" translate="yes" xml:space="preserve">
          <source>If you want to try to install a distribution by yourself, resolving all dependencies on your own, you follow one of two possible build paths.</source>
          <target state="translated">Если вы хотите попробовать установить дистрибутив самостоятельно,разрешив все зависимости,вы следуете одному из двух возможных путей сборки.</target>
        </trans-unit>
        <trans-unit id="fbe14747549d8ad4516b4e89ba086fe45d5bc952" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;$.&lt;/code&gt; , you can reduce it to a simple one-liner, like one of these:</source>
          <target state="translated">Если вы хотите использовать &lt;code&gt;$.&lt;/code&gt; , вы можете сократить его до простого однострочника, например одного из следующих:</target>
        </trans-unit>
        <trans-unit id="638caf8fdb384503ed24e0af4c2fa1fdaedcfe89" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; to time out a system call you need to use an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; pair. You can't rely on the alarm causing the system call to fail with &lt;code&gt;$!&lt;/code&gt; set to &lt;code&gt;EINTR&lt;/code&gt; because Perl sets up signal handlers to restart system calls on some systems. Using &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; always works, modulo the caveats given in &lt;a href=&quot;../perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите использовать &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; для тайм-аута системного вызова, вам нужно использовать пару &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . Вы не можете полагаться на сигнал тревоги, вызывающий сбой системного вызова с &lt;code&gt;$!&lt;/code&gt; установлен в &lt;code&gt;EINTR&lt;/code&gt; , потому что Perl настраивает обработчики сигналов для перезапуска системных вызовов в некоторых системах. Использование &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; всегда работает по модулю предостережений, указанных &lt;a href=&quot;../perlipc#Signals&quot;&gt;в Сигналах в perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47fc081d4f98f1098211a1c78312dbb51873804c" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; to time out a system call you need to use an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; pair. You can't rely on the alarm causing the system call to fail with &lt;code&gt;$!&lt;/code&gt; set to &lt;code&gt;EINTR&lt;/code&gt; because Perl sets up signal handlers to restart system calls on some systems. Using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; always works, modulo the caveats given in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите использовать &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; для тайм-аута системного вызова, вам нужно использовать пару &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . Вы не можете полагаться на сигнал тревоги, вызывающий сбой системного вызова с &lt;code&gt;$!&lt;/code&gt; установлен в &lt;code&gt;EINTR&lt;/code&gt; , потому что Perl настраивает обработчики сигналов для перезапуска системных вызовов в некоторых системах. Использование &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; всегда работает по модулю предостережений, указанных &lt;a href=&quot;perlipc#Signals&quot;&gt;в Сигналах в perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="95a0ee4afc73cc3c28bb4ee34fc5e5c78c608e7d" translate="yes" xml:space="preserve">
          <source>If you want to use Perl on a non-z/OS EBCDIC machine, please let us know by sending mail to perlbug@perl.org</source>
          <target state="translated">Если вы хотите использовать Perl на машине nonz/OS EBCDIC,пожалуйста,сообщите нам об этом по электронной почте по адресу perlbug@perl.org.</target>
        </trans-unit>
        <trans-unit id="e5b580ca1f65ec0f5a604fbeb668e8741070d520" translate="yes" xml:space="preserve">
          <source>If you want to use Perl on the Hurd, I recommend using the Debian GNU/Hurd distribution ( see &lt;a href=&quot;http://www.debian.org/&quot;&gt;http://www.debian.org/&lt;/a&gt; ), even if an official, stable release has not yet been made. The old &quot;gnu-0.2&quot; binary distribution will most certainly have additional problems.</source>
          <target state="translated">Если вы хотите использовать Perl на Hurd, я рекомендую использовать дистрибутив Debian GNU / Hurd (см. &lt;a href=&quot;http://www.debian.org/&quot;&gt;Http://www.debian.org/&lt;/a&gt; ), даже если официальный стабильный выпуск еще не выпущен. Старый двоичный дистрибутив &quot;gnu-0.2&quot; наверняка будет иметь дополнительные проблемы.</target>
        </trans-unit>
        <trans-unit id="7687d514ed5fdcc15efde5d3bf9ba63b53f53add" translate="yes" xml:space="preserve">
          <source>If you want to use a module, try the &lt;code&gt;uniq&lt;/code&gt; function from &lt;a href=&quot;http://search.cpan.org/perldoc/List::MoreUtils&quot;&gt;List::MoreUtils&lt;/a&gt;. In list context it returns the unique elements, preserving their order in the list. In scalar context, it returns the number of unique elements.</source>
          <target state="translated">Если вы хотите использовать модуль, попробуйте функцию &lt;code&gt;uniq&lt;/code&gt; из &lt;a href=&quot;http://search.cpan.org/perldoc/List::MoreUtils&quot;&gt;List :: MoreUtils&lt;/a&gt; . В контексте списка он возвращает уникальные элементы, сохраняя их порядок в списке. В скалярном контексте он возвращает количество уникальных элементов.</target>
        </trans-unit>
        <trans-unit id="655bd3463f5ce3b5ada699426719c6ddc69d4f2a" translate="yes" xml:space="preserve">
          <source>If you want to use multiple patterns, e.g. &lt;code&gt;bsd_glob(&quot;a* b*&quot;)&lt;/code&gt; , you should probably throw them in a set as in &lt;code&gt;bsd_glob(&quot;{a*,b*}&quot;)&lt;/code&gt; . This is because the argument to bsd_glob() isn't subjected to parsing by the C shell. Remember that you can use a backslash to escape things.</source>
          <target state="translated">Если вы хотите использовать несколько шаблонов, например, &lt;code&gt;bsd_glob(&quot;a* b*&quot;)&lt;/code&gt; , вам, вероятно, следует добавить их в набор, как в &lt;code&gt;bsd_glob(&quot;{a*,b*}&quot;)&lt;/code&gt; . Это происходит потому, что аргумент bsd_glob () не подвергается синтаксическому анализу оболочкой C. Помните, что для экранирования можно использовать обратную косую черту.</target>
        </trans-unit>
        <trans-unit id="daaf83327da114b41b8c24aa71d08a4f5617620d" translate="yes" xml:space="preserve">
          <source>If you want to use non-ASCII bytes (outside the bytes 0x00..0x7f) in the &quot;source code&quot; of your code, to be portable you have to be explicit about what bytes they are. Someone might for example be using your code under a UTF-8 locale, in which case random native bytes might be illegal (&quot;Malformed UTF-8 ...&quot;) This means that for example embedding ISO 8859-1 bytes beyond 0x7f into your strings might cause trouble later. If the bytes are native 8-bit bytes, you can use the &lt;code&gt;bytes&lt;/code&gt; pragma. If the bytes are in a string (regular expressions being curious strings), you can often also use the &lt;code&gt;\xHH&lt;/code&gt; or more portably, the &lt;code&gt;\N{U+HH}&lt;/code&gt; notations instead of embedding the bytes as-is. If you want to write your code in UTF-8, you can use &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите использовать байты, отличные от ASCII (вне байтов 0x00..0x7f) в &amp;laquo;исходном коде&amp;raquo; вашего кода, чтобы быть переносимым, вы должны четко указать, какие это байты. Кто-то может, например, использовать ваш код в локали UTF-8, и в этом случае случайные собственные байты могут быть недопустимыми (&amp;laquo;Неверный формат UTF-8 ...&amp;raquo;). Это означает, что, например, встраивание байтов ISO 8859-1 за пределами 0x7f в ваш струны могут вызвать проблемы позже. Если байты являются собственными 8-битными байтами, вы можете использовать прагму &lt;code&gt;bytes&lt;/code&gt; . Если байты находятся в строке (регулярные выражения представляют собой любопытные строки), вы можете также использовать &lt;code&gt;\xHH&lt;/code&gt; или, более переносимо, нотацию &lt;code&gt;\N{U+HH}&lt;/code&gt; вместо встраивания байтов как есть. Если вы хотите написать свой код в UTF-8, вы можете использовать &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bfe339f2912f8f17fbf2b42472a9d509e3a576bf" translate="yes" xml:space="preserve">
          <source>If you want to use the same literal digits (644) in Perl, you have to tell Perl to treat them as octal numbers either by prefixing the digits with a &lt;code&gt;0&lt;/code&gt; or using &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите использовать одни и те же буквальные цифры (644) в Perl, вы должны указать Perl обрабатывать их как восьмеричные числа, либо добавив к цифрам префикс &lt;code&gt;0&lt;/code&gt; , либо используя &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ee36968e514e749df3ac1a70b3903aee1ab0ec1b" translate="yes" xml:space="preserve">
          <source>If you want to use threads, you should primarily use the Perl 5.8.0 threads model by running Configure with -Duseithreads.</source>
          <target state="translated">Если вы хотите использовать потоки,в первую очередь следует использовать потоковую модель Perl 5.8.0,запустив команду Configure with -Duseithreads.</target>
        </trans-unit>
        <trans-unit id="f0b79aac4ab0e44b3e5cf20ea8795f9b26be612e" translate="yes" xml:space="preserve">
          <source>If you want to work with comma-separated values, don't do this since that format is a bit more complicated. Use one of the modules that handle that format, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV&quot;&gt;Text::CSV&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_XS&quot;&gt;Text::CSV_XS&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_PP&quot;&gt;Text::CSV_PP&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите работать со значениями, разделенными запятыми, не делайте этого, поскольку этот формат немного сложнее. Используйте один из модулей, поддерживающих этот формат, например &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV&quot;&gt;Text :: CSV&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_XS&quot;&gt;Text :: CSV_XS&lt;/a&gt; или &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_PP&quot;&gt;Text :: CSV_PP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37acc7e93925635a2960bac98f19ec762c55738f" translate="yes" xml:space="preserve">
          <source>If you want to work with formatted dates, the &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date::Manip&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; modules can help you.</source>
          <target state="translated">Если вы хотите работать с форматированными датами, вам могут помочь модули &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date :: Manip&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt; или &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c337db840462e094257c46f34c19710018f93799" translate="yes" xml:space="preserve">
          <source>If you want to write to an existing SV's buffer and set its value to a string, use SvPV_force() or one of its variants to force the SV to be a PV. This will remove any of various types of non-stringness from the SV while preserving the content of the SV in the PV. This can be used, for example, to append data from an API function to a buffer without extra copying:</source>
          <target state="translated">Если вы хотите записать в существующий буфер SV и установить его значение в строку,используйте SvPV_force()или один из его вариантов,чтобы заставить SV быть PV.Это удалит любой из различных типов неограниченности из SV,сохраняя при этом содержимое SV в PV.Это может быть использовано,например,для добавления данных из функции API в буфер без дополнительного копирования:</target>
        </trans-unit>
        <trans-unit id="17fab6cd5cfc4d3a8699ee4d492a9132990d5dbf" translate="yes" xml:space="preserve">
          <source>If you want to zap all predefined aliases, you can use</source>
          <target state="translated">Если вы хотите отменить все предопределенные псевдонимы,вы можете использовать</target>
        </trans-unit>
        <trans-unit id="6dad17422598919d77ad32018e1ee73ac029ac1c" translate="yes" xml:space="preserve">
          <source>If you want your code to be portable, your format (&lt;code&gt;fmt&lt;/code&gt; ) argument should use only the conversion specifiers defined by the ANSI C standard (C89, to play safe). These are &lt;code&gt;aAbBcdHIjmMpSUwWxXyYZ%&lt;/code&gt; . But even then, the &lt;b&gt;results&lt;/b&gt; of some of the conversion specifiers are non-portable. For example, the specifiers &lt;code&gt;aAbBcpZ&lt;/code&gt; change according to the locale settings of the user, and both how to set locales (the locale names) and what output to expect are non-standard. The specifier &lt;code&gt;c&lt;/code&gt; changes according to the timezone settings of the user and the timezone computation rules of the operating system. The &lt;code&gt;Z&lt;/code&gt; specifier is notoriously unportable since the names of timezones are non-standard. Sticking to the numeric specifiers is the safest route.</source>
          <target state="translated">Если вы хотите, чтобы ваш код был переносимым, ваш аргумент формата ( &lt;code&gt;fmt&lt;/code&gt; ) должен использовать только спецификаторы преобразования, определенные стандартом ANSI C (C89, на всякий случай). Это &lt;code&gt;aAbBcdHIjmMpSUwWxXyYZ%&lt;/code&gt; . Но даже тогда &lt;b&gt;результаты&lt;/b&gt; некоторых спецификаторов преобразования непереносимы. Например, спецификаторы &lt;code&gt;aAbBcpZ&lt;/code&gt; изменяются в соответствии с настройками языкового стандарта пользователя, и то, как устанавливать языковые стандарты (имена языковых стандартов) и какой результат следует ожидать, нестандартны. Спецификатор &lt;code&gt;c&lt;/code&gt; изменяется в соответствии с настройками часового пояса пользователя и правилами вычисления часового пояса операционной системы. &lt;code&gt;Z&lt;/code&gt; Спецификатор, как известно, непереносимый, так как названия часовых поясов нестандартны. Использование числовых спецификаторов - самый безопасный путь.</target>
        </trans-unit>
        <trans-unit id="b8922cb8873f110b4ceb1333b3f31e99ca5b2eb1" translate="yes" xml:space="preserve">
          <source>If you want your encoding to work with &lt;a href=&quot;../encoding&quot;&gt;encoding&lt;/a&gt; pragma, you should also implement the method below.</source>
          <target state="translated">Если вы хотите, чтобы ваша кодировка работала с прагмой &lt;a href=&quot;../encoding&quot;&gt;кодирования&lt;/a&gt; , вы также должны реализовать метод ниже.</target>
        </trans-unit>
        <trans-unit id="e7210c4e7ce82b46e9e62a14e14a71ab868752cc" translate="yes" xml:space="preserve">
          <source>If you want your here-docs to be indented with the rest of the code, you'll need to remove leading whitespace from each line manually:</source>
          <target state="translated">Если вы хотите,чтобы ваши here-docs были смещены с остальным кодом,вам нужно будет удалить ведущие пробелы из каждой строки вручную:</target>
        </trans-unit>
        <trans-unit id="eb763454ad4db2bd6193f7e99d444faca44a82eb" translate="yes" xml:space="preserve">
          <source>If you want your program to be compatible with versions of Perl before 5.20, you must use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; instead. (In previous versions of Perl, the behavior of the statements &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'NONFATAL';&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; was unspecified; they did not behave as if they included the &lt;code&gt;=&amp;gt; 'all'&lt;/code&gt; portion. As of 5.20, they do.)</source>
          <target state="translated">Если вы хотите, чтобы ваша программа была совместима с версиями Perl до 5.20, вы должны &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; вместо. (В предыдущих версиях Perl, поведение заявлений &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'NONFATAL';&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; не было определены, что они не ведут себя , как если бы они включали в себя &lt;code&gt;=&amp;gt; 'all'&lt;/code&gt; части . По состоянию на 5.20, да.)</target>
        </trans-unit>
        <trans-unit id="3d68917c192fee56b1141df74b8f16f9fa5100fe" translate="yes" xml:space="preserve">
          <source>If you want, you may make low-level pipe() and fork() syscalls to stitch this together by hand. This example only talks to itself, but you could reopen the appropriate handles to STDIN and STDOUT and call other processes. (The following example lacks proper error checking.)</source>
          <target state="translated">При желании вы можете сделать низкоуровневые трубки и fork()syscalls,чтобы сшить их вручную.Этот пример говорит только сам с собой,но вы можете заново открыть соответствующие дескрипторы в STDIN и STDOUT и вызвать другие процессы.(В следующем примере отсутствует надлежащая проверка на ошибки).</target>
        </trans-unit>
        <trans-unit id="9a78398c052f882736bece8b1553a1b8e0dc056b" translate="yes" xml:space="preserve">
          <source>If you wanted just to append to a row, you'd have to do something a bit funnier looking:</source>
          <target state="translated">Если бы ты хотел просто пристроиться к ряду,тебе бы пришлось сделать что-нибудь более забавное:</target>
        </trans-unit>
        <trans-unit id="2260da4124856b0020df29775382e24cb7c28087" translate="yes" xml:space="preserve">
          <source>If you wanted text and not lines, you would use</source>
          <target state="translated">Если бы вы хотели текст,а не строки,вы бы использовали</target>
        </trans-unit>
        <trans-unit id="b649b444ce3825b2b868566f3609222a2cd25baa" translate="yes" xml:space="preserve">
          <source>If you wanted the commas preserved as separate fields (i.e. like split does if your split pattern has capturing parentheses), you would just make the last parameter undefined (or remove it).</source>
          <target state="translated">Если бы вы хотели,чтобы запятые сохранялись как отдельные поля (т.е.как в случае с разделом,если ваш шаблон разделения имеет захватывающие скобки),вы бы просто сделали последний параметр неопределенным (или удалили его).</target>
        </trans-unit>
        <trans-unit id="5fba67ea1fbf1509f7d61f0bae5321559a412330" translate="yes" xml:space="preserve">
          <source>If you wanted to do the same thing for lines, you wouldn't need a regular expression:</source>
          <target state="translated">Если бы вы хотели сделать то же самое для строк,вам не понадобилось бы регулярное выражение:</target>
        </trans-unit>
        <trans-unit id="ed640c7d7a4ae2cd65ac815fdaa4ce3af7479470" translate="yes" xml:space="preserve">
          <source>If you wanted to have a $ref_to_AoA variable as a reference to an array, you'd have to do something like this:</source>
          <target state="translated">Если бы вы хотели иметь переменную $ref_to_AoA в качестве ссылки на массив,вам пришлось бы сделать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="fed8c5d580fcbca1e699420a58d9ad3cd67321fd" translate="yes" xml:space="preserve">
          <source>If you wanted to keep track of subscripts, you might do this:</source>
          <target state="translated">Если ты хочешь отслеживать подписки,ты можешь это сделать:</target>
        </trans-unit>
        <trans-unit id="fbf69379e2b3dc67cd59111850ee63e9c65dd9db" translate="yes" xml:space="preserve">
          <source>If you wanted to see the inverse tables, you would first have to sort on the desired numbers column as in recipes 4, 5 or 6, then take the output of the first numbers column.</source>
          <target state="translated">Если вы хотите увидеть обратные таблицы,сначала нужно отсортировать столбец с нужными номерами,как в рецептах 4,5 или 6,а затем вывести первый столбец с номерами.</target>
        </trans-unit>
        <trans-unit id="1d598a9db20ad75da95def7772f5c1aab9645a1d" translate="yes" xml:space="preserve">
          <source>If you were into Schwartzian Transforms, you would probably have selected map for that</source>
          <target state="translated">Если бы вы занимались шварцвальдскими преобразованиями,вы,вероятно,выбрали бы карту для этого.</target>
        </trans-unit>
        <trans-unit id="ad840be29267c1ff305e523c8e88cf5317d35dc5" translate="yes" xml:space="preserve">
          <source>If you were to set &lt;code&gt;$b[3] = 4&lt;/code&gt; , then instead of reporting that &quot;a and b are deep copies of each other&quot;, it now reports that &lt;code&gt;&quot;b smartmatches in a&quot;&lt;/code&gt; . That's because the corresponding position in &lt;code&gt;@a&lt;/code&gt; contains an array that (eventually) has a 4 in it.</source>
          <target state="translated">Если бы вы установили &lt;code&gt;$b[3] = 4&lt;/code&gt; , то вместо сообщения, что &amp;laquo;a и b являются глубокими копиями друг друга&amp;raquo;, теперь он сообщает, что &lt;code&gt;&quot;b smartmatches in a&quot;&lt;/code&gt; . Это потому, что соответствующая позиция в &lt;code&gt;@a&lt;/code&gt; содержит массив, в котором (в конечном итоге) есть 4.</target>
        </trans-unit>
        <trans-unit id="25e66b6a4d3408c5b81e396702004bd84b8fbf9d" translate="yes" xml:space="preserve">
          <source>If you wish to compile with the Socket extension, you need to have the TCP/IP toolkit, and you need to make sure that -lsocket locates the correct copy of socket3r.lib. Beware that the Watcom compiler ships with a stub version of socket3r.lib which has very little functionality. Also beware the order in which wlink searches directories for libraries. You may have /usr/lib/socket3r.lib pointing to the correct library, but wlink may pick up /usr/watcom/10.6/usr/lib/socket3r.lib instead. Make sure they both point to the correct library, that is, /usr/tcptk/current/usr/lib/socket3r.lib.</source>
          <target state="translated">Если вы хотите скомпилировать с расширением Socket,у вас должен быть инструментарий TCP/IP,и вы должны убедиться,что -lsocket находит правильную копию socket3r.lib.Остерегайтесь,что компилятор Watcom поставляется с версией stub socket3r.lib,которая имеет очень мало функциональности.Также остерегайтесь порядка,в котором wlink ищет каталоги для библиотек.Возможно,у вас есть /usr/lib/socket3r.lib,указывающий на правильную библиотеку,но вместо этого wlink может взять /usr/watcom/10.6/usr/lib/socket3r.lib.Убедитесь,что оба они указывают на правильную библиотеку,т.е./usr/tcptk/current/usr/lib/socket3r.lib.</target>
        </trans-unit>
        <trans-unit id="743a9842bd7eb1c587a8ceb73e47cc40eff3e0ec" translate="yes" xml:space="preserve">
          <source>If you wish to install perl versions for all architectures (68020, mips, sparc and 386) run:</source>
          <target state="translated">Если вы хотите установить perl-версии для всех архитектур (68020,mips,sparc и 386),запустите их:</target>
        </trans-unit>
        <trans-unit id="fe0f0e4408b545cb1ecebca491d9be266bb67e8f" translate="yes" xml:space="preserve">
          <source>If you wish to supply an alternative debugger for Perl to run, invoke your script with a colon and a package argument given to the &lt;b&gt;-d&lt;/b&gt; flag. Perl's alternative debuggers include a Perl profiler, &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt;, which is available separately as a CPAN distribution. To profile your Perl program in the file</source>
          <target state="translated">Если вы хотите предоставить Perl альтернативный отладчик для запуска, вызовите свой сценарий с двоеточием и аргументом пакета, указанным для флага &lt;b&gt;-d&lt;/b&gt; . Альтернативные отладчики Perl включают профилировщик Perl, &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel :: NYTProf&lt;/a&gt; , который доступен отдельно как дистрибутив CPAN. Чтобы профилировать вашу программу Perl в файле</target>
        </trans-unit>
        <trans-unit id="b105ef1f647cb2687215fb2803b65285f6c51529" translate="yes" xml:space="preserve">
          <source>If you wish to turn an entire POD document into a parse-tree, that process is fairly straightforward. The &lt;b&gt;parse_text()&lt;/b&gt; method is the key to doing this successfully. Every paragraph-callback (i.e. the polymorphic methods for &lt;b&gt;command()&lt;/b&gt;, &lt;b&gt;verbatim()&lt;/b&gt;, and &lt;b&gt;textblock()&lt;/b&gt; paragraphs) takes a &lt;b&gt;Pod::Paragraph&lt;/b&gt; object as an argument. Each paragraph object has a &lt;b&gt;parse_tree()&lt;/b&gt; method that can be used to get or set a corresponding parse-tree. So for each of those paragraph-callback methods, simply call &lt;b&gt;parse_text()&lt;/b&gt; with the options you desire, and then use the returned parse-tree to assign to the given paragraph object.</source>
          <target state="translated">Если вы хотите превратить весь документ POD в дерево синтаксического анализа, этот процесс довольно прост. Метод &lt;b&gt;parse_text ()&lt;/b&gt; - ключ к успешному выполнению этой &lt;b&gt;задачи&lt;/b&gt; . Каждый обратный вызов абзаца (то есть полиморфные методы для абзацев &lt;b&gt;command ()&lt;/b&gt; , &lt;b&gt;verbatim ()&lt;/b&gt; и &lt;b&gt;textblock ()&lt;/b&gt; ) принимает в качестве аргумента объект &lt;b&gt;Pod :: Paragraph&lt;/b&gt; . Каждый объект абзаца имеет метод &lt;b&gt;parse_tree (),&lt;/b&gt; который можно использовать для получения или установки соответствующего дерева синтаксического анализа. Поэтому для каждого из этих методов обратного вызова &lt;b&gt;абзаца&lt;/b&gt; просто вызовите &lt;b&gt;parse_text ()&lt;/b&gt; с &lt;b&gt;желаемыми&lt;/b&gt; параметрами, а затем используйте возвращенное дерево синтаксического анализа для присвоения данному объекту абзаца.</target>
        </trans-unit>
        <trans-unit id="77c82d86f4fb285fcd145d9c870b966041509421" translate="yes" xml:space="preserve">
          <source>If you wish to use GNU ld, then you need to pass it the -Wl,-E flag. The hints/solaris_2.sh file tries to do this automatically by setting the following Configure variables:</source>
          <target state="translated">Если вы хотите использовать GNU ld,то вам нужно передать ему флаг -Wl,-E.Файл hints/solaris_2.sh пытается сделать это автоматически,установив следующие переменные Configure:</target>
        </trans-unit>
        <trans-unit id="5c10ef4b4d7cf77ba9367b0a5ba13535a2314b3d" translate="yes" xml:space="preserve">
          <source>If you wish to use gcc to build add-on modules for use with the perl shipped with Solaris, you should use the Solaris::PerlGcc module which is available from CPAN. The perl shipped with Solaris is configured and built with the Sun compilers, and the compiler configuration information stored in Config.pm is therefore only relevant to the Sun compilers. The Solaris:PerlGcc module contains a replacement Config.pm that is correct for gcc - see the module for details.</source>
          <target state="translated">Если вы хотите использовать gcc для создания дополнительных модулей для использования с perl,поставляемым с Solaris,вы должны использовать модуль Solaris::PerlGcc,который доступен в CPAN.Perl,поставляемый с Solaris,конфигурируется и собирается с помощью компиляторов Sun,поэтому информация о конфигурации компилятора,хранящаяся в Config.pm,относится только к компиляторам Sun.Модуль Solaris:PerlGcc содержит замену Config.pm,которая подходит для gcc-подробнее см.модуль.</target>
        </trans-unit>
        <trans-unit id="461c22560c9b4e2d096c9a209fc41fbc9b8e1805" translate="yes" xml:space="preserve">
          <source>If you wonder what complex numbers are, they were invented to be able to solve the following equation:</source>
          <target state="translated">Если вам интересно,что такое комплексные числа,то они были изобретены,чтобы иметь возможность решать следующее уравнение:</target>
        </trans-unit>
        <trans-unit id="58f2be2cb41014bdf8c7d1f6da3d5ed7b3a57878" translate="yes" xml:space="preserve">
          <source>If you wonder why defaults for conversion are different for str() and num(), note how easy it was to write the symbolic calculator. This simplicity is due to an appropriate choice of defaults. One extra note: due to the explicit recursion num() is more fragile than sym(): we need to explicitly check for the type of $a and $b. If components $a and $b happen to be of some related type, this may lead to problems.</source>
          <target state="translated">Если вы удивляетесь,почему значения по умолчанию для преобразования для str()и num()отличаются,обратите внимание на то,как легко было написать символьный калькулятор.Эта простота обусловлена правильным выбором значений по умолчанию.Одно дополнительное примечание:из-за явной рекурсии num()более хрупкая,чем sym():нам нужно явно проверить тип $a и $b.Если компоненты $a и $b окажутся какого-то родственного типа,это может привести к проблемам.</target>
        </trans-unit>
        <trans-unit id="f88d82472c17285676b32563ec0b930b79f27b19" translate="yes" xml:space="preserve">
          <source>If you would like to know about a version dependency before you start running the program, put something like this at its top:</source>
          <target state="translated">Если вы хотите узнать о зависимости от версии до того,как вы начнете запускать программу,положите что-нибудь подобное наверх:</target>
        </trans-unit>
        <trans-unit id="c3bc63e78a724b45aa4c8fcf7d5d3a90c3663440" translate="yes" xml:space="preserve">
          <source>If you would like to print out a lot of man page continuously, you probably want to set the C and D registers to set contiguous page numbering and even/odd paging, at least on some versions of man(7).</source>
          <target state="translated">Если вы хотите постоянно распечатывать большое количество man-страниц,то,вероятно,вы захотите установить регистры C и D,чтобы установить сопряженную нумерацию страниц и четную/одобную страницу,по крайней мере,в некоторых версиях man(7).</target>
        </trans-unit>
        <trans-unit id="4e270feabb28d65fb97bce6b5a62077129b3eed4" translate="yes" xml:space="preserve">
          <source>If you would rather see it in CCSID 1047 order then change the number 34 in the last line to 39, like this:</source>
          <target state="translated">Если вы предпочитаете видеть его в порядке CCSID 1047,то поменяйте цифру 34 в последней строке на 39,вот так:</target>
        </trans-unit>
        <trans-unit id="7ab3cc4dd9f42b386f286d85d40432c48d4dbc0d" translate="yes" xml:space="preserve">
          <source>If you would rather see it in POSIX-BC order then change the number 34 in the last line to 44, like this:</source>
          <target state="translated">Если вы предпочитаете видеть его в порядке POSIX-BC,то измените цифру 34 в последней строке на 44,вот так:</target>
        </trans-unit>
        <trans-unit id="4685079e88ddb435b412b9c5b1c049410dc612d3" translate="yes" xml:space="preserve">
          <source>If you would rather see the above table in CCSID 0037 order rather than ASCII + Latin-1 order then run the table through:</source>
          <target state="translated">Если вы предпочитаете видеть вышеприведенную таблицу в порядке CCSID 0037,а не в порядке ASCII+латиница-1,то прогоните таблицу до конца:</target>
        </trans-unit>
        <trans-unit id="32ccbee06ab47d2346ade36365b388768fa75f8c" translate="yes" xml:space="preserve">
          <source>If you would rather see this table listing hexadecimal values then run the table through:</source>
          <target state="translated">Если вы хотите увидеть эту таблицу с перечислением шестнадцатиричных значений,то прогоните таблицу:</target>
        </trans-unit>
        <trans-unit id="ee951a76c16a66932dc3802ba31a24c5d5d45366" translate="yes" xml:space="preserve">
          <source>If you write just &lt;code&gt;[]&lt;/code&gt; , you get a new, empty anonymous array. If you write just &lt;code&gt;{}&lt;/code&gt; , you get a new, empty anonymous hash.</source>
          <target state="translated">Если вы напишете просто &lt;code&gt;[]&lt;/code&gt; , вы получите новый пустой анонимный массив. Если вы напишете просто &lt;code&gt;{}&lt;/code&gt; , вы получите новый пустой анонимный хеш.</target>
        </trans-unit>
        <trans-unit id="6e5ce930a64c177374e0a87543a2b84b1ca0633d" translate="yes" xml:space="preserve">
          <source>If you write your own test, use the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2ftestanything.org&quot;&gt;Test Anything Protocol&lt;/a&gt;.</source>
          <target state="translated">Если вы пишете свой собственный тест, используйте &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2ftestanything.org&quot;&gt;Test Anything Protocol&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4b7f29b396f8216559006548d8b8987bccc01b5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a C or C++ programmer, you might be looking for Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword.</source>
          <target state="translated">Если вы программист на C или C ++, возможно, вы ищете ключевое слово Perl &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65480a92112439353360a0f2410e7e3031db6948" translate="yes" xml:space="preserve">
          <source>If you'd like a graphical user interface and you have &lt;a href=&quot;http://search.cpan.org/perldoc/Tk&quot;&gt;Tk&lt;/a&gt;, you can use &lt;code&gt;ptkdb&lt;/code&gt; . It's on CPAN and available for free.</source>
          <target state="translated">Если вам нужен графический интерфейс пользователя и у вас есть &lt;a href=&quot;http://search.cpan.org/perldoc/Tk&quot;&gt;Tk&lt;/a&gt; , вы можете использовать &lt;code&gt;ptkdb&lt;/code&gt; . Он находится на CPAN и доступен бесплатно.</target>
        </trans-unit>
        <trans-unit id="c82ff6955ec720dbffdb6e597947e26e8c52b3d3" translate="yes" xml:space="preserve">
          <source>If you'd like to disable the use of one or more of these utilities and/or modules, see the &lt;code&gt;$BLACKLIST&lt;/code&gt; variable further down.</source>
          <target state="translated">Если вы хотите отключить использование одной или нескольких из этих утилит и / или модулей, см. &lt;code&gt;$BLACKLIST&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="52486225415552ac3d601c87ba41d238a14d5679" translate="yes" xml:space="preserve">
          <source>If you'd like to make &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; (and many other bits of Perl) die on error, have a look at the &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; pragma.</source>
          <target state="translated">Если вы хотите, чтобы &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; (и многие другие части Perl) &lt;a href=&quot;autodie&quot;&gt;умирала из-за&lt;/a&gt; ошибки, взгляните на прагму autodie .</target>
        </trans-unit>
        <trans-unit id="1efbce8f9e88ed4ba8cc94bb84af468b14e5c10a" translate="yes" xml:space="preserve">
          <source>If you'd like to make &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; (and many other bits of Perl) die on error, have a look at the &lt;a href=&quot;../autodie&quot;&gt;autodie&lt;/a&gt; pragma.</source>
          <target state="translated">Если вы хотите, чтобы &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; (и многие другие части Perl) &lt;a href=&quot;../autodie&quot;&gt;умирала из-за&lt;/a&gt; ошибки, взгляните на прагму autodie .</target>
        </trans-unit>
        <trans-unit id="73a95e0734804b8dcc4d934eb0b4ac64271a89fa" translate="yes" xml:space="preserve">
          <source>If you'd like to manually inspect &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s failure, you can check all possible failure modes by inspecting &lt;code&gt;$?&lt;/code&gt; like this:</source>
          <target state="translated">Если вы хотите , чтобы вручную проверять &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; &amp;laquo;s отказ, вы можете проверить все возможные режимы отказа от проверки &lt;code&gt;$?&lt;/code&gt; как это:</target>
        </trans-unit>
        <trans-unit id="c50262b9b752d6c3a022a1f95bc5efa143b999d6" translate="yes" xml:space="preserve">
          <source>If you'd like to manually inspect &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s failure, you can check all possible failure modes by inspecting &lt;code&gt;$?&lt;/code&gt; like this:</source>
          <target state="translated">Если вы хотите , чтобы вручную проверять &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; &amp;laquo;s отказ, вы можете проверить все возможные режимы отказа от проверки &lt;code&gt;$?&lt;/code&gt; как это:</target>
        </trans-unit>
        <trans-unit id="b7d0d2c6ab654703248e935ebd07682399b01f80" translate="yes" xml:space="preserve">
          <source>If you'd like to see the raw output of your tests, set the &lt;code&gt;TEST_VERBOSE&lt;/code&gt; variable to true.</source>
          <target state="translated">Если вы хотите увидеть необработанный результат ваших тестов, установите для переменной &lt;code&gt;TEST_VERBOSE&lt;/code&gt; значение true.</target>
        </trans-unit>
        <trans-unit id="15cb39149b7ad3616c39f88b2becd39a6aed03b0" translate="yes" xml:space="preserve">
          <source>If you'd rather treat each line individually, you can do that, too, by just transforming them in-place in the code reference and returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. Say that you don't want</source>
          <target state="translated">Если вы предпочитаете обрабатывать каждую строку индивидуально, вы также можете сделать это, просто преобразовав их на месте в ссылке на код и вернув &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Скажи, что ты не хочешь</target>
        </trans-unit>
        <trans-unit id="ffd95bdd9903099e5f9ecacdcf9a08a9aec1e1ad" translate="yes" xml:space="preserve">
          <source>If you're a plugin author, you'll be interested in how to &lt;a href=&quot;#register_handler&quot;&gt;register_handler&lt;/a&gt;s, how &lt;a href=&quot;#detect_source&quot;&gt;detect_source&lt;/a&gt; works.</source>
          <target state="translated">Если вы являетесь автором плагина, вам будет интересно узнать, как &lt;a href=&quot;#register_handler&quot;&gt;register_handler&lt;/a&gt; , как работает &lt;a href=&quot;#detect_source&quot;&gt;detect_source&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec02db45e6d3a34d0a303395b0efb8490d821d7c" translate="yes" xml:space="preserve">
          <source>If you're committed to creating a temporary file by hand, use the process ID and/or the current time-value. If you need to have many temporary files in one process, use a counter:</source>
          <target state="translated">Если вы намерены создать временный файл вручную,используйте идентификатор процесса и/или текущее значение времени.Если вам необходимо иметь много временных файлов в одном процессе,используйте счетчик:</target>
        </trans-unit>
        <trans-unit id="6a57c8d5168852184b3e7f9eacd5e84a511755f4" translate="yes" xml:space="preserve">
          <source>If you're concerned about 8-bit textual data then see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;. If you want to deal with multibyte characters, however, there are some gotchas. See the section on Regular Expressions.</source>
          <target state="translated">Если вас беспокоят 8-битные текстовые данные, см. &lt;a href=&quot;perllocale&quot;&gt;Perllocale&lt;/a&gt; . Однако если вы хотите иметь дело с многобайтовыми символами, есть некоторые подводные камни. См. Раздел Регулярные выражения.</target>
        </trans-unit>
        <trans-unit id="a4a17aeb59ac658e17124a0d2eb0b805c011e3c8" translate="yes" xml:space="preserve">
          <source>If you're concerned about people profiting from your code, then the bottom line is that nothing but a restrictive license will give you legal security. License your software and pepper it with threatening statements like &quot;This is unpublished proprietary software of XYZ Corp. Your access to it does not give you permission to use it blah blah blah.&quot; We are not lawyers, of course, so you should see a lawyer if you want to be sure your license's wording will stand up in court.</source>
          <target state="translated">Если вас беспокоят люди,извлекающие выгоду из вашего кода,то суть в том,что ничего,кроме ограничительной лицензии,не даст вам законной безопасности.Лицензируйте свои программы и переливайте их угрожающими заявлениями типа &quot;Это неопубликованные несвободные программы XYZ Corp.Ваш доступ к нему не дает вам разрешения использовать его бла-бла-бла&quot;.Конечно,мы не юристы,поэтому вам следует обратиться к юристу,если вы хотите быть уверены в том,что формулировки вашей лицензии встанут в суде.</target>
        </trans-unit>
        <trans-unit id="20f5afeb7883b43b071ad0d90c989471842051d6" translate="yes" xml:space="preserve">
          <source>If you're concerned about people profiting from your code, then the bottom line is that nothing but a restrictive license will give you legal security. License your software and pepper it with threatening statements like &quot;This is unpublished proprietary software of XYZ Corp. Your access to it does not give you permission to use it blah blah blah.&quot; You should see a lawyer to be sure your license's wording will stand up in court.</source>
          <target state="translated">Если вас беспокоят люди,извлекающие выгоду из вашего кода,то суть в том,что ничего,кроме ограничительной лицензии,не даст вам законной безопасности.Лицензируйте свои программы и переливайте их угрожающими заявлениями типа &quot;Это неопубликованные несвободные программы XYZ Corp.Ваш доступ к нему не дает вам разрешения использовать его бла-бла-бла&quot;.Вам следует обратиться к адвокату,чтобы удостовериться,что формулировки вашей лицензии встанут в суде.</target>
        </trans-unit>
        <trans-unit id="28d412e72884dbac279b68cd8636bc53150a9095" translate="yes" xml:space="preserve">
          <source>If you're confused about why you use an '@' there on a hash slice instead of a '%', think of it like this. The type of bracket (square or curly) governs whether it's an array or a hash being looked at. On the other hand, the leading symbol ('$' or '@') on the array or hash indicates whether you are getting back a singular value (a scalar) or a plural one (a list).</source>
          <target state="translated">Если вас смущает,почему вы используете '@' на кусочке хэша вместо '%',подумайте об этом вот так.Тип скобки (квадратная или фигурная)определяет,является ли это массивом или хэшем.С другой стороны,ведущий символ ('$' или '@')на массиве или хэше указывает,возвращается ли единственное значение (скаляр)или множественное (список).</target>
        </trans-unit>
        <trans-unit id="2fdaeb94f7920871da7274b75b49a557aeabaf4a" translate="yes" xml:space="preserve">
          <source>If you're creating a completely new result</source>
          <target state="translated">Если вы создаете совершенно новый результат</target>
        </trans-unit>
        <trans-unit id="6e2a7b543e2f454e92700f7b1967ab94c4b894e7" translate="yes" xml:space="preserve">
          <source>If you're currently linking your perl executable to a shared</source>
          <target state="translated">Если вы в настоящее время связываете ваш исполняемый файл perl с общим доступом</target>
        </trans-unit>
        <trans-unit id="5ae9e7742fc3a996e99839cc61f7b8352d875d18" translate="yes" xml:space="preserve">
          <source>If you're debugging a script that uses #!, and normally relies on the shell's $PATH search, the -S option causes perl to do that search, so you don't have to type the path or &lt;code&gt;`which $scriptname`&lt;/code&gt; .</source>
          <target state="translated">Если вы отлаживаете сценарий, который использует # !, и обычно полагается на поиск оболочки $ PATH, опция -S заставляет perl выполнять этот поиск, поэтому вам не нужно вводить путь или &lt;code&gt;`which $scriptname`&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c253632d224aa0744dad2b2922eca154c4278dec" translate="yes" xml:space="preserve">
          <source>If you're deprecating a feature with the intent of later simplifying another bit of code, say so. If you're fixing a performance problem or adding a new feature to support some other bit of the core, mention that.</source>
          <target state="translated">Если вы отклоняете функцию с целью последующего упрощения еще одного бита кода,скажем так.Если вы исправляете проблему производительности или добавляете новую функцию для поддержки другого бита ядра,упомяните об этом.</target>
        </trans-unit>
        <trans-unit id="b41a3856c0dbc6e888db5696272009c4533b95af" translate="yes" xml:space="preserve">
          <source>If you're developing a CPAN distribution using XS, you may add your own file called</source>
          <target state="translated">Если вы разрабатываете CPAN дистрибутив с использованием XS,вы можете добавить свой собственный файл под названием</target>
        </trans-unit>
        <trans-unit id="897c140e9db65d769b3515a8af2bf69889950440" translate="yes" xml:space="preserve">
          <source>If you're getting this error from a here-document, you may have included unseen whitespace before or after your closing tag or there may not be a linebreak after it. A good programmer's editor will have a way to help you find these characters (or lack of characters). See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for the full details on here-documents.</source>
          <target state="translated">Если вы получаете эту ошибку из здесь-документа, возможно, вы включили невидимые пробелы до или после закрывающего тега или после него может не быть разрыва строки. У хорошего программистского редактора есть способ помочь вам найти эти символы (или их отсутствие). См. &lt;a href=&quot;perlop&quot;&gt;Perlop&lt;/a&gt; для получения полной информации о здесь-документах.</target>
        </trans-unit>
        <trans-unit id="a4fd5cbfd79a1c891c020d447f65eef0d65886a8" translate="yes" xml:space="preserve">
          <source>If you're going to put your Pod at the end of the file, and you're using an &lt;code&gt;__END__&lt;/code&gt; or &lt;code&gt;__DATA__&lt;/code&gt; cut mark, make sure to put an empty line there before the first Pod command.</source>
          <target state="translated">Если вы собираетесь поместить свой Pod в конец файла и используете &lt;code&gt;__END__&lt;/code&gt; &lt;code&gt;__DATA__&lt;/code&gt; __END__ или __DATA__ , обязательно поместите пустую строку перед первой командой Pod.</target>
        </trans-unit>
        <trans-unit id="0fef8c8a09918fb182d2a0653d091964fe4d5654" translate="yes" xml:space="preserve">
          <source>If you're in a slow syscall (like &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;ing, &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt;ing, or &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;ing from your keyboard or a socket) and haven't set up your own &lt;code&gt;$SIG{INT}&lt;/code&gt; handler, then you won't be able to CTRL-C your way back to the debugger, because the debugger's own &lt;code&gt;$SIG{INT}&lt;/code&gt; handler doesn't understand that it needs to raise an exception to longjmp(3) out of slow syscalls.</source>
          <target state="translated">Если вы используете медленный системный вызов (например, &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; с клавиатуры или сокета) и не настроили собственный обработчик &lt;code&gt;$SIG{INT}&lt;/code&gt; , то вы не сможете CTRL -C ваш путь обратно к отладчику, потому что собственный обработчик &lt;code&gt;$SIG{INT}&lt;/code&gt; отладчика не понимает, что ему необходимо вызывать исключение для longjmp (3) из медленных системных вызовов.</target>
        </trans-unit>
        <trans-unit id="14f4284650d0a24b2d57ce770464abe6b8363cfa" translate="yes" xml:space="preserve">
          <source>If you're just trying to get a print out of each line of Perl code as it executes, the way that &lt;code&gt;sh -x&lt;/code&gt; provides for shell scripts, you can't use Perl's &lt;b&gt;-D&lt;/b&gt; switch. Instead do this</source>
          <target state="translated">Если вы просто пытаетесь распечатать каждую строку кода Perl во время ее выполнения, то как &lt;code&gt;sh -x&lt;/code&gt; предоставляет сценарии оболочки, вы не можете использовать переключатель Perl &lt;b&gt;-D&lt;/b&gt; . Вместо этого сделай это</target>
        </trans-unit>
        <trans-unit id="e1d724a87dfd2f97b8c95cc8c3b05426d4d76542" translate="yes" xml:space="preserve">
          <source>If you're just trying to patch a binary, in many cases something as simple as this works:</source>
          <target state="translated">Если вы просто пытаетесь исправить двоичный файл,во многих случаях что-то настолько простое,как это работает:</target>
        </trans-unit>
        <trans-unit id="beae682a73c10931e4ab41819afea65e05d531cf" translate="yes" xml:space="preserve">
          <source>If you're looking for an EBNF grammar, see &lt;a href=&quot;parser/grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt;.</source>
          <target state="translated">Если вы ищете грамматику EBNF, см. &lt;a href=&quot;parser/grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55c4ac9978b7084a6172dad11c1733f741ff1455" translate="yes" xml:space="preserve">
          <source>If you're looking for something a bit more rigorous, try &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;.</source>
          <target state="translated">Если вы ищете что-то более строгое, попробуйте &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7091178e821abb2a7bce9c92cae74d109146a9a0" translate="yes" xml:space="preserve">
          <source>If you're looking for the information on how to use here-documents, which used to be here, that's been moved to &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Если вы ищете информацию о том, как использовать здесь-документы, которые раньше были здесь, они были перемещены в &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote и Quote-like Operators в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="889cd4ec91070da4d939fc8ed6a3a8c2e2067138" translate="yes" xml:space="preserve">
          <source>If you're looking to write your own object system, or you need to maintain code which implements objects from scratch then this document will help you understand exactly how Perl does object orientation.</source>
          <target state="translated">Если вы хотите написать свою собственную объектную систему,или вам нужно поддерживать код,который реализует объекты с нуля,то этот документ поможет вам точно понять,как Perl делает объектную ориентацию.</target>
        </trans-unit>
        <trans-unit id="ddf0bc3794c8ee98c81f65ada98d73c84a0b3b0d" translate="yes" xml:space="preserve">
          <source>If you're lucky enough to be using a system that supports non-blocking reads (most Unixish systems do), you need only to use the &lt;code&gt;O_NDELAY&lt;/code&gt; or &lt;code&gt;O_NONBLOCK&lt;/code&gt; flag from the &lt;code&gt;Fcntl&lt;/code&gt; module in conjunction with &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Если вам посчастливилось использовать систему, поддерживающую неблокирующее чтение (это делает большинство систем Unixish), вам нужно только использовать флаг &lt;code&gt;O_NDELAY&lt;/code&gt; или &lt;code&gt;O_NONBLOCK&lt;/code&gt; из модуля &lt;code&gt;Fcntl&lt;/code&gt; в сочетании с &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1442d0654a360821d205030d12b7c46d2249369f" translate="yes" xml:space="preserve">
          <source>If you're lucky you should see &quot;All tests successful&quot;. But there can be a few failed subtests (less than 5 hopefully) depending on some external conditions (e.g. some subtests fail under linux/dosemu or plain dos with short filenames only).</source>
          <target state="translated">Если тебе повезет,ты должен увидеть &quot;Все тесты успешны&quot;.Но может быть несколько неудачных подтестов (менее 5,будем надеяться)в зависимости от некоторых внешних условий (например,некоторые подтесты не работают под linux/dosemu или обычные дозы только с короткими именами файлов).</target>
        </trans-unit>
        <trans-unit id="81d8181270fe0a221e4cfe0273d672eeca038de7" translate="yes" xml:space="preserve">
          <source>If you're matching against &lt;code&gt;$_&lt;/code&gt; , the &lt;code&gt;$_ =~&lt;/code&gt; part can be omitted:</source>
          <target state="translated">Если вы сравниваете с &lt;code&gt;$_&lt;/code&gt; , часть &lt;code&gt;$_ =~&lt;/code&gt; можно опустить:</target>
        </trans-unit>
        <trans-unit id="8dff24fd1b5ec5a9dffa27b27da41b1f996870a7" translate="yes" xml:space="preserve">
          <source>If you're matching against the special default variable &lt;code&gt;$_&lt;/code&gt; , the &lt;code&gt;$_ =~&lt;/code&gt; part can be omitted:</source>
          <target state="translated">Если вы сопоставляете специальную переменную по умолчанию &lt;code&gt;$_&lt;/code&gt; , часть &lt;code&gt;$_ =~&lt;/code&gt; можно опустить:</target>
        </trans-unit>
        <trans-unit id="426f58876b20aa644c87cac6d34c02796b1541e8" translate="yes" xml:space="preserve">
          <source>If you're mixing UTF-8 and non-UTF-8 strings, it is necessary to upgrade the non-UTF-8 strings to UTF-8. If you've got an SV, the easiest way to do this is:</source>
          <target state="translated">Если вы смешиваете строки UTF-8 и неUTF-8,необходимо обновить строки неUTF-8 до UTF-8.Если у вас есть SV,самый простой способ это сделать:</target>
        </trans-unit>
        <trans-unit id="0b4dc2534030724a7fd2a22ed631de91b923d0d4" translate="yes" xml:space="preserve">
          <source>If you're more familiar with writing in HTML than with writing in Pod, you can try your hand at writing documentation in simple HTML, and converting it to Pod with the experimental &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::HTML2Pod&quot;&gt;Pod::HTML2Pod&lt;/a&gt; module, (available in CPAN), and looking at the resulting code. The experimental &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt; module in CPAN might also be useful.</source>
          <target state="translated">Если вы больше знакомы с написанием в HTML, чем с написанием в Pod, вы можете попробовать свои силы в написании документации на простом HTML и преобразовании ее в Pod с помощью экспериментального модуля &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::HTML2Pod&quot;&gt;Pod :: HTML2Pod&lt;/a&gt; (доступного в CPAN) и поиска в получившемся коде. Также может быть полезен экспериментальный модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt; в CPAN.</target>
        </trans-unit>
        <trans-unit id="661a15733b02e1bde18a48ee6f26023806e52abe" translate="yes" xml:space="preserve">
          <source>If you're more from the object-oriented camp, you can inherit from Storable and directly store your objects by invoking &lt;code&gt;store&lt;/code&gt; as a method. The fact that the root of the to-be-stored tree is a blessed reference (i.e. an object) is special-cased so that the retrieve does not provide a reference to that object but rather the blessed object reference itself. (Otherwise, you'd get a reference to that blessed object).</source>
          <target state="translated">Если вы больше принадлежите к объектно-ориентированному лагерю, вы можете наследовать от Storable и напрямую сохранять свои объекты, вызывая &lt;code&gt;store&lt;/code&gt; как метод. Тот факт, что корнем сохраняемого дерева является благословенная ссылка (то есть объект), имеет специальный регистр, так что извлечение не обеспечивает ссылку на этот объект, а скорее саму ссылку на благословенный объект. (В противном случае вы получите ссылку на этот благословенный объект).</target>
        </trans-unit>
        <trans-unit id="90c11316b76d508e073f9fc77a3e623b3eada282" translate="yes" xml:space="preserve">
          <source>If you're new to Perl, you should start by running &lt;code&gt;perldoc perlintro&lt;/code&gt; , which is a general intro for beginners and provides some background to help you navigate the rest of Perl's extensive documentation. Run &lt;code&gt;perldoc
perldoc&lt;/code&gt; to learn more things you can do with</source>
          <target state="translated">Если вы новичок в Perl, вам следует начать с запуска &lt;code&gt;perldoc perlintro&lt;/code&gt; , который является общим введением для начинающих и предоставляет некоторую справочную информацию, которая поможет вам ориентироваться в остальной части обширной документации Perl. Запустите &lt;code&gt;perldoc perldoc&lt;/code&gt; чтобы узнать больше о том, что вы можете делать с</target>
        </trans-unit>
        <trans-unit id="744942d070c981ce6cf7077125a9b1fdb8807cc7" translate="yes" xml:space="preserve">
          <source>If you're new to the Perl debugger, you may prefer to read &lt;a href=&quot;perldebtut&quot;&gt;perldebtut&lt;/a&gt;, which is a tutorial introduction to the debugger.</source>
          <target state="translated">Если вы новичок в отладчике Perl, возможно, вы предпочтете прочитать &lt;a href=&quot;perldebtut&quot;&gt;perldebtut&lt;/a&gt; , который представляет собой вводное руководство по отладчику.</target>
        </trans-unit>
        <trans-unit id="c2727aad3001460d90c1014c2e79041ef3c0a256" translate="yes" xml:space="preserve">
          <source>If you're not running VMS, this module does nothing.</source>
          <target state="translated">Если вы не запускаете VMS,этот модуль ничего не делает.</target>
        </trans-unit>
        <trans-unit id="57b30f05d7f8cbe152533a07743b1d8313aa4f82" translate="yes" xml:space="preserve">
          <source>If you're not sure what you have (the &lt;code&gt;VAL&lt;/code&gt; case), wrap the method call in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block to catch the exception if &lt;code&gt;VAL&lt;/code&gt; is undefined.</source>
          <target state="translated">Если вы не уверены, что у вас есть ( случай &lt;code&gt;VAL&lt;/code&gt; ), заключите вызов метода в блок &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , чтобы перехватить исключение, если &lt;code&gt;VAL&lt;/code&gt; не определен.</target>
        </trans-unit>
        <trans-unit id="92ef540b5bff7fa8b60e3b8701e23d84d3552eb5" translate="yes" xml:space="preserve">
          <source>If you're not the Perl administrator you probably don't have permission to install a module to its default location. Then you should install it for your own use into your home directory like so:</source>
          <target state="translated">Если вы не являетесь администратором Perl,то,скорее всего,у вас нет прав на установку модуля на его место по умолчанию.Тогда вы должны установить его для собственного использования в вашем домашнем каталоге:</target>
        </trans-unit>
        <trans-unit id="9feed406758bc42352583f962fb6765533ea27d0" translate="yes" xml:space="preserve">
          <source>If you're not used to reading BNF grammars, this is how it works: You're fed certain things by the tokeniser, which generally end up in upper case. Here, &lt;code&gt;ADDOP&lt;/code&gt; , is provided when the tokeniser sees &lt;code&gt;+&lt;/code&gt; in your code. &lt;code&gt;ASSIGNOP&lt;/code&gt; is provided when &lt;code&gt;=&lt;/code&gt; is used for assigning. These are &quot;terminal symbols&quot;, because you can't get any simpler than them.</source>
          <target state="translated">Если вы не привыкли читать грамматики BNF, то вот как это работает: вы получаете определенные данные от токенизатора, которые обычно отображаются в верхнем регистре. Здесь &lt;code&gt;ADDOP&lt;/code&gt; предоставляется, когда токенизатор видит &lt;code&gt;+&lt;/code&gt; в вашем коде. &lt;code&gt;ASSIGNOP&lt;/code&gt; предоставляется, когда &lt;code&gt;=&lt;/code&gt; используется для назначения. Это &amp;laquo;терминальные символы&amp;raquo;, потому что ничего проще их не найти.</target>
        </trans-unit>
        <trans-unit id="d41cee3341b958945c48519633ed1e0a770e7261" translate="yes" xml:space="preserve">
          <source>If you're not writing a server/client for an existing protocol like NNTP or SMTP, you should give some thought to how your server will know when the client has finished talking, and vice-versa. Most protocols are based on one-line messages and responses (so one party knows the other has finished when a &quot;\n&quot; is received) or multi-line messages and responses that end with a period on an empty line (&quot;\n.\n&quot; terminates a message/response).</source>
          <target state="translated">Если вы не пишете сервер/клиент для существующего протокола,такого как NNTP или SMTP,вам следует подумать о том,как ваш сервер узнает,когда клиент закончит говорить,и наоборот.Большинство протоколов основаны на однострочных сообщениях и ответах (так что одна сторона знает,что другая закончила при получении &quot;\n&quot;)или многострочных сообщениях и ответах,которые заканчиваются периодом на пустой строке (&quot;\n.\n&quot; завершает сообщение/ответ).</target>
        </trans-unit>
        <trans-unit id="1904985e3da30cf5eb915cfb278068985854bae1" translate="yes" xml:space="preserve">
          <source>If you're not writing such a tool, then whether you accept noncharacters as input is up to you (though the Standard recommends that you not). If you do strict input stream checking with Perl, these code points continue to be forbidden. This is to maintain backward compatibility (otherwise potential security holes could open up, as an unsuspecting application that was written assuming the noncharacters would be filtered out before getting to it, could now, without warning, start getting them). To do strict checking, you can use the layer &lt;code&gt;:encoding('UTF-8')&lt;/code&gt; .</source>
          <target state="translated">Если вы не пишете такой инструмент, то принимаете ли вы несимвольные символы в качестве входных данных - решать вам (хотя Стандарт рекомендует этого не делать). Если вы выполняете строгую проверку входного потока с помощью Perl, эти кодовые точки остаются запрещенными. Это сделано для поддержания обратной совместимости (в противном случае могут открыться потенциальные дыры в безопасности, так как ничего не подозревающее приложение, написанное с предположением, что несимволы будут отфильтрованы до того, как добраться до него, теперь может без предупреждения начать их получать). Чтобы выполнить строгую проверку, вы можете использовать слой &lt;code&gt;:encoding('UTF-8')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e740be7e86f98ca86a316e7e6f108d26ec4db83" translate="yes" xml:space="preserve">
          <source>If you're on Unix, you already have an IDE--Unix itself. The Unix philosophy is the philosophy of several small tools that each do one thing and do it well. It's like a carpenter's toolbox.</source>
          <target state="translated">Если вы на Unix,то у вас уже есть IDE-Unix.Философия Unix-это философия нескольких небольших инструментов,каждый из которых делает одну вещь и делает ее хорошо.Это как плотницкий ящик для инструментов.</target>
        </trans-unit>
        <trans-unit id="27b6c4407588281e5e7fdb718dd9826644dbabc0" translate="yes" xml:space="preserve">
          <source>If you're on a POSIX system, Perl supports the &lt;code&gt;POSIX::strtod&lt;/code&gt; function for converting strings to doubles (and also &lt;code&gt;POSIX::strtol&lt;/code&gt; for longs). Its semantics are somewhat cumbersome, so here's a &lt;code&gt;getnum&lt;/code&gt; wrapper function for more convenient access. This function takes a string and returns the number it found, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for input that isn't a C float. The &lt;code&gt;is_numeric&lt;/code&gt; function is a front end to &lt;code&gt;getnum&lt;/code&gt; if you just want to say, &quot;Is this a float?&quot;</source>
          <target state="translated">Если вы работаете в системе POSIX, Perl поддерживает функцию &lt;code&gt;POSIX::strtod&lt;/code&gt; для преобразования строк в двойные (а также &lt;code&gt;POSIX::strtol&lt;/code&gt; для длинных ). Его семантика несколько громоздка, поэтому вот &lt;code&gt;getnum&lt;/code&gt; оболочка getnum для более удобного доступа. Эта функция принимает строку и возвращает найденное число или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; для входных данных, которые не являются числами C с плавающей запятой. Функция &lt;code&gt;is_numeric&lt;/code&gt; - это интерфейс для &lt;code&gt;getnum&lt;/code&gt; , если вы просто хотите спросить: &amp;laquo;Это число с плавающей запятой?&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="fe652d8671f9747b2b27fba3ba0a6953bf5a58ab" translate="yes" xml:space="preserve">
          <source>If you're only a C programmer, than this is the end of the message for you. You can quit right now, and if you care to, save off the source and run it when you feel like it. Or not.</source>
          <target state="translated">Если вы только программист на Си,то для вас это конец сообщения.Вы можете уволиться прямо сейчас,и если хотите,сохранить исходный текст и запустить его,когда захотите.Или нет.</target>
        </trans-unit>
        <trans-unit id="5f443393381ebb2ba3b4781af2f167f994444b4f" translate="yes" xml:space="preserve">
          <source>If you're passing a filehandle to a function, you can write the function in two ways:</source>
          <target state="translated">Если вы передаете файловую ручку в функцию,вы можете записать функцию двумя способами:</target>
        </trans-unit>
        <trans-unit id="3681c9d29e3cea8b052a12522cde089c668422cf" translate="yes" xml:space="preserve">
          <source>If you're passing around filehandles, you could usually just use the bare typeglob, like &lt;code&gt;*STDOUT&lt;/code&gt; , but typeglobs references work, too. For example:</source>
          <target state="translated">Если вы передаете дескрипторы файлов, вы обычно можете просто использовать голый typeglob, например &lt;code&gt;*STDOUT&lt;/code&gt; , но ссылки на typeglobs тоже работают. Например:</target>
        </trans-unit>
        <trans-unit id="8f816f45cbfc0eef6f9ae6c1011d3c4a6ca61924" translate="yes" xml:space="preserve">
          <source>If you're planning on generating new filehandles, you could do this. Notice to pass back just the bare *FH, not its reference.</source>
          <target state="translated">Если вы планируете создать новые файловые ручки,вы можете это сделать.Обратите внимание на то,чтобы передать обратно только голый *FH,а не его ссылку.</target>
        </trans-unit>
        <trans-unit id="e8bfd94e153d8978fbc196c7118de9fb39d2dab3" translate="yes" xml:space="preserve">
          <source>If you're planning to do more extensive work than a single small fix, we encourage you to read the documentation below. This will help you focus your work and make your patches easier to incorporate into the Perl source.</source>
          <target state="translated">Если вы планируете выполнить более обширную работу,чем одно небольшое исправление,мы рекомендуем вам прочитать документацию ниже.Это поможет вам сфокусировать работу и упростит включение патчей в исходный текст на Perl.</target>
        </trans-unit>
        <trans-unit id="304b9d32f29eb0f2f218ff94e8f5f53580345dcb" translate="yes" xml:space="preserve">
          <source>If you're planning to filetest the return values out of a &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, you'd better prepend the directory in question. Otherwise, because we didn't &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; there, it would have been testing the wrong file.</source>
          <target state="translated">Если вы планируете тестировать возвращаемые значения из &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; , вам лучше добавить соответствующий каталог. В противном случае, поскольку мы не использовали &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; , тестировался не тот файл.</target>
        </trans-unit>
        <trans-unit id="f907870b50e1902094cd7a51307296876f77264b" translate="yes" xml:space="preserve">
          <source>If you're planning to filetest the return values out of a &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, you'd better prepend the directory in question. Otherwise, because we didn't &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; there, it would have been testing the wrong file.</source>
          <target state="translated">Если вы планируете тестировать возвращаемые значения из &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; , вам лучше добавить соответствующий каталог. В противном случае, поскольку мы не использовали &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; , тестировался не тот файл.</target>
        </trans-unit>
        <trans-unit id="fcece448e0aa8ee8873fb9b13cee8077eaed1e18" translate="yes" xml:space="preserve">
          <source>If you're reading this document because you want to write a formatter subclass, continue reading it and then read &lt;a href=&quot;simple/subclassing&quot;&gt;Pod::Simple::Subclassing&lt;/a&gt;, and then possibly even read &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; (some of which is for parser-writers, but much of which is notes to formatter-writers).</source>
          <target state="translated">Если вы читаете этот документ, потому что хотите написать подкласс средства форматирования, продолжайте читать его, а затем прочтите &lt;a href=&quot;simple/subclassing&quot;&gt;Pod :: Simple :: Subclassing&lt;/a&gt; , а затем, возможно, даже прочитайте &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; (некоторые из которых предназначены для разработчиков синтаксических анализаторов, но многие из них это примечания для редакторов форматирования).</target>
        </trans-unit>
        <trans-unit id="3eca1cf4cac957f4047c12a2cccf4d8bf7c0618e" translate="yes" xml:space="preserve">
          <source>If you're reading this document just because you have a Pod-processing subclass that you want to use, this document (plus the documentation for the subclass) is probably all you need to read.</source>
          <target state="translated">Если вы читаете этот документ только потому,что у вас есть подкласс Pod-обработки,который вы хотите использовать,этот документ (плюс документация для подкласса)-это,вероятно,все,что вам нужно прочитать.</target>
        </trans-unit>
        <trans-unit id="b7d2d7b7f7d3b1824419996342901896caf3e1ec" translate="yes" xml:space="preserve">
          <source>If you're running Perl on a system that distinguishes between text files and binary files, then you should check out &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt; for tips for dealing with this. The key distinction between systems that need &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; and those that don't is their text file formats. Systems like Unix, Mac OS, and Plan 9, that end lines with a single character and encode that character in C as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; do not need &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt;. The rest need it.</source>
          <target state="translated">Если вы используете Perl в системе, которая различает текстовые файлы и двоичные файлы, вам следует проверить &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt; для получения советов по решению этой проблемы. Ключевое различие между системами, которым требуется &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; , и системами, в которых его нет, - это форматы текстовых файлов. Такие системы, как Unix, Mac OS и Plan 9, которые заканчивают строки одним символом и кодируют этот символ в C как &lt;code&gt;&quot;\n&quot;&lt;/code&gt; , не нуждаются в &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; . Остальным это нужно.</target>
        </trans-unit>
        <trans-unit id="ffabd87b995f6de8b55fa057fefd0560b9ffddaf" translate="yes" xml:space="preserve">
          <source>If you're running Perl on a system that distinguishes between text files and binary files, then you should check out &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt; for tips for dealing with this. The key distinction between systems that need &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; and those that don't is their text file formats. Systems like Unix, Mac OS, and Plan 9, that end lines with a single character and encode that character in C as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; do not need &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt;. The rest need it.</source>
          <target state="translated">Если вы используете Perl в системе, которая различает текстовые файлы и двоичные файлы, вам следует проверить &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt; для получения советов по решению этой проблемы. Ключевое различие между системами, которым требуется &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; , и системами, в которых его нет, - это форматы текстовых файлов. Такие системы, как Unix, Mac OS и Plan 9, которые заканчивают строки одним символом и кодируют этот символ в C как &lt;code&gt;&quot;\n&quot;&lt;/code&gt; , не нуждаются в &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; . Остальным это нужно.</target>
        </trans-unit>
        <trans-unit id="39c1b50b544a3df322b75f65dc11d5ac4c69a35f" translate="yes" xml:space="preserve">
          <source>If you're storing handles in an array or hash, or in general whenever you're using any expression more complex than a bareword handle or a plain, unsubscripted scalar variable to retrieve it, you will have to use a block returning the filehandle value instead, in which case the LIST may not be omitted:</source>
          <target state="translated">Если вы храните дескрипторы в массиве или хэше,или вообще когда вы используете какое-либо выражение,более сложное,чем дескриптор пустого слова или простую,не подписанную скалярную переменную,чтобы получить ее,вам придется использовать блок,возвращающий значение дескриптора,и в этом случае СПИСОК не может быть опущен:</target>
        </trans-unit>
        <trans-unit id="1ed2a4901ca871ef8cee85b2ad371ae78f316632" translate="yes" xml:space="preserve">
          <source>If you're submitting values using the GET method, create a URL and encode the form using the &lt;code&gt;query_form&lt;/code&gt; method:</source>
          <target state="translated">Если вы отправляете значения с помощью метода GET, создайте URL-адрес и &lt;code&gt;query_form&lt;/code&gt; форму с помощью метода query_form :</target>
        </trans-unit>
        <trans-unit id="d5f5ca288d27f19393728db02ea58b007b723ea8" translate="yes" xml:space="preserve">
          <source>If you're talking about obscuring method calls in parent classes, see &lt;a href=&quot;perlootut#Overriding-methods-and-method-resolution&quot;&gt;Overriding methods and method resolution in perlootut&lt;/a&gt;.</source>
          <target state="translated">Если вы говорите о скрытии вызовов методов в родительских классах, см. &lt;a href=&quot;perlootut#Overriding-methods-and-method-resolution&quot;&gt;Переопределение методов и разрешения методов в perlootut&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9fb0313a494e266734d606dab0fb4c3f5c1638a" translate="yes" xml:space="preserve">
          <source>If you're trying to do variable interpolation, it's definitely better to use the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; function, because the older notation can cause people to become confused with the indirect filehandle notation.</source>
          <target state="translated">Если вы пытаетесь выполнить интерполяцию переменных, определенно лучше использовать функцию &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; , потому что старая нотация может запутать людей с косвенной нотацией дескриптора файла.</target>
        </trans-unit>
        <trans-unit id="b2f801c8c750d6402e7dad5eddfca92a856a8093" translate="yes" xml:space="preserve">
          <source>If you're unsure of the meaning of an error message you've run across, &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; for an explanation. If the message isn't in perldiag, it probably isn't generated by Perl. You may have luck consulting your operating system documentation instead.</source>
          <target state="translated">Если вы не уверены в значении обнаруженного вами сообщения об ошибке, за разъяснениями &lt;a href=&quot;perldiag&quot;&gt;обратитесь&lt;/a&gt; к &lt;b&gt;perldoc &lt;/b&gt;perldiag . Если сообщения нет в perldiag, вероятно, оно не сгенерировано Perl. Вместо этого вам, возможно, посчастливится проконсультироваться с документацией по вашей операционной системе.</target>
        </trans-unit>
        <trans-unit id="4b93133a107f3dc1672015bebe523f72dafb6b9f" translate="yes" xml:space="preserve">
          <source>If you're uploading to CPAN, the automated gremlins will extract the README file and place that in your CPAN directory. It'll also appear in the main</source>
          <target state="translated">Если вы загружаете в CPAN,автоматические гремлины извлекут файл README и поместят его в ваш каталог CPAN.Он также появится в главном</target>
        </trans-unit>
        <trans-unit id="3ad89e38e60f381b4a7eacce6c02e2db727251db" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;Archive::Tar&lt;/code&gt; 's &lt;code&gt;extract()&lt;/code&gt; method, &lt;code&gt;setcwd()&lt;/code&gt; will be called for you.</source>
          <target state="translated">Если вы используете &lt;code&gt;Archive::Tar&lt;/code&gt; &amp;laquo;s &lt;code&gt;extract()&lt;/code&gt; метод, &lt;code&gt;setcwd()&lt;/code&gt; будет вызываться для вас.</target>
        </trans-unit>
        <trans-unit id="0cc14a892bad71218591bbe7bbef35b81fe36647" translate="yes" xml:space="preserve">
          <source>If you're using VMStar:</source>
          <target state="translated">Если ты используешь VMStar:</target>
        </trans-unit>
        <trans-unit id="76511f6d042eedee604ffae23aa88974c6f04729" translate="yes" xml:space="preserve">
          <source>If you're using a module that's not thread-safe for some reason, you can protect yourself by using it from one, and only one thread at all. If you need multiple threads to access such a module, you can use semaphores and lots of programming discipline to control access to it. Semaphores are covered in &lt;a href=&quot;#Basic-semaphores&quot;&gt;Basic semaphores&lt;/a&gt;.</source>
          <target state="translated">Если вы используете модуль, который по какой-то причине не является потокобезопасным, вы можете защитить себя, используя его из одного и только одного потока. Если вам нужно несколько потоков для доступа к такому модулю, вы можете использовать семафоры и множество программных дисциплин для управления доступом к нему. Семафоры описаны в &lt;a href=&quot;#Basic-semaphores&quot;&gt;Базовых семафорах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9aa1259aa5ab1edcbb7c8ec755fbb7d9933607e8" translate="yes" xml:space="preserve">
          <source>If you're using a version of Perl before 5.004, you must call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; once at the start of your program to seed the random number generator.</source>
          <target state="translated">Если вы используете версию Perl до 5.004, вы должны вызвать &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; один раз в начале своей программы, чтобы заполнить генератор случайных чисел.</target>
        </trans-unit>
        <trans-unit id="9ff91ee4a99e5bbc7fa9f896e9934c1f57633ce3" translate="yes" xml:space="preserve">
          <source>If you're using localization in an application that keeps a configuration file, you might consider something like this in your project class:</source>
          <target state="translated">Если вы используете локализацию в приложении,которое хранит файл конфигурации,вы можете рассмотреть нечто подобное в своем проектном классе:</target>
        </trans-unit>
        <trans-unit id="e98919158b85262f93e6e1cca66f69e28561af51" translate="yes" xml:space="preserve">
          <source>If you're using references as keys within your hash tables, you're bound to be disappointed when retrieving your data. Indeed, Perl stringifies references used as hash table keys. If you later wish to access the items via another reference stringification (i.e. using the same reference that was used for the key originally to record the value into the hash table), it will work because both references stringify to the same string.</source>
          <target state="translated">Если вы используете ссылки в качестве ключей в ваших хэш-таблицах,вы наверняка будете разочарованы при извлечении данных.Действительно,Perl строчит ссылки,используемые в качестве ключей хэш-таблиц.Если позже вы захотите получить доступ к элементам с помощью другой строковой идентификации (т.е.используя ту же самую ссылку,которая использовалась для ключа изначально для записи значения в хэш-таблицу),то это сработает,потому что обе ссылки строятся в одну и ту же строку.</target>
        </trans-unit>
        <trans-unit id="cda64e05edf4afefc7befad6697f98377f63d5c2" translate="yes" xml:space="preserve">
          <source>If you're using strict, you</source>
          <target state="translated">Если ты используешь строгое,ты</target>
        </trans-unit>
        <trans-unit id="5149a95571d7bad870cf9d14644f05c40d4e4c11" translate="yes" xml:space="preserve">
          <source>If you're using the POST method, create your own user agent and encode the content appropriately.</source>
          <target state="translated">Если вы используете метод POST,создайте свой собственный пользовательский агент и закодируйте содержимое соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="94dea5f329a320df5b1676d594bbe7ddb6af4d25" translate="yes" xml:space="preserve">
          <source>If you're using untarzipme or StuffIt, the archive should be extracted now. &lt;b&gt;Or&lt;/b&gt;, you can use the freeware &lt;b&gt;suntar&lt;/b&gt; or</source>
          <target state="translated">Если вы используете untarzipme или StuffIt, архив должен быть извлечен сейчас. &lt;b&gt;Или&lt;/b&gt; вы можете использовать бесплатную программу &lt;b&gt;suntar&lt;/b&gt; или</target>
        </trans-unit>
        <trans-unit id="03aaa8fe5a352318fc187dc162360b47448bfe8d" translate="yes" xml:space="preserve">
          <source>If you're working with globs at runtime, and need to disambiguate *^G from *{&quot;^G&quot;}, then you should use the raw NAME method.</source>
          <target state="translated">Если вы работаете с глобусами во время выполнения,и вам нужно выделить *^G из *{&quot;^G&quot;},то вам следует использовать метод raw NAME.</target>
        </trans-unit>
        <trans-unit id="86326ce985c6268f6aa266be33a273db0ac99980" translate="yes" xml:space="preserve">
          <source>If you're worried about users selecting bad passwords, you should proactively check when they try to change their password (by modifying</source>
          <target state="translated">Если вы беспокоитесь о том,что пользователи выбирают плохие пароли,вам следует проактивно проверять,когда они пытаются сменить свой пароль (путем модификации</target>
        </trans-unit>
        <trans-unit id="c631e014f0d55506d4df289cf9b8b44d3544afb4" translate="yes" xml:space="preserve">
          <source>If you're writing code, such as an editor, that is supposed to be able to handle any Unicode text data, then you shouldn't be using these code points yourself, and instead allow them in the input. If you need sentinels, they should instead be something that isn't legal Unicode. For UTF-8 data, you can use the bytes 0xC1 and 0xC2 as sentinels, as they never appear in well-formed UTF-8. (There are equivalents for UTF-EBCDIC). You can also store your Unicode code points in integer variables and use negative values as sentinels.</source>
          <target state="translated">Если вы пишете код,например,редактор,который должен быть способен обрабатывать любые текстовые данные Юникода,то вы не должны сами использовать эти точки кода,а вместо этого допускать их во входных данных.Если вам нужны дозорные,они должны быть чем-то не легальным в Юникоде.Для данных в кодировке UTF-8 в качестве часовых можно использовать байты 0xC1 и 0xC2,так как они никогда не появляются в хорошо сформированной кодировке UTF-8.(Есть эквиваленты для UTF-EBCDIC).Вы также можете хранить точки кода Unicode в целочисленных переменных и использовать отрицательные значения в качестве часовых.</target>
        </trans-unit>
        <trans-unit id="a276dfc7f44e7268960d2975b30664b78a301f5a" translate="yes" xml:space="preserve">
          <source>If you're writing your own &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, you may need to create your own iterators too. If so you'll need to subclass &lt;a href=&quot;parser/iterator&quot;&gt;TAP::Parser::Iterator&lt;/a&gt;.</source>
          <target state="translated">Если вы пишете свой собственный &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; , вам также может потребоваться создать свои собственные итераторы. Если это так, вам нужно &lt;a href=&quot;parser/iterator&quot;&gt;создать&lt;/a&gt; подкласс TAP :: Parser :: Iterator .</target>
        </trans-unit>
        <trans-unit id="6d3ca82cb6d85e36f098b04f831321b68f9f28ab" translate="yes" xml:space="preserve">
          <source>If you're writing your own documentation in POD, the</source>
          <target state="translated">Если вы пишете свою собственную документацию в POD,то</target>
        </trans-unit>
        <trans-unit id="609941eec97975f4a0354cdbfbac32c60f31f261" translate="yes" xml:space="preserve">
          <source>If you've already got some other kind of email object, consider passing it to &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Abstract&quot;&gt;Email::Abstract&lt;/a&gt; and then using its cast method to get an &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; object:</source>
          <target state="translated">Если у вас уже есть какой-то другой объект электронной почты, подумайте о передаче его в &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Abstract&quot;&gt;Email :: Abstract,&lt;/a&gt; а затем с помощью его метода cast для получения объекта &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email :: MIME&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="49b89fe4b531fe550fa8cdc2584e0b4d10940e84" translate="yes" xml:space="preserve">
          <source>If you've been around Perl a while, all this talk of escape sequences may seem familiar. Similar escape sequences are used in double-quoted strings and in fact the regexps in Perl are mostly treated as double-quoted strings. This means that variables can be used in regexps as well. Just like double-quoted strings, the values of the variables in the regexp will be substituted in before the regexp is evaluated for matching purposes. So we have:</source>
          <target state="translated">Если вы были некоторое время рядом с Перлом,все эти разговоры о последовательности побега могут показаться знакомыми.Подобные экранирующие последовательности используются в строках в двойных кавычках,а на самом деле,регеxps в Perl в основном рассматриваются как строки в двойных кавычках.Это означает,что переменные могут использоваться и в регеxps.Так же,как и строки в двойных кавычках,значения переменных в регеxp будут подставляться до того,как регеxp будет вычислен для соответствия.Так и есть:</target>
        </trans-unit>
        <trans-unit id="3fd6cd86298d336909fb8326200590d5396e0f52" translate="yes" xml:space="preserve">
          <source>If you've chosen to use vac 4, be sure to run 4.4.0.3. Older versions will turn up nasty later on. For vac 5 be sure to run at least 5.0.1.0, but vac 5.0.2.6 or up is highly recommended. Note that since IBM has removed vac 5.0.2.1 through 5.0.2.5 from the software depot, these versions should be considered obsolete.</source>
          <target state="translated">Если вы решили использовать vac 4,обязательно запустите 4.4.0.3.Более старые версии будут неприятны позже.Для версии 5 обязательно запустите как минимум 5.0.1.0,но настоятельно рекомендуется использовать версию 5.0.2.6 или выше.Обратите внимание,что поскольку IBM удалила версии 5.0.2.1-5.0.2.5 из хранилища программного обеспечения,эти версии следует считать устаревшими.</target>
        </trans-unit>
        <trans-unit id="7f36de392e6562a98fef168bd0f4fd2b6d55a056" translate="yes" xml:space="preserve">
          <source>If you've found a bug with the perl interpreter or one of the modules in the standard library (those that come with Perl), you can use the &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; utility that comes with Perl (&amp;gt;= 5.004). It collects information about your installation to include with your message, then sends the message to the right place.</source>
          <target state="translated">Если вы обнаружили ошибку в интерпретаторе Perl или в одном из модулей стандартной библиотеки (тех, которые поставляются с Perl), вы можете использовать утилиту &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; , поставляемую с Perl (&amp;gt; = 5.004). Он собирает информацию о вашей установке для включения в ваше сообщение, а затем отправляет сообщение в нужное место.</target>
        </trans-unit>
        <trans-unit id="b588af6702d40920fe6ce77142ddd4be23c82335" translate="yes" xml:space="preserve">
          <source>If you've just implemented a new feature, complete with doc, tests and well-commented code, a brief commit message will often suffice. If, however, you've just changed a single character deep in the parser or lexer, you might need to write a small novel to ensure that future readers understand what you did and why you did it.</source>
          <target state="translated">Если вы только что внедрили новую возможность,снабжённую док-станцией,тестами и хорошо прокомментированным кодом,часто достаточно короткого сообщения о коммите.Однако,если вы только что изменили один символ глубоко в парсере или лексере,вам может понадобиться написать небольшой роман,чтобы будущие читатели поняли,что вы сделали и почему вы это сделали.</target>
        </trans-unit>
        <trans-unit id="f8a6a3763262120fa20c3dbe30b8abff9d5efbc9" translate="yes" xml:space="preserve">
          <source>If you've played with the examples above and tried to embed a script that</source>
          <target state="translated">Если вы играли с приведенными выше примерами и пытались внедрить скрипт,который</target>
        </trans-unit>
        <trans-unit id="b894c5ed183f4f7ceceb8937af0c436c24867f7d" translate="yes" xml:space="preserve">
          <source>If you've read all the documentation in the document and the ones listed above, you're more than ready to hack on Perl.</source>
          <target state="translated">Если вы прочитали всю документацию в документе и перечисленные выше,вы более чем готовы взломать Perl.</target>
        </trans-unit>
        <trans-unit id="f7a6adb80f0b785d2ca1e30e58d59926760d3865" translate="yes" xml:space="preserve">
          <source>If you've read this far in the docs, you've seen this:</source>
          <target state="translated">Если вы так далеко читали в доках,вы это видели:</target>
        </trans-unit>
        <trans-unit id="a5397b1b280e497ccfa7136829a3dcfe46903bd5" translate="yes" xml:space="preserve">
          <source>If you've selected VMS syntax, and the file specification you pass to one of these routines contains a &quot;/&quot;, they assume you are using Unix emulation and apply the Unix syntax rules instead, for that function call only.</source>
          <target state="translated">Если вы выбрали синтаксис VMS,и спецификация файла,которую вы передаете в одну из этих процедур,содержит &quot;/&quot;,они предполагают,что вы используете эмуляцию Unix и применяете правила синтаксиса Unix вместо этого,только для этого вызова функции.</target>
        </trans-unit>
        <trans-unit id="33caaa832315103fc3c31014628789c923502260" translate="yes" xml:space="preserve">
          <source>If you, as a user, do not need explicit access to the &quot;seen&quot; hash, then you can set the &lt;code&gt;Sparseseen&lt;/code&gt; option to allow Data::Dumper to eschew building the &quot;seen&quot; hash for scalars that are known not to possess more than one reference. This speeds up serialization considerably if you use the XS implementation.</source>
          <target state="translated">Если вам, как пользователю, не нужен явный доступ к &amp;laquo; &lt;code&gt;Sparseseen&lt;/code&gt; &amp;raquo; хешу, то вы можете установить параметр Sparseseen, чтобы разрешить Data :: Dumper избегать построения &amp;laquo;видимого&amp;raquo; хэша для скаляров, которые, как известно, не обладают более чем одна ссылка. Это значительно ускоряет сериализацию, если вы используете реализацию XS.</target>
        </trans-unit>
        <trans-unit id="5641fffcc326bff3bce0a7d7f55bb29dc536ec90" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;DESTROY&lt;/code&gt; method issues a warning during global destruction, the Perl interpreter will append the string &quot; during global destruction&quot; to the warning.</source>
          <target state="translated">Если ваш метод &lt;code&gt;DESTROY&lt;/code&gt; выдает предупреждение во время глобального уничтожения, интерпретатор Perl добавит к предупреждению строку &amp;laquo;во время глобального уничтожения&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e35bc3de6478c74b3aa05b11b90d2c08a9c1eb35" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;DESTROY&lt;/code&gt; method throws an error, this error will be ignored. It will not be sent to &lt;code&gt;STDERR&lt;/code&gt; and it will not cause the program to die. However, if your destructor is running inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; block, then the error will change the value of &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">Если ваш метод &lt;code&gt;DESTROY&lt;/code&gt; выдает ошибку, эта ошибка будет проигнорирована. Он не будет отправлен в &lt;code&gt;STDERR&lt;/code&gt; и не приведет к завершению работы программы. Однако, если ваш деструктор выполняется внутри блока &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , ошибка изменит значение &lt;code&gt;$@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd8f1a46e80e1b05c149003c578cc17ee1529e3e" translate="yes" xml:space="preserve">
          <source>If your AIX is installed with 64-bit support, you can expect 64-bit configurations to work. In combination with threads some tests might still fail.</source>
          <target state="translated">Если ваш AIX установлен с 64-битной поддержкой,можно ожидать,что 64-битные конфигурации будут работать.В сочетании с потоками некоторые тесты все равно могут не сработать.</target>
        </trans-unit>
        <trans-unit id="91cec945ceabbd679cf0509d145b2a724547b098" translate="yes" xml:space="preserve">
          <source>If your AIX system is installed with 64-bit support, you can expect 64-bit configurations to work. If you want to use 64-bit Perl on AIX 6.1 you need an APAR for a libc.a bug which affects (n)dbm_XXX functions. The APAR number for this problem is IZ39077.</source>
          <target state="translated">Если ваша система AIX установлена с поддержкой 64-битных версий,то можно ожидать,что 64-битные конфигурации будут работать.Если вы хотите использовать 64-битный Perl на AIX 6.1,вам понадобится APAR для ошибки libc.a,которая влияет на функции (n)dbm_XXX.Номер APAR для этой проблемы-IZ39077.</target>
        </trans-unit>
        <trans-unit id="70f3f72afc2e138648aa89e71840c2969a866fbe" translate="yes" xml:space="preserve">
          <source>If your EXISTS function returns true, Memoize will try to fetch the cached value by invoking &lt;code&gt;C-&amp;gt;FETCH(key)&lt;/code&gt; . MyExpirePolicy::FETCH should return the cached value. Otherwise, Memoize will call the memoized function to compute the appropriate value, and will store it into the cache by calling &lt;code&gt;C-&amp;gt;STORE(key, value)&lt;/code&gt; .</source>
          <target state="translated">Если ваша функция EXISTS возвращает истину, Memoize попытается получить кешированное значение, вызвав &lt;code&gt;C-&amp;gt;FETCH(key)&lt;/code&gt; . MyExpirePolicy :: FETCH должен возвращать кешированное значение. В противном случае Memoize вызовет мемоизированную функцию для вычисления соответствующего значения и сохранит его в кеше, вызвав &lt;code&gt;C-&amp;gt;STORE(key, value)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e28af787c875d4ef84c9b0c4d899259d2721791" translate="yes" xml:space="preserve">
          <source>If your PO and MO files are under a path elsewhere than &lt;code&gt;auto/&lt;/code&gt; , you may specify it using the &lt;code&gt;Path&lt;/code&gt; option.</source>
          <target state="translated">Если ваши файлы PO и MO находятся в другом месте, кроме &lt;code&gt;auto/&lt;/code&gt; , вы можете указать его с помощью параметра &lt;code&gt;Path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58c89e96cd32d30e30553bcd6fbdd11d2690ecc7" translate="yes" xml:space="preserve">
          <source>If your Perl book isn't listed and you think it should be, let us know.</source>
          <target state="translated">Если ваша книга Perl не в списке,и вы думаете,что так и должно быть,дайте нам знать.</target>
        </trans-unit>
        <trans-unit id="6d6e9b58c49da08447f00e52e9068c5bb7576426" translate="yes" xml:space="preserve">
          <source>If your Perl script is itself encoded in &lt;a href=&quot;#Unicode-Encodings&quot;&gt;UTF-8&lt;/a&gt;, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma must be explicitly included to enable recognition of that (in string or regular expression literals, or in identifier names). &lt;b&gt;This is the only time when an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
utf8&lt;/code&gt; is needed.&lt;/b&gt; (See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;).</source>
          <target state="translated">Если ваш Perl-скрипт сам закодирован в &lt;a href=&quot;#Unicode-Encodings&quot;&gt;UTF-8&lt;/a&gt; , прагма &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; должна быть явно включена, чтобы ее можно было распознать (в строковых литералах, литералах регулярных выражений или в именах идентификаторов). &lt;b&gt;Это единственный раз, когда требуется явное &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; . &lt;/b&gt;(См. &lt;a href=&quot;utf8&quot;&gt;Utf8&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1456eed38b989e671412e5dabebc6b17a35fdee8" translate="yes" xml:space="preserve">
          <source>If your Perl success stories and testimonials may be of help to others who wish to advocate the use of Perl in their applications, or if you wish to simply express your gratitude to Larry and the Perl developers, please write to perl-thanks@perl.org .</source>
          <target state="translated">Если ваши истории успеха Perl и отзывы могут быть полезны тем,кто хочет пропагандировать использование Perl в своих приложениях,или если вы хотите просто выразить свою благодарность Ларри и разработчикам Perl,пожалуйста,напишите по адресу perl-thanks@perl.org .</target>
        </trans-unit>
        <trans-unit id="bb4511b53500ce7e796c6be816fd150d579ce6bd" translate="yes" xml:space="preserve">
          <source>If your Perl was configured with &lt;b&gt;-Accflags=-DPERL_MEM_LOG&lt;/b&gt;, setting the environment variable &lt;code&gt;PERL_MEM_LOG&lt;/code&gt; enables logging debug messages. The value has the form &lt;code&gt;&amp;lt;&lt;i&gt;number&lt;/i&gt;&amp;gt;[m][s][t]&lt;/code&gt;, where &lt;code&gt;&lt;i&gt;number&lt;/i&gt;&lt;/code&gt; is the file descriptor number you want to write to (2 is default), and the combination of letters specifies that you want information about (m)emory and/or (s)v, optionally with (t)imestamps. For example, &lt;code&gt;PERL_MEM_LOG=1mst&lt;/code&gt; logs all information to stdout. You can write to other opened file descriptors in a variety of ways:</source>
          <target state="translated">Если ваш Perl был настроен с помощью &lt;b&gt;-Accflags = -DPERL_MEM_LOG&lt;/b&gt; , установка переменной среды &lt;code&gt;PERL_MEM_LOG&lt;/code&gt; позволяет вести журнал отладочных сообщений. Значение имеет вид &lt;code&gt;&amp;lt;&lt;i&gt;number&lt;/i&gt;&amp;gt;[m][s][t]&lt;/code&gt; , где &lt;code&gt;&lt;i&gt;number&lt;/i&gt;&lt;/code&gt; - это номер дескриптора файла, в который вы хотите записать (2 по умолчанию), а комбинация букв указывает, что вам нужна информация о (m) emory и / или (s) v, необязательно с (t) imestamps. Например, &lt;code&gt;PERL_MEM_LOG=1mst&lt;/code&gt; записывает всю информацию в стандартный вывод. Вы можете писать в другие открытые файловые дескрипторы различными способами:</target>
        </trans-unit>
        <trans-unit id="283276e9d183ad9eef7a4c2f27ba79df3995c5ec" translate="yes" xml:space="preserve">
          <source>If your algorithm requires that &lt;code&gt;reduce&lt;/code&gt; produce an identity value, then make sure that you always pass that identity value as the first argument to prevent &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; being returned</source>
          <target state="translated">Если ваш алгоритм требует, чтобы &lt;code&gt;reduce&lt;/code&gt; производило значение идентификатора, убедитесь, что вы всегда передаете это значение идентификатора в качестве первого аргумента, чтобы предотвратить возврат &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="826651d97de1fb76050036181700ee31a9d7cf34" translate="yes" xml:space="preserve">
          <source>If your application requires accepting data from untrusted sources, you are best off with a less powerful and more-likely safe serialization format and implementation. If your data is sufficiently simple, JSON is a good choice and offers maximum interoperability.</source>
          <target state="translated">Если ваше приложение требует принимать данные из недоверенных источников,лучше всего использовать менее мощный и более безопасный формат и реализацию сериализации.Если ваши данные достаточно просты,JSON является хорошим выбором и предлагает максимальную функциональную совместимость.</target>
        </trans-unit>
        <trans-unit id="6fedf0cadcf133b09c8efb7dc310cff7b7302cdf" translate="yes" xml:space="preserve">
          <source>If your changes are in a single git commit, run the following commands to generate the patch file and attach it to your bug report:</source>
          <target state="translated">Если ваши изменения находятся в одном git-комите,выполните следующие команды,чтобы сгенерировать файл заплаток и прикрепить его к отчёту об ошибке:</target>
        </trans-unit>
        <trans-unit id="db2c1fd426ed9f2c60db2929723c4b3e4c8b99fa" translate="yes" xml:space="preserve">
          <source>If your changes are in multiple commits, generate a patch file for each one and provide them to perlbug's &lt;code&gt;-p&lt;/code&gt; option separated by commas:</source>
          <target state="translated">Если ваши изменения находятся в нескольких коммитах, сгенерируйте файл патча для каждого из них и предоставьте их для параметра perlbug &lt;code&gt;-p&lt;/code&gt; , разделив их запятыми:</target>
        </trans-unit>
        <trans-unit id="e23115cc45aeaf527b25ea3227a4ca58a4bbcf8b" translate="yes" xml:space="preserve">
          <source>If your class does have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method, we strongly recommend that you override &lt;code&gt;can&lt;/code&gt; in your class as well. Your overridden &lt;code&gt;can&lt;/code&gt; method should return a subroutine reference for any method that your &lt;code&gt;AUTOLOAD&lt;/code&gt; responds to.</source>
          <target state="translated">Если в вашем классе есть метод &lt;code&gt;AUTOLOAD&lt;/code&gt; , мы настоятельно рекомендуем вам также переопределить &lt;code&gt;can&lt;/code&gt; в своем классе. Ваш переопределенный метод &lt;code&gt;can&lt;/code&gt; должен возвращать ссылку на подпрограмму для любого метода, на который отвечает ваш &lt;code&gt;AUTOLOAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce7692bb0712bd055e295162eb35d771d86fcad6" translate="yes" xml:space="preserve">
          <source>If your class responds to method calls via &lt;code&gt;AUTOLOAD&lt;/code&gt; , you may want to overload &lt;code&gt;can&lt;/code&gt; to return a subroutine reference for methods which your &lt;code&gt;AUTOLOAD&lt;/code&gt; method handles.</source>
          <target state="translated">Если ваш класс отвечает на вызовы методов через &lt;code&gt;AUTOLOAD&lt;/code&gt; , вы можете перегрузки &lt;code&gt;can&lt;/code&gt; возвращать ссылку на подпрограмму для методов , которые ваш &lt;code&gt;AUTOLOAD&lt;/code&gt; метод ручки.</target>
        </trans-unit>
        <trans-unit id="d51ef4c74c99126a798f834a23d66ffbb341d516" translate="yes" xml:space="preserve">
          <source>If your code is destined for systems with severely constrained (or missing!) virtual memory systems then you want to be</source>
          <target state="translated">Если ваш код предназначен для систем с сильно ограниченной (или отсутствующей!)виртуальной памятью,то вы хотите быть</target>
        </trans-unit>
        <trans-unit id="b8ec960b62faa8f2d9e01172beeee1747d962ecd" translate="yes" xml:space="preserve">
          <source>If your code is to run on Perl versions earlier than 5.20, it is worthwhile to note that using &lt;code&gt;$`&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; slows down regexp matching quite a bit, while &lt;code&gt;$&amp;amp;&lt;/code&gt; slows it down to a lesser extent, because if they are used in one regexp in a program, they are generated for</source>
          <target state="translated">Если ваш код должен работать в версиях Perl до 5.20, стоит отметить, что использование &lt;code&gt;$`&lt;/code&gt; и &lt;code&gt;$'&lt;/code&gt; немного замедляет сопоставление регулярных выражений, тогда как &lt;code&gt;$&amp;amp;&lt;/code&gt; замедляет его в меньшей степени, потому что, если они используются в одно регулярное выражение в программе, они генерируются для</target>
        </trans-unit>
        <trans-unit id="f35b1b808d1504007b3ea085214451b1ee61358c" translate="yes" xml:space="preserve">
          <source>If your code just uses the 52 letters A-Z and a-z, plus SPACE, the digits 0-9, and the punctuation characters that Perl uses, plus a few controls that are denoted by escape sequences like &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt; , then there's nothing special about using Perl, and your code may very well work on an ASCII machine without change.</source>
          <target state="translated">Если в вашем коде всего лишь 52 буквы AZ и az, плюс ПРОБЕЛ, цифры 0-9 и символы пунктуации, которые использует Perl, а также несколько элементов управления, которые обозначены escape-последовательностями, такими как &lt;code&gt;\n&lt;/code&gt; и &lt;code&gt;\t&lt;/code&gt; , тогда нет ничего особенного. об использовании Perl, и ваш код вполне может работать на ASCII-машине без изменений.</target>
        </trans-unit>
        <trans-unit id="8e9b4a996206aa3ecbfc36df229dca4fb6c7a7b5" translate="yes" xml:space="preserve">
          <source>If your code still needs to run on older versions, stick to &lt;code&gt;foreach&lt;/code&gt; for your topicalizer and you will be less unhappy.</source>
          <target state="translated">Если ваш код по-прежнему нужно запускать в более старых версиях, придерживайтесь &lt;code&gt;foreach&lt;/code&gt; для актуатора, и вы будете менее недовольны.</target>
        </trans-unit>
        <trans-unit id="dcc0823ff9797cfd85918a8c234e7eca9a51dc4f" translate="yes" xml:space="preserve">
          <source>If your command contains &lt;b&gt;special characters&lt;/b&gt; (&amp;lt; &amp;gt; | &amp;amp;), it will be internally stringified before executing the command, to avoid that these special characters are escaped and passed as arguments instead of retaining their special meaning.</source>
          <target state="translated">Если ваша команда содержит &lt;b&gt;специальные символы&lt;/b&gt; (&amp;lt;&amp;gt; | &amp;amp;), она будет внутренне преобразована в строку перед выполнением команды, чтобы избежать экранирования этих специальных символов и их передачи в качестве аргументов вместо сохранения их особого значения.</target>
        </trans-unit>
        <trans-unit id="cf42d5b15f10438a9ce2c86e1004158d46b18003" translate="yes" xml:space="preserve">
          <source>If your copy of Perl is recent enough to contain this documentation (version 5.002 or later), then the perl library (and</source>
          <target state="translated">Если ваша копия Perl достаточно свежая,чтобы содержать эту документацию (версия 5.002 или более поздняя),то библиотека perl (и</target>
        </trans-unit>
        <trans-unit id="2fc9b0cc9eec68d672ffff71ad1ff12aed25c2cc" translate="yes" xml:space="preserve">
          <source>If your encoding can work with PerlIO but needs line buffering, you MUST define this method so it returns true. 7bit ISO-2022 encodings are one example that needs this. When this method is missing, false is assumed.</source>
          <target state="translated">Если ваша кодировка может работать с PerlIO,но нуждается в буферизации строк,вы ДОЛЖНЫ определить этот метод,чтобы он вернул true.7-битные кодировки ISO-2022-один из примеров,когда это необходимо.Когда этот метод отсутствует,предполагается false.</target>
        </trans-unit>
        <trans-unit id="d924438284770c83006ec82d036605b95adc1613" translate="yes" xml:space="preserve">
          <source>If your encoding does not support PerlIO for some reasons, just;</source>
          <target state="translated">Если ваша кодировка по каким-то причинам не поддерживает PerlIO,просто..;</target>
        </trans-unit>
        <trans-unit id="1bb14712099b199ef0cd902ac0e502361e5d3ab8" translate="yes" xml:space="preserve">
          <source>If your executables start with something like #!perl or #!/usr/bin/perl MakeMaker will change this to the path of the perl 'Makefile.PL' was invoked with so the programs will be sure to run properly even if perl is not in /usr/bin/perl.</source>
          <target state="translated">Если ваши исполняемые файлы начинаются с чего-то вроде #!perl или #!/usr/bin/perl,MakeMaker изменит это на путь,по которому вызывался perl 'Makefile.PL',так что программы будут корректно запускаться,даже если perl не находится в /usr/bin/perl.</target>
        </trans-unit>
        <trans-unit id="0c644837e9e9bd2635823c6fa674e7d01fcd0f60" translate="yes" xml:space="preserve">
          <source>If your extension uses some features of Perl which are not available on older releases of Perl, your users would appreciate an early meaningful warning. You would probably put this information into the</source>
          <target state="translated">Если ваше расширение использует некоторые функции Perl,которые недоступны на старых версиях Perl,ваши пользователи будут благодарны за раннее содержательное предупреждение.Вы,вероятно,поместили бы эту информацию в</target>
        </trans-unit>
        <trans-unit id="adbe147193e70e68bb2371038fd445f29bb86c7b" translate="yes" xml:space="preserve">
          <source>If your function already returns a reference, you don't need to create the reference yourself.</source>
          <target state="translated">Если ваша функция уже возвращает ссылку,вам не нужно создавать ссылку самостоятельно.</target>
        </trans-unit>
        <trans-unit id="8e3814e00e4bd2f311a16402f4ba979bbd48ac96" translate="yes" xml:space="preserve">
          <source>If your gcc is configured to use GNU as and ld but you want to use the Solaris ones instead to build perl, then you'll need to add -B/usr/ccs/bin/ to the gcc command line. One convenient way to do that is with</source>
          <target state="translated">Если ваш gcc настроен на использование GNU как и ld,но вы хотите использовать Solaris для сборки perl,то вам нужно добавить -B/usr/ccs/bin/в командную строку gcc.Один из удобных способов сделать это</target>
        </trans-unit>
        <trans-unit id="5872fc905315842d011082a682a6367cfb7ca9e6" translate="yes" xml:space="preserve">
          <source>If your hash could have repeated values, the methods above will only find one of the associated keys. This may or may not worry you. If it does worry you, you can always reverse the hash into a hash of arrays instead:</source>
          <target state="translated">Если ваш хэш может иметь повторяющиеся значения,методы,описанные выше,найдут только один из связанных с ним ключей.Это может вас беспокоить,а может и не беспокоить.Если это действительно вас беспокоит,вы всегда можете превратить хэш в хэш массива:</target>
        </trans-unit>
        <trans-unit id="a7de42f17abf69fc8056c809db5d175a47bd9c23" translate="yes" xml:space="preserve">
          <source>If your input is binary, and is supposed to remain binary, you shouldn't decode it to a text string, of course. But in all other cases, you should decode it.</source>
          <target state="translated">Если ваш вход является двоичным и должен остаться двоичным,то,конечно,вы не должны декодировать его в текстовую строку.Но во всех остальных случаях,вы должны декодировать ее.</target>
        </trans-unit>
        <trans-unit id="d2667a072564b25eaaca13a334f7f9d262c4dc4d" translate="yes" xml:space="preserve">
          <source>If your lexicon is a tied hash the simple act of caching the compiled value can be fatal.</source>
          <target state="translated">Если ваш лексикон-связанный хэш,то простой акт кэширования скомпилированного значения может оказаться фатальным.</target>
        </trans-unit>
        <trans-unit id="84a874bfb13cfbdc7a992429f47c0892596ec6c2" translate="yes" xml:space="preserve">
          <source>If your locale environment variables (&lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_CTYPE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; ) contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching), the default encoding of your &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , and &lt;code&gt;STDERR&lt;/code&gt; , and of &lt;b&gt;any subsequent file open&lt;/b&gt;, is UTF-8.</source>
          <target state="translated">Если переменные среды вашей локали ( &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_CTYPE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; ) содержат строки 'UTF-8' или 'UTF8' (соответствие без учета регистра), кодировку по умолчанию для ваших &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; и &lt;code&gt;STDERR&lt;/code&gt; , а также &lt;b&gt;всех последующих открытых файлов&lt;/b&gt; , это UTF-8.</target>
        </trans-unit>
        <trans-unit id="6549b9662c9333f9038a43e101cb863214588ba8" translate="yes" xml:space="preserve">
          <source>If your locale is a UTF-8 locale, starting in Perl v5.20, Perl works well for all categories except &lt;code&gt;LC_COLLATE&lt;/code&gt; dealing with sorting and the &lt;code&gt;cmp&lt;/code&gt; operator.</source>
          <target state="translated">Если ваш языковой стандарт является локалью UTF-8, начиная с Perl v5.20, Perl хорошо работает для всех категорий, кроме &lt;code&gt;LC_COLLATE&lt;/code&gt; , относящегося к сортировке, и оператора &lt;code&gt;cmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3b150d3cc1b32cbef03e749b88c3f5c90012ceb" translate="yes" xml:space="preserve">
          <source>If your newly minted styles refer to any new #variables, you'll need to define a callback subroutine that will populate (or modify) those variables. They are then available for use in the style you've chosen.</source>
          <target state="translated">Если ваши новые отчеканенные стили относятся к любым новым #переменным,вам нужно определить подпрограмму обратного вызова,которая будет заполнять (или изменять)эти переменные.Затем они будут доступны для использования в выбранном вами стиле.</target>
        </trans-unit>
        <trans-unit id="db09b35e2a7d627ad25d25e5e66ae789bbe364b8" translate="yes" xml:space="preserve">
          <source>If your operating system supports a proper mv(1) utility or its functional equivalent, this works:</source>
          <target state="translated">Если ваша операционная система поддерживает соответствующую утилиту mv(1)или ее функциональный эквивалент,это работает:</target>
        </trans-unit>
        <trans-unit id="b728e9092f3f9368f8a8be6c5ce7886b0a62de25" translate="yes" xml:space="preserve">
          <source>If your patch changes code (rather than just changing documentation), you should also include one or more test cases which illustrate the bug you're fixing or validate the new functionality you're adding. In general, you should update an existing test file rather than create a new one.</source>
          <target state="translated">Если ваш патч изменяет код (а не просто изменяет документацию),вы также должны включить один или несколько тестовых примеров,которые иллюстрируют ошибку,которую вы исправляете,или подтверждают новую добавляемую вами функциональность.В общем случае,вам следует обновить существующий файл теста,а не создавать новый.</target>
        </trans-unit>
        <trans-unit id="78a3de11301e669e248cee7c9e70b2562ff6e9f5" translate="yes" xml:space="preserve">
          <source>If your perl does not support times larger than &lt;code&gt;2^31&lt;/code&gt; seconds then this module is likely to fail at processing dates beyond the year 2038. There are moves afoot to fix that in perl. Alternatively use 64 bit perl. Or if none of those are options, use the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module which has support for years well into the future and past.</source>
          <target state="translated">Если ваш Perl не поддерживает времена, превышающие &lt;code&gt;2^31&lt;/code&gt; секунду, то этот модуль, скорее всего, выйдет из строя при обработке дат после 2038 года. В Perl есть шаги, чтобы исправить это. В качестве альтернативы используйте 64-битный Perl. Или, если ни один из этих вариантов не подходит, используйте модуль &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime,&lt;/a&gt; который поддерживает многие годы в будущем и прошлом.</target>
        </trans-unit>
        <trans-unit id="b5f6d77f27ea6c645390efe18bf989b76fa95e9b" translate="yes" xml:space="preserve">
          <source>If your perl is compiled with &lt;code&gt;-DDEBUGGING&lt;/code&gt; , you may use the &lt;b&gt;-Dr&lt;/b&gt; flag on the command line.</source>
          <target state="translated">Если ваш perl скомпилирован с &lt;code&gt;-DDEBUGGING&lt;/code&gt; , вы можете использовать флаг &lt;b&gt;-Dr&lt;/b&gt; в командной строке.</target>
        </trans-unit>
        <trans-unit id="6fb3bbcc486c0ac676b28f725bda572e8ce7d210" translate="yes" xml:space="preserve">
          <source>If your perl is using Perl's malloc() and was compiled with the necessary switches (this is the default), then it will print memory usage statistics after compiling your code when &lt;code&gt;$ENV{PERL_DEBUG_MSTATS}
&amp;gt; 1&lt;/code&gt; , and before termination of the program when &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt;= 1&lt;/code&gt; . The report format is similar to the following example:</source>
          <target state="translated">Если ваш perl использует Perl malloc () и был скомпилирован с необходимыми переключателями (это значение по умолчанию), тогда он будет печатать статистику использования памяти после компиляции вашего кода, когда &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt; 1&lt;/code&gt; , и перед завершением программы, когда &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt;= 1&lt;/code&gt; . Формат отчета аналогичен следующему примеру:</target>
        </trans-unit>
        <trans-unit id="a0ec21abacef113106404f37c8ffeaf0991584f3" translate="yes" xml:space="preserve">
          <source>If your perl supports &lt;code&gt;PerlIO&lt;/code&gt; (which is the default), you can use a &lt;code&gt;PerlIO&lt;/code&gt; layer to decode and encode directly via a filehandle. The following two examples are fully identical in functionality:</source>
          <target state="translated">Если ваш Perl поддерживает &lt;code&gt;PerlIO&lt;/code&gt; (по умолчанию), вы можете использовать слой &lt;code&gt;PerlIO&lt;/code&gt; для декодирования и кодирования напрямую через дескриптор файла. Следующие два примера полностью идентичны по функциональности:</target>
        </trans-unit>
        <trans-unit id="091f7db96070043c9514e8ee2a91acbe99a23b27" translate="yes" xml:space="preserve">
          <source>If your rc file contains:</source>
          <target state="translated">Если ваш rc-файл содержит:</target>
        </trans-unit>
        <trans-unit id="1cc732c143d69a605c4a486fe1919dbc8511b3b7" translate="yes" xml:space="preserve">
          <source>If your routine iterates through some kind of list (such as a list of files, or records in a database) you may consider providing a callback so that users can manipulate each element of the list in turn. File::Find provides an example of this with its &lt;code&gt;find(\&amp;amp;wanted, $dir)&lt;/code&gt; syntax.</source>
          <target state="translated">Если ваша процедура перебирает какой-либо список (например, список файлов или записи в базе данных), вы можете рассмотреть возможность предоставления обратного вызова, чтобы пользователи могли по очереди манипулировать каждым элементом списка. File :: Find предоставляет пример этого с синтаксисом &lt;code&gt;find(\&amp;amp;wanted, $dir)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20d69711a4dff3eb5c2c54e4925f7a2d49b42d0e" translate="yes" xml:space="preserve">
          <source>If your script works with huge numbers and Calc is too slow for them, you can also for the loading of one of these libraries and if none of them can be used, the code will die:</source>
          <target state="translated">Если ваш скрипт работает с огромными числами,а Calc слишком медленный для них,вы можете также загрузить одну из этих библиотек,и если ни одна из них не может быть использована,то код погибнет:</target>
        </trans-unit>
        <trans-unit id="686d70af0d50a3bff3e29e104e2f82c37c794acd" translate="yes" xml:space="preserve">
          <source>If your stdio requires a seek or eof between reads and writes on a particular stream, so does Perl. (This doesn't apply to sysread() and syswrite().)</source>
          <target state="translated">Если ваш студио требует поиска или очков между чтением и записью на определенном потоке,то и Perl тоже.(Это не относится к функциям sysread()и syswrite().).</target>
        </trans-unit>
        <trans-unit id="34ff0a2e68bd649cc4624def7ce4b58902e2e24e" translate="yes" xml:space="preserve">
          <source>If your subsecond sleeping is implemented with &lt;code&gt;nanosleep()&lt;/code&gt; instead of &lt;code&gt;usleep()&lt;/code&gt; , you can mix subsecond sleeping with signals since &lt;code&gt;nanosleep()&lt;/code&gt; does not use signals. This, however, is not portable, and you should first check for the truth value of &lt;code&gt;&amp;amp;Time::HiRes::d_nanosleep&lt;/code&gt; to see whether you have nanosleep, and then carefully read your &lt;code&gt;nanosleep()&lt;/code&gt; C API documentation for any peculiarities.</source>
          <target state="translated">Если ваш субсекундный сон реализован с помощью &lt;code&gt;nanosleep()&lt;/code&gt; вместо &lt;code&gt;usleep()&lt;/code&gt; , вы можете смешивать субсекундный сон с сигналами, поскольку &lt;code&gt;nanosleep()&lt;/code&gt; не использует сигналы. Это, однако, не переносимо, и вы должны сначала проверить истинное значение &lt;code&gt;&amp;amp;Time::HiRes::d_nanosleep&lt;/code&gt; чтобы увидеть, есть ли у вас nanosleep, а затем внимательно прочитать документацию по API &lt;code&gt;nanosleep()&lt;/code&gt; C на предмет каких-либо особенностей.</target>
        </trans-unit>
        <trans-unit id="7033933f15e134ae512f052ac986d8b0ac72a9af" translate="yes" xml:space="preserve">
          <source>If your system doesn't support dynamic loading, you still probably ought to use &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;. See &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; and &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; for more information (in brief, just use &lt;b&gt;make perl&lt;/b&gt; instead of a plain &lt;b&gt;make&lt;/b&gt; to rebuild perl with a new static extension).</source>
          <target state="translated">Если ваша система не поддерживает динамическую загрузку, вам все равно, вероятно, следует использовать &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; . См. &lt;a href=&quot;perlxstut&quot;&gt;Perlxstut&lt;/a&gt; и &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt; для получения дополнительной информации (вкратце, просто используйте &lt;b&gt;make perl&lt;/b&gt; вместо простого &lt;b&gt;make&lt;/b&gt; для пересборки perl с новым статическим расширением).</target>
        </trans-unit>
        <trans-unit id="976a5d23704d8a7827f274e64a1b65ab7ed369e5" translate="yes" xml:space="preserve">
          <source>If your system has a strange pointer size--meaning a pointer is neither as big as an int nor as big as a long--it may not be possible to pack or unpack pointers in big- or little-endian byte order. Attempting to do so raises an exception.</source>
          <target state="translated">Если в вашей системе странный размер указателя,то есть указатель не настолько велик,как int,и не настолько велик,как long,то упаковать или распаковать указатели в большом или маленьком байтовом порядке невозможно.Попытка сделать это вызывает исключение.</target>
        </trans-unit>
        <trans-unit id="c8f634435d2540d4ac325a2965a4ae17a54489a6" translate="yes" xml:space="preserve">
          <source>If your system has the &lt;code&gt;sigaction()&lt;/code&gt; function then signal handlers are installed using it. This means you get reliable signal handling.</source>
          <target state="translated">Если в вашей системе есть &lt;code&gt;sigaction()&lt;/code&gt; то с ее помощью устанавливаются обработчики сигналов. Это означает, что вы получаете надежную обработку сигнала.</target>
        </trans-unit>
        <trans-unit id="fd4695d7aa352602cd4c4febe7f1355134b6280c" translate="yes" xml:space="preserve">
          <source>If your system lacks &lt;code&gt;gettimeofday()&lt;/code&gt; or an emulation of it you don't get &lt;code&gt;gettimeofday()&lt;/code&gt; or the one-argument form of &lt;code&gt;tv_interval()&lt;/code&gt; . If your system lacks all of &lt;code&gt;nanosleep()&lt;/code&gt; , &lt;code&gt;usleep()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;poll&lt;/code&gt; , you don't get &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; , or &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; . If your system lacks both &lt;code&gt;ualarm()&lt;/code&gt; and &lt;code&gt;setitimer()&lt;/code&gt; you don't get &lt;code&gt;Time::HiRes::ualarm()&lt;/code&gt; or &lt;code&gt;Time::HiRes::alarm()&lt;/code&gt; .</source>
          <target state="translated">Если в вашей системе отсутствует &lt;code&gt;gettimeofday()&lt;/code&gt; или ее эмуляция, вы не получите &lt;code&gt;gettimeofday()&lt;/code&gt; или форму с одним аргументом &lt;code&gt;tv_interval()&lt;/code&gt; . Если в вашей системе отсутствуют все функции &lt;code&gt;nanosleep()&lt;/code&gt; , &lt;code&gt;usleep()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;poll&lt;/code&gt; , вы не получите &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; или &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; . Если в вашей системе отсутствуют &lt;code&gt;ualarm()&lt;/code&gt; и &lt;code&gt;setitimer()&lt;/code&gt; вы не получите &lt;code&gt;Time::HiRes::ualarm()&lt;/code&gt; или &lt;code&gt;Time::HiRes::alarm()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3404e2a55faf84740517a5a0e24d39c3bdace4c" translate="yes" xml:space="preserve">
          <source>If your system supports dynamic loading, for reasons of portability and sanity you probably ought to use &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; (also part of the standard perl distribution). This tool converts C header files to Perl extensions. See &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; for how to get started with &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;.</source>
          <target state="translated">Если ваша система поддерживает динамическую загрузку, по причинам переносимости и разумности вам, вероятно, следует использовать &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; (также часть стандартного дистрибутива Perl). Этот инструмент преобразует файлы заголовков C в расширения Perl. См. &lt;a href=&quot;perlxstut&quot;&gt;Perlxstut,&lt;/a&gt; чтобы узнать, как начать работу с &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c32ad1b9a818a02634ef64d7fbd9495e5b9eebf0" translate="yes" xml:space="preserve">
          <source>If your system supports the portable operating system programming interface (POSIX), you can use the following code, which you'll note turns off echo processing as well.</source>
          <target state="translated">Если ваша система поддерживает интерфейс программирования портативной операционной системы (POSIX),вы можете использовать следующий код,который,как вы заметите,отключает также обработку эха.</target>
        </trans-unit>
        <trans-unit id="cf51a5f9f685e20ec9fa41065bc4bbf9f512757f" translate="yes" xml:space="preserve">
          <source>If z is a pure real number (i.e. &lt;code&gt;b == 0&lt;/code&gt; ), then the above yields:</source>
          <target state="translated">Если z - чистое действительное число (т.е. &lt;code&gt;b == 0&lt;/code&gt; ), то приведенное выше дает:</target>
        </trans-unit>
        <trans-unit id="866f3e73958b23adbe3e41bd3c02c8704cd81475" translate="yes" xml:space="preserve">
          <source>If, and only if, a token is a bailout token, you can get an &quot;explanation&quot; via this method. The explanation is the text after the mystical &quot;Bail out!&quot; words which appear in the tap output.</source>
          <target state="translated">Если и только если токен является спасительным,то с помощью этого метода можно получить &quot;объяснение&quot;.Объяснение-это текст после мистических слов &quot;Bail out!&quot;,которые появляются в тап-выходе.</target>
        </trans-unit>
        <trans-unit id="4f07d749cb3d9f280003a3874694f44dd0f9a196" translate="yes" xml:space="preserve">
          <source>If, at the end of a run you get the message</source>
          <target state="translated">Если в конце пробежки вы получите сообщение.</target>
        </trans-unit>
        <trans-unit id="748ad1a2344142dff26b49b0321a5e20db97e62e" translate="yes" xml:space="preserve">
          <source>If, for a given file, Perl is unable to create the backup file as specified in the extension then it will skip that file and continue on with the next one (if it exists).</source>
          <target state="translated">Если для данного файла Perl не может создать резервную копию,указанную в расширении,то он пропустит этот файл и продолжит работу со следующим (если он существует).</target>
        </trans-unit>
        <trans-unit id="3190be8312e8fef021a8d99a686331f02896c645" translate="yes" xml:space="preserve">
          <source>If, for some odd reason, you really want to see the whole file at once rather than processing line-by-line, you can slurp it in (as long as you can fit the whole thing in memory!):</source>
          <target state="translated">Если по какой-то странной причине вы действительно хотите видеть весь файл сразу,а не обрабатывать его построчно,вы можете втиснуть его в память (до тех пор,пока вы можете уместить все это в памяти!):</target>
        </trans-unit>
        <trans-unit id="8294d55294098cd1496efb3523c86ff173cf45ca" translate="yes" xml:space="preserve">
          <source>If, for some reason, you have a file descriptor instead of a filehandle (perhaps you used &lt;code&gt;POSIX::open&lt;/code&gt; ), you can use the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; function from the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module:</source>
          <target state="translated">Если по какой-то причине у вас есть дескриптор файла вместо дескриптора файла (возможно, вы использовали &lt;code&gt;POSIX::open&lt;/code&gt; ), вы можете использовать функцию &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; из модуля &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e7db8cc8d76b7ab2eda9890eb0170658ba11e9d0" translate="yes" xml:space="preserve">
          <source>If, surprisingly, the implementor of a Pod formatter can't find a satisfactory pre-existing table mapping from Unicode characters to escapes in the target format (e.g., a decent table of Unicode characters to *roff escapes), it will be necessary to build such a table. If you are in this circumstance, you should begin with the characters in the range 0x00A0 - 0x00FF, which is mostly the heavily used accented characters. Then proceed (as patience permits and fastidiousness compels) through the characters that the (X)HTML standards groups judged important enough to merit mnemonics for. These are declared in the (X)HTML specifications at the www.W3.org site. At time of writing (September 2001), the most recent entity declaration files are:</source>
          <target state="translated">Если,на удивление,реализующий Pod-форматер не сможет найти удовлетворительного предварительного отображения таблицы от символов Юникода к эскапетам в целевом формате (например,достойную таблицу символов Юникода к *рофф-эскапетам),то необходимо будет построить такую таблицу.Если вы находитесь в таком положении,то следует начать с символов в диапазоне 0x00A0-0x00FF,которые в основном являются сильно используемыми акцентированными символами.Затем продолжайте (как позволяет терпение и требовательность)через символы,которые группы стандартов (X)HTML посчитали достаточно важными,чтобы заслужить мнемонику.Они указаны в спецификациях (X)HTML на сайте www.W3.org.На момент написания настоящего документа (сентябрь 2001 г.)самыми последними файлами с декларациями субъектов являются файлы с декларациями субъектов:</target>
        </trans-unit>
        <trans-unit id="3906f56da4298c4e536de3ebef7105b8dabd75e9" translate="yes" xml:space="preserve">
          <source>Ignore &lt;code&gt;dSP&lt;/code&gt; and &lt;code&gt;PUSHMARK(SP)&lt;/code&gt; for now. They will be discussed in the next example.</source>
          <target state="translated">Игнорировать &lt;code&gt;dSP&lt;/code&gt; и &lt;code&gt;PUSHMARK(SP)&lt;/code&gt; на данный момент. Они будут рассмотрены в следующем примере.</target>
        </trans-unit>
        <trans-unit id="51be86b7131a2f6dd784631a551ad5a124bca532" translate="yes" xml:space="preserve">
          <source>Ignore ASCII vs. EBCDIC sort differences.</source>
          <target state="translated">Игнорируйте различия в сортировке ASCII и EBCDIC.</target>
        </trans-unit>
        <trans-unit id="be1854061543f14642d8f6508b59d601baedc0d4" translate="yes" xml:space="preserve">
          <source>Ignore case.</source>
          <target state="translated">Не обращай внимания.</target>
        </trans-unit>
        <trans-unit id="2e352eadd6b1808d1d1be87c9129c2b0edb3ffba" translate="yes" xml:space="preserve">
          <source>Ignore the message about missing &lt;code&gt;ln&lt;/code&gt; , and about &lt;code&gt;-c&lt;/code&gt; option to tr</source>
          <target state="translated">Игнорируйте сообщение об отсутствии &lt;code&gt;ln&lt;/code&gt; и опции &lt;code&gt;-c&lt;/code&gt; для tr</target>
        </trans-unit>
        <trans-unit id="28a9d1669608fdb03cba836ec390fdcfb1aebfee" translate="yes" xml:space="preserve">
          <source>Ignore the warning.</source>
          <target state="translated">Не обращай внимания на предупреждение.</target>
        </trans-unit>
        <trans-unit id="2789be88625c10d2c36088f497ee1c896ef071b5" translate="yes" xml:space="preserve">
          <source>Ignore them: in IRIX 5.3 there is no way to quieten ld about this.</source>
          <target state="translated">Игнорируйте их:в IRIX 5.3 нет способа заставить замолчать об этом.</target>
        </trans-unit>
        <trans-unit id="2b4603ab54eaf129f7b585f0908e9724e9831b25" translate="yes" xml:space="preserve">
          <source>Ignores any arguments and returns a new &lt;code&gt;TAP::Parser::Scheduler::Spinner&lt;/code&gt; object.</source>
          <target state="translated">Игнорирует любые аргументы и возвращает новый объект &lt;code&gt;TAP::Parser::Scheduler::Spinner&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="870e1aa14cd979f7f1df9488b978998300179625" translate="yes" xml:space="preserve">
          <source>Ignoring A Thread</source>
          <target state="translated">игнорирование нити</target>
        </trans-unit>
        <trans-unit id="817c7ffeee7200e3277cebf23a0b3dcda06d9829" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &amp;lt;</source>
          <target state="translated">Илья Захаревич &amp;lt;</target>
        </trans-unit>
        <trans-unit id="91b2e058cf65f0cabffee0e92051934b87d3bc3b" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich (ilya@math.ohio-state.edu)</source>
          <target state="translated">Илья Захаревич (ilya@math.ohio-state.edu)</target>
        </trans-unit>
        <trans-unit id="031c817d16973027b8790762eb4b0c35cafca1e9" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &lt;a href=&quot;mailto:ilyaz@cpan.org&quot;&gt;mailto:ilyaz@cpan.org&lt;/a&gt;.</source>
          <target state="translated">Илья Захаревич &lt;a href=&quot;mailto:ilyaz@cpan.org&quot;&gt;mailto: ilyaz@cpan.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="afff5ba88102f80e4aa07d73498f8952aca29188" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &lt;a href=&quot;mailto:perl-module-hash-memoize@ilyaz.org&quot;&gt;mailto:perl-module-hash-memoize@ilyaz.org&lt;/a&gt;.</source>
          <target state="translated">Илья Захаревич &lt;a href=&quot;mailto:perl-module-hash-memoize@ilyaz.org&quot;&gt;mailto: perl-module-hash-memoize@ilyaz.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4248a84d563fa7da7c5bae89f2669c77f908cab3" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt;</source>
          <target state="translated">Илья Захаревич &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33d5a3e7b454b4e36eb89767df3980ae73e9890b" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich ilya@math.ohio-state.edu</source>
          <target state="translated">Илья Захаревич ilya@math.ohio-state.edu</target>
        </trans-unit>
        <trans-unit id="0182df78996d3eb0a76431c398a0f49f0059b1f4" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich originally extracted &lt;code&gt;XSLoader&lt;/code&gt; from &lt;code&gt;DynaLoader&lt;/code&gt; .</source>
          <target state="translated">Илья Захаревич изначально извлек &lt;code&gt;XSLoader&lt;/code&gt; из &lt;code&gt;DynaLoader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b5ae6dbba6c0391c239461a326224f80e808d8a" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich, cpan@ilyaz.org</source>
          <target state="translated">Илья Захаревич,cpan@ilyaz.org.</target>
        </trans-unit>
        <trans-unit id="f84c916319b1f129948f110816b58ce5079819de" translate="yes" xml:space="preserve">
          <source>Images, Pixmap and Bitmap Manipulation, Drawing, and Graphing</source>
          <target state="translated">Изображения,растровые и растровые манипуляции,рисование и графическое изображение</target>
        </trans-unit>
        <trans-unit id="6a42b9040934c9280685a56f5dc127e9e6ee5b8d" translate="yes" xml:space="preserve">
          <source>Imagine that the here-doc end marker is at the beginning of the line. Now you can use &lt;code&gt;\p{InKana}&lt;/code&gt; and &lt;code&gt;\P{InKana}&lt;/code&gt; .</source>
          <target state="translated">Представьте, что маркер конца документа находится в начале строки. Теперь вы можете использовать &lt;code&gt;\p{InKana}&lt;/code&gt; и &lt;code&gt;\P{InKana}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fae6fb5571f38013c7696bd62a49c387d5a5d68" translate="yes" xml:space="preserve">
          <source>Immediate Filters</source>
          <target state="translated">Срочные фильтры</target>
        </trans-unit>
        <trans-unit id="8a696df97fa48af3310dcba0d55250b2371b7422" translate="yes" xml:space="preserve">
          <source>Immediate filters are useful for one-off situations. For more generic problems it can be useful to package the filter up in its own module.</source>
          <target state="translated">Немедленные фильтры полезны в разовых ситуациях.Для более общих проблем может быть полезно упаковать фильтр в собственный модуль.</target>
        </trans-unit>
        <trans-unit id="42b04d9e2ede4faefd5e97013f894508883e5ac4" translate="yes" xml:space="preserve">
          <source>Immediately after the check routine is called the returned node is checked for being compile-time executable. If it is (the value is judged to be constant) it is immediately executed, and a</source>
          <target state="translated">Сразу после вызова процедуры проверки возвращаемый узел проверяется на компилируемость.Если это так (значение считается постоянным),то оно сразу же выполняется,и a</target>
        </trans-unit>
        <trans-unit id="5d2ecc7281cc6015d762f885a1871742572e70d2" translate="yes" xml:space="preserve">
          <source>Immediately after the filter has been applied to the source, Filter::Simple will pass control to Exporter, so it can do its magic too.</source>
          <target state="translated">Сразу же после применения фильтра к источнику,фильтр::Simple передаст управление экспортеру,так что он может сделать свою магию тоже.</target>
        </trans-unit>
        <trans-unit id="10353737d8f43f937641dff0028a206109a7686a" translate="yes" xml:space="preserve">
          <source>Implementation can adjust its idea of number of bytes in the buffer. Do not use this - use PerlIO_fast_gets.</source>
          <target state="translated">Реализация может скорректировать свое представление о количестве байт в буфере.Не используйте это-используйте PerlIO_fast_gets.</target>
        </trans-unit>
        <trans-unit id="2c98a52672a4f466f688e44c536060b9826553e9" translate="yes" xml:space="preserve">
          <source>Implementation can return pointer to current position in the &quot;buffer&quot; and a count of bytes available in the buffer. Do not use this - use PerlIO_fast_gets.</source>
          <target state="translated">Реализация может возвращать указатель на текущую позицию в &quot;буфере&quot; и счетчик доступных в буфере байт.Не использовать-использовать PerlIO_fast_gets.</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">Детали внедрения</target>
        </trans-unit>
        <trans-unit id="867f93d010e1413848b9511b5f08d11efe452a94" translate="yes" xml:space="preserve">
          <source>Implementation of sv_copypv and sv_copypv_nomg. Calls get magic iff flags include SV_GMAGIC.</source>
          <target state="translated">Реализация sv_copypv и sv_copypv_nomg.Вызовы получают волшебные iff-флаги,в том числе SV_GMAGIC.</target>
        </trans-unit>
        <trans-unit id="93a44ec01f30940976c8468009fd696e0d07c0cd" translate="yes" xml:space="preserve">
          <source>Implementations of mktemp(), tmpnam(), and tempnam() are provided, but should be used with caution since they return only a filename that was valid when function was called, so cannot guarantee that the file will not exist by the time the caller opens the filename.</source>
          <target state="translated">Введение mktemp(),tmpnam()и tempnam()предусмотрено,но должно использоваться с осторожностью,так как они возвращают только имя файла,которое было действительным при вызове функции,поэтому не могут гарантировать,что файл не будет существовать к моменту,когда вызывающий абонент откроет имя файла.</target>
        </trans-unit>
        <trans-unit id="472357ef916af9461389e46cdf6fcf7419adc52b" translate="yes" xml:space="preserve">
          <source>Implementations should detect the error as soon as it occurs in any of the other functions and save the corresponding message for later retrieval. This will avoid problems on some platforms (such as SunOS) where the error message is very temporary (e.g., dlerror()).</source>
          <target state="translated">Введение должно выявить ошибку,как только она возникает в любой из других функций,и сохранить соответствующее сообщение для последующего извлечения.Это позволит избежать проблем на некоторых платформах (таких как SunOS),где сообщение об ошибке является очень временным (например,dlerror()).</target>
        </trans-unit>
        <trans-unit id="7772f795eb98ffae1df16f5f22b8f9f0482251d7" translate="yes" xml:space="preserve">
          <source>Implemented on 64 bit VMS 8.3. VMS requires the symbolic link to be in Unix syntax if it is intended to resolve to a valid path.</source>
          <target state="translated">Реализовано на 64-битной VMS 8.3.VMS требует,чтобы символьная ссылка была в синтаксисе Unix,если она предназначена для преобразования в правильный путь.</target>
        </trans-unit>
        <trans-unit id="5c327b5ffaa641fc9ab42ad686d92c062f812101" translate="yes" xml:space="preserve">
          <source>Implementing PerlIO Layers</source>
          <target state="translated">Внедрение слоев PerlIO</target>
        </trans-unit>
        <trans-unit id="d1d235ff6e6c8fe294165e40ee8fb7af96b238c6" translate="yes" xml:space="preserve">
          <source>Implements a customized option parser used for &lt;a href=&quot;../perldoc&quot;&gt;Pod::Perldoc&lt;/a&gt;.</source>
          <target state="translated">Реализует настраиваемый синтаксический анализатор параметров, используемый для &lt;a href=&quot;../perldoc&quot;&gt;Pod :: Perldoc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b6d8e1ab41db2682597810f350ac0e642396e48" translate="yes" xml:space="preserve">
          <source>Implements default import method for modules</source>
          <target state="translated">Вводит метод импорта по умолчанию для модулей</target>
        </trans-unit>
        <trans-unit id="600b4d0a91fb59ceef4048c760197d5c6d1f4db1" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">Реализует команду &lt;code&gt;prove&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="500351adb27caa795501b65867b0b58aab9da04f" translate="yes" xml:space="preserve">
          <source>Implements the fcntl(2) function. You'll probably have to say</source>
          <target state="translated">Вводит функцию fcntl(2).Вероятно,вам придется сказать.</target>
        </trans-unit>
        <trans-unit id="345a4b053fd3ba6ba91b9b4a311d01970f38b745" translate="yes" xml:space="preserve">
          <source>Implements the ioctl(2) function. You'll probably first have to say</source>
          <target state="translated">Вводит функцию ioctl(2).Наверное,сначала вы должны сказать.</target>
        </trans-unit>
        <trans-unit id="a755dd53c48e0431df0fb3c83a53268941625f80" translate="yes" xml:space="preserve">
          <source>Implicit context</source>
          <target state="translated">Неявный контекст</target>
        </trans-unit>
        <trans-unit id="690e1538d5a86cb3fc7e71c1d7249c0d6e3e0181" translate="yes" xml:space="preserve">
          <source>Import all symbolic constants. Same as doing this</source>
          <target state="translated">Импортируйте все символические константы.То же самое,что и это.</target>
        </trans-unit>
        <trans-unit id="f641b0147eed755158e9f661a30e441db68a2b9a" translate="yes" xml:space="preserve">
          <source>Important Caveats</source>
          <target state="translated">Важные пещеры</target>
        </trans-unit>
        <trans-unit id="49b3bb070775e7c46535f7d9ea2b7446b904f0e4" translate="yes" xml:space="preserve">
          <source>Important platform-specific changes</source>
          <target state="translated">Важные изменения на платформе</target>
        </trans-unit>
        <trans-unit id="90ab5ed3bb3e27748d586ad9b9b11e2ab9efaaf8" translate="yes" xml:space="preserve">
          <source>Importing</source>
          <target state="translated">Importing</target>
        </trans-unit>
        <trans-unit id="a56aac727c58f5874136fceda15607b87290a37d" translate="yes" xml:space="preserve">
          <source>Importing a particular constant may not be very portable, because the import will fail on platforms that do not have that constant. A more portable way to set &lt;code&gt;$!&lt;/code&gt; to a valid value is to use:</source>
          <target state="translated">Импорт конкретной константы может быть не очень переносимым, потому что импорт не удастся на платформах, которые не имеют этой константы. Более удобный способ установить &lt;code&gt;$!&lt;/code&gt; к действительному значению следует использовать:</target>
        </trans-unit>
        <trans-unit id="d4eab83913c9890e5e3e1ea6b76a702ac39df78f" translate="yes" xml:space="preserve">
          <source>Importing this module causes the subroutine color in Test::Builder::Tester to be called with a true value causing colour highlighting to be turned on in debug output.</source>
          <target state="translated">Импорт этого модуля приводит к тому,что цвет подпрограмм в Test::Builder::Tester вызывается с истинным значением,что приводит к включению подсветки цвета в отладочном выводе.</target>
        </trans-unit>
        <trans-unit id="b94be8f7a2bde6a23ee55b54ee8fc9eb76bd786e" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;anyinflate&lt;/code&gt; and &lt;code&gt;$AnyInflateError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">Импортирует &lt;code&gt;anyinflate&lt;/code&gt; и &lt;code&gt;$AnyInflateError&lt;/code&gt; . То же, что и это</target>
        </trans-unit>
        <trans-unit id="a47d4827ba5d67c837818053a8d62f3b22e590b8" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;anyuncompress&lt;/code&gt; and &lt;code&gt;$AnyUncompressError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">Импортирует &lt;code&gt;anyuncompress&lt;/code&gt; и &lt;code&gt;$AnyUncompressError&lt;/code&gt; . То же, что и это</target>
        </trans-unit>
        <trans-unit id="95b77142aa14b6211216f5a16e3e213d0c392505" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;bunzip2&lt;/code&gt; and &lt;code&gt;$Bunzip2Error&lt;/code&gt; . Same as doing this</source>
          <target state="translated">Импортирует &lt;code&gt;bunzip2&lt;/code&gt; и &lt;code&gt;$Bunzip2Error&lt;/code&gt; . То же, что и это</target>
        </trans-unit>
        <trans-unit id="611c05e07552b8091c699fb7c8b34e627de5035f" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;bzip2&lt;/code&gt; and &lt;code&gt;$Bzip2Error&lt;/code&gt; . Same as doing this</source>
          <target state="translated">Импортирует &lt;code&gt;bzip2&lt;/code&gt; и &lt;code&gt;$Bzip2Error&lt;/code&gt; . То же, что и это</target>
        </trans-unit>
        <trans-unit id="0f1d5114934adc139dbbd5be66e7aa4d256c7031" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;deflate&lt;/code&gt; , &lt;code&gt;$DeflateError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; . Same as doing this</source>
          <target state="translated">Импортирует &lt;code&gt;deflate&lt;/code&gt; , &lt;code&gt;$DeflateError&lt;/code&gt; и все символьные константы, которые могут использоваться &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; . То же, что и это</target>
        </trans-unit>
        <trans-unit id="c0b3cbf51bdd7f4f367077b86b68d9bc7e23e42e" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;gunzip&lt;/code&gt; and &lt;code&gt;$GunzipError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">Импортирует &lt;code&gt;gunzip&lt;/code&gt; и &lt;code&gt;$GunzipError&lt;/code&gt; . То же, что и это</target>
        </trans-unit>
        <trans-unit id="d34135d0717f9ce2e7a0257450b1f62fae7932dc" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;$GzipError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; . Same as doing this</source>
          <target state="translated">Импортирует &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;$GzipError&lt;/code&gt; и все символьные константы, которые могут использоваться &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; . То же, что и это</target>
        </trans-unit>
        <trans-unit id="115a4b04735017c59cebd861430122e98ed196f8" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;inflate&lt;/code&gt; and &lt;code&gt;$InflateError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">Импорт &lt;code&gt;inflate&lt;/code&gt; и &lt;code&gt;$InflateError&lt;/code&gt; . То же, что и это</target>
        </trans-unit>
        <trans-unit id="1ee8ff5937f6a57c492292c874195f1b43a7fe78" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;rawdeflate&lt;/code&gt; , &lt;code&gt;$RawDeflateError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; . Same as doing this</source>
          <target state="translated">Импортирует &lt;code&gt;rawdeflate&lt;/code&gt; , &lt;code&gt;$RawDeflateError&lt;/code&gt; и все символьные константы, которые могут использоваться &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; . То же, что и это</target>
        </trans-unit>
        <trans-unit id="e767570633f5f871775c917a3828a5e9681f4ffd" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;rawinflate&lt;/code&gt; and &lt;code&gt;$RawInflateError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">Импортирует &lt;code&gt;rawinflate&lt;/code&gt; и &lt;code&gt;$RawInflateError&lt;/code&gt; . То же, что и это</target>
        </trans-unit>
        <trans-unit id="fce5310acfbe49b368b9871554a40ed6e277e8c4" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;unzip&lt;/code&gt; and &lt;code&gt;$UnzipError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">Импортирует &lt;code&gt;unzip&lt;/code&gt; и &lt;code&gt;$UnzipError&lt;/code&gt; . То же, что и это</target>
        </trans-unit>
        <trans-unit id="1c2f9178eea45bfd7d471760d92c394f1bace450" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;zip&lt;/code&gt; , &lt;code&gt;$ZipError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; . Same as doing this</source>
          <target state="translated">Импортирует &lt;code&gt;zip&lt;/code&gt; , &lt;code&gt;$ZipError&lt;/code&gt; и все символьные константы, которые могут использоваться &lt;code&gt;IO::Compress::Zip&lt;/code&gt; . То же, что и это</target>
        </trans-unit>
        <trans-unit id="2699b28db29be60d4c03ef4c15f7b6c27c20980d" translate="yes" xml:space="preserve">
          <source>Imports all the functions.</source>
          <target state="translated">Импортирует все функции.</target>
        </trans-unit>
        <trans-unit id="4e34e9af4ba46ea0c9c8bc6002dd0b4972427661" translate="yes" xml:space="preserve">
          <source>Imports some semantics into the current package from the named module, generally by aliasing certain subroutine or variable names into your package. It is exactly equivalent to</source>
          <target state="translated">Импортирует некоторую семантику в текущий пакет из модуля с именем,как правило,с помощью наложения псевдонимов на определенные имена подпрограмм или переменных в вашем пакете.Это в точности эквивалентно</target>
        </trans-unit>
        <trans-unit id="3c2be47729bab4d065b481df08ff204f1f40d914" translate="yes" xml:space="preserve">
          <source>Imports the selected functions.</source>
          <target state="translated">Импорт выбранных функций.</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="e283b44852c55b8cc7c5d3c10f2fb1158a34c408" translate="yes" xml:space="preserve">
          <source>In 5.000 to 5.003 perls, trigonometry was done in the &lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt; module. With 5.004, the &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt; module (part of the standard Perl distribution) implements the trigonometric functions. Internally it uses the &lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt; module and some functions can break out from the real axis into the complex plane, for example the inverse sine of 2.</source>
          <target state="translated">В версиях от 5.000 до 5.003 perls тригонометрия выполнялась в модуле &lt;a href=&quot;math/complex&quot;&gt;Math :: Complex&lt;/a&gt; . В версии 5.004 модуль &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; (часть стандартного дистрибутива Perl) реализует тригонометрические функции. Внутри он использует модуль &lt;a href=&quot;math/complex&quot;&gt;Math :: Complex,&lt;/a&gt; и некоторые функции могут выходить из действительной оси в комплексную плоскость, например, обратный синус 2.</target>
        </trans-unit>
        <trans-unit id="608cccc0c9bbe325204a599a0810ba75fef50b66" translate="yes" xml:space="preserve">
          <source>In 5.9.3, Newx() and friends replace the older New() API, and drops the first parameter,</source>
          <target state="translated">В 5.9.3,Newx()и друзья заменяют старый API New(),и опускают первый параметр,</target>
        </trans-unit>
        <trans-unit id="05edeadfa5f882c58e75733f9ca5c3ffa7b75300" translate="yes" xml:space="preserve">
          <source>In 5.9.3, newSV() replaces the older NEWSV() API, and drops the first parameter,</source>
          <target state="translated">В версии 5.9.3 newSV()заменяет старый API NEWSV()и сбрасывает первый параметр,</target>
        </trans-unit>
        <trans-unit id="a0bd3ec2d46f47a7c53bb5eb7fb75ed665e3e0d8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#EXAMPLE-4&quot;&gt;EXAMPLE 4&lt;/a&gt; the second part of .xs file contained the following description of an XSUB:</source>
          <target state="translated">В &lt;a href=&quot;#EXAMPLE-4&quot;&gt;ПРИМЕРЕ 4&lt;/a&gt; вторая часть файла .xs содержала следующее описание XSUB:</target>
        </trans-unit>
        <trans-unit id="f10507678ddeb0946365b72294700c17d41e824f" translate="yes" xml:space="preserve">
          <source>In &lt;b&gt;Use Rule 1&lt;/b&gt;, you can omit the curly brackets whenever the thing inside them is an atomic scalar variable like &lt;code&gt;$aref&lt;/code&gt; . For example, &lt;code&gt;@$aref&lt;/code&gt; is the same as &lt;code&gt;@{$aref}&lt;/code&gt; , and &lt;code&gt;$$aref[1]&lt;/code&gt; is the same as &lt;code&gt;${$aref}[1]&lt;/code&gt; . If you're just starting out, you may want to adopt the habit of always including the curly brackets.</source>
          <target state="translated">В &lt;b&gt;Правиле использования 1&lt;/b&gt; вы можете опустить фигурные скобки, если внутри них находится атомарная скалярная переменная, например &lt;code&gt;$aref&lt;/code&gt; . Например, &lt;code&gt;@$aref&lt;/code&gt; совпадает с &lt;code&gt;@{$aref}&lt;/code&gt; , а &lt;code&gt;$$aref[1]&lt;/code&gt; совпадает с &lt;code&gt;${$aref}[1]&lt;/code&gt; . Если вы только начинаете, вы можете принять привычку всегда включать фигурные скобки.</target>
        </trans-unit>
        <trans-unit id="557547e0e5d90bb8da914cf09cde8cf85870da5a" translate="yes" xml:space="preserve">
          <source>In &lt;b&gt;shell&lt;/b&gt; programming, the syntactic combination of a program name and its arguments. More loosely, anything you type to a shell (a command interpreter) that starts it doing something. Even more loosely, a Perl &lt;b&gt;statement&lt;/b&gt;, which might start with a &lt;b&gt;label&lt;/b&gt; and typically ends with a semicolon.</source>
          <target state="translated">В программировании &lt;b&gt;оболочки&lt;/b&gt; - синтаксическая комбинация имени программы и ее аргументов. Точнее, все, что вы вводите в оболочку (командный интерпретатор), которая запускает ее что-то. Еще более свободно - &lt;b&gt;оператор&lt;/b&gt; Perl , который может начинаться с &lt;b&gt;метки&lt;/b&gt; и обычно заканчивается точкой с запятой.</target>
        </trans-unit>
        <trans-unit id="893925583fca341ee58483bd99d5162198b9d0c6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;(?...)&lt;/code&gt; both absolute and relative backreferences may be used. The entire pattern can be reinserted with &lt;code&gt;(?R)&lt;/code&gt; or &lt;code&gt;(?0)&lt;/code&gt;. If you prefer to name your groups, you can use &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; to recurse into that group.</source>
          <target state="translated">В &lt;code&gt;(?...)&lt;/code&gt; могут использоваться как абсолютные, так и относительные обратные ссылки. Весь узор можно повторно вставить с помощью &lt;code&gt;(?R)&lt;/code&gt; или &lt;code&gt;(?0)&lt;/code&gt; . Если вы предпочитаете давать своим группам имена, вы можете использовать &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; Name ) для рекурсии в эту группу.</target>
        </trans-unit>
        <trans-unit id="38fa69a28fd92dcbb1d20c664855898c29a90ccb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; or its inline equivalent &lt;code&gt;\Q&lt;/code&gt; .</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; или его эквивалент инлайн &lt;code&gt;\Q&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1fe5fe4877107e3688ff937058cd386854f2587" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Compress::Zlib&lt;/code&gt; version 1.x, &lt;code&gt;gzopen&lt;/code&gt; used the zlib library to open the underlying file. This made things especially tricky when a Perl filehandle was passed to &lt;code&gt;gzopen&lt;/code&gt; . Behind the scenes the numeric C file descriptor had to be extracted from the Perl filehandle and this passed to the zlib library.</source>
          <target state="translated">В &lt;code&gt;Compress::Zlib&lt;/code&gt; версии 1.x &lt;code&gt;gzopen&lt;/code&gt; использовал библиотеку zlib для открытия базового файла. Это особенно &lt;code&gt;gzopen&lt;/code&gt; когда дескриптор файла Perl передавался в gzopen . За кулисами числовой дескриптор файла C должен был быть извлечен из дескриптора файла Perl и передан в библиотеку zlib.</target>
        </trans-unit>
        <trans-unit id="bccc4f78696454721af791a75896e8b3d0106582" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Compress::Zlib&lt;/code&gt; version 2.x, the &lt;code&gt;gzopen&lt;/code&gt; interface has been completely rewritten to use the &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; for writing gzip files and &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt; for reading gzip files. None of the limitations mentioned above apply.</source>
          <target state="translated">В &lt;code&gt;Compress::Zlib&lt;/code&gt; версии 2.x интерфейс &lt;code&gt;gzopen&lt;/code&gt; был полностью переписан, чтобы использовать &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO :: Compress :: Gzip&lt;/a&gt; для записи файлов gzip и &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO :: Uncompress :: Gunzip&lt;/a&gt; для чтения файлов gzip. Ни одно из упомянутых выше ограничений не применяется.</target>
        </trans-unit>
        <trans-unit id="e00aec70e3db954ff900ae2d1de9b4a90ac0844b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Encode&lt;/code&gt; 2.10 or later, &lt;code&gt;LEAVE_SRC&lt;/code&gt; is also implied.</source>
          <target state="translated">В &lt;code&gt;Encode&lt;/code&gt; 2.10 или &lt;code&gt;LEAVE_SRC&lt;/code&gt; также подразумевается LEAVE_SRC .</target>
        </trans-unit>
        <trans-unit id="51676bb8ef9795bee4bcbafed10516b2d6301ddf" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;native floating point --&amp;gt; native integer&lt;/code&gt; conversions the magnitude of the result is less than or equal to the magnitude of the source. (</source>
          <target state="translated">В &lt;code&gt;native floating point --&amp;gt; native integer&lt;/code&gt; преобразованиях чисел с плавающей запятой в собственные целые числа величина результата меньше или равна величине источника. (</target>
        </trans-unit>
        <trans-unit id="67145b5258ab605d487808bb8f38203833e35128" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;simple_replace&lt;/code&gt; we used the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; modifier to replace all occurrences of the regexp on each line. (Even though the regular expression appears in a loop, Perl is smart enough to compile it only once.) As with &lt;code&gt;simple_grep&lt;/code&gt; , both the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/$regexp/$replacement/g&lt;/a&gt;&lt;/code&gt; use &lt;code&gt;$_&lt;/code&gt; implicitly.</source>
          <target state="translated">В &lt;code&gt;simple_replace&lt;/code&gt; мы использовали модификатор &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; для замены всех вхождений регулярного выражения в каждой строке. (Даже несмотря на то, что регулярное выражение появляется в цикле, Perl достаточно умен, чтобы скомпилировать его только один раз.) Как и в случае с &lt;code&gt;simple_grep&lt;/code&gt; , как &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ,так и &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/$regexp/$replacement/g&lt;/a&gt;&lt;/code&gt; неявно используют &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d077e5ff0102748fbe2d5e45a0e1e202f0802167" translate="yes" xml:space="preserve">
          <source>In AIX 4.2 Perl extensions that use C++ functions that use statics may have problems in that the statics are not getting initialized. In newer AIX releases this has been solved by linking Perl with the libC_r library, but unfortunately in AIX 4.2 the said library has an obscure bug where the various functions related to time (such as time() and gettimeofday()) return broken values, and therefore in AIX 4.2 Perl is not linked against the libC_r.</source>
          <target state="translated">В AIX 4.2 расширения Perl,использующие функции C++,использующие статические поправки,могут иметь проблемы с тем,что статические поправки не инициализируются.В новых релизах AIX это было решено путем связывания Perl с библиотекой libC_r,но,к сожалению,в AIX 4.2 указанная библиотека имеет непонятную ошибку,когда различные функции,связанные со временем (такие как time()и gettimeofday()),возвращают нарушенные значения,и,следовательно,в AIX 4.2 Perl не связан с libC_r.</target>
        </trans-unit>
        <trans-unit id="5c64677f24dcacb245231383a983d4852fe14280" translate="yes" xml:space="preserve">
          <source>In BigInt, all numbers except &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; are integers.</source>
          <target state="translated">В BigInt все числа, кроме &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; и &lt;code&gt;-inf&lt;/code&gt; , являются целыми.</target>
        </trans-unit>
        <trans-unit id="f83bdc44eedb56878bfa30e1ea8c050d2167ca73" translate="yes" xml:space="preserve">
          <source>In BigInt, unless upgrading is in effect, the result is truncated to an integer.</source>
          <target state="translated">В BigInt,если не происходит обновление,результат усекается до целого числа.</target>
        </trans-unit>
        <trans-unit id="a6200922eb25a34272b79346b2b9f5be87e701ac" translate="yes" xml:space="preserve">
          <source>In CVS and RCS version 1.9 is followed by 1.10. Since CPAN compares version numbers numerically we use a sprintf() to convert 1.9 to 1.009 and 1.10 to 1.010 which compare properly.</source>
          <target state="translated">В CVS и RCS версии 1.9 за ней следует 1.10.Так как CPAN сравнивает номера версий в числовом выражении,мы используем функцию sprintf()для преобразования 1.9 в 1.009 и 1.10 в 1.010,которые корректно сравнивают.</target>
        </trans-unit>
        <trans-unit id="e6d98db49c1b068959bb3c31358e246a1630b67a" translate="yes" xml:space="preserve">
          <source>In CVS, RCS and SVN you use $Revision$ (see the documentation of your version control system for details). Every time the file is checked in the $Revision$ will be updated, updating your $VERSION.</source>
          <target state="translated">В CVS,RCS и SVN Вы используете $Revision$ (подробнее см.документацию по Вашей системе управления версиями).Каждый раз,когда файл проверяется в $Revision$,он обновляется,обновляя Вашу $VERSION.</target>
        </trans-unit>
        <trans-unit id="562c80499b9073a3905b98e95f6a9c71ca119547" translate="yes" xml:space="preserve">
          <source>In Cray UNICOS there is some strange numerical instability that results in root(), cos(), sin(), cosh(), sinh(), losing accuracy fast. Beware. The bug may be in UNICOS math libs, in UNICOS C compiler, in Math::Complex. Whatever it is, it does not manifest itself anywhere else where Perl runs.</source>
          <target state="translated">В Cray UNICOS есть некоторая странная числовая нестабильность,которая приводит к тому,что корень(),cos(),sin(),cosh(),sinh()быстро теряют точность.Будьте осторожны.Ошибка может быть в математических библиотеках UNICOS,в компиляторе UNICOS C,в Math::Complex.Что бы это ни было,оно не проявляется нигде,где запущен Perl.</target>
        </trans-unit>
        <trans-unit id="c2148313df160c8d66540765266d0deaea355ab2" translate="yes" xml:space="preserve">
          <source>In DUCET v4.0.0, primary weight of &lt;code&gt;C&lt;/code&gt; is &lt;code&gt;0E60&lt;/code&gt; and that of &lt;code&gt;D&lt;/code&gt; is &lt;code&gt;0E6D&lt;/code&gt; . So setting primary weight of &lt;code&gt;CH&lt;/code&gt; to &lt;code&gt;0E6A&lt;/code&gt; (as a value between &lt;code&gt;0E60&lt;/code&gt; and &lt;code&gt;0E6D&lt;/code&gt; ) makes ordering as &lt;code&gt;C &amp;lt; CH &amp;lt; D&lt;/code&gt; . Exactly speaking DUCET already has some characters between &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; : &lt;code&gt;small capital C&lt;/code&gt; (&lt;code&gt;U+1D04&lt;/code&gt;) with primary weight &lt;code&gt;0E64&lt;/code&gt; , &lt;code&gt;c-hook/C-hook&lt;/code&gt; (&lt;code&gt;U+0188/U+0187&lt;/code&gt;) with &lt;code&gt;0E65&lt;/code&gt; , and &lt;code&gt;c-curl&lt;/code&gt; (&lt;code&gt;U+0255&lt;/code&gt; ) with &lt;code&gt;0E69&lt;/code&gt; . Then primary weight &lt;code&gt;0E6A&lt;/code&gt; for &lt;code&gt;CH&lt;/code&gt; makes &lt;code&gt;CH&lt;/code&gt; ordered between &lt;code&gt;c-curl&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; .</source>
          <target state="translated">В DUCET v4.0.0 первичный вес &lt;code&gt;C&lt;/code&gt; равен &lt;code&gt;0E60&lt;/code&gt; , а вес &lt;code&gt;D&lt;/code&gt; - &lt;code&gt;0E6D&lt;/code&gt; . Таким образом, установка первичного веса &lt;code&gt;CH&lt;/code&gt; на &lt;code&gt;0E6A&lt;/code&gt; (как значение между &lt;code&gt;0E60&lt;/code&gt; и &lt;code&gt;0E6D&lt;/code&gt; ) приводит к упорядочиванию как &lt;code&gt;C &amp;lt; CH &amp;lt; D&lt;/code&gt; . Точно говоря, в DUCET уже есть некоторые символы между &lt;code&gt;C&lt;/code&gt; и &lt;code&gt;D&lt;/code&gt; : &lt;code&gt;small capital C&lt;/code&gt; ( &lt;code&gt;U+1D04&lt;/code&gt; ) с основным весом &lt;code&gt;0E64&lt;/code&gt; , &lt;code&gt;c-hook/C-hook&lt;/code&gt; ( &lt;code&gt;U+0188/U+0187&lt;/code&gt; ) с &lt;code&gt;0E65&lt;/code&gt; и &lt;code&gt;c-curl&lt;/code&gt; ( &lt;code&gt;U+0255&lt;/code&gt; ) с &lt;code&gt;0E69&lt;/code&gt; . Затем первичный вес &lt;code&gt;0E6A&lt;/code&gt; для &lt;code&gt;CH&lt;/code&gt; делает &lt;code&gt;CH&lt;/code&gt; заказал между &lt;code&gt;c-curl&lt;/code&gt; и &lt;code&gt;D&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cbd5bc5a38769b2182dd3a8ac3c64a575d3f230" translate="yes" xml:space="preserve">
          <source>In English grammar, a short noun phrase between a verb and its direct object indicating the beneficiary or recipient of the action. In Perl, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; STDOUT &quot;$foo\n&quot;;&lt;/code&gt; can be understood as &amp;ldquo;verb indirect-object object&amp;rdquo;, where &lt;code&gt;STDOUT&lt;/code&gt; is the recipient of the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; action, and &lt;code&gt;&quot;$foo&quot;&lt;/code&gt; is the object being printed. Similarly, when invoking a &lt;b&gt;method&lt;/b&gt;, you might place the invocant in the dative slot between the method and its arguments:</source>
          <target state="translated">В английской грамматике - короткое существительное между глаголом и его прямым объектом, указывающее на бенефициара или получателя действия. В Perl &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; STDOUT &quot;$foo\n&quot;;&lt;/code&gt; может пониматься как &amp;laquo;глагол косвенный объект-объект&amp;raquo;, где &lt;code&gt;STDOUT&lt;/code&gt; - это получатель действия &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , а &lt;code&gt;&quot;$foo&quot;&lt;/code&gt; - это печатаемый объект. Точно так же при вызове &lt;b&gt;метода&lt;/b&gt; вы можете поместить инвокант в дательный слот между методом и его аргументами:</target>
        </trans-unit>
        <trans-unit id="217cde63e66af3805baaae8b61bf234934e3a17f" translate="yes" xml:space="preserve">
          <source>In IRIX 5.3 and with Perl 5.8.1 (Perl 5.8.0 didn't compile in IRIX 5.3) the following failures are known.</source>
          <target state="translated">В IRIX 5.3 и с Perl 5.8.1 (Perl 5.8.0 не компилировался в IRIX 5.3)известны следующие сбои.</target>
        </trans-unit>
        <trans-unit id="ae875351a921c55e10385097f1ce568f0cc36c5c" translate="yes" xml:space="preserve">
          <source>In MakeMaker-based installations,</source>
          <target state="translated">В установках на основе MakeMaker,</target>
        </trans-unit>
        <trans-unit id="a8ca889adcc661187e58d592f4912a7f93ee302a" translate="yes" xml:space="preserve">
          <source>In Math::BigInt, passing a negative number precision has no effect since no numbers have digits after the dot. In &lt;a href=&quot;bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;, it will round all results to P digits after the dot.</source>
          <target state="translated">В Math :: BigInt передача отрицательной точности числа не имеет никакого эффекта, поскольку числа не имеют цифр после точки. В &lt;a href=&quot;bigfloat&quot;&gt;Math :: BigFloat&lt;/a&gt; все результаты округляются до P цифр после точки.</target>
        </trans-unit>
        <trans-unit id="846e78092ad74f765fcf7c9c94ce51c84e742d1b" translate="yes" xml:space="preserve">
          <source>In Memory Databases</source>
          <target state="translated">В базах данных памяти</target>
        </trans-unit>
        <trans-unit id="3f860bffab3d111dbe427091c4d724eab7972b48" translate="yes" xml:space="preserve">
          <source>In Part 1 we mentioned that Perl compiles a regexp into a compact sequence of opcodes. Thus, a compiled regexp is a data structure that can be stored once and used again and again. The regexp quote &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; does exactly that: &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/string/&lt;/a&gt;&lt;/code&gt; compiles the &lt;code&gt;string&lt;/code&gt; as a regexp and transforms the result into a form that can be assigned to a variable:</source>
          <target state="translated">В Части 1 мы упоминали, что Perl компилирует регулярное выражение в компактную последовательность кодов операций. Таким образом, скомпилированное регулярное выражение - это структура данных, которую можно сохранять один раз и использовать снова и снова. Цитата регулярного выражения &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; делает именно это: &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/string/&lt;/a&gt;&lt;/code&gt; компилирует &lt;code&gt;string&lt;/code&gt; как регулярное выражение и преобразует результат в форму, которая может быть присвоена переменной:</target>
        </trans-unit>
        <trans-unit id="b8e23998d4d31cf53431494db737762f35860793" translate="yes" xml:space="preserve">
          <source>In Perl 5.005, the thread model was that all data is implicitly shared, and shared access to data has to be explicitly synchronized. This model is called</source>
          <target state="translated">В Perl 5.005 модель потока состояла в том,что все данные неявно совместно используются,а общий доступ к данным должен быть явно синхронизирован.Эта модель называется</target>
        </trans-unit>
        <trans-unit id="0ef40fb67bd5325ef3bc9871c79bffa2a2f9def8" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, declare the variable with &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; declaration creates the lexical variable that persists between calls to the subroutine:</source>
          <target state="translated">В Perl 5.10 объявите переменную с &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; декларация создает лексическую переменную , которая сохраняется между вызовами подпрограммы:</target>
        </trans-unit>
        <trans-unit id="fcad1e403285c6c0597be1e44d89e383fc28fe4e" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, the</source>
          <target state="translated">На Perl 5.10</target>
        </trans-unit>
        <trans-unit id="3754647e31be439690cdc120d0f37bbfc1ee49d5" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, use the &lt;code&gt;given-when&lt;/code&gt; construct described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;:</source>
          <target state="translated">В Perl 5.10 используйте конструкцию &lt;code&gt;given-when&lt;/code&gt; , описанную в &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ef6f20b95a614e3c70a519351a658bbdee2e34af" translate="yes" xml:space="preserve">
          <source>In Perl 5.10.0 the &lt;code&gt;/p&lt;/code&gt; match operator flag and the &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; , and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables were introduced, that allowed you to suffer the penalties only on patterns marked with &lt;code&gt;/p&lt;/code&gt;.</source>
          <target state="translated">В Perl 5.10.0 был введен флаг оператора сопоставления &lt;code&gt;/p&lt;/code&gt; и &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; и &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , которые позволяли вам нести штрафы только для шаблонов, отмеченных &lt;code&gt;/p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfdfceeeffa73fd56622a7e4fbcd615a7de619f1" translate="yes" xml:space="preserve">
          <source>In Perl 5.16 and earlier, copy-on-write (see the next section) shared a flag bit with read-only scalars. So the only way to test whether &lt;code&gt;sv_setsv&lt;/code&gt; , etc., will raise a &quot;Modification of a read-only value&quot; error in those versions is:</source>
          <target state="translated">В Perl 5.16 и ранее при копировании при записи (см. Следующий раздел) бит флага разделялся с доступными только для чтения скалярами. Таким образом, единственный способ проверить, &lt;code&gt;sv_setsv&lt;/code&gt; ли sv_setsv и т. Д. Ошибку &amp;laquo;Изменение значения только для чтения&amp;raquo; в этих версиях:</target>
        </trans-unit>
        <trans-unit id="9c29d499be725da440aa9799fa65cef604b0abdb" translate="yes" xml:space="preserve">
          <source>In Perl 5.18.0 onwards, perl started noting the presence of each of the three variables separately, and only copied that part of the string required; so in</source>
          <target state="translated">В Perl 5.18.0 и далее,perl начал отмечать наличие каждой из трех переменных по отдельности,и копировал только ту часть строки,которая требовалась;так в</target>
        </trans-unit>
        <trans-unit id="ac74f29244f42c123f550a223146503cf87cca65" translate="yes" xml:space="preserve">
          <source>In Perl 5.20 and earlier, the only pragmas to be completely supported are: &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (&lt;code&gt;$[&lt;/code&gt; , which behaves like a pragma, is also supported.)</source>
          <target state="translated">В Perl 5.20 и ранее полностью поддерживаются только прагмы: &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . ( Также поддерживается &lt;code&gt;$[&lt;/code&gt; , которая ведет себя как прагма.)</target>
        </trans-unit>
        <trans-unit id="a99daea546c9fc521d28b295e0227c75c1c77163" translate="yes" xml:space="preserve">
          <source>In Perl 5.20 and higher this is ignored. Due to a new copy-on-write mechanism, ${^PREMATCH}, ${^MATCH}, and ${^POSTMATCH} will be available after the match regardless of the modifier.</source>
          <target state="translated">В Perl 5.20 и выше это игнорируется.Благодаря новому механизму копирования на запись,${^PREMATCH},${^MATCH}и ${^POSTMATCH}будут доступны после матча независимо от модификатора.</target>
        </trans-unit>
        <trans-unit id="5dd87335d7944293ee760ce3fce6d463be42dedd" translate="yes" xml:space="preserve">
          <source>In Perl 5.20.0 a new copy-on-write system was enabled by default, which finally fixes all performance issues with these three variables, and makes them safe to use anywhere.</source>
          <target state="translated">В Perl 5.20.0 по умолчанию была включена новая система копирования на запись,которая окончательно исправляет все проблемы с производительностью этих трех переменных и делает их безопасными для использования в любом месте.</target>
        </trans-unit>
        <trans-unit id="f3bfdc8baf280a72c47cbbea941ae21c16b028e7" translate="yes" xml:space="preserve">
          <source>In Perl 5.20.0 this was changed so that it would be &lt;b&gt;exactly&lt;/b&gt; the same as setting &lt;code&gt;$/&lt;/code&gt; to undef, with the exception that this warning would be thrown.</source>
          <target state="translated">В Perl 5.20.0 это было изменено так, что оно будет &lt;b&gt;точно&lt;/b&gt; таким же, как установка &lt;code&gt;$/&lt;/code&gt; на undef, за исключением того, что будет выдано это предупреждение.</target>
        </trans-unit>
        <trans-unit id="b9a5cb481a025f6680fe2e560f757bef411f0354" translate="yes" xml:space="preserve">
          <source>In Perl 5.22 and later, all groups within a regexp can be set to non-capturing by using the new &lt;code&gt;/n&lt;/code&gt; flag:</source>
          <target state="translated">В Perl 5.22 и более поздних версиях все группы в регулярном выражении могут быть отключены от захвата с помощью нового флага &lt;code&gt;/n&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="829f62b5d0005de3966076a8745c273476071683" translate="yes" xml:space="preserve">
          <source>In Perl 5.6 and some books the &lt;code&gt;:raw&lt;/code&gt; layer (previously sometimes also referred to as a &quot;discipline&quot;) is documented as the inverse of the &lt;code&gt;:crlf&lt;/code&gt; layer. That is no longer the case - other layers which would alter the binary nature of the stream are also disabled. If you want UNIX line endings on a platform that normally does CRLF translation, but still want UTF-8 or encoding defaults, the appropriate thing to do is to add &lt;code&gt;:perlio&lt;/code&gt; to the PERLIO environment variable.</source>
          <target state="translated">В Perl 5.6 и некоторых книгах слой &lt;code&gt;:raw&lt;/code&gt; (ранее иногда также называемый &amp;laquo;дисциплиной&amp;raquo;) задокументирован как &lt;code&gt;:crlf&lt;/code&gt; слоя : crlf . Это уже не так - другие уровни, которые могут изменить двоичную природу потока, также отключены. Если вам нужны окончания строк UNIX на платформе, которая обычно выполняет преобразование CRLF, но при этом требуется UTF-8 или значения по умолчанию для кодировки, правильным &lt;code&gt;:perlio&lt;/code&gt; будет добавить : perlio в переменную среды PERLIO.</target>
        </trans-unit>
        <trans-unit id="8fac8c7e82a994285a91ea520c95723e026d4360" translate="yes" xml:space="preserve">
          <source>In Perl 5.6, a new model was introduced in which all is was thread local and shared access to data has to be explicitly declared. This model is called</source>
          <target state="translated">В Perl 5.6 была введена новая модель,в которой все является потоковым локальным и общий доступ к данным должен быть явно декларирован.Эта модель называется</target>
        </trans-unit>
        <trans-unit id="c2abdf6c9d513612683e10abfef7f22af8c5271f" translate="yes" xml:space="preserve">
          <source>In Perl 5.6, the</source>
          <target state="translated">На Perl 5.6</target>
        </trans-unit>
        <trans-unit id="26c0c53508feac78fbf5a2c99792e045ffa03c8a" translate="yes" xml:space="preserve">
          <source>In Perl 5.6.0 the &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; dynamic arrays were introduced that supply the indices of successful matches. So you could for example do this:</source>
          <target state="translated">В Perl 5.6.0 были введены динамические массивы &lt;code&gt;@-&lt;/code&gt; и &lt;code&gt;@+&lt;/code&gt; которые предоставляют индексы успешных совпадений. Например, вы можете сделать это:</target>
        </trans-unit>
        <trans-unit id="523c10b75565b9e0e195e0700fdbbd2ed237ae32" translate="yes" xml:space="preserve">
          <source>In Perl 5.8, the</source>
          <target state="translated">На Perl 5.8</target>
        </trans-unit>
        <trans-unit id="a58322d6122d01dd67612b6444328927a4d69bfc" translate="yes" xml:space="preserve">
          <source>In Perl 5.8.0 the slowness was often quite spectacular; in Perl 5.8.1 a caching scheme was introduced which improved the situation. In general, operations with UTF-8 encoded strings are still slower. As an example, the Unicode properties (character classes) like &lt;code&gt;\p{Nd}&lt;/code&gt; are known to be quite a bit slower (5-20 times) than their simpler counterparts like &lt;code&gt;[0-9]&lt;/code&gt; (then again, there are hundreds of Unicode characters matching &lt;code&gt;Nd&lt;/code&gt; compared with the 10 ASCII characters matching &lt;code&gt;[0-9]&lt;/code&gt; ).</source>
          <target state="translated">В Perl 5.8.0 медлительность часто была весьма впечатляющей; в Perl 5.8.1 была введена схема кеширования, которая улучшила ситуацию. В целом, операции со строками в кодировке UTF-8 все еще медленнее. Например, свойства Unicode (классы символов), такие как &lt;code&gt;\p{Nd}&lt;/code&gt; как известно, немного медленнее (в 5-20 раз), чем их более простые аналоги, такие как &lt;code&gt;[0-9]&lt;/code&gt; (опять же, существуют сотни Unicode символы, соответствующие &lt;code&gt;Nd&lt;/code&gt; , по сравнению с 10 символами ASCII, соответствующими &lt;code&gt;[0-9]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0c85305fdff4b0749bfcf24c2c7a107269854de9" translate="yes" xml:space="preserve">
          <source>In Perl 6, &lt;code&gt;when()&lt;/code&gt; will always do an implicit smartmatch with its argument, while in Perl 5 it is convenient (albeit potentially confusing) to suppress this implicit smartmatch in various rather loosely-defined situations, as roughly outlined above. (The difference is largely because Perl 5 does not have, even internally, a boolean type.)</source>
          <target state="translated">В Perl 6 &lt;code&gt;when()&lt;/code&gt; всегда будет выполнять неявное интеллектуальное сопоставление со своим аргументом, тогда как в Perl 5 удобно (хотя и потенциально сбивать с толку) подавление этого неявного интеллектуального сопоставления в различных довольно слабо определенных ситуациях, как примерно описано выше. (Разница в основном состоит в том, что Perl 5 не имеет, даже внутренне, логического типа.)</target>
        </trans-unit>
        <trans-unit id="ca97d510355543881848d3f320ae7ab2b8841db0" translate="yes" xml:space="preserve">
          <source>In Perl most objects are hashes, but the OO systems we recommend keep you from having to worry about this. In practice, it's best to consider an object's internal data structure opaque.</source>
          <target state="translated">В Perl большинство объектов-это хэши,но системы OO мы рекомендуем не беспокоить вас по этому поводу.На практике лучше всего считать внутреннюю структуру данных объекта непрозрачной.</target>
        </trans-unit>
        <trans-unit id="243bad753f535e22807612697dcecab4311e323e" translate="yes" xml:space="preserve">
          <source>In Perl regular expressions, most regexp elements 'eat up' a certain amount of string when they match. For instance, the regexp element &lt;code&gt;[abc}]&lt;/code&gt; eats up one character of the string when it matches, in the sense that Perl moves to the next character position in the string after the match. There are some elements, however, that don't eat up characters (advance the character position) if they match. The examples we have seen so far are the anchors. The anchor &lt;code&gt;^&lt;/code&gt; matches the beginning of the line, but doesn't eat any characters. Similarly, the word boundary anchor &lt;code&gt;\b&lt;/code&gt; matches wherever a character matching &lt;code&gt;\w&lt;/code&gt; is next to a character that doesn't, but it doesn't eat up any characters itself. Anchors are examples of</source>
          <target state="translated">В регулярных выражениях Perl большинство элементов регулярных выражений &amp;laquo;съедают&amp;raquo; определенное количество строк при совпадении. Например, элемент регулярного выражения &lt;code&gt;[abc}]&lt;/code&gt; поглощает один символ строки, когда он совпадает, в том смысле, что Perl перемещается на позицию следующего символа в строке после совпадения. Однако есть некоторые элементы, которые не поглощают символы (перемещают позицию символа), если они совпадают. Примеры, которые мы видели до сих пор, - это якоря. Якорь &lt;code&gt;^&lt;/code&gt; соответствует началу строки, но не содержит никаких символов. Точно так же привязка границы слова &lt;code&gt;\b&lt;/code&gt; соответствует везде, где совпадающий символ &lt;code&gt;\w&lt;/code&gt; находится рядом с символом, которого нет, но он сам не поглощает символы. Якоря являются примерами</target>
        </trans-unit>
        <trans-unit id="905e1c7e56de580fc4af4b17e4c486804586d33e" translate="yes" xml:space="preserve">
          <source>In Perl terms this means that supplying the usual Perl numbers (also known as scalars, please see &lt;a href=&quot;../perldata&quot;&gt;perldata&lt;/a&gt;) as input for the trigonometric functions might produce as output results that no more are simple real numbers: instead they are complex numbers.</source>
          <target state="translated">В терминах Perl это означает, что предоставление обычных чисел Perl (также известных как скаляры, см. &lt;a href=&quot;../perldata&quot;&gt;Perldata&lt;/a&gt; ) в качестве входных данных для тригонометрических функций может привести к выходным результатам, которые больше не являются простыми действительными числами: вместо этого они являются комплексными числами.</target>
        </trans-unit>
        <trans-unit id="7f326f4fd32f12380a2d175a436e985d3f4c2edf" translate="yes" xml:space="preserve">
          <source>In Perl v5.14, all non-ASCII characters are quoted in non-UTF-8-encoded strings, but not quoted in UTF-8 strings.</source>
          <target state="translated">В Perl v5.14 все не-ASCII-символы цитируются в строках,не кодированных в кодировке UTF-8,но не цитируются в строках в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="0ffdb19ef413239753228d33908dad38e29d542e" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^MATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$MATCH&lt;/code&gt; .</source>
          <target state="translated">В Perl v5.18 и ранее гарантировано возвращение определенного значения только тогда, когда шаблон был скомпилирован или выполнен с модификатором &lt;code&gt;/p&lt;/code&gt; . В Perl v5.20 модификатор &lt;code&gt;/p&lt;/code&gt; ничего не делает, поэтому &lt;code&gt;${^MATCH}&lt;/code&gt; делает то же самое, что и &lt;code&gt;$MATCH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4dbbc56c5f11021be8e37601f6986f49dc8e148" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^POSTMATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$POSTMATCH&lt;/code&gt; .</source>
          <target state="translated">В Perl v5.18 и ранее гарантировано возвращение определенного значения только тогда, когда шаблон был скомпилирован или выполнен с модификатором &lt;code&gt;/p&lt;/code&gt; . В Perl v5.20 модификатор &lt;code&gt;/p&lt;/code&gt; ничего не делает, поэтому &lt;code&gt;${^POSTMATCH}&lt;/code&gt; делает то же самое, что и &lt;code&gt;$POSTMATCH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05c22186f7acbb5a1c00ca1269cc907a18af05f8" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^PREMATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$PREMATCH&lt;/code&gt; .</source>
          <target state="translated">В Perl v5.18 и ранее гарантировано возвращение определенного значения только тогда, когда шаблон был скомпилирован или выполнен с модификатором &lt;code&gt;/p&lt;/code&gt; . В Perl v5.20 модификатор &lt;code&gt;/p&lt;/code&gt; ничего не делает, поэтому &lt;code&gt;${^PREMATCH}&lt;/code&gt; делает то же самое, что и &lt;code&gt;$PREMATCH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5432c77569fd0514eaa8844532d6c5cc637bdaa6" translate="yes" xml:space="preserve">
          <source>In Perl versions 5.6 and earlier the quicksort algorithm was used to implement &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;, but in Perl 5.8 a mergesort algorithm was also made available, mainly to guarantee worst case O(N log N) behaviour: the worst case of quicksort is O(N**2). In Perl 5.8 and later, quicksort defends against quadratic behaviour by shuffling large arrays before sorting.</source>
          <target state="translated">В версиях Perl 5.6 и более ранних для реализации &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; использовался алгоритм быстрой сортировки , но в Perl 5.8 также был доступен алгоритм сортировки слиянием , в основном для обеспечения наихудшего поведения O (N log N): наихудший случай быстрой сортировки - O ( N ** 2). В Perl 5.8 и более поздних версиях quicksort защищает от квадратичного поведения путем перемешивания больших массивов перед сортировкой.</target>
        </trans-unit>
        <trans-unit id="8b481016607f0afb6a75f448e44a95f87a802232" translate="yes" xml:space="preserve">
          <source>In Perl you will get a floating point value if you do one of the following:</source>
          <target state="translated">В Perl вы получите значение с плавающей точкой,если сделаете одно из следующих действий:</target>
        </trans-unit>
        <trans-unit id="7d663b5a48798d90608073d23eaf6d6597db1534" translate="yes" xml:space="preserve">
          <source>In Perl, &lt;code&gt;else if&lt;/code&gt; is spelled &lt;code&gt;elsif&lt;/code&gt; .</source>
          <target state="translated">В Perl &lt;code&gt;else if&lt;/code&gt; пишется как &lt;code&gt;elsif&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49774beef30ebf83ad6beb68cfd55f59cc0e76e3" translate="yes" xml:space="preserve">
          <source>In Perl, a class is just a package, and methods are just subroutines. Perl doesn't get more formal than that and lets you set up the package just the way that you like it (that is, it doesn't set up anything for you).</source>
          <target state="translated">В Perl класс-это просто пакет,а методы-просто подпрограммы.Perl не становится более формальным и позволяет настроить пакет именно так,как вам нравится (т.е.он ничего для вас не настраивает).</target>
        </trans-unit>
        <trans-unit id="983e915935b5fb68c2f1bb82bb4cf04272a6754a" translate="yes" xml:space="preserve">
          <source>In Perl, a sequence of statements that defines a scope is called a block. Sometimes a block is delimited by the file containing it (in the case of a required file, or the program as a whole), and sometimes a block is delimited by the extent of a string (in the case of an eval).</source>
          <target state="translated">В Perl последовательность выражений,определяющая область действия,называется блоком.Иногда блок отделяется содержащим его файлом (в случае требуемого файла или программы в целом),а иногда блок отделяется объемом строки (в случае оценки).</target>
        </trans-unit>
        <trans-unit id="476c5432e1fcd1b2c55042740329df48b50efcfd" translate="yes" xml:space="preserve">
          <source>In Perl, an object is a blessed reference. The standard way of associating data with an object is to store the data inside the object's body, that is, the piece of data pointed to by the reference.</source>
          <target state="translated">В Perl,объект-это благословенная ссылка.Стандартный способ связывания данных с объектом заключается в хранении данных внутри тела объекта,то есть той части данных,на которую указывает ссылка.</target>
        </trans-unit>
        <trans-unit id="6459245c83006474d0636721805e8f89399cea54" translate="yes" xml:space="preserve">
          <source>In Perl, any package can be a class. The difference between a package which is a class and one which isn't is based on how the package is used. Here's our &quot;class declaration&quot; for the &lt;code&gt;File&lt;/code&gt; class:</source>
          <target state="translated">В Perl любой пакет может быть классом. Разница между пакетом, который является классом, и пакетом, который не является классом, зависит от того, как этот пакет используется. Вот наше &amp;laquo;объявление класса&amp;raquo; для класса &lt;code&gt;File&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="935b815c5b098d8ca1c1e87b1e728cb47b24fb51" translate="yes" xml:space="preserve">
          <source>In Perl, any value that would look like &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;&quot;0&quot;&lt;/code&gt; if evaluated in a string context. Since undefined values evaluate to &lt;code&gt;&quot;&quot;&lt;/code&gt; , all undefined values are false, but not all false values are undefined.</source>
          <target state="translated">В Perl - любое значение, которое выглядело бы как &lt;code&gt;&quot;&quot;&lt;/code&gt; или &lt;code&gt;&quot;0&quot;&lt;/code&gt; при вычислении в строковом контексте. Поскольку неопределенные значения оцениваются как &lt;code&gt;&quot;&quot;&lt;/code&gt; , все неопределенные значения являются ложными, но не все ложные значения являются неопределенными.</target>
        </trans-unit>
        <trans-unit id="56beb88cb62afd75b5b76cfb0ba20b6ebe456c89" translate="yes" xml:space="preserve">
          <source>In Perl, binary &lt;code&gt;+&lt;/code&gt; is always addition. &lt;code&gt;$string1 + $string2&lt;/code&gt; converts both strings to numbers and then adds them. To concatenate two strings, use the &lt;code&gt;.&lt;/code&gt; operator.</source>
          <target state="translated">В Perl двоичный &lt;code&gt;+&lt;/code&gt; всегда является сложением. &lt;code&gt;$string1 + $string2&lt;/code&gt; преобразует обе строки в числа, а затем складывает их. Чтобы объединить две строки, используйте &lt;code&gt;.&lt;/code&gt; оператор.</target>
        </trans-unit>
        <trans-unit id="a33a4933eab4c192832e758c7f44c0a0303ba50a" translate="yes" xml:space="preserve">
          <source>In Perl, methods are simply subroutines that live in a class's package. Methods are always written to receive the object as their first argument:</source>
          <target state="translated">В Perl методы-это просто подпрограммы,которые живут в пакете класса.Методы всегда пишутся для получения объекта в качестве их первого аргумента:</target>
        </trans-unit>
        <trans-unit id="ea72a9a423acf3df90a345514eea4421a19ceb17" translate="yes" xml:space="preserve">
          <source>In Perl, the debugger is not a separate program the way it usually is in the typical compiled environment. Instead, the &lt;b&gt;-d&lt;/b&gt; flag tells the compiler to insert source information into the parse trees it's about to hand off to the interpreter. That means your code must first compile correctly for the debugger to work on it. Then when the interpreter starts up, it preloads a special Perl library file containing the debugger.</source>
          <target state="translated">В Perl отладчик не является отдельной программой, как это обычно бывает в типичной скомпилированной среде. Вместо этого флаг &lt;b&gt;-d&lt;/b&gt; указывает компилятору вставить исходную информацию в деревья синтаксического анализа, которые он собирается передать интерпретатору. Это означает, что ваш код должен сначала правильно скомпилироваться, чтобы отладчик работал с ним. Затем, когда интерпретатор запускается, он предварительно загружает специальный файл библиотеки Perl, содержащий отладчик.</target>
        </trans-unit>
        <trans-unit id="3c642476c3d73c23016f66bc533c3f6f2db6cded" translate="yes" xml:space="preserve">
          <source>In Perl, the operator determines what operation is performed, independent of the type of the operands. For example &lt;code&gt;$x + $y&lt;/code&gt; is always a numeric addition, and if &lt;code&gt;$x&lt;/code&gt; or &lt;code&gt;$y&lt;/code&gt; do not contain numbers, an attempt is made to convert them to numbers first.</source>
          <target state="translated">В Perl оператор определяет, какая операция выполняется, независимо от типа операндов. Например, &lt;code&gt;$x + $y&lt;/code&gt; всегда является числовым сложением, и если &lt;code&gt;$x&lt;/code&gt; или &lt;code&gt;$y&lt;/code&gt; не содержат чисел, сначала делается попытка преобразовать их в числа.</target>
        </trans-unit>
        <trans-unit id="05577297c46ae0d2cd55a130e9e49792d0bf233a" translate="yes" xml:space="preserve">
          <source>In Perl, there is no special keyword for constructing an object. However, most OO modules on CPAN use a method named &lt;code&gt;new()&lt;/code&gt; to construct a new object:</source>
          <target state="translated">В Perl нет специального ключевого слова для создания объекта. Однако большинство OO-модулей в CPAN используют метод с именем &lt;code&gt;new()&lt;/code&gt; для создания нового объекта:</target>
        </trans-unit>
        <trans-unit id="e4aecd76031e1346a21238102ea29667311ebe2a" translate="yes" xml:space="preserve">
          <source>In Perl, you just can't access memory at random, but the structural and representational conversion provided by &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is an excellent alternative. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function converts values to a byte sequence containing representations according to a given specification, the so-called &quot;template&quot; argument. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is the reverse process, deriving some values from the contents of a string of bytes. (Be cautioned, however, that not all that has been packed together can be neatly unpacked - a very common experience as seasoned travellers are likely to confirm.)</source>
          <target state="translated">В Perl вы просто не можете получить произвольный доступ к памяти, но структурное и репрезентативное преобразование, обеспечиваемое &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; , является отличной альтернативой. Функция &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; преобразует значения в последовательность байтов, содержащую представления в соответствии с заданной спецификацией, так называемый аргумент &amp;laquo;шаблон&amp;raquo;. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; - это обратный процесс, извлекающий некоторые значения из содержимого строки байтов. (Однако имейте в виду, что не все, что было упаковано вместе, можно аккуратно распаковать - очень распространенный опыт, который, вероятно, подтвердят опытные путешественники.)</target>
        </trans-unit>
        <trans-unit id="3a69ee0657acfe60fc783ea37121861ef3e8b2c7" translate="yes" xml:space="preserve">
          <source>In Practice</source>
          <target state="translated">На практике</target>
        </trans-unit>
        <trans-unit id="9c9de61f162399b6dd1501b64047f173f7ebabe0" translate="yes" xml:space="preserve">
          <source>In SVN, $Revision$ should be the same for every file in the project so they would all have the same $VERSION. CVS and RCS have a different $Revision$ per file so each file will have a different $VERSION. Distributed version control systems, such as SVK, may have a different $Revision$ based on who checks out the file, leading to a different $VERSION on each machine! Finally, some distributed version control systems, such as darcs, have no concept of revision number at all.</source>
          <target state="translated">В SVN $Revision$ должен быть одинаковым для каждого файла в проекте,чтобы все они имели одинаковые $VERSION.CVS и RCS имеют разные $Revision$ для каждого файла,так что каждый файл будет иметь свою $VERSION.Распределенные системы управления версиями,такие как SVK,могут иметь разные $Revision$ в зависимости от того,кто проверяет файл,что приводит к разным $VERSION на каждой машине! Наконец,некоторые распределенные системы управления версиями,такие как darcs,вообще не имеют понятия номера ревизии.</target>
        </trans-unit>
        <trans-unit id="35c376db5dd46f66500036f6b8bff5133701d987" translate="yes" xml:space="preserve">
          <source>In SunOS 4.x you most probably want to use the SunOS ld, /usr/bin/ld, since the more recent versions of GNU ld (like 2.13) do not seem to work for building Perl anymore. When linking the extensions, the GNU ld gets very unhappy and spews a lot of errors like this</source>
          <target state="translated">В SunOS 4.x вы,скорее всего,захотите использовать SunOS ld,/usr/bin/ld,поскольку более поздние версии GNU ld (например,2.13),похоже,больше не работают для сборки Perl.При компоновке расширений лицензия GNU ld становится очень несчастной и выдает много таких ошибок</target>
        </trans-unit>
        <trans-unit id="ef1e3aace4bede70eba3cee6d6eb0864ab35df15" translate="yes" xml:space="preserve">
          <source>In Tru64 Perl is automatically able to use large files, that is, files larger than 2 gigabytes, there is no need to use the Configure -Duselargefiles option as described in INSTALL (though using the option is harmless).</source>
          <target state="translated">В Tru64 Perl автоматически может использовать большие файлы,то есть файлы размером более 2 гигабайт,нет необходимости использовать опцию Configure -Duselargefiles,как описано в INSTALL (хотя использование этой опции безвредно).</target>
        </trans-unit>
        <trans-unit id="cc19255447bc355361ae2f45799e7311a851742c" translate="yes" xml:space="preserve">
          <source>In Tru64 Perl's integers are automatically 64-bit wide, there is no need to use the Configure -Duse64bitint option as described in INSTALL. Similarly, there is no need for -Duse64bitall since pointers are automatically 64-bit wide.</source>
          <target state="translated">В Tru64 Perl целые числа автоматически становятся 64-битными,нет необходимости использовать опцию Configure -Duse64bitint,как описано в INSTALL.Аналогично,нет необходимости использовать опцию -Duse64bitall,так как указатели автоматически становятся 64-битными.</target>
        </trans-unit>
        <trans-unit id="92e8004abe586abe7845a841b1a5b8acbf9b5035" translate="yes" xml:space="preserve">
          <source>In Tru64 V5 (at least V5.1A, V5.1B) you cannot build threaded Perl with gcc because the system header &amp;lt;pthread.h&amp;gt; explicitly checks for supported C compilers, gcc (at least 3.2.2) not being one of them. But the system C compiler should work just fine.</source>
          <target state="translated">В Tru64 V5 (по крайней мере, V5.1A, V5.1B) вы не можете создавать многопоточный Perl с помощью gcc, потому что системный заголовок &amp;lt;pthread.h&amp;gt; явно проверяет наличие поддерживаемых компиляторов C, gcc (по крайней мере 3.2.2) не является одним из них . Но системный компилятор C должен работать нормально.</target>
        </trans-unit>
        <trans-unit id="6303bf4cf60f3cd73bbb5bee3d92ebf1b27db248" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, it is not guaranteed that the lexer buffer actually contains valid UTF-8. Lexing code must be robust in the face of invalid encoding.</source>
          <target state="translated">В режиме UTF-8 не гарантируется,что лексерный буфер действительно содержит действительный UTF-8.Код лексирования должен быть робастным перед лицом недействительной кодировки.</target>
        </trans-unit>
        <trans-unit id="5587dff620034120288215aaa5eec31db833ac28" translate="yes" xml:space="preserve">
          <source>In Unicode 4.1.0, the definition D2 of canonical composition (which affects NFC and NFKC) has been changed (see Public Review Issue #29 and recent UAX #15). This module has used the newer definition since the version 0.07 (Oct 31, 2001). This module will not support the normalization according to the older definition, even if the Unicode version implemented by perl is lower than 4.1.0.</source>
          <target state="translated">В Юникоде 4.1.0 было изменено определение D2 канонического состава (которое влияет на NFC и NFKC)(см.Public Review Issue #29 и recent UAX #15).Этот модуль использует более новое определение с версии 0.07 (31 октября 2001).Этот модуль не будет поддерживать нормализацию в соответствии со старым определением,даже если версия Юникода,реализованная на perl,ниже 4.1.0.</target>
        </trans-unit>
        <trans-unit id="4add5639cbd0356c9e63afa54113a4c2eb6433cf" translate="yes" xml:space="preserve">
          <source>In Unicode terminology a</source>
          <target state="translated">В терминологии Юникода a</target>
        </trans-unit>
        <trans-unit id="f8ecaf55c52d72cac38172d4d214a7acd326645e" translate="yes" xml:space="preserve">
          <source>In Unicode, not just characters with the General Category of Lowercase Letter, but any character with the Lowercase property, including Modifier Letters, Letter Numbers, some Other Symbols, and one Combining Mark.</source>
          <target state="translated">В Юникоде,не только символы с Общей Категорией Нижней Буквы,но и любой символ с свойством Нижний регистр,включая Modifier Letters,Letter Numbers,некоторые другие символы,и один комбинированный знак.</target>
        </trans-unit>
        <trans-unit id="6d6e7c6b62a7207f53debc7941773b1adb72b5b5" translate="yes" xml:space="preserve">
          <source>In Unicode, not just characters with the General Category of Uppercase Letter, but any character with the Uppercase property, including some Letter Numbers and Symbols. Not to be confused with &lt;b&gt;titlecase&lt;/b&gt;.</source>
          <target state="translated">В Юникоде не только символы с общей категорией прописных букв, но и любые символы со свойством верхнего регистра, включая некоторые буквенные числа и символы. Не путать с &lt;b&gt;заглавной буквой&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b113bf75921160dcb55ede1f720912618b376337" translate="yes" xml:space="preserve">
          <source>In Unix, a sequence of zero or more nonnewline characters terminated with a &lt;b&gt;newline&lt;/b&gt; character. On non-Unix machines, this is emulated by the C library even if the underlying &lt;b&gt;operating system&lt;/b&gt; has different ideas.</source>
          <target state="translated">В Unix - последовательность из нуля или более символов, не являющихся &lt;b&gt;новой&lt;/b&gt; строкой, оканчивающаяся &lt;b&gt;символом новой строки&lt;/b&gt; . На машинах, отличных от Unix, это эмулируется библиотекой C, даже если в базовой &lt;b&gt;операционной системе&lt;/b&gt; есть другие идеи.</target>
        </trans-unit>
        <trans-unit id="1bf9694eb8cd962c6afbe1434566f7218f970b1f" translate="yes" xml:space="preserve">
          <source>In Windows platforms, &lt;code&gt;$^O&lt;/code&gt; is not very helpful: since it is always &lt;code&gt;MSWin32&lt;/code&gt; , it doesn't tell the difference between 95/98/ME/NT/2000/XP/CE/.NET. Use &lt;code&gt;Win32::GetOSName()&lt;/code&gt; or Win32::GetOSVersion() (see &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt; and &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;) to distinguish between the variants.</source>
          <target state="translated">На платформах Windows &lt;code&gt;$^O&lt;/code&gt; не очень помогает: поскольку это всегда &lt;code&gt;MSWin32&lt;/code&gt; , он не различает 95/98 / ME / NT / 2000 / XP / CE / .NET. Используйте &lt;code&gt;Win32::GetOSName()&lt;/code&gt; или Win32 :: GetOSVersion () (см. &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt; и &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; ), чтобы различать варианты.</target>
        </trans-unit>
        <trans-unit id="d8d2f9cdc2abce1c37c00210e5a99994671e5e54" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; code, text may contain formatting codes for formatting or for E&amp;lt;...&amp;gt; escapes, as in:</source>
          <target state="translated">В коде &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; текст может содержать коды форматирования для форматирования или для E &amp;lt;...&amp;gt; экранирования, как в:</target>
        </trans-unit>
        <trans-unit id="01e19714f7b922e3746b1633bf7eecd4c7104aed" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loop, &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; can be used to detect the end of each file, whereas &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; will detect the end of the very last file only. Examples:</source>
          <target state="translated">Через цикл &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; можно использовать &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; для определения конца каждого файла, тогда как &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; обнаружит только конец самого последнего файла. Примеры:</target>
        </trans-unit>
        <trans-unit id="41690d136fbd264eb140c8b8c6cc615177c5eb14" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loop, &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; can be used to detect the end of each file, whereas &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; will detect the end of the very last file only. Examples:</source>
          <target state="translated">Через цикл &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; можно использовать &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; для определения конца каждого файла, тогда как &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; обнаружит только конец самого последнего файла. Примеры:</target>
        </trans-unit>
        <trans-unit id="bc099e33e27d3f3cccb59648c75894207f5a15fa" translate="yes" xml:space="preserve">
          <source>In a Perl built for debugging, some buckets may have negative usable size. This means that these buckets cannot (and will not) be used. For larger buckets, the memory footprint may be one page greater than a power of 2. If so, the corresponding power of two is printed in the &lt;code&gt;APPROX&lt;/code&gt; field above.</source>
          <target state="translated">В Perl, созданном для отладки, некоторые корзины могут иметь отрицательный полезный размер. Это означает, что эти корзины не могут (и не будут) использоваться. Для сегментов большего размера объем памяти может быть на одну страницу больше, чем степень двойки. Если это так, соответствующая степень двойки печатается в поле &lt;code&gt;APPROX&lt;/code&gt; выше.</target>
        </trans-unit>
        <trans-unit id="9d530f843344f7a394d5586d561f13c274faa0f4" translate="yes" xml:space="preserve">
          <source>In a Perl version number such as 5.6.2, this is the 2. Values greater than 50 represent potentially unstable development subversions. This value is manually set in</source>
          <target state="translated">В Perl версии,такой как 5.6.2,это 2.Значения больше 50 представляют собой потенциально нестабильные подрывные процессы развития.Это значение устанавливается вручную в</target>
        </trans-unit>
        <trans-unit id="0f808181882ea1893d708887496cf67865ae159d" translate="yes" xml:space="preserve">
          <source>In a Perl version number such as 5.6.2, this is the 5. This value is manually set in</source>
          <target state="translated">В версии Perl,например,5.6.2,это 5.Это значение устанавливается вручную в параметре</target>
        </trans-unit>
        <trans-unit id="9adb69905ef42f7e50e2708e20623f57aec71e19" translate="yes" xml:space="preserve">
          <source>In a Perl version number such as 5.6.2, this is the 6. This value is manually set in</source>
          <target state="translated">В версии Perl,например,5.6.2,это 6.Это значение устанавливается вручную в параметре</target>
        </trans-unit>
        <trans-unit id="00e75241de38f496d3e98c78e65b223be163fce0" translate="yes" xml:space="preserve">
          <source>In a UTF-8 locale in v5.20 and later, the only visible difference between locale and non-locale in regular expressions should be tainting (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;).</source>
          <target state="translated">В локали UTF-8 в версии 5.20 и новее единственная видимая разница между локалью и не-локалью в регулярных выражениях должна быть искажением (см. &lt;a href=&quot;perlsec&quot;&gt;Perlsec&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="684ae84268e30b89f35130d6bd4027aeb36b7294" translate="yes" xml:space="preserve">
          <source>In a bracketed character class in a regular expression pattern, you had a range which has exactly one end of it specified using &lt;code&gt;\N{}&lt;/code&gt; , and the other end is specified using a non-portable mechanism. Perl treats the range as a Unicode range, that is, all the characters in it are considered to be the Unicode characters, and which may be different code points on some platforms Perl runs on. For example, &lt;code&gt;[\N{U+06}-\x08]&lt;/code&gt; is treated as if you had instead said &lt;code&gt;[\N{U+06}-\N{U+08}]&lt;/code&gt; , that is it matches the characters whose code points in Unicode are 6, 7, and 8. But that &lt;code&gt;\x08&lt;/code&gt; might indicate that you meant something different, so the warning gets raised.</source>
          <target state="translated">В классе символов в квадратных скобках в шаблоне регулярного выражения у вас был диапазон, у которого ровно один конец указан с помощью &lt;code&gt;\N{}&lt;/code&gt; , а другой конец указан с использованием непереносимого механизма. Perl рассматривает диапазон как диапазон Unicode, то есть все символы в нем считаются символами Unicode и могут быть разными кодовыми точками на некоторых платформах, на которых работает Perl. Например, &lt;code&gt;[\N{U+06}-\x08]&lt;/code&gt; обрабатывается так, как если бы вы вместо этого сказали &lt;code&gt;[\N{U+06}-\N{U+08}]&lt;/code&gt; , то есть он соответствует символам, кодовые точки которых в Unicode это 6, 7 и 8. Но это &lt;code&gt;\x08&lt;/code&gt; может означать, что вы имели в виду нечто иное, поэтому возникает предупреждение.</target>
        </trans-unit>
        <trans-unit id="1004ce202059ee590c51b52b194413677ea17ca4" translate="yes" xml:space="preserve">
          <source>In a context not requiring a list value, the value of what appears to be a list literal is simply the value of the final element, as with the C comma operator. For example,</source>
          <target state="translated">В контексте,не требующем значения списка,значение того,что кажется буквальным списком,является просто значением конечного элемента,как в случае с оператором C запятая.Например,</target>
        </trans-unit>
        <trans-unit id="4c9fb939bd1697123252f0ff4192d8603d7b42ba" translate="yes" xml:space="preserve">
          <source>In a future version of Storable, we intend to provide options to disable loading modules for classes and to disable deserializing objects altogether.</source>
          <target state="translated">В будущей версии Storable мы планируем предоставить возможность отключить загрузку модулей для классов и вообще отключить десериализацию объектов.</target>
        </trans-unit>
        <trans-unit id="7f48268e7084e302cd8de3636cf3c45d91f67d83" translate="yes" xml:space="preserve">
          <source>In a list context it returns a list of all the operator names. (Not yet implemented, use @names = opset_to_ops(full_opset).)</source>
          <target state="translated">В контексте списка возвращает список всех имен операторов.(Пока не реализовано,используйте @names=opset_to_ops(full_opset)).</target>
        </trans-unit>
        <trans-unit id="b5d9986ae8bd12e0cac8222f9f5aeaf66d07a75b" translate="yes" xml:space="preserve">
          <source>In a list context it returns the inflation object, &lt;code&gt;$i&lt;/code&gt; , and the</source>
          <target state="translated">В контексте списка он возвращает объект инфляции, &lt;code&gt;$i&lt;/code&gt; , и</target>
        </trans-unit>
        <trans-unit id="145c4668502bd10d7409835c5418f6cbabe20a25" translate="yes" xml:space="preserve">
          <source>In a list context it returns the inflation stream, &lt;code&gt;$i&lt;/code&gt; , and the</source>
          <target state="translated">В контексте списка он возвращает поток инфляции, &lt;code&gt;$i&lt;/code&gt; , и</target>
        </trans-unit>
        <trans-unit id="1cf4f84fa82dd8ae218d529ba322249a8b367063" translate="yes" xml:space="preserve">
          <source>In a list context, &lt;code&gt;extract_quotelike&lt;/code&gt; would return the list</source>
          <target state="translated">В контексте списка &lt;code&gt;extract_quotelike&lt;/code&gt; вернет список</target>
        </trans-unit>
        <trans-unit id="7602890513e241f884402d4ec0723dbc5ab2f461" translate="yes" xml:space="preserve">
          <source>In a list context, all the functions return &lt;code&gt;(&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;,$original_text)&lt;/code&gt; on failure. In a scalar context, failure is indicated by returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (in this case the input text is not modified in any way).</source>
          <target state="translated">В контексте списка все функции возвращают &lt;code&gt;(&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;,$original_text)&lt;/code&gt; в случае ошибки. В скалярном контексте сбой обозначается возвращением &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (в этом случае входной текст никоим образом не изменяется).</target>
        </trans-unit>
        <trans-unit id="9a94ef45d6203b10b750123aea4390fcb5b00e20" translate="yes" xml:space="preserve">
          <source>In a list context, all the subroutines return a list, the first three elements of which are always:</source>
          <target state="translated">В контексте списка все подпрограммы возвращают список,первые три элемента которого всегда:</target>
        </trans-unit>
        <trans-unit id="f3d0f0be64532af27f8e2b721243720c0db92d9a" translate="yes" xml:space="preserve">
          <source>In a list context, an array of 11 elements is returned. The elements are:</source>
          <target state="translated">В контексте списка возвращается массив из 11 элементов.Элементы являются:</target>
        </trans-unit>
        <trans-unit id="8d3d6cbfb7caf07ade67b0cd6e1a9dc2096892c7" translate="yes" xml:space="preserve">
          <source>In a pinch, if you cannot wait for Configure to be educated, or if you have a good hunch of where quux() might be available, you can temporarily try the following:</source>
          <target state="translated">В крайнем случае,если вы не можете дождаться,когда Configure получит образование,или если у вас есть хорошее представление о том,где может быть доступна функция quux(),вы можете временно попробовать следующее:</target>
        </trans-unit>
        <trans-unit id="8692c1987c2bd18d4696b2de38e79ce9a490834f" translate="yes" xml:space="preserve">
          <source>In a real situation, care should be taken that all threads are finished executing before the program exits. That care has &lt;b&gt;not&lt;/b&gt; been taken in these examples in the interest of simplicity. Running these examples</source>
          <target state="translated">В реальной ситуации следует позаботиться о том, чтобы все потоки завершили выполнение до выхода из программы. В этих примерах &lt;b&gt;не&lt;/b&gt; было уделено должного внимания простоте. Запуск этих примеров</target>
        </trans-unit>
        <trans-unit id="81c10dc0ae0ebb18c61b259ddfe6843d666964b7" translate="yes" xml:space="preserve">
          <source>In a reciprocal fashion, an operation provides either a scalar or a list context to each of its arguments. For example, if you say</source>
          <target state="translated">Во взаимном порядке операция предоставляет либо скаляр,либо контекст списка для каждого из своих аргументов.Например,если вы говорите</target>
        </trans-unit>
        <trans-unit id="c78cf6df929776e529a74a77e45234f404202f1c" translate="yes" xml:space="preserve">
          <source>In a regular expression, the backslash can perform one of two tasks: it either takes away the special meaning of the character following it (for instance, &lt;code&gt;\|&lt;/code&gt; matches a vertical bar, it's not an alternation), or it is the start of a backslash or escape sequence.</source>
          <target state="translated">В регулярном выражении обратная косая черта может выполнять одну из двух задач: либо убирать особое значение следующего за ней символа (например, &lt;code&gt;\|&lt;/code&gt; соответствует вертикальной полосе, это не чередование), либо она является началом обратная косая черта или escape-последовательность.</target>
        </trans-unit>
        <trans-unit id="81b5d9cd571e9943815277ab89c7fe545d260e8a" translate="yes" xml:space="preserve">
          <source>In a scalar context &lt;code&gt;deflate&lt;/code&gt; will return &lt;code&gt;$out&lt;/code&gt; only.</source>
          <target state="translated">В скалярном контексте &lt;code&gt;deflate&lt;/code&gt; вернет только &lt;code&gt;$out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d751225aea131e8c18607565afa032c5caedabd6" translate="yes" xml:space="preserve">
          <source>In a scalar context &lt;code&gt;flush&lt;/code&gt; will return &lt;code&gt;$out&lt;/code&gt; only.</source>
          <target state="translated">В скалярном контексте &lt;code&gt;flush&lt;/code&gt; вернет только &lt;code&gt;$out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24a49c87bdb8b460c4017296f34ddb336c87c832" translate="yes" xml:space="preserve">
          <source>In a scalar context it returns the group name.</source>
          <target state="translated">В скалярном контексте возвращает имя группы.</target>
        </trans-unit>
        <trans-unit id="32d6c6f3bf39438d4047ce657137dce5d3577d7c" translate="yes" xml:space="preserve">
          <source>In a scalar context opcodes returns the number of opcodes in this version of perl (around 350 for perl-5.7.0).</source>
          <target state="translated">В скалярном контексте опкоды возвращают количество опкодов в этой версии perl (около 350 для perl-5.7.0).</target>
        </trans-unit>
        <trans-unit id="208f6e20787f24b907ff451f1741888a45d23759" translate="yes" xml:space="preserve">
          <source>In a scalar context the method returns the number of values associated with the key, &lt;code&gt;$key&lt;/code&gt; .</source>
          <target state="translated">В скалярном контексте метод возвращает количество значений, связанных с ключом &lt;code&gt;$key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cec0bad3cd5e75ede69094662ac02e11b4300440" translate="yes" xml:space="preserve">
          <source>In a scalar context the new socket is returned, or undef upon failure. In a list context a two-element array is returned containing the new socket and the peer address; the list will be empty upon failure.</source>
          <target state="translated">В контексте скаляра новое гнездо возвращается или не возвращается при отказе.В контексте списка возвращается двухэлементный массив,содержащий новый сокет и одноранговый адрес;при отказе список будет пустым.</target>
        </trans-unit>
        <trans-unit id="92d1e3370613f74b8985a6b3b39b4a2c46223d16" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_quotelike&lt;/code&gt; returns just the complete substring that matched a quotelike operation (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on failure). In a scalar or void context, the input text has the same substring (and any specified prefix) removed.</source>
          <target state="translated">В скалярном контексте &lt;code&gt;extract_quotelike&lt;/code&gt; возвращает только полную подстроку, которая соответствует операции кавычки (или &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в случае неудачи). В скалярном или пустом контексте из входного текста удаляется одна и та же подстрока (и любой указанный префикс).</target>
        </trans-unit>
        <trans-unit id="b5b8dc86dc00a1f2952c9a2e48c451d832e4c066" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_tagged&lt;/code&gt; returns just the complete substring that matched a tagged text (including the start and end tags). &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned on failure. In addition, the original input text has the returned substring (and any prefix) removed from it.</source>
          <target state="translated">В скалярном контексте &lt;code&gt;extract_tagged&lt;/code&gt; возвращает только полную подстроку, которая соответствует тексту с тегами (включая начальный и конечный теги). &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; возвращается в случае неудачи. Кроме того, из исходного входного текста удалена возвращенная подстрока (и любой префикс).</target>
        </trans-unit>
        <trans-unit id="f9900a2af209760381e75d8f7a14615b5a9bdbec" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_variable&lt;/code&gt; returns just the complete substring that matched a variablish expression. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned on failure. In addition, the original input text has the returned substring (and any prefix) removed from it.</source>
          <target state="translated">В скалярном контексте &lt;code&gt;extract_variable&lt;/code&gt; возвращает только полную подстроку, которая соответствует выражению variablish. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; возвращается в случае неудачи. Кроме того, из исходного входного текста удалена возвращенная подстрока (и любой префикс).</target>
        </trans-unit>
        <trans-unit id="945278245cb407350f6bc45cb3b502fc5ad85d58" translate="yes" xml:space="preserve">
          <source>In a scalar context, just the extracted substring is returned. In a void context, the extracted substring (and any prefix) are simply removed from the beginning of the first argument.</source>
          <target state="translated">В скалярном контексте возвращается только извлеченная подстрока.В пустом контексте извлеченная подстрока (и любой префикс)просто удаляется из начала первого аргумента.</target>
        </trans-unit>
        <trans-unit id="7e3e24a2a724494140e588e3803a95e574330808" translate="yes" xml:space="preserve">
          <source>In a scalar context, the extracted string is returned, having first been removed from the input text. Thus, the following code also processes each quote-like operation, but actually removes them from $text:</source>
          <target state="translated">В скалярном контексте возвращается извлеченная строка,впервые удаленная из входного текста.Таким образом,следующий код также обрабатывает каждую котировочную операцию,но фактически удаляет их из $текста:</target>
        </trans-unit>
        <trans-unit id="0d5544cfc850136e8726fbbd9c72234c9b7ae747" translate="yes" xml:space="preserve">
          <source>In a sense, perl (the C program) is a good example of embedding Perl (the language), so I'll demonstrate embedding with</source>
          <target state="translated">В некотором смысле,Perl (программа на С)является хорошим примером встраивания Perl (язык),поэтому я продемонстрирую встраивание с помощью</target>
        </trans-unit>
        <trans-unit id="ff595beb69ecf8f38b6337a9d03b24a9b262246c" translate="yes" xml:space="preserve">
          <source>In a similar fashion, overriding the &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; function also overrides the equivalent I/O operator &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt; . Also, overriding &lt;code&gt;&lt;a href=&quot;functions/readpipe&quot;&gt;readpipe&lt;/a&gt;&lt;/code&gt; also overrides the operators &lt;code&gt;``&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Аналогичным образом переопределение функции &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; также отменяет эквивалентный оператор ввода-вывода &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt; . Кроме того, переопределение &lt;code&gt;&lt;a href=&quot;functions/readpipe&quot;&gt;readpipe&lt;/a&gt;&lt;/code&gt; также отменяет операторы &lt;code&gt;``&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d250c896d3f5eb11d7a648b3bc78f5925e2fcce" translate="yes" xml:space="preserve">
          <source>In a void context the behaviour of the extraction subroutines is exactly the same as in a scalar context, except (of course) that the extracted substring is not returned.</source>
          <target state="translated">В пустом контексте поведение подпрограмм извлечения точно такое же,как и в скалярном,за исключением (разумеется)того,что извлеченная подстрока не возвращается.</target>
        </trans-unit>
        <trans-unit id="164ac7c993944f12e7319a81a34bfbc9042d71d4" translate="yes" xml:space="preserve">
          <source>In a void context, the input text just has the matched substring (and any specified prefix) removed.</source>
          <target state="translated">В контексте пустоты во входном тексте просто удаляется соответствующая подстрока (и любой указанный префикс).</target>
        </trans-unit>
        <trans-unit id="a9b13f420194df675e5068f5af3ab2ba48ac53e8" translate="yes" xml:space="preserve">
          <source>In a word - don't, at least not without a *very* good reason. Your scripts can just as easily begin with &quot;#!/usr/local/bin/perl&quot; as with &quot;#!/usr/bin/perl&quot;. Scripts supplied by Apple and other third parties as part of installation packages and such have generally only been tested with the /usr/bin/perl that's installed by Apple.</source>
          <target state="translated">Одним словом-не надо,по крайней мере,без *очень*веской причины.Ваши скрипты могут так же легко начать с &quot;#!/usr/local/bin/perl&quot;,как и с &quot;#!/usr/bin/perl&quot;.Скрипты,поставляемые Apple и другими сторонними разработчиками как часть установочных пакетов,и,как правило,проверялись только с помощью /usr/bin/perl,который установлен Apple.</target>
        </trans-unit>
        <trans-unit id="fcf1ea0b348743b5d23b285ecea8c108896961cc" translate="yes" xml:space="preserve">
          <source>In academia, a curriculum vit&amp;aelig;, a fancy kind of r&amp;eacute;sum&amp;eacute;. In Perl, an internal &amp;ldquo;code value&amp;rdquo; typedef holding a &lt;b&gt;subroutine&lt;/b&gt;. The &lt;code&gt;CV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">В академических кругах это curriculum vit&amp;aelig;, причудливое резюме. В Perl - внутреннее определение typedef &amp;laquo;кодового значения&amp;raquo;, содержащее &lt;b&gt;подпрограмму&lt;/b&gt; . Тип &lt;code&gt;CV&lt;/code&gt; является подклассом &lt;b&gt;SV&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b2f52867b2f837c43cc5640194de947dbf1e2090" translate="yes" xml:space="preserve">
          <source>In actuality, the period and &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations are themselves types of character classes, so the ones surrounded by brackets are just one type of character class. When we need to make a distinction, we refer to them as &quot;bracketed character classes.&quot;</source>
          <target state="translated">На самом деле, период и аббревиатуры &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; сами по себе являются типами классов символов, поэтому те, которые заключены в квадратные скобки, являются лишь одним типом классов символов. Когда нам нужно провести различие, мы называем их &amp;laquo;классами символов в квадратных скобках&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="46e3a38016d86ba7214b26757c2cfc95f05dd8d8" translate="yes" xml:space="preserve">
          <source>In addition</source>
          <target state="translated">Кроме того</target>
        </trans-unit>
        <trans-unit id="7e82af699df6da7e07e9ea8a98307994127655f1" translate="yes" xml:space="preserve">
          <source>In addition EXTEND will be called when perl would have pre-extended allocation in a real array.</source>
          <target state="translated">Кроме того,будет вызван EXTEND,когда perl будет иметь расширенное выделение в реальном массиве.</target>
        </trans-unit>
        <trans-unit id="ed2d1a9f24dc62aaee4efacb9df22dbcc5333d73" translate="yes" xml:space="preserve">
          <source>In addition it contains two fields that are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and &lt;code&gt;pprivate&lt;/code&gt; members. &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure, whose use and management is the responsibility of the compiling engine. Perl will never modify either of these values.</source>
          <target state="translated">Кроме того, он содержит два поля, предназначенных для частного использования обработчиком регулярных выражений, который скомпилировал шаблон. Это члены &lt;code&gt;intflags&lt;/code&gt; и &lt;code&gt;pprivate&lt;/code&gt; . &lt;code&gt;pprivate&lt;/code&gt; - это пустой указатель на произвольную структуру, за использование и управление которой отвечает механизм компиляции. Perl никогда не будет изменять ни одно из этих значений.</target>
        </trans-unit>
        <trans-unit id="7aa9ca3525844fd7a1f1f038ab777e0241661c46" translate="yes" xml:space="preserve">
          <source>In addition it contains two fields that are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values.</source>
          <target state="translated">Кроме того, он содержит два поля, предназначенных для частного использования обработчиком регулярных выражений, который скомпилировал шаблон. Это члены &lt;code&gt;intflags&lt;/code&gt; и pprivate. &lt;code&gt;pprivate&lt;/code&gt; является недействительным указателем на произвольную структуру, использование которых и управление является ответственностью компилирования двигателя. perl никогда не изменит ни одно из этих значений.</target>
        </trans-unit>
        <trans-unit id="152b5f495da9efbec00e14f0ef1bc85e80c4a061" translate="yes" xml:space="preserve">
          <source>In addition to &lt;b&gt;scripts&lt;/b&gt;, Unicode also defines &lt;b&gt;blocks&lt;/b&gt; of characters. The difference between scripts and blocks is that the concept of scripts is closer to natural languages, while the concept of blocks is more of an artificial grouping based on groups of Unicode characters with consecutive ordinal values. For example, the &lt;code&gt;&quot;Basic Latin&quot;&lt;/code&gt; block is all the characters whose ordinals are between 0 and 127, inclusive; in other words, the ASCII characters. The &lt;code&gt;&quot;Latin&quot;&lt;/code&gt; script contains some letters from this as well as several other blocks, like &lt;code&gt;&quot;Latin-1 Supplement&quot;&lt;/code&gt; , &lt;code&gt;&quot;Latin Extended-A&quot;&lt;/code&gt; ,</source>
          <target state="translated">В дополнение к &lt;b&gt;сценариям&lt;/b&gt; Unicode также определяет &lt;b&gt;блоки&lt;/b&gt; символов. Разница между скриптами и блоками заключается в том, что концепция скриптов ближе к естественным языкам, тогда как концепция блоков представляет собой скорее искусственную группировку, основанную на группах символов Unicode с последовательными порядковыми значениями. Например, блок &lt;code&gt;&quot;Basic Latin&quot;&lt;/code&gt; - это все символы, порядковые номера которых находятся от 0 до 127 включительно; другими словами, символы ASCII. &lt;code&gt;&quot;Latin&quot;&lt;/code&gt; сценарий содержит некоторые буквы из этого, а также нескольких других блоков, как &lt;code&gt;&quot;Latin-1 Supplement&quot;&lt;/code&gt; , &lt;code&gt;&quot;Latin Extended-A&quot;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="f86a4eaf10c727caafeb64d3a643f53ff65e9454" translate="yes" xml:space="preserve">
          <source>In addition to adding seconds, there are two APIs for adding months and years:</source>
          <target state="translated">В дополнение к добавлению секунд,есть два API для добавления месяцев и лет:</target>
        </trans-unit>
        <trans-unit id="b2fd5a60f4cdde51801210d2d64a0096f9f11eee" translate="yes" xml:space="preserve">
          <source>In addition to an editor/IDE you might be interested in a more powerful shell environment for Win32. Your options include</source>
          <target state="translated">В дополнение к редактору/IDE вас может заинтересовать более мощная оболочка для Win32.Ваши опции включают в себя</target>
        </trans-unit>
        <trans-unit id="1749590c161975b92597e609a16d593c1ab667da" translate="yes" xml:space="preserve">
          <source>In addition to being Unix, we're U/WIN.</source>
          <target state="translated">Помимо того,что мы Unix,мы U/WIN.</target>
        </trans-unit>
        <trans-unit id="59ad52f794c0c2f95e95db00a5db4b0758359fc7" translate="yes" xml:space="preserve">
          <source>In addition to computing what you expected, the last example also does &lt;b&gt;not&lt;/b&gt; &quot;taint&quot; the result with an accuracy or precision setting, which would influence any further operation.</source>
          <target state="translated">В дополнение к вычислению того, что вы ожидали, последний пример также &lt;b&gt;не&lt;/b&gt; &quot;искажает&quot; результат точностью или настройкой точности, которая могла бы повлиять на любую дальнейшую операцию.</target>
        </trans-unit>
        <trans-unit id="ae2d9c47551f30ac79ac4fb8a4a7835684b54313" translate="yes" xml:space="preserve">
          <source>In addition to fields allowed in pack(), you may prefix a field with a %&amp;lt;number&amp;gt; to indicate that you want a &amp;lt;number&amp;gt;-bit checksum of the items instead of the items themselves. Default is a 16-bit checksum. Checksum is calculated by summing numeric values of expanded values (for string fields the sum of &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; is taken; for bit fields the sum of zeroes and ones).</source>
          <target state="translated">В дополнение к полям, разрешенным в pack (), вы можете добавить к полю префикс% &amp;lt;number&amp;gt;, чтобы указать, что вам нужна &amp;lt;number&amp;gt; -битовая контрольная сумма элементов вместо самих элементов. По умолчанию - 16-битная контрольная сумма. Контрольная сумма вычисляется путем суммирования числовых значений развернутых значений (для строковых полей берется сумма &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; ; для битовых полей сумма нулей и единиц).</target>
        </trans-unit>
        <trans-unit id="8fab1ee4cfb63b6e2e7d76c7cfd5888f6ab2e679" translate="yes" xml:space="preserve">
          <source>In addition to fields allowed in pack(), you may prefix a field with a %&amp;lt;number&amp;gt; to indicate that you want a &amp;lt;number&amp;gt;-bit checksum of the items instead of the items themselves. Default is a 16-bit checksum. Checksum is calculated by summing numeric values of expanded values (for string fields the sum of &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; is taken; for bit fields the sum of zeroes and ones).</source>
          <target state="translated">В дополнение к полям, разрешенным в pack (), вы можете добавить к полю префикс% &amp;lt;number&amp;gt;, чтобы указать, что вам нужна &amp;lt;number&amp;gt; -битовая контрольная сумма элементов вместо самих элементов. По умолчанию - 16-битная контрольная сумма. Контрольная сумма вычисляется путем суммирования числовых значений развернутых значений (для строковых полей берется сумма &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; ; для битовых полей сумма нулей и единиц).</target>
        </trans-unit>
        <trans-unit id="40ec63aed202427c78ae99bf79365c2b0344aea9" translate="yes" xml:space="preserve">
          <source>In addition to interacting with the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern, &lt;code&gt;(*MARK:NAME)&lt;/code&gt; can be used to &quot;label&quot; a pattern branch, so that after matching, the program can determine which branches of the pattern were involved in the match.</source>
          <target state="translated">В дополнение к взаимодействию с шаблоном &lt;code&gt;(*SKIP)&lt;/code&gt; , &lt;code&gt;(*MARK:NAME)&lt;/code&gt; может использоваться для &amp;laquo;пометки&amp;raquo; ветви шаблона, чтобы после сопоставления программа могла определить, какие ветви шаблона были задействованы в сопоставлении.</target>
        </trans-unit>
        <trans-unit id="cea68ca5519ffc8129501826ad0bb9062eef1e64" translate="yes" xml:space="preserve">
          <source>In addition to possible bugs and an inability to follow changes to the translation policy with off/on switches of TERMIO translation, this introduces a serious incompatible change: before sysread() on text-mode filehandles would go through the translation layer, now it would not.</source>
          <target state="translated">В дополнение к возможным ошибкам и невозможности следить за изменениями в политике перевода при выключении/включении переключателей перевода TERMIO,это вносит серьезное несовместимое изменение:раньше sysread()на файловых дескрипторах текстового режима проходила через переводческий уровень,теперь нет.</target>
        </trans-unit>
        <trans-unit id="d4d69cf9bd1e25a37f285dc63efc29fb797f0fe0" translate="yes" xml:space="preserve">
          <source>In addition to standard-like API defined so far above there is an &quot;implementation&quot; interface which allows perl to get at internals of PerlIO. The following calls correspond to the various FILE_xxx macros determined by Configure - or their equivalent in other implementations. This section is really of interest to only those concerned with detailed perl-core behaviour, implementing a PerlIO mapping or writing code which can make use of the &quot;read ahead&quot; that has been done by the IO system in the same way perl does. Note that any code that uses these interfaces must be prepared to do things the traditional way if a handle does not support them.</source>
          <target state="translated">В дополнение к стандартному API,описанному выше,существует &quot;имплементационный&quot; интерфейс,позволяющий perl попасть во внутреннюю часть PerlIO.Следующие вызовы соответствуют различным макросам FILE_xxx,определенным Configure-или их эквивалентам в других реализациях.Этот раздел действительно представляет интерес только для тех,кто занимается детализацией поведения perl-ядер,реализацией PerlIO-разметки или написанием кода,который может использовать &quot;read ahead&quot;,что было сделано системой ввода-вывода аналогично тому,как это делает perl.Заметьте,что любой код,использующий эти интерфейсы,должен быть готов к традиционным вещам,если дескриптор не поддерживает их.</target>
        </trans-unit>
        <trans-unit id="17eaea3931a67cb37ce8cb0cb3c4e8d09398b8c0" translate="yes" xml:space="preserve">
          <source>In addition to the MEDIUM security checks, also check for the possibility of ``chown() giveaway'' using the L</source>
          <target state="translated">В дополнение к проверке безопасности MEDIUM,также проверьте возможность ``дачи'',используя L</target>
        </trans-unit>
        <trans-unit id="89182cb06f6668d208e0619e4cbe15cde7591879" translate="yes" xml:space="preserve">
          <source>In addition to the OVERLOAD keyword, if you need to control how Perl autogenerates missing overloaded operators, you can set the FALLBACK keyword in the module header section, like this:</source>
          <target state="translated">В дополнение к ключевому слову OVERLOAD,если вам нужно контролировать,как Perl автогенерирует отсутствующие перегруженные операторы,вы можете установить ключевое слово FALLBACK в разделе заголовка модуля,например,так:</target>
        </trans-unit>
        <trans-unit id="cf43e38422f03f19f7c8bc12dfe3cf7238322b4f" translate="yes" xml:space="preserve">
          <source>In addition to the STANDARD security, the output directory is checked to make sure that it is owned either by root or the user running the program. If the directory is writable by group or by other, it is then checked to make sure that the sticky bit is set.</source>
          <target state="translated">В дополнение к безопасности STANDARD проверяется выходной каталог,чтобы удостовериться,что он принадлежит либо корневому пользователю,либо пользователю,выполняющему программу.Если каталог может быть записан группой или другим пользователем,то он проверяется,чтобы удостовериться,что установлен липкий бит.</target>
        </trans-unit>
        <trans-unit id="a6827bb11452b38549da194a0e9f946e676fb6ab" translate="yes" xml:space="preserve">
          <source>In addition to the compiler flags used to select the SDK, also add the flags for creating a universal binary:</source>
          <target state="translated">В дополнение к флагам компилятора,используемым для выбора SDK,добавьте также флаги для создания универсального бинарного файла:</target>
        </trans-unit>
        <trans-unit id="73c76010fe3f7536529c60cd357cfa7c8e4a0b21" translate="yes" xml:space="preserve">
          <source>In addition to the different levels of OS involvement in threads, different OSes (and different thread implementations for a particular OS) allocate CPU cycles to threads in different ways.</source>
          <target state="translated">В дополнение к различным уровням участия операционных систем в потоках,различные операционные системы (и различные поточные реализации для конкретной операционной системы)по-разному распределяют циклы процессора по потокам.</target>
        </trans-unit>
        <trans-unit id="79a96fb0aa6c1ca892c14d42638abd6240d03e9c" translate="yes" xml:space="preserve">
          <source>In addition to the file and subroutine-related variables mentioned above, the debugger also maintains various magical internal variables.</source>
          <target state="translated">Кроме файловых и подпрограммных переменных,упомянутых выше,отладчик также поддерживает различные магические внутренние переменные.</target>
        </trans-unit>
        <trans-unit id="bab0de29db31c89ae8ab9839888cf6f1bf406c03" translate="yes" xml:space="preserve">
          <source>In addition to the key-value pairs accepted by &lt;a href=&quot;../socket&quot;&gt;IO::Socket&lt;/a&gt;, &lt;code&gt;IO::Socket::INET&lt;/code&gt; provides.</source>
          <target state="translated">В дополнение к парам &quot;ключ-значение&quot;, принятым &lt;a href=&quot;../socket&quot;&gt;IO :: Socket&lt;/a&gt; , &lt;code&gt;IO::Socket::INET&lt;/code&gt; предоставляет.</target>
        </trans-unit>
        <trans-unit id="7a72b31c557cda8bc1b722b2e6a26c2c901af09d" translate="yes" xml:space="preserve">
          <source>In addition to the key-value pairs accepted by &lt;a href=&quot;../socket&quot;&gt;IO::Socket&lt;/a&gt;, &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; provides.</source>
          <target state="translated">В дополнение к парам ключ-значение, принятым &lt;a href=&quot;../socket&quot;&gt;IO :: Socket&lt;/a&gt; , &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; предоставляет.</target>
        </trans-unit>
        <trans-unit id="7c45e877ad35106ffbe7de68a1cdc70a047e523f" translate="yes" xml:space="preserve">
          <source>In addition to the metacharacters, there are some ASCII characters which don't have printable character equivalents and are instead represented by</source>
          <target state="translated">В дополнение к мета-символам,существуют некоторые ASCII-символы,которые не имеют печатаемых эквивалентов символов и вместо этого представлены следующим образом</target>
        </trans-unit>
        <trans-unit id="08676326b07558d72976a15d2e5ea67b5354d4ab" translate="yes" xml:space="preserve">
          <source>In addition to the perl API described above, a C API is available for extension writers. The following C functions are available in the modglobal hash:</source>
          <target state="translated">В дополнение к описанному выше perl API,для разработчиков расширений доступен C API.Следующие функции C доступны в модглобальном хэше:</target>
        </trans-unit>
        <trans-unit id="ef88c015cd90a62555639afdea15aa945900339f" translate="yes" xml:space="preserve">
          <source>In addition to the quote delimiters &lt;code&gt;'&lt;/code&gt;, &lt;code&gt;&quot;&lt;/code&gt;, and &lt;code&gt;`&lt;/code&gt;, full Perl quote-like quoting (i.e. q{string}, qq{string}, etc) can be specified by including the letter 'q' as a delimiter. Hence:</source>
          <target state="translated">В дополнении к кавычкам &lt;code&gt;'&lt;/code&gt; , &lt;code&gt;&quot;&lt;/code&gt; и &lt;code&gt;`&lt;/code&gt; , полный Perl цитата, как процитировать (т.е. Q {строку}, {кв. строки}, и т.д.) может быть определена путем включения буквы&amp;bdquo;Q&amp;ldquo; в качестве разделителя Следовательно.:</target>
        </trans-unit>
        <trans-unit id="3ee26c7c2937194436d9d08c9a82ea42e06abcd1" translate="yes" xml:space="preserve">
          <source>In addition to the six exported functions there exists one function that can only be accessed with a fully qualified function call.</source>
          <target state="translated">В дополнение к шести экспортированным функциям существует одна функция,доступ к которой возможен только при полностью квалифицированном вызове функции.</target>
        </trans-unit>
        <trans-unit id="1fd0fd0dfb0a01af1b34dd0a74cf43897f0a81ea" translate="yes" xml:space="preserve">
          <source>In addition to the tie() interface, it is also possible to access most of the functions provided in the Berkeley DB API directly. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;THE API INTERFACE&lt;/a&gt;.</source>
          <target state="translated">Помимо интерфейса tie (), также можно получить доступ к большинству функций, предоставляемых в API Berkeley DB напрямую. См. &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;ИНТЕРФЕЙС API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53b1ffa79f559c5952d0b2eca922c0eb1fe018a7" translate="yes" xml:space="preserve">
          <source>In addition to the traditional Perl default MRO (depth first search, called &lt;code&gt;DFS&lt;/code&gt; here), Perl now offers the C3 MRO as well. Perl's support for C3 is based on the work done in Stevan Little's module &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class::C3&lt;/a&gt;, and most of the C3-related documentation here is ripped directly from there.</source>
          <target state="translated">В дополнение к традиционному MRO Perl по умолчанию (поиск в глубину, называемый здесь &lt;code&gt;DFS&lt;/code&gt; ), Perl теперь также предлагает C3 MRO. Поддержка Perl для C3 основана на работе, проделанной в модуле Stevan Little &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class :: C3&lt;/a&gt; , и большая часть документации, относящейся к C3, взята прямо оттуда.</target>
        </trans-unit>
        <trans-unit id="8eca212407dc344e58d9927ac55df67e502679ba" translate="yes" xml:space="preserve">
          <source>In addition to the two arrays that form the inversion map, &lt;code&gt;prop_invmap&lt;/code&gt; returns two other values; one is a scalar that gives some details as to the format of the entries of the map array; the other is a default value, useful in maps whose format name begins with the letter &lt;code&gt;&quot;a&quot;&lt;/code&gt; , as described &lt;a href=&quot;#a&quot;&gt;below in its subsection&lt;/a&gt;; and for specialized purposes, such as converting to another data structure, described at the end of this main section.</source>
          <target state="translated">В дополнение к двум массивам, которые формируют карту инверсии, &lt;code&gt;prop_invmap&lt;/code&gt; возвращает два других значения; один - скаляр, который дает некоторые детали относительно формата записей массива карты; другой - значение по умолчанию, полезное для карт, название формата которых начинается с буквы &lt;code&gt;&quot;a&quot;&lt;/code&gt; , как описано &lt;a href=&quot;#a&quot;&gt;ниже в соответствующем подразделе&lt;/a&gt; ; и для специальных целей, таких как преобразование в другую структуру данных, описанную в конце этого основного раздела.</target>
        </trans-unit>
        <trans-unit id="dab2897e25695e7867181ff90ba23794c8c60c0d" translate="yes" xml:space="preserve">
          <source>In addition to using the &lt;code&gt;\p{Blk=...}&lt;/code&gt; and &lt;code&gt;\P{Blk=...}&lt;/code&gt; constructs, you can also test whether a code point is in the</source>
          <target state="translated">Помимо использования конструкций &lt;code&gt;\p{Blk=...}&lt;/code&gt; и &lt;code&gt;\P{Blk=...}&lt;/code&gt; , вы также можете проверить, находится ли кодовая точка в</target>
        </trans-unit>
        <trans-unit id="dac7bc321eb3333dc44a14f1d9acf1fbd74fd29b" translate="yes" xml:space="preserve">
          <source>In addition to what was matched, Perl also provides the positions of what was matched as contents of the &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; arrays. &lt;code&gt;$-[0]&lt;/code&gt; is the position of the start of the entire match and &lt;code&gt;$+[0]&lt;/code&gt; is the position of the end. Similarly, &lt;code&gt;$-[n]&lt;/code&gt; is the position of the start of the &lt;code&gt;$n&lt;/code&gt; match and &lt;code&gt;$+[n]&lt;/code&gt; is the position of the end. If &lt;code&gt;$n&lt;/code&gt; is undefined, so are &lt;code&gt;$-[n]&lt;/code&gt; and &lt;code&gt;$+[n]&lt;/code&gt; . Then this code</source>
          <target state="translated">В дополнение к тому, что было сопоставлено, Perl также предоставляет позиции того, что было сопоставлено, как содержимое массивов &lt;code&gt;@-&lt;/code&gt; и &lt;code&gt;@+&lt;/code&gt; . &lt;code&gt;$-[0]&lt;/code&gt; - это позиция начала всего совпадения, а &lt;code&gt;$+[0]&lt;/code&gt; - позиция конца. Аналогично, &lt;code&gt;$-[n]&lt;/code&gt; - это позиция начала совпадения &lt;code&gt;$n&lt;/code&gt; а &lt;code&gt;$+[n]&lt;/code&gt; - позиция конца. Если &lt;code&gt;$n&lt;/code&gt; не определено, равны &lt;code&gt;$-[n]&lt;/code&gt; и &lt;code&gt;$+[n]&lt;/code&gt; . Тогда этот код</target>
        </trans-unit>
        <trans-unit id="340df59f8245bd9d352756a2f3fe84ca2ba2b14a" translate="yes" xml:space="preserve">
          <source>In addition, Perl defines the following:</source>
          <target state="translated">Кроме того,Perl определяет следующее:</target>
        </trans-unit>
        <trans-unit id="7b18dfd70f7fb70cb969c8b7231702490b8ef572" translate="yes" xml:space="preserve">
          <source>In addition, Perl permits the following widely-supported conversions:</source>
          <target state="translated">Кроме того,Perl допускает следующие широко поддерживаемые преобразования:</target>
        </trans-unit>
        <trans-unit id="58a30b45039ea55ccfbff7c03b534706dd5f4a4e" translate="yes" xml:space="preserve">
          <source>In addition, a second package variable (&lt;code&gt;@Filter::Simple::components&lt;/code&gt; ) contains a list of the various pieces of &lt;code&gt;$_&lt;/code&gt; , as they were originally split up to allow placeholders to be inserted.</source>
          <target state="translated">Кроме того, вторая переменная пакета ( &lt;code&gt;@Filter::Simple::components&lt;/code&gt; ) содержит список различных частей &lt;code&gt;$_&lt;/code&gt; , поскольку они изначально были разделены, чтобы можно было вставить заполнители.</target>
        </trans-unit>
        <trans-unit id="8b824cddab0454f6fa746f5f5efb2df055e6a062" translate="yes" xml:space="preserve">
          <source>In addition, an attempt is made to recognize several common Unix library names, and filter them out or convert them to their VMS equivalents, as appropriate.</source>
          <target state="translated">Кроме того,делается попытка распознать несколько общих имен Unix-библиотек и,при необходимости,отфильтровать их или преобразовать в их эквиваленты VMS.</target>
        </trans-unit>
        <trans-unit id="20f0764c130ac7b7bb4ff76a14f2a6cf3a71b811" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a simple filename, the default values for the &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options will be sourced from that file.</source>
          <target state="translated">Кроме того, если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; - простое имя файла, значения по умолчанию для параметров &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; и &lt;code&gt;exTime&lt;/code&gt; будут взяты из этого файла.</target>
        </trans-unit>
        <trans-unit id="bdc3e8410e98f27c3f135fcd34c0e133beddff18" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a simple filename, the default values for the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt; options will be sourced from that file.</source>
          <target state="translated">Кроме того, если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; - простое имя файла, значения по умолчанию для параметров &lt;code&gt;Name&lt;/code&gt; и &lt;code&gt;Time&lt;/code&gt; будут взяты из этого файла.</target>
        </trans-unit>
        <trans-unit id="91ed0a2f179c5ac2d45e1e913820f71e61b32911" translate="yes" xml:space="preserve">
          <source>In addition, if the input file/buffer does contain compressed data and there is non-compressed data immediately following it, setting this option will make this module treat the whole file/buffer as a single data stream.</source>
          <target state="translated">Кроме того,если входной файл/буфер содержит сжатые данные,а за ним сразу же следуют несжатые данные,установка этой опции заставит этот модуль рассматривать весь файл/буфер как единый поток данных.</target>
        </trans-unit>
        <trans-unit id="a03250cf8d36596835773013a7ed159131abe9f9" translate="yes" xml:space="preserve">
          <source>In addition, on failure in</source>
          <target state="translated">Кроме того,при неудаче</target>
        </trans-unit>
        <trans-unit id="289227a7d3ba6bcbce57645ed49463f1d7e46764" translate="yes" xml:space="preserve">
          <source>In addition, other &lt;a href=&quot;getopt/long&quot;&gt;Getopt::Long&lt;/a&gt; error messages may result from invalid command-line options.</source>
          <target state="translated">Кроме того, другие сообщения об ошибках &lt;a href=&quot;getopt/long&quot;&gt;Getopt :: Long&lt;/a&gt; могут возникать из-за неверных параметров командной строки.</target>
        </trans-unit>
        <trans-unit id="147a39b11e58c10277c6a279d8224a769b9bb498" translate="yes" xml:space="preserve">
          <source>In addition, output may be piped to a subprocess, using the character '|'. Anything after this character on the command line is passed to a subprocess for execution; the subprocess takes the output of Perl as its input.</source>
          <target state="translated">Кроме того,вывод может быть передан в подпроцесс,используя символ '|'.Все,что после этого символа в командной строке передается в подпроцесс на исполнение,подпроцесс принимает на вход вывод Perl.</target>
        </trans-unit>
        <trans-unit id="99121fa175239d30527a66db54352aec9e7f4845" translate="yes" xml:space="preserve">
          <source>In addition, plenty of code in the wild does all of its OO &quot;by hand&quot;, using just the Perl built-in OO features. If you need to maintain such code, you should read &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; to understand exactly how Perl's built-in OO works.</source>
          <target state="translated">Вдобавок, множество программных кодов выполняет все объектно-ориентированные операции &amp;laquo;вручную&amp;raquo;, используя только встроенные в Perl функции объектно-ориентированного программирования. Если вам нужно поддерживать такой код, вам следует прочитать &lt;a href=&quot;perlobj&quot;&gt;perlobj,&lt;/a&gt; чтобы точно понять, как работает объектно- ориентированный объект , встроенный в Perl.</target>
        </trans-unit>
        <trans-unit id="df2c5f9f6d74347865f1b7d8c718b9166dce24c6" translate="yes" xml:space="preserve">
          <source>In addition, subroutines are named with an initial '&amp;amp;', though this is optional when unambiguous, just as the word &quot;do&quot; is often redundant in English. Symbol table entries can be named with an initial '*', but you don't really care about that yet (if ever :-).</source>
          <target state="translated">Кроме того, имена подпрограмм начинаются с символа &amp;laquo;&amp;amp;&amp;raquo;, хотя это необязательно, если оно недвусмысленно, так же как слово &amp;laquo;do&amp;raquo; часто бывает избыточным в английском языке. Записи в таблице символов могут быть названы с начального символа '*', но вас это пока не волнует (если вообще когда-либо :-).</target>
        </trans-unit>
        <trans-unit id="e4639b7e9ac66cd60ee8c3525c4580bbed98b234" translate="yes" xml:space="preserve">
          <source>In addition, the generated &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine passes its own argument list to the filtering subroutine, so the BANG.pm filter could easily be made parametric:</source>
          <target state="translated">Кроме того, сгенерированная подпрограмма &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; передает свой собственный список аргументов подпрограмме фильтрации, поэтому фильтр BANG.pm можно легко сделать параметрическим:</target>
        </trans-unit>
        <trans-unit id="3e36eb4b4d16be01e13411f12c4f853328d8d124" translate="yes" xml:space="preserve">
          <source>In addition, the returned value will be unique within the context of the Pod::Simple::XHTML object unless a second argument is passed a true value. ID attributes should always be unique within a single XHTML document, but pass the true value if you are creating not an ID but a URL hash to point to an ID (i.e., if you need to put the &quot;#foo&quot; in &lt;code&gt;&amp;lt;a href=&quot;#foo&quot;&amp;gt;foo&amp;lt;/a&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Кроме того, возвращаемое значение будет уникальным в контексте объекта Pod :: Simple :: XHTML, если второму аргументу не будет передано истинное значение. Атрибуты идентификатора всегда должны быть уникальными в пределах одного документа XHTML, но передавать истинное значение, если вы создаете не идентификатор, а хэш URL-адреса, указывающий на идентификатор (т. Е. Если вам нужно поместить &quot;#foo&quot; в &lt;code&gt;&amp;lt;a href=&quot;#foo&quot;&amp;gt;foo&amp;lt;/a&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de0edea48e0434c59597ceff4d726d410f442fce" translate="yes" xml:space="preserve">
          <source>In addition, when ldopts is called with parameters, it will return the argument string rather than print it to STDOUT.</source>
          <target state="translated">Кроме того,когда ldopts вызывается с параметрами,он возвращает строку аргумента вместо того,чтобы распечатать ее в STDOUT.</target>
        </trans-unit>
        <trans-unit id="0fe8a6e2911b84e5bf182d375e70d71ebf4dcde5" translate="yes" xml:space="preserve">
          <source>In all Perl versions you can use &lt;code&gt;as_number()&lt;/code&gt; or &lt;code&gt;as_int&lt;/code&gt; for the same effect:</source>
          <target state="translated">Во всех версиях Perl вы можете использовать &lt;code&gt;as_number()&lt;/code&gt; или &lt;code&gt;as_int&lt;/code&gt; для того же эффекта:</target>
        </trans-unit>
        <trans-unit id="9a826c545f2fecb5bd50e173dbd7f3d696f12f03" translate="yes" xml:space="preserve">
          <source>In all Perl versions, &lt;code&gt;\s&lt;/code&gt; matches the 5 characters [\t\n\f\r ]; that is, the horizontal tab, the newline, the form feed, the carriage return, and the space. Starting in Perl v5.18, it also matches the vertical tab, &lt;code&gt;\cK&lt;/code&gt; . See note &lt;code&gt;[1]&lt;/code&gt; below for a discussion of this.</source>
          <target state="translated">Во всех версиях Perl &lt;code&gt;\s&lt;/code&gt; соответствует 5 символам [\ t \ n \ f \ r]; то есть горизонтальная табуляция, перевод строки, подача страницы, возврат каретки и пробел. Начиная с Perl v5.18, он также соответствует вертикальной табуляции &lt;code&gt;\cK&lt;/code&gt; . См. Примечание &lt;code&gt;[1]&lt;/code&gt; ниже для обсуждения этого.</target>
        </trans-unit>
        <trans-unit id="781b45f1e32e901ab32d784bb9ee31c8ef4d8da4" translate="yes" xml:space="preserve">
          <source>In all but the most memory-paranoid configurations (ex: PURIFY), heads and bodies are allocated out of arenas, which by default are approximately 4K chunks of memory parcelled up into N heads or bodies. Sv-bodies are allocated by their sv-type, guaranteeing size consistency needed to allocate safely from arrays.</source>
          <target state="translated">Во всех конфигурациях,за исключением большинства памяти-параноидов (например:PURIFY),головы и тела выделяются из арен,которые по умолчанию составляют приблизительно 4K куски памяти,разделенные на N голов или тел.Sv-тела выделяются по их sv-типу,гарантируя согласованность размеров,необходимую для безопасного выделения из массивов.</target>
        </trans-unit>
        <trans-unit id="82cf0166b1026f5214dc5e9dee6752fb9c70f2f9" translate="yes" xml:space="preserve">
          <source>In all cases shown above, the line indentation shows the call tree. If bit 2 of &lt;code&gt;frame&lt;/code&gt; is set, a line is printed on exit from a subroutine as well. If bit 4 is set, the arguments are printed along with the caller info. If bit 8 is set, the arguments are printed even if they are tied or references. If bit 16 is set, the return value is printed, too.</source>
          <target state="translated">Во всех случаях, показанных выше, отступ строки показывает дерево вызовов. Если установлен бит 2 &lt;code&gt;frame&lt;/code&gt; , строка также печатается при выходе из подпрограммы. Если установлен бит 4, аргументы печатаются вместе с информацией о вызывающем абоненте. Если установлен бит 8, аргументы печатаются, даже если они связаны или ссылаются. Если установлен бит 16, также печатается возвращаемое значение.</target>
        </trans-unit>
        <trans-unit id="6061ee2ae8dec0f2b671e0d3e14bae7a6b818d83" translate="yes" xml:space="preserve">
          <source>In all cases where the very common phenomenon of quantification (saying &quot;</source>
          <target state="translated">Во всех случаях,когда очень распространенный феномен количественной оценки (поговорка &quot;</target>
        </trans-unit>
        <trans-unit id="e3c2c7f74b86dde15a7c489ee7be1789b4697e9f" translate="yes" xml:space="preserve">
          <source>In all dealings with contributed modules, everyone maintaining Perl should keep in mind that the code belongs to the original author, that they may not be on perl5-porters at any given time, and that a patch is not official unless it has been integrated into the author's copy of the module. To aid with this, and with points #1, #2, and #3 above, contact information for the authors of all contributed modules should be kept with the Perl distribution.</source>
          <target state="translated">Во всех отношениях с предоставляемыми модулями каждый,кто поддерживает Perl,должен помнить,что код принадлежит первоначальному автору,что они не могут быть на perl5-портерах в любой момент времени,и что патч не является официальным,если только он не был интегрирован в авторскую копию модуля.Для помощи в этом,а также с учетом пунктов #1,#2 и #3 выше,контактная информация авторов всех внесенных модулей должна храниться в дистрибутиве Perl.</target>
        </trans-unit>
        <trans-unit id="9f633a9cd1f1e79fef8f8eaa0a6cfd15cedc67ef" translate="yes" xml:space="preserve">
          <source>In all of the above cases, option values may be inserted in the bundle. For example:</source>
          <target state="translated">Во всех вышеперечисленных случаях значения опций могут быть вставлены в связку.Например:</target>
        </trans-unit>
        <trans-unit id="2383a8bd7489fcdd2f83ac67cbbc873796c97eb5" translate="yes" xml:space="preserve">
          <source>In all operations on %ENV, the key string is treated as if it were entirely uppercase, regardless of the case actually specified in the Perl expression.</source>
          <target state="translated">Во всех операциях над %ENV строка ключа обрабатывается,как если бы она была полностью прописной,независимо от того,какой регистр фактически указан в выражении Perl.</target>
        </trans-unit>
        <trans-unit id="95b3792cd6f5e2af35835ac883e0e6a53f125114" translate="yes" xml:space="preserve">
          <source>In all the above examples, &lt;code&gt;minus()&lt;/code&gt; is required only to return the result of the subtraction: Perl takes care of the assignment to $x. In fact, such methods should</source>
          <target state="translated">Во всех приведенных выше примерах &lt;code&gt;minus()&lt;/code&gt; требуется только для возврата результата вычитания: Perl заботится о присвоении $ x. На самом деле такие методы должны</target>
        </trans-unit>
        <trans-unit id="97f2c173d7ed4e9aee1d1f9fb64f4d9f9b0ea2fe" translate="yes" xml:space="preserve">
          <source>In all the previous examples I have 'hard-wired' the name of the Perl subroutine to be called from C. Most of the time though, it is more convenient to be able to specify the name of the Perl subroutine from within the Perl script.</source>
          <target state="translated">Во всех предыдущих примерах у меня есть &quot;hard-wired&quot; название подпрограммы Perl,которая будет вызываться из C.В большинстве случаев,однако,удобнее иметь возможность указать имя подпрограммы Perl из скрипта Perl.</target>
        </trans-unit>
        <trans-unit id="aaae17ed6f36eac3220705015e0ea930013f7c8e" translate="yes" xml:space="preserve">
          <source>In all these cases, the user can override this stubborn behaviour by prepending the command with the word force, for example:</source>
          <target state="translated">Во всех этих случаях пользователь может переопределить это упрямое поведение,подготовив команду,например,с помощью слова force:</target>
        </trans-unit>
        <trans-unit id="4cbe02d68ddbd502acef7d9e9916746fae4beca6" translate="yes" xml:space="preserve">
          <source>In almost all cases like this, it's usually a far, far better idea to use the structured control flow mechanisms of &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; instead of resorting to a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. For certain applications, the catch and throw pair of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; and die() for exception processing can also be a prudent approach.</source>
          <target state="translated">Практически во всех подобных случаях гораздо лучше использовать механизмы структурированного потока управления &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; вместо того, чтобы прибегать к &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; . Для некоторых приложений пара catch и throw &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; и die () для обработки исключений также может быть разумным подходом.</target>
        </trans-unit>
        <trans-unit id="8cf0558a3828c482ff92b5a9786f51b397db3041" translate="yes" xml:space="preserve">
          <source>In an array context &lt;code&gt;extract_multiple&lt;/code&gt; returns an array of substrings of the original string, as extracted by the specified extractors. In a scalar context, &lt;code&gt;extract_multiple&lt;/code&gt; returns the first substring successfully extracted from the original string. In both scalar and void contexts the original string has the first successfully extracted substring removed from it. In all contexts &lt;code&gt;extract_multiple&lt;/code&gt; starts at the current &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; of the string, and sets that &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; appropriately after it matches.</source>
          <target state="translated">В контексте массива &lt;code&gt;extract_multiple&lt;/code&gt; возвращает массив подстрок исходной строки, извлеченный указанными экстракторами. В скалярном контексте &lt;code&gt;extract_multiple&lt;/code&gt; возвращает первую подстроку, успешно извлеченную из исходной строки. Как в скалярном, так и в пустом контексте из исходной строки удалена первая успешно извлеченная подстрока. Во всех контекстах &lt;code&gt;extract_multiple&lt;/code&gt; начинается в текущих &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; струны, а также устанавливает , что &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; надлежащим образом после того, как он соответствует.</target>
        </trans-unit>
        <trans-unit id="0bf045366670deb82562441b69ea96760a43c736" translate="yes" xml:space="preserve">
          <source>In an array context the return value is a list containing, the number of articles in the group, the number of the first article, the number of the last article and the group name.</source>
          <target state="translated">В контексте массива возвращаемое значение представляет собой список,содержащий,количество статей в группе,номер первой статьи,номер последней статьи и имя группы.</target>
        </trans-unit>
        <trans-unit id="5a5982cddd4d8975197c2744da1608d9e4548d41" translate="yes" xml:space="preserve">
          <source>In an array context, returns a list of lines returned from the server. In a scalar context, returns a reference to a list.</source>
          <target state="translated">В контексте массива возвращает список строк,возвращенных с сервера.В контексте скаляра возвращает ссылку на список.</target>
        </trans-unit>
        <trans-unit id="c41a798a42099e75be11d7d0369af1bc79b214a4" translate="yes" xml:space="preserve">
          <source>In an interpolated literal, whether a double-quoted string or a regex, you may specify a character by its number using the &lt;code&gt;\x{&lt;i&gt;HHHHHH&lt;/i&gt;}&lt;/code&gt; escape.</source>
          <target state="translated">В интерполированном литерале, будь то строка в двойных кавычках или регулярное выражение, вы можете указать символ по его номеру с помощью escape- символа &lt;code&gt;\x{&lt;i&gt;HHHHHH&lt;/i&gt;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4918ab5fdbd686e859250551837a7ee9a52207eb" translate="yes" xml:space="preserve">
          <source>In ancient times, Unix was also used to refer to some code that a couple of people at Bell Labs wrote to make use of a PDP-7 computer that wasn&amp;rsquo;t doing much of anything else at the time.</source>
          <target state="translated">В древние времена Unix также использовался для обозначения некоторого кода, который несколько человек из Bell Labs написали для использования компьютера PDP-7, который в то время не делал ничего другого.</target>
        </trans-unit>
        <trans-unit id="d17b1ed4f6399a33863173b63d7cf4eeef9ce1db" translate="yes" xml:space="preserve">
          <source>In any case do not expect nanosecond resolution, or even a microsecond resolution. Also note that the modify/access timestamps might have different resolutions, and that they need not be synchronized, e.g. if the operations are</source>
          <target state="translated">В любом случае не ожидайте наносекундного или даже микросекундного разрешения.Также обратите внимание на то,что временные метки изменения/получения доступа могут иметь разное разрешение,и что их не нужно синхронизировать,например,если операции</target>
        </trans-unit>
        <trans-unit id="a2ea48b73fadf70f92647ed4cbbc7d19e3016b8b" translate="yes" xml:space="preserve">
          <source>In any case you will be prompted with the correct invocation of the &lt;code&gt;inst_perl&lt;/code&gt; target that installs the new binary into INSTALLBIN.</source>
          <target state="translated">В любом случае вам будет предложено правильно &lt;code&gt;inst_perl&lt;/code&gt; цель inst_perl, которая устанавливает новый двоичный файл в INSTALLBIN.</target>
        </trans-unit>
        <trans-unit id="416ebb085a2d5e940040c711d2f8d1e17ddebb19" translate="yes" xml:space="preserve">
          <source>In any way, if you're seeing failures beyond those mentioned in this document, please consider upgrading to the latest Hurd before reporting the failure as a bug.</source>
          <target state="translated">В любом случае,если вы видите сбои,выходящие за рамки упомянутых в этом документе,пожалуйста,подумайте об обновлении до последней версии Hurd,прежде чем сообщать о сбое как об ошибке.</target>
        </trans-unit>
        <trans-unit id="86069d4fc266f927b18d767a1cba7026af51c3e5" translate="yes" xml:space="preserve">
          <source>In array context returns a two-element array with the seconds and microseconds since the epoch. In scalar context returns floating seconds like &lt;code&gt;Time::HiRes::time()&lt;/code&gt; (see below).</source>
          <target state="translated">В контексте массива возвращает двухэлементный массив с секундами и микросекундами с начала эпохи. В скалярном контексте возвращает плавающие секунды, например &lt;code&gt;Time::HiRes::time()&lt;/code&gt; (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="16582d55b272e81d53e1e61c0aba11a653333faf" translate="yes" xml:space="preserve">
          <source>In between two &lt;b&gt;subscripts&lt;/b&gt;, the arrow is optional.</source>
          <target state="translated">Стрелка между двумя &lt;b&gt;нижними индексами&lt;/b&gt; необязательна.</target>
        </trans-unit>
        <trans-unit id="e15bc0bc69692882714387f5e16ad85b014d51b1" translate="yes" xml:space="preserve">
          <source>In block mode, &lt;code&gt;filter_read&lt;/code&gt; will append a block of data which is &amp;lt;= &lt;code&gt;$size&lt;/code&gt; to the end of the &lt;code&gt;$_&lt;/code&gt; scalar. It is important to emphasise the that &lt;code&gt;filter_read&lt;/code&gt; will not necessarily read a block which is</source>
          <target state="translated">В блочном режиме &lt;code&gt;filter_read&lt;/code&gt; добавит блок данных &lt;code&gt;$size&lt;/code&gt; &amp;lt;= $ size в конец скаляра &lt;code&gt;$_&lt;/code&gt; . Важно подчеркнуть, что &lt;code&gt;filter_read&lt;/code&gt; не обязательно будет читать блок, который</target>
        </trans-unit>
        <trans-unit id="86311b9447535cd22a0807e557574828944f0087" translate="yes" xml:space="preserve">
          <source>In bootstrapping situations it is usually sufficient to translate only a few YAML files to Data::Dumper for crucial modules like &lt;code&gt;YAML::Syck&lt;/code&gt; , &lt;code&gt;YAML.pm&lt;/code&gt; and &lt;code&gt;Expect.pm&lt;/code&gt; . If you prefer Storable over Data::Dumper, remember to pull out a Storable version that writes an older format than all the other Storable versions that will need to read them.</source>
          <target state="translated">В ситуациях начальной загрузки обычно достаточно перевести в Data :: Dumper только несколько файлов YAML для таких важных модулей, как &lt;code&gt;YAML::Syck&lt;/code&gt; , &lt;code&gt;YAML.pm&lt;/code&gt; и &lt;code&gt;Expect.pm&lt;/code&gt; . Если вы предпочитаете Storable, а не Data :: Dumper, не забудьте извлечь версию Storable, которая записывает более старый формат, чем все другие версии Storable, которым необходимо их прочитать.</target>
        </trans-unit>
        <trans-unit id="7d32bdf3cfc0bcbd8616099443aea4c2f02bae5f" translate="yes" xml:space="preserve">
          <source>In both cases this should only be considered to be a temporary measure - you should upgrade to the later version of perl as soon as is practicable.</source>
          <target state="translated">В обоих случаях это следует рассматривать только как временную меру-вам следует как можно скорее перейти на более позднюю версию perl.</target>
        </trans-unit>
        <trans-unit id="d2a841147fc72cc4482e0a7e84067a22e8db15fe" translate="yes" xml:space="preserve">
          <source>In both cases, if you want access to the original, unaltered routine, use the &lt;code&gt;CORE::&lt;/code&gt; prefix:</source>
          <target state="translated">В обоих случаях, если вы хотите получить доступ к исходной неизмененной подпрограмме, используйте префикс &lt;code&gt;CORE::&lt;/code&gt; :::</target>
        </trans-unit>
        <trans-unit id="3b49d045d120cddc991a05308fecf5d02438bfd9" translate="yes" xml:space="preserve">
          <source>In both cases, it is strongly recommended that you use these flags when you run Configure. If you do not use do this, but later answer the questions about 64-bit numbers when Configure asks you, you may get a configuration that cannot be compiled, or that does not function as expected.</source>
          <target state="translated">В обоих случаях настоятельно рекомендуется использовать эти флаги при запуске программы Configure.Если вы не используете их,но позже ответите на вопросы о 64-битных числах при запросе Configure,вы можете получить конфигурацию,которая не может быть скомпилирована или работает не так,как ожидалось.</target>
        </trans-unit>
        <trans-unit id="28f5f411ebc893dbf219e8f06f5338fdd368072e" translate="yes" xml:space="preserve">
          <source>In both forms, the value returned is the value of the last expression evaluated inside the mini-program; a return statement may be also used, just as with subroutines. The expression providing the return value is evaluated in void, scalar, or list context, depending on the context of the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;wantarray&quot;&gt;wantarray&lt;/a&gt; for more on how the evaluation context can be determined.</source>
          <target state="translated">В обеих формах возвращаемое значение - это значение последнего выражения, вычисленного внутри мини-программы; также может использоваться оператор return, как и в случае с подпрограммами. Выражение, обеспечивающее возвращаемое значение, оценивается в пустом, скалярном или списковом контексте, в зависимости от контекста самого &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . См. &lt;a href=&quot;wantarray&quot;&gt;Wantarray,&lt;/a&gt; чтобы узнать больше о том, как можно определить контекст оценки.</target>
        </trans-unit>
        <trans-unit id="4a7857febf47f6d9d7d4d6147004e7ae7af4e0b5" translate="yes" xml:space="preserve">
          <source>In both forms, the value returned is the value of the last expression evaluated inside the mini-program; a return statement may be also used, just as with subroutines. The expression providing the return value is evaluated in void, scalar, or list context, depending on the context of the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;#wantarray&quot;&gt;wantarray&lt;/a&gt; for more on how the evaluation context can be determined.</source>
          <target state="translated">В обеих формах возвращаемое значение - это значение последнего выражения, вычисленного внутри мини-программы; также может использоваться оператор return, как и в случае с подпрограммами. Выражение, обеспечивающее возвращаемое значение, оценивается в пустом, скалярном или списковом контексте, в зависимости от контекста самого &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . См. &lt;a href=&quot;#wantarray&quot;&gt;Wantarray,&lt;/a&gt; чтобы узнать больше о том, как можно определить контекст оценки.</target>
        </trans-unit>
        <trans-unit id="c9f62f445147592772dba8cf7d0b7f085f6d5d1f" translate="yes" xml:space="preserve">
          <source>In both last cases, the last expression is evaluated in the context that was applied to the &lt;code&gt;given&lt;/code&gt; block.</source>
          <target state="translated">В обоих последних случаях последнее выражение оценивается в контексте, который был применен к &lt;code&gt;given&lt;/code&gt; блоку.</target>
        </trans-unit>
        <trans-unit id="faca50452b363bafe8294bb759677cc9d971a027" translate="yes" xml:space="preserve">
          <source>In both the case of unquoted command line arguments or in calls to &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; VMS wildcard expansion is performed. (csh-style wildcard expansion is available if you use &lt;code&gt;File::Glob::glob&lt;/code&gt; .) If the wildcard filespec contains a device or directory specification, then the resultant filespecs will also contain a device and directory; otherwise, device and directory information are removed. VMS-style resultant filespecs will contain a full device and directory, while Unix-style resultant filespecs will contain only as much of a directory path as was present in the input filespec. For example, if your default directory is Perl_Root:[000000], the expansion of &lt;code&gt;[.t]*.*&lt;/code&gt; will yield filespecs like &quot;perl_root:[t]base.dir&quot;, while the expansion of &lt;code&gt;t/*/*&lt;/code&gt; will yield filespecs like &quot;t/base.dir&quot;. (This is done to match the behavior of glob expansion performed by Unix shells.)</source>
          <target state="translated">Как в случае аргументов командной строки без кавычек, так и при &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; VMS подстановочный знак выполняется. (Расширение с подстановочными знаками в стиле csh доступно, если вы используете &lt;code&gt;File::Glob::glob&lt;/code&gt; .) Если спецификация файлов с подстановочными знаками содержит спецификацию устройства или каталога, то результирующие спецификации файлов также будут содержать устройство и каталог; в противном случае удаляется информация об устройстве и каталоге. Результирующие спецификации файлов в стиле VMS будут содержать полное устройство и каталог, тогда как результирующие спецификации файлов в стиле Unix будут содержать только ту часть пути к каталогу, которая присутствует во входной спецификации файлов. Например, если ваш каталог по умолчанию - Perl_Root: [000000], расширение &lt;code&gt;[.t]*.*&lt;/code&gt; Приведет к таким файлам, как &amp;laquo;perl_root: [t] base.dir&amp;raquo;, а расширение &lt;code&gt;t/*/*&lt;/code&gt; даст спецификации типа &quot;t / base.dir&quot;. (Это сделано для соответствия поведению расширения glob, выполняемого оболочками Unix.)</target>
        </trans-unit>
        <trans-unit id="7acbdc4bab7e93326f2e293e78aa137135b956f7" translate="yes" xml:space="preserve">
          <source>In both these examples, the character being matched is non-Unicode, so Unicode doesn't define how it should match. It clearly isn't an ASCII hex digit, so the first example clearly should fail, and so it does, with no warning. But it is arguable that the second example should have an undefined, hence &lt;code&gt;FALSE&lt;/code&gt; , result. So a warning is raised for it.</source>
          <target state="translated">В обоих этих примерах сопоставляемый символ не является Unicode, поэтому Unicode не определяет, как он должен соответствовать. Ясно, что это не шестнадцатеричная цифра ASCII, поэтому первый пример явно должен потерпеть неудачу, и так оно и есть, без предупреждения. Но можно утверждать, что второй пример должен иметь результат undefined, а значит, &lt;code&gt;FALSE&lt;/code&gt; . Так что за это делается предупреждение.</target>
        </trans-unit>
        <trans-unit id="9f0223354df20f59a567232c3197191e5bff5d52" translate="yes" xml:space="preserve">
          <source>In both usages of the autosplitter, only subroutines defined following the perl</source>
          <target state="translated">В обоих случаях при использовании авторазбивателя,только подпрограммы,определенные после perl</target>
        </trans-unit>
        <trans-unit id="e541d9732ad7ef01278201444dc42735718b9c21" translate="yes" xml:space="preserve">
          <source>In case of L&amp;lt;...&amp;gt; codes with no &quot;text|&quot; part in them, older formatters have exhibited great variation in actually displaying the link or cross reference. For example, L&amp;lt;crontab(5)&amp;gt; would render as &quot;the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot;, or &quot;in the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot; or just &quot;&lt;code&gt;crontab(5)&lt;/code&gt; &quot;.</source>
          <target state="translated">В случае кодов L &amp;lt;...&amp;gt; без &quot;текста |&quot; Часть из них, более старые программы форматирования продемонстрировали большие различия в фактическом отображении ссылки или перекрестной ссылки. Например, L &amp;lt;crontab (5)&amp;gt; будет отображаться как &amp;laquo; &lt;code&gt;crontab(5)&lt;/code&gt; страница crontab (5) &amp;raquo;, &amp;laquo;в &lt;code&gt;crontab(5)&lt;/code&gt; &amp;raquo; или просто &amp;laquo; &lt;code&gt;crontab(5)&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="365d296ccf4014f926ba35dfa5ea9a2c360d66e7" translate="yes" xml:space="preserve">
          <source>In case of doubt, insert the following statement in front of your Perl program:</source>
          <target state="translated">В случае сомнений,вставьте следующее утверждение перед вашей программой Perl:</target>
        </trans-unit>
        <trans-unit id="dfdb2521cd21a1ef333094706d67bdf22192a8cc" translate="yes" xml:space="preserve">
          <source>In case the advice in this guide has been updated recently, read the latest version directly from the perl source:</source>
          <target state="translated">В случае,если советы,содержащиеся в этом руководстве,были недавно обновлены,прочтите последнюю версию непосредственно из источника perl:</target>
        </trans-unit>
        <trans-unit id="23c62db8a34f2416b1d1b03ee56f5f1471c6e5f5" translate="yes" xml:space="preserve">
          <source>In case the result of one operation has more digits than specified, it is rounded. The rounding mode taken is either the default mode, or the one supplied to the operation after the</source>
          <target state="translated">Если результат одной операции имеет больше цифр,чем указано,то он округляется.Принятый режим округления является либо режимом по умолчанию,либо режимом,который поставляется на операцию после операции</target>
        </trans-unit>
        <trans-unit id="4ff81268a14bba4a99da29ff2559bdaaf817ec79" translate="yes" xml:space="preserve">
          <source>In case you can choose between running a Makefile.PL or a Build.PL, which installer would you prefer (EUMM or MB or RAND)?</source>
          <target state="translated">В случае,если вы можете выбрать между запуском Makefile.PL или Build.PL,какую программу установки вы предпочитаете (EUMM или MB или RAND)?</target>
        </trans-unit>
        <trans-unit id="4bcc550b219bf3be3a6806897874d6bb2e99f2b2" translate="yes" xml:space="preserve">
          <source>In case you're not familiar with the &quot;regular&quot; Version 8 regex routines, here are the pattern-matching rules not described above.</source>
          <target state="translated">В случае,если вы не знакомы с &quot;обычными&quot; регекс-программами 8 версии,вот правила сопоставления шаблонов,не описанные выше.</target>
        </trans-unit>
        <trans-unit id="62dab9a7c702990dbb833dc9d9dafc87377a09a8" translate="yes" xml:space="preserve">
          <source>In cases of exceptionally aberrant documents, Pod parsers may abort the parse. Even then, using &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;ing/&lt;code&gt;croak&lt;/code&gt; ing is to be avoided; where possible, the parser library may simply close the input file and add text like &quot;*** Formatting Aborted ***&quot; to the end of the (partial) in-memory document.</source>
          <target state="translated">В случае исключительно ошибочных документов парсеры Pod могут прервать анализ. Даже в этом случае, с помощью &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ING / &lt;code&gt;croak&lt;/code&gt; Ing следует избегать; где возможно, библиотека синтаксического анализатора может просто закрыть входной файл и добавить текст типа &amp;laquo;*** Форматирование прервано ***&amp;raquo; в конец (частичного) документа в памяти.</target>
        </trans-unit>
        <trans-unit id="59b86d710288939d8eb974b61f2bbf30d7a131a6" translate="yes" xml:space="preserve">
          <source>In cases where get_title can't find the title, it will return empty-string (&quot;&quot;).</source>
          <target state="translated">В случаях,когда get_title не может найти заголовок,он возвращает пустую строку (&quot;&quot;).</target>
        </trans-unit>
        <trans-unit id="8bf9664b1f4d1fbea5b6e435c9a6c227eff0e2f3" translate="yes" xml:space="preserve">
          <source>In certain cases, the OS-level handles created by the pipe(), socket(), and accept() operators are apparently not duplicated accurately in pseudo-processes. This only happens in some situations, but where it does happen, it may result in deadlocks between the read and write ends of pipe handles, or inability to send or receive data across socket handles.</source>
          <target state="translated">В некоторых случаях дескрипторы уровня ОС,созданные операторами pipe(),socket()и accept(),по-видимому,не дублируются точно в псевдо-процессах.Это происходит только в некоторых ситуациях,но там,где это действительно происходит,это может привести к тупиковым ситуациям между концами трубных дескрипторов для чтения и записи,или к невозможности отправки или получения данных через дескрипторы сокетов.</target>
        </trans-unit>
        <trans-unit id="f0057891cced8b178aba4808a03218c5201e0280" translate="yes" xml:space="preserve">
          <source>In certain systems, the operating system's locale support is broken and cannot be fixed or used by Perl. Such deficiencies can and will result in mysterious hangs and/or Perl core dumps when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect. When confronted with such a system, please report in excruciating detail to &amp;lt;</source>
          <target state="translated">В некоторых системах поддержка локали операционной системы нарушена и не может быть исправлена ​​или использована Perl. Такие недостатки могут и будут приводить к загадочным зависаниям и / или дампам ядра Perl при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . Если вы столкнетесь с такой системой, пожалуйста, сообщите в мучительных подробностях &amp;lt;</target>
        </trans-unit>
        <trans-unit id="60c7a29f6dd0bd0c499c2a79f889945240814e67" translate="yes" xml:space="preserve">
          <source>In code that currently says &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader; @ISA = qw(AutoLoader);&lt;/code&gt; you should remove AutoLoader from @ISA and change &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader 'AUTOLOAD';&lt;/code&gt; .</source>
          <target state="translated">В коде, который в настоящее время говорит &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader; @ISA = qw(AutoLoader);&lt;/code&gt; вам следует удалить AutoLoader из @ISA и изменить &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader;&lt;/code&gt; чтобы &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader 'AUTOLOAD';&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b746a74a7b045be066091fe7c51bf38b893c45a1" translate="yes" xml:space="preserve">
          <source>In comparison to the standard implementation where the object is a hash and the fields correspond to hash keys, here the fields correspond to hashes, and the object determines the hash key. Thus the hashes appear to be turned</source>
          <target state="translated">В сравнении со стандартной реализацией,где объект является хэшем,а поля соответствуют хэш-ключам,здесь поля соответствуют хэшам,а объект определяет хэш-ключ.Таким образом,хэши оказываются обращенными</target>
        </trans-unit>
        <trans-unit id="402b2ae815c1f3f49820717ee0f679511f29fbf5" translate="yes" xml:space="preserve">
          <source>In connection with &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; simply adds bits, and this can be put to good use to count set bits efficiently:</source>
          <target state="translated">В связи с &lt;code&gt;b&lt;/code&gt; или &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; просто добавляет биты, и это может быть хорошее применение эффективно рассчитывать установленные биты:</target>
        </trans-unit>
        <trans-unit id="ed09b7a66d2eaa93bbb9724cd18388dac9e53c52" translate="yes" xml:space="preserve">
          <source>In consequence, if two or more classes want to access an object they</source>
          <target state="translated">В результате,если два или более класса хотят получить доступ к объекту,то они</target>
        </trans-unit>
        <trans-unit id="f69c1a7795cd05f1f7a1c806e629e11c671e5598" translate="yes" xml:space="preserve">
          <source>In contrast, &lt;code&gt;\b{...}&lt;/code&gt; and &lt;code&gt;\B{...}&lt;/code&gt; may or may not match at the beginning and end of the line, depending on the boundary type. These implement the Unicode default boundaries, specified in &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/&lt;/a&gt;. The boundary types currently available are:</source>
          <target state="translated">Напротив, &lt;code&gt;\b{...}&lt;/code&gt; и &lt;code&gt;\B{...}&lt;/code&gt; могут совпадать или не совпадать в начале и конце строки, в зависимости от типа границы. Они реализуют границы Unicode по умолчанию, указанные в &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/&lt;/a&gt; . В настоящее время доступны следующие типы границ:</target>
        </trans-unit>
        <trans-unit id="01521aaa27588449bcad287436418e3fa90af89f" translate="yes" xml:space="preserve">
          <source>In contrast, INSTALL_BASE has predictable, easy to explain installation locations. Now that Module::Build and MakeMaker both have INSTALL_BASE there is little reason to use PREFIX other than to preserve your existing installation locations. If you are starting a fresh Perl installation we encourage you to use INSTALL_BASE. If you have an existing installation installed via PREFIX, consider moving it to an installation structure matching INSTALL_BASE and using that instead.</source>
          <target state="translated">В отличие от этого,программа INSTALL_BASE имеет предсказуемые,легко объясняемые места установки.Теперь,когда у обоих модулей Module::Build и MakeMaker есть INSTALL_BASE,нет никаких причин использовать PREFIX,кроме как сохранить существующие места установки.Если вы начинаете новую установку на Perl,мы рекомендуем вам использовать INSTALL_BASE.Если у вас существующая инсталляция установлена через PREFIX,подумайте о переносе ее в структуру инсталляции,подходящую под INSTALL_BASE,и вместо этого используйте ее.</target>
        </trans-unit>
        <trans-unit id="b83a5099aeab352d7a9903a13c782e0d912d2e78" translate="yes" xml:space="preserve">
          <source>In contrast, hard references are more like hard links in a Unix file system: They are used to access an underlying object without concern for what its (other) name is. When the word &quot;reference&quot; is used without an adjective, as in the following paragraph, it is usually talking about a hard reference.</source>
          <target state="translated">Напротив,жесткие ссылки больше похожи на жесткие ссылки в файловой системе Unix:Они используются для доступа к базовому объекту,не заботясь о том,как его (другое)имя.Когда слово &quot;ссылка&quot; используется без прилагательного,как в следующем параграфе,обычно речь идет о жесткой ссылке.</target>
        </trans-unit>
        <trans-unit id="4fefb1775bf2d6d801dc0e18387b980f80b2a1f8" translate="yes" xml:space="preserve">
          <source>In contrast, modules in the</source>
          <target state="translated">В отличие от модулей в</target>
        </trans-unit>
        <trans-unit id="d9d8046b6af82f0d0498eb1133f08ab96606ff69" translate="yes" xml:space="preserve">
          <source>In corporate life, to grant official approval to a thing, as in, &amp;ldquo;The VP of Engineering has blessed our WebCruncher project.&amp;rdquo; Similarly, in Perl, to grant official approval to a &lt;b&gt;referent&lt;/b&gt; so that it can function as an &lt;b&gt;object&lt;/b&gt;, such as a WebCruncher object. See the &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">В корпоративной жизни - дать официальное одобрение чему-либо, например: &amp;laquo;Вице-президент по разработке благословил наш проект WebCruncher&amp;raquo;. Точно так же в Perl - предоставить официальное утверждение &lt;b&gt;референту,&lt;/b&gt; чтобы он мог работать как &lt;b&gt;объект&lt;/b&gt; , например объект WebCruncher. См. Функцию &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; в Camel, глава 27, &amp;laquo;Функции&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d9b2433b690bbfb6a8d4a6c1783fb717c5f969db" translate="yes" xml:space="preserve">
          <source>In deep binding, lexical variables mentioned in anonymous subroutines are the same ones that were in scope when the subroutine was created. In shallow binding, they are whichever variables with the same names happen to be in scope when the subroutine is called. Perl always uses deep binding of lexical variables (i.e., those created with my()). However, dynamic variables (aka global, local, or package variables) are effectively shallowly bound. Consider this just one more reason not to use them. See the answer to &lt;a href=&quot;#What's-a-closure%3f&quot;&gt;What's a closure?&lt;/a&gt;.</source>
          <target state="translated">При глубоком связывании лексические переменные, упомянутые в анонимных подпрограммах, совпадают с теми, которые находились в области видимости при создании подпрограммы. При поверхностном связывании это те переменные с одинаковыми именами, которые оказываются в области видимости при вызове подпрограммы. Perl всегда использует глубокую привязку лексических переменных (т. Е. Созданных с помощью my ()). Однако динамические переменные (также известные как глобальные, локальные или пакетные переменные) фактически неглубоко связаны. Считайте это еще одной причиной не использовать их. См. Ответ на вопрос &lt;a href=&quot;#What's-a-closure%3f&quot;&gt;Что такое закрытие?&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20fadc3ec5ca97e1da30f076e8b9de4f5b9c66b4" translate="yes" xml:space="preserve">
          <source>In directories where either &lt;code&gt;Makefile.PL&lt;/code&gt; or &lt;code&gt;Build.PL&lt;/code&gt; exist, &lt;code&gt;perldoc&lt;/code&gt; will add &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; first to its search path, and as long as you're not the superuser will add &lt;code&gt;blib&lt;/code&gt; too. This is really helpful if you're working inside of a build directory and want to read through the docs even if you have a version of a module previously installed.</source>
          <target state="translated">В каталогах, где существует &lt;code&gt;Makefile.PL&lt;/code&gt; или &lt;code&gt;Build.PL&lt;/code&gt; , будет добавлен &lt;code&gt;perldoc&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; и &lt;code&gt;lib&lt;/code&gt; сначала в свой путь поиска, и если вы не суперпользователь, тоже добавит &lt;code&gt;blib&lt;/code&gt; . Это действительно полезно, если вы работаете внутри каталога сборки и хотите прочитать документацию, даже если у вас установлена ​​ранее установленная версия модуля.</target>
        </trans-unit>
        <trans-unit id="b98ec9678a77351791b177991b84c25fc1205921" translate="yes" xml:space="preserve">
          <source>In each of the following groups, there may be many more constants provided than just the ones given as examples in the section heading. If the heading ends &lt;code&gt;...&lt;/code&gt; then this means there are likely more; the exact constants provided will depend on the OS and headers found at compile-time.</source>
          <target state="translated">В каждой из следующих групп может быть намного больше констант, чем только те, которые приведены в качестве примеров в заголовке раздела. Если заголовок заканчивается &lt;code&gt;...&lt;/code&gt; значит, вероятно, их больше; точные предоставленные константы будут зависеть от ОС и заголовков, найденных во время компиляции.</target>
        </trans-unit>
        <trans-unit id="6cd886bd81b2389456301c1edaca970f0fd117a3" translate="yes" xml:space="preserve">
          <source>In earlier versions, when byte and character data were concatenated, the new string was sometimes created by decoding the byte strings as</source>
          <target state="translated">В более ранних версиях,когда байтовые и символьные данные были сцеплены,новая строка иногда создавалась путем декодирования строк байтов как</target>
        </trans-unit>
        <trans-unit id="7dc7a0656f22946eb4e770e46a3f69e5d6f40e31" translate="yes" xml:space="preserve">
          <source>In effect, your search prefix is ignored and $Config{vms_prefix} is used instead.</source>
          <target state="translated">По сути,ваш поисковый префикс игнорируется и вместо него используется $Config{vms_prefix}.</target>
        </trans-unit>
        <trans-unit id="4c62ad53bb4b783795294732eef580256b60e336" translate="yes" xml:space="preserve">
          <source>In either case, you should still be able to run the scripts with perl explicitly:</source>
          <target state="translated">В любом случае,вы все равно должны иметь возможность явно запускать скрипты на perl:</target>
        </trans-unit>
        <trans-unit id="fb41a30683f07ad432fb7627b6f4d0b50b059664" translate="yes" xml:space="preserve">
          <source>In extreme cases, &lt;b&gt;perlbug&lt;/b&gt; may not work well enough on your system to guide you through composing a bug report. In those cases, you may be able to use &lt;b&gt;perlbug -d&lt;/b&gt; to get system configuration information to include in a manually composed bug report to &lt;b&gt;perlbug@perl.org&lt;/b&gt;.</source>
          <target state="translated">В крайних случаях &lt;b&gt;perlbug&lt;/b&gt; может не работать достаточно хорошо в вашей системе, чтобы помочь вам при составлении отчета об ошибке. В таких случаях вы можете использовать &lt;b&gt;perlbug -d,&lt;/b&gt; чтобы получить информацию о конфигурации системы и включить ее в составленный вручную отчет об ошибке на &lt;b&gt;perlbug@perl.org&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="abe9c1f86e0ce32785f02f8f2556f43d9ccd3599" translate="yes" xml:space="preserve">
          <source>In fact it is not 100% true that a compiled unit contains a pointer to the scratchpad AV. In fact it contains a pointer to an AV of (initially) one element, and this element is the scratchpad AV. Why do we need an extra level of indirection?</source>
          <target state="translated">На самом деле не на 100% верно,что скомпилированный блок содержит указатель на скрэтчпад AV.На самом деле он содержит указатель на AV (изначально)одного элемента,и этим элементом является скрэтчпад AV.Зачем нужен дополнительный уровень идирекции?</target>
        </trans-unit>
        <trans-unit id="e844204f376cced819af429b122503a8c0eba54a" translate="yes" xml:space="preserve">
          <source>In fact mangling of</source>
          <target state="translated">На самом деле,покалывание</target>
        </trans-unit>
        <trans-unit id="3370e0fda40977698cd4fccd53b4e05e504a7a69" translate="yes" xml:space="preserve">
          <source>In fact numbers stored in the native integer format may be stored either in the signed native form, or in the unsigned native form. Thus the limits for Perl numbers stored as native integers would typically be -2**31..2**32-1, with appropriate modifications in the case of 64-bit integers. Again, this does not mean that Perl can do operations only over integers in this range: it is possible to store many more integers in floating point format.</source>
          <target state="translated">На самом деле числа,хранящиеся в формате нативных чисел,могут храниться как в подписанной нативной форме,так и в неподписанной нативной форме.Таким образом,ограничения для Perl чисел,хранящихся в виде нативных целых чисел,обычно составляют -2**31..2**32-1,с соответствующими изменениями в случае 64-битных целых чисел.Опять же,это не означает,что Perl может выполнять операции только над целыми числами в этом диапазоне:можно хранить гораздо больше целых чисел в формате с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="58c12119d45a0a6b7a7d70173ad8a47276ea5e91" translate="yes" xml:space="preserve">
          <source>In fact, a dynamic variable (also known as package or global variables) are still accessible using the fully qualified &lt;code&gt;::&lt;/code&gt; notation even while a lexical of the same name is also visible:</source>
          <target state="translated">Фактически, динамическая переменная (также известная как пакет или глобальные переменные) по-прежнему доступна с использованием полностью квалифицированной нотации &lt;code&gt;::&lt;/code&gt; , даже если также отображается лексическое выражение с тем же именем:</target>
        </trans-unit>
        <trans-unit id="43fe617e28edf5522d6d7a7c2fe5c4bc3af16527" translate="yes" xml:space="preserve">
          <source>In fact, a simple identifier within such curlies is forced to be a string, and likewise within a hash subscript. Neither need quoting. Our earlier example, &lt;code&gt;$days{'Feb'}&lt;/code&gt; can be written as &lt;code&gt;$days{Feb}&lt;/code&gt; and the quotes will be assumed automatically. But anything more complicated in the subscript will be interpreted as an expression. This means for example that &lt;code&gt;$version{2.0}++&lt;/code&gt; is equivalent to &lt;code&gt;$version{2}++&lt;/code&gt; , not to &lt;code&gt;$version{'2.0'}++&lt;/code&gt; .</source>
          <target state="translated">Фактически, простой идентификатор внутри таких фигурных скобок должен быть строкой, а также должен быть внутри хеш-индекса. Цитировать тоже не нужно. В нашем предыдущем примере &lt;code&gt;$days{'Feb'}&lt;/code&gt; можно записать как &lt;code&gt;$days{Feb}&lt;/code&gt; и кавычки будут приняты автоматически. Но все более сложное в нижнем индексе будет интерпретировано как выражение. Это означает, например, что &lt;code&gt;$version{2.0}++&lt;/code&gt; эквивалентна &lt;code&gt;$version{2}++&lt;/code&gt; , а не &lt;code&gt;$version{'2.0'}++&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="721f4b0102ec5d45627b4acee4d7283205201fd1" translate="yes" xml:space="preserve">
          <source>In fact, if you predeclare functions you want to call that way, you don't even need parentheses:</source>
          <target state="translated">На самом деле,если вы предварительно объявите функции,которые хотите вызвать таким образом,вам даже не нужны скобки:</target>
        </trans-unit>
        <trans-unit id="84798f732a21afa219bddab775dec767e752c195" translate="yes" xml:space="preserve">
          <source>In fact, one can put this check into a POSTCALL: section as well. Together with PREINIT: simplifications, this leads to:</source>
          <target state="translated">Фактически,эту проверку можно поместить и в раздел POSTCALL:.Вместе с ПРЕЙНИТОМ:упрощениями это приводит:</target>
        </trans-unit>
        <trans-unit id="ebdfc7c600521f2938c49c5c2856e2e2b5dd3018" translate="yes" xml:space="preserve">
          <source>In fact, the above is a specific instance of a more general problem: we can't guarantee to produce BEGIN blocks or &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declarations in exactly the right place. So if you use a module which affects compilation (such as by over-riding keywords, overloading constants or whatever) then the output code might not work as intended.</source>
          <target state="translated">Фактически, приведенное выше является частным случаем более общей проблемы: мы не можем гарантировать создание блоков BEGIN или &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; объявлений точно в нужном месте. Поэтому, если вы используете модуль, который влияет на компиляцию (например, путем переопределения ключевых слов, перегрузки констант или чего-то еще), тогда выходной код может работать не так, как задумано.</target>
        </trans-unit>
        <trans-unit id="ee7429eb30ff20d649952850c91750d9f7b5208e" translate="yes" xml:space="preserve">
          <source>In fact, the skeleton modules shown above are fully functional</source>
          <target state="translated">На самом деле,показанные выше скелетные модули полностью функциональны.</target>
        </trans-unit>
        <trans-unit id="c08ff00d22228fb68d08d8dbc97cd530161909a6" translate="yes" xml:space="preserve">
          <source>In fact, what can happen is that the Perl subroutine you have called can access the &lt;code&gt;@_&lt;/code&gt; array from a previous Perl subroutine. This will occur when the code that is executing the</source>
          <target state="translated">Фактически, может случиться так, что вызванная вами подпрограмма Perl может получить доступ к массиву &lt;code&gt;@_&lt;/code&gt; из предыдущей подпрограммы Perl. Это произойдет, когда код, выполняющий</target>
        </trans-unit>
        <trans-unit id="5159536cbfaf213ba408ca2109f0a550ad3339ea" translate="yes" xml:space="preserve">
          <source>In fact, you can use as many repeated angle-brackets as you like so long as you have the same number of them in the opening and closing delimiters, and make sure that whitespace immediately follows the last '&amp;lt;' of the opening delimiter, and immediately precedes the first '&amp;gt;' of the closing delimiter. (The whitespace is ignored.) So the following will also work:</source>
          <target state="translated">Фактически, вы можете использовать столько повторяющихся угловых скобок, сколько захотите, при условии, что у вас одинаковое количество их в открывающем и закрывающем разделителях, и убедитесь, что пробел сразу же следует за последним '&amp;lt;' открывающего разделителя, и непосредственно перед первым символом &quot;&amp;gt;&quot; закрывающего ограничителя. (Пробелы игнорируются.) Таким образом, также будет работать следующее:</target>
        </trans-unit>
        <trans-unit id="eeef4cfd76862c3bdd64f8624b59be39f324bbb5" translate="yes" xml:space="preserve">
          <source>In former versions of FindBin there was no &lt;code&gt;again&lt;/code&gt; function. The workaround was to force the &lt;code&gt;BEGIN&lt;/code&gt; block to be executed again:</source>
          <target state="translated">В прежних версиях FindBin не было &lt;code&gt;again&lt;/code&gt; функция. Обходной путь заключался в том, чтобы принудительно выполнить блок &lt;code&gt;BEGIN&lt;/code&gt; снова:</target>
        </trans-unit>
        <trans-unit id="81bdf0d224677096b960b752cf09cb19f280de31" translate="yes" xml:space="preserve">
          <source>In function definitions, name starts in column 0 (return value-type is on previous line)</source>
          <target state="translated">В определениях функций имя начинается с столбца 0 (возвращаемое значение-тип находится в предыдущей строке).</target>
        </trans-unit>
        <trans-unit id="bd418e3b4eaab23d82d37560db5e07798de430bc" translate="yes" xml:space="preserve">
          <source>In general the flags should be preserved in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; after compilation, although the regex engine might want to add or delete some of them to invoke or disable some special behavior in Perl. The flags along with any special behavior they cause are documented below:</source>
          <target state="translated">В общем, флаги должны быть сохранены в &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; после компиляции, хотя механизм регулярных выражений может захотеть добавить или удалить некоторые из них, чтобы вызвать или отключить какое-то особое поведение в Perl. Флаги вместе с любым вызываемым ими особым поведением описаны ниже:</target>
        </trans-unit>
        <trans-unit id="cf0fc22fd30f9556953173964854405f4701bcb8" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Module ()&lt;/code&gt; is recommended over &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Module&lt;/code&gt; , because it determines module availability at compile time, not in the middle of your program's execution. An exception would be if two modules each tried to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; each other, and each also called a function from that other module. In that case, it's easy to use &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">В общем, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Module ()&lt;/code&gt; рекомендуется, а не &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Module&lt;/code&gt; , поскольку он определяет доступность модуля во время компиляции, а не в середине выполнения вашей программы. Исключением было бы, если бы два модуля пытались &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; друг друга, и каждый также вызывал функцию из этого другого модуля. В этом случае вместо этого просто использовать &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f587f957aa9f0d170955c8740a69ee20fd8f9433" translate="yes" xml:space="preserve">
          <source>In general, a value of 256MB (or &quot;256*1024*1024&quot;) is sufficient for Perl to compile at maximum optimization.</source>
          <target state="translated">В общем,значения 256MB (или &quot;256*1024*1024&quot;)достаточно для того,чтобы Perl скомпилировал при максимальной оптимизации.</target>
        </trans-unit>
        <trans-unit id="131ff1b059b6e02af211bb33de067db4f34cad70" translate="yes" xml:space="preserve">
          <source>In general, any generated Makefile checks for the current version of MakeMaker and the version the Makefile was built under. If NO_VC is set, the version check is neglected. Do not write this into your Makefile.PL, use it interactively instead.</source>
          <target state="translated">В общем,любой сгенерированный Makefile проверяет текущую версию MakeMaker и версию,под которой был собран Makefile.Если установлено NO_VC,то проверка версии игнорируется.Не записывайте это в Makefile.PL,используйте его интерактивно.</target>
        </trans-unit>
        <trans-unit id="ed1c758f94f821404f1b8e30ece4cfe61ee49211" translate="yes" xml:space="preserve">
          <source>In general, binmode() should be called after open() but before any I/O is done on the filehandle. Calling binmode() normally flushes any pending buffered output data (and perhaps pending input data) on the handle. An exception to this is the &lt;code&gt;:encoding&lt;/code&gt; layer that changes the default character encoding of the handle; see &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;. The &lt;code&gt;:encoding&lt;/code&gt; layer sometimes needs to be called in mid-stream, and it doesn't flush the stream. The &lt;code&gt;:encoding&lt;/code&gt; also implicitly pushes on top of itself the &lt;code&gt;:utf8&lt;/code&gt; layer because internally Perl operates on UTF8-encoded Unicode characters.</source>
          <target state="translated">Как правило, binmode () следует вызывать после open (), но до того, как для дескриптора файла будет произведен какой-либо ввод-вывод. Вызов binmode () обычно сбрасывает все ожидающие буферизованные выходные данные (и, возможно, ожидающие входные данные) на дескрипторе. Исключением является &lt;code&gt;:encoding&lt;/code&gt; слой кодирования, который изменяет кодировку символов по умолчанию для дескриптора; см. &lt;a href=&quot;#open&quot;&gt;открытый&lt;/a&gt; . Уровень &lt;code&gt;:encoding&lt;/code&gt; иногда необходимо вызывать в середине потока, и он не сбрасывает поток. &lt;code&gt;:encoding&lt;/code&gt; также косвенно наталкивает на вершине себя &lt;code&gt;:utf8&lt;/code&gt; слой , потому что внутри Perl работает на UTF8 кодировке символов Unicode.</target>
        </trans-unit>
        <trans-unit id="fcb23e7c19f51e6c8ab203413d609cc6c59591a8" translate="yes" xml:space="preserve">
          <source>In general, binmode() should be called after open() but before any I/O is done on the filehandle. Calling binmode() normally flushes any pending buffered output data (and perhaps pending input data) on the handle. An exception to this is the &lt;code&gt;:encoding&lt;/code&gt; layer that changes the default character encoding of the handle; see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;. The &lt;code&gt;:encoding&lt;/code&gt; layer sometimes needs to be called in mid-stream, and it doesn't flush the stream. The &lt;code&gt;:encoding&lt;/code&gt; also implicitly pushes on top of itself the &lt;code&gt;:utf8&lt;/code&gt; layer because internally Perl operates on UTF8-encoded Unicode characters.</source>
          <target state="translated">Как правило, binmode () следует вызывать после open (), но до того, как для дескриптора файла будет произведен какой-либо ввод-вывод. Вызов binmode () обычно сбрасывает все ожидающие буферизованные выходные данные (и, возможно, ожидающие входные данные) на дескрипторе. Исключением является &lt;code&gt;:encoding&lt;/code&gt; слой кодирования, который изменяет кодировку символов по умолчанию для дескриптора; см. &lt;a href=&quot;open&quot;&gt;открытый&lt;/a&gt; . Уровень &lt;code&gt;:encoding&lt;/code&gt; иногда необходимо вызывать в середине потока, и он не сбрасывает поток. &lt;code&gt;:encoding&lt;/code&gt; также косвенно наталкивает на вершине себя &lt;code&gt;:utf8&lt;/code&gt; слой , потому что внутри Perl работает на UTF8 кодировке символов Unicode.</target>
        </trans-unit>
        <trans-unit id="9112f219636184c8537b2886b966af1ac78ce610" translate="yes" xml:space="preserve">
          <source>In general, documentation should describe what Perl does &quot;now&quot; rather than what it used to do. It's perfectly reasonable to include notes in documentation about how behaviour has changed from previous releases, but, with very few exceptions, documentation isn't &quot;dual-life&quot; -- it doesn't need to fully describe how all old versions used to work.</source>
          <target state="translated">В общем,документация должна описывать то,что Perl делает &quot;сейчас&quot;,а не то,что он делал раньше.Вполне разумно включать в документацию заметки о том,как изменилось поведение по сравнению с предыдущими выпусками,но,за очень редкими исключениями,документация не является &quot;двойной жизнью&quot;-она не нуждается в полном описании того,как работали все старые версии.</target>
        </trans-unit>
        <trans-unit id="c3bded401bb84dc2978238aa4ca8d1e409847f99" translate="yes" xml:space="preserve">
          <source>In general, don't directly access the system in code meant to be portable. That means, no &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;``&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;|&lt;/code&gt;, nor any of the other things that makes being a Perl hacker worth being.</source>
          <target state="translated">В общем, не обращайтесь напрямую к системе в коде, предназначенном для переносимости. Это означает, что нет &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;``&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; с &lt;code&gt;|&lt;/code&gt; , ни что-либо другое, что делает хакером Perl достойным.</target>
        </trans-unit>
        <trans-unit id="4812a1f34a0b31a652cad991bba82f8957d788f2" translate="yes" xml:space="preserve">
          <source>In general, functions in Perl that serve as wrappers for system calls (&quot;syscalls&quot;) of the same name (like chown(2), fork(2), closedir(2), etc.) return true when they succeed and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise, as is usually mentioned in the descriptions below. This is different from the C interfaces, which return &lt;code&gt;-1&lt;/code&gt; on failure. Exceptions to this rule include &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt;. System calls also set the special &lt;code&gt;$!&lt;/code&gt; variable on failure. Other functions do not, except accidentally.</source>
          <target state="translated">В общем, функции в Perl, которые служат обертками для системных вызовов (&quot;syscalls&quot;) с тем же именем (например, chown (2), fork (2), closedir (2) и т. Д.), Возвращают true, если они выполнены успешно, и &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в противном случае. , как обычно упоминается в описаниях ниже. Это отличается от интерфейсов C, которые возвращают &lt;code&gt;-1&lt;/code&gt; в случае ошибки. Исключения из этого правила включают &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; . Системные вызовы также устанавливают специальный &lt;code&gt;$!&lt;/code&gt; переменная при сбое. Других функций нет, кроме как случайно.</target>
        </trans-unit>
        <trans-unit id="2d920741739edbfdbddc6a5906e0b7d1f697b74b" translate="yes" xml:space="preserve">
          <source>In general, if something strange has gone wrong with your program and you're not sure where you should look for help, try making your code comply with &lt;b&gt;use strict&lt;/b&gt; and &lt;b&gt;use warnings&lt;/b&gt;. These will often point out exactly where the trouble is.</source>
          <target state="translated">В общем, если с вашей программой что-то пошло не так, и вы не знаете, где искать помощь, попробуйте привести свой код в соответствие с &lt;b&gt;use strict&lt;/b&gt; и &lt;b&gt;использовать предупреждения&lt;/b&gt; . Они часто указывают, в чем именно заключается проблема.</target>
        </trans-unit>
        <trans-unit id="4f338449d4134d94449e7a10434356d790a883d8" translate="yes" xml:space="preserve">
          <source>In general, it is better to create directories with a permissive MASK and let the user modify that with their &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; than it is to supply a restrictive MASK and give the user no way to be more permissive. The exceptions to this rule are when the file or directory should be kept private (mail files, for instance). The perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; discusses the choice of MASK in more detail.</source>
          <target state="translated">В общем, лучше создать каталоги с разрешающей МАСКОЙ и позволить пользователю изменять ее с помощью своей &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; , чем предоставлять ограничительную МАСКУ и не давать пользователю возможности быть более разрешительной. Исключениями из этого правила являются случаи, когда файл или каталог должны оставаться закрытыми (например, почтовые файлы). В записи perlfunc (1) в &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; более подробно обсуждается выбор MASK.</target>
        </trans-unit>
        <trans-unit id="859fd0676cfab168da7696f014146535cbe0534d" translate="yes" xml:space="preserve">
          <source>In general, it is better to create directories with a permissive MASK and let the user modify that with their &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; than it is to supply a restrictive MASK and give the user no way to be more permissive. The exceptions to this rule are when the file or directory should be kept private (mail files, for instance). The perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; discusses the choice of MASK in more detail.</source>
          <target state="translated">В общем, лучше создать каталоги с разрешающей МАСКОЙ и позволить пользователю изменять ее с помощью своей &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; , чем предоставлять ограничительную МАСКУ и не давать пользователю возможности быть более разрешительной. Исключениями из этого правила являются случаи, когда файл или каталог должны оставаться закрытыми (например, почтовые файлы). В записи perlfunc (1) в &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; более подробно обсуждается выбор MASK.</target>
        </trans-unit>
        <trans-unit id="cad59e50fb94fade64091c926ff1356d37dc6324" translate="yes" xml:space="preserve">
          <source>In general, it's not a good idea to write extensions that modify their input parameters, as in Example 3. Instead, you should probably return multiple values in an array and let the caller handle them (we'll do this in a later example). However, in order to better accommodate calling pre-existing C routines, which often do modify their input parameters, this behavior is tolerated.</source>
          <target state="translated">В общем,не стоит писать расширения,которые изменяют свои входные параметры,как в Примере 3.Вместо этого,вероятно,нужно вернуть несколько значений в массив и позволить вызывающему абоненту обрабатывать их (мы сделаем это в следующем примере).Однако,для того,чтобы лучше приспособиться к вызову уже существующих C-процедур,которые часто изменяют свои входные параметры,такое поведение допустимо.</target>
        </trans-unit>
        <trans-unit id="183640340bc430e8d749b47027dff4d3c19e6dde" translate="yes" xml:space="preserve">
          <source>In general, memory allocation and de-allocation isn't something you can or should be worrying about much in Perl.</source>
          <target state="translated">В общем,выделение и де-локация памяти-это не то,о чем вы можете или должны беспокоиться на Perl.</target>
        </trans-unit>
        <trans-unit id="694bbd0c5ca4e3fe0dcb487e904ca0b8ccaba6cd" translate="yes" xml:space="preserve">
          <source>In general, please follow the particular style of the code you are patching.</source>
          <target state="translated">В общем,пожалуйста,следуйте конкретному стилю кода,который вы исправляете.</target>
        </trans-unit>
        <trans-unit id="76448cd179f9ee3d08189e3b4f4ab1ba0deb68f0" translate="yes" xml:space="preserve">
          <source>In general, production code should not have file paths hardcoded. Making them user-supplied or read from a configuration file is better, keeping in mind that file path syntax varies on different machines.</source>
          <target state="translated">В целом,в производственном коде не должно быть жестко закодированных путей к файлам.Лучше сделать их пользовательскими или читать из конфигурационного файла,имея в виду,что синтаксис путей к файлам на разных машинах разный.</target>
        </trans-unit>
        <trans-unit id="15ebd5f7d0f38eb2ba1e333ec5e5f7197b5f77f7" translate="yes" xml:space="preserve">
          <source>In general, the VMS version of ext() should properly handle input from extensions originally designed for a Unix or VMS environment. If you encounter problems, or discover cases where the search could be improved, please let us know.</source>
          <target state="translated">В целом,версия ext()для VMS должна корректно обрабатывать входные данные из расширений,изначально разработанных для Unix или среды VMS.Если вы столкнулись с проблемами или обнаружили случаи,когда поиск может быть улучшен,пожалуйста,сообщите нам об этом.</target>
        </trans-unit>
        <trans-unit id="6fd9faf570da706152bccbfe022ff5b9665bb3b0" translate="yes" xml:space="preserve">
          <source>In general, the benefit of a language is closely related to the skill of the people using that language. If you or your team can be faster, better, and stronger through Perl, you'll deliver more value. Remember, people often respond better to what they get out of it. If you run into resistance, figure out what those people get out of the other choice and how Perl might satisfy that requirement.</source>
          <target state="translated">В целом,польза от языка тесно связана с мастерством людей,пользующихся этим языком.Если вы или ваша команда сможете быть быстрее,лучше и сильнее с помощью Perl,вы получите больше пользы.Помните,что люди часто лучше реагируют на то,что они получают от этого.Если вы сталкиваетесь с сопротивлением,выяснить,что эти люди получают из другого выбора и как Perl может удовлетворить это требование.</target>
        </trans-unit>
        <trans-unit id="c1872d2ad517d8a6c01a447283eab0112566170f" translate="yes" xml:space="preserve">
          <source>In general, the distributed kit for a Perl extension includes a file named Makefile.PL, which is a Perl program which is used to create a</source>
          <target state="translated">В общем,в состав распределенного набора для расширения Perl входит файл с именем Makefile.PL,который представляет собой Perl-программу,используемую для создания</target>
        </trans-unit>
        <trans-unit id="3997a59e30d7c4c978daa07218b367eb8d7c9173" translate="yes" xml:space="preserve">
          <source>In general, the easiest path to portability is always to specify filenames in Unix format unless they will need to be processed by native commands or utilities. Because of this latter consideration, the File::Spec module by default returns native format specifications regardless of input format. This default may be reversed so that filenames are always reported in Unix format by specifying the &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; feature logical in the environment.</source>
          <target state="translated">В общем, самый простой путь к переносимости - всегда указывать имена файлов в формате Unix, если только их не нужно обрабатывать с помощью собственных команд или утилит. Из-за этого последнего соображения модуль File :: Spec по умолчанию возвращает спецификации собственного формата независимо от входного формата. Это значение по умолчанию можно изменить, чтобы имена файлов всегда сообщались в формате Unix, указав логическую функцию &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; в среде.</target>
        </trans-unit>
        <trans-unit id="28770c3025c0aede638f676bb8209a09acd6f0b6" translate="yes" xml:space="preserve">
          <source>In general, the perl interpreter views itself as the center of the universe as far as the Perl program goes. XS code is viewed as a help-mate, to accomplish things that perl doesn't do, or doesn't do fast enough, but always subservient to perl. The closer XS code adheres to this model, the less likely conflicts will occur.</source>
          <target state="translated">В общем,интерпретатор Perl рассматривает себя как центр вселенной до тех пор,пока идет программа Perl.Код XS рассматривается как помощник,чтобы выполнять вещи,которые perl не делает или делает недостаточно быстро,но всегда подчиняется perl.Чем ближе код XS к этой модели,тем меньше вероятность возникновения конфликтов.</target>
        </trans-unit>
        <trans-unit id="a1d0e4d941599d8b8058171587801ee612197c61" translate="yes" xml:space="preserve">
          <source>In general, the standard modules work across platforms. Notable exceptions are the &lt;code&gt;CPAN&lt;/code&gt; module (which currently makes connections to external programs that may not be available), platform-specific modules (like &lt;code&gt;ExtUtils::MM_VMS&lt;/code&gt; ), and DBM modules.</source>
          <target state="translated">Обычно стандартные модули работают на разных платформах. Заметными исключениями являются модуль &lt;code&gt;CPAN&lt;/code&gt; (который в настоящее время устанавливает соединения с внешними программами, которые могут быть недоступны), специфичные для платформы модули (например, &lt;code&gt;ExtUtils::MM_VMS&lt;/code&gt; ) и модули DBM.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
