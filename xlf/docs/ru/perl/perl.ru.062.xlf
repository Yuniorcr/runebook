<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="23fce1430ee4d5e6ff2eda3c170c6c5f5f7f9889" translate="yes" xml:space="preserve">
          <source>The stability of these extensions varies widely. Some have been part of the core language for many years. Others are experimental and may change without warning or be completely removed. Check the documentation on an individual feature to verify its current status.</source>
          <target state="translated">Стабильность этих расширений варьируется в широких пределах.Некоторые из них являются частью основного языка на протяжении многих лет.Другие являются экспериментальными и могут изменяться без предупреждения или полностью удаляться.Проверьте документацию по отдельным функциям,чтобы проверить их текущее состояние.</target>
        </trans-unit>
        <trans-unit id="1fd7c6e1c540b52e642a959640d5271791317f81" translate="yes" xml:space="preserve">
          <source>The stack arguments are accessible through the &lt;code&gt;ST(n)&lt;/code&gt; macro, which returns the &lt;code&gt;n&lt;/code&gt; 'th stack argument. Argument 0 is the first argument passed in the Perl subroutine call. These arguments are &lt;code&gt;SV*&lt;/code&gt; , and can be used anywhere an &lt;code&gt;SV*&lt;/code&gt; is used.</source>
          <target state="translated">Аргументы стека доступны через макрос &lt;code&gt;ST(n)&lt;/code&gt; , который возвращает &lt;code&gt;n&lt;/code&gt; -й аргумент стека. Аргумент 0 - это первый аргумент, переданный при вызове подпрограммы Perl. Это аргументы &lt;code&gt;SV*&lt;/code&gt; , и их можно использовать везде, где используется &lt;code&gt;SV*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="607b1af778b28e37b1d81fc8b926b116b2fd196e" translate="yes" xml:space="preserve">
          <source>The stack arguments are accessible through the &lt;code&gt;ST(n)&lt;/code&gt; macro, which returns the &lt;code&gt;n&lt;/code&gt;'th stack argument. Argument 0 is the first argument passed in the Perl subroutine call. These arguments are &lt;code&gt;SV*&lt;/code&gt;, and can be used anywhere an &lt;code&gt;SV*&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a0b1ef2ef458b2d3cc833a6246a76631f78cfb" translate="yes" xml:space="preserve">
          <source>The stack size of currently extant threads cannot be changed, therefore, the following results in the above error:</source>
          <target state="translated">Размер стека существующих в настоящее время потоков не может быть изменен,поэтому приведенная ниже ошибка приводит к ошибке,описанной выше:</target>
        </trans-unit>
        <trans-unit id="852fc28bbec79ad0af0406e767c0c9a99d1cbd8b" translate="yes" xml:space="preserve">
          <source>The standard &lt;a href=&quot;IO::Select&quot;&gt;&lt;code&gt;IO::Select&lt;/code&gt;&lt;/a&gt; module provides a user-friendlier interface to &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38654d44cc2a58273ab5b5792f4d5c5499881e36" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;&lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;Math::BigRat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; modules, along with the &lt;code&gt;bignum&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, and &lt;code&gt;bigrat&lt;/code&gt; pragmas, provide variable-precision arithmetic and overloaded operators, although they're currently pretty slow. At the cost of some space and considerable speed, they avoid the normal pitfalls associated with limited-precision representations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc601a28bc12b4ada50e0942554017adba6dc50b" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; modules, along with the &lt;code&gt;bignum&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; , and &lt;code&gt;bigrat&lt;/code&gt; pragmas, provide variable-precision arithmetic and overloaded operators, although they're currently pretty slow. At the cost of some space and considerable speed, they avoid the normal pitfalls associated with limited-precision representations.</source>
          <target state="translated">Стандартные &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; вместе с &lt;code&gt;bignum&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; и &lt;code&gt;bigrat&lt;/code&gt; предоставляют арифметические операции с переменной точностью и перегруженные операторы, хотя в настоящее время они довольно медленные. За счет некоторого места и значительной скорости они избегают обычных ошибок, связанных с представлениями с ограниченной точностью.</target>
        </trans-unit>
        <trans-unit id="ebb34ffe368cd7aab86ce86e94cbaf4a640b2d39" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">Стандартный модуль &lt;code&gt;IO::Select&lt;/code&gt; предоставляет более удобный интерфейс для &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; , в основном потому, что он выполняет всю работу с битовой маской за вас.</target>
        </trans-unit>
        <trans-unit id="16315bade45df278e7f616f03ff95a3f0a8f22eb" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">Стандартный модуль &lt;code&gt;IO::Select&lt;/code&gt; предоставляет более удобный интерфейс для &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; , в основном потому, что он выполняет всю работу с битовой маской за вас.</target>
        </trans-unit>
        <trans-unit id="7c56d1d9eaa2950435f175be867488228983813f" translate="yes" xml:space="preserve">
          <source>The standard Perl 5 MRO would be (D, B, A, C). The result being that &lt;b&gt;A&lt;/b&gt; appears before &lt;b&gt;C&lt;/b&gt;, even though &lt;b&gt;C&lt;/b&gt; is the subclass of &lt;b&gt;A&lt;/b&gt;. The C3 MRO algorithm however, produces the following order: (D, B, C, A), which does not have this issue.</source>
          <target state="translated">Стандартный Perl 5 MRO будет (D, B, A, C). В результате того , что появляется перед &lt;b&gt;C&lt;/b&gt; , даже если &lt;b&gt;C&lt;/b&gt; является подклассом &lt;b&gt;A&lt;/b&gt; . Однако алгоритм C3 MRO производит следующий порядок: (D, B, C, A), который не имеет этой проблемы.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="65db7a2a2e4a32185cf7e73efd313530e97c3f64" translate="yes" xml:space="preserve">
          <source>The standard Pod::Parser method parse_from_filehandle() takes up to two arguments, the first being the file handle to read POD from and the second being the file handle to write the formatted output to. The first defaults to STDIN if not given, and the second defaults to STDOUT. The method parse_from_file() is almost identical, except that its two arguments are the input and output disk files instead. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for the specific details.</source>
          <target state="translated">Стандартный метод Pod :: Parser parse_from_filehandle () принимает до двух аргументов, первый из которых представляет собой дескриптор файла для чтения POD, а второй - дескриптор файла для записи форматированного вывода. Первый по умолчанию - STDIN, если не указан, а второй - по умолчанию STDOUT. Метод parse_from_file () почти идентичен, за исключением того, что его два аргумента - это входные и выходные файлы на диске. См. &lt;a href=&quot;parser&quot;&gt;Pod :: Parser&lt;/a&gt; для получения более подробной информации.</target>
        </trans-unit>
        <trans-unit id="d459c791ef0819fa116e56f83671629a780f70ae" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_file() takes one argument naming the POD file to read from. By default, the output is sent to &lt;code&gt;STDOUT&lt;/code&gt; , but this can be changed with the output_fh() method.</source>
          <target state="translated">Стандартный метод Pod :: Simple parse_file () принимает один аргумент, называющий файл POD, из которого нужно читать. По умолчанию вывод отправляется в &lt;code&gt;STDOUT&lt;/code&gt; , но это можно изменить с помощью метода output_fh ().</target>
        </trans-unit>
        <trans-unit id="3e6fd6624c64417efc3c147b58226ae1b1c796d2" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_file() takes one argument naming the POD file to read from. By default, the output is sent to &lt;code&gt;STDOUT&lt;/code&gt;, but this can be changed with the output_fh() method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b669405b1331755a6517c831be989ebdf0920199" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_from_file() takes up to two arguments, the first being the input file to read POD from and the second being the file to write the formatted output to.</source>
          <target state="translated">Стандартный метод Pod::Simple parse_from_file()принимает до двух аргументов,первый из которых является входным файлом для чтения POD,а второй-файлом для записи отформатированного вывода.</target>
        </trans-unit>
        <trans-unit id="c21871c0e5568494a7fbe46008b5f9b899656bd2" translate="yes" xml:space="preserve">
          <source>The standard Tie::RefHash module provides a convenient workaround to this.</source>
          <target state="translated">Стандартный модуль Tie::RefHash обеспечивает удобный обходной путь.</target>
        </trans-unit>
        <trans-unit id="baf8b1f6a3bcf32c285c5388e646857a3e93b793" translate="yes" xml:space="preserve">
          <source>The standard Unicode properties listed below are documented in &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;; Perl_Decimal_Digit is documented in &lt;a href=&quot;Unicode::UCD#prop_invmap%28%29&quot;&gt;&quot;prop_invmap()&quot; in Unicode::UCD&lt;/a&gt;. The other Perl extensions are in &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;&quot;Other Properties&quot; in perlunicode&lt;/a&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cc6332c8e3c57e5b8e7b4ce541f13735f1aa06" translate="yes" xml:space="preserve">
          <source>The standard Unicode properties listed below are documented in &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;; Perl_Decimal_Digit is documented in &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt;. The other Perl extensions are in &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;Other Properties in perlunicode&lt;/a&gt;;</source>
          <target state="translated">Стандартные свойства Unicode, перечисленные ниже, задокументированы в &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt; ; Perl_Decimal_Digit задокументирован в &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap () в Unicode :: UCD&lt;/a&gt; . Другие расширения Perl находятся &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;в разделе &amp;laquo;Другие свойства&amp;raquo; в perlunicode&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="fdea898e7a6fa5187cc16e508d0249ddcaeda57c" translate="yes" xml:space="preserve">
          <source>The standard release of Perl (the one maintained by the Perl development team) is distributed only in source code form. You can find the latest releases at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;.</source>
          <target state="translated">Стандартный выпуск Perl (поддерживаемый командой разработчиков Perl) распространяется только в виде исходного кода. Вы можете найти последние выпуски на &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="026f8e314f5a0595f026a7356cc10536cfc51440" translate="yes" xml:space="preserve">
          <source>The standard sections of a manual page are:</source>
          <target state="translated">Стандартные разделы страницы руководства:</target>
        </trans-unit>
        <trans-unit id="da6ced5233b9d24371e1284e5b4cf92ab897f075" translate="yes" xml:space="preserve">
          <source>The standard tools that deal with module distribution (PAUSE, CPAN, etc.) form an identifier for each distribution by joining the 'name' and 'version' attributes with a dash (&lt;code&gt;-&lt;/code&gt;) character. Tools who are prepared to deal with distributions that have no version numbers generally omit the dash as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe88b6db5cc5c12b5e1ae182a8ede9bae134d07" translate="yes" xml:space="preserve">
          <source>The standard typemap does not contain PerlIO * before perl 5.7, but it has the three stream variants. Using a PerlIO * directly is not backwards compatible unless you provide your own typemap.</source>
          <target state="translated">Стандартная типовая карта не содержит PerlIO*до perl 5.7,но имеет три потоковых варианта.Использование PerlIO*напрямую не является обратно совместимым,если только вы не предоставляете свою собственную типовую карту.</target>
        </trans-unit>
        <trans-unit id="a4d40d48d96b939643d17277ad94dfc253906873" translate="yes" xml:space="preserve">
          <source>The standard typemap offers three variants of PerlIO *: &lt;code&gt;InputStream&lt;/code&gt; (T_IN), &lt;code&gt;InOutStream&lt;/code&gt; (T_INOUT) and &lt;code&gt;OutputStream&lt;/code&gt; (T_OUT). A bare &lt;code&gt;PerlIO *&lt;/code&gt; is considered a T_INOUT. If it matters in your code (see below for why it might) #define or typedef one of the specific names and use that as the argument or result type in your XS file.</source>
          <target state="translated">Стандартная карта типов предлагает три варианта PerlIO *: &lt;code&gt;InputStream&lt;/code&gt; (T_IN), &lt;code&gt;InOutStream&lt;/code&gt; (T_INOUT) и &lt;code&gt;OutputStream&lt;/code&gt; (T_OUT). Голый &lt;code&gt;PerlIO *&lt;/code&gt; считаются T_INOUT. Если это имеет значение в вашем коде (см. Ниже, почему это может быть) #define или typedef одно из конкретных имен и используйте его в качестве аргумента или типа результата в вашем XS-файле.</target>
        </trans-unit>
        <trans-unit id="3718e2c8d6baf1715fb8924869dc7062354846f5" translate="yes" xml:space="preserve">
          <source>The standard/default list of directories in which dl_findfile() will search for libraries etc. Directories are searched in order: $dl_library_path[0], [1], ... etc</source>
          <target state="translated">Стандартный/определенный по умолчанию список каталогов,в которых dl_findfile()будет искать библиотеки и т.д.Поиск каталогов осуществляется по порядку:$dl_library_path[0],[1],...и т.д.</target>
        </trans-unit>
        <trans-unit id="81b82092af810ac11d0e71f19aeda4997801a33d" translate="yes" xml:space="preserve">
          <source>The stash associated with a typed lexical. This returns the %Foo:: hash for &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; .</source>
          <target state="translated">Тайник, связанный с типизированной лексикой. Это возвращает% Foo :: hash для &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3fb6f3b4dcfdcba93815cd0cdb0c770846f5f5f" translate="yes" xml:space="preserve">
          <source>The stash associated with a typed lexical. This returns the &lt;code&gt;%Foo::&lt;/code&gt; hash for &lt;code&gt;my Foo $bar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1de13e351b83e422c637b81ca7943274ca516a1" translate="yes" xml:space="preserve">
          <source>The stash for the package code will be compiled into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc4f30ab95381b1c15dfe4d97fa8f832c168bf1d" translate="yes" xml:space="preserve">
          <source>The stash in which this &quot;our&quot; variable was declared.</source>
          <target state="translated">Тайник,в котором была объявлена эта &quot;наша&quot; переменная.</target>
        </trans-unit>
        <trans-unit id="869b087a95d93860c966339061a3c7eb5e7a6410" translate="yes" xml:space="preserve">
          <source>The stat preceding %s wasn't an lstat</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136e96ab03183ea4c3a7028af3545e7d9d5bc253" translate="yes" xml:space="preserve">
          <source>The stat() mode bits are probably right for most of the files and directories found on your system, because few people want to use the additional features offered by access(). But you may encounter surprises if your program runs on a system that uses ACLs, since the stat() information won't reflect the actual permissions.</source>
          <target state="translated">Биты режима stat(),вероятно,подходят для большинства файлов и каталогов,найденных в вашей системе,потому что мало кто хочет использовать дополнительные возможности,предлагаемые функцией access().Но вы можете столкнуться с неожиданностями,если ваша программа работает в системе,использующей ACL,так как информация stat()не будет отражать реальные права доступа.</target>
        </trans-unit>
        <trans-unit id="e8e71255cf8fb3fde9520415463a7e71c11cd3c9" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; doesn't change the current position, but it does clear the end-of-file condition on the handle, so that the next &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; makes Perl try again to read something.</source>
          <target state="translated">Оператор &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; не изменяет текущую позицию, но очищает условие конца файла для дескриптора, так что следующий &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; заставляет Perl снова попытаться прочитать что-то.</target>
        </trans-unit>
        <trans-unit id="29c5f769bcdc76ec76db73fb881f9e3de17be2e0" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;seek($gw_fh, 0, 1)&lt;/code&gt; doesn't change the current position, but it does clear the end-of-file condition on the handle, so that the next &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; makes Perl try again to read something.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="707171be35bdd3b79efa241046dd3631507040a6" translate="yes" xml:space="preserve">
          <source>The status 2 indicates that at least one of the specified files does not contain</source>
          <target state="translated">Статус 2 указывает на то,что хотя бы один из указанных файлов не содержит</target>
        </trans-unit>
        <trans-unit id="9251e77389b34b5c344d864eb779d11058b888c5" translate="yes" xml:space="preserve">
          <source>The status code returned from &lt;code&gt;inflate&lt;/code&gt; will only trigger termination of the main processing loop if it isn't &lt;code&gt;Z_OK&lt;/code&gt; . When &lt;code&gt;LimitOutput&lt;/code&gt; has not been used the &lt;code&gt;Z_OK&lt;/code&gt; status means that the end of the compressed data stream has been reached or there has been an error in uncompression.</source>
          <target state="translated">Код состояния, возвращаемый из &lt;code&gt;inflate&lt;/code&gt; , вызовет завершение основного цикла обработки, только если это не &lt;code&gt;Z_OK&lt;/code&gt; . Когда &lt;code&gt;LimitOutput&lt;/code&gt; не использовался, статус &lt;code&gt;Z_OK&lt;/code&gt; означает, что достигнут конец потока сжатых данных или произошла ошибка при распаковке.</target>
        </trans-unit>
        <trans-unit id="779e93e5e5c79de152e0d904d8c2cb9d0f5d9a7f" translate="yes" xml:space="preserve">
          <source>The status code returned from &lt;code&gt;inflate&lt;/code&gt; will only trigger termination of the main processing loop if it isn't &lt;code&gt;Z_OK&lt;/code&gt;. When &lt;code&gt;LimitOutput&lt;/code&gt; has not been used the &lt;code&gt;Z_OK&lt;/code&gt; status means that the end of the compressed data stream has been reached or there has been an error in uncompression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2298239a448f47305c5dbab535dd02c58c7526e3" translate="yes" xml:space="preserve">
          <source>The status of the hushed flag also affects output of VMS error messages from compilation errors. Again, you still get the Perl error message (and the code in $STATUS)</source>
          <target state="translated">Статус затихшего флага также влияет на вывод сообщений об ошибках VMS от ошибок компиляции.Опять же,вы все равно получаете сообщение об ошибке Perl (и код в $STATUS).</target>
        </trans-unit>
        <trans-unit id="4cb40ccf1b5efc1b553ba9f11bd2e4b83ffc7264" translate="yes" xml:space="preserve">
          <source>The status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt; ) command, successful call to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;, or from the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; operator. This is just the 16-bit status word returned by the traditional Unix &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; system call (or else is made up to look like it). Thus, the exit value of the subprocess is really (&lt;code&gt;$?&amp;gt;&amp;gt;
8&lt;/code&gt; ), and &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; gives which signal, if any, the process died from, and &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; reports whether there was a core dump.</source>
          <target state="translated">Статус, возвращаемый последним закрытием канала, командой обратной кавычки ( &lt;code&gt;``&lt;/code&gt; ), успешным вызовом &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; или оператором &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; . Это всего лишь 16-битное слово состояния, возвращаемое традиционным системным вызовом Unix &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; (или иначе созданное так, чтобы оно выглядело). Таким образом, значение выхода подпроцесса действительно ( &lt;code&gt;$?&amp;gt;&amp;gt; 8&lt;/code&gt; ), а &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; дает сигнал, из-за которого процесс умер, а &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; сообщает, был ли дамп ядра.</target>
        </trans-unit>
        <trans-unit id="9f58cb3cab9b9d58145034f89f71fdaeeb21297a" translate="yes" xml:space="preserve">
          <source>The status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt;) command, successful call to &lt;code&gt;wait()&lt;/code&gt; or &lt;code&gt;waitpid()&lt;/code&gt;, or from the &lt;code&gt;system()&lt;/code&gt; operator. This is just the 16-bit status word returned by the traditional Unix &lt;code&gt;wait()&lt;/code&gt; system call (or else is made up to look like it). Thus, the exit value of the subprocess is really (&lt;code&gt;$? &amp;gt;&amp;gt; 8&lt;/code&gt;), and &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; gives which signal, if any, the process died from, and &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; reports whether there was a core dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6450e7782a48b71f2dca0230b4493dd10ff37ce5" translate="yes" xml:space="preserve">
          <source>The status value that is returned by the user's &lt;code&gt;filter&lt;/code&gt; method or anonymous sub and the &lt;code&gt;filter_read&lt;/code&gt; and &lt;code&gt;read_exact&lt;/code&gt; functions take the same set of values, namely:</source>
          <target state="translated">Значение статуса, возвращаемое пользовательским методом &lt;code&gt;filter&lt;/code&gt; или анонимной подпрограммой, и функции &lt;code&gt;filter_read&lt;/code&gt; и &lt;code&gt;read_exact&lt;/code&gt; принимают один и тот же набор значений, а именно:</target>
        </trans-unit>
        <trans-unit id="2660ee0526b1b40a8d851a0826ec3b948b6dbdee" translate="yes" xml:space="preserve">
          <source>The stdio(3C) manpage notes that for LP32 applications, only 255 files may be opened using fopen(), and only file descriptors 0 through 255 can be used in a stream. Since perl calls open() and then fdopen(3C) with the resulting file descriptor, perl is limited to 255 simultaneous open files, even if sysopen() is used. If this proves to be an insurmountable problem, you can compile perl as a LP64 application, see &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;&quot;Building an LP64 perl&quot;&lt;/a&gt; for details. Note also that the default resource limit for open file descriptors on Solaris is 255, so you will have to modify your ulimit or rctl (Solaris 9 onwards) appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8220a76d45ce112350b70ee4dbd73fc8b8bc74" translate="yes" xml:space="preserve">
          <source>The stdio(3C) manpage notes that for LP32 applications, only 255 files may be opened using fopen(), and only file descriptors 0 through 255 can be used in a stream. Since perl calls open() and then fdopen(3C) with the resulting file descriptor, perl is limited to 255 simultaneous open files, even if sysopen() is used. If this proves to be an insurmountable problem, you can compile perl as a LP64 application, see &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;Building an LP64 perl&lt;/a&gt; for details. Note also that the default resource limit for open file descriptors on Solaris is 255, so you will have to modify your ulimit or rctl (Solaris 9 onwards) appropriately.</source>
          <target state="translated">В справочной странице stdio (3C) отмечается, что для приложений LP32 с помощью fopen () можно открыть только 255 файлов, а в потоке можно использовать только файловые дескрипторы с 0 по 255. Поскольку perl вызывает open (), а затем fdopen (3C) с результирующим файловым дескриптором, perl ограничен до 255 одновременных открытых файлов, даже если используется sysopen (). Если это окажется непреодолимой проблемой, вы можете скомпилировать Perl как приложение LP64, подробности см. В разделе &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;Создание LP64 perl&lt;/a&gt; . Также обратите внимание, что ограничение ресурсов по умолчанию для дескрипторов открытых файлов в Solaris составляет 255, поэтому вам придется соответствующим образом изменить свой ulimit или rctl (Solaris 9 и далее).</target>
        </trans-unit>
        <trans-unit id="5a65b444e930fbaa9c0e870b3e72484e3ba2cfa8" translate="yes" xml:space="preserve">
          <source>The steps above are in a very specific order, designed to be the reverse order of when the context was pushed. The first thing to do is to copy and/or protect any return arguments and free any temps in the current scope. Scope exits like an rvalue sub normally return a mortal copy of their return args (as opposed to lvalue subs). It is important to make this copy before the save stack is popped or variables are restored, or bad things like the following can happen:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00bff96ca21371570b04e3ba98b01671b01481ae" translate="yes" xml:space="preserve">
          <source>The store functions will &lt;code&gt;croak&lt;/code&gt; if they run into such references unless you set &lt;code&gt;$Storable::forgive_me&lt;/code&gt; to some &lt;code&gt;TRUE&lt;/code&gt; value. In that case, the fatal message is converted to a warning and some meaningless string is stored instead.</source>
          <target state="translated">Функции хранилища будут &lt;code&gt;croak&lt;/code&gt; если они сталкиваются с такими ссылками, если вы не установите &lt;code&gt;$Storable::forgive_me&lt;/code&gt; в какое-то значение &lt;code&gt;TRUE&lt;/code&gt; . В этом случае фатальное сообщение преобразуется в предупреждение, и вместо него сохраняется некоторая бессмысленная строка.</target>
        </trans-unit>
        <trans-unit id="af1c1657bd0ce03b1ba6ae64acc2840b7f31bd40" translate="yes" xml:space="preserve">
          <source>The strend and patend pointers should point to the byte following the last character of each string.</source>
          <target state="translated">Указатели стренд и патендов должны указывать на байт,следующий за последним символом каждой строки.</target>
        </trans-unit>
        <trans-unit id="ccae9ac2ba65b56262ababed8ca5ba389eb0ed32" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; . (Ths tells Perl to use the &lt;code&gt;NDBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="translated">Строка &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; . (Это говорит Perl использовать пакет &lt;code&gt;NDBM_File&lt;/code&gt; для выполнения функций хэша.)</target>
        </trans-unit>
        <trans-unit id="0acc3252158ec09fb79d744584bd9ec310ab3fc7" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt;. (Ths tells Perl to use the &lt;code&gt;NDBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bebcac85b77891a0ebb57e146c479aea7f7cca3" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;ODBM_File&quot;&lt;/code&gt;. (Ths tells Perl to use the &lt;code&gt;ODBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c77c76e1fc3205395047a2345f8ef41459d3bb" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;$vec&lt;/code&gt; only takes up as many bits as it needs. For instance, if you had 16 entries in &lt;code&gt;@ints&lt;/code&gt; , &lt;code&gt;$vec&lt;/code&gt; only needs two bytes to store them (not counting the scalar variable overhead).</source>
          <target state="translated">Строка &lt;code&gt;$vec&lt;/code&gt; занимает ровно столько битов, сколько ей нужно. Например, если у вас было 16 записей в &lt;code&gt;@ints&lt;/code&gt; , &lt;code&gt;$vec&lt;/code&gt; нужно всего два байта для их хранения (не считая накладных расходов на скалярную переменную).</target>
        </trans-unit>
        <trans-unit id="dc49e0b476d0350280c159b76d14abbf494b1cf7" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;$vec&lt;/code&gt; only takes up as many bits as it needs. For instance, if you had 16 entries in &lt;code&gt;@ints&lt;/code&gt;, &lt;code&gt;$vec&lt;/code&gt; only needs two bytes to store them (not counting the scalar variable overhead).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace981c506425cb8cbcfe9d653a843e517d5bdac" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; has six graphemes but up to eight codepoints. This counts by grapheme, not by codepoint:</source>
          <target state="translated">Строка &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; имеет шесть графем, но до восьми кодовых точек. Это считается графемой, а не кодом:</target>
        </trans-unit>
        <trans-unit id="c8568d09543e0ac94aa7c4682834b259e167d475" translate="yes" xml:space="preserve">
          <source>The string bitwise operators, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt;, treat their operands as strings of bytes. As such, values above 0xFF are nonsensical. Some instances of these have been deprecated since Perl 5.24, and were made fatal in 5.28, but it turns out that in cases where the wide characters did not affect the end result, no deprecation notice was raised, and so remain legal. Now, all occurrences either are fatal or raise a deprecation warning, so that the remaining legal occurrences became fatal in 5.32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5487cb3c1b5dd51f93004e758fb4f77bc307a840" translate="yes" xml:space="preserve">
          <source>The string bitwise operators, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt;, treat their operands as strings of bytes. As such, values above 0xFF are nonsensical. Using such code points with these operators was deprecated in Perl 5.24, and is fatal as of Perl 5.28.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e842cb2ff66d209b19263b7c79265ed68c6571d7" translate="yes" xml:space="preserve">
          <source>The string following whatever was matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK). Example:</source>
          <target state="translated">Строка, следующая за тем, что совпадало с последним успешным совпадением с шаблоном (не считая совпадений, скрытых внутри BLOCK или &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; заключенных в текущий BLOCK). Пример:</target>
        </trans-unit>
        <trans-unit id="3ba0048f660cfcd3f32cbfe2f76535c5c8d897d2" translate="yes" xml:space="preserve">
          <source>The string following whatever was matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;eval()&lt;/code&gt; enclosed by the current BLOCK). Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64817d2b5e56c060bf38149d53adb10efe254293" translate="yes" xml:space="preserve">
          <source>The string for Tuesday, December 12, 1995.</source>
          <target state="translated">Струна на вторник,12 декабря 1995 года.</target>
        </trans-unit>
        <trans-unit id="f9abb06eb1806839c0e5b7b9bda35c81b35ae824" translate="yes" xml:space="preserve">
          <source>The string index to a &lt;b&gt;hash&lt;/b&gt;, used to look up the &lt;b&gt;value&lt;/b&gt; associated with that key.</source>
          <target state="translated">Строковый индекс &lt;b&gt;хэша&lt;/b&gt; , используемый для поиска &lt;b&gt;значения,&lt;/b&gt; связанного с этим ключом.</target>
        </trans-unit>
        <trans-unit id="b6885316bc4f379b0a1d01488371bab62a2d9d85" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdaff357d54d31b09acea6f6d18fd623eddeb9f1" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">Строка разбита на части, описанные ШАБЛОНОМ. Каждый фрагмент отдельно преобразуется в значение. Обычно либо строка является результатом &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; , либо символы строки представляют собой какую-либо структуру C.</target>
        </trans-unit>
        <trans-unit id="1c49e7731d3dc172a2f14e1ee383fed675a44e84" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">Строка разбита на части, описанные ШАБЛОНОМ. Каждый фрагмент отдельно преобразуется в значение. Обычно либо строка является результатом &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; , либо символы строки представляют собой какую-либо структуру C.</target>
        </trans-unit>
        <trans-unit id="188acb1539bbcc7515d5af86f1bf3d6e3f0bd9c0" translate="yes" xml:space="preserve">
          <source>The string matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK).</source>
          <target state="translated">Строка, совпадающая с последним успешным совпадением с шаблоном (не считая совпадений, скрытых в BLOCK или &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; заключенных в текущий BLOCK).</target>
        </trans-unit>
        <trans-unit id="e9cf9b6b7809255e19e6a3b715176fe34d8d904e" translate="yes" xml:space="preserve">
          <source>The string matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;eval()&lt;/code&gt; enclosed by the current BLOCK).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c0c038ca187cf5160e57a2c61c41440d3e8e16" translate="yes" xml:space="preserve">
          <source>The string output (of floating point numbers) is padded with zeros:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d206cfe2e19b0f3779f91c6d76bdde7d7e22deb" translate="yes" xml:space="preserve">
          <source>The string output (of floating point numbers) will be padded with zeros:</source>
          <target state="translated">Вывод строки (чисел с плавающей точкой)будет дополнен нулями:</target>
        </trans-unit>
        <trans-unit id="baf7cbc523832c454565f07354dbdc53faf7a98a" translate="yes" xml:space="preserve">
          <source>The string output will always have leading and trailing zeros stripped and drop a plus sign. &lt;code&gt;bstr()&lt;/code&gt; will give you always the form with a decimal point, while &lt;code&gt;bsstr()&lt;/code&gt; (s for scientific) gives you the scientific notation.</source>
          <target state="translated">В строковом выводе всегда будут удалены начальные и конечные нули и будет пропущен знак плюса. &lt;code&gt;bstr()&lt;/code&gt; всегда будет давать вам форму с десятичной точкой, а &lt;code&gt;bsstr()&lt;/code&gt; (s для научных) дает вам научную нотацию.</target>
        </trans-unit>
        <trans-unit id="fe7b97aace0009c030b7f9cefcb2ca042c7263c6" translate="yes" xml:space="preserve">
          <source>The string preceding whatever was matched by the last successful pattern match, not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK.</source>
          <target state="translated">Строка, предшествующая тому, что совпадало с последним успешным совпадением с шаблоном, не считая совпадений, скрытых в BLOCK или &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , заключенных в текущий BLOCK.</target>
        </trans-unit>
        <trans-unit id="7f5e6eea58cb9fa29a6890f23f4c2850f3c5d5cc" translate="yes" xml:space="preserve">
          <source>The string preceding whatever was matched by the last successful pattern match, not counting any matches hidden within a BLOCK or &lt;code&gt;eval&lt;/code&gt; enclosed by the current BLOCK.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="339432ba64926aa8fa758ffc110e1d9819cad770" translate="yes" xml:space="preserve">
          <source>The string result of any operation that uses locale information is tainted, as it is possible for a locale to be untrustworthy. See &lt;a href=&quot;#SECURITY&quot;&gt;&quot;SECURITY&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d01fff15593695c94b4861cde9efd9b7494ec49" translate="yes" xml:space="preserve">
          <source>The string result of any operation that uses locale information is tainted, as it is possible for a locale to be untrustworthy. See &lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt;.</source>
          <target state="translated">Строковый результат любой операции, использующей информацию о языковом стандарте, испорчен, поскольку языковой стандарт может быть ненадежным. Смотрите &lt;a href=&quot;#SECURITY&quot;&gt;БЕЗОПАСНОСТЬ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8fe36e2f9f506bb3c17ca908f63a229076cb522b" translate="yes" xml:space="preserve">
          <source>The string returned is not always in NFD/NFKD. Reordering may be required.</source>
          <target state="translated">Возвращаемая строка не всегда находится в NFD/NFKD.Может потребоваться переупорядочивание.</target>
        </trans-unit>
        <trans-unit id="2d311addc77468e8c33d61dc204474a00d32a5a2" translate="yes" xml:space="preserve">
          <source>The string that represents the C type that was not found in the typemap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0906d45502ea0bd7da882f8e89531d4e1f01bc75" translate="yes" xml:space="preserve">
          <source>The string that starts options. If a constant string is not sufficient, see &lt;code&gt;prefix_pattern&lt;/code&gt; .</source>
          <target state="translated">Строка, с которой начинается options. Если постоянной строки недостаточно, см. &lt;code&gt;prefix_pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efa5933751bfaa2a6c4eeedd57fd05169704edd2" translate="yes" xml:space="preserve">
          <source>The string that starts options. If a constant string is not sufficient, see &lt;code&gt;prefix_pattern&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcff2e1cc42c11b32cad489cc398585a2adb0338" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by</source>
          <target state="translated">Вставляемая строка представлена следующим образом</target>
        </trans-unit>
        <trans-unit id="00f6f2add8143f7b5f6195521c58d01172830e33" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by &lt;code&gt;len&lt;/code&gt; octets starting at &lt;code&gt;pv&lt;/code&gt;. These octets are interpreted as either UTF-8 or Latin-1, according to whether the &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; flag is set in &lt;code&gt;flags&lt;/code&gt;. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;). If a string to be inserted is available as a Perl scalar, the &lt;a href=&quot;#lex_stuff_sv&quot;&gt;&quot;lex_stuff_sv&quot;&lt;/a&gt; function is more convenient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41abf45c9431728dd7313f8c098905bb3fb1c5d" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by octets starting at</source>
          <target state="translated">Вставляемая строка представлена октетами,начинающимися от</target>
        </trans-unit>
        <trans-unit id="c0c0bf345ccfdae0fb09cf9ab2d8e8d8ae4c0512" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by octets starting at &lt;code&gt;pv&lt;/code&gt; and continuing to the first nul. These octets are interpreted as either UTF-8 or Latin-1, according to whether the &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; flag is set in &lt;code&gt;flags&lt;/code&gt;. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;). If it is not convenient to nul-terminate a string to be inserted, the &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;&quot;lex_stuff_pvn&quot;&lt;/a&gt; function is more appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afbb1230317b082fc0f64afe5f1a79c6e5661e9b" translate="yes" xml:space="preserve">
          <source>The string to be inserted is the string value of</source>
          <target state="translated">Вставляемая строка является строковым значением параметра</target>
        </trans-unit>
        <trans-unit id="55208eb6676e3f7f6524a3ebd4f29e07cc0731fc" translate="yes" xml:space="preserve">
          <source>The string to be inserted is the string value of &lt;code&gt;sv&lt;/code&gt;. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;). If a string to be inserted is not already a Perl scalar, the &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;&quot;lex_stuff_pvn&quot;&lt;/a&gt; function avoids the need to construct a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a627ebdca058ca40f7afebaa0947770e3b19935" translate="yes" xml:space="preserve">
          <source>The string value of &lt;code&gt;$!&lt;/code&gt; is that returned by the CRTL's strerror() function, so it will include the VMS message for VMS-specific errors. The numeric value of &lt;code&gt;$!&lt;/code&gt; is the value of &lt;code&gt;errno&lt;/code&gt; , except if errno is EVMSERR, in which case &lt;code&gt;$!&lt;/code&gt; contains the value of vaxc$errno. Setting &lt;code&gt;$!&lt;/code&gt; always sets errno to the value specified. If this value is EVMSERR, it also sets vaxc$errno to 4 (NONAME-F-NOMSG), so that the string value of &lt;code&gt;$!&lt;/code&gt; won't reflect the VMS error message from before &lt;code&gt;$!&lt;/code&gt; was set.</source>
          <target state="translated">Строковое значение &lt;code&gt;$!&lt;/code&gt; это то, что возвращается функцией strerror () CRTL, поэтому она будет включать сообщение VMS для ошибок, специфичных для VMS. Числовое значение &lt;code&gt;$!&lt;/code&gt; - значение &lt;code&gt;errno&lt;/code&gt; , кроме случая, когда errno - EVMSERR, и в этом случае &lt;code&gt;$!&lt;/code&gt; содержит значение vaxc $ errno. Установка &lt;code&gt;$!&lt;/code&gt; всегда устанавливает errno равным указанному значению. Если это значение EVMSERR, оно также устанавливает vaxc $ errno равным 4 (NONAME-F-NOMSG), так что строковое значение &lt;code&gt;$!&lt;/code&gt; не будет отображать сообщение об ошибке VMS до &lt;code&gt;$!&lt;/code&gt; был установлен.</target>
        </trans-unit>
        <trans-unit id="6bce1054a07cc28e1b64ace7f7b805802c74829f" translate="yes" xml:space="preserve">
          <source>The string value of &lt;code&gt;$!&lt;/code&gt; is that returned by the CRTL's strerror() function, so it will include the VMS message for VMS-specific errors. The numeric value of &lt;code&gt;$!&lt;/code&gt; is the value of &lt;code&gt;errno&lt;/code&gt;, except if errno is EVMSERR, in which case &lt;code&gt;$!&lt;/code&gt; contains the value of vaxc$errno. Setting &lt;code&gt;$!&lt;/code&gt; always sets errno to the value specified. If this value is EVMSERR, it also sets vaxc$errno to 4 (NONAME-F-NOMSG), so that the string value of &lt;code&gt;$!&lt;/code&gt; won't reflect the VMS error message from before &lt;code&gt;$!&lt;/code&gt; was set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1f52a4cdbc897685e0ae4db35f3139cd121ffc" translate="yes" xml:space="preserve">
          <source>The string value of the $data provided as argument is appended to the message we calculate the digest for. The return value is the $ctx object itself.</source>
          <target state="translated">Строковое значение $data,предоставленное в качестве аргумента,добавляется к сообщению,для которого мы вычисляем дайджест.Возвращаемым значением является сам объект $ctx.</target>
        </trans-unit>
        <trans-unit id="7a8e800596cb341c8f599d3168bdf4ec9c0dbea7" translate="yes" xml:space="preserve">
          <source>The strings returned may not be useful for 3-argument open().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1b5858acfdd756a7774d6480e810b1c2f37266" translate="yes" xml:space="preserve">
          <source>The stroke ordering includes some characters that are not CJK Unified Ideographs and can't utilize &lt;code&gt;weightStroke()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d2353f63db6ded15b27f9ce53f46b40b4850e7c" translate="yes" xml:space="preserve">
          <source>The struct() function</source>
          <target state="translated">Функция struct()</target>
        </trans-unit>
        <trans-unit id="2b18f7164a2da5acc0a078abefbfdb45f1b7ed1a" translate="yes" xml:space="preserve">
          <source>The structure of the tied() data is an array reference with elements</source>
          <target state="translated">Структура данных tied()представляет собой ссылку на массив с элементами</target>
        </trans-unit>
        <trans-unit id="6772fe1a2535c049980c3763958a49b4c1d992f9" translate="yes" xml:space="preserve">
          <source>The stub package included with the perl distribution allows some additional methods:</source>
          <target state="translated">Пакет stub,входящий в состав дистрибутива perl,позволяет использовать некоторые дополнительные методы:</target>
        </trans-unit>
        <trans-unit id="69dca73bafb51f0fe392c69e65938a9183f98a5b" translate="yes" xml:space="preserve">
          <source>The sub will receive exactly 1 argument, the type of thing being tagged 'context', 'hub', or 'event'. In the future additional things may be tagged, in which case new strings will be passed in. These are purely informative, you can (and usually should) ignore them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c28ea2e9a2d4863b1fc0e89e9b8c44c6fa89947" translate="yes" xml:space="preserve">
          <source>The sub you provide should always return a unique identifier. Most things will expect a proper UUID string, however nothing in Test2::API enforces this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bfcc48f6a94ab4b3e39e57492b7c1d6d2ad759d" translate="yes" xml:space="preserve">
          <source>The submitter address in &lt;code&gt;AUTH&lt;/code&gt; option is expected to be in a format as required by RFC 2554, in an RFC2821-quoted form and xtext-encoded, or &amp;lt;&amp;gt; .</source>
          <target state="translated">Предполагается, что адрес отправителя в опции &lt;code&gt;AUTH&lt;/code&gt; будет в формате, требуемом RFC 2554, в форме, заключенной в кавычки RFC2821 и в кодировке xtext, или &amp;lt;&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="4ac8a2878ef2e11af070ab32ec1a2e0bca8078f0" translate="yes" xml:space="preserve">
          <source>The subroutine (including package) that threw the exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99602f0147c6aaadcc127e8f752211c7da8fb282" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'='&lt;/code&gt; does not overload the Perl assignment operator: it is used only to allow mutators to work as described here. (See &lt;a href=&quot;#Assignments&quot;&gt;&quot;Assignments&quot;&lt;/a&gt; above.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb6dff8391b18be99fd9ebb7eb204cdfa56639a" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'='&lt;/code&gt; does not overload the Perl assignment operator: it is used only to allow mutators to work as described here. (See &lt;a href=&quot;#Assignments&quot;&gt;Assignments&lt;/a&gt; above.)</source>
          <target state="translated">Подпрограмма для &lt;code&gt;'='&lt;/code&gt; не перегружает оператор присваивания Perl: она используется только для того, чтобы мутаторы работали, как описано здесь. (См. &lt;a href=&quot;#Assignments&quot;&gt;Задания&lt;/a&gt; выше.)</target>
        </trans-unit>
        <trans-unit id="f6d2e2cf74b94dd2aff54191a4db818c472b013b" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'qr'&lt;/code&gt; is used wherever the object is interpolated into or used as a regexp, including when it appears on the RHS of a &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator.</source>
          <target state="translated">Подпрограмма для &lt;code&gt;'qr'&lt;/code&gt; используется везде, где объект интерполируется или используется как регулярное выражение, в том числе когда он появляется в правой части оператора &lt;code&gt;=~&lt;/code&gt; или &lt;code&gt;!~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64e556905a1003da7539606b5717985b47db5c9d" translate="yes" xml:space="preserve">
          <source>The subroutine for the assignment variant of an operator is required only to return the result of the operation. It is permitted to change the value of its operand (this is safe because Perl calls the copy constructor first), but this is optional since Perl assigns the returned value to the left-hand operand anyway.</source>
          <target state="translated">Подпрограмма для варианта назначения оператора требуется только для возврата результата операции.Допускается изменять значение своего операнда (это безопасно,так как Perl сначала вызывает конструктор копирования),но это необязательно,так как Perl все равно присваивает возвращаемое значение левому операнду.</target>
        </trans-unit>
        <trans-unit id="ae06f7431af42fbc790df16df23af545b2646544" translate="yes" xml:space="preserve">
          <source>The subroutine interface has the advantage over the constants interface in that only two subroutines are exported into your namespace, versus thirty-eight in the constants interface, and aliases and true color attributes are supported. On the flip side, the constants interface has the advantage of better compile time error checking, since misspelled names of colors or attributes in calls to color() and colored() won't be caught until runtime whereas misspelled names of constants will be caught at compile time. So, pollute your namespace with almost two dozen subroutines that you may not even use that often, or risk a silly bug by mistyping an attribute. Your choice, TMTOWTDI after all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf76f7497b47b7fb391cbc985e75a2ec906b200f" translate="yes" xml:space="preserve">
          <source>The subroutine interface has the advantage over the constants interface in that only two subroutines are exported into your namespace, versus thirty-eight in the constants interface. On the flip side, the constants interface has the advantage of better compile time error checking, since misspelled names of colors or attributes in calls to color() and colored() won't be caught until runtime whereas misspelled names of constants will be caught at compile time. So, pollute your namespace with almost two dozen subroutines that you may not even use that often, or risk a silly bug by mistyping an attribute. Your choice, TMTOWTDI after all.</source>
          <target state="translated">Интерфейс подпрограммы имеет преимущество перед интерфейсом констант в том,что в пространство имен экспортируются только две подпрограммы,по сравнению с тридцатью восемью в интерфейсе констант.На обратной стороне,интерфейс констант имеет преимущество лучшей проверки ошибок компиляции,так как неправильно написанные имена цветов или атрибутов в вызовах color()и color()не будут пойманы до выполнения,в то время как неправильно написанные имена констант будут пойманы во время компиляции.Таким образом,загрязните ваше пространство имён почти двумя десятками подпрограмм,которые вы можете даже не использовать так часто,или рискуете получить глупую ошибку,неправильно написав атрибут.В конце концов,это ваш выбор,TMTOWTDI.</target>
        </trans-unit>
        <trans-unit id="914a52e2466ed981c0c31fa5a16b3a84e13235bf" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to five optional arguments:</source>
          <target state="translated">Подпрограмма принимает до пяти необязательных аргументов:</target>
        </trans-unit>
        <trans-unit id="685ad04169c11394ad7ed60a2bfecf22cb675ffa" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments (the same set as &lt;code&gt;extract_tagged&lt;/code&gt; except for the string to be processed). It returns a reference to a subroutine which in turn takes a single argument (the text to be extracted from).</source>
          <target state="translated">Подпрограмма принимает до четырех необязательных аргументов (тот же набор, что и &lt;code&gt;extract_tagged&lt;/code&gt; , за исключением обрабатываемой строки). Он возвращает ссылку на подпрограмму, которая, в свою очередь, принимает единственный аргумент (текст, из которого нужно извлечь).</target>
        </trans-unit>
        <trans-unit id="8d893978d831c7b5b97d6abcf392307452f2c4dc" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments:</source>
          <target state="translated">Подпрограмма принимает до четырех необязательных аргументов:</target>
        </trans-unit>
        <trans-unit id="7612ae6125d2980d42108a51846f43870c13a8ab" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to two optional arguments:</source>
          <target state="translated">Подпрограмма принимает до двух необязательных аргументов:</target>
        </trans-unit>
        <trans-unit id="e4c12336d2e867ba9a727cf78cc335118965b26b" translate="yes" xml:space="preserve">
          <source>The subroutine that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc2edb73f368d2c8247ff6673cfa64dcc7b4601" translate="yes" xml:space="preserve">
          <source>The subroutine will have &lt;code&gt;CvFILE&lt;/code&gt; set according to &lt;code&gt;PL_curcop&lt;/code&gt;. Other aspects of the subroutine will be left in their default state. The caller is free to mutate the subroutine beyond its initial state after this function has returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="265ef174cfb1c0102c91c9689e3bcac20840f609" translate="yes" xml:space="preserve">
          <source>The subroutine will have an empty prototype and will ignore any arguments when called. Its constant behaviour is determined by &lt;code&gt;sv&lt;/code&gt;. If &lt;code&gt;sv&lt;/code&gt; is null, the subroutine will yield an empty list. If &lt;code&gt;sv&lt;/code&gt; points to a scalar, the subroutine will always yield that scalar. If &lt;code&gt;sv&lt;/code&gt; points to an array, the subroutine will always yield a list of the elements of that array in list context, or the number of elements in the array in scalar context. This function takes ownership of one counted reference to the scalar or array, and will arrange for the object to live as long as the subroutine does. If &lt;code&gt;sv&lt;/code&gt; points to a scalar then the inlining assumes that the value of the scalar will never change, so the caller must ensure that the scalar is not subsequently written to. If &lt;code&gt;sv&lt;/code&gt; points to an array then no such assumption is made, so it is ostensibly safe to mutate the array or its elements, but whether this is really supported has not been determined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f27fb61975933bf23afb22d7dcc89dbb6c6b52" translate="yes" xml:space="preserve">
          <source>The subroutine will have the entry point &lt;code&gt;subaddr&lt;/code&gt;. It will have the prototype specified by the nul-terminated string &lt;code&gt;proto&lt;/code&gt;, or no prototype if &lt;code&gt;proto&lt;/code&gt; is null. The prototype string is copied; the caller can mutate the supplied string afterwards. If &lt;code&gt;filename&lt;/code&gt; is non-null, it must be a nul-terminated filename, and the subroutine will have its &lt;code&gt;CvFILE&lt;/code&gt; set accordingly. By default &lt;code&gt;CvFILE&lt;/code&gt; is set to point directly to the supplied string, which must be static. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;XS_DYNAMIC_FILENAME&lt;/code&gt; bit set, then a copy of the string will be taken instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a75faaa2a2f313dd76bd18e70bc1892ae4231d3" translate="yes" xml:space="preserve">
          <source>The subroutines for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; , and &lt;code&gt;'bool'&lt;/code&gt; can return any arbitrary Perl value. If the corresponding operation for this value is overloaded too, the operation will be called again with this value.</source>
          <target state="translated">Подпрограммы для &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; и &lt;code&gt;'bool'&lt;/code&gt; могут возвращать любое произвольное значение Perl. Если соответствующая операция для этого значения также перегружена, операция будет вызвана снова с этим значением.</target>
        </trans-unit>
        <trans-unit id="740359d4d5595e110911a4995def79d738d321f7" translate="yes" xml:space="preserve">
          <source>The subroutines for &lt;code&gt;'&quot;&quot;'&lt;/code&gt;, &lt;code&gt;'0+'&lt;/code&gt;, and &lt;code&gt;'bool'&lt;/code&gt; can return any arbitrary Perl value. If the corresponding operation for this value is overloaded too, the operation will be called again with this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268a5bcbdfddf71f1babd661a5336aa5d10c3ae8" translate="yes" xml:space="preserve">
          <source>The subroutines must return a specially-formatted string, with one or more newline-separated lines. Each line must be one of the following:</source>
          <target state="translated">Подпрограммы должны возвращать специально отформатированную строку,с одной или несколькими строками,разделенными на новые.Каждая строка должна быть одной из следующих:</target>
        </trans-unit>
        <trans-unit id="2ba07955562198fe0f02a6cf2bc902a4d38ec5bc" translate="yes" xml:space="preserve">
          <source>The subscript separator for multidimensional array emulation. If you refer to a hash element as</source>
          <target state="translated">Разделитель подскриптов для эмуляции многомерных массивов.Если вы ссылаетесь на хэш-элемент как</target>
        </trans-unit>
        <trans-unit id="b5d318f376ec00a74018e4ca7dc7c929a2558708" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Оператор подстановки. Смотрите &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96c15efd757813123cfb6bdf82217c841dbb4c27" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdda388fa507341e8fbaf2711ecce13a77670278" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Оператор подстановки. Смотрите &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43eed4ac710279951c5f21e178623c718cf97122" translate="yes" xml:space="preserve">
          <source>The substring to be extracted must appear at the current &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; location of the string's variable (or at index zero, if no &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; position is defined). In other words, the &lt;code&gt;extract_...&lt;/code&gt; subroutines</source>
          <target state="translated">Подстрока, которая должна быть извлечена, должна появиться в текущей &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; строковой переменной (или в нулевом индексе, если позиция &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; не определена). Другими словами, &lt;code&gt;extract_...&lt;/code&gt; подпрограмм</target>
        </trans-unit>
        <trans-unit id="2d860483efae722d0cafa03a2a83e556d7c44ecb" translate="yes" xml:space="preserve">
          <source>The substring to be extracted must appear at the current &lt;code&gt;pos&lt;/code&gt; location of the string's variable (or at index zero, if no &lt;code&gt;pos&lt;/code&gt; position is defined). In other words, the &lt;code&gt;extract_...&lt;/code&gt; subroutines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c80d088e6c6c206a945e539d4bfb8f011c76009" translate="yes" xml:space="preserve">
          <source>The subtest event itself, with the first 2 events nested inside it as children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631c84fac439176eea77875d9cd55aac6e34bef4" translate="yes" xml:space="preserve">
          <source>The subtle but sometimes brutal art of attempting to turn your possibly malformed program into a valid &lt;b&gt;syntax tree&lt;/b&gt;.</source>
          <target state="translated">Тонкое, но иногда жестокое искусство попытки превратить вашу возможно некорректную программу в действительное &lt;b&gt;синтаксическое дерево&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="69b5462de54900759de9c61920b693e4e317aaf5" translate="yes" xml:space="preserve">
          <source>The subversion level of this package. The value of subversion comes from the</source>
          <target state="translated">Уровень диверсии данного пакета.Значение диверсии происходит от</target>
        </trans-unit>
        <trans-unit id="270d4886cf1a538b0addd0c2b282f59bb7645fa0" translate="yes" xml:space="preserve">
          <source>The superuser (&lt;code&gt;UID&lt;/code&gt; == 0). Also the top-level directory of the filesystem.</source>
          <target state="translated">Суперпользователь ( &lt;code&gt;UID&lt;/code&gt; == 0). Также каталог верхнего уровня файловой системы.</target>
        </trans-unit>
        <trans-unit id="bb4d5743fc0dd23109f98c367b228edac660d539" translate="yes" xml:space="preserve">
          <source>The support of Unicode is new starting from Perl version v5.6, and more fully implemented in versions v5.8 and later. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">Поддержка Unicode появилась впервые, начиная с версии Perl v5.6, и более полно реализована в версиях v5.8 и новее. См. &lt;a href=&quot;perluniintro&quot;&gt;Perluniintro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c60ded369392eed501121f572768a1d278a7c99" translate="yes" xml:space="preserve">
          <source>The supported features, documented further below, are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84c55afdf9f74f3a1d06dd4132c903afc0559c7" translate="yes" xml:space="preserve">
          <source>The supported platforms are Linux, and OS X (some *BSD might work at least partly, but they have not yet been tested).</source>
          <target state="translated">Поддерживаются платформы Linux и OS X (некоторые *BSD могут работать хотя бы частично,но они еще не протестированы).</target>
        </trans-unit>
        <trans-unit id="c6fbcb6100de3c481ef36f607630c6994106ebd8" translate="yes" xml:space="preserve">
          <source>The surprising part is that &lt;code&gt;--a&lt;/code&gt; sets option &lt;code&gt;a&lt;/code&gt; (due to auto completion), not &lt;code&gt;all&lt;/code&gt; .</source>
          <target state="translated">Удивительно то, что &lt;code&gt;--a&lt;/code&gt; устанавливает параметр &lt;code&gt;a&lt;/code&gt; (из-за автоматического завершения), а не &lt;code&gt;all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75d8922e6906461ffb1cdb138b9e2b992bbd28c0" translate="yes" xml:space="preserve">
          <source>The surprising part is that &lt;code&gt;--a&lt;/code&gt; sets option &lt;code&gt;a&lt;/code&gt; (due to auto completion), not &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033617fd53c9330532a1c3d67c45fd0449d158c6" translate="yes" xml:space="preserve">
          <source>The surroundings or environment. The context given by the surrounding code determines what kind of data a particular &lt;b&gt;expression&lt;/b&gt; is expected to return. The three primary contexts are &lt;b&gt;list context&lt;/b&gt;, &lt;b&gt;scalar&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. Scalar context is sometimes subdivided into &lt;b&gt;Boolean context&lt;/b&gt;, &lt;b&gt;numeric context&lt;/b&gt;, &lt;b&gt;string context&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. There&amp;rsquo;s also a &amp;ldquo;don&amp;rsquo;t care&amp;rdquo; context (which is dealt with in Camel chapter 2, &amp;ldquo;Bits and Pieces&amp;rdquo;, if you care).</source>
          <target state="translated">Окружение или окружение. Контекст, задаваемый окружающим кодом, определяет, какие данные должно возвращать конкретное &lt;b&gt;выражение&lt;/b&gt; . Три основных контекста - это контекст &lt;b&gt;списка&lt;/b&gt; , &lt;b&gt;скалярный&lt;/b&gt; и &lt;b&gt;пустой контекст&lt;/b&gt; . Скалярный контекст иногда подразделяется на &lt;b&gt;логический контекст&lt;/b&gt; , &lt;b&gt;числовой контекст&lt;/b&gt; , &lt;b&gt;строковый контекст&lt;/b&gt; и &lt;b&gt;пустой контекст&lt;/b&gt; . Также есть контекст &amp;laquo;безразлично&amp;raquo; (который рассматривается во второй главе Camel &amp;laquo;Биты и куски&amp;raquo;, если вам интересно).</target>
        </trans-unit>
        <trans-unit id="295e290eb0d08f2169eeef73696284f8eecaacb4" translate="yes" xml:space="preserve">
          <source>The sv_magic function uses &lt;code&gt;how&lt;/code&gt; to determine which, if any, predefined &quot;Magic Virtual Table&quot; should be assigned to the &lt;code&gt;mg_virtual&lt;/code&gt; field. See the &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;&quot;Magic Virtual Tables&quot;&lt;/a&gt; section below. The &lt;code&gt;how&lt;/code&gt; argument is also stored in the &lt;code&gt;mg_type&lt;/code&gt; field. The value of &lt;code&gt;how&lt;/code&gt; should be chosen from the set of macros &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; found in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed80b515b4081009a4556929c3f21adbe337dfc8" translate="yes" xml:space="preserve">
          <source>The sv_magic function uses &lt;code&gt;how&lt;/code&gt; to determine which, if any, predefined &quot;Magic Virtual Table&quot; should be assigned to the &lt;code&gt;mg_virtual&lt;/code&gt; field. See the &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; section below. The &lt;code&gt;how&lt;/code&gt; argument is also stored in the &lt;code&gt;mg_type&lt;/code&gt; field. The value of &lt;code&gt;how&lt;/code&gt; should be chosen from the set of macros &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; found in</source>
          <target state="translated">Функция sv_magic использует &lt;code&gt;how&lt;/code&gt; определения, какая из предопределенных &amp;laquo;волшебных виртуальных таблиц&amp;raquo; должна быть назначена полю &lt;code&gt;mg_virtual&lt;/code&gt; , если таковые имеются . См. Раздел &amp;laquo; &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Волшебные виртуальные столы&lt;/a&gt; &amp;raquo; ниже. &lt;code&gt;how&lt;/code&gt; аргумент также хранится в &lt;code&gt;mg_type&lt;/code&gt; поле. Значение &lt;code&gt;how&lt;/code&gt; следует выбирать из набора макросов &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; , найденных в</target>
        </trans-unit>
        <trans-unit id="6d632295f69a2e258303de734a1930d293a5d47a" translate="yes" xml:space="preserve">
          <source>The switch statement is called &lt;code&gt;given/when&lt;/code&gt; and only available in perl 5.10 or newer. See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">Оператор switch называется &lt;code&gt;given/when&lt;/code&gt; и доступен только в Perl 5.10 или новее. См. &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Операторы переключения в perlsyn&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51ab4452b7e8aefb4a20c0fd55e5ee11bfae3081" translate="yes" xml:space="preserve">
          <source>The switch statement is called &lt;code&gt;given&lt;/code&gt;/&lt;code&gt;when&lt;/code&gt; and only available in perl 5.10 or newer. See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc5a13c9ade0909b5ffefb1aee0a9413eb8d3b5" translate="yes" xml:space="preserve">
          <source>The switches above deserve explanation. &lt;code&gt;--no-ff&lt;/code&gt; indicates that even if all your work can be applied linearly against blead, a merge commit should still be prepared. This ensures that all your work will be shown as a side branch, with all its commits merged into the mainstream blead by the merge commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8e93cb0b51582c675d9a8aa40dc2d0d3cfccab" translate="yes" xml:space="preserve">
          <source>The switches here are -r to recurse into any directories below 't' and -b which adds ./blib/lib and ./blib/arch to Perl's include path so that the tests can find the code they will be testing. If I'm testing a module of which an earlier version is already installed I need to be careful about the include path to make sure I'm not running my tests against the installed version rather than the new one that I'm working on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea55b37c83e9242fca02717bc11a9fce7934d1e9" translate="yes" xml:space="preserve">
          <source>The symbol between angle brackets indicates the op's type, for example; &amp;lt;2&amp;gt; is a BINOP, &amp;lt;@&amp;gt; a LISTOP, and &amp;lt;#&amp;gt; is a PADOP, which is used in threaded perls. (see &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;&quot;OP class abbreviations&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4512bd52c00d29ccebf2f597b2a43c4da8833a" translate="yes" xml:space="preserve">
          <source>The symbol between angle brackets indicates the op's type, for example; &amp;lt;2&amp;gt; is a BINOP, &amp;lt;@&amp;gt; a LISTOP, and &amp;lt;#&amp;gt; is a PADOP, which is used in threaded perls. (see &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;OP class abbreviations&lt;/a&gt;).</source>
          <target state="translated">Символ в угловых скобках указывает, например, тип операции; &amp;lt;2&amp;gt; - это BINOP, &amp;lt;@&amp;gt; - LISTOP, а &amp;lt;#&amp;gt; - это PADOP, который используется в многопоточном Perl. (см. &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;аббревиатуры классов OP&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2fa8c942f2b2a058230427b77fde679fbccbc45f" translate="yes" xml:space="preserve">
          <source>The symbol table for a package happens to be stored in the hash of that name with two colons appended. The main symbol table's name is thus &lt;code&gt;%main::&lt;/code&gt; , or &lt;code&gt;%::&lt;/code&gt; for short. Likewise the symbol table for the nested package mentioned earlier is named &lt;code&gt;%OUTER::INNER::&lt;/code&gt; .</source>
          <target state="translated">Таблица символов для пакета хранится в хэше этого имени с двумя добавленными двоеточиями. Таким образом, имя основной таблицы символов - &lt;code&gt;%main::&lt;/code&gt; или &lt;code&gt;%::&lt;/code&gt; для краткости. Точно так же таблица символов для вложенного пакета, упомянутого ранее, называется &lt;code&gt;%OUTER::INNER::&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="309a96ca92bbc8636f854ec2354e0659976f1abe" translate="yes" xml:space="preserve">
          <source>The symbol table for a package happens to be stored in the hash of that name with two colons appended. The main symbol table's name is thus &lt;code&gt;%main::&lt;/code&gt;, or &lt;code&gt;%::&lt;/code&gt; for short. Likewise the symbol table for the nested package mentioned earlier is named &lt;code&gt;%OUTER::INNER::&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d8237c3f2b5d66316d69a0012fa0f4c23704f9" translate="yes" xml:space="preserve">
          <source>The symbol table is filled with names looking like line-noise.</source>
          <target state="translated">Таблица символов заполнена именами,похожими на шум линии.</target>
        </trans-unit>
        <trans-unit id="9284dc458d23c8892508c2adfd2449416ee1df69" translate="yes" xml:space="preserve">
          <source>The symbolic constants for the mode argument are exported by VMS::Stdio by default, and are also exported by the Fcntl package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5234fa33c4424920b3b6f455994e7727a2634e0" translate="yes" xml:space="preserve">
          <source>The symbols, ZIP_CM_STORE, ZIP_CM_DEFLATE, ZIP_CM_BZIP2 and ZIP_CM_LZMA are used to select the compression method.</source>
          <target state="translated">Для выбора метода сжатия используются символы ZIP_CM_STORE,ZIP_CM_DEFLATE,ZIP_CM_BZIP2 и ZIP_CM_LZMA.</target>
        </trans-unit>
        <trans-unit id="b89d5eb1a6608598259ad58b96f51e05f4c62a8d" translate="yes" xml:space="preserve">
          <source>The synonym Strtod() may be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e5ab20507b2337eca95f7b51820364382691825" translate="yes" xml:space="preserve">
          <source>The syntactic position falling between a method call and its arguments when using the indirect object invocation syntax. (The slot is distinguished by the absence of a comma between it and the next argument.) &lt;code&gt;STDERR&lt;/code&gt; is in the indirect object slot here:</source>
          <target state="translated">Синтаксическая позиция между вызовом метода и его аргументами при использовании синтаксиса косвенного вызова объекта. (Слот отличается отсутствием запятой между ним и следующим аргументом.) &lt;code&gt;STDERR&lt;/code&gt; находится здесь в слоте косвенного объекта:</target>
        </trans-unit>
        <trans-unit id="f8f8b505ce05315e1a17e36787d4eec3e6ea7c76" translate="yes" xml:space="preserve">
          <source>The syntax</source>
          <target state="translated">Синтаксис</target>
        </trans-unit>
        <trans-unit id="98466f6b4c50ed9b1b9be5898a44ee0da163a090" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;(?[ ])&lt;/code&gt; in a regular expression yields a list of single code points, none can be a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba4b4939723b8e356e5354c0a4613ac1ca8c7fbd" translate="yes" xml:space="preserve">
          <source>The syntax and behavior is similar to a &lt;code&gt;SKIP: BLOCK&lt;/code&gt; except the tests will be marked as failing but todo. &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret them as passing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b260d025f9cb3da5ac539f033e81a2ed933eaba6" translate="yes" xml:space="preserve">
          <source>The syntax and behavior is similar to a &lt;code&gt;SKIP: BLOCK&lt;/code&gt; except the tests will be marked as failing but todo. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret them as passing.</source>
          <target state="translated">Синтаксис и поведение аналогичны &lt;code&gt;SKIP: BLOCK&lt;/code&gt; за исключением того, что тесты будут помечены как неуспешные, но необходимо. &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; интерпретирует их как пройденные.</target>
        </trans-unit>
        <trans-unit id="47cc68a8f32c23223d1563cd08d4fd0cd4cd2e20" translate="yes" xml:space="preserve">
          <source>The syntax for &lt;code&gt;skip&lt;/code&gt; is about the only way it can be, but it's still quite confusing. Just start with the above examples and you'll be okay.</source>
          <target state="translated">Синтаксис &lt;code&gt;skip&lt;/code&gt; - это единственный возможный вариант, но он все равно довольно запутанный. Просто начните с приведенных выше примеров, и все будет в порядке.</target>
        </trans-unit>
        <trans-unit id="ad53e9b382fc96ff2b2e55cab8f01b18f6934cd1" translate="yes" xml:space="preserve">
          <source>The syntax for an Input FileGlob is identical to &lt;code&gt;File::Glob&lt;/code&gt; , except for the following</source>
          <target state="translated">Синтаксис входного FileGlob идентичен &lt;code&gt;File::Glob&lt;/code&gt; , за исключением следующего</target>
        </trans-unit>
        <trans-unit id="91b339d4084c59a0f56840bad513aaf8cf0b9224" translate="yes" xml:space="preserve">
          <source>The syntax for an Input FileGlob is identical to &lt;code&gt;File::Glob&lt;/code&gt;, except for the following</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d238d90126a97e645c3d07a616c57a948aa56c49" translate="yes" xml:space="preserve">
          <source>The syntax for encoding text strings to binary strings is as simple as decoding:</source>
          <target state="translated">Синтаксис для кодирования текстовых строк в бинарные строки так же прост,как и декодирование:</target>
        </trans-unit>
        <trans-unit id="6de19f7b88c80bb9cdb41dbc1a8bdd69b98ff8b9" translate="yes" xml:space="preserve">
          <source>The syntax of patterns used in Perl pattern matching evolved from those supplied in the Bell Labs Research Unix 8th Edition (Version 8) regex routines. (The code is actually derived (distantly) from Henry Spencer's freely redistributable reimplementation of those V8 routines.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de2770d6e55eee81f76094997c8b0b61106fb04" translate="yes" xml:space="preserve">
          <source>The syntax:</source>
          <target state="translated">Синтаксис:</target>
        </trans-unit>
        <trans-unit id="6e911200da76df16e0a83de577d8669f75cca2df" translate="yes" xml:space="preserve">
          <source>The sysread(), recv(), syswrite() and send() operators are deprecated on handles that have the &lt;code&gt;:utf8&lt;/code&gt; layer, either explicitly, or implicitly, eg., with the &lt;code&gt;:encoding(UTF-16LE)&lt;/code&gt; layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f851731919e85a8b6dbd2464120f7f6baa4b5b" translate="yes" xml:space="preserve">
          <source>The system being designed is large, or is likely to become large.</source>
          <target state="translated">Проектируемая система большая или,скорее всего,станет большой.</target>
        </trans-unit>
        <trans-unit id="a8562e11d0057f4470ed7be8cd68c00d5386166f" translate="yes" xml:space="preserve">
          <source>The system copy routine may also be called directly under VMS and OS/2 as &lt;code&gt;File::Copy::syscopy&lt;/code&gt; (or under VMS as &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; , which is the routine that does the actual work for syscopy).</source>
          <target state="translated">&lt;code&gt;File::Copy::syscopy&lt;/code&gt; подпрограмму копирования можно также вызвать непосредственно в VMS и OS / 2 как File :: Copy :: syscopy (или в VMS как &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; , которая выполняет фактическую работу для syscopy).</target>
        </trans-unit>
        <trans-unit id="b94efe0827258f7a0df5937358145073b3689390" translate="yes" xml:space="preserve">
          <source>The system copy routine may also be called directly under VMS and OS/2 as &lt;code&gt;File::Copy::syscopy&lt;/code&gt; (or under VMS as &lt;code&gt;File::Copy::rmscopy&lt;/code&gt;, which is the routine that does the actual work for syscopy).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b60dcb15de0e9f8fb8f2aec0c96f53a958b30c3" translate="yes" xml:space="preserve">
          <source>The system design is already object-oriented.</source>
          <target state="translated">Дизайн системы уже ориентирован на объект.</target>
        </trans-unit>
        <trans-unit id="252893c973435ea38255f9114e6c78b7c2f4935b" translate="yes" xml:space="preserve">
          <source>The system function it replaces can have its static return buffer trashed, not only by a subesequent call to that function, but by a &lt;code&gt;freelocale&lt;/code&gt;, &lt;code&gt;setlocale&lt;/code&gt;, or other locale change. The returned buffer of this function is not changed until the next call to it, so the buffer is never in a trashed state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2d2b02a34c5f3a2771d92387a8965fe957ed399" translate="yes" xml:space="preserve">
          <source>The system ignores the first line and feeds the program to</source>
          <target state="translated">Система игнорирует первую строку и направляет программу на</target>
        </trans-unit>
        <trans-unit id="f1eb32227e059ade5c92f6015a4dd65ea3a6bc28" translate="yes" xml:space="preserve">
          <source>The system time is the amount of time the kernel itself spent executing routines, or system calls, on behalf of this process user.</source>
          <target state="translated">Системное время-это количество времени,которое само ядро потратило на выполнение процедур или системных вызовов от имени данного пользователя процесса.</target>
        </trans-unit>
        <trans-unit id="831ee4615baf52dd07f0a014bffa561cd6b8234d" translate="yes" xml:space="preserve">
          <source>The system time of the null loop might be slightly more than the system time of the loop with the actual code and therefore the difference might end up being &amp;lt; 0.</source>
          <target state="translated">Системное время нулевого цикла может быть немного больше, чем системное время цикла с фактическим кодом, и поэтому разница может оказаться &amp;lt;0.</target>
        </trans-unit>
        <trans-unit id="5880c4b2f3b12a5f35ec0374b9437ee3cf2ad712" translate="yes" xml:space="preserve">
          <source>The system's notion of time of day and calendar date is controlled in widely different ways. Don't assume the timezone is stored in &lt;code&gt;$ENV{TZ}&lt;/code&gt; , and even if it is, don't assume that you can control the timezone through that variable. Don't assume anything about the three-letter timezone abbreviations (for example that MST would be the Mountain Standard Time, it's been known to stand for Moscow Standard Time). If you need to use timezones, express them in some unambiguous format like the exact number of minutes offset from UTC, or the POSIX timezone format.</source>
          <target state="translated">Системные понятия времени суток и календарной даты контролируются различными способами. Не предполагайте, что часовой пояс хранится в &lt;code&gt;$ENV{TZ}&lt;/code&gt; , и даже если это так, не предполагайте, что вы можете контролировать часовой пояс с помощью этой переменной. Не предполагайте ничего о трехбуквенных аббревиатурах часовых поясов (например, что MST будет горным стандартным временем, оно, как известно, означает московское стандартное время). Если вам нужно использовать часовые пояса, выразите их в каком-либо недвусмысленном формате, например в точном смещении количества минут от UTC или в формате часового пояса POSIX.</target>
        </trans-unit>
        <trans-unit id="ed3226a2f2631da1a16aa62735723438d4e491ac" translate="yes" xml:space="preserve">
          <source>The system's notion of time of day and calendar date is controlled in widely different ways. Don't assume the timezone is stored in &lt;code&gt;$ENV{TZ}&lt;/code&gt;, and even if it is, don't assume that you can control the timezone through that variable. Don't assume anything about the three-letter timezone abbreviations (for example that MST would be the Mountain Standard Time, it's been known to stand for Moscow Standard Time). If you need to use timezones, express them in some unambiguous format like the exact number of minutes offset from UTC, or the POSIX timezone format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10bc5e79cfd3d40c28f5293903b887866aeb92ec" translate="yes" xml:space="preserve">
          <source>The table below has two columns. The left column contains the &lt;code&gt;\p{}&lt;/code&gt; constructs to look up, possibly preceded by the flags mentioned above; and the right column contains information about them, like a description, or synonyms. The table shows both the single and compound forms for each property that has them. If the left column is a short name for a property, the right column will give its longer, more descriptive name; and if the left column is the longest name, the right column will show any equivalent shortest name, in both single and compound forms if applicable.</source>
          <target state="translated">В таблице ниже два столбца. Левый столбец содержит конструкции &lt;code&gt;\p{}&lt;/code&gt; для поиска, возможно, им предшествуют упомянутые выше флаги; а в правом столбце содержится информация о них, например описание или синонимы. В таблице показаны как одиночные, так и составные формы для каждого свойства, которое их имеет. Если левый столбец - это короткое имя свойства, в правом столбце будет его более длинное и описательное имя; и если в левом столбце указано самое длинное имя, в правом столбце будет отображаться любое эквивалентное кратчайшее имя, как в простой, так и в составной форме, если это применимо.</target>
        </trans-unit>
        <trans-unit id="1666e90a958abe062ff0c13eedc4273819f1aea6" translate="yes" xml:space="preserve">
          <source>The table file should locate in the</source>
          <target state="translated">Файл таблицы должен находиться в</target>
        </trans-unit>
        <trans-unit id="0f20314df9f35b36eb10a691047b3cd3cf2ffd4f" translate="yes" xml:space="preserve">
          <source>The table in this section lists all the Perl API elements available, sorted by the version in which support starts. This includes all the elements that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1154d069cc05928d8b59c50b5730e339b959183" translate="yes" xml:space="preserve">
          <source>The table of methods for all operations is cached in magic for the symbol table hash for the package. The cache is invalidated during processing of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; , new function definitions, and changes in @ISA.</source>
          <target state="translated">Таблица методов для всех операций магически кэшируется для хеша таблицы символов для пакета. Кеш становится недействительным во время обработки &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; , новых определений функций и изменений в @ISA.</target>
        </trans-unit>
        <trans-unit id="2c1ebd6c35d6d5b09dedbf5b41acedd8ee971357" translate="yes" xml:space="preserve">
          <source>The table of methods for all operations is cached in magic for the symbol table hash for the package. The cache is invalidated during processing of &lt;code&gt;use overload&lt;/code&gt;, &lt;code&gt;no overload&lt;/code&gt;, new function definitions, and changes in @ISA.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf2718afd051a8a2171808fbbd533fc26865cc1" translate="yes" xml:space="preserve">
          <source>The table of smartmatches in &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;&quot;Smartmatch Operator&quot; in perlop&lt;/a&gt; is not identical to that proposed by the Raku specification, mainly due to differences between Raku's and Perl 5's data models, but also because the Raku spec has changed since Perl 5 rushed into early adoption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36cd501ad88aba2f3b3a0d1d67027c7a1e869d6" translate="yes" xml:space="preserve">
          <source>The table of smartmatches in &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator in perlop&lt;/a&gt; is not identical to that proposed by the Perl 6 specification, mainly due to differences between Perl 6's and Perl 5's data models, but also because the Perl 6 spec has changed since Perl 5 rushed into early adoption.</source>
          <target state="translated">Таблица интеллектуальных совпадений в &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator в perlop&lt;/a&gt; не идентична таблице , предложенной спецификацией Perl 6, в основном из-за различий между моделями данных Perl 6 и Perl 5, а также из-за того, что спецификация Perl 6 изменилась с тех пор, как Perl 5 начал быстро внедряться. .</target>
        </trans-unit>
        <trans-unit id="744a22264ceb5e3af0d89371d88c54fa44eb074f" translate="yes" xml:space="preserve">
          <source>The table structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ad06074e14c7f30c5f734701604346041b5cbc" translate="yes" xml:space="preserve">
          <source>The tangent</source>
          <target state="translated">Касательная</target>
        </trans-unit>
        <trans-unit id="9125938896cf0c452742065869d161bf7df834a0" translate="yes" xml:space="preserve">
          <source>The tarball can be created as follows:</source>
          <target state="translated">Тарбол можно создать следующим образом:</target>
        </trans-unit>
        <trans-unit id="5f3864dd27cd34c2e98d0ec223d6fceecc7c957c" translate="yes" xml:space="preserve">
          <source>The target directory to store the spec files in can be set using &lt;code&gt;dir&lt;/code&gt; as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87ef1c14b4fb669d5f4570a38dcf5e22aa3e1b3" translate="yes" xml:space="preserve">
          <source>The target is to make OS/2 one of the best supported platform for using/building/developing Perl and</source>
          <target state="translated">Цель состоит в том,чтобы сделать OS/2 одной из лучших поддерживаемых платформ для использования/создания/разработки Perl и</target>
        </trans-unit>
        <trans-unit id="f704785556fc74856ecd269c550a540acda7d08d" translate="yes" xml:space="preserve">
          <source>The target of the OP, or nothing for a nulled OP.</source>
          <target state="translated">Цель ОП,или ничего для нулевой ОП.</target>
        </trans-unit>
        <trans-unit id="d551cba509e623574e29a4be73bb109e3d69062b" translate="yes" xml:space="preserve">
          <source>The template can take a different set of rules per key that is used.</source>
          <target state="translated">Шаблон может принимать другой набор правил для каждого используемого ключа.</target>
        </trans-unit>
        <trans-unit id="7dd55749521ef7a1d8d1762bd0dfd93dc2ed7572" translate="yes" xml:space="preserve">
          <source>The template may be any filename with some number of X's appended to it, for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56fadcfb4c1428b721edcda3a997763e93a92ef4" translate="yes" xml:space="preserve">
          <source>The template may be any filename with some number of X's appended to it, for example F. The trailing X's are replaced with unique alphanumeric combinations.</source>
          <target state="translated">Шаблоном может быть любое имя файла с некоторым количеством X,например F.В трейлинге X заменяются уникальными буквенно-цифровыми комбинациями.</target>
        </trans-unit>
        <trans-unit id="d2a0774e46a5ddeb6abfa59a3643d774d174d289" translate="yes" xml:space="preserve">
          <source>The temporaries stack stores pointers to xVs whose reference counts will be decremented soon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b658a51743ea23f5f90b8615b574c3089e0c4bce" translate="yes" xml:space="preserve">
          <source>The tenth and subsequent priorities are to look in directories named</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="527fc2a5f793bc1d57c90fcfdd90ce2b38cfafb9" translate="yes" xml:space="preserve">
          <source>The term &quot;native&quot; does not mean quite as much when we talk about native integers, as it does when native floating point numbers are involved. The only implication of the term &quot;native&quot; on integers is that the limits for the maximal and the minimal supported true integral quantities are close to powers of 2. However, &quot;native&quot; floats have a most fundamental restriction: they may represent only those numbers which have a relatively &quot;short&quot; representation when converted to a binary fraction. For example, 0.9 cannot be represented by a native float, since the binary fraction for 0.9 is infinite:</source>
          <target state="translated">Термин &quot;родной&quot; не так много значит,когда мы говорим о родных целых числах,как это бывает,когда речь идет о родных числах с плавающей точкой.Единственным подтекстом термина &quot;родные&quot; на целые числа является то,что границы максимальных и минимальных поддерживаемых истинных интегральных величин близки к степеням 2.Однако,&quot;родные&quot; числа с плавающей точкой имеют самое фундаментальное ограничение:они могут представлять только те числа,которые при преобразовании в двоичную дробь имеют относительно &quot;короткое&quot; представление.Например,0.9 не может быть представлено &quot;родным&quot; флотом,так как двоичная доля для 0.9 бесконечна:</target>
        </trans-unit>
        <trans-unit id="60065770d703c59b1d8e19903d480a6c8c3d4ce7" translate="yes" xml:space="preserve">
          <source>The term &quot;railroad normal form&quot; is a bit esoteric, with &quot;syntax diagram/charts&quot;, or &quot;railroad diagram/charts&quot; being more common terms. Nevertheless it provides a useful mental image of a regex program: each node can be thought of as a unit of track, with a single entry and in most cases a single exit point (there are pieces of track that fork, but statistically not many), and the whole forms a layout with a single entry and single exit point. The matching process can be thought of as a car that moves along the track, with the particular route through the system being determined by the character read at each possible connector point. A car can fall off the track at any point but it may only proceed as long as it matches the track.</source>
          <target state="translated">Термин &quot;железнодорожная нормальная форма&quot; является немного эзотерическим,при этом &quot;синтаксисная диаграмма/схемы&quot; или &quot;железнодорожная диаграмма/схемы&quot; являются более распространенными терминами.Тем не менее,он дает полезный ментальный образ регекс-программы:каждый узел можно рассматривать как единицу пути,с одной вилкой и в большинстве случаев с одной точкой выхода (есть кусочки пути,которые вилки,но их статистически не много),и все это образует макет с одной точкой входа и одной точкой выхода.Процесс сопоставления можно представить как машину,которая движется по треку,при этом конкретный маршрут через систему определяется по символам,прочитанным в каждой возможной точке соединения.Автомобиль может упасть с трассы в любой точке,но он может продолжать движение только до тех пор,пока соответствует трассе.</target>
        </trans-unit>
        <trans-unit id="cb8cf5974b1ed2433ffc34db8b95199dcc132ecd" translate="yes" xml:space="preserve">
          <source>The term 'mathemagic' describes the overloaded implementation of mathematical operators. Mathemagical operations raise an issue. Consider the code:</source>
          <target state="translated">Термин &quot;математический&quot; описывает перегруженную реализацию математических операторов.Математические операции поднимают проблему.Рассмотрим код:</target>
        </trans-unit>
        <trans-unit id="eaeae7045f589906beb0ab8c4692ec54095f2a80" translate="yes" xml:space="preserve">
          <source>The term, &quot;Unicode bug&quot; has been applied to an inconsistency with the code points in the &lt;code&gt;Latin-1 Supplement&lt;/code&gt; block, that is, between 128 and 255. Without a locale specified, unlike all other characters or code points, these characters can have very different semantics depending on the rules in effect. (Characters whose code points are above 255 force Unicode rules; whereas the rules for ASCII characters are the same under both ASCII and Unicode rules.)</source>
          <target state="translated">Термин &amp;laquo;ошибка Unicode&amp;raquo; был применен к несоответствию с кодовыми точками в &lt;code&gt;Latin-1 Supplement&lt;/code&gt; блоке Latin-1 , то есть между 128 и 255. Без указания локали, в отличие от всех других символов или кодовых точек, эти символы могут иметь очень разная семантика в зависимости от действующих правил. (Символы с кодовыми точками выше 255 применяют правила Unicode; тогда как правила для символов ASCII одинаковы как для правил ASCII, так и для правил Unicode.)</target>
        </trans-unit>
        <trans-unit id="694ad9d197b3bccc91651d679f02271b6dd9c6f8" translate="yes" xml:space="preserve">
          <source>The terminal output bit rate (often mistakenly called the baud rate) for this terminal - if not set a warning will be generated and it will be defaulted to 9600.</source>
          <target state="translated">Скорость терминального вывода битов (часто ошибочно называемая скоростью передачи)для этого терминала-если ее не установить,то будет выдано предупреждение,и по умолчанию она будет равна 9600.</target>
        </trans-unit>
        <trans-unit id="45cdb3e3cad66807c8dfdf23c9cff4fc7bd36017" translate="yes" xml:space="preserve">
          <source>The terminal type whose termcap entry will be used - if not supplied it will default to $ENV{TERM}: if that is not set then &lt;b&gt;Tgetent&lt;/b&gt; will croak.</source>
          <target state="translated">Тип терминала, для которого будет использоваться запись termcap - если не &lt;b&gt;указано, по&lt;/b&gt; умолчанию будет $ ENV {TERM}: если это не установлено, &lt;b&gt;Tgetent&lt;/b&gt; будет &lt;b&gt;квакать&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="a8d5f39cee7740c7c53d20d14cbf1ad8092c45e0" translate="yes" xml:space="preserve">
          <source>The terminating string may be either an identifier (a word), or some quoted text. An unquoted identifier works like double quotes. There may not be a space between the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and the identifier, unless the identifier is explicitly quoted. (If you put a space it will be treated as a null identifier, which is valid, and matches the first empty line.) The terminating string must appear by itself (unquoted and with no surrounding whitespace) on the terminating line.</source>
          <target state="translated">Завершающая строка может быть идентификатором (словом) или текстом в кавычках. Идентификатор без кавычек работает как двойные кавычки. Между &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; и идентификатором не может быть пробела , если идентификатор не указан явно. (Если вы поместите пробел, он будет рассматриваться как нулевой идентификатор, который действителен и соответствует первой пустой строке.) Завершающая строка должна появляться сама по себе (без кавычек и без окружающих пробелов) в завершающей строке.</target>
        </trans-unit>
        <trans-unit id="10b4a47dbe9b183e3332ce5dc657e06a6f7d67c1" translate="yes" xml:space="preserve">
          <source>The terminating string may be either an identifier (a word), or some quoted text. An unquoted identifier works like double quotes. There may not be a space between the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and the identifier, unless the identifier is explicitly quoted. The terminating string must appear by itself (unquoted and with no surrounding whitespace) on the terminating line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693f7bb103883c0a728e204ee6c0e2c1249be088" translate="yes" xml:space="preserve">
          <source>The terminator of runtime &lt;code&gt;(?{...})&lt;/code&gt; is found by temporarily switching control to the perl parser, which should stop at the point where the logically balancing terminating &lt;code&gt;}&lt;/code&gt; is found.</source>
          <target state="translated">Терминатор времени выполнения &lt;code&gt;(?{...})&lt;/code&gt; находится путем временного переключения управления на парсер perl, который должен остановиться в точке, где обнаруживается завершение логической балансировки &lt;code&gt;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45074fa74bab84b7b8642e2f2cccf8a44bd5974b" translate="yes" xml:space="preserve">
          <source>The test</source>
          <target state="translated">Тест</target>
        </trans-unit>
        <trans-unit id="404700fb40de228f041c8b476423971728a238e9" translate="yes" xml:space="preserve">
          <source>The test harness leaves much to be desired. Patches welcome.</source>
          <target state="translated">Тестовый жгут оставляет желать лучшего.Патчи приветствуются.</target>
        </trans-unit>
        <trans-unit id="a5f877c1b13f5bd28ecef34f68e2dcb7eb31de7b" translate="yes" xml:space="preserve">
          <source>The test name extensions. Defaults to &lt;code&gt;.t&lt;/code&gt;.</source>
          <target state="translated">Расширения имени теста. По умолчанию &lt;code&gt;.t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6571e20ce9a71fb843fe89c152d8dbe08235f523" translate="yes" xml:space="preserve">
          <source>The test phase is when the distribution's automated test suite is run. Any library that is needed only for testing and not for subsequent use should be listed here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b17a09a74e93fa5e780df81bc80e5b90469686" translate="yes" xml:space="preserve">
          <source>The test suite is much better, but always needs improvement.</source>
          <target state="translated">Тестовый набор намного лучше,но всегда нуждается в улучшении.</target>
        </trans-unit>
        <trans-unit id="710c520b5e701804e8b8991b8c559c8c70f62fc8" translate="yes" xml:space="preserve">
          <source>The test will exit with 255.</source>
          <target state="translated">Тест выйдет с 255.</target>
        </trans-unit>
        <trans-unit id="adc50b89ec0ba50b71ee74cf410505fc2fa0bc3e" translate="yes" xml:space="preserve">
          <source>The testing system is designed to be used by performing a three step process for each test you wish to test. This process starts with using &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; in advance to declare what the testsuite you are testing will output with &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; to stdout and stderr.</source>
          <target state="translated">Система тестирования предназначена для использования путем выполнения трехэтапного процесса для каждого теста, который вы хотите протестировать. Этот процесс начинается с использования &lt;code&gt;test_out&lt;/code&gt; и &lt;code&gt;test_err&lt;/code&gt; заранее, чтобы объявить, какой набор тестов, который вы тестируете, будет выводить с помощью &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; в stdout и stderr.</target>
        </trans-unit>
        <trans-unit id="7d184971a14375f569314d2fb6a264dcab98a443" translate="yes" xml:space="preserve">
          <source>The testing system is designed to be used by performing a three step process for each test you wish to test. This process starts with using &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; in advance to declare what the testsuite you are testing will output with &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; to stdout and stderr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d3c8b5f530bcb2e21b05b385528e49c2684bd6" translate="yes" xml:space="preserve">
          <source>The tests</source>
          <target state="translated">Испытания</target>
        </trans-unit>
        <trans-unit id="a22b8fe6a3e6e46d5dd177a5cb8828e7b0955e47" translate="yes" xml:space="preserve">
          <source>The tests &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-B&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; , &lt;code&gt;-e&lt;/code&gt; , &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-S&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; , and &lt;code&gt;-z&lt;/code&gt; work as advertised. The return values for &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; tell you whether you can actually access the file; this may not reflect the UIC-based file protections. Since real and effective UIC don't differ under VMS, &lt;code&gt;-O&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; are equivalent to &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; . Similarly, several other tests, including &lt;code&gt;-A&lt;/code&gt; , &lt;code&gt;-g&lt;/code&gt; , &lt;code&gt;-k&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; , and &lt;code&gt;-u&lt;/code&gt; , aren't particularly meaningful under VMS, and the values returned by these tests reflect whatever your CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; routine does to the equivalent bits in the st_mode field. Finally, &lt;code&gt;-d&lt;/code&gt; returns true if passed a device specification without an explicit directory (e.g. &lt;code&gt;DUA1:&lt;/code&gt; ), as well as if passed a directory.</source>
          <target state="translated">Тесты &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-B&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; , &lt;code&gt;-e&lt;/code&gt; , &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-S&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; и &lt;code&gt;-z&lt;/code&gt; работают как заявлено. Возвращаемые значения для &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; и &lt;code&gt;-x&lt;/code&gt; говорят вам, действительно ли вы можете получить доступ к файлу; это может не отражать защиту файлов на основе UIC. Поскольку реальный и действующий UIC не различаются в VMS, &lt;code&gt;-O&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; эквивалентны &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; и &lt;code&gt;-x&lt;/code&gt; . Кроме, несколько других тестов, включая &lt;code&gt;-A&lt;/code&gt; , &lt;code&gt;-g&lt;/code&gt; , &lt;code&gt;-k&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; и &lt;code&gt;-u&lt;/code&gt; , не являются особенно значимыми при VMS, и возвращаемые значения этих тестов отражают точто ваш CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; рутина делает эквивалентным битам в поле st_mode. Наконец, &lt;code&gt;-d&lt;/code&gt; возвращает истину, если передана спецификация устройства без явного каталога (например, &lt;code&gt;DUA1:&lt;/code&gt; , а также если передана директория.</target>
        </trans-unit>
        <trans-unit id="9c967d1ae062bd6388a4176bc92989ac103705dc" translate="yes" xml:space="preserve">
          <source>The tests &lt;code&gt;-b&lt;/code&gt;, &lt;code&gt;-B&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt;, &lt;code&gt;-d&lt;/code&gt;, &lt;code&gt;-e&lt;/code&gt;, &lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-M&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;-S&lt;/code&gt;, &lt;code&gt;-t&lt;/code&gt;, &lt;code&gt;-T&lt;/code&gt;, and &lt;code&gt;-z&lt;/code&gt; work as advertised. The return values for &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-x&lt;/code&gt; tell you whether you can actually access the file; this may not reflect the UIC-based file protections. Since real and effective UIC don't differ under VMS, &lt;code&gt;-O&lt;/code&gt;, &lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;, and &lt;code&gt;-X&lt;/code&gt; are equivalent to &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-x&lt;/code&gt;. Similarly, several other tests, including &lt;code&gt;-A&lt;/code&gt;, &lt;code&gt;-g&lt;/code&gt;, &lt;code&gt;-k&lt;/code&gt;, &lt;code&gt;-l&lt;/code&gt;, &lt;code&gt;-p&lt;/code&gt;, and &lt;code&gt;-u&lt;/code&gt;, aren't particularly meaningful under VMS, and the values returned by these tests reflect whatever your CRTL &lt;code&gt;stat()&lt;/code&gt; routine does to the equivalent bits in the st_mode field. Finally, &lt;code&gt;-d&lt;/code&gt; returns true if passed a device specification without an explicit directory (e.g. &lt;code&gt;DUA1:&lt;/code&gt;), as well as if passed a directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc12f2671ba906087d5eb6304768a3d9deaa9bcf" translate="yes" xml:space="preserve">
          <source>The tests are wholly and completely skipped. [10] This will work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8be2ba8a0a786a9e0b622bcec19843e1f59daa7" translate="yes" xml:space="preserve">
          <source>The tests for this module directly access &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; hash keys. Most, if not all of these hash keys have public API methods that could be used instead to avoid the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fe750878672d4fb196503a672d7f5b98d0e668b" translate="yes" xml:space="preserve">
          <source>The text &quot;Object Attributes&quot; comprises the heading there. The text in these heading commands can use formatting codes, as seen here:</source>
          <target state="translated">Текст &quot;Атрибуты объекта&quot; состоит из заголовка.Текст в этих командах заголовка может использовать коды форматирования,как показано здесь:</target>
        </trans-unit>
        <trans-unit id="5d105df3ca2da40b603c19669d88379eb24889fa" translate="yes" xml:space="preserve">
          <source>The text content will have tabs already expanded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca64065f1722f4560dea83450c678ea442c364d" translate="yes" xml:space="preserve">
          <source>The text in the above examples enclosed between the &lt;code&gt;&quot;/&quot;&lt;/code&gt; characters can be just about any regular expression. It is independent of the main pattern, so doesn't share any capturing groups,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5846d0e4adec8717ba9914b28f27a3deba7538bf" translate="yes" xml:space="preserve">
          <source>The text matched by the highest used capture group of the last successful search pattern. It is logically equivalent to the highest numbered capture variable (&lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, ...) which has a defined value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422420f7789cdb6ab09e238f60941fefea41ab12" translate="yes" xml:space="preserve">
          <source>The text matched by the last bracket of the last successful search pattern. This is useful if you don't know which one of a set of alternative patterns matched. For example:</source>
          <target state="translated">Текст соответствует последней скобке последнего успешного шаблона поиска.Это полезно,если вы не знаете,какой из наборов альтернативных шаблонов подходит.Например:</target>
        </trans-unit>
        <trans-unit id="8d5e558c4e38b1badcb4cca2c007e3208f52adfb" translate="yes" xml:space="preserve">
          <source>The text matched by the used group most-recently closed (i.e. the group with the rightmost closing parenthesis) of the last successful search pattern.</source>
          <target state="translated">Текст,совпадающий по используемой группе,наиболее часто закрываемой (т.е.группе с правой крайней закрывающей скобкой)с последним успешным шаблоном поиска.</target>
        </trans-unit>
        <trans-unit id="5e596703d1021b4590de3b141bfc6f8bfaf78ff0" translate="yes" xml:space="preserve">
          <source>The text matched by the used group most-recently closed (i.e. the group with the rightmost closing parenthesis) of the last successful search pattern. This is subtly different from &lt;code&gt;$+&lt;/code&gt;. For example in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c9727d8e424808f3451a4472d65a7ff102f563" translate="yes" xml:space="preserve">
          <source>The text of a message to print immediately prior to printing the program's usage message.</source>
          <target state="translated">Текст сообщения для печати непосредственно перед печатью сообщения об использовании программы.</target>
        </trans-unit>
        <trans-unit id="2808389282f74befb5070bb0b9545514e48a6905" translate="yes" xml:space="preserve">
          <source>The text of the Makefile is run through this method before writing to disk. It allows systems a chance to make portability fixes to the Makefile.</source>
          <target state="translated">Текст Makefile прогоняется через этот метод перед записью на диск.Это позволяет системам сделать исправления переносимости в Makefile.</target>
        </trans-unit>
        <trans-unit id="fe3785c2d13add392a07d1b360e255c73be9984b" translate="yes" xml:space="preserve">
          <source>The text of the message as a &lt;code&gt;SVpv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4abae05debe0661c57f27b361d90da4ccea7c4db" translate="yes" xml:space="preserve">
          <source>The text/binary issue is covered at length in the Cygwin documentation.</source>
          <target state="translated">Текстовый/бинарный вопрос подробно рассматривается в документации Cygwin.</target>
        </trans-unit>
        <trans-unit id="3155c02df4aea0a613a1c72b2a9ac5c7a7efff80" translate="yes" xml:space="preserve">
          <source>The thetas, phis, direction, and distance in the above are all in radians.</source>
          <target state="translated">Тэты,физы,направление и расстояние в вышеперечисленных точках находятся в радиусах.</target>
        </trans-unit>
        <trans-unit id="b1d631fb3ea4c05afea84d61f3fa4b47ab2ddcf3" translate="yes" xml:space="preserve">
          <source>The thing you&amp;rsquo;re working on. Structures like &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , and &lt;code&gt;given&lt;/code&gt; set the topic for you by assigning to &lt;code&gt;$_&lt;/code&gt; , the default (</source>
          <target state="translated">То, над чем вы работаете. Структуры вроде &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; и &lt;code&gt;given&lt;/code&gt; задают для вас тему, назначая &lt;code&gt;$_&lt;/code&gt; значение по умолчанию (</target>
        </trans-unit>
        <trans-unit id="d349e0f7ce22448af1f85ae29fc321760bdcefb3" translate="yes" xml:space="preserve">
          <source>The thing you&amp;rsquo;re working on. Structures like &lt;code&gt;while(&amp;lt;&amp;gt;)&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;foreach&lt;/code&gt;, and &lt;code&gt;given&lt;/code&gt; set the topic for you by assigning to &lt;code&gt;$_&lt;/code&gt;, the default (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3293c9c16b6eb4008c2299c5283501a14ee373" translate="yes" xml:space="preserve">
          <source>The third argument ($binmode) will select binary mode if passed as a TRUE value. In binary mode &quot;\n&quot; will be encoded in the same way as any other non-printable character. This ensures that a decoder will end up with exactly the same string whatever line ending sequence it uses. In general it is preferable to use the base64 encoding for binary data; see &lt;a href=&quot;MIME::Base64&quot;&gt;MIME::Base64&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7aa255f6bad43d19c5308997ee1af4d4b4ab78c" translate="yes" xml:space="preserve">
          <source>The third argument ($binmode) will select binary mode if passed as a TRUE value. In binary mode &quot;\n&quot; will be encoded in the same way as any other non-printable character. This ensures that a decoder will end up with exactly the same string whatever line ending sequence it uses. In general it is preferable to use the base64 encoding for binary data; see &lt;a href=&quot;base64&quot;&gt;MIME::Base64&lt;/a&gt;.</source>
          <target state="translated">Третий аргумент ($ binmode) выберет двоичный режим, если он передан как ИСТИНА. В двоичном режиме &quot;\ n&quot; будет закодирован так же, как и любой другой непечатаемый символ. Это гарантирует, что декодер получит точно такую ​​же строку, какую бы последовательность окончания строки он ни использовал. Как правило, для двоичных данных предпочтительно использовать кодировку base64; см. &lt;a href=&quot;base64&quot;&gt;MIME :: Base64&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf989e588a5ff932bae69e35a56b32b82b9fac73" translate="yes" xml:space="preserve">
          <source>The third argument &lt;code&gt;\@on_fail&lt;/code&gt;) is an optional set of diagnostics to be sent in the event of a test failure. Unlike with &lt;code&gt;fail()&lt;/code&gt; these diagnostics must be plain strings, data structures are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402137bf9c592f0ce8adeea3685dbc19201507dd" translate="yes" xml:space="preserve">
          <source>The third argument can be a hash reference with options. Note that all options are case-sensitive.</source>
          <target state="translated">Третьим аргументом может быть ссылка на хэш с опциями.Обратите внимание,что все опции чувствительны к регистру.</target>
        </trans-unit>
        <trans-unit id="d09df4868eb6859f97bcec11bc2fb80a75d17197" translate="yes" xml:space="preserve">
          <source>The third argument is an optional prefix. All files will be tucked away in the directory you specify as prefix. So if you have files 'a' and 'b' in your archive, and you specify 'foo' as prefix, they will be written to the archive as 'foo/a' and 'foo/b'.</source>
          <target state="translated">Третий аргумент-необязательный префикс.Все файлы будут убраны в каталог,который вы указываете как префикс.Поэтому,если у вас в архиве есть файлы 'a' и 'b',а в качестве префикса вы указываете 'foo',они будут записаны в архив как 'foo/a' и 'foo/b'.</target>
        </trans-unit>
        <trans-unit id="f4fe54f58bf6b8a68158e2a28b4c6c3ebee0bf58" translate="yes" xml:space="preserve">
          <source>The third argument is set to TRUE if (and only if) the two operands have been swapped. Perl may do this to ensure that the first argument (&lt;code&gt;$self&lt;/code&gt; ) is an object implementing the overloaded operation, in line with general object calling conventions. For example, if &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are &lt;code&gt;Number&lt;/code&gt; s:</source>
          <target state="translated">Третий аргумент имеет значение ИСТИНА, если (и только если) два операнда поменялись местами. Perl может сделать это, чтобы гарантировать, что первый аргумент ( &lt;code&gt;$self&lt;/code&gt; ) является объектом, реализующим перегруженную операцию, в соответствии с общими соглашениями о вызове объектов. Например, если &lt;code&gt;$x&lt;/code&gt; и &lt;code&gt;$y&lt;/code&gt; - &lt;code&gt;Number&lt;/code&gt; s:</target>
        </trans-unit>
        <trans-unit id="e0c4e0c0cbbd72e926793186b0870f3e51aaf16b" translate="yes" xml:space="preserve">
          <source>The third argument is set to TRUE if (and only if) the two operands have been swapped. Perl may do this to ensure that the first argument (&lt;code&gt;$self&lt;/code&gt;) is an object implementing the overloaded operation, in line with general object calling conventions. For example, if &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are &lt;code&gt;Number&lt;/code&gt;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6927ece55a1584561056753f900c2e3751385e3" translate="yes" xml:space="preserve">
          <source>The third form of character class you can use in Perl regular expressions is the bracketed character class. In its simplest form, it lists the characters that may be matched, surrounded by square brackets, like this: &lt;code&gt;[aeiou]&lt;/code&gt; . This matches one of &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt; . Like the other character classes, exactly one character is matched.* To match a longer string consisting of characters mentioned in the character class, follow the character class with a &lt;a href=&quot;perlre#Quantifiers&quot;&gt;quantifier&lt;/a&gt;. For instance, &lt;code&gt;[aeiou]+&lt;/code&gt; matches one or more lowercase English vowels.</source>
          <target state="translated">Третья форма класса символов, которую вы можете использовать в регулярных выражениях Perl, - это класс символов в квадратных скобках. В простейшей форме он перечисляет символы, которые могут быть сопоставлены, заключенный в квадратные скобки, например: &lt;code&gt;[aeiou]&lt;/code&gt; . Это соответствует одному из &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; или &lt;code&gt;u&lt;/code&gt; . Как и в случае с другими классами символов, сопоставляется ровно один символ. * Чтобы сопоставить более длинную строку, состоящую из символов, упомянутых в классе символов, введите после класса символов &lt;a href=&quot;perlre#Quantifiers&quot;&gt;квантификатор&lt;/a&gt; . Например, &lt;code&gt;[aeiou]+&lt;/code&gt; соответствует одной или нескольким строчным английским гласным.</target>
        </trans-unit>
        <trans-unit id="da916e8511a4663908a2df2d14a8fc11695fa70c" translate="yes" xml:space="preserve">
          <source>The third form of character class you can use in Perl regular expressions is the bracketed character class. In its simplest form, it lists the characters that may be matched, surrounded by square brackets, like this: &lt;code&gt;[aeiou]&lt;/code&gt;. This matches one of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt;. Like the other character classes, exactly one character is matched.* To match a longer string consisting of characters mentioned in the character class, follow the character class with a &lt;a href=&quot;perlre#Quantifiers&quot;&gt;quantifier&lt;/a&gt;. For instance, &lt;code&gt;[aeiou]+&lt;/code&gt; matches one or more lowercase English vowels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c965cda02550e370a5b37b87d94e4f8f16189d" translate="yes" xml:space="preserve">
          <source>The third option is to work around the problem by disabling the DB_File completely when build Perl by specifying -Ui_db to Configure, and then using the BerkeleyDB module from CPAN instead of DB_File. The BerkeleyDB works with Berkeley DB versions 2.* or greater.</source>
          <target state="translated">Третья опция заключается в том,чтобы обойти проблему,полностью отключив DB_File при сборке Perl,указав -Ui_db to Configure,а затем используя модуль BerkeleyDB из CPAN вместо DB_File.BerkeleyDB работает с Berkeley DB версии 2.*или выше.</target>
        </trans-unit>
        <trans-unit id="06ac2659f5a86781c045ab0079857269ceabc456" translate="yes" xml:space="preserve">
          <source>The third parameter is an integer flag, which tells &lt;code&gt;rmscopy&lt;/code&gt; how to handle timestamps. If it is &amp;lt; 0, none of the input file's timestamps are propagated to the output file. If it is &amp;gt; 0, then it is interpreted as a bitmask: if bit 0 (the LSB) is set, then timestamps other than the revision date are propagated; if bit 1 is set, the revision date is propagated. If the third parameter to &lt;code&gt;rmscopy&lt;/code&gt; is 0, then it behaves much like the DCL COPY command: if the name or type of the output file was explicitly specified, then no timestamps are propagated, but if they were taken implicitly from the input filespec, then all timestamps other than the revision date are propagated. If this parameter is not supplied, it defaults to 0.</source>
          <target state="translated">Третий параметр - это целочисленный флаг, который сообщает &lt;code&gt;rmscopy&lt;/code&gt; , как обрабатывать временные метки. Если он &amp;lt;0, ни одна из временных меток входного файла не передается в выходной файл. Если он&amp;gt; 0, то это интерпретируется как битовая маска: если бит 0 (LSB) установлен, то распространяются отметки времени, отличные от даты ревизии; если бит 1 установлен, дата редакции распространяется. Если третий параметр для &lt;code&gt;rmscopy&lt;/code&gt; равен 0, то он ведет себя так же, как команда DCL COPY: если имя или тип выходного файла были явно указаны, то временные метки не распространяются, но если они были взяты неявно из входного файла спецификации, тогда распространяются все временные метки, кроме даты ревизии. Если этот параметр не указан, по умолчанию он равен 0.</target>
        </trans-unit>
        <trans-unit id="65eff2bc7c7605d4f858e4809838a551a55b2c9c" translate="yes" xml:space="preserve">
          <source>The third parameter of &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; determines whether AUTOLOAD lookup is performed if the given method is not present: non-zero means yes, look for AUTOLOAD; zero means no, don't look for AUTOLOAD. Calling &lt;code&gt;gv_fetchmethod&lt;/code&gt; is equivalent to calling &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; with a non-zero &lt;code&gt;autoload&lt;/code&gt; parameter.</source>
          <target state="translated">Третий параметр &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; определяет, выполняется ли поиск AUTOLOAD , если данный метод отсутствует: ненулевое значение означает да, ищите AUTOLOAD; ноль означает нет, не ищите AUTOLOAD. Вызов &lt;code&gt;gv_fetchmethod&lt;/code&gt; эквивалентен вызову &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; с ненулевым параметром &lt;code&gt;autoload&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04bad251a051beab258a1b64e282a2e8539b9769" translate="yes" xml:space="preserve">
          <source>The third, even more efficient way is to ape how it is done within the Perl guts:</source>
          <target state="translated">Третий,еще более эффективный способ-обезьяна,как это делается в кишках Perl:</target>
        </trans-unit>
        <trans-unit id="4baba8cca2cc8406f593d4d91d751f6705e4259a" translate="yes" xml:space="preserve">
          <source>The thread ID in which the event was generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35817a67488b477301f26017a906bceb6698d6d8" translate="yes" xml:space="preserve">
          <source>The thread ID of the hub the event was sent to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c45ac3b3a9de2cee8656fb9dfb3aeb3d0a968d" translate="yes" xml:space="preserve">
          <source>The threaded Perl build works also on AIX 5.1 but the IBM Perl build (Perl v5.6.0) is not threaded on AIX 5.1.</source>
          <target state="translated">Потоковая Perl-сборка также работает на AIX 5.1,но Perl-сборка IBM (Perl v5.6.0)не работает на AIX 5.1.</target>
        </trans-unit>
        <trans-unit id="7cda8f2369f06b63a0604a363c17ca6dadb5ab34" translate="yes" xml:space="preserve">
          <source>The three alternative macros are for the most commonly needed validations; they are likely to run somewhat faster than this more general one, as they can be inlined into your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c1bbb696ed6ae965a0f7d9f707a450102369948" translate="yes" xml:space="preserve">
          <source>The three dotted bitwise assignment operators (&lt;code&gt;&amp;amp;.=&lt;/code&gt;&lt;code&gt;|.=&lt;/code&gt;&lt;code&gt;^.=&lt;/code&gt; ) are new in Perl 5.22 and experimental. See &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.</source>
          <target state="translated">Три пунктирных оператора побитового присваивания ( &lt;code&gt;&amp;amp;.=&lt;/code&gt; &lt;code&gt;|.=&lt;/code&gt; &lt;code&gt;^.=&lt;/code&gt; ) Являются новыми в Perl 5.22 и экспериментальными. См. &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Побитовые строковые операторы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c23c9e704aad4fb3e2b155575140f095b0d8c904" translate="yes" xml:space="preserve">
          <source>The three dotted bitwise assignment operators (&lt;code&gt;&amp;amp;.=&lt;/code&gt;&lt;code&gt;|.=&lt;/code&gt;&lt;code&gt;^.=&lt;/code&gt;) are new in Perl 5.22. See &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608f375aebf252abe9239c4f7b8a529aa2fe8363" translate="yes" xml:space="preserve">
          <source>The three features of key hashes,</source>
          <target state="translated">Три особенности ключевых хэшей,</target>
        </trans-unit>
        <trans-unit id="062af9abb2e5d348e479446852d7c0c45c4b3f85" translate="yes" xml:space="preserve">
          <source>The three invocations of the subroutine all operate in sync. The semaphore, though, makes sure that only one thread is accessing the global variable at once.</source>
          <target state="translated">Все три вызова подпрограммы работают синхронно.Однако семафор обеспечивает одновременный доступ только одного потока к глобальной переменной.</target>
        </trans-unit>
        <trans-unit id="c211076f27a370be0b7366cd2b652219b05d68b1" translate="yes" xml:space="preserve">
          <source>The three predefined variables $DB_HASH, $DB_BTREE and $DB_RECNO are usually adequate for most applications. If you do need to create extra instances of these objects, constructors are available for each file type.</source>
          <target state="translated">Три предопределенные переменные $DB_HASH,$DB_BTREE и $DB_RECNO обычно адекватны для большинства приложений.Если вам все же необходимо создать дополнительные экземпляры этих объектов,то для каждого типа файлов доступны конструкторы.</target>
        </trans-unit>
        <trans-unit id="e9c27515a2acd2e5fb4a7aba2f69ec1143808efd" translate="yes" xml:space="preserve">
          <source>The three principal virtues of a programmer are Laziness, Impatience, and Hubris. See the Camel Book for why.</source>
          <target state="translated">Три главных достоинства программиста-это лень,нетерпение и Hubris.Смотри &quot;Книгу верблюдов&quot;.</target>
        </trans-unit>
        <trans-unit id="8d0972bf14f371a7ca1ef1bcaa261257cc368602" translate="yes" xml:space="preserve">
          <source>The three variables, api_revision, api_version, and api_subversion, specify the version of the oldest perl binary compatible with the present perl. In a full version string such as</source>
          <target state="translated">Три переменные-api_revision,api_version и api_subversion-определяют версию старейшего бинарного файла perl,совместимого с настоящим perl.В полной строке версии,такой как</target>
        </trans-unit>
        <trans-unit id="5f7adaa1232b94661eb586ac3b6e3dfed3cf89b3" translate="yes" xml:space="preserve">
          <source>The three warnings functions, &lt;code&gt;warnings::warn&lt;/code&gt; , &lt;code&gt;warnings::warnif&lt;/code&gt; and &lt;code&gt;warnings::enabled&lt;/code&gt; can optionally take an object reference in place of a category name. In this case the functions will use the class name of the object as the warnings category.</source>
          <target state="translated">Три функции &lt;code&gt;warnings::warn&lt;/code&gt; , &lt;code&gt;warnings::warnif&lt;/code&gt; :: warn , warnings :: warnif и warnings &lt;code&gt;warnings::enabled&lt;/code&gt; могут дополнительно использовать ссылку на объект вместо имени категории. В этом случае функции будут использовать имя класса объекта в качестве категории предупреждений.</target>
        </trans-unit>
        <trans-unit id="7318f95ef0833e84e87f8f8ccae92d5cf168ab78" translate="yes" xml:space="preserve">
          <source>The three warnings functions, &lt;code&gt;warnings::warn&lt;/code&gt;, &lt;code&gt;warnings::warnif&lt;/code&gt; and &lt;code&gt;warnings::enabled&lt;/code&gt; can optionally take an object reference in place of a category name. In this case the functions will use the class name of the object as the warnings category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330a38aeb545f580c0244d785039ed36ba36d545" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl #121481]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl # 121481]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b68d73ad1b59ae384323f9df247206460ebd3566" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl #116487]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl # 116487]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8045076fdd60e6523f73b7c70511783c44a65e4" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl #119313]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl # 119313]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a16744b674df3a293c07c2c144ffeafe30d93a5" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl #119315]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl # 119315]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed1860908f3e196b681653f0d3c4015121aac114" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl #119317]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl # 119317]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c89e9b1dbbb9968b38d0d3719212d5f4f930d48c" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl #119437]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl # 119437]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a1e967726ae4e6415ad56477887e8f2fd56977f" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl #119451]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl # 119451]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f14154eef095f6d5ad9ed12b7ee560090c8240df" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl #119453]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl # 119453]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1140c9b87fc789061a9c67b7de5921f54ea0a0a7" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl #119455]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl # 119455]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6f307da7b6aa442d7423ca357f21550160d4bb6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl #120085]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl # 120085]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b73333a2d87bb4bdcdf8360f5d380f719aac7b6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl #122947]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl # 122947]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25b9d0a99bd226d2ae0ff1a2acdc8ae410a969ec" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl #123630]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl # 123630]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0769a8451d93e389be7960f58724061e03726c33" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl #123707]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl # 123707]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4152408e418529cff3fa9a89a90fa02a4c71e407" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl #120162]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl # 120162]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="896c7c2fe4064687353e3dfbb412d579a6d56aea" translate="yes" xml:space="preserve">
          <source>The tie() function binds a variable to a class (package) that will provide the implementation for access methods for that variable. Once this magic has been performed, accessing a tied variable automatically triggers method calls in the proper class. The complexity of the class is hidden behind magic methods calls. The method names are in ALL CAPS, which is a convention that Perl uses to indicate that they're called implicitly rather than explicitly--just like the BEGIN() and END() functions.</source>
          <target state="translated">Функция tie()связывает переменную с классом (пакетом),который обеспечит реализацию методов доступа к этой переменной.После того,как эта магия выполнена,доступ к связанной переменной автоматически вызывает метод в соответствующем классе.Сложность класса скрыта за вызовами магических методов.Имена методов находятся во ВСЕХ CAPS,что является условным обозначением,которое Perl использует для указания на то,что они вызываются неявно,а не явно-так же,как и функции BEGIN()и END().</target>
        </trans-unit>
        <trans-unit id="0cc71f8e2650c3f7dc36c81297b9a74bd871dbac" translate="yes" xml:space="preserve">
          <source>The tighter rules given above for the single form apply to everything to the right of the colon or equals; the looser rules still apply to everything to the left.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae79bd4ddb1c94445f10f56348d3008d5501006" translate="yes" xml:space="preserve">
          <source>The time at which the program began running, in seconds since the epoch (beginning of 1970). The values returned by the &lt;b&gt;-M&lt;/b&gt;, &lt;b&gt;-A&lt;/b&gt;, and &lt;b&gt;-C&lt;/b&gt; filetests are based on this value.</source>
          <target state="translated">Время начала выполнения программы в секундах с начала 1970-х гг. Значения, возвращаемые тестами &lt;b&gt;-M&lt;/b&gt; , &lt;b&gt;-A&lt;/b&gt; и &lt;b&gt;-C&lt;/b&gt; , основаны на этом значении.</target>
        </trans-unit>
        <trans-unit id="850e579e5bd369cd341c43e0bd12ab77ec41d87f" translate="yes" xml:space="preserve">
          <source>The time has been cut in half, which is a respectable speed improvement by any standard. Naturally, it is important to check the output is consistent with the first program run, this is where the Unix system &lt;code&gt;cksum&lt;/code&gt; utility comes in.</source>
          <target state="translated">Время сократилось вдвое, что по любым стандартам является значительным улучшением скорости. Естественно, важно убедиться, что вывод согласуется с первым запуском программы, здесь на &lt;code&gt;cksum&lt;/code&gt; приходит утилита cksum системы Unix .</target>
        </trans-unit>
        <trans-unit id="b516aafa3dbd5e537bbd8654d3807aa023edea27" translate="yes" xml:space="preserve">
          <source>The time it takes varies depending on how fast your machine is and how large your encoding is. Unless you are working on something big like euc-tw, it won't take too long.</source>
          <target state="translated">Время,необходимое для этого,варьируется в зависимости от того,насколько быстр ваш станок и насколько велика ваша кодировка.Если вы не работаете над чем-то большим,например,над euc-tw,это не займет много времени.</target>
        </trans-unit>
        <trans-unit id="e4a773ca459be08fb127884cfab114e154432eff" translate="yes" xml:space="preserve">
          <source>The time of the null loop (a loop with the same number of rounds but empty loop body) is subtracted from the time of the real loop.</source>
          <target state="translated">Время нулевого цикла (цикла с таким же количеством циклов,но с пустым телом цикла)вычитается из времени реального цикла.</target>
        </trans-unit>
        <trans-unit id="b6a2ce725119cbf8ac82ed9014cf15ca7bd90e68" translate="yes" xml:space="preserve">
          <source>The time returned also includes the process times of the terminated child processes for which wait() has been executed. This value is somewhat like the second value returned by the times() of core Perl, but not necessarily identical. Note that due to backward compatibility limitations the returned value may wrap around at about 2147 seconds or at about 36 minutes.</source>
          <target state="translated">Возвращаемое время также включает в себя время завершенных дочерних процессов,для которых была выполнена функция wait().Это значение в некоторой степени похоже на второе значение,возвращаемое функцией times()ядра Perl,но не обязательно идентично.Обратите внимание,что из-за ограничений обратной совместимости возвращаемое значение может обернуться примерно 2147 секунд или около 36 минут.</target>
        </trans-unit>
        <trans-unit id="0d1626bdb98ca3cc408f22b06c2161e7fe233ac0" translate="yes" xml:space="preserve">
          <source>The time when Perl is actually doing what your code says to do, as opposed to the earlier period of time when it was trying to figure out whether what you said made any sense whatsoever, which is &lt;b&gt;compile time&lt;/b&gt;.</source>
          <target state="translated">Время, когда Perl фактически выполняет то, что говорит ваш код, в отличие от более раннего периода времени, когда он пытался выяснить, имеет ли то, что вы сказали, какой-либо смысл, то есть &lt;b&gt;время компиляции&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="84f0e5475a9de884cf21f0b5087fb4edeef00da2" translate="yes" xml:space="preserve">
          <source>The time when Perl is trying to make sense of your code, as opposed to when it thinks it knows what your code means and is merely trying to do what it thinks your code says to do, which is &lt;b&gt;runtime&lt;/b&gt;.</source>
          <target state="translated">Время, когда Perl пытается разобраться в вашем коде, а не тогда, когда он думает, что знает, что означает ваш код, и просто пытается делать то, что, по его мнению, ваш код говорит делать, а именно &lt;b&gt;время выполнения&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2e4f067abc3cb37a82d1ce3a350c4ed5ac55d47a" translate="yes" xml:space="preserve">
          <source>The timeout in the [PKG] can be specified as zero to effect a &quot;poll&quot;, but you shouldn't do that because a new IO::Select object will be created behind the scenes just to do the single poll. This is horrendously inefficient. Use rather true select() with a zero timeout on the handle, or non-blocking IO.</source>
          <target state="translated">Таймаут в [PKG]может быть указан как ноль,чтобы произвести &quot;опрос&quot;,но вы не должны делать этого,потому что новый IO::Select объект будет создан за кулисами только для того,чтобы провести одиночный опрос.Это ужасно неэффективно.Используйте скорее истинную функцию select()с нулевым таймаутом на дескрипторе,или неблокирующий IO.</target>
        </trans-unit>
        <trans-unit id="538790731acb7259f937f6ff4a2bbf78b24054c5" translate="yes" xml:space="preserve">
          <source>The timeout may be a number of seconds relative to the current time (e.g., 5 seconds from when the call is made), or may be an absolute timeout in</source>
          <target state="translated">Таймаут может быть несколько секунд относительно текущего времени (например,5 секунд с момента совершения вызова),или может быть абсолютным таймаутом в</target>
        </trans-unit>
        <trans-unit id="ff980bdd72965b0a57183b47bf6c39d63a6adebb" translate="yes" xml:space="preserve">
          <source>The timeout value, in seconds, for this socket connection. How exactly this value is utilized is defined in the socket domain subclasses that make use of the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd8fbd616a78a90070ef718270fee035f94b0bad" translate="yes" xml:space="preserve">
          <source>The timing is done using time(3) and times(3).</source>
          <target state="translated">Синхронизация выполняется с использованием времени(3)и времени(3).</target>
        </trans-unit>
        <trans-unit id="bfc27e045cf8c436a59465851692c98d92afa4eb" translate="yes" xml:space="preserve">
          <source>The title of this section indicates the second problem you may run into sooner or later when you pack C structures. If the function you intend to call expects a, say, &lt;code&gt;void *&lt;/code&gt; value, you</source>
          <target state="translated">Заголовок этого раздела указывает на вторую проблему, с которой вы можете рано или поздно столкнуться при упаковке структур C. Если функция, которую вы собираетесь вызвать, ожидает, скажем, значение &lt;code&gt;void *&lt;/code&gt; , вы</target>
        </trans-unit>
        <trans-unit id="3aeea9af350571abf85e25c4751ee40203e9d46b" translate="yes" xml:space="preserve">
          <source>The top level documentation about Perl regular expressions is found in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">Документация верхнего уровня о регулярных выражениях Perl находится в &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3205e679e2f0bb1ae1342389bae87dd20bedcfd5" translate="yes" xml:space="preserve">
          <source>The top node in the tree is &lt;code&gt;[ 'Document', \%attributes,
&lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</source>
          <target state="translated">Верхний узел в дереве - это &lt;code&gt;[ 'Document', \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37995bec6dd9b8643c48818f0b81e11787b543cc" translate="yes" xml:space="preserve">
          <source>The total elapsed times the test took to run, in seconds from the epoch..</source>
          <target state="translated">Общее время,затраченное на проведение теста,в секундах от эпохи...</target>
        </trans-unit>
        <trans-unit id="1c62e4162c4c89e197d0fdd84f0911b0a91d8950" translate="yes" xml:space="preserve">
          <source>The total number of comparisons is equal to the sum of the squares of the number of entries in each bucket. For a random hash of &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt; keys into &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt; buckets, the expected value is:</source>
          <target state="translated">Общее количество сравнений равно сумме квадратов количества записей в каждой корзине. Для случайного хеширования &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt; ключей в &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt; сегментов ожидаемое значение:</target>
        </trans-unit>
        <trans-unit id="dd7a1cc091879ad89ef24fb0639fcf0e894d70ac" translate="yes" xml:space="preserve">
          <source>The total number of comparisons is equal to the sum of the squares of the number of entries in each bucket. For a random hash of &lt;code&gt;&amp;lt;n&lt;/code&gt;&amp;gt; keys into &lt;code&gt;&amp;lt;k&lt;/code&gt;&amp;gt; buckets, the expected value is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c2502de58f3e2d86d4adebf37cdce84d5b9f9b" translate="yes" xml:space="preserve">
          <source>The total time it took for the test to run, in seconds. If &lt;code&gt;Time::HiRes&lt;/code&gt; is available, it will have finer granularity.</source>
          <target state="translated">Общее время, необходимое для запуска теста, в секундах. Если &lt;code&gt;Time::HiRes&lt;/code&gt; доступен, он будет иметь более тонкую детализацию.</target>
        </trans-unit>
        <trans-unit id="1b3a565887dd69be936761de4d497f57b4dfa910" translate="yes" xml:space="preserve">
          <source>The tradeoff is that one needs to calculate the number of return values in advance (though overextending the stack will not typically hurt anything but memory consumption).</source>
          <target state="translated">Компромисс заключается в том,что необходимо заранее рассчитать количество возвращаемых значений (хотя чрезмерное увеличение стека,как правило,не повредит ничему,кроме расхода памяти).</target>
        </trans-unit>
        <trans-unit id="02dc2cb0935e5c48d56deb5ed1a283c1991198d6" translate="yes" xml:space="preserve">
          <source>The traditional &quot;0&quot;, &quot;1&quot;, and &quot;2&quot; MODEs are implemented with different numeric values on some systems. The flags exported by &lt;code&gt;Fcntl&lt;/code&gt; (O_RDONLY, O_WRONLY, O_RDWR) should work everywhere though. (Mac OS, OS/390)</source>
          <target state="translated">Традиционные РЕЖИМЫ &amp;laquo;0&amp;raquo;, &amp;laquo;1&amp;raquo; и &amp;laquo;2&amp;raquo; реализуются с разными числовыми значениями в некоторых системах. Флаги, экспортируемые &lt;code&gt;Fcntl&lt;/code&gt; (O_RDONLY, O_WRONLY, O_RDWR), должны работать везде. (Mac OS, OS / 390)</target>
        </trans-unit>
        <trans-unit id="edec44b15608ad1c090140c537934ec3a77ab750" translate="yes" xml:space="preserve">
          <source>The traditional one has it followed by a name enclosed in braces, meaning the character (or sequence of characters) given by that name. Thus &lt;code&gt;\N{ASTERISK}&lt;/code&gt; is another way of writing &lt;code&gt;*&lt;/code&gt; , valid in both double-quoted strings and regular expression patterns. In patterns, it doesn't have the meaning an unescaped &lt;code&gt;*&lt;/code&gt; does.</source>
          <target state="translated">В традиционном варианте за ним следует имя, заключенное в фигурные скобки, что означает символ (или последовательность символов), заданный этим именем. Таким образом, &lt;code&gt;\N{ASTERISK}&lt;/code&gt; - это еще один способ записи &lt;code&gt;*&lt;/code&gt; , допустимый как для строк в двойных кавычках, так и для шаблонов регулярных выражений. В шаблонах он не имеет значения, которое имеет неэкранированный &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa46fd7f5efd6b7870b67ed7954394e54344b140" translate="yes" xml:space="preserve">
          <source>The traditional one has it followed by a name enclosed in braces, meaning the character (or sequence of characters) given by that name. Thus &lt;code&gt;\N{ASTERISK}&lt;/code&gt; is another way of writing &lt;code&gt;*&lt;/code&gt;, valid in both double-quoted strings and regular expression patterns. In patterns, it doesn't have the meaning an unescaped &lt;code&gt;*&lt;/code&gt; does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf50a6157f8b6c5d609d11261410355088e7eb85" translate="yes" xml:space="preserve">
          <source>The transitional compilation environment is obtained with the following compiler and linker flags:</source>
          <target state="translated">Переходная среда компиляции получается с помощью следующих флагов компилятора и компоновщика:</target>
        </trans-unit>
        <trans-unit id="5205d19a729f5413830c865ec36ec411e1524d36" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;a href=&quot;#tr%2F%2F%2F&quot;&gt;&lt;code&gt;tr///&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;&quot;Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a818fdcd409263a5793457d26567f24ef801cf" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;a href=&quot;#y%2F%2F%2F&quot;&gt;&lt;code&gt;y///&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;&quot;Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7383cd567e6253ea6210a9db604e2fa9e5e4632a" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Оператор транслитерации. То же, что и &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; . См. Раздел &amp;laquo; &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Операторы типа кавычек&amp;raquo; в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e96d614d57d8ccc80741217a9adfc3a85457d070" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Оператор транслитерации. То же, что и &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; . См. Раздел &amp;laquo; &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Операторы типа кавычек&amp;raquo; в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4178c59a00064af8220ead2c08c98e1676579390" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Оператор транслитерации. То же, что и &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; . См. Раздел &amp;laquo; &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Операторы типа кавычек&amp;raquo; в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea9a92782ae9df97b0632f112e4b5544a1a9028b" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Оператор транслитерации. То же, что и &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; . См. Раздел &amp;laquo; &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Операторы типа кавычек&amp;raquo; в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75ab4f7335b924ba00dcfa6684ad7ab9b56afe36" translate="yes" xml:space="preserve">
          <source>The trap and untrap methods are synonyms for deny and permit respectfully.</source>
          <target state="translated">Ловушка и методы-ловушка-это синонимы отрицания и разрешения с уважением.</target>
        </trans-unit>
        <trans-unit id="79edf12630cd230667f23adf7c1c02295b7aaf31" translate="yes" xml:space="preserve">
          <source>The treatment of more than one physical &lt;b&gt;line&lt;/b&gt; as a single logical line. &lt;b&gt;Makefile&lt;/b&gt; lines are continued by putting a backslash before the &lt;b&gt;newline&lt;/b&gt;. Mail headers, as defined by RFC 822, are continued by putting a space or tab</source>
          <target state="translated">Обработка более чем одной физической &lt;b&gt;линии&lt;/b&gt; как одной логической линии. Строки &lt;b&gt;Makefile&lt;/b&gt; продолжаются обратной косой чертой перед &lt;b&gt;новой строкой&lt;/b&gt; . Заголовки писем, как определено в RFC 822, продолжаются помещением пробела или табуляции.</target>
        </trans-unit>
        <trans-unit id="416e0656b5d6eca80f77db061d8df87eef2d675e" translate="yes" xml:space="preserve">
          <source>The tree is created by the compiler while</source>
          <target state="translated">Дерево создается компилятором во время</target>
        </trans-unit>
        <trans-unit id="751a409fc8b6dd72130af7dcf107013d6a066c03" translate="yes" xml:space="preserve">
          <source>The trick in this task is to find the directory. Before your script does anything else (such as a &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;), you can get the current working directory with the &lt;code&gt;Cwd&lt;/code&gt; module, which comes with Perl:</source>
          <target state="translated">Уловка в этой задаче состоит в том, чтобы найти каталог. Прежде чем ваш сценарий сделает что-либо еще (например, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; ), вы можете получить текущий рабочий каталог с &lt;code&gt;Cwd&lt;/code&gt; модуля Cwd , который поставляется с Perl:</target>
        </trans-unit>
        <trans-unit id="37e82dc52d548373adee493d4ea5761e5091b906" translate="yes" xml:space="preserve">
          <source>The trick in this task is to find the directory. Before your script does anything else (such as a &lt;code&gt;chdir&lt;/code&gt;), you can get the current working directory with the &lt;code&gt;Cwd&lt;/code&gt; module, which comes with Perl:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5f4f31af96f44cb48b6403e792709ecc6d53b8e" translate="yes" xml:space="preserve">
          <source>The trick is that if you read a &lt;code&gt;BOM&lt;/code&gt; , you will know the byte order, since if it was written on a big-endian platform, you will read the bytes &lt;code&gt;0xFE 0xFF&lt;/code&gt;, but if it was written on a little-endian platform, you will read the bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt;. (And if the originating platform was writing in ASCII platform UTF-8, you will read the bytes &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt;.)</source>
          <target state="translated">Хитрость в том, что если вы читаете &lt;code&gt;BOM&lt;/code&gt; , вы будете знать порядок байтов, поскольку если она была написана на платформе с &lt;code&gt;0xFE 0xFF&lt;/code&gt; байтов, вы прочитаете байты 0xFE 0xFF , но если она была написана на платформе с прямым порядком байтов, вы будет читать байты &lt;code&gt;0xFF 0xFE&lt;/code&gt; . (И если &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt; платформа писала на платформе ASCII UTF-8, вы прочитаете байты 0xEF 0xBB 0xBF .)</target>
        </trans-unit>
        <trans-unit id="d8b1136600662502a87d3bbe9f24bb9e6d532704" translate="yes" xml:space="preserve">
          <source>The trick is that if you read a &lt;code&gt;BOM&lt;/code&gt;, you will know the byte order, since if it was written on a big-endian platform, you will read the bytes &lt;code&gt;0xFE 0xFF&lt;/code&gt;, but if it was written on a little-endian platform, you will read the bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt;. (And if the originating platform was writing in ASCII platform UTF-8, you will read the bytes &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f1375fe9d48b636ba837bd6c5d9b3f6fb48c48" translate="yes" xml:space="preserve">
          <source>The trick is to give a special parameter to the Configure shell script when running it on AIX:</source>
          <target state="translated">Хитрость заключается в том,чтобы дать специальный параметр скрипту оболочки Configure при его запуске на AIX:</target>
        </trans-unit>
        <trans-unit id="0a8f7f70cdf2316a2ca5d5174affe77306a16af9" translate="yes" xml:space="preserve">
          <source>The trick to this problem is avoiding accidental autovivification. If you want to check three keys deep, you might na&amp;iuml;vely try this:</source>
          <target state="translated">Уловка решения этой проблемы заключается в том, чтобы избежать случайного автовивификации. Если вы хотите проверить три ключа в глубину, вы можете наивно попробовать следующее:</target>
        </trans-unit>
        <trans-unit id="8f023c48c1c4fd330a5e021a4a36ff097b3f2c34" translate="yes" xml:space="preserve">
          <source>The tricky thing to remember is that the first parameter is true if you want to</source>
          <target state="translated">Коварная вещь,которую нужно запомнить,это то,что первый параметр является истинным,если вы хотите.</target>
        </trans-unit>
        <trans-unit id="0358acd687c89e6aeedb15fd79329af2ac79f19b" translate="yes" xml:space="preserve">
          <source>The trigonometric constant &lt;b&gt;pi&lt;/b&gt; and some of handy multiples of it are also defined.</source>
          <target state="translated">Также определены тригонометрическая константа &lt;b&gt;пи&lt;/b&gt; и некоторые из удобных кратных ей.</target>
        </trans-unit>
        <trans-unit id="46116b5afa30e36e5dfcca4ac124810d45929096" translate="yes" xml:space="preserve">
          <source>The trust in item 2 is transitive. If A trusts B, and B trusts C, then A trusts C. So if you do not override &lt;code&gt;@ISA&lt;/code&gt; with &lt;code&gt;@CARP_NOT&lt;/code&gt; , then this trust relationship is identical to, &quot;inherits from&quot;.</source>
          <target state="translated">Доверие к п. 2 является переходным. Если A доверяет B, а B доверяет C, то A доверяет C. Поэтому, если вы не переопределяете &lt;code&gt;@ISA&lt;/code&gt; с помощью &lt;code&gt;@CARP_NOT&lt;/code&gt; , то это доверительное отношение идентично &amp;laquo;наследует от&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="5a53c9a156d74f53aad5146b2193b6c99edc7b60" translate="yes" xml:space="preserve">
          <source>The trust in item 2 is transitive. If A trusts B, and B trusts C, then A trusts C. So if you do not override &lt;code&gt;@ISA&lt;/code&gt; with &lt;code&gt;@CARP_NOT&lt;/code&gt;, then this trust relationship is identical to, &quot;inherits from&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761c5f5b8a8444418e2d9bdc4d8cca16ccc65180" translate="yes" xml:space="preserve">
          <source>The truth of the matter is that perl's regular expressions these days are much more complex than this kind of structure, but visualising it this way can help when trying to get your bearings, and it matches the current implementation pretty closely.</source>
          <target state="translated">Правда в том,что регулярные выражения perl в наши дни намного сложнее,чем подобные структуры,но визуализация их таким образом может помочь при попытке сориентироваться,и они довольно близко подходят к текущей реализации.</target>
        </trans-unit>
        <trans-unit id="df6a9452c74fa01c8c98846cb474f3c173568489" translate="yes" xml:space="preserve">
          <source>The tty driver is put into raw mode and restored using an operating system specific command, in UNIX-like environments &lt;code&gt;stty&lt;/code&gt; .</source>
          <target state="translated">Драйвер tty переводится в необработанный режим и восстанавливается с помощью специальной команды операционной системы в UNIX-подобных средах &lt;code&gt;stty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdeef98c16938c38d93335b37db574e68be16a48" translate="yes" xml:space="preserve">
          <source>The tty driver is put into raw mode and restored using an operating system specific command, in UNIX-like environments &lt;code&gt;stty&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fb31ac14610942d5eec87bdc1a87d0b036e971" translate="yes" xml:space="preserve">
          <source>The tutorial started in the Llama continues in the Alpaca, which introduces the intermediate features of references, data structures, object-oriented programming, and modules:</source>
          <target state="translated">Учебное пособие,начатое в Llama,продолжается в Alpaca,где представлены промежуточные функции ссылок,структур данных,объектно-ориентированного программирования и модулей:</target>
        </trans-unit>
        <trans-unit id="6ef070521ff5826ca5eb1f98285ab64a027e2793" translate="yes" xml:space="preserve">
          <source>The two additional lines request from perl to catch various common problems in your code. They check different things so you need both. A potential problem caught by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; will cause your code to stop immediately when it is encountered, while &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; will merely give a warning (like the command-line switch &lt;b&gt;-w&lt;/b&gt;) and let your code run. To read more about them check their respective manual pages at &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">Две дополнительные строки запрашивают perl для выявления различных распространенных проблем в вашем коде. Они проверяют разные вещи, поэтому вам нужно и то, и другое. Потенциальная проблема, обнаруженная при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; заставит ваш код немедленно останавливаться, когда он встречается, при этом &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; просто выдаст предупреждение (например, ключ командной строки &lt;b&gt;-w&lt;/b&gt; ) и позволит вашему коду работать. Чтобы узнать больше о них, просмотрите соответствующие страницы руководства на &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; и &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80da0e6781561e53bd7245c97926dc9ea61049b1" translate="yes" xml:space="preserve">
          <source>The two additional lines request from perl to catch various common problems in your code. They check different things so you need both. A potential problem caught by &lt;code&gt;use strict;&lt;/code&gt; will cause your code to stop immediately when it is encountered, while &lt;code&gt;use warnings;&lt;/code&gt; will merely give a warning (like the command-line switch &lt;b&gt;-w&lt;/b&gt;) and let your code run. To read more about them check their respective manual pages at &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2dc4945c85043455423fb1b5a39f8aa3d6b28f" translate="yes" xml:space="preserve">
          <source>The two argument form of add_bits() will add the first $nbits bits from $data. For the last potentially partial byte only the high order &lt;code&gt;$nbits % 8&lt;/code&gt; bits are used. If $nbits is greater than &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; , then this method would do the same as &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; .</source>
          <target state="translated">Форма с двумя аргументами add_bits () добавит первые $ nbits битов из $ data. Для последнего потенциально неполного байта используются только &lt;code&gt;$nbits % 8&lt;/code&gt; биты $ nbits% 8 . Если $ nbits больше, чем &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; , то этот метод будет делать то же, что и &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a487d05aa816a2a714594f695177da57d7a262a6" translate="yes" xml:space="preserve">
          <source>The two argument form of add_bits() will add the first $nbits bits from $data. For the last potentially partial byte only the high order &lt;code&gt;$nbits % 8&lt;/code&gt; bits are used. If $nbits is greater than &lt;code&gt;length($data) * 8&lt;/code&gt;, then this method would do the same as &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edfc68f9b85a8c57ac6b419328c423790a72a43e" translate="yes" xml:space="preserve">
          <source>The two arrays &lt;code&gt;@ISA&lt;/code&gt; and &lt;code&gt;@EXPORT&lt;/code&gt; are very important. The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of other packages in which to search for methods (or subroutines) that do not exist in the current package. This is usually only important for object-oriented extensions (which we will talk about much later), and so usually doesn't need to be modified.</source>
          <target state="translated">Два массива &lt;code&gt;@ISA&lt;/code&gt; и &lt;code&gt;@EXPORT&lt;/code&gt; очень важны. &lt;code&gt;@ISA&lt;/code&gt; массив содержит список других пакетов , в которых можно искать методы (или подпрограммы) , которые не существуют в текущем пакете. Обычно это важно только для объектно-ориентированных расширений (о которых мы поговорим намного позже), и поэтому обычно не требует изменений.</target>
        </trans-unit>
        <trans-unit id="1bc049a18027fa1202df37bcfed013d26326a12f" translate="yes" xml:space="preserve">
          <source>The two control characters ^D and ^Z, and the tokens __END__ and __DATA__ may be used to indicate the logical end of the script before the actual end of file. Any following text is ignored.</source>
          <target state="translated">Два управляющих символа ^D и ^Z,а также маркеры __END__и __DATA__могут использоваться для указания логического конца скрипта до фактического конца файла.Любой следующий текст игнорируется.</target>
        </trans-unit>
        <trans-unit id="34dcc268df0f1b7f78c17ae23e0cef09454c6cdc" translate="yes" xml:space="preserve">
          <source>The two entry points are &lt;code&gt;re_intuit_start()&lt;/code&gt; and &lt;code&gt;pregexec()&lt;/code&gt; . These routines have a somewhat incestuous relationship with overlap between their functions, and &lt;code&gt;pregexec()&lt;/code&gt; may even call &lt;code&gt;re_intuit_start()&lt;/code&gt; on its own. Nevertheless other parts of the perl source code may call into either, or both.</source>
          <target state="translated">Две точки входа - это &lt;code&gt;re_intuit_start()&lt;/code&gt; и &lt;code&gt;pregexec()&lt;/code&gt; . Эти подпрограммы имеют несколько кровосмесительную связь с перекрытием их функций, и &lt;code&gt;pregexec()&lt;/code&gt; может даже вызывать &lt;code&gt;re_intuit_start()&lt;/code&gt; самостоятельно. Тем не менее, другие части исходного кода Perl могут вызывать одну или обе.</target>
        </trans-unit>
        <trans-unit id="18c4b8288d8734c5d96fe76caf7da0dc805d1f00" translate="yes" xml:space="preserve">
          <source>The two entry points are &lt;code&gt;re_intuit_start()&lt;/code&gt; and &lt;code&gt;pregexec()&lt;/code&gt;. These routines have a somewhat incestuous relationship with overlap between their functions, and &lt;code&gt;pregexec()&lt;/code&gt; may even call &lt;code&gt;re_intuit_start()&lt;/code&gt; on its own. Nevertheless other parts of the perl source code may call into either, or both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4c95b48b6a1668825ba4572ce44483ca77dc51" translate="yes" xml:space="preserve">
          <source>The two filenames can also be given separately in full as &lt;code&gt;$dirfile&lt;/code&gt; and &lt;code&gt;$pagfilename&lt;/code&gt; . This suits for two files without &quot;.dir&quot; and &quot;.pag&quot; extensions, perhaps for example two files from &lt;a href=&quot;file/temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">Два имени файла также могут быть указаны отдельно полностью как &lt;code&gt;$dirfile&lt;/code&gt; и &lt;code&gt;$pagfilename&lt;/code&gt; . Это подходит для двух файлов без расширений &quot;.dir&quot; и &quot;.pag&quot;, например, для двух файлов из &lt;a href=&quot;file/temp&quot;&gt;File :: Temp&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d779d1807753d79ce6e5b3476dc2ab8ca5a48661" translate="yes" xml:space="preserve">
          <source>The two filenames can also be given separately in full as &lt;code&gt;$dirfile&lt;/code&gt; and &lt;code&gt;$pagfilename&lt;/code&gt;. This suits for two files without &quot;.dir&quot; and &quot;.pag&quot; extensions, perhaps for example two files from &lt;a href=&quot;File::Temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f1774e1f537dc56f588c1be426bca15556e7438" translate="yes" xml:space="preserve">
          <source>The two first forms are simply syntactic sugar which automatically load the right module on first use. The second form allow you to use algorithm names which contains letters which are not legal perl identifiers, e.g. &quot;SHA-1&quot;. If no implementation for the given algorithm can be found, then an exception is raised.</source>
          <target state="translated">Первые две формы-это просто синтаксический сахар,который автоматически загружает нужный модуль при первом использовании.Вторая форма позволяет использовать имена алгоритмов,которые содержат буквы,не являющиеся легальными perl идентификаторами,например &quot;SHA-1&quot;.Если реализация для данного алгоритма не найдена,то возникает исключение.</target>
        </trans-unit>
        <trans-unit id="c95a4925ad583d0cdab2da763605ba8a5577a6cd" translate="yes" xml:space="preserve">
          <source>The two main uses for this are to switch back to using the package sub inside an inner scope:</source>
          <target state="translated">Двумя основными целями для этого являются возврат к использованию подпакета внутри внутренней области видимости:</target>
        </trans-unit>
        <trans-unit id="9fdb893929b74d583f916a04691865e61a0c8195" translate="yes" xml:space="preserve">
          <source>The two most common mistakes made in constructing something like an array of arrays is either accidentally counting the number of elements or else taking a reference to the same memory location repeatedly. Here's the case where you just get the count instead of a nested array:</source>
          <target state="translated">Две наиболее распространенные ошибки при построении нечто вроде массива массивов-это либо случайный подсчет количества элементов,либо многократное обращение к одному и тому же месту памяти.Вот случай,когда вместо вложенного массива происходит просто подсчет:</target>
        </trans-unit>
        <trans-unit id="bd2d45d08dbd09dca740f5cf8bff110dce877246" translate="yes" xml:space="preserve">
          <source>The two primary use cases supported by &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; for plugins are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef613531270a3be0f714b7b0c6603ad457c5c67" translate="yes" xml:space="preserve">
          <source>The two primary use cases supported by &lt;a href=&quot;harness&quot;&gt;TAP::Harness&lt;/a&gt; for plugins are</source>
          <target state="translated">&lt;a href=&quot;harness&quot;&gt;TAP :: Harness&lt;/a&gt; для плагинов поддерживает два основных варианта использования :</target>
        </trans-unit>
        <trans-unit id="49899df9616cd2a3f123de74937bc969a55089e7" translate="yes" xml:space="preserve">
          <source>The two quickest fixes are either to render Perl silent about any locale inconsistencies or to run Perl under the default locale &quot;C&quot;.</source>
          <target state="translated">Двумя самыми быстрыми исправлениями являются:либо вывод информации о несоответствиях на Perl,либо запуск Perl под установленной по умолчанию локалью &quot;C&quot;.</target>
        </trans-unit>
        <trans-unit id="1d29057aa8b200a921ab9b4c9f2a8fac7349c60a" translate="yes" xml:space="preserve">
          <source>The two sets of barcharts give stats and a visual indication of performance of the hash.</source>
          <target state="translated">Два набора баркасов дают статистику и визуальную индикацию исполнения хэша.</target>
        </trans-unit>
        <trans-unit id="ea356fe6678cb16635414403ae22dc70cf7c6eb2" translate="yes" xml:space="preserve">
          <source>The two statements:</source>
          <target state="translated">Оба заявления:</target>
        </trans-unit>
        <trans-unit id="9d44f9be0143700229ab0017bf471dc2508dbc35" translate="yes" xml:space="preserve">
          <source>The two-sided ordering operators &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;cmp&quot;&lt;/code&gt;, and the smartmatch operator &lt;code&gt;&quot;~~&quot;&lt;/code&gt;, are non-associative with respect to each other and with respect to the equality operators of the same precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f9fd98a080c00fe06d27a5abbbe001334533cf" translate="yes" xml:space="preserve">
          <source>The type of partition. See the &lt;code&gt;&quot;:PARTITION_&quot;&lt;/code&gt; export class for a list of known types. See also &lt;code&gt;IsRecognizedPartition&lt;/code&gt; and &lt;code&gt;IsContainerPartition&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e850f7b70f56596c655ae357f7738793fa85127" translate="yes" xml:space="preserve">
          <source>The type of the constant (</source>
          <target state="translated">Тип константы (</target>
        </trans-unit>
        <trans-unit id="207d3c0594c531831415850568f05351cc4335f1" translate="yes" xml:space="preserve">
          <source>The type of the third parameter is arbitrary as far as the typemap is concerned. It just has to be in line with the declared variable.</source>
          <target state="translated">Тип третьего параметра является произвольным для типовой карты.Он просто должен соответствовать объявленной переменной.</target>
        </trans-unit>
        <trans-unit id="3a8fb2c5d9024ab64dd8a1b418b0785f1b45c2d4" translate="yes" xml:space="preserve">
          <source>The type-to-match is whitewashed (except for commas, which have no whitespace before them, and multiple &lt;code&gt;*&lt;/code&gt; which have no whitespace between them).</source>
          <target state="translated">Соответствующий тип выделен белым цветом (за исключением запятых, перед которыми нет пробелов, и нескольких &lt;code&gt;*&lt;/code&gt; ,между которыми нет пробелов).</target>
        </trans-unit>
        <trans-unit id="065bb709681867146d38619409b0c4858958cd7d" translate="yes" xml:space="preserve">
          <source>The typemap checks that a scalar reference is passed from perl to XS.</source>
          <target state="translated">Типовая карта проверяет,что ссылка на скаляр передается от perl к XS.</target>
        </trans-unit>
        <trans-unit id="1aca61f72e9539e566a25a6f843796b117e0a616" translate="yes" xml:space="preserve">
          <source>The types are:</source>
          <target state="translated">Типы:</target>
        </trans-unit>
        <trans-unit id="b8218b5c6abbddadba7d9cdb24a7712b0e31ed41" translate="yes" xml:space="preserve">
          <source>The typical C compiler&amp;rsquo;s first pass, which processes lines beginning with &lt;code&gt;#&lt;/code&gt; for conditional compilation and macro definition, and does various manipulations of the program text based on the current definitions. Also known as</source>
          <target state="translated">Типичный первый проход компилятора C, который обрабатывает строки, начинающиеся с &lt;code&gt;#&lt;/code&gt; для условной компиляции и определения макроса, и выполняет различные манипуляции с текстом программы на основе текущих определений. Также известный как</target>
        </trans-unit>
        <trans-unit id="c3f6853138e86a46a65a1f12c8ebb77c9ad23c63" translate="yes" xml:space="preserve">
          <source>The typical approach uses the Perl debugger, described in the</source>
          <target state="translated">Типичный подход использует отладчик Perl,описанный в разделе</target>
        </trans-unit>
        <trans-unit id="4f5664b1824b0de67fa46d923ec8d9a2b184a8da" translate="yes" xml:space="preserve">
          <source>The typical approach uses the Perl debugger, described in the &lt;a href=&quot;http://man.he.net/man1/perldebug&quot;&gt;perldebug(1)&lt;/a&gt; manpage, on an &quot;empty&quot; program, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d039cb4fff50dcf102a20e5a834fd5dcb92db29" translate="yes" xml:space="preserve">
          <source>The typical input/output flow of a program is:</source>
          <target state="translated">Типичный поток ввода/вывода программы:</target>
        </trans-unit>
        <trans-unit id="bb341dafe72dfd453b6e963169c19a0e3677ecc8" translate="yes" xml:space="preserve">
          <source>The typical interactions between pieces of data are best represented by operators.</source>
          <target state="translated">Типичные взаимодействия между фрагментами данных лучше всего представлены операторами.</target>
        </trans-unit>
        <trans-unit id="37bcc82c39e22721104650473d90114a9246bb63" translate="yes" xml:space="preserve">
          <source>The typical usage case is for private modules or working copies of projects from remote repositories on the local disk.</source>
          <target state="translated">Типичный случай использования-для приватных модулей или рабочих копий проектов из удаленных репозиториев на локальном диске.</target>
        </trans-unit>
        <trans-unit id="a4e2f09da65ffeb5dd41665671b5f400f853e79b" translate="yes" xml:space="preserve">
          <source>The typical usage is from within a Makefile generated by &lt;a href=&quot;makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;. So under normal circumstances you won't have to deal with this module directly.</source>
          <target state="translated">Типичное использование - из Makefile, созданного &lt;a href=&quot;makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt; . Таким образом, при нормальных обстоятельствах вам не придется иметь дело с этим модулем напрямую.</target>
        </trans-unit>
        <trans-unit id="e5ea1d13fc13ac160da9f2f104ab7304934ae9cc" translate="yes" xml:space="preserve">
          <source>The typical usage is from within perl's own Makefile (to build</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b839dd64fd51c7239737d976be2aaf701494cef3" translate="yes" xml:space="preserve">
          <source>The typical way to use an &lt;code&gt;EVERY&lt;/code&gt; call is to wrap it in another base method, that all classes inherit. For example, to ensure that every destructor an object inherits is actually called (as opposed to just the left-most-depth-first-est one):</source>
          <target state="translated">Типичный способ использования вызова &lt;code&gt;EVERY&lt;/code&gt; - заключить его в другой базовый метод, который наследуют все классы. Например, чтобы гарантировать, что каждый деструктор, который наследует объект, действительно вызывается (в отличие от только самого левого деструктора по глубине):</target>
        </trans-unit>
        <trans-unit id="d078360c456578fa6c56aaca3475f63295e459b1" translate="yes" xml:space="preserve">
          <source>The uncolor() function and support for ANSI_COLORS_DISABLED were added in Term::ANSIColor 1.04, included in Perl 5.8.0.</source>
          <target state="translated">Функция uncolor()и поддержка ANSI_COLORS_DISABLED добавлены в Term::ANSIColor 1.04,входящий в Perl 5.8.0.</target>
        </trans-unit>
        <trans-unit id="d4305b00ed1c85486a9072f02e9b2ef3f0a22224" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;SetFilePointer&lt;/code&gt; returns &lt;code&gt;0xFFFFFFFF&lt;/code&gt; to indicate failure, but if &lt;code&gt;$ioivOffsetHigh&lt;/code&gt; is not &lt;code&gt;[]&lt;/code&gt;, you would also have to check &lt;code&gt;$^E&lt;/code&gt; to determine whether &lt;code&gt;0xFFFFFFFF&lt;/code&gt; indicates an error or not. &lt;code&gt;Win32API::File::SetFilePointer&lt;/code&gt; does this checking for you and returns a false value if and only if the underlying &lt;code&gt;SetFilePointer&lt;/code&gt; failed. For this reason, &lt;code&gt;$uNewPos&lt;/code&gt; is set to &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; if you set the file pointer to the beginning of the file [or any position with 0 for the low-order 4 bytes].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2ba2ed494fcbfde7ff54569b0d33c7f011e269" translate="yes" xml:space="preserve">
          <source>The underlying behaviour of &lt;code&gt;%+&lt;/code&gt; is provided by the &lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2846292c4ece0df1cdbdb746e73838c0174b8ea" translate="yes" xml:space="preserve">
          <source>The underlying behaviour of &lt;code&gt;%+&lt;/code&gt; is provided by the &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="translated">Базовое поведение &lt;code&gt;%+&lt;/code&gt; обеспечивается модулем &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc10f153a716bc66afaf3456e02a5c9183a04515" translate="yes" xml:space="preserve">
          <source>The underlying parser object. This is useful if you need the full information for the test program.</source>
          <target state="translated">Объект,лежащий в основе парсера.Это полезно,если вам нужна полная информация для тестовой программы.</target>
        </trans-unit>
        <trans-unit id="b7d8dde972f17bdda4b61ab86196bc96064679a1" translate="yes" xml:space="preserve">
          <source>The undump program was an ancient attempt to speed up Perl program by storing the already-compiled form to disk. This is no longer a viable option, as it only worked on a few architectures, and wasn't a good solution anyway.</source>
          <target state="translated">Программа undump была древней попыткой ускорить программу Perl,сохранив уже скомпилированную форму на диск.Это больше не является жизнеспособным вариантом,так как она работала только на нескольких архитектурах,и в любом случае не была хорошим решением.</target>
        </trans-unit>
        <trans-unit id="be8a46bbcbbd519aa2c58d3aea183c9d8f4c685d" translate="yes" xml:space="preserve">
          <source>The unfortunate similarity of this function's name to that of Perl's &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; operator is strictly coincidental. This function works from the left; &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; works from the right.</source>
          <target state="translated">Прискорбное сходство имени этой функции с именем оператора &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; в Perl является строго случайным. Эта функция работает слева; &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; работает справа.</target>
        </trans-unit>
        <trans-unit id="a30b1d50e05e4b08ed93704bd74f564e5fd07aba" translate="yes" xml:space="preserve">
          <source>The unfortunate similarity of this function's name to that of Perl's &lt;code&gt;chop&lt;/code&gt; operator is strictly coincidental. This function works from the left; &lt;code&gt;chop&lt;/code&gt; works from the right.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="188f61d7ec87851548e9f8daeb9600a5a694a2e6" translate="yes" xml:space="preserve">
          <source>The union of two array refs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3db9d0f0db6a082e0aea1f0a6be142ef87df51" translate="yes" xml:space="preserve">
          <source>The untie Gotcha</source>
          <target state="translated">Развязка Поймал</target>
        </trans-unit>
        <trans-unit id="12164923a1b041bdc762cdb62bbbc7fb759ea434" translate="yes" xml:space="preserve">
          <source>The untie() Gotcha</source>
          <target state="translated">Развязка()Попалась</target>
        </trans-unit>
        <trans-unit id="50d65961a427d2a64bc08d49e4d87b52f498e907" translate="yes" xml:space="preserve">
          <source>The uppercase variants (&lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\H&lt;/code&gt; , and &lt;code&gt;\V&lt;/code&gt; ) are character classes that match, respectively, any character that isn't a word character, digit, whitespace, horizontal whitespace, or vertical whitespace.</source>
          <target state="translated">Варианты верхнего регистра ( &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\H&lt;/code&gt; и &lt;code&gt;\V&lt;/code&gt; ) - это классы символов, которые соответствуют, соответственно, любому символу, который не является символом слова, цифрой, пробелом, горизонтальным пробелом или вертикальным пробелом.</target>
        </trans-unit>
        <trans-unit id="969149804a3c69f65ce9535464f4fe7c8cb52284" translate="yes" xml:space="preserve">
          <source>The uppercase variants (&lt;code&gt;\W&lt;/code&gt;, &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, &lt;code&gt;\H&lt;/code&gt;, and &lt;code&gt;\V&lt;/code&gt;) are character classes that match, respectively, any character that isn't a word character, digit, whitespace, horizontal whitespace, or vertical whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a360f037634db2d1e1b847c01d4ff39f2e82c73" translate="yes" xml:space="preserve">
          <source>The uri you passed to the constructor</source>
          <target state="translated">Ури,который ты передал строителю.</target>
        </trans-unit>
        <trans-unit id="7175c322baef80b04d65002673bad08dde1a5590" translate="yes" xml:space="preserve">
          <source>The urllist parameter has CD-ROM support</source>
          <target state="translated">Параметр urllist имеет поддержку CD-ROM</target>
        </trans-unit>
        <trans-unit id="0e71ac825c7f966ddb9142eb457a1ad27b050118" translate="yes" xml:space="preserve">
          <source>The usage is for a canned filter is:</source>
          <target state="translated">Используется для консервированного фильтра:</target>
        </trans-unit>
        <trans-unit id="28d3b03a1f670128ac1940bc311030e5942649cb" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;*glob{FILEHANDLE}&lt;/code&gt; was deprecated in Perl 5.8. The intention was to use &lt;code&gt;*glob{IO}&lt;/code&gt; instead, for which &lt;code&gt;*glob{FILEHANDLE}&lt;/code&gt; is an alias.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826c70de8255c56bc69c42539c313e47e2f05832" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;//g&lt;/code&gt; is shown in the following example. Suppose we have a string that consists of words separated by spaces. If we know how many words there are in advance, we could extract the words using groupings:</source>
          <target state="translated">Использование &lt;code&gt;//g&lt;/code&gt; показано в следующем примере. Предположим, у нас есть строка, состоящая из слов, разделенных пробелами. Если мы заранее знаем, сколько слов есть, мы могли бы выделить слова с помощью группировки:</target>
        </trans-unit>
        <trans-unit id="6a8f9ae899c24a9ba384007b7a56b302e1ecb384" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;/g&lt;/code&gt; is shown in the following example. Suppose we have a string that consists of words separated by spaces. If we know how many words there are in advance, we could extract the words using groupings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832a5d88d8f5443e11412058babdb54340f702ac" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; is discouraged, as it can result in exceptions not being thrown if you</source>
          <target state="translated">Использование &lt;code&gt;:void&lt;/code&gt; не рекомендуется, так как это может привести к тому, что исключения не будут выбраны, если вы</target>
        </trans-unit>
        <trans-unit id="0ce5a82961769245d2e039e505d826cd3e904ef4" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; with Fatal is discouraged.</source>
          <target state="translated">Использование &lt;code&gt;:void&lt;/code&gt; с Fatal не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="dac4651068bc57e4e25c4b9a7bdd7a073791862a" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;=&amp;gt;&lt;/code&gt; above provides necessary quoting of &lt;code&gt;MODULE&lt;/code&gt; . If you don't use the fat comma (eg you don't have any ARGUMENTS), then you'll need to quote the MODULE.</source>
          <target state="translated">Использование &lt;code&gt;=&amp;gt;&lt;/code&gt; выше обеспечивает необходимое цитирование &lt;code&gt;MODULE&lt;/code&gt; . Если вы не используете жирную запятую (например, у вас нет АРГУМЕНТОВ), вам нужно указать МОДУЛЬ.</target>
        </trans-unit>
        <trans-unit id="3987152a02b0e8946670fa1ed3d0263b2379f73d" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\K&lt;/code&gt; inside of another lookaround assertion is allowed, but the behaviour is currently not well defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b512e8508712c1167d958e6e4ad448ccc7e030f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\Q&lt;/code&gt; causes the &amp;lt;.&amp;gt; in the regex to be treated as a regular character, so that &lt;code&gt;P.&lt;/code&gt; matches a &lt;code&gt;P&lt;/code&gt; followed by a dot.</source>
          <target state="translated">Использование &lt;code&gt;\Q&lt;/code&gt; приводит к тому, что &amp;lt;.&amp;gt; В регулярном выражении обрабатывается как обычный символ, так что &lt;code&gt;P.&lt;/code&gt; соответствует &lt;code&gt;P&lt;/code&gt; , за которым следует точка.</target>
        </trans-unit>
        <trans-unit id="fc1eea836569752f037bcfe192ccf1fd3a1c9537" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\Q&lt;/code&gt; causes the &lt;code&gt;.&lt;/code&gt; in the regex to be treated as a regular character, so that &lt;code&gt;P.&lt;/code&gt; matches a &lt;code&gt;P&lt;/code&gt; followed by a dot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a848a8f72097323f82bf0128df3ae2506a4c5d0" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;my()&lt;/code&gt; in a false conditional has been deprecated in Perl 5.10, and became a fatal error in Perl 5.30.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="514e40665c7756f02fb508e8f86f86167ddf537d" translate="yes" xml:space="preserve">
          <source>The use of a camel with the topic of Perl is a trademark of O'Reilly and Associates, Inc. Used with permission.</source>
          <target state="translated">Использование верблюда с темой Perl является торговой маркой компании O'Reilly and Associates,Inc.Используется с разрешения.</target>
        </trans-unit>
        <trans-unit id="9cb45eca9a7939753b03a1360d763d098c0e7870" translate="yes" xml:space="preserve">
          <source>The use of all caps for constant names is merely a convention, although it is recommended in order to make constants stand out and to help avoid collisions with other barewords, keywords, and subroutine names. Constant names must begin with a letter or underscore. Names beginning with a double underscore are reserved. Some poor choices for names will generate warnings, if warnings are enabled at compile time.</source>
          <target state="translated">Использование всех прописных букв для имен констант-это всего лишь соглашение,хотя оно рекомендуется для того,чтобы выделить константы и помочь избежать столкновений с другими пустыми словами,ключевыми словами и именами подпрограмм.Имена констант должны начинаться с буквы или подчеркивания.Имена,начинающиеся с двойного знака подчеркивания,зарезервированы.Некоторые плохие имена будут выдавать предупреждения,если предупреждения включены во время компиляции.</target>
        </trans-unit>
        <trans-unit id="58b862df75de13b5dcf2d9b0b606b5454f4112c1" translate="yes" xml:space="preserve">
          <source>The use of hash keys starting with a hyphen (&lt;code&gt;-name&lt;/code&gt; ) or entirely in upper case (&lt;code&gt;NAME&lt;/code&gt; ) is a relic of older versions of Perl in which ordinary lower case strings were not handled correctly by the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator. While some modules retain uppercase or hyphenated argument keys for historical reasons or as a matter of personal style, most new modules should use simple lower case keys. Whatever you choose, be consistent!</source>
          <target state="translated">Использование хеш-ключей, начинающихся с дефиса ( &lt;code&gt;-name&lt;/code&gt; ) или полностью заглавных ( &lt;code&gt;NAME&lt;/code&gt; ), является пережитком старых версий Perl, в которых обычные строчные строки не обрабатывались правильно оператором &lt;code&gt;=&amp;gt;&lt;/code&gt; . В то время как некоторые модули сохраняют ключи аргументов в верхнем регистре или через дефис по историческим причинам или в соответствии с личным стилем, большинство новых модулей должны использовать простые ключи нижнего регистра. Что бы вы ни выбрали, будьте последовательны!</target>
        </trans-unit>
        <trans-unit id="42f05d562fbd6250c25a2395c7f661a4ca156a47" translate="yes" xml:space="preserve">
          <source>The use of hash keys starting with a hyphen (&lt;code&gt;-name&lt;/code&gt;) or entirely in upper case (&lt;code&gt;NAME&lt;/code&gt;) is a relic of older versions of Perl in which ordinary lower case strings were not handled correctly by the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator. While some modules retain uppercase or hyphenated argument keys for historical reasons or as a matter of personal style, most new modules should use simple lower case keys. Whatever you choose, be consistent!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0181fb947fb2e09fe7658e112ec2fe9418c5503f" translate="yes" xml:space="preserve">
          <source>The use of interpreter-based threads in perl is officially &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">Официально не &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;рекомендуется&lt;/a&gt; использовать потоки на основе интерпретатора в Perl .</target>
        </trans-unit>
        <trans-unit id="74fecb64d5ab9c5206223686d13a4c9238b9c4d9" translate="yes" xml:space="preserve">
          <source>The use of one-shot &lt;code&gt;gzip&lt;/code&gt; above just reads from &lt;code&gt;$r-&amp;gt;filename&lt;/code&gt; and writes the compressed data to standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4d1599ed2c314509e371c80e5511844a0d9d78" translate="yes" xml:space="preserve">
          <source>The use of out of range code points was deprecated in Perl 5.24, and became a fatal error in Perl 5.28.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9bd1a86a4853953267a9ded9b1645e890ed750a" translate="yes" xml:space="preserve">
          <source>The use of out of range code points was deprecated in Perl 5.24; as of Perl 5.28 using a code point exceeding &lt;code&gt;IV_MAX&lt;/code&gt; throws a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af3aa24ab804ebe0a65aee4289caba48448e851d" translate="yes" xml:space="preserve">
          <source>The use of parentheses around a &lt;b&gt;subpattern&lt;/b&gt; in a &lt;b&gt;regular expression&lt;/b&gt; to store the matched &lt;b&gt;substring&lt;/b&gt; as a &lt;b&gt;backreference&lt;/b&gt;. (Captured strings are also returned as a list in &lt;b&gt;list context&lt;/b&gt;.) See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">Использование круглых скобок вокруг &lt;b&gt;подшаблона&lt;/b&gt; в &lt;b&gt;регулярном выражении&lt;/b&gt; для сохранения совпадающей &lt;b&gt;подстроки&lt;/b&gt; в качестве &lt;b&gt;обратной ссылки&lt;/b&gt; . (Захваченные строки также возвращаются в виде списка в &lt;b&gt;контексте списка&lt;/b&gt; .) См. Главу 5 Camel &amp;laquo;Сопоставление с образцом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ceb3a7a104da1d4a198b733387677a08ee3ca395" translate="yes" xml:space="preserve">
          <source>The use of parenthesis can be used to capture parts of the input filename.</source>
          <target state="translated">Использование скобок может быть использовано для захвата частей имени входного файла.</target>
        </trans-unit>
        <trans-unit id="379fb1c054bbd3152f276aaca35f049867852f33" translate="yes" xml:space="preserve">
          <source>The use of the following functions is discouraged as they are not actually testing functions and produce no diagnostics to help figure out what went wrong. They were written before &lt;code&gt;is_deeply()&lt;/code&gt; existed because I couldn't figure out how to display a useful diff of two arbitrary data structures.</source>
          <target state="translated">Использование следующих функций не рекомендуется, поскольку они на самом деле не являются функциями тестирования и не производят диагностику, помогающую выяснить, что пошло не так. Они были написаны до того, как &lt;code&gt;is_deeply()&lt;/code&gt; потому что я не мог понять, как отобразить полезную разницу двух произвольных структур данных.</target>
        </trans-unit>
        <trans-unit id="5b392cf4598b7c92d87fc443e5bf63773c90811b" translate="yes" xml:space="preserve">
          <source>The usenm option</source>
          <target state="translated">Возможность использования</target>
        </trans-unit>
        <trans-unit id="977cdd9dc7908139553c49b2609de1c2c08baff9" translate="yes" xml:space="preserve">
          <source>The user id owning the file</source>
          <target state="translated">Идентификатор пользователя,владеющего файлом</target>
        </trans-unit>
        <trans-unit id="5d40086458e1b194df3ff27c332046fe8de9903b" translate="yes" xml:space="preserve">
          <source>The user name that owns the file</source>
          <target state="translated">Имя пользователя,которому принадлежит файл</target>
        </trans-unit>
        <trans-unit id="9ab82377d9d8e711c9e229f8137ce74619a6f296" translate="yes" xml:space="preserve">
          <source>The user time is the amount of time the entire process spent on behalf of the user on this system executing this program.</source>
          <target state="translated">Время пользователя-это количество времени,потраченное от имени пользователя на эту систему,выполняющую данную программу.</target>
        </trans-unit>
        <trans-unit id="244da933c00a6b886bfc62a46ed8d2ddfb906e87" translate="yes" xml:space="preserve">
          <source>The user who wants the memoization cache to be expired according to your policy will say so by writing</source>
          <target state="translated">Пользователь,который хочет,чтобы срок действия memoization кэша истек в соответствии с вашей политикой,скажет об этом,написав</target>
        </trans-unit>
        <trans-unit id="bb2fd16359343bc75d33118c9751a1ecbc3d3037" translate="yes" xml:space="preserve">
          <source>The usual arithmetic (+,-,+=,-=) is also available on the objects.</source>
          <target state="translated">Обычная арифметика (+,-,+=,-=)также доступна на объектах.</target>
        </trans-unit>
        <trans-unit id="c7334043434491bfd6d25a23b05fb6d156604749" translate="yes" xml:space="preserve">
          <source>The usual calling signature is</source>
          <target state="translated">Обычная позывная подпись</target>
        </trans-unit>
        <trans-unit id="72046882a8fdaf30c0521d766b5cf67d3d264433" translate="yes" xml:space="preserve">
          <source>The usual idiom is:</source>
          <target state="translated">Обычная идиома:</target>
        </trans-unit>
        <trans-unit id="7ac11eaf69a957a9aa5638ad8debab406436e005" translate="yes" xml:space="preserve">
          <source>The usual method for terminating a thread is to &lt;a href=&quot;functions/return&quot;&gt;return EXPR&lt;/a&gt; from the entry point function with the appropriate return value(s).</source>
          <target state="translated">Обычный метод завершения потока - &lt;a href=&quot;functions/return&quot;&gt;вернуть EXPR&lt;/a&gt; из функции точки входа с соответствующим возвращаемым значением (ями).</target>
        </trans-unit>
        <trans-unit id="9019b0c3813c3cf91527f6ac86d5eb12ae5c43b5" translate="yes" xml:space="preserve">
          <source>The usual method for terminating a thread is to &lt;a href=&quot;perlfunc#return-EXPR&quot;&gt;return()&lt;/a&gt; from the entry point function with the appropriate return value(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="189fd1d4b573f9b0c1b1794439c343e0650165ef" translate="yes" xml:space="preserve">
          <source>The usual shell redirection symbols &lt;code&gt; | &lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; are recognized by the cpan shell &lt;b&gt;only when surrounded by whitespace&lt;/b&gt;. So piping to pager or redirecting output into a file works somewhat as in a normal shell, with the stipulation that you must type extra spaces.</source>
          <target state="translated">Обычные символы перенаправления оболочки &lt;code&gt; | &lt;/code&gt; и &lt;code&gt;&amp;gt;&lt;/code&gt; распознаются оболочкой cpan, &lt;b&gt;только если они окружены&lt;/b&gt; пробелами . Таким образом, конвейерная передача на пейджер или перенаправление вывода в файл работает как в обычной оболочке с условием, что вы должны вводить дополнительные пробелы.</target>
        </trans-unit>
        <trans-unit id="f5284fa656dfbed57ca832128b9046307b6a8989" translate="yes" xml:space="preserve">
          <source>The usual warnings if it can't read or write the files involved.</source>
          <target state="translated">Обычные предупреждения,если он не может прочитать или записать соответствующие файлы.</target>
        </trans-unit>
        <trans-unit id="9c1efd4c7ee39f810e92b8d45a9ddf28889531e0" translate="yes" xml:space="preserve">
          <source>The usual warnings if it cannot read or write the files involved.</source>
          <target state="translated">Обычные предупреждения,если он не может прочитать или записать соответствующие файлы.</target>
        </trans-unit>
        <trans-unit id="22c79ee036d08be39b9326c3b9dab69e6aa2a162" translate="yes" xml:space="preserve">
          <source>The usually available constants are</source>
          <target state="translated">Обычно доступными константами являются</target>
        </trans-unit>
        <trans-unit id="59963cc04cd3e99323ab911f21a23f907334eab6" translate="yes" xml:space="preserve">
          <source>The usually available constants are as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2efc4102646dfcf9e84b807940c146f94356608b" translate="yes" xml:space="preserve">
          <source>The util.c:1716 is the source code file and line number.</source>
          <target state="translated">Файл use.c:1716-это файл с исходным кодом и номером строки.</target>
        </trans-unit>
        <trans-unit id="822e481a167310eec4961d968bbe1f00f0652d77" translate="yes" xml:space="preserve">
          <source>The utilities &lt;code&gt;c2ph&lt;/code&gt; and &lt;code&gt;pstruct&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f118979bfd7ebb716612c147525a5086ff812a" translate="yes" xml:space="preserve">
          <source>The utilities c2ph and pstruct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d163a1d052b62f7d060607d4bf6b7f91f9aa60" translate="yes" xml:space="preserve">
          <source>The v-strings are portable only up to v2147483647 (0x7FFF_FFFF), that's how far EBCDIC, or more precisely UTF-EBCDIC will go.</source>
          <target state="translated">v-строки переносятся только до v2147483647 (0x7FFF_FFFF),вот как далеко зайдет EBCDIC,а точнее UTF-EBCDIC.</target>
        </trans-unit>
        <trans-unit id="84e2770182dc038d9b47afe7e9b08eec9556b081" translate="yes" xml:space="preserve">
          <source>The v5.16 release also supports a &lt;code&gt;:loose&lt;/code&gt; import for loose matching of character names, which works just like loose matching of property names: that is, it disregards case, whitespace, and underscores:</source>
          <target state="translated">Выпуск v5.16 также поддерживает импорт &lt;code&gt;:loose&lt;/code&gt; для свободного сопоставления имен символов, который работает так же, как свободное сопоставление имен свойств: то есть игнорирует регистр, пробелы и подчеркивания:</target>
        </trans-unit>
        <trans-unit id="b193f0ebc1769a16dcfcc639a8401c8c00cf9c0e" translate="yes" xml:space="preserve">
          <source>The valgrind tool can be used to find out both memory leaks and illegal heap memory accesses. As of version 3.3.0, Valgrind only supports Linux on x86, x86-64 and PowerPC and Darwin (OS X) on x86 and x86-64). The special &quot;test.valgrind&quot; target can be used to run the tests under valgrind. Found errors and memory leaks are logged in files named</source>
          <target state="translated">Инструмент valgrind может быть использован для обнаружения как утечек памяти,так и несанкционированного доступа к кучевой памяти.Начиная с версии 3.3.0,Valgrind поддерживает Linux только на x86,x86-64 и PowerPC и Darwin (OS X)на x86 и x86-64).Специальная мишень &quot;test.valgrind&quot; может быть использована для запуска тестов под Valgrind.Найденные ошибки и утечки памяти записываются в файлы с именами</target>
        </trans-unit>
        <trans-unit id="d0c464474306348983509bffccc9878d55f4fc97" translate="yes" xml:space="preserve">
          <source>The valgrind tool can be used to find out both memory leaks and illegal heap memory accesses. As of version 3.3.0, Valgrind only supports Linux on x86, x86-64 and PowerPC and Darwin (OS X) on x86 and x86-64. The special &quot;test.valgrind&quot; target can be used to run the tests under valgrind. Found errors and memory leaks are logged in files named</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa3e07c88c6113557baab8df17b4983a954a8994" translate="yes" xml:space="preserve">
          <source>The value assigned to the key &lt;code&gt;'fallback'&lt;/code&gt; tells Perl how hard it should try to find an alternative way to implement a missing operator.</source>
          <target state="translated">Значение, присвоенное ключу &lt;code&gt;'fallback'&lt;/code&gt; сообщает Perl, насколько усердно ему следует искать альтернативный способ реализации отсутствующего оператора.</target>
        </trans-unit>
        <trans-unit id="6f766eba2f1a65e15d6582321bc30fe9d0e0e26a" translate="yes" xml:space="preserve">
          <source>The value associated with &lt;code&gt;env&lt;/code&gt; is itself a hashref that is matched against corresponding values in the &lt;code&gt;%ENV&lt;/code&gt; hash. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">Значение, связанное с &lt;code&gt;env&lt;/code&gt; , само по себе является хэш-ссылкой, которая сопоставляется с соответствующими значениями в хэше &lt;code&gt;%ENV&lt;/code&gt; . Ключи с префиксом &lt;code&gt;not_&lt;/code&gt; отменяют соответствующее совпадение.</target>
        </trans-unit>
        <trans-unit id="aa731dffe1d7c5a02c15e427c4d55ad58928d794" translate="yes" xml:space="preserve">
          <source>The value associated with &lt;code&gt;perlconfig&lt;/code&gt; is itself a hashref that is matched against corresponding values in the &lt;code&gt;%Config::Config&lt;/code&gt; hash living in the &lt;code&gt;Config.pm&lt;/code&gt; module. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">Значение, связанное с &lt;code&gt;perlconfig&lt;/code&gt; , само по себе является хэш-ссылкой, которая сопоставляется с соответствующими значениями в хэше &lt;code&gt;%Config::Config&lt;/code&gt; &lt;code&gt;Config.pm&lt;/code&gt; модуле Config.pm . Ключи с префиксом &lt;code&gt;not_&lt;/code&gt; отменяют соответствующее совпадение.</target>
        </trans-unit>
        <trans-unit id="86d758b44cf7d343d2636c283000a90f2b95ec68" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;$offset&lt;/code&gt; in Unix will be &lt;code&gt;0&lt;/code&gt; , but in Mac OS Classic will be some large number. &lt;code&gt;$offset&lt;/code&gt; can then be added to a Unix time value to get what should be the proper value on any system.</source>
          <target state="translated">Значение &lt;code&gt;$offset&lt;/code&gt; в Unix будет равно &lt;code&gt;0&lt;/code&gt; , но в Mac OS Classic будет какое-то большое число. Затем &lt;code&gt;$offset&lt;/code&gt; может быть добавлен к значению времени Unix, чтобы получить то, что должно быть правильным значением в любой системе.</target>
        </trans-unit>
        <trans-unit id="9f9c34760dc2837fd17b567df1f5e5a179a637d8" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;$offset&lt;/code&gt; in Unix will be &lt;code&gt;0&lt;/code&gt;, but in Mac OS Classic will be some large number. &lt;code&gt;$offset&lt;/code&gt; can then be added to a Unix time value to get what should be the proper value on any system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a050ff582b3cdf570af43e605e700a8d71acf02" translate="yes" xml:space="preserve">
          <source>The value in each entry of the hash is what you are referring to when you use the &lt;code&gt;*name&lt;/code&gt; typeglob notation.</source>
          <target state="translated">Значение в каждой записи хэша - это то, что вы имеете в виду, когда используете нотацию &lt;code&gt;*name&lt;/code&gt; typeglob.</target>
        </trans-unit>
        <trans-unit id="0f707479820ff9d25dbdd6e993639c9a31b93e20" translate="yes" xml:space="preserve">
          <source>The value is identical to &lt;code&gt;$Config{'osname'}&lt;/code&gt; . See also &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; and the &lt;b&gt;-V&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">Значение идентично &lt;code&gt;$Config{'osname'}&lt;/code&gt; . См. Также &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; и ключ командной строки &lt;b&gt;-V,&lt;/b&gt; задокументированный в &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78983deb0ac0844027ede959bcbb4cd4a4216250" translate="yes" xml:space="preserve">
          <source>The value is identical to &lt;code&gt;$Config{'osname'}&lt;/code&gt;. See also &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; and the &lt;b&gt;-V&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun#-V&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b8122c0413fdd3eed692b348862e9493d569f3" translate="yes" xml:space="preserve">
          <source>The value of $side is</source>
          <target state="translated">Стоимость стороны $</target>
        </trans-unit>
        <trans-unit id="31a20ded01fa49bc667d71f5d635d0f8fadc7fc6" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; on OpenVMS is &quot;VMS&quot;. To determine the architecture that you are running on refer to &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773190d7908d36ab9698d1cdc21dc993faf50e45" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; on VOS is &quot;vos&quot;. To determine the architecture that you are running on refer to &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed978648f213fc988aacb1860e0d05dc9fcc12a7" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$!&lt;/code&gt; at the time when the exception occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495d3ee61dabdfbea0b627a5268ea9c708b5aa50" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$?&lt;/code&gt; when the context was created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ad0b97e1d614d4823576a0d2d5c3aedd5bf44c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$@&lt;/code&gt; when the context was created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3e350bc3160e2ef2f10c200798865cfdef3abe" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$Config{sitelib}&lt;/code&gt; is also determined in C code and not read from &lt;code&gt;Config.pm&lt;/code&gt; , which is not loaded.</source>
          <target state="translated">Значение &lt;code&gt;$Config{sitelib}&lt;/code&gt; также определяется в коде C, а не читается из &lt;code&gt;Config.pm&lt;/code&gt; , который не загружен.</target>
        </trans-unit>
        <trans-unit id="e9e93b8ce5897e26af26e26d476dcd12a339350a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$Config{sitelib}&lt;/code&gt; is also determined in C code and not read from &lt;code&gt;Config.pm&lt;/code&gt;, which is not loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec5b14ed87db6c409cf2d38c4b2eab23f206eae" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$^O&lt;/code&gt; on OpenVMS is &quot;VMS&quot;. To determine the architecture that you are running on refer to &lt;code&gt;$Config{'archname'}&lt;/code&gt; .</source>
          <target state="translated">Значение &lt;code&gt;$^O&lt;/code&gt; в OpenVMS - &amp;laquo;VMS&amp;raquo;. Чтобы определить архитектуру, на которой вы работаете, обратитесь к &lt;code&gt;$Config{'archname'}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a38163b3b1097c345c4ed53de76d7f29841da7e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$^O&lt;/code&gt; on VOS is &quot;vos&quot;. To determine the architecture that you are running on without resorting to loading all of &lt;code&gt;%Config&lt;/code&gt; you can examine the content of the &lt;code&gt;@INC&lt;/code&gt; array like so:</source>
          <target state="translated">Значение &lt;code&gt;$^O&lt;/code&gt; в VOS равно &quot;vos&quot;. Чтобы определить архитектуру, на которой вы работаете, не прибегая к загрузке всего &lt;code&gt;%Config&lt;/code&gt; вы можете проверить содержимое массива &lt;code&gt;@INC&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="0b11ba94deca518a1e2cfb4f0d2fd72a2e75493b" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$_&lt;/code&gt; when the sub returns will be stored in the filename header field.</source>
          <target state="translated">Значение &lt;code&gt;$_&lt;/code&gt; при возврате подпрограммы будет сохранено в поле заголовка имени файла.</target>
        </trans-unit>
        <trans-unit id="623588465c88b3488f6369fa12fbc193d14ce397" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$_&lt;/code&gt; when the sub returns will be used as the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e887b08023c56383b67ea2dd8816e1569e2d83d2" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;flags&lt;/code&gt; determines the behavior when &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character. If &lt;code&gt;flags&lt;/code&gt; is 0, when a malformation is found, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. Also, if UTF-8 warnings haven't been lexically disabled, a warning is raised.</source>
          <target state="translated">Значение &lt;code&gt;flags&lt;/code&gt; определяет поведение, когда &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; не указывает на правильно сформированный символ UTF-8. Если &lt;code&gt;flags&lt;/code&gt; равен 0, при обнаружении уродства возвращается ноль и &lt;code&gt;*retlen&lt;/code&gt; так что ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) является следующей возможной позицией в &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , с которой может начинаться неизменный символ. Кроме того, если предупреждения UTF-8 не были лексически отключены, возникает предупреждение.</target>
        </trans-unit>
        <trans-unit id="2605ec2ff838d0693c21dd89f119bc12d32e8a67" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;flags&lt;/code&gt; determines the behavior when &lt;code&gt;s&lt;/code&gt; does not point to a well-formed UTF-8 character. If &lt;code&gt;flags&lt;/code&gt; is 0, encountering a malformation causes zero to be returned and &lt;code&gt;*retlen&lt;/code&gt; is set so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. Also, if UTF-8 warnings haven't been lexically disabled, a warning is raised. Some UTF-8 input sequences may contain multiple malformations. This function tries to find every possible one in each call, so multiple warnings can be raised for the same sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4b4f2983d220858913f6137ac2e8d4d0fdf8f5" translate="yes" xml:space="preserve">
          <source>The value of a character (&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;) is the corresponding Unicode code point.</source>
          <target state="translated">Значение символа ( &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ) - это соответствующая кодовая точка Unicode.</target>
        </trans-unit>
        <trans-unit id="77376c07ae757b89b1359df5120af7875474ea9a" translate="yes" xml:space="preserve">
          <source>The value of a character (&lt;code&gt;ord&lt;/code&gt;, &lt;code&gt;chr&lt;/code&gt;) is the corresponding Unicode code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="920c1e9d793047c1281d1ee5cb5fb337f4ae7f17" translate="yes" xml:space="preserve">
          <source>The value of an attribute may itself be another object. For example, instead of returning its last mod time as a number, the &lt;code&gt;File&lt;/code&gt; class could return a &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; object representing that value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e567ba2156b576b88f1e773ff7f64942df23743" translate="yes" xml:space="preserve">
          <source>The value of an attribute may itself be another object. For example, instead of returning its last mod time as a number, the &lt;code&gt;File&lt;/code&gt; class could return a &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; object representing that value.</source>
          <target state="translated">Само значение атрибута может быть другим объектом. Например, вместо того, чтобы возвращать время последнего изменения в виде числа, класс &lt;code&gt;File&lt;/code&gt; может вернуть объект &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime,&lt;/a&gt; представляющий это значение.</target>
        </trans-unit>
        <trans-unit id="b0e6c192bc663d6d0a358f12fd16e1e3c9bf344d" translate="yes" xml:space="preserve">
          <source>The value of any Unicode (not including Perl extensions) character property mentioned above for any single code point is available through &lt;a href=&quot;Unicode::UCD#charprop%28%29&quot;&gt;&quot;charprop()&quot; in Unicode::UCD&lt;/a&gt;. &lt;a href=&quot;Unicode::UCD#charprops_all%28%29&quot;&gt;&quot;charprops_all()&quot; in Unicode::UCD&lt;/a&gt; returns the values of all the Unicode properties for a given code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be98eb05f5630113ca4199a823f81cc002596a7" translate="yes" xml:space="preserve">
          <source>The value of any Unicode (not including Perl extensions) character property mentioned above for any single code point is available through &lt;a href=&quot;unicode/ucd#charprop()&quot;&gt;charprop() in Unicode::UCD&lt;/a&gt;. &lt;a href=&quot;unicode/ucd#charprops_all()&quot;&gt;charprops_all() in Unicode::UCD&lt;/a&gt; returns the values of all the Unicode properties for a given code point.</source>
          <target state="translated">Значение любого свойства символа Unicode (не включая расширения Perl), упомянутого выше для любой отдельной кодовой точки, доступно через &lt;a href=&quot;unicode/ucd#charprop()&quot;&gt;charprop () в Unicode :: UCD&lt;/a&gt; . &lt;a href=&quot;unicode/ucd#charprops_all()&quot;&gt;charprops_all () в Unicode :: UCD&lt;/a&gt; возвращает значения всех свойств Unicode для данной кодовой точки.</target>
        </trans-unit>
        <trans-unit id="81fc623a108af3428235cbe74b6771e41c797430" translate="yes" xml:space="preserve">
          <source>The value of revision comes from the</source>
          <target state="translated">Значение ревизии исходит из</target>
        </trans-unit>
        <trans-unit id="c5c1cdba3a8acef681606512f4cdff2bb03f5d89" translate="yes" xml:space="preserve">
          <source>The value of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7754c871491afddea48233869a135f618ec6e6a4" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;...Host&lt;/code&gt; argument will be split to give both the hostname and port (or service name):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96cb89717e8339762098eca6a52dfe1d75c52296" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;flags&lt;/code&gt; hint to getaddrinfo(), or the $flags parameter to getnameinfo() contains unrecognised flags.</source>
          <target state="translated">Значение &lt;code&gt;flags&lt;/code&gt; указывает на getaddrinfo () или параметр $ flags для getnameinfo () содержит нераспознанные флаги.</target>
        </trans-unit>
        <trans-unit id="de2c00bdfe45ec53f217b88f118a8da5474d909d" translate="yes" xml:space="preserve">
          <source>The value of the ADLER32 field read must match the adler32 value of the uncompressed data actually contained in the file.</source>
          <target state="translated">Значение считанного поля ADLER32 должно совпадать со значением adler32 несжатых данных,фактически содержащихся в файле.</target>
        </trans-unit>
        <trans-unit id="932cb4d9b33ea8ac456d8558a4c42d4644723cbc" translate="yes" xml:space="preserve">
          <source>The value of the CRC32 field read must match the crc32 value of the uncompressed data actually contained in the gzip file.</source>
          <target state="translated">Значение прочитанного поля CRC32 должно совпадать со значением crc32 несжатых данных,фактически содержащихся в gzip-файле.</target>
        </trans-unit>
        <trans-unit id="7e9f5de9a38d28729524674757f04e1cb2068248" translate="yes" xml:space="preserve">
          <source>The value of the ISIZE fields read must match the length of the uncompressed data actually read from the file.</source>
          <target state="translated">Значение прочитанных полей ISIZE должно соответствовать длине фактически прочитанных из файла несжатых данных.</target>
        </trans-unit>
        <trans-unit id="6975eb5b4fde16e6c94a6652320983d4f157fb4c" translate="yes" xml:space="preserve">
          <source>The value of the OP's SV, if it has one, in a short human-readable format.</source>
          <target state="translated">Значение SV ОП,если оно есть,в коротком читаемом человеком формате.</target>
        </trans-unit>
        <trans-unit id="335bddece83d92e99066c5c702486489e5db8aca" translate="yes" xml:space="preserve">
          <source>The value of the function is not being passed back as the function's return value, but by changing the value of the variable that was passed into the function. You might have guessed that when you saw that the return value of round is of type &quot;void&quot;.</source>
          <target state="translated">Значение функции передается не как возвращаемое значение функции,а путем изменения значения переменной,которая была передана в функцию.Вы могли догадаться,когда увидели,что возвращаемое значение округления имеет тип &quot;void&quot;.</target>
        </trans-unit>
        <trans-unit id="332bfecdbc3324ed6709a244ef3af16edb8104ba" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the &lt;code&gt;given&lt;/code&gt; block if no condition is true.</source>
          <target state="translated">Значение последнего оцененного выражения &lt;code&gt;given&lt;/code&gt; блока, если ни одно условие не выполняется.</target>
        </trans-unit>
        <trans-unit id="77cf8495b50e92c33dbdf25b33ef15173c2d3541" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the successful &lt;code&gt;when&lt;/code&gt; /&lt;code&gt;default&lt;/code&gt; clause, if there happens to be one.</source>
          <target state="translated">Значение последнего оцененного выражения успешного предложения &lt;code&gt;when&lt;/code&gt; / &lt;code&gt;default&lt;/code&gt; , если оно есть.</target>
        </trans-unit>
        <trans-unit id="658f9d607f7e2f28f592626f4c387f2ebc102faa" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the successful &lt;code&gt;when&lt;/code&gt;/&lt;code&gt;default&lt;/code&gt; clause, if there happens to be one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55ec6306f776bf3aa6ec09d7496286d68bd8fba" translate="yes" xml:space="preserve">
          <source>The value of this expression will be TRUE if &lt;code&gt;$var&lt;/code&gt; contains that sequence of characters, and FALSE otherwise. The portion enclosed in &lt;code&gt;'/'&lt;/code&gt; characters denotes the characteristic we are looking for. We use the term</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9dbf107286e577746464279a9f4d776045ba7e1" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; may be compared against the encrypted password from the UAF returned by the &lt;code&gt;getpw*&lt;/code&gt; functions, in order to authenticate users. If you're going to do this, remember that the encrypted password in the UAF was generated using uppercase username and password strings; you'll have to upcase the arguments to &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; to insure that you'll get the proper value:</source>
          <target state="translated">Значение, возвращаемое функцией &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; , может сравниваться с зашифрованным паролем от &lt;code&gt;getpw*&lt;/code&gt; функциями getpw * , для аутентификации пользователей. Если вы собираетесь это сделать, помните, что зашифрованный пароль в UAF был сгенерирован с использованием строк имени пользователя и пароля в верхнем регистре; вам придется упростить аргументы для &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; чтобы убедиться, что вы получите правильное значение:</target>
        </trans-unit>
        <trans-unit id="750d57c2b28689ee366bb45cb08dd596ede16734" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; may be affected after the call, and the filehandle may be flushed. (Win32)</source>
          <target state="translated">Значение, возвращаемое &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; , может измениться после вызова, и дескриптор файла может быть сброшен. (Win32)</target>
        </trans-unit>
        <trans-unit id="b9eb02fecf7e78b1a88f2675d747749b95555376" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; is the offset in seconds from 01-JAN-1970 00:00:00 (just like the CRTL's times() routine), in order to make life easier for code coming in from the POSIX/Unix world.</source>
          <target state="translated">Значение, возвращаемое &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , представляет собой смещение в секундах от 01-JAN-1970 00:00:00 (точно так же, как подпрограмма times () CRTL), чтобы упростить жизнь для кода, поступающего из мира POSIX / Unix.</target>
        </trans-unit>
        <trans-unit id="d9cf508ed581e40b436f75a599821b5c9826f4e6" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;crypt&lt;/code&gt; may be compared against the encrypted password from the UAF returned by the &lt;code&gt;getpw*&lt;/code&gt; functions, in order to authenticate users. If you're going to do this, remember that the encrypted password in the UAF was generated using uppercase username and password strings; you'll have to upcase the arguments to &lt;code&gt;crypt&lt;/code&gt; to insure that you'll get the proper value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50fe607f9117d605b4d45bd6d7204d58d2fef28d" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;time&lt;/code&gt; is the offset in seconds from 01-JAN-1970 00:00:00 (just like the CRTL's times() routine), in order to make life easier for code coming in from the POSIX/Unix world.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce33a69a270de7fcb08010c8a7a1e528d7b525f" translate="yes" xml:space="preserve">
          <source>The value returned by DELETE becomes the return value of the call to delete(). If you want to emulate the normal behavior of delete(), you should return whatever FETCH would have returned for this key. In this example, we have chosen instead to return a value which tells the caller whether the file was successfully deleted.</source>
          <target state="translated">Возвращаемое DELETE значение становится возвращаемым значением вызова delete().Если вы хотите эмулировать нормальное поведение delete(),вы должны вернуть то,что FETCH вернул бы для этого ключа.В данном примере мы выбрали вместо этого возвращаемое значение,которое сообщает вызывающему абоненту,был ли файл успешно удален.</target>
        </trans-unit>
        <trans-unit id="6bc17f7cca700d462e95542bbd03b318a3e0be44" translate="yes" xml:space="preserve">
          <source>The value returned by the</source>
          <target state="translated">Значение,возвращаемое</target>
        </trans-unit>
        <trans-unit id="b1bca5853c9e5fa5adb4f19b1edc9ad3fc182540" translate="yes" xml:space="preserve">
          <source>The value returned from the</source>
          <target state="translated">Значение,возвращаемое из</target>
        </trans-unit>
        <trans-unit id="d7686ece8175813a2cb013172fefbbbe14b8eb04" translate="yes" xml:space="preserve">
          <source>The value returned is the new-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;Old-style versus new-style block names&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d9e575a1b77ab1385aca4b943feac671ed7f01" translate="yes" xml:space="preserve">
          <source>The value returned is the new-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">Возвращаемое значение - это новый стиль (см. &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Сравнение имен блоков в старом и новом стиле&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c04520f682b85fb43c817253d00adbc0066c3e0a" translate="yes" xml:space="preserve">
          <source>The value returned is the scalar itself, if the argument is a scalar, or a reference, if the argument is a hash, array or subroutine.</source>
          <target state="translated">Возвращаемое значение является самим скаляром,если аргумент является скаляром,или ссылкой,если аргумент является хэшем,массивом или подпрограммным.</target>
        </trans-unit>
        <trans-unit id="942e5b04dedd3b9d9ca5012565213fea51195584" translate="yes" xml:space="preserve">
          <source>The value returned should correspond to the new text to use in its place If the empty string is returned or an undefined value is returned, then the given &lt;code&gt;$text&lt;/code&gt; is ignored (not processed).</source>
          <target state="translated">Возвращаемое значение должно соответствовать новому тексту, который будет использоваться вместо него. Если возвращается пустая строка или возвращается неопределенное значение, то данный &lt;code&gt;$text&lt;/code&gt; игнорируется (не обрабатывается).</target>
        </trans-unit>
        <trans-unit id="8dccf8bfa93428dffce75a953ae318dc76ebcb1f" translate="yes" xml:space="preserve">
          <source>The value returned should correspond to the new text to use in its place. If the empty string or an undefined value is returned then no further processing will be performed for this line.</source>
          <target state="translated">Возвращаемое значение должно соответствовать новому тексту,который будет использоваться вместо него.Если возвращается пустая строка или неопределенное значение,то дальнейшая обработка этой строки выполняться не будет.</target>
        </trans-unit>
        <trans-unit id="55279d7373f25daebc72a715903f6a4795228bf8" translate="yes" xml:space="preserve">
          <source>The value returned will be true if the &lt;code&gt;$paragraph&lt;/code&gt; and the rest of the text in the same section as &lt;code&gt;$paragraph&lt;/code&gt; should be selected (included) for processing; otherwise a false value is returned.</source>
          <target state="translated">Возвращаемое значение будет истинным, если &lt;code&gt;$paragraph&lt;/code&gt; и остальной текст в том же разделе, что и &lt;code&gt;$paragraph&lt;/code&gt; должны быть выбраны (включены) для обработки; в противном случае возвращается ложное значение.</target>
        </trans-unit>
        <trans-unit id="10aaf64078984131d35f43803e32214eb7af6f36" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. It is invoked just before leaving the currently processed directory. It is called in void context with no arguments. The name of the current directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt; . This hook is handy for summarizing a directory, such as calculating its disk usage. When</source>
          <target state="translated">Значение должно быть ссылкой на код. Он вызывается непосредственно перед выходом из текущего обрабатываемого каталога. Он вызывается в пустом контексте без аргументов. Имя текущего каталога находится в &lt;code&gt;$File::Find::dir&lt;/code&gt; . Эта ловушка удобна для суммирования каталога, например для расчета использования его диска. когда</target>
        </trans-unit>
        <trans-unit id="704f4eb234b60fc2ba78db6c9fbae91192095f92" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. It is invoked just before leaving the currently processed directory. It is called in void context with no arguments. The name of the current directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt;. This hook is handy for summarizing a directory, such as calculating its disk usage. When</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ae9d02429326a11943298c08065d301c422900" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;&quot;The wanted function&quot;&lt;/a&gt; below. The &lt;code&gt;&amp;amp;wanted&lt;/code&gt; subroutine is mandatory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddbdffc9717f2bba2ebf5303cd71401d0bf2a249" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;The wanted function&lt;/a&gt; below. The &lt;code&gt;&amp;amp;wanted&lt;/code&gt; subroutine is mandatory.</source>
          <target state="translated">Значение должно быть ссылкой на код. Эта ссылка на код описана ниже в &lt;a href=&quot;#The-wanted-function&quot;&gt;разделе &quot;Требуемая функция&quot;&lt;/a&gt; . &lt;code&gt;&amp;amp;wanted&lt;/code&gt; подпрограмма является обязательной.</target>
        </trans-unit>
        <trans-unit id="444cd91bd48610204aa4348a8cd314eec59c4347" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is used to preprocess the current directory. The name of the currently processed directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt; . Your preprocessing function is called after &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, but before the loop that calls the &lt;code&gt;wanted()&lt;/code&gt; function. It is called with a list of strings (actually file/directory names) and is expected to return a list of strings. The code can be used to sort the file/directory names alphabetically, numerically, or to filter out directory entries based on their name alone. When</source>
          <target state="translated">Значение должно быть ссылкой на код. Эта ссылка на код используется для предварительной обработки текущего каталога. Имя обрабатываемого в данный момент каталога находится в &lt;code&gt;$File::Find::dir&lt;/code&gt; . Ваша функция предварительной обработки вызывается после &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; , но до цикла, вызывающего функцию &lt;code&gt;wanted()&lt;/code&gt; . Он вызывается со списком строк (фактически с именами файлов / каталогов) и должен возвращать список строк. Код может использоваться для сортировки имен файлов / каталогов по алфавиту, числам или для фильтрации записей каталогов только по их имени. когда</target>
        </trans-unit>
        <trans-unit id="f55a9d5538f4afdc7e60c610536ec48e43299b30" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is used to preprocess the current directory. The name of the currently processed directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt;. Your preprocessing function is called after &lt;code&gt;readdir()&lt;/code&gt;, but before the loop that calls the &lt;code&gt;wanted()&lt;/code&gt; function. It is called with a list of strings (actually file/directory names) and is expected to return a list of strings. The code can be used to sort the file/directory names alphabetically, numerically, or to filter out directory entries based on their name alone. When</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8d0d31a50d605febd9456f0c05a144d0e549cc" translate="yes" xml:space="preserve">
          <source>The value should be the complete TAP output.</source>
          <target state="translated">Значение должно быть полным TAP-выходом.</target>
        </trans-unit>
        <trans-unit id="1236d86898ff88a6ba5efcf381d222ec31979c55" translate="yes" xml:space="preserve">
          <source>The value stack stores individual perl scalar values as temporaries between expressions. Some perl expressions operate on entire lists; for that purpose we need to know where on the stack each list begins. This is the purpose of the mark stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977d1c1fec14dab01803e1202ad5b70915c99932" translate="yes" xml:space="preserve">
          <source>The value supplied with &lt;code&gt;-Comment&lt;/code&gt; option can contain any character except NULL.</source>
          <target state="translated">Значение, &lt;code&gt;-Comment&lt;/code&gt; параметром -Comment, может содержать любой символ, кроме NULL.</target>
        </trans-unit>
        <trans-unit id="5a33beea90e0c4b3cd6d3aa1b159094d2037e800" translate="yes" xml:space="preserve">
          <source>The value supplied with &lt;code&gt;-Name&lt;/code&gt; option can contain any character except NULL.</source>
          <target state="translated">Значение, &lt;code&gt;-Name&lt;/code&gt; параметром -Name, может содержать любой символ, кроме NULL.</target>
        </trans-unit>
        <trans-unit id="f1aeb63cc4cb0e101586c3105fecbdbf9caca8c2" translate="yes" xml:space="preserve">
          <source>The value supplied with the &lt;code&gt;Comment&lt;/code&gt; option can only contain ISO 8859-1 characters plus line-feed.</source>
          <target state="translated">Значение, предоставленное с параметром &amp;laquo; &lt;code&gt;Comment&lt;/code&gt; может содержать только символы ISO 8859-1 плюс перевод строки.</target>
        </trans-unit>
        <trans-unit id="56d224f65d33c0660d7f4661847cc1e8f860019d" translate="yes" xml:space="preserve">
          <source>The value supplied with the &lt;code&gt;Name&lt;/code&gt; option can only contain ISO 8859-1 characters.</source>
          <target state="translated">Значение, указанное с параметром &amp;laquo; &lt;code&gt;Name&lt;/code&gt; может содержать только символы ISO 8859-1.</target>
        </trans-unit>
        <trans-unit id="250b7ab858db3f7115ff282b675a91ac8e641be6" translate="yes" xml:space="preserve">
          <source>The value(s) returned by the failed subroutine. When the subroutine was called in a list context, this will always be a reference to an array containing the results. When the subroutine was called in a scalar context, this will be the actual scalar returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5341e40485577e6df05a609244175f85c79fb195" translate="yes" xml:space="preserve">
          <source>The values are specified on the following format line in the same order as the picture fields. The expressions providing the values must be separated by commas. They are all evaluated in a list context before the line is processed, so a single list expression could produce multiple list elements. The expressions may be spread out to more than one line if enclosed in braces. If so, the opening brace must be the first token on the first line. If an expression evaluates to a number with a decimal part, and if the corresponding picture specifies that the decimal part should appear in the output (that is, any picture except multiple &quot;#&quot; characters &lt;b&gt;without&lt;/b&gt; an embedded &quot;.&quot;), the character used for the decimal point is determined by the current LC_NUMERIC locale if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect. This means that, if, for example, the run-time environment happens to specify a German locale, &quot;,&quot; will be used instead of the default &quot;.&quot;. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;#WARNINGS&quot;&gt;WARNINGS&lt;/a&gt; for more information.</source>
          <target state="translated">Значения указываются в следующей строке формата в том же порядке, что и поля изображения. Выражения, предоставляющие значения, должны быть разделены запятыми. Все они оцениваются в контексте списка перед обработкой строки, поэтому одно выражение списка может создать несколько элементов списка. Выражения могут быть растянуты на более чем одну строку, если заключены в фигурные скобки. В таком случае открывающая скобка должна быть первым маркером в первой строке. Если выражение оценивается как число с десятичной частью, и если соответствующее изображение указывает, что десятичная часть должна отображаться в выводе (то есть любое изображение, кроме нескольких символов &quot;#&quot; &lt;b&gt;без&lt;/b&gt; встроенного &quot;.&quot;), Используемый символ для десятичной точки определяется текущим языковым стандартом LC_NUMERIC, если &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; действует. Это означает, что, если, например, среда выполнения задает немецкий язык, вместо значения по умолчанию &amp;laquo;.&amp;raquo; Будет использоваться &amp;laquo;,&amp;raquo;. См. &lt;a href=&quot;perllocale&quot;&gt;Perllocale&lt;/a&gt; и &lt;a href=&quot;#WARNINGS&quot;&gt;ПРЕДУПРЕЖДЕНИЯ&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="c72d7d9a1485bc34599e1ebeb09b10805e996267" translate="yes" xml:space="preserve">
          <source>The values are specified on the following format line in the same order as the picture fields. The expressions providing the values must be separated by commas. They are all evaluated in a list context before the line is processed, so a single list expression could produce multiple list elements. The expressions may be spread out to more than one line if enclosed in braces. If so, the opening brace must be the first token on the first line. If an expression evaluates to a number with a decimal part, and if the corresponding picture specifies that the decimal part should appear in the output (that is, any picture except multiple &quot;#&quot; characters &lt;b&gt;without&lt;/b&gt; an embedded &quot;.&quot;), the character used for the decimal point is determined by the current LC_NUMERIC locale if &lt;code&gt;use locale&lt;/code&gt; is in effect. This means that, if, for example, the run-time environment happens to specify a German locale, &quot;,&quot; will be used instead of the default &quot;.&quot;. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;#WARNINGS&quot;&gt;&quot;WARNINGS&quot;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf008b9072b1cecb517f8aeffecd9422e5c3c63" translate="yes" xml:space="preserve">
          <source>The values of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; on some of these platforms include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd5bfa6286ea39c4bd9487ae2b5176bb3be48be" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;$^O&lt;/code&gt; on some of these platforms includes:</source>
          <target state="translated">Значения &lt;code&gt;$^O&lt;/code&gt; на некоторых из этих платформ включают:</target>
        </trans-unit>
        <trans-unit id="540bf16e20569214e1b31e52cdcbc4ee480d311c" translate="yes" xml:space="preserve">
          <source>The values pushed onto the return stack of the XSUB are actually mortal SV's. They are made mortal so that once the values are copied by the calling program, the SV's that held the returned values can be deallocated. If they were not mortal, then they would continue to exist after the XSUB routine returned, but would not be accessible. This is a memory leak.</source>
          <target state="translated">Значения,вытесненные на обратный стек XSUB,на самом деле являются смертельными SV.Они сделаны смертельными таким образом,что как только значения будут скопированы вызывающей программой,SV,которые держали возвращенные значения,могут быть разобраны.Если бы они не были смертельными,то они продолжали бы существовать после того,как XSUB вернулся,но не были бы доступны.Это утечка памяти.</target>
        </trans-unit>
        <trans-unit id="e474878aa7db7e96c4629326d93b845326ef064e" translate="yes" xml:space="preserve">
          <source>The values stored in config.sh may be either single-quoted or double-quoted. Double-quoted strings are handy for those cases where you need to include escape sequences in the strings. To avoid runtime variable interpolation, any &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; characters are replaced by &lt;code&gt;\$&lt;/code&gt; and &lt;code&gt;\@&lt;/code&gt; , respectively. This isn't foolproof, of course, so don't embed &lt;code&gt;\$&lt;/code&gt; or &lt;code&gt;\@&lt;/code&gt; in double-quoted strings unless you're willing to deal with the consequences. (The slashes will end up escaped and the &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; will trigger variable interpolation)</source>
          <target state="translated">Значения, хранящиеся в config.sh, могут быть заключены в одинарные или двойные кавычки. Строки с двойными кавычками удобны в тех случаях, когда вам нужно включить в строки escape-последовательности. Чтобы избежать интерполяции переменных времени выполнения, любые символы &lt;code&gt;$&lt;/code&gt; и &lt;code&gt;@&lt;/code&gt; заменяются на &lt;code&gt;\$&lt;/code&gt; и &lt;code&gt;\@&lt;/code&gt; соответственно. Конечно, это не является надежным, поэтому не вставляйте &lt;code&gt;\$&lt;/code&gt; или &lt;code&gt;\@&lt;/code&gt; в строки с двойными кавычками, если вы не хотите иметь дело с последствиями. (Косые черты будут экранированы, а &lt;code&gt;$&lt;/code&gt; или &lt;code&gt;@&lt;/code&gt; вызовут интерполяцию переменных)</target>
        </trans-unit>
        <trans-unit id="2fb3e0a0c43753411747016bb8289e7cafa37f14" translate="yes" xml:space="preserve">
          <source>The values stored in config.sh may be either single-quoted or double-quoted. Double-quoted strings are handy for those cases where you need to include escape sequences in the strings. To avoid runtime variable interpolation, any &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; characters are replaced by &lt;code&gt;\$&lt;/code&gt; and &lt;code&gt;\@&lt;/code&gt;, respectively. This isn't foolproof, of course, so don't embed &lt;code&gt;\$&lt;/code&gt; or &lt;code&gt;\@&lt;/code&gt; in double-quoted strings unless you're willing to deal with the consequences. (The slashes will end up escaped and the &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; will trigger variable interpolation)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23b5412a89e9982acfd046a606aac6df7b125a8" translate="yes" xml:space="preserve">
          <source>The values stored in the hashes above are mostly the direct equivalent of their C counterpart. Like their C counterparts, all are set to a default values - that means you don't have to set</source>
          <target state="translated">Значения,сохраненные в приведенных выше хэшах,в основном являются прямым эквивалентом их C-конверта.Как и их C-контрагенты,все они установлены на значения по умолчанию-это означает,что вам не придется устанавливать</target>
        </trans-unit>
        <trans-unit id="9e6700989ab1dbf25d28d4fd1b763593cc3c720f" translate="yes" xml:space="preserve">
          <source>The values supplied with the &lt;code&gt;-Name&lt;/code&gt; and &lt;code&gt;-Comment&lt;/code&gt; options can contain multiple embedded nulls. The string written to the gzip header will consist of the characters up to, but not including, the first embedded NULL.</source>
          <target state="translated">Значения, предоставленные с параметрами &lt;code&gt;-Name&lt;/code&gt; и &lt;code&gt;-Comment&lt;/code&gt; , могут содержать несколько встроенных нулей. Строка, записанная в заголовок gzip, будет состоять из символов до первого встроенного NULL, но не включая его.</target>
        </trans-unit>
        <trans-unit id="f4d39e5aa9ce36eff93868e0e7af4d9b6a02d8ec" translate="yes" xml:space="preserve">
          <source>The values supplied with the &lt;code&gt;-Name&lt;/code&gt; and &lt;code&gt;-Comment&lt;/code&gt; options cannot contain multiple embedded nulls.</source>
          <target state="translated">Значения, предоставленные с параметрами &lt;code&gt;-Name&lt;/code&gt; и &lt;code&gt;-Comment&lt;/code&gt; , не могут содержать несколько встроенных нулей.</target>
        </trans-unit>
        <trans-unit id="6344a1b12727e711425a7cd0809233875bc47e54" translate="yes" xml:space="preserve">
          <source>The values to be compared are always passed by reference and should not be modified.</source>
          <target state="translated">Сравниваемые значения всегда передаются по ссылке и не должны изменяться.</target>
        </trans-unit>
        <trans-unit id="0a3bdf6ba268c4d17126cd579eaa00987525d1a3" translate="yes" xml:space="preserve">
          <source>The variable $ref may have referred to the subroutine &lt;code&gt;fred&lt;/code&gt; whenever the call to &lt;code&gt;SaveSub1&lt;/code&gt; was made but by the time &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it now holds the number &lt;code&gt;47&lt;/code&gt; . Because we saved only a pointer to the original SV in &lt;code&gt;SaveSub1&lt;/code&gt; , any changes to $ref will be tracked by the pointer &lt;code&gt;rememberSub&lt;/code&gt; . This means that whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called, it will attempt to execute the code which is referenced by the SV* &lt;code&gt;rememberSub&lt;/code&gt; . In this case though, it now refers to the integer &lt;code&gt;47&lt;/code&gt; , so expect Perl to complain loudly.</source>
          <target state="translated">Переменная $ ref могла ссылаться на подпрограмму &lt;code&gt;fred&lt;/code&gt; всякий раз, когда был сделан вызов &lt;code&gt;SaveSub1&lt;/code&gt; , но к моменту &lt;code&gt;CallSavedSub1&lt;/code&gt; теперь он содержит номер &lt;code&gt;47&lt;/code&gt; . Поскольку мы сохранили только указатель на исходный SV в &lt;code&gt;SaveSub1&lt;/code&gt; , любые изменения в $ ref будут отслеживаться указателем &lt;code&gt;rememberSub&lt;/code&gt; . Это означает, что всякий раз, когда &lt;code&gt;CallSavedSub1&lt;/code&gt; , он будет пытаться выполнить код, на который ссылается SV * &lt;code&gt;rememberSub&lt;/code&gt; . В данном случае, однако, теперь оно относится к целому числу &lt;code&gt;47&lt;/code&gt; , так что ожидайте, что Perl громко пожалуется.</target>
        </trans-unit>
        <trans-unit id="b062bdbf031860e708b29efdacf136fb5d1f0b68" translate="yes" xml:space="preserve">
          <source>The variable $ref may have referred to the subroutine &lt;code&gt;fred&lt;/code&gt; whenever the call to &lt;code&gt;SaveSub1&lt;/code&gt; was made but by the time &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it now holds the number &lt;code&gt;47&lt;/code&gt;. Because we saved only a pointer to the original SV in &lt;code&gt;SaveSub1&lt;/code&gt;, any changes to $ref will be tracked by the pointer &lt;code&gt;rememberSub&lt;/code&gt;. This means that whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called, it will attempt to execute the code which is referenced by the SV* &lt;code&gt;rememberSub&lt;/code&gt;. In this case though, it now refers to the integer &lt;code&gt;47&lt;/code&gt;, so expect Perl to complain loudly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1d8279ad869db1c2929300f40e329172cf94dc" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C compiler alone. The symbols defined by cpp or by cc when it calls cpp are not in this list, see cppsymbols and cppccsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">Переменная содержит символы,определенные только компилятором языка Си.Символов,определенных cpp или cc при вызове cpp нет в этом списке,смотрите cppsymbols и cppccsymbols.Список представляет собой разделенный пробелами список символов symbol=value tokens.</target>
        </trans-unit>
        <trans-unit id="501db733d2ef38c039a965292ca77f71bc56d687" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C compiler when it calls cpp. The symbols defined by the cc alone or cpp alone are not in this list, see ccsymbols and cppsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">Переменная содержит символы,определенные компилятором Си при вызове cpp.Символов,определенных только cc или cpp,в этом списке нет,см.ccsymbols и cppsymbols.Список представляет собой разделенный пробелами список символов symbol=value tokens.</target>
        </trans-unit>
        <trans-unit id="00b4b60fa439030036a66d7ff80e60844c78536a" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C preprocessor alone. The symbols defined by cc or by cc when it calls cpp are not in this list, see ccsymbols and cppccsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">Переменная содержит символы,определенные только препроцессором языка С.Символов,определенных cc или cc при вызове cpp нет в этом списке,см.ccymbols и cppccsymbols.Список представляет собой разделенный пробелами список символов symbol=value tokens.</target>
        </trans-unit>
        <trans-unit id="83d3f8e3698f4e666192e80e4c4c129382375649" translate="yes" xml:space="preserve">
          <source>The variables &lt;code&gt;$@&lt;/code&gt; , &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$^E&lt;/code&gt; , and &lt;code&gt;$?&lt;/code&gt; contain information about different types of error conditions that may appear during execution of a Perl program. The variables are shown ordered by the &quot;distance&quot; between the subsystem which reported the error and the Perl process. They correspond to errors detected by the Perl interpreter, C library, operating system, or an external program, respectively.</source>
          <target state="translated">Переменные &lt;code&gt;$@&lt;/code&gt; , &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$^E&lt;/code&gt; и &lt;code&gt;$?&lt;/code&gt; содержат информацию о различных типах ошибок, которые могут возникнуть во время выполнения программы Perl. Переменные показаны в порядке &amp;laquo;расстояния&amp;raquo; между подсистемой, сообщившей об ошибке, и процессом Perl. Они соответствуют ошибкам, обнаруженным интерпретатором Perl, библиотекой C, операционной системой или внешней программой, соответственно.</target>
        </trans-unit>
        <trans-unit id="b727dbcbaa890861d8b1f725dd2b28a4ab07c49e" translate="yes" xml:space="preserve">
          <source>The variables &lt;code&gt;$@&lt;/code&gt;, &lt;code&gt;$!&lt;/code&gt;, &lt;code&gt;$^E&lt;/code&gt;, and &lt;code&gt;$?&lt;/code&gt; contain information about different types of error conditions that may appear during execution of a Perl program. The variables are shown ordered by the &quot;distance&quot; between the subsystem which reported the error and the Perl process. They correspond to errors detected by the Perl interpreter, C library, operating system, or an external program, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61a4e2ec2fd6a9d823c4ff48f24791a3afc0a43" translate="yes" xml:space="preserve">
          <source>The variables are thousands of characters long and you know that they don't change, and you need to wring out the last little bit of speed by having Perl skip testing for that. (There is a maintenance penalty for doing this, as mentioning &lt;code&gt;/o&lt;/code&gt; constitutes a promise that you won't change the variables in the pattern. If you do change them, Perl won't even notice.)</source>
          <target state="translated">Переменные состоят из тысяч символов, и вы знаете, что они не меняются, и вам нужно выжать последнюю каплю скорости, пропустив тестирование Perl для этого. (За это взимается штраф за обслуживание, поскольку упоминание &lt;code&gt;/o&lt;/code&gt; представляет собой обещание, что вы не измените переменные в шаблоне. Если вы измените их, Perl даже не заметит.)</target>
        </trans-unit>
        <trans-unit id="11544c219d80b67a63dc9e0a8e442712e549045b" translate="yes" xml:space="preserve">
          <source>The variables&amp;mdash;such as &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; , and &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%&amp;ndash; &lt;/code&gt; &amp;mdash;that hold the text remembered in a pattern match. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">Переменные, такие как &lt;code&gt;$1&lt;/code&gt; и &lt;code&gt;$2&lt;/code&gt; , а также &lt;code&gt;%+&lt;/code&gt; и &lt;code&gt;%&amp;ndash; &lt;/code&gt; которые содержат текст, запомненный в соответствии с шаблоном. См. Главу 5 &amp;laquo;Верблюд&amp;raquo; &amp;laquo;Сопоставление с образцом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d984e8b7b660f5c99b516a5829ac59bafa50592e" translate="yes" xml:space="preserve">
          <source>The variables&amp;mdash;such as &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt;, and &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%&amp;ndash; &lt;/code&gt;&amp;mdash;that hold the text remembered in a pattern match. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a6309a6878656688c2b0908ac3992f68dc7d19" translate="yes" xml:space="preserve">
          <source>The variant called by &lt;a href=&quot;#ack&quot;&gt;&quot;ack&quot;&lt;/a&gt; with the &quot;syn&quot; protocol and &lt;code&gt;$syn_forking&lt;/code&gt; enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b54417d53e0d1cfe584f4211726c367ffae98a" translate="yes" xml:space="preserve">
          <source>The variant of OS2::_control87() with default values good for handling exception mask: if no &lt;code&gt;mask&lt;/code&gt; , uses exception mask part of &lt;code&gt;new&lt;/code&gt; only. If no &lt;code&gt;new&lt;/code&gt; , disables all the floating point exceptions.</source>
          <target state="translated">Вариант OS2 :: _ control87 () со значениями по умолчанию подходит для обработки маски исключения: если нет &lt;code&gt;mask&lt;/code&gt; , использует только часть маски исключения из &lt;code&gt;new&lt;/code&gt; . Если нет &lt;code&gt;new&lt;/code&gt; , отключает все исключения с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="949da3d76c7f29272d20c982b210c531dcfc20d4" translate="yes" xml:space="preserve">
          <source>The variant of OS2::_control87() with default values good for handling exception mask: if no &lt;code&gt;mask&lt;/code&gt;, uses exception mask part of &lt;code&gt;new&lt;/code&gt; only. If no &lt;code&gt;new&lt;/code&gt;, disables all the floating point exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307e90e437dd1da42b4c1389ea6c9b26886479f7" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;extract_...&lt;/code&gt; subroutines may be used to extract a delimited substring, possibly after skipping a specified prefix string. By default, that prefix is optional whitespace (&lt;code&gt;/\s*/&lt;/code&gt; ), but you can change it to whatever you wish (see below).</source>
          <target state="translated">Различные подпрограммы &lt;code&gt;extract_...&lt;/code&gt; могут использоваться для извлечения подстроки с разделителями, возможно, после пропуска указанной строки префикса. По умолчанию этот префикс является необязательным пробелом ( &lt;code&gt;/\s*/&lt;/code&gt; ), но вы можете изменить его на все, что захотите (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="53ae99cb4c2e82006930873ef81a93aa0cb472f5" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;extract_...&lt;/code&gt; subroutines may be used to extract a delimited substring, possibly after skipping a specified prefix string. By default, that prefix is optional whitespace (&lt;code&gt;/\s*/&lt;/code&gt;), but you can change it to whatever you wish (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c592ef06c081d09dc8157d9f5c4a05ab70da35e" translate="yes" xml:space="preserve">
          <source>The various MSWin32 Perl's can distinguish the OS they are running on via the value of the fifth element of the list returned from &lt;a href=&quot;win32#Win32%3A%3AGetOSVersion%28%29&quot;&gt;&lt;code&gt;Win32::GetOSVersion()&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc16009f09e3803367ecc5c2f24dcc5baf8339c5" translate="yes" xml:space="preserve">
          <source>The various MSWin32 Perl's can distinguish the OS they are running on via the value of the fifth element of the list returned from &lt;code&gt;Win32::GetOSVersion()&lt;/code&gt; . For example:</source>
          <target state="translated">Различные Perl для MSWin32 могут различать ОС, в которых они работают, по значению пятого элемента списка, возвращаемого &lt;code&gt;Win32::GetOSVersion()&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="b5f8a6767121d40d53463b6246a6dc21454cdfba" translate="yes" xml:space="preserve">
          <source>The various named unary operators are treated as functions with one argument, with optional parentheses.</source>
          <target state="translated">Различные именованные одинарные операторы рассматриваются как функции с одним аргументом,с необязательными круглыми скобками.</target>
        </trans-unit>
        <trans-unit id="8d7dece5f96deb4f2078174f4b6a63435a6090e8" translate="yes" xml:space="preserve">
          <source>The various options that can be specified are:</source>
          <target state="translated">Можно указать различные опции:</target>
        </trans-unit>
        <trans-unit id="d5834701f76b16947132d9ecda0666e7fbd30f61" translate="yes" xml:space="preserve">
          <source>The various stacks have different purposes, and operate in slightly different ways. Their differences are noted below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f2d3209693f371a4dffdf7b8f3fc9b9432bc2c1" translate="yes" xml:space="preserve">
          <source>The various types of data aggregate form a natural hierarchy that facilitates the use of inheritance and polymorphism.</source>
          <target state="translated">Различные типы совокупности данных образуют естественную иерархию,которая облегчает использование наследования и полиморфизма.</target>
        </trans-unit>
        <trans-unit id="579f7176cc72efc4b3e6d5cd5bbca1f7407618f4" translate="yes" xml:space="preserve">
          <source>The vast majority of problems that are reported in this area boil down to the fact that C strings are NULL terminated, whilst Perl strings are not. See &lt;a href=&quot;#DBM-FILTERS&quot;&gt;&quot;DBM FILTERS&quot;&lt;/a&gt; for a generic way to work around this problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dcabdd4901aed0767d31bd0d04d8aa2ce24975f" translate="yes" xml:space="preserve">
          <source>The vast majority of problems that are reported in this area boil down to the fact that C strings are NULL terminated, whilst Perl strings are not. See &lt;a href=&quot;#DBM-FILTERS&quot;&gt;DBM FILTERS&lt;/a&gt; for a generic way to work around this problem.</source>
          <target state="translated">Подавляющее большинство проблем, о которых сообщают в этой области, сводятся к тому, что строки C завершаются NULL, а строки Perl - нет. См. В &lt;a href=&quot;#DBM-FILTERS&quot;&gt;DBM FILTERS&lt;/a&gt; общий способ решения этой проблемы.</target>
        </trans-unit>
        <trans-unit id="6c55d44dd5a799dd5be32ea5b3f1cae585e95693" translate="yes" xml:space="preserve">
          <source>The vast majority of the code was written by Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; , Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt; , Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt; . VMS support by Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt; . OS/2 support by Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt; . Mac support by Paul Schinder &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt; , and Thomas Wegner &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt; . abs2rel() and rel2abs() written by Shigio Yamaguchi &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt; , modified by Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt; . splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.</source>
          <target state="translated">Подавляющее большинство кода было написано Кеннетом Альбановски &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; , Энди Догерти &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt; , Андреасом Кенигом &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt; , Тимом Бансом &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt; . Поддержка VMS Чарльзом Бейли &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt; . Поддержка OS / 2 от Ильи Захаревича &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt; . Поддержка Mac: Пол Шиндер &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt; и Томас Вегнер &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt; . abs2rel () и rel2abs (), написанные Шиджио Ямагути &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt; , измененные Барри Слеймейкер &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt; . splitpath (), splitdir (), catpath () и catdir () от Barrie Slaymaker.</target>
        </trans-unit>
        <trans-unit id="78e57f945db726a29f3a1812670cc08732e95ca3" translate="yes" xml:space="preserve">
          <source>The vast majority of the code was written by Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt;, Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt;, Andreas K&amp;ouml;nig &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt;, Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt;. VMS support by Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt;. OS/2 support by Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt;. Mac support by Paul Schinder &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt;, and Thomas Wegner &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt;. abs2rel() and rel2abs() written by Shigio Yamaguchi &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt;, modified by Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt;. splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c837eb7150f7389b8a819378e52b179af4ab77" translate="yes" xml:space="preserve">
          <source>The vec() function may produce surprising results if used on strings containing characters with ordinal values above 255. In such a case, the results are consistent with the internal encoding of the characters, but not with much else. So don't do that, and starting in Perl 5.28, a deprecation message is issued if you do so, becoming illegal in Perl 5.32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a3f9b4fdc58bce9dc91ad1590ca608ffcca3cf" translate="yes" xml:space="preserve">
          <source>The veil of abstraction separating the &lt;b&gt;interface&lt;/b&gt; from the &lt;b&gt;implementation&lt;/b&gt; (whether enforced or not), which mandates that all access to an &lt;b&gt;object&lt;/b&gt;&amp;rsquo;s state be through &lt;b&gt;methods&lt;/b&gt; alone.</source>
          <target state="translated">Завеса абстракции, отделяющая &lt;b&gt;интерфейс&lt;/b&gt; от &lt;b&gt;реализации&lt;/b&gt; (принудительно или нет), которая требует, чтобы весь доступ к состоянию &lt;b&gt;объекта&lt;/b&gt; осуществлялся только через &lt;b&gt;методы&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="9b9ecb3d60d103c7f5665f456eda4698f957144a" translate="yes" xml:space="preserve">
          <source>The verify method always returns true ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20efbe7543ae8d526c7c1a14310569f9dadb6162" translate="yes" xml:space="preserve">
          <source>The version identifier for an XS module. This is usually handled automatically by &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . See &lt;code&gt;XS_VERSION_BOOTCHECK&lt;/code&gt; .</source>
          <target state="translated">Идентификатор версии для модуля XS. Обычно это автоматически выполняется &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . См. &lt;code&gt;XS_VERSION_BOOTCHECK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7557d13ad6548a59235452a6893c4504ed7e5952" translate="yes" xml:space="preserve">
          <source>The version identifier for an XS module. This is usually handled automatically by &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#XS_VERSION_BOOTCHECK&quot;&gt;&quot;XS_VERSION_BOOTCHECK&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e13051932ac793eddfcf7780ddfecbd50a22ea0e" translate="yes" xml:space="preserve">
          <source>The version is essentially an arbitrary string, but</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ddac7f13e9a2dc240c79129edea2cf74e24b8cc" translate="yes" xml:space="preserve">
          <source>The version number of the installed module - this will be &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the module had no (or unparsable) version number, or if the variable &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; was set to true. (See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below for details)</source>
          <target state="translated">Номер версии установленного модуля - это будет &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если у модуля нет (или не поддается синтаксическому анализу) номера версии, или если для переменной &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; задано значение true. (Подробнее см. Раздел &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; ниже)</target>
        </trans-unit>
        <trans-unit id="881eef9e03334c572492df3693b2b9db2367c722" translate="yes" xml:space="preserve">
          <source>The version number of the installed module - this will be &lt;code&gt;undef&lt;/code&gt; if the module had no (or unparsable) version number, or if the variable &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; was set to true. (See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below for details)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df3b2ff1998ec5ce67afe0561e7a92741c1659e" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows 2003 and Windows Home Server are identical; the SUITEMASK field must be used to differentiate between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0209883e46d2f3d87480f57905626dfd8d2e876" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows 7 and Windows Server 2008 R2 are identical; the PRODUCTTYPE field must be used to differentiate between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3168417cf9b56ff32b762909d40ba25ab0407e1" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows 8 and Windows Server 2012 are identical; the PRODUCTTYPE field must be used to differentiate between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7672ecea9c16e88589676b7a7fa4e019bcc4830" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows Vista and Windows Server 2008 are identical; the PRODUCTTYPE field must be used to differentiate between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a46a8ab62276eba4b76cf2918d64eaf428fd45" translate="yes" xml:space="preserve">
          <source>The version of PA-RISC at the time of this document's last update is 2.0, which is also the last there will be. HP PA-RISC systems are usually referred to with model description &quot;HP 9000&quot;. The last CPU in this series is the PA-8900. Support for PA-RISC architectured machines officially ends as shown in the following table:</source>
          <target state="translated">Версия PA-RISC на момент последнего обновления этого документа-2.0,которая также будет последней.На системы HP PA-RISC обычно ссылаются с описанием модели &quot;HP 9000&quot;.Последним процессором этой серии является PA-8900.Поддержка архитектурных машин PA-RISC официально заканчивается,как показано в следующей таблице:</target>
        </trans-unit>
        <trans-unit id="d9cdcafc4749e48949c53b1e0f4aeffeae610286" translate="yes" xml:space="preserve">
          <source>The version of ext() which is executed under VMS differs from the Unix-OS/2 version in several respects:</source>
          <target state="translated">Версия ext(),которая выполняется под VMS,несколько отличается от версии Unix-OS/2:</target>
        </trans-unit>
        <trans-unit id="fa000c815a6c1f4aa9d1d3cce6270062ea44f5d2" translate="yes" xml:space="preserve">
          <source>The version of ext() which is executed under Win32 differs from the Unix-OS/2 version in several respects:</source>
          <target state="translated">Версия ext(),которая выполняется под Win32,несколько отличается от версии Unix-OS/2:</target>
        </trans-unit>
        <trans-unit id="eea453196c9ecc4c3ad7040390519b5e41971ecc" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement Vstrings, to use &lt;a href=&quot;#isvstring&quot;&gt;&quot;isvstring&quot;&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c1fecbb3d585e94f9621773c665e2e2cd3f97d" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement Vstrings, to use &lt;a href=&quot;#isvstring&quot;&gt;isvstring&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">Версия perl, которую вы используете, не реализует Vstrings, чтобы использовать &lt;a href=&quot;#isvstring&quot;&gt;isvstring,&lt;/a&gt; вам нужно будет использовать более новую версию perl.</target>
        </trans-unit>
        <trans-unit id="decdd9bf0416592f2797901080148ed0ab06c7cc" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement weak references, to use &lt;a href=&quot;#isweak&quot;&gt;&quot;isweak&quot;&lt;/a&gt; or &lt;a href=&quot;#weaken&quot;&gt;&quot;weaken&quot;&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f3dd17d141437206c98482882771da9fd578da" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement weak references, to use &lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt; or &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">Версия Perl , которые вы используете не реализуют слабые ссылки, использовать &lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt; или &lt;a href=&quot;#weaken&quot;&gt;ослабить&lt;/a&gt; вам нужно будет использовать более новую релиз Perl.</target>
        </trans-unit>
        <trans-unit id="93c33ec188f162276af3a60f34074e13ed0b75fe" translate="yes" xml:space="preserve">
          <source>The version of the distribution to which the META.yml file refers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68f5af181947e373672838e7416d0d6d5457c72" translate="yes" xml:space="preserve">
          <source>The version of the distribution to which the META.yml file refers. This is a mandatory field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64bb3d6c21bf2a657e7026f0eee7644697eafb33" translate="yes" xml:space="preserve">
          <source>The version of the module distributed with Perl should, whenever possible, be the latest version of the module as distributed by the author (the latest non-beta version in the case of public Perl releases), although the pumpkin holder may hold off on upgrading the version of the module distributed with Perl to the latest version until the latest version has had sufficient testing.</source>
          <target state="translated">Версия модуля,распространяемого с Perl,должна,по возможности,быть последней версией модуля,распространяемого автором (последняя не бета-версия в случае публичных релизов Perl),хотя держатель тыквы может отложить обновление версии модуля,распространяемого с Perl,до последней версии до тех пор,пока последняя версия не пройдет достаточное тестирование.</target>
        </trans-unit>
        <trans-unit id="b21f22d5179989f705ed9d6a2a79b769acbc417d" translate="yes" xml:space="preserve">
          <source>The version of the module in the Perl core should still be considered the work of the original author. All patches, bug reports, and so forth should be fed back to them. Their development directions should be respected whenever possible.</source>
          <target state="translated">Версия модуля в ядре Perl все равно должна считаться работой оригинального автора.Все исправления,сообщения об ошибках и т.д.должны быть возвращены к ним.Их направления развития должны по возможности соблюдаться.</target>
        </trans-unit>
        <trans-unit id="92d384762292f03ed396ad91a060564bf7d9627e" translate="yes" xml:space="preserve">
          <source>The version this module needs to be -- this is optional</source>
          <target state="translated">Версия этого модуля должна быть --это опционально</target>
        </trans-unit>
        <trans-unit id="7c293dc4ef8b29552aa12216990ef31577ac2eeb" translate="yes" xml:space="preserve">
          <source>The versions of as and ld supplied with Solaris work fine for building perl. There is normally no need to install the GNU versions to compile perl.</source>
          <target state="translated">Варианты as и ld,поставляемые с Solaris,прекрасно подходят для строительства perl.Обычно для сборки perl нет необходимости устанавливать версии GNU.</target>
        </trans-unit>
        <trans-unit id="991e6e65f67b3a36b7e485bd86d8f440ac42e72f" translate="yes" xml:space="preserve">
          <source>The very end of the document:</source>
          <target state="translated">В самом конце документа:</target>
        </trans-unit>
        <trans-unit id="c59ec45ae7f53d6bfeaac3f5d1524ea40228db75" translate="yes" xml:space="preserve">
          <source>The very first thing you should do is look into getting the Term::ReadKey extension from CPAN. As we mentioned earlier, it now even has limited support for non-portable (read: not open systems, closed, proprietary, not POSIX, not Unix, etc.) systems.</source>
          <target state="translated">Первое,что вам нужно сделать,это посмотреть,как получить расширение Term::ReadKey из CPAN.Как мы упоминали ранее,теперь оно даже имеет ограниченную поддержку для неподвижных (читайте:не открытые системы,закрытые,проприетарные,не POSIX,не Unix и т.д.)систем.</target>
        </trans-unit>
        <trans-unit id="a54a90d3a077b2809332364bbb3b822680082301" translate="yes" xml:space="preserve">
          <source>The volume portion is always returned with a trailing &quot;:&quot;. The directory portion is always returned with a leading (to denote a relative path) and a trailing &quot;:&quot; (to denote a directory). The file portion is always returned</source>
          <target state="translated">Порция объема всегда возвращается с записями &quot;:&quot;.Часть каталога всегда возвращается с ведущим (для обозначения относительного пути)и ведущим &quot;:&quot; (для обозначения каталога).Порция файла всегда возвращается</target>
        </trans-unit>
        <trans-unit id="1ec332efc336ec299c7acc49f0d1e2fc497986e3" translate="yes" xml:space="preserve">
          <source>The wanted function</source>
          <target state="translated">Разыскиваемая функция</target>
        </trans-unit>
        <trans-unit id="6125dd5f3b647dbf86db0b504a3821e5fb95de7e" translate="yes" xml:space="preserve">
          <source>The wanted function takes no arguments but rather does its work through a collection of variables.</source>
          <target state="translated">Разыскиваемая функция не принимает аргументов,а выполняет свою работу через набор переменных.</target>
        </trans-unit>
        <trans-unit id="20d73a1883be618af881251a4f69445af19dc1a9" translate="yes" xml:space="preserve">
          <source>The warning category (or categories) packed into a &lt;code&gt;SVuv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="badd12b3cb878c5659d7f27917ce9ac00752a63d" translate="yes" xml:space="preserve">
          <source>The warning is considered severe enough not to be affected by the &lt;b&gt;-w&lt;/b&gt; switch (or its absence) because previously compiled invocations of the function will still be using the old value of the function. If you need to be able to redefine the subroutine, you need to ensure that it isn't inlined, either by dropping the &lt;code&gt;()&lt;/code&gt; prototype (which changes calling semantics, so beware) or by thwarting the inlining mechanism in some other way, e.g. by adding an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, as mentioned above:</source>
          <target state="translated">Предупреждение считается достаточно серьезным, чтобы на него не повлиял переключатель &lt;b&gt;-w&lt;/b&gt; (или его отсутствие), потому что ранее скомпилированные вызовы функции по-прежнему будут использовать старое значение функции. Если вам нужно иметь возможность переопределить подпрограмму, вам необходимо убедиться, что она не встроена, либо отбросив прототип ( &lt;code&gt;()&lt;/code&gt; (который изменяет семантику вызова, так что будьте осторожны), либо заблокировав механизм встраивания каким-либо другим способом, например добавив явный &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; , как упоминалось выше:</target>
        </trans-unit>
        <trans-unit id="dad69db2f27b61d28a567c57b099e70158211293" translate="yes" xml:space="preserve">
          <source>The warning is considered severe enough not to be affected by the &lt;b&gt;-w&lt;/b&gt; switch (or its absence) because previously compiled invocations of the function will still be using the old value of the function. If you need to be able to redefine the subroutine, you need to ensure that it isn't inlined, either by dropping the &lt;code&gt;()&lt;/code&gt; prototype (which changes calling semantics, so beware) or by thwarting the inlining mechanism in some other way, e.g. by adding an explicit &lt;code&gt;return&lt;/code&gt;, as mentioned above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228748e063ab0367333a5d358a372ffaa2776b68" translate="yes" xml:space="preserve">
          <source>The way I see this being used is like basically this:</source>
          <target state="translated">То,как я вижу,что это используется,в основном так:</target>
        </trans-unit>
        <trans-unit id="bf8410bbe832531f3fd9213bd8f3ba1287e55dc6" translate="yes" xml:space="preserve">
          <source>The way Perl builds up these op trees in the parsing process can be unravelled by examining</source>
          <target state="translated">Способ,которым Perl строит эти деревья операций в процессе анализа,можно раскрыть,изучив</target>
        </trans-unit>
        <trans-unit id="b9a4e5fa4cbdb6cec50f6eac70c4ad531843cef7" translate="yes" xml:space="preserve">
          <source>The way Test::More handles this is with a named block. Basically, a block of tests which can be skipped over or made todo. It's best if I just show you...</source>
          <target state="translated">Способ Тест::Больше ручек с именованным блоком.В основном,блок тестов,который можно пропустить или сделать тодо.Будет лучше,если я покажу тебе...</target>
        </trans-unit>
        <trans-unit id="3a44ce079c4bba6650cbd971c39500928ccb7c22" translate="yes" xml:space="preserve">
          <source>The way a program responds to an error. The exception-handling mechanism in Perl is the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">Как программа реагирует на ошибку. Механизм обработки исключений в Perl - это оператор &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="485d9ec05d9e7ee1509acc95cd728f99a6dde4db" translate="yes" xml:space="preserve">
          <source>The way a program responds to an error. The exception-handling mechanism in Perl is the &lt;code&gt;eval&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39341ae7c243431172aa717f037dcb000913133f" translate="yes" xml:space="preserve">
          <source>The way it resolves which actual method to call is:</source>
          <target state="translated">Способ,которым он решает,какой реальный метод вызова:</target>
        </trans-unit>
        <trans-unit id="2ecf3674cf5632aa049fa7e267f9fbd82a5b7877" translate="yes" xml:space="preserve">
          <source>The way it works is that when the &lt;code&gt;@{...}&lt;/code&gt; is seen in the double-quoted string, it's evaluated as a block. The block creates a reference to an anonymous array containing the results of the call to &lt;code&gt;mysub(1,2,3)&lt;/code&gt; . So the whole block returns a reference to an array, which is then dereferenced by &lt;code&gt;@{...}&lt;/code&gt; and stuck into the double-quoted string. This chicanery is also useful for arbitrary expressions:</source>
          <target state="translated">Это работает так: когда &lt;code&gt;@{...}&lt;/code&gt; встречается в строке с двойными кавычками, он оценивается как блок. Блок создает ссылку на анонимный массив, содержащий результаты вызова &lt;code&gt;mysub(1,2,3)&lt;/code&gt; . Таким образом, весь блок возвращает ссылку на массив, который затем разыменовывается с помощью &lt;code&gt;@{...}&lt;/code&gt; и вставляется в строку, заключенную в двойные кавычки. Эта хитрость также полезна для произвольных выражений:</target>
        </trans-unit>
        <trans-unit id="22373b22c059855720b294750ec63ef1e1b487f7" translate="yes" xml:space="preserve">
          <source>The way it works is that when the &lt;code&gt;@{...}&lt;/code&gt; is seen in the double-quoted string, it's evaluated as a block. The block creates a reference to an anonymous array containing the results of the call to &lt;code&gt;mysub(1,2,3)&lt;/code&gt;. So the whole block returns a reference to an array, which is then dereferenced by &lt;code&gt;@{...}&lt;/code&gt; and stuck into the double-quoted string. This chicanery is also useful for arbitrary expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="464aa10ca9c1c0eb18ad0b5fbb41c9f2af8f5587" translate="yes" xml:space="preserve">
          <source>The way this trick works is that the character with the code point &lt;code&gt;U+FFFE&lt;/code&gt; is not supposed to be in input streams, so the sequence of bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt; is unambiguously &quot;&lt;code&gt;BOM&lt;/code&gt; , represented in little-endian format&quot; and cannot be &lt;code&gt;U+FFFE&lt;/code&gt; , represented in big-endian format&quot;.</source>
          <target state="translated">Этот трюк работает так: символ с кодовой точкой &lt;code&gt;U+FFFE&lt;/code&gt; не должен находиться во входных потоках, поэтому последовательность байтов &lt;code&gt;0xFF 0xFE&lt;/code&gt; однозначно является &amp;laquo; &lt;code&gt;BOM&lt;/code&gt; , представленной в формате с прямым порядком байтов&amp;raquo; и не может быть &lt;code&gt;U+FFFE&lt;/code&gt; . , представленные в формате big-endian &quot;.</target>
        </trans-unit>
        <trans-unit id="03d93acd73703280d7e5deb9019540799404d722" translate="yes" xml:space="preserve">
          <source>The way this trick works is that the character with the code point &lt;code&gt;U+FFFE&lt;/code&gt; is not supposed to be in input streams, so the sequence of bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt; is unambiguously &quot;&lt;code&gt;BOM&lt;/code&gt;, represented in little-endian format&quot; and cannot be &lt;code&gt;U+FFFE&lt;/code&gt;, represented in big-endian format&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f55c636a9c9c26eb587e152e4c24ce7d11dc1f3" translate="yes" xml:space="preserve">
          <source>The way this works under-the-hood is that every thread has a choice of using a locale specific to it (this is the Windows and POSIX 2008 functionality), or the global locale that is accessible to all threads (this is the functionality that has always been there). The implementations for Windows and POSIX are completely different. On Windows, the runtime can be set up so that the standard &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt; function either only knows about the global locale or the locale for this thread. On POSIX, &lt;code&gt;setlocale&lt;/code&gt; always deals with the global locale, and other functions have been created to handle per-thread locales. Perl makes this transparent to perl-space code. It continues to use &lt;code&gt;POSIX::setlocale()&lt;/code&gt;, and the interpreter translates that into the per-thread functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5898f48e7b39c1a379ea1247c549323ccbb46061" translate="yes" xml:space="preserve">
          <source>The way to get around this problem is to use the Berkeley DB API method called &lt;code&gt;seq&lt;/code&gt; . This method allows sequential access to key/value pairs. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;THE API INTERFACE&lt;/a&gt; for details of both the &lt;code&gt;seq&lt;/code&gt; method and the API in general.</source>
          <target state="translated">Чтобы обойти эту проблему, используйте метод API Berkeley DB под названием &lt;code&gt;seq&lt;/code&gt; . Этот метод обеспечивает последовательный доступ к парам ключ / значение. См. &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;ИНТЕРФЕЙС API&lt;/a&gt; для получения подробной информации как о методе &lt;code&gt;seq&lt;/code&gt; ,так и об API в целом.</target>
        </trans-unit>
        <trans-unit id="365d9cd3356a85ac2e3ab542f36bc2743ee69357" translate="yes" xml:space="preserve">
          <source>The way to get around this problem is to use the Berkeley DB API method called &lt;code&gt;seq&lt;/code&gt;. This method allows sequential access to key/value pairs. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;&quot;THE API INTERFACE&quot;&lt;/a&gt; for details of both the &lt;code&gt;seq&lt;/code&gt; method and the API in general.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd500d8c20565e5f312bdd0b6574f8c8052649e9" translate="yes" xml:space="preserve">
          <source>The way to use this class is to make a new object of this class, set any options, and then call one of the search options (probably &lt;code&gt;survey&lt;/code&gt; or &lt;code&gt;find&lt;/code&gt; ). The sections below discuss the syntaxes for doing all that.</source>
          <target state="translated">Способ использования этого класса - создать новый объект этого класса, установить любые параметры, а затем вызвать одну из опций поиска (возможно, &lt;code&gt;survey&lt;/code&gt; или &lt;code&gt;find&lt;/code&gt; ). В разделах ниже обсуждаются синтаксисы для всего этого.</target>
        </trans-unit>
        <trans-unit id="70dcc819697307fd63c00ab11c88076b157ec890" translate="yes" xml:space="preserve">
          <source>The way to use this class is to make a new object of this class, set any options, and then call one of the search options (probably &lt;code&gt;survey&lt;/code&gt; or &lt;code&gt;find&lt;/code&gt;). The sections below discuss the syntaxes for doing all that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5268c05807fff3d270f4531a0cd21a77634cf686" translate="yes" xml:space="preserve">
          <source>The web server handling the HTTP service is assumed to be at its standard port, number 80. If the server you're trying to connect to is at a different port, like 1080 or 8080, you should specify it as the named-parameter pair, &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt; . The &lt;code&gt;autoflush&lt;/code&gt; method is used on the socket because otherwise the system would buffer up the output we sent it. (If you're on a prehistoric Mac, you'll also need to change every &lt;code&gt;&quot;\n&quot;&lt;/code&gt; in your code that sends data over the network to be a &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; instead.)</source>
          <target state="translated">Предполагается, что веб-сервер, обрабатывающий службу HTTP, находится на своем стандартном порте, номер 80. Если сервер, к которому вы пытаетесь подключиться, находится на другом порту, например 1080 или 8080, вы должны указать его как пару именованных параметров. , &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt; . В &lt;code&gt;autoflush&lt;/code&gt; используется метод autoflush, потому что в противном случае система буферизует отправленный нами вывод. (Если вы используете доисторический Mac, вам также необходимо изменить каждый &lt;code&gt;&quot;\n&quot;&lt;/code&gt; в вашем коде, который отправляет данные по сети, на &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="c2c0fa4dc9353a78eef2a13048e071f4e11d6efd" translate="yes" xml:space="preserve">
          <source>The web server handling the HTTP service is assumed to be at its standard port, number 80. If the server you're trying to connect to is at a different port, like 1080 or 8080, you should specify it as the named-parameter pair, &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt;. The &lt;code&gt;autoflush&lt;/code&gt; method is used on the socket because otherwise the system would buffer up the output we sent it. (If you're on a prehistoric Mac, you'll also need to change every &lt;code&gt;&quot;\n&quot;&lt;/code&gt; in your code that sends data over the network to be a &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; instead.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22573d6d6dbb31578b3c4fa9e8a17816a358dfc" translate="yes" xml:space="preserve">
          <source>The well known Unicode Byte Order Marks are as follows: if the file begins with the two literal byte values 0xFE 0xFF, this is the BOM for big-endian UTF-16. If the file begins with the two literal byte value 0xFF 0xFE, this is the BOM for little-endian UTF-16. On an ASCII platform, if the file begins with the three literal byte values 0xEF 0xBB 0xBF, this is the BOM for UTF-8. A mechanism portable to EBCDIC platforms is to:</source>
          <target state="translated">Известные Unicode Byte Order Marks выглядят следующим образом:если файл начинается с двух буквенных значений байтов 0xFE 0xFF,то это BOM для big-endian UTF-16.Если файл начинается с двух буквенных значений байтов 0xFF 0xFE,то это закладка для бигмендиального UTF-16.На ASCII платформе,если файл начинается со значения трех байтов 0xEF 0xBB 0xBF,то это закладка для UTF-8.Механизм,переносимый на платформы EBCDIC,является таковым:</target>
        </trans-unit>
        <trans-unit id="c25fe7dd72c3069b0e017baa01097278ab17f62e" translate="yes" xml:space="preserve">
          <source>The while loop from line 14 to line 26 grabs a scalar off the input queue and checks against the prime this thread is responsible for. Line 15 checks to see if there's a remainder when we divide the number to be checked by our prime. If there is one, the number must not be evenly divisible by our prime, so we need to either pass it on to the next thread if we've created one (line 17) or create a new thread if we haven't.</source>
          <target state="translated">В то время как цикл от 14-й до 26-й строки захватывает скаляр из входной очереди и проверяет его по нулевому значению,за которое отвечает этот поток.Строка 15 проверяет,есть ли остаток,когда мы делим число,которое мы проверяем на простую.Если оно есть,то число не должно быть равномерно разделено на простые,поэтому мы должны либо передать его следующему потоку,если мы создали один (строка 17),либо создать новый поток,если мы этого не делали.</target>
        </trans-unit>
        <trans-unit id="a997f7e1957d2b943d666798431c61228059e247" translate="yes" xml:space="preserve">
          <source>The whole Unicode standard &lt;a href=&quot;http://www.unicode.org/unicode/uni2book/u2.html&quot;&gt;http://www.unicode.org/unicode/uni2book/u2.html&lt;/a&gt;</source>
          <target state="translated">Полный стандарт Unicode &lt;a href=&quot;http://www.unicode.org/unicode/uni2book/u2.html&quot;&gt;http://www.unicode.org/unicode/uni2book/u2.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52ed5e8abe2195d94e62a75cf32bf369a78b18af" translate="yes" xml:space="preserve">
          <source>The whole idea of the &quot;standard C API to start applications&quot; is that the forms &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;&quot;foo&quot;&lt;/code&gt; of program arguments are completely interchangeable.</source>
          <target state="translated">Вся идея &amp;laquo;стандартного C API для запуска приложений&amp;raquo; состоит в том, что формы аргументов программы &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;&quot;foo&quot;&lt;/code&gt; полностью взаимозаменяемы.</target>
        </trans-unit>
        <trans-unit id="0fe54c442e0898f0c65d2e7e96e6d557275adef9" translate="yes" xml:space="preserve">
          <source>The whole scheme for interpreting two-digit years can be considered a bug.</source>
          <target state="translated">Вся схема интерпретации двузначных лет может считаться ошибкой.</target>
        </trans-unit>
        <trans-unit id="06823ddcb564d7e0125b4ed62adb0242c15ff840" translate="yes" xml:space="preserve">
          <source>The wide character is not used in the &lt;code&gt;&amp;amp;&lt;/code&gt; operation because the left operand is shorter. This now throws an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5992a1d1d14f7a847e98f6f7210198b195d54e7" translate="yes" xml:space="preserve">
          <source>The wide-character-specific (Unicode) functions. Each of these is just the same as the version without the trailing &quot;W&quot; except that strings are expected in Unicode and some lengths are measured as number of &lt;code&gt;WCHAR&lt;/code&gt;s instead of number of bytes, as indicated below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d301a149055986dea057eaf7f10ce99a292fd767" translate="yes" xml:space="preserve">
          <source>The width of the left margin in spaces. Defaults to 0. This is the margin for all text, including headings, not the amount by which regular text is indented; for the latter, see &lt;b&gt;-i&lt;/b&gt; option.</source>
          <target state="translated">Ширина левого поля в пробелах. По умолчанию 0. Это поле для всего текста, включая заголовки, а не размер отступа обычного текста; для последнего см. параметр &lt;b&gt;-i&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="00b688a33a04cf250468fb3feaca19bab2ec26fc" translate="yes" xml:space="preserve">
          <source>The width of the left margin in spaces. Defaults to 0. This is the margin for all text, including headings, not the amount by which regular text is indented; for the latter, see the</source>
          <target state="translated">Ширина левого поля в пространствах.По умолчанию 0-это поле для всего текста,включая заголовки,а не сумма,на которую отступает обычный текст;о последнем см.в разделе</target>
        </trans-unit>
        <trans-unit id="9f8ba2c52e40b69413c01ffc592fe399547fc20f" translate="yes" xml:space="preserve">
          <source>The word returned by the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function when you apply it to a reference to a subroutine. See also &lt;b&gt;CV&lt;/b&gt;.</source>
          <target state="translated">Слово, возвращаемое функцией &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; , когда вы применяете его к ссылке на подпрограмму. См. Также &lt;b&gt;резюме&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="6d42ff99a16e8f67b82856c6d2b84806cf10fd36" translate="yes" xml:space="preserve">
          <source>The word returned by the &lt;code&gt;ref&lt;/code&gt; function when you apply it to a reference to a subroutine. See also &lt;b&gt;CV&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28be5b370df296bc57d076e1c2849a0ebee70013" translate="yes" xml:space="preserve">
          <source>The work isn't over until the paperwork is done, and you're going to need to put in some time writing some documentation for your module. &lt;code&gt;module-starter&lt;/code&gt; or &lt;code&gt;h2xs&lt;/code&gt; will provide a stub for you to fill in; if you're not sure about the format, look at &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; for an introduction. Provide a good synopsis of how your module is used in code, a description, and then notes on the syntax and function of the individual subroutines or methods. Use Perl comments for developer notes and POD for end-user notes.</source>
          <target state="translated">Работа не закончена, пока не будут оформлены документы, и вам нужно будет потратить некоторое время на написание некоторой документации для вашего модуля. &lt;code&gt;module-starter&lt;/code&gt; или &lt;code&gt;h2xs&lt;/code&gt; предоставит вам заглушку для заполнения; если вы не уверены в формате, посмотрите &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; для введения. Предоставьте хороший синопсис того, как ваш модуль используется в коде, описание, а затем примечания по синтаксису и функциям отдельных подпрограмм или методов. Используйте комментарии Perl для заметок разработчика и POD для заметок конечного пользователя.</target>
        </trans-unit>
        <trans-unit id="a31887edd2b89b26426a7d0c030500f19faef476" translate="yes" xml:space="preserve">
          <source>The work of the interpreter has two main stages: compiling the code into the internal representation, or bytecode, and then executing it. &lt;a href=&quot;perlguts#Compiled-code&quot;&gt;&quot;Compiled code&quot; in perlguts&lt;/a&gt; explains exactly how the compilation stage happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1436e107c02b49fba4e33d8aaae3115ec601983a" translate="yes" xml:space="preserve">
          <source>The work of the interpreter has two main stages: compiling the code into the internal representation, or bytecode, and then executing it. &lt;a href=&quot;perlguts#Compiled-code&quot;&gt;Compiled code in perlguts&lt;/a&gt; explains exactly how the compilation stage happens.</source>
          <target state="translated">Работа интерпретатора состоит из двух основных этапов: компиляция кода во внутреннее представление или байт-код, а затем его выполнение. &lt;a href=&quot;perlguts#Compiled-code&quot;&gt;Скомпилированный код в perlguts&lt;/a&gt; точно объясняет, как происходит этап компиляции.</target>
        </trans-unit>
        <trans-unit id="8b1397bff51f75db954e0f3e3e1b665db01ca7e8" translate="yes" xml:space="preserve">
          <source>The world's languages are written in many different scripts. This sentence (unless you're reading it in translation) is written in Latin, while Russian is written in Cyrillic, and Greek is written in, well, Greek; Japanese mainly in Hiragana or Katakana. There are many more.</source>
          <target state="translated">Языки мира написаны множеством различных шрифтов.Это предложение (если только вы не читаете его в переводе)написано на латыни,в то время как русский написан кириллицей,а греческий,ну,греческий;японский в основном на хирагане или катакане.Их гораздо больше.</target>
        </trans-unit>
        <trans-unit id="85da59eaf7698f05d48c68376bdd4ba3b6dce3bd" translate="yes" xml:space="preserve">
          <source>The worst patches make use of system-specific features. It's highly unlikely that non-portable additions to the Perl language will be accepted.</source>
          <target state="translated">В худших исправлениях используются специфические для системы функции.Весьма маловероятно,что не переносимые дополнения к языку Perl будут приняты.</target>
        </trans-unit>
        <trans-unit id="2affe5ea5db32cf7d355e39106992f04132aac2d" translate="yes" xml:space="preserve">
          <source>The write filehandle will have autoflush turned on.</source>
          <target state="translated">В ручке файла записи будет включена автопромывка.</target>
        </trans-unit>
        <trans-unit id="f34726284c86402203e3588790fd3c449c8531b5" translate="yes" xml:space="preserve">
          <source>The yacc coming with BS2000 POSIX didn't work for us. So we had to use bison. We had to make a few changes to perl in order to use the pure (reentrant) parser of bison. We used version 1.25, but we had to add a few changes due to EBCDIC. See below for more details concerning yacc.</source>
          <target state="translated">Якк,пришедший с BS2000 POSIX,не работал на нас.Поэтому нам пришлось использовать бизона.Нам пришлось внести несколько изменений в perl,чтобы использовать чистый (реентерабельный)парсер бизона.Мы использовали версию 1.25,но нам пришлось добавить несколько изменений из-за EBCDIC.Подробнее о yacc.</target>
        </trans-unit>
        <trans-unit id="0aff817087165151aec8e0b6db814baaf554f377" translate="yes" xml:space="preserve">
          <source>The z/OS Unix Tools and Toys list may prove helpful and contains links to ports of much of the software helpful for building Perl. &lt;a href=&quot;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&quot;&gt;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&lt;/a&gt;</source>
          <target state="translated">Список инструментов и игрушек для z / OS Unix может оказаться полезным и содержит ссылки на порты большей части программного обеспечения, полезного для создания Perl. &lt;a href=&quot;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&quot;&gt;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="26c38255249743d87d50270df89b2a9ebd2b4fd7" translate="yes" xml:space="preserve">
          <source>The zhuyin ordering includes some characters that are not CJK Unified Ideographs and can't utilize &lt;code&gt;weightZhuyin()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f215722614928e4a382d634f12d1b784a861305a" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;$reg&lt;/code&gt; can be used as a regexp:</source>
          <target state="translated">Тогда &lt;code&gt;$reg&lt;/code&gt; можно использовать как регулярное выражение:</target>
        </trans-unit>
        <trans-unit id="de5ca28d4aa169910f5c4821c56dad5137cddc68" translate="yes" xml:space="preserve">
          <source>Then again, you could always use parentheses.</source>
          <target state="translated">С другой стороны,ты всегда можешь использовать скобки.</target>
        </trans-unit>
        <trans-unit id="8f720f0ca68279a1e213df21b730afd59a9417d5" translate="yes" xml:space="preserve">
          <source>Then along comes Unicode which has room for over a million characters (and Perl allows for even more). This means that a character may require more than a single byte to represent it, and so the two terms are no longer equivalent. What matter are the characters as whole entities, and not usually the bytes that comprise them. That's what the term &quot;Character Semantics&quot; in the title of this section refers to.</source>
          <target state="translated">Затем идет Unicode,в котором есть место для более чем миллиона символов (а Perl позволяет еще больше).Это означает,что для представления символа может потребоваться больше одного байта,и поэтому эти два термина больше не эквивалентны.Важно,чтобы символы представляли собой целые сущности,а не байты,которые их составляют.Именно к этому относится термин &quot;Семантика символов&quot; в заголовке данного раздела.</target>
        </trans-unit>
        <trans-unit id="48ff6c17f5c4132eb7b4e146224751484821d774" translate="yes" xml:space="preserve">
          <source>Then compile:</source>
          <target state="translated">Тогда соберись:</target>
        </trans-unit>
        <trans-unit id="894eab3b8839b7526298878f8b7e43bb55872aae" translate="yes" xml:space="preserve">
          <source>Then copy setargv.obj to %PlatformSDKDir%\lib</source>
          <target state="translated">Затем скопируйте setargv.obj в %PlatformSDKDir%\lib.</target>
        </trans-unit>
        <trans-unit id="939d22a5767f7f1b738027999de54521a98a4c28" translate="yes" xml:space="preserve">
          <source>Then delete every .bundle file found anywhere in the folders:</source>
          <target state="translated">После этого удалите каждый файл пакета,найденный в любом месте папок:</target>
        </trans-unit>
        <trans-unit id="072381135845bbd0f86b6799cfa84f6d7fbff38f" translate="yes" xml:space="preserve">
          <source>Then go on to declare and use your variables in functions without any qualifications. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; and the &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for details on mechanics and style issues in module creation.</source>
          <target state="translated">Затем переходите к объявлению и использованию ваших переменных в функциях без каких-либо оговорок. См. &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; и &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; для получения подробной информации о механике и стилях при создании модуля.</target>
        </trans-unit>
        <trans-unit id="0260e987a9bcfe5e51c92652bad4a0b41e5cc334" translate="yes" xml:space="preserve">
          <source>Then increment any of the dotted-decimal components (v1.20.1 or v1.21.0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27efe9215ba97f3d69be224566771bce0e52d95d" translate="yes" xml:space="preserve">
          <source>Then make your changes. For example, if Leon Brocard changes his name to Orange Brocard, we should change his name in the AUTHORS file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcffa804562972342cabda61bf0a405b76b432e" translate="yes" xml:space="preserve">
          <source>Then move the files (probably just the</source>
          <target state="translated">Затем переместите файлы (возможно,просто</target>
        </trans-unit>
        <trans-unit id="16764d0cdf61fb44dac45d466795c94ebcc324fb" translate="yes" xml:space="preserve">
          <source>Then override the &lt;code&gt;start_for&lt;/code&gt; method in the subclass to check for when &quot;$flags-&amp;gt;{'target'}&quot; is equal to 'foo' and set a flag that marks that you're in a foo block (maybe &quot;$self-&amp;gt;{'in_foo'} = 1&quot;). Then override the &lt;code&gt;handle_text&lt;/code&gt; method to check for the flag, and pass $text to your custom subroutine to construct the HTML output for 'foo' elements, something like:</source>
          <target state="translated">Затем переопределите метод &lt;code&gt;start_for&lt;/code&gt; в подклассе, чтобы проверить, когда &quot;$ flags -&amp;gt; {'target'}&quot; равно 'foo', и установите флаг, который отмечает, что вы находитесь в блоке foo (возможно, &quot;$ self-&amp;gt; {'in_foo'} = 1 &quot;). Затем переопределите метод &lt;code&gt;handle_text&lt;/code&gt; , чтобы проверить наличие флага, и передайте $ text своей пользовательской подпрограмме для создания вывода HTML для элементов 'foo', например:</target>
        </trans-unit>
        <trans-unit id="5906927423d13fecbc7d429a1e04d7524ab55ae4" translate="yes" xml:space="preserve">
          <source>Then run the following script (or something like it):</source>
          <target state="translated">Затем запустите следующий скрипт (или что-то в этом роде):</target>
        </trans-unit>
        <trans-unit id="dc813daf18229cd1ceaa147ef073875823c78936" translate="yes" xml:space="preserve">
          <source>Then that text and all remaining text up through and including a line beginning with &lt;code&gt;=cut&lt;/code&gt; will be ignored. The format of the intervening text is described in &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="translated">Тогда этот текст и весь оставшийся текст, включая строку, начинающуюся с &lt;code&gt;=cut&lt;/code&gt; , будут проигнорированы. Формат промежуточного текста описан в &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8606c2212e120ef5c1865576f0176c5b8ada5faa" translate="yes" xml:space="preserve">
          <source>Then the assignment with the indirection on the left-hand-side would use the existing reference that was already there:</source>
          <target state="translated">Тогда задание с направлением слева будет использовать существующую ссылку,которая уже была там:</target>
        </trans-unit>
        <trans-unit id="8207f190aea8ef5aad0fa43cccb20c94bdffd926" translate="yes" xml:space="preserve">
          <source>Then the handler makes absolutely no attempt to interpret the data it receives and simply passes it as a string:</source>
          <target state="translated">Тогда обработчик абсолютно не пытается интерпретировать получаемые данные и просто передает их как строку:</target>
        </trans-unit>
        <trans-unit id="724e763cfec8edb999475aec0cbf98b0b938163f" translate="yes" xml:space="preserve">
          <source>Then the match is executed and the remaining lines describe the process:</source>
          <target state="translated">Затем выполняется совпадение,а остальные строки описывают процесс:</target>
        </trans-unit>
        <trans-unit id="41718c26f8da915843d6b183e2c76ef5e3a2e26d" translate="yes" xml:space="preserve">
          <source>Then to use it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581e9b63d178af7824ad52db20f4431ce7a1a3ec" translate="yes" xml:space="preserve">
          <source>Then use any of those as you would a normal filehandle. Anywhere that Perl is expecting a filehandle, an indirect filehandle may be used instead. An indirect filehandle is just a scalar variable that contains a filehandle. Functions like &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, or the &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; diamond operator will accept either a named filehandle or a scalar variable containing one:</source>
          <target state="translated">Затем используйте любой из них, как обычный дескриптор файла. Везде, где Perl ожидает дескриптор файла, вместо него можно использовать косвенный дескриптор файла. Косвенный дескриптор файла - это просто скалярная переменная, содержащая дескриптор файла. Такие функции, как &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; или алмазный оператор &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; будут принимать именованный дескриптор файла или скалярную переменную, содержащую его:</target>
        </trans-unit>
        <trans-unit id="1cf2cb2bbe0265bf12a87e03d2ba1a967297063a" translate="yes" xml:space="preserve">
          <source>Then use any of those as you would a normal filehandle. Anywhere that Perl is expecting a filehandle, an indirect filehandle may be used instead. An indirect filehandle is just a scalar variable that contains a filehandle. Functions like &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;seek&lt;/code&gt;, or the &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; diamond operator will accept either a named filehandle or a scalar variable containing one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be01a69ef7dc497f6d53fec0422df0742cb41c46" translate="yes" xml:space="preserve">
          <source>Then use it like:</source>
          <target state="translated">Тогда используй его как:</target>
        </trans-unit>
        <trans-unit id="ac583abd9dd0b62af4de435d7d5497c2d6ffcb6a" translate="yes" xml:space="preserve">
          <source>Then we have to give each character a unique ID so your computer can tell the difference between 'a' and 'A'. This itemized character repertoire is now a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3068081feb5a0d3d89b7875b7ddf972f866ffeca" translate="yes" xml:space="preserve">
          <source>Then when you call $lh-&amp;gt;maketext(</source>
          <target state="translated">Затем, когда вы вызываете $ lh-&amp;gt; maketext (</target>
        </trans-unit>
        <trans-unit id="ef2df7391bceda4d0a67009f959c0d587bbf6bd2" translate="yes" xml:space="preserve">
          <source>Then you can merge it into master like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4174f8d83f029a8fa078cc1b0e4b602d5427b4d7" translate="yes" xml:space="preserve">
          <source>Then you can progress through any remaining notable Unicode characters in the range 0x2000-0x204D (consult the character tables at www.unicode.org), and whatever else strikes your fancy. For example, in</source>
          <target state="translated">Затем вы можете пройтись по всем оставшимся заметным символам Юникода в диапазоне 0x2000-0x204D (см.таблицы символов на сайте www.unicode.org),и все остальное поразит вас своей фантазией.Например,в</target>
        </trans-unit>
        <trans-unit id="84a1243ca0e6b4d4a37040b980b310d461ab4076" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended in new code.</source>
          <target state="translated">Затем вы можете использовать &lt;code&gt;FH&lt;/code&gt; как дескриптор, в &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; и &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; и так далее. Обратите внимание, что это глобальная переменная, поэтому использовать эту форму в новом коде не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="c81a39d78bb4e09ef8b273b017dac3466493479a" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended in new code.</source>
          <target state="translated">Затем вы можете использовать &lt;code&gt;FH&lt;/code&gt; как дескриптор, в &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; и &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; и так далее. Обратите внимание, что это глобальная переменная, поэтому использовать эту форму в новом коде не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="8845af43a427cd30379b447f56ac8ef63aa6a453" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;close FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended when dealing with filehandles other than Perl's built-in ones (e.g. STDOUT and STDIN).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aceabb34e67cf540951bd4247eacd0dbbabee283" translate="yes" xml:space="preserve">
          <source>Then you'll need to know how to manipulate the Perl stack. That's described in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">Тогда вам нужно будет знать, как управлять стеком Perl. Это описано в &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9e623e714cffb21ba3a72f8e67c6ce57fe9270e" translate="yes" xml:space="preserve">
          <source>Then you'll need to pass the &lt;code&gt;nocase&lt;/code&gt; option in order to recognize &quot;Name&quot;:</source>
          <target state="translated">Затем вам нужно будет передать опцию &lt;code&gt;nocase&lt;/code&gt; , чтобы распознать &quot;Имя&quot;:</target>
        </trans-unit>
        <trans-unit id="5eea4f63f47d5b222c66289e4dec5701bc66810a" translate="yes" xml:space="preserve">
          <source>Then you've just supplied an automatic &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; in front of their argument, which can be more than a bit surprising. The old &lt;code&gt;@foo&lt;/code&gt; which used to hold one thing doesn't get passed in. Instead, &lt;code&gt;func()&lt;/code&gt; now gets passed in a &lt;code&gt;1&lt;/code&gt; ; that is, the number of elements in &lt;code&gt;@foo&lt;/code&gt; . And the &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; gets called in scalar context so it starts scribbling on your &lt;code&gt;@_&lt;/code&gt; parameter list. Ouch!</source>
          <target state="translated">Затем вы только что поставили автоматический &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; перед их аргументом, что может быть более чем немного удивительным. Старый &lt;code&gt;@foo&lt;/code&gt; , который раньше содержал что-то одно, не передается. Вместо этого &lt;code&gt;func()&lt;/code&gt; теперь передается в &lt;code&gt;1&lt;/code&gt; ; то есть количество элементов в &lt;code&gt;@foo&lt;/code&gt; . И &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; &lt;code&gt;@_&lt;/code&gt; в скалярном контексте, поэтому оно начинает рисовать в вашем списке параметров @_ . Ой!</target>
        </trans-unit>
        <trans-unit id="b0ba92bfa9d677231987d2b57b0a01cd1852383d" translate="yes" xml:space="preserve">
          <source>Then you've just supplied an automatic &lt;code&gt;scalar&lt;/code&gt; in front of their argument, which can be more than a bit surprising. The old &lt;code&gt;@foo&lt;/code&gt; which used to hold one thing doesn't get passed in. Instead, &lt;code&gt;func()&lt;/code&gt; now gets passed in a &lt;code&gt;1&lt;/code&gt;; that is, the number of elements in &lt;code&gt;@foo&lt;/code&gt;. And the &lt;code&gt;m//g&lt;/code&gt; gets called in scalar context so instead of a list of words it returns a boolean result and advances &lt;code&gt;pos($text)&lt;/code&gt;. Ouch!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d2223d4e367bda9f7a187be5ce1bdedd21df546" translate="yes" xml:space="preserve">
          <source>Then your Russian translator calls on the phone, to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee85b5d75e24b7f6cf7782bfc085bcfc0c87d6f5" translate="yes" xml:space="preserve">
          <source>Then, it determines the class and method name of the context it was invoked from.</source>
          <target state="translated">Затем он определяет имя класса и метода контекста,из которого он был вызван.</target>
        </trans-unit>
        <trans-unit id="6c23388be94a600da1203bed601e75b409a6b29f" translate="yes" xml:space="preserve">
          <source>Then, push your new branch to your fork.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5bc01ce529788e374ab9bf2dcdef9e77b7d91a8" translate="yes" xml:space="preserve">
          <source>There (probably) should be a semicolon at the end of the opening token</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d80e1f2d5ca1daef620a79f94100cd3a43dcad2" translate="yes" xml:space="preserve">
          <source>There appears to be a bug in the floating point implementation on BS2000 POSIX systems such that calling int() on the product of a number and a small magnitude number is not the same as calling int() on the quotient of that number and a large magnitude number. For example, in the following Perl code:</source>
          <target state="translated">В реализации с плавающей точкой на POSIX-системах BS2000 проявляется ошибка,заключающаяся в том,что вызов int()на произведение числа и малого числа не то же самое,что вызов int()на коэффициент этого числа и большого числа.Например,в следующем коде на Perl:</target>
        </trans-unit>
        <trans-unit id="bb6e61aa6502fa98f73e845b088e443cab1a90e3" translate="yes" xml:space="preserve">
          <source>There appears to be a bug in the floating point implementation on S/390 systems such that calling int() on the product of a number and a small magnitude number is not the same as calling int() on the quotient of that number and a large magnitude number. For example, in the following Perl code:</source>
          <target state="translated">В реализации с плавающей точкой на системах S/390 появилась ошибка,заключающаяся в том,что вызов int()на произведение числа и малого числа магнитуды не то же самое,что вызов int()на коэффициент этого числа и большого числа магнитуды.Например,в следующем коде на Perl:</target>
        </trans-unit>
        <trans-unit id="4eb2187ac5dc9a4b6af234beb08ab0fae2350bcf" translate="yes" xml:space="preserve">
          <source>There are 2 types of hooks, init hooks, and release hooks. As the names suggest, these hooks are triggered when contexts are created or released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1cfe28fcf075678633050ad3a49243fab1a122" translate="yes" xml:space="preserve">
          <source>There are 3 kinds of items that may be populated; special patterns, #vars, and literal text, which is copied verbatim. (Yes, it's a set of s///g steps.)</source>
          <target state="translated">Существует 3 вида предметов,которые могут быть заселены:специальные шаблоны,#vars и буквальный текст,который копируется дословно.(Да,это набор шагов s///g.)</target>
        </trans-unit>
        <trans-unit id="6e9231df83ad3f347c0bf53efa7fd0781ae7adef" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;lint&lt;/code&gt; and &amp;lt;splint&amp;gt; targets in Makefile, but you may have to diddle with the flags (see above).</source>
          <target state="translated">В Makefile есть цели &lt;code&gt;lint&lt;/code&gt; и &amp;lt;splint&amp;gt;, но вам, возможно, придется поработать с флагами (см. Выше).</target>
        </trans-unit>
        <trans-unit id="fe9ce8188c03cc1c80382377cc03bbf3d1eefe6b" translate="yes" xml:space="preserve">
          <source>There are DECC feature logical names AND ODS-5 volume attributes that also control what values are returned for the date fields.</source>
          <target state="translated">Существуют логические имена функций DECC и атрибуты тома ODS-5,которые также управляют тем,какие значения возвращаются для полей даты.</target>
        </trans-unit>
        <trans-unit id="153a01ed3dca851e07404e7b116e0f624fedd9d4" translate="yes" xml:space="preserve">
          <source>There are a couple of exceptions to the above rule. &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; is always interpreted as a Unicode code point, so that &lt;code&gt;\N{U+0050}&lt;/code&gt; is &lt;code&gt;&quot;P&quot;&lt;/code&gt; even on EBCDIC platforms. And if &lt;code&gt;&lt;a href=&quot;encoding&quot;&gt;use encoding&lt;/a&gt;&lt;/code&gt; is in effect, the number is considered to be in that encoding, and is translated from that into the platform's native encoding if there is a corresponding native character; otherwise to Unicode.</source>
          <target state="translated">Из приведенного выше правила есть несколько исключений. &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; всегда интерпретируется как кодовая точка Unicode, так что &lt;code&gt;\N{U+0050}&lt;/code&gt; имеет значение &lt;code&gt;&quot;P&quot;&lt;/code&gt; даже на платформах EBCDIC. И если &lt;code&gt;&lt;a href=&quot;encoding&quot;&gt;use encoding&lt;/a&gt;&lt;/code&gt; считается, что число находится в этой кодировке, и переводится из этого числа в собственную кодировку платформы, если есть соответствующий собственный символ; в противном случае - в Юникод.</target>
        </trans-unit>
        <trans-unit id="4e415da7b1ad793f82f6c66993b6dabfb03be0ae" translate="yes" xml:space="preserve">
          <source>There are a couple of macros to do very basic exception handling in XS modules. You have to define &lt;code&gt;NO_XSLOCKS&lt;/code&gt; before including</source>
          <target state="translated">Есть пара макросов для очень простой обработки исключений в модулях XS. Вы должны определить &lt;code&gt;NO_XSLOCKS&lt;/code&gt; перед включением</target>
        </trans-unit>
        <trans-unit id="b559285d4827f1039158fa6a1c7be09bcea8695c" translate="yes" xml:space="preserve">
          <source>There are a couple of other symbols that you're likely to encounter that aren't really type specifiers:</source>
          <target state="translated">Есть еще пара символов,с которыми вы,скорее всего,столкнетесь и которые на самом деле не являются спецификаторами типа:</target>
        </trans-unit>
        <trans-unit id="cd28f27e3e26acb88f426d59ef73cb49b8748e10" translate="yes" xml:space="preserve">
          <source>There are a couple of special arrays too, such as &lt;code&gt;@ARGV&lt;/code&gt; (the command line arguments to your script) and &lt;code&gt;@_&lt;/code&gt; (the arguments passed to a subroutine). These are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">Также есть несколько специальных массивов, таких как &lt;code&gt;@ARGV&lt;/code&gt; (аргументы командной строки вашего скрипта) и &lt;code&gt;@_&lt;/code&gt; (аргументы, передаваемые подпрограмме). Они задокументированы в &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d71c568688cddeb0974cf4c64aacf00c4a7ae0fc" translate="yes" xml:space="preserve">
          <source>There are a couple of things to note about this analysis. First, the third alternative in the second group 'de' also allows a match, but we stopped before we got to it - at a given character position, leftmost wins. Second, we were able to get a match at the first character position of the string 'a'. If there were no matches at the first position, Perl would move to the second character position 'b' and attempt the match all over again. Only when all possible paths at all possible character positions have been exhausted does Perl give up and declare &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; to be false.</source>
          <target state="translated">Об этом анализе следует отметить несколько моментов. Во-первых, третья альтернатива во второй группе 'de' также допускает совпадение, но мы остановились, прежде чем дошли до него - в данной позиции символа побеждает крайний левый. Во-вторых, мы смогли найти совпадение в позиции первого символа строки 'a'. Если бы не было совпадений в первой позиции, Perl переместился бы на позицию второго символа 'b' и снова попытался бы найти совпадение. Только когда все возможные пути во всех возможных позициях символов исчерпаны, Perl сдаётся и объявляет &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; быть ложным.</target>
        </trans-unit>
        <trans-unit id="deb5e7398add69ec1651990d98a23a3300e8eb2d" translate="yes" xml:space="preserve">
          <source>There are a couple of things to note about this analysis. First, the third alternative in the second group &lt;code&gt;'de'&lt;/code&gt; also allows a match, but we stopped before we got to it - at a given character position, leftmost wins. Second, we were able to get a match at the first character position of the string &lt;code&gt;'a'&lt;/code&gt;. If there were no matches at the first position, Perl would move to the second character position &lt;code&gt;'b'&lt;/code&gt; and attempt the match all over again. Only when all possible paths at all possible character positions have been exhausted does Perl give up and declare &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; to be false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39aecaa3926975713f4a2a65afbfb40347095ccc" translate="yes" xml:space="preserve">
          <source>There are a couple of ways that you can process an entire hash. You can get a list of keys, then go through each key, or grab a one key-value pair at a time.</source>
          <target state="translated">Есть пара способов обработать целый гашиш.Вы можете получить список ключей,затем просмотреть каждый ключ,или взять по одной паре ключей за раз.</target>
        </trans-unit>
        <trans-unit id="af13ea056584d18f28105e6dfb4305dd6e1f93f8" translate="yes" xml:space="preserve">
          <source>There are a few basic principles which define object oriented Perl:</source>
          <target state="translated">Есть несколько основных принципов,которые определяют объектно-ориентированный Perl:</target>
        </trans-unit>
        <trans-unit id="6ad0df8b5bb1240ec34f94939aa27ca4c87aa9d3" translate="yes" xml:space="preserve">
          <source>There are a few exceptions though: &lt;code&gt;x&lt;/code&gt; can be either string repetition or list repetition, depending on the type of the left operand, and &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; can be either string or numeric bit operations.</source>
          <target state="translated">Однако есть несколько исключений: &lt;code&gt;x&lt;/code&gt; может быть либо повторением строки, либо повторением списка, в зависимости от типа левого операнда, и &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; и &lt;code&gt;~&lt;/code&gt; могут быть строковыми или числовыми битовыми операциями.</target>
        </trans-unit>
        <trans-unit id="90c71cfbe20f7e4576d0df45674b3d041e6521fa" translate="yes" xml:space="preserve">
          <source>There are a few exceptions though: &lt;code&gt;x&lt;/code&gt; can be either string repetition or list repetition, depending on the type of the left operand, and &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; can be either string or numeric bit operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7bb479453f1e1c0fcfea035067e079420f6246" translate="yes" xml:space="preserve">
          <source>There are a few more things you might want to know about matching operators. The global modifier &lt;code&gt;//g&lt;/code&gt; allows the matching operator to match within a string as many times as possible. In scalar context, successive matches against a string will have &lt;code&gt;//g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function. For example,</source>
          <target state="translated">Есть еще несколько вещей, которые вы, возможно, захотите узнать об операторах сопоставления. Глобальный модификатор &lt;code&gt;//g&lt;/code&gt; позволяет оператору сопоставления совпадать в строке как можно больше раз. В скалярном контексте при последующих совпадениях со строкой &lt;code&gt;//g&lt;/code&gt; будет переходить от совпадения к совпадению, отслеживая положение в строке по мере ее продвижения. Вы можете получить или установить позицию с помощью функции &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; . Например,</target>
        </trans-unit>
        <trans-unit id="21076df5229fe033ea741a2399501b4983daa45a" translate="yes" xml:space="preserve">
          <source>There are a few more things you might want to know about matching operators. The global modifier &lt;code&gt;/g&lt;/code&gt; allows the matching operator to match within a string as many times as possible. In scalar context, successive matches against a string will have &lt;code&gt;/g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;pos()&lt;/code&gt; function. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4300a240e517c8a51298a8d027c6fc76723dcec0" translate="yes" xml:space="preserve">
          <source>There are a few point to bear in mind if you want to change the ordering in a BTREE database:</source>
          <target state="translated">Есть несколько моментов,которые следует иметь в виду,если вы хотите изменить заказ в базе данных BTREE:</target>
        </trans-unit>
        <trans-unit id="7b1086e8333561d2682eac30f860ad2422dfc42d" translate="yes" xml:space="preserve">
          <source>There are a few things to bear in mind when creating your own &lt;code&gt;ResultFactory&lt;/code&gt; :</source>
          <target state="translated">При создании собственного &lt;code&gt;ResultFactory&lt;/code&gt; следует учитывать несколько вещей :</target>
        </trans-unit>
        <trans-unit id="de8a54b9295025b3c139573926386493cb554215" translate="yes" xml:space="preserve">
          <source>There are a few things to bear in mind when creating your own &lt;code&gt;ResultFactory&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378f2e66966b2788636abfdbe2bc87b5abb48ea4" translate="yes" xml:space="preserve">
          <source>There are a few things you need to know, however:</source>
          <target state="translated">Однако,есть несколько вещей,которые вы должны знать:</target>
        </trans-unit>
        <trans-unit id="52b3f437a68cd4b70bf1c33277b0b324dc172b8a" translate="yes" xml:space="preserve">
          <source>There are a handful of cases where a tool author may want to create a new context by hand, which is why the &lt;code&gt;new&lt;/code&gt; method exists. Unless you really know what you are doing you should avoid this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="291c6f1e95cd386fbf1435fa808c577724438440" translate="yes" xml:space="preserve">
          <source>There are a lot of modules on CPAN, and it's easy to miss one that's similar to what you're planning on contributing. Have a good plough through &lt;a href=&quot;http://metacpan.org&quot;&gt;http://metacpan.org&lt;/a&gt; and make sure you're not the one reinventing the wheel!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cbfb29c30b87800b111898e71e11f4933f270fc" translate="yes" xml:space="preserve">
          <source>There are a lot of modules on CPAN, and it's easy to miss one that's similar to what you're planning on contributing. Have a good plough through the &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt; and make sure you're not the one reinventing the wheel!</source>
          <target state="translated">На CPAN много модулей, и легко пропустить один, похожий на тот, который вы планируете внести. Хорошо прогуляйтесь по &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt; и убедитесь, что вы не изобретаете велосипед заново!</target>
        </trans-unit>
        <trans-unit id="8202fc94e9abdf77b0bbe8e0da596aca565bfbf9" translate="yes" xml:space="preserve">
          <source>There are a number of &quot;magic&quot; scalars with names that look like punctuation or line noise. These special variables are used for all kinds of purposes, and are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. The only one you need to know about for now is &lt;code&gt;$_&lt;/code&gt; which is the &quot;default variable&quot;. It's used as the default argument to a number of functions in Perl, and it's set implicitly by certain looping constructs.</source>
          <target state="translated">Существует ряд &amp;laquo;волшебных&amp;raquo; скаляров с именами, похожими на знаки препинания или линейный шум. Эти специальные переменные используются для самых разных целей и задокументированы в &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; . Единственное, о чем вам сейчас нужно знать, это &lt;code&gt;$_&lt;/code&gt; которая является &amp;laquo;переменной по умолчанию&amp;raquo;. Он используется в качестве аргумента по умолчанию для ряда функций в Perl и неявно устанавливается определенными конструкциями цикла.</target>
        </trans-unit>
        <trans-unit id="bbba855a854345636dbf0d940dc495c0ac9b2bb4" translate="yes" xml:space="preserve">
          <source>There are a number of Unicode characters that match a sequence of multiple characters under &lt;code&gt;/i&lt;/code&gt;. For example, &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; should match the sequence &lt;code&gt;fi&lt;/code&gt;. Perl is not currently able to do this when the multiple characters are in the pattern and are split between groupings, or when one or more are quantified. Thus</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc3a0395d03ea21a961b5ccde55199ca19344c6" translate="yes" xml:space="preserve">
          <source>There are a number of Unicode characters that match multiple characters under &lt;code&gt;/i&lt;/code&gt;. For example, &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; should match the sequence &lt;code&gt;fi&lt;/code&gt; . Perl is not currently able to do this when the multiple characters are in the pattern and are split between groupings, or when one or more are quantified. Thus</source>
          <target state="translated">Есть несколько символов Unicode, которые соответствуют нескольким символам в &lt;code&gt;/i&lt;/code&gt; . Например, &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; должна соответствовать последовательности &lt;code&gt;fi&lt;/code&gt; . Perl в настоящее время не может этого сделать, если в шаблоне есть несколько символов, разделенных между группами, или когда один или несколько символов определены количественно. Таким образом</target>
        </trans-unit>
        <trans-unit id="3dd2d0257d19015791fc17037d18a20e756ba477" translate="yes" xml:space="preserve">
          <source>There are a number of escape sequences and character classes that we haven't covered yet.</source>
          <target state="translated">Есть ряд экранирующих последовательностей и классов персонажей,которые мы еще не рассмотрели.</target>
        </trans-unit>
        <trans-unit id="58e8ff088e1d138c7e62589f4caba0154e035619" translate="yes" xml:space="preserve">
          <source>There are a number of flags that can be found at the end of regular expression constructs that are</source>
          <target state="translated">В конце конструкций регулярных выражений можно найти несколько флагов,которые являются следующими</target>
        </trans-unit>
        <trans-unit id="9c8583e91f1bbf24b33308cfc971070d355cbca1" translate="yes" xml:space="preserve">
          <source>There are a number of issues with regard to case-insensitive matching in Unicode rules. See &lt;code&gt;&quot;i&quot;&lt;/code&gt; under &lt;a href=&quot;#Modifiers&quot;&gt;&quot;Modifiers&quot;&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9135b7f56d303db71c9d18be0e91860f32c7ff91" translate="yes" xml:space="preserve">
          <source>There are a number of issues with regard to case-insensitive matching in Unicode rules. See &lt;code&gt;i&lt;/code&gt; under &lt;a href=&quot;#Modifiers&quot;&gt;Modifiers&lt;/a&gt; above.</source>
          <target state="translated">Существует ряд проблем, связанных с сопоставлением без учета регистра в правилах Unicode. См. &lt;code&gt;i&lt;/code&gt; разделе &quot; &lt;a href=&quot;#Modifiers&quot;&gt;Модификаторы&quot;&lt;/a&gt; выше.</target>
        </trans-unit>
        <trans-unit id="022096dd663fb452b1d41c016ae62776dae4f673" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the NDBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="translated">Существует ряд ограничений на размер данных,которые Вы можете хранить в файле НБМ.Наиболее важным является то,что длина ключа плюс длина связанного с ним значения не должна превышать 1008 байт.</target>
        </trans-unit>
        <trans-unit id="98194cdd08210646c306ab64213d7decc3e2f871" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the ODBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d53d5198c98896d8e7795e9a89c4a433023428" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the SDBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="translated">Существует ряд ограничений на размер данных,которые можно хранить в SDBM файле.Наиболее важным является то,что длина ключа плюс длина связанного с ним значения не должна превышать 1008 байт.</target>
        </trans-unit>
        <trans-unit id="52efe033e2beba5914060b25e959b1d5bcc3adec" translate="yes" xml:space="preserve">
          <source>There are a number of modules which let you write GUIs in Perl. Most GUI toolkits have a perl interface: an incomplete list follows.</source>
          <target state="translated">Существует ряд модулей,которые позволяют писать графические интерфейсы на Perl.Большинство GUI-инструментов имеют perl-интерфейс:неполный список приведен ниже.</target>
        </trans-unit>
        <trans-unit id="7c6653dd731ed3a59a2ee9aba20887a251e28fb4" translate="yes" xml:space="preserve">
          <source>There are a number of new concepts introduced here, described below:</source>
          <target state="translated">Здесь вводится ряд новых понятий,описанных ниже:</target>
        </trans-unit>
        <trans-unit id="5042e54e451264a1c914a632ba72877f3d1fb724" translate="yes" xml:space="preserve">
          <source>There are a number of other limitations with the &lt;code&gt;Merge&lt;/code&gt; option:</source>
          <target state="translated">У опции &lt;code&gt;Merge&lt;/code&gt; есть ряд других ограничений :</target>
        </trans-unit>
        <trans-unit id="7b02972f75c4a57c97baf269f0fc3720b5f2bc53" translate="yes" xml:space="preserve">
          <source>There are a number of reasons that you might prefer &lt;code&gt;Tie::File&lt;/code&gt; . A list is available at &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вы можете предпочесть &lt;code&gt;Tie::File&lt;/code&gt; по ряду причин . Список доступен на &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13eb2afa7bef68b0d1a21f81cf96c931809f02f6" translate="yes" xml:space="preserve">
          <source>There are a number of reasons that you might prefer &lt;code&gt;Tie::File&lt;/code&gt;. A list is available at &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc49fd5fe581b9df69b9289066f92c4c1dfec1b9" translate="yes" xml:space="preserve">
          <source>There are a number of security issues with the full Unicode list of word characters. See &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt;.</source>
          <target state="translated">Есть ряд проблем безопасности с полным списком символов слова Unicode. См. &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;Http://unicode.org/reports/tr36&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="34fde0bc8e68f7eb8a6a5b8c75bef1c718f91f74" translate="yes" xml:space="preserve">
          <source>There are a number of ways to handle this sort of problem. The best way is to always have all threads acquire locks in the exact same order. If, for example, you lock variables &lt;code&gt;$x&lt;/code&gt; , &lt;code&gt;$y&lt;/code&gt; , and &lt;code&gt;$z&lt;/code&gt; , always lock &lt;code&gt;$x&lt;/code&gt; before &lt;code&gt;$y&lt;/code&gt; , and &lt;code&gt;$y&lt;/code&gt; before &lt;code&gt;$z&lt;/code&gt; . It's also best to hold on to locks for as short a period of time to minimize the risks of deadlock.</source>
          <target state="translated">Есть несколько способов справиться с подобными проблемами. Лучше всего, чтобы все потоки всегда получали блокировки в одном и том же порядке. Если, например, вы блокируете переменные &lt;code&gt;$x&lt;/code&gt; , &lt;code&gt;$y&lt;/code&gt; и &lt;code&gt;$z&lt;/code&gt; , всегда блокируйте &lt;code&gt;$x&lt;/code&gt; перед &lt;code&gt;$y&lt;/code&gt; и &lt;code&gt;$y&lt;/code&gt; перед &lt;code&gt;$z&lt;/code&gt; . Также лучше удерживать блокировки в течение короткого периода времени, чтобы минимизировать риски тупиковой ситуации.</target>
        </trans-unit>
        <trans-unit id="cb7bd877fbaa099a03520b258b73c60485273da7" translate="yes" xml:space="preserve">
          <source>There are a number of ways to handle this sort of problem. The best way is to always have all threads acquire locks in the exact same order. If, for example, you lock variables &lt;code&gt;$x&lt;/code&gt;, &lt;code&gt;$y&lt;/code&gt;, and &lt;code&gt;$z&lt;/code&gt;, always lock &lt;code&gt;$x&lt;/code&gt; before &lt;code&gt;$y&lt;/code&gt;, and &lt;code&gt;$y&lt;/code&gt; before &lt;code&gt;$z&lt;/code&gt;. It's also best to hold on to locks for as short a period of time to minimize the risks of deadlock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32c15283e2f4c6b7705b70493695500588d21f8" translate="yes" xml:space="preserve">
          <source>There are a number of ways to hide the source to your Perl programs, with varying levels of &quot;security&quot;.</source>
          <target state="translated">Есть несколько способов скрыть источник для ваших программ на Perl,с различными уровнями &quot;безопасности&quot;.</target>
        </trans-unit>
        <trans-unit id="47ea19cfdb1d50b8922388e83c50c4e47a818ebc" translate="yes" xml:space="preserve">
          <source>There are a number of ways, with varying efficiency. If you want a count of a certain single character (X) within a string, you can use the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; function like so:</source>
          <target state="translated">Есть несколько способов с разной эффективностью. Если вы хотите подсчитать определенный одиночный символ (X) в строке, вы можете использовать функцию &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="b49ba886c3971e0e735660e0bc77176d9460c20e" translate="yes" xml:space="preserve">
          <source>There are a number of ways, with varying efficiency. If you want a count of a certain single character (X) within a string, you can use the &lt;code&gt;tr///&lt;/code&gt; function like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bba5f24a6f4653ec9fc5a0573f80d18dac8d06b" translate="yes" xml:space="preserve">
          <source>There are a set of utilities which help you in developing Perl programs, and in particular, extending Perl with C.</source>
          <target state="translated">Существует набор утилит,которые помогут вам в разработке Perl программ,и в частности,в расширении Perl с помощью C.</target>
        </trans-unit>
        <trans-unit id="38b993b6e04cfcdc788f4b122babf509e8a292ac" translate="yes" xml:space="preserve">
          <source>There are a significant number of test failures in the CPAN modules shipped with Perl v5.22 and 5.24. These are only in modules not primarily maintained by Perl 5 porters. Some of these are failures in the tests only: they don't realize that it is proper to get different results on EBCDIC platforms. And some of the failures are real bugs. If you compile and do a &lt;code&gt;make test&lt;/code&gt; on Perl, all tests on the &lt;code&gt;/cpan&lt;/code&gt; directory are skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1252989edb8e8176f3bcfc5773893823daccc4" translate="yes" xml:space="preserve">
          <source>There are a significant number of test failures in the CPAN modules shipped with Perl v5.22. These are only in modules not primarily maintained by Perl 5 porters. Some of these are failures in the tests only: they don't realize that it is proper to get different results on EBCDIC platforms. And some of the failures are real bugs. If you compile and do a &lt;code&gt;make test&lt;/code&gt; on Perl, all tests on the &lt;code&gt;/cpan&lt;/code&gt; directory are skipped.</source>
          <target state="translated">В модулях CPAN, поставляемых с Perl v5.22, наблюдается значительное количество ошибок тестирования. Они есть только в модулях, которые в основном не обслуживаются переносчиками Perl 5. Некоторые из них являются ошибками только в тестах: они не понимают, что на платформах EBCDIC следует получать разные результаты. А некоторые из сбоев - настоящие ошибки. Если вы компилируете и выполняете &lt;code&gt;make test&lt;/code&gt; на Perl, все тесты в &lt;code&gt;/cpan&lt;/code&gt; пропускаются.</target>
        </trans-unit>
        <trans-unit id="9a68ba03d821b0f9ca941d8a7348ffd6b9675672" translate="yes" xml:space="preserve">
          <source>There are a variety of ways of transforming data with an intra character set mapping that serve a variety of purposes. Sorting was discussed in the previous section and a few of the other more popular mapping techniques are discussed next.</source>
          <target state="translated">Существует множество способов преобразования данных с помощью внутрисимвольного картирования,которые служат различным целям.Сортировка обсуждалась в предыдущем разделе,а несколько других,более популярных,методов картирования обсуждаются далее.</target>
        </trans-unit>
        <trans-unit id="263ac344d4080439af54082913373a451c912861" translate="yes" xml:space="preserve">
          <source>There are actually two distinct kinds of version objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c243ce02550d420fdebc8e85f18f50ac8e89a64" translate="yes" xml:space="preserve">
          <source>There are actually two varieties of null strings (sometimes referred to as &quot;empty&quot; strings), a defined one and an undefined one. The defined version is just a string of length zero, such as &lt;code&gt;&quot;&quot;&lt;/code&gt; . The undefined version is the value that indicates that there is no real value for something, such as when there was an error, or at end of file, or when you refer to an uninitialized variable or element of an array or hash. Although in early versions of Perl, an undefined scalar could become defined when first used in a place expecting a defined value, this no longer happens except for rare cases of autovivification as explained in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. You can use the defined() operator to determine whether a scalar value is defined (this has no meaning on arrays or hashes), and the undef() operator to produce an undefined value.</source>
          <target state="translated">На самом деле существует две разновидности нулевых строк (иногда называемых &amp;laquo;пустыми&amp;raquo; строками): определенная и неопределенная. Определенная версия - это просто строка нулевой длины, например &lt;code&gt;&quot;&quot;&lt;/code&gt; . Неопределенная версия - это значение, которое указывает, что для чего-либо нет реального значения, например, когда произошла ошибка, или в конце файла, или когда вы ссылаетесь на неинициализированную переменную или элемент массива или хеша. Хотя в ранних версиях Perl неопределенный скаляр мог быть определен при первом использовании в месте, где ожидалось определенное значение, этого больше не происходит, за исключением редких случаев автовивификации, как описано в &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Вы можете использовать оператор defined (), чтобы определить, определено ли скалярное значение (это не имеет значения для массивов или хэшей), и оператор undef (), чтобы создать неопределенное значение.</target>
        </trans-unit>
        <trans-unit id="fe88dd9a713bfccf6064f23560d8e8bd2b27790f" translate="yes" xml:space="preserve">
          <source>There are actually two varieties of null strings (sometimes referred to as &quot;empty&quot; strings), a defined one and an undefined one. The defined version is just a string of length zero, such as &lt;code&gt;&quot;&quot;&lt;/code&gt;. The undefined version is the value that indicates that there is no real value for something, such as when there was an error, or at end of file, or when you refer to an uninitialized variable or element of an array or hash. Although in early versions of Perl, an undefined scalar could become defined when first used in a place expecting a defined value, this no longer happens except for rare cases of autovivification as explained in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. You can use the defined() operator to determine whether a scalar value is defined (this has no meaning on arrays or hashes), and the undef() operator to produce an undefined value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="547f74aebc059a529676c6646c9bed2946a0409e" translate="yes" xml:space="preserve">
          <source>There are additional macros whose values may be bitwise OR'ed with the &lt;code&gt;GV_ADD&lt;/code&gt; argument to enable certain extra features. Those bits are:</source>
          <target state="translated">Существуют дополнительные макросы, значения которых можно объединить с помощью побитового ИЛИ с аргументом &lt;code&gt;GV_ADD&lt;/code&gt; , чтобы включить определенные дополнительные функции. Вот эти биты:</target>
        </trans-unit>
        <trans-unit id="7a746509c86dffe25d4594a4b2c6a264d173eb5e" translate="yes" xml:space="preserve">
          <source>There are additional methods for regular expression patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51046d0ad7a7252d1ce87aabe4027ffe3663a57e" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;Win32::IsWinNT()&lt;/code&gt; and &lt;code&gt;Win32::IsWin95()&lt;/code&gt; ; try &lt;code&gt;perldoc Win32&lt;/code&gt; , and as of libwin32 0.19 (not part of the core Perl distribution) &lt;code&gt;Win32::GetOSName()&lt;/code&gt; . The very portable &lt;code&gt;POSIX::uname()&lt;/code&gt; will work too:</source>
          <target state="translated">Также существуют &lt;code&gt;Win32::IsWinNT()&lt;/code&gt; и &lt;code&gt;Win32::IsWin95()&lt;/code&gt; ; попробуйте &lt;code&gt;perldoc Win32&lt;/code&gt; , а начиная с libwin32 0.19 (не входит в основной дистрибутив Perl) &lt;code&gt;Win32::GetOSName()&lt;/code&gt; . Переносимый &lt;code&gt;POSIX::uname()&lt;/code&gt; тоже будет работать:</target>
        </trans-unit>
        <trans-unit id="a575561f3064d05553d9a3fbf390d2ed1e96d270" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;Win32::IsWinNT()|Win32/Win32::IsWinNT()&lt;/code&gt;, &lt;code&gt;Win32::IsWin95()|Win32/Win32::IsWin95()&lt;/code&gt;, and &lt;a href=&quot;win32#Win32%3A%3AGetOSName%28%29&quot;&gt;&lt;code&gt;Win32::GetOSName()&lt;/code&gt;&lt;/a&gt;; try &lt;a href=&quot;win32&quot;&gt;&lt;code&gt;perldoc Win32&lt;/code&gt;&lt;/a&gt;. The very portable &lt;a href=&quot;posix#uname&quot;&gt;&lt;code&gt;POSIX::uname()&lt;/code&gt;&lt;/a&gt; will work too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e848855fa991c061ba1b0f19b935d8e48a52c00" translate="yes" xml:space="preserve">
          <source>There are also a variety of other special-purpose macros which save particular types or values of interest. &lt;code&gt;SAVETMPS&lt;/code&gt; has already been mentioned above. Others include &lt;code&gt;SAVEFREEPV&lt;/code&gt; which arranges for a PV (i.e. a string buffer) to be freed, or &lt;code&gt;SAVEDESTRUCTOR&lt;/code&gt; which arranges for a given function pointer to be invoked on scope exit. A full list of such macros can be found in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23127dab9bc88fbefc66139b670c575d072a34d4" translate="yes" xml:space="preserve">
          <source>There are also certain operations that are illegal. You can't nest &lt;code&gt;\p{...}&lt;/code&gt; and &lt;code&gt;\P{...}&lt;/code&gt; calls within a wildcard subpattern, and &lt;code&gt;\G&lt;/code&gt; doesn't make sense, so is also prohibited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68cc104cb95d94223dc9fddad7fb75cbcb044f6c" translate="yes" xml:space="preserve">
          <source>There are also endless possibilities to use</source>
          <target state="translated">Есть также бесконечные возможности использования</target>
        </trans-unit>
        <trans-unit id="d8a2e4b90dc5ccc934f88be56fb54a760d42a1e5" translate="yes" xml:space="preserve">
          <source>There are also layers which actually just set flags on lower layers, or layers that modify the current stack but don't persist on the stack themselves; these are referred to as pseudo-layers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323189fd57b85b2e190ea90f3e9bb682b3b9f2e0" translate="yes" xml:space="preserve">
          <source>There are also plenty of Perl related newsgroups located under &lt;code&gt;comp.lang.perl.*&lt;/code&gt; .</source>
          <target state="translated">Есть также множество связанных с Perl групп новостей, расположенных в &lt;code&gt;comp.lang.perl.*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="527d1ab1f5f5398fbabcd044390ef4e42b5f0b60" translate="yes" xml:space="preserve">
          <source>There are also some commercial products that may work for you, although you have to buy a license for them.</source>
          <target state="translated">Есть также некоторые коммерческие продукты,которые могут работать на вас,хотя вы должны купить лицензию на них.</target>
        </trans-unit>
        <trans-unit id="8875c64205867a602cf00ce82127ede7aefa737d" translate="yes" xml:space="preserve">
          <source>There are also some commonly used modules for the task. &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt; (distributed with 5.8) provides access to perl's internal function &lt;code&gt;looks_like_number&lt;/code&gt; for determining whether a variable looks like a number. &lt;a href=&quot;Data::Types&quot;&gt;Data::Types&lt;/a&gt; exports functions that validate data types using both the above and other regular expressions. Thirdly, there is &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; which has regular expressions to match various types of numbers. Those three modules are available from the CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ce59232e232d36fa4b243d9439f11e909759d7" translate="yes" xml:space="preserve">
          <source>There are also some commonly used modules for the task. &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; (distributed with 5.8) provides access to perl's internal function &lt;code&gt;looks_like_number&lt;/code&gt; for determining whether a variable looks like a number. &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Types&quot;&gt;Data::Types&lt;/a&gt; exports functions that validate data types using both the above and other regular expressions. Thirdly, there is &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; which has regular expressions to match various types of numbers. Those three modules are available from the CPAN.</source>
          <target state="translated">Также есть несколько часто используемых модулей для этой задачи. &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; (распространяется с 5.8) обеспечивает доступ к внутренней функции perl &lt;code&gt;looks_like_number&lt;/code&gt; для определения того, выглядит ли переменная как число. &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Types&quot;&gt;Data :: Types&lt;/a&gt; экспортирует функции, которые проверяют типы данных, используя как указанные выше, так и другие регулярные выражения. В-третьих, есть &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common, в&lt;/a&gt; котором есть регулярные выражения для сопоставления различных типов чисел. Эти три модуля доступны на CPAN.</target>
        </trans-unit>
        <trans-unit id="b1ee19a63035c233ed5685ff1e3a13cd9e4a26d4" translate="yes" xml:space="preserve">
          <source>There are also some other op types: a &lt;code&gt;PMOP&lt;/code&gt; holds a regular expression, and has no children, and a &lt;code&gt;LOOP&lt;/code&gt; may or may not have children. If the &lt;code&gt;op_children&lt;/code&gt; field is non-zero, it behaves like a &lt;code&gt;LISTOP&lt;/code&gt; . To complicate matters, if a &lt;code&gt;UNOP&lt;/code&gt; is actually a &lt;code&gt;null&lt;/code&gt; op after optimization (see &lt;a href=&quot;#Compile-pass-2%3a-context-propagation&quot;&gt;Compile pass 2: context propagation&lt;/a&gt;) it will still have children in accordance with its former type.</source>
          <target state="translated">Есть также некоторые другие типы &lt;code&gt;PMOP&lt;/code&gt; : PMOP содержит регулярное выражение и не имеет дочерних элементов , а &lt;code&gt;LOOP&lt;/code&gt; может иметь или не иметь дочерних элементов . Если поле &lt;code&gt;op_children&lt;/code&gt; не равно нулю, оно ведет себя как &lt;code&gt;LISTOP&lt;/code&gt; . Чтобы усложнить ситуацию, если &lt;code&gt;UNOP&lt;/code&gt; фактически является &lt;code&gt;null&lt;/code&gt; операцией после оптимизации (см. Этап &lt;a href=&quot;#Compile-pass-2%3a-context-propagation&quot;&gt;компиляции 2: распространение контекста&lt;/a&gt; ), он все равно будет иметь дочерние элементы в соответствии с его прежним типом.</target>
        </trans-unit>
        <trans-unit id="11f74fbe23dd4e59c95a6d0f147c6383a5a62308" translate="yes" xml:space="preserve">
          <source>There are also some other op types: a &lt;code&gt;PMOP&lt;/code&gt; holds a regular expression, and has no children, and a &lt;code&gt;LOOP&lt;/code&gt; may or may not have children. If the &lt;code&gt;op_children&lt;/code&gt; field is non-zero, it behaves like a &lt;code&gt;LISTOP&lt;/code&gt;. To complicate matters, if a &lt;code&gt;UNOP&lt;/code&gt; is actually a &lt;code&gt;null&lt;/code&gt; op after optimization (see &lt;a href=&quot;#Compile-pass-2%3A-context-propagation&quot;&gt;&quot;Compile pass 2: context propagation&quot;&lt;/a&gt;) it will still have children in accordance with its former type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d74afa3e57d8bf587dddccd05e8aa225e3034ba7" translate="yes" xml:space="preserve">
          <source>There are also some tricks that you can play with &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; and the accumulator variable &lt;code&gt;$^A&lt;/code&gt; , but you lose a lot of the value of formats since &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; won't handle paging and so on. You end up reimplementing formats when you use them.</source>
          <target state="translated">Есть также некоторые уловки, с которыми вы можете поиграть с &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; и переменной аккумулятора &lt;code&gt;$^A&lt;/code&gt; , но вы потеряете большую часть значения форматов, поскольку &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; не будет обрабатывать разбиение на страницы и так далее. Вы в конечном итоге повторно реализуете форматы, когда используете их.</target>
        </trans-unit>
        <trans-unit id="4d45adb6b43e1a59ad871510a945d0116f3df08b" translate="yes" xml:space="preserve">
          <source>There are also some tricks that you can play with &lt;code&gt;formline&lt;/code&gt; and the accumulator variable &lt;code&gt;$^A&lt;/code&gt;, but you lose a lot of the value of formats since &lt;code&gt;formline&lt;/code&gt; won't handle paging and so on. You end up reimplementing formats when you use them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a607b0a4fc3c7e1671b30a3b355e931c22fa4ed" translate="yes" xml:space="preserve">
          <source>There are also the two values &lt;code&gt;PL_sv_yes&lt;/code&gt; and &lt;code&gt;PL_sv_no&lt;/code&gt; , which contain boolean TRUE and FALSE values, respectively. Like &lt;code&gt;PL_sv_undef&lt;/code&gt; , their addresses can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed.</source>
          <target state="translated">Также есть два значения &lt;code&gt;PL_sv_yes&lt;/code&gt; и &lt;code&gt;PL_sv_no&lt;/code&gt; , которые содержат логические значения TRUE и FALSE соответственно. Как и &lt;code&gt;PL_sv_undef&lt;/code&gt; , их адреса могут использоваться всякий раз, когда требуется &lt;code&gt;SV*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bada6ac2c7944b1149547067859a10dc227a309f" translate="yes" xml:space="preserve">
          <source>There are also the two values &lt;code&gt;PL_sv_yes&lt;/code&gt; and &lt;code&gt;PL_sv_no&lt;/code&gt;, which contain boolean TRUE and FALSE values, respectively. Like &lt;code&gt;PL_sv_undef&lt;/code&gt;, their addresses can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9975f54ba4b1444b192c3d8bfd7d71c13ebdbb" translate="yes" xml:space="preserve">
          <source>There are also versions of the functions with &quot;_hex&quot; or &quot;_base64&quot; appended to the name, which returns the digest in the indicated form.</source>
          <target state="translated">Существуют также версии функций с приложением &quot;_hex&quot; или &quot;_base64&quot; к названию,которые возвращают дайджест в указанном виде.</target>
        </trans-unit>
        <trans-unit id="a5a4f4a9450ec80ee122e2031504c8884d21e28d" translate="yes" xml:space="preserve">
          <source>There are at least two instance variables stored in a hash reference, {data} and {encoding}.</source>
          <target state="translated">В ссылке на хэш хранятся как минимум две переменные экземпляра,{данные}и {кодировка}.</target>
        </trans-unit>
        <trans-unit id="68682d3f996c5d0d4c5e2cf0ab83889b2edb3594" translate="yes" xml:space="preserve">
          <source>There are cases when you will not know beforehand how many tests your script is going to run. In this case, you can declare your tests at the end.</source>
          <target state="translated">Бывают случаи,когда вы не знаете заранее,сколько тестов будет запущено вашим скриптом.В этом случае вы можете объявить свои тесты в конце.</target>
        </trans-unit>
        <trans-unit id="13a4d162b9b64ac9d632dbabef83e1cc311a2290" translate="yes" xml:space="preserve">
          <source>There are certain application spaces which are already very, very well served by CPAN. One example is templating systems, another is date and time modules, and there are many more. While it is a rite of passage to write your own version of these things, please consider carefully whether the Perl world really needs you to publish it.</source>
          <target state="translated">Существуют определенные области применения,которые уже очень и очень хорошо обслуживаются CPAN.Одним из примеров являются системы шаблонов,другим-модули даты и времени,а их намного больше.Хотя это обряд посвящения в написание собственной версии этих вещей,пожалуйста,внимательно подумайте,действительно ли мир Perl нуждается в том,чтобы вы его опубликовали.</target>
        </trans-unit>
        <trans-unit id="6418df0a423a65fdef15c0f2ab1cbad9a1e3cda6" translate="yes" xml:space="preserve">
          <source>There are certain properties that wildcard subpatterns don't currently work with. These are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f399d82ea760be3c44c0c12193de98d98ca6c0b6" translate="yes" xml:space="preserve">
          <source>There are corresponding one-letter commands &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; for each of the four categories and another, &lt;code&gt;i&lt;/code&gt; for any of the mentioned four. Each of the four entities is implemented as a class with slightly differing methods for displaying an object.</source>
          <target state="translated">Существуют соответствующие однобуквенные команды &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; для каждой из четырех категорий и еще одна, &lt;code&gt;i&lt;/code&gt; для любой из упомянутых четырех. Каждая из четырех сущностей реализована как класс с немного разными методами отображения объекта.</target>
        </trans-unit>
        <trans-unit id="61165542c376ce1515ee946fb54e0b62bf506b50" translate="yes" xml:space="preserve">
          <source>There are currently three implementations:</source>
          <target state="translated">В настоящее время есть три реализации:</target>
        </trans-unit>
        <trans-unit id="97e0702d9f24205eb392b550bdee3cc7f1886fbc" translate="yes" xml:space="preserve">
          <source>There are currently two implementations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb1fef3dafc65f2dd5f6f03815febb7cc02429e1" translate="yes" xml:space="preserve">
          <source>There are different classes in the &lt;a href=&quot;Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; namespace for supporting various mailbox types. Note that these modules are generally rather limited and only support &lt;b&gt;reading&lt;/b&gt; rather than writing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7082baef78129948a9aee04418c7c10c1b4d4a87" translate="yes" xml:space="preserve">
          <source>There are different classes in the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; namespace for supporting various mailbox types. Note that these modules are generally rather limited and only support &lt;b&gt;reading&lt;/b&gt; rather than writing.</source>
          <target state="translated">В пространстве имен &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email :: Folder&lt;/a&gt; существуют разные классы для поддержки различных типов почтовых ящиков. Обратите внимание, что эти модули, как правило, довольно ограничены и поддерживают только &lt;b&gt;чтение,&lt;/b&gt; а не запись.</target>
        </trans-unit>
        <trans-unit id="7ffae46f4361bbc29cee623ab319bb8483adbbdb" translate="yes" xml:space="preserve">
          <source>There are exceptions to the above rules for dereference operations (which, if Step 1 fails, always fall back to the normal, built-in implementations - see Dereferencing), and for &lt;code&gt;~~&lt;/code&gt; (which has its own set of rules - see &lt;code&gt;Matching&lt;/code&gt; under &lt;a href=&quot;#Overloadable-Operations&quot;&gt;&quot;Overloadable Operations&quot;&lt;/a&gt; above).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed85d6fa9e5690e5659a7fcf3cc7c90a6a9abc89" translate="yes" xml:space="preserve">
          <source>There are exceptions to the above rules for dereference operations (which, if Step 1 fails, always fall back to the normal, built-in implementations - see Dereferencing), and for &lt;code&gt;~~&lt;/code&gt; (which has its own set of rules - see &lt;code&gt;Matching&lt;/code&gt; under &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; above).</source>
          <target state="translated">Существуют исключения из приведенных выше правил для операций разыменования (которые в случае сбоя на этапе 1 всегда возвращаются к обычным встроенным реализациям - см. Разыменование) и для &lt;code&gt;~~&lt;/code&gt; (который имеет свой собственный набор правил - см. &lt;code&gt;Matching&lt;/code&gt; разделе &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Перегрузочные операции&lt;/a&gt; выше).</target>
        </trans-unit>
        <trans-unit id="129afe5f5ce43c82f8dd2611661b6c6fae2152e8" translate="yes" xml:space="preserve">
          <source>There are exceptions to the simple scalar maps. Some properties have some elements in their map list that are themselves lists of scalars; and some special strings are returned that are not to be interpreted as-is. Element [2] (placed into &lt;code&gt;$format&lt;/code&gt; in the example above) of the returned four element list tells you if the map has any of these special elements or not, as follows:</source>
          <target state="translated">Есть исключения из простых скалярных карт. Некоторые свойства имеют в своем списке карт некоторые элементы, которые сами являются списками скаляров; и возвращаются некоторые специальные строки, которые не следует интерпретировать как есть. Элемент [2] (помещенный в &lt;code&gt;$format&lt;/code&gt; в приведенном выше примере) возвращенного списка из четырех элементов сообщает вам, есть ли на карте какие-либо из этих специальных элементов или нет, следующим образом:</target>
        </trans-unit>
        <trans-unit id="03da32e2f08e4c55ca723ef0de464a8b0fc8a37a" translate="yes" xml:space="preserve">
          <source>There are five pattern matching operations other than a strict one-to-one match between the pattern and the source to be checked for a match.</source>
          <target state="translated">Существует пять операций по совпадению шаблонов,кроме строгой проверки на соответствие между шаблоном и источником.</target>
        </trans-unit>
        <trans-unit id="caaaee4619b1124c4cd083d4f94b5aeee43dd52b" translate="yes" xml:space="preserve">
          <source>There are four arguments:</source>
          <target state="translated">Есть четыре аргумента:</target>
        </trans-unit>
        <trans-unit id="c30d8b75df6d6d560de84db459ba9ddeaac5bfd4" translate="yes" xml:space="preserve">
          <source>There are four methods associated with DBM Filters. All work identically, and each is used to install (or uninstall) a single DBM Filter. Each expects a single parameter, namely a reference to a sub. The only difference between them is the place that the filter is installed.</source>
          <target state="translated">Существует четыре метода,связанных с фильтрами DBM.Все они работают одинаково,и каждый из них используется для установки (или удаления)одного фильтра DBM.Каждый из них ожидает один параметр,а именно,ссылку на подфайл.Единственное различие между ними-место установки фильтра.</target>
        </trans-unit>
        <trans-unit id="2b4786fe13177802911e40046450c4aa8a6b7442" translate="yes" xml:space="preserve">
          <source>There are four routines that can be used to call a Perl subroutine from within a C program. These four are:</source>
          <target state="translated">Есть четыре подпрограммы,которые могут быть использованы для вызова подпрограмм на Perl из программы на C.Эти четыре:</target>
        </trans-unit>
        <trans-unit id="0b4c3b4907f361ea335c94a68bf5900b38774c4c" translate="yes" xml:space="preserve">
          <source>There are just two ways to make a reference, and just two ways to use it once you have it.</source>
          <target state="translated">Есть только два способа сделать ссылку,и только два способа использовать ее,как только она у вас есть.</target>
        </trans-unit>
        <trans-unit id="451300c3402db478bc017d97504bbf1dc7589d4f" translate="yes" xml:space="preserve">
          <source>There are literally dozens of other OO-related modules on CPAN besides those covered here, and you're likely to run across one or more of them if you work with other people's code.</source>
          <target state="translated">Есть буквально десятки других модулей,связанных с OO на CPAN,кроме тех,которые описаны здесь,и вы,вероятно,столкнетесь с одним или несколькими из них,если будете работать с чужим кодом.</target>
        </trans-unit>
        <trans-unit id="6c77d5c24285fecf2b82ebf41d5dec81876d45b0" translate="yes" xml:space="preserve">
          <source>There are lots more commands and options, but the above will do it.</source>
          <target state="translated">Команд и опций гораздо больше,но вышеприведенные команды и опции это сделают.</target>
        </trans-unit>
        <trans-unit id="837d89ccfb96f196a244bf30256b711d40a975e1" translate="yes" xml:space="preserve">
          <source>There are many Perl &lt;a href=&quot;http://search.cpan.org/perldoc/lists.perl.org&quot;&gt;mailing lists&lt;/a&gt; for various topics, specifically the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flists.perl.org%2flist%2fbeginners.html&quot;&gt;beginners list&lt;/a&gt; may be of use.</source>
          <target state="translated">Существует множество &lt;a href=&quot;http://search.cpan.org/perldoc/lists.perl.org&quot;&gt;списков рассылки&lt;/a&gt; Perl по разным темам, в частности, может пригодиться &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flists.perl.org%2flist%2fbeginners.html&quot;&gt;список для новичков&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c100a4e2353b8e1e3f993e428fe4246a2ed1c1dd" translate="yes" xml:space="preserve">
          <source>There are many Perl &lt;a href=&quot;lists.perl.org&quot;&gt;mailing lists&lt;/a&gt; for various topics, specifically the &lt;a href=&quot;http://lists.perl.org/list/beginners.html&quot;&gt;beginners list&lt;/a&gt; may be of use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bec5519f33a4e7bdc4a53a2313d4e1bcfcd1067" translate="yes" xml:space="preserve">
          <source>There are many books on Perl and Perl-related. A few of these are good, some are OK, but many aren't worth your money. There is a list of these books, some with extensive reviews, at &lt;a href=&quot;http://books.perl.org/&quot;&gt;http://books.perl.org/&lt;/a&gt; . We list some of the books here, and while listing a book implies our endorsement, don't think that not including a book means anything.</source>
          <target state="translated">Есть много книг по Perl и связанным с ним. Некоторые из них хороши, некоторые - в порядке, но многие не стоят ваших денег. Список этих книг, некоторые с обширными обзорами, можно найти на &lt;a href=&quot;http://books.perl.org/&quot;&gt;http://books.perl.org/&lt;/a&gt; . Мы перечисляем некоторые книги здесь, и, хотя перечисление книги подразумевает нашу поддержку, не думайте, что отсутствие книги ничего не значит.</target>
        </trans-unit>
        <trans-unit id="c4e51ecd675e07ca3b7be0664408ec108e37de71" translate="yes" xml:space="preserve">
          <source>There are many different ftp firewall products available. But unfortunately there is no standard for how to traverse a firewall. The list below shows the sequence of commands that Net::FTP will use</source>
          <target state="translated">Существует множество различных ftp продуктов брандмауэра.Но,к сожалению,нет стандарта,как пройти через брандмауэр.В списке ниже показана последовательность команд,которые будут использовать Net::FTP</target>
        </trans-unit>
        <trans-unit id="ccca22cadfc5874b657dd6b896d963adc193de41" translate="yes" xml:space="preserve">
          <source>There are many good &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fbooks%2flibrary.html&quot;&gt;books on Perl&lt;/a&gt;.</source>
          <target state="translated">По &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fbooks%2flibrary.html&quot;&gt;Perl&lt;/a&gt; есть много хороших книг .</target>
        </trans-unit>
        <trans-unit id="25f8cf87f8d0d010ba0c130a03c0c733508760a7" translate="yes" xml:space="preserve">
          <source>There are many good &lt;a href=&quot;http://www.perl.org/books/library.html&quot;&gt;books on Perl&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c010c4c2e46af9e1a3df8426bb24c3742b96b7" translate="yes" xml:space="preserve">
          <source>There are many more properties than the very basic ones described here. A complete list is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">Есть намного больше свойств, чем самые простые, описанные здесь. Полный список находится в &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a8e433d3ac89e153ddbae16288b146a2a506dab" translate="yes" xml:space="preserve">
          <source>There are many other functions available since FileHandle is descended from IO::File, IO::Seekable, and IO::Handle. Please see those respective pages for documentation on more functions.</source>
          <target state="translated">Существует множество других функций,поскольку FileHandle происходит от IO::File,IO::Seekable и IO::Handle.Пожалуйста,ознакомьтесь с соответствующими страницами для получения документации по другим функциям.</target>
        </trans-unit>
        <trans-unit id="19b014b8d66d3b187e540a67f34591fd12721782" translate="yes" xml:space="preserve">
          <source>There are many reasons, but the major one is cross-platform compatibility.</source>
          <target state="translated">Есть много причин,но главная из них-кросс-платформенная совместимость.</target>
        </trans-unit>
        <trans-unit id="ec8353eb61918c8ea09b548fd2c7481452870299" translate="yes" xml:space="preserve">
          <source>There are many ways to ensure that values are what you expect or want to accept. Besides the specific examples that we cover in the perlfaq, you can also look at the modules with &quot;Assert&quot; and &quot;Validate&quot; in their names, along with other modules such as &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f22a618b10f083a38eaf97d7560bbf775ba04c7" translate="yes" xml:space="preserve">
          <source>There are many ways to ensure that values are what you expect or want to accept. Besides the specific examples that we cover in the perlfaq, you can also look at the modules with &quot;Assert&quot; and &quot;Validate&quot; in their names, along with other modules such as &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt;.</source>
          <target state="translated">Есть много способов убедиться, что ценности соответствуют вашим ожиданиям или желаниям. Помимо конкретных примеров, которые мы рассмотрим в perlfaq, вы также можете посмотреть модули, в именах которых есть &amp;laquo;Assert&amp;raquo; и &amp;laquo;Validate&amp;raquo;, а также другие модули, такие как &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c508352f954b14145337f34025470ea842ef7b40" translate="yes" xml:space="preserve">
          <source>There are many ways to get multiline data into a string. If you want it to happen automatically while reading input, you'll want to set $/ (probably to '' for paragraphs or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for the whole file) to allow you to read more than one line at a time.</source>
          <target state="translated">Есть много способов превратить многострочные данные в строку. Если вы хотите, чтобы это происходило автоматически при чтении ввода, вам нужно установить $ / (возможно, в &amp;laquo;&amp;raquo; для абзацев или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; для всего файла), чтобы вы могли читать более одной строки за раз.</target>
        </trans-unit>
        <trans-unit id="d0c13e2ae1a5d488cf21f540ff8605d82939bccd" translate="yes" xml:space="preserve">
          <source>There are many ways to get multiline data into a string. If you want it to happen automatically while reading input, you'll want to set $/ (probably to '' for paragraphs or &lt;code&gt;undef&lt;/code&gt; for the whole file) to allow you to read more than one line at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc3f3b5eae147e801f5f43fb6a8fbac0ae189bf" translate="yes" xml:space="preserve">
          <source>There are many, many Unicode character properties. For the full list see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. Most of them have synonyms with shorter names, also listed there. Some synonyms are a single character. For these, you can drop the braces. For instance, &lt;code&gt;\pM&lt;/code&gt; is the same thing as &lt;code&gt;\p{Mark}&lt;/code&gt; , meaning things like accent marks.</source>
          <target state="translated">Есть очень много свойств символов Юникода. Полный список см. В &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt; . У большинства из них есть синонимы с более короткими названиями, также перечисленные там. Некоторые синонимы представляют собой один символ. Для них вы можете сбросить скобы. Например, &lt;code&gt;\pM&lt;/code&gt; - это то же самое, что &lt;code&gt;\p{Mark}&lt;/code&gt; , что означает такие вещи, как знаки ударения.</target>
        </trans-unit>
        <trans-unit id="69da32a8fafef027c405b2092d6a66a08f07e5a2" translate="yes" xml:space="preserve">
          <source>There are many, many Unicode character properties. For the full list see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. Most of them have synonyms with shorter names, also listed there. Some synonyms are a single character. For these, you can drop the braces. For instance, &lt;code&gt;\pM&lt;/code&gt; is the same thing as &lt;code&gt;\p{Mark}&lt;/code&gt;, meaning things like accent marks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a61fc5e0ce0e0ef09d3d9c85a06d1ddbe46e285" translate="yes" xml:space="preserve">
          <source>There are many, many code points, but computers work with bytes, and a byte has room for only 256 values. Unicode has many more characters than that, so you need a method to make these accessible.</source>
          <target state="translated">Есть много,много точек кода,но компьютеры работают с байтами,а байт имеет место только для 256 значений.Юникод имеет гораздо больше символов,чем это,поэтому вам нужен метод,чтобы сделать их доступными.</target>
        </trans-unit>
        <trans-unit id="88acdd96ec6d6927c08fab60ea3227280069d628" translate="yes" xml:space="preserve">
          <source>There are many, many sources for Solaris information. A few of the important ones for perl:</source>
          <target state="translated">Есть много,много источников информации о Солярисе.Несколько важных для perl:</target>
        </trans-unit>
        <trans-unit id="83467e96db886b15aa3db22c9e9e4b034057eea3" translate="yes" xml:space="preserve">
          <source>There are modules to help you through the process of writing a module: &lt;a href=&quot;ExtUtils::ModuleMaker&quot;&gt;ExtUtils::ModuleMaker&lt;/a&gt;, &lt;a href=&quot;Module::Starter&quot;&gt;Module::Starter&lt;/a&gt;, &lt;a href=&quot;Minilla::Tutorial&quot;&gt;Minilla::Tutorial&lt;/a&gt;, &lt;a href=&quot;Dist::Milla::Tutorial&quot;&gt;Dist::Milla::Tutorial&lt;/a&gt;, &lt;a href=&quot;Dist::Zilla::Starter&quot;&gt;Dist::Zilla::Starter&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f4eee710987379a0f55c604a3354e69d7b2875" translate="yes" xml:space="preserve">
          <source>There are modules to help you through the process of writing a module: &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::ModuleMaker&quot;&gt;ExtUtils::ModuleMaker&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Install&quot;&gt;Module::Install&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;</source>
          <target state="translated">Существуют модули, которые помогут вам в процессе написания модуля: &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::ModuleMaker&quot;&gt;ExtUtils :: ModuleMaker&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Install&quot;&gt;Module :: Install&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da29172199b45020f43775089b9830c405a497fb" translate="yes" xml:space="preserve">
          <source>There are no deprecations or fatalizations scheduled for Perl 5.34.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d4491371efc2ca44fd016e5d9139fc5fa773fa" translate="yes" xml:space="preserve">
          <source>There are no loops of references.</source>
          <target state="translated">Нет никаких циклов ссылок.</target>
        </trans-unit>
        <trans-unit id="476c776008d55428fe7585fbd0c3dce927c522c4" translate="yes" xml:space="preserve">
          <source>There are no unique methods for unknown results.</source>
          <target state="translated">Нет уникальных методов для неизвестных результатов.</target>
        </trans-unit>
        <trans-unit id="b571d2027807fc8b9e77b0de9129097419041bc0" translate="yes" xml:space="preserve">
          <source>There are non-obvious Unicode rules under &lt;code&gt;/i&lt;/code&gt; that can match variably, but which you might not think could. For example, the substring &lt;code&gt;&quot;ss&quot;&lt;/code&gt; can match the single character LATIN SMALL LETTER SHARP S. There are other sequences of ASCII characters that can match single ligature characters, such as LATIN SMALL LIGATURE FFI matching &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/ffi/i&lt;/a&gt;&lt;/code&gt;. Starting in Perl v5.16, if you only care about ASCII matches, adding the &lt;code&gt;/aa&lt;/code&gt; modifier to the regex will exclude all these non-obvious matches, thus getting rid of this message. You can also say &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re qw(/aa)&lt;/code&gt; to apply &lt;code&gt;/aa&lt;/code&gt; to all regular expressions compiled within its scope. See &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;.</source>
          <target state="translated">В разделе &lt;code&gt;/i&lt;/code&gt; есть неочевидные правила Unicode, которые могут варьироваться, но о которых вы могли не подумать. Например, подстрока &lt;code&gt;&quot;ss&quot;&lt;/code&gt; может соответствовать одиночному символу LATIN SMALL LETTER SHARP S. Существуют и другие последовательности символов ASCII, которые могут соответствовать одиночным символам лигатуры, такие как LATIN SMALL LIGATURE FFI, соответствующие &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/ffi/i&lt;/a&gt;&lt;/code&gt; . Начиная с Perl v5.16, если вас интересуют только соответствия ASCII, добавление модификатора &lt;code&gt;/aa&lt;/code&gt; к регулярному выражению исключит все эти неочевидные совпадения, тем самым избавившись от этого сообщения. Вы также можете сказать, что &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re qw(/aa)&lt;/code&gt; чтобы применить &lt;code&gt;/aa&lt;/code&gt; ко всем регулярным выражениям, скомпилированным в его области. См. &lt;a href=&quot;re&quot;&gt;Re&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e5ad264a4513834556a80639fe98434e6bc7fc63" translate="yes" xml:space="preserve">
          <source>There are now two nested loops in the code: the outer loop for reading the compressed data from STDIN, as before; and the inner loop to carry out the uncompression.</source>
          <target state="translated">Теперь в коде есть два вложенных цикла:внешний цикл для считывания сжатых данных из STDIN,как и раньше;и внутренний цикл для выполнения несжатия.</target>
        </trans-unit>
        <trans-unit id="30d7f3a596ae687e7d1a74baf88a83df7d754b06" translate="yes" xml:space="preserve">
          <source>There are only a few attributes currently handled by Perl itself (or directly by this module, depending on how you look at it.) However, package-specific attributes are allowed by an extension mechanism. (See &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;&quot;Package-specific Attribute Handling&quot;&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a69e0c87595733580f5c73f14c1fdeb5543877d6" translate="yes" xml:space="preserve">
          <source>There are only a few attributes currently handled by Perl itself (or directly by this module, depending on how you look at it.) However, package-specific attributes are allowed by an extension mechanism. (See &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;Package-specific Attribute Handling&lt;/a&gt; below.)</source>
          <target state="translated">Есть только несколько атрибутов, которые в настоящее время обрабатываются самим Perl (или непосредственно этим модулем, в зависимости от того, как вы на него смотрите). Однако специфические для пакета атрибуты разрешены механизмом расширения. (См. Раздел &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;Обработка атрибутов для конкретного пакета&lt;/a&gt; ниже.)</target>
        </trans-unit>
        <trans-unit id="108ccf06b73794e0f286d42a6259562039de6c36" translate="yes" xml:space="preserve">
          <source>There are other documents which might contain the information that you're looking for:</source>
          <target state="translated">Есть и другие документы,которые могут содержать информацию,которую вы ищете:</target>
        </trans-unit>
        <trans-unit id="ffadbd86efea8ed0c7e9318ac1bd6a93e63feaa1" translate="yes" xml:space="preserve">
          <source>There are other minor differences, particularly regarding &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but in general, the correspondence is extremely close.</source>
          <target state="translated">Есть и другие незначительные отличия, в частности, касающиеся &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; , но в целом соответствие очень тесное.</target>
        </trans-unit>
        <trans-unit id="496c73a8b66b8bb32b2aaf26def98246996ff9e4" translate="yes" xml:space="preserve">
          <source>There are other minor differences, particularly regarding &lt;code&gt;exists&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, but in general, the correspondence is extremely close.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7bb3958077e624c5300c166b4aa5d1f00cfb6ff" translate="yes" xml:space="preserve">
          <source>There are other runtime options as well. You can use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Есть и другие варианты исполнения. Вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1c3cf0f599cf582932d460a014aeed655f3e2812" translate="yes" xml:space="preserve">
          <source>There are other runtime options as well. You can use &lt;code&gt;pack()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae6e762f25c5a7d9726dbb80f1e49251722d367" translate="yes" xml:space="preserve">
          <source>There are platforms where longs are 64 bits, and platforms where ints are 64 bits, and while we are out to shock you, even platforms where shorts are 64 bits. This is all legal according to the C standard. (In other words, &quot;long long&quot; is not a portable way to specify 64 bits, and &quot;long long&quot; is not even guaranteed to be any wider than &quot;long&quot;.)</source>
          <target state="translated">Есть платформы,где длины составляют 64 бита,и платформы,где дюймы-64 бита,и пока мы хотим шокировать вас,даже платформы,где шорты-64 бита.Все это легально в соответствии со стандартом C.(Другими словами,&quot;long long&quot; не является переносным способом указания 64 бит,а &quot;long long long&quot; даже не гарантированно будет шире &quot;long&quot;).</target>
        </trans-unit>
        <trans-unit id="a1d48b6e5e54bf5c7c0f9c8f92bbb4b843c99efe" translate="yes" xml:space="preserve">
          <source>There are probably many more bugs on non-ASCII platforms (EBCDIC).</source>
          <target state="translated">Вероятно,существует гораздо больше ошибок на не-ASCII платформах (EBCDIC).</target>
        </trans-unit>
        <trans-unit id="6034cbb411ab9fcf9d496b60426633cf7c795bb5" translate="yes" xml:space="preserve">
          <source>There are quite a few systems out there that do worse!</source>
          <target state="translated">Есть много систем,которые делают хуже!</target>
        </trans-unit>
        <trans-unit id="1d2d754395a1d1b23e17d21c745bf8aafd6b351f" translate="yes" xml:space="preserve">
          <source>There are rare cases where this package-based resolution can be a problem. If you copy a subroutine from one package to another, &lt;code&gt;SUPER&lt;/code&gt; resolution will be done based on the original package.</source>
          <target state="translated">В редких случаях это решение на основе пакета может быть проблемой. Если вы копируете подпрограмму из одного пакета в другой, &lt;code&gt;SUPER&lt;/code&gt; разрешение будет выполнено на основе исходного пакета.</target>
        </trans-unit>
        <trans-unit id="af62a9f4883bfebec9e4b48e9587f48259af1d0b" translate="yes" xml:space="preserve">
          <source>There are really two tracks of perl development: a maintenance version and an experimental version. The maintenance versions are stable, and have an even number as the minor release (i.e. perl5.18.x, where 18 is the minor release). The experimental versions may include features that don't make it into the stable versions, and have an odd number as the minor release (i.e. perl5.19.x, where 19 is the minor release).</source>
          <target state="translated">На самом деле есть два пути разработки perl:версия для сопровождения и экспериментальная версия.Сопровождающие версии стабильны и имеют четный номер как младший релиз (т.е.perl5.18.x,где 18-младший релиз).Экспериментальные версии могут включать возможности,которые не попадают в стабильную версию,и иметь нечётное число в качестве минорного релиза (т.е.perl5.19.x,где 19-минорный релиз).</target>
        </trans-unit>
        <trans-unit id="f3f1aa2e43835efb5ebefe1c81df4f88e92a3e7e" translate="yes" xml:space="preserve">
          <source>There are really two tracks of perl development: a maintenance version and an experimental version. The maintenance versions are stable, and have an even number as the minor release (i.e. perl5.24.x, where 24 is the minor release). The experimental versions may include features that don't make it into the stable versions, and have an odd number as the minor release (i.e. perl5.25.x, where 25 is the minor release).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1bf8726c4584d2c3d7eed2a3217ca6397579941" translate="yes" xml:space="preserve">
          <source>There are several I/O operators you should know about.</source>
          <target state="translated">Есть несколько операторов ввода/вывода,о которых вы должны знать.</target>
        </trans-unit>
        <trans-unit id="2fda79a606c9c0725617e5e789142491b7fdc787" translate="yes" xml:space="preserve">
          <source>There are several ambiguous cases where a conversion routine cannot determine whether an input filename is in Unix format or in VMS format, since now both VMS and Unix file specifications may have characters in them that could be mistaken for syntax delimiters of the other type. So some pathnames simply cannot be used in a mode that allows either type of pathname to be present. Perl will tend to assume that an ambiguous filename is in Unix format.</source>
          <target state="translated">Существует несколько неоднозначных случаев,когда процедура преобразования не может определить,находится ли имя входного файла в формате Unix или в формате VMS,так как теперь и спецификации VMS и Unix-файлов могут содержать символы,которые могут быть ошибочно приняты за синтаксические разделители другого типа.Так что некоторые патнамы просто не могут быть использованы в режиме,который позволяет присутствовать любому типу патнамов.Perl будет склонен предположить,что неоднозначное имя файла находится в формате Unix.</target>
        </trans-unit>
        <trans-unit id="83b566d12c94cc6ef80e2c552897da25fbcd52af" translate="yes" xml:space="preserve">
          <source>There are several components in CPAN.pm that use environment variables. The build tools, &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; and &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; use some, while others matter to the levels above them. Some of these are specified by the Perl Toolchain Gang:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2d6ce8616f44441a994dbb2d806ba6e4997805" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying countries. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">Существует несколько различных наборов кодов,которые можно использовать для идентификации стран.Набор кодов может быть указан как по имени,так и по константе,которая автоматически экспортируется данным модулем.</target>
        </trans-unit>
        <trans-unit id="74b369e9ecdad508287761106812f2205698bcfc" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying currencies. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">Существует несколько различных наборов кодов,которые можно использовать для идентификации валют.Набор кодов может быть задан как по имени,так и по константе,которая автоматически экспортируется данным модулем.</target>
        </trans-unit>
        <trans-unit id="c5df10a209c7b9d0bd6df6a76c15e47c845b73fd" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying languages. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">Существует несколько различных наборов кода,которые можно использовать для идентификации языков.Набор кодов может быть указан как по имени,так и по константе,которая автоматически экспортируется данным модулем.</target>
        </trans-unit>
        <trans-unit id="357e0be22039446c2158a4027e1ee33566fa847b" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying scripts. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">Существует несколько различных наборов кода,которые можно использовать для идентификации скриптов.Набор кода может быть указан как по имени,так и по константе,которая автоматически экспортируется данным модулем.</target>
        </trans-unit>
        <trans-unit id="c871d77268a0e9a3faf86ba66c7adbf672f7193a" translate="yes" xml:space="preserve">
          <source>There are several escape sequences that convert characters or strings between upper and lower case, and they are also available within patterns. &lt;code&gt;\l&lt;/code&gt; and &lt;code&gt;\u&lt;/code&gt; convert the next character to lower or upper case, respectively:</source>
          <target state="translated">Есть несколько escape-последовательностей, которые преобразуют символы или строки между верхним и нижним регистром, и они также доступны в шаблонах. &lt;code&gt;\l&lt;/code&gt; и &lt;code&gt;\u&lt;/code&gt; преобразуют следующий символ в нижний или верхний регистр соответственно:</target>
        </trans-unit>
        <trans-unit id="8dd1b15a1dbfd18df05cd02be13096a5a0b828cf" translate="yes" xml:space="preserve">
          <source>There are several functions available to specify characters and code points portably in tests. The always-preloaded functions &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; and its inverse &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt; take code points and translate appropriately. The file</source>
          <target state="translated">Для переносимого задания символов и кодов в тестах доступно несколько функций. Всегда предварительно загруженные функции &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; и его обратный &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt; принимают кодовые точки и переводят соответствующим образом. Файл</target>
        </trans-unit>
        <trans-unit id="324d2fa183413ecef672812d1ff51b1b76337a11" translate="yes" xml:space="preserve">
          <source>There are several great resources for locating workshops: the &lt;a href=&quot;#Websites&quot;&gt;websites&lt;/a&gt; mentioned above, the &lt;a href=&quot;#Calendar-of-Perl-Events&quot;&gt;calendar&lt;/a&gt; mentioned below, and the YAPC Europe website, &lt;a href=&quot;http://www.yapceurope.org/&quot;&gt;http://www.yapceurope.org/&lt;/a&gt;, which is probably the best resource for European Perl events.</source>
          <target state="translated">Есть несколько отличных ресурсов для размещения семинаров: упомянутые выше &lt;a href=&quot;#Websites&quot;&gt;веб-сайты&lt;/a&gt; , &lt;a href=&quot;#Calendar-of-Perl-Events&quot;&gt;календарь,&lt;/a&gt; упомянутый ниже, и веб-сайт YAPC Europe, &lt;a href=&quot;http://www.yapceurope.org/&quot;&gt;http://www.yapceurope.org/&lt;/a&gt; , который, вероятно, является лучшим ресурсом для европейских событий Perl.</target>
        </trans-unit>
        <trans-unit id="832a8879ea071712935214efe0cfd19085976c3b" translate="yes" xml:space="preserve">
          <source>There are several of these, which are equivalents, using the &lt;code&gt;\p{}&lt;/code&gt; notation, for Posix classes and are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70817f22a3f6a9efb5f508894682105db2aa6387" translate="yes" xml:space="preserve">
          <source>There are several of these, which are equivalents, using the &lt;code&gt;\p{}&lt;/code&gt; notation, for Posix classes and are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">Есть несколько из них, которые в нотации &lt;code&gt;\p{}&lt;/code&gt; являются эквивалентами классов Posix и описаны в &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;классах символов POSIX в perlrecharclass&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f33ad2d3a2c17446bc61c87b03a2741b5207b2ef" translate="yes" xml:space="preserve">
          <source>There are several of these, which are the standard Posix classes extended to the full Unicode range. They are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f83d1183ceda85cce3fcdc239963f72e745557e" translate="yes" xml:space="preserve">
          <source>There are several of these, which are the standard Posix classes extended to the full Unicode range. They are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">Есть несколько из них, которые представляют собой стандартные классы Posix, расширенные до полного диапазона Unicode. Они описаны в &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;классах символов POSIX в perlrecharclass&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff60b9f3f7c3df35d25431cc4664ba95f5cce4d6" translate="yes" xml:space="preserve">
          <source>There are several types of character class tests that Perl implements. The only ones described here are those that directly correspond to C library functions that operate on 8-bit characters, but there are equivalents that operate on wide characters, and UTF-8 encoded strings. All are more fully described in &lt;a href=&quot;perlapi#Character-classification&quot;&gt;&quot;Character classification&quot; in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;&quot;Character case changing&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3db56f779a367ad8451b62021cf957e6240bc01" translate="yes" xml:space="preserve">
          <source>There are several types of character class tests that Perl implements. The only ones described here are those that directly correspond to C library functions that operate on 8-bit characters, but there are equivalents that operate on wide characters, and UTF-8 encoded strings. All are more fully described in &lt;a href=&quot;perlapi#Character-classification&quot;&gt;Character classification in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;Character case changing in perlapi&lt;/a&gt;.</source>
          <target state="translated">Perl реализует несколько типов тестов символьных классов. Здесь описаны только те, которые напрямую соответствуют функциям библиотеки C, которые работают с 8-битными символами, но есть эквиваленты, которые работают с широкими символами и строками в кодировке UTF-8. Все это более полно описано в &lt;a href=&quot;perlapi#Character-classification&quot;&gt;разделах &amp;laquo;Классификация символов в perlapi&amp;raquo;&lt;/a&gt; и &amp;laquo; Изменение регистра &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;символов в perlapi&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2e0a93aaf35e3ad5cd5182c4904a3f139cb368f" translate="yes" xml:space="preserve">
          <source>There are several ways to call the debugger:</source>
          <target state="translated">Есть несколько способов вызова отладчика:</target>
        </trans-unit>
        <trans-unit id="e8db18a3a166163bfb23804a9a1202e4ece1bc54" translate="yes" xml:space="preserve">
          <source>There are several ways to wrap your Perl scripts in DCL</source>
          <target state="translated">Есть несколько способов обернуть ваши Perl скрипты в DCL</target>
        </trans-unit>
        <trans-unit id="9d4463c6ded942fe4cd0ec81ef54653fbdb5493c" translate="yes" xml:space="preserve">
          <source>There are some bugs in the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&quot;U0&quot;&lt;/code&gt; template</source>
          <target state="translated">Ошибки в шаблоне &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&quot;U0&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5363960c51ded4425aac0c5e8d1bf8c47e9bafcf" translate="yes" xml:space="preserve">
          <source>There are some cases where Perl can't immediately tell the difference between an expression and a statement. For instance, the syntax for a block and an anonymous hash reference constructor look the same unless there's something in the braces to give Perl a hint. The ellipsis is a syntax error if Perl doesn't guess that the &lt;code&gt;{ ... }&lt;/code&gt; is a block. In that case, it doesn't think the &lt;code&gt;...&lt;/code&gt; is an ellipsis because it's expecting an expression instead of a statement:</source>
          <target state="translated">В некоторых случаях Perl не может сразу отличить выражение от оператора. Например, синтаксис блока и конструктора анонимной ссылки на хеш выглядит одинаково, если только в фигурных скобках нет ничего, что могло бы дать Perl подсказку. Многоточие - это синтаксическая ошибка, если Perl не догадывается, что &lt;code&gt;{ ... }&lt;/code&gt; является блоком. В этом случае он не думает, что &lt;code&gt;...&lt;/code&gt; является многоточием, потому что ожидает выражение вместо оператора:</target>
        </trans-unit>
        <trans-unit id="56b7755399d4ee6979402a39fa3144930c83cfee" translate="yes" xml:space="preserve">
          <source>There are some cases where Perl can't immediately tell the difference between an expression and a statement. For instance, the syntax for a block and an anonymous hash reference constructor look the same unless there's something in the braces to give Perl a hint. The ellipsis is a syntax error if Perl doesn't guess that the &lt;code&gt;{ ... }&lt;/code&gt; is a block. Inside your block, you can use a &lt;code&gt;;&lt;/code&gt; before the ellipsis to denote that the &lt;code&gt;{ ... }&lt;/code&gt; is a block and not a hash reference constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d390e2b6c3127ccfec700a0a95db3ede4e9652" translate="yes" xml:space="preserve">
          <source>There are some caveats with the use of runtime statements like &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter&lt;/code&gt; and the assignment to package variables, which can be very subtle for the unaware programmer. This may happen for instance with mutually recursive modules, which are affected by the time the relevant constructions are executed.</source>
          <target state="translated">Есть некоторые предостережения при использовании операторов времени выполнения, таких как &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter&lt;/code&gt; и присвоение переменных пакета, что может быть очень тонким для неосведомленного программиста. Это может происходить, например, с взаимно рекурсивными модулями, на которые влияет время выполнения соответствующих конструкций.</target>
        </trans-unit>
        <trans-unit id="4f5521a0adc9e1424f0db1d5eef9bf6747b3a1ab" translate="yes" xml:space="preserve">
          <source>There are some caveats with the use of runtime statements like &lt;code&gt;require Exporter&lt;/code&gt; and the assignment to package variables, which can be very subtle for the unaware programmer. This may happen for instance with mutually recursive modules, which are affected by the time the relevant constructions are executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344f93501dc28c704b9a2e67faf75c375217d583" translate="yes" xml:space="preserve">
          <source>There are some complications that are ignored in the examples above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d05d692911a48f923ff823586f7db33a368c559" translate="yes" xml:space="preserve">
          <source>There are some convenience functions available that can help with the destruction of xVs. These functions introduce the concept of &quot;mortality&quot;. An xV that is mortal has had its reference count marked to be decremented, but not actually decremented, until &quot;a short time later&quot;. Generally the term &quot;short time later&quot; means a single Perl statement, such as a call to an XSUB function. The actual determinant for when mortal xVs have their reference count decremented depends on two macros, SAVETMPS and FREETMPS. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; and &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for more details on these macros.</source>
          <target state="translated">Доступны некоторые удобные функции, которые могут помочь с уничтожением xV. Эти функции вводят понятие &amp;laquo;смертность&amp;raquo;. Счетчик ссылок xV, который является смертным, был помечен как подлежащий уменьшению, но фактически не уменьшен до &amp;laquo;короткого времени спустя&amp;raquo;. Обычно термин &amp;laquo;через некоторое время&amp;raquo; означает отдельный оператор Perl, такой как вызов функции XSUB. Фактический детерминант того, когда у смертных xV уменьшается счетчик ссылок, зависит от двух макросов: SAVETMPS и FREETMPS. См. &lt;a href=&quot;perlcall&quot;&gt;Perlcall&lt;/a&gt; и &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; для получения более подробной информации об этих макросах.</target>
        </trans-unit>
        <trans-unit id="0d7095e4177705611245878da2c1cd341f565d3b" translate="yes" xml:space="preserve">
          <source>There are some convenience functions available that can help with the destruction of xVs. These functions introduce the concept of &quot;mortality&quot;. Much documentation speaks of an xV itself being mortal, but this is misleading. It is really</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aad51f0e11a34d98334dfd8a5325d2defc4e5c1" translate="yes" xml:space="preserve">
          <source>There are some different considerations for each form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b9699f0d3b28a88deb2c4c365035a0647ae160" translate="yes" xml:space="preserve">
          <source>There are some difficulties in using the tied hash interface if you want to manipulate a BTREE database with duplicate keys. Consider this code:</source>
          <target state="translated">Есть некоторые трудности в использовании связанного хэш-интерфейса,если вы хотите манипулировать базой данных BTREE с дублирующимися ключами.Рассмотрим этот код:</target>
        </trans-unit>
        <trans-unit id="c09cd4cd0008c42a9eb3710539a1c18a01958eae" translate="yes" xml:space="preserve">
          <source>There are some downsides here: the size economy will not stand at runtime after this &lt;code&gt;init()&lt;/code&gt; runs. But it should not be that critical, since if you don't have space for that, you won't have space for any other language besides the main one as well. You could do that too with ties, expanding the value at lookup time which should be more time expensive as an option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c652dbfd06883d908b23bc1bfea111a0463399a9" translate="yes" xml:space="preserve">
          <source>There are some drawbacks to this approach. One is that any extension which calls any file-manipulating C function will need to be recompiled (just follow the usual &quot;perl Makefile.PL; make; make test; make install&quot; procedure).</source>
          <target state="translated">Есть некоторые недостатки в этом подходе.Один из них заключается в том,что любое расширение,вызывающее функцию манипулирования файлами на C,должно быть перекомпилировано (просто следуйте обычной процедуре &quot;perl Makefile.PL;make;make test;make install&quot;).</target>
        </trans-unit>
        <trans-unit id="9cd4d89394373d1a964c062cbd37f2a471efcbee" translate="yes" xml:space="preserve">
          <source>There are some locale-related library calls that still aren't thread-safe because they return data in a buffer global to all threads. In the past, these didn't matter as locales weren't thread-safe at all. But now you have to be aware of them in case your module is called in a multi-threaded application. The known ones are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b359481d6fbdc6a6a4b31621c42bd37e3d7940e" translate="yes" xml:space="preserve">
          <source>There are some obvious disadvantages with this technique.</source>
          <target state="translated">Есть некоторые очевидные недостатки этой техники.</target>
        </trans-unit>
        <trans-unit id="5ca89f8811d4cbda81105708f26c4da2bc407dd8" translate="yes" xml:space="preserve">
          <source>There are some optional options you can pass to &lt;code&gt;memoize&lt;/code&gt; to change the way it behaves a little. To supply options, invoke &lt;code&gt;memoize&lt;/code&gt; like this:</source>
          <target state="translated">Есть несколько дополнительных параметров, которые вы можете передать в &lt;code&gt;memoize&lt;/code&gt; , чтобы немного изменить его поведение. Чтобы предоставить параметры, вызовите &lt;code&gt;memoize&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="94c539cef62e9aa25e310b57bc5c00ca12ad3ddb" translate="yes" xml:space="preserve">
          <source>There are some shortcuts for oneliners; see &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;-C in perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362784bb7e407303367ae06c7f4d21b101719adc" translate="yes" xml:space="preserve">
          <source>There are some shortcuts for oneliners; see &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt; in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">Есть несколько ярлыков для oneliners; см. &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt; в &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="242b6f00a4806779b2651b44eef8a2d396dd9333" translate="yes" xml:space="preserve">
          <source>There are some special instructions for building Perl with Sun Studio on Linux. Following the normal &lt;code&gt;Configure&lt;/code&gt;, you have to run make as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6709b6148bb02040a39a95e98f282835dfc33f" translate="yes" xml:space="preserve">
          <source>There are some warnings with respect to malformed hyperlinks:</source>
          <target state="translated">Есть некоторые предупреждения в отношении неправильных гиперссылок:</target>
        </trans-unit>
        <trans-unit id="ce8df6ad608907441859c0c720df59bd6834bb9d" translate="yes" xml:space="preserve">
          <source>There are still many places where Unicode (in some encoding or another) could be given as arguments or received as results, or both in Perl, but it is not, in spite of Perl having extensive ways to input and output in Unicode, and a few other &quot;entry points&quot; like the &lt;code&gt;@ARGV&lt;/code&gt; array (which can sometimes be interpreted as UTF-8).</source>
          <target state="translated">Есть еще много мест, где Unicode (в той или иной кодировке) может быть указан как аргумент или получен как результат, или и то, и другое в Perl, но это не так, несмотря на то, что Perl имеет обширные способы ввода и вывода в Unicode, и несколько других &amp;laquo;точек входа&amp;raquo;, таких как массив &lt;code&gt;@ARGV&lt;/code&gt; (который иногда можно интерпретировать как UTF-8).</target>
        </trans-unit>
        <trans-unit id="59db2905dffb1315acaf3a1dc211ceadeec4d5cb" translate="yes" xml:space="preserve">
          <source>There are three Command Line flags that can be used to control when warnings are (or aren't) produced:</source>
          <target state="translated">Есть три флага командной строки,которые можно использовать для управления,когда предупреждения выдаются (или не выдаются):</target>
        </trans-unit>
        <trans-unit id="10489a4543147a152f672e9c6f67f2c24de29afb" translate="yes" xml:space="preserve">
          <source>There are three basic ways of running external commands:</source>
          <target state="translated">Существует три основных способа выполнения внешних команд:</target>
        </trans-unit>
        <trans-unit id="ee1484d5257f2915d554120f4ce6bfb497ce1d27" translate="yes" xml:space="preserve">
          <source>There are three basic ways that you can structure a threaded program. Which model you choose depends on what you need your program to do. For many non-trivial threaded programs, you'll need to choose different models for different pieces of your program.</source>
          <target state="translated">Существует три основных способа структурирования потоковой программы.Какая модель вы выберете,зависит от того,что вам нужна ваша программа,чтобы сделать.Для многих нетривиальных потоковых программ вам нужно будет выбрать различные модели для различных частей вашей программы.</target>
        </trans-unit>
        <trans-unit id="7fc3fd61896b5d12698d6fdcfdceea06c9dc86a3" translate="yes" xml:space="preserve">
          <source>There are three distinct concepts of &quot;next&quot; in the regex engine, and it is important to keep them clear.</source>
          <target state="translated">В регекс-двигателе есть три различных понятия &quot;следующий&quot;,и важно,чтобы они были понятны.</target>
        </trans-unit>
        <trans-unit id="95aff53d816fd931550c2a4895fd2449f30b17c2" translate="yes" xml:space="preserve">
          <source>There are three popular ways to avoid this overhead. One solution involves running the Apache HTTP server (available from &lt;a href=&quot;http://www.apache.org/&quot;&gt;http://www.apache.org/&lt;/a&gt; ) with either of the mod_perl or mod_fastcgi plugin modules.</source>
          <target state="translated">Есть три популярных способа избежать этих накладных расходов. Одно из решений включает запуск HTTP-сервера Apache (доступного по &lt;a href=&quot;http://www.apache.org/&quot;&gt;адресу http://www.apache.org/&lt;/a&gt; ) с помощью подключаемых модулей mod_perl или mod_fastcgi.</target>
        </trans-unit>
        <trans-unit id="99df9d7a05fef99c9f9af3d138353a09ea2aa37e" translate="yes" xml:space="preserve">
          <source>There are three types of character classes in Perl regular expressions: the dot, backslash sequences, and the form enclosed in square brackets. Keep in mind, though, that often the term &quot;character class&quot; is used to mean just the bracketed form. Certainly, most Perl documentation does that.</source>
          <target state="translated">В регулярных выражениях Perl существует три типа классов символов:точка,обратная косая черта и форма,заключенная в квадратные скобки.Однако следует помнить,что часто термин &quot;класс символов&quot; используется только для обозначения формы,заключенной в скобки.Конечно,в большинстве Perl-документаций так и делается.</target>
        </trans-unit>
        <trans-unit id="a78a1c3edbdc828e2c5469275355a4d4c1a4e525" translate="yes" xml:space="preserve">
          <source>There are three ways to do this. First, the easy but inefficient way, which is also the default, in order to maintain source compatibility with extensions: whenever</source>
          <target state="translated">Есть три способа сделать это.Первый-простой,но неэффективный способ,который также является способом по умолчанию,для поддержания совместимости исходного текста с расширениями:когда</target>
        </trans-unit>
        <trans-unit id="95c05fa69dfba88648a1ac130ade8afd3e3bcc34" translate="yes" xml:space="preserve">
          <source>There are three ways to write a test in the core: &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d88ffa178365fa0703151483456030669a9d8af" translate="yes" xml:space="preserve">
          <source>There are three ways to write a test in the core: &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt;,</source>
          <target state="translated">Есть три способа написать тест в ядре: &lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="1233ca5594cc5aa5bc69145748e72c13824fb763" translate="yes" xml:space="preserve">
          <source>There are three ways to write your own source filter. You can write it in C, use an external program as a filter, or write the filter in Perl. I won't cover the first two in any great detail, so I'll get them out of the way first. Writing the filter in Perl is most convenient, so I'll devote the most space to it.</source>
          <target state="translated">Есть три способа написать свой собственный фильтр исходных текстов.Вы можете написать его на Си,использовать в качестве фильтра внешнюю программу или написать фильтр на Perl.Первые два способа я не буду описывать в подробностях,так что сначала я их уберу.Написать фильтр на Perl удобнее всего,поэтому я посвящу ему больше всего места.</target>
        </trans-unit>
        <trans-unit id="4d1ca307ab6382d572650b48515269fd5ebc805c" translate="yes" xml:space="preserve">
          <source>There are times when you may find it useful to have a thread explicitly give up the CPU to another thread. You may be doing something processor-intensive and want to make sure that the user-interface thread gets called frequently. Regardless, there are times that you might want a thread to give up the processor.</source>
          <target state="translated">Бывают моменты,когда может оказаться полезным,чтобы поток явно отдал процессор другому потоку.Возможно,вы делаете что-то процессорное и хотите,чтобы поток пользовательского интерфейса часто вызывался.Независимо от этого,бывают случаи,когда вам может понадобиться,чтобы поток отказался от процессора.</target>
        </trans-unit>
        <trans-unit id="aabf4548dd9ce503cb7793127ff7d0d6ca4a9258" translate="yes" xml:space="preserve">
          <source>There are two basic modes of operation (plus turning if off):</source>
          <target state="translated">Существует два основных режима работы (плюс выключение при выключении):</target>
        </trans-unit>
        <trans-unit id="a13ac870bbe694381404312541ad897bb1c7bfff" translate="yes" xml:space="preserve">
          <source>There are two callbacks, &lt;code&gt;named_buff&lt;/code&gt; is called in all the cases the FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR &lt;a href=&quot;Tie::Hash&quot;&gt;Tie::Hash&lt;/a&gt; callbacks would be on changes to &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; and &lt;code&gt;named_buff_iter&lt;/code&gt; in the same cases as FIRSTKEY and NEXTKEY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b9f0a36cbfc725453b6b4804987d2d7a53bc2c" translate="yes" xml:space="preserve">
          <source>There are two callbacks, &lt;code&gt;named_buff&lt;/code&gt; is called in all the cases the FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; callbacks would be on changes to &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; and &lt;code&gt;named_buff_iter&lt;/code&gt; in the same cases as FIRSTKEY and NEXTKEY.</source>
          <target state="translated">Существует два обратных вызова, &lt;code&gt;named_buff&lt;/code&gt; вызывается во всех случаях, а обратные вызовы FETCH, STORE, DELETE, CLEAR, EXISTS и SCALAR &lt;a href=&quot;tie/hash&quot;&gt;Tie :: Hash&lt;/a&gt; будут при изменении &lt;code&gt;%+&lt;/code&gt; и &lt;code&gt;%-&lt;/code&gt; и &lt;code&gt;named_buff_iter&lt;/code&gt; в тех же случаях, что и FIRSTKEY и NEXTKEY.</target>
        </trans-unit>
        <trans-unit id="85a26ce9bc0772a2a092df698289266d1f10ecae" translate="yes" xml:space="preserve">
          <source>There are two cases, multi-byte and single-byte locales. First multi-byte:</source>
          <target state="translated">Есть два случая,многобайтовые и однобайтовые локали.Первый многобайтовый:</target>
        </trans-unit>
        <trans-unit id="3f6e50ca71fb9ef8a58634080d592b643d6be431" translate="yes" xml:space="preserve">
          <source>There are two cases:</source>
          <target state="translated">Есть два дела:</target>
        </trans-unit>
        <trans-unit id="c07255028b3b5bd9a90385fc5c125ed8062cb54e" translate="yes" xml:space="preserve">
          <source>There are two commonly used techniques of profiling executables:</source>
          <target state="translated">Существует два широко используемых метода профилирования исполняемых файлов:</target>
        </trans-unit>
        <trans-unit id="ca79bf7ca29122cb03591230567965097d73b502" translate="yes" xml:space="preserve">
          <source>There are two different types of version objects, corresponding to the two different styles of versions in use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4918f14b7918995ede690de784e45ce5b334a99c" translate="yes" xml:space="preserve">
          <source>There are two distinctive features of the dyna-linking model of OS/2: first, all the references to external functions are resolved at the compile time; second, there is no runtime fixup of the DLLs after they are loaded into memory. The first feature is an enormous advantage over other models: it avoids conflicts when several DLLs used by an application export entries with the same name. In such cases &quot;other&quot; models of dyna-linking just choose between these two entry points using some random criterion - with predictable disasters as results. But it is the second feature which requires the build of</source>
          <target state="translated">Есть две отличительные особенности модели дина-связи OS/2:во-первых,все ссылки на внешние функции разрешаются во время компиляции;во-вторых,не исправляется время выполнения DLL после их загрузки в память.Первая особенность является огромным преимуществом перед другими моделями:она позволяет избежать конфликтов,когда несколько DLL,используемых приложением,экспортируют записи с одним и тем же именем.В таких случаях &quot;другие&quot; модели связывания дайн просто выбирают между этими двумя точками входа по какому-то случайному критерию-с предсказуемыми катастрофами в качестве результатов.Но это вторая особенность,которая требует создания</target>
        </trans-unit>
        <trans-unit id="b851bdf3c81b8784e2dddc6e20b8e6c18978a571" translate="yes" xml:space="preserve">
          <source>There are two exit points from the inner uncompression loop.</source>
          <target state="translated">Есть две точки выхода из внутреннего контура несжимания.</target>
        </trans-unit>
        <trans-unit id="108b59b47c97316f062b5266aff655788506a06e" translate="yes" xml:space="preserve">
          <source>There are two forms of octal escapes. Each is used to specify a character by its code point specified in octal notation.</source>
          <target state="translated">Есть две формы восьмеричного побега.Каждая из них используется для задания символа по его кодовой точке,указанной в восьмеричной нотации.</target>
        </trans-unit>
        <trans-unit id="172fa4a9b4de533e56c4707adea17699b11d4a1b" translate="yes" xml:space="preserve">
          <source>There are two important points to remember:</source>
          <target state="translated">Есть два важных момента,которые нужно запомнить:</target>
        </trans-unit>
        <trans-unit id="ef6d3355d6294c0400eecec7ab06563e8c2ddc8b" translate="yes" xml:space="preserve">
          <source>There are two keys with a special meaning in the hash: &quot;read&quot; and &quot;write&quot;. These contain packlist files. After the copying is done, install() will write the list of target files to $from_to{write}. If $from_to{read} is given the contents of this file will be merged into the written file. The read and the written file may be identical, but on AFS it is quite likely that people are installing to a different directory than the one where the files later appear.</source>
          <target state="translated">В гашише есть два ключа с особым значением:&quot;читать&quot; и &quot;писать&quot;.Они содержат файлы пакетного списка.После копирования функция install()запишет список целевых файлов в $from_to{write}.При указании $from_to{read}содержимое этого файла будет объединено в записываемый файл.Прочитанный и записанный файл может быть идентичен,но на AFS вполне вероятно,что люди устанавливают в директорию,отличную от директории,в которой позже появятся эти файлы.</target>
        </trans-unit>
        <trans-unit id="127794821c87aa3c1561f9022c74d909b021fad3" translate="yes" xml:space="preserve">
          <source>There are two main ways that contexts are popped. During normal execution as scopes are exited, functions like &lt;code&gt;pp_leave&lt;/code&gt;, &lt;code&gt;pp_leaveloop&lt;/code&gt; and &lt;code&gt;pp_leavesub&lt;/code&gt; process and pop just one context using &lt;code&gt;cx_popfoo&lt;/code&gt; and &lt;code&gt;cx_popblock&lt;/code&gt;. On the other hand, things like &lt;code&gt;pp_return&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; may have to pop back several scopes until a sub or loop context is found, and exceptions (such as &lt;code&gt;die&lt;/code&gt;) need to pop back contexts until an eval context is found. Both of these are accomplished by &lt;code&gt;dounwind()&lt;/code&gt;, which is capable of processing and popping all contexts above the target one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06480546f8f7593dd6ae9d9e44d7bf0995b966a" translate="yes" xml:space="preserve">
          <source>There are two new display parameters.</source>
          <target state="translated">Появились два новых параметра отображения.</target>
        </trans-unit>
        <trans-unit id="3c86f1c0ffd1daa198d3368c1af9e850c8735019" translate="yes" xml:space="preserve">
          <source>There are two operands, but no operator giving how you want to combine them.</source>
          <target state="translated">Есть два операндов,но ни один оператор не дает,как вы хотите их совместить.</target>
        </trans-unit>
        <trans-unit id="24dc61084886e44e27660b4a97166077845b5c95" translate="yes" xml:space="preserve">
          <source>There are two package separators in Perl: A double colon (&lt;code&gt;::&lt;/code&gt; ) and a single quote (&lt;code&gt;'&lt;/code&gt;). Normal identifiers can start or end with a double colon, and can contain several parts delimited by double colons. Single quotes have similar rules, but with the exception that they are not legal at the end of an identifier: That is, &lt;code&gt;$'foo&lt;/code&gt; and &lt;code&gt;$foo'bar&lt;/code&gt; are legal, but &lt;code&gt;$foo'bar'&lt;/code&gt; is not.</source>
          <target state="translated">В Perl есть два разделителя пакетов: двойное двоеточие ( &lt;code&gt;::&lt;/code&gt; ) и одинарная кавычка ( &lt;code&gt;'&lt;/code&gt; ). Обычные идентификаторы могут начинаться или заканчиваться двойным двоеточием и могут содержать несколько частей, разделенных двойными двоеточиями. Для одинарных кавычек действуют аналогичные правила, но за исключением того, что они недопустимы в конце идентификатора: то есть &lt;code&gt;$'foo&lt;/code&gt; и &lt;code&gt;$foo'bar&lt;/code&gt; допустимы, а &lt;code&gt;$foo'bar'&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="281389919696086dbd7adfd1393b788681ca075b" translate="yes" xml:space="preserve">
          <source>There are two package separators in Perl: A double colon (&lt;code&gt;::&lt;/code&gt;) and a single quote (&lt;code&gt;'&lt;/code&gt;). Normal identifiers can start or end with a double colon, and can contain several parts delimited by double colons. Single quotes have similar rules, but with the exception that they are not legal at the end of an identifier: That is, &lt;code&gt;$'foo&lt;/code&gt; and &lt;code&gt;$foo'bar&lt;/code&gt; are legal, but &lt;code&gt;$foo'bar'&lt;/code&gt; is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75895a5372bf6c78e51cf652a3ae78bb3d9b2367" translate="yes" xml:space="preserve">
          <source>There are two principal conventions (it is useful to call them &lt;code&gt;Dos*&lt;/code&gt; and &lt;code&gt;Win*&lt;/code&gt; - though this part of the function signature is not always determined by the name of the API) of reporting the error conditions of OS/2 API. Most of &lt;code&gt;Dos*&lt;/code&gt; APIs report the error code as the result of the call (so 0 means success, and there are many types of errors). Most of &lt;code&gt;Win*&lt;/code&gt; API report success/fail via the result being &lt;code&gt;TRUE&lt;/code&gt; /&lt;code&gt;FALSE&lt;/code&gt; ; to find the reason for the failure one should call WinGetLastError() API.</source>
          <target state="translated">Есть два основных соглашения (полезно называть их &lt;code&gt;Dos*&lt;/code&gt; и &lt;code&gt;Win*&lt;/code&gt; - хотя эта часть сигнатуры функции не всегда определяется именем API) сообщения об ошибках OS / 2 API. Большинство API-интерфейсов &lt;code&gt;Dos*&lt;/code&gt; сообщают код ошибки как результат вызова (поэтому 0 означает успех, и существует множество типов ошибок). Большинство &lt;code&gt;Win*&lt;/code&gt; API сообщают об успехе / неудаче с результатом &lt;code&gt;TRUE&lt;/code&gt; / &lt;code&gt;FALSE&lt;/code&gt; ; чтобы выяснить причину сбоя, необходимо вызвать API WinGetLastError ().</target>
        </trans-unit>
        <trans-unit id="2eaa4513f3f865ba65175af81cc35fc35f264abc" translate="yes" xml:space="preserve">
          <source>There are two principal conventions (it is useful to call them &lt;code&gt;Dos*&lt;/code&gt; and &lt;code&gt;Win*&lt;/code&gt; - though this part of the function signature is not always determined by the name of the API) of reporting the error conditions of OS/2 API. Most of &lt;code&gt;Dos*&lt;/code&gt; APIs report the error code as the result of the call (so 0 means success, and there are many types of errors). Most of &lt;code&gt;Win*&lt;/code&gt; API report success/fail via the result being &lt;code&gt;TRUE&lt;/code&gt;/&lt;code&gt;FALSE&lt;/code&gt;; to find the reason for the failure one should call WinGetLastError() API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b7ddfa19fa0f3f3b716199a0f4db35df4687cb" translate="yes" xml:space="preserve">
          <source>There are two steps to running the test suite:</source>
          <target state="translated">Есть два шага к запуску тестового набора:</target>
        </trans-unit>
        <trans-unit id="5595b4165f441d44d1cb7724594811d46925edfc" translate="yes" xml:space="preserve">
          <source>There are two structures used to store a compiled regular expression. One, the &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is populated by the engine currently being. used and some of its fields read by perl to implement things such as the stringification of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для хранения скомпилированного регулярного выражения используются две структуры. &lt;a href=&quot;perlreapi&quot;&gt;Во-&lt;/a&gt; первых, структура &lt;code&gt;regexp&lt;/code&gt; описанная в perlreapi , заполняется текущим движком. используется, и некоторые из его полей читаются Perl для реализации таких вещей, как строковая привязка &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5100abedaa25e172d048855813a77ed10197f346" translate="yes" xml:space="preserve">
          <source>There are two structures used to store a compiled regular expression. One, the &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is populated by the engine currently being. used and some of its fields read by perl to implement things such as the stringification of &lt;code&gt;qr//&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2fe23c780ba1b117d60c962e46037021ac3aa2" translate="yes" xml:space="preserve">
          <source>There are two syntaxes for formatting codes:</source>
          <target state="translated">Существует два синтаксиса для форматирования кодов:</target>
        </trans-unit>
        <trans-unit id="7371ec3e37b63adab8d04f7c4222af55c486c054" translate="yes" xml:space="preserve">
          <source>There are two that I can think off.</source>
          <target state="translated">Есть два,о которых я могу подумать.</target>
        </trans-unit>
        <trans-unit id="6d886c39930696ad6e408c59f68366994aaac004" translate="yes" xml:space="preserve">
          <source>There are two ways to build persistent private variables in Perl 5.10. First, you can simply use the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; feature. Or, you can use closures, if you want to stay compatible with releases older than 5.10.</source>
          <target state="translated">В Perl 5.10 есть два способа создания постоянных частных переменных. Во-первых, вы можете просто использовать функцию &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; . Или вы можете использовать закрытия, если хотите оставаться совместимыми с выпусками старше 5.10.</target>
        </trans-unit>
        <trans-unit id="61e69f88599a859bbb0f9c52d49cc582b32af203" translate="yes" xml:space="preserve">
          <source>There are two ways to build persistent private variables in Perl 5.10. First, you can simply use the &lt;code&gt;state&lt;/code&gt; feature. Or, you can use closures, if you want to stay compatible with releases older than 5.10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7079fb330c8f6fcf4a67d7d60f1f7e8ba9c961" translate="yes" xml:space="preserve">
          <source>There are two ways to create and load an AV. The first method creates an empty AV:</source>
          <target state="translated">Есть два способа создать и загрузить AV.Первый способ создает пустой AV:</target>
        </trans-unit>
        <trans-unit id="48bc33b0558cf40893cd4b6a9aee4a0aeea211f9" translate="yes" xml:space="preserve">
          <source>There are two ways to enable debugging output for regular expressions.</source>
          <target state="translated">Есть два способа включить отладочный вывод для регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="0ef643530975df52bad47239ca43b62c4abb64aa" translate="yes" xml:space="preserve">
          <source>There are two ways to enter v-strings: a bare number with two or more decimal points, or a bare number with one or more decimal points and a leading 'v' character (also bare). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6ac5b22382be34f18ee4c2a153755024871b3a" translate="yes" xml:space="preserve">
          <source>There are two ways to load the &lt;code&gt;feature&lt;/code&gt; pragma implicitly:</source>
          <target state="translated">Есть два способа неявно загрузить прагму &lt;code&gt;feature&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="af911c100c71eb3b76adfb1d6d843d034d346f08" translate="yes" xml:space="preserve">
          <source>There are two ways to specify the selection. Either a string (scalar) representing a selection regexp for sections to be printed when -verbose is set to 99, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f214eee3e697782835e9e4f8a448217e9a53a985" translate="yes" xml:space="preserve">
          <source>There are two ways to use Cocoa from Perl. Apple's PerlObjCBridge module, included with Mac OS X, can be used by standalone scripts to access Foundation (i.e. non-GUI) classes and objects.</source>
          <target state="translated">Есть два способа использовать какао от Перла.Модуль PerlObjCBridge от Apple,входящий в Mac OS X,может использоваться отдельными скриптами для доступа к классам и объектам Foundation (т.е.не-GUI).</target>
        </trans-unit>
        <trans-unit id="767f59a65489b12a4b5161b27a3a60165cdfb67b" translate="yes" xml:space="preserve">
          <source>There are two ways to use a DBM Filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409a8226f327930f82376970d0a5dd5d41e49fa0" translate="yes" xml:space="preserve">
          <source>There are undoubtedly serious bugs lurking somewhere in code this funky :-) Bug reports and other feedback are most welcome.</source>
          <target state="translated">Несомненно,где-то в коде затаились серьезные ошибки,эти причудливые :-).Сообщения об ошибках и другие отзывы приветствуются.</target>
        </trans-unit>
        <trans-unit id="85be9b959b2e4ac88632b966dc97bb4a96c09ffb" translate="yes" xml:space="preserve">
          <source>There are undoubtedly serious bugs lurking somewhere in this code, if only because parts of it give the impression of understanding a great deal more about Perl than they really do.</source>
          <target state="translated">Несомненно,где-то в этом коде затаились серьезные ошибки,хотя бы потому,что некоторые из них создают впечатление,что Perl понимает гораздо больше,чем на самом деле.</target>
        </trans-unit>
        <trans-unit id="04b3f04345fdb786670dce0b2cea7b0b8304663e" translate="yes" xml:space="preserve">
          <source>There are useful variations on this theme. The sense of the match can be reversed by using the &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">На эту тему есть полезные вариации. Смысл совпадения можно изменить с помощью оператора &lt;code&gt;!~&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ccb3b88b50c8aa38b3bc60c7b4f5ddbf691da924" translate="yes" xml:space="preserve">
          <source>There are usually several synonyms for each possible value. Use &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; to access those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9efcf4d71ac56a124108c21d7833f5bea0582a" translate="yes" xml:space="preserve">
          <source>There are usually several synonyms for each possible value. Use &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; to access those.</source>
          <target state="translated">Обычно для каждого возможного значения существует несколько синонимов. Используйте &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; для доступа к ним.</target>
        </trans-unit>
        <trans-unit id="defaf951c93d8c59c8e8c2838dbcdfdd9abafeeb" translate="yes" xml:space="preserve">
          <source>There are usually three or four interval timers (signals) available: the &lt;code&gt;$which&lt;/code&gt; can be &lt;code&gt;ITIMER_REAL&lt;/code&gt; , &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt; , &lt;code&gt;ITIMER_PROF&lt;/code&gt; , or &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; . Note that which ones are available depends: true UNIX platforms usually have the first three, but only Solaris seems to have &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; (which is used to profile multithreaded programs). Win32 unfortunately does not have interval timers.</source>
          <target state="translated">Обычно доступно три или четыре интервальных таймера (сигнала): &lt;code&gt;$which&lt;/code&gt; может быть &lt;code&gt;ITIMER_REAL&lt;/code&gt; , &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt; , &lt;code&gt;ITIMER_PROF&lt;/code&gt; или &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; . Обратите внимание, какие из них доступны, зависит от того, какие из них доступны: на настоящих платформах UNIX обычно есть первые три, но, похоже, только Solaris имеет &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; (который используется для профилирования многопоточных программ). Win32, к сожалению, не имеет интервальных таймеров.</target>
        </trans-unit>
        <trans-unit id="ed047ca7fa087626bb96ec97a8dcb6e6e48edfcd" translate="yes" xml:space="preserve">
          <source>There are usually three or four interval timers (signals) available: the &lt;code&gt;$which&lt;/code&gt; can be &lt;code&gt;ITIMER_REAL&lt;/code&gt;, &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt;, &lt;code&gt;ITIMER_PROF&lt;/code&gt;, or &lt;code&gt;ITIMER_REALPROF&lt;/code&gt;. Note that which ones are available depends: true UNIX platforms usually have the first three, but only Solaris seems to have &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; (which is used to profile multithreaded programs). Win32 unfortunately does not have interval timers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d22a105cc916ea14dd34be71dc22f4c1bb3fd7e" translate="yes" xml:space="preserve">
          <source>There are various aspects of the pattern that can be used to facilitate optimisations along these lines:</source>
          <target state="translated">Существуют различные аспекты шаблона,которые могут быть использованы для облегчения оптимизации по этим линиям:</target>
        </trans-unit>
        <trans-unit id="e3cedfe60646d2e7422ff8b2a7a07f8c037537db" translate="yes" xml:space="preserve">
          <source>There are various other failures, that as of SunOS 4.1.4 and gcc 3.2.2 look a lot like gcc bugs. Many of the failures happen in the Encode tests, where for example when the test expects &quot;0&quot; you get &quot;&amp;amp;#48;&quot; which should after a little squinting look very odd indeed. Another example is earlier in</source>
          <target state="translated">Есть и другие сбои, которые в SunOS 4.1.4 и gcc 3.2.2 очень похожи на ошибки gcc. Многие из сбоев происходят в тестах Encode, где, например, когда тест ожидает &amp;laquo;0&amp;raquo;, вы получите &amp;laquo;&amp;amp; # 48;&amp;raquo; который после небольшого прищурения должен выглядеть действительно очень странно. Другой пример приведен ранее в</target>
        </trans-unit>
        <trans-unit id="e93c51ec114e78593d3350d4739a1d10d41d678a" translate="yes" xml:space="preserve">
          <source>There are various other synonyms that can be used besides the names listed in the table. For example, &lt;code&gt;\p{PosixAlpha}&lt;/code&gt; can be written as &lt;code&gt;\p{Alpha}&lt;/code&gt; . All are listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;.</source>
          <target state="translated">Помимо названий, перечисленных в таблице, можно использовать и другие синонимы. Например, &lt;code&gt;\p{PosixAlpha}&lt;/code&gt; можно записать как &lt;code&gt;\p{Alpha}&lt;/code&gt; . Все они перечислены в &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Свойствах, доступных через \ p {} и \ P {} в perluniprops&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc8fcc00bcaa69a62d8c2fd3f050d67f5a95dbce" translate="yes" xml:space="preserve">
          <source>There are various other synonyms that can be used besides the names listed in the table. For example, &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; can be written as &lt;code&gt;\p{Alpha}&lt;/code&gt;. All are listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;&quot;Properties accessible through \p{} and \P{}&quot; in perluniprops&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20fb423bc3be57a7bce8d37147a935d047431e3f" translate="yes" xml:space="preserve">
          <source>There are various special make targets that can be used to test Perl slightly differently than the standard &quot;test&quot; target. Not all them are expected to give a 100% success rate. Many of them have several aliases, and many of them are not available on certain operating systems.</source>
          <target state="translated">Существуют различные специальные мишени,которые могут быть использованы для тестирования Perl немного иначе,чем стандартная &quot;тестовая&quot; мишень.Ожидается,что не все они дадут 100% успех.Многие из них имеют несколько псевдонимов,и многие из них недоступны на некоторых операционных системах.</target>
        </trans-unit>
        <trans-unit id="7a37b656849e5abe23739ebb1083bad00e7235fc" translate="yes" xml:space="preserve">
          <source>There are various syntaxes, listed below. In the syntaxes given, &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , and &lt;code&gt;section&lt;/code&gt; cannot contain the characters '/' and '|'; and any '&amp;lt;' or '&amp;gt;' should be matched.</source>
          <target state="translated">Ниже перечислены различные синтаксисы. В приведенных синтаксисах &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; и &lt;code&gt;section&lt;/code&gt; не могут содержать символы '/' и '|'; и любые '&amp;lt;' или '&amp;gt;' должны совпадать.</target>
        </trans-unit>
        <trans-unit id="154dae7c2bfb8ff3e2e9f53b8d516d9eec568a2c" translate="yes" xml:space="preserve">
          <source>There are various syntaxes, listed below. In the syntaxes given, &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, and &lt;code&gt;section&lt;/code&gt; cannot contain the characters '/' and '|'; and any '&amp;lt;' or '&amp;gt;' should be matched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37ed54ad4b4e800cd45604ce3c3818f96427db4" translate="yes" xml:space="preserve">
          <source>There are various things to note:</source>
          <target state="translated">Есть на что обратить внимание:</target>
        </trans-unit>
        <trans-unit id="b76fc3582c89676c08603c7aa65b9cc5c9b6bcec" translate="yes" xml:space="preserve">
          <source>There are various ways in which the private and public flags may differ. For example, in perl 5.16 and earlier a tied SV may have a valid underlying value in the IV slot (so SvIOKp is true), but the data should be accessed via the FETCH routine rather than directly, so SvIOK is false. (In perl 5.18 onwards, tied scalars use the flags the same way as untied scalars.) Another is when numeric conversion has occurred and precision has been lost: only the private flag is set on 'lossy' values. So when an NV is converted to an IV with loss, SvIOKp, SvNOKp and SvNOK will be set, while SvIOK wont be.</source>
          <target state="translated">Флаги частных и общественных организаций могут различаться по-разному.Например,в perl 5.16 и более ранних версиях связанное SV может иметь действительное базовое значение в IV слоте (поэтому SvIOKp истинен),но доступ к данным должен осуществляться через рутину FETCH,а не напрямую,поэтому SvIOK ложен.(В perl 5.18 и далее,привязанные скаляры используют флаги так же,как и несвязанные скаляры).Другое дело,когда произошло числовое преобразование и точность потеряна:только приватный флаг устанавливается на 'lossy' значения.Таким образом,когда NV преобразовывается в IV с потерями,SvIOKp,SvNOKp и SvNOK устанавливаются,в то время как SvIOK-нет.</target>
        </trans-unit>
        <trans-unit id="bf9b799d87e5a86957d5b5b84b03a08b714f7c53" translate="yes" xml:space="preserve">
          <source>There are web archives of the mailing list at:</source>
          <target state="translated">Есть веб-архивы списка рассылки по адресу:</target>
        </trans-unit>
        <trans-unit id="491c71a7d655138bb171154df9a2d69cb67f8248" translate="yes" xml:space="preserve">
          <source>There are, at first glance, three kinds of L links: URL, man, and pod.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35625b0405457bfbc71b97ae568ca975b4ffb8db" translate="yes" xml:space="preserve">
          <source>There aren't currently any real UTF-8 locales, even though some locale names contain the string &quot;UTF-8&quot;.</source>
          <target state="translated">В настоящее время нет никаких реальных UTF-8 локалей,хотя некоторые имена локалей содержат строку &quot;UTF-8&quot;.</target>
        </trans-unit>
        <trans-unit id="f18bc503764d637966b24fa60ca1825eff55d27b" translate="yes" xml:space="preserve">
          <source>There can (and in some cases, must) be whitespace between the operator and the quoting characters, except when &lt;code&gt;#&lt;/code&gt; is being used as the quoting character. &lt;code&gt;q#foo#&lt;/code&gt; is parsed as the string &lt;code&gt;foo&lt;/code&gt;, while &lt;code&gt;q #foo#&lt;/code&gt; is the operator &lt;code&gt;q&lt;/code&gt; followed by a comment. Its argument will be taken from the next line. This allows you to write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc581d54ed5726e14da03dd8d1af5cdf478d3d5" translate="yes" xml:space="preserve">
          <source>There can be whitespace between the operator and the quoting characters, except when &lt;code&gt;#&lt;/code&gt; is being used as the quoting character. &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q#foo#&lt;/a&gt;&lt;/code&gt; is parsed as the string &lt;code&gt;foo&lt;/code&gt; , while &lt;code&gt;q #foo#&lt;/code&gt; is the operator &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; followed by a comment. Its argument will be taken from the next line. This allows you to write:</source>
          <target state="translated">Между оператором и символами кавычек может быть пробел, кроме случаев, когда &lt;code&gt;#&lt;/code&gt; используется в качестве символа кавычек. &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q#foo#&lt;/a&gt;&lt;/code&gt; анализируется как строка &lt;code&gt;foo&lt;/code&gt; , а &lt;code&gt;q #foo#&lt;/code&gt; - это оператор &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; , за которым следует комментарий. Его аргумент будет взят из следующей строки. Это позволяет писать:</target>
        </trans-unit>
        <trans-unit id="7f8e18aa50aec43fc98b47477339b319d9bf73e8" translate="yes" xml:space="preserve">
          <source>There does not need to be whitespace at the start of the &quot;&lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; input&lt;/code&gt; &quot; line, but it is useful for improving readability. Placing a semi-colon at the end of that line is also optional. Any amount and kind of whitespace may be placed between the &quot;&lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;&quot; and &quot;&lt;code&gt;input&lt;/code&gt; &quot;.</source>
          <target state="translated">В начале строки &amp;laquo; &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; input&lt;/code&gt; &amp;raquo; не должно быть пробелов , но это полезно для улучшения читаемости. Также необязательно ставить точку с запятой в конце этой строки. Между &amp;laquo; &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; &amp;raquo; и &amp;laquo; &lt;code&gt;input&lt;/code&gt; &amp;raquo; может быть любое количество и вид пробелов .</target>
        </trans-unit>
        <trans-unit id="0ed8a4a87dc8b9885199d341701749c4f7ba168d" translate="yes" xml:space="preserve">
          <source>There does not need to be whitespace at the start of the &quot;&lt;code&gt;int input&lt;/code&gt;&quot; line, but it is useful for improving readability. Placing a semi-colon at the end of that line is also optional. Any amount and kind of whitespace may be placed between the &quot;&lt;code&gt;int&lt;/code&gt;&quot; and &quot;&lt;code&gt;input&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674ce7b791aca3a84e36e5ed443e53056266d194" translate="yes" xml:space="preserve">
          <source>There exists a port of Perl to the ILE environment. This port, however, is based quite an old release of Perl, Perl 5.00502 (August 1998). (As of July 2002 the latest release of Perl is 5.8.0, and even 5.6.1 has been out since April 2001.) If you need to run Perl on ILE, though, you may need this older port: &lt;a href=&quot;http://www.cpan.org/ports/#os400&quot;&gt;http://www.cpan.org/ports/#os400&lt;/a&gt; Note that any Perl release later than 5.00502 has not been ported to ILE.</source>
          <target state="translated">Существует порт Perl в среду ILE. Этот порт, однако, основан на довольно старой версии Perl, Perl 5.00502 (август 1998 г.). (По состоянию на июль 2002 г. последняя версия Perl - 5.8.0, и даже 5.6.1 вышла с апреля 2001 г.) Если вам нужно запустить Perl на ILE, вам может понадобиться этот более старый порт: &lt;a href=&quot;http://www.cpan.org/ports/#os400&quot;&gt;http: // www.cpan.org/ports/#os400&lt;/a&gt; Обратите внимание, что ни один выпуск Perl позже 5.00502 не был перенесен на ILE.</target>
        </trans-unit>
        <trans-unit id="0d9d302333913269ef8b0575b5cd9f95eaae918e" translate="yes" xml:space="preserve">
          <source>There has been a long-standing bug in Perl that causes a lexical variable not to be cleared at scope exit when its declaration includes a false conditional. Some people have exploited this bug to achieve a kind of static variable. To allow us to fix this bug, people should not be relying on this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e08bda06a78f17f34330ccdc939ea82e2b5bf49" translate="yes" xml:space="preserve">
          <source>There is Coverity setup for the perl5 project: &lt;a href=&quot;https://scan.coverity.com/projects/perl5&quot;&gt;https://scan.coverity.com/projects/perl5&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10164fd98639a8c3044721a3ed9b1556ef825187" translate="yes" xml:space="preserve">
          <source>There is a &quot;hints&quot; file for BS2000 called hints.posix-bc (because posix-bc is the OS name given by `uname`) that specifies the correct values for most things. The major problem is (of course) the EBCDIC character set. We have german EBCDIC version.</source>
          <target state="translated">Для BS2000 существует файл &quot;подсказок&quot; под названием hints.posix-bc (поскольку posix-bc-это имя операционной системы,задаваемое `uname`),который задаёт правильные значения для большинства вещей.Основной проблемой является (конечно)набор символов EBCDIC.У нас есть немецкая версия EBCDIC.</target>
        </trans-unit>
        <trans-unit id="5374f2f6990509e72c419ef45603ab27e3bc80da" translate="yes" xml:space="preserve">
          <source>There is a $diagnostics::DEBUG variable you may set if you're desperately curious what sorts of things are being intercepted.</source>
          <target state="translated">Есть переменная $diagnostics::DEBUG,которую вы можете установить,если вам отчаянно интересно,какие именно вещи перехватываются.</target>
        </trans-unit>
        <trans-unit id="4e2dabede0ae332ec4295f1f32bf75c6726b72c4" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;lint&lt;/code&gt; target in Makefile, but you may have to diddle with the flags (see above).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b8779e0a6e284066d3e0c5dc63c7524691a431" translate="yes" xml:space="preserve">
          <source>There is a CPAN module, &lt;code&gt;&lt;a href=&quot;Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt;, which allows you to define your own mappings to be used in &lt;code&gt;lc()&lt;/code&gt;, &lt;code&gt;lcfirst()&lt;/code&gt;, &lt;code&gt;uc()&lt;/code&gt;, &lt;code&gt;ucfirst()&lt;/code&gt;, and &lt;code&gt;fc&lt;/code&gt; (or their double-quoted string inlined versions such as &lt;code&gt;\U&lt;/code&gt;). (Prior to Perl 5.16, this functionality was partially provided in the Perl core, but suffered from a number of insurmountable drawbacks, so the CPAN module was written instead.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a13bc3171b7f184b15ada467454c70823010717" translate="yes" xml:space="preserve">
          <source>There is a CPAN module, &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt;, which allows you to define your own mappings to be used in &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; (or their double-quoted string inlined versions such as &lt;code&gt;\U&lt;/code&gt; ). (Prior to Perl 5.16, this functionality was partially provided in the Perl core, but suffered from a number of insurmountable drawbacks, so the CPAN module was written instead.)</source>
          <target state="translated">Существует модуль CPAN, &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt; , который позволяет вам определять ваши собственные сопоставления, которые будут использоваться в &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; (или их строковых версиях, заключенных в двойные кавычки. такие как &lt;code&gt;\U&lt;/code&gt; ). (До Perl 5.16 эта функциональность частично предоставлялась в ядре Perl, но страдала рядом непреодолимых недостатков, поэтому вместо него был написан модуль CPAN.)</target>
        </trans-unit>
        <trans-unit id="c5d3a875427fdf261fbe25e4b0c804d418f70748" translate="yes" xml:space="preserve">
          <source>There is a Clone module available on CPAN which implements deep cloning natively, i.e. without freezing to memory and thawing the result. It is aimed to replace Storable's dclone() some day. However, it does not currently support Storable hooks to redefine the way deep cloning is performed.</source>
          <target state="translated">На CPAN доступен модуль клонирования,который реализует глубокое клонирование нативно,т.е.без замораживания в памяти и оттаивания результата.Он предназначен для замены Storable's dclone()когда-нибудь.Однако в настоящее время он не поддерживает Storable's hooks для переопределения способа глубокого клонирования.</target>
        </trans-unit>
        <trans-unit id="d1abe7c402c9589925c2fd5cdd3fc7738d6e503b" translate="yes" xml:space="preserve">
          <source>There is a Perl interface to TrollTech's Qt toolkit, but it does not appear to be maintained.</source>
          <target state="translated">В инструментарии TrollTech's Qt есть Perl интерфейс,но он,кажется,не обслуживается.</target>
        </trans-unit>
        <trans-unit id="2368d7b8dd55271d773f21a14ae9eb87cfb16560" translate="yes" xml:space="preserve">
          <source>There is a bug in perl5.6.0 with UV's that are &amp;gt;= 1&amp;lt;&amp;lt;31. This will show up as tests 8 and 9 of dualvar.t failing</source>
          <target state="translated">В perl5.6.0 есть ошибка с UV&amp;gt; = 1 &amp;lt;&amp;lt; 31. Это будет отображаться как неудачные тесты 8 и 9 файла dualvar.t</target>
        </trans-unit>
        <trans-unit id="74ad132a2446bd3d40e9bf990b8f1b1aa2a313b3" translate="yes" xml:space="preserve">
          <source>There is a central directory for the Perl community: &lt;a href=&quot;http://perl.org&quot;&gt;http://perl.org&lt;/a&gt; maintained by the Perl Foundation (&lt;a href=&quot;http://www.perlfoundation.org/&quot;&gt;http://www.perlfoundation.org/&lt;/a&gt;), which tracks and provides services for a variety of other community sites.</source>
          <target state="translated">Существует центральный каталог сообщества Perl: &lt;a href=&quot;http://perl.org&quot;&gt;http://perl.org,&lt;/a&gt; поддерживаемый Perl Foundation ( &lt;a href=&quot;http://www.perlfoundation.org/&quot;&gt;http://www.perlfoundation.org/&lt;/a&gt; ), который отслеживает и предоставляет услуги для множества других сайтов сообщества.</target>
        </trans-unit>
        <trans-unit id="b14e35e5c9ac344a8ff5825a4050f6c40c0d0c03" translate="yes" xml:space="preserve">
          <source>There is a class method in &lt;code&gt;PerlIO::Layer&lt;/code&gt;&lt;code&gt;find&lt;/code&gt; which is implemented as XS code. It is called by &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to validate the layers:</source>
          <target state="translated">В &lt;code&gt;PerlIO::Layer&lt;/code&gt; &lt;code&gt;find&lt;/code&gt; есть метод класса, который реализован в виде кода XS. Он вызывается при &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; для проверки слоев:</target>
        </trans-unit>
        <trans-unit id="ba9884f209caf6d0506a39ac341c0ea3ddd78c13" translate="yes" xml:space="preserve">
          <source>There is a class method in &lt;code&gt;PerlIO::Layer&lt;/code&gt;&lt;code&gt;find&lt;/code&gt; which is implemented as XS code. It is called by &lt;code&gt;import&lt;/code&gt; to validate the layers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130b2ceadd9a5f49d4085944a7e2f2612f7d6b00" translate="yes" xml:space="preserve">
          <source>There is a facility called &quot;file extension associations&quot;. This can be manipulated via the two commands &quot;assoc&quot; and &quot;ftype&quot; that come standard with Windows. Type &quot;ftype /?&quot; for a complete example of how to set this up for perl scripts (Say what? You thought Windows wasn't perl-ready? :).</source>
          <target state="translated">Существует средство,называемое &quot;ассоциации файловых расширений&quot;.Им можно манипулировать с помощью двух команд &quot;assoc&quot; и &quot;ftype&quot;,которые стандартно поставляются с Windows.Введите &quot;ftype /?&quot; для полного примера того,как настроить это для perl скриптов (Скажите что? Вы думали,что Windows не готова? :).</target>
        </trans-unit>
        <trans-unit id="56c8b0f7b0876f90abc844b5aa213cd2600b5f4e" translate="yes" xml:space="preserve">
          <source>There is a fairly obvious gotcha included with the line directive: Debuggers and profilers will only show the last source line to appear at a particular line number in a given file. Care should be taken not to cause line number collisions in code you'd like to debug later.</source>
          <target state="translated">Есть довольно очевидное попадание,включенное в директиву line:Отладчики и профайлеры покажут только последнюю строку исходного текста,которая появится на определенном номере строки в данном файле.Следует позаботиться о том,чтобы не вызвать коллизии номеров строк в коде,который вы хотите отладить позже.</target>
        </trans-unit>
        <trans-unit id="bb9de8709414ce3be99387c65eb446322517dbc7" translate="yes" xml:space="preserve">
          <source>There is a full version history in the Changes file, and the Test::More versions included as core can be found using &lt;a href=&quot;../module/corelist&quot;&gt;Module::CoreList&lt;/a&gt;:</source>
          <target state="translated">В файле изменений есть полная история версий, а версии Test :: More, включенные в качестве основных, можно найти с помощью &lt;a href=&quot;../module/corelist&quot;&gt;Module :: CoreList&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="fc72621c4f74524103b116a2301e947655e4bfff" translate="yes" xml:space="preserve">
          <source>There is a full version history in the Changes file, and the Test::More versions included as core can be found using &lt;a href=&quot;Module::CoreList&quot;&gt;Module::CoreList&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8d363093d476f461ae875eb02ff5a19f7dc579" translate="yes" xml:space="preserve">
          <source>There is a functional programming API available for programmers to query information.</source>
          <target state="translated">Программистам доступен функциональный API программирования для запроса информации.</target>
        </trans-unit>
        <trans-unit id="a15e4bcad41aa0b597b5c043d274e21e152196d8" translate="yes" xml:space="preserve">
          <source>There is a further complication with non-closure anonymous subs (i.e. those that do not refer to any lexicals outside that sub). In this case, the anonymous prototype is shared rather than being cloned. This has the consequence that the parent may be freed while there are still active children,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2afd310e60a2687221eb36caee1877ab18ed5e49" translate="yes" xml:space="preserve">
          <source>There is a further complication with non-closure anonymous subs (i.e. those that do not refer to any lexicals outside that sub). In this case, the anonymous prototype is shared rather than being cloned. This has the consequence that the parent may be freed while there are still active children, eg</source>
          <target state="translated">Есть еще одно осложнение,связанное с неразглашением анонимных субстанций (т.е.тех,которые не ссылаются ни на какие лексики за пределами этой субстанции).В этом случае анонимный прототип является общим,а не клонируется.Это приводит к тому,что родитель может быть освобождён,пока ещё есть активные дети,например,в следующих случаях</target>
        </trans-unit>
        <trans-unit id="6e38f9a6f0524cb60060c7ab66b100df8645a3df" translate="yes" xml:space="preserve">
          <source>There is a given/when statement in Perl, but it is experimental and likely to change in future. See &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bfd060d0feb488ff6b3d46ad13ea7e46b879b0f" translate="yes" xml:space="preserve">
          <source>There is a known bug in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f36a7b0d4fbbd5ecb9f7c10c28ff43dbc8a0e2c1" translate="yes" xml:space="preserve">
          <source>There is a large collection of locale definitions at:</source>
          <target state="translated">Существует большая коллекция определений локалей:</target>
        </trans-unit>
        <trans-unit id="164a3c40b19ffea76d12a9ba083e8f9f3b80b6e7" translate="yes" xml:space="preserve">
          <source>There is a large memory overhead for each record offset and for each cache entry: about 310 bytes per cached data record, and about 21 bytes per offset table entry.</source>
          <target state="translated">Для каждого смещения записи и для каждой записи в кэше существует большая загруженность памяти:около 310 байт на одну запись кэшированных данных и около 21 байта на одну запись таблицы смещения.</target>
        </trans-unit>
        <trans-unit id="6d613e26c7817a472a293f57a0848d067f1f9f1e" translate="yes" xml:space="preserve">
          <source>There is a lint variant called &lt;code&gt;splint&lt;/code&gt; (Secure Programming Lint) available from &lt;a href=&quot;http://www.splint.org/&quot;&gt;http://www.splint.org/&lt;/a&gt; that should compile on any Unix-like platform.</source>
          <target state="translated">Существует вариант lint, называемый &lt;code&gt;splint&lt;/code&gt; (Secure Programming Lint), доступный на &lt;a href=&quot;http://www.splint.org/&quot;&gt;http://www.splint.org/,&lt;/a&gt; который должен компилироваться на любой Unix-подобной платформе.</target>
        </trans-unit>
        <trans-unit id="50d5366c81be8e75e037c5167a3d288dd1f93227" translate="yes" xml:space="preserve">
          <source>There is a list &lt;code&gt;=item&lt;/code&gt; right above the flagged line that has no text contents. You probably want to delete empty items.</source>
          <target state="translated">Прямо над отмеченной строкой есть list &lt;code&gt;=item&lt;/code&gt; , не имеющий текстового содержимого. Вероятно, вы захотите удалить пустые элементы.</target>
        </trans-unit>
        <trans-unit id="9491003a2d6e2370bad105f107b81a379a482390" translate="yes" xml:space="preserve">
          <source>There is a list &lt;code&gt;=item&lt;/code&gt; that has no text contents. You probably want to delete empty items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f99dfe0ca2905f67ecab8086230b0fc7ddbaec" translate="yes" xml:space="preserve">
          <source>There is a mailing list available for users of this distribution, &lt;a href=&quot;mailto:datetime@perl.org&quot;&gt;mailto:datetime@perl.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e52de09f7d095fa1c4329ee2a9ca8823bc2d60ff" translate="yes" xml:space="preserve">
          <source>There is a partial workaround (which can be made complete with newer OS/2 kernels): create a forwarder DLL with the same name as the DLL of the older version of Perl, which forwards the entry points to the newer Perl's DLL. Make this DLL accessible on (say) the &lt;code&gt;BEGINLIBPATH&lt;/code&gt; of the new Perl executable. When the new executable accesses old Perl's extension DLLs, they would request the old Perl's DLL by name, get the forwarder instead, so effectively will link with the currently running (new) Perl DLL.</source>
          <target state="translated">Существует частичный обходной путь (который может быть выполнен в комплекте с новыми ядрами OS / 2): создать DLL пересылки с тем же именем, что и у DLL старой версии Perl, которая перенаправляет точки входа в более новую библиотеку Perl. Сделайте эту DLL доступной (скажем) на &lt;code&gt;BEGINLIBPATH&lt;/code&gt; нового исполняемого файла Perl. Когда новый исполняемый файл обращается к старым библиотекам расширений Perl, они запрашивают старую DLL Perl по имени, вместо этого получают средство пересылки, поэтому эффективно связываются с текущей (новой) DLL Perl.</target>
        </trans-unit>
        <trans-unit id="d1126a23763c29c3a1bec0b9bdcdb94247472fba" translate="yes" xml:space="preserve">
          <source>There is a potential syntactic ambiguity between signatures and prototypes (see &lt;a href=&quot;#Prototypes&quot;&gt;&quot;Prototypes&quot;&lt;/a&gt;), because both start with an opening parenthesis and both can appear in some of the same places, such as just after the name in a subroutine declaration. For historical reasons, when signatures are not enabled, any opening parenthesis in such a context will trigger very forgiving prototype parsing. Most signatures will be interpreted as prototypes in those circumstances, but won't be valid prototypes. (A valid prototype cannot contain any alphabetic character.) This will lead to somewhat confusing error messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ca9ff3bac6a75872d6256fe67ed0855ac24ebb" translate="yes" xml:space="preserve">
          <source>There is a potential syntactic ambiguity between signatures and prototypes (see &lt;a href=&quot;#Prototypes&quot;&gt;Prototypes&lt;/a&gt;), because both start with an opening parenthesis and both can appear in some of the same places, such as just after the name in a subroutine declaration. For historical reasons, when signatures are not enabled, any opening parenthesis in such a context will trigger very forgiving prototype parsing. Most signatures will be interpreted as prototypes in those circumstances, but won't be valid prototypes. (A valid prototype cannot contain any alphabetic character.) This will lead to somewhat confusing error messages.</source>
          <target state="translated">Существует потенциальная синтаксическая двусмысленность между сигнатурами и прототипами (см. &lt;a href=&quot;#Prototypes&quot;&gt;Прототипы&lt;/a&gt; ), потому что оба начинаются с открывающей круглой скобки и оба могут появляться в одних и тех же местах, например, сразу после имени в объявлении подпрограммы. По историческим причинам, когда подписи не включены, любая открывающая скобка в таком контексте вызовет очень щадящий синтаксический анализ прототипа. Большинство подписей будут интерпретироваться как прототипы в этих обстоятельствах, но не будут действительными прототипами. (Действительный прототип не может содержать буквенные символы.) Это приведет к появлению несколько запутанных сообщений об ошибках.</target>
        </trans-unit>
        <trans-unit id="d27354b37f9e6840bfd23c6a2efc0450a836df2f" translate="yes" xml:space="preserve">
          <source>There is a relationship between roles and classes, as each class implies the existence of a role of the same name. There is also a relationship between inheritance and roles, in that a subclass that inherits from an ancestor class implicitly performs any roles its parent performs. Thus you can use &lt;code&gt;DOES&lt;/code&gt; in place of &lt;code&gt;isa&lt;/code&gt; safely, as it will return true in all places where &lt;code&gt;isa&lt;/code&gt; will return true (provided that any overridden &lt;code&gt;DOES&lt;/code&gt;</source>
          <target state="translated">Между ролями и классами существует взаимосвязь, поскольку каждый класс подразумевает существование роли с таким же именем. Существует также связь между наследованием и ролями, поскольку подкласс, наследующий от класса-предка, неявно выполняет любые роли, которые выполняет его родительский класс. Таким образом, вы можете безопасно использовать &lt;code&gt;DOES&lt;/code&gt; вместо &lt;code&gt;isa&lt;/code&gt; , так как он вернет true во всех местах, где &lt;code&gt;isa&lt;/code&gt; вернет true (при условии, что любое переопределенное значение &lt;code&gt;DOES&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d92cff32e2893123d7b11efd15dfbc88dd3973f8" translate="yes" xml:space="preserve">
          <source>There is a rich ecosystem of &lt;code&gt;Moose&lt;/code&gt; extensions on CPAN under the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2fsearch%3fquery%3dMooseX%26mode%3ddist&quot;&gt;MooseX&lt;/a&gt; namespace. In addition, many modules on CPAN already use &lt;code&gt;Moose&lt;/code&gt; , providing you with lots of examples to learn from.</source>
          <target state="translated">На CPAN существует богатая экосистема расширений &lt;code&gt;Moose&lt;/code&gt; в пространстве имен &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2fsearch%3fquery%3dMooseX%26mode%3ddist&quot;&gt;MooseX&lt;/a&gt; . Кроме того, многие модули CPAN уже используют &lt;code&gt;Moose&lt;/code&gt; , что дает вам множество примеров, на которых можно учиться.</target>
        </trans-unit>
        <trans-unit id="63c6a415ec649ec3fee18b8a757da8ffbc58b528" translate="yes" xml:space="preserve">
          <source>There is a rich ecosystem of &lt;code&gt;Moose&lt;/code&gt; extensions on CPAN under the &lt;a href=&quot;https://metacpan.org/search?q=MooseX&quot;&gt;MooseX&lt;/a&gt; namespace. In addition, many modules on CPAN already use &lt;code&gt;Moose&lt;/code&gt;, providing you with lots of examples to learn from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db652ab14c5e9efe4a7bcfa81f503ee955d3fa8" translate="yes" xml:space="preserve">
          <source>There is a section detected in the page name of L&amp;lt;...&amp;gt;, e.g. &lt;code&gt;L&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; . POD hyperlinks may point to POD documents only. Please write &lt;code&gt;C&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; instead. Some formatters are able to expand this to appropriate code. For links to (builtin) functions, please say &lt;code&gt;L&amp;lt;perlfunc/mkdir&amp;gt;&lt;/code&gt; , without ().</source>
          <target state="translated">Обнаружен раздел в имени страницы L &amp;lt;...&amp;gt;, например, &lt;code&gt;L&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; . Гиперссылки POD могут указывать только на документы POD. Напишите вместо этого &lt;code&gt;C&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; . Некоторые программы форматирования могут расширить это до соответствующего кода. Для ссылок на (встроенные) функции, пожалуйста, скажите &lt;code&gt;L&amp;lt;perlfunc/mkdir&amp;gt;&lt;/code&gt; без ().</target>
        </trans-unit>
        <trans-unit id="00c1ae760ee79d8ac4a3185792db70643cfa006e" translate="yes" xml:space="preserve">
          <source>There is a single stash called &lt;code&gt;PL_defstash&lt;/code&gt; that holds the items that exist in the &lt;code&gt;main&lt;/code&gt; package. To get at the items in other packages, append the string &quot;::&quot; to the package name. The items in the &lt;code&gt;Foo&lt;/code&gt; package are in the stash &lt;code&gt;Foo::&lt;/code&gt; in PL_defstash. The items in the &lt;code&gt;Bar::Baz&lt;/code&gt; package are in the stash &lt;code&gt;Baz::&lt;/code&gt; in &lt;code&gt;Bar::&lt;/code&gt; 's stash.</source>
          <target state="translated">Существует единственный тайник под названием &lt;code&gt;PL_defstash&lt;/code&gt; ,в котором хранятся элементы, существующие в &lt;code&gt;main&lt;/code&gt; пакете. Чтобы получить доступ к элементам в других пакетах, добавьте строку &amp;laquo;::&amp;raquo; к имени пакета. Элементы пакета &lt;code&gt;Foo&lt;/code&gt; находятся в тайнике &lt;code&gt;Foo::&lt;/code&gt; в PL_defstash. Элементы в пакете &lt;code&gt;Bar::Baz&lt;/code&gt; находятся в тайнике &lt;code&gt;Baz::&lt;/code&gt; in &lt;code&gt;Bar::&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da12b97e4f2d1305f926ea3b6d55a42d5c8e4baf" translate="yes" xml:space="preserve">
          <source>There is a single stash called &lt;code&gt;PL_defstash&lt;/code&gt; that holds the items that exist in the &lt;code&gt;main&lt;/code&gt; package. To get at the items in other packages, append the string &quot;::&quot; to the package name. The items in the &lt;code&gt;Foo&lt;/code&gt; package are in the stash &lt;code&gt;Foo::&lt;/code&gt; in PL_defstash. The items in the &lt;code&gt;Bar::Baz&lt;/code&gt; package are in the stash &lt;code&gt;Baz::&lt;/code&gt; in &lt;code&gt;Bar::&lt;/code&gt;'s stash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410d21275559c0b069f15cf1ae78b078a451978c" translate="yes" xml:space="preserve">
          <source>There is a special form of this construct, called &lt;code&gt;\K&lt;/code&gt; (available since Perl 5.10.0), which causes the regex engine to &quot;keep&quot; everything it had matched prior to the &lt;code&gt;\K&lt;/code&gt; and not include it in &lt;code&gt;$&amp;amp;&lt;/code&gt; . This effectively provides variable-length look-behind. The use of &lt;code&gt;\K&lt;/code&gt; inside of another look-around assertion is allowed, but the behaviour is currently not well defined.</source>
          <target state="translated">Существует особая форма этой конструкции, называемая &lt;code&gt;\K&lt;/code&gt; (доступная с Perl 5.10.0), которая заставляет обработчик регулярных выражений &amp;laquo;сохранять&amp;raquo; все, что было сопоставлено до &lt;code&gt;\K&lt;/code&gt; и не включать это в &lt;code&gt;$&amp;amp;&lt;/code&gt; . Это эффективно обеспечивает возможность просмотра назад переменной длины. Использование &lt;code&gt;\K&lt;/code&gt; внутри другого утверждения просмотра разрешено, но поведение в настоящее время четко не определено.</target>
        </trans-unit>
        <trans-unit id="132434df2410147d359e3620818bc1c35f77d26b" translate="yes" xml:space="preserve">
          <source>There is a special form of this construct, called &lt;code&gt;\K&lt;/code&gt; (available since Perl 5.10.0), which causes the regex engine to &quot;keep&quot; everything it had matched prior to the &lt;code&gt;\K&lt;/code&gt; and not include it in &lt;code&gt;$&amp;amp;&lt;/code&gt;. This effectively provides non-experimental variable-length lookbehind of any length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0599747d66099e132ad6b9e84b12be8636f0ae4e" translate="yes" xml:space="preserve">
          <source>There is a syntax error in the /usr/include/sys/socket.h header file that IBM supplies with USS V2R7, V2R8, and possibly V2R9. The problem with the header file is that near the definition of the SO_REUSEPORT constant there is a spurious extra '/' character outside of a comment like so:</source>
          <target state="translated">В заголовочном файле /usr/include/sys/socket.h,который IBM поставляет с USS V2R7,V2R8 и,возможно,V2R9,имеется синтаксическая ошибка.Проблема с заголовочным файлом заключается в том,что рядом с определением константы SO_REUSEPORT есть поддельный дополнительный символ '/' вне комментария типа этого:</target>
        </trans-unit>
        <trans-unit id="4f5af7c338789d7b91669b50869dfdd492384f9b" translate="yes" xml:space="preserve">
          <source>There is a technique that can be used to handle variable length lookbehinds on earlier releases, and longer than 255 characters. It is described in &lt;a href=&quot;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&quot;&gt;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b527eadae01dab13ed85ec63c9837bc3c0c67bda" translate="yes" xml:space="preserve">
          <source>There is a tradeoff between taking full advantage of one particular type of computer and taking advantage of a full range of them. Naturally, as you broaden your range and become more diverse, the common factors drop, and you are left with an increasingly smaller area of common ground in which you can operate to accomplish a particular task. Thus, when you begin attacking a problem, it is important to consider under which part of the tradeoff curve you want to operate. Specifically, you must decide whether it is important that the task that you are coding has the full generality of being portable, or whether to just get the job done right now. This is the hardest choice to be made. The rest is easy, because Perl provides many choices, whichever way you want to approach your problem.</source>
          <target state="translated">Существует компромисс между полным использованием преимуществ одного конкретного типа компьютера и полным их диапазоном.Естественно,по мере того,как вы расширяете свой ассортимент и становитесь все более разнообразными,общие факторы падают,и у вас остается все меньшая площадь,на которой вы можете работать для выполнения определенной задачи.Таким образом,когда вы начинаете атаковать проблему,важно учитывать,под какой частью кривой компромисса вы хотите работать.В частности,вы должны решить,важно ли то,что задача,которую вы кодируете,имеет полную универсальность переносимости,или же вы просто выполняете работу прямо сейчас.Это самый трудный выбор.Остальное легко,потому что Perl предоставляет множество вариантов,независимо от того,как вы хотите подойти к своей проблеме.</target>
        </trans-unit>
        <trans-unit id="8ea25b9abfe4373f567bc9679e7275e7fb164486" translate="yes" xml:space="preserve">
          <source>There is a utility called &lt;a href=&quot;../corelist&quot;&gt;corelist&lt;/a&gt; provided with this module which is a convenient way of querying from the command-line.</source>
          <target state="translated">С этим модулем поставляется утилита &lt;a href=&quot;../corelist&quot;&gt;corelist,&lt;/a&gt; которая является удобным способом выполнения запросов из командной строки.</target>
        </trans-unit>
        <trans-unit id="26e6ac611235e43f07c357cfef8c6952cf104cdd" translate="yes" xml:space="preserve">
          <source>There is a utility called &lt;a href=&quot;corelist&quot;&gt;corelist&lt;/a&gt; provided with this module which is a convenient way of querying from the command-line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82aef8cfd5e32e2a307fc10353cb3d2e49f98a7d" translate="yes" xml:space="preserve">
          <source>There is a variable &lt;code&gt;$File::Find::fullname&lt;/code&gt; which holds the absolute pathname of the file with all symbolic links resolved. If the link is a dangling symbolic link, then fullname will be set to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Существует переменная &lt;code&gt;$File::Find::fullname&lt;/code&gt; которая содержит абсолютный путь к файлу со всеми разрешенными символическими ссылками. Если ссылка представляет собой висящую символическую ссылку, то для полного имени будет установлено &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="973df2b639c4d3b005a76e2b6bc5345ee00adfab" translate="yes" xml:space="preserve">
          <source>There is a variable &lt;code&gt;$File::Find::fullname&lt;/code&gt; which holds the absolute pathname of the file with all symbolic links resolved. If the link is a dangling symbolic link, then fullname will be set to &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9ea31c4237da29f14d09c3e17b0abf6058f6c2" translate="yes" xml:space="preserve">
          <source>There is a way to achieve a similar task from C via Perl API: create a</source>
          <target state="translated">Есть способ достичь аналогичной задачи из C через Perl API:создать a</target>
        </trans-unit>
        <trans-unit id="186d9ac4ec1df84f73c4528af239edb0b67d87e7" translate="yes" xml:space="preserve">
          <source>There is a way to completely hide any modifiable globals (they are all moved to heap), the compilation setting &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt; . It is not normally used, but can be used for testing, read more about it in &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;Background and PERL_IMPLICIT_CONTEXT in perlguts&lt;/a&gt;.</source>
          <target state="translated">Есть способ полностью скрыть любые изменяемые глобальные объекты (все они перемещаются в кучу), настройка компиляции &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt; . Обычно он не используется, но может использоваться для тестирования, подробнее об этом &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;читайте в разделе &amp;laquo;Фон&amp;raquo; и &amp;laquo;PERL_IMPLICIT_CONTEXT&amp;raquo; в perlguts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6e88f7ecf4798ea1155b449543fac9f0b354b61" translate="yes" xml:space="preserve">
          <source>There is a way to completely hide any modifiable globals (they are all moved to heap), the compilation setting &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt;. It is not normally used, but can be used for testing, read more about it in &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;&quot;Background and PERL_IMPLICIT_CONTEXT&quot; in perlguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887ba5df14249dda0cf87b4c4aa3777b9fca5f36" translate="yes" xml:space="preserve">
          <source>There is a way to tell perl to do complete cleanup: set the environment variable PERL_DESTRUCT_LEVEL to a non-zero value. The t/TEST wrapper does set this to 2, and this is what you need to do too, if you don't want to see the &quot;global leaks&quot;: For example, for running under valgrind</source>
          <target state="translated">Есть способ сказать perl сделать полную очистку:установить переменную окружения PERL_DESTRUCT_LEVEL в ненулевое значение.Обертка t/TEST действительно устанавливает это значение в 2,и это то,что вам тоже нужно сделать,если вы не хотите видеть &quot;глобальные утечки&quot;:Например,для работы под valgrind</target>
        </trans-unit>
        <trans-unit id="691cdea86f4db4ba9a2ac59e7fc6b55f031421ad" translate="yes" xml:space="preserve">
          <source>There is absolutely no excuse for not documenting your extension. Documentation belongs in the .pm file. This file will be fed to pod2man, and the embedded documentation will be converted to the manpage format, then placed in the blib directory. It will be copied to Perl's manpage directory when the extension is installed.</source>
          <target state="translated">Нет абсолютно никаких оправданий для того,чтобы не документировать ваше продление.Документация находится в файле .pm.Этот файл будет передан в pod2man,а встроенная документация будет преобразована в формат manpage,а затем помещена в каталог blib.После установки расширения она будет скопирована в каталог manpage Perl.</target>
        </trans-unit>
        <trans-unit id="d8cca778f6ffeefe438e516146882fedcff922a7" translate="yes" xml:space="preserve">
          <source>There is also &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigrat;&lt;/code&gt; which gives you big rationals:</source>
          <target state="translated">Есть также &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigrat;&lt;/code&gt; что дает вам большой разум:</target>
        </trans-unit>
        <trans-unit id="9cf519c73fbae0fe8c0d4ffe79764b81487dc294" translate="yes" xml:space="preserve">
          <source>There is also &lt;code&gt;use bigrat;&lt;/code&gt; which gives you big rationals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43bcf99a2a57a573a071e20e50556250aa32095b" translate="yes" xml:space="preserve">
          <source>There is also a function to add magic to an &lt;code&gt;HV&lt;/code&gt; :</source>
          <target state="translated">Также есть функция для добавления магии в &lt;code&gt;HV&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5e09c6821154895943bc8dd098914ffb05015157" translate="yes" xml:space="preserve">
          <source>There is also a function to add magic to an &lt;code&gt;HV&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f310316f81fc52692e5ac947e6e74f350603233" translate="yes" xml:space="preserve">
          <source>There is also a larger form of a char class structure used to represent POSIX char classes under &lt;code&gt;/l&lt;/code&gt; matching, called &lt;code&gt;regnode_charclass_posixl&lt;/code&gt; which has an additional 32-bit bitmap indicating which POSIX char classes have been included.</source>
          <target state="translated">Существует также более крупная форма структуры классов символов POSIX, используемая для представления классов символов POSIX при сопоставлении &lt;code&gt;/l&lt;/code&gt; , называемая &lt;code&gt;regnode_charclass_posixl&lt;/code&gt; , которая имеет дополнительный 32-битный битовый массив, указывающий, какие классы символов POSIX были включены.</target>
        </trans-unit>
        <trans-unit id="76c5f483367def15ac8c922d54c4856b499dee91" translate="yes" xml:space="preserve">
          <source>There is also a mailing list available for users of this distribution, at &lt;a href=&quot;http://lists.perl.org/list/cpan-workers.html&quot;&gt;http://lists.perl.org/list/cpan-workers.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1a33cdb5c1f767d6b5b045c29afd70795ca96e" translate="yes" xml:space="preserve">
          <source>There is also a toyedit Text widget based editor written in Perl that is distributed with the Tk module on CPAN. The ptkdb ( &lt;a href=&quot;http://ptkdb.sourceforge.net/&quot;&gt;http://ptkdb.sourceforge.net/&lt;/a&gt; ) is a Perl/Tk-based debugger that acts as a development environment of sorts. Perl Composer ( &lt;a href=&quot;http://perlcomposer.sourceforge.net/&quot;&gt;http://perlcomposer.sourceforge.net/&lt;/a&gt; ) is an IDE for Perl/Tk GUI creation.</source>
          <target state="translated">Существует также редактор на основе виджета Toyedit Text, написанный на Perl, который распространяется с модулем Tk на CPAN. Ptkdb ( &lt;a href=&quot;http://ptkdb.sourceforge.net/&quot;&gt;http://ptkdb.sourceforge.net/&lt;/a&gt; ) - это отладчик на основе Perl / Tk, который действует как своего рода среда разработки. Perl Composer ( &lt;a href=&quot;http://perlcomposer.sourceforge.net/&quot;&gt;http://perlcomposer.sourceforge.net/&lt;/a&gt; ) - это IDE для создания графического интерфейса Perl / Tk.</target>
        </trans-unit>
        <trans-unit id="d6fbaba8f9d7c369b3de63f57e236ae1dbe1ef42" translate="yes" xml:space="preserve">
          <source>There is also an irc channel available for users of this distribution, at &lt;a href=&quot;irc://irc.perl.org/#toolchain&quot;&gt;&lt;code&gt;#toolchain&lt;/code&gt; on &lt;code&gt;irc.perl.org&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d533bbf93c93c54738d070099b6cc38c79c4b031" translate="yes" xml:space="preserve">
          <source>There is an active user community that provides many software packages for the Synology DSM systems; at the time of writing this document they provide Perl version 5.24.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace8b22bc48d6e6e8b62fe08966c97467280b304" translate="yes" xml:space="preserve">
          <source>There is an edge case when using &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; from within a subroutine which was created in a different module than the one it is called from. It sounds complicated, but it really isn't. Here is an example which will not work correctly:</source>
          <target state="translated">Существует крайний случай при использовании &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; из подпрограммы, которая была создана в другом модуле, чем тот, из которого она вызывается. Звучит сложно, но на самом деле это не так. Вот пример, который не будет работать правильно:</target>
        </trans-unit>
        <trans-unit id="689977e776e24b93188512fdd38744344797e09f" translate="yes" xml:space="preserve">
          <source>There is an edge case when using &lt;code&gt;next::method&lt;/code&gt; from within a subroutine which was created in a different module than the one it is called from. It sounds complicated, but it really isn't. Here is an example which will not work correctly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407ad0e2a6f54d3dcabda775887575e4b7a50908" translate="yes" xml:space="preserve">
          <source>There is another directory ($CPAN::Config-&amp;gt;{keep_source_where}) where the original distribution files are kept. This directory is not covered by the cache manager and must be controlled by the user. If you choose to have the same directory as build_dir and as keep_source_where directory, then your sources will be deleted with the same fifo mechanism.</source>
          <target state="translated">Есть еще один каталог ($ CPAN :: Config -&amp;gt; {keep_source_where}), где хранятся исходные файлы распространения. Этот каталог не покрывается диспетчером кеширования и должен контролироваться пользователем. Если вы выберете тот же каталог, что и build_dir, и каталог keep_source_where, ваши источники будут удалены с помощью того же механизма fifo.</target>
        </trans-unit>
        <trans-unit id="58cdb83a1e784fb0e74fd64a5af55da9c7c710fa" translate="yes" xml:space="preserve">
          <source>There is another method which can be used, namely letting Perl do it for you automatically whenever it regains control after the callback has terminated. This is done by simply not using the</source>
          <target state="translated">Есть еще один метод,который может быть использован,а именно,позволить Perl делать это за вас автоматически,когда он возвращает контроль после завершения обратного вызова.Это делается путем простого отказа от использования</target>
        </trans-unit>
        <trans-unit id="259d1525b7b40afbda3635dfb60885ec2065cd0c" translate="yes" xml:space="preserve">
          <source>There is another way to trade clarity for compactness: INPUT sections allow declaration of C variables which do not appear in the parameter list of a subroutine. Thus the above code for mutate() can be rewritten as</source>
          <target state="translated">Есть еще один способ обменять прозрачность на компактность:ИНПУТ-секции позволяют объявлять переменные C,которые не появляются в списке параметров подпрограммы.Таким образом,приведенный выше код для mutate()можно переписать как</target>
        </trans-unit>
        <trans-unit id="69c800bd073688bcd19d75ca494a0e096bef464f" translate="yes" xml:space="preserve">
          <source>There is currently no method for going the other way; but I can probably provide one upon request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6993af1c1a90a2fde20c8f99658cf4ef71df4e8c" translate="yes" xml:space="preserve">
          <source>There is currently no way to turn off the guesswork that tries to format unmarked text appropriately, and sometimes it isn't wanted (particularly when using POD to document something other than Perl). Most of the work toward fixing this has now been done, however, and all that's still needed is a user interface.</source>
          <target state="translated">В настоящее время нет способа отключить догадки,которые пытаются правильно отформатировать немаркированный текст,а иногда и не нужны (особенно при использовании POD для документирования чего-то кроме Perl).Большая часть работы по исправлению этого,однако,уже сделана,и все,что все еще нужно-это пользовательский интерфейс.</target>
        </trans-unit>
        <trans-unit id="658a8d7bbc3f0f0bd3eee360c95b181c02d32e56" translate="yes" xml:space="preserve">
          <source>There is lots more to bracketed character classes; full details are in &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;&quot;Bracketed Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923e1f4510dc236d985b28a823797fd535b1836b" translate="yes" xml:space="preserve">
          <source>There is no</source>
          <target state="translated">Нет</target>
        </trans-unit>
        <trans-unit id="4ac6b5cad845dedcdb84c876c16dd65a46ac7fff" translate="yes" xml:space="preserve">
          <source>There is no 2GB limit on process size.</source>
          <target state="translated">Ограничения по размеру процесса в 2 ГБ не существует.</target>
        </trans-unit>
        <trans-unit id="4389ed97cd408884e879872fd75e0815bd058c0d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;*.bs&lt;/code&gt; file supplied with the extension. Instead, there may be a &lt;code&gt;*_BS&lt;/code&gt; file which has code for the special cases, like posix for berkeley db on the NeXT.</source>
          <target state="translated">Там нет &lt;code&gt;*.bs&lt;/code&gt; файла поставляется с расширением. Вместо этого может быть файл &lt;code&gt;*_BS&lt;/code&gt; , который содержит код для особых случаев, например posix для berkeley db на NeXT.</target>
        </trans-unit>
        <trans-unit id="f9908fb44bd4986c8ec4678f0acbb2e49a902c07" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;sysseek($fh, 0, 1)&lt;/code&gt;&lt;/a&gt; for that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b489252bb15e6f1ecbef798ed7f66f86847082" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; for that.</source>
          <target state="translated">Там нет &lt;code&gt;systell&lt;/code&gt; функции. Используйте для этого &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ea7c815b6a5bfae1bac221a98896771b7bb3184" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; for that.</source>
          <target state="translated">Там нет &lt;code&gt;systell&lt;/code&gt; функции. Используйте для этого &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76a2f2ea0128a2c9f814d14705cbf22fee6bb330" translate="yes" xml:space="preserve">
          <source>There is no BNF, but you can paw your way through the yacc grammar in perly.y in the source distribution if you're particularly brave. The grammar relies on very smart tokenizing code, so be prepared to venture into toke.c as well.</source>
          <target state="translated">Нет никакого BNF,но вы можете проложить свой путь через грамматику yacc в perly.y в дистрибутиве исходников,если вы особенно храбры.Грамматика основана на очень умном символизирующем коде,так что будьте готовы рискнуть и на toke.c.</target>
        </trans-unit>
        <trans-unit id="32ad1aee364e105dad5b41374df7e156cb6a43e2" translate="yes" xml:space="preserve">
          <source>There is no advantage to putting subroutines which will _always_ be called after the &lt;code&gt;__DATA__&lt;/code&gt; token.</source>
          <target state="translated">Нет никакого преимущества в размещении подпрограмм, которые _всегда_ вызываются после токена &lt;code&gt;__DATA__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a280984dba8147f4930e83be6fff5dcdd90c3af1" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; function calls the &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method for the package used. See also &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91dc6d303227194ff188b9dc751fb889211ca0d" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; function calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the package used. See also &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">Встроенной функции &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; . Это просто обычный метод (подпрограмма), определенный (или унаследованный) модулями, которые хотят экспортировать имена в другой модуль. Функция &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; вызывает метод &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; для используемого пакета. Смотрите также &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt; , &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; и &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe76bcf1a7a27510fd944eef657a41eda4d72a44" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; function calls the &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the package used. See also &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">Встроенной функции &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; . Это просто обычный метод (подпрограмма), определенный (или унаследованный) модулями, которые хотят экспортировать имена в другой модуль. Функция &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; вызывает метод &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; для используемого пакета. Смотрите также &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; , &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt; и &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05fb5ccde6fe684391b3c4f8ff40b801e9c52e40" translate="yes" xml:space="preserve">
          <source>There is no builtin way to say &quot;float this to the right hand side of the page, however wide it is.&quot; You have to specify where it goes. The truly desperate can generate their own format on the fly, based on the current number of columns, and then eval() it:</source>
          <target state="translated">Нет встроенного способа сказать &quot;переместите это в правую часть страницы,какой бы широкой она не была&quot;.Вы должны указать,куда это идет.По-настоящему отчаявшиеся могут сгенерировать свой собственный формат на лету,основываясь на текущем количестве столбцов,а затем eval()его:</target>
        </trans-unit>
        <trans-unit id="5ec86a2b5c6a22a41774d9be82dd0c618a3c5c45" translate="yes" xml:space="preserve">
          <source>There is no check to assert that the filehandle passed from Perl to C was created with the right &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; mode.</source>
          <target state="translated">Нет проверки, чтобы утверждать, что дескриптор файла, переданный из Perl в C, был создан в правильном режиме &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="218dbdb05fa2faf351feae2d57dfa67d5a01ea2a" translate="yes" xml:space="preserve">
          <source>There is no check to assert that the filehandle passed from Perl to C was created with the right &lt;code&gt;open()&lt;/code&gt; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4297cc5a425f7dacf2e1ca88cce095827acd4bc7" translate="yes" xml:space="preserve">
          <source>There is no data immediately after the compressed data stream.</source>
          <target state="translated">Сразу после сжатого потока данных нет данных.</target>
        </trans-unit>
        <trans-unit id="784e961111d5a1435645faa2fd65cc0510bda63f" translate="yes" xml:space="preserve">
          <source>There is no decrypt function. This function isn't all that useful for cryptography (for that, look for</source>
          <target state="translated">Функции расшифровки нет.Эта функция не так уж и полезна для криптографии (для этого ищите</target>
        </trans-unit>
        <trans-unit id="7d50acdbf96ea291176f3a2d7e886b2944e1f2b9" translate="yes" xml:space="preserve">
          <source>There is no description given for most non-Perl defined properties (See &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt; for that).</source>
          <target state="translated">Нет описания для большинства свойств, не определенных Perl (см. &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;Http://www.unicode.org/reports/tr44/&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="efbf1382c6e11055de15bc7597f5ea124690d870" translate="yes" xml:space="preserve">
          <source>There is no double interpolation in Perl, so the &lt;code&gt;$100&lt;/code&gt; is left as is.</source>
          <target state="translated">В Perl нет двойной интерполяции, поэтому &lt;code&gt;$100&lt;/code&gt; оставляем как есть.</target>
        </trans-unit>
        <trans-unit id="455b851bfe4dcf94993aa6ab9485d19207a20655" translate="yes" xml:space="preserve">
          <source>There is no easy way to provide this functionality in &lt;code&gt;Archive::Tar&lt;/code&gt; , because a tarball can contain many files, and each of which could be encoded in a different way.</source>
          <target state="translated">Нет простого способа реализовать эту функциональность в &lt;code&gt;Archive::Tar&lt;/code&gt; , потому что tarball может содержать много файлов, каждый из которых может быть закодирован по-своему.</target>
        </trans-unit>
        <trans-unit id="5f678f49ea0f0b1f3db41874eff418b0f56e6c16" translate="yes" xml:space="preserve">
          <source>There is no easy way to provide this functionality in &lt;code&gt;Archive::Tar&lt;/code&gt;, because a tarball can contain many files, and each of which could be encoded in a different way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27f49800696d7a52910d2aa32267a02c4e742caa" translate="yes" xml:space="preserve">
          <source>There is no equivalent operator to force an expression to be interpolated in list context because in practice, this is never needed. If you really wanted to do so, however, you could use the construction &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; , but usually a simple &lt;code&gt;(some expression)&lt;/code&gt; suffices.</source>
          <target state="translated">Не существует эквивалентного оператора для принудительной интерполяции выражения в контексте списка, потому что на практике это никогда не требуется. Однако, если вы действительно этого хотите, вы можете использовать конструкцию &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; , но обычно достаточно простого &lt;code&gt;(some expression)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb80803d06b14ddbd06119d95cbdefe4be98fc5" translate="yes" xml:space="preserve">
          <source>There is no equivalent operator to force an expression to be interpolated in list context because in practice, this is never needed. If you really wanted to do so, however, you could use the construction &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt;, but usually a simple &lt;code&gt;(some expression)&lt;/code&gt; suffices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da385daea49ac6d957f9692c325e916978ed205" translate="yes" xml:space="preserve">
          <source>There is no equivalent to &lt;code&gt;fgets&lt;/code&gt; ; one should use &lt;code&gt;sv_gets&lt;/code&gt; instead:</source>
          <target state="translated">Нет эквивалента &lt;code&gt;fgets&lt;/code&gt; ; вместо этого следует использовать &lt;code&gt;sv_gets&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9c4f353571f4abb0cafbf257cbbb852b1668ac0d" translate="yes" xml:space="preserve">
          <source>There is no equivalent to &lt;code&gt;fgets&lt;/code&gt;; one should use &lt;code&gt;sv_gets&lt;/code&gt; instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b2b22bb272d9529f5a7b2eeb648640b188c1f1" translate="yes" xml:space="preserve">
          <source>There is no firewall</source>
          <target state="translated">Нет брандмауэра</target>
        </trans-unit>
        <trans-unit id="121835ac892ea37b942952f42c3ffe4014099c6d" translate="yes" xml:space="preserve">
          <source>There is no general solution to all of this. It is a mess.</source>
          <target state="translated">Нет общего решения для всего этого.Это беспорядок.</target>
        </trans-unit>
        <trans-unit id="87f0999d25c4eb3604c738b2e0116726668320dd" translate="yes" xml:space="preserve">
          <source>There is no general solution to all of this. It's just a mess.</source>
          <target state="translated">Нет общего решения для всего этого.Просто беспорядок.</target>
        </trans-unit>
        <trans-unit id="b2b55e890caeb51d36e6b91d2ac8fcb1b35de4f5" translate="yes" xml:space="preserve">
          <source>There is no interface to request alternative CHECK behavior as for decode_argv(). If you need that you need to call encode/decode yourself. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b8fcbb171cbccbd111cd2bd311ab6e6fcd1a58" translate="yes" xml:space="preserve">
          <source>There is no low precedence operator for defined-OR.</source>
          <target state="translated">Нет оператора с низким приоритетом для определения-ИЛИ.</target>
        </trans-unit>
        <trans-unit id="a8da251185c2a49373fb6cf76b3c29c18692d780" translate="yes" xml:space="preserve">
          <source>There is no need to inherit from the &lt;b&gt;SelfLoader&lt;/b&gt;.</source>
          <target state="translated">Нет необходимости наследовать от &lt;b&gt;SelfLoader&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="6e895b74ce6094374e60e95c58a0d18a65714b5a" translate="yes" xml:space="preserve">
          <source>There is no need to upgrade if you already have it installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f9d8d1ae5518832290b8aa40a4082b8960c7be8" translate="yes" xml:space="preserve">
          <source>There is no one DBM module available on all platforms. &lt;a href=&quot;sdbm_file&quot;&gt;&lt;code&gt;SDBM_File&lt;/code&gt;&lt;/a&gt; and the others are generally available on all Unix and DOSish ports, but not in MacPerl, where only &lt;a href=&quot;ndbm_file&quot;&gt;&lt;code&gt;NDBM_File&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;db_file&quot;&gt;&lt;code&gt;DB_File&lt;/code&gt;&lt;/a&gt; are available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3cd63858e09b2c6b6ec38df40d5828e10651d9" translate="yes" xml:space="preserve">
          <source>There is no one DBM module available on all platforms. &lt;code&gt;SDBM_File&lt;/code&gt; and the others are generally available on all Unix and DOSish ports, but not in MacPerl, where only &lt;code&gt;NDBM_File&lt;/code&gt; and &lt;code&gt;DB_File&lt;/code&gt; are available.</source>
          <target state="translated">Нет одного модуля DBM, доступного на всех платформах. &lt;code&gt;SDBM_File&lt;/code&gt; и другие обычно доступны на всех портах Unix и DOSish, но не в MacPerl, где &lt;code&gt;NDBM_File&lt;/code&gt; только NDBM_File и &lt;code&gt;DB_File&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc935adca7e5bcb15422e7a69e6858c66da25299" translate="yes" xml:space="preserve">
          <source>There is no provision for delaying a request body using an &lt;code&gt;Expect&lt;/code&gt; header. Unexpected &lt;code&gt;1XX&lt;/code&gt; responses are silently ignored as per the specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93f05645168f7a6ce32010423ff327f27468e22" translate="yes" xml:space="preserve">
          <source>There is no public API for popping individual values or items from the save stack. Instead, via the scope stack, the &lt;code&gt;ENTER&lt;/code&gt; and &lt;code&gt;LEAVE&lt;/code&gt; pair form a way to start and stop nested scopes. Leaving a nested scope via &lt;code&gt;LEAVE&lt;/code&gt; will restore all of the saved values that had been pushed since the most recent &lt;code&gt;ENTER&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d4d5447e705702a110e831b9f5c50697a0ccfe" translate="yes" xml:space="preserve">
          <source>There is no public API to directly push items to the temporaries stack. Instead, the API function &lt;code&gt;sv_2mortal()&lt;/code&gt; is used to mortalize an xV, adding its address to the temporaries stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb47afbc2311aee90586d3371f78c62b2ed90edb" translate="yes" xml:space="preserve">
          <source>There is no quantifier &lt;code&gt;{,n}&lt;/code&gt; . That's interpreted as a literal string.</source>
          <target state="translated">Нет квантификатора &lt;code&gt;{,n}&lt;/code&gt; . Это интерпретируется как буквальная строка.</target>
        </trans-unit>
        <trans-unit id="4e5e1c10d207641a72418018f1f75f1613935380" translate="yes" xml:space="preserve">
          <source>There is no quantifier &lt;code&gt;{,n}&lt;/code&gt;. That's currently illegal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61924ba7fcca566e3d46f3a27c41097477fd32e" translate="yes" xml:space="preserve">
          <source>There is no reason to directly use this package. This package is documented for completeness. This package can change, or go away completely at any time. Directly using, or monkeypatching this package is not supported in any way shape or form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378d1a5bc456220dab02d99326a34c6e9f3d48c2" translate="yes" xml:space="preserve">
          <source>There is no reason you should not use Perl as a language to glue Unix tools together, or to prototype a Macintosh application, or to manage the Windows registry. If it makes no sense to aim for portability for one reason or another in a given program, then don't bother.</source>
          <target state="translated">Нет причин не использовать Perl в качестве языка для склеивания Unix-инструментов,прототипа приложения Macintosh или управления реестром Windows.Если по той или иной причине в данной программе нет смысла стремиться к переносимости,то не беспокойтесь.</target>
        </trans-unit>
        <trans-unit id="860dd139f43df25bd42c1af5b8706f2806229649" translate="yes" xml:space="preserve">
          <source>There is no requirement to convert anything.</source>
          <target state="translated">Нет необходимости что-то преобразовывать.</target>
        </trans-unit>
        <trans-unit id="5d190eab008c4161478c644351172b878f4f965a" translate="yes" xml:space="preserve">
          <source>There is no set_layers(), nor does get_layers() return a tied array mirroring the stack, or anything fancy like that. This is not accidental or unintentional. The PerlIO layer stack is a bit more complicated than just a stack (see for example the behaviour of &lt;code&gt;:raw&lt;/code&gt; ). You are supposed to use open() and binmode() to manipulate the stack.</source>
          <target state="translated">Нет ни set_layers (), ни get_layers (), ни возврата связанного массива, отражающего стек, или чего-либо подобного. Это не случайно или непреднамеренно. Стек слоев PerlIO немного сложнее, чем просто стек (см., Например, поведение &lt;code&gt;:raw&lt;/code&gt; ). Вы должны использовать open () и binmode () для управления стеком.</target>
        </trans-unit>
        <trans-unit id="382f006c5b68a9b9a43fcd623fca8e14332f9212" translate="yes" xml:space="preserve">
          <source>There is no set_layers(), nor does get_layers() return a tied array mirroring the stack, or anything fancy like that. This is not accidental or unintentional. The PerlIO layer stack is a bit more complicated than just a stack (see for example the behaviour of &lt;code&gt;:raw&lt;/code&gt;). You are supposed to use open() and binmode() to manipulate the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb140242be9c5687c6a498b3df2879f2625b5b6" translate="yes" xml:space="preserve">
          <source>There is no shell to process metacharacters, and the native standard is to pass a command line terminated by &quot;\n&quot; &quot;\r&quot; or &quot;\0&quot; to the spawned program. Redirection such as &lt;code&gt;&amp;gt; foo&lt;/code&gt; is performed (if at all) by the run time library of the spawned program. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Не существует оболочки для обработки метасимволов, и собственный стандарт заключается в передаче созданной программе командной строки, заканчивающейся &quot;\ n&quot;, \ r или &quot;\ 0&quot;. Перенаправление, такое как &lt;code&gt;&amp;gt; foo&lt;/code&gt; , выполняется (если вообще выполняется) библиотекой времени выполнения порожденной программы. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="deba5b88e82775e19650d3712106c375f59f7e30" translate="yes" xml:space="preserve">
          <source>There is no significant speed gain between compile time and run time class creation, there is just a new, more standard order of events.</source>
          <target state="translated">Нет существенного прироста скорости между временем компиляции и созданием временного класса,есть только новый,более стандартный порядок событий.</target>
        </trans-unit>
        <trans-unit id="6b7801d1cfdd5c48abee3f679e368ab10b3ad8dc" translate="yes" xml:space="preserve">
          <source>There is no simple answer to this question. Perl frameworks can run everything from basic file servers and small scale intranets to massive multinational multilingual websites that are the core to international businesses.</source>
          <target state="translated">На этот вопрос нет простого ответа.Фреймворки Perl могут запускать все-от базовых файловых серверов и небольших интранетов до массивных многонациональных многоязычных веб-сайтов,которые являются ядром международного бизнеса.</target>
        </trans-unit>
        <trans-unit id="300fa34c66267d66af5fbbb27ef916d4adcee2ea" translate="yes" xml:space="preserve">
          <source>There is no simple replacement possible since a qualifier and all its subqualifiers must be considered together, so we use our own utility routine for the replacement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557d02393de130217c50453e6a017ae2fadcbc8e" translate="yes" xml:space="preserve">
          <source>There is no simple solution to this because of printf()'s limited intelligence, but for many types the right format is available as with either 'f' or '_f' suffix, for example:</source>
          <target state="translated">Простого решения этой проблемы нет из-за ограниченного интеллекта printf(),но для многих типов доступен правильный формат,как,например,с суффиксом 'f' или '_f':</target>
        </trans-unit>
        <trans-unit id="5540c0e13568fd5e0e7ecd528ea43dc498771d2a" translate="yes" xml:space="preserve">
          <source>There is no simple way to access WPS objects. The only way I know is via &lt;code&gt;OS2::REXX&lt;/code&gt; and &lt;code&gt;SOM&lt;/code&gt; extensions (see &lt;a href=&quot;OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;, &lt;a href=&quot;som&quot;&gt;SOM&lt;/a&gt;). However, we do not have access to convenience methods of Object-REXX. (Is it possible at all? I know of no Object-REXX API.) The &lt;code&gt;SOM&lt;/code&gt; extension (currently in alpha-text) may eventually remove this shortcoming; however, due to the fact that DII is not supported by the &lt;code&gt;SOM&lt;/code&gt; module, using &lt;code&gt;SOM&lt;/code&gt; is not as convenient as one would like it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ceb0317aba48e3a3b6cabda91010f77ae7a54b9" translate="yes" xml:space="preserve">
          <source>There is no simple way to access WPS objects. The only way I know is via &lt;code&gt;OS2::REXX&lt;/code&gt; and &lt;code&gt;SOM&lt;/code&gt; extensions (see &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/SOM&quot;&gt;SOM&lt;/a&gt;). However, we do not have access to convenience methods of Object-REXX. (Is it possible at all? I know of no Object-REXX API.) The &lt;code&gt;SOM&lt;/code&gt; extension (currently in alpha-text) may eventually remove this shortcoming; however, due to the fact that DII is not supported by the &lt;code&gt;SOM&lt;/code&gt; module, using &lt;code&gt;SOM&lt;/code&gt; is not as convenient as one would like it.</source>
          <target state="translated">Нет простого способа получить доступ к объектам WPS. Я знаю только один способ - через &lt;code&gt;OS2::REXX&lt;/code&gt; и &lt;code&gt;SOM&lt;/code&gt; (см. &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/SOM&quot;&gt;SOM&lt;/a&gt; ). Однако у нас нет доступа к удобным методам Object-REXX. (Возможно ли это вообще? Я не знаю API Object-REXX.) Расширение &lt;code&gt;SOM&lt;/code&gt; (в настоящее время в виде альфа-текста) может в конечном итоге устранить этот недостаток; однако из-за того, что DII не поддерживается модулем &lt;code&gt;SOM&lt;/code&gt; , использование &lt;code&gt;SOM&lt;/code&gt; не так удобно, как хотелось бы.</target>
        </trans-unit>
        <trans-unit id="06843bf4e2da3a9df3bd916b78c90fe1d32c0462" translate="yes" xml:space="preserve">
          <source>There is no special class syntax in Perl, but a package may act as a class if it provides subroutines to act as methods. Such a package may also derive some of its methods from another class (package) by listing the other package name(s) in its global @ISA array (which must be a package global, not a lexical).</source>
          <target state="translated">В Perl нет специального синтаксиса классов,но пакет может выступать в качестве класса,если он предоставляет подпрограмм для работы в качестве методов.Такой пакет может также получать некоторые из своих методов из другого класса (пакета),перечисляя другие имена пакетов в его глобальном массиве @ISA (который должен быть глобальным пакетом,а не лексическим).</target>
        </trans-unit>
        <trans-unit id="f83d3f75f9b7673dc85f27f3287a09a764999d4c" translate="yes" xml:space="preserve">
          <source>There is no specific mailing list for Perl on VOS. You can contact the Stratus Technologies Customer Assistance Center (CAC) for your region, or you can use the contact information located in the distribution files on the Stratus Anonymous FTP site.</source>
          <target state="translated">В VOS нет специального списка рассылки для Perl.Вы можете связаться с Центром Обслуживания Клиентов (CAC)Stratus Technologies для вашего региона или использовать контактную информацию,расположенную в файлах рассылки на сайте Stratus Anonymous FTP.</target>
        </trans-unit>
        <trans-unit id="100c2da519836111bd839e12cb2fd3dec223d870" translate="yes" xml:space="preserve">
          <source>There is no specification of the formatter after the &lt;code&gt;=for&lt;/code&gt; command.</source>
          <target state="translated">После команды &lt;code&gt;=for&lt;/code&gt; не указывается форматтер .</target>
        </trans-unit>
        <trans-unit id="670b965fe2aed5c0a5a49c42acbad90f9fc925e9" translate="yes" xml:space="preserve">
          <source>There is no such thing as a network representation for reals, so if you want to send your real numbers across computer boundaries, you'd better stick to text representation, possibly using the hexadecimal float format (avoiding the decimal conversion loss), unless you're absolutely sure what's on the other end of the line. For the even more adventuresome, you can use the byte-order modifiers from the previous section also on floating point codes.</source>
          <target state="translated">Нет такого понятия,как сетевое представление для реалов,так что если вы хотите посылать свои реальные числа через компьютерные границы,вам лучше придерживаться текстового представления,возможно,используя шестнадцатеричный формат с плавающей запятой (избегая потерь при десятичном преобразовании),если только вы не абсолютно уверены,что находится на другом конце строки.Для еще более приключений можно использовать модификаторы порядка байт из предыдущего раздела также на кодах с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="485f9819a36f9757672adb9a54833a7d985d4ad2" translate="yes" xml:space="preserve">
          <source>There is no support at present for tied @ISA. There is a potential conflict between magic entries needed to notice setting of @ISA, and those needed to implement 'tie'.</source>
          <target state="translated">В настоящее время нет поддержки для связанных @ISA.Существует потенциальный конфликт между магическими элементами,необходимыми для того,чтобы заметить установку @ISA,и теми,которые необходимы для реализации 'tie'.</target>
        </trans-unit>
        <trans-unit id="8ce7f675d43b056af9ee6718421eba4a7f2bb579" translate="yes" xml:space="preserve">
          <source>There is no support for a Request-URI of '*' for the 'OPTIONS' request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d4e44dc9af068a1f923f5eebfb3439b41ed99d" translate="yes" xml:space="preserve">
          <source>There is no support for dynamically linked libraries in QNX4.</source>
          <target state="translated">В QNX4 нет поддержки динамически связанных библиотек.</target>
        </trans-unit>
        <trans-unit id="ddb797616f9cbf4b2f8a2cb06d0ccee2c08c8ad1" translate="yes" xml:space="preserve">
          <source>There is no syseof() function, which is ok, since &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; doesn't work well on device files (like ttys) anyway. Use &lt;a href=&quot;#sysread-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;sysread&lt;/code&gt;&lt;/a&gt; and check for a return value of 0 to decide whether you're done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a30aae9994d5aba957137545368eea0ce0f5eb" translate="yes" xml:space="preserve">
          <source>There is no syseof() function, which is ok, since eof() doesn't work well on device files (like ttys) anyway. Use sysread() and check for a return value for 0 to decide whether you're done.</source>
          <target state="translated">Функции syseof()нет,что нормально,так как eof()все равно плохо работает на файлах девайсов (например,ttys).Используйте sysread()и проверьте возвращаемое значение 0,чтобы решить,закончили ли вы.</target>
        </trans-unit>
        <trans-unit id="8fc13de7d6614c5dd033dd321c9bbd82b325da63" translate="yes" xml:space="preserve">
          <source>There is no technical reason why a Berkeley DB database cannot be shared by both a Perl and a C application.</source>
          <target state="translated">Нет никаких технических причин,по которым база данных БД Беркли не может быть совместно использована как Perl,так и C-приложением.</target>
        </trans-unit>
        <trans-unit id="79f7328788708da5a0cdbfe8c102e73defe278fc" translate="yes" xml:space="preserve">
          <source>There is no way to reliably detect the encoding automatically, so if people keep sending you data without charset indication, you may have to educate them.</source>
          <target state="translated">Нет способа надежно обнаружить кодировку автоматически,поэтому,если люди продолжают посылать вам данные без указания кодовых страниц,вам,возможно,придется обучить их.</target>
        </trans-unit>
        <trans-unit id="20ec9f83105615b23b9fac938fd715b5bc923fe1" translate="yes" xml:space="preserve">
          <source>There is no way to turn it back on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4ba678fc087cfe3ed3657d1daba5422cdd5616" translate="yes" xml:space="preserve">
          <source>There is nothing special about Memoize::Expire. It is just an example. If you don't like the policy that it implements, you are free to write your own expiration policy module that implements whatever policy you desire. Here is how to do that. Let us suppose that your module will be named MyExpirePolicy.</source>
          <target state="translated">Нет ничего особенного в Memoize::Истечение.Это просто пример.Если вам не нравится политика,которую он реализует,вы можете написать свой собственный модуль политики истечения срока действия,который реализует любую политику,какую захотите.Вот как это сделать.Предположим,что ваш модуль будет называться MyExpirePolicy.</target>
        </trans-unit>
        <trans-unit id="6fcd6f426861d4a9d172b0ea1e309235434fe63e" translate="yes" xml:space="preserve">
          <source>There is now a &lt;code&gt;bsstr()&lt;/code&gt; method to get the string in scientific notation aka &lt;code&gt;1e+2&lt;/code&gt; instead of &lt;code&gt;100&lt;/code&gt; . Be advised that overloaded 'eq' always uses bstr() for comparison, but Perl will represent some numbers as 100 and others as 1e+308. If in doubt, convert both arguments to Math::BigInt before comparing them as strings:</source>
          <target state="translated">Теперь существует &lt;code&gt;bsstr()&lt;/code&gt; для получения строки в экспоненциальной записи, известной как &lt;code&gt;1e+2&lt;/code&gt; , вместо &lt;code&gt;100&lt;/code&gt; . Имейте в виду, что перегруженный 'eq' всегда использует bstr () для сравнения, но Perl будет представлять некоторые числа как 100, а другие как 1e + 308. В случае сомнений преобразуйте оба аргумента в Math :: BigInt, прежде чем сравнивать их как строки:</target>
        </trans-unit>
        <trans-unit id="5ae720bb4190ab9bd815350aa7eadedcf7d8ced5" translate="yes" xml:space="preserve">
          <source>There is now a &lt;code&gt;bsstr()&lt;/code&gt; method to get the string in scientific notation aka &lt;code&gt;1e+2&lt;/code&gt; instead of &lt;code&gt;100&lt;/code&gt;. Be advised that overloaded 'eq' always uses bstr() for comparison, but Perl represents some numbers as 100 and others as 1e+308. If in doubt, convert both arguments to Math::BigInt before comparing them as strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f759aa48f981bff2eecdd8034d0137dd1c154a" translate="yes" xml:space="preserve">
          <source>There is of course lots more to find out about, this has just scratched the surface. The best way to learn more is to use perldoc to find out more about the language, to read the on-line help (&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; is probably the next place to go), and of course, experiment.</source>
          <target state="translated">Конечно, есть еще много чего узнать, это только начало. Лучший способ узнать больше - использовать perldoc, чтобы узнать больше о языке, прочитать он-лайн справку ( &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; , вероятно, следующее место, куда нужно пойти) и, конечно же, поэкспериментировать.</target>
        </trans-unit>
        <trans-unit id="4c5dc52000b85d6cc8d7d71cfdf7a1cf6d094cbc" translate="yes" xml:space="preserve">
          <source>There is often a matter of opinion and taste, and there isn't any one answer that fits everyone. In general, you want to use either the current stable release, or the stable release immediately prior to that one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f1fdaa6644f76210c716aac51df03a67575812a" translate="yes" xml:space="preserve">
          <source>There is often a matter of opinion and taste, and there isn't any one answer that fits everyone. In general, you want to use either the current stable release, or the stable release immediately prior to that one. Currently, those are perl5.18.x and perl5.16.x, respectively.</source>
          <target state="translated">Часто возникает вопрос мнения и вкуса,и нет ни одного ответа,который подошел бы всем.В общем,вы хотите использовать либо текущий стабильный релиз,либо стабильный релиз непосредственно перед ним.В настоящее время это perl5.18.x и perl5.16.x соответственно.</target>
        </trans-unit>
        <trans-unit id="6fddc6aff8f6804eafbdecf55f8d9d2197b85b37" translate="yes" xml:space="preserve">
          <source>There is one caveat with INSTALL_BASE, though, since it acts differently from the PREFIX and LIB settings that older versions of &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; advocated. INSTALL_BASE does not support installing modules for multiple versions of Perl or different architectures under the same directory. You should consider whether you really want that and, if you do, use the older PREFIX and LIB settings. See the &lt;a href=&quot;ExtUtils::Makemaker&quot;&gt;ExtUtils::Makemaker&lt;/a&gt; documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0ec9ff71273582227d757a4501aa81fcc373f2" translate="yes" xml:space="preserve">
          <source>There is one caveat with INSTALL_BASE, though, since it acts differently from the PREFIX and LIB settings that older versions of &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; advocated. INSTALL_BASE does not support installing modules for multiple versions of Perl or different architectures under the same directory. You should consider whether you really want that and, if you do, use the older PREFIX and LIB settings. See the &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Makemaker&quot;&gt;ExtUtils::Makemaker&lt;/a&gt; documentation for more details.</source>
          <target state="translated">Однако с INSTALL_BASE есть одно предостережение, поскольку он действует иначе, чем настройки PREFIX и LIB, которые &lt;a href=&quot;extutils/makemaker&quot;&gt;защищали&lt;/a&gt; более старые версии ExtUtils :: MakeMaker . INSTALL_BASE не поддерживает установку модулей для нескольких версий Perl или разных архитектур в одном каталоге. Вы должны подумать, действительно ли вы этого хотите, и, если хотите, использовать старые настройки PREFIX и LIB. См. &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Makemaker&quot;&gt;Документацию ExtUtils :: Makemaker&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="14196e0aaa427146743d8121cb1facbe4cf5fb5c" translate="yes" xml:space="preserve">
          <source>There is one crucial restriction: the prereqs of an optional feature &lt;b&gt;must not&lt;/b&gt; include &lt;code&gt;configure&lt;/code&gt; phase prereqs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b4745ddf35dec712ea27023babefb7e0f47466" translate="yes" xml:space="preserve">
          <source>There is one exception to all this. &lt;code&gt;\p{All}&lt;/code&gt; looks like a Unicode property, but it is a Perl extension that is defined to be true for all possible code points, Unicode or not, so no warning is ever generated when matching this against a non-Unicode code point. (Prior to v5.20, it was an exact synonym for &lt;code&gt;\p{Any}&lt;/code&gt; , matching code points &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;0x10FFFF&lt;/code&gt; .)</source>
          <target state="translated">Из всего этого есть одно исключение. &lt;code&gt;\p{All}&lt;/code&gt; выглядит как свойство Unicode, но это расширение Perl, которое определено как истинное для всех возможных кодовых точек, Unicode или нет, поэтому при сопоставлении этого с кодовой точкой, отличной от Unicode, не генерируется никаких предупреждений. (До версии 5.20 это был точный синоним &lt;code&gt;\p{Any}&lt;/code&gt; , совпадающий с кодовыми точками от &lt;code&gt;0&lt;/code&gt; до &lt;code&gt;0x10FFFF&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="a280fffe45cedb42744a2a95530fed2f40145dd0" translate="yes" xml:space="preserve">
          <source>There is one exception to all this. &lt;code&gt;\p{All}&lt;/code&gt; looks like a Unicode property, but it is a Perl extension that is defined to be true for all possible code points, Unicode or not, so no warning is ever generated when matching this against a non-Unicode code point. (Prior to v5.20, it was an exact synonym for &lt;code&gt;\p{Any}&lt;/code&gt;, matching code points &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;0x10FFFF&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74416e05e81083925dbb5ceee8b9f9eabc0d1420" translate="yes" xml:space="preserve">
          <source>There is one exception to this rule:</source>
          <target state="translated">Есть одно исключение из этого правила:</target>
        </trans-unit>
        <trans-unit id="aa93104b268b1c94a90858506e09be1c5b4335fe" translate="yes" xml:space="preserve">
          <source>There is one exception, and that is base 2 with negative $x:</source>
          <target state="translated">Есть одно исключение,а именно база 2 с отрицательным значением $x:</target>
        </trans-unit>
        <trans-unit id="8cbb7256d41af14511a3636bc506131a71d8c56d" translate="yes" xml:space="preserve">
          <source>There is one exception. If you use an alphanumeric character as the delimiter of your pattern (which you probably shouldn't do for readability reasons), you have to escape the delimiter if you want to match it. Perl won't warn then. See also &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;&quot;Gory details of parsing quoted constructs&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa0a4472a2d7ed2b714a912f015cd1d6e2a650e" translate="yes" xml:space="preserve">
          <source>There is one exception. If you use an alphanumeric character as the delimiter of your pattern (which you probably shouldn't do for readability reasons), you have to escape the delimiter if you want to match it. Perl won't warn then. See also &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;Gory details of parsing quoted constructs in perlop&lt;/a&gt;.</source>
          <target state="translated">Есть одно исключение. Если вы используете буквенно-цифровой символ в качестве разделителя вашего шаблона (что вам, вероятно, не следует делать из соображений удобочитаемости), вам нужно избегать разделителя, если вы хотите сопоставить его. Тогда Perl не предупредит. См. Также &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;подробную информацию о синтаксическом анализе цитируемых конструкций в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6afd3e4f300e1185505b80a57213e90e8f05b7f4" translate="yes" xml:space="preserve">
          <source>There is one minor difference: if variables are declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; in the initialization section of the &lt;code&gt;for&lt;/code&gt; , the lexical scope of those variables is exactly the &lt;code&gt;for&lt;/code&gt; loop (the body of the loop and the control sections).</source>
          <target state="translated">Есть одно небольшое отличие: если переменные объявляются с помощью &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; в разделе инициализации &lt;code&gt;for&lt;/code&gt; , лексическая область видимости этих переменных - это точно цикл &lt;code&gt;for&lt;/code&gt; (тело цикла и разделы управления).</target>
        </trans-unit>
        <trans-unit id="9813dc853a6a86bf5a99b935f981b5a1ed789ab3" translate="yes" xml:space="preserve">
          <source>There is one minor difference: if variables are declared with &lt;code&gt;my&lt;/code&gt; in the initialization section of the &lt;code&gt;for&lt;/code&gt;, the lexical scope of those variables is exactly the &lt;code&gt;for&lt;/code&gt; loop (the body of the loop and the control sections).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ea2627da96768f4457b4c193dca3613fbaa7aa" translate="yes" xml:space="preserve">
          <source>There is one small difference between &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; : the former will not affect assignments to variables and the return value of some functions. &lt;code&gt;bigint&lt;/code&gt; truncates these results to integer too:</source>
          <target state="translated">Есть одно небольшое различие между &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; : первое не влияет на присвоение переменных и возвращаемое значение некоторых функций. &lt;code&gt;bigint&lt;/code&gt; также усекает эти результаты до целых чисел:</target>
        </trans-unit>
        <trans-unit id="b8649e02d1e449cfaae6e608c7b04929643e83c2" translate="yes" xml:space="preserve">
          <source>There is one small difference between &lt;code&gt;use integer&lt;/code&gt; and &lt;code&gt;use bigint&lt;/code&gt;: the former will not affect assignments to variables and the return value of some functions. &lt;code&gt;bigint&lt;/code&gt; truncates these results to integer too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84dd6a42f4605e651baa6c6eefa2a08f75e64c2" translate="yes" xml:space="preserve">
          <source>There is one subtle difference between the following statements:</source>
          <target state="translated">Есть одно тонкое различие между следующими утверждениями:</target>
        </trans-unit>
        <trans-unit id="577b4723acc7dc122f5a6c392fd693ead8ac6f77" translate="yes" xml:space="preserve">
          <source>There is one unary operator:</source>
          <target state="translated">Есть один унарный оператор:</target>
        </trans-unit>
        <trans-unit id="d67d211508568f3ee020a0acfadaaf645e5efa24" translate="yes" xml:space="preserve">
          <source>There is only a single &lt;code&gt;%^H&lt;/code&gt; , but arbitrarily many modules that want to use its scoping semantics. To avoid stepping on each other's toes, they need to be sure to use different keys in the hash. It is therefore conventional for a module to use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. After this module-identifying prefix, the rest of the key is entirely up to the module: it may include any characters whatsoever. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; and &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; . Modules following this convention all play nicely with each other.</source>
          <target state="translated">Есть только один &lt;code&gt;%^H&lt;/code&gt; , но произвольно много модулей, которые хотят использовать его семантику области видимости. Чтобы не наступать друг другу на ногу, они должны обязательно использовать разные ключи в хэше. Поэтому для модуля принято использовать только ключи, которые начинаются с имени модуля (имени его основного пакета) и символа &amp;laquo;/&amp;raquo;. После этого префикса, идентифицирующего модуль, остальная часть ключа полностью зависит от модуля: он может включать любые символы. Например, модуль &lt;code&gt;Foo::Bar&lt;/code&gt; должен использовать такие ключи, как &lt;code&gt;Foo::Bar/baz&lt;/code&gt; и &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; . Все модули, следующие этому соглашению, прекрасно взаимодействуют друг с другом.</target>
        </trans-unit>
        <trans-unit id="3740e3b8de22c29d0f5b6e37bf6c582521c6e016" translate="yes" xml:space="preserve">
          <source>There is only a single &lt;code&gt;%^H&lt;/code&gt;, but arbitrarily many modules that want to use its scoping semantics. To avoid stepping on each other's toes, they need to be sure to use different keys in the hash. It is therefore conventional for a module to use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. After this module-identifying prefix, the rest of the key is entirely up to the module: it may include any characters whatsoever. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; and &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt;. Modules following this convention all play nicely with each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c0c34478d863fe370e8b15b9734da447a63b38" translate="yes" xml:space="preserve">
          <source>There is outline support for co-existence of PerlIO with stdio. Obviously if PerlIO is implemented in terms of stdio there is no problem. However in other cases then mechanisms must exist to create a FILE * which can be passed to library code which is going to use stdio calls.</source>
          <target state="translated">В общих чертах поддерживается сосуществование PerlIO с stdio.Очевидно,что если PerlIO реализован с точки зрения stdio,то проблем нет.Однако в других случаях должны существовать механизмы для создания ФАЙЛА *,который может быть передан в код библиотеки,использующей stdio вызовы.</target>
        </trans-unit>
        <trans-unit id="a0392addc7a656cb8a34b007fdd104d3df93294e" translate="yes" xml:space="preserve">
          <source>There is some debate as to whether to say &quot;regexp&quot; or &quot;regex&quot;. In this document we will use the term &quot;regex&quot; unless there is a special reason not to, in which case we will explain why.</source>
          <target state="translated">Идет дискуссия о том,говорить ли &quot;регекс&quot; или &quot;регекс&quot;.В этом документе мы будем использовать термин &quot;регекс&quot;,если только нет особых причин не делать этого,и в этом случае мы объясним почему.</target>
        </trans-unit>
        <trans-unit id="6f838e3edb2d3e6da973960ec694558ee6ce5470" translate="yes" xml:space="preserve">
          <source>There is some problem with the way &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;f&lt;/code&gt; works under threaded Perl, perhaps because of the lexical scoping of &lt;code&gt;@_&lt;/code&gt; . This is a bug in Perl, and until it is resolved, memoized functions will see a slightly different &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; and will perform a little more slowly on threaded perls than unthreaded perls.</source>
          <target state="translated">Есть некоторая проблема с тем, как &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;f&lt;/code&gt; работает в многопоточном Perl, возможно, из-за лексической области видимости &lt;code&gt;@_&lt;/code&gt; . Это ошибка Perl, и, пока она не будет устранена, мемоизированные функции будут видеть немного другого &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; и будут работать немного медленнее на многопоточных perl'ах, чем на непоточных perls.</target>
        </trans-unit>
        <trans-unit id="2bcd1c67f3d88bee674b646d4ad741c0978c442b" translate="yes" xml:space="preserve">
          <source>There is some problem with the way &lt;code&gt;goto &amp;amp;f&lt;/code&gt; works under threaded Perl, perhaps because of the lexical scoping of &lt;code&gt;@_&lt;/code&gt;. This is a bug in Perl, and until it is resolved, memoized functions will see a slightly different &lt;code&gt;caller()&lt;/code&gt; and will perform a little more slowly on threaded perls than unthreaded perls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c4c8715915dd906a17ab857892228134a49607" translate="yes" xml:space="preserve">
          <source>There is some whitespace on a seemingly empty line. POD is very sensitive to such things, so this is flagged. &lt;b&gt;vi&lt;/b&gt; users switch on the &lt;b&gt;list&lt;/b&gt; option to avoid this problem.</source>
          <target state="translated">В кажущейся пустой строке есть пробелы. POD очень чувствителен к таким вещам, поэтому это помечено. Пользователи &lt;b&gt;vi&lt;/b&gt; включают опцию &lt;b&gt;списка,&lt;/b&gt; чтобы избежать этой проблемы.</target>
        </trans-unit>
        <trans-unit id="c71483f882bf4da31c0c8d8f1949a4bc637c87a4" translate="yes" xml:space="preserve">
          <source>There is still a big part of the API not supported by</source>
          <target state="translated">По-прежнему существует большая часть API,не поддерживаемая</target>
        </trans-unit>
        <trans-unit id="808a7cbe8640b29d30d1f97308938be9ff6d1171" translate="yes" xml:space="preserve">
          <source>There is still a small theoretical chance that a signal will interrupt the system-level &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; operation before completion. There is also a possibility that some STDIO implementations may call multiple system level &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;s even if the buffer was empty to start. There may be some systems where this probability is reduced to zero, and this is not a concern when using &lt;code&gt;:perlio&lt;/code&gt; instead of your system's STDIO.</source>
          <target state="translated">По-прежнему существует небольшая теоретическая вероятность того, что сигнал прервет операцию &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; на системном уровне до завершения. Также существует вероятность того, что некоторые реализации STDIO могут вызывать функции &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; нескольких системного уровня, даже если буфер для запуска был пуст. В некоторых системах эта вероятность снижена до нуля, и это не проблема при использовании &lt;code&gt;:perlio&lt;/code&gt; вместо STDIO вашей системы.</target>
        </trans-unit>
        <trans-unit id="0c9adb8b47f26bb800c4b672d40c4761b57cb21d" translate="yes" xml:space="preserve">
          <source>There is still a small theoretical chance that a signal will interrupt the system-level &lt;code&gt;write()&lt;/code&gt; operation before completion. There is also a possibility that some STDIO implementations may call multiple system level &lt;code&gt;write()&lt;/code&gt;s even if the buffer was empty to start. There may be some systems where this probability is reduced to zero, and this is not a concern when using &lt;code&gt;:perlio&lt;/code&gt; instead of your system's STDIO.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96312d6625c318df54bef83c86f5b35fb95ca06e" translate="yes" xml:space="preserve">
          <source>There is the &quot;next regnode&quot; from a given regnode, a value which is rarely useful except that sometimes it matches up in terms of value with one of the others, and that sometimes the code assumes this to always be so.</source>
          <target state="translated">Существует &quot;следующий перезапуск&quot; из заданного перезапуска,значение,которое редко бывает полезным,за исключением того,что иногда оно совпадает по значению с одним из других,и что иногда код предполагает,что это всегда так.</target>
        </trans-unit>
        <trans-unit id="7b46535959966668b5c0eb95890256b8fd5dc3c4" translate="yes" xml:space="preserve">
          <source>There is the &quot;next regop&quot; from a given regop/regnode. This is the regop physically located after the current one, as determined by the size of the current regop. This is often useful, such as when dumping the structure we use this order to traverse. Sometimes the code assumes that the &quot;next regnode&quot; is the same as the &quot;next regop&quot;, or in other words assumes that the sizeof a given regop type is always going to be one regnode large.</source>
          <target state="translated">Существует &quot;следующий регоп&quot; из заданного регопа/регода.Это регоп,физически расположенный после текущего,определяемый размером текущего регопа.Это часто бывает полезно,например,при демпинге структуры,когда мы используем этот порядок для прохождения.Иногда код предполагает,что &quot;следующий регноз&quot; тот же самый,что и &quot;следующий регноз&quot;,или,другими словами,предполагает,что размер данного типа регноза всегда будет один регноз большой.</target>
        </trans-unit>
        <trans-unit id="e671500d0c7786e7f8681f40410ba60c12dae4fc" translate="yes" xml:space="preserve">
          <source>There is the &quot;regnext&quot; from a given regop. This is the regop which is reached by jumping forward by the value of &lt;code&gt;NEXT_OFF()&lt;/code&gt; , or in a few cases for longer jumps by the &lt;code&gt;arg1&lt;/code&gt; field of the &lt;code&gt;regnode_1&lt;/code&gt; structure. The subroutine &lt;code&gt;regnext()&lt;/code&gt; handles this transparently. This is the logical successor of the node, which in some cases, like that of the &lt;code&gt;BRANCH&lt;/code&gt; regop, has special meaning.</source>
          <target state="translated">Есть &quot;regnext&quot; из данного regop. Это regop, который достигается при переходе вперед на значение &lt;code&gt;NEXT_OFF()&lt;/code&gt; или, в некоторых случаях, при более длинных &lt;code&gt;regnode_1&lt;/code&gt; на поле &lt;code&gt;arg1&lt;/code&gt; структуры regnode_1 . Подпрограмма &lt;code&gt;regnext()&lt;/code&gt; обрабатывает это прозрачно. Это является логическим преемником узла, который в некоторых случаях, как и в &lt;code&gt;BRANCH&lt;/code&gt; regop, имеет особое значение.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
