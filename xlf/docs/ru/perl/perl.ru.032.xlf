<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="77df0281a5c47be5d00ae61a57ff00e23d9d5e5b" translate="yes" xml:space="preserve">
          <source>EXPORTABLE FUNCTIONS</source>
          <target state="translated">ЭКСПОРТИРУЕМЫЕ ФУНКЦИИ</target>
        </trans-unit>
        <trans-unit id="22d0596dab83a0920d66ad899d3e61f47464b88e" translate="yes" xml:space="preserve">
          <source>EXPORTABLE VARIABLES</source>
          <target state="translated">ЭКСПОРТИРУЕМЫЕ ПЕРЕМЕННЫЕ</target>
        </trans-unit>
        <trans-unit id="43aade251566381046f1d9dd6f51422fde3c0fbd" translate="yes" xml:space="preserve">
          <source>EXPORTED FUNCTIONS</source>
          <target state="translated">ЭКСПОРТИРУЕМЫЕ ФУНКЦИИ</target>
        </trans-unit>
        <trans-unit id="8b30e3050a39fae8e0c617ff76ab8d47b5f0b044" translate="yes" xml:space="preserve">
          <source>EXPORTED SYMBOLS</source>
          <target state="translated">ЭКСПОРТИРУЕМАЯ СИМВОЛИКА</target>
        </trans-unit>
        <trans-unit id="e9e012170f2df7cb18fa26019e2b46cbf4a91319" translate="yes" xml:space="preserve">
          <source>EXPORTS</source>
          <target state="translated">EXPORTS</target>
        </trans-unit>
        <trans-unit id="7b479848a0ec11ad7c3ba1025f3ac20068015bb9" translate="yes" xml:space="preserve">
          <source>EXPORTS (by request only)</source>
          <target state="translated">ЭКСПОРТЫ (только по запросу)</target>
        </trans-unit>
        <trans-unit id="6b6562ec1f5d1b67f0bbd288b913382cd128ba1e" translate="yes" xml:space="preserve">
          <source>EXPORT_LIST: name of a file that is passed to linker to define symbols to be exported.</source>
          <target state="translated">EXPORT_LIST:имя файла,который передается компоновщику для определения экспортируемых символов.</target>
        </trans-unit>
        <trans-unit id="a6fc3ffe71e48b679d9c5609def42ab3c69aa49f" translate="yes" xml:space="preserve">
          <source>EXPORT_OK</source>
          <target state="translated">EXPORT_OK</target>
        </trans-unit>
        <trans-unit id="f817892a6b7b040f6bf499b1ab6645711184a4f1" translate="yes" xml:space="preserve">
          <source>EXPR</source>
          <target state="translated">EXPR</target>
        </trans-unit>
        <trans-unit id="62af5da98ccf954a1bd12d8422eab969d058949e" translate="yes" xml:space="preserve">
          <source>EXPR is executed as a system command. The collected standard output of the command is returned. In scalar context, it comes back as a single (potentially multi-line) string. In list context, returns a list of lines (however you've defined lines with &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; in &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;)). This is the internal function implementing the &lt;code&gt;qx/EXPR/&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;qx/EXPR/&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;perlop#qx%2FSTRING%2F&quot;&gt;&quot;&lt;code&gt;qx/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt;&quot; in perlop&lt;/a&gt;. If EXPR is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3499643610f3dd44dae6eb02d7fed2d648b428d9" translate="yes" xml:space="preserve">
          <source>EXPR is executed as a system command. The collected standard output of the command is returned. In scalar context, it comes back as a single (potentially multi-line) string. In list context, returns a list of lines (however you've defined lines with &lt;code&gt;$/&lt;/code&gt; or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; ). This is the internal function implementing the &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;. If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR выполняется как системная команда. Собранный стандартный вывод команды возвращается. В скалярном контексте он возвращается как одна (потенциально многострочная) строка. В контексте списка возвращает список строк (однако вы определили строки с помощью &lt;code&gt;$/&lt;/code&gt; или &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; ). Это внутренняя функция, реализующая оператор &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; , но вы можете использовать ее напрямую. Оператор &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; более подробно обсуждается &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;в разделе &amp;laquo;Операторы ввода-вывода в perlop&amp;raquo;&lt;/a&gt; . Если EXPR опущен, используется &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f586c420e6eaf4cfbda37e4566d4c88b6984ca54" translate="yes" xml:space="preserve">
          <source>EXPR is executed as a system command. The collected standard output of the command is returned. In scalar context, it comes back as a single (potentially multi-line) string. In list context, returns a list of lines (however you've defined lines with &lt;code&gt;$/&lt;/code&gt; or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; ). This is the internal function implementing the &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;. If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR выполняется как системная команда. Собранный стандартный вывод команды возвращается. В скалярном контексте он возвращается как одна (потенциально многострочная) строка. В контексте списка возвращает список строк (однако вы определили строки с помощью &lt;code&gt;$/&lt;/code&gt; или &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; ). Это внутренняя функция, реализующая оператор &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; , но вы можете использовать ее напрямую. Оператор &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; более подробно обсуждается &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;в разделе &amp;laquo;Операторы ввода-вывода в perlop&amp;raquo;&lt;/a&gt; . Если EXPR опущен, используется &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="891bbd450e125f5b1ee12d035ddc1a7eef7a872c" translate="yes" xml:space="preserve">
          <source>EXPRESSION</source>
          <target state="translated">EXPRESSION</target>
        </trans-unit>
        <trans-unit id="6f64d0b0e54fcf9769746a65fbf9b2ecb163ee70" translate="yes" xml:space="preserve">
          <source>EXTEND</source>
          <target state="translated">EXTEND</target>
        </trans-unit>
        <trans-unit id="105f8f5f3c21e49b28c3216ab6b37ce1503d78bf" translate="yes" xml:space="preserve">
          <source>EXTEND this, count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a4d24b33941bccd86ff7ba0c19dc15933e36a4" translate="yes" xml:space="preserve">
          <source>EXTENDED CONSTRUCTS</source>
          <target state="translated">РАЗВЁРНУТЫЕ КОНСТРУКЦИИ</target>
        </trans-unit>
        <trans-unit id="b070e356144357fb71137b31e2e89f09d2f73b53" translate="yes" xml:space="preserve">
          <source>EXTERN.h</source>
          <target state="translated">EXTERN.h</target>
        </trans-unit>
        <trans-unit id="92f627e6114fde8ec8e85f5dc7eb0d8548926fd9" translate="yes" xml:space="preserve">
          <source>EXTERNAL</source>
          <target state="translated">EXTERNAL</target>
        </trans-unit>
        <trans-unit id="21d7721c8d41e278d11d43cf30b3f64d4c13b7f4" translate="yes" xml:space="preserve">
          <source>EXTRA</source>
          <target state="translated">EXTRA</target>
        </trans-unit>
        <trans-unit id="13ae0f4e98553c4041bca1bd5b70b21a5aa6d865" translate="yes" xml:space="preserve">
          <source>EXTRALIBS</source>
          <target state="translated">EXTRALIBS</target>
        </trans-unit>
        <trans-unit id="3633746b067241666bc462dcfe7a24ff23a8db68" translate="yes" xml:space="preserve">
          <source>Each</source>
          <target state="translated">Each</target>
        </trans-unit>
        <trans-unit id="64713135c29a168f621e3cd6c59750f2ec3360d2" translate="yes" xml:space="preserve">
          <source>Each &quot;=over&quot; ... &quot;=back&quot; region should be one of the following:</source>
          <target state="translated">Каждое &quot;=over&quot;...&quot;=зад&quot; должен быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="8573b03d1dbd851733546c18897b586541b26327" translate="yes" xml:space="preserve">
          <source>Each &lt;b&gt;File&lt;/b&gt; section reports on a single file. Each &lt;b&gt;Subroutine&lt;/b&gt; section reports on a single subroutine apart from the special cases &quot;(definitions)&quot; and &quot;(main)&quot;. These report, respectively, on subroutine definitions found by the initial symbol table walk and on the main part of the program or module external to all subroutines.</source>
          <target state="translated">Каждый раздел &lt;b&gt;файла&lt;/b&gt; представляет собой отчет об одном файле. Каждый раздел &lt;b&gt;подпрограммы&lt;/b&gt; сообщает об одной подпрограмме, за исключением особых случаев &amp;laquo;(определения)&amp;raquo; и &amp;laquo;(основной)&amp;raquo;. Они сообщают, соответственно, об определениях подпрограмм, найденных в ходе начального обхода таблицы символов, и об основной части программы или модуля, внешнего по отношению ко всем подпрограммам.</target>
        </trans-unit>
        <trans-unit id="c3f67868071b09e484f931abe029f1f8f7b5dc16" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;--$source-option&lt;/code&gt; option must specify a key/value pair separated by an &lt;code&gt;=&lt;/code&gt; . If an option can take multiple values, just specify it multiple times, as with the &lt;code&gt;extensions=&lt;/code&gt; examples above. If the option should be a hash reference, specify the value as a second pair separated by a &lt;code&gt;=&lt;/code&gt; , as in the &lt;code&gt;pset=&lt;/code&gt; examples above (escape &lt;code&gt;=&lt;/code&gt; with a backslash).</source>
          <target state="translated">Каждая &lt;code&gt;--$source-option&lt;/code&gt; должна указывать пару ключ / значение, разделенную знаком &lt;code&gt;=&lt;/code&gt; . Если параметр может принимать несколько значений, просто укажите его несколько раз, как в примерах &lt;code&gt;extensions=&lt;/code&gt; выше. Если параметр должен быть хэш ссылки, указать значение в качестве второй пары будут разделены &lt;code&gt;=&lt;/code&gt; , как и в &lt;code&gt;pset=&lt;/code&gt; примеров выше (побег &lt;code&gt;=&lt;/code&gt; с обратной косой чертой).</target>
        </trans-unit>
        <trans-unit id="72aa1e6906c5ec0ac410f03e5bee3a9d52fb4bb1" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;--$source-option&lt;/code&gt; option must specify a key/value pair separated by an &lt;code&gt;=&lt;/code&gt;. If an option can take multiple values, just specify it multiple times, as with the &lt;code&gt;extensions=&lt;/code&gt; examples above. If the option should be a hash reference, specify the value as a second pair separated by a &lt;code&gt;=&lt;/code&gt;, as in the &lt;code&gt;pset=&lt;/code&gt; examples above (escape &lt;code&gt;=&lt;/code&gt; with a backslash).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114f01b386e99faf35799463e66245b3c628986d" translate="yes" xml:space="preserve">
          <source>Each C type is represented by an entry in the typemap file that is responsible for converting perl variables (SV, AV, HV, CV, etc.) to and from that type. The following sections list all XS types that come with perl by default.</source>
          <target state="translated">Каждый тип C представлен записью в файле типовой карты,которая отвечает за преобразование переменных perl (SV,AV,HV,CV и т.д.)в этот тип и из него.В следующих разделах перечислены все типы XS,которые по умолчанию поставляются с perl.</target>
        </trans-unit>
        <trans-unit id="45fe11f5c5ad8666badf6e1b74648061569fd2e9" translate="yes" xml:space="preserve">
          <source>Each CV has a pointer, &lt;code&gt;CvOUTSIDE()&lt;/code&gt; , to its lexically enclosing CV (if any). Because pointers to anonymous sub prototypes are stored in &lt;code&gt;&amp;amp;&lt;/code&gt; pad slots, it is a possible to get a circular reference, with the parent pointing to the child and vice-versa. To avoid the ensuing memory leak, we do not increment the reference count of the CV pointed to by &lt;code&gt;CvOUTSIDE&lt;/code&gt; in the</source>
          <target state="translated">Каждое CV имеет указатель &lt;code&gt;CvOUTSIDE()&lt;/code&gt; на его лексически включающее CV (если есть). Поскольку указатели на анонимные под-прототипы хранятся в слотах &lt;code&gt;&amp;amp;&lt;/code&gt; Pad, можно получить циклическую ссылку, при которой родительский элемент указывает на дочерний элемент и наоборот. Чтобы избежать последующей утечки памяти, мы не увеличиваем счетчик ссылок CV, на который указывает &lt;code&gt;CvOUTSIDE&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="0a552f3c9f394752d19b918c33b1679413791b25" translate="yes" xml:space="preserve">
          <source>Each CV has a pointer, &lt;code&gt;CvOUTSIDE()&lt;/code&gt;, to its lexically enclosing CV (if any). Because pointers to anonymous sub prototypes are stored in &lt;code&gt;&amp;amp;&lt;/code&gt; pad slots, it is a possible to get a circular reference, with the parent pointing to the child and vice-versa. To avoid the ensuing memory leak, we do not increment the reference count of the CV pointed to by &lt;code&gt;CvOUTSIDE&lt;/code&gt; in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877f690dc448228c6c71438f034057615156195d" translate="yes" xml:space="preserve">
          <source>Each INPUT or OUTPUT typemap entry is a double-quoted Perl string that will be evaluated in the presence of certain variables to get the final C code for mapping a certain C type.</source>
          <target state="translated">Каждая запись в INPUT или OUTPUT-это строка Perl в двойных кавычках,которая будет оцениваться при наличии определенных переменных,чтобы получить окончательный код C для отображения определенного типа C.</target>
        </trans-unit>
        <trans-unit id="fb013f151204036ffe28cd6f1b7420c85313acfd" translate="yes" xml:space="preserve">
          <source>Each NAME is assumed to be in the calling package. See share_from for an alternative method (which &lt;code&gt;share&lt;/code&gt; uses).</source>
          <target state="translated">Предполагается, что каждое ИМЯ находится в вызывающем пакете. См. Share_from для альтернативного метода (который использует &lt;code&gt;share&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5c9985ee57f0e8b2c8e51c7278e3d4c3d9b47d87" translate="yes" xml:space="preserve">
          <source>Each NAME must be the &lt;b&gt;name&lt;/b&gt; of a non-lexical variable, typically with the leading type identifier included. A bareword is treated as a function name.</source>
          <target state="translated">Каждое ИМЯ должно быть &lt;b&gt;именем&lt;/b&gt; нелексической переменной, обычно с включенным идентификатором ведущего типа. Простое слово рассматривается как имя функции.</target>
        </trans-unit>
        <trans-unit id="2d1afe9f64b8afc5ff5d1587bde457161df361bb" translate="yes" xml:space="preserve">
          <source>Each array &lt;code&gt;@{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; holds the lines of $filename for a file compiled by Perl. The same is also true for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">Каждый массив &lt;code&gt;@{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; содержит строки с именем $ filename для файла, скомпилированного Perl. То же самое верно и для &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; строк, которые содержат подпрограммы или которые в настоящее время выполняются. Имя $ filename для строк &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ed выглядит так &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4542f557bdf7a70f332f8c5d8d58355f058485ae" translate="yes" xml:space="preserve">
          <source>Each array &lt;code&gt;@{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; holds the lines of $filename for a file compiled by Perl. The same is also true for &lt;code&gt;eval&lt;/code&gt;ed strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;eval&lt;/code&gt;ed strings looks like &lt;code&gt;(eval 34)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f0c2f3d8605c13877f68e54dd82f6341b8fae0" translate="yes" xml:space="preserve">
          <source>Each class can define its &lt;b&gt;attributes&lt;/b&gt;. When we instantiate an object, we assign values to those attributes. For example, every &lt;code&gt;File&lt;/code&gt; object has a path. Attributes are sometimes called &lt;b&gt;properties&lt;/b&gt;.</source>
          <target state="translated">Каждый класс может определять свои &lt;b&gt;атрибуты&lt;/b&gt; . Когда мы создаем экземпляр объекта, мы присваиваем значения этим атрибутам. Например, у каждого объекта &lt;code&gt;File&lt;/code&gt; есть путь. Атрибуты иногда называют &lt;b&gt;свойствами&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="64bf8b278b40ceb1457596f928446c91560cdf44" translate="yes" xml:space="preserve">
          <source>Each compartment has an associated &quot;operator mask&quot;. Recall that perl code is compiled into an internal format before execution. Evaluating perl code (e.g. via &quot;eval&quot; or &quot;do 'file'&quot;) causes the code to be compiled into an internal format and then, provided there was no error in the compilation, executed. Code evaluated in a compartment compiles subject to the compartment's operator mask. Attempting to evaluate code in a compartment which contains a masked operator will cause the compilation to fail with an error. The code will not be executed.</source>
          <target state="translated">Каждое отделение имеет соответствующую &quot;маску оператора&quot;.Напомним,что perl-код перед выполнением компилируется во внутренний формат.Оценка perl-кода (например,через &quot;eval&quot; или &quot;do 'file'&quot;)приводит к тому,что код компилируется во внутренний формат,а затем,при условии отсутствия ошибок в компиляции,выполняется.Код,вычисленный в помещении,компилируется с учетом маски оператора помещения.Попытка оценить код в помещении,содержащем оператор masked,приведет к ошибке при компиляции.Код не будет выполнен.</target>
        </trans-unit>
        <trans-unit id="c6c4ed2bbcee866615b18a5377b47f14999fe9bd" translate="yes" xml:space="preserve">
          <source>Each context entry is labelled with a context type, &lt;code&gt;cx_type&lt;/code&gt;. Typical context types are &lt;code&gt;CXt_SUB&lt;/code&gt;, &lt;code&gt;CXt_EVAL&lt;/code&gt; etc., as well as &lt;code&gt;CXt_BLOCK&lt;/code&gt; and &lt;code&gt;CXt_NULL&lt;/code&gt; which represent a basic scope (as pushed by &lt;code&gt;pp_enter&lt;/code&gt;) and a sort block. The type determines which part of the context union are valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035a2860cc641f9a6aba917e368a923359692185" translate="yes" xml:space="preserve">
          <source>Each element in the struct data has an accessor method, which is used to assign to the element and to fetch its value. The default accessor can be overridden by declaring a &lt;code&gt;&lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; of the same name in the package. (See Example 2.)</source>
          <target state="translated">Каждый элемент в данных структуры имеет метод доступа, который используется для присвоения элементу и получения его значения. Средство доступа по умолчанию можно переопределить, объявив в пакете одноименную &lt;code&gt;&lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; . (См. Пример 2.)</target>
        </trans-unit>
        <trans-unit id="79c8cb706f1fcfacc217858c7c85ae02ae2f4052" translate="yes" xml:space="preserve">
          <source>Each element in the struct data has an accessor method, which is used to assign to the element and to fetch its value. The default accessor can be overridden by declaring a &lt;code&gt;sub&lt;/code&gt; of the same name in the package. (See Example 2.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1373d9ec88c46f95e3a35afb96af5418baf7f3" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;%!&lt;/code&gt; has a true value only if &lt;code&gt;$!&lt;/code&gt; is set to that value. For example, &lt;code&gt;$!{ENOENT}&lt;/code&gt; is true if and only if the current value of &lt;code&gt;$!&lt;/code&gt; is &lt;code&gt;ENOENT&lt;/code&gt; ; that is, if the most recent error was &quot;No such file or directory&quot; (or its moral equivalent: not all operating systems give that exact error, and certainly not all languages). To check if a particular key is meaningful on your system, use &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;
$!{the_key}&lt;/code&gt; ; for a list of legal keys, use &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %!&lt;/code&gt; . See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt; for more information, and also see &lt;a href=&quot;#%24!&quot;&gt;$!&lt;/a&gt;.</source>
          <target state="translated">Каждый элемент &lt;code&gt;%!&lt;/code&gt; имеет истинное значение, только если &lt;code&gt;$!&lt;/code&gt; установлено на это значение. Например, &lt;code&gt;$!{ENOENT}&lt;/code&gt; истинно тогда и только тогда, когда текущее значение &lt;code&gt;$!&lt;/code&gt; это &lt;code&gt;ENOENT&lt;/code&gt; ; то есть, если самой последней ошибкой было &amp;laquo;Нет такого файла или каталога&amp;raquo; (или его моральный эквивалент: не все операционные системы выдают эту точную ошибку и, конечно, не все языки). Чтобы проверить, имеет ли значение конкретный ключ в вашей системе, используйте &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $!{the_key}&lt;/code&gt; ; для получения списка допустимых ключей используйте &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %!&lt;/code&gt; . См. Дополнительную информацию в &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt; , а также в &lt;a href=&quot;#%24!&quot;&gt;$! &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e3f755ecf95a73dbcb1fefb62d992d2bd88e203f" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;%!&lt;/code&gt; has a true value only if &lt;code&gt;$!&lt;/code&gt; is set to that value. For example, &lt;code&gt;$!{ENOENT}&lt;/code&gt; is true if and only if the current value of &lt;code&gt;$!&lt;/code&gt; is &lt;code&gt;ENOENT&lt;/code&gt;; that is, if the most recent error was &quot;No such file or directory&quot; (or its moral equivalent: not all operating systems give that exact error, and certainly not all languages). The specific true value is not guaranteed, but in the past has generally been the numeric value of &lt;code&gt;$!&lt;/code&gt;. To check if a particular key is meaningful on your system, use &lt;code&gt;exists $!{the_key}&lt;/code&gt;; for a list of legal keys, use &lt;code&gt;keys %!&lt;/code&gt;. See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt; for more information, and also see &lt;a href=&quot;#%24%21&quot;&gt;&quot;$!&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a2d451f571f682ca87c1d143e9cc5d9cc9752a" translate="yes" xml:space="preserve">
          <source>Each element of the &lt;code&gt;@tests&lt;/code&gt; array is either:</source>
          <target state="translated">Каждый элемент массива &lt;code&gt;@tests&lt;/code&gt; либо:</target>
        </trans-unit>
        <trans-unit id="d55ab66461652be4398995f0bc7395b92cdadc85" translate="yes" xml:space="preserve">
          <source>Each element on the right-hand side must be a reference to a datum of the right type. Parentheses immediately surrounding an array (and possibly also &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;) will make each element of the array an alias to the corresponding scalar referenced on the right-hand side:</source>
          <target state="translated">Каждый элемент с правой стороны должен быть ссылкой на датум правильного типа. Круглые скобки, непосредственно окружающие массив (и, возможно, также &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ), сделают каждый элемент массива псевдонимом для соответствующего скаляра, указанного в правой части:</target>
        </trans-unit>
        <trans-unit id="73d053df17de770313a9997b0c6b33ddac74a8d7" translate="yes" xml:space="preserve">
          <source>Each element on the right-hand side must be a reference to a datum of the right type. Parentheses immediately surrounding an array (and possibly also &lt;code&gt;my&lt;/code&gt;/&lt;code&gt;state&lt;/code&gt;/&lt;code&gt;our&lt;/code&gt;/&lt;code&gt;local&lt;/code&gt;) will make each element of the array an alias to the corresponding scalar referenced on the right-hand side:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4684b159123c6d2eb2be5f3fb5fb6b32cbd2c836" translate="yes" xml:space="preserve">
          <source>Each element's type can be scalar, array, hash, or class.</source>
          <target state="translated">Каждый тип элемента может быть скаляром,массивом,хэшем или классом.</target>
        </trans-unit>
        <trans-unit id="4a18db593068986b02fcc2822d10b93bd6ae4e04" translate="yes" xml:space="preserve">
          <source>Each engine is supposed to provide access to a constant structure of the following format:</source>
          <target state="translated">Каждый движок должен обеспечивать доступ к постоянной структуре следующего формата:</target>
        </trans-unit>
        <trans-unit id="df21f7171545bb80d42912cbb46608328ace6052" translate="yes" xml:space="preserve">
          <source>Each field in a picture line starts with either &quot;@&quot; (at) or &quot;^&quot; (caret), indicating what we'll call, respectively, a &quot;regular&quot; or &quot;special&quot; field. The choice of pad characters determines whether a field is textual or numeric. The tilde operators are not part of a field. Let's look at the various possibilities in detail.</source>
          <target state="translated">Каждое поле в строке картинки начинается либо с &quot;@&quot; (at),либо с &quot;^&quot; (caret),указывая на то,что мы будем называть,соответственно,&quot;обычным&quot; или &quot;специальным&quot; полем.Выбор символов планшета определяет,является ли поле текстовым или числовым.Операторы тильды не являются частью поля.Рассмотрим подробно различные возможности.</target>
        </trans-unit>
        <trans-unit id="e86751063b4744e62f491d3c6500569d32c72d11" translate="yes" xml:space="preserve">
          <source>Each filehandle in Perl counts the number of lines that have been read from it. (Depending on the value of &lt;code&gt;$/&lt;/code&gt; , Perl's idea of what constitutes a line may not match yours.) When a line is read from a filehandle (via &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ), or when &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek()&lt;/a&gt;&lt;/code&gt; is called on it, &lt;code&gt;$.&lt;/code&gt; becomes an alias to the line counter for that filehandle.</source>
          <target state="translated">Каждый дескриптор файла в Perl подсчитывает количество прочитанных из него строк. ( В зависимости от значения &lt;code&gt;$/&lt;/code&gt; , идея в Perl , что представляет собой линию может не совпадать с вашими.) Когда строка считывается с дескриптором (через &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ), или когда &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek()&lt;/a&gt;&lt;/code&gt; является призвал его, &lt;code&gt;$.&lt;/code&gt; становится псевдонимом счетчика строк для этого дескриптора файла.</target>
        </trans-unit>
        <trans-unit id="8e57c60a3cb6708806cfdda0d69fc8cd46dd15f5" translate="yes" xml:space="preserve">
          <source>Each filehandle in Perl counts the number of lines that have been read from it. (Depending on the value of &lt;code&gt;$/&lt;/code&gt;, Perl's idea of what constitutes a line may not match yours.) When a line is read from a filehandle (via &lt;code&gt;readline()&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;), or when &lt;code&gt;tell()&lt;/code&gt; or &lt;code&gt;seek()&lt;/code&gt; is called on it, &lt;code&gt;$.&lt;/code&gt; becomes an alias to the line counter for that filehandle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a9624b1b717a0ce3347c2a7723ee1a1d25abab" translate="yes" xml:space="preserve">
          <source>Each handle can be an &lt;code&gt;IO::Handle&lt;/code&gt; object, an integer or an array reference where the first element is an &lt;code&gt;IO::Handle&lt;/code&gt; or an integer.</source>
          <target state="translated">Каждый дескриптор может быть объектом &lt;code&gt;IO::Handle&lt;/code&gt; , целым числом или ссылкой на массив, где первым элементом является &lt;code&gt;IO::Handle&lt;/code&gt; или целое число.</target>
        </trans-unit>
        <trans-unit id="c1d7462289e4cec1a7aa1fe4c855d903202ec597" translate="yes" xml:space="preserve">
          <source>Each hash &lt;code&gt;%{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; contains breakpoints and actions keyed by line number. Individual entries (as opposed to the whole hash) are settable. Perl only cares about Boolean true here, although the values used by</source>
          <target state="translated">Каждый хэш &lt;code&gt;%{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; содержит точки останова и действия, привязанные к номеру строки. Можно настроить отдельные записи (в отличие от всего хеша). Perl здесь заботится только о логическом значении true, хотя значения, используемые</target>
        </trans-unit>
        <trans-unit id="62cc45eed91752b51404de9ea925a035fb43cbad" translate="yes" xml:space="preserve">
          <source>Each id must be unique within the document.</source>
          <target state="translated">Каждый идентификатор должен быть уникальным в документе.</target>
        </trans-unit>
        <trans-unit id="667975ad4758db6be064d162ec07e954e503457b" translate="yes" xml:space="preserve">
          <source>Each individual compressed data stream is read until the logical end-of-file is reached. Then &lt;code&gt;nextStream&lt;/code&gt; is called. This will skip to the start of the next compressed data stream and clear the end-of-file flag.</source>
          <target state="translated">Каждый отдельный поток сжатых данных читается до тех пор, пока не будет достигнут логический конец файла. Затем &lt;code&gt;nextStream&lt;/code&gt; . Это приведет к переходу к началу следующего потока сжатых данных и сбросу флага конца файла.</target>
        </trans-unit>
        <trans-unit id="18f2cec26478e04f9b7de7d10fcbddee95e58d2c" translate="yes" xml:space="preserve">
          <source>Each initializer is a pair of values:</source>
          <target state="translated">Каждый инициализатор представляет собой пару значений:</target>
        </trans-unit>
        <trans-unit id="16164820a467e235638c757ccfe00052f4c79b5f" translate="yes" xml:space="preserve">
          <source>Each is a reference to an array of hostnames (in order of preference), which should be used for the given protocol</source>
          <target state="translated">Каждое из них является ссылкой на массив имен хостов (в порядке предпочтения),который должен использоваться для данного протокола</target>
        </trans-unit>
        <trans-unit id="d29b86c40a3e654b348fa005424d750255213988" translate="yes" xml:space="preserve">
          <source>Each is an instance of a class with the following methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0eab90b97db650ebd8f6bc0b1085529dd6f2a05" translate="yes" xml:space="preserve">
          <source>Each key is the property name in its longest, most descriptive form. The values are what &lt;a href=&quot;#charprop%28%29&quot;&gt;&quot;charprop()&quot;&lt;/a&gt; would return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c5e455da6b08e4d8e8bc9f42db356fdab7233a" translate="yes" xml:space="preserve">
          <source>Each key is the property name in its longest, most descriptive form. The values are what &lt;a href=&quot;#charprop()&quot;&gt;charprop()&lt;/a&gt; would return.</source>
          <target state="translated">Каждый ключ - это имя свойства в его самой длинной и описательной форме. Значения - это то, что &lt;a href=&quot;#charprop()&quot;&gt;возвращает функция charprop ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47492265b46ae806bb067e9b524f132422627a4f" translate="yes" xml:space="preserve">
          <source>Each letter may optionally be followed by a number indicating the repeat count. A numeric repeat count may optionally be enclosed in brackets, as in &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; . The repeat count gobbles that many values from the LIST when used with all format types other than &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;P&lt;/code&gt; , where it means something else, described below. Supplying a &lt;code&gt;*&lt;/code&gt; for the repeat count instead of a number means to use however many items are left, except for:</source>
          <target state="translated">За каждой буквой необязательно может следовать число, указывающее счетчик повторов. Числовое число повторений может быть дополнительно заключено в скобки, как в &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; . Число повторений проглатывает , что многие значения из списка , когда используются со всеми типами форматов , отличных от , , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; и &lt;code&gt;P&lt;/code&gt; , где это означает что-то еще, описанное ниже. Поставка &lt;code&gt;*&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; для счетчика повторов вместо числа означает использовать сколько угодно элементов, за исключением:</target>
        </trans-unit>
        <trans-unit id="f1b93edbbeb731023c3dcd7b867f87661f785306" translate="yes" xml:space="preserve">
          <source>Each letter may optionally be followed by a number indicating the repeat count. A numeric repeat count may optionally be enclosed in brackets, as in &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; . The repeat count gobbles that many values from the LIST when used with all format types other than &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;P&lt;/code&gt; , where it means something else, described below. Supplying a &lt;code&gt;*&lt;/code&gt; for the repeat count instead of a number means to use however many items are left, except for:</source>
          <target state="translated">За каждой буквой необязательно может следовать число, указывающее счетчик повторов. Числовое число повторений может быть дополнительно заключено в скобки, как в &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; . Число повторений проглатывает , что многие значения из списка , когда используются со всеми типами форматов , отличных от , , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; и &lt;code&gt;P&lt;/code&gt; , где это означает что-то еще, описанное ниже. Поставка &lt;code&gt;*&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; для счетчика повторов вместо числа означает использовать сколько угодно элементов, за исключением:</target>
        </trans-unit>
        <trans-unit id="0ed7a060f431ab2cc494847effa3cd5278eb7c4f" translate="yes" xml:space="preserve">
          <source>Each letter may optionally be followed by a number indicating the repeat count. A numeric repeat count may optionally be enclosed in brackets, as in &lt;code&gt;pack(&quot;C[80]&quot;, @arr)&lt;/code&gt;. The repeat count gobbles that many values from the LIST when used with all format types other than &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;P&lt;/code&gt;, where it means something else, described below. Supplying a &lt;code&gt;*&lt;/code&gt; for the repeat count instead of a number means to use however many items are left, except for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca2b686ea513abcdcd81b004dc80b72da247c37" translate="yes" xml:space="preserve">
          <source>Each locale key is a reference to a hash that has the form above, and gives the casing rules for that particular locale, which take precedence over the locale-independent ones when in that locale.</source>
          <target state="translated">Каждый ключ локали является ссылкой на хэш,который имеет форму,описанную выше,и дает правила оболочки для данной конкретной локали,которые имеют приоритет над локально-независимыми,когда находятся в данной локали.</target>
        </trans-unit>
        <trans-unit id="b81c66f6a67c62b4046a77844c9acd84b539087f" translate="yes" xml:space="preserve">
          <source>Each method returns the old value of the &lt;code&gt;IO::Handle&lt;/code&gt; attribute. The methods each take an optional EXPR, which, if supplied, specifies the new value for the &lt;code&gt;IO::Handle&lt;/code&gt; attribute in question. If not supplied, most methods do nothing to the current value--except for &lt;code&gt;autoflush()&lt;/code&gt; , which will assume a 1 for you, just to be different.</source>
          <target state="translated">Каждый метод возвращает старое значение атрибута &lt;code&gt;IO::Handle&lt;/code&gt; . Каждый метод принимает необязательный EXPR, который, если он указан, указывает новое значение для рассматриваемого атрибута &lt;code&gt;IO::Handle&lt;/code&gt; . Если не указан, большинство методов ничего не делают с текущим значением - за исключением &lt;code&gt;autoflush()&lt;/code&gt; , который примет за вас 1, просто чтобы отличаться.</target>
        </trans-unit>
        <trans-unit id="549fa064c8357d58112301aba532e091511a4996" translate="yes" xml:space="preserve">
          <source>Each method returns the old value of the &lt;code&gt;IO::Handle&lt;/code&gt; attribute. The methods each take an optional EXPR, which, if supplied, specifies the new value for the &lt;code&gt;IO::Handle&lt;/code&gt; attribute in question. If not supplied, most methods do nothing to the current value--except for &lt;code&gt;autoflush()&lt;/code&gt;, which will assume a 1 for you, just to be different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a408a79f13c6ec4a0cd81e57c787564393f289b" translate="yes" xml:space="preserve">
          <source>Each name-type pair declares one element of the struct. Each element name will be defined as an accessor method unless a method by that name is explicitly defined; in the latter case, a warning is issued if the warning flag (&lt;b&gt;-w&lt;/b&gt;) is set.</source>
          <target state="translated">Каждая пара имя-тип объявляет один элемент структуры. Каждое имя элемента будет определено как метод доступа, если явно не определен метод с таким именем; в последнем случае выдается предупреждение, если установлен флаг предупреждения ( &lt;b&gt;-w&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="bea2fa8177204a00acbe330d65cd373309740d46" translate="yes" xml:space="preserve">
          <source>Each of the &lt;code&gt;$section_spec&lt;/code&gt; arguments should be a section specification as described in &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS&lt;/a&gt;. The section specifications are parsed by this method and the resulting regular expressions are stored in the invoking object.</source>
          <target state="translated">Каждый из аргументов &lt;code&gt;$section_spec&lt;/code&gt; должен быть спецификацией раздела, как описано в &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;СПЕЦИФИКАЦИЯХ РАЗДЕЛА&lt;/a&gt; . Спецификации раздела анализируются этим методом, а полученные регулярные выражения сохраняются в вызывающем объекте.</target>
        </trans-unit>
        <trans-unit id="9af6792ba1f44d7cb824f7440960f3ef5c01b6ba" translate="yes" xml:space="preserve">
          <source>Each of the POSIX classes matches exactly the same as their ASCII-range counterparts.</source>
          <target state="translated">Каждый из классов POSIX точно совпадает с их аналогами ASCII-диапазона.</target>
        </trans-unit>
        <trans-unit id="be167c32ebe292b1abf425a82a9d67c142fdc9a5" translate="yes" xml:space="preserve">
          <source>Each of the argument lists above comes out of the &lt;code&gt;normalize_f&lt;/code&gt; function looking exactly the same, like this:</source>
          <target state="translated">Каждый из приведенных выше списков аргументов является результатом функции &lt;code&gt;normalize_f&lt;/code&gt; , которая выглядит точно так же, как это:</target>
        </trans-unit>
        <trans-unit id="93679dc7d627c4c7a6a3897712645c4450ba1379" translate="yes" xml:space="preserve">
          <source>Each of the commands that produce listings of modules (&lt;code&gt;r&lt;/code&gt; , &lt;code&gt;autobundle&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; ) also return a list of the IDs of all modules within the list.</source>
          <target state="translated">Каждая из команд , &lt;code&gt;autobundle&lt;/code&gt; списки модулей ( &lt;code&gt;r&lt;/code&gt; , autobundle , &lt;code&gt;u&lt;/code&gt; ), также возвращает список идентификаторов всех модулей в списке.</target>
        </trans-unit>
        <trans-unit id="36a145ce6b55d2eacd4e152e8b778cb0812f1b4c" translate="yes" xml:space="preserve">
          <source>Each of the elementary pieces of regular expressions which were described before (such as &lt;code&gt;ab&lt;/code&gt; or &lt;code&gt;\Z&lt;/code&gt; ) could match at most one substring at the given position of the input string. However, in a typical regular expression these elementary pieces are combined into more complicated patterns using combining operators &lt;code&gt;ST&lt;/code&gt; , &lt;code&gt;S|T&lt;/code&gt; , &lt;code&gt;S*&lt;/code&gt; etc. (in these examples &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; are regular subexpressions).</source>
          <target state="translated">Каждая из элементарных частей регулярных выражений, которые были описаны ранее (например, &lt;code&gt;ab&lt;/code&gt; или &lt;code&gt;\Z&lt;/code&gt; ), может соответствовать не более одной подстроке в данной позиции входной строки. Однако в типичном регулярном выражении эти элементарные части объединяются в более сложные шаблоны с использованием операторов объединения &lt;code&gt;ST&lt;/code&gt; , &lt;code&gt;S|T&lt;/code&gt; , &lt;code&gt;S*&lt;/code&gt; и т. Д. (В этих примерах &lt;code&gt;S&lt;/code&gt; и &lt;code&gt;T&lt;/code&gt; являются регулярными подвыражениями).</target>
        </trans-unit>
        <trans-unit id="c1f94498db7cafa14ac711805deae194684f4e3e" translate="yes" xml:space="preserve">
          <source>Each of the elementary pieces of regular expressions which were described before (such as &lt;code&gt;ab&lt;/code&gt; or &lt;code&gt;\Z&lt;/code&gt;) could match at most one substring at the given position of the input string. However, in a typical regular expression these elementary pieces are combined into more complicated patterns using combining operators &lt;code&gt;ST&lt;/code&gt;, &lt;code&gt;S|T&lt;/code&gt;, &lt;code&gt;S*&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf85de30bb2350d06139ae6bc58a79af96a26e97" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print a message of &quot;Syntax error.&quot; (followed by a newline) to &lt;code&gt;STDERR&lt;/code&gt; , immediately followed by just the &quot;SYNOPSIS&quot; section (also printed to &lt;code&gt;STDERR&lt;/code&gt; ) and will exit with a status of 2:</source>
          <target state="translated">Каждый из следующих вызовов &lt;code&gt;pod2usage()&lt;/code&gt; выводит сообщение &amp;laquo;Синтаксическая ошибка&amp;raquo;. (за которым следует новая строка) в &lt;code&gt;STDERR&lt;/code&gt; , сразу за ним следует только раздел &amp;laquo;SYNOPSIS&amp;raquo; (также распечатанный в &lt;code&gt;STDERR&lt;/code&gt; ), и выйдет со статусом 2:</target>
        </trans-unit>
        <trans-unit id="c471e82fa0389f6962922185f6c1c022a3af5d32" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print a message of &quot;Syntax error.&quot; (followed by a newline) to &lt;code&gt;STDERR&lt;/code&gt;, immediately followed by just the &quot;SYNOPSIS&quot; section (also printed to &lt;code&gt;STDERR&lt;/code&gt;) and will exit with a status of 2:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da247936c8bb95b82240dfbb57e8459e5c728eb2" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print just the &quot;SYNOPSIS&quot; section to &lt;code&gt;STDERR&lt;/code&gt; and will exit with a status of 2:</source>
          <target state="translated">Каждый из следующих вызовов &lt;code&gt;pod2usage()&lt;/code&gt; выводит в &lt;code&gt;STDERR&lt;/code&gt; только раздел &amp;laquo; SYNOPSIS&amp;raquo; и завершается со статусом 2:</target>
        </trans-unit>
        <trans-unit id="c3bf15a510b108560bc55f9dc642118c67f04409" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print the &quot;SYNOPSIS&quot; section and any &quot;OPTIONS&quot; and/or &quot;ARGUMENTS&quot; sections to &lt;code&gt;STDOUT&lt;/code&gt; and will exit with a status of 1:</source>
          <target state="translated">Каждый из следующих вызовов &lt;code&gt;pod2usage()&lt;/code&gt; выводит раздел &amp;laquo;СИНТАКСИС&amp;raquo; и любые разделы &amp;laquo;ОПЦИИ&amp;raquo; и / или &amp;laquo;АРГУМЕНТЫ&amp;raquo; в &lt;code&gt;STDOUT&lt;/code&gt; и завершает работу со статусом 1:</target>
        </trans-unit>
        <trans-unit id="8a8549150e98bb7d0199412efeddf54defc2c85f" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print the entire manual page to &lt;code&gt;STDOUT&lt;/code&gt; and will exit with a status of 1:</source>
          <target state="translated">Каждый из следующих вызовов &lt;code&gt;pod2usage()&lt;/code&gt; будет печатать всю справочную страницу в &lt;code&gt;STDOUT&lt;/code&gt; и завершать работу со статусом 1:</target>
        </trans-unit>
        <trans-unit id="159291495d574283955b7dd83a0159a4cbe57ab7" translate="yes" xml:space="preserve">
          <source>Each of the following methods will return the total number of corresponding tests if called in scalar context. If called in list context, returns the descriptions of the parsers which contain the corresponding tests (see &lt;code&gt;add&lt;/code&gt; for an explanation of description.</source>
          <target state="translated">Каждый из следующих методов вернет общее количество соответствующих тестов, если они вызваны в скалярном контексте. При вызове в контексте списка возвращает описания парсеров, которые содержат соответствующие тесты (см. &lt;code&gt;add&lt;/code&gt; для объяснения описания.</target>
        </trans-unit>
        <trans-unit id="b4805d0a6e23a882a6f379f5e1aaffac33d67fcd" translate="yes" xml:space="preserve">
          <source>Each of the functions will now be discussed in turn.</source>
          <target state="translated">Теперь каждая из функций будет обсуждаться по очереди.</target>
        </trans-unit>
        <trans-unit id="cf8ee854b23795d139b708dbd25340dc64f25e5b" translate="yes" xml:space="preserve">
          <source>Each of the functions will return</source>
          <target state="translated">Каждая из функций вернется</target>
        </trans-unit>
        <trans-unit id="67d949b14cef9bc96632c4a26c1317dd5c052479" translate="yes" xml:space="preserve">
          <source>Each of the integer pack codes &lt;code&gt;sSlLqQ&lt;/code&gt; results in a fixed number of bytes, no matter where you execute your program. This may be useful for some applications, but it does not provide for a portable way to pass data structures between Perl and C programs (bound to happen when you call XS extensions or the Perl function &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt;), or when you read or write binary files. What you'll need in this case are template codes that depend on what your local C compiler compiles when you code &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;unsigned long&lt;/code&gt; , for instance. These codes and their corresponding byte lengths are shown in the table below. Since the C standard leaves much leeway with respect to the relative sizes of these data types, actual values may vary, and that's why the values are given as expressions in C and Perl. (If you'd like to use values from &lt;code&gt;%Config&lt;/code&gt; in your program you have to import it with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; .)</source>
          <target state="translated">Каждый из целочисленных кодов пакета &lt;code&gt;sSlLqQ&lt;/code&gt; дает фиксированное количество байтов независимо от того, где вы выполняете свою программу. Это может быть полезно для некоторых приложений, но не обеспечивает переносимого способа передачи структур данных между программами Perl и C (обязательно произойдет, когда вы вызываете расширения XS или &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; функции Perl ) или когда вы читаете или записываете двоичные файлы. . В этом случае вам понадобятся коды шаблонов, которые зависят от того, что компилирует ваш локальный компилятор C, когда вы кодируете &lt;code&gt;short&lt;/code&gt; или &lt;code&gt;unsigned long&lt;/code&gt; код., например. Эти коды и соответствующие им байтовые длины показаны в таблице ниже. Поскольку стандарт C оставляет большую свободу действий в отношении относительных размеров этих типов данных, фактические значения могут отличаться, и поэтому значения представлены в виде выражений в C и Perl. (Если вы хотите использовать значения из &lt;code&gt;%Config&lt;/code&gt; в своей программе, вам необходимо импортировать их с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="6060e81492ddf46249708e305af675d2cd8e4300" translate="yes" xml:space="preserve">
          <source>Each of the integer pack codes &lt;code&gt;sSlLqQ&lt;/code&gt; results in a fixed number of bytes, no matter where you execute your program. This may be useful for some applications, but it does not provide for a portable way to pass data structures between Perl and C programs (bound to happen when you call XS extensions or the Perl function &lt;code&gt;syscall&lt;/code&gt;), or when you read or write binary files. What you'll need in this case are template codes that depend on what your local C compiler compiles when you code &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;unsigned long&lt;/code&gt;, for instance. These codes and their corresponding byte lengths are shown in the table below. Since the C standard leaves much leeway with respect to the relative sizes of these data types, actual values may vary, and that's why the values are given as expressions in C and Perl. (If you'd like to use values from &lt;code&gt;%Config&lt;/code&gt; in your program you have to import it with &lt;code&gt;use Config&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d0d0049982558d7e176e2f3ab3ea596bc6e428" translate="yes" xml:space="preserve">
          <source>Each of the methods below (except config(), accuracy() and precision()) accepts three additional parameters. These arguments &lt;code&gt;$A&lt;/code&gt; , &lt;code&gt;$P&lt;/code&gt; and &lt;code&gt;$R&lt;/code&gt; are &lt;code&gt;accuracy&lt;/code&gt; , &lt;code&gt;precision&lt;/code&gt; and &lt;code&gt;round_mode&lt;/code&gt; . Please see the section about &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;ACCURACY and PRECISION&lt;/a&gt; for more information.</source>
          <target state="translated">Каждый из приведенных ниже методов (кроме config (), precision () и precision ()) принимает три дополнительных параметра. Эти аргументы &lt;code&gt;$A&lt;/code&gt; , &lt;code&gt;$P&lt;/code&gt; и &lt;code&gt;$R&lt;/code&gt; - это &lt;code&gt;accuracy&lt;/code&gt; , &lt;code&gt;precision&lt;/code&gt; и &lt;code&gt;round_mode&lt;/code&gt; . Пожалуйста, смотрите раздел &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;ТОЧНОСТЬ и ТОЧНОСТЬ&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="2d2b46938dbf24928125c2dd236a1a486381e417" translate="yes" xml:space="preserve">
          <source>Each of the methods below (except config(), accuracy() and precision()) accepts three additional parameters. These arguments &lt;code&gt;$A&lt;/code&gt;, &lt;code&gt;$P&lt;/code&gt; and &lt;code&gt;$R&lt;/code&gt; are &lt;code&gt;accuracy&lt;/code&gt;, &lt;code&gt;precision&lt;/code&gt; and &lt;code&gt;round_mode&lt;/code&gt;. Please see the section about &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;&quot;ACCURACY and PRECISION&quot;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bb55af40d1c4ccf668c4ee509cae7b3650aeb0" translate="yes" xml:space="preserve">
          <source>Each of the methods works identically, and is used to install (or uninstall) a single DBM Filter. The only difference between them is the place that the filter is installed.</source>
          <target state="translated">Каждый из методов работает одинаково,и используется для установки (или удаления)одного DBM-фильтра.Единственное различие между ними-место установки фильтра.</target>
        </trans-unit>
        <trans-unit id="d70d3afe0fc2fcaf924f4e6c71f92047845119e3" translate="yes" xml:space="preserve">
          <source>Each of the targets is created only once (but see &lt;a href=&quot;#Scratchpads-and-recursion&quot;&gt;&quot;Scratchpads and recursion&quot;&lt;/a&gt; below), and when an opcode needs to put an integer, a double, or a string on stack, it just sets the corresponding parts of its</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb52f34c0e7c886d38c077a6693f8fac31c72b2" translate="yes" xml:space="preserve">
          <source>Each of the targets is created only once (but see &lt;a href=&quot;#Scratchpads-and-recursion&quot;&gt;Scratchpads and recursion&lt;/a&gt; below), and when an opcode needs to put an integer, a double, or a string on stack, it just sets the corresponding parts of its</source>
          <target state="translated">Каждая из целей создается только один раз (но см. &lt;a href=&quot;#Scratchpads-and-recursion&quot;&gt;Блокноты и рекурсию&lt;/a&gt; ниже), и когда код операции должен поместить в стек целое число, двойное число или строку, он просто устанавливает соответствующие части своего</target>
        </trans-unit>
        <trans-unit id="61645526a5f8cc5b5b38c365e573e3b9ce2a363a" translate="yes" xml:space="preserve">
          <source>Each of these areas will be discussed in the following sections.</source>
          <target state="translated">Каждая из этих областей будет обсуждаться в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="4a7e0927366cb3008e3cb582f1225e023afb76ec" translate="yes" xml:space="preserve">
          <source>Each of these functions are called without arguments and return the absolute path of the current working directory.</source>
          <target state="translated">Каждая из этих функций вызывается без аргументов и возвращает абсолютный путь текущей рабочей директории.</target>
        </trans-unit>
        <trans-unit id="fb6c26bfd690fb609fa0a362b968489c94f785d7" translate="yes" xml:space="preserve">
          <source>Each of these input objects are described in further detail in the sections which follow.</source>
          <target state="translated">Каждый из этих объектов ввода подробно описан в последующих разделах.</target>
        </trans-unit>
        <trans-unit id="cd0ac943df3c5c0919c257e9e2ba53e934e28e43" translate="yes" xml:space="preserve">
          <source>Each of these methods may modify the first input argument, except</source>
          <target state="translated">Каждый из этих методов может изменять первый входной аргумент,за исключением следующего</target>
        </trans-unit>
        <trans-unit id="94636e821462a702e9dcf821156451ce10166f58" translate="yes" xml:space="preserve">
          <source>Each of these methods may modify the first input argument.</source>
          <target state="translated">Каждый из этих методов может изменить первый входной аргумент.</target>
        </trans-unit>
        <trans-unit id="1fd6321d309f67bf764c8af9cff581fae0812fa5" translate="yes" xml:space="preserve">
          <source>Each of these nodes represents an op, a fundamental operation inside the Perl core. The code which implements each operation can be found in the</source>
          <target state="translated">Каждый из этих узлов представляет собой операцию,фундаментальную операцию внутри ядра Perl.Код,реализующий каждую операцию,можно найти в разделе</target>
        </trans-unit>
        <trans-unit id="eb5de442d3b4d44516edecf88d3338777e703e96" translate="yes" xml:space="preserve">
          <source>Each of these objects may be replaced by calling one of these parser methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d6b2a3cedc47a8c8496247740303b046f066c7" translate="yes" xml:space="preserve">
          <source>Each of these options is optional; you can include some, all, or none of them.</source>
          <target state="translated">Каждый из этих вариантов является необязательным;вы можете включить некоторые,все или ни один из них.</target>
        </trans-unit>
        <trans-unit id="b15a1940399791f7b94602b4451362ab540da911" translate="yes" xml:space="preserve">
          <source>Each of these routines accepts a file specification in either VMS or Unix syntax, and returns the converted file specification, or &lt;code&gt;undef&lt;/code&gt; if an error occurs. The conversions are, for the most part, simply string manipulations; the routines do not check the details of syntax (e.g. that only legal characters are used). There is one exception: when running under VMS, conversions from VMS syntax use the $PARSE service to expand specifications, so illegal syntax, or a relative directory specification which extends above the tope of the current directory path (e.g [---.foo] when in dev:[dir.sub]) will cause errors. In general, any legal file specification will be converted properly, but garbage input tends to produce garbage output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b7bd343bf185137324ab08afba721e66b470a2" translate="yes" xml:space="preserve">
          <source>Each of these routines is prototyped as taking a single scalar argument, so you can use them as unary operators in complex expressions (as long as you don't use the &lt;code&gt;&amp;amp;&lt;/code&gt; form of subroutine call, which bypasses prototype checking).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fde8ca981b648a0a7df0eccad95608e9bb268d" translate="yes" xml:space="preserve">
          <source>Each op is preceded by two pointers: one points to the next op in the slab, and the other points to the slab that owns it. The next-op pointer is needed so that Perl can iterate over a slab and free all its ops. (Op structures are of different sizes, so the slab's ops can't merely be treated as a dense array.) The slab pointer is needed for accessing a reference count on the slab: when the last op on a slab is freed, the slab itself is freed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f0b67ca5c809a794efbf846b5f11a39a783c34" translate="yes" xml:space="preserve">
          <source>Each operand is considered in a modified scalar context, the modification being that array and hash variables are passed by reference to the operator, which implicitly dereferences them. Both elements of each pair are the same:</source>
          <target state="translated">Каждый операнд рассматривается в модифицированном скалярном контексте,при этом модификация заключается в том,что массив и хэш-переменные передаются по ссылке на оператор,который неявно разыменовывает их.Оба элемента каждой пары одинаковы:</target>
        </trans-unit>
        <trans-unit id="76254c26642feac52117b7e65ad2b643499a9d47" translate="yes" xml:space="preserve">
          <source>Each operator has both a terse name (its opname) and a more verbose or recognisable descriptive name. The opdesc function can be used to return a list of descriptions for a list of operators.</source>
          <target state="translated">Каждый оператор имеет как краткое имя (его opname),так и более многословное или узнаваемое описательное имя.Функция opdesc может быть использована для возврата списка описаний для списка операторов.</target>
        </trans-unit>
        <trans-unit id="0ffccbf8d7d785427858064bfe414c9a343b8478" translate="yes" xml:space="preserve">
          <source>Each option specifier consists of two parts: the name specification and the argument specification.</source>
          <target state="translated">Каждый спецификатор опции состоит из двух частей:спецификации имени и спецификации аргумента.</target>
        </trans-unit>
        <trans-unit id="49dbe9df44df46422e8ed79c89a972f7e0a049b6" translate="yes" xml:space="preserve">
          <source>Each package contains a special array called &lt;code&gt;@ISA&lt;/code&gt; . The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of that class's parent classes, if any. This array is examined when Perl does method resolution, which we will cover later.</source>
          <target state="translated">Каждый пакет содержит специальный массив с именем &lt;code&gt;@ISA&lt;/code&gt; . &lt;code&gt;@ISA&lt;/code&gt; массив содержит список родительских классов этого класса, если таковые имеются. Этот массив исследуется, когда Perl выполняет разрешение метода, о чем мы поговорим позже.</target>
        </trans-unit>
        <trans-unit id="ddf57d8082b4349ec2c54b6a8bdc282825375550" translate="yes" xml:space="preserve">
          <source>Each package contains a special array called &lt;code&gt;@ISA&lt;/code&gt; which contains a list of that class's parent classes, if any. This array is simply a list of scalars, each of which is a string that corresponds to a package name. The array is examined when Perl does method resolution, which is covered in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9236fa90d77c1443c1fcc30f0eb2e90c48b3b452" translate="yes" xml:space="preserve">
          <source>Each package contains a special array called &lt;code&gt;@ISA&lt;/code&gt;. The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of that class's parent classes, if any. This array is examined when Perl does method resolution, which we will cover later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd56746947dceb1b1ebf83666e64df3d893f0573" translate="yes" xml:space="preserve">
          <source>Each pair is an array reference with two elements - namely the</source>
          <target state="translated">Каждая пара представляет собой ссылку на массив с двумя элементами,а именно</target>
        </trans-unit>
        <trans-unit id="79339b4554cd8ab3b93700df12bacff7c6d9a530" translate="yes" xml:space="preserve">
          <source>Each pathname that is a directory that matches the pattern has a slash appended.</source>
          <target state="translated">К каждому патнану,который является каталогом,совпадающим с шаблоном,добавляется косая черта.</target>
        </trans-unit>
        <trans-unit id="20b56d27482026f6b453dfe18f7f652ebd744ed0" translate="yes" xml:space="preserve">
          <source>Each plugin should register itself by providing the following structure</source>
          <target state="translated">Каждый плагин должен зарегистрировать себя,предоставив следующую структуру</target>
        </trans-unit>
        <trans-unit id="4bc675eeb53212d68aff2215974b513fa9d0ff3e" translate="yes" xml:space="preserve">
          <source>Each programmer will, of course, have his or her own preferences in regards to formatting, but there are some general guidelines that will make your programs easier to read, understand, and maintain.</source>
          <target state="translated">Каждый программист,конечно,будет иметь свои предпочтения в отношении форматирования,но есть некоторые общие рекомендации,которые сделают ваши программы легче читать,понимать и поддерживать.</target>
        </trans-unit>
        <trans-unit id="e2d7e5e3cbcd85e0f15e433073f3c09c16649807" translate="yes" xml:space="preserve">
          <source>Each pseudo-process maintains its own virtual environment. Modifications to %ENV affect the virtual environment, and are only visible within that pseudo-process, and in any processes (or pseudo-processes) launched from it.</source>
          <target state="translated">Каждый псевдо-процесс поддерживает свою собственную виртуальную среду.Изменения в %ENV влияют на виртуальное окружение,и видны только внутри этого псевдо-процесса,а также в любых процессах (или псевдо-процессах),запускаемых из него.</target>
        </trans-unit>
        <trans-unit id="25a97b930031adadf111787667688ded94505539" translate="yes" xml:space="preserve">
          <source>Each pseudo-process maintains its own virtual idea of the current directory. Modifications to the current directory using chdir() are only visible within that pseudo-process, and in any processes (or pseudo-processes) launched from it. All file and directory accesses from the pseudo-process will correctly map the virtual working directory to the real working directory appropriately.</source>
          <target state="translated">Каждый псевдо-процесс поддерживает свое виртуальное представление о текущем каталоге.Изменения в текущей директории с помощью chdir()видны только внутри этого псевдо-процесса и в любых процессах (или псевдо-процессах),запущенных из него.Все доступы к файлам и директориям из псевдо-процесса будут корректно сопоставлять виртуальный рабочий каталог с реальным рабочим каталогом.</target>
        </trans-unit>
        <trans-unit id="8f4f1268e7fb63f76b0f62897f0f8014b138b792" translate="yes" xml:space="preserve">
          <source>Each result bit is based on the least-significant bit of the corresponding input character, i.e., on &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate bits 0 and 1, as do characters &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; .</source>
          <target state="translated">Каждый бит результата основан на младшем бите соответствующего входного символа, т. &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt; На ord ($ char)% 2 . В частности, символы &lt;code&gt;&quot;0&quot;&lt;/code&gt; и &lt;code&gt;&quot;1&quot;&lt;/code&gt; генерируют биты 0 и 1, как и символы &lt;code&gt;&quot;\000&quot;&lt;/code&gt; и &lt;code&gt;&quot;\001&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abf39ff7c44d3c8c17f0be2056a001c031f6f08e" translate="yes" xml:space="preserve">
          <source>Each result bit is based on the least-significant bit of the corresponding input character, i.e., on &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate bits 0 and 1, as do characters &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; .</source>
          <target state="translated">Каждый бит результата основан на младшем бите соответствующего входного символа, т. &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt; На ord ($ char)% 2 . В частности, символы &lt;code&gt;&quot;0&quot;&lt;/code&gt; и &lt;code&gt;&quot;1&quot;&lt;/code&gt; генерируют биты 0 и 1, как и символы &lt;code&gt;&quot;\000&quot;&lt;/code&gt; и &lt;code&gt;&quot;\001&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1993b5736422a8ea772061042ca6c62dead2e8c" translate="yes" xml:space="preserve">
          <source>Each result bit is based on the least-significant bit of the corresponding input character, i.e., on &lt;code&gt;ord($char)%2&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate bits 0 and 1, as do characters &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1801d81c7323468b4de78bc480016b6092b96d8e" translate="yes" xml:space="preserve">
          <source>Each result fetched is a result object of a different type. There are common methods to each result object and different types may have methods unique to their type. Sometimes a type method may be overridden in a subclass, but its use is guaranteed to be identical.</source>
          <target state="translated">Каждый полученный результат является объектом результата разного типа.Для каждого объекта результата существуют общие методы,и различные типы могут иметь методы,уникальные для их типа.Иногда метод типа может быть переопределен в подклассе,но его использование гарантированно идентично.</target>
        </trans-unit>
        <trans-unit id="4e19bf2bd96e365232fc6a017a9d4e2f9f8f058b" translate="yes" xml:space="preserve">
          <source>Each result returned is a &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt; subclass, referred to as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca0f4c2c0d0f6d5b588e090e9018c1d20041904" translate="yes" xml:space="preserve">
          <source>Each result returned is a &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; subclass, referred to as</source>
          <target state="translated">Каждый возвращаемый результат - это подкласс &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; , называемый</target>
        </trans-unit>
        <trans-unit id="ce5b6f7b029d0c88c7f3bdd0a0914e98b5dca329" translate="yes" xml:space="preserve">
          <source>Each result returned is a subclass of &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. See that module and related classes for more information on how to use them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a1f92895a8d5d3bca2a476a0ec322b95e7589a" translate="yes" xml:space="preserve">
          <source>Each result returned is a subclass of &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. See that module and related classes for more information on how to use them.</source>
          <target state="translated">Каждый возвращаемый результат является подклассом &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; . См. Этот модуль и связанные классы для получения дополнительной информации о том, как их использовать.</target>
        </trans-unit>
        <trans-unit id="8f5ef808a290d77bcb78c1a52baf58c7827e311b" translate="yes" xml:space="preserve">
          <source>Each scalar &lt;code&gt;${&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; contains &lt;code&gt;&quot;_&amp;lt;$filename&quot;&lt;/code&gt; . This is also the case for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">Каждый скаляр &lt;code&gt;${&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; содержит &lt;code&gt;&quot;_&amp;lt;$filename&quot;&lt;/code&gt; . Это также относится к оцененным строкам, которые содержат подпрограммы или которые в настоящее время выполняются. Имя $ filename для строк &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ed выглядит так &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccc94bfc366f53a70874613dffa08986828d80a8" translate="yes" xml:space="preserve">
          <source>Each scalar &lt;code&gt;${&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; contains &lt;code&gt;&quot;_&amp;lt;$filename&quot;&lt;/code&gt;. This is also the case for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;eval&lt;/code&gt;ed strings looks like &lt;code&gt;(eval 34)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b759249474717644d66332dcc04eba32c6b818f" translate="yes" xml:space="preserve">
          <source>Each semaphore has a counter attached to it. By default, semaphores are created with the counter set to one, &lt;code&gt;down()&lt;/code&gt; decrements the counter by one, and &lt;code&gt;up()&lt;/code&gt; increments by one. However, we can override any or all of these defaults simply by passing in different values:</source>
          <target state="translated">К каждому семафору прикреплен счетчик. По умолчанию семафоры создаются со счетчиком, установленным на единицу, &lt;code&gt;down()&lt;/code&gt; уменьшает счетчик на единицу, а &lt;code&gt;up()&lt;/code&gt; увеличивает на единицу. Однако мы можем переопределить любые или все эти значения по умолчанию, просто передав другие значения:</target>
        </trans-unit>
        <trans-unit id="9e3598640cb6381c253bcf070a1e62dc7e9d0823" translate="yes" xml:space="preserve">
          <source>Each step is of the form &lt;code&gt;n &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;&lt;/code&gt;, with &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; the part of the string matched and &lt;code&gt;&amp;lt;y&amp;gt;&lt;/code&gt; the part not yet matched. The &lt;code&gt;|  1:  STAR&lt;/code&gt; says that Perl is at line number 1 in the compilation list above. See &lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;Debugging Regular Expressions in perldebguts&lt;/a&gt; for much more detail.</source>
          <target state="translated">Каждый шаг имеет форму &lt;code&gt;n &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;&lt;/code&gt; , где &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; соответствует части строки, а &lt;code&gt;&amp;lt;y&amp;gt;&lt;/code&gt; - части, которая еще не согласована. &lt;code&gt;| 1: STAR&lt;/code&gt; сообщает, что Perl находится в строке номер 1 в списке компиляции выше. Более подробную информацию см. В разделе &amp;laquo; &lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;Отладка регулярных выражений в perldebguts&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="621b92ce1167d60ce7eabc3bf97a2ce373df3b42" translate="yes" xml:space="preserve">
          <source>Each step is of the form &lt;code&gt;n &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;&lt;/code&gt;, with &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; the part of the string matched and &lt;code&gt;&amp;lt;y&amp;gt;&lt;/code&gt; the part not yet matched. The &lt;code&gt;| 1: STAR&lt;/code&gt; says that Perl is at line number 1 in the compilation list above. See &lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;&quot;Debugging Regular Expressions&quot; in perldebguts&lt;/a&gt; for much more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f223fa7c50954c6826a1fdb18aaf28328cfda343" translate="yes" xml:space="preserve">
          <source>Each test can be given a little descriptive name as the second argument to &lt;code&gt;ok()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bdc8ff98493a9f7ade9d6296926319855358f97" translate="yes" xml:space="preserve">
          <source>Each thread (except the main thread) is started using the C locale. The main thread is started like all other Perl programs; see &lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot; in perllocale&lt;/a&gt;. You can switch locales in any thread as often as you like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3defe21495aad5ab5041830fd4fe29198a67142" translate="yes" xml:space="preserve">
          <source>Each time &lt;code&gt;$finder-&amp;gt;next&lt;/code&gt; is called, the iterator returns one of two possible values:</source>
          <target state="translated">Каждый раз, когда &lt;code&gt;$finder-&amp;gt;next&lt;/code&gt; , итератор возвращает одно из двух возможных значений:</target>
        </trans-unit>
        <trans-unit id="54bbe29b947a5618329ec98194ec80f8aabe46b6" translate="yes" xml:space="preserve">
          <source>Each type of section can appear an arbitrary number of times and does not have to appear at all. For example, a typemap may commonly lack &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; sections if all it needs to do is associate additional C types with core XS types like T_PTROBJ. Lines that start with a hash &lt;code&gt;#&lt;/code&gt; are considered comments and ignored in the &lt;code&gt;TYPEMAP&lt;/code&gt; section, but are considered significant in &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; . Blank lines are generally ignored.</source>
          <target state="translated">Каждый тип раздела может появляться произвольное количество раз и не обязательно должен появляться. Например, в карте типов обычно могут отсутствовать разделы &lt;code&gt;INPUT&lt;/code&gt; и &lt;code&gt;OUTPUT&lt;/code&gt; , если все, что ей нужно сделать, это связать дополнительные типы C с базовыми типами XS, такими как T_PTROBJ. Строки, начинающиеся с хеша &lt;code&gt;#&lt;/code&gt; , считаются комментариями и игнорируются в разделе &lt;code&gt;TYPEMAP&lt;/code&gt; , но считаются важными для &lt;code&gt;INPUT&lt;/code&gt; и &lt;code&gt;OUTPUT&lt;/code&gt; . Пустые строки обычно игнорируются.</target>
        </trans-unit>
        <trans-unit id="b8ab41b525aa7b7c38e4e3da5cf8193e961a308c" translate="yes" xml:space="preserve">
          <source>Each type of section can appear an arbitrary number of times and does not have to appear at all. For example, a typemap may commonly lack &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; sections if all it needs to do is associate additional C types with core XS types like T_PTROBJ. Lines that start with a hash &lt;code&gt;#&lt;/code&gt; are considered comments and ignored in the &lt;code&gt;TYPEMAP&lt;/code&gt; section, but are considered significant in &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt;. Blank lines are generally ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99826defe1aa3e0e7dfa632ce9b50c12211fd46" translate="yes" xml:space="preserve">
          <source>Each typedef has specific routines that manipulate the various data types.</source>
          <target state="translated">Каждый typedef имеет свои подпрограммы,которые манипулируют различными типами данных.</target>
        </trans-unit>
        <trans-unit id="a786e808038f24779f10721b5785e1d471731d02" translate="yes" xml:space="preserve">
          <source>Each value in the results list will be a hash reference containing the following fields:</source>
          <target state="translated">Каждое значение в списке результатов будет представлять собой хэш-ссылку,содержащую следующие поля:</target>
        </trans-unit>
        <trans-unit id="d6fa3b1f2df46de4d0da0473d7f7df5be8fdd538" translate="yes" xml:space="preserve">
          <source>Each version of Perl comes with the documentation that was current at the time of release. This poses a problem for content such as book lists. There are probably very nice books published after this list was included in your Perl release, and you can check the latest released version at &lt;a href=&quot;http://perldoc.perl.org/perlbook.html&quot;&gt;http://perldoc.perl.org/perlbook.html&lt;/a&gt; .</source>
          <target state="translated">Каждая версия Perl поставляется с документацией, действующей на момент выпуска. Это создает проблему для такого контента, как списки книг. Вероятно, после того, как этот список был включен в ваш выпуск Perl, были опубликованы очень хорошие книги, и вы можете проверить последнюю выпущенную версию на &lt;a href=&quot;http://perldoc.perl.org/perlbook.html&quot;&gt;http://perldoc.perl.org/perlbook.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a017204ca793ea63195213655418d18b5e46cf36" translate="yes" xml:space="preserve">
          <source>Earlier Mac OS X releases (10.2 &quot;Jaguar&quot; and older) did not include a completely thread-safe libc, so threading is not fully supported. Also, earlier releases included a buggy libdb, so some of the DB_File tests are known to fail on those releases.</source>
          <target state="translated">Ранние выпуски Mac OS X (10.2 &quot;Jaguar&quot; и более ранние)не включали полностью потоковую защиту libc,поэтому потоковая обработка не поддерживается полностью.Кроме того,в более ранних релизах была включена багги libdb,поэтому некоторые тесты DB_File,как известно,не работают в этих релизах.</target>
        </trans-unit>
        <trans-unit id="a252186ae05a758597f2268019d7fe33e7216333" translate="yes" xml:space="preserve">
          <source>Earlier releases caveats</source>
          <target state="translated">Предыдущие выпуски содержат предостережения</target>
        </trans-unit>
        <trans-unit id="8144bf937e246b0c3995f39e74e8340a0ff57aa1" translate="yes" xml:space="preserve">
          <source>Earlier than Perl 5.10, you have a bit of work to do. You want to avoid compiling a regular expression every time you want to match it. In this example, perl must recompile the regular expression for every iteration of the &lt;code&gt;foreach&lt;/code&gt; loop since it has no way to know what &lt;code&gt;$pattern&lt;/code&gt; will be:</source>
          <target state="translated">До версии Perl 5.10 у вас есть над чем поработать. Вам нужно избегать компиляции регулярного выражения каждый раз, когда вы хотите сопоставить его. В этом примере perl должен перекомпилировать регулярное выражение для каждой итерации цикла &lt;code&gt;foreach&lt;/code&gt; , так как у него нет способа узнать, каким будет &lt;code&gt;$pattern&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2412eca1a81df7ff0f1d8fd57bf151a2e60cb6ee" translate="yes" xml:space="preserve">
          <source>Earlier versions of Perl accepted almost all the 6.1 names. These were most extensively documented in the v5.14 version of this pod: &lt;a href=&quot;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&quot;&gt;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&lt;/a&gt;.</source>
          <target state="translated">Ранние версии Perl принимали почти все имена 6.1. Наиболее подробно они описаны в версии v5.14 этого модуля: &lt;a href=&quot;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&quot;&gt;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="041f750894a2130f024fa1d40c0e0cb8140d53b7" translate="yes" xml:space="preserve">
          <source>Earlier versions of Storable would immediately croak if they encountered a file with a higher internal version number than the reading Storable knew about. Internal version numbers are increased each time new data types (such as restricted hashes) are added to the vocabulary of the file format. This meant that a newer Storable module had no way of writing a file readable by an older Storable, even if the writer didn't store newer data types.</source>
          <target state="translated">Более ранние версии Storable мгновенно перестанут работать,если наткнутся на файл с более высоким внутренним номером версии,чем известно читателю Storable.Внутренний номер версии увеличивается каждый раз,когда в словарь формата файла добавляются новые типы данных (например,ограниченные хэши).Это означало,что более новый модуль Storable не имел возможности записать файл,читаемый более старым модулем Storable,даже если в нем не хранились более новые типы данных.</target>
        </trans-unit>
        <trans-unit id="e4b297dbcd2a6bb824d7c2a7ee2008800dedb8e3" translate="yes" xml:space="preserve">
          <source>Earlier, we mentioned that the &lt;code&gt;File&lt;/code&gt; class's &lt;code&gt;last_mod_time&lt;/code&gt; accessor could return a &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; object. This is a perfect example of composition. We could go even further, and make the &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; accessors return objects as well. The &lt;code&gt;File&lt;/code&gt; class would then be &lt;b&gt;composed&lt;/b&gt; of several other objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641edf650debd12f3350ba77247f6ae399c9cef3" translate="yes" xml:space="preserve">
          <source>Earlier, we mentioned that the &lt;code&gt;File&lt;/code&gt; class's &lt;code&gt;last_mod_time&lt;/code&gt; accessor could return a &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; object. This is a perfect example of composition. We could go even further, and make the &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; accessors return objects as well. The &lt;code&gt;File&lt;/code&gt; class would then be &lt;b&gt;composed&lt;/b&gt; of several other objects.</source>
          <target state="translated">Ранее мы упоминали, что метод &lt;code&gt;File&lt;/code&gt; &lt;code&gt;last_mod_time&lt;/code&gt; класса File может возвращать объект &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; . Это прекрасный образец композиции. Мы могли бы пойти еще дальше и сделать так, чтобы &lt;code&gt;path&lt;/code&gt; доступа к path и &lt;code&gt;content&lt;/code&gt; также возвращали объекты. Тогда класс &lt;code&gt;File&lt;/code&gt; будет &lt;b&gt;состоять&lt;/b&gt; из нескольких других объектов.</target>
        </trans-unit>
        <trans-unit id="0f33a9394c2fcd538084772b52d2341a61de3e00" translate="yes" xml:space="preserve">
          <source>Early Perl versions worked on some EBCDIC machines, but the last known version that ran on EBCDIC was v5.8.7, until v5.22, when the Perl core again works on z/OS. Theoretically, it could work on OS/400 or Siemens' BS2000 (or their successors), but this is untested. In v5.22 and 5.24, not all the modules found on CPAN but shipped with core Perl work on z/OS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e2d95ddabd105e29656829184c35d2859c555dc" translate="yes" xml:space="preserve">
          <source>Early Perl versions worked on some EBCDIC machines, but the last known version that ran on EBCDIC was v5.8.7, until v5.22, when the Perl core again works on z/OS. Theoretically, it could work on OS/400 or Siemens' BS2000 (or their successors), but this is untested. In v5.22, not all the modules found on CPAN but shipped with core Perl work on z/OS.</source>
          <target state="translated">Ранние версии Perl работали на некоторых машинах EBCDIC,но последней известной версией,которая работала на EBCDIC,была v5.8.7,до v5.22,когда Perl ядро снова работает на z/OS.Теоретически,оно могло работать на OS/400 или Siemens' BS2000 (или их преемниках),но это не протестировано.В v5.22 не все модули,найденные на CPAN,но поставляемые с ядром Perl,работают на z/OS.</target>
        </trans-unit>
        <trans-unit id="59b164194e7edb2e85034e9b78794d560a716b37" translate="yes" xml:space="preserve">
          <source>Ease testing test modules built with Test::Builder</source>
          <target state="translated">Простые в тестировании модули,построенные с помощью Test::Builder</target>
        </trans-unit>
        <trans-unit id="dae7ef5eb7ee790d1fea0c60a9c1de322881c27f" translate="yes" xml:space="preserve">
          <source>Easier to test new testing tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a188f6f02161d17a281a3ef192ea2346304b188" translate="yes" xml:space="preserve">
          <source>Easily interact with CPAN from the command line</source>
          <target state="translated">Легко взаимодействовать с CPAN из командной строки.</target>
        </trans-unit>
        <trans-unit id="45fc6c80b5f40c599a9996e4565f6c3c0441f578" translate="yes" xml:space="preserve">
          <source>Eclipse</source>
          <target state="translated">Eclipse</target>
        </trans-unit>
        <trans-unit id="995f14f2d2d8a63a7a9da7579e9e95a2acf52319" translate="yes" xml:space="preserve">
          <source>Ed Avis</source>
          <target state="translated">Эд Эвис</target>
        </trans-unit>
        <trans-unit id="9b2f1a6097a83d57a9f13c69653ee867428c4309" translate="yes" xml:space="preserve">
          <source>Ed Avis &amp;lt;eda@linux01.wcl.local&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00837140532ce93fe6f2a0b0f08779867c4ee055" translate="yes" xml:space="preserve">
          <source>Ed J &amp;lt;mohawk2@users.noreply.github.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="528c45b93e145146f93473cbaa4675f9b54b16c1" translate="yes" xml:space="preserve">
          <source>Edgar &quot;Trizor&quot; Bering &amp;lt;trizor@gmail.com&amp;gt;</source>
          <target state="translated">Эдгар &quot;Trizor&quot; Беринг &amp;lt;trizor@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1f7a7e23b64ce5747c4a63c4739d2a868d6ca53c" translate="yes" xml:space="preserve">
          <source>Edit the GNUmakefile, makefile.mk (or Makefile, if you're using nmake) and change the values of INST_DRV and INST_TOP. You can also enable various build flags. These are explained in the makefiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76b3763dae70623eb55885995406de6279fdb6e" translate="yes" xml:space="preserve">
          <source>Edit the Makefile.PL file so that the corresponding line looks like this:</source>
          <target state="translated">Отредактируйте файл Makefile.PL так,чтобы соответствующая строка выглядела так:</target>
        </trans-unit>
        <trans-unit id="f7940347fff54108cd46081728a5cf85408a717b" translate="yes" xml:space="preserve">
          <source>Edit the files generated. You don't have to if you have no time AND no intention to give it to someone else. But it is a good idea to edit the pod and to add more tests.</source>
          <target state="translated">Отредактируйте сгенерированные файлы.Ты не обязан,если у тебя нет времени и нет намерения отдавать его кому-то другому.Но это хорошая идея-отредактировать стручок и добавить больше тестов.</target>
        </trans-unit>
        <trans-unit id="954ea018e0a987091c4440d55ba64f48e0cccfe8" translate="yes" xml:space="preserve">
          <source>Edit the makefile.mk (or Makefile, if you're using nmake) and change the values of INST_DRV and INST_TOP. You can also enable various build flags. These are explained in the makefiles.</source>
          <target state="translated">Отредактируйте makefile.mk (или Makefile,если вы используете nmake)и измените значения INST_DRV и INST_TOP.Также можно включить различные флаги сборки.Это объясняется в makefile.</target>
        </trans-unit>
        <trans-unit id="b93bb818c85552f3fcd19e172c258ef9c6aad22d" translate="yes" xml:space="preserve">
          <source>Editor Support for Debugging</source>
          <target state="translated">Редакционная поддержка отладки</target>
        </trans-unit>
        <trans-unit id="68575b9eb0c3bb98d30a72178c5ff21f9fae81f0" translate="yes" xml:space="preserve">
          <source>Editor to use.</source>
          <target state="translated">Редактор на использование.</target>
        </trans-unit>
        <trans-unit id="77cd7c3d29d911531fb7afe572b99c8c5ba4e8b7" translate="yes" xml:space="preserve">
          <source>Editorial adjustments by Gurusamy Sarathy &amp;lt;gsar@ActiveState.com&amp;gt;</source>
          <target state="translated">Редакционные поправки сделаны Гурусами Сарати &amp;lt;gsar@ActiveState.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e5b26fe0f2ccbc86d51353217407910ecc40ac72" translate="yes" xml:space="preserve">
          <source>Edward Zborowski &amp;lt;ed@rubensteintech.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73be54c86084c8c273a09c1c9821e5a9131296dd" translate="yes" xml:space="preserve">
          <source>Effect:</source>
          <target state="translated">Effect:</target>
        </trans-unit>
        <trans-unit id="8117456b097c6d57fb7d1f1dab282a3702937b2f" translate="yes" xml:space="preserve">
          <source>Efficient removal of characters from the beginning of the string buffer. &lt;code&gt;SvPOK(sv)&lt;/code&gt;, or at least &lt;code&gt;SvPOKp(sv)&lt;/code&gt;, must be true and &lt;code&gt;ptr&lt;/code&gt; must be a pointer to somewhere inside the string buffer. &lt;code&gt;ptr&lt;/code&gt; becomes the first character of the adjusted string. Uses the &lt;code&gt;OOK&lt;/code&gt; hack. On return, only &lt;code&gt;SvPOK(sv)&lt;/code&gt; and &lt;code&gt;SvPOKp(sv)&lt;/code&gt; among the &lt;code&gt;OK&lt;/code&gt; flags will be true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7ac9002bbe557a0e89e8f9ac76410e740b68c3" translate="yes" xml:space="preserve">
          <source>Efficient removal of characters from the beginning of the string buffer. SvPOK(sv), or at least SvPOKp(sv), must be true and the &lt;code&gt;ptr&lt;/code&gt; must be a pointer to somewhere inside the string buffer. The &lt;code&gt;ptr&lt;/code&gt; becomes the first character of the adjusted string. Uses the &quot;OOK hack&quot;. On return, only SvPOK(sv) and SvPOKp(sv) among the OK flags will be true.</source>
          <target state="translated">Эффективное удаление символов из начала строкового буфера. SvPOK (sv) или, по крайней мере, SvPOKp (sv), должен быть истинным, а &lt;code&gt;ptr&lt;/code&gt; должен быть указателем на что-то внутри строкового буфера. Знак &lt;code&gt;ptr&lt;/code&gt; становится первым символом измененной строки. Использует &amp;laquo;OOK hack&amp;raquo;. По возвращении только SvPOK (sv) и SvPOKp (sv) среди флагов OK будут истинными.</target>
        </trans-unit>
        <trans-unit id="f18b25f084ce81b950168aedca18f94cb1425062" translate="yes" xml:space="preserve">
          <source>Efficiently compute time from local and GMT time</source>
          <target state="translated">Эффективное вычисление времени по местному и GMT времени</target>
        </trans-unit>
        <trans-unit id="654f6a3bdd1d9e4bdcf155781a2de9b4ed80c132" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;IO::String&lt;/code&gt; or &lt;code&gt;perlio&lt;/code&gt; support is needed to support writing stringified archives. Currently, &lt;code&gt;perlio&lt;/code&gt; is the preferred method, if available.</source>
          <target state="translated">Либо &lt;code&gt;IO::String&lt;/code&gt; или &lt;code&gt;perlio&lt;/code&gt; поддержка необходима для поддержки написания строковой архивы. В настоящее время предпочтительным методом является &lt;code&gt;perlio&lt;/code&gt; , если он доступен.</target>
        </trans-unit>
        <trans-unit id="85dba161f5ca6a960a7dc8fa1039724a8c09cad4" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (starting in Perl 5.10.0), or &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (old-style) where</source>
          <target state="translated">Либо &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (начиная с Perl 5.10.0), либо &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (старый стиль), где</target>
        </trans-unit>
        <trans-unit id="52f049aa56476852e6a153929348eb18e7bf1459" translate="yes" xml:space="preserve">
          <source>Either a named or anonymous pipe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb02a27773229541ab59b1944bd46b1d5a6ebed2" translate="yes" xml:space="preserve">
          <source>Either a regular &lt;b&gt;assignment&lt;/b&gt; or a compound &lt;b&gt;operator&lt;/b&gt; composed of an ordinary assignment and some other operator, that changes the value of a variable in place; that is, relative to its old value. For example, &lt;code&gt;$a += 2&lt;/code&gt; adds &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;$a&lt;/code&gt; .</source>
          <target state="translated">Либо обычное &lt;b&gt;присваивание,&lt;/b&gt; либо составной &lt;b&gt;оператор,&lt;/b&gt; состоящий из обычного присваивания и некоторого другого оператора, который изменяет значение переменной на месте; то есть относительно его старого значения. Например, &lt;code&gt;$a += 2&lt;/code&gt; добавляет &lt;code&gt;2&lt;/code&gt; к &lt;code&gt;$a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dd3a0e7d7fd04d60cdb8e08fb04cc78c683756e" translate="yes" xml:space="preserve">
          <source>Either a regular &lt;b&gt;assignment&lt;/b&gt; or a compound &lt;b&gt;operator&lt;/b&gt; composed of an ordinary assignment and some other operator, that changes the value of a variable in place; that is, relative to its old value. For example, &lt;code&gt;$a += 2&lt;/code&gt; adds &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;$a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281cd0fa078fd4c1ba948d728426cec878f64c16" translate="yes" xml:space="preserve">
          <source>Either assimilate new technologies, or build bridges to them.</source>
          <target state="translated">Либо ассимилировать новые технологии,либо навести к ним мосты.</target>
        </trans-unit>
        <trans-unit id="616b8deb9c86ed3074fc60088a26151e3856d891" translate="yes" xml:space="preserve">
          <source>Either form above will work. This will return a list of attributes defined on the object. This list is returned in the attribute definition order, parent class attributes are listed before subclass attributes. Duplicate attributes will be removed before the list is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2577d609c330867bbdb6a4c63c0df0f3f5ae7cc8" translate="yes" xml:space="preserve">
          <source>Either have an argumentless =over, or have its argument a strictly positive number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b1d548fa9375ac8cee4b6bb3288cae52feda67" translate="yes" xml:space="preserve">
          <source>Either not implemented or a no-op. (Android)</source>
          <target state="translated">Либо не выполнено,либо нет.(Андроид)</target>
        </trans-unit>
        <trans-unit id="9fd8e33d6202aef3ccb0a1588e2309a6eeaf7193" translate="yes" xml:space="preserve">
          <source>Either of &lt;code&gt;LocalService&lt;/code&gt; or &lt;code&gt;PeerService&lt;/code&gt; (or their &lt;code&gt;...Port&lt;/code&gt; synonyms) can be either a service name, a decimal number, or a string containing both a service name and number, in a form such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6aadb20634080f518a8887a688da9b1fee48d93" translate="yes" xml:space="preserve">
          <source>Either of the above forms of &quot;layer&quot; specifications can be made the default for a lexical scope with the &lt;code&gt;use open ...&lt;/code&gt; pragma. See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47f17b2cb7b7674bb2cbd89473a3cd6f362bf48" translate="yes" xml:space="preserve">
          <source>Either of the following will work instead:</source>
          <target state="translated">Вместо этого сработает любое из нижеперечисленных:</target>
        </trans-unit>
        <trans-unit id="e5a6a14049fff21a602c284699a2c9fbe3ca6693" translate="yes" xml:space="preserve">
          <source>Either single-quote your strings, or (preferably) use forward slashes. Since all DOS and Windows versions since something like MS-DOS 2.0 or so have treated &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt; the same in a path, you might as well use the one that doesn't clash with Perl--or the POSIX shell, ANSI C and C++, awk, Tcl, Java, or Python, just to mention a few. POSIX paths are more portable, too.</source>
          <target state="translated">Либо заключите строки в одинарные кавычки, либо (желательно) используйте косую черту. Поскольку все версии DOS и Windows, начиная с чего-то вроде MS-DOS 2.0 или около того, обрабатывали &lt;code&gt;/&lt;/code&gt; и &lt;code&gt;\&lt;/code&gt; одинаково в пути, вы также можете использовать тот, который не конфликтует с Perl, или оболочку POSIX, ANSI C и C ++, awk, Tcl, Java или Python, и это лишь некоторые из них. Пути POSIX также более переносимы.</target>
        </trans-unit>
        <trans-unit id="a48425d47cea1024da1aa0b5eb56b9a2e8f4b87c" translate="yes" xml:space="preserve">
          <source>Either stringify the structure yourself (no fun), or else get the MLDBM (which uses Data::Dumper) module from CPAN and layer it on top of either DB_File or GDBM_File. You might also try DBM::Deep, but it can be a bit slow.</source>
          <target state="translated">Либо сами строчите структуру (неинтересно),либо получите модуль MLDBM (который использует модуль Data::Dumper)из CPAN и наложите его поверх DB_File или GDBM_File.Вы также можете попробовать DBM::Deep,но это может быть немного медленно.</target>
        </trans-unit>
        <trans-unit id="f91179ba5041e3cd11279b2a09e8c8dafe42d600" translate="yes" xml:space="preserve">
          <source>Either the 5.006001 or the 5.6.1 format is acceptable.</source>
          <target state="translated">Допускается либо формат 5.006001,либо 5.6.1.</target>
        </trans-unit>
        <trans-unit id="f3046bc2658fc9703b653ff4f645f1c7f4b09d3a" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag will warn you when you use an array slice with a single index.</source>
          <target state="translated">Либо &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; Прагмы или &lt;b&gt;-w&lt;/b&gt; флаг предупредит вас , когда вы используете срез массива с одним индексом.</target>
        </trans-unit>
        <trans-unit id="175fe2f08cb303f8f8870d3f7cd0357b5f36d7a6" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;use warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag will warn you when you use an array slice with a single index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906b6fd14fb2f43afa53be4e9384438767144648" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;warnings::warn&lt;/code&gt; or &lt;code&gt;warnings::warnif&lt;/code&gt; function should be used to actually display the warnings message. This is because they can make use of the feature that allows warnings to be escalated into fatal errors. So in this case</source>
          <target state="translated">Либо &lt;code&gt;warnings::warn&lt;/code&gt; или &lt;code&gt;warnings::warnif&lt;/code&gt; функция должна использоваться , чтобы фактически отобразить сообщение предупреждения. Это потому, что они могут использовать функцию, которая позволяет преобразовывать предупреждения в фатальные ошибки. Так что в этом случае</target>
        </trans-unit>
        <trans-unit id="0780376e7962816fa4ff7b6a652f65ef6eadb7db" translate="yes" xml:space="preserve">
          <source>Either use parentheses or the high-precedence variant of the operator.</source>
          <target state="translated">Используйте скобки или вариант оператора с высоким коэффициентом усиления.</target>
        </trans-unit>
        <trans-unit id="ac2efacdb85d4049866934d48a775a119bbac29d" translate="yes" xml:space="preserve">
          <source>Either way, the implementation isn't going to generate results larger than the size of the integer type Perl was built with (32 bits or 64 bits).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6479b4a431808cf309ed8137f781bb957df27d9" translate="yes" xml:space="preserve">
          <source>Either you don't have more than one line in the string you're looking at (probably), or else you aren't using the correct modifier(s) on your pattern (possibly).</source>
          <target state="translated">Либо у вас не более одной строки в строке,на которую вы смотрите (возможно),либо вы не используете правильный модификатор(ы)на вашем шаблоне (возможно).</target>
        </trans-unit>
        <trans-unit id="e153f909edaedd24892df1d401944b8821af0128" translate="yes" xml:space="preserve">
          <source>Elapsed Real Time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45775ed8dae80c63b3497b4ea826a44ca2dea3f" translate="yes" xml:space="preserve">
          <source>Elapsed returns a &lt;a href=&quot;../../benchmark&quot;&gt;Benchmark&lt;/a&gt; object that represents the running time of the aggregated tests. In order for &lt;code&gt;elapsed&lt;/code&gt; to be valid you must call &lt;code&gt;start&lt;/code&gt; before running the tests and &lt;code&gt;stop&lt;/code&gt; immediately afterwards.</source>
          <target state="translated">Elapsed возвращает объект &lt;a href=&quot;../../benchmark&quot;&gt;Benchmark,&lt;/a&gt; который представляет время выполнения агрегированных тестов. Чтобы &lt;code&gt;elapsed&lt;/code&gt; был действительным, вы должны вызвать &lt;code&gt;start&lt;/code&gt; перед запуском тестов и &lt;code&gt;stop&lt;/code&gt; сразу после этого.</target>
        </trans-unit>
        <trans-unit id="2fb6b6b80655efc89d39c9e3dbc4f534ad641e2d" translate="yes" xml:space="preserve">
          <source>Elapsed returns a &lt;a href=&quot;benchmark&quot;&gt;Benchmark&lt;/a&gt; object that represents the running time of the aggregated tests. In order for &lt;code&gt;elapsed&lt;/code&gt; to be valid you must call &lt;code&gt;start&lt;/code&gt; before running the tests and &lt;code&gt;stop&lt;/code&gt; immediately afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685684a16f4001786549b1ab800e18b9d9c7dce4" translate="yes" xml:space="preserve">
          <source>Electronic mail address of the perl5 administrator.</source>
          <target state="translated">Электронный почтовый адрес администратора perl5.</target>
        </trans-unit>
        <trans-unit id="0206d29187ee24de18ffe8c7060208c783959fc1" translate="yes" xml:space="preserve">
          <source>Electronic mail address of the person who ran Configure. This can be used by units that require the user's e-mail, like</source>
          <target state="translated">Электронный почтовый адрес человека,который запустил &quot;Настройку&quot;.Это может быть использовано устройствами,которым требуется электронная почта пользователя,такими как</target>
        </trans-unit>
        <trans-unit id="fb92ce1ec6eee388978bf1476ef4da0f49ddc2f4" translate="yes" xml:space="preserve">
          <source>Element Types and Accessor Methods</source>
          <target state="translated">Типы элементов и методы аксессуаров</target>
        </trans-unit>
        <trans-unit id="56be9d95047d3837a8e260ecf6fab5aa5091179f" translate="yes" xml:space="preserve">
          <source>Eliminate the macros in the output to the MMS/MMK file.</source>
          <target state="translated">Устраните макросы в выходных данных MMS/MMK-файла.</target>
        </trans-unit>
        <trans-unit id="0043730cfa58902fc1eb2bab5c9cf7b854c601fd" translate="yes" xml:space="preserve">
          <source>Eliminates any information in the type-ahead buffer on a read from the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372fe5af53dfb10b96df623d9727deb1110a3dd2" translate="yes" xml:space="preserve">
          <source>Email any corrections or questions to me.</source>
          <target state="translated">Напишите мне любые исправления или вопросы.</target>
        </trans-unit>
        <trans-unit id="2f6c017bc97bb2714dd0b54f8c31090aba3e0c32" translate="yes" xml:space="preserve">
          <source>Email::Sender::Transport::SMTP</source>
          <target state="translated">Email::Sender::Transport::SMTP</target>
        </trans-unit>
        <trans-unit id="f4fe0960af2e7da0a8e6abd0220f7fb9ccfc0f82" translate="yes" xml:space="preserve">
          <source>Email::Sender::Transport::Sendmail</source>
          <target state="translated">Email::Sender::Transport::Sendmail</target>
        </trans-unit>
        <trans-unit id="a5bcdc422fa0c0f86b08b10ed2c448b54076951e" translate="yes" xml:space="preserve">
          <source>Embedded Code Execution Frequency</source>
          <target state="translated">Встроенная частота выполнения кода</target>
        </trans-unit>
        <trans-unit id="1c0d431f261d9feabca2f4bf0f5d2be5226959da" translate="yes" xml:space="preserve">
          <source>Embedded Ctrl-As (octal 001) in the input will be mapped to spaces on output, due to an internal implementation detail.</source>
          <target state="translated">Встроенные Ctrl-As (восьмеричный 001)на входе будут отображены на пробелы на выходе,благодаря внутренней детализации реализации.</target>
        </trans-unit>
        <trans-unit id="b65de96935df088746b85b44766bded2aa4a92cf" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can also turn off any modifiers already present by using,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="036d707633278129886b9180244ca67da739555e" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can also turn off any modifiers already present by using, e.g., &lt;code&gt;(?-i)&lt;/code&gt;. Modifiers can also be combined into a single expression, e.g., &lt;code&gt;(?s-i)&lt;/code&gt; turns on single line mode and turns off case insensitivity.</source>
          <target state="translated">Встроенные модификаторы также могут отключить любые уже существующие модификаторы, используя, например, &lt;code&gt;(?-i)&lt;/code&gt; . Модификаторы также могут быть объединены в одно выражение, например, &lt;code&gt;(?s-i)&lt;/code&gt; включает однострочный режим и отключает нечувствительность к регистру.</target>
        </trans-unit>
        <trans-unit id="609e053d4c0081ee95d3a87942874703d9f5ab55" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can have two important advantages over the usual modifiers. Embedded modifiers allow a custom set of modifiers for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8b1388248a7771ad7a19db052c3e57cdc37002" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can have two important advantages over the usual modifiers. Embedded modifiers allow a custom set of modifiers to</source>
          <target state="translated">Встроенные модификаторы могут иметь два важных преимущества по сравнению с обычными модификаторами.Встраиваемые модификаторы позволяют</target>
        </trans-unit>
        <trans-unit id="77fff13bcd07ad216d2d3e4a9dc81f2e17688911" translate="yes" xml:space="preserve">
          <source>Embedded modifiers may also be added to a non-capturing grouping. &lt;code&gt;(?i-m:regexp)&lt;/code&gt; is a non-capturing grouping that matches &lt;code&gt;regexp&lt;/code&gt; case insensitively and turns off multi-line mode.</source>
          <target state="translated">Встроенные модификаторы также могут быть добавлены к группировке без захвата. &lt;code&gt;(?i-m:regexp)&lt;/code&gt; - это группа без захвата, которая нечувствительна к регистру &lt;code&gt;regexp&lt;/code&gt; и отключает многострочный режим.</target>
        </trans-unit>
        <trans-unit id="b92d8665944f4979bd50de8585ed3b0fd45dfa5f" translate="yes" xml:space="preserve">
          <source>Embedding Functions</source>
          <target state="translated">Встраиваемые функции</target>
        </trans-unit>
        <trans-unit id="dfab320700daa38157038d3e70e9093fcfa26c1f" translate="yes" xml:space="preserve">
          <source>Embedding Perl inside a 64-bit application.</source>
          <target state="translated">Встраивание Perl внутри 64-битного приложения.</target>
        </trans-unit>
        <trans-unit id="0694b8bb0407da0c117f25cc81dd5d48908ff82d" translate="yes" xml:space="preserve">
          <source>Embedding Perl under Win32</source>
          <target state="translated">Размещение Perl под Win32</target>
        </trans-unit>
        <trans-unit id="9cbcae97b606ebda37a4c9c0051aab393c7f7d13" translate="yes" xml:space="preserve">
          <source>Embedding Pods in Perl Modules</source>
          <target state="translated">Встраиваемые стручки в модули Perl</target>
        </trans-unit>
        <trans-unit id="3332088412158a65b80fc73f2172f27d8031dce4" translate="yes" xml:space="preserve">
          <source>Embedding comments and modifiers in a regular expression</source>
          <target state="translated">Вставка комментариев и модификаторов в регулярное выражение</target>
        </trans-unit>
        <trans-unit id="2f84d71eabfb2db471c3906b955c997d8f2ea42c" translate="yes" xml:space="preserve">
          <source>Emboldened by this, you dive into the second phrase that your software needs to output: &quot;Your query matched 10 files in 4 directories.&quot;. You notice that if you want to treat phrases as indivisible, as the gettext manual wisely advises, you need four cases now, instead of two, to cover the permutations of singular and plural on the two items, $dir_count and $file_count. So you try this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7beea65f566b123cc3fc19969be422b43965af" translate="yes" xml:space="preserve">
          <source>Emit the popular wake-on-lan magic udp packet to wake up a local device. See also &lt;a href=&quot;Net::Wake&quot;&gt;Net::Wake&lt;/a&gt;, but this has the mac address as 1st arg. &lt;code&gt;$host&lt;/code&gt; should be the local gateway. Without it will broadcast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1ebe53d6ccd7815c61ce7589f6b78c18dd612d" translate="yes" xml:space="preserve">
          <source>Emits a warning, usually by printing it to &lt;code&gt;STDERR&lt;/code&gt;. &lt;code&gt;warn&lt;/code&gt; interprets its operand LIST in the same way as &lt;code&gt;die&lt;/code&gt;, but is slightly different in what it defaults to when LIST is empty or makes an empty string. If it is empty and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; already contains an exception value then that value is used after appending &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt;. If it is empty and &lt;code&gt;$@&lt;/code&gt; is also empty then the string &lt;code&gt;&quot;Warning: Something's wrong&quot;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d5d024243158295b0b17ef00bb9b23203d9360" translate="yes" xml:space="preserve">
          <source>EmojiSources.txt</source>
          <target state="translated">EmojiSources.txt</target>
        </trans-unit>
        <trans-unit id="182fa8e51f2878e5ebff39e46c9563939a1274d1" translate="yes" xml:space="preserve">
          <source>Empty (?) without any modifiers in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ea7a43c3020a563e25bd1eedc14c28db07661d" translate="yes" xml:space="preserve">
          <source>Empty \%c in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482c748a5823d75ff12d9a6680ae909964eacc76" translate="yes" xml:space="preserve">
          <source>Empty \%c{}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45054945a8770b05f8103d2a4a0bb1b804cbf85" translate="yes" xml:space="preserve">
          <source>Empty \%c{} in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abbe29d0eda029ba0d774099d16a176aaf760777" translate="yes" xml:space="preserve">
          <source>Empty parts of the file/buffer will have NULL (0x00) bytes written to them.</source>
          <target state="translated">Пустые части файла/буфера будут иметь запись NULL (0x00)байт.</target>
        </trans-unit>
        <trans-unit id="bd4ef1b6c1ef24f987c292a748ebade1052ce4dc" translate="yes" xml:space="preserve">
          <source>Empty strings as well as other illegal numbers results in 'NaN'.</source>
          <target state="translated">Пустые строки,а также другие незаконные номера приводят к 'NaN'.</target>
        </trans-unit>
        <trans-unit id="b78fcf2b7184ff747f91ac2d4e85304d73a66a8f" translate="yes" xml:space="preserve">
          <source>Emptying a file of existing contents, either automatically when opening a file for writing or explicitly via the &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Очистка файла от существующего содержимого либо автоматически при открытии файла для записи, либо явно с помощью функции &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f60475c9fb8f070699dc0b6997447641f41933fa" translate="yes" xml:space="preserve">
          <source>Emptying a file of existing contents, either automatically when opening a file for writing or explicitly via the &lt;code&gt;truncate&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3810839f51735c2952e4638769a72e1f188779e" translate="yes" xml:space="preserve">
          <source>Emulate low-level math with BigInt code</source>
          <target state="translated">Эмулируйте низкоуровневую математику с помощью кода BigInt.</target>
        </trans-unit>
        <trans-unit id="eaff5ce9fb66a8294a29b4afda7fa93b8fb7b74b" translate="yes" xml:space="preserve">
          <source>Emulated using multiple interpreters. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;. (Win32)</source>
          <target state="translated">Эмулируется с использованием нескольких интерпретаторов. См. &lt;a href=&quot;perlfork&quot;&gt;Perlfork&lt;/a&gt; . (Win32)</target>
        </trans-unit>
        <trans-unit id="a7b07a2e86e21bbe02318bb5339e9e3819d02d9c" translate="yes" xml:space="preserve">
          <source>Emulated using synchronization functions such that it can be interrupted by &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;, and limited to a maximum of 4294967 seconds, approximately 49 days. (Win32)</source>
          <target state="translated">Эмулируется с использованием функций синхронизации, так что она может быть прервана &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; и ограничена максимумом 4294967 секунд, примерно 49 дней. (Win32)</target>
        </trans-unit>
        <trans-unit id="2fab2548b326a0aed3bd44319bab854e6c0cf455" translate="yes" xml:space="preserve">
          <source>Emulated using timers that must be explicitly polled whenever Perl wants to dispatch &quot;safe signals&quot; and therefore cannot interrupt blocking system calls. (Win32)</source>
          <target state="translated">Эмулируется с помощью таймеров,которые должны быть явно опрошены всякий раз,когда Perl хочет посылать &quot;безопасные сигналы&quot; и,следовательно,не может прервать блокировку системных вызовов.(Win32)</target>
        </trans-unit>
        <trans-unit id="9b1e45abf8f6f88976507fbf984db8d99aa517be" translate="yes" xml:space="preserve">
          <source>Emulates Unix &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; (which considers &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; to indicate an error) by mapping the &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;SS$_ABORT&lt;/code&gt; (&lt;code&gt;44&lt;/code&gt; ). This behavior may be overridden with the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'exit'&lt;/code&gt; . As with the CRTL's &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; function, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; is also mapped to an exit status of &lt;code&gt;SS$_NORMAL&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt; ); this mapping cannot be overridden. Any other argument to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; is used directly as Perl's exit status. On VMS, unless the future POSIX_EXIT mode is enabled, the exit code should always be a valid VMS exit code and not a generic number. When the POSIX_EXIT mode is enabled, a generic number will be encoded in a method compatible with the C library _POSIX_EXIT macro so that it can be decoded by other programs, particularly ones written in C, like the GNV package. (VMS)</source>
          <target state="translated">Эмулирует функцию &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; Unix ( которая рассматривает &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; как указание на ошибку) путем сопоставления &lt;code&gt;1&lt;/code&gt; с &lt;code&gt;SS$_ABORT&lt;/code&gt; ( &lt;code&gt;44&lt;/code&gt; ). Это поведение можно переопределить с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'exit'&lt;/code&gt; . Как и в случае с функцией &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; CRTL , &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; также отображается в статус выхода &lt;code&gt;SS$_NORMAL&lt;/code&gt; ( &lt;code&gt;1&lt;/code&gt; ); это сопоставление нельзя переопределить. Любой другой аргумент для &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; используется непосредственно как статус выхода Perl. В VMS, если будущий режим POSIX_EXIT не включен, код выхода всегда должен быть действительным кодом выхода VMS, а не общим номером. Когда включен режим POSIX_EXIT, общий номер будет закодирован методом, совместимым с макросом _POSIX_EXIT библиотеки C, чтобы его можно было декодировать другими программами, особенно написанными на C, такими как пакет GNV. (VMS)</target>
        </trans-unit>
        <trans-unit id="2c857b36dcd15d79dca987f0a21532d5543740f0" translate="yes" xml:space="preserve">
          <source>Emulation is provided for &lt;code&gt;runtests&lt;/code&gt; and &lt;code&gt;execute_tests&lt;/code&gt; but the pluggable 'Straps' interface that previous versions of &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; supported is not reproduced here. Straps is now available as a stand alone module: &lt;a href=&quot;Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8694061aed01e45167cf3a5722aa921d3e6ee71" translate="yes" xml:space="preserve">
          <source>Emulation is provided for &lt;code&gt;runtests&lt;/code&gt; and &lt;code&gt;execute_tests&lt;/code&gt; but the pluggable 'Straps' interface that previous versions of &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; supported is not reproduced here. Straps is now available as a stand alone module: &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;.</source>
          <target state="translated">Эмуляция предоставляется для &lt;code&gt;runtests&lt;/code&gt; и &lt;code&gt;execute_tests&lt;/code&gt; , но подключаемый интерфейс 'Straps', поддерживаемый предыдущими версиями &lt;a href=&quot;harness&quot;&gt;Test :: Harness,&lt;/a&gt; здесь не воспроизводится. Straps теперь доступен как отдельный модуль: &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test :: Harness :: Straps&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c3201c23058080f5cca7ba534770368c083d322" translate="yes" xml:space="preserve">
          <source>Enable DUMP and all execute options. Equivalent to:</source>
          <target state="translated">Включите DUMP и все опции выполнения.Эквивалент к:</target>
        </trans-unit>
        <trans-unit id="3519927c57abd6568424c455930c1e3320ae7f4f" translate="yes" xml:space="preserve">
          <source>Enable DUMP and all non-extra execute options. Equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3687b13f8be99eb4a1bd7121c185ac6fb0233a5d" translate="yes" xml:space="preserve">
          <source>Enable Verbose mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb7295d3b950c4331c9fe377d6496cd34ea08ee" translate="yes" xml:space="preserve">
          <source>Enable all options at once except OFFSETS, OFFSETSDBG and BUFFERS. (To get every single option without exception, use both ALL and EXTRA.)</source>
          <target state="translated">Включите все опции сразу,кроме OFFSETS,OFFSETSDBG и BUFFERS.(Чтобы получить все без исключения опции,используйте как ALL,так и EXTRA).</target>
        </trans-unit>
        <trans-unit id="605ee0c2cc03659c524ca183e1ce55b5400e895c" translate="yes" xml:space="preserve">
          <source>Enable all options at once except OFFSETS, OFFSETSDBG, BUFFERS, WILDCARD, and DUMP_PRE_OPTIMIZE. (To get every single option without exception, use both ALL and EXTRA, or starting in 5.30 on a &lt;code&gt;-DDEBUGGING&lt;/code&gt;-enabled perl interpreter, use the &lt;b&gt;-Drv&lt;/b&gt; command-line switches.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c54f50dbe8b1d2b9d4279a847b1af1e242ac5db" translate="yes" xml:space="preserve">
          <source>Enable caching of timings for the null loop. The time taken for COUNT rounds of the null loop will be calculated only once for each different COUNT used.</source>
          <target state="translated">Включить кэширование таймингов для нулевого цикла.Время,необходимое для циклов COUNT,будет вычисляться только один раз для каждой отдельной используемой COUNT.</target>
        </trans-unit>
        <trans-unit id="af34a92294247e0324cf9cb4ab7591c0157d3cc4" translate="yes" xml:space="preserve">
          <source>Enable debugging of offsets information. This emits copious amounts of trace information and doesn't mesh well with other debug options.</source>
          <target state="translated">Включите отладку информации о смещениях.Это испускает большое количество информации о трассировке и плохо сочетается с другими опциями отладки.</target>
        </trans-unit>
        <trans-unit id="b22eafe66ff9363c232181834545b3e27fc24dda" translate="yes" xml:space="preserve">
          <source>Enable debugging of start-point optimisations.</source>
          <target state="translated">Включить отладку оптимизаций в начальной точке.</target>
        </trans-unit>
        <trans-unit id="b1ed4094a3f33fb70b77d3ab5d3985c70cad2408" translate="yes" xml:space="preserve">
          <source>Enable debugging of states in the engine.</source>
          <target state="translated">Включите отладку состояний в двигателе.</target>
        </trans-unit>
        <trans-unit id="6cc2f783a9f51a88860f66f38bb6654412ccd3b7" translate="yes" xml:space="preserve">
          <source>Enable debugging of the \G modifier.</source>
          <target state="translated">Включить отладку модификатора \G.</target>
        </trans-unit>
        <trans-unit id="8b1fc985774fbcf866da54c3c69b513cb35f440c" translate="yes" xml:space="preserve">
          <source>Enable debugging of the recursion stack in the engine. Enabling or disabling this option automatically does the same for debugging states as well. This output from this can be quite large.</source>
          <target state="translated">Включите отладку рекурсивного стека в двигателе.Включение или выключение этой опции автоматически делает то же самое и для отладочных состояний.Этот вывод может быть довольно большим.</target>
        </trans-unit>
        <trans-unit id="ed7bfb6f5b63e62332ddfc6bbbaf1f7a2a0d576b" translate="yes" xml:space="preserve">
          <source>Enable debugging output.</source>
          <target state="translated">Включите вывод отладки.</target>
        </trans-unit>
        <trans-unit id="139048524bc56f6e0f7692e0183c038f5bfd94d8" translate="yes" xml:space="preserve">
          <source>Enable debugging the capture group storage during match. Warning, this can potentially produce extremely large output.</source>
          <target state="translated">Включите отладку хранилища групп захвата во время матча.Предупреждение,это потенциально может привести к чрезвычайно большому объему вывода.</target>
        </trans-unit>
        <trans-unit id="d009cb1e8dd02879690564369c53161c26ba761e" translate="yes" xml:space="preserve">
          <source>Enable enhanced TRIE debugging. Enhances both TRIEE and TRIEC.</source>
          <target state="translated">Включите расширенную отладку TRIE.Улучшает как ТРИЕЕ,так и ТРИЕК.</target>
        </trans-unit>
        <trans-unit id="ef5eb4e7b2447bf19044b39ea2e195cd6618fd76" translate="yes" xml:space="preserve">
          <source>Enable enhanced optimisation debugging and start-point optimisations. Probably not useful except when debugging the regexp engine itself.</source>
          <target state="translated">Включает усовершенствованную отладку оптимизации и оптимизацию в начальной точке.Вероятно,не будет полезным,кроме как при отладке самого регенератора.</target>
        </trans-unit>
        <trans-unit id="07e248f2e2b8869e02ee4bbd9a3b445fa1e02104" translate="yes" xml:space="preserve">
          <source>Enable new features</source>
          <target state="translated">Включение новых функций</target>
        </trans-unit>
        <trans-unit id="82441ac52d9ab4a30896d0bdffedf2a9be220d10" translate="yes" xml:space="preserve">
          <source>Enable recognition of &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT_LIST&lt;/code&gt; and &lt;code&gt;INOUT_LIST&lt;/code&gt; declarations. Default is true.</source>
          <target state="translated">Включите распознавание объявлений &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT_LIST&lt;/code&gt; и &lt;code&gt;INOUT_LIST&lt;/code&gt; . По умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="fdedc1b60d005db3c310868a2b39cafdd59a5eb1" translate="yes" xml:space="preserve">
          <source>Enable recognition of &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT_LIST&lt;/code&gt; and &lt;code&gt;INOUT_LIST&lt;/code&gt; declarations. Default is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04f3ebaeb9867e3812b1e018ab387d5924f7ef6" translate="yes" xml:space="preserve">
          <source>Enable recognition of ANSI-like descriptions of function signature. Default is true.</source>
          <target state="translated">Включение распознавания ANSI-подобных описаний сигнатуры функции.По умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="8fa85b7034e330ca755a5c73c63b76397e087c71" translate="yes" xml:space="preserve">
          <source>Enable simple signal handling</source>
          <target state="translated">Простая обработка сигналов</target>
        </trans-unit>
        <trans-unit id="3c3a9e686f47a71d2d2bd49c91054de061662284" translate="yes" xml:space="preserve">
          <source>Enable the breakpoint so it will stop the execution of the program.</source>
          <target state="translated">Включите точку останова,чтобы она остановила выполнение программы.</target>
        </trans-unit>
        <trans-unit id="4a2a1634a6a3ef06d28edb649a7e0d6a7bf8554f" translate="yes" xml:space="preserve">
          <source>Enable the dumping of the compiled pattern before the optimization phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd4f88c7522d41d4cd111539c1b1db699d331e1" translate="yes" xml:space="preserve">
          <source>Enable the options enabled by &quot;All&quot;, plus STATE, TRIEC, and TRIEM.</source>
          <target state="translated">Включите опции,включенные в &quot;Все&quot;,плюс STATE,TRIEC и TRIEM.</target>
        </trans-unit>
        <trans-unit id="6607ef3ad5faa3d582896ad07ab9785dae90ca8e" translate="yes" xml:space="preserve">
          <source>Enable this option if you wish all spawned processes to be killed if the initially spawned process (the parent) is killed or dies without waiting for child processes.</source>
          <target state="translated">Включите эту опцию,если хотите,чтобы все порожденные процессы были убиты,если изначально порожденный процесс (родительский)был убит или умирает,не дожидаясь дочерних процессов.</target>
        </trans-unit>
        <trans-unit id="b7b7c90b9b4e4815dd4d9b7ad285d70eda8ebb7d" translate="yes" xml:space="preserve">
          <source>Enable/disable UTF-8 (or UTF-EBCDIC) in source code</source>
          <target state="translated">Включение/выключение UTF-8 (или UTF-EBCDIC)в исходном коде</target>
        </trans-unit>
        <trans-unit id="80acee2f67ff4da70c6002b5a0e094b4d2f31c43" translate="yes" xml:space="preserve">
          <source>Enables all warnings regardless of &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; or &lt;code&gt;$^W&lt;/code&gt; . See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">Включает все предупреждения , независимо от &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; или &lt;code&gt;$^W&lt;/code&gt; . См. &lt;a href=&quot;warnings&quot;&gt;Предупреждения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b9030574fd9ae227a9d9bdb446332c94bd2ab62" translate="yes" xml:space="preserve">
          <source>Enables all warnings regardless of &lt;code&gt;no warnings&lt;/code&gt; or &lt;code&gt;$^W&lt;/code&gt;. See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1089d1ea88536805f57559da91fba3d7a2761ecb" translate="yes" xml:space="preserve">
          <source>Enables certain optimizations. The only optimization that is currently affected is the use of</source>
          <target state="translated">Обеспечивает определенные оптимизации.Единственная оптимизация,на которую в настоящее время оказывается влияние-это использование</target>
        </trans-unit>
        <trans-unit id="c2846984fdcc8df09665bcc109bb5474af315f7d" translate="yes" xml:space="preserve">
          <source>Enables or disable debugging by setting the &lt;code&gt;$Benchmark::Debug&lt;/code&gt; flag:</source>
          <target state="translated">Включает или отключает отладку, устанавливая флаг &lt;code&gt;$Benchmark::Debug&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9d480a633ce9bb7aa941c3d98a4cbb4d5ac2bf6a" translate="yes" xml:space="preserve">
          <source>Enables output related to the optimisation phase of compilation.</source>
          <target state="translated">Позволяет выводить данные,связанные с фазой оптимизации компиляции.</target>
        </trans-unit>
        <trans-unit id="8017ccdfaea2ad3f4aa3c94d96674940233700a6" translate="yes" xml:space="preserve">
          <source>Enables use of the prompt specified by pmt=usr-prmpt on input from the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55c00ee236233e66b2d47bad2c1ced81c03c99b" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;bundling_values&lt;/code&gt; will disable the other two styles of bundling.</source>
          <target state="translated">Включение &lt;code&gt;bundling_values&lt;/code&gt; отключит два других стиля объединения.</target>
        </trans-unit>
        <trans-unit id="b18f32d5490f57e3f4e0f875c588a069b00f5590" translate="yes" xml:space="preserve">
          <source>Enabling the &lt;code&gt;utf8&lt;/code&gt; pragma has the following effect:</source>
          <target state="translated">Включение &lt;code&gt;utf8&lt;/code&gt; дает следующий эффект:</target>
        </trans-unit>
        <trans-unit id="7fe2071dd005ed63dfae111e383f15806253aa16" translate="yes" xml:space="preserve">
          <source>Enabling this option will allow single-character options to be bundled. To distinguish bundles from long option names, long options</source>
          <target state="translated">Включение этой опции позволит объединять опции с одним символом.Чтобы отличить наборы от длинных имен опций,длинные опции</target>
        </trans-unit>
        <trans-unit id="867d7c3018e88764391a8a8cad25d71d6020f155" translate="yes" xml:space="preserve">
          <source>Encapsulation</source>
          <target state="translated">Encapsulation</target>
        </trans-unit>
        <trans-unit id="2059232562a427f990749c23a8c8ebdde1b9014d" translate="yes" xml:space="preserve">
          <source>Encapsulation is important for several reasons. First, it allows you to separate the public API from the private implementation. This means you can change that implementation without breaking the API.</source>
          <target state="translated">Инкапсуляция важна по нескольким причинам.Во-первых,она позволяет отделить публичный API от частной реализации.Это означает,что вы можете изменить эту реализацию,не нарушая API.</target>
        </trans-unit>
        <trans-unit id="782e817cf07d938d62f7f0517e130f19ec6b4cf1" translate="yes" xml:space="preserve">
          <source>Encode</source>
          <target state="translated">Encode</target>
        </trans-unit>
        <trans-unit id="e276943b90499b3ae3cf8000afe6554906eb7f6a" translate="yes" xml:space="preserve">
          <source>Encode - character encodings in Perl</source>
          <target state="translated">Код-кодировка символов в Perl</target>
        </trans-unit>
        <trans-unit id="3c5a64c26d9e551da565d681ba9a9c2bc735a49c" translate="yes" xml:space="preserve">
          <source>Encode Implementation Base Class</source>
          <target state="translated">Базовый класс реализации кодирования</target>
        </trans-unit>
        <trans-unit id="39e91613c24a80edc94f024f6bfb3382d7e896d8" translate="yes" xml:space="preserve">
          <source>Encode a scalar, hash reference or array reference as YAML.</source>
          <target state="translated">Кодируйте скаляр,ссылку на хэш или массив как YAML.</target>
        </trans-unit>
        <trans-unit id="a78fa70f2287f5b23c037b4b8025fba5e083909c" translate="yes" xml:space="preserve">
          <source>Encode aliases &lt;code&gt;GB2312&lt;/code&gt; to &lt;code&gt;euc-cn&lt;/code&gt; in full agreement with IANA registration. &lt;code&gt;cp936&lt;/code&gt; is supported separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09bb3342b0d46392bfdbf9d685c504c20ab444c4" translate="yes" xml:space="preserve">
          <source>Encode aliases &lt;code&gt;KS_C_5601-1987&lt;/code&gt; to &lt;code&gt;cp949&lt;/code&gt; to reflect this common misusage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b3896738d8cf6b15e5278f1369de611febee2e" translate="yes" xml:space="preserve">
          <source>Encode and decode according to the base64 scheme for &quot;URL applications&quot; [1]. This is a variant of the base64 encoding which does not use padding, does not break the string into multiple lines and use the characters &quot;-&quot; and &quot;_&quot; instead of &quot;+&quot; and &quot;/&quot; to avoid using reserved URL characters.</source>
          <target state="translated">Кодирование и декодирование по схеме base64 для &quot;URL-приложений&quot; [1].Это вариант кодировки base64,который не использует подстановку,не разбивает строку на несколько строк и использует символы &quot;-&quot; и &quot;_&quot; вместо &quot;+&quot; и &quot;/&quot;,чтобы избежать использования зарезервированных символов URL.</target>
        </trans-unit>
        <trans-unit id="3d01d8346257820c445f334ba81d16daa9f20915" translate="yes" xml:space="preserve">
          <source>Encode consists of a collection of modules whose details are too extensive to fit in one document. This one itself explains the top-level APIs and general topics at a glance. For other topics and more details, see the documentation for these modules:</source>
          <target state="translated">Код состоит из коллекции модулей,подробности которых слишком обширны,чтобы поместиться в один документ.Этот документ сам по себе объясняет API верхнего уровня и общие темы с первого взгляда.Остальные темы и более подробную информацию см.в документации к этим модулям:</target>
        </trans-unit>
        <trans-unit id="90f9c590e83b0f216769d26a64108ee3d5af71e4" translate="yes" xml:space="preserve">
          <source>Encode converts from the beginning to \x7E, leaving \xe3 in the buffer because it is invalid (partial character).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5888dafc03b9c4595a9ef704f5d312540bc3c184" translate="yes" xml:space="preserve">
          <source>Encode data by calling the encode_base64() function. The first argument is the byte string to encode. The second argument is the line-ending sequence to use. It is optional and defaults to &quot;\n&quot;. The returned encoded string is broken into lines of no more than 76 characters each and it will end with $eol unless it is empty. Pass an empty string as second argument if you do not want the encoded string to be broken into lines.</source>
          <target state="translated">Кодируйте данные вызовом функции encode_base64().Первый аргумент-строка байт для кодирования.Второй аргумент-конечная строковая последовательность,которую необходимо использовать.Он необязателен и по умолчанию равен &quot;\n&quot;.Возвращаемая закодированная строка разбивается на строки не более 76 символов каждая и заканчивается на $eol,если только она не пуста.Передайте пустую строку в качестве второго аргумента,если вы не хотите,чтобы кодированная строка разбивалась на строки.</target>
        </trans-unit>
        <trans-unit id="41b574dce061d3c694f8cd7218cbb982019874dd" translate="yes" xml:space="preserve">
          <source>Encode method takes a scalar string as its input and uses &lt;a href=&quot;encode#UTF-8-vs.-utf8-vs.-UTF8&quot;&gt;strict UTF-8&lt;/a&gt; encoder for encoding it to UTF-8 bytes. Then a sequence of UTF-8 bytes is encoded into MIME encoded-words (&lt;code&gt;MIME-Header&lt;/code&gt; and &lt;code&gt;MIME-B&lt;/code&gt; use a Base64 variant while &lt;code&gt;MIME-Q&lt;/code&gt; uses a Quoted-Printable variant) where each MIME encoded-word is limited to 75 characters. MIME encoded-words are separated by &lt;code&gt;CRLF SPACE&lt;/code&gt; and joined to one output string. Output string is suitable for unstructured field body of the email header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1878d2d011ae54a82ea1609093ac6e764e131f0" translate="yes" xml:space="preserve">
          <source>Encode separately supports &lt;code&gt;Big5&lt;/code&gt; and &lt;code&gt;cp950&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f5b904d93724daaede7a0f5d5a6e265bb69f88" translate="yes" xml:space="preserve">
          <source>Encode separately supports &lt;code&gt;Shift_JIS&lt;/code&gt; and &lt;code&gt;cp932&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceff1e1e1923f02a7939b507f33300e3a696eaa2" translate="yes" xml:space="preserve">
          <source>Encode up to 1.86 internally used &quot;local $_&quot; to implement this older form. But consider the code below;</source>
          <target state="translated">Кодируйте до 1.86 во внутреннем использовании &quot;local $_&quot; для реализации этой старой формы.Но обратите внимание на код,приведенный ниже;</target>
        </trans-unit>
        <trans-unit id="dec95d5717280ac4e0be7dcb9e6fc7bc4a47ecee" translate="yes" xml:space="preserve">
          <source>Encode uses the Unicode Character Map (UCM) format for source character mappings. This format is used by IBM's ICU package and was adopted by Nick Ing-Simmons for use with the Encode module. Since UCM is more flexible than Tcl's Encoding Map and far more user-friendly, this is the recommended format for Encode now.</source>
          <target state="translated">Кодировка использует формат Unicode Character Map (UCM)для сопоставления исходных символов.Этот формат используется в IBM ICU пакете и был принят Ником Ing-Simmons для использования с модулем Encode.Так как UCM более гибкий,чем Tcl's Encoding Map и гораздо более удобный для пользователя,сейчас это рекомендуемый формат для Encode.</target>
        </trans-unit>
        <trans-unit id="5d2cad9401edfbef92e75be01cb40c4e9ecc4cf6" translate="yes" xml:space="preserve">
          <source>Encode::Alias</source>
          <target state="translated">Encode::Alias</target>
        </trans-unit>
        <trans-unit id="552324ae1eb023be362415291b1291f3f52556a7" translate="yes" xml:space="preserve">
          <source>Encode::Alias - alias definitions to encodings</source>
          <target state="translated">Кодировка::Псевдоним-определение псевдонима к кодировке</target>
        </trans-unit>
        <trans-unit id="cc91ef6d8b4186209599d785324e380db05af545" translate="yes" xml:space="preserve">
          <source>Encode::Byte</source>
          <target state="translated">Encode::Byte</target>
        </trans-unit>
        <trans-unit id="d4b97f8bcca673137fe3a8c4311fa29b1376a129" translate="yes" xml:space="preserve">
          <source>Encode::Byte - Single Byte Encodings</source>
          <target state="translated">Кодировка::Байт-Однобайтовое кодирование</target>
        </trans-unit>
        <trans-unit id="930606b772f93c8896784219cc491d7a0cee7e76" translate="yes" xml:space="preserve">
          <source>Encode::Byte -- Extended ASCII</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f240792605e5eac4a6580e33ee29dcc7a428c2" translate="yes" xml:space="preserve">
          <source>Encode::Byte implements most single-byte encodings except for Symbols and EBCDIC. The following encodings are based on single-byte encodings implemented as extended ASCII. Most of them map \x80-\xff (upper half) to non-ASCII characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da29f26c3e55351d546a404e8b09b53f82affc8" translate="yes" xml:space="preserve">
          <source>Encode::CJKConstants</source>
          <target state="translated">Encode::CJKConstants</target>
        </trans-unit>
        <trans-unit id="97376755cadc9b08ac2bdcffa80b5c4759e6f7df" translate="yes" xml:space="preserve">
          <source>Encode::CJKConstants.pm -- Internally used by Encode::??::ISO_2022_*</source>
          <target state="translated">Кодировка::CJKConstants.pm --Внутренне используется Кодировка::??::ISO_2022_*</target>
        </trans-unit>
        <trans-unit id="44fea5bddc6721fb4b956554b9d88900826d60c7" translate="yes" xml:space="preserve">
          <source>Encode::CN</source>
          <target state="translated">Encode::CN</target>
        </trans-unit>
        <trans-unit id="40f3392265131b672490757c292c084a525d4184" translate="yes" xml:space="preserve">
          <source>Encode::CN - China-based Chinese Encodings</source>
          <target state="translated">Кодировка::CN-Китайские кодировки</target>
        </trans-unit>
        <trans-unit id="56aaed97f5a41017265e5458630887666002ff6b" translate="yes" xml:space="preserve">
          <source>Encode::CN -- Continental China</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207660f321fc12762f2e79b28e35fbb26736a3e7" translate="yes" xml:space="preserve">
          <source>Encode::CN::HZ</source>
          <target state="translated">Encode::CN::HZ</target>
        </trans-unit>
        <trans-unit id="622d7b0a21ca0c1a08d6dda20da0057e0358570c" translate="yes" xml:space="preserve">
          <source>Encode::CN::HZ -- internally used by Encode::CN</source>
          <target state="translated">Кодировка::CN::HZ --внутренне используется Кодировка::CN</target>
        </trans-unit>
        <trans-unit id="b24bb381f68ba02b49c4c2cd2767f183910da09e" translate="yes" xml:space="preserve">
          <source>Encode::Config</source>
          <target state="translated">Encode::Config</target>
        </trans-unit>
        <trans-unit id="0b7c024127a98fc8be2586eade5f76bc22701aab" translate="yes" xml:space="preserve">
          <source>Encode::Config -- internally used by Encode</source>
          <target state="translated">Кодировка::Настройка --внутренне используется Кодировкой</target>
        </trans-unit>
        <trans-unit id="2a8ba6ae9bd0735a827d283930aa3dc28cd2cae3" translate="yes" xml:space="preserve">
          <source>Encode::EBCDIC</source>
          <target state="translated">Encode::EBCDIC</target>
        </trans-unit>
        <trans-unit id="3b31a7154f7c03e9be274aacce1e4dc5a66d5ec6" translate="yes" xml:space="preserve">
          <source>Encode::EBCDIC - EBCDIC Encodings</source>
          <target state="translated">Кодировка::EBCDIC-EBCDIC Кодировки</target>
        </trans-unit>
        <trans-unit id="a0fb1479e2e68a75a05e36aff16d787758a1778e" translate="yes" xml:space="preserve">
          <source>Encode::Encoder</source>
          <target state="translated">Encode::Encoder</target>
        </trans-unit>
        <trans-unit id="3bfd37620385e094ff5d1811f8a5aaf8e5a7a125" translate="yes" xml:space="preserve">
          <source>Encode::Encoder -- Object Oriented Encoder</source>
          <target state="translated">Кодировка::Кодировщик --Объектно-ориентированный кодировщик</target>
        </trans-unit>
        <trans-unit id="4551a7e4c9181d379ae1288237c1ebecccd59bb8" translate="yes" xml:space="preserve">
          <source>Encode::Encoding</source>
          <target state="translated">Encode::Encoding</target>
        </trans-unit>
        <trans-unit id="932dfcdaef25e880e85283d712d29f239746970b" translate="yes" xml:space="preserve">
          <source>Encode::Encoding - Encode Implementation Base Class</source>
          <target state="translated">Кодирование::Кодирование-Базовый класс реализации кодирования</target>
        </trans-unit>
        <trans-unit id="77662ad703615bf25ca69905bb6db23d72296bb9" translate="yes" xml:space="preserve">
          <source>Encode::GSM0338</source>
          <target state="translated">Encode::GSM0338</target>
        </trans-unit>
        <trans-unit id="ede01420f58b4c2565b3da82244d84c95da5b4af" translate="yes" xml:space="preserve">
          <source>Encode::GSM0338 -- ESTI GSM 03.38 Encoding</source>
          <target state="translated">Кодирование::GSM0338 --ESTI GSM 03.38 Кодирование</target>
        </trans-unit>
        <trans-unit id="e93ed447e10d95864f0386c026ec121cd47c60ab" translate="yes" xml:space="preserve">
          <source>Encode::Guess</source>
          <target state="translated">Encode::Guess</target>
        </trans-unit>
        <trans-unit id="8b1b151431a67a55222cbbcf0270cd834cbd2d46" translate="yes" xml:space="preserve">
          <source>Encode::Guess -- Guesses encoding from data</source>
          <target state="translated">Кодировка::Угадай --Угадай кодировку из данных.</target>
        </trans-unit>
        <trans-unit id="f460e270f104cac10b54ab28764ae1739d32a63f" translate="yes" xml:space="preserve">
          <source>Encode::Guess does not work on EBCDIC platforms.</source>
          <target state="translated">Кодировка::Думаю,не работает на платформах EBCDIC.</target>
        </trans-unit>
        <trans-unit id="8030a57667933f97cc9c39195dbf244e622a18a0" translate="yes" xml:space="preserve">
          <source>Encode::Guess enables you to guess in what encoding a given data is encoded, or at least tries to.</source>
          <target state="translated">Кодировка::Угадать позволяет угадать,в какой кодировке закодированы данные,или,по крайней мере,попытаться.</target>
        </trans-unit>
        <trans-unit id="4c76dcf9e721cd63d6b7c64ae9ac390cd36bca44" translate="yes" xml:space="preserve">
          <source>Encode::Guess-&amp;gt;add_suspects</source>
          <target state="translated">Encode::Guess-&amp;gt;add_suspects</target>
        </trans-unit>
        <trans-unit id="e5a679cb789609bd6b4f6bc29c3c93aa2af2b209" translate="yes" xml:space="preserve">
          <source>Encode::Guess-&amp;gt;guess($data)</source>
          <target state="translated">Encode::Guess-&amp;gt;guess($data)</target>
        </trans-unit>
        <trans-unit id="91b94bb51243fdcafbdb22a3d3b975f9b8695d1d" translate="yes" xml:space="preserve">
          <source>Encode::Guess-&amp;gt;set_suspects</source>
          <target state="translated">Encode::Guess-&amp;gt;set_suspects</target>
        </trans-unit>
        <trans-unit id="a0735b72517ca9ff3c7f14337ef1ad3eeea0e3f0" translate="yes" xml:space="preserve">
          <source>Encode::HanExtra -- More Chinese via CPAN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9eb31f93d16c6f8ad3ca48a91dab8c5071fe46" translate="yes" xml:space="preserve">
          <source>Encode::JIS2K -- JIS X 0213 encodings via CPAN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37ee0e2e550bc3634d116c838f3ba94375b8c47" translate="yes" xml:space="preserve">
          <source>Encode::JP</source>
          <target state="translated">Encode::JP</target>
        </trans-unit>
        <trans-unit id="341afac777ffb0b1e52b3a6aa26c1fcd31687ea1" translate="yes" xml:space="preserve">
          <source>Encode::JP - Japanese Encodings</source>
          <target state="translated">Кодировка::JP-японская Кодировка</target>
        </trans-unit>
        <trans-unit id="4d2ce26abda0dd0d175937050c97398037e5cc87" translate="yes" xml:space="preserve">
          <source>Encode::JP -- Japan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e6a27be2a727bdf7e4a113a80bef5ed7da8c32a" translate="yes" xml:space="preserve">
          <source>Encode::JP::H2Z</source>
          <target state="translated">Encode::JP::H2Z</target>
        </trans-unit>
        <trans-unit id="61c842d29f655e9a02cc88f2dfe176c79b0a7ccb" translate="yes" xml:space="preserve">
          <source>Encode::JP::H2Z -- internally used by Encode::JP::2022_JP*</source>
          <target state="translated">Кодировка::JP::H2Z --внутренне используется Кодировка::JP::2022_JP*</target>
        </trans-unit>
        <trans-unit id="57d3b7cea6d80534a4eab96981ae8b12e91a572d" translate="yes" xml:space="preserve">
          <source>Encode::JP::JIS7</source>
          <target state="translated">Encode::JP::JIS7</target>
        </trans-unit>
        <trans-unit id="728d78512ef0e5fd10db6af9228f9f55491f142e" translate="yes" xml:space="preserve">
          <source>Encode::JP::JIS7 -- internally used by Encode::JP</source>
          <target state="translated">Кодировка::JP::JIS7 --внутренне используется Кодировка::JP</target>
        </trans-unit>
        <trans-unit id="9292d6d6d6c3d612ab88b4d0a9b44cce420ff5ea" translate="yes" xml:space="preserve">
          <source>Encode::KR</source>
          <target state="translated">Encode::KR</target>
        </trans-unit>
        <trans-unit id="32eef4f01d06c098fb548d1006c901f52a812e7e" translate="yes" xml:space="preserve">
          <source>Encode::KR - Korean Encodings</source>
          <target state="translated">Кодировка::KR-корейская Кодировка</target>
        </trans-unit>
        <trans-unit id="1af58b45e5ddb5840265bad145aa164eaffbeea7" translate="yes" xml:space="preserve">
          <source>Encode::KR -- Korea</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adea371ce7b9ff3c3566f35ac1420ac2e2ede009" translate="yes" xml:space="preserve">
          <source>Encode::KR::2022_KR</source>
          <target state="translated">Encode::KR::2022_KR</target>
        </trans-unit>
        <trans-unit id="3976fa623737771006bbaafdf23430529728651d" translate="yes" xml:space="preserve">
          <source>Encode::KR::2022_KR -- internally used by Encode::KR</source>
          <target state="translated">Кодировка::KR::2022_KR --внутренне используется Кодировка::KR</target>
        </trans-unit>
        <trans-unit id="e9d431857fb2daca858cf0e24708414e6076d14b" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Header</source>
          <target state="translated">Encode::MIME::Header</target>
        </trans-unit>
        <trans-unit id="f2030bc40a6a13ab85bce58de044a451e0f2022a" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Header -- MIME 'B' and 'Q' header encoding</source>
          <target state="translated">Кодировка::MIME::Заголовок --MIME 'B' и 'Q' кодировка заголовков</target>
        </trans-unit>
        <trans-unit id="8d4bde122083dca41ec16dc22bc309e1ca8f4388" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Header -- MIME encoding for an unstructured email header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660e24530b4b214dbcf404910cce6c40e5661246" translate="yes" xml:space="preserve">
          <source>Encode::MIME::NAME -- internally used by Encode</source>
          <target state="translated">Кодировка::MIME::ИМЯ --внутренне используемое кодирование</target>
        </trans-unit>
        <trans-unit id="5f4e8291cc2cc181fac6cfb29c5aaebe19ffe8d7" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Name</source>
          <target state="translated">Encode::MIME::Name</target>
        </trans-unit>
        <trans-unit id="28fab0785bc684a2a52d97e53a66b49d5527d9be" translate="yes" xml:space="preserve">
          <source>Encode::PerlIO</source>
          <target state="translated">Encode::PerlIO</target>
        </trans-unit>
        <trans-unit id="41a3b8bb23e3f7b5138303897788011e915cffdf" translate="yes" xml:space="preserve">
          <source>Encode::PerlIO -- a detailed document on Encode and PerlIO</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd20dbfc849a216b8ec8f0aae8d9f22755869e7" translate="yes" xml:space="preserve">
          <source>Encode::Supported</source>
          <target state="translated">Encode::Supported</target>
        </trans-unit>
        <trans-unit id="eb0c5a3a273c3a4c4ad776ddaca0c86b8236ef3c" translate="yes" xml:space="preserve">
          <source>Encode::Supported -- Encodings supported by Encode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="617dc5e07f69ab0016776f02fcae4aa5417d4cf3" translate="yes" xml:space="preserve">
          <source>Encode::Symbol</source>
          <target state="translated">Encode::Symbol</target>
        </trans-unit>
        <trans-unit id="305d6a4ecfbcb83575125920205199ebfad9ecbc" translate="yes" xml:space="preserve">
          <source>Encode::Symbol - Symbol Encodings</source>
          <target state="translated">Кодировка::Символ-Символ Кодировка</target>
        </trans-unit>
        <trans-unit id="246710749ac240e0889edf0116d38bdff86ae7a9" translate="yes" xml:space="preserve">
          <source>Encode::Symbols</source>
          <target state="translated">Encode::Symbols</target>
        </trans-unit>
        <trans-unit id="7353083e24fd78826faff9ec9dd3ca1f0abfeb68" translate="yes" xml:space="preserve">
          <source>Encode::TW</source>
          <target state="translated">Encode::TW</target>
        </trans-unit>
        <trans-unit id="169a69c17f2e47c33a2090f250bc6f54465bac9c" translate="yes" xml:space="preserve">
          <source>Encode::TW - Taiwan-based Chinese Encodings</source>
          <target state="translated">Кодировка::TW-Тайваньские китайские кодировки</target>
        </trans-unit>
        <trans-unit id="0a45467a524b47a94315245ccf968b728241554a" translate="yes" xml:space="preserve">
          <source>Encode::TW -- Taiwan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f419db0e193bdb95ad1bf1d32e4308acad0add9f" translate="yes" xml:space="preserve">
          <source>Encode::Unicode</source>
          <target state="translated">Encode::Unicode</target>
        </trans-unit>
        <trans-unit id="2ba2c8325c871771b84294002113cdbbccea72d4" translate="yes" xml:space="preserve">
          <source>Encode::Unicode -- Various Unicode Transformation Formats</source>
          <target state="translated">Кодировка::Юникод --Различные форматы преобразования Юникода</target>
        </trans-unit>
        <trans-unit id="510f299bed8b57aaad0840b1977677d5faf52278" translate="yes" xml:space="preserve">
          <source>Encode::Unicode -- other Unicode encodings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e91aa87151df83dcd6a084acf2bef4fbe28cca" translate="yes" xml:space="preserve">
          <source>Encode::Unicode::UTF7</source>
          <target state="translated">Encode::Unicode::UTF7</target>
        </trans-unit>
        <trans-unit id="46189c892fa791248c9e1697ba2bd11d7d60c2a5" translate="yes" xml:space="preserve">
          <source>Encode::Unicode::UTF7 -- UTF-7 encoding</source>
          <target state="translated">Кодировка::Юникод::UTF7 --кодировка UTF-7</target>
        </trans-unit>
        <trans-unit id="89d34727747f027f9d8e6303c1a70b2655a0c0fe" translate="yes" xml:space="preserve">
          <source>Encode::decode(&quot;Guess&quot; ...)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca2ce49b12c2ee816a410523ba091dc693a60d6" translate="yes" xml:space="preserve">
          <source>Encodes a scalar, hash reference or array reference as YAMLish.</source>
          <target state="translated">Кодирует скаляр,ссылку на хэш или массив как YAMLish.</target>
        </trans-unit>
        <trans-unit id="225ac8da293afbab880950db9793bf5ef9a811e8" translate="yes" xml:space="preserve">
          <source>Encodes the invocand as a byte string in the given format as specified in IEEE 754-2008. Note that the encoded value is the nearest possible representation of the value. This value might not be exactly the same as the value in the invocand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c840f47e19e39ed11ebf36e763d836813b7799" translate="yes" xml:space="preserve">
          <source>Encodes the scalar value</source>
          <target state="translated">Кодирует скалярное значение</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="8febd2fa21d6fa8e1d3dfe269d8ca87dc204d2c3" translate="yes" xml:space="preserve">
          <source>Encoding Classification (by Anton Tagunov and Dan Kogai)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33835dcaa05ba53de2779ac501c0b636ae0c061" translate="yes" xml:space="preserve">
          <source>Encoding Names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e649a0b553388aa0aefbd82d8b0f0d1a27873465" translate="yes" xml:space="preserve">
          <source>Encoding and decoding of base64 strings</source>
          <target state="translated">Кодирование и декодирование строк base64</target>
        </trans-unit>
        <trans-unit id="6b77915998634f10773a65ebf127633caa0903b3" translate="yes" xml:space="preserve">
          <source>Encoding and decoding of quoted-printable strings</source>
          <target state="translated">Кодирование и декодирование строк для печати в кавычках</target>
        </trans-unit>
        <trans-unit id="a998510992fa4d69263beacea1ddcc7415077441" translate="yes" xml:space="preserve">
          <source>Encoding handling assumes that PerlIO is available and does not work properly if it isn't. The &lt;code&gt;utf8&lt;/code&gt; option is therefore not supported unless Perl is built with PerlIO support.</source>
          <target state="translated">Обработка кодирования предполагает, что PerlIO доступен, и в противном случае не работает должным образом. Поэтому опция &lt;code&gt;utf8&lt;/code&gt; не поддерживается, если Perl не построен с поддержкой PerlIO.</target>
        </trans-unit>
        <trans-unit id="04cfa3e7800a4d240dc7f677c9407b294c248bcf" translate="yes" xml:space="preserve">
          <source>Encoding layer</source>
          <target state="translated">Слой кодирования</target>
        </trans-unit>
        <trans-unit id="b9782d5b4b9e78ce07208ac3d1921ad180cd2fcb" translate="yes" xml:space="preserve">
          <source>Encoding names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680e8d978db89c29bc9f5396c102c8ec2731a094" translate="yes" xml:space="preserve">
          <source>Encoding names are case insensitive. White space in names is ignored. In addition, an encoding may have aliases. Each encoding has one &quot;canonical&quot; name. The &quot;canonical&quot; name is chosen from the names of the encoding by picking the first in the following sequence (with a few exceptions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01cbaf646f7cdfb7eb0fbb21f815c71c722e02c1" translate="yes" xml:space="preserve">
          <source>Encoding via PerlIO</source>
          <target state="translated">Кодирование через PerlIO</target>
        </trans-unit>
        <trans-unit id="46fade9210aeab4b837cd79bdf4256d2a5f65faf" translate="yes" xml:space="preserve">
          <source>Encoding vs. Charset -- terminology</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e06c1fc55b2907153074d333e66853227f2028" translate="yes" xml:space="preserve">
          <source>Encodings are categorized and implemented in several different modules but you don't have to &lt;code&gt;use Encode::XX&lt;/code&gt; to make them available for most cases. Encode.pm will automatically load those modules on demand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc5b05d5a707cb27dff01159bcf1a3ca6a46e7c" translate="yes" xml:space="preserve">
          <source>Encodings supported by Encode</source>
          <target state="translated">Поддерживаемые кодировки</target>
        </trans-unit>
        <trans-unit id="f136f667340e5f4c44804d0073e50a60db219512" translate="yes" xml:space="preserve">
          <source>Encrypted communication channel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c4ae224ac38c50705eb255694dceb50337fe4c9" translate="yes" xml:space="preserve">
          <source>End of File. Sometimes used metaphorically as the terminating string of a &lt;b&gt;here document&lt;/b&gt;.</source>
          <target state="translated">Конец файла. Иногда используется метафорически как завершающая строка &lt;b&gt;документа здесь&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="e61fae84390da1a34c4b2fbd657622d5073292c7" translate="yes" xml:space="preserve">
          <source>End of file.</source>
          <target state="translated">Конец файла.</target>
        </trans-unit>
        <trans-unit id="d1e4562e3c175d8468bb1a01a7952bd0d3b259e1" translate="yes" xml:space="preserve">
          <source>End the sending of data to the remote server. This is done by ensuring that the data already sent ends with CRLF then sending '.CRLF' to end the transmission. Once this data has been sent &lt;code&gt;dataend&lt;/code&gt; calls &lt;code&gt;response&lt;/code&gt; and returns true if &lt;code&gt;response&lt;/code&gt; returns CMD_OK.</source>
          <target state="translated">Завершите отправку данных на удаленный сервер. Это достигается путем обеспечения того, чтобы уже отправленные данные заканчивались CRLF, а затем отправляли .CRLF для завершения передачи. После того, как эти данные были отправлены, &lt;code&gt;dataend&lt;/code&gt; вызывает &lt;code&gt;response&lt;/code&gt; и возвращает истину, если &lt;code&gt;response&lt;/code&gt; возвращает CMD_OK.</target>
        </trans-unit>
        <trans-unit id="5b395d065aa5966c6da16e4b8c501ca68c3ecd37" translate="yes" xml:space="preserve">
          <source>End-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Концевые пальцы от Pod::Простые::PullParser</target>
        </trans-unit>
        <trans-unit id="8676dbbd19637e0c1604c4bcd69f9208a03cfa1a" translate="yes" xml:space="preserve">
          <source>End.U</source>
          <target state="translated">End.U</target>
        </trans-unit>
        <trans-unit id="d1787011d64eb206cd1d2b206a7e53314fc2df0d" translate="yes" xml:space="preserve">
          <source>Ends a try block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;&quot;Exception Handling&quot; in perlguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4d04612cae76dda50e81f179859b4b712ba14ff" translate="yes" xml:space="preserve">
          <source>Ends a try block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">Завершает блок попытки. См. Раздел &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Обработка исключений в perlguts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ea2083617805ed93273c46ed0c4792fa3da7a0b" translate="yes" xml:space="preserve">
          <source>Enforce type integrity if required</source>
          <target state="translated">При необходимости обеспечить целостность типов</target>
        </trans-unit>
        <trans-unit id="286ca1647ce3f25ee107c4a9d50837ecd6b2a964" translate="yes" xml:space="preserve">
          <source>Enforcing redispatch</source>
          <target state="translated">Усиление повторных записей</target>
        </trans-unit>
        <trans-unit id="a1681854c9f0debb40072c691fd6f403e3a9401c" translate="yes" xml:space="preserve">
          <source>Enginsite</source>
          <target state="translated">Enginsite</target>
        </trans-unit>
        <trans-unit id="649df08a448ee3fa90f3746baaf6b0907df42c91" translate="yes" xml:space="preserve">
          <source>English</source>
          <target state="translated">English</target>
        </trans-unit>
        <trans-unit id="256aa1d5dab6cf2100434b619aada1a930ae7c7d" translate="yes" xml:space="preserve">
          <source>English ('en') is</source>
          <target state="translated">Английский ('en')</target>
        </trans-unit>
        <trans-unit id="7aa949020d6b22aac250e3885290aa830dd72a15" translate="yes" xml:space="preserve">
          <source>English - use nice English (or awk) names for ugly punctuation variables</source>
          <target state="translated">English-используйте красивые английские (или awk)имена для уродливых знаков препинания.</target>
        </trans-unit>
        <trans-unit id="34afa6db1cf569bd02a3ffe4f7e6036f1798a631" translate="yes" xml:space="preserve">
          <source>English.pm</source>
          <target state="translated">English.pm</target>
        </trans-unit>
        <trans-unit id="99343727bceed607c32f483621540aee48471580" translate="yes" xml:space="preserve">
          <source>Enough of the definition talk! Let's have a few examples.</source>
          <target state="translated">Хватит разговоров об определении! Давайте приведем несколько примеров.</target>
        </trans-unit>
        <trans-unit id="d899ea5401439c93a0c8f86febf8bb8f4f088e5d" translate="yes" xml:space="preserve">
          <source>Ensure that colons marking targets are preceded by space, in order to distinguish the target delimiter from a colon appearing as part of a filespec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8988a13726c59d935ea79d755d1455be0fc83772" translate="yes" xml:space="preserve">
          <source>Ensure that you know what \b really does: it's the boundary between a word character, \w, and something that isn't a word character. That thing that isn't a word character might be \W, but it can also be the start or end of the string.</source>
          <target state="translated">Убедитесь,что вы знаете,что на самом деле делает \b:это граница между символом слова,\w,и чем-то,что не является символом слова.То,что не является символом слова,может быть \W,но также может быть началом или концом строки.</target>
        </trans-unit>
        <trans-unit id="8680a11001e2d2163c0b3f5d95efb035f3fa7b03" translate="yes" xml:space="preserve">
          <source>Ensure you're following the latest advice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21287dbbbfc03a6ee27ae105b87e32fa291261eb" translate="yes" xml:space="preserve">
          <source>Ensure your module works under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;-w&lt;/code&gt;</source>
          <target state="translated">Убедитесь, что ваш модуль работает под &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использованием&lt;/a&gt; и &lt;code&gt;-w&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee84d37b57aec0c02ba775d818a3471f6da99fba" translate="yes" xml:space="preserve">
          <source>Ensure your module works under &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;-w&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3137a5d79c4479978038346bf282e1d45e0aa011" translate="yes" xml:space="preserve">
          <source>Ensures that &lt;code&gt;MoveFileEx&lt;/code&gt; won't return until the operation has finished and been flushed to disk. This is not supported under Windows 95. Only affects file renames to another file system, forcing a buffer flush at the end of the copy operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f974b332a5fa28c86d4229cace8185f73744894" translate="yes" xml:space="preserve">
          <source>Ensures that sv is a SVt_PV and that its SvCUR is 0, and that it is properly null terminated. Equivalent to sv_setpvs(&quot;&quot;), but more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1279af9b58018ff33488efc0656bb62fda8db44f" translate="yes" xml:space="preserve">
          <source>Enter interactive mode by running</source>
          <target state="translated">Войдите в интерактивный режим,запустив</target>
        </trans-unit>
        <trans-unit id="74eb99da3b9ba3df5f4be61ae4522068a9b27d10" translate="yes" xml:space="preserve">
          <source>Entire arrays (and slices of arrays and hashes) are denoted by '@', which works much as the word &quot;these&quot; or &quot;those&quot; does in English, in that it indicates multiple values are expected.</source>
          <target state="translated">Целые массивы (и ломтики массивов и хэшей)обозначаются словом &quot;@&quot;,которое работает так же,как и слово &quot;эти&quot; или &quot;те&quot; в английском языке,в том смысле,что оно указывает на то,что ожидается несколько значений.</target>
        </trans-unit>
        <trans-unit id="d245bbc8252b0b71ede0a2f949fc5b29d829fd5d" translate="yes" xml:space="preserve">
          <source>Entire hashes are denoted by '%':</source>
          <target state="translated">Целые хэши обозначаются знаком &quot;%&quot;:</target>
        </trans-unit>
        <trans-unit id="4f918189cf78ab84f6519ba2dcb57f2ae316f72b" translate="yes" xml:space="preserve">
          <source>Entries cannot be plain object files, as many Win32 compilers will not handle object files in the place of libraries.</source>
          <target state="translated">Записи не могут быть обычными объектными файлами,так как многие Win32 компиляторы не будут работать с объектными файлами вместо библиотек.</target>
        </trans-unit>
        <trans-unit id="673fba8e1fb3916663891e031f77ca1343408944" translate="yes" xml:space="preserve">
          <source>Entries in &lt;code&gt;$potential_libs&lt;/code&gt; beginning with a colon and followed by alphanumeric characters are treated as flags. Unknown flags will be ignored.</source>
          <target state="translated">Записи в &lt;code&gt;$potential_libs&lt;/code&gt; начинающиеся с двоеточия и за которыми следуют буквенно-цифровые символы, рассматриваются как флаги. Неизвестные флаги будут проигнорированы.</target>
        </trans-unit>
        <trans-unit id="a95d99085680ef5c64c2fe5754604ba2f596d896" translate="yes" xml:space="preserve">
          <source>Entries such as:</source>
          <target state="translated">Такие записи,как..:</target>
        </trans-unit>
        <trans-unit id="8d07f7a288d3779719c1509961105704b61f4cef" translate="yes" xml:space="preserve">
          <source>Entry in the INPUT section of a typemap</source>
          <target state="translated">Вход в секцию INPUT типовой карты</target>
        </trans-unit>
        <trans-unit id="237fc607826e845da2eb03390fed5a45c866b715" translate="yes" xml:space="preserve">
          <source>Entry in the OUTPUT section of a typemap</source>
          <target state="translated">Введите в раздел OUTPUT типовой карты</target>
        </trans-unit>
        <trans-unit id="81a846de6d38920893fe50bf678fb10abc3847e2" translate="yes" xml:space="preserve">
          <source>Entry in the TYPEMAP section of a typemap</source>
          <target state="translated">Вход в раздел TYPEMAP типовой карты</target>
        </trans-unit>
        <trans-unit id="f211ac2a755354cfc7e79a205b52eb23e2f010b1" translate="yes" xml:space="preserve">
          <source>Entware-ng comes with a precompiled 5.24.1 (June 2017) that allowes building shared XS code. Note that this installation does &lt;b&gt;not&lt;/b&gt; use a site_perl folder. The available &lt;code&gt;cpan&lt;/code&gt; works. If all required development packages are installed too, also for XS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2562690818adae41c773c584b6f6c09ebb4d39c" translate="yes" xml:space="preserve">
          <source>Env</source>
          <target state="translated">Env</target>
        </trans-unit>
        <trans-unit id="fbbe5fa808eea7f4c74b5ba16db47dab460bc3b9" translate="yes" xml:space="preserve">
          <source>Env - perl module that imports environment variables as scalars or arrays</source>
          <target state="translated">Env-perl модуль,который импортирует переменные окружения в виде скаляров или массивов.</target>
        </trans-unit>
        <trans-unit id="ec072bba7befaa68af710fe3549eb0491d7badd1" translate="yes" xml:space="preserve">
          <source>Environment Variables</source>
          <target state="translated">Переменные среды</target>
        </trans-unit>
        <trans-unit id="e19f8816c6f7ccbb7d40a44b81def1ffb731d4e0" translate="yes" xml:space="preserve">
          <source>Environment for Compiling perl on Solaris</source>
          <target state="translated">Окружающая среда для компиляции перла на Солярисе</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e160747cc9ac3da385ca9f9c1cb6f2e6810dff" translate="yes" xml:space="preserve">
          <source>Environment variables that the program cares about, normally presented as a list using &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , and &lt;code&gt;=back&lt;/code&gt; . For example:</source>
          <target state="translated">Переменные среды, которые важны для программы, обычно представлены в виде списка с использованием &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; и &lt;code&gt;=back&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="047031c84702987a532453c9aba009b3c909ceb6" translate="yes" xml:space="preserve">
          <source>Environment variables that the program cares about, normally presented as a list using &lt;code&gt;=over&lt;/code&gt;, &lt;code&gt;=item&lt;/code&gt;, and &lt;code&gt;=back&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ed6121898e672a267f0f15674f039aebf49694" translate="yes" xml:space="preserve">
          <source>Environment variables to be set during the command</source>
          <target state="translated">Переменные окружения,которые должны быть установлены во время команды</target>
        </trans-unit>
        <trans-unit id="ec3aedc215415465ba248c2b745d070af96045ef" translate="yes" xml:space="preserve">
          <source>Eof</source>
          <target state="translated">Eof</target>
        </trans-unit>
        <trans-unit id="7264243f4aeaaab7fbb98bd7afd5e953b5900f7b" translate="yes" xml:space="preserve">
          <source>Equality Operators</source>
          <target state="translated">Равноправные операторы</target>
        </trans-unit>
        <trans-unit id="f6a4eb155ac0505cd34f3102780f106892d4662a" translate="yes" xml:space="preserve">
          <source>Equivalence between Decimal and Dotted-Decimal Versions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cfd756767e68de5473421aba90c9077344def28" translate="yes" xml:space="preserve">
          <source>Equivalent examples:</source>
          <target state="translated">Эквивалентные примеры:</target>
        </trans-unit>
        <trans-unit id="c61e2265d123d76133484971263eb3576ac59dd9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$octets = encode(&quot;utf8&quot;, $string)&lt;/code&gt; . The characters in $string are encoded in Perl's internal format, and the result is returned as a sequence of octets. Because all possible characters in Perl have a (loose, not strict) UTF-8 representation, this function cannot fail.</source>
          <target state="translated">Эквивалентно &lt;code&gt;$octets = encode(&quot;utf8&quot;, $string)&lt;/code&gt; . Символы в $ string кодируются во внутреннем формате Perl, а результат возвращается как последовательность октетов. Поскольку все возможные символы в Perl имеют (свободное, не строгое) представление UTF-8, эта функция не может дать сбой.</target>
        </trans-unit>
        <trans-unit id="2e78d6f894c7d9e2878d9273592738107eb000e0" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$octets = encode(&quot;utf8&quot;, $string)&lt;/code&gt;. The characters in $string are encoded in Perl's internal format, and the result is returned as a sequence of octets. Because all possible characters in Perl have a (loose, not strict) utf8 representation, this function cannot fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a263a53c5879a617814d231b90b810689cbeec78" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$string = decode(&quot;utf8&quot;, $octets [, CHECK])&lt;/code&gt; . The sequence of octets represented by $octets is decoded from UTF-8 into a sequence of logical characters. Because not all sequences of octets are valid UTF-8, it is quite possible for this function to fail. For CHECK, see &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;Handling Malformed Data&lt;/a&gt;.</source>
          <target state="translated">Эквивалентен &lt;code&gt;$string = decode(&quot;utf8&quot;, $octets [, CHECK])&lt;/code&gt; . Последовательность октетов, представленная $ octets, декодируется из UTF-8 в последовательность логических символов. Поскольку не все последовательности октетов являются допустимыми UTF-8, эта функция вполне может выйти из строя. Для CHECK см. &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;Обработка искаженных данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98fe51deeaa55823d52414f5281c460f4be56e6e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$string = decode(&quot;utf8&quot;, $octets [, CHECK])&lt;/code&gt;. The sequence of octets represented by $octets is decoded from (loose, not strict) utf8 into a sequence of logical characters. Because not all sequences of octets are valid not strict utf8, it is quite possible for this function to fail. For CHECK, see &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;&quot;Handling Malformed Data&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032e60eb7c99d19d4d7f40467e50e02c1b3b3e31" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;(x) - 1&lt;/code&gt; , but more precise for small argument values [C99].</source>
          <target state="translated">Эквивалентен &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;(x) - 1&lt;/code&gt; , но более точен для малых значений аргумента [C99].</target>
        </trans-unit>
        <trans-unit id="48506d548803ae745c6c6681b3b6b358f76d6d1f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log&lt;/a&gt;(1 + x)&lt;/code&gt; , but more stable results for small argument values [C99].</source>
          <target state="translated">Эквивалентно &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log&lt;/a&gt;(1 + x)&lt;/code&gt; , но более стабильные результаты для малых значений аргумента [C99].</target>
        </trans-unit>
        <trans-unit id="22c30bad53a9801aa2549ef28438b22b8be2db3e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; , except that &lt;code&gt;$\&lt;/code&gt; (the output record separator) is not appended. The FORMAT and the LIST are actually parsed as a single list. The first argument of the list will be interpreted as the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; format. This means that &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; will use &lt;code&gt;$_[0]&lt;/code&gt; as the format. See &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt; for an explanation of the format argument. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; for &lt;code&gt;LC_NUMERIC&lt;/code&gt; Look for this throught pod is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale setting. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">Эквивалентен &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; , за исключением того, что &lt;code&gt;$\&lt;/code&gt; (разделитель выходной записи) не добавляется. FORMAT и LIST фактически анализируются как один список. Первый аргумент списка будет интерпретирован как формат &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; . Это означает, что &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; будет использовать &lt;code&gt;$_[0]&lt;/code&gt; в качестве формата. См. &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;Sprintf&lt;/a&gt; для объяснения аргумента формата. Если &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; для &lt;code&gt;LC_NUMERIC&lt;/code&gt; Искать этот сквозной модуль и был вызван POSIX :: setlocale (), на символ, используемый для десятичного разделителя в форматированных числах с плавающей запятой, влияет &lt;code&gt;LC_NUMERIC&lt;/code&gt; локали LC_NUMERIC . См. &lt;a href=&quot;perllocale&quot;&gt;Perllocale&lt;/a&gt; и &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="200de086c8cd5535e67b47001e5f819da8109f8f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt&lt;/a&gt;(x * x + y * y)&lt;/code&gt; except more stable on very large or very small arguments [C99].</source>
          <target state="translated">Эквивалентен &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt&lt;/a&gt;(x * x + y * y)&lt;/code&gt; за исключением большей стабильности при очень больших или очень маленьких аргументах [C99].</target>
        </trans-unit>
        <trans-unit id="0f1d23c2683b2580eee5762a2646e2cfdbd51243" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; , except that &lt;code&gt;$\&lt;/code&gt; (the output record separator) is not appended. The FORMAT and the LIST are actually parsed as a single list. The first argument of the list will be interpreted as the &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; format. This means that &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; will use &lt;code&gt;$_[0]&lt;/code&gt; as the format. See &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt; for an explanation of the format argument. If &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; for &lt;code&gt;LC_NUMERIC&lt;/code&gt; Look for this throught pod is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale setting. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">Эквивалентен &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; , за исключением того, что &lt;code&gt;$\&lt;/code&gt; (разделитель выходной записи) не добавляется. FORMAT и LIST фактически анализируются как один список. Первый аргумент списка будет интерпретирован как формат &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; . Это означает, что &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; будет использовать &lt;code&gt;$_[0]&lt;/code&gt; в качестве формата. См. &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;Sprintf&lt;/a&gt; для объяснения аргумента формата. Если &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; для &lt;code&gt;LC_NUMERIC&lt;/code&gt; Искать этот сквозной модуль и был вызван POSIX :: setlocale (), на символ, используемый для десятичного разделителя в форматированных числах с плавающей запятой, влияет &lt;code&gt;LC_NUMERIC&lt;/code&gt; локали LC_NUMERIC . См. &lt;a href=&quot;../perllocale&quot;&gt;Perllocale&lt;/a&gt; и &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="756e8875e122c06649638568056dc5b432d11a8e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;exp(x) - 1&lt;/code&gt;, but more precise for small argument values [C99].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c725f59de42f50ead6905d172ab4b7ba28d808a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;log(1 + x)&lt;/code&gt;, but more stable results for small argument values [C99].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3145a78dd9afcf2f738531a37fc2117722087949" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;print FILEHANDLE sprintf(FORMAT, LIST)&lt;/code&gt;, except that &lt;a href=&quot;perlvar#%24%5C&quot;&gt;&lt;code&gt;$\&lt;/code&gt;&lt;/a&gt; (the output record separator) is not appended. The FORMAT and the LIST are actually parsed as a single list. The first argument of the list will be interpreted as the &lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt; format. This means that &lt;code&gt;printf(@_)&lt;/code&gt; will use &lt;code&gt;$_[0]&lt;/code&gt; as the format. See &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;sprintf&lt;/a&gt; for an explanation of the format argument. If &lt;code&gt;use locale&lt;/code&gt; (including &lt;code&gt;use locale ':not_characters'&lt;/code&gt;) is in effect and &lt;a href=&quot;posix#setlocale&quot;&gt;&lt;code&gt;POSIX::setlocale&lt;/code&gt;&lt;/a&gt; has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale setting. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b67359eada935d408cfee6f1b32b93eb73c3ef" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sqrt(x * x + y * y)&lt;/code&gt; except more stable on very large or very small arguments [C99].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b647b2f27ee1659c31db9d984b63f0b9e63a18" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sv_setsv(sv, &amp;amp;PL_sv_undef)&lt;/code&gt;, but more efficient. Doesn't handle set magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4e0dc744110e721ecf88197993cbcc2b45d001" translate="yes" xml:space="preserve">
          <source>Equivalent to Perl code &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $gv&lt;/code&gt; .</source>
          <target state="translated">Эквивалентно коду Perl &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $gv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ac49f4bdd12fc964afb5f8290211f9aa65a79c7" translate="yes" xml:space="preserve">
          <source>Equivalent to Perl code &lt;code&gt;local $gv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876fc7d247587a71d98917cb3c3453fd65fea359" translate="yes" xml:space="preserve">
          <source>Equivalent to running mktemp() with $dir/$prefixXXXXXXXX (using unix file convention as an example)</source>
          <target state="translated">Эквивалент запуску mktemp()с $dir/$prefixXXXXXX (на примере unix-файла).</target>
        </trans-unit>
        <trans-unit id="4dba35bcd4ac839e52783da10b5058566f3e3b91" translate="yes" xml:space="preserve">
          <source>Equivalent to specifying a DIR of &quot;File::Spec-&amp;gt;tmpdir&quot;, writing the file into the same temporary directory as would be used if no template was specified at all.</source>
          <target state="translated">Эквивалентно указанию DIR &quot;File :: Spec-&amp;gt; tmpdir&quot;, запись файла в тот же временный каталог, который использовался бы, если бы шаблон не был указан вообще.</target>
        </trans-unit>
        <trans-unit id="bb3d71a18fde90428e21cf7d4198ea242cfa57c5" translate="yes" xml:space="preserve">
          <source>Equivalent to the &lt;a href=&quot;#-C-%5Bnumber%2Flist%5D&quot;&gt;-C&lt;/a&gt; command-line switch. Note that this is not a boolean variable. Setting this to &lt;code&gt;&quot;1&quot;&lt;/code&gt; is not the right way to &quot;enable Unicode&quot; (whatever that would mean). You can use &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &quot;disable Unicode&quot;, though (or alternatively unset PERL_UNICODE in your shell before starting Perl). See the description of the &lt;a href=&quot;#-C-%5Bnumber%2Flist%5D&quot;&gt;-C&lt;/a&gt; switch for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a667e4f94596d8444896d0c578ec8dad154ae9ae" translate="yes" xml:space="preserve">
          <source>Equivalent to the &lt;b&gt;-C&lt;/b&gt; command-line switch. Note that this is not a boolean variable. Setting this to &lt;code&gt;&quot;1&quot;&lt;/code&gt; is not the right way to &quot;enable Unicode&quot; (whatever that would mean). You can use &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &quot;disable Unicode&quot;, though (or alternatively unset PERL_UNICODE in your shell before starting Perl). See the description of the &lt;b&gt;-C&lt;/b&gt; switch for more information.</source>
          <target state="translated">Эквивалентен переключателю командной строки &lt;b&gt;-C&lt;/b&gt; . Обратите внимание, что это не логическая переменная. Установка этого параметра на &lt;code&gt;&quot;1&quot;&lt;/code&gt; - неправильный способ &amp;laquo;включить Unicode&amp;raquo; (что бы это ни значило). Вы можете использовать &lt;code&gt;&quot;0&quot;&lt;/code&gt; чтобы &amp;laquo;отключить Unicode&amp;raquo; (или, альтернативно, сбросить PERL_UNICODE в вашей оболочке перед запуском Perl). См. Описание переключателя &lt;b&gt;-C&lt;/b&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="d371f28bfea1e852f448381bb4f0bdfccaa7149e" translate="yes" xml:space="preserve">
          <source>Equivalent to:</source>
          <target state="translated">Эквивалентно:</target>
        </trans-unit>
        <trans-unit id="7cc25c4fa96172ec73030c6c0f3dc9c51687c491" translate="yes" xml:space="preserve">
          <source>Equivalents of</source>
          <target state="translated">Эквиваленты</target>
        </trans-unit>
        <trans-unit id="7ebcf33d0a14ddb91ad477ae52a7af6de25e76c9" translate="yes" xml:space="preserve">
          <source>Er, that's it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0256add701298dc7a17e42cc9eb936d630438581" translate="yes" xml:space="preserve">
          <source>Erases one character. Defined by</source>
          <target state="translated">Стирает один персонаж.Определяется</target>
        </trans-unit>
        <trans-unit id="7c24401b7c6f89af67334e697241400ad5298e5f" translate="yes" xml:space="preserve">
          <source>Erases the current input. Defined by</source>
          <target state="translated">Стирает текущий вход.Определяется</target>
        </trans-unit>
        <trans-unit id="2bfde103fe0a2fc7c857d2e77fed8dacf0bc3d48" translate="yes" xml:space="preserve">
          <source>Eric L. Brine,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b196c5d2b8bc0f57dd78e558fed28f0a83be47" translate="yes" xml:space="preserve">
          <source>Eric Wilhelm &amp;lt;ewilhelm@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3053d2e8a81cd1d9716eddc9ced731b4c51383d" translate="yes" xml:space="preserve">
          <source>Eric Wilhelm @ &amp;lt;ewilhelm at cpan dot org&amp;gt;</source>
          <target state="translated">Эрик Вильгельм @ &amp;lt;ewilhelm at cpan dot org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d8bf3fea74cb51ac9ebccafa9b5bfc9e28b1c902" translate="yes" xml:space="preserve">
          <source>Errno</source>
          <target state="translated">Errno</target>
        </trans-unit>
        <trans-unit id="76cf9c662cbb85bc782a4c519361391afd6f8281" translate="yes" xml:space="preserve">
          <source>Errno - System errno constants</source>
          <target state="translated">Эррно-Системные эррно-константы</target>
        </trans-unit>
        <trans-unit id="27356fe30834096ffaeafbce7b977e0f80915dea" translate="yes" xml:space="preserve">
          <source>Erroneous numbering of =item numbers; they need to ascend consecutively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2f6a15cf8da2b27e5a4af47b58e7ad71c0b3d9" translate="yes" xml:space="preserve">
          <source>Error</source>
          <target state="translated">Error</target>
        </trans-unit>
        <trans-unit id="6cc16f28f695995f841e32ad9be43613256395fe" translate="yes" xml:space="preserve">
          <source>Error Checking</source>
          <target state="translated">Проверка на ошибки</target>
        </trans-unit>
        <trans-unit id="ecbd14ea4e6e17d8a2dc17467fb021874d4a82c9" translate="yes" xml:space="preserve">
          <source>Error Variables</source>
          <target state="translated">Переменные ошибки</target>
        </trans-unit>
        <trans-unit id="cfb1de7f5665b658bcddfda7619c881aef88520a" translate="yes" xml:space="preserve">
          <source>Error checking is, as usual, left as an exercise for the reader.</source>
          <target state="translated">Проверка на ошибки,как обычно,остаётся для читателя упражнением.</target>
        </trans-unit>
        <trans-unit id="da4e40dd69c1ef29292868ee52af685e14566b19" translate="yes" xml:space="preserve">
          <source>Error checking, as always, has been left as an exercise for the reader.</source>
          <target state="translated">Проверка на ошибки,как всегда,осталась для читателя упражнением.</target>
        </trans-unit>
        <trans-unit id="deb19663fe1130ad1a6752c882ecbce1fa91037d" translate="yes" xml:space="preserve">
          <source>Error converting file specification %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1fae3d7127b124ae1e94579e5dd51376530e7b" translate="yes" xml:space="preserve">
          <source>Error handling and messages</source>
          <target state="translated">Обработка ошибок и сообщения</target>
        </trans-unit>
        <trans-unit id="34660817ebc668307d6b9b58b072f03bc4a8634d" translate="yes" xml:space="preserve">
          <source>Error handling is still a work in progress. If the program encounters a problem reading a zip file it is likely to terminate with an unhelpful error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb7b0a0be7d85a55ee74f50c125415c68cb8808" translate="yes" xml:space="preserve">
          <source>Error information specific to the current operating system. At the moment, this differs from &lt;code&gt;$!&lt;/code&gt; under only VMS, OS/2, and Win32 (and for MacPerl). On all other platforms, &lt;code&gt;$^E&lt;/code&gt; is always just the same as &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">Информация об ошибке, относящаяся к текущей операционной системе. На данный момент это отличается от &lt;code&gt;$!&lt;/code&gt; только под VMS, OS / 2 и Win32 (и для MacPerl). На всех других платформах &lt;code&gt;$^E&lt;/code&gt; всегда совпадает с &lt;code&gt;$!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f630bce8e4480d279f4c43b7f93e39940eec25e0" translate="yes" xml:space="preserve">
          <source>Error information specific to the current operating system. At the moment, this differs from &lt;code&gt;&lt;a href=&quot;#%24%21&quot;&gt;&quot;$!&quot;&lt;/a&gt;&lt;/code&gt; under only VMS, OS/2, and Win32 (and for MacPerl). On all other platforms, &lt;code&gt;$^E&lt;/code&gt; is always just the same as &lt;code&gt;$!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915cf7d6fb5fed9ebc1249138f0ba313553fae0a" translate="yes" xml:space="preserve">
          <source>Error message &quot;No error definitions found&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36186555ca5a85354d834f18239bd5446de015bb" translate="yes" xml:space="preserve">
          <source>Error message text from the last failed DynaLoader function. Note that, similar to errno in unix, a successful function call does not reset this message.</source>
          <target state="translated">Текст сообщения об ошибке из последней неудачной функции DynaLoader.Обратите внимание,что,как и errno в unix,успешный вызов функции не сбрасывает это сообщение.</target>
        </trans-unit>
        <trans-unit id="50134ffbfcda43f0c3168aa2876061d57b69c6ae" translate="yes" xml:space="preserve">
          <source>Error results (warning and fatal) contain:</source>
          <target state="translated">Результаты ошибок (предупреждение и смертельный исход)содержат:</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="e722317f0272c736783202d0439c1a84302bd3c9" translate="yes" xml:space="preserve">
          <source>Errors in rendering (non-existent function-name, non-existent coderef) are written to the STDOUT, or wherever you've set it via walk_output().</source>
          <target state="translated">Ошибки в рендеринге (несуществующее имя функции,несуществующий код)записываются в STDOUT,или где бы вы его ни установили с помощью функции walk_output().</target>
        </trans-unit>
        <trans-unit id="da8460251cea0573bc6a64a9a743976f334f7752" translate="yes" xml:space="preserve">
          <source>Errors set by Winsock functions are now put directly into &lt;code&gt;$^E&lt;/code&gt;, and the relevant &lt;code&gt;WSAE*&lt;/code&gt; error codes are now exported from the &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; modules for testing this against.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0934c88916cf6f7537fb99e4833669f3818f9855" translate="yes" xml:space="preserve">
          <source>Errors using the various *style* calls, and bad args to walk_output(), result in die(). Use an eval if you wish to catch these errors and continue processing.</source>
          <target state="translated">Ошибки,использующие различные вызовы *style*,и плохие аргументы для функции walk_output(),приводят к тому,что функция die().Используйте eval,если хотите отловить эти ошибки и продолжить обработку.</target>
        </trans-unit>
        <trans-unit id="2a3a3e693d223668963c1734745a9c3d61b5507c" translate="yes" xml:space="preserve">
          <source>Eryq (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7b714d8f396c877eacf7d3ad661cfe313a3efe9" translate="yes" xml:space="preserve">
          <source>Escape backslashes (&lt;code&gt;\&lt;/code&gt;) in prototype strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa094bf265d4ea86b5f894d7a380cedfb2baed9e" translate="yes" xml:space="preserve">
          <source>Escape sequences</source>
          <target state="translated">Побеговые последовательности</target>
        </trans-unit>
        <trans-unit id="a95db9b35f0577a2b6c8dd20cb8afa6149f7b7b9" translate="yes" xml:space="preserve">
          <source>Escapes a given code source name (typically a file name but can also be a command that was read from) so that double-quotes and backslashes are escaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa6da9272c9b7871ca718b60455b77d2d266044" translate="yes" xml:space="preserve">
          <source>Escapes all &lt;code&gt;$&lt;/code&gt; so they are not interpreted as make variables.</source>
          <target state="translated">Экранирует все &lt;code&gt;$&lt;/code&gt; , поэтому они не интерпретируются как переменные make.</target>
        </trans-unit>
        <trans-unit id="d630054693cd8886f832682006b6bb07e97c811d" translate="yes" xml:space="preserve">
          <source>Escapes at most the first &quot;count&quot; chars of pv and puts the results into dsv such that the size of the escaped string will not exceed &quot;max&quot; chars and will not contain any incomplete escape sequences. The number of bytes escaped will be returned in the STRLEN *escaped parameter if it is not null. When the dsv parameter is null no escaping actually occurs, but the number of bytes that would be escaped were it not null will be calculated.</source>
          <target state="translated">Побеждает максимум на первых &quot;счетных&quot; графиках pv и помещает результаты в dsv таким образом,чтобы размер экранированной строки не превышал &quot;макс.&quot; графиков и не содержал незавершенных экранирующих последовательностей.Количество байт экранированной строки будет возвращено в параметре STRLEN *escaped,если оно не нулевое.Когда параметр dsv равен нулю,экранирование на самом деле не происходит,но количество байт,которое было бы экранировано,если бы оно не было нулевым,будет вычислено.</target>
        </trans-unit>
        <trans-unit id="e9331784f47985d4023ae09824ecf12ebdf39d50" translate="yes" xml:space="preserve">
          <source>Escapes at most the first &lt;code&gt;count&lt;/code&gt; chars of &lt;code&gt;pv&lt;/code&gt; and puts the results into &lt;code&gt;dsv&lt;/code&gt; such that the size of the escaped string will not exceed &lt;code&gt;max&lt;/code&gt; chars and will not contain any incomplete escape sequences. The number of bytes escaped will be returned in the &lt;code&gt;STRLEN *escaped&lt;/code&gt; parameter if it is not null. When the &lt;code&gt;dsv&lt;/code&gt; parameter is null no escaping actually occurs, but the number of bytes that would be escaped were it not null will be calculated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73daf05e61c2f4ceabfe0f8dc9e8bd0fe087922" translate="yes" xml:space="preserve">
          <source>Escapes stray &lt;code&gt;$&lt;/code&gt; so they are not interpreted as make variables.</source>
          <target state="translated">Escape stray &lt;code&gt;$&lt;/code&gt; , поэтому они не интерпретируются как переменные make.</target>
        </trans-unit>
        <trans-unit id="92b417d4a5ce0ac686aeee5640af004624297a4e" translate="yes" xml:space="preserve">
          <source>Especially &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;.</source>
          <target state="translated">Особенно &lt;a href=&quot;bignum&quot;&gt;бигнум&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51e6f8fb1216de07279b7184fe32486c4afcbbd5" translate="yes" xml:space="preserve">
          <source>Especially &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; as in &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; .</source>
          <target state="translated">Особенно &lt;a href=&quot;bigrat&quot;&gt;bigrat,&lt;/a&gt; как в &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcd99d9147aed607626e5d2c3fbf27fa8eaba872" translate="yes" xml:space="preserve">
          <source>Especially &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; as in &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; and &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt; as in &lt;code&gt;perl -Mbignum -le 'print sqrt(2)'&lt;/code&gt; .</source>
          <target state="translated">Особенно &lt;a href=&quot;bigrat&quot;&gt;bigrat,&lt;/a&gt; как в &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; &lt;a href=&quot;bignum&quot;&gt;1/4 &lt;/a&gt;' и bignum, как в &lt;code&gt;perl -Mbignum -le 'print sqrt(2)'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5485ef59e2abd6d9fec5641c427b8c1a89ee861e" translate="yes" xml:space="preserve">
          <source>Essentially this is the same as the &lt;code&gt;__LINE__&lt;/code&gt; macro, but the &lt;code&gt;line_num(+3)&lt;/code&gt; idiom is arguably nicer.</source>
          <target state="translated">По сути, это то же самое, что и макрос &lt;code&gt;__LINE__&lt;/code&gt; , но &lt;code&gt;line_num(+3)&lt;/code&gt; возможно, лучше.</target>
        </trans-unit>
        <trans-unit id="0c6dff48b0f039b109420e87e1e42abbab8710f8" translate="yes" xml:space="preserve">
          <source>Establish an ISA relationship with base classes at compile time</source>
          <target state="translated">Установите отношения ISA с базовыми классами во время компиляции.</target>
        </trans-unit>
        <trans-unit id="576347ec826f38428d8c8a6f8ec4acb2bceab911" translate="yes" xml:space="preserve">
          <source>Europe</source>
          <target state="translated">Europe</target>
        </trans-unit>
        <trans-unit id="aa9b05a82a74755dccc358002821ca69d31c5e54" translate="yes" xml:space="preserve">
          <source>European Computer Manufacturers Association &lt;a href=&quot;http://www.ecma.ch&quot;&gt;http://www.ecma.ch&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0309a3b568036fa350070f80c5e87dff1124fc90" translate="yes" xml:space="preserve">
          <source>Eval the codeblock, return success or failure, and the error message. This code protects $@ and $!, they will be restored by the end of the run. This code also temporarily blocks $SIG{DIE} handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57720a74163f29f2034ea0831d9223b2072fcf53" translate="yes" xml:space="preserve">
          <source>Eval-group in insecure regular expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de6a23b74739863fdcb66dba07f712f221ab630" translate="yes" xml:space="preserve">
          <source>Eval-group not allowed at runtime, use re 'eval' in regex m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fc4317afc6d18f75173c8034624de946965f7e" translate="yes" xml:space="preserve">
          <source>Eval-group not allowed, use re 'eval' in regex m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15622021802352824cd00f0a03614ec0fdf9d50b" translate="yes" xml:space="preserve">
          <source>Evaluates EXPR and exits immediately with that value. Example:</source>
          <target state="translated">Оценивает EXPR и немедленно выходит с этим значением.Пример:</target>
        </trans-unit>
        <trans-unit id="c44b93a0add3946a941d2db7675bb524bcd7719a" translate="yes" xml:space="preserve">
          <source>Evaluates its expression in list context and dumps out the result in a pretty-printed fashion. Nested data structures are printed out recursively, unlike the real &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function in Perl. When dumping hashes, you'll probably prefer 'x \%h' rather than 'x %h'. See &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; if you'd like to do this yourself.</source>
          <target state="translated">Оценивает свое выражение в контексте списка и выводит результат в красивой печатной форме. Вложенные структуры данных распечатываются рекурсивно, в отличие от реальной функции &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; в Perl. При сбросе хешей вы, вероятно, предпочтете &amp;laquo;x \% h&amp;raquo;, а не &amp;laquo;x% h&amp;raquo;. См. &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue,&lt;/a&gt; если вы хотите сделать это самостоятельно.</target>
        </trans-unit>
        <trans-unit id="a5bd312d1ed9e2d998f61c992d1949d05f3189c8" translate="yes" xml:space="preserve">
          <source>Evaluates its expression in list context and dumps out the result in a pretty-printed fashion. Nested data structures are printed out recursively, unlike the real &lt;code&gt;print&lt;/code&gt; function in Perl. When dumping hashes, you'll probably prefer 'x \%h' rather than 'x %h'. See &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; if you'd like to do this yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac54d42c3ebf7c1eb1985e5c37def23568be458" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; to each element) and composes a list of the results of each such evaluation. Each element of LIST may produce zero, one, or more elements in the generated list, so the number of elements in the generated list may differ from that in LIST. In scalar context, returns the total number of elements so generated. In list context, returns the generated list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6b463c629f711f381a6e44374ee5717c9b5851" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; to each element) and returns the list value consisting of those elements for which the expression evaluated to true. In scalar context, returns the number of times the expression was true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eee27e1be9e7d28580a29bfa24323cac2b1efa9" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;code&gt;$_&lt;/code&gt; to each element) and returns the list value composed of the results of each such evaluation. In scalar context, returns the total number of elements so generated. Evaluates BLOCK or EXPR in list context, so each element of LIST may produce zero, one, or more elements in the returned value.</source>
          <target state="translated">Оценивает BLOCK или EXPR для каждого элемента LIST (локально устанавливая &lt;code&gt;$_&lt;/code&gt; для каждого элемента) и возвращает значение списка, состоящее из результатов каждой такой оценки. В скалярном контексте возвращает общее количество сгенерированных элементов. Оценивает BLOCK или EXPR в контексте списка, поэтому каждый элемент LIST может создавать ноль, один или несколько элементов в возвращаемом значении.</target>
        </trans-unit>
        <trans-unit id="e159565a978e2dbd25deef6d431807eb47abbd14" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;code&gt;$_&lt;/code&gt; to each element) and returns the list value consisting of those elements for which the expression evaluated to true. In scalar context, returns the number of times the expression was true.</source>
          <target state="translated">Оценивает BLOCK или EXPR для каждого элемента LIST (локально устанавливая &lt;code&gt;$_&lt;/code&gt; для каждого элемента) и возвращает значение списка, состоящее из тех элементов, для которых выражение было оценено как истинное. В скалярном контексте возвращает, сколько раз выражение было истинным.</target>
        </trans-unit>
        <trans-unit id="cf5a5afbdf639c60540cb29b1afb8482a4c27513" translate="yes" xml:space="preserve">
          <source>Evaluates the hash in scalar context and returns the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb27bcd152d36bb6aa40c050f7aa6bc064a148c" translate="yes" xml:space="preserve">
          <source>Evaluates the hash in scalar context and returns the result. Handles magic when the hash is tied.</source>
          <target state="translated">Оценивает хэш в скалярном контексте и возвращает результат.Обрабатывает магию,когда хэш связан.</target>
        </trans-unit>
        <trans-unit id="4e9ac4c1ee356b0a19d18eecf82ac765b9101304" translate="yes" xml:space="preserve">
          <source>Evaluates the passed SV. Result handling is done the same as for &lt;code&gt;call_sv()&lt;/code&gt; etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808c33dddbb9e00ae9c3a4845059fe43368d7b0a" translate="yes" xml:space="preserve">
          <source>Evaluates to 0xFFFD, the code point of the Unicode REPLACEMENT CHARACTER</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c62a6c57ccf104ad2d41815aed270108351d20" translate="yes" xml:space="preserve">
          <source>Evaluates to 1 if the byte &lt;code&gt;c&lt;/code&gt; represents the same character when encoded in UTF-8 as when not; otherwise evaluates to 0. UTF-8 invariant characters can be copied as-is when converting to/from UTF-8, saving time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100562c78d7cbca55f4722b4014576ae868df4e3" translate="yes" xml:space="preserve">
          <source>Evaluates to 1 if the representation of code point &lt;code&gt;cp&lt;/code&gt; is the same whether or not it is encoded in UTF-8; otherwise evaluates to 0. UTF-8 invariant characters can be copied as-is when converting to/from UTF-8, saving time. &lt;code&gt;cp&lt;/code&gt; is Unicode if above 255; otherwise is platform-native.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb14ed1a5da1a7d197c5bfa2c110468f119a341" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE if the plain locale pragma without a parameter (&lt;code&gt;use locale&lt;/code&gt;) is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f226763df7ae244c2d5731a8cec87c6ad68b9c" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE if, when compiling a perl program (including an &lt;code&gt;eval&lt;/code&gt;) if the plain locale pragma without a parameter (&lt;code&gt;use locale&lt;/code&gt;) is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f195a4b1422deea528999a2aea4d2e3abe0a2cb0" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE if, when executing a perl program (including an &lt;code&gt;eval&lt;/code&gt;) if the plain locale pragma without a parameter (&lt;code&gt;use locale&lt;/code&gt;) is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b7efdaaae8c2d5acf037415de9e55f35d46853a" translate="yes" xml:space="preserve">
          <source>Evaluates to a list of the words extracted out of</source>
          <target state="translated">Оценивает до списка слов,извлеченных из</target>
        </trans-unit>
        <trans-unit id="d65f4596e5b21853db6815029e47b4d12178eb0e" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8 that represents one of the Unicode non-character code points; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ba361513dd4325cee403415d7567ac05c0deb6" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8 that represents one of the Unicode surrogate code points; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b4e5bdfedcccceafa909bcd677f735ead45367" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8 that represents some Unicode code point completely acceptable for open interchange between all applications; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation. Any bytes remaining before &lt;code&gt;e&lt;/code&gt;, but beyond the ones needed to form the first code point in &lt;code&gt;s&lt;/code&gt;, are not examined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="394362d7a28197545d54a3464886ae1b442e8f27" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8 that represents some Unicode non-surrogate code point; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation. Any bytes remaining before &lt;code&gt;e&lt;/code&gt;, but beyond the ones needed to form the first code point in &lt;code&gt;s&lt;/code&gt;, are not examined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5579ca82ad3ea408feb922437fb3356d093b24" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8, as extended by Perl, that represents some code point, subject to the restrictions given by &lt;code&gt;flags&lt;/code&gt;; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation. Any bytes remaining before &lt;code&gt;e&lt;/code&gt;, but beyond the ones needed to form the first code point in &lt;code&gt;s&lt;/code&gt;, are not examined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70279dc7ca9469f018e588c174a215d906087c5" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8, as extended by Perl, that represents some code point; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation. Any bytes remaining before &lt;code&gt;e&lt;/code&gt;, but beyond the ones needed to form the first code point in &lt;code&gt;s&lt;/code&gt;, are not examined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f4958a116f001f9e79787b5473e92c45467956" translate="yes" xml:space="preserve">
          <source>Evaluating a Perl statement from your C program</source>
          <target state="translated">Оценка Perl заявления от вашей программы на C</target>
        </trans-unit>
        <trans-unit id="fdfaa902629988731ecf820e3310a76ecb105be5" translate="yes" xml:space="preserve">
          <source>Evaluating perl code (e.g. via &quot;eval&quot; or &quot;do 'file'&quot;) causes the code to be compiled into an internal format and then, provided there was no error in the compilation, executed. The internal format is based on many distinct</source>
          <target state="translated">Оценка perl кода (например,с помощью &quot;eval&quot; или &quot;do 'file'&quot;)приводит к тому,что код компилируется во внутренний формат,а затем,при условии отсутствия ошибок в компиляции,выполняется.Внутренний формат основан на множестве различных</target>
        </trans-unit>
        <trans-unit id="e1f930d87a7c101ffac9391f41733ff5b3321f0a" translate="yes" xml:space="preserve">
          <source>Even &lt;code&gt;$x += 5&lt;/code&gt; or &lt;code&gt;$x++&lt;/code&gt; are not guaranteed to be atomic.</source>
          <target state="translated">Даже &lt;code&gt;$x += 5&lt;/code&gt; или &lt;code&gt;$x++&lt;/code&gt; не могут быть атомарными.</target>
        </trans-unit>
        <trans-unit id="459a068431296abdc9a0ee020cbb72e87da92588" translate="yes" xml:space="preserve">
          <source>Even after they stabilize, some tests may fail.</source>
          <target state="translated">Даже после того,как они стабилизируются,некоторые тесты могут провалиться.</target>
        </trans-unit>
        <trans-unit id="1dd817d2a76ad639afa2f373c6b0e32abc7df4b3" translate="yes" xml:space="preserve">
          <source>Even if a certain letter is tailored, its equivalent would not always tailored as well as it. For example, even though W is tailored, fullwidth W (&lt;code&gt;U+FF37&lt;/code&gt;), W with acute (&lt;code&gt;U+1E82&lt;/code&gt;), etc. are not tailored. The result may depend on whether source strings are normalized or not, and whether decomposed or composed. Thus &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt; is less preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014c0223d524d2f9046bd74912b924b926ef1dba" translate="yes" xml:space="preserve">
          <source>Even if a module is thread-safe, it doesn't mean that the module is optimized to work well with threads. A module could possibly be rewritten to utilize the new features in threaded Perl to increase performance in a threaded environment.</source>
          <target state="translated">Даже если модуль является потоково-безопасным,это не означает,что он оптимизирован для хорошей работы с потоками.Модуль может быть переписан,чтобы использовать новые возможности в потоковом Perl для повышения производительности в потоковой среде.</target>
        </trans-unit>
        <trans-unit id="ea9410fd8b85c13558ab2ec195f440b39ef94e1e" translate="yes" xml:space="preserve">
          <source>Even if a prototype is available at compile time, the body of the subroutine is not (it hasn't been &lt;code&gt;AUTOLOAD&lt;/code&gt; ed yet). perl needs to examine both the &lt;code&gt;()&lt;/code&gt; prototype and the body of a subroutine at compile time to detect that it can safely replace calls to that subroutine with the constant value.</source>
          <target state="translated">Даже если прототип доступен во время компиляции, тело подпрограммы недоступно (оно еще не было &lt;code&gt;AUTOLOAD&lt;/code&gt; ). Perl необходимо проверить как прототип &lt;code&gt;()&lt;/code&gt; ,так и тело подпрограммы во время компиляции, чтобы определить, что он может безопасно заменить вызовы этой подпрограммы постоянным значением.</target>
        </trans-unit>
        <trans-unit id="732edb0c232306cf9f713f481702d02637baa9d1" translate="yes" xml:space="preserve">
          <source>Even if a prototype is available at compile time, the body of the subroutine is not (it hasn't been &lt;code&gt;AUTOLOAD&lt;/code&gt;ed yet). perl needs to examine both the &lt;code&gt;()&lt;/code&gt; prototype and the body of a subroutine at compile time to detect that it can safely replace calls to that subroutine with the constant value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e9d9a1a7409534a2957addc0cb2ac7a35e101e4" translate="yes" xml:space="preserve">
          <source>Even if no</source>
          <target state="translated">Даже если нет</target>
        </trans-unit>
        <trans-unit id="9a52563c6b228851d7bd722e9df68900d397ecd2" translate="yes" xml:space="preserve">
          <source>Even if there are no groupings in a regexp, it is still possible to find out what exactly matched in a string. If you use them, Perl will set &lt;code&gt;$`&lt;/code&gt; to the part of the string before the match, will set &lt;code&gt;$&amp;amp;&lt;/code&gt; to the part of the string that matched, and will set &lt;code&gt;$'&lt;/code&gt; to the part of the string after the match. An example:</source>
          <target state="translated">Даже если в регулярном выражении нет группировок, все равно можно узнать, что именно соответствует в строке. Если вы их используете, Perl установит &lt;code&gt;$`&lt;/code&gt; как часть строки перед совпадением, установит &lt;code&gt;$&amp;amp;&lt;/code&gt; как часть совпавшей строки и установит &lt;code&gt;$'&lt;/code&gt; как часть строки после совпадения. Пример:</target>
        </trans-unit>
        <trans-unit id="d0239289e914ec51bf43e7158f9d72ad004bea40" translate="yes" xml:space="preserve">
          <source>Even if you aren't in doubt, consider the mental welfare of the person who has to maintain the code after you, and who will probably put parentheses in the wrong place.</source>
          <target state="translated">Даже если вы не сомневаетесь,подумайте о психическом благополучии человека,который должен поддерживать код после вас,и который,скорее всего,поставит скобки не в то место.</target>
        </trans-unit>
        <trans-unit id="2698b39349f79453a318cb744bc9cc6aed1c6f70" translate="yes" xml:space="preserve">
          <source>Even if you don't currently make use of the API interface, it is still worth reading it.</source>
          <target state="translated">Даже если вы в данный момент не пользуетесь API интерфейсом,все равно стоит его прочитать.</target>
        </trans-unit>
        <trans-unit id="7c8671eab5d7a940c940da36a9cbcdd6d20bec94" translate="yes" xml:space="preserve">
          <source>Even if you don't want to modify an array, this mechanism is useful for passing multiple arrays in a single LIST, because normally the LIST mechanism will merge all the array values so that you can't extract out the individual arrays. For more on typeglobs, see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;&quot;Typeglobs and Filehandles&quot; in perldata&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11193f6fb31e4425ba4f294d83acb0ef83b5308c" translate="yes" xml:space="preserve">
          <source>Even if you don't want to modify an array, this mechanism is useful for passing multiple arrays in a single LIST, because normally the LIST mechanism will merge all the array values so that you can't extract out the individual arrays. For more on typeglobs, see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs and Filehandles in perldata&lt;/a&gt;.</source>
          <target state="translated">Даже если вы не хотите изменять массив, этот механизм полезен для передачи нескольких массивов в один СПИСОК, поскольку обычно механизм СПИСОК объединяет все значения массива, так что вы не можете извлечь отдельные массивы. Дополнительные сведения о typeglobs см. В разделе &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs и Filehandles в perldata&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="704c6dd5d66c1d05562f24b58fe540e4c1622bbc" translate="yes" xml:space="preserve">
          <source>Even in a pattern that is interpolated and compiled at run-time, literal code blocks will be compiled once, at perl compile time; the following prints &quot;ABCD&quot;:</source>
          <target state="translated">Даже в паттерне,который интерполирован и скомпилирован во время выполнения,буквальные блоки кода будут скомпилированы один раз,во время компиляции perl;далее будет выведено &quot;ABCD&quot;:</target>
        </trans-unit>
        <trans-unit id="f9a57fec05cf4b4012f5962aa352266b10461d68" translate="yes" xml:space="preserve">
          <source>Even more drastic example of a process-scope change is &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt;: the root directory of all the threads changes, and no thread can undo it (as opposed to &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Еще более радикальным примером изменения области действия процесса является &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt; : изменяется корневой каталог всех потоков, и ни один поток не может отменить его (в отличие от &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d47488f3c7fd4b4fcceda28125544a987450d2a0" translate="yes" xml:space="preserve">
          <source>Even more drastic example of a process-scope change is &lt;code&gt;chroot()&lt;/code&gt;: the root directory of all the threads changes, and no thread can undo it (as opposed to &lt;code&gt;chdir()&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fba46823e424c4e147c0d6ca9c73a6300bf0908c" translate="yes" xml:space="preserve">
          <source>Even numbered minor versions (5.14, 5.16, 5.18) are production versions, and odd numbered minor versions (5.15, 5.17, 5.19) are development versions. Unless you want to try out an experimental feature, you probably never want to install a development version of Perl.</source>
          <target state="translated">Даже пронумерованные второстепенные версии (5.14,5.16,5.18)являются производственными версиями,а нечетные второстепенные версии (5.15,5.17,5.19)-разработческими версиями.Если вы не хотите опробовать экспериментальную возможность,вы,вероятно,никогда не захотите устанавливать разрабатываемую версию Perl.</target>
        </trans-unit>
        <trans-unit id="985c32669ab9bb43127ab9478cdf373b1b43c14e" translate="yes" xml:space="preserve">
          <source>Even the fallback for &lt;code&gt;decode&lt;/code&gt; must return octets, which are then decoded with the character encoding that &lt;code&gt;decode&lt;/code&gt; accepts. So for example if you wish to decode octets as UTF-8, and use ISO-8859-15 as a fallback for bytes that are not valid UTF-8, you could write</source>
          <target state="translated">Даже резервный вариант для &lt;code&gt;decode&lt;/code&gt; должен возвращать октеты, которые затем декодируются с кодировкой символов, которую принимает &lt;code&gt;decode&lt;/code&gt; . Так, например, если вы хотите декодировать октеты как UTF-8 и использовать ISO-8859-15 в качестве запасного варианта для байтов, которые не являются допустимыми UTF-8, вы можете написать</target>
        </trans-unit>
        <trans-unit id="899cce7279e173a144c83044ba4c75852234efbb" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;dog&lt;/code&gt; is the first alternative in the second regex, &lt;code&gt;cat&lt;/code&gt; is able to match earlier in the string.</source>
          <target state="translated">Несмотря на то, что &lt;code&gt;dog&lt;/code&gt; является первой альтернативой во втором регулярном выражении, &lt;code&gt;cat&lt;/code&gt; может найти более раннее совпадение в строке.</target>
        </trans-unit>
        <trans-unit id="491ac4fd5a527c06bb95d6b29c3d2ceec9e2c0d4" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;dog&lt;/code&gt; is the first alternative in the second regexp, &lt;code&gt;cat&lt;/code&gt; is able to match earlier in the string.</source>
          <target state="translated">Несмотря на то, что &lt;code&gt;dog&lt;/code&gt; является первой альтернативой во втором регулярном выражении, &lt;code&gt;cat&lt;/code&gt; может найти более раннее совпадение в строке.</target>
        </trans-unit>
        <trans-unit id="9e410bea532f43017a3bc057208bf28febe91829" translate="yes" xml:space="preserve">
          <source>Even though HP-UX 10.20 and 11.00 are not actively maintained by HP anymore, updates for the HP ANSI C compiler are still available from time to time, and it might be advisable to see if updates are applicable. At the moment of writing, the latests available patches for 11.00 that should be applied are PHSS_35098, PHSS_35175, PHSS_35100, PHSS_33036, and PHSS_33902). If you have a SUM account, you can use it to search for updates/patches. Enter &quot;ANSI&quot; as keyword.</source>
          <target state="translated">Несмотря на то,что HP-UX 10.20 и 11.00 больше не активно поддерживаются HP,обновления для компилятора HP ANSI C все еще доступны время от времени,и,возможно,было бы желательно проверить,применимы ли эти обновления.На момент написания статьи доступными заплатками для 11.00,которые должны применяться,являются PHSS_35098,PHSS_35175,PHSS_35100,PHSS_33036 и PHSS_33902).Если у вас есть учетная запись SUM,вы можете использовать ее для поиска обновлений/патчей.Введите &quot;ANSI&quot; в качестве ключевого слова.</target>
        </trans-unit>
        <trans-unit id="66ef75af64ac05e5f42a2e25f67b5dd40dad7f74" translate="yes" xml:space="preserve">
          <source>Even though VOS allows the slash character to appear in object names, because the VOS port of Perl interprets it as a pathname delimiting character, VOS files, directories, or links whose names contain a slash character cannot be processed. Such files must be renamed before they can be processed by Perl.</source>
          <target state="translated">Несмотря на то,что VOS позволяет символу косой черты появляться в именах объектов,потому что VOS-порт Perl интерпретирует его как символ,разделяющий патнамы,VOS-файлы,каталоги или ссылки,имена которых содержат символ косой черты,не могут быть обработаны.Такие файлы должны быть переименованы до того,как они будут обработаны Perl.</target>
        </trans-unit>
        <trans-unit id="cdd82719baf99cfe9734df3eaad725f4efdb196d" translate="yes" xml:space="preserve">
          <source>Even though a reference may be declared as a constant, the reference may point to data which may be changed, as this code shows.</source>
          <target state="translated">Даже если ссылка может быть объявлена константой,она может указывать на данные,которые могут быть изменены,как показывает этот код.</target>
        </trans-unit>
        <trans-unit id="6c1ced7503a24a96a968e8abe517680e11868256" translate="yes" xml:space="preserve">
          <source>Even though it doesn't do much, it is still preferable to writing your own classes from scratch.</source>
          <target state="translated">Несмотря на то,что это не так уж и много,все равно предпочтительнее писать свои собственные классы с нуля.</target>
        </trans-unit>
        <trans-unit id="5d86d002ba38ad23c3e6f35071476718335949c5" translate="yes" xml:space="preserve">
          <source>Even though it looks as though they're the same method calls (uid), they aren't, because a &lt;code&gt;File::stat&lt;/code&gt; object is different from a &lt;code&gt;User::pwent&lt;/code&gt; object.</source>
          <target state="translated">Хотя кажется, что это одни и те же вызовы методов (uid), это не так, потому что объект &lt;code&gt;File::stat&lt;/code&gt; отличается от объекта &lt;code&gt;User::pwent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dc6e1961fe501af8f7b8e43fd427c0320c933fd" translate="yes" xml:space="preserve">
          <source>Even though some of this section may not be understandable to you on first reading, we think it's important enough to highlight some of the gotchas before delving further, so here goes:</source>
          <target state="translated">Несмотря на то,что некоторые из этих разделов могут быть непонятны вам в первом чтении,мы считаем,что достаточно важно выделить некоторые из гетч,прежде чем углубляться в них,так что вот,пожалуйста:</target>
        </trans-unit>
        <trans-unit id="a15d3a1eac0736a5f4619bbd0fabeec7d4b2fc07" translate="yes" xml:space="preserve">
          <source>Even though these two matches might be thought of as complements, until v5.20 they were so only on Unicode code points.</source>
          <target state="translated">Несмотря на то,что эти два совпадения можно было бы считать дополнениями,до версии 5.20 они были таковыми только в точках кода Юникода.</target>
        </trans-unit>
        <trans-unit id="763ed71064b10dfe0eadc8f471bf100bdbc4763d" translate="yes" xml:space="preserve">
          <source>Even though with normal text files a &quot;\n&quot; will do the trick, there is still no unified scheme for terminating a line that is portable between Unix, DOS/Win, and Macintosh, except to terminate</source>
          <target state="translated">Несмотря на то,что с обычными текстовыми файлами подойдет &quot;\n&quot;,до сих пор нет унифицированной схемы завершения строки,переносимой между Unix,DOS/Win и Macintosh,кроме как для завершения</target>
        </trans-unit>
        <trans-unit id="4630d8c85d1750185c25d65fe850b66a19d12625" translate="yes" xml:space="preserve">
          <source>Even though you started with a completely empty hash, after that call to &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; you've created the structure you needed to check for &lt;code&gt;key3&lt;/code&gt; :</source>
          <target state="translated">Несмотря на то, что вы начали с полностью пустым хешем, после этого вызова to &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; вы создали структуру, необходимую для проверки &lt;code&gt;key3&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="65c079978ec4f4cfbd582b4959b8aaf4fe2b2dbe" translate="yes" xml:space="preserve">
          <source>Even though you started with a completely empty hash, after that call to &lt;code&gt;exists&lt;/code&gt; you've created the structure you needed to check for &lt;code&gt;key3&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c088010f5560d49366ca00a6983df9e83535cb" translate="yes" xml:space="preserve">
          <source>Even when on a single platform (if you can call Unix a single platform), remember not to count on the existence or the contents of particular system-specific files or directories, like</source>
          <target state="translated">Даже если вы работаете на одной платформе (если вы можете называть Unix одной платформой),не забывайте рассчитывать на существование или содержание конкретных системных файлов или каталогов,таких как</target>
        </trans-unit>
        <trans-unit id="1602f4d9817a3dceaa33d17e6c176137283825a5" translate="yes" xml:space="preserve">
          <source>Even with all this work, regexp matching happens remarkably fast. To speed things up, Perl compiles the regexp into a compact sequence of opcodes that can often fit inside a processor cache. When the code is executed, these opcodes can then run at full throttle and search very quickly.</source>
          <target state="translated">Даже при всей этой работе,повторное сопоставление происходит удивительно быстро.Чтобы ускорить процесс,Perl компилирует регеxp в компактную последовательность опкодов,которые часто могут поместиться в кэш процессора.Когда код выполняется,эти опкоды могут затем работать на полном ходу и очень быстро выполнять поиск.</target>
        </trans-unit>
        <trans-unit id="35946850beee8b541477d17361e646c61666892c" translate="yes" xml:space="preserve">
          <source>Even with the latest version of Perl, it is known that certain constructs with threads may result in warning messages concerning leaked scalars or unreferenced scalars. However, such warnings are harmless, and may safely be ignored.</source>
          <target state="translated">Даже в последней версии Perl известно,что некоторые конструкции с потоками могут приводить к предупреждающим сообщениям об утечках скаляров или о наличии не связанных со связью скаляров.Однако такие предупреждения безвредны и могут быть безопасно проигнорированы.</target>
        </trans-unit>
        <trans-unit id="878e531bfbade13b1bab65a888ae7d4bdc1140e8" translate="yes" xml:space="preserve">
          <source>Event Log</source>
          <target state="translated">Журнал событий</target>
        </trans-unit>
        <trans-unit id="d3032d704e23194c50435cf4a6371b080589c4eb" translate="yes" xml:space="preserve">
          <source>Event driven.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1394956111c7856f6f7f78713d6c0aa968cc8b" translate="yes" xml:space="preserve">
          <source>Event for TAP version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb79b9266fc643c28f6d3ecc5b6b3731a8786707" translate="yes" xml:space="preserve">
          <source>Event for a simple failed assertion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd541c73c6d801e12ef6ab2a2ef6eeb8678fe31" translate="yes" xml:space="preserve">
          <source>Event for a simple passing assertion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cbb1e51381ea5f156ee24e974d0e8c3d15bb5e6" translate="yes" xml:space="preserve">
          <source>Event for subtest types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa125b31576ec16d1e191efd5ca768b2aa4efa32" translate="yes" xml:space="preserve">
          <source>Event package name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="3cece53956ddc248529397d0c65ecaab5ebb07b6" translate="yes" xml:space="preserve">
          <source>Events live under this namespace. It is considered acceptable for third party distributions to add new event types in this namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50edb0cf580f75f4a0fea837a24e96eb1cff3aca" translate="yes" xml:space="preserve">
          <source>Events use this facet when they need to set the plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b8ce2e1404f72b01628a7fbd8afce9a0ca4416" translate="yes" xml:space="preserve">
          <source>Events within a buffered subtest may or may not be sent to the formatter as they happen. If a formatter fails to specify then the default is to &lt;b&gt;NOT SEND&lt;/b&gt; the events as they are generated, instead the formatter can pull them from the &lt;code&gt;subevents&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4538af23a815bef65c32e32809e639186875a9f" translate="yes" xml:space="preserve">
          <source>Eventually, with better documentation and possible some cleanup, this could be part of &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d002601ef62e11979d8b7c94cd10d54da0d3a8e1" translate="yes" xml:space="preserve">
          <source>Ever wanted to know what a regex looked like? You'll need perl compiled with the DEBUGGING flag for this one:</source>
          <target state="translated">Когда-нибудь хотел узнать,как выглядит регекс? Для этого вам понадобится Perl,скомпилированный с флагом DEBUGGING:</target>
        </trans-unit>
        <trans-unit id="d845fa7f9ca71d8879b9cc1aee98930cd966bdbd" translate="yes" xml:space="preserve">
          <source>Every CPAN module has a bug tracker set up in RT, &lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt;. You can submit bugs to RT either through its web interface or by email. To email a bug report, send it to bug-&amp;lt;distribution-name&amp;gt;@rt.cpan.org . For example, if you wanted to report a bug in &lt;a href=&quot;Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, you could send a message to bug-Business-ISBN@rt.cpan.org .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc9126b1847307a5366bc653e3a3467f58a3dfa" translate="yes" xml:space="preserve">
          <source>Every CPAN module has a bug tracker set up in RT, &lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt;. You can submit bugs to RT either through its web interface or by email. To email a bug report, send it to bug-&amp;lt;distribution-name&amp;gt;@rt.cpan.org . For example, if you wanted to report a bug in &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, you could send a message to bug-Business-ISBN@rt.cpan.org .</source>
          <target state="translated">В каждом модуле CPAN настроен трекер ошибок в RT, &lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt; . Вы можете отправлять сообщения об ошибках в RT либо через его веб-интерфейс, либо по электронной почте. Чтобы отправить отчет об ошибке по электронной почте, отправьте его на адрес bug- &amp;lt;distribution-name&amp;gt; @ rt.cpan.org. Например, если вы хотите сообщить об ошибке в &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business :: ISBN&lt;/a&gt; , вы можете отправить сообщение по адресу bug-Business-ISBN@rt.cpan.org.</target>
        </trans-unit>
        <trans-unit id="b8dc7000ca1bb13ca17faed27406eccbd7bcf88b" translate="yes" xml:space="preserve">
          <source>Every Makefile.PL is run by perl in a separate process. Likewise we run 'make' and 'make install' in separate processes. If you have any parameters (e.g. PREFIX, UNINST or the like) you want to pass to the calls, please specify them here.</source>
          <target state="translated">Каждый Makefile.PL запускается на perl в отдельном процессе.Аналогично мы запускаем 'make' и 'make install' в отдельных процессах.Если у вас есть какие-либо параметры (например,PREFIX,UNINST или подобные),которые вы хотите передать на вызовы,пожалуйста,укажите их здесь.</target>
        </trans-unit>
        <trans-unit id="5243f64d154762b9f500ff300bf1242e41c19e00" translate="yes" xml:space="preserve">
          <source>Every Unicode character is assigned a general category, which is the &quot;most usual categorization of a character&quot; (from &lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt;).</source>
          <target state="translated">Каждому символу Юникода назначается общая категория, которая является &amp;laquo;самой обычной категоризацией символа&amp;raquo; (из &lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="44bc5eca50d1bb33525106b332f679e0c37967c9" translate="yes" xml:space="preserve">
          <source>Every Unicode character is assigned a general category, which is the &quot;most usual categorization of a character&quot; (from &lt;a href=&quot;https://www.unicode.org/reports/tr44&quot;&gt;https://www.unicode.org/reports/tr44&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe5013abe724619f4b95c9d05a2b40a50dbbb59" translate="yes" xml:space="preserve">
          <source>Every YAML document represents a single hash reference. The valid keys in this hash are as follows:</source>
          <target state="translated">Каждый документ YAML представляет собой единую ссылку на хэш.Действительные ключи в этом хэше следующие:</target>
        </trans-unit>
        <trans-unit id="302f7ff33fa3b90fdd2132b2697fb84f8705e874" translate="yes" xml:space="preserve">
          <source>Every YAML file may contain arbitrary documents according to the YAML specification, and every document is treated as an entity that can specify the treatment of a single distribution.</source>
          <target state="translated">Каждый YAML-файл может содержать произвольные документы в соответствии со спецификацией YAML,и каждый документ рассматривается как сущность,которая может указать обработку одного дистрибутива.</target>
        </trans-unit>
        <trans-unit id="08580b590313edf277a406f46fd0c846e6d3947e" translate="yes" xml:space="preserve">
          <source>Every case has a specific application and one or more exceptions, and there is no replacement for running a few tests and finding out which method works best for your particular environment, this is why writing optimal code is not an exact science, and why we love using Perl so much - TMTOWTDI.</source>
          <target state="translated">В каждом случае есть свое приложение и одно или несколько исключений,и нет замены запуску нескольких тестов и выяснению,какой метод лучше всего подходит для вашей конкретной среды,поэтому написание оптимального кода не является точной наукой,и почему мы так любим использовать Perl-TMTOWTDI.</target>
        </trans-unit>
        <trans-unit id="5d3966578fbc31ddc5c9c823b10c9d09c4de1eb0" translate="yes" xml:space="preserve">
          <source>Every code point can be represented by more than one possible syntactically valid UTF-8 sequence. Early on, both Unicode and Perl considered any of these to be valid, but now, all sequences longer than the shortest possible one are considered to be malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e844c7ea0f1cedd3ae0259a6817d00e2a02c10f0" translate="yes" xml:space="preserve">
          <source>Every developer publishing modules on CPAN needs a CPAN ID. Visit &lt;code&gt;&lt;a href=&quot;http://pause.perl.org/&quot;&gt;http://pause.perl.org/&lt;/a&gt;&lt;/code&gt;, select &quot;Request PAUSE Account&quot;, and wait for your request to be approved by the PAUSE administrators.</source>
          <target state="translated">Каждому разработчику, публикующему модули на CPAN, нужен CPAN ID. Посетите &lt;code&gt;&lt;a href=&quot;http://pause.perl.org/&quot;&gt;http://pause.perl.org/&lt;/a&gt;&lt;/code&gt; , выберите &amp;laquo;Запросить учетную запись PAUSE&amp;raquo; и дождитесь утверждения вашего запроса администраторами PAUSE.</target>
        </trans-unit>
        <trans-unit id="e4befbeaf4f0b8eb62e07538a8708d75b3c87445" translate="yes" xml:space="preserve">
          <source>Every element in an arrayref directly below a 'par' key is eligible to be run in parallel, while vavalues directly below a 'seq' key must be run in sequence.</source>
          <target state="translated">Каждый элемент массива,находящийся непосредственно под ключом 'par',может быть запущен параллельно,в то время как вавалы,находящиеся непосредственно под ключом 'seq',должны выполняться последовательно.</target>
        </trans-unit>
        <trans-unit id="e1c563b6d35c0f4b5118e9474a1d4ce3c52e7bcc" translate="yes" xml:space="preserve">
          <source>Every element node in the parse tree is represented by an arrayref of the form: &lt;code&gt;[ &lt;i&gt;elementname&lt;/i&gt;, \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;. See the example tree dump in the Synopsis, above.</source>
          <target state="translated">Каждый узел элемента в дереве синтаксического анализа представлен ссылкой на массив в форме: &lt;code&gt;[ &lt;i&gt;elementname&lt;/i&gt;, \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt; . См. Пример дампа дерева в Синопсисе выше.</target>
        </trans-unit>
        <trans-unit id="6134bc0f6fbba39ed1a9d9da08c6587b9ff61665" translate="yes" xml:space="preserve">
          <source>Every line here (apart from the braces, of course) contains a macro. The first line sets up the function declaration as Perl expects for PP code; line 3 sets up variable declarations for the argument stack and the target, the return value of the operation. Finally, it tries to see if the addition operation is overloaded; if so, the appropriate subroutine is called.</source>
          <target state="translated">Каждая строка здесь (кроме фигурных скобок,конечно)содержит макрос.Первая строка устанавливает декларацию функции так,как Perl ожидает для кода PP;третья строка устанавливает объявления переменных для стека аргументов и целевой,возвращаемой величины операции.Наконец,она пытается увидеть,перегружена ли операция сложения;если да,то вызывается соответствующая подпрограмма.</target>
        </trans-unit>
        <trans-unit id="9871a7eb268ef840aca89ae1947284ed4718351a" translate="yes" xml:space="preserve">
          <source>Every line here (apart from the braces, of course) contains a macro. The first line sets up the function declaration as Perl expects for PP code; line 3 sets up variable declarations for the argument stack and the target, the return value of the operation. Line 4 tries to see if the addition operation is overloaded; if so, the appropriate subroutine is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16573fbf6c4df85710f7971d1598380405b3cf7c" translate="yes" xml:space="preserve">
          <source>Every single tool in the chain from this, to &lt;code&gt;ok&lt;/code&gt;, to anything &lt;code&gt;ok&lt;/code&gt; calls needs to increment the &lt;code&gt;$Level&lt;/code&gt; variable. When an error occurs Test::Builder will do a trace to the stack frame determined by &lt;code&gt;$Level&lt;/code&gt;, and report that file+line as the one where the error occurred. If you or any other tool you use forgets to set &lt;code&gt;$Level&lt;/code&gt; then errors will be reported to the wrong place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a07a9740c8c1d7a3f895cbb42b5e873e7ccb12fd" translate="yes" xml:space="preserve">
          <source>Every source stream is associated with only one file.</source>
          <target state="translated">Каждый исходный поток связан только с одним файлом.</target>
        </trans-unit>
        <trans-unit id="5b61ca48fb706399cd7458bb7c44f76e50b97e70" translate="yes" xml:space="preserve">
          <source>Every text node in the tree is represented by a simple (non-ref) string scalar. So you can test &lt;code&gt;&lt;a href=&quot;../../functions/ref&quot;&gt;ref($node)&lt;/a&gt;&lt;/code&gt; to see whether you have an element node or just a text node.</source>
          <target state="translated">Каждый текстовый узел в дереве представлен простым (не ссылочным) строковым скаляром. Таким образом, вы можете протестировать &lt;code&gt;&lt;a href=&quot;../../functions/ref&quot;&gt;ref($node)&lt;/a&gt;&lt;/code&gt; чтобы увидеть, есть ли у вас узел элемента или только текстовый узел.</target>
        </trans-unit>
        <trans-unit id="4b4dd92417b29f82a4df6cf833806102b2032c12" translate="yes" xml:space="preserve">
          <source>Every text node in the tree is represented by a simple (non-ref) string scalar. So you can test &lt;code&gt;ref($node)&lt;/code&gt; to see whether you have an element node or just a text node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f280cfdb5544f17d8056c7b9960291300e70ff8a" translate="yes" xml:space="preserve">
          <source>Every variable type has its own namespace, as do several non-variable identifiers. This means that you can, without fear of conflict, use the same name for a scalar variable, an array, or a hash--or, for that matter, for a filehandle, a directory handle, a subroutine name, a format name, or a label. This means that $foo and @foo are two different variables. It also means that &lt;code&gt;$foo[1]&lt;/code&gt; is a part of @foo, not a part of $foo. This may seem a bit weird, but that's okay, because it is weird.</source>
          <target state="translated">Каждый тип переменной имеет свое собственное пространство имен, как и несколько идентификаторов без переменных. Это означает, что вы можете, не опасаясь конфликта, использовать одно и то же имя для скалярной переменной, массива или хэша - или, если на то пошло, для дескриптора файла, дескриптора каталога, имени подпрограммы, имени формата, или ярлык. Это означает, что $ foo и @foo - две разные переменные. Это также означает, что &lt;code&gt;$foo[1]&lt;/code&gt; является частью @foo, а не частью $ foo. Это может показаться немного странным, но это нормально, потому что это странно.</target>
        </trans-unit>
        <trans-unit id="c6b180367788582d4ac065b82e10c88a1c69b113" translate="yes" xml:space="preserve">
          <source>Every version of perl has some number of features present but considered &quot;experimental.&quot; For much of the life of Perl 5, this was only a designation found in the documentation. Starting in Perl v5.10.0, and more aggressively in v5.18.0, experimental features were placed behind pragmata used to enable the feature and disable associated warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a304f3d76dc1d9d113e9e43b3de43a63253440" translate="yes" xml:space="preserve">
          <source>Everyone needs compound data structures, and in Perl the way you get them is with references. There are four important rules for managing references: Two for making references and two for using them. Once you know these rules you can do most of the important things you need to do with references.</source>
          <target state="translated">Всем нужны сложные структуры данных,а в Perl то,как вы их получаете-со ссылками.Есть четыре важных правила для управления ссылками:Два-для создания ссылок и два-для их использования.Как только вы знаете эти правила,вы можете делать большинство важных вещей,которые вам нужно делать со ссылками.</target>
        </trans-unit>
        <trans-unit id="d9f3a853f21ee670feb2d57d64386bb213e70924" translate="yes" xml:space="preserve">
          <source>Everything is exported by default</source>
          <target state="translated">Все экспортируется по умолчанию</target>
        </trans-unit>
        <trans-unit id="821563e027b1aef4013748dd378d74e1f89659aa" translate="yes" xml:space="preserve">
          <source>Everything that comes with the official</source>
          <target state="translated">Все,что приходит с официальным</target>
        </trans-unit>
        <trans-unit id="f760e16023bf894abde8086e9d7f6c930e923eae" translate="yes" xml:space="preserve">
          <source>Evolution</source>
          <target state="translated">Evolution</target>
        </trans-unit>
        <trans-unit id="be9e0b5a60df791db5db8c0c5ce8e708153692fd" translate="yes" xml:space="preserve">
          <source>Exact name value matching means you have to specify case, hyphens, underscores, and spaces precisely in the name you want. Loose matching follows the Unicode rules &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&quot;&gt;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&lt;/a&gt;, where these are mostly irrelevant. Except for a few outlier character names, these are the same rules as are already used for any other &lt;code&gt;\p{...}&lt;/code&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b6ebbed9d8b46f1eee90eb921f0ea47e548b03" translate="yes" xml:space="preserve">
          <source>Exact version of acceptance unclear, but no later than Perl 5.18.</source>
          <target state="translated">Точный вариант принятия неясен,но не позднее,чем Perl 5.18.</target>
        </trans-unit>
        <trans-unit id="e38657e86225451957dba5ba0d3e55c8be9b8de9" translate="yes" xml:space="preserve">
          <source>Exactly equivalent to &lt;code&gt;Perl_croak(aTHX_ &quot;%s&quot;, PL_no_modify)&lt;/code&gt; , but generates terser object code than using &lt;code&gt;Perl_croak&lt;/code&gt; . Less code used on exception code paths reduces CPU cache pressure.</source>
          <target state="translated">Точно эквивалентно &lt;code&gt;Perl_croak(aTHX_ &quot;%s&quot;, PL_no_modify)&lt;/code&gt; , но генерирует более сжатый объектный код, чем использование &lt;code&gt;Perl_croak&lt;/code&gt; . Меньшее количество кода, используемого в путях кода исключения, снижает нагрузку на кэш ЦП.</target>
        </trans-unit>
        <trans-unit id="1def74e4170191cc1ecc96e344d4615200db8d79" translate="yes" xml:space="preserve">
          <source>Exactly equivalent to &lt;code&gt;Perl_croak(aTHX_ &quot;%s&quot;, PL_no_modify)&lt;/code&gt;, but generates terser object code than using &lt;code&gt;Perl_croak&lt;/code&gt;. Less code used on exception code paths reduces CPU cache pressure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6053d16ee562b64ba170e6e47fc5857d6aeb0497" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;&quot;gv_fetchmeth_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd790b9a98470795c376e22181e112aefbda6acd" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;&quot;gv_fetchmeth_pvn&quot;&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8b76dc891dae007ee34c3cafc01118a9a75f9f" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">Точно так &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;же&lt;/a&gt; , как gv_fetchmeth_pvn , но принимает строку с завершающим нулем вместо пары строка / длина.</target>
        </trans-unit>
        <trans-unit id="108d410dddfe12b3ba82a3d3c5aded251e31ceaa" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">Точно так &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;же&lt;/a&gt; , как gv_fetchmeth_pvn , но принимает строку имени в форме SV вместо пары строка / длина.</target>
        </trans-unit>
        <trans-unit id="70cd839834c4360be38cc8d256d0d20412f0b989" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;&quot;gv_fetchmeth_pvn_autoload&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11580dd84621e2b64c36cda28026ace99fe93821" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;&quot;gv_fetchmeth_pvn_autoload&quot;&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752e1ac766f2cea599a309e02440f40a97bb8d75" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">Точно так &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;же&lt;/a&gt; , как gv_fetchmeth_pvn_autoload , но принимает строку с завершающим нулем вместо пары строка / длина.</target>
        </trans-unit>
        <trans-unit id="a2b3eb60980e277cbebb6619993b224a080d7c7e" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">Точно так &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;же&lt;/a&gt; , как gv_fetchmeth_pvn_autoload , но принимает строку имени в форме SV вместо пары строка / длина.</target>
        </trans-unit>
        <trans-unit id="0d559e98d13b3a163a9ac6d26cc159b061a846ce" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;&quot;pad_add_name_pvn&quot;&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241177ff9d4a9c2896853e85618eb16dd97a70c1" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;&quot;pad_add_name_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca8fa3e370c992adee4f86a24ca37067ce4aaf2" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;&quot;pad_add_name_pvn&quot;&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fed67a8755ba4f29f90415a63203b5925d94458" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="translated">Точно так &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;же&lt;/a&gt; , как pad_add_name_pvn , но принимает буквальную строку вместо пары строка / длина.</target>
        </trans-unit>
        <trans-unit id="08b5afa04635fafa6b86d20073dca412668556d2" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">Точно так &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;же&lt;/a&gt; , как pad_add_name_pvn , но принимает строку с завершающим нулем вместо пары строка / длина.</target>
        </trans-unit>
        <trans-unit id="2ec05cc4ebe9d68aa94cb00389e8f5276b127226" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">Точно так &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;же&lt;/a&gt; , как pad_add_name_pvn , но принимает строку имени в форме SV вместо пары строка / длина.</target>
        </trans-unit>
        <trans-unit id="721fb60df3440b2db377705e79d6aa33255046e5" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;&quot;pad_findmy_pvn&quot;&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858cd1e7a5bd641a77589913581d976a28b686b2" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;&quot;pad_findmy_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c2f18b7b484bc1bcc0d307015d1cb3e5fc9527" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;&quot;pad_findmy_pvn&quot;&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc43c20a7b147a5aa429b8bfb5b2198f1bee606" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="translated">Точно так &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;же&lt;/a&gt; , как pad_findmy_pvn , но принимает буквальную строку вместо пары строка / длина.</target>
        </trans-unit>
        <trans-unit id="1f5dc14f0356699ed601763f5b30ea66b583f929" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">Точно так &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;же&lt;/a&gt; , как pad_findmy_pvn , но принимает строку с завершающим нулем вместо пары строка / длина.</target>
        </trans-unit>
        <trans-unit id="381384c344ba8cf1c452502a4a84edc8e962e04a" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">Точно так &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;же&lt;/a&gt; , как pad_findmy_pvn , но принимает строку имени в форме SV вместо пары строка / длина.</target>
        </trans-unit>
        <trans-unit id="18d3309cb57d37bd7fd350ad135bb897c6c3caec" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pv&quot;&gt;&quot;sv_derived_from_pv&quot;&lt;/a&gt;, but doesn't take a &lt;code&gt;flags&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e2d16336a0ca2ee4b68d73a469a9a7d8cd8bf4" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pv&quot;&gt;sv_derived_from_pv&lt;/a&gt;, but doesn't take a &lt;code&gt;flags&lt;/code&gt; parameter.</source>
          <target state="translated">Точно так &lt;a href=&quot;#sv_derived_from_pv&quot;&gt;же&lt;/a&gt; , как sv_dehibited_from_pv , но не принимает параметр &lt;code&gt;flags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b2c74334223dd3188d999503340448a8a7e5fef" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;&quot;sv_derived_from_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba2fef806c19d8e36b1b9aa042130a5d1188a1f" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;&quot;sv_derived_from_pvn&quot;&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair. This is the advised form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca422a64172952765c1b42b368f2ea1d836ab7e" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">Точно так &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;же&lt;/a&gt; , как sv_dehibited_from_pvn , но принимает строку с завершающим нулем вместо пары строка / длина.</target>
        </trans-unit>
        <trans-unit id="89c565bb719c5d7bd5d0a569932a9c743f646c23" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">Точно так &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;же&lt;/a&gt; , как sv_dehibited_from_pvn , но принимает строку имени в форме SV вместо пары строка / длина.</target>
        </trans-unit>
        <trans-unit id="f536be833f98474874e14c0022645d10cd4c4708" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;code&gt;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)&lt;/code&gt; but more efficient. The</source>
          <target state="translated">Точно как &lt;code&gt;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)&lt;/code&gt; но более эффективен.</target>
        </trans-unit>
        <trans-unit id="ed85a2d94251cb3b70317fcac3c7aa7dfac953f8" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;code&gt;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)&lt;/code&gt; but more efficient. The &lt;code&gt;which&lt;/code&gt; parameter is identical to &lt;a href=&quot;#XopENTRY&quot;&gt;&quot;XopENTRY&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91cb14ad58a1b4462086f211195165ae13adba9c" translate="yes" xml:space="preserve">
          <source>Exactly like C:</source>
          <target state="translated">Точно как С:</target>
        </trans-unit>
        <trans-unit id="7525b0bc0e061494669779471f34623f62998790" translate="yes" xml:space="preserve">
          <source>Exactly what the</source>
          <target state="translated">Именно то,что</target>
        </trans-unit>
        <trans-unit id="738aaf2dccc78981e8b455dca2a194bd2ca3770c" translate="yes" xml:space="preserve">
          <source>Exactly what were the failed locale settings varies. In the above the settings were that the LC_ALL was &quot;En_US&quot; and the LANG had no value. This error means that Perl detected that you and/or your operating system supplier and/or system administrator have set up the so-called locale system but Perl could not use those settings. This was not dead serious, fortunately: there is a &quot;default locale&quot; called &quot;C&quot; that Perl can and will use, and the script will be run. Before you really fix the problem, however, you will get the same error message each time you run Perl. How to really fix the problem can be found in &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; section &lt;b&gt;LOCALE PROBLEMS&lt;/b&gt;.</source>
          <target state="translated">Конкретно, какие именно настройки локали были неудачными, различаются. В приведенных выше настройках LC_ALL был &amp;laquo;En_US&amp;raquo;, а LANG не имел значения. Эта ошибка означает, что Perl обнаружил, что вы и / или поставщик вашей операционной системы и / или системный администратор настроили так называемую систему языковых стандартов, но Perl не может использовать эти настройки. К счастью, это было несерьезно: существует &amp;laquo;локаль по умолчанию&amp;raquo; под названием &amp;laquo;C&amp;raquo;, которую Perl может и будет использовать, и сценарий будет запущен. Однако, прежде чем вы действительно исправите проблему, вы будете получать одно и то же сообщение об ошибке при каждом запуске Perl. Как на самом деле решить проблему, можно найти в разделе &lt;a href=&quot;perllocale&quot;&gt;perllocale &lt;/a&gt;&lt;b&gt;ПРОБЛЕМЫ &lt;/b&gt;ЛОКАЛЬНОЙ &lt;b&gt;ПРОБЛЕМЫ&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d8b6b2bbc7b58a995a5244483a44038c0c9b80cc" translate="yes" xml:space="preserve">
          <source>Examine signals that are blocked and pending. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;sigset&lt;/code&gt; argument. Consult your system's &lt;code&gt;sigpending&lt;/code&gt; manpage for details.</source>
          <target state="translated">Изучите заблокированные и ожидающие сигналы. Здесь в &lt;code&gt;sigset&lt;/code&gt; аргумента sigset используются объекты &lt;code&gt;POSIX::SigSet&lt;/code&gt; . За подробностями &lt;code&gt;sigpending&lt;/code&gt; к справочной странице вашей системы .</target>
        </trans-unit>
        <trans-unit id="9cc359cbd82e941e0ce6d56fc00bde6962483e78" translate="yes" xml:space="preserve">
          <source>Examines an op, which is expected to identify a subroutine at runtime, and attempts to determine at compile time which subroutine it identifies. This is normally used during Perl compilation to determine whether a prototype can be applied to a function call.</source>
          <target state="translated">Изучает операцию,которая должна идентифицировать подпрограмму во время выполнения,и пытается определить во время компиляции,какую подпрограмму она идентифицирует.Обычно это используется во время компиляции Perl для определения того,может ли прототип быть применен к вызову функции.</target>
        </trans-unit>
        <trans-unit id="2816ec163840831fe4101935d11468555274d9b0" translate="yes" xml:space="preserve">
          <source>Examines an op, which is expected to identify a subroutine at runtime, and attempts to determine at compile time which subroutine it identifies. This is normally used during Perl compilation to determine whether a prototype can be applied to a function call. &lt;code&gt;cvop&lt;/code&gt; is the op being considered, normally an &lt;code&gt;rv2cv&lt;/code&gt; op. A pointer to the identified subroutine is returned, if it could be determined statically, and a null pointer is returned if it was not possible to determine statically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce88b50818f0436a7682c61cd164aaafa21bdd4b" translate="yes" xml:space="preserve">
          <source>Examines the value of EXPR, expecting it to be a reference, and returns a string giving information about the reference and the type of referent. If EXPR is not specified, &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21009b11f09e3868b5cd364062bd16a01cd87baf" translate="yes" xml:space="preserve">
          <source>Examining internal data structures with the &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; functions</source>
          <target state="translated">Изучение внутренних структур данных с помощью функций &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f9b5ae7207832dd1764b8c81e77154d27039133" translate="yes" xml:space="preserve">
          <source>Examining internal data structures with the &lt;code&gt;dump&lt;/code&gt; functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e9d648412ff129c07a7aa241744818aaa63c13b" translate="yes" xml:space="preserve">
          <source>Examining internal data structures with the dump functions</source>
          <target state="translated">Исследование внутренних структур данных с функциями дампа</target>
        </trans-unit>
        <trans-unit id="f25587ebeed31098679dd0a945296052447509f8" translate="yes" xml:space="preserve">
          <source>Examining the tree</source>
          <target state="translated">Изучение дерева</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="3ee687a4836f2979219916954f4addd8522f2875" translate="yes" xml:space="preserve">
          <source>Example - a Hexadecimal Handle</source>
          <target state="translated">Пример-шестнадцатеричная ручка</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">Пример 1</target>
        </trans-unit>
        <trans-unit id="d64751054e2d27b855282a556af039128d434ede" translate="yes" xml:space="preserve">
          <source>Example 1: A simple filter.</source>
          <target state="translated">Пример 1:Простой фильтр.</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">Пример 2</target>
        </trans-unit>
        <trans-unit id="c9ff53c2379b7cde740f23e7a5efd8af7e83e70f" translate="yes" xml:space="preserve">
          <source>Example 2: Using the context</source>
          <target state="translated">Пример 2:Использование контекста</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93fa8f292e6f2e8759c24edf270a2f53c96a1766" translate="yes" xml:space="preserve">
          <source>Example 3: Using the context within the filter</source>
          <target state="translated">Пример 3:Использование контекста в фильтре</target>
        </trans-unit>
        <trans-unit id="39e8f452734bc5ce3b169811da6ab1984a676dbf" translate="yes" xml:space="preserve">
          <source>Example 4: Using filter_del</source>
          <target state="translated">Пример 4:Использование filter_del</target>
        </trans-unit>
        <trans-unit id="82dd29f8b1cca5a0b9d8a8b5b47aff607b15559f" translate="yes" xml:space="preserve">
          <source>Example Distroprefs Files</source>
          <target state="translated">Пример Файлы дистропрефектов</target>
        </trans-unit>
        <trans-unit id="1a2aefe8979aba9b8da50d2227d60de10fe393b6" translate="yes" xml:space="preserve">
          <source>Example corrected to show map of maps instead of list of maps (though descriptive text said 'map' even in v1.3)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1479866f8111c0730b394a4d0e54b9686736ec4" translate="yes" xml:space="preserve">
          <source>Example hints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c67a372e04bf6d9b9e0054bc94bbe354f79d761" translate="yes" xml:space="preserve">
          <source>Example implementation might be:</source>
          <target state="translated">Примером может быть реализация:</target>
        </trans-unit>
        <trans-unit id="65cdc590a56f144422e8ab9d8551b4654f6b8393" translate="yes" xml:space="preserve">
          <source>Example of use of &lt;code&gt;%m&lt;/code&gt; :</source>
          <target state="translated">Пример использования &lt;code&gt;%m&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1e6115c04f6e10d5d5d6b87e30e1b6023acf08e4" translate="yes" xml:space="preserve">
          <source>Example of use of &lt;code&gt;%m&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec471d84b36457f0d9d75c03377c9e3cd5f3de93" translate="yes" xml:space="preserve">
          <source>Example of use:</source>
          <target state="translated">Пример использования:</target>
        </trans-unit>
        <trans-unit id="ea87c9b65b6478fdd7882c8529d632b267f39539" translate="yes" xml:space="preserve">
          <source>Example similar to MAN1PODS.</source>
          <target state="translated">Пример аналогичен MAN1PODS.</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">Пример использования:</target>
        </trans-unit>
        <trans-unit id="6f46925524d1c01021e97594cd0f9813ff23d01d" translate="yes" xml:space="preserve">
          <source>Example wrapper function, using a custom stacktrace:</source>
          <target state="translated">Пример функции обертки,использующей пользовательскую стековую трассировку:</target>
        </trans-unit>
        <trans-unit id="917f746ede8d074c95df4b99d59d955a898465de" translate="yes" xml:space="preserve">
          <source>Example, convert all JSON objects into the integer 5:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a0b26277d048bcac5dd947ecabce4cb52276c3" translate="yes" xml:space="preserve">
          <source>Example, decode JSON objects of the form &lt;code&gt;{ &quot;__widget__&quot; =&amp;gt; &amp;lt;id&amp;gt; }&lt;/code&gt; into the corresponding &lt;code&gt;$WIDGET{&amp;lt;id&amp;gt;}&lt;/code&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7278e6c050b8c04dedcbda9af1550657a42fb4fe" translate="yes" xml:space="preserve">
          <source>Example, decode UTF-32LE-encoded JSON:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdc025886948570c6fbbadab1e6327c7c909d59" translate="yes" xml:space="preserve">
          <source>Example, encode a Perl scalar as JSON value without enabled &lt;code&gt;allow_nonref&lt;/code&gt;, resulting in an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed5be0c52bbf20defd0c9e845ecf60ed4c32045" translate="yes" xml:space="preserve">
          <source>Example, output UTF-16BE-encoded JSON:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70eed4e935f1e0e0b91352974e074471d01f2095" translate="yes" xml:space="preserve">
          <source>Example, space_before and indent disabled, space_after enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78e4fad7b27510e9dff599bdcd34d99787fce83" translate="yes" xml:space="preserve">
          <source>Example, space_before enabled, space_after and indent disabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21504e5520a63c06708e793261e7989f6e598670" translate="yes" xml:space="preserve">
          <source>Example.pm</source>
          <target state="translated">Example.pm</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2f9aab2ce8a7f69580f3ffba5062983af60212df" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;0.16&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1b656e9d62a39986b515e970fb598d7c6a0a28" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;0&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d065a1b59988aa6c329900c3cada65931aeef53b" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;Module-Build&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="723a51aade7b3dfa260aa71d4fea09d109817345" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;Module::Build version 0.16&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb81d7d81b9c7defbedc3997e69a4b739f84df6" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;module&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118e06607524b497bf1e00dd9542fcda25763c44" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;perl&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad6ecdc1416c4a99a21cafbb2b565e4a7ce52ac" translate="yes" xml:space="preserve">
          <source>Example: Altering Concise Renderings</source>
          <target state="translated">Пример:Изменение кратких оборотов</target>
        </trans-unit>
        <trans-unit id="e9234fbd94650af302f3c53c866ca9eab6d98b89" translate="yes" xml:space="preserve">
          <source>Example: At the command prompt Type &quot;nmake nwinstall&quot;. This will install NetWare Perl on the NetWare Server. Similarly, if you type &quot;nmake install&quot;, this will cause the binaries to be installed on the local machine. (Typically under the c:\perl folder)</source>
          <target state="translated">Пример:В командной строке введите &quot;nmake nwinstall&quot;.Это позволит установить NetWare Perl на NetWare Server.Аналогично,если вы наберете &quot;nmake install&quot;,это приведет к установке исполняемых файлов на локальную машину.(Обычно в папке c:\perl).</target>
        </trans-unit>
        <trans-unit id="24e5d3a101404316459c21180a1f55d046da675c" translate="yes" xml:space="preserve">
          <source>Example: Encode::ROT13</source>
          <target state="translated">Пример:Кодировка::ROT13</target>
        </trans-unit>
        <trans-unit id="d0830c89a9652382868513b8862db0a3cc84254e" translate="yes" xml:space="preserve">
          <source>Example: Parse some JSON arrays/objects in a given string and return them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0721ccbd9aaee85c90df176a3976ea110912494f" translate="yes" xml:space="preserve">
          <source>Example: The following code</source>
          <target state="translated">Пример:Следующий код</target>
        </trans-unit>
        <trans-unit id="57772da1cf0c7d363a78ec1c7ba403554cdf5105" translate="yes" xml:space="preserve">
          <source>Example: You can execute the following on the command prompt.</source>
          <target state="translated">Пример:В командной строке можно выполнить следующее.</target>
        </trans-unit>
        <trans-unit id="f2749017763b820ec8a5aab014519f7d7e9831d5" translate="yes" xml:space="preserve">
          <source>Example: base64 transcoder</source>
          <target state="translated">Пример:транскодер base64</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="1d7dd2b19077ebadaa57d2f6ba2c64d87037ae05" translate="yes" xml:space="preserve">
          <source>Examples (assuming an ASCII platform)</source>
          <target state="translated">Примеры (в предположении платформы ASCII)</target>
        </trans-unit>
        <trans-unit id="47370b8eea1efa5172e76cf237bd26e7f736ebd6" translate="yes" xml:space="preserve">
          <source>Examples for converting:</source>
          <target state="translated">Примеры для конвертации:</target>
        </trans-unit>
        <trans-unit id="386c7abd2323831ffe2716ae79487fcd14a21d5e" translate="yes" xml:space="preserve">
          <source>Examples for rounding:</source>
          <target state="translated">Примеры округления:</target>
        </trans-unit>
        <trans-unit id="49d15bdd087c216bc7ae6d4ea03d99c8cec52e40" translate="yes" xml:space="preserve">
          <source>Examples in documentation should be illustrative of the concept they're explaining. Sometimes, the best way to show how a language feature works is with a small program the reader can run without modification. More often, examples will consist of a snippet of code containing only the &quot;important&quot; bits. The definition of &quot;important&quot; varies from snippet to snippet. Sometimes it's important to declare &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , initialize all variables and fully catch every error condition. More often than not, though, those things obscure the lesson the example was intended to teach.</source>
          <target state="translated">Примеры в документации должны иллюстрировать концепцию, которую они объясняют. Иногда лучший способ показать, как работает функция языка, - это небольшая программа, которую читатель может запустить без изменений. Чаще всего примеры состоят из фрагментов кода, содержащих только &amp;laquo;важные&amp;raquo; биты. Определение &amp;laquo;важного&amp;raquo; варьируется от фрагмента к фрагменту. Иногда важно объявить &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , инициализировать все переменные и полностью уловить каждое условие ошибки. Однако чаще всего эти вещи затемняют урок, который должен преподать пример.</target>
        </trans-unit>
        <trans-unit id="d11119ca6453ac0e54148249adca86e00f07f1e8" translate="yes" xml:space="preserve">
          <source>Examples in documentation should be illustrative of the concept they're explaining. Sometimes, the best way to show how a language feature works is with a small program the reader can run without modification. More often, examples will consist of a snippet of code containing only the &quot;important&quot; bits. The definition of &quot;important&quot; varies from snippet to snippet. Sometimes it's important to declare &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;use warnings&lt;/code&gt;, initialize all variables and fully catch every error condition. More often than not, though, those things obscure the lesson the example was intended to teach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a591376177b86768f6394133fb691d5a829d17d6" translate="yes" xml:space="preserve">
          <source>Examples of invalid syntax:</source>
          <target state="translated">Примеры недействительного синтаксиса:</target>
        </trans-unit>
        <trans-unit id="0d4621bd6639238b0ab788dd2cc321e39c7fc192" translate="yes" xml:space="preserve">
          <source>Examples of legal names are '$foo' for a scalar, '@foo' for an array, '%foo' for a hash, '&amp;amp;foo' or 'foo' for a subroutine and '*foo' for a glob (i.e. all symbol table entries associated with &quot;foo&quot;, including scalar, array, hash, sub and filehandle).</source>
          <target state="translated">Примеры допустимых имен: '$ foo' для скаляра, '@foo' для массива, '% foo' для хэша, '&amp;amp; foo' или 'foo' для подпрограммы и '* foo' для глобуса (т.е. все записи таблицы символов, связанные с &quot;foo&quot;, включая скаляр, массив, хэш, подпрограмму и дескриптор файла).</target>
        </trans-unit>
        <trans-unit id="d7c5ae33ac348a4d6e7614da1b0d7da380e1b269" translate="yes" xml:space="preserve">
          <source>Examples of use</source>
          <target state="translated">Примеры применения</target>
        </trans-unit>
        <trans-unit id="1a5dea85313337dc5454525e91430329e3b9eb0f" translate="yes" xml:space="preserve">
          <source>Examples of valid syntax (even though the attributes are unknown):</source>
          <target state="translated">Примеры правильного синтаксиса (даже если атрибуты неизвестны):</target>
        </trans-unit>
        <trans-unit id="45b39bd436c5d9cd8f4ca9dd2c7eb59c66eb58b2" translate="yes" xml:space="preserve">
          <source>Examples section another documentation provided by John Heidemann &amp;lt;johnh@ISI.EDU&amp;gt;</source>
          <target state="translated">Раздел &quot;Примеры&quot; - другая документация, предоставленная Джоном Хайдеманном &amp;lt;johnh@ISI.EDU&amp;gt;</target>
        </trans-unit>
        <trans-unit id="628a5608e1a43ca4bfb86500d847d49e2edd6c80" translate="yes" xml:space="preserve">
          <source>Examples where callbacks are necessary include</source>
          <target state="translated">Примеры,в которых необходимы обратные вызовы,включают</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="f98a53c84b8d27c6aba2afa49d1eb4984f22de98" translate="yes" xml:space="preserve">
          <source>Examples: &quot;[_1]&quot; and &quot;[,_1]&quot;, which are synonymous; and &quot;&lt;code&gt;[,ID-(,_4,-,_2,)]&lt;/code&gt; &quot;, which compiles as &lt;code&gt;&lt;a href=&quot;../functions/join&quot;&gt;join&lt;/a&gt; &quot;&quot;, &quot;ID-(&quot;, $_[4], &quot;-&quot;, $_[2], &quot;)&quot;&lt;/code&gt; .</source>
          <target state="translated">Примеры: &amp;laquo;[_1]&amp;raquo; и &amp;laquo;[, _1]&amp;raquo;, которые являются синонимами; и &quot; &lt;code&gt;[,ID-(,_4,-,_2,)]&lt;/code&gt; &quot;, который компилируется как &lt;code&gt;&lt;a href=&quot;../functions/join&quot;&gt;join&lt;/a&gt; &quot;&quot;, &quot;ID-(&quot;, $_[4], &quot;-&quot;, $_[2], &quot;)&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0be9a5482bf17e8c5fe99a02aec7a8cea84f74f4" translate="yes" xml:space="preserve">
          <source>Examples: &quot;[_1]&quot; and &quot;[,_1]&quot;, which are synonymous; and &quot;&lt;code&gt;[,ID-(,_4,-,_2,)]&lt;/code&gt;&quot;, which compiles as &lt;code&gt;join &quot;&quot;, &quot;ID-(&quot;, $_[4], &quot;-&quot;, $_[2], &quot;)&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4e742ff692e5060c86af7b99c37b81006ce99b" translate="yes" xml:space="preserve">
          <source>Except &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , &lt;b&gt;Unicode::Normalize&lt;/b&gt; is required (see also &lt;b&gt;CAVEAT&lt;/b&gt;).</source>
          <target state="translated">За исключением &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , требуется &lt;b&gt;Unicode :: Normalize&lt;/b&gt; (см. Также &lt;b&gt;CAVEAT&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="750b06c4e20cd4bb5392f789eb453ec81bdf0ee9" translate="yes" xml:space="preserve">
          <source>Except &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt;, &lt;b&gt;Unicode::Normalize&lt;/b&gt; is required (see also &lt;b&gt;CAVEAT&lt;/b&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a44f67c097a553bfa410868c60dd16cabf490e" translate="yes" xml:space="preserve">
          <source>Except being faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7f15d16385003ab5d07150052df64664c66bff" translate="yes" xml:space="preserve">
          <source>Except for &lt;a href=&quot;#The-Basics&quot;&gt;&quot;The Basics&quot;&lt;/a&gt; section, this page assumes you are familiar with regular expression basics, like what is a &quot;pattern&quot;, what does it look like, and how it is basically used. For a reference on how they are used, plus various examples of the same, see discussions of &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt;, &lt;code&gt;qr//&lt;/code&gt; and &lt;code&gt;&quot;??&quot;&lt;/code&gt; in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b1235f5e6dc422681dc01e8714586f7ad38364" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;FILTER_ONLY code =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; , each of the component filters is called repeatedly, once for each component found in the source code.</source>
          <target state="translated">За исключением &lt;code&gt;FILTER_ONLY code =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; , каждый из фильтров компонентов вызывается повторно, один раз для каждого компонента, найденного в исходном коде.</target>
        </trans-unit>
        <trans-unit id="4893191369665d6053617936c829c46737cadf4b" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;FILTER_ONLY code =&amp;gt; sub {...}&lt;/code&gt;, each of the component filters is called repeatedly, once for each component found in the source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a10e7180b4b8a76ea58d012850b5f1c4bcb634" translate="yes" xml:space="preserve">
          <source>Except importing the functions, 'autoload' is same as 'load'.</source>
          <target state="translated">Кроме импорта функций,'автозагрузка' аналогична 'загрузке'.</target>
        </trans-unit>
        <trans-unit id="18f4bd6df6292a6b95734ee2a00973430550afe7" translate="yes" xml:space="preserve">
          <source>Except specifing the package and quoting module name, 'autoload_remote' is same as 'load_remote'.</source>
          <target state="translated">За исключением указания имени пакета и кавычки модуля,'autoload_remote' аналогичен 'load_remote'.</target>
        </trans-unit>
        <trans-unit id="16e04cb1bb937a46789e35dba24fd14a5feb954d" translate="yes" xml:space="preserve">
          <source>Except specifing the package and quoting module name, 'load_remote' is same as 'load'.</source>
          <target state="translated">За исключением указания пакета и цитирования имени модуля,'load_remote' аналогичен 'load'.</target>
        </trans-unit>
        <trans-unit id="f55cf6c06e02d10efcfcfb37efbd0c881f531275" translate="yes" xml:space="preserve">
          <source>Excepting those listed above, we're currently unable to guarantee that B::Deparse will produce a pragma at the correct point in the program. (Specifically, pragmas at the beginning of a block often appear right before the start of the block instead.) Since the effects of pragmas are often lexically scoped, this can mean that the pragma holds sway over a different portion of the program than in the input file.</source>
          <target state="translated">За исключением перечисленных выше,в настоящее время мы не можем гарантировать,что B::Deparse произведет прагматизм в правильной точке программы.(В частности,прагмы в начале блока часто появляются прямо перед началом блока).Поскольку эффекты прагм часто лексически просматриваются,это может означать,что прагма имеет влияние на другую часть программы,нежели во входном файле.</target>
        </trans-unit>
        <trans-unit id="20788aa11834509830be30396b88f6404f087e8c" translate="yes" xml:space="preserve">
          <source>Exception Handling</source>
          <target state="translated">Обработка исключений</target>
        </trans-unit>
        <trans-unit id="826f288dbfc038dead10724f69465c1bfe17a68f" translate="yes" xml:space="preserve">
          <source>Exception Handling (simple) Macros</source>
          <target state="translated">Обработка исключений (простые)Макросы</target>
        </trans-unit>
        <trans-unit id="c63dbeff42b8bdcfbb58c593ff1bf6b1c3d8a3ca" translate="yes" xml:space="preserve">
          <source>Exception class used by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a349dc2d7ddd050d57ee72af0506a4a2b31cc9" translate="yes" xml:space="preserve">
          <source>Exception event</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa345b763368fc4f9065828d77e9729e19d258cc" translate="yes" xml:space="preserve">
          <source>Exception handing</source>
          <target state="translated">Исключительная вручение</target>
        </trans-unit>
        <trans-unit id="3ab46cd93f74baf3da5f557d5f2997aae41ff3b1" translate="yes" xml:space="preserve">
          <source>Exceptions from &lt;code&gt;max_size&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt; or other errors will result in a pseudo-HTTP status code of 599 and a reason of &quot;Internal Exception&quot;. The content field in the response will contain the text of the exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d504b2a99c5e1f8d7e7350318f686e5cbee7a60e" translate="yes" xml:space="preserve">
          <source>Exceptions from autodying functions.</source>
          <target state="translated">Исключения из функций автоматического копирования.</target>
        </trans-unit>
        <trans-unit id="1242bf8dd433a51fa4c19b0e3a208b834c9fc265" translate="yes" xml:space="preserve">
          <source>Exceptions from autodying system().</source>
          <target state="translated">Исключения из системы автоматического копирования (autodying system()).</target>
        </trans-unit>
        <trans-unit id="48741c44a476b90391e45eac22eeaa9b0d399fee" translate="yes" xml:space="preserve">
          <source>Exceptions produced by the &lt;code&gt;autodie&lt;/code&gt; pragma are members of the &lt;a href=&quot;autodie/exception&quot;&gt;autodie::exception&lt;/a&gt; class. The preferred way to work with these exceptions under Perl 5.10 is as follows:</source>
          <target state="translated">Исключения, создаваемые &lt;code&gt;autodie&lt;/code&gt; являются членами класса &lt;a href=&quot;autodie/exception&quot;&gt;autodie :: exception&lt;/a&gt; . Предпочтительный способ работы с этими исключениями в Perl 5.10 следующий:</target>
        </trans-unit>
        <trans-unit id="53d59c8491a17793e5a74a9328b1458c0ce10dc9" translate="yes" xml:space="preserve">
          <source>Exceptions produced by the &lt;code&gt;autodie&lt;/code&gt; pragma are members of the &lt;a href=&quot;autodie::exception&quot;&gt;autodie::exception&lt;/a&gt; class. The preferred way to work with these exceptions under Perl 5.10 is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5986414d0fc4bb9c4ee5d8198af90a5eb243568c" translate="yes" xml:space="preserve">
          <source>Exceptions, error return codes, exit statuses, and errno settings. Typically used for function or module documentation; program documentation uses DIAGNOSTICS instead. The general rule of thumb is that errors printed to &lt;code&gt;STDOUT&lt;/code&gt; or &lt;code&gt;STDERR&lt;/code&gt; and intended for the end user are documented in DIAGNOSTICS while errors passed internal to the calling program and intended for other programmers are documented in ERRORS. When documenting a function that sets errno, a full list of the possible errno values should be given here.</source>
          <target state="translated">Исключения, коды возврата ошибок, статусы выхода и настройки errno. Обычно используется для документации функций или модулей; в программной документации используется ДИАГНОСТИКА. Общее практическое правило заключается в том, что ошибки, выводимые в &lt;code&gt;STDOUT&lt;/code&gt; или &lt;code&gt;STDERR&lt;/code&gt; и предназначенные для конечного пользователя, документируются в DIAGNOSTICS, в то время как ошибки, передаваемые внутри вызывающей программы и предназначенные для других программистов, документируются в ERRORS. При документировании функции, которая устанавливает errno, здесь должен быть приведен полный список возможных значений errno.</target>
        </trans-unit>
        <trans-unit id="3e8ef9fa750a38a235f6f5db2c10f6d27bcf66b2" translate="yes" xml:space="preserve">
          <source>Excessive pride, the sort of thing for which Zeus zaps you. Also the quality that makes you write (and maintain) programs that other people won&amp;rsquo;t want to say bad things about. Hence, the third great virtue of a programmer. See also &lt;b&gt;laziness&lt;/b&gt; and &lt;b&gt;impatience&lt;/b&gt;.</source>
          <target state="translated">Чрезмерная гордость, из-за чего Зевс убивает вас. Также качество, которое заставляет вас писать (и поддерживать) программы, о которых другие люди не захотят говорить плохие вещи. Отсюда третье важное достоинство программиста. См. Также &lt;b&gt;лень&lt;/b&gt; и &lt;b&gt;нетерпение&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="a5d912f09e4af174aa651a0745dc7cd68fcf8fd2" translate="yes" xml:space="preserve">
          <source>Excessively long &amp;lt;&amp;gt; operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff53c1a7c6e7525075531f3d6b8357745fac262" translate="yes" xml:space="preserve">
          <source>Exchanging signed integers between different platforms works only when all platforms store them in the same format. Most platforms store signed integers in two's-complement notation, so usually this is not an issue.</source>
          <target state="translated">Обмен подписанными целыми числами между разными платформами работает только тогда,когда все платформы хранят их в одном формате.Большинство платформ хранят подписанные целые числа в нотации с двумя дополнениями,поэтому обычно это не является проблемой.</target>
        </trans-unit>
        <trans-unit id="6d598c708e755dc53aa35c070da1bc37864ef85e" translate="yes" xml:space="preserve">
          <source>Exclude the given routine and its descendants from the profile.</source>
          <target state="translated">Исключите из профиля данную рутину и ее потомков.</target>
        </trans-unit>
        <trans-unit id="712815e07d58e914b686a30fadb75309ce36dd4f" translate="yes" xml:space="preserve">
          <source>Excommunicated</source>
          <target state="translated">Excommunicated</target>
        </trans-unit>
        <trans-unit id="ce52f407fe57f7ce5f94a6ed1047c07eafabc89f" translate="yes" xml:space="preserve">
          <source>Executables for Perl utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8a72f8f7694a401a32218abd4406ae1d283fcc" translate="yes" xml:space="preserve">
          <source>Executables for gzip, zip, and VMStar:</source>
          <target state="translated">Исполняемые файлы для gzip,zip и VMStar:</target>
        </trans-unit>
        <trans-unit id="58de6b665842567beab85d292c3b5870de1c65ae" translate="yes" xml:space="preserve">
          <source>Execute a regexp. The arguments are</source>
          <target state="translated">Выполнить регэкспертизу.Аргументы таковы.</target>
        </trans-unit>
        <trans-unit id="bac595ee7bf88de92060cce1abba1b3d844e6519" translate="yes" xml:space="preserve">
          <source>Execute command as a Perl statement. A trailing semicolon will be supplied. If the Perl statement would otherwise be confused for a Perl debugger, use a leading semicolon, too.</source>
          <target state="translated">Выполните команду,как заявление на Perl.Будет поставлена точка с запятой.Если в противном случае для отладчика Perl оператор Perl будет перепутан,используйте и ведущую точку с запятой.</target>
        </trans-unit>
        <trans-unit id="ec1ff77553768eb52e9d8af54796c7b0bfee25e2" translate="yes" xml:space="preserve">
          <source>Execute related options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45a9d6764cd8a4584e5070807ab16a657d631e8" translate="yes" xml:space="preserve">
          <source>Execute the following commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c456233f2824914a52bfceba7c1ea3f220aec8f" translate="yes" xml:space="preserve">
          <source>Execute the given C code and print its results. &lt;b&gt;WARNING&lt;/b&gt;: Perl makes heavy use of macros, and</source>
          <target state="translated">Выполните указанный код C и распечатайте его результаты. &lt;b&gt;ВНИМАНИЕ&lt;/b&gt; : Perl интенсивно использует макросы, и</target>
        </trans-unit>
        <trans-unit id="9ac88dd7c0b19c435fb63cfe3bac19cbfc350e4d" translate="yes" xml:space="preserve">
          <source>Execute the provided install script from shell or via its icon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061e9bcfa95dc9f2f39332fda78eedc474b39569" translate="yes" xml:space="preserve">
          <source>Execute this statement for a hint about where to find CORE:</source>
          <target state="translated">Выполните это заявление для подсказки,где найти CORE:</target>
        </trans-unit>
        <trans-unit id="a79b5094cc2990d328a2ac30ea62e13817dec0a0" translate="yes" xml:space="preserve">
          <source>Executes a &lt;code&gt;GET&lt;/code&gt; request for the URL and saves the response body to the file name provided. The URL must have unsafe characters escaped and international domain names encoded. If the file already exists, the request will include an &lt;code&gt;If-Modified-Since&lt;/code&gt; header with the modification timestamp of the file. You may specify a different &lt;code&gt;If-Modified-Since&lt;/code&gt; header yourself in the &lt;code&gt;$options-&amp;gt;{headers}&lt;/code&gt; hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2aff22989bc6aeac5d6cd7864aab55a4f7fed20" translate="yes" xml:space="preserve">
          <source>Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST', 'PUT', etc.) on the given URL. The URL must have unsafe characters escaped and international domain names encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574f52d839fd11f8f8f4c4d0ddacf0528556159a" translate="yes" xml:space="preserve">
          <source>Executing a postponed regular expression 50 times without consuming any input string will result in a fatal error. The maximum depth is compiled into perl, so changing it requires a custom build.</source>
          <target state="translated">Выполнение отложенного регулярного выражения 50 раз без использования входной строки приведет к фатальной ошибке.Максимальная глубина скомпилирована в perl,поэтому для ее изменения требуется пользовательская сборка.</target>
        </trans-unit>
        <trans-unit id="92a60b45df076860f644e5d058a8c446b0d5be54" translate="yes" xml:space="preserve">
          <source>Executing a postponed regular expression too many times without consuming any input string will also result in a fatal error. The depth at which that happens is compiled into perl, so it can be changed with a custom build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="13709dfa0128b531e84d0b60f2a2419c6bf04dbf" translate="yes" xml:space="preserve">
          <source>Execution of END blocks</source>
          <target state="translated">Выполнение END блоков</target>
        </trans-unit>
        <trans-unit id="675e718a6b33ba2b7929f770db612d9a80f9b87e" translate="yes" xml:space="preserve">
          <source>Execution of a regex generally involves two phases, the first being finding the start point in the string where we should match from, and the second being running the regop interpreter.</source>
          <target state="translated">Выполнение регекса обычно включает в себя две фазы:первая-поиск начальной точки в строке,с которой мы должны совпасть,и вторая-запуск интерпретатора regop.</target>
        </trans-unit>
        <trans-unit id="119f08e3cf8da3d7fe34ab1131df979eb14179b1" translate="yes" xml:space="preserve">
          <source>Execution of any &lt;code&gt;CHECK&lt;/code&gt; blocks.</source>
          <target state="translated">Выполнение любых блоков &lt;code&gt;CHECK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0603019ab35ef11320acde0ed06d6533404cfee9" translate="yes" xml:space="preserve">
          <source>Execution of any &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="translated">Выполнение любых блоков &lt;code&gt;END&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4f82800233d6c7223698c2e187aa3ccc7d2dc01" translate="yes" xml:space="preserve">
          <source>Execution of the interpreter itself used to be recursive, but thanks to the efforts of Dave Mitchell in the 5.9.x development track, that has changed: now an internal stack is maintained on the heap and the routine is fully iterative. This can make it tricky as the code is quite conservative about what state it stores, with the result that two consecutive lines in the code can actually be running in totally different contexts due to the simulated recursion.</source>
          <target state="translated">Исполнение самого переводчика раньше было рекурсивным,но благодаря усилиям Дэйва Митчелла в разработке 5.9.x,что изменилось:теперь на куче поддерживается внутренний стек и рутина полностью итеративна.Это может сделать его хитрым,так как код довольно консервативен в отношении того,какое состояние он сохраняет,в результате чего две последовательные строки в коде могут на самом деле выполняться в совершенно разных контекстах благодаря симулированной рекурсии.</target>
        </trans-unit>
        <trans-unit id="4e9f10726faddb4d512801b20f95c6f56436cea8" translate="yes" xml:space="preserve">
          <source>Exercises the C function of the same name in scalar context. Returns the same SV that the C function returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc06ef2194671cce285095b6f928f8f2f608822" translate="yes" xml:space="preserve">
          <source>Exercises the C function of the same name. Returns nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248b9fcc2702356b63c40509208ebb73f559ce07" translate="yes" xml:space="preserve">
          <source>Exhaustive information on the topic of references can be found in &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;, &lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt;, &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; and &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt;.</source>
          <target state="translated">Исчерпывающую информацию по теме ссылок можно найти в &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; , &lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt; , &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; и &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76b5089ada110a0136449f09bf11c2275168e2c5" translate="yes" xml:space="preserve">
          <source>Existing 32 bit apps are properly known as LP32, i.e. Longs and Pointers are 32 bit. 64-bit apps are more properly known as LP64. The discriminating feature of a LP64 bit app is its ability to utilise a 64-bit address space. It is perfectly possible to have a LP32 bit app that supports both 64-bit integers (long long) and largefiles (&amp;gt; 2GB), and this is the default for perl-5.6.0.</source>
          <target state="translated">Существующие 32-битные приложения правильно известны как LP32, т. Е. Длинные значения и указатели 32-битные. 64-битные приложения более правильно известны как LP64. Отличительной особенностью приложения LP64 bit является его способность использовать 64-битное адресное пространство. Вполне возможно иметь приложение LP32 бит, которое поддерживает как 64-битные целые числа (long long), так и большие файлы (&amp;gt; 2 ГБ), и это значение по умолчанию для perl-5.6.0.</target>
        </trans-unit>
        <trans-unit id="3ce132dcaab82a474dd839ab951c3eef1631d645" translate="yes" xml:space="preserve">
          <source>Existing syntax and semantics should only be marked for destruction in very limited circumstances. If they are believed to be very rarely used, stand in the way of actual improvement to the Perl language or perl interpreter, and if affected code can be easily updated to continue working, they may be considered for removal. When in doubt, caution dictates that we will favor backward compatibility. When a feature is deprecated, a statement of reasoning describing the decision process will be posted, and a link to it will be provided in the relevant perldelta documents.</source>
          <target state="translated">Существующий синтаксис и семантика должны быть обозначены для уничтожения только в очень ограниченных обстоятельствах.Если считается,что они используются очень редко,встаньте на пути фактического улучшения языка Perl или интерпретатора perl,и если пораженный код может быть легко обновлен для продолжения работы,он может быть рассмотрен на предмет удаления.В случае сомнений,осторожность диктует,что мы будем отдавать предпочтение обратной совместимости.Если какая-либо функция будет удалена,будет выложено обоснование,описывающее процесс принятия решения,а ссылка на нее будет дана в соответствующих документах perldelta.</target>
        </trans-unit>
        <trans-unit id="6d9d19533b0fbf724f69a3d7a99a413b54990645" translate="yes" xml:space="preserve">
          <source>Exit Code</source>
          <target state="translated">Код выхода</target>
        </trans-unit>
        <trans-unit id="45d746a8ea75007a4818f4a9a13d84ba46bc8da2" translate="yes" xml:space="preserve">
          <source>Exiting eval via %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc760fc51ed4d60f1f58db324e3b3ab5637ff7f6" translate="yes" xml:space="preserve">
          <source>Exiting format via %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6b6283c09f2fd4cd4d37232a60ec674d66805a" translate="yes" xml:space="preserve">
          <source>Exiting pseudo-block via %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a99dd93f7907c63d9f314a53349298ea450b60" translate="yes" xml:space="preserve">
          <source>Exiting subroutine via %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eedf12ff192cfbfe7957d4a6c26105640adbff0b" translate="yes" xml:space="preserve">
          <source>Exiting substitution via %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71626cd31b069ac3980d7ed6a6abb80f71225a3" translate="yes" xml:space="preserve">
          <source>Exits</source>
          <target state="translated">Exits</target>
        </trans-unit>
        <trans-unit id="bc031d65eaef8ccada69a0c994a430a53a41354d" translate="yes" xml:space="preserve">
          <source>Exotic Templates</source>
          <target state="translated">Экзотические шаблоны</target>
        </trans-unit>
        <trans-unit id="2c6c990ee216fb59d7ad72ee8d28ebcceeb5a21e" translate="yes" xml:space="preserve">
          <source>Expand and unexpand tabs like unix expand(1) and unexpand(1)</source>
          <target state="translated">Закладки Expand и unexpand(1)в виде unix expansion(1)и unexpand(1)</target>
        </trans-unit>
        <trans-unit id="2b116400884e9dbc3a5bf5fe94b7d6faa8b0dd38" translate="yes" xml:space="preserve">
          <source>Expand conventional syntax constructions into equivalent ones that expose their internal operation.</source>
          <target state="translated">Расширьте обычные синтаксические конструкции до эквивалентных,раскрывающих их внутреннюю работу.</target>
        </trans-unit>
        <trans-unit id="a24145087edc62ad61c2e0e0ed9777002b6b1d94" translate="yes" xml:space="preserve">
          <source>Expand double-quoted strings into the corresponding combinations of concatenation, uc, ucfirst, lc, lcfirst, quotemeta, and join. For instance, print</source>
          <target state="translated">Разверните строки в двойных кавычках на соответствующие комбинации конкатенация,uc,ucfirst,lc,lcfirst,quotemeta,и соедините.Например,распечатать</target>
        </trans-unit>
        <trans-unit id="a3cec9741cec0dca8594001a6d2ea842476ee2ac" translate="yes" xml:space="preserve">
          <source>Expand patterns that start with '~' to user name home directories.</source>
          <target state="translated">Разверните шаблоны,которые начинаются с '~',в домашние каталоги с именами пользователей.</target>
        </trans-unit>
        <trans-unit id="6b6e1cee8dd20e696133457bd5f5a86ddd470c1e" translate="yes" xml:space="preserve">
          <source>Expanding on these:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc5537d5aa41a3bee835484d8a71db89d04af82" translate="yes" xml:space="preserve">
          <source>Expands MM[KS]/Make macros in a text string, using the contents of identically named elements of &lt;code&gt;%$self&lt;/code&gt; , and returns the result as a file specification in Unix syntax.</source>
          <target state="translated">Расширяет MM [KS] / Make макрос в текстовой строке, используя содержимое идентично названных элементов &lt;code&gt;%$self&lt;/code&gt; , и возвращает результат в виде спецификации файла в синтаксисе Unix.</target>
        </trans-unit>
        <trans-unit id="bb3eba70260caae42d2a56d669b04a37e9fa0e09" translate="yes" xml:space="preserve">
          <source>Expands MM[KS]/Make macros in a text string, using the contents of identically named elements of &lt;code&gt;%$self&lt;/code&gt;, and returns the result as a file specification in Unix syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5783f703e4997395da1ed4bfbdfa29354401cb" translate="yes" xml:space="preserve">
          <source>Expands a message, intended for the user, to include an indication of the current location in the code, if the message does not already appear to be complete.</source>
          <target state="translated">Расширяет сообщение,предназначенное для пользователя,чтобы включить в код указание текущего местоположения,если сообщение еще не является полным.</target>
        </trans-unit>
        <trans-unit id="acbbc593d8399af8ae3b5c591c83e4cbee77c103" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV so that it has room for the indicated number of bytes (remember to reserve space for an extra trailing &lt;code&gt;NUL&lt;/code&gt; character). Calls &lt;code&gt;sv_grow&lt;/code&gt; to perform the expansion if necessary. Returns a pointer to the character buffer. SV must be of type &amp;gt;= &lt;code&gt;SVt_PV&lt;/code&gt;. One alternative is to call &lt;code&gt;sv_grow&lt;/code&gt; if you are not sure of the type of SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adde8be1848474c5303345a29bcef52bb4a7e17d" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV so that it has room for the indicated number of bytes (remember to reserve space for an extra trailing &lt;code&gt;NUL&lt;/code&gt; character). Calls &lt;code&gt;sv_grow&lt;/code&gt; to perform the expansion if necessary. Returns a pointer to the character buffer. SV must be of type &amp;gt;= SVt_PV. One alternative is to call &lt;code&gt;sv_grow&lt;/code&gt; if you are not sure of the type of SV.</source>
          <target state="translated">Расширяет символьный буфер в SV так, чтобы в нем было место для указанного количества байтов (не забудьте зарезервировать место для дополнительного &lt;code&gt;NUL&lt;/code&gt; символа NUL ). При необходимости &lt;code&gt;sv_grow&lt;/code&gt; для выполнения раскрытия. Возвращает указатель на символьный буфер. SV должен иметь тип&amp;gt; = SVt_PV. Одна альтернатива - вызвать &lt;code&gt;sv_grow&lt;/code&gt; , если вы не уверены в типе SV.</target>
        </trans-unit>
        <trans-unit id="e07f45c58aaef41c3cc48eff8856e3deb378b3c7" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV. If necessary, uses &lt;code&gt;sv_unref&lt;/code&gt; and upgrades the SV to &lt;code&gt;SVt_PV&lt;/code&gt; . Returns a pointer to the character buffer. Use the &lt;code&gt;SvGROW&lt;/code&gt; wrapper instead.</source>
          <target state="translated">Расширяет символьный буфер в SV. При необходимости использует &lt;code&gt;sv_unref&lt;/code&gt; и обновляет SV до &lt;code&gt;SVt_PV&lt;/code&gt; . Возвращает указатель на символьный буфер. Используйте &lt;code&gt;SvGROW&lt;/code&gt; вместо обертки.</target>
        </trans-unit>
        <trans-unit id="bdfec9c6e27c21de38d0ad42245bca4c56a0db95" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV. If necessary, uses &lt;code&gt;sv_unref&lt;/code&gt; and upgrades the SV to &lt;code&gt;SVt_PV&lt;/code&gt;. Returns a pointer to the character buffer. Use the &lt;code&gt;SvGROW&lt;/code&gt; wrapper instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b55719b11400ab3946110ac0b6da5f10e36cb7" translate="yes" xml:space="preserve">
          <source>Expands_On_NFC</source>
          <target state="translated">Expands_On_NFC</target>
        </trans-unit>
        <trans-unit id="6067c08bd93995f39d3f36483e3f4ef3039e3007" translate="yes" xml:space="preserve">
          <source>Expands_On_NFD</source>
          <target state="translated">Expands_On_NFD</target>
        </trans-unit>
        <trans-unit id="5df7d510e0afb51aa87d43b92bcf880d99423548" translate="yes" xml:space="preserve">
          <source>Expands_On_NFKC</source>
          <target state="translated">Expands_On_NFKC</target>
        </trans-unit>
        <trans-unit id="cc2ac673ebfc4ca4115add5e1d8491f6e16313e9" translate="yes" xml:space="preserve">
          <source>Expands_On_NFKD</source>
          <target state="translated">Expands_On_NFKD</target>
        </trans-unit>
        <trans-unit id="60ad5e3c5be34af787f1a5a9f57ebcde8c336258" translate="yes" xml:space="preserve">
          <source>Expected '=item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf0de321b4edfe39f598e66ba458f32fd64da99" translate="yes" xml:space="preserve">
          <source>Expected '=item *'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777c7b4c3fe35b49213cdaeefc6c1268989f5da0" translate="yes" xml:space="preserve">
          <source>Expecting a single value is not quite the same as knowing that there will be one. If someone modified</source>
          <target state="translated">Ожидание одного значения не совсем то же самое,что знание того,что оно будет.Если кто-то изменил</target>
        </trans-unit>
        <trans-unit id="64185a4c949e7204414cf46ff03bc3f1606cbf77" translate="yes" xml:space="preserve">
          <source>Expecting close bracket in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65287be72b978ac388e5b50adfdc25bcb62b5804" translate="yes" xml:space="preserve">
          <source>Expecting interpolated extended charclass in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf72e88f58634dcb4936f677084e0a00acfdd002" translate="yes" xml:space="preserve">
          <source>Expects an anonymous hash of name =&amp;gt; value pairs. Same rules apply for names as in &lt;code&gt;new&lt;/code&gt; . If no argument is supplied, will return the &quot;seen&quot; list of name =&amp;gt; value pairs, in a list context. Otherwise, returns the object itself.</source>
          <target state="translated">Ожидает анонимный хэш пар имя =&amp;gt; значение. К именам применяются те же правила, что и в &lt;code&gt;new&lt;/code&gt; . Если аргумент не предоставлен, вернет &amp;laquo;увиденный&amp;raquo; список пар имя =&amp;gt; значение в контексте списка. В противном случае возвращает сам объект.</target>
        </trans-unit>
        <trans-unit id="4d7959ebdbd1eb9b37094b35dddbe6785e49b443" translate="yes" xml:space="preserve">
          <source>Expects an anonymous hash of name =&amp;gt; value pairs. Same rules apply for names as in &lt;code&gt;new&lt;/code&gt;. If no argument is supplied, will return the &quot;seen&quot; list of name =&amp;gt; value pairs, in a list context. Otherwise, returns the object itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc66b53e07eb3ff24ec3024a45e5d4fb318685f8" translate="yes" xml:space="preserve">
          <source>Experimental %s on scalar is now forbidden</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b17e379ead5f797c5aa37eb9dc9a107df81896" translate="yes" xml:space="preserve">
          <source>Experimental Details on given and when</source>
          <target state="translated">Экспериментальные Детали по заданным и когда</target>
        </trans-unit>
        <trans-unit id="f6f74c01abe74837a83d80a82742b5139aa6cefe" translate="yes" xml:space="preserve">
          <source>Experimental Support for Sun Studio Compilers for Linux OS</source>
          <target state="translated">Экспериментальная поддержка компиляторов Sun Studio для Linux OS</target>
        </trans-unit>
        <trans-unit id="7e049d90ac73798a976f271b4843fd29805765d5" translate="yes" xml:space="preserve">
          <source>Experimental aliasing via reference not enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e15651ca047ada36f7efb9c2f8e000cd639262b" translate="yes" xml:space="preserve">
          <source>Experimental features made easy</source>
          <target state="translated">Экспериментальные функции упростились</target>
        </trans-unit>
        <trans-unit id="ed2ea169fad6a1c0c998398ba26a1941a42d9f93" translate="yes" xml:space="preserve">
          <source>Experimental features must be experimental in two stable releases before being marked non-experimental. Experimental features will only have their experimental status revoked when they no longer have any design-changing bugs open against them and when they have remained unchanged in behavior for the entire length of a development cycle. In other words, a feature present in v5.20.0 may be marked no longer experimental in v5.22.0 if and only if its behavior is unchanged throughout all of v5.21.</source>
          <target state="translated">Экспериментальные признаки должны быть экспериментальными в двух стабильных выпусках,прежде чем они будут помечены как неэкспериментальные.Экспериментальные функции будут отозваны только тогда,когда у них больше не будет ошибок,изменяющих конструкцию,и когда они останутся неизменными в поведении на протяжении всего цикла разработки.Другими словами,признак,присутствующий в версии v5.20.0,может быть помечен как неэкспериментальный в версии v5.22.0 только в том случае,если его поведение оставалось неизменным на протяжении всего цикла разработки в версии v5.21.</target>
        </trans-unit>
        <trans-unit id="812cee3839ce593c6e7f8fb81f34a218fc92295b" translate="yes" xml:space="preserve">
          <source>Experimental implementation to deal with optional_features from META.yml. Still needs coordination with installer software and currently works only for META.yml declaring &lt;code&gt;dynamic_config=0&lt;/code&gt; . Use with caution.</source>
          <target state="translated">Экспериментальная реализация для работы с optional_features из META.yml. По-прежнему требует согласования с установщиком и в настоящее время работает только для META.yml с объявлением &lt;code&gt;dynamic_config=0&lt;/code&gt; . Используйте с осторожностью.</target>
        </trans-unit>
        <trans-unit id="134ab6b7ca3f00324871d474fd88846598632c3d" translate="yes" xml:space="preserve">
          <source>Experimental subroutine signatures not enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a2e6bb257f27dcbf131f0e4c5090288b803bfa" translate="yes" xml:space="preserve">
          <source>Experimental support for using Intel C++ Compiler has been added. Edit win32/Makefile and pick the correct CCTYPE for the Visual C that Intel C was installed into. Also uncomment __ICC to enable Intel C on Visual C support. To set up the build enviroment, from the Start Menu run IA-32 Visual Studio 20__ mode or Intel 64 Visual Studio 20__ mode as appropriate. Then run nmake as usually in that prompt box.</source>
          <target state="translated">Добавлена экспериментальная поддержка использования Intel C++Compiler.Отредактирован win32/Makefile и выбран правильный CCTYPE для Visual C,в который Intel C был установлен.Также добавлен комментарий __ICC для включения поддержки Intel C на Visual C.Для настройки среды сборки из меню &quot;Пуск&quot; запустите режим IA-32 Visual Studio 20__или Intel 64 Visual Studio 20__соответственно.Затем запустите nmake,как обычно в этом окне запроса.</target>
        </trans-unit>
        <trans-unit id="910b0326198fc0d6a945d746fbbbc76ed369e62f" translate="yes" xml:space="preserve">
          <source>Experimental support for using Intel C++ Compiler has been added. Edit win32/Makefile and pick the correct CCTYPE for the Visual C that Intel C was installed into. Also uncomment __ICC to enable Intel C on Visual C support. To set up the build environment, from the Start Menu run IA-32 Visual Studio 20__ mode or Intel 64 Visual Studio 20__ mode as appropriate. Then run nmake as usually in that prompt box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512d10cc80bbcc4b910ab34f44eacc0c8a8cab5b" translate="yes" xml:space="preserve">
          <source>Explain how to make a valid fh without going through open()(i.e. apply a layer). For example if the file is not opened through perl, but we want to get back a fh, like it was opened by Perl.</source>
          <target state="translated">Объясните,как сделать действительный fh,не проходя через open()(т.е.применить слой).Например,если файл не открыт через perl,но мы хотим получить обратно fh,как будто он был открыт через Perl.</target>
        </trans-unit>
        <trans-unit id="c3c57a0034753db204133ffc1a0baecdf062f580" translate="yes" xml:space="preserve">
          <source>Explanation of the error, or the error itself (such as an exception). In perl exceptions may be blessed objects, so this field may contain a blessed object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd7eb7e15c45c52322c743748d0912cc8c1637a0" translate="yes" xml:space="preserve">
          <source>Explicit blessing to '' (assuming package main)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae3abeefc2986f2eb842d3cd9632c0a0316ad1f" translate="yes" xml:space="preserve">
          <source>Explicit context</source>
          <target state="translated">Явный контекст</target>
        </trans-unit>
        <trans-unit id="04ff6c95ad88a6e349a482b76bfc08416f18ea96" translate="yes" xml:space="preserve">
          <source>Explicitly forces no carriage control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d335bbeeb032574984b5eec4fdf9e2563d5abb" translate="yes" xml:space="preserve">
          <source>Explicitly using the &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;SAVETMPS&lt;/code&gt; --&lt;code&gt;FREETMPS&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; pairing</source>
          <target state="translated">Явное с помощью &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;SAVETMPS&lt;/code&gt; - &lt;code&gt;FREETMPS&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; спаривание</target>
        </trans-unit>
        <trans-unit id="6e87a66444e923290e00f1a8b43474c974953b7a" translate="yes" xml:space="preserve">
          <source>Explicitly using the &lt;code&gt;ENTER&lt;/code&gt;/&lt;code&gt;SAVETMPS&lt;/code&gt;--&lt;code&gt;FREETMPS&lt;/code&gt;/&lt;code&gt;LEAVE&lt;/code&gt; pairing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d165ee97f26b031b938fc12621899c47ca3e7175" translate="yes" xml:space="preserve">
          <source>Exponentiation</source>
          <target state="translated">Exponentiation</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="b04b1d43c804b579fc2179b2b3b449ae1560ae80" translate="yes" xml:space="preserve">
          <source>Export tags defined</source>
          <target state="translated">Определены теги экспорта</target>
        </trans-unit>
        <trans-unit id="a10fabb79509133b618928fd32456dad097bd96f" translate="yes" xml:space="preserve">
          <source>Exportable Functions</source>
          <target state="translated">Экспортируемые функции</target>
        </trans-unit>
        <trans-unit id="087b5b3729015829a7b8d0086f8e5125870ab2b2" translate="yes" xml:space="preserve">
          <source>Exportable Methods</source>
          <target state="translated">Экспортируемые методы</target>
        </trans-unit>
        <trans-unit id="3fb8ab7d4fdb770897f754d6218d2ea74b86ecf3" translate="yes" xml:space="preserve">
          <source>Exportable constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fa04392e9fbe49aa17d919da35cd7332fea185" translate="yes" xml:space="preserve">
          <source>Exported utility variables</source>
          <target state="translated">Экспортируемые служебные переменные</target>
        </trans-unit>
        <trans-unit id="0cd84bdcb23e59371516a9290d82778263ec9c7c" translate="yes" xml:space="preserve">
          <source>Exporter</source>
          <target state="translated">Exporter</target>
        </trans-unit>
        <trans-unit id="e3272220a019edf889f502d8e939100dd7ba6db5" translate="yes" xml:space="preserve">
          <source>Exporter - Implements default import method for modules</source>
          <target state="translated">Экспортер-Вводит метод импорта по умолчанию для модулей</target>
        </trans-unit>
        <trans-unit id="9677334ff1544480ffd2a9303280ab252a694823" translate="yes" xml:space="preserve">
          <source>Exporter guts</source>
          <target state="translated">кишки экспортера</target>
        </trans-unit>
        <trans-unit id="733f73993629cd5a5a17865554f4f49f3a533105" translate="yes" xml:space="preserve">
          <source>Exporter has a special method, 'export_to_level' which is used in situations where you can't directly call Exporter's import method. The export_to_level method looks like:</source>
          <target state="translated">Экспортер имеет специальный метод 'export_to_level',который используется в ситуациях,когда невозможно напрямую вызвать метод импорта экспортера.Метод export_to_level имеет вид:</target>
        </trans-unit>
        <trans-unit id="e3e659931fe986137a62058f2b4abcef03d65202" translate="yes" xml:space="preserve">
          <source>Exporter.pm</source>
          <target state="translated">Exporter.pm</target>
        </trans-unit>
        <trans-unit id="dc76f5ce6b0b38a5f000b46176cc35b9cb43b24a" translate="yes" xml:space="preserve">
          <source>Exporter::Heavy</source>
          <target state="translated">Exporter::Heavy</target>
        </trans-unit>
        <trans-unit id="1d1140249dd08a40f776c20b9ddd54b5796c4a08" translate="yes" xml:space="preserve">
          <source>Exporter::Heavy - Exporter guts</source>
          <target state="translated">Экспортер::Тяжелый-Экспортер кишки</target>
        </trans-unit>
        <trans-unit id="5212c627287d01ea51f61b228d900e6e7aa1a003" translate="yes" xml:space="preserve">
          <source>Exporting Without Inheriting from Exporter</source>
          <target state="translated">Экспорт без унаследования от экспортера</target>
        </trans-unit>
        <trans-unit id="b76a470ae357815e917068bbc5728a8478edaac1" translate="yes" xml:space="preserve">
          <source>Exporting Without Using Exporter's import Method</source>
          <target state="translated">Экспорт без использования метода импорта экспортера</target>
        </trans-unit>
        <trans-unit id="1b7c31e16f36f853e2c6c57c0f5c8d014a8558d8" translate="yes" xml:space="preserve">
          <source>Exporting variables is not a good idea. They can change under the hood, provoking horrible effects at-a-distance that are too hard to track and to fix. Trust me: they are not worth it.</source>
          <target state="translated">Экспорт переменных-это плохая идея.Они могут изменяться под капотом,вызывая ужасные эффекты на расстоянии,которые слишком трудно отследить и исправить.Поверьте мне:они того не стоят.</target>
        </trans-unit>
        <trans-unit id="071e64c7e24a9d0c7e9058c9548f279b0db62c55" translate="yes" xml:space="preserve">
          <source>Exporting your new function</source>
          <target state="translated">Экспорт вашей новой функции</target>
        </trans-unit>
        <trans-unit id="0e16537914a0163e01ecd7e0945bc56c50eb3849" translate="yes" xml:space="preserve">
          <source>Exports</source>
          <target state="translated">Exports</target>
        </trans-unit>
        <trans-unit id="78a2a7642c638f47b6ed7502eab44ca9b2bee2ca" translate="yes" xml:space="preserve">
          <source>Exports all the test functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf2ed8b53d5a014c877f2053b8b2d2b823e37e6" translate="yes" xml:space="preserve">
          <source>Exports in this section are not commonly needed. These all have the 'test2_' prefix to help ensure they stand out. You should look at the &lt;a href=&quot;#MAIN-API-EXPORTS&quot;&gt;&quot;MAIN API EXPORTS&quot;&lt;/a&gt; section before looking here. This section is one where &quot;Great power comes with great responsibility&quot;. It is possible to break things badly if you are not careful with these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a78d15b2b917cc03293d31b108e05ce4d52026f" translate="yes" xml:space="preserve">
          <source>Exports pollute the namespace of the module user. If you must export try to use &lt;code&gt;@EXPORT_OK&lt;/code&gt; in preference to &lt;code&gt;@EXPORT&lt;/code&gt; and avoid short or common symbol names to reduce the risk of name clashes.</source>
          <target state="translated">Экспорт загрязняет пространство имен пользователя модуля. Если вам необходимо экспортировать, попробуйте использовать &lt;code&gt;@EXPORT_OK&lt;/code&gt; вместо &lt;code&gt;@EXPORT&lt;/code&gt; и избегайте коротких или общих имен символов, чтобы снизить риск конфликтов имен.</target>
        </trans-unit>
        <trans-unit id="19680f4d8bc35c089321258ed1726974e515bb01" translate="yes" xml:space="preserve">
          <source>Exports pollute the namespace of the module user. If you must export try to use @EXPORT_OK in preference to @EXPORT and avoid short or common names to reduce the risk of name clashes.</source>
          <target state="translated">Экспорт загрязняет пространство имён пользователя модуля.Если необходимо экспортировать,попробуйте использовать @EXPORT_OK вместо @EXPORT и избегайте коротких или общих имен,чтобы уменьшить риск столкновения имен.</target>
        </trans-unit>
        <trans-unit id="991118c2b6b3c16c0bc4bf38a36f6ec2aa05622c" translate="yes" xml:space="preserve">
          <source>Expose the individual bytes of characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b67fdeebc6a730537832b31cf1e590434ac7ad11" translate="yes" xml:space="preserve">
          <source>Exposes the POSIX function getcwd(3) or re-implements it if it's not available.</source>
          <target state="translated">Выставляет POSIX-функцию getcwd(3)или выполняет ее повторно,если она недоступна.</target>
        </trans-unit>
        <trans-unit id="30e13c3f2f4b6a85ea0443e9079e6877bde86d9e" translate="yes" xml:space="preserve">
          <source>Expressing the command as a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="848bbebe9b69edd539cf121a71439bdfe81b397c" translate="yes" xml:space="preserve">
          <source>Expressions like this are useful in conditionals:</source>
          <target state="translated">Такие выражения полезны в кондиционерах:</target>
        </trans-unit>
        <trans-unit id="130f8cc58ed68e3a1fe427428482f60dc97e9301" translate="yes" xml:space="preserve">
          <source>Ext/Ension</source>
          <target state="translated">Ext/Ension</target>
        </trans-unit>
        <trans-unit id="ae4a822ac4b76bc07804416206c3daa608046771" translate="yes" xml:space="preserve">
          <source>ExtUtils</source>
          <target state="translated">ExtUtils</target>
        </trans-unit>
        <trans-unit id="8adb87135c238343780172ae48188681cf370acf" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder</source>
          <target state="translated">ExtUtils::CBuilder</target>
        </trans-unit>
        <trans-unit id="0dd29c2a17cfd9dc6e5beb4505e91940187682bf" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder - Compile and link C code for Perl modules</source>
          <target state="translated">ExtUtils::CBuilder-Компиляция и компоновка кода на C для Perl модулей</target>
        </trans-unit>
        <trans-unit id="de9e9dbbe64dfc1f06076f5b598c40c5b97a4f07" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder is maintained as part of the Perl 5 core. Please submit any bug reports via the</source>
          <target state="translated">Экстерьер::CBuilder поддерживается как часть ядра Perl 5.Пожалуйста,отправляйте любые сообщения об ошибках через</target>
        </trans-unit>
        <trans-unit id="6d9aae08362d79c65318eda6627f0ab746bbee95" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder::Platform::Windows</source>
          <target state="translated">ExtUtils::CBuilder::Platform::Windows</target>
        </trans-unit>
        <trans-unit id="ec8f2943e4d10ff3dad921becf4700a9c605fc5f" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder::Platform::Windows - Builder class for Windows platforms</source>
          <target state="translated">ExtUtils::CBuilder::Platform::Windows-класс Builder для Windows платформ</target>
        </trans-unit>
        <trans-unit id="0f5f8c4e317cb9e14dbc99f8c4725e7101d063e0" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command</source>
          <target state="translated">ExtUtils::Command</target>
        </trans-unit>
        <trans-unit id="13685feaf020782447b9941746d4b335bddf0883" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command - utilities to replace common UNIX commands in Makefiles etc.</source>
          <target state="translated">ExtUtils::Command-утилиты для замены обычных UNIX-команд в Makefiles и т.д.</target>
        </trans-unit>
        <trans-unit id="1e0e65de42d77495693723755508f19700283291" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command::MM</source>
          <target state="translated">ExtUtils::Command::MM</target>
        </trans-unit>
        <trans-unit id="57baedd89a659e1e0ecff540830bcf69ebde4c0c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command::MM - Commands for the MM's to use in Makefiles</source>
          <target state="translated">ExtUtils::Команда::ММ-Команды для использования ММ в Makefiles</target>
        </trans-unit>
        <trans-unit id="e8520d9305bb1b6b30673860c2a9fc7e0bb43af7" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command::MM encapsulates code which would otherwise have to be done with large &quot;one&quot; liners.</source>
          <target state="translated">ExtUtils::Command::MM инкапсулирует код,который в противном случае пришлось бы делать с большими &quot;одними&quot; лайнерами.</target>
        </trans-unit>
        <trans-unit id="01aca525aa3b0d3504eab62f629ea7ae316a1df9" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant</source>
          <target state="translated">ExtUtils::Constant</target>
        </trans-unit>
        <trans-unit id="eb53ab587c5df3bac6d41d873980d0a80f5c155a" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant - generate XS code to import C header constants</source>
          <target state="translated">ExtUtils::Constant-генерировать XS код для импорта констант заголовка C</target>
        </trans-unit>
        <trans-unit id="2bfb67938397e6eb325051359a5d323e79a220d8" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant facilitates generating C and XS wrapper code to allow perl modules to AUTOLOAD constants defined in C library header files. It is principally used by the &lt;code&gt;h2xs&lt;/code&gt; utility, on which this code is based. It doesn't contain the routines to scan header files to extract these constants.</source>
          <target state="translated">ExtUtils :: Constant упрощает создание кода оболочки C и XS, чтобы модули Perl могли использовать константы AUTOLOAD, определенные в файлах заголовков библиотеки C. В основном он используется утилитой &lt;code&gt;h2xs&lt;/code&gt; , на которой основан этот код. Он не содержит процедур сканирования файлов заголовков для извлечения этих констант.</target>
        </trans-unit>
        <trans-unit id="66069119c4474ce5db2c00c2fc5c7ebe74e509d3" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base</source>
          <target state="translated">ExtUtils::Constant::Base</target>
        </trans-unit>
        <trans-unit id="a5a92bf27fd8a70fb8d0d04675721591091d31a8" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base - base class for ExtUtils::Constant objects</source>
          <target state="translated">ExtUtils::Постоянные::Базовый-базовый класс для ExtUtils::Постоянные объекты</target>
        </trans-unit>
        <trans-unit id="37d28c0e096d851a074af795694f3e4ed605e4fe" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base exports no subroutines. The following methods are available</source>
          <target state="translated">ExtUtils::Постоянно::База не экспортирует подпрограммы.Доступны следующие методы</target>
        </trans-unit>
        <trans-unit id="cc85f41228edcbb25fda849b24e857773037224e" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base provides a base implementation of methods to generate C code to give fast constant value lookup by named string. Currently it's mostly used ExtUtils::Constant::XS, which generates the lookup code for the constant() subroutine found in many XS modules.</source>
          <target state="translated">ExtUtils::Constant::Base предоставляет базовую реализацию методов генерации кода на C для быстрого поиска постоянных значений по именованной строке.В настоящее время в основном используется ExtUtils::Constant::XS,который генерирует код поиска подпрограмм константы(),встречающихся во многих XS модулях.</target>
        </trans-unit>
        <trans-unit id="01123cf69ee0503631a353722ce7083ea5078bc4" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Utils</source>
          <target state="translated">ExtUtils::Constant::Utils</target>
        </trans-unit>
        <trans-unit id="eb7021c674be1dbbac0f5d2f00a2ee805361885c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Utils - helper functions for ExtUtils::Constant</source>
          <target state="translated">ExtUtils::Постоянно::Utils-вспомогательные функции для ExtUtils::Постоянно</target>
        </trans-unit>
        <trans-unit id="88fa01ca987de7b887a3c79f4e501e05801215f9" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Utils packages up utility subroutines used by ExtUtils::Constant, ExtUtils::Constant::Base and derived classes. All its functions are explicitly exportable.</source>
          <target state="translated">ExtUtils::Constant::Utils упаковывает утилиты,используемые ExtUtils::Constant,ExtUtils::Constant::Base и производные классы.Все ее функции явно экспортируются.</target>
        </trans-unit>
        <trans-unit id="691e427f212f20f1a4e97a292f83b191a9330664" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::XS</source>
          <target state="translated">ExtUtils::Constant::XS</target>
        </trans-unit>
        <trans-unit id="7b304383401bf8b504f1c4575e883635046c55a8" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::XS - generate C code for XS modules' constants.</source>
          <target state="translated">ExtUtils::Constant::XS-генерировать C-код для констант XS-модулей.</target>
        </trans-unit>
        <trans-unit id="a134fe12059f0bb9cd89ef6f92c5ae2e9810c57e" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::XS overrides ExtUtils::Constant::Base to generate C code for XS modules' constants.</source>
          <target state="translated">ExtUtils::Константа::XS переопределяет ExtUtils::Константа::База для генерации C-кода для констант XS-модулей.</target>
        </trans-unit>
        <trans-unit id="5fb8ee5bc96080dc35b8c113dc4ab7e19f1f7f22" translate="yes" xml:space="preserve">
          <source>ExtUtils::Embed</source>
          <target state="translated">ExtUtils::Embed</target>
        </trans-unit>
        <trans-unit id="939f083947624f21f9b736c75a4f6438e18f6655" translate="yes" xml:space="preserve">
          <source>ExtUtils::Embed - Utilities for embedding Perl in C/C++ applications</source>
          <target state="translated">ExtUtils::Embed-Утилиты для встраивания Perl в приложения на Си/Си++.</target>
        </trans-unit>
        <trans-unit id="66d1280ba3865302835b81bea028e8fe495e808d" translate="yes" xml:space="preserve">
          <source>ExtUtils::Install</source>
          <target state="translated">ExtUtils::Install</target>
        </trans-unit>
        <trans-unit id="e1917ee01b8bd661c56eb9ac792b975c3df2f5a1" translate="yes" xml:space="preserve">
          <source>ExtUtils::Install - install files from here to there</source>
          <target state="translated">ExtUtils::Install-установка файлов отсюда до туда</target>
        </trans-unit>
        <trans-unit id="b703bea959a592e6e8e04477edfce4ad8bd309c6" translate="yes" xml:space="preserve">
          <source>ExtUtils::Installed</source>
          <target state="translated">ExtUtils::Installed</target>
        </trans-unit>
        <trans-unit id="3984de1657750a05991b5ea96245f59313691aaf" translate="yes" xml:space="preserve">
          <source>ExtUtils::Installed - Inventory management of installed modules</source>
          <target state="translated">ExtUtils::Установленные-Управление запасами установленных модулей</target>
        </trans-unit>
        <trans-unit id="b02212efafd95acf708fbde6c1ea9a18a4ebc3b3" translate="yes" xml:space="preserve">
          <source>ExtUtils::Installed provides a standard way to find out what core and module files have been installed. It uses the information stored in .packlist files created during installation to provide this information. In addition it provides facilities to classify the installed files and to extract directory information from the .packlist files.</source>
          <target state="translated">ExtUtils::Installed предоставляет стандартный способ узнать,какие файлы ядра и модули были установлены.Он использует информацию,хранящуюся в файлах .packlist,созданных во время установки,для предоставления этой информации.Кроме того,он предоставляет возможности для классификации установленных файлов и извлечения информации о каталогах из файлов .packlist.</target>
        </trans-unit>
        <trans-unit id="42c25bbd2df5e46fa299efe94a0a5ec1d56bc561" translate="yes" xml:space="preserve">
          <source>ExtUtils::Liblist</source>
          <target state="translated">ExtUtils::Liblist</target>
        </trans-unit>
        <trans-unit id="1c444f69f6d944829dae0bfb3cb19187e41f4b3d" translate="yes" xml:space="preserve">
          <source>ExtUtils::Liblist - determine libraries to use and how to use them</source>
          <target state="translated">ExtUtils::Liblist-определить библиотеки для использования и как их использовать.</target>
        </trans-unit>
        <trans-unit id="d6d8f29d2d6c812d8608b7eecff6b50d5b23bb32" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM</source>
          <target state="translated">ExtUtils::MM</target>
        </trans-unit>
        <trans-unit id="d9944867a30cc09571228059a446b44834907174" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM - OS adjusted ExtUtils::MakeMaker subclass</source>
          <target state="translated">Экстра-утилиты::ММ-Настройка ОС Экстра-утилиты::Подкласс MakeMaker</target>
        </trans-unit>
        <trans-unit id="8e1a56d427b6cdce97fbab94a739a6369e0e5125" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM is a subclass of &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; which automatically chooses the appropriate OS specific subclass for you (ie. &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt;, etc...).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db5ed850a839f5d75d47dcc96cd13b3666aca25d" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM is a subclass of ExtUtils::MakeMaker which automatically chooses the appropriate OS specific subclass for you (ie. ExtUils::MM_Unix, etc...).</source>
          <target state="translated">ExtUtils::MM-это подкласс ExtUtils::MakeMaker,который автоматически выбирает для вас соответствующий подкласс,специфичный для операционной системы (т.е.ExtUils::MM_Unix и т.д...).</target>
        </trans-unit>
        <trans-unit id="f20ad18d2cdfe05b996f3064f2baa9077e90198e" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_AIX</source>
          <target state="translated">ExtUtils::MM_AIX</target>
        </trans-unit>
        <trans-unit id="e2c65ab01c23a32d98e8b4e3a0d77782b9a1b0c7" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_AIX - AIX specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">Специфический подкласс ExtUtils::MM_AIX-AIX подкласс ExtUtils::MM_Unix</target>
        </trans-unit>
        <trans-unit id="82f6a9462d97b2eeba15d489f4c29f1201ca8139" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any</source>
          <target state="translated">ExtUtils::MM_Any</target>
        </trans-unit>
        <trans-unit id="28e6e24f25939bb77bd8b0e8b5c1b5591ab0a63a" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any - Platform-agnostic MM methods</source>
          <target state="translated">ExtUtils::MM_Any-Платформенно-диагностические ММ-методы</target>
        </trans-unit>
        <trans-unit id="f1beb9206779be8013b3e4a60d1eb3c845414417" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any is a subclass of &lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt;. The methods noted here override File::Spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4017c7fd6c6b1a7382d3693845441ec57607400" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any is a subclass of File::Spec. The methods noted here override File::Spec.</source>
          <target state="translated">ExtUtils::MM_Any-подкласс File::Spec.Методы,отмеченные здесь,переопределяют File::Spec.</target>
        </trans-unit>
        <trans-unit id="a07e79b177dfcc3d173d4e96906fb19054e96233" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any is a superclass for the ExtUtils::MM_* set of modules. It contains methods which are either inherently cross-platform or are written in a cross-platform manner.</source>
          <target state="translated">ExtUtils::MM_Any-это суперкласс для набора модулей ExtUtils::MM_*.Он содержит методы,которые либо по своей сути являются кроссплатформенными,либо написаны кроссплатформенным образом.</target>
        </trans-unit>
        <trans-unit id="01e79daa480a30aec67c1c77b38113a2fa75acb1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_BeOS</source>
          <target state="translated">ExtUtils::MM_BeOS</target>
        </trans-unit>
        <trans-unit id="ff7047e18f778da31bd8596ebbae3ca3c16815a1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_BeOS - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_BeOS-методы переопределения поведения UN*X в ExtUtils::MakeMaker</target>
        </trans-unit>
        <trans-unit id="32f54e4d1cdff9fa869169ffbe48a1f8a6442f8d" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Cygwin</source>
          <target state="translated">ExtUtils::MM_Cygwin</target>
        </trans-unit>
        <trans-unit id="26a23a31e9ae337b30e976cee9bfe04ee8714af5" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Cygwin - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_Cygwin-методы переопределения поведения UN*X в ExtUtils::MakeMaker</target>
        </trans-unit>
        <trans-unit id="83b34173b4084fe7b0f1b8e7080f5e44721c1652" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_DOS</source>
          <target state="translated">ExtUtils::MM_DOS</target>
        </trans-unit>
        <trans-unit id="ce09d2a78829bfe3f6e4a91c1fda8bf736e91cd1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_DOS - DOS specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_DOS-специфический для DOS подкласс ExtUtils::MM_Unix</target>
        </trans-unit>
        <trans-unit id="95c4b06cdebc87ea8f0b490c31911c2d3a160085" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Darwin</source>
          <target state="translated">ExtUtils::MM_Darwin</target>
        </trans-unit>
        <trans-unit id="ce3594f7f3d66367be8d04f9a60ed3e5b23e61ae" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Darwin - special behaviors for OS X</source>
          <target state="translated">ExtUtils::MM_Darwin-специальное поведение для OS X</target>
        </trans-unit>
        <trans-unit id="a35d39f1996d06db96e0eb3bc7581c9d1bb37583" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_MacOS</source>
          <target state="translated">ExtUtils::MM_MacOS</target>
        </trans-unit>
        <trans-unit id="a75ee91bd51d22344f5f01dea69463550d1b77f8" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_MacOS - once produced Makefiles for MacOS Classic</source>
          <target state="translated">ExtUtils::MM_MacOS-однажды создал Makefiles для MacOS Classic</target>
        </trans-unit>
        <trans-unit id="05b1c57f6a3a8d6a042ca608dff6a349761c8182" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_NW5</source>
          <target state="translated">ExtUtils::MM_NW5</target>
        </trans-unit>
        <trans-unit id="c8c1829d86b2c857e5650f081f857c1eaf86f3e8" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_NW5 - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_NW5-методы переопределения поведения UN*X в ExtUtils::MakeMaker</target>
        </trans-unit>
        <trans-unit id="e0950761db3807deb0218887807e7b7bff1a358b" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_OS2</source>
          <target state="translated">ExtUtils::MM_OS2</target>
        </trans-unit>
        <trans-unit id="9c18e1ac0450cd34c6460b2c5c7a1220fbf998b2" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_OS2 - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_OS2-методы переопределения поведения UN*X в ExtUtils::MakeMaker</target>
        </trans-unit>
        <trans-unit id="9754f9a33576ee28f994ec3ff4f6032e292d0ec1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_QNX</source>
          <target state="translated">ExtUtils::MM_QNX</target>
        </trans-unit>
        <trans-unit id="5c959f779c55270f8bb8da4da99da8c51701f934" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_QNX - QNX specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">Специфический подкласс ExtUtils::MM_QNX-QNX подкласс ExtUtils::MM_Unix</target>
        </trans-unit>
        <trans-unit id="d9cffc939c33c81ae491e577ff7a0f67f32115db" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_UWIN</source>
          <target state="translated">ExtUtils::MM_UWIN</target>
        </trans-unit>
        <trans-unit id="392dbc1b30426cf86e8bbd0156b4353d7aae576c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_UWIN - U/WIN specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_UWIN-U/WIN специфический подкласс ExtUtils::MM_Unix</target>
        </trans-unit>
        <trans-unit id="6b69e4024267a17dfff2456177fce03e32e171de" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_Unix</target>
        </trans-unit>
        <trans-unit id="c828df98d7850f84de0cbb81d4e4596caa76f94a" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Unix - methods used by ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_Unix-методы,используемые ExtUtils::MakeMaker</target>
        </trans-unit>
        <trans-unit id="2f00201cd4f3a6fbb76802bb39ac7a005b8f24e3" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Unix. This is a temporary solution.</source>
          <target state="translated">ExtUtils::MM_Unix.Это временное решение.</target>
        </trans-unit>
        <trans-unit id="5bbe314072fa79cbbe64e27d3c034cb7ecbc2df1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VMS</source>
          <target state="translated">ExtUtils::MM_VMS</target>
        </trans-unit>
        <trans-unit id="c328e4aa3661448cfc600baf641ce3b368446553" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VMS - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_VMS-методы переопределения поведения UN*X в ExtUtils::MakeMaker</target>
        </trans-unit>
        <trans-unit id="cbf6a31d4b30a3697a77d880951a740af6fe002e" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VOS</source>
          <target state="translated">ExtUtils::MM_VOS</target>
        </trans-unit>
        <trans-unit id="248c1927adaa54c68b53917bcd12ca60bc242150" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VOS - VOS specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_VOS-специфический для VOS подкласс ExtUtils::MM_Unix</target>
        </trans-unit>
        <trans-unit id="01b2b6f5d2a1e4c4ed0f2cb32046a9a5d606a04c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win32</source>
          <target state="translated">ExtUtils::MM_Win32</target>
        </trans-unit>
        <trans-unit id="31634682156707a3a92d7105825df2529eb4f747" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win32 - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_Win32-методы переопределения поведения UN*X в ExtUtils::MakeMaker</target>
        </trans-unit>
        <trans-unit id="dd4f189a6328e4d51489c48940b1b07f49808b7b" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win95</source>
          <target state="translated">ExtUtils::MM_Win95</target>
        </trans-unit>
        <trans-unit id="ef84388c3c22f4aa37ab1ec6dcdd24ddaa801da4" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win95 - method to customize MakeMaker for Win9X</source>
          <target state="translated">ExtUtils::MM_Win95-метод настройки MakeMaker для Win9X.</target>
        </trans-unit>
        <trans-unit id="2eeeaab10b029e1825f471249451e612175f476c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY</source>
          <target state="translated">ExtUtils::MY</target>
        </trans-unit>
        <trans-unit id="a29677c3a7812ab9e27275d7d315711580baa3c5" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY - ExtUtils::MakeMaker subclass for customization</source>
          <target state="translated">ExtUtils::MY-ExtUtils::MakeMaker подкласс для настройки</target>
        </trans-unit>
        <trans-unit id="8c6225988b72e5033c42e6301547dce425e25ee5" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY is a subclass of &lt;a href=&quot;ExtUtils::MM&quot;&gt;ExtUtils::MM&lt;/a&gt;. Its provided in your Makefile.PL for you to add and override MakeMaker functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="077ce2e66cf34d26fc93548b5aa4b0a365551ad3" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY is a subclass of ExtUtils::MM. Its provided in your Makefile.PL for you to add and override MakeMaker functionality.</source>
          <target state="translated">ExtUtils::MY-подкласс ExtUtils::MM.Он предоставляется в вашем Makefile.PL для добавления и переопределения функциональности MakeMaker.</target>
        </trans-unit>
        <trans-unit id="a8d99fc9d222321dd1dd6e7c9d39239d74c92fb3" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY might turn out to be a temporary solution, but MY won't go away.</source>
          <target state="translated">ExtUtils::MY может оказаться временным решением,но MY не уйдет.</target>
        </trans-unit>
        <trans-unit id="6da8b7232afb53dfdcd9b1c4dde891781d5ce223" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MakeMaker</target>
        </trans-unit>
        <trans-unit id="b8052cbade448d159716f320bb8b7066c1c35927" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker (EUMM) is object oriented. Each directory below the current directory that contains a Makefile.PL is treated as a separate object. This makes it possible to write an unlimited number of Makefiles with a single invocation of WriteMakefile().</source>
          <target state="translated">ExtUtils::MakeMaker (EUMM)является объектно-ориентированным.Каждый каталог под текущей директорией,который содержит Makefile.PL,рассматривается как отдельный объект.Это позволяет записывать неограниченное количество Makefiles с одним вызовом WriteMakefile().</target>
        </trans-unit>
        <trans-unit id="6ea38d2404e8bb2fe915619afea85f24fef8c2cc" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker - Create a module Makefile</source>
          <target state="translated">ExtUtils::MakeMaker-Создать модуль Makefile</target>
        </trans-unit>
        <trans-unit id="e6df2289ed559a450ea26d00c0d0e4cee5508740" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker subclass for customization</source>
          <target state="translated">ExtUtils::Подкласс MakeMaker для настройки</target>
        </trans-unit>
        <trans-unit id="c60c158c602a516f81a6ae9bca65b474a071fe74" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Config</source>
          <target state="translated">ExtUtils::MakeMaker::Config</target>
        </trans-unit>
        <trans-unit id="d3014ef697f5ada430bc56427a7b9caae4e6e02c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Config - Wrapper around Config.pm</source>
          <target state="translated">ExtUtils::MakeMaker::Config-Обёртка вокруг Config.pm</target>
        </trans-unit>
        <trans-unit id="9ccd57b3ecc86c99f88666a4cbfa65fcc3d9511f" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::FAQ</source>
          <target state="translated">ExtUtils::MakeMaker::FAQ</target>
        </trans-unit>
        <trans-unit id="30461ff8ef34cae5ca5dc88e0a98e8273138112a" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::FAQ - Frequently Asked Questions About MakeMaker</source>
          <target state="translated">Экстра-утилиты::MakeMaker::FAQ-Часто задаваемые вопросы о MakeMaker</target>
        </trans-unit>
        <trans-unit id="51e7eb76f593803326b81c0b7eddf02ecc2dca1f" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Locale</source>
          <target state="translated">ExtUtils::MakeMaker::Locale</target>
        </trans-unit>
        <trans-unit id="95b89cbe7015202586c4481ef682b645c3e89ac2" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Locale - bundled Encode::Locale</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91ea2c313a203d7ca441511bcd463e56db95e2e" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Tutorial</source>
          <target state="translated">ExtUtils::MakeMaker::Tutorial</target>
        </trans-unit>
        <trans-unit id="a40c04994e7a37e13af27331a991a5aa646c9b73" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Tutorial - Writing a module with MakeMaker</source>
          <target state="translated">ExtUtils::MakeMaker::Tutorial-Написание модуля с помощью MakeMaker</target>
        </trans-unit>
        <trans-unit id="b357eaa10f6891f76e970ffb5f2bf93f495e4a17" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest</source>
          <target state="translated">ExtUtils::Manifest</target>
        </trans-unit>
        <trans-unit id="c2882ccdd5737a1b3d2f4dc3d31014e58dd46653" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest - Utilities to write and check a MANIFEST file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3226afa87ddca4ba7171d22b9f2b78d098b58f76" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest - utilities to write and check a MANIFEST file</source>
          <target state="translated">ExtUtils::Manifest-утилиты для записи и проверки файла MANIFEST</target>
        </trans-unit>
        <trans-unit id="5668766f97bcd05c6bdb7c965133d9727537b625" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest exports no functions by default. The following are exported on request</source>
          <target state="translated">ExtUtils::Манифест по умолчанию не экспортирует никаких функций.По запросу экспортируются следующие функции</target>
        </trans-unit>
        <trans-unit id="bdbe036be435e29a3c3c98d79b72ee067d6d642d" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest exports no functions by default. The following are exported on request:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d683dc5b10b650f60d4d9d340eeb5154c9725c7" translate="yes" xml:space="preserve">
          <source>ExtUtils::Miniperl</source>
          <target state="translated">ExtUtils::Miniperl</target>
        </trans-unit>
        <trans-unit id="a62bb061ae9acdfb750b378b1f62a97de2f7165a" translate="yes" xml:space="preserve">
          <source>ExtUtils::Miniperl - write the C code for miniperlmain.c and perlmain.c</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc3f091d177ebdf88e70a7d90d1a0e96a9ebda2" translate="yes" xml:space="preserve">
          <source>ExtUtils::Miniperl - write the C code for perlmain.c</source>
          <target state="translated">ExtUtils::Miniperl-пишите код на C для perlmain.c</target>
        </trans-unit>
        <trans-unit id="1c32c7f84e8dc881e25db6f6d50706131d6d8758" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mkbootstrap</source>
          <target state="translated">ExtUtils::Mkbootstrap</target>
        </trans-unit>
        <trans-unit id="bbfa5e60d2823fa64c959ef9034364b18eddc3e9" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mkbootstrap - make a bootstrap file for use by DynaLoader</source>
          <target state="translated">ExtUtils::Mkbootstrap-сделайте загрузочный файл для использования DynaLoader</target>
        </trans-unit>
        <trans-unit id="6719b923f8e283bd552384bd5af81cadfef85883" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mksymlists</source>
          <target state="translated">ExtUtils::Mksymlists</target>
        </trans-unit>
        <trans-unit id="15ab523f4d3c60af2d551125aa18471a39d07e7c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mksymlists - write linker options files for dynamic extension</source>
          <target state="translated">ExtUtils::Mksymlists-запись линкерных опций файлов для динамического расширения</target>
        </trans-unit>
        <trans-unit id="dac17ac78f3539cbb386b1e56ee2b529662e80e5" translate="yes" xml:space="preserve">
          <source>ExtUtils::Packlist</source>
          <target state="translated">ExtUtils::Packlist</target>
        </trans-unit>
        <trans-unit id="2fd0b32af3911843b6577751529d4515df509939" translate="yes" xml:space="preserve">
          <source>ExtUtils::Packlist - manage .packlist files</source>
          <target state="translated">ExtUtils::Packlist-управление файлами .packlist</target>
        </trans-unit>
        <trans-unit id="b6cb6e0433e264b8d9ae4674f7b9ee20c7cc9a0e" translate="yes" xml:space="preserve">
          <source>ExtUtils::Packlist provides a standard way to manage .packlist files. Functions are provided to read and write .packlist files. The original .packlist format is a simple list of absolute pathnames, one per line. In addition, this package supports an extended format, where as well as a filename each line may contain a list of attributes in the form of a space separated list of key=value pairs. This is used by the installperl script to differentiate between files and links, for example.</source>
          <target state="translated">ExtUtils::Packlist предоставляет стандартный способ управления файлами .packlist.Функции предназначены для чтения и записи файлов .packlist.Оригинальный формат .packlist представляет собой простой список абсолютных имен,по одному на строку.Кроме того,этот пакет поддерживает расширенный формат,где,как и имя файла,каждая строка может содержать список атрибутов в виде разделенного пробелами списка пар ключ=значение.Это используется,например,скриптом installperl для различения файлов и ссылок.</target>
        </trans-unit>
        <trans-unit id="c27f6826e3e72b1481e238cd590b927b9a8c7674" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS</source>
          <target state="translated">ExtUtils::ParseXS</target>
        </trans-unit>
        <trans-unit id="a0bc42ea6560aea10d0d6a20cba29d9f0d9456c6" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS - converts Perl XS code into C code</source>
          <target state="translated">ExtUtils::ParseXS-преобразует код Perl XS в код C</target>
        </trans-unit>
        <trans-unit id="03159689beb1e83556a0d792cc8509ee6422dca5" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Constants</source>
          <target state="translated">ExtUtils::ParseXS::Constants</target>
        </trans-unit>
        <trans-unit id="cf5795919350a424f2fdddb099257f73945e1a05" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Constants - Initialization values for some globals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34afc1a15abc59a30f0d297ced64f7e5d7089b18" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Eval</source>
          <target state="translated">ExtUtils::ParseXS::Eval</target>
        </trans-unit>
        <trans-unit id="b114f3881b5796ad889d6328dec9b5e233d60f40" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Eval - Clean package to evaluate code in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd75ce4683a9aa22ba6c700ca353d47d601b2384" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Utilities</source>
          <target state="translated">ExtUtils::ParseXS::Utilities</target>
        </trans-unit>
        <trans-unit id="92bd9c932412ce4f8422b75c6801374ed24acdf2" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Utilities - Subroutines used with ExtUtils::ParseXS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244cbf4be92c60aff1ddbf35e6ab53db17abecdd" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps</source>
          <target state="translated">ExtUtils::Typemaps</target>
        </trans-unit>
        <trans-unit id="d3f0982ef48a7ff5c4bec28af01b2fc9c1b9e324" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps - Read/Write/Modify Perl/XS typemap files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f91cda6d284fa20124d5451bc24b51143532bb" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::Cmd</source>
          <target state="translated">ExtUtils::Typemaps::Cmd</target>
        </trans-unit>
        <trans-unit id="795fa4eef7e8ecb9427bfc09a6b1dcc43d73ee93" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::Cmd - Quick commands for handling typemaps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9969ccb534d5e151d4ccb9e73ab988320ed4b6" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::InputMap</source>
          <target state="translated">ExtUtils::Typemaps::InputMap</target>
        </trans-unit>
        <trans-unit id="c325c829d365d7d7a6812090290f7b83b3596b1c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::InputMap - Entry in the INPUT section of a typemap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237c9b6dbebb9b4ed396f0dce6a67fb3af72515a" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::OutputMap</source>
          <target state="translated">ExtUtils::Typemaps::OutputMap</target>
        </trans-unit>
        <trans-unit id="661bb31eef11ca983e8d0917113f95b3a60d7add" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::OutputMap - Entry in the OUTPUT section of a typemap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6feaee53a536421bc2b64881bb22fc287b99e2b4" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::Type</source>
          <target state="translated">ExtUtils::Typemaps::Type</target>
        </trans-unit>
        <trans-unit id="42aba54068b70ea208aa1cd601ae498fb974dba4" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::Type - Entry in the TYPEMAP section of a typemap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973e953fd629b20b4ca87588491035c2a7556141" translate="yes" xml:space="preserve">
          <source>ExtUtils::XSSymSet</source>
          <target state="translated">ExtUtils::XSSymSet</target>
        </trans-unit>
        <trans-unit id="f716c096c97d144856a93624d2a5d5bd094c5cae" translate="yes" xml:space="preserve">
          <source>ExtUtils::XSSymSet - keep sets of symbol names palatable to the VMS linker</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01cb2601da9ca9e6f049c24d0b16efdb7998074" translate="yes" xml:space="preserve">
          <source>ExtUtils::testlib</source>
          <target state="translated">ExtUtils::testlib</target>
        </trans-unit>
        <trans-unit id="c819a99ea2471502c8a0521252e569cacdf6e150" translate="yes" xml:space="preserve">
          <source>ExtUtils::testlib - add blib/* directories to @INC</source>
          <target state="translated">ExtUtils::testlib-добавить каталоги blib/*в @INC</target>
        </trans-unit>
        <trans-unit id="1a8525beca2f4f9e103dd4931ef378f407141d6e" translate="yes" xml:space="preserve">
          <source>Extend File Glob to Allow Input and Output Files</source>
          <target state="translated">Расширить глобус файлов,чтобы разрешить входные и выходные файлы</target>
        </trans-unit>
        <trans-unit id="82d26601ba012fb977fae11b9393fa91fb289790" translate="yes" xml:space="preserve">
          <source>Extend your pattern's legibility by permitting whitespace and comments. Details in &lt;a href=&quot;#%2Fx-and-%2Fxx&quot;&gt;&quot;/x and /xx&quot;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab77626f5cddcb8bbb657382d4af81d5cdf9048" translate="yes" xml:space="preserve">
          <source>Extend your pattern's legibility by permitting whitespace and comments. Details in &lt;a href=&quot;#%2fx&quot;&gt;/x&lt;/a&gt;</source>
          <target state="translated">Увеличьте удобочитаемость вашего шаблона, разрешив пробелы и комментарии. Детали в &lt;a href=&quot;#%2fx&quot;&gt;/ х&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d44d230ea6fe0935f3b1482cff787c6266b3d3b" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;expect&lt;/code&gt; . This is a hash reference with four allowed keys, &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; , &lt;code&gt;reuse&lt;/code&gt; , and &lt;code&gt;talk&lt;/code&gt; .</source>
          <target state="translated">Расширенное &lt;code&gt;expect&lt;/code&gt; . Это ссылка на хэш с четырьмя разрешенными ключами, &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; , &lt;code&gt;reuse&lt;/code&gt; и &lt;code&gt;talk&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efc98640815d67fe8a62500e0c5368b07039dddc" translate="yes" xml:space="preserve">
          <source>Extended Bracketed Character Classes</source>
          <target state="translated">Классы с расширенными скобками</target>
        </trans-unit>
        <trans-unit id="08ad66702e505f4acfeb7ef02a28aef2a444692f" translate="yes" xml:space="preserve">
          <source>Extended Grapheme Clusters (Logical characters)</source>
          <target state="translated">Расширенные кластеры графем (логические символы)</target>
        </trans-unit>
        <trans-unit id="b408f65a0dc6251545ba8a1cae00a09cef180586" translate="yes" xml:space="preserve">
          <source>Extended Patterns</source>
          <target state="translated">Расширенные модели</target>
        </trans-unit>
        <trans-unit id="5acbb8b9cc41fceabb939a9490161468292c9ddc" translate="yes" xml:space="preserve">
          <source>Extended Unix Character. See ISO-2022.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57638586a902beff6d532df64e0c7307238ec6d1" translate="yes" xml:space="preserve">
          <source>Extended description and discussion of the program or functions, or the body of the documentation for man pages that document something else. If particularly long, it's a good idea to break this up into subsections &lt;code&gt;=head2&lt;/code&gt; directives like:</source>
          <target state="translated">Расширенное описание и обсуждение программы или функций, или основная часть документации для страниц руководства, которые документируют что-то еще. Если это особенно длинно, рекомендуется разбить его на директивы &lt;code&gt;=head2&lt;/code&gt; например:</target>
        </trans-unit>
        <trans-unit id="e1eee637af0775263c15116e6a9a092f2dd1ed43" translate="yes" xml:space="preserve">
          <source>Extended integer, Perl style. This can be either an optional leading plus or minus sign, followed by a sequence of digits, or an octal string (a zero, optionally followed by '0', '1', .. '7'), or a hexadecimal string (&lt;code&gt;0x&lt;/code&gt; followed by '0' .. '9', 'a' .. 'f', case insensitive), or a binary string (&lt;code&gt;0b&lt;/code&gt; followed by a series of '0' and '1').</source>
          <target state="translated">Расширенное целое число в стиле Perl. Это может быть либо необязательный начальный знак плюс или минус, за которым следует последовательность цифр, либо восьмеричная строка (ноль, за которой необязательно следует '0', '1', .. '7') или шестнадцатеричная строка ( &lt;code&gt;0x&lt;/code&gt; , за которым следует '0' .. '9', 'a' .. 'f', без учета регистра) или двоичная строка ( &lt;code&gt;0b&lt;/code&gt; , за которой следует последовательность из '0' и '1').</target>
        </trans-unit>
        <trans-unit id="7f8a27621bd1b83106ef3b26b5852eb1064f0fc5" translate="yes" xml:space="preserve">
          <source>Extended processing of command line options</source>
          <target state="translated">Расширенная обработка опций командной строки</target>
        </trans-unit>
        <trans-unit id="5db438e4dc97c2c680eb06228229b5484c1bdab3" translate="yes" xml:space="preserve">
          <source>Extending and Embedding Test::More</source>
          <target state="translated">Тест на расширение и встраивание::Больше</target>
        </trans-unit>
        <trans-unit id="8093cc064296db81eb0f5514264d7ee6d955b145" translate="yes" xml:space="preserve">
          <source>Extending it to csh patterns is left as an exercise to the reader.</source>
          <target state="translated">Распространение его на csh шаблоны оставлено в качестве упражнения для читателя.</target>
        </trans-unit>
        <trans-unit id="4e50bd25f128e6a96c634dc99854b32ea96ab716" translate="yes" xml:space="preserve">
          <source>Extending your Extension</source>
          <target state="translated">Продление срока действия</target>
        </trans-unit>
        <trans-unit id="4f8331dd312ba43f266e8a83a2d73cbbbec52b3f" translate="yes" xml:space="preserve">
          <source>Extension Layers</source>
          <target state="translated">Расширительные слои</target>
        </trans-unit>
        <trans-unit id="7e80c98508d4f62822b0432554091a536a41d48e" translate="yes" xml:space="preserve">
          <source>Extension Modules</source>
          <target state="translated">Модули расширения</target>
        </trans-unit>
        <trans-unit id="bd951e4e9e05b88a206b50063022ae727663d6c9" translate="yes" xml:space="preserve">
          <source>Extension based on</source>
          <target state="translated">Расширение на основе</target>
        </trans-unit>
        <trans-unit id="c6f2131d44d90eead55c47a30930686fccd53dcc" translate="yes" xml:space="preserve">
          <source>Extension based on .h and .c files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67518e197246f71238efe738515b0409050e6007" translate="yes" xml:space="preserve">
          <source>Extension based on _.h_ and _.c_ files</source>
          <target state="translated">Расширение,основанное на файлах _.h_и _.c_.</target>
        </trans-unit>
        <trans-unit id="4711cbf045a57cbff83b6f9f271bd795fbb6b53d" translate="yes" xml:space="preserve">
          <source>Extension methods</source>
          <target state="translated">Методы расширения</target>
        </trans-unit>
        <trans-unit id="cce4d271f69e77a8f0acdb625f0076753f28069c" translate="yes" xml:space="preserve">
          <source>Extension modules are written in C (or a mix of Perl and C). They are usually dynamically loaded into Perl if and when you need them, but may also be linked in statically. Supported extension modules include Socket, Fcntl, and POSIX.</source>
          <target state="translated">Модули расширения написаны на C (или смесь Perl и C).Обычно они динамически загружаются в Perl,если и когда вам это необходимо,но также могут быть связаны статически.Поддерживаемые модули расширений включают Socket,Fcntl и POSIX.</target>
        </trans-unit>
        <trans-unit id="60ffce38ec556078960f77c6601f9f4334d9b141" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of compound statements. These are introduced by a keyword which the extension recognizes, and the syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;&quot;PL_keyword_plugin&quot; in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c486c72e2c41ab9d29ece60988b5356674e74f" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of compound statements. These are introduced by a keyword which the extension recognizes, and the syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;PL_keyword_plugin in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="translated">Модули расширения также могут подключаться к анализатору Perl для определения новых видов составных операторов. Они вводятся ключевым словом, которое распознает расширение, а синтаксис, следующий за ключевым словом, полностью определяется расширением. Если вы разработчик, см. &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;PL_keyword_plugin в perlapi&lt;/a&gt; для получения информации о механизме. Если вы используете такой модуль, см. Документацию к модулю для получения подробной информации о синтаксисе, который он определяет.</target>
        </trans-unit>
        <trans-unit id="b6efb310f19bf6564f19089c880a0a0d87286db9" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of keyword-headed expression. These may look like functions, but may also look completely different. The syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;&quot;PL_keyword_plugin&quot; in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17db2bf16378aa10db2e67a8c2600f3a25122fec" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of keyword-headed expression. These may look like functions, but may also look completely different. The syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;PL_keyword_plugin in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="translated">Модули расширения также могут подключаться к синтаксическому анализатору Perl для определения новых видов выражений с заголовками ключевых слов. Они могут выглядеть как функции, но также могут выглядеть совершенно иначе. Синтаксис, следующий за ключевым словом, полностью определяется расширением. Если вы разработчик, см. &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;PL_keyword_plugin в perlapi,&lt;/a&gt; чтобы узнать о механизме. Если вы используете такой модуль, см. Документацию к модулю для получения подробной информации о синтаксисе, который он определяет.</target>
        </trans-unit>
        <trans-unit id="656bcfe284e2da39c77d4fdab55b16ad3c654719" translate="yes" xml:space="preserve">
          <source>Extensions</source>
          <target state="translated">Extensions</target>
        </trans-unit>
        <trans-unit id="6e975483dac372a5ca9dfd4b8e5e57b37a1180dd" translate="yes" xml:space="preserve">
          <source>Extensions and XS are, in theory, buildable by anyone using free tools. In practice, many don't, as users of the Acorn platform are used to binary distributions. MakeMaker does run, but no available make currently copes with MakeMaker's makefiles; even if and when this should be fixed, the lack of a Unix-like shell will cause problems with makefile rules, especially lines of the form &lt;code&gt;cd
sdbm &amp;amp;&amp;amp; make all&lt;/code&gt; , and anything using quoting.</source>
          <target state="translated">Теоретически расширения и XS могут создавать все, кто использует бесплатные инструменты. На практике многие этого не делают, поскольку пользователи платформы Acorn привыкли к двоичным дистрибутивам. MakeMaker работает, но ни одна из доступных в настоящее время make файлов не справляется с make-файлами MakeMaker; даже если и когда это должно быть исправлено, отсутствие Unix-подобной оболочки вызовет проблемы с правилами make-файла, особенно со строками в форме &lt;code&gt;cd sdbm &amp;amp;&amp;amp; make all&lt;/code&gt; и всем , что использует кавычки.</target>
        </trans-unit>
        <trans-unit id="23912b80f63053ec1a446ffda41e3d5c9d541b79" translate="yes" xml:space="preserve">
          <source>Extensions and XS are, in theory, buildable by anyone using free tools. In practice, many don't, as users of the Acorn platform are used to binary distributions. MakeMaker does run, but no available make currently copes with MakeMaker's makefiles; even if and when this should be fixed, the lack of a Unix-like shell will cause problems with makefile rules, especially lines of the form &lt;code&gt;cd sdbm &amp;amp;&amp;amp; make all&lt;/code&gt;, and anything using quoting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8be19ac765682f953ef7dfbb23fec79e7869c76" translate="yes" xml:space="preserve">
          <source>Extensions may be built either using the contents of the perl source directory tree or from the installed perl library. The recommended way is to build extensions after you have run 'make install' on perl itself. You can do that in any directory on your hard disk that is not below the perl source tree. The support for extensions below the ext directory of the perl distribution is only good for the standard extensions that come with perl.</source>
          <target state="translated">Расширения могут быть собраны как из содержимого дерева исходных каталогов perl,так и из установленной библиотеки perl.Рекомендуется собирать расширения после того,как вы запустили 'make install' на perl.Вы можете сделать это в любом каталоге на жестком диске,который не находится ниже дерева исходных текстов perl.Поддержка расширений,расположенных ниже каталога ext дистрибутива perl,хороша только для стандартных расширений,поставляемых вместе с perl.</target>
        </trans-unit>
        <trans-unit id="fd1105050ae42d352634f9a22fd2cfbe7c3340ac" translate="yes" xml:space="preserve">
          <source>Extensions.U</source>
          <target state="translated">Extensions.U</target>
        </trans-unit>
        <trans-unit id="8e77bd8de5230e7d94a54f34b54e4ee866ebaf07" translate="yes" xml:space="preserve">
          <source>External Subroutines (XS)</source>
          <target state="translated">Внешние подпрограммы (XS)</target>
        </trans-unit>
        <trans-unit id="fe58f6fb5713c9d9970ba20c8c7e99ac12d8ebd1" translate="yes" xml:space="preserve">
          <source>External scripts may be called by their basename. Perl will try the same extensions as when processing &lt;b&gt;-S&lt;/b&gt; command-line switch.</source>
          <target state="translated">Внешние скрипты могут вызываться по их базовому имени. Perl будет пробовать те же расширения, что и при обработке ключа командной строки &lt;b&gt;-S&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="ac98225101654b1670f972aaf6165f07d86a4dc2" translate="yes" xml:space="preserve">
          <source>External scripts starting with &lt;code&gt;#!&lt;/code&gt; or &lt;code&gt;extproc &lt;/code&gt; will be executed directly, without calling the shell, by calling the program specified on the rest of the first line.</source>
          <target state="translated">Внешние скрипты, начинающиеся с &lt;code&gt;#!&lt;/code&gt; или &lt;code&gt;extproc &lt;/code&gt; будет выполняться напрямую, без вызова оболочки, путем вызова программы, указанной в оставшейся части первой строки.</target>
        </trans-unit>
        <trans-unit id="26bf182753057236397eb723fd4891db5f117a3e" translate="yes" xml:space="preserve">
          <source>External subroutines (XSUBs) that maintain their own global state may not work correctly. Such XSUBs will either need to maintain locks to protect simultaneous access to global data from different pseudo-processes, or maintain all their state on the Perl symbol table, which is copied naturally when fork() is called. A callback mechanism that provides extensions an opportunity to clone their state will be provided in the near future.</source>
          <target state="translated">Внешние подпрограммы (XSUB),которые поддерживают свое собственное глобальное состояние,могут работать некорректно.Такие XSUBs должны будут либо поддерживать блокировки для защиты одновременного доступа к глобальным данным от различных псевдо-процессов,либо поддерживать все свое состояние на таблице символов Perl,которая естественным образом копируется при вызове fork().Механизм обратного вызова,обеспечивающий расширение возможности клонирования их состояния,будет предоставлен в ближайшем будущем.</target>
        </trans-unit>
        <trans-unit id="fc2399f06f4a8800f1e9f8c63e75b404573137c6" translate="yes" xml:space="preserve">
          <source>Extname</source>
          <target state="translated">Extname</target>
        </trans-unit>
        <trans-unit id="38bd9c2b38d963363075f657df2649a5a865d34f" translate="yes" xml:space="preserve">
          <source>Extra RECNO Methods</source>
          <target state="translated">Дополнительные методы RECNO</target>
        </trans-unit>
        <trans-unit id="080170d5c582217b07d6b630ccf123361bce391b" translate="yes" xml:space="preserve">
          <source>Extra arguments given to &lt;code&gt;subtest&lt;/code&gt; are passed to the callback. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f428c72b95856a35d58cb6523d1d9bf0d7e2e713" translate="yes" xml:space="preserve">
          <source>Extra debugging of how tries execute.</source>
          <target state="translated">Дополнительная отладка того,как пытаются выполнить.</target>
        </trans-unit>
        <trans-unit id="642e34f2d2485598d6a1289983f49ac33667a504" translate="yes" xml:space="preserve">
          <source>Extra debugging options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0f7f868e14cfcf2986def25df2bc4196200327" translate="yes" xml:space="preserve">
          <source>Extra layers can be inserted to process the data as it flows through. This was the driving need for including the scheme in perl 5.7.0+ - we needed a mechanism to allow data to be translated between perl's internal encoding (conceptually at least Unicode as UTF-8), and the &quot;native&quot; format used by the system. This is provided by the &quot;:encoding(xxxx)&quot; layer which typically sits above the buffering layer.</source>
          <target state="translated">Для обработки данных по мере их прохождения можно вставлять дополнительные слои.Это было вызвано необходимостью включения схемы в perl 5.7.0+-нам нужен был механизм,позволяющий переводить данные между внутренней кодировкой perl (концептуально как минимум Unicode в виде UTF-8)и &quot;родным&quot; форматом,используемым системой.Это обеспечивается слоем &quot;:кодировки(xxxx)&quot;,который обычно располагается над буферным слоем.</target>
        </trans-unit>
        <trans-unit id="678bd1bdccc15e114b793e04d18d631885eca63c" translate="yes" xml:space="preserve">
          <source>Extract delimited text sequences from strings.</source>
          <target state="translated">Извлечение из строк разделенных текстовых последовательностей.</target>
        </trans-unit>
        <trans-unit id="7254948dbbd318f1e97d0a1eeb40a1eb2d41c79b" translate="yes" xml:space="preserve">
          <source>Extract it like this</source>
          <target state="translated">Извлечь его вот так</target>
        </trans-unit>
        <trans-unit id="05a2f0e61aa11822c7799b10cf19bd9f231551af" translate="yes" xml:space="preserve">
          <source>Extract it to a spaceless path but not into the perl build source. Don't extract it into the same directory as celib. Make a copy of the &quot;wince-arm-pocket-wce300&quot; folder and rename the copy to &quot;wince-arm-pocket-wce400&quot;. This is a hack so we can build a CE 4.0 binary by linking in CE 3.0 ARM asm; the linker doesn't care. Windows Mobile/WinCE are backwards compatible with machine code like Desktop Windows.</source>
          <target state="translated">Извлеките его по безпространственному пути,но не в источник сборки perl.Не извлекайте его в тот же каталог,что и celib.Сделайте копию папки &quot;wince-arm-pocket-wce300&quot; и переименуйте её в &quot;wince-arm-pocket-wce400&quot;.Это хак,так что мы можем собрать двоичный файл CE 4.0,соединив его с CE 3.0 ARM asm;компоновщику все равно.Windows Mobile/WinCE обратно совместимы с машинным кодом,таким как Desktop Windows.</target>
        </trans-unit>
        <trans-unit id="7749ca362c5039000e30519eec908556e69a793e" translate="yes" xml:space="preserve">
          <source>Extract it to a spaceless path but not into the perl build source. I call this directory &quot;celib-palm-3.0&quot; but in the GitHub snapshot it will be called &quot;celib-master&quot;. Make a copy of the &quot;wince-arm-pocket-wce300-release&quot; folder and rename the copy to &quot;wince-arm-pocket-wce400&quot;. This is a hack so we can build a CE 4.0 binary by linking in CE 3.0 ARM asm; the linker doesn't care. Windows Mobile/WinCE are backwards compatible with machine code like Desktop Windows.</source>
          <target state="translated">Извлеките его по безпространственному пути,но не в источник сборки perl.Я называю этот каталог &quot;celib-palm-3.0&quot;,но в снимке GitHub он будет называться &quot;celib-master&quot;.Сделайте копию папки &quot;wince-arm-pocket-wce300-release&quot; и переименуйте её в &quot;wince-arm-pocket-wce400&quot;.Это хак,так что мы можем собрать двоичный файл CE 4.0,соединив его с CE 3.0 ARM asm;компоновщику всё равно.Windows Mobile/WinCE обратно совместимы с машинным кодом,таким как Desktop Windows.</target>
        </trans-unit>
        <trans-unit id="6a5aa60c177bb5d75235a8c111f9e4b6cea8ac1c" translate="yes" xml:space="preserve">
          <source>Extract selected sections of POD from input</source>
          <target state="translated">Извлечь выбранные участки POD из входа</target>
        </trans-unit>
        <trans-unit id="48348ed6315b959bdb6c19c5f46693033fe9a289" translate="yes" xml:space="preserve">
          <source>Extract this object, optionally to an alternative name.</source>
          <target state="translated">Извлеките этот объект,опционально под альтернативным именем.</target>
        </trans-unit>
        <trans-unit id="700d36da6316894ea4553b7a4764bc2e9b2ffb63" translate="yes" xml:space="preserve">
          <source>Extracted from core distribution for publishing on the CPAN by S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;sebastien (at) aperghis.net&amp;gt;.</source>
          <target state="translated">Извлечено из основного дистрибутива для публикации на CPAN Себастьяном Апергис-Трамони &amp;lt;sebastien (at) aperghis.net&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="8d01377458bb164941cbab45b0257bce76f2aaf1" translate="yes" xml:space="preserve">
          <source>Extracting Version Numbers from Perl Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33342b226b64c6cbc40d180e3ba186ad44a5f06f" translate="yes" xml:space="preserve">
          <source>Extracting matches</source>
          <target state="translated">Извлечение спичек</target>
        </trans-unit>
        <trans-unit id="16e9f64b08e09da9325dc889d58611a8376664da" translate="yes" xml:space="preserve">
          <source>Extracts a substring out of EXPR and returns it. First character is at offset zero. If OFFSET is negative, starts that far back from the end of the string. If LENGTH is omitted, returns everything through the end of the string. If LENGTH is negative, leaves that many characters off the end of the string.</source>
          <target state="translated">Извлекает подстроку из EXPR и возвращает ее.Первый символ находится в нулевом смещении.Если OFFSET отрицательный,начинается так далеко от конца строки.Если LENGTH опущен,возвращает все через конец строки.Если LENGTH отрицательный,оставляет так много символов вне конца строки.</target>
        </trans-unit>
        <trans-unit id="7e02013b2bc8b8b15efdd928d9932b054c7620a2" translate="yes" xml:space="preserve">
          <source>Extracts the contents of the tar file. The first argument can either be the name of the tar file to create or a reference to an open file handle (e.g. a GLOB reference). All relative paths in the tar file will be created underneath the current working directory.</source>
          <target state="translated">Извлекает содержимое файла tar.Первым аргументом может быть либо имя создаваемого tar-файла,либо ссылка на открытый дескриптор файла (например,GLOB-ссылка).Все относительные пути в tar-файле будут созданы под текущей рабочей директорией.</target>
        </trans-unit>
        <trans-unit id="885f6e090c877a36591aaa902dd00c6dd7b9efec" translate="yes" xml:space="preserve">
          <source>Extras.U</source>
          <target state="translated">Extras.U</target>
        </trans-unit>
        <trans-unit id="f680827447f98b26a0af418fbc0405801d7796f6" translate="yes" xml:space="preserve">
          <source>Extremely high code points were never specified in any standard, and require an extension to UTF-8 to express, which Perl does. It is likely that programs written in something other than Perl would not be able to read files that contain these; nor would Perl understand files written by something that uses a different extension. For these reasons, there is a separate set of flags that can warn and/or disallow these extremely high code points, even if other above-Unicode ones are accepted. They are the &lt;code&gt;UNICODE_WARN_PERL_EXTENDED&lt;/code&gt; and &lt;code&gt;UNICODE_DISALLOW_PERL_EXTENDED&lt;/code&gt; flags. For more information see &lt;a href=&quot;#UTF8_GOT_PERL_EXTENDED&quot;&gt;&quot;&lt;code&gt;UTF8_GOT_PERL_EXTENDED&lt;/code&gt;&quot;&lt;/a&gt;. Of course &lt;code&gt;UNICODE_DISALLOW_SUPER&lt;/code&gt; will treat all above-Unicode code points, including these, as malformations. (Note that the Unicode standard considers anything above 0x10FFFF to be illegal, but there are standards predating it that allow up to 0x7FFF_FFFF (2**31 -1))</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a686562152550b10f6394ec5f13fc276de5710" translate="yes" xml:space="preserve">
          <source>Extremely high code points were never specified in any standard, and require an extension to UTF-8 to express, which Perl does. It is likely that programs written in something other than Perl would not be able to read files that contain these; nor would Perl understand files written by something that uses a different extension. For these reasons, there is a separate set of flags that can warn and/or disallow these extremely high code points, even if other above-Unicode ones are accepted. They are the &lt;code&gt;UTF8_WARN_PERL_EXTENDED&lt;/code&gt; and &lt;code&gt;UTF8_DISALLOW_PERL_EXTENDED&lt;/code&gt; flags. For more information see &lt;a href=&quot;#UTF8_GOT_PERL_EXTENDED&quot;&gt;&quot;&lt;code&gt;UTF8_GOT_PERL_EXTENDED&lt;/code&gt;&quot;&lt;/a&gt;. Of course &lt;code&gt;UTF8_DISALLOW_SUPER&lt;/code&gt; will treat all above-Unicode code points, including these, as malformations. (Note that the Unicode standard considers anything above 0x10FFFF to be illegal, but there are standards predating it that allow up to 0x7FFF_FFFF (2**31 -1))</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f25b6a320c5687fd271f37b1ee97e7d69228f2" translate="yes" xml:space="preserve">
          <source>Extremely similar to open2(), open3() spawns the given $cmd and connects CHLD_OUT for reading from the child, CHLD_IN for writing to the child, and CHLD_ERR for errors. If CHLD_ERR is false, or the same file descriptor as CHLD_OUT, then STDOUT and STDERR of the child are on the same filehandle (this means that an autovivified lexical cannot be used for the STDERR filehandle, see SYNOPSIS). The CHLD_IN will have autoflush turned on.</source>
          <target state="translated">Чрезвычайно похожая на open2(),open3()порождает заданный $cmd и соединяет CHLD_OUT для чтения с дочерним,CHLD_IN для записи с дочерним,и CHLD_ERR для ошибок.Если CHLD_ERR-false,или тот же самый файловый дескриптор,что и CHLD_OUT,то STDOUT и STDERR дочернего элемента находятся в одной файловой оболочке (это означает,что для файловой оболочки STDERR нельзя использовать автоповидимый лексикон,см.SYNOPSIS).В CHLD_IN будет включена автопромывка.</target>
        </trans-unit>
        <trans-unit id="92eb55a6ceeed67d784ed90769a2d53fa3c77acb" translate="yes" xml:space="preserve">
          <source>Extremely similar to open2(), open3() spawns the given command and connects $chld_out for reading from the child, $chld_in for writing to the child, and $chld_err for errors. If $chld_err is false, or the same file descriptor as $chld_out, then STDOUT and STDERR of the child are on the same filehandle. This means that an autovivified lexical cannot be used for the STDERR filehandle, but gensym from &lt;a href=&quot;symbol&quot;&gt;Symbol&lt;/a&gt; can be used to vivify a new glob reference, see &lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;&lt;/a&gt;. The $chld_in will have autoflush turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2122187dffca50e0b79b010ea05ebfa6a4d1181" translate="yes" xml:space="preserve">
          <source>Extshortname</source>
          <target state="translated">Extshortname</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="ade1d38216915151ba7db0ce62f3199d7bf8e743" translate="yes" xml:space="preserve">
          <source>F:/bin</source>
          <target state="translated">F:/bin</target>
        </trans-unit>
        <trans-unit id="16a6231368962f338e8f37dfc91ca30753938154" translate="yes" xml:space="preserve">
          <source>FACET FIELDS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="3f8b9d0d8f1563ce34d8f76abc9faf53ac55bb32" translate="yes" xml:space="preserve">
          <source>FAQs, tricks and tips for &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65569c995a4785c8ee0ddac72f9a5d5496ad6056" translate="yes" xml:space="preserve">
          <source>FAQs, tricks and tips for &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; .</source>
          <target state="translated">Часто задаваемые вопросы, приемы и подсказки по &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dec5a3344b6b1da0ebe322bd0a2dfc8eb4528955" translate="yes" xml:space="preserve">
          <source>FATAL errors will cause the program to halt (&lt;code&gt;croak&lt;/code&gt; ), since the problem is so severe that it would be dangerous to continue. (This can always be trapped with &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but it's not a good idea. Under the circumstances, dying is the best thing to do).</source>
          <target state="translated">ФАТАЛЬНЫЕ ошибки приведут к остановке программы ( &lt;code&gt;croak&lt;/code&gt; ), поскольку проблема настолько серьезна, что было бы опасно продолжать. (Это всегда можно поймать с помощью &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , но это плохая идея. В данных обстоятельствах лучше всего умереть).</target>
        </trans-unit>
        <trans-unit id="6b6f2d1eafcc9e88114df946d6ac19bc0f376a0c" translate="yes" xml:space="preserve">
          <source>FATAL errors will cause the program to halt (&lt;code&gt;croak&lt;/code&gt;), since the problem is so severe that it would be dangerous to continue. (This can always be trapped with &lt;code&gt;eval&lt;/code&gt;, but it's not a good idea. Under the circumstances, dying is the best thing to do).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69754788a4c6beb4ec0ff140aa5c158dca3bfa2a" translate="yes" xml:space="preserve">
          <source>FB_CROAK</source>
          <target state="translated">FB_CROAK</target>
        </trans-unit>
        <trans-unit id="b626cf33b4a041c5ce4d521b41bf3a7b58bd485d" translate="yes" xml:space="preserve">
          <source>FB_DEFAULT</source>
          <target state="translated">FB_DEFAULT</target>
        </trans-unit>
        <trans-unit id="757934dd26eb29cb3152a5f387ec3d2edb168405" translate="yes" xml:space="preserve">
          <source>FB_PERLQQ FB_HTMLCREF FB_XMLCREF</source>
          <target state="translated">FB_PERLQQ FB_HTMLCREF FB_XMLCREF</target>
        </trans-unit>
        <trans-unit id="0a74cbd8c5cb0982de1a9bcfa6850e000455346d" translate="yes" xml:space="preserve">
          <source>FB_QUIET</source>
          <target state="translated">FB_QUIET</target>
        </trans-unit>
        <trans-unit id="0dd7f31fe0e5f67c669f4440fb273121e4c806e4" translate="yes" xml:space="preserve">
          <source>FB_WARN</source>
          <target state="translated">FB_WARN</target>
        </trans-unit>
        <trans-unit id="8e8b3f3bb48e9f1566f046dd9abec5d58654f4a5" translate="yes" xml:space="preserve">
          <source>FCNTL</source>
          <target state="translated">FCNTL</target>
        </trans-unit>
        <trans-unit id="47dadeeeb2bc9f5421eaa6bbbe50810a393d4c66" translate="yes" xml:space="preserve">
          <source>FEATURE BUNDLES</source>
          <target state="translated">ФУНКЦИОНАЛЬНЫЕ НАБОРЫ</target>
        </trans-unit>
        <trans-unit id="ec8e87c2f7d4da8aaca114d6270ea98cb522428f" translate="yes" xml:space="preserve">
          <source>FEATURES = less-&amp;gt;of()</source>
          <target state="translated">ОСОБЕННОСТИ = меньше-&amp;gt; из ()</target>
        </trans-unit>
        <trans-unit id="489edc9160737f1f5321c8439e0d90f85d95108c" translate="yes" xml:space="preserve">
          <source>FEEDBACK</source>
          <target state="translated">FEEDBACK</target>
        </trans-unit>
        <trans-unit id="a721f50a7a690a4a15e9a37c997197a6892fe7c1" translate="yes" xml:space="preserve">
          <source>FETCH</source>
          <target state="translated">FETCH</target>
        </trans-unit>
        <trans-unit id="a36834b47beb7b8fa9cc177881caffbc9273b059" translate="yes" xml:space="preserve">
          <source>FETCH this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b96ae35c4cdaf0d5015e044df05ffbf062155e" translate="yes" xml:space="preserve">
          <source>FETCH this, index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f0417b5bc981c089adeff175d8d240c193a1c5f" translate="yes" xml:space="preserve">
          <source>FETCH this, key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c895bf1dc50f257bb516434bac2edbda6ee48875" translate="yes" xml:space="preserve">
          <source>FETCHSIZE and STORESIZE are used to provide &lt;code&gt;$#array&lt;/code&gt; and equivalent &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; access.</source>
          <target state="translated">FETCHSIZE и STORESIZE используются для предоставления доступа к &lt;code&gt;$#array&lt;/code&gt; и эквивалентному &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; доступу.</target>
        </trans-unit>
        <trans-unit id="9a55d444e2f42ff3332a7b20892e03b42c0dde45" translate="yes" xml:space="preserve">
          <source>FETCHSIZE and STORESIZE are used to provide &lt;code&gt;$#array&lt;/code&gt; and equivalent &lt;code&gt;scalar(@array)&lt;/code&gt; access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655cf3f775d1131bb1cd13d50dcc9384058c7e74" translate="yes" xml:space="preserve">
          <source>FETCHSIZE returned a negative value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffdae04b785f3e9a65f525eb253a77d31047f28b" translate="yes" xml:space="preserve">
          <source>FETCHSIZE this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845bc45b1b1e5326c244df2ee7648f3ddd776170" translate="yes" xml:space="preserve">
          <source>FETCH_</source>
          <target state="translated">FETCH_</target>
        </trans-unit>
        <trans-unit id="05cf9a52ee9997400d322323b2f4f5f087799c04" translate="yes" xml:space="preserve">
          <source>FIELDS</source>
          <target state="translated">FIELDS</target>
        </trans-unit>
        <trans-unit id="07c257b16606b468b4287bbfd069963fcb6c04a5" translate="yes" xml:space="preserve">
          <source>FIFO</source>
          <target state="translated">FIFO</target>
        </trans-unit>
        <trans-unit id="3f799155fde6a8df0e53471e8ebc22e51aee5205" translate="yes" xml:space="preserve">
          <source>FIFO (named pipe).</source>
          <target state="translated">FIFO (названная труба).</target>
        </trans-unit>
        <trans-unit id="b4915d3a7ef82abdf96f2b5042452a69b2ea344c" translate="yes" xml:space="preserve">
          <source>FILE</source>
          <target state="translated">FILE</target>
        </trans-unit>
        <trans-unit id="188699dbc4f938b6c1d493b9b4e73beaae160b4d" translate="yes" xml:space="preserve">
          <source>FILE may contain Unicode characters outside the system codepage. Once the file has been created you can use Win32::GetANSIPathName() to get a name that can be passed to system calls and external programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1037b28078b931a2bcf7381d1504e913f7749ea4" translate="yes" xml:space="preserve">
          <source>FILEGV</source>
          <target state="translated">FILEGV</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
