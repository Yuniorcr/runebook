<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="b3c1ad83c7446d82ad768f4c14cbc6cf2bb28a0e" translate="yes" xml:space="preserve">
          <source>Note also that the whole range idea is rather unportable between character sets--and even within character sets they may cause results you probably didn't expect. A sound principle is to use only ranges that begin from and end at either alphabets of equal case (a-e, A-E), or digits (0-4). Anything else is unsafe. If in doubt, spell out the character sets in full.</source>
          <target state="translated">Заметьте также,что идея всего диапазона довольно непорядочна между наборами символов-и даже внутри наборов символов они могут привести к результатам,которых вы,вероятно,не ожидали.Звуковой принцип заключается в использовании только диапазонов,которые начинаются и заканчиваются либо на алфавитах одинакового регистра (a-e,A-E),либо на цифрах (0-4).Все остальное небезопасно.Если сомневаетесь,произнесите наборы символов полностью.</target>
        </trans-unit>
        <trans-unit id="e91fc700eef8c024136a19a3d1a25e4a4aec8312" translate="yes" xml:space="preserve">
          <source>Note also that there are some basic rules to using &quot;=over&quot; ... &quot;=back&quot; regions:</source>
          <target state="translated">Обратите внимание,что существуют некоторые основные правила использования &quot;=over&quot; ...&quot;=зад&quot; регионов:</target>
        </trans-unit>
        <trans-unit id="f240a6fbb992211509f6bddbfc9324c218ab462f" translate="yes" xml:space="preserve">
          <source>Note also that this is a minimum setup; you might want to add other packages of &lt;b&gt;ADE&lt;/b&gt; (the</source>
          <target state="translated">Также обратите внимание, что это минимальная настройка; вы можете добавить другие пакеты &lt;b&gt;ADE&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="8f0a8f1a21849e70b5e894c297b75fbda2be2da8" translate="yes" xml:space="preserve">
          <source>Note also that you &lt;b&gt;must&lt;/b&gt; consider the encoded value as atomic; i.e., you should not consider it as anything but an opaque, unanalysable string value. (The internals of the encoding method may change in future versions, as the language tagging standard changes over time.)</source>
          <target state="translated">Также обратите внимание, что вы &lt;b&gt;должны&lt;/b&gt; рассматривать закодированное значение как атомарное; то есть вы не должны рассматривать его как что-либо, кроме непрозрачного, не поддающегося анализу строкового значения. (Внутреннее устройство метода кодирования может измениться в будущих версиях, поскольку стандарт языковых тегов со временем меняется.)</target>
        </trans-unit>
        <trans-unit id="5bce497daf670728bb21a4272ea4f02098c78b3e" translate="yes" xml:space="preserve">
          <source>Note also the existence of &lt;code&gt;sv_catpvf&lt;/code&gt; and &lt;code&gt;sv_vcatpvfn&lt;/code&gt; , combining concatenation with formatting.</source>
          <target state="translated">Также обратите внимание на существование &lt;code&gt;sv_catpvf&lt;/code&gt; и &lt;code&gt;sv_vcatpvfn&lt;/code&gt; , сочетающих конкатенацию с форматированием.</target>
        </trans-unit>
        <trans-unit id="2c03a1bb63438d075c735c239a360c45cd5c5f8e" translate="yes" xml:space="preserve">
          <source>Note especially that &lt;code&gt;$cref-&amp;gt;&amp;amp;*&lt;/code&gt; is</source>
          <target state="translated">Обратите особое внимание на то, что &lt;code&gt;$cref-&amp;gt;&amp;amp;*&lt;/code&gt; - это</target>
        </trans-unit>
        <trans-unit id="329f3fa12538d44b63cb4bc769615094799f44fc" translate="yes" xml:space="preserve">
          <source>Note for BSD users: setting &lt;code&gt;$0&lt;/code&gt; does not completely remove &quot;perl&quot; from the ps(1) output. For example, setting &lt;code&gt;$0&lt;/code&gt; to &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; may result in &lt;code&gt;&quot;perl: foobar (perl)&quot;&lt;/code&gt; (whether both the &lt;code&gt;&quot;perl: &quot;&lt;/code&gt; prefix and the &quot; (perl)&quot; suffix are shown depends on your exact BSD variant and version). This is an operating system feature, Perl cannot help it.</source>
          <target state="translated">Примечание для пользователей BSD: установка &lt;code&gt;$0&lt;/code&gt; не полностью удаляет &quot;perl&quot; из вывода ps (1). Например, установка &lt;code&gt;$0&lt;/code&gt; на &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; может привести к &lt;code&gt;&quot;perl: foobar (perl)&quot;&lt;/code&gt; ( отображение префикса &lt;code&gt;&quot;perl: &quot;&lt;/code&gt; и суффикса &amp;laquo;(perl)&amp;raquo; зависит от вашего точного варианта и версии BSD). Это особенность операционной системы, Perl не может с этим поделать.</target>
        </trans-unit>
        <trans-unit id="7293fa6262cc45f7e2dbf5481215c1d362820f1d" translate="yes" xml:space="preserve">
          <source>Note for Linux and Debian GNU/kFreeBSD users: Before Perl v5.16.0 perl would emulate POSIX semantics on Linux systems using LinuxThreads, a partial implementation of POSIX Threads that has since been superseded by the Native POSIX Thread Library (NPTL).</source>
          <target state="translated">Замечание для пользователей Linux и Debian GNU/kFreeBSD:До версии Perl v5.16.0 perl эмулировал семантику POSIX на системах Linux с использованием LinuxThreads,частичной реализации POSIX Threads,которая с тех пор была заменена на Native POSIX Thread Library (NPTL).</target>
        </trans-unit>
        <trans-unit id="7aea9b8c7cfe32358e543467b0f84f66f59444bc" translate="yes" xml:space="preserve">
          <source>Note for Linux users: Between v5.8.1 and v5.16.0 Perl would work around non-POSIX thread semantics the minority of Linux systems (and Debian GNU/kFreeBSD systems) that used LinuxThreads, this emulation has since been removed. See the documentation for &lt;a href=&quot;../perlvar#%24%24&quot;&gt;$$&lt;/a&gt; for details.</source>
          <target state="translated">Примечание для пользователей Linux: Между версиями v5.8.1 и v5.16.0 Perl работал над семантикой потоков, отличных от POSIX, в меньшинстве систем Linux (и систем Debian GNU / kFreeBSD), которые использовали LinuxThreads, с тех пор эта эмуляция была удалена. Подробности смотрите в документации к &lt;a href=&quot;../perlvar#%24%24&quot;&gt;$$&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbdce38416b294a5283ce0536b64d8889c65db49" translate="yes" xml:space="preserve">
          <source>Note for Linux users: Between v5.8.1 and v5.16.0 Perl would work around non-POSIX thread semantics the minority of Linux systems (and Debian GNU/kFreeBSD systems) that used LinuxThreads, this emulation has since been removed. See the documentation for &lt;a href=&quot;perlvar#%24%24&quot;&gt;$$&lt;/a&gt; for details.</source>
          <target state="translated">Примечание для пользователей Linux: Между версиями v5.8.1 и v5.16.0 Perl работал над семантикой потоков, отличных от POSIX, в меньшинстве систем Linux (и систем Debian GNU / kFreeBSD), которые использовали LinuxThreads, с тех пор эта эмуляция была удалена. Подробности смотрите в документации к &lt;a href=&quot;perlvar#%24%24&quot;&gt;$$&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb69bfe72361defc6ffb1f69be5dc9409ce2ae2e" translate="yes" xml:space="preserve">
          <source>Note how the first and last entries are protected by quotes in order to protect the spaces.</source>
          <target state="translated">Обратите внимание,что первая и последняя записи защищены кавычками,чтобы защитить пробелы.</target>
        </trans-unit>
        <trans-unit id="b9400fb5715aebae33791834189bda7b7f0594aa" translate="yes" xml:space="preserve">
          <source>Note how the last three examples in the table above are treated specially by the parser. &lt;code&gt;mygrep()&lt;/code&gt; is parsed as a true list operator, &lt;code&gt;myrand()&lt;/code&gt; is parsed as a true unary operator with unary precedence the same as &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;mytime()&lt;/code&gt; is truly without arguments, just like &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt;. That is, if you say</source>
          <target state="translated">Обратите внимание, как последние три примера в приведенной выше таблице обрабатываются анализатором особым образом. &lt;code&gt;mygrep()&lt;/code&gt; анализируется как истинный оператор списка, &lt;code&gt;myrand()&lt;/code&gt; анализируется как истинный унарный оператор с унарным приоритетом, таким же, как и &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; , а &lt;code&gt;mytime()&lt;/code&gt; действительно без аргументов, как и &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; . То есть, если вы скажете</target>
        </trans-unit>
        <trans-unit id="32d61faf03809511f3cea1cbe82aa61f0b9ca92a" translate="yes" xml:space="preserve">
          <source>Note how we load the user pragma &lt;code&gt;myint&lt;/code&gt; with an empty list &lt;code&gt;()&lt;/code&gt; to prevent its &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; being called.</source>
          <target state="translated">Обратите внимание на то, как мы загружаем пользовательскую прагму &lt;code&gt;myint&lt;/code&gt; с пустым списком &lt;code&gt;()&lt;/code&gt; , чтобы предотвратить ее &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25c06a27ee940fb1ce392065b6dccdd03fd73088" translate="yes" xml:space="preserve">
          <source>Note however that some built-ins can't have their syntax expressed by a prototype (such as &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;). If you override them you won't be able to fully mimic their original syntax.</source>
          <target state="translated">Обратите внимание, однако, что синтаксис некоторых встроенных модулей не может быть выражен прототипом (например, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; ). Если вы переопределите их, вы не сможете полностью имитировать их исходный синтаксис.</target>
        </trans-unit>
        <trans-unit id="210da70db6283ccd39e5584b10f4c87c0f89d9d6" translate="yes" xml:space="preserve">
          <source>Note however that to use some of these operators you need to have a sh-syntax shell installed (see &lt;a href=&quot;#Pdksh&quot;&gt;Pdksh&lt;/a&gt;, &lt;a href=&quot;#Frequently-asked-questions&quot;&gt;Frequently asked questions&lt;/a&gt;), and perl should be able to find it (see &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;).</source>
          <target state="translated">Однако обратите внимание, что для использования некоторых из этих операторов у вас должна быть установлена ​​оболочка sh-синтаксиса (см. &lt;a href=&quot;#Pdksh&quot;&gt;Pdksh&lt;/a&gt; , &lt;a href=&quot;#Frequently-asked-questions&quot;&gt;Часто задаваемые вопросы&lt;/a&gt; ), и perl должен ее найти (см. &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6cd6d4fe1827d7816f9b8f3e1b0034bce7c56311" translate="yes" xml:space="preserve">
          <source>Note however, that this function does an exact match using &lt;code&gt;eq&lt;/code&gt; on the full path. So it cannot compensate for case-insensitive file- systems or compare 2 paths to see if they would point to the same underlying file.</source>
          <target state="translated">Обратите внимание, однако, что эта функция точно соответствует, используя &lt;code&gt;eq&lt;/code&gt; для полного пути. Таким образом, он не может компенсировать регистронезависимые файловые системы или сравнивать 2 пути, чтобы увидеть, указывают ли они на один и тот же базовый файл.</target>
        </trans-unit>
        <trans-unit id="e19273a97b7ee5052886f577d9a46a4421684819" translate="yes" xml:space="preserve">
          <source>Note however, that you need to have</source>
          <target state="translated">Обратите внимание,однако,что вы должны иметь</target>
        </trans-unit>
        <trans-unit id="507e6816311ba5923485459a746f4c205372d3f9" translate="yes" xml:space="preserve">
          <source>Note if you specify &lt;code&gt;-&lt;/code&gt; as the command, in an analogous fashion to &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;-|&quot;)&lt;/code&gt; the child process will just be the forked Perl process rather than an external command. This feature isn't yet supported on Win32 platforms.</source>
          <target state="translated">Обратите внимание: если вы укажете &lt;code&gt;-&lt;/code&gt; в качестве команды, аналогично для &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;-|&quot;)&lt;/code&gt; дочерний процесс будет просто разветвленным процессом Perl, а не внешней командой. Эта функция еще не поддерживается на платформах Win32.</target>
        </trans-unit>
        <trans-unit id="da9342b413d4bbcd1dc6fe59e3ee28645b823224" translate="yes" xml:space="preserve">
          <source>Note in the last example, the end of the string is considered a word boundary.</source>
          <target state="translated">Обратите внимание,что в последнем примере конец строки считается границей слова.</target>
        </trans-unit>
        <trans-unit id="07e19a6ca0b876d2709ab0ec0dfc79383c491dc1" translate="yes" xml:space="preserve">
          <source>Note on ISO-2022-JP(-1)?</source>
          <target state="translated">Обратите внимание на ISO-2022-JP(-1)?</target>
        </trans-unit>
        <trans-unit id="b88ed054c638a5f7768e2dd282a5e1b35bab783a" translate="yes" xml:space="preserve">
          <source>Note on Step 7: some operators have a different semantic depending on the type of their operands. As there is no way to instruct Perl to treat the operands as, e.g., numbers instead of strings, the result here may not be what you expect. See &lt;a href=&quot;#BUGS-AND-PITFALLS&quot;&gt;BUGS AND PITFALLS&lt;/a&gt;.</source>
          <target state="translated">Примечание к шагу 7: некоторые операторы имеют разную семантику в зависимости от типа их операндов. Поскольку нет способа указать Perl обрабатывать операнды как, например, числа, а не строки, результат может быть не таким, как вы ожидаете. См. &lt;a href=&quot;#BUGS-AND-PITFALLS&quot;&gt;ОШИБКИ И АВАРИИ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15bc1023efea2381a2db802c419cf3e98569e03f" translate="yes" xml:space="preserve">
          <source>Note on the format of the urllist parameter</source>
          <target state="translated">Обратите внимание на формат параметра urllist</target>
        </trans-unit>
        <trans-unit id="cc738b8cb2fe5493887c63f096423e4e822a4785" translate="yes" xml:space="preserve">
          <source>Note particularly that $x continues to refer to the value passed into newprint()</source>
          <target state="translated">Обратите внимание,в частности,что $x продолжает относиться к значению,передаваемому в newprint()</target>
        </trans-unit>
        <trans-unit id="977ff75717e2ad5549c27c1fec3fb1a8727cd2e9" translate="yes" xml:space="preserve">
          <source>Note several important features of this example. First of all, the</source>
          <target state="translated">Обратите внимание на несколько важных особенностей этого примера.Прежде всего</target>
        </trans-unit>
        <trans-unit id="99e506d24bb1d2d8c0953ced78837622f6175e3d" translate="yes" xml:space="preserve">
          <source>Note that &quot;&amp;lt;&amp;amp;STDIN&quot; makes a copy, but &quot;&amp;lt;&amp;amp;=STDIN&quot; makes an alias. That means if you close an aliased handle, all aliases become inaccessible. This is not true with a copied one.</source>
          <target state="translated">Обратите внимание, что &amp;laquo;&amp;lt;&amp;amp; STDIN&amp;raquo; создает копию, а &amp;laquo;&amp;lt;&amp;amp; = STDIN&amp;raquo; создает псевдоним. Это означает, что если вы закроете дескриптор с псевдонимом, все псевдонимы станут недоступны. Это не так с копией.</target>
        </trans-unit>
        <trans-unit id="760e35c71509b97a49875e6fc164a9d4be791312" translate="yes" xml:space="preserve">
          <source>Note that $x is still printed as having its true non-integer value of 5.8 since it wasn't operated on. And note too the wrap-around from the largest positive integer to the largest negative one. Also, arguments passed to functions and the values returned by them are &lt;b&gt;not&lt;/b&gt; affected by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; . E.g.,</source>
          <target state="translated">Обратите внимание, что $ x по-прежнему печатается со своим истинным нецелым значением 5,8, поскольку с ним не работали. Также обратите внимание на переход от наибольшего положительного целого числа к наибольшему отрицательному. Кроме того, аргументы, передаваемые функциям, и возвращаемые ими значения &lt;b&gt;не&lt;/b&gt; зависят от &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; . Например,</target>
        </trans-unit>
        <trans-unit id="e599f385e86c967c815cb5ac633fbf5c8b743e32" translate="yes" xml:space="preserve">
          <source>Note that &amp;lt;FILE&amp;gt; is</source>
          <target state="translated">Обратите внимание, что &amp;lt;FILE&amp;gt; - это</target>
        </trans-unit>
        <trans-unit id="f28b0b3d67592306ce241a091fd7fa4b9b9390b5" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#make_iterator&quot;&gt;make_iterator&lt;/a&gt; has been</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;#make_iterator&quot;&gt;make_iterator&lt;/a&gt; был</target>
        </trans-unit>
        <trans-unit id="d5449cbba5d5e7a82db88f55e4440d98e4342ea0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../dynaloader&quot;&gt;DynaLoader&lt;/a&gt; is a special case where it must call &lt;code&gt;boot_DynaLoader&lt;/code&gt; directly.</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;../dynaloader&quot;&gt;DynaLoader&lt;/a&gt; - это особый случай, когда он должен вызывать &lt;code&gt;boot_DynaLoader&lt;/code&gt; напрямую.</target>
        </trans-unit>
        <trans-unit id="d2b414b3045e4a13e62684509b81beee13f1a03b" translate="yes" xml:space="preserve">
          <source>Note that &lt;b&gt;-S&lt;/b&gt; switch supports scripts with additional extensions</source>
          <target state="translated">Обратите внимание, что переключатель &lt;b&gt;-S&lt;/b&gt; поддерживает скрипты с дополнительными расширениями.</target>
        </trans-unit>
        <trans-unit id="df5cabe56a3fab1a8dfd7142a90c482f8fae0efd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; has lower priority than relational operators, so for example the parentheses are essential in a test like</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; имеет более низкий приоритет, чем реляционные операторы, поэтому, например, круглые скобки важны в тестах вроде</target>
        </trans-unit>
        <trans-unit id="522782427bfce1d8f14995dfc30aaa97199ffa5d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;ADFS::HardDisk.$.File&quot; ne 'ADFS::HardDisk.$.File'&lt;/code&gt; and that the second stage of &lt;code&gt;$&lt;/code&gt; interpolation in regular expressions will fall foul of the &lt;code&gt;$.&lt;/code&gt; if scripts are not careful.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&quot;ADFS::HardDisk.$.File&quot; ne 'ADFS::HardDisk.$.File'&lt;/code&gt; и что второй этап интерполяции &lt;code&gt;$&lt;/code&gt; в регулярных выражениях не соответствует значению &lt;code&gt;$.&lt;/code&gt; если скрипты неосторожны.</target>
        </trans-unit>
        <trans-unit id="12ecea42a6af74c63b7121532319090437ea634b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;|&quot;&lt;/code&gt; and &lt;code&gt;&quot;^&quot;&lt;/code&gt; have lower priority than relational operators, so for example the parentheses are essential in a test like</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&quot;|&quot;&lt;/code&gt; и &lt;code&gt;&quot;^&quot;&lt;/code&gt; имеют более низкий приоритет, чем реляционные операторы, поэтому, например, круглые скобки важны в тестах вроде</target>
        </trans-unit>
        <trans-unit id="79eafdbed824b09455353e30518fbddb877197c5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Similarly, grep returns aliases into the original list, much as a for loop's index variable aliases the list elements. That is, modifying an element of a list returned by grep (for example, in a &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; or another &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;) actually modifies the element in the original list. This is usually something to be avoided when writing clear code.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;$_&lt;/code&gt; является псевдонимом значения списка, поэтому его можно использовать для изменения элементов LIST. Хотя это полезно и поддерживается, это может привести к странным результатам, если элементы LIST не являются переменными. Точно так же grep возвращает псевдонимы в исходный список, так же как индексная переменная цикла for создает псевдонимы элементов списка. То есть изменение элемента списка, возвращаемого grep (например, в &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; или другом &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; ), фактически изменяет элемент в исходном списке. Обычно этого следует избегать при написании четкого кода.</target>
        </trans-unit>
        <trans-unit id="922c04cd95d993e5139c2b97058698400e67f636" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Similarly, grep returns aliases into the original list, much as a for loop's index variable aliases the list elements. That is, modifying an element of a list returned by grep (for example, in a &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; or another &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;) actually modifies the element in the original list. This is usually something to be avoided when writing clear code.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;$_&lt;/code&gt; является псевдонимом значения списка, поэтому его можно использовать для изменения элементов LIST. Хотя это полезно и поддерживается, это может привести к странным результатам, если элементы LIST не являются переменными. Точно так же grep возвращает псевдонимы в исходный список, так же как индексная переменная цикла for создает псевдонимы элементов списка. То есть изменение элемента списка, возвращаемого grep (например, в &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; или другом &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; ), фактически изменяет элемент в исходном списке. Обычно этого следует избегать при написании четкого кода.</target>
        </trans-unit>
        <trans-unit id="ea689de74e82f416fbcbf4ee9e4cea8733686d01" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;#grep&quot;&gt;grep&lt;/a&gt; for an array composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;$_&lt;/code&gt; является псевдонимом значения списка, поэтому его можно использовать для изменения элементов LIST. Хотя это полезно и поддерживается, это может привести к странным результатам, если элементы LIST не являются переменными. В большинстве случаев &lt;code&gt;foreach&lt;/code&gt; для этой цели обычный цикл foreach . См. Также &lt;a href=&quot;#grep&quot;&gt;grep&lt;/a&gt; для массива, состоящего из тех элементов исходного списка, для которых BLOCK или EXPR оцениваются как истинные.</target>
        </trans-unit>
        <trans-unit id="e54794d0f40f1a8695668c788a3a5c6d8b245de4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt; for an array composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;$_&lt;/code&gt; является псевдонимом значения списка, поэтому его можно использовать для изменения элементов LIST. Хотя это полезно и поддерживается, это может привести к странным результатам, если элементы LIST не являются переменными. В большинстве случаев &lt;code&gt;foreach&lt;/code&gt; для этой цели обычный цикл foreach . См. Также &lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt; для массива, состоящего из тех элементов исходного списка, для которых BLOCK или EXPR оцениваются как истинные.</target>
        </trans-unit>
        <trans-unit id="ff224648e7f90554d343ed0de97c9efcc8456e37" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$processed&lt;/code&gt; may be empty (when &lt;code&gt;$normalized&lt;/code&gt; contains no starter or starts with the last starter), and then &lt;code&gt;$unprocessed&lt;/code&gt; should be equal to the entire &lt;code&gt;$normalized&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;$processed&lt;/code&gt; может быть пустым (когда &lt;code&gt;$normalized&lt;/code&gt; содержит стартера или начинается с последнего стартера), и тогда &lt;code&gt;$unprocessed&lt;/code&gt; должно быть равно полному &lt;code&gt;$normalized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd002d9c23fd4dcc51fd0e853c891c09f321ec46" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;-s/a/b/&lt;/code&gt; не выполняет замену с отрицанием. Однако выражение &lt;code&gt;-&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; прежнему работает должным образом: только отдельные буквы, следующие за минусом, интерпретируются как проверки файлов.</target>
        </trans-unit>
        <trans-unit id="dd375a04334c45f998942d7896c30f702e8152ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;-s/a/b/&lt;/code&gt; не выполняет замену с отрицанием. Однако выражение &lt;code&gt;-&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; прежнему работает должным образом: только отдельные буквы, следующие за минусом, интерпретируются как проверки файлов.</target>
        </trans-unit>
        <trans-unit id="48bc3a755225cb163af628efdd36b7e99bf599a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;:constants256&lt;/code&gt; does not include the other constants, so if you want to mix both, you need to include &lt;code&gt;:constants&lt;/code&gt; as well. You may want to explicitly import at least &lt;code&gt;RESET&lt;/code&gt; , as in:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;:constants256&lt;/code&gt; не включает другие константы, поэтому, если вы хотите смешать обе, вам также необходимо включить &lt;code&gt;:constants&lt;/code&gt; . Вы можете явно импортировать как минимум &lt;code&gt;RESET&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="f3a3c31d64bd9d3852dee2165f0cdbe3c7fd1617" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;../../functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; are the totals of the wait and exit statuses of each of the tests. These values are totalled only to provide a true value if any of them are non-zero.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;../../functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; - это итоги статусов ожидания и выхода каждого из тестов. Эти значения суммируются только для получения истинного значения, если любое из них не равно нулю.</target>
        </trans-unit>
        <trans-unit id="9173a2f0f306c97db5af943fc6a5b25c88ebded1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; are not listed above. If called as methods on a Time::Piece object, they act as constructors, returning a new Time::Piece object for the current time. In other words: they're not useful as methods.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; не указаны выше. Если они вызываются как методы объекта Time :: Piece, они действуют как конструкторы, возвращая новый объект Time :: Piece для текущего времени. Другими словами: они бесполезны как методы.</target>
        </trans-unit>
        <trans-unit id="9ce1c937ab3425a64de9dbc02778e5245a104b13" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; returns the last character. To return all but the last character, use &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; возвращает последний символ. Чтобы вернуть все символы, кроме последнего, используйте &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37ddc1b7985e6cde1bfecc807084dd2439da4505" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; не будет вызывать ваши блоки &lt;code&gt;END&lt;/code&gt; и не будет вызывать методы &lt;code&gt;DESTROY&lt;/code&gt; для ваших объектов.</target>
        </trans-unit>
        <trans-unit id="a60dfdd6e65097f6c305737073a8bc35fe255a7e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; raises an exception if used on a machine that doesn't implement fcntl(2). See the Fcntl module or your fcntl(2) manpage to learn what functions are available on your system.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; вызывает исключение, если используется на машине, которая не реализует fcntl (2). См. Модуль Fcntl или справочную страницу fcntl (2), чтобы узнать, какие функции доступны в вашей системе.</target>
        </trans-unit>
        <trans-unit id="dfb2038f7135091071546cb9a6d373bb9a56e94d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; is generally not necessary when using normal filehandles; it is provided so that you can control I/O to existing record-structured files when necessary. You can also use the &lt;code&gt;vmsfopen&lt;/code&gt; function in the VMS::Stdio extension to gain finer control of I/O to files and devices with different record structures.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; обычно не требуется при использовании обычных файловых дескрипторов; он предоставляется для того, чтобы при необходимости вы могли управлять вводом-выводом в существующие файлы со структурой записей. Вы можете также использовать &lt;code&gt;vmsfopen&lt;/code&gt; функцию расширения VMS :: STDIO , чтобы получить более тонкий контроль ввода / вывода файлов и устройств с различными структурами записей.</target>
        </trans-unit>
        <trans-unit id="bb9b28a9d5d46f3c748ef4753fd4b0b26da11633" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; returns the last character. To return all but the last character, use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; возвращает последний символ. Чтобы вернуть все символы, кроме последнего, используйте &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2886ca2fd4621ed375e17bc5caf418ae86a77d6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; не будет вызывать ваши блоки &lt;code&gt;END&lt;/code&gt; и не будет вызывать методы &lt;code&gt;DESTROY&lt;/code&gt; для ваших объектов.</target>
        </trans-unit>
        <trans-unit id="f249c4d8b204567737cd31f8ec07948c8d5ac294" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; raises an exception if used on a machine that doesn't implement fcntl(2). See the Fcntl module or your fcntl(2) manpage to learn what functions are available on your system.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; вызывает исключение, если используется на машине, которая не реализует fcntl (2). См. Модуль Fcntl или справочную страницу fcntl (2), чтобы узнать, какие функции доступны в вашей системе.</target>
        </trans-unit>
        <trans-unit id="d7d9c1784c1fe9a279665a4571e3c21c04751dcb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; разбивает свои аргументы на пробелы и обрабатывает каждый сегмент как отдельный образец. Таким образом, &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; соответствует всем файлам с</target>
        </trans-unit>
        <trans-unit id="dd0f76b7382c19ee434e95709a48f61a31e19d7a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9&lt;/code&gt; does not work with the current version of EMX.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9&lt;/code&gt; не работает с текущей версией EMX.</target>
        </trans-unit>
        <trans-unit id="d132135000cd2c7bd9f4aab4e6bdef7ae41bf7a4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; depends on the fdopen() C library function. On many Unix systems, fdopen() is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the POSIX::open() function.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; зависит от библиотечной функции fdopen () C. Во многих системах Unix известно, что fdopen () завершается ошибкой, когда файловые дескрипторы превышают определенное значение, обычно 255. Если вам нужно больше файловых дескрипторов, рассмотрите возможность использования функции POSIX :: open ().</target>
        </trans-unit>
        <trans-unit id="967dccf72de487894a0bc580911ae2819ad24053" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; does &lt;b&gt;not&lt;/b&gt; do regular expression character classes such as &lt;code&gt;\d&lt;/code&gt; or &lt;code&gt;\pL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; operator is not equivalent to the &lt;code&gt;&lt;i&gt;tr(1)&lt;/i&gt;&lt;/code&gt; utility. If you want to map strings between lower/upper cases, see &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; and &lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;, and in general consider using the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; operator if you need regular expressions. The &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , and &lt;code&gt;\l&lt;/code&gt; string-interpolation escapes on the right side of a substitution operator will perform correct case-mappings, but &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[a-z][A-Z]&lt;/a&gt;&lt;/code&gt; will not (except sometimes on legacy 7-bit data).</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; вовсе &lt;b&gt;не&lt;/b&gt; делать регулярные занятия выражением характера , такие как &lt;code&gt;\d&lt;/code&gt; или &lt;code&gt;\pL&lt;/code&gt; . Оператор &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; не эквивалентен утилите &lt;code&gt;&lt;i&gt;tr(1)&lt;/i&gt;&lt;/code&gt; . Если вы хотите отображать строки между нижним и верхним регистрами, см. &lt;a href=&quot;functions/lc&quot;&gt;Lc&lt;/a&gt; и &lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt; , и вообще рассмотрите возможность использования оператора &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , если вам нужны регулярные выражения. &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , а &lt;code&gt;\l&lt;/code&gt; строка-интерполяция побеги на правой стороне оператора замещения будет выполнять правильные тематические отображения, но &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[a-z][A-Z]&lt;/a&gt;&lt;/code&gt; не будет (кроме случаев, когда используются устаревшие 7-битные данные).</target>
        </trans-unit>
        <trans-unit id="1a25e1352e6c84bdaa3b67f15d7d22519e3dc2fd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\U&lt;/code&gt; in interpolated strings, translates to uppercase, while &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\u&lt;/code&gt; in interpolated strings, translates to titlecase in languages that make the distinction (which is equivalent to uppercase in languages without the distinction).</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;\U&lt;/code&gt; в интерполированных строках переводится в верхний регистр, тогда как &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;\u&lt;/code&gt; в интерполированных строках переводится в titlecase в языках, которые делают различие (что эквивалентно прописным буквам в языках без различия).</target>
        </trans-unit>
        <trans-unit id="f7309bf49e0287f1d8c15ab22ef310f10a5d4bd7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; разбивает свои аргументы на пробелы и обрабатывает каждый сегмент как отдельный образец. Таким образом, &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; соответствует всем файлам с</target>
        </trans-unit>
        <trans-unit id="986549b394dff5a5a4195bbc3a0e0761106da86b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; depends on the fdopen() C library function. On many Unix systems, fdopen() is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the POSIX::open() function.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; зависит от библиотечной функции fdopen () C. Во многих системах Unix известно, что fdopen () завершается ошибкой, когда файловые дескрипторы превышают определенное значение, обычно 255. Если вам нужно больше файловых дескрипторов, рассмотрите возможность использования функции POSIX :: open ().</target>
        </trans-unit>
        <trans-unit id="79f5400ae4c62646c847435cddda21b4c40e3a93" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Dump&lt;/code&gt; will not report</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;Dump&lt;/code&gt; не сообщает</target>
        </trans-unit>
        <trans-unit id="14efce4f98a6d3ded52ecf9f7ef2c0c61f9e5d1c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;END&lt;/code&gt; code blocks are &lt;b&gt;not&lt;/b&gt; executed at the end of a string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;: if any &lt;code&gt;END&lt;/code&gt; code blocks are created in a string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;, they will be executed just as any other &lt;code&gt;END&lt;/code&gt; code block of that package in LIFO order just before the interpreter is being exited.</source>
          <target state="translated">Обратите внимание, что блоки кода &lt;code&gt;END&lt;/code&gt; &lt;b&gt;не&lt;/b&gt; выполняются в конце строки &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; : если какие-либо блоки кода &lt;code&gt;END&lt;/code&gt; созданы в строке &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; , они будут выполняться так же, как любой другой блок кода &lt;code&gt;END&lt;/code&gt; этого пакета в порядке LIFO, просто до выхода из интерпретатора.</target>
        </trans-unit>
        <trans-unit id="6b4c9a20647174655acdade54ceb924854974320" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Math::BigFloat-&amp;gt;accuracy()&lt;/code&gt; and &lt;code&gt;Math::BigFloat-&amp;gt;precision()&lt;/code&gt; set the global variables, and thus &lt;b&gt;any&lt;/b&gt; newly created number will be subject to the global rounding &lt;b&gt;immediately&lt;/b&gt;. This means that in the examples above, the &lt;code&gt;3&lt;/code&gt; as argument to &lt;code&gt;bdiv()&lt;/code&gt; will also get an accuracy of &lt;b&gt;5&lt;/b&gt;.</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;Math::BigFloat-&amp;gt;accuracy()&lt;/code&gt; и &lt;code&gt;Math::BigFloat-&amp;gt;precision()&lt;/code&gt; установить глобальные переменные, и , таким образом , &lt;b&gt;любой&lt;/b&gt; вновь созданный номер будет зависеть от глобального округления &lt;b&gt;немедленно&lt;/b&gt; . Это означает, что в приведенных выше примерах точность &lt;code&gt;3&lt;/code&gt; as для &lt;code&gt;bdiv()&lt;/code&gt; также будет равна &lt;b&gt;5&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d2356c11b794082befde64b563384a96e7b0173c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;NULL&lt;/code&gt; is a valid &lt;code&gt;proto&lt;/code&gt; and will always return &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;NULL&lt;/code&gt; является допустимым &lt;code&gt;proto&lt;/code&gt; и всегда будет возвращать &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb94a8fcace7106b0c7ce3250a66c0e461c261b7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;STDERR&lt;/code&gt; WILL NOT be changed, regardless.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;STDERR&lt;/code&gt; НЕ БУДЕТ изменен, в любом случае.</target>
        </trans-unit>
        <trans-unit id="3dc8a38e3cc3af9d760a1ed60a8a353aa279d10b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;TAP::Parser&lt;/code&gt; is designed to be the central &quot;maker&quot; - ie: it is responsible for creating most new objects in the &lt;code&gt;TAP::Parser::*&lt;/code&gt; namespace.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;TAP::Parser&lt;/code&gt; разработан как центральный &amp;laquo;производитель&amp;raquo;, то есть: он отвечает за создание большинства новых объектов в пространстве имен &lt;code&gt;TAP::Parser::*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4f8d4428f9f4403397e153eb6c9a469d63599ed" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;UNIVERSAL&lt;/code&gt; (and any members of &lt;code&gt;UNIVERSAL&lt;/code&gt; 's MRO) are not part of the MRO of a class, even though all classes implicitly inherit methods from &lt;code&gt;UNIVERSAL&lt;/code&gt; and its parents.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;UNIVERSAL&lt;/code&gt; (и любые члены MRO &lt;code&gt;UNIVERSAL&lt;/code&gt; ) не являются частью MRO класса, даже если все классы неявно наследуют методы &lt;code&gt;UNIVERSAL&lt;/code&gt; и его родителей.</target>
        </trans-unit>
        <trans-unit id="40891c11dca9d7b7c3291116c4d74a2cf45b3046" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N&lt;/code&gt; has two meanings. When of the form &lt;code&gt;\N{NAME}&lt;/code&gt; , it matches the character or character sequence whose name is &lt;code&gt;NAME&lt;/code&gt; ; and similarly when of the form &lt;code&gt;\N{U+&lt;i&gt;hex&lt;/i&gt;}&lt;/code&gt;, it matches the character whose Unicode code point is</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;\N&lt;/code&gt; имеет два значения. Когда имеет форму &lt;code&gt;\N{NAME}&lt;/code&gt; , он соответствует символу или последовательности символов, имя которой - &lt;code&gt;NAME&lt;/code&gt; ; и аналогично, когда он имеет форму &lt;code&gt;\N{U+&lt;i&gt;hex&lt;/i&gt;}&lt;/code&gt; , он соответствует символу, чья кодовая точка Unicode -</target>
        </trans-unit>
        <trans-unit id="6fec90a9c83208c9ab833401f72e3ba22b8885c3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; can mean a &lt;a href=&quot;#Named-or-numbered-characters-and-character-sequences&quot;&gt;named or numbered character &lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;\N{...}&lt;/code&gt; может означать &lt;a href=&quot;#Named-or-numbered-characters-and-character-sequences&quot;&gt;именованный или нумерованный символ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c272dee08a4ec0d279e74b44ce54c8507ca63ec0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; is compile-time; it's a special form of string constant used inside double-quotish strings; this means that you cannot use variables inside the &lt;code&gt;\N{...}&lt;/code&gt; . If you want similar run-time functionality, use &lt;a href=&quot;#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame()&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;\N{...}&lt;/code&gt; - время компиляции; это особая форма строковой константы, используемая внутри строк, заключенных в двойные кавычки; это означает, что вы не можете использовать переменные внутри &lt;code&gt;\N{...}&lt;/code&gt; . Если вам нужна аналогичная функциональность во время выполнения, используйте &lt;a href=&quot;#charnames%3a%3astring_vianame(name)&quot;&gt;charnames :: string_vianame ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fd4812fc895b96b92cb32be1e45c1db5eaf35e8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{U+&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt;, where the</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;\N{U+&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt; , где</target>
        </trans-unit>
        <trans-unit id="591330d2defbab5242891eb86fdca8e3950ac9ed" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\c\&lt;/code&gt; alone at the end of a regular expression (or doubled-quoted string) is not valid. The backslash must be followed by another character. That is, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; means &lt;code&gt;chr(28) . '&lt;i&gt;X&lt;/i&gt;'&lt;/code&gt; for all characters</source>
          <target state="translated">Обратите внимание, что один &lt;code&gt;\c\&lt;/code&gt; в конце регулярного выражения (или строки в двойных кавычках) недопустим. За обратной косой чертой должен следовать другой символ. То есть &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; означает &lt;code&gt;chr(28) . '&lt;i&gt;X&lt;/i&gt;'&lt;/code&gt; для всех символов</target>
        </trans-unit>
        <trans-unit id="0564917393e190d68550cf153ec3fa749f8ef1c2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;blessed($thing)&lt;/code&gt; will also return false if &lt;code&gt;$thing&lt;/code&gt; has been blessed into a class named &quot;0&quot;. This is a possible, but quite pathological. Don't create a class named &quot;0&quot; unless you know what you're doing.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;blessed($thing)&lt;/code&gt; также вернет false, если &lt;code&gt;$thing&lt;/code&gt; был благословлен в класс с именем &quot;0&quot;. Это возможно, но довольно патологично. Не создавайте класс с именем &amp;laquo;0&amp;raquo;, если вы не знаете, что делаете.</target>
        </trans-unit>
        <trans-unit id="a119dbc9113a7d44b6376d76a949b8d8575c309d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;gen_delimited_pat&lt;/code&gt; was previously called &lt;code&gt;delimited_pat&lt;/code&gt; . That name may still be used, but is now deprecated.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;gen_delimited_pat&lt;/code&gt; ранее назывался &lt;code&gt;delimited_pat&lt;/code&gt; . Это имя все еще можно использовать, но оно устарело.</target>
        </trans-unit>
        <trans-unit id="c0da4f2ba6d0cf36f2dd51c6be576bdda729bf43" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;make_source&lt;/code&gt; &amp;amp; &lt;code&gt;make_perl_source&lt;/code&gt; have been</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;make_source&lt;/code&gt; и &lt;code&gt;make_perl_source&lt;/code&gt; были</target>
        </trans-unit>
        <trans-unit id="cb4cf0c7c42248024c78a0bb26a98cce7a24f07e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;openlog()&lt;/code&gt; now takes three arguments, just like &lt;code&gt;openlog(3)&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;openlog()&lt;/code&gt; теперь принимает три аргумента, как и &lt;code&gt;openlog(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3174509a7760d68363f8a3d59612b5b0d75c608" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;size&lt;/code&gt; is the full size of the destination buffer and the result is guaranteed to be &lt;code&gt;NUL&lt;/code&gt; -terminated if there is room. Note that room for the &lt;code&gt;NUL&lt;/code&gt; should be included in &lt;code&gt;size&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;size&lt;/code&gt; - это полный размер целевого буфера, и результат гарантированно будет &lt;code&gt;NUL&lt;/code&gt; - завершен, если есть место. Обратите внимание, что место для &lt;code&gt;NUL&lt;/code&gt; должно быть включено в &lt;code&gt;size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1ee97366e8a29ba82d524849876bc9dc36688aa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="a8a3ab354ef3e6d59f72d20cd807dd1f627a195f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_magicext&lt;/code&gt; will allow things that &lt;code&gt;sv_magic&lt;/code&gt; will not. In particular, you can add magic to SvREADONLY SVs, and add more than one instance of the same 'how'.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;sv_magicext&lt;/code&gt; разрешит то, &lt;code&gt;sv_magic&lt;/code&gt; не может sv_magic . В частности, вы можете добавить магию в SVREADONLY SV и добавить более одного экземпляра одного и того же &amp;laquo;как&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d17fdc7c9d347932f15c81a113739f79e8f9e848" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_setref_pv&lt;/code&gt; copies the pointer while this copies the string.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;sv_setref_pv&lt;/code&gt; копирует указатель, а это - строку.</target>
        </trans-unit>
        <trans-unit id="5b6169277ca527d5391cec9228283f0ee301bda5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_setref_pvn&lt;/code&gt; copies the string while this copies the pointer.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;sv_setref_pvn&lt;/code&gt; копирует строку, а это копирует указатель.</target>
        </trans-unit>
        <trans-unit id="c8b9e5c8595e30b3314518789be3e0f347c198b7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;utf8::downgrade()&lt;/code&gt; can fail if the string contains characters that don't fit into a byte.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;utf8::downgrade()&lt;/code&gt; может завершиться ошибкой, если строка содержит символы, которые не помещаются в байт.</target>
        </trans-unit>
        <trans-unit id="aa060ed1a78be536ec85c38f0f18576d3c573522" translate="yes" xml:space="preserve">
          <source>Note that =end commands must match the currently open =begin command. That is, they must properly nest. For example, this is valid:</source>
          <target state="translated">Обратите внимание,что команды =end должны совпадать с текущей открытой командой =begin.То есть,они должны правильно гнездиться.Например,это допустимо:</target>
        </trans-unit>
        <trans-unit id="29f1f8d502ed33af80a815e01f2ba72fc747d301" translate="yes" xml:space="preserve">
          <source>Note that ASCII characters that don't map to control characters are discouraged, and will generate the warning (when enabled) &lt;a href=&quot;#%5cc%25c%22-is-more-clearly-written-simply-as-%22%25s&quot;&gt;\c%c is more clearly written simply as %s&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что символы ASCII, которые не сопоставляются с управляющими символами, не приветствуются и будут генерировать предупреждение (если включено) &lt;a href=&quot;#%5cc%25c%22-is-more-clearly-written-simply-as-%22%25s&quot;&gt;\ c% c более четко записывается как% s&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f696f805b3c072e83294d03b83db4d7aa8d5f2f" translate="yes" xml:space="preserve">
          <source>Note that E&amp;lt;number&amp;gt;</source>
          <target state="translated">Обратите внимание, что E &amp;lt;число&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0b2805b17d2c93e101d429684bf1e4cc0ec6e9bf" translate="yes" xml:space="preserve">
          <source>Note that GNU tar earlier than version 1.14 does not cope well with the &lt;code&gt;POSIX header prefix&lt;/code&gt; . If you use such a version, consider setting the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что GNU tar до версии 1.14 плохо справляется с &lt;code&gt;POSIX header prefix&lt;/code&gt; . Если вы используете такую ​​версию, подумайте о том, чтобы установить для переменной &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41555ab0bf65d38958a3f14aeb7171b1e0133dfc" translate="yes" xml:space="preserve">
          <source>Note that GNU's gzip/gunzip is not the same as Info-ZIP's zip/unzip package. The former is a simple compression tool; the latter permits creation of multi-file archives.</source>
          <target state="translated">Обратите внимание,что пакет GNU gzip/gunzip не то же самое,что пакет Info-ZIP zip/unzip.Первый-простой инструмент сжатия;второй позволяет создавать многофайловые архивы.</target>
        </trans-unit>
        <trans-unit id="622ccc1f7f386f33bcd0fe7e88ec0737a974a63d" translate="yes" xml:space="preserve">
          <source>Note that Hash Quality Score would be 1 for an ideal hash, numbers close to and below 1 indicate good hashing, and number significantly above indicate a poor score. In practice it should be around 0.95 to 1.05. It is defined as:</source>
          <target state="translated">Обратите внимание,что оценка качества хэша была бы 1 для идеального хэша,цифры,близкие к 1 и ниже,указывают на хорошее хэширование,а цифры значительно выше-на плохую оценку.На практике она должна быть около 0,95-1,05.Определяется как:</target>
        </trans-unit>
        <trans-unit id="5a0bd34cdc923419eb75f34bbc27c1a38f42a083" translate="yes" xml:space="preserve">
          <source>Note that META files are expected to be in UTF-8 encoding, only. When converted string data, it must first be decoded from UTF-8.</source>
          <target state="translated">Обратите внимание,что META-файлы должны быть только в кодировке UTF-8.При преобразовании строковых данных они должны быть сначала декодированы в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="9d701eb861ec485b89d355a1ef6df2a9826d0960" translate="yes" xml:space="preserve">
          <source>Note that MakeMaker actually emits makefiles with different syntax depending on what 'make' it thinks you are using. Therefore, it is important that one of the following values appears in Config.pm:</source>
          <target state="translated">Обратите внимание,что MakeMaker на самом деле испускает makefiles с различным синтаксисом в зависимости от того,что 'make' он думает,что вы используете.Поэтому важно,чтобы одно из следующих значений появилось в Config.pm:</target>
        </trans-unit>
        <trans-unit id="e57e92f05abaff6b44fad917e7a4948606c4c50b" translate="yes" xml:space="preserve">
          <source>Note that Perl can be compiled and run under either ASCII or EBCDIC (See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;). Most of the documentation (and even comments in the code) ignore the EBCDIC possibility. For almost all purposes the differences are transparent. As an example, under EBCDIC, instead of UTF-8, UTF-EBCDIC is used to encode Unicode strings, and so whenever this documentation refers to &lt;code&gt;utf8&lt;/code&gt; (and variants of that name, including in function names), it also (essentially transparently) means &lt;code&gt;UTF-EBCDIC&lt;/code&gt; . But the ordinals of characters differ between ASCII, EBCDIC, and the UTF- encodings, and a string encoded in UTF-EBCDIC may occupy more bytes than in UTF-8.</source>
          <target state="translated">Обратите внимание, что Perl может быть скомпилирован и запущен как под ASCII, так и под EBCDIC (см. &lt;a href=&quot;perlebcdic&quot;&gt;Perlebcdic&lt;/a&gt; ). Большая часть документации (и даже комментариев в коде) игнорирует возможность EBCDIC. Почти для всех целей различия прозрачны. Например, в EBCDIC вместо UTF-8 используется UTF-EBCDIC для кодирования строк Unicode, и поэтому всякий раз, когда эта документация ссылается на &lt;code&gt;utf8&lt;/code&gt; (и варианты этого имени, включая имена функций), он также (по сути прозрачно) означает &lt;code&gt;UTF-EBCDIC&lt;/code&gt; . Но порядковые номера символов в кодировках ASCII, EBCDIC и UTF различаются, а строка, закодированная в UTF-EBCDIC, может занимать больше байтов, чем в UTF-8.</target>
        </trans-unit>
        <trans-unit id="18cd527588221d4d537c9d16a7ea7760668b37e5" translate="yes" xml:space="preserve">
          <source>Note that Perl considers grapheme clusters to be separate characters, so for example</source>
          <target state="translated">Обратите внимание,что Perl считает графемные кластеры отдельными символами,так что например</target>
        </trans-unit>
        <trans-unit id="eab78c95236503996e3835788eca975544654d36" translate="yes" xml:space="preserve">
          <source>Note that Perl doesn't use COMSPEC for this purpose because COMSPEC has a high degree of variability among users, leading to portability concerns. Besides, Perl can use a shell that may not be fit for interactive use, and setting COMSPEC to such a shell may interfere with the proper functioning of other programs (which usually look in COMSPEC to find a shell fit for interactive use).</source>
          <target state="translated">Обратите внимание,что Perl не использует КОМСПЕК для этой цели,потому что КОМСПЕК имеет высокую степень вариабельности среди пользователей,что приводит к проблемам переносимости.Кроме того,Perl может использовать оболочку,которая может не подходить для интерактивного использования,и настройка COMSPEC под такую оболочку может помешать нормальной работе других программ (которые обычно ищут в COMSPEC оболочку,подходящую для интерактивного использования).</target>
        </trans-unit>
        <trans-unit id="0b9723f4ea6f4a0b6aceb296908b35e0318ba34c" translate="yes" xml:space="preserve">
          <source>Note that Perl supports passing of up to only 14 arguments to your syscall, which in practice should (usually) suffice.</source>
          <target state="translated">Обратите внимание,что Perl поддерживает передачу до 14 аргументов в ваш системный звонок,чего на практике должно (обычно)быть достаточно.</target>
        </trans-unit>
        <trans-unit id="fc038a57f3e25b6eadeaf90180f1c3439e440f0b" translate="yes" xml:space="preserve">
          <source>Note that Perl will start to look for scripts only if OS/2 cannot start the specified application, thus &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'blah'&lt;/code&gt; will not look for a script if there is an executable file</source>
          <target state="translated">Обратите внимание, что Perl начнет искать сценарии только в том случае, если OS / 2 не может запустить указанное приложение, поэтому &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'blah'&lt;/code&gt; не будет искать сценарий, если есть исполняемый файл.</target>
        </trans-unit>
        <trans-unit id="91fa96b82144dedf82260fa9f38047e79dd27888" translate="yes" xml:space="preserve">
          <source>Note that Pod authors may use formatting codes inside the &quot;text&quot; part of &quot;L&amp;lt;text|name&amp;gt;&quot; (and so on for L&amp;lt;text|/&quot;sec&quot;&amp;gt;).</source>
          <target state="translated">Обратите внимание, что авторы Pod могут использовать коды форматирования внутри &amp;laquo;текстовой&amp;raquo; части &amp;laquo;L &amp;lt;text | name&amp;gt;&amp;raquo; (и так далее для L &amp;lt;text | / &amp;laquo;sec&amp;raquo;&amp;gt;).</target>
        </trans-unit>
        <trans-unit id="e78fad76e523eb715d0d0985d903052e1c5e94f3" translate="yes" xml:space="preserve">
          <source>Note that RFC 1951 data is not a good choice of compression format to use in isolation, especially if you want to auto-detect it.</source>
          <target state="translated">Обратите внимание,что данные RFC 1951 не являются хорошим выбором формата сжатия,который можно использовать изолированно,особенно если вы хотите автоматически обнаружить их.</target>
        </trans-unit>
        <trans-unit id="9c1a2afa5425cbbe8c2645f8ed66553e6e705923" translate="yes" xml:space="preserve">
          <source>Note that SHA-1 and SHA-2 use</source>
          <target state="translated">Обратите внимание,что SHA-1 и SHA-2 используют</target>
        </trans-unit>
        <trans-unit id="5e739101966d2d75e1e2a13b96e1acfc17a54320" translate="yes" xml:space="preserve">
          <source>Note that TODO tests</source>
          <target state="translated">Обратите внимание,что тесты TODO</target>
        </trans-unit>
        <trans-unit id="adf90b14f7079e4b164d5f4781cb0955f5b8199b" translate="yes" xml:space="preserve">
          <source>Note that Tie::File will only close any filehandles that it opened internally. If you passed it a filehandle as above, you &quot;own&quot; the filehandle, and are responsible for closing it after you have untied the @array.</source>
          <target state="translated">Обратите внимание,что Tie::File закрывает только те файловые дескрипторы,которые были открыты внутри него.Если вы передали ему файловый дескриптор,как описано выше,вы &quot;владеете&quot; этим дескриптором и отвечаете за его закрытие после того,как развяжете @массив.</target>
        </trans-unit>
        <trans-unit id="4afe4a651bf63522c9809fb7b99b7a958e429b1d" translate="yes" xml:space="preserve">
          <source>Note that a &quot;=begin</source>
          <target state="translated">Обратите внимание,что &quot;=начало</target>
        </trans-unit>
        <trans-unit id="8b724b26e18550406b5e1585fe304e6c44d42b0e" translate="yes" xml:space="preserve">
          <source>Note that a blank line must have no blanks in it. Thus &lt;code&gt;&quot;fred\n \nstuff\n\n&quot;&lt;/code&gt; is one paragraph, but &lt;code&gt;&quot;fred\n\nstuff\n\n&quot;&lt;/code&gt; is two.</source>
          <target state="translated">Обратите внимание, что в пустой строке не должно быть пробелов. Таким образом, &lt;code&gt;&quot;fred\n \nstuff\n\n&quot;&lt;/code&gt; - это один абзац, а &lt;code&gt;&quot;fred\n\nstuff\n\n&quot;&lt;/code&gt; - два.</target>
        </trans-unit>
        <trans-unit id="488f211edef26ffffb5b05c7e2b69aaf3b6426c8" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">Обратите внимание, что сам по себе блок семантически идентичен циклу, который выполняется один раз. Таким образом, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; может быть использован для раннего выхода из такого блока.</target>
        </trans-unit>
        <trans-unit id="ca2f98d2c44647b8c6e794a001b57317b63f04d1" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; will exit such a block early.</source>
          <target state="translated">Обратите внимание, что сам по себе блок семантически идентичен циклу, который выполняется один раз. Таким образом, &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; выйдет из такого блока раньше.</target>
        </trans-unit>
        <trans-unit id="d2013e8e837998ea5b5ded0d68af26e9b66d75ac" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">Обратите внимание, что сам по себе блок семантически идентичен циклу, который выполняется один раз. Таким образом, &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; внутри такого блока эффективно превратит его в конструкцию цикла.</target>
        </trans-unit>
        <trans-unit id="69d8a2b47ed12c267af9de16d301feaa50d0b140" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">Обратите внимание, что сам по себе блок семантически идентичен циклу, который выполняется один раз. Таким образом, &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; может быть использован для раннего выхода из такого блока.</target>
        </trans-unit>
        <trans-unit id="b7cf9f9549146f3e33d4f74b132eb49835f491f8" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; will exit such a block early.</source>
          <target state="translated">Обратите внимание, что сам по себе блок семантически идентичен циклу, который выполняется один раз. Таким образом, &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; выйдет из такого блока раньше.</target>
        </trans-unit>
        <trans-unit id="0597bd4ffb228a1e2d68cc747265b06bb6260752" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">Обратите внимание, что сам по себе блок семантически идентичен циклу, который выполняется один раз. Таким образом, &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; внутри такого блока эффективно превратит его в конструкцию цикла.</target>
        </trans-unit>
        <trans-unit id="3807425ae34b529f2149724bf4de6b8be9e97ec8" translate="yes" xml:space="preserve">
          <source>Note that a character expressed as an octal escape is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">Обратите внимание,что символ,выраженный как восьмеричный беглец,рассматривается регекс-движком как символ,не имеющий особого значения,и будет соответствовать &quot;как есть&quot;.</target>
        </trans-unit>
        <trans-unit id="45cc111c1e3b21172f0f2335e1ae7306a7eb5e16" translate="yes" xml:space="preserve">
          <source>Note that a character expressed as one of these escapes is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">Обратите внимание,что персонаж,выраженный как один из этих выходок,считается персонажем без особого значения регекс-движком и будет соответствовать &quot;как есть&quot;.</target>
        </trans-unit>
        <trans-unit id="093e11c1b10d3b91cf6120aba258f5fb6f25eb07" translate="yes" xml:space="preserve">
          <source>Note that a character or character sequence expressed as a named or numbered character is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">Обратите внимание,что символ или последовательность символов,выраженная в виде именованного или пронумерованного символа,считается символом без особого значения регекс-движком и будет соответствовать &quot;как есть&quot;.</target>
        </trans-unit>
        <trans-unit id="5b8eb289741baff1763a39069ed3ea0111511da4" translate="yes" xml:space="preserve">
          <source>Note that a format begins with the letter &quot;a&quot; if and only the property it is for requires adjustments by adding the offsets in multi-element ranges. For all these properties, an entry should be adjusted only if the map is a scalar which is an integer. That is, it must match the regular expression:</source>
          <target state="translated">Обратите внимание,что формат начинается с буквы &quot;а&quot;,если и только свойство,для которого он предназначен,требует корректировки путем добавления смещений в многоэлементные диапазоны.Для всех этих свойств запись должна быть скорректирована только в том случае,если карта является скаляром,представляющим собой целое число.То есть она должна соответствовать регулярному выражению:</target>
        </trans-unit>
        <trans-unit id="277e9c9ef26afafa8762a7902fac38086141ef72" translate="yes" xml:space="preserve">
          <source>Note that a scalar can be made to have both string and numeric content through numeric operations:</source>
          <target state="translated">Обратите внимание,что скаляр может иметь как строковое,так и числовое содержимое с помощью числовых операций:</target>
        </trans-unit>
        <trans-unit id="7ba4f70f6b75455ad6abeb4c11f3ab4b74ce3ab3" translate="yes" xml:space="preserve">
          <source>Note that a shared variable guarantees that if two or more threads try to modify it at the same time, the internal state of the variable will not become corrupted. However, there are no guarantees beyond this, as explained in the next section.</source>
          <target state="translated">Обратите внимание,что общая переменная гарантирует,что если два или более потока попытаются изменить ее одновременно,внутреннее состояние переменной не будет повреждено.Тем не менее,нет никаких гарантий за пределами этого,как поясняется в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="cbf633a93711ea65ac990e0ec5a96e4eb2db906d" translate="yes" xml:space="preserve">
          <source>Note that a side-effect of the above is that &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; are no longer exported at all. This is due to the way the &lt;code&gt;Exporter&lt;/code&gt; module works. If you are migrating a codebase to use the new interface, you will have to list everything explicitly. But that's just good practice anyway.</source>
          <target state="translated">Обратите внимание, что побочным эффектом вышеизложенного является то, что &lt;code&gt;mkpath&lt;/code&gt; и &lt;code&gt;rmtree&lt;/code&gt; больше не экспортируются. Это связано с тем, как работает модуль &lt;code&gt;Exporter&lt;/code&gt; . Если вы переносите кодовую базу для использования нового интерфейса, вам придется все явно перечислить. Но в любом случае это просто хорошая практика.</target>
        </trans-unit>
        <trans-unit id="fabccca2b124b57df72b15874578f07ff3f430bb" translate="yes" xml:space="preserve">
          <source>Note that according to the POSIX 1003.1-1996 the FILENAME may have any number of trailing slashes. Some operating and filesystems do not get this right, so Perl automatically removes all trailing slashes to keep everyone happy.</source>
          <target state="translated">Обратите внимание,что в соответствии с POSIX 1003.1-1996 ФИЛЕНАМА может иметь любое количество трейлинговых слэшей.В некоторых операционных и файловых системах это неправильно,поэтому Perl автоматически удаляет все трейлинговые слэши,чтобы все были довольны.</target>
        </trans-unit>
        <trans-unit id="83be315fcf65b1854e9827d37b7aa0e643910e0c" translate="yes" xml:space="preserve">
          <source>Note that all C programs (including the perl interpreter, which is written in C) always have an underlying locale. That locale is the &quot;C&quot; locale unless changed by a call to &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt;. When Perl starts up, it changes the underlying locale to the one which is indicated by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;. When using the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module or writing XS code, it is important to keep in mind that the underlying locale may be something other than &quot;C&quot;, even if the program hasn't explicitly changed it.</source>
          <target state="translated">Обратите внимание, что все программы на C (включая интерпретатор Perl, написанный на C) всегда имеют базовый языковой стандарт. Этот языковой стандарт является языковым стандартом &quot;C&quot;, если он не изменен вызовом &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale ()&lt;/a&gt; . Когда Perl запускается, он меняет базовый языковой стандарт на тот, который указан &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ОКРУЖЕНИЕМ&lt;/a&gt; . При использовании модуля &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; или написании кода XS важно иметь в виду, что базовая локаль может быть чем-то другим, кроме &amp;laquo;C&amp;raquo;, даже если программа не изменила его явно.</target>
        </trans-unit>
        <trans-unit id="9ab24412bb95107f3eb55078583c0a90d9214b85" translate="yes" xml:space="preserve">
          <source>Note that all Perl API global variables must be referenced with the &lt;code&gt;PL_&lt;/code&gt; prefix. Again, those not listed here are not to be used by extension writers, and can be changed or removed without notice; same with macros. Some macros are provided for compatibility with the older, unadorned names, but this support may be disabled in a future release.</source>
          <target state="translated">Обратите внимание, что все глобальные переменные Perl API должны иметь префикс &lt;code&gt;PL_&lt;/code&gt; . Опять же, те, которые здесь не перечислены, не должны использоваться разработчиками расширений и могут быть изменены или удалены без предварительного уведомления; то же самое с макросами. Некоторые макросы предоставлены для совместимости со старыми, неприукрашенными именами, но эта поддержка может быть отключена в будущем выпуске.</target>
        </trans-unit>
        <trans-unit id="89aa7734c4b74b60a4c1310b623d823298b487c6" translate="yes" xml:space="preserve">
          <source>Note that all access is read-only. You cannot modify the internals by using this module. Also, note that the B::OP and B::SV objects created by this module are only valid for as long as the underlying objects exist; their creation doesn't increase the reference counts of the underlying objects. Trying to access the fields of a freed object will give incomprehensible results, or worse.</source>
          <target state="translated">Обратите внимание,что весь доступ предоставляется только для чтения.Вы не можете модифицировать внутреннюю часть с помощью этого модуля.Также обратите внимание,что объекты B::OP и B::SV,созданные этим модулем,действительны только до тех пор,пока существуют лежащие в основе объекты;их создание не увеличивает количество ссылок на лежащие в основе объекты.Попытка получить доступ к полям освобожденного объекта даст непонятный результат или даже хуже.</target>
        </trans-unit>
        <trans-unit id="8decf89662be3764b31363ba5ddb1483e12ddabb" translate="yes" xml:space="preserve">
          <source>Note that all non-essential underscores are removed in the display of the short names below.</source>
          <target state="translated">Обратите внимание,что все несущественные знаки подчеркивания удаляются при отображении коротких имен внизу.</target>
        </trans-unit>
        <trans-unit id="cbd6c5b0c5e74d46b9b73ec517d66ec65461aeb4" translate="yes" xml:space="preserve">
          <source>Note that all of the above are overridden within the scope of &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt;; but you should be using this pragma only for debugging.</source>
          <target state="translated">Обратите внимание, что все вышеперечисленное переопределяется в пределах объема &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt; ; но вы должны использовать эту прагму только для отладки.</target>
        </trans-unit>
        <trans-unit id="205ec32f1130d522301c48a5f23e3282ae5c3cdd" translate="yes" xml:space="preserve">
          <source>Note that all updates of the %result are additive, the hash will not be cleared before use, thus allowing status results of many installs to be easily aggregated.</source>
          <target state="translated">Обратите внимание,что все обновления %-результата являются аддитивами,хэш не будет очищен перед использованием,что позволяет легко агрегировать результаты состояния многих установок.</target>
        </trans-unit>
        <trans-unit id="36cc92c47c9f292a67886537ca085ec97a646fe9" translate="yes" xml:space="preserve">
          <source>Note that all we have described here in this quick overview is the simplest most straightforward use of &lt;b&gt;Pod::Parser&lt;/b&gt; to do stream-based parsing. It is also possible to use the &lt;b&gt;Pod::Parser::parse_text&lt;/b&gt; function to do more sophisticated tree-based parsing. See &lt;a href=&quot;#TREE-BASED-PARSING&quot;&gt;TREE-BASED PARSING&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что все, что мы описали здесь в этом кратком обзоре, - это простейшее и понятное использование &lt;b&gt;Pod :: Parser&lt;/b&gt; для анализа на основе потоков. Также можно использовать функцию &lt;b&gt;Pod :: Parser :: parse_text&lt;/b&gt; для более сложного синтаксического анализа на основе дерева. См. &lt;a href=&quot;#TREE-BASED-PARSING&quot;&gt;РАЗБОР НА ОСНОВЕ ДЕРЕВО&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b40f1346b332774a6bbe4756105b2451b5aa080" translate="yes" xml:space="preserve">
          <source>Note that almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. There are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; , and &lt;code&gt;Titlecase_Letter&lt;/code&gt; , all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. The second set is &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; , and &lt;code&gt;Titlecase&lt;/code&gt; , all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case, so they are &lt;code&gt;Cased&lt;/code&gt; , but aren't considered to be letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt; s. They're actually &lt;code&gt;Letter_Number&lt;/code&gt; s.) This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt; , both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что почти все свойства невосприимчивы к сопоставлению без учета регистра. То есть добавление модификатора регулярного выражения &lt;code&gt;/i&lt;/code&gt; не меняет то, что они соответствуют. Затронуты два набора. Первый набор &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; и &lt;code&gt;Titlecase_Letter&lt;/code&gt; , все из которых соответствуют &lt;code&gt;Cased_Letter&lt;/code&gt; под &lt;code&gt;/i&lt;/code&gt; соответствия. Второй набор - это &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; и &lt;code&gt;Titlecase&lt;/code&gt; , которые соответствуют &lt;code&gt;Cased&lt;/code&gt; при сопоставлении &lt;code&gt;/i&lt;/code&gt; . (Разница между этими наборами состоит в том, что некоторые элементы, например римские цифры, могут быть как в верхнем, так и в нижнем регистре, поэтому они &lt;code&gt;Cased&lt;/code&gt; , но не считаются буквами, поэтому они не являются &lt;code&gt;Cased_Letter&lt;/code&gt; s. На самом деле это &lt;code&gt;Letter_Number&lt;/code&gt; s.) Этот набор также включает подмножества &lt;code&gt;PosixUpper&lt;/code&gt; и &lt;code&gt;PosixLower&lt;/code&gt; , оба из которых под &lt;code&gt;/i&lt;/code&gt; соответствуют &lt;code&gt;PosixAlpha&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd7c4807ae2f9f37a6e187d7bd38a50b276ee8ea" translate="yes" xml:space="preserve">
          <source>Note that although &lt;code&gt;$!&lt;/code&gt; appears to be dual-valued variable, it is actually implemented using a tied scalar:</source>
          <target state="translated">Обратите внимание, что хотя &lt;code&gt;$!&lt;/code&gt; кажется двузначной переменной, на самом деле она реализована с использованием связанного скаляра:</target>
        </trans-unit>
        <trans-unit id="606458ff6017524382f12a8fd94125b35d1b63bc" translate="yes" xml:space="preserve">
          <source>Note that an &quot;=over&quot; ... &quot;=back&quot; region should have some content. That is, authors should not have an empty region like this:</source>
          <target state="translated">Обратите внимание,что &quot;=over&quot; ...&quot;=обратный&quot; регион должен иметь некоторое содержание.То есть у авторов не должно быть пустого региона,как этот:</target>
        </trans-unit>
        <trans-unit id="8f873ccce2134d828b1fb4400b87f6f3fdbeb512" translate="yes" xml:space="preserve">
          <source>Note that an INVARIANT character (i.e. ASCII on non-EBCDIC machines) is a valid UTF-8 character.</source>
          <target state="translated">Обратите внимание,что ИНВАРИАНТНЫЙ символ (т.е.ASCII на машинах,не относящихся к EBCDIC)является действительным символом UTF-8.</target>
        </trans-unit>
        <trans-unit id="587e23eccc6cff27f015e2a6ec6c9aa159cb0d1a" translate="yes" xml:space="preserve">
          <source>Note that an exit() or die() that is compiled 'hushed' because of &quot;use vmsish&quot; is not un-hushed by calling vmsish::hushed(0) at runtime.</source>
          <target state="translated">Обратите внимание,что exit()или die(),скомпилированные 'hushed' из-за &quot;use vmsish&quot;,не хэшируются вызовом vmsish::hushed(0)во время выполнения.</target>
        </trans-unit>
        <trans-unit id="b2477a9523ad15c5452b9aa241b6f568c4bd6177" translate="yes" xml:space="preserve">
          <source>Note that any variables and functions that are not documented in this document (or in &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;) are considered for internal use only, and as such are subject to change without notice.</source>
          <target state="translated">Обратите внимание, что любые переменные и функции, которые не задокументированы в этом документе (или в &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; ), рассматриваются только для внутреннего использования и, как таковые, могут быть изменены без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="a6b66f44f204ce59d376598daa611217f2bbd286" translate="yes" xml:space="preserve">
          <source>Note that any variables and functions that are not documented in this manpages (or in &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) are considered for internal use only, and as such are subject to change without notice.</source>
          <target state="translated">Обратите внимание, что любые переменные и функции, которые не задокументированы на этих страницах руководства (или в &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; ), рассматриваются только для внутреннего использования и, как таковые, могут быть изменены без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="ce41211a36e2b403696bfe4a4b1fe54c951c0f65" translate="yes" xml:space="preserve">
          <source>Note that anything inside a &lt;code&gt;\Q...\E&lt;/code&gt; stays unaffected by &lt;code&gt;/x&lt;/code&gt;. And note that &lt;code&gt;/x&lt;/code&gt; doesn't affect space interpretation within a single multi-character construct. For example in &lt;code&gt;\x{...}&lt;/code&gt; , regardless of the &lt;code&gt;/x&lt;/code&gt; modifier, there can be no spaces. Same for a &lt;a href=&quot;#Quantifiers&quot;&gt;quantifier&lt;/a&gt; such as &lt;code&gt;{3}&lt;/code&gt; or &lt;code&gt;{5,}&lt;/code&gt; . Similarly, &lt;code&gt;(?:...)&lt;/code&gt; can't have a space between the &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt; . Within any delimiters for such a construct, allowed spaces are not affected by &lt;code&gt;/x&lt;/code&gt;, and depend on the construct. For example, &lt;code&gt;\x{...}&lt;/code&gt; can't have spaces because hexadecimal numbers don't have spaces in them. But, Unicode properties can have spaces, so in &lt;code&gt;\p{...}&lt;/code&gt; there can be spaces that follow the Unicode rules, for which see &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание , что все внутри &lt;code&gt;\Q...\E&lt;/code&gt; остается не помеха &lt;code&gt;/x&lt;/code&gt; . И обратите внимание, что &lt;code&gt;/x&lt;/code&gt; не влияет на интерпретацию пробелов в одной многосимвольной конструкции. Например, в &lt;code&gt;\x{...}&lt;/code&gt; , независимо от модификатора &lt;code&gt;/x&lt;/code&gt; , не может быть пробелов. То же самое для &lt;a href=&quot;#Quantifiers&quot;&gt;квантификатора,&lt;/a&gt; такого как &lt;code&gt;{3}&lt;/code&gt; или &lt;code&gt;{5,}&lt;/code&gt; . Точно так же &lt;code&gt;(?:...)&lt;/code&gt; не может иметь пробелов между &lt;code&gt;(&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; И &lt;code&gt;:&lt;/code&gt; . В пределах любых разделителей для такой конструкции разрешенные пробелы не зависят от &lt;code&gt;/x&lt;/code&gt; и зависят от конструкции. Например, &lt;code&gt;\x{...}&lt;/code&gt; не может иметь пробелов, потому что в шестнадцатеричных числах нет пробелов. Но свойства Unicode могут иметь пробелы, поэтому в &lt;code&gt;\p{...}&lt;/code&gt; могут быть пробелы, соответствующие правилам Unicode, для которых см. &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Свойства, доступные через \ p {} и \ P {} в perluniprops&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fdc0e788793ca02998116be1ca2d6034cbab69c" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.14, &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; will insert the named sequence into double-quoted strings, and &lt;code&gt;charnames::string_vianame(&quot;KATAKANA
LETTER AINU P&quot;)&lt;/code&gt; will return the same string this function does, but will also operate on character names that aren't named sequences, without you having to know which are which. See &lt;a href=&quot;../charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что начиная с Perl 5.14, &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; будет вставлять названную последовательность в строки, &lt;code&gt;charnames::string_vianame(&quot;KATAKANA LETTER AINU P&quot;)&lt;/code&gt; в двойные кавычки, а charnames :: string_vianame (&amp;laquo;KATAKANA LETTER AINU P&amp;raquo;) вернет ту же строку, что и эта функция, но будет также работают с именами символов, которые не являются именованными последовательностями, без необходимости знать, какие из них есть. См. &lt;a href=&quot;../charnames&quot;&gt;Имена символов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e472cfdb1b217c8839b9da7d68aebc2ef451ccc9" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.20, literal control characters in variable names are deprecated; and as of Perl 5.22, any other non-graphic characters are also deprecated.</source>
          <target state="translated">Обратите внимание,что начиная с версии Perl 5.20 буквенные управляющие символы в именах переменных устаревают;а начиная с версии Perl 5.22 устаревают и любые другие неграфические символы.</target>
        </trans-unit>
        <trans-unit id="4a675b15092aa8c87c6f30bd02df31fd70694188" translate="yes" xml:space="preserve">
          <source>Note that atan2(0, 0) is not well-defined.</source>
          <target state="translated">Обратите внимание,что atan2(0,0)плохо определен.</target>
        </trans-unit>
        <trans-unit id="8fbf5b8aea29a3936ba6fef9526fd98f6b5784c6" translate="yes" xml:space="preserve">
          <source>Note that attribute handlers that are scheduled for the &lt;code&gt;BEGIN&lt;/code&gt; phase are handled as soon as the attribute is detected (i.e. before any subsequently defined &lt;code&gt;BEGIN&lt;/code&gt; blocks are executed).</source>
          <target state="translated">Обратите внимание, что обработчики атрибутов, запланированные для фазы &lt;code&gt;BEGIN&lt;/code&gt; , обрабатываются, как только атрибут обнаруживается (т. Е. До того, как будут выполнены какие-либо определенные впоследствии блоки &lt;code&gt;BEGIN&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0f24e592f4d8a1a531dda62544ac7d2f7b1bf174" translate="yes" xml:space="preserve">
          <source>Note that because &lt;b&gt;-i&lt;/b&gt; renames or deletes the original file before creating a new file of the same name, Unix-style soft and hard links will not be preserved.</source>
          <target state="translated">Обратите внимание: поскольку &lt;b&gt;-i&lt;/b&gt; переименовывает или удаляет исходный файл перед созданием нового файла с тем же именем, программные и жесткие ссылки в стиле Unix не сохраняются.</target>
        </trans-unit>
        <trans-unit id="49723b78c25f9f94694a955ddf0fb169c3bb02b1" translate="yes" xml:space="preserve">
          <source>Note that because multiple extensions may be using &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; or &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic, it is important for extensions to take extra care to avoid conflict. Typically only using the magic on objects blessed into the same class as the extension is sufficient. For &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic, it is usually a good idea to define an &lt;code&gt;MGVTBL&lt;/code&gt; , even if all its fields will be &lt;code&gt;0&lt;/code&gt; , so that individual &lt;code&gt;MAGIC&lt;/code&gt; pointers can be identified as a particular kind of magic using their magic virtual table. &lt;code&gt;mg_findext&lt;/code&gt; provides an easy way to do that:</source>
          <target state="translated">Обратите внимание: поскольку несколько расширений могут использовать &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; или &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; , важно, чтобы расширения проявляли особую осторожность, чтобы избежать конфликтов. Обычно достаточно использовать магию только для объектов, относящихся к тому же классу, что и расширение. Для магии &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; обычно хорошей идеей является определение &lt;code&gt;MGVTBL&lt;/code&gt; , даже если все его поля будут равны &lt;code&gt;0&lt;/code&gt; , чтобы отдельные указатели &lt;code&gt;MAGIC&lt;/code&gt; можно было идентифицировать как особый вид магии, используя их виртуальную волшебную таблицу. &lt;code&gt;mg_findext&lt;/code&gt; предоставляет простой способ сделать это:</target>
        </trans-unit>
        <trans-unit id="2432f753e906c1dd9f81b56a7cfbeac9aa989c16" translate="yes" xml:space="preserve">
          <source>Note that because of stupid OS/2 limitations the full path of the perl script is not available when you use &lt;code&gt;extproc&lt;/code&gt; , thus you are forced to use &lt;code&gt;-S&lt;/code&gt; perl switch, and your script should be on the &lt;code&gt;PATH&lt;/code&gt; . As a plus side, if you know a full path to your script, you may still start it with</source>
          <target state="translated">Обратите внимание, что из-за глупых ограничений OS / 2 полный путь к сценарию perl недоступен, когда вы используете &lt;code&gt;extproc&lt;/code&gt; , поэтому вы вынуждены использовать переключатель &lt;code&gt;-S&lt;/code&gt; perl, и ваш сценарий должен находиться в &lt;code&gt;PATH&lt;/code&gt; . В качестве положительного момента, если вы знаете полный путь к вашему скрипту, вы все равно можете запустить его с</target>
        </trans-unit>
        <trans-unit id="ad5dd4afa174c9cef5b24c559737823b7753c820" translate="yes" xml:space="preserve">
          <source>Note that because this rendering was done on a non-threaded perl, the PADOPs in the previous examples are now SVOPs, and some (but not all) of the square brackets have been replaced by round ones. This is a subtle feature to provide some visual distinction between renderings on threaded and un-threaded perls.</source>
          <target state="translated">Обратите внимание,что поскольку этот рендеринг был сделан на непоточном perl,PADOPs в предыдущих примерах теперь являются SVOPs,и некоторые (но не все)квадратные скобки были заменены на круглые.Это тонкая функция,позволяющая визуально различать рендеринг на потоковом и непоточном perl.</target>
        </trans-unit>
        <trans-unit id="e6d44ccabe09fa1f4e596936119e58147bb0fd41" translate="yes" xml:space="preserve">
          <source>Note that because we are operating on approximations of real numbers, these errors can happen when merely `too close' to the singularities listed above.</source>
          <target state="translated">Обратите внимание,что поскольку мы работаем с аппроксимациями реальных чисел,такие ошибки могут возникать,когда просто `чтобы приблизиться` к перечисленным выше сингулярностям.</target>
        </trans-unit>
        <trans-unit id="3cac802226be8e6c597ab4225af3fcdf654d037f" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; in Perl are implemented directly using &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; in C. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) is in force then signed C integers are used, else unsigned C integers are used. Either way, the implementation isn't going to generate results larger than the size of the integer type Perl was built with (32 bits or 64 bits).</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; в Perl реализуются напрямую с использованием &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; в C. Если &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; (см. &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Целочисленная арифметика&lt;/a&gt; ), то используются целые числа C со знаком, в противном случае используются целые числа C. В любом случае реализация не будет генерировать результаты, превышающие размер целочисленного типа, с которым был создан Perl (32 или 64 бита).</target>
        </trans-unit>
        <trans-unit id="04cf68d9424884dadb0aa2996784eb6ff505962d" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; do not increment the reference count of the stored &lt;code&gt;val&lt;/code&gt; , which is the caller's responsibility. If these functions return a NULL value, the caller will usually have to decrement the reference count of &lt;code&gt;val&lt;/code&gt; to avoid a memory leak.</source>
          <target state="translated">Обратите внимание, что и &lt;code&gt;hv_store&lt;/code&gt; , и &lt;code&gt;hv_store_ent&lt;/code&gt; не увеличивают счетчик ссылок сохраненного значения &lt;code&gt;val&lt;/code&gt; , за что отвечает вызывающий. Если эти функции возвращают значение NULL, вызывающей стороне обычно приходится уменьшать счетчик ссылок &lt;code&gt;val&lt;/code&gt; , чтобы избежать утечки памяти.</target>
        </trans-unit>
        <trans-unit id="74a9256e12aa22e857528719131785d55699987c" translate="yes" xml:space="preserve">
          <source>Note that both paths are assumed to have a notation that distinguishes a directory path (with trailing ':') from a file path (without trailing ':').</source>
          <target state="translated">Обратите внимание,что предполагается,что оба пути имеют примечание,которое отличает путь каталога (с трейлингом ':')от пути файла (без трейлинга ':').</target>
        </trans-unit>
        <trans-unit id="0e8fd56db9f2f95bb2076209ba3c59af9c411003" translate="yes" xml:space="preserve">
          <source>Note that both the &lt;code&gt;CanonicalName&lt;/code&gt; and &lt;code&gt;FilterName&lt;/code&gt; options can modify the value used for the zip filename header field.</source>
          <target state="translated">Обратите внимание, что параметры &lt;code&gt;CanonicalName&lt;/code&gt; и &lt;code&gt;FilterName&lt;/code&gt; могут изменять значение, используемое для поля заголовка имени файла zip-архива.</target>
        </trans-unit>
        <trans-unit id="b4c874fe97ef7da4bd4b4b5db7330a5fe9438bed" translate="yes" xml:space="preserve">
          <source>Note that bsd_glob() deviates from POSIX and FreeBSD glob(3) behaviour by not considering &lt;code&gt;ENOENT&lt;/code&gt; and &lt;code&gt;ENOTDIR&lt;/code&gt; as errors - bsd_glob() will continue processing despite those errors, unless the &lt;code&gt;GLOB_ERR&lt;/code&gt; flag is set.</source>
          <target state="translated">Обратите внимание, что bsd_glob () отличается от поведения POSIX и FreeBSD glob (3), не рассматривая &lt;code&gt;ENOENT&lt;/code&gt; и &lt;code&gt;ENOTDIR&lt;/code&gt; как ошибки - bsd_glob () продолжит обработку, несмотря на эти ошибки, если не &lt;code&gt;GLOB_ERR&lt;/code&gt; флаг GLOB_ERR .</target>
        </trans-unit>
        <trans-unit id="a4b82a298fa226e67135978079ffa22b87e99940" translate="yes" xml:space="preserve">
          <source>Note that capture groups matched inside of recursion are not accessible after the recursion returns, so the extra layer of capturing groups is necessary. Thus &lt;code&gt;$+{NAME_PAT}&lt;/code&gt; would not be defined even though &lt;code&gt;$+{NAME}&lt;/code&gt; would be.</source>
          <target state="translated">Обратите внимание, что группы захвата, сопоставленные внутри рекурсии, недоступны после возврата из рекурсии, поэтому необходим дополнительный уровень групп захвата. Таким образом, &lt;code&gt;$+{NAME_PAT}&lt;/code&gt; не будет определен, хотя &lt;code&gt;$+{NAME}&lt;/code&gt; будет.</target>
        </trans-unit>
        <trans-unit id="bc76dc97a1c19045dc8a76b9a6b2095a51024d2b" translate="yes" xml:space="preserve">
          <source>Note that certain exponentiation expressions are ill-defined: these include &lt;code&gt;0**0&lt;/code&gt; , &lt;code&gt;1**Inf&lt;/code&gt; , and &lt;code&gt;Inf**0&lt;/code&gt; . Do not expect any particular results from these special cases, the results are platform-dependent.</source>
          <target state="translated">Обратите внимание, что некоторые выражения возведения в степень не определены: они включают &lt;code&gt;0**0&lt;/code&gt; , &lt;code&gt;1**Inf&lt;/code&gt; и &lt;code&gt;Inf**0&lt;/code&gt; . Не ждите особых результатов от этих особых случаев, результаты зависят от платформы.</target>
        </trans-unit>
        <trans-unit id="ae568ca1008d1cccb4f94c7517bbb753d06bd905" translate="yes" xml:space="preserve">
          <source>Note that characters from 128 to 255 (inclusive) are by default internally not encoded as UTF-8 for backward compatibility reasons.</source>
          <target state="translated">Обратите внимание,что символы от 128 до 255 (включительно)по умолчанию внутренне не закодированы как UTF-8 по причинам обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="20fe49f9b13e959950bbe4e0a6e4e652aef94a09" translate="yes" xml:space="preserve">
          <source>Note that clients who do not support the &lt;code&gt;GNU Extended Header&lt;/code&gt; feature will not be able to read these archives. Such clients include tars on &lt;code&gt;Solaris&lt;/code&gt; , &lt;code&gt;Irix&lt;/code&gt; and &lt;code&gt;AIX&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что клиенты, которые не поддерживают функцию &lt;code&gt;GNU Extended Header&lt;/code&gt; , не смогут читать эти архивы. К таким клиентам относятся tars в &lt;code&gt;Solaris&lt;/code&gt; , &lt;code&gt;Irix&lt;/code&gt; и &lt;code&gt;AIX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fce890d3f4b569eee4d4fb3d808316a6c987e62" translate="yes" xml:space="preserve">
          <source>Note that codes 6 (rapid blink) and 9 (strike-through) are specified in ANSI X3.64 and ECMA-048 but are not commonly supported by most displays and emulators and therefore aren't supported by this module at the present time. ECMA-048 also specifies a large number of other attributes, including a sequence of attributes for font changes, Fraktur characters, double-underlining, framing, circling, and overlining. As none of these attributes are widely supported or useful, they also aren't currently supported by this module.</source>
          <target state="translated">Обратите внимание,что коды 6 (быстрое мигание)и 9 (забастовка)указаны в ANSI X3.64 и ECMA-048,но обычно не поддерживаются большинством дисплеев и эмуляторов и поэтому не поддерживаются данным модулем в настоящее время.ECMA-048 также указывает большое количество других атрибутов,в том числе последовательность атрибутов для изменения шрифта,символы фрактура,двойные подчёркивания,кадрирование,обводка и подчёркивание.Поскольку ни один из этих атрибутов не поддерживается и не является полезным,в настоящее время они также не поддерживаются данным модулем.</target>
        </trans-unit>
        <trans-unit id="701f822191abdf1e19724503033550d3adb9a3d3" translate="yes" xml:space="preserve">
          <source>Note that coercing an arbitrary scalar into a plain PV will potentially strip useful data from it. For example if the SV was &lt;code&gt;SvROK&lt;/code&gt; , then the referent will have its reference count decremented, and the SV itself may be converted to an &lt;code&gt;SvPOK&lt;/code&gt; scalar with a string buffer containing a value such as &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что преобразование произвольного скаляра в простой PV потенциально лишит его полезных данных. Например, если SV был &lt;code&gt;SvROK&lt;/code&gt; , то счетчик ссылок референта будет уменьшен, а сам SV может быть преобразован в скаляр &lt;code&gt;SvPOK&lt;/code&gt; со строковым буфером, содержащим такое значение, как &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c860f546e898e4ab8af10e9688384776e80d8690" translate="yes" xml:space="preserve">
          <source>Note that connected() considers a half-open TCP socket to be &quot;in a connected state&quot;. Specifically, connected() does not distinguish between the &lt;b&gt;ESTABLISHED&lt;/b&gt; and &lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP states; it returns the peer address, rather than undef, in either case. Thus, in general, connected() cannot be used to reliably learn whether the peer has initiated a graceful shutdown because in most cases (see below) the local TCP state machine remains in &lt;b&gt;CLOSE-WAIT&lt;/b&gt; until the local application calls shutdown() or close(); only at that point does connected() return undef.</source>
          <target state="translated">Обратите внимание, что connected () считает, что полуоткрытый TCP-сокет находится &amp;laquo;в подключенном состоянии&amp;raquo;. В частности, connected () не различает состояния TCP &lt;b&gt;ESTABLISHED&lt;/b&gt; и &lt;b&gt;CLOSE-WAIT&lt;/b&gt; ; в любом случае он возвращает адрес однорангового узла, а не undef. Таким образом, как правило, connected () не может использоваться для надежного определения, инициировал ли партнер плавное завершение работы, потому что в большинстве случаев (см. Ниже) локальный конечный автомат TCP остается в состоянии &lt;b&gt;CLOSE-WAIT,&lt;/b&gt; пока локальное приложение не вызовет shutdown () или close (); только в этот момент connected () возвращает undef.</target>
        </trans-unit>
        <trans-unit id="4c163cf186643a94245d42938672412776fa5e48" translate="yes" xml:space="preserve">
          <source>Note that currently some test scripts may fail when run in parallel (most notably</source>
          <target state="translated">Обратите внимание,что в настоящее время некоторые тестовые скрипты могут давать сбои при параллельном выполнении (особенно это касается</target>
        </trans-unit>
        <trans-unit id="fab55f641e790811b170e8b9128a927c617d8c7b" translate="yes" xml:space="preserve">
          <source>Note that define_alias() will not be able to override the canonical name of encodings. Encodings are first looked up by canonical name before potential aliases are tried.</source>
          <target state="translated">Обратите внимание,что функция define_alias()не сможет переопределить каноническое имя кодировок.Кодировки сначала просматриваются по каноническим именам,а затем пробуются потенциальные псевдонимы.</target>
        </trans-unit>
        <trans-unit id="da1de0e37193fb693b5c5e6bff7827d4423ee163" translate="yes" xml:space="preserve">
          <source>Note that despite the existence of this optag a memory resource attack may still be possible using only :base_core ops.</source>
          <target state="translated">Обратите внимание,что несмотря на существование данного оптага,атака на ресурсы памяти все равно возможна с использованием только :base_core ops.</target>
        </trans-unit>
        <trans-unit id="8256313554b42c8373b7bc367151c3b74d8cc5fc" translate="yes" xml:space="preserve">
          <source>Note that dot (</source>
          <target state="translated">Обратите внимание,что точка (</target>
        </trans-unit>
        <trans-unit id="765abb42fa3dbbf2af93a7f1e80231e5f09ac37f" translate="yes" xml:space="preserve">
          <source>Note that due to excessive paranoia, if $Getopt::Std::STANDARD_HELP_VERSION isn't true (the default is false), then the messages are printed on STDERR, and the processing continues after the messages are printed. This being the opposite of the standard-conforming behaviour, it is strongly recommended to set $Getopt::Std::STANDARD_HELP_VERSION to true.</source>
          <target state="translated">Обратите внимание,что из-за чрезмерной паранойи,если $Getopt::Std::STANDARD_HELP_VERSION не равен true (по умолчанию false),то сообщения распечатываются на STDERR,и обработка продолжается после распечатки сообщений.Поскольку это противоположно стандартному поведению,настоятельно рекомендуется установить значение переменной $Getopt::Std::STANDARD_HELP_VERSION равным true.</target>
        </trans-unit>
        <trans-unit id="1bbc11a7c1c533941b49be5f36414035e1261338" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;pp_&lt;/code&gt; function is expected to return a pointer to the next op. Calls to perl subs (and eval blocks) are handled within the same runops loop, and do not consume extra space on the C stack. For example, &lt;code&gt;pp_entersub&lt;/code&gt; and &lt;code&gt;pp_entertry&lt;/code&gt; just push a &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; block struct onto the context stack which contain the address of the op following the sub call or eval. They then return the first op of that sub or eval block, and so execution continues of that sub or block. Later, a &lt;code&gt;pp_leavesub&lt;/code&gt; or &lt;code&gt;pp_leavetry&lt;/code&gt; op pops the &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; , retrieves the return op from it, and returns it.</source>
          <target state="translated">Обратите внимание, что каждая функция &lt;code&gt;pp_&lt;/code&gt; должна возвращать указатель на следующую операцию. Вызовы подпрограмм Perl (и блоков eval) обрабатываются в одном и том же цикле runops и не занимают лишнего места в стеке C. Например, &lt;code&gt;pp_entersub&lt;/code&gt; и &lt;code&gt;pp_entertry&lt;/code&gt; просто &lt;code&gt;CxSUB&lt;/code&gt; &lt;code&gt;CxEVAL&lt;/code&gt; блока CxSUB или CxEVAL в стек контекста, который содержит адрес операции, следующей за подвызовом или eval. Затем они возвращают первую операцию этой подпрограммы или блока eval, и поэтому выполнение этой подпрограммы или блока продолжается. Позже &lt;code&gt;pp_leavesub&lt;/code&gt; или &lt;code&gt;pp_leavetry&lt;/code&gt; извлекает &lt;code&gt;CxSUB&lt;/code&gt; или &lt;code&gt;CxEVAL&lt;/code&gt; , извлекает из нее операцию возврата и возвращает ее.</target>
        </trans-unit>
        <trans-unit id="420d7847072074bbd6eaf28b4c7884f7445e96dd" translate="yes" xml:space="preserve">
          <source>Note that each of these return &lt;code&gt;$self&lt;/code&gt; when you call them as &lt;code&gt;$self-&amp;gt;&lt;i&gt;whatever(value)&lt;/i&gt;&lt;/code&gt;. That's so that you can chain together set-attribute calls like this:</source>
          <target state="translated">Обратите внимание, что каждый из них возвращает &lt;code&gt;$self&lt;/code&gt; когда вы вызываете их как &lt;code&gt;$self-&amp;gt;&lt;i&gt;whatever(value)&lt;/i&gt;&lt;/code&gt; . Это так, чтобы вы могли связать вместе вызовы set-attribute следующим образом:</target>
        </trans-unit>
        <trans-unit id="51d2022d4221c4239f7b2040e5d01a22869c3e3c" translate="yes" xml:space="preserve">
          <source>Note that even though SunOS and Solaris are binary compatible, these values are different. Go figure.</source>
          <target state="translated">Обратите внимание,что несмотря на бинарную совместимость SunOS и Solaris,эти значения отличаются.Поехали.</target>
        </trans-unit>
        <trans-unit id="8c3fc5526126d228e7dc152e5bae2056ec1d2dd9" translate="yes" xml:space="preserve">
          <source>Note that failed case-changing operations done as a result of case-insensitive &lt;code&gt;/i&lt;/code&gt; regular expression matching will show up in this warning as having the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operation (as that is what the regular expression engine calls behind the scenes.)</source>
          <target state="translated">Обратите внимание, что неудачные операции изменения регистра, выполненные в результате нечувствительного к регистру сопоставления регулярных выражений &lt;code&gt;/i&lt;/code&gt; , будут отображаться в этом предупреждении как имеющие операцию &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; (поскольку это то, что обработчик регулярных выражений вызывает за кулисами).</target>
        </trans-unit>
        <trans-unit id="8661f786e43fee3fd71c6daeb5a91a3c5f42f424" translate="yes" xml:space="preserve">
          <source>Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using &lt;code&gt;Z_FINISH&lt;/code&gt; ) or when you want to create a</source>
          <target state="translated">Обратите внимание, что сброс может серьезно ухудшить степень сжатия, поэтому его следует использовать только для завершения декомпрессии (с использованием &lt;code&gt;Z_FINISH&lt;/code&gt; ) или когда вы хотите создать</target>
        </trans-unit>
        <trans-unit id="a95fd032f7a2402cab6502921fb63c15d3283b35" translate="yes" xml:space="preserve">
          <source>Note that for control characters (&lt;code&gt;Gc=cc&lt;/code&gt; ), Unicode's data files have the string &quot;&lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &quot;, but the real name of each of these characters is the empty string. This function returns that real name, the empty string. (There are names for these characters, but they are considered aliases, not the Name property name, and are contained in the &lt;code&gt;Name_Alias&lt;/code&gt; property.)</source>
          <target state="translated">Обратите внимание, что для управляющих символов ( &lt;code&gt;Gc=cc&lt;/code&gt; ) файлы данных Unicode имеют строку &amp;laquo; &lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &amp;raquo;, но настоящее имя каждого из этих символов - пустая строка. Эта функция возвращает это настоящее имя, пустую строку. (У этих символов есть имена, но они считаются псевдонимами, а не именем свойства Name, и содержатся в свойстве &lt;code&gt;Name_Alias&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="d3b4cbb1ed8f855f79ca32bff7fc152fc5c21ab5" translate="yes" xml:space="preserve">
          <source>Note that for larger bit-strings, it's more efficient to use the two-argument version</source>
          <target state="translated">Обратите внимание,что для больших битовых строк более эффективно использовать двухпараметрическую версию.</target>
        </trans-unit>
        <trans-unit id="a191f82c0a0eecf7bccec0288b197819c9c21ed4" translate="yes" xml:space="preserve">
          <source>Note that for simpler testing requirements it will often be possible to replace the above code with a single call to &lt;code&gt;runtests&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что для более простых требований к тестированию часто можно заменить приведенный выше код одним вызовом &lt;code&gt;runtests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff6a50ca77c83bd7639e6227860f0a0332790a2f" translate="yes" xml:space="preserve">
          <source>Note that for the &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity and not-a-number) the definition of &quot;numeric&quot; is somewhat unusual: the strings themselves (like &quot;Inf&quot;) are considered numeric, and anything following them is considered non-numeric.</source>
          <target state="translated">Обратите внимание, что для &lt;code&gt;Inf&lt;/code&gt; и &lt;code&gt;NaN&lt;/code&gt; (бесконечность и не число) определение &amp;laquo;числовой&amp;raquo; несколько необычно: сами строки (например, &amp;laquo;Inf&amp;raquo;) считаются числовыми, а все, что следует за ними, считается нечисловым.</target>
        </trans-unit>
        <trans-unit id="de25d3b42b2818ebeccffadf90f915562d81e76b" translate="yes" xml:space="preserve">
          <source>Note that formats are treated as anon subs, and are cloned each time write is called (if necessary).</source>
          <target state="translated">Обратите внимание,что форматы рассматриваются как anon subs,и клонируются каждый раз при записи вызываются (если необходимо).</target>
        </trans-unit>
        <trans-unit id="be9d64d44ec51b213716f420b24aa9198bccd3c7" translate="yes" xml:space="preserve">
          <source>Note that freezing an object structure and immediately thawing it actually achieves a deep cloning of that structure:</source>
          <target state="translated">Обратите внимание,что замораживание структуры объекта и ее немедленное размораживание на самом деле приводит к глубокому клонированию этой структуры:</target>
        </trans-unit>
        <trans-unit id="692f49a79ca8c218f709da74928c335686702cff" translate="yes" xml:space="preserve">
          <source>Note that from &lt;a href=&quot;../bigint&quot;&gt;Math::BigInt&lt;/a&gt; v1.76 onwards, FastCalc will be loaded automatically, if possible.</source>
          <target state="translated">Обратите внимание, что начиная с &lt;a href=&quot;../bigint&quot;&gt;Math :: BigInt&lt;/a&gt; v1.76 и далее FastCalc будет загружаться автоматически, если это возможно.</target>
        </trans-unit>
        <trans-unit id="f6a562b762d80b1c79a4a2e57ae06efed1d20b20" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">Обратите внимание, что такие функции, как &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; могут возвращать огромные списки при использовании с большими файлами DBM. Вы можете предпочесть использовать функцию &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; для перебора больших файлов DBM. Пример:</target>
        </trans-unit>
        <trans-unit id="744885e641d2306d4fbe957365af5d32ac0b76f3" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over such. Example:</source>
          <target state="translated">Обратите внимание, что такие функции, как &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; могут возвращать огромные списки при использовании с большими объектами, такими как файлы DBM. Вы можете предпочесть использовать функцию &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; для итерации по такому. Пример:</target>
        </trans-unit>
        <trans-unit id="72ffa6aa03e0b04398c1553e4a97b08735d3745c" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">Обратите внимание, что такие функции, как &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; могут возвращать огромные списки при использовании с большими файлами DBM. Вы можете предпочесть использовать функцию &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; для перебора больших файлов DBM. Пример:</target>
        </trans-unit>
        <trans-unit id="a1b483511502689b9e22b000546db0922817c2d1" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over such. Example:</source>
          <target state="translated">Обратите внимание, что такие функции, как &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; могут возвращать огромные списки при использовании с большими объектами, такими как файлы DBM. Вы можете предпочесть использовать функцию &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; для итерации по такому. Пример:</target>
        </trans-unit>
        <trans-unit id="ae8752600c3751f3c52b44262525865199cca383" translate="yes" xml:space="preserve">
          <source>Note that functions such as keys() and values() may return huge lists when used on large objects, like DBM files. You may prefer to use the each() function to iterate over such. Example:</source>
          <target state="translated">Обратите внимание,что такие функции,как keys()и value()могут возвращать огромные списки при использовании на больших объектах,например,в DBM-файлах.Вы можете предпочесть использовать функцию each()для итераций,а не таких.Пример:</target>
        </trans-unit>
        <trans-unit id="d8b624d4598897ef720d34e8f550c09e63657b83" translate="yes" xml:space="preserve">
          <source>Note that glibc &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;, etc. are buggy before glibc version 2.17. They won't allow a &lt;code&gt;%.s&lt;/code&gt; format with a precision to create a string that isn't valid UTF-8 if the current underlying locale of the program is UTF-8. What happens is that the &lt;code&gt;%s&lt;/code&gt; and its operand are simply skipped without any notice. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что glibc &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; и т. Д. Содержат ошибки до версии glibc 2.17. Они не позволят формату &lt;code&gt;%.s&lt;/code&gt; с точностью создать строку, которая не является допустимой UTF-8, если текущая базовая локаль программы - UTF-8. Происходит то, что &lt;code&gt;%s&lt;/code&gt; и его операнд просто пропускаются без какого-либо уведомления. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="622115f32e89cdb0d30c0373c6c70d90996631c4" translate="yes" xml:space="preserve">
          <source>Note that globbing only lists directories explicitly asked for, for example FOO/* will not list FOO/bar/Acme-Sthg-n.nn.tar.gz. This may be regarded as a bug that may be changed in some future version.</source>
          <target state="translated">Обратите внимание,что globbing только списки каталогов,явно запрашиваемых,например,FOO/*,не будут списывать FOO/bar/Acme-Sthg-n.n.tar.gz.Это может быть расценено как ошибка,которая может быть изменена в некоторых будущих версиях.</target>
        </trans-unit>
        <trans-unit id="608b43e88fa71f94e1e6a28718931116afacd602" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; needs external data for it to work, no subroutine call is possible without it. As an example, the standard debugger's &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; depends on the &lt;code&gt;$DB::deep&lt;/code&gt; variable (it defines how many levels of recursion deep into the debugger you can go before a mandatory break). If &lt;code&gt;$DB::deep&lt;/code&gt; is not defined, subroutine calls are not possible, even though &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; exists.</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; требуются внешние данные для работы, без них невозможно вызвать подпрограмму. Например, стандартный отладчик &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; зависит от переменной &lt;code&gt;$DB::deep&lt;/code&gt; (она определяет, сколько уровней рекурсии глубоко в отладчике вы можете пройти до обязательного перерыва). Если &lt;code&gt;$DB::deep&lt;/code&gt; не определен, вызовы подпрограмм невозможны, даже если существует &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac18f8ca65d2ef342faed7220894d625a0f93e79" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;CanonicalName&lt;/code&gt; is enabled, a normalized filename will be passed to the sub.</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;CanonicalName&lt;/code&gt; включен, в подпрограмму будет передано нормализованное имя файла.</target>
        </trans-unit>
        <trans-unit id="5f3c24624d3659de7e4c912e62eae398eab95882" translate="yes" xml:space="preserve">
          <source>Note that if a pattern compiled within &lt;code&gt;'strict'&lt;/code&gt; is recompiled, say by interpolating into another pattern, outside of &lt;code&gt;'strict'&lt;/code&gt; , it is not checked again for strictness. This is because if it works under strict it must work under non-strict.</source>
          <target state="translated">Обратите внимание, что если шаблон, скомпилированный в &lt;code&gt;'strict'&lt;/code&gt; , перекомпилируется, например, путем интерполяции в другой шаблон, за пределами &lt;code&gt;'strict'&lt;/code&gt; , он не проверяется снова на строгость. Это потому, что если он работает под строгим контролем, он должен работать под нестрогим.</target>
        </trans-unit>
        <trans-unit id="308556457296cab4f486eee25acd00edabad2290" translate="yes" xml:space="preserve">
          <source>Note that if a string argument starts with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; , it will be considered an option on itself.</source>
          <target state="translated">Обратите внимание, что если строковый аргумент начинается с &lt;code&gt;-&lt;/code&gt; или &lt;code&gt;--&lt;/code&gt; , он будет считаться опцией сам по себе.</target>
        </trans-unit>
        <trans-unit id="8c44aba0e7ff586bf06544855993dee92b7ebfb4" translate="yes" xml:space="preserve">
          <source>Note that if a tainted string is added to &lt;code&gt;@INC&lt;/code&gt; , the following problem will be reported:</source>
          <target state="translated">Обратите внимание, что если в &lt;code&gt;@INC&lt;/code&gt; добавлена ​​испорченная строка, будет сообщено о следующей проблеме:</target>
        </trans-unit>
        <trans-unit id="9afccffdaaa8763c6bff65d340b0383eec4b2bf1" translate="yes" xml:space="preserve">
          <source>Note that if a temp directory is your current directory, it cannot be removed. C</source>
          <target state="translated">Обратите внимание,что если временный каталог является вашим текущим каталогом,он не может быть удален.C</target>
        </trans-unit>
        <trans-unit id="e3273fcdfd70332486252bf4b49416cc8786a3a4" translate="yes" xml:space="preserve">
          <source>Note that if an initialized scalar variable is used instead the result is different: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh='zzz'; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;($fh, ...)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;( *{'zzz'}, ...)&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; forbids such practice.</source>
          <target state="translated">Обратите внимание: если вместо этого используется инициализированная скалярная переменная, результат будет другим: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh='zzz'; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;($fh, ...)&lt;/code&gt; эквивалентен &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;( *{'zzz'}, ...)&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; запрещает такую ​​практику.</target>
        </trans-unit>
        <trans-unit id="6fd8bc012a0b5fd862eb29b81c0bd7a1843836fc" translate="yes" xml:space="preserve">
          <source>Note that if multiple files are parsed for a single POD document (perhaps the result of some future &lt;code&gt;=include&lt;/code&gt; directive) this method is invoked for every file that is parsed. If you wish to perform certain initializations once per document, then you should use &lt;b&gt;begin_pod()&lt;/b&gt;.</source>
          <target state="translated">Обратите внимание, что если несколько файлов анализируются для одного документа POD (возможно, в результате какой-то директивы future &lt;code&gt;=include&lt;/code&gt; ), этот метод вызывается для каждого анализируемого файла. Если вы хотите выполнить определенные инициализации один раз для каждого документа, вам следует использовать &lt;b&gt;begin_pod ()&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="826d10bf58e0edead500c1a2f5a6d8c68eb347e0" translate="yes" xml:space="preserve">
          <source>Note that if no errors are encountered, &lt;code&gt;$err&lt;/code&gt; will reference an empty array. This means that &lt;code&gt;$err&lt;/code&gt; will always end up TRUE; so you need to test &lt;code&gt;@$err&lt;/code&gt; to determine if errors occured.</source>
          <target state="translated">Обратите внимание: если ошибок не обнаружено, &lt;code&gt;$err&lt;/code&gt; будет ссылаться на пустой массив. Это означает, что &lt;code&gt;$err&lt;/code&gt; всегда будет иметь значение ИСТИНА; поэтому вам нужно проверить &lt;code&gt;@$err&lt;/code&gt; чтобы определить, произошли ли ошибки.</target>
        </trans-unit>
        <trans-unit id="1324e5c55e1f48c00e9179366ddca7ad4be15ea2" translate="yes" xml:space="preserve">
          <source>Note that if tests have a trailing plan, it is not possible to set this property for unplanned tests as we do not know it's unplanned until the plan is reached:</source>
          <target state="translated">Обратите внимание,что если у тестов есть трейлинговый план,невозможно установить это свойство для незапланированных тестов,так как мы не знаем,что он незапланирован до тех пор,пока план не будет достигнут:</target>
        </trans-unit>
        <trans-unit id="58bd8c74c7de485d278dd761f4ec5c815966b6fe" translate="yes" xml:space="preserve">
          <source>Note that if the cache is a tied hash, &lt;code&gt;flush_cache&lt;/code&gt; will attempt to invoke the &lt;code&gt;CLEAR&lt;/code&gt; method on the hash. If there is no &lt;code&gt;CLEAR&lt;/code&gt; method, this will cause a run-time error.</source>
          <target state="translated">Обратите внимание, что если кеш является связанным хешем, &lt;code&gt;flush_cache&lt;/code&gt; попытается вызвать метод &lt;code&gt;CLEAR&lt;/code&gt; для хеша. Если метод &lt;code&gt;CLEAR&lt;/code&gt; отсутствует , это вызовет ошибку времени выполнения.</target>
        </trans-unit>
        <trans-unit id="9c084f4d82be664fcc79d00bcef732fc1be8ca28" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt; Unicode characters are read instead of bytes (the LENGTH, OFFSET, and the return value of sysread() are in Unicode characters). The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt;, &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;, and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что если дескриптор файла был помечен как &lt;code&gt;:utf8&lt;/code&gt; , символы Unicode читаются вместо байтов (LENGTH, OFFSET и возвращаемое значение sysread () находятся в символах Unicode). Уровень &lt;code&gt;:encoding(...)&lt;/code&gt; неявно представляет уровень &lt;code&gt;:utf8&lt;/code&gt; . См. &lt;a href=&quot;#binmode&quot;&gt;Binmode&lt;/a&gt; , &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt; и &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a528a8e216af2d3ed813e217add7c3fe0518eef" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt; Unicode characters are read instead of bytes (the LENGTH, OFFSET, and the return value of sysread() are in Unicode characters). The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;, and the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что если дескриптор файла был помечен как &lt;code&gt;:utf8&lt;/code&gt; , символы Unicode читаются вместо байтов (LENGTH, OFFSET и возвращаемое значение sysread () находятся в символах Unicode). Уровень &lt;code&gt;:encoding(...)&lt;/code&gt; неявно представляет уровень &lt;code&gt;:utf8&lt;/code&gt; . См. &lt;a href=&quot;binmode&quot;&gt;Binmode&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; и &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0908e03d8ce40c7005e83d17332e47cd6f9ef387" translate="yes" xml:space="preserve">
          <source>Note that if the input text is a read-only string (i.e. a literal), no attempt is made to remove the extracted text.</source>
          <target state="translated">Обратите внимание,что если вводимый текст является строкой,доступной только для чтения (т.е.литералом),попытка удалить извлеченный текст не предпринимается.</target>
        </trans-unit>
        <trans-unit id="34c9b253a358e643fbf719eebaacbe9ee361bc74" translate="yes" xml:space="preserve">
          <source>Note that if the platform doesn't have &lt;code&gt;LC_NUMERIC&lt;/code&gt; and/or &lt;code&gt;LC_MONETARY&lt;/code&gt; available or enabled, the corresponding elements of the hash will be missing.</source>
          <target state="translated">Обратите внимание, что если платформа не имеет доступных или включенных &lt;code&gt;LC_NUMERIC&lt;/code&gt; и / или &lt;code&gt;LC_MONETARY&lt;/code&gt; , соответствующие элементы хэша будут отсутствовать.</target>
        </trans-unit>
        <trans-unit id="c9c7ab75927f08e77cc4898e73b8aeda27cc0c9a" translate="yes" xml:space="preserve">
          <source>Note that if the regular expression is tainted, then Perl will die rather than calling the subroutine when the name of the subroutine is determined by the tainted data.</source>
          <target state="translated">Обратите внимание,что если регулярное выражение является запятнанным,то Perl умрет,вместо того,чтобы вызывать подпрограмму,когда имя подпрограммы будет определено по запятнанным данным.</target>
        </trans-unit>
        <trans-unit id="2b2dc5e51258adfa883882440e13a3cae6f294a4" translate="yes" xml:space="preserve">
          <source>Note that if the version of the PM module is an NV (a floating point number), it will be stringified with a possible loss of precision (currently chopping to nine decimal places) so that it may not match the version of the XS module anymore. Quoting the $VERSION declaration to make it a string is recommended if long version numbers are used.</source>
          <target state="translated">Обратите внимание,что если версия модуля PM является NV (число с плавающей точкой),то она будет строиться с возможной потерей точности (в настоящее время измельчение до девяти знаков после запятой),так что она может больше не совпадать с версией модуля XS.При использовании длинных номеров версий рекомендуется цитировать декларацию $VERSION,чтобы сделать ее строкой.</target>
        </trans-unit>
        <trans-unit id="6c6048c09fbd601d5bded4c49f7b53cc961721c5" translate="yes" xml:space="preserve">
          <source>Note that if there was a subroutine call between us and line 29, and we wanted to &lt;b&gt;single-step&lt;/b&gt; through it, we could use the '&lt;b&gt;s&lt;/b&gt;' command, and to step over it we would use '&lt;b&gt;n&lt;/b&gt;' which would execute the sub, but not descend into it for inspection. In this case though, we simply continue down to line 29:</source>
          <target state="translated">Обратите внимание, что если бы между нами и строкой 29 был вызов подпрограммы, и мы хотели бы &lt;b&gt;пройти&lt;/b&gt; через нее &lt;b&gt;пошагово&lt;/b&gt; , мы могли бы использовать команду ' &lt;b&gt;s&lt;/b&gt; ', а для перехода через нее мы использовали бы ' &lt;b&gt;n&lt;/b&gt; ', которая будет выполнять подпрограмму, но не спускаться в нее для осмотра. В этом случае мы просто продолжаем до строки 29:</target>
        </trans-unit>
        <trans-unit id="9f3dd1e37239e5e6990e5357970b72eac4a59098" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что если бы на указанном выше был блок &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , он выполнялся бы даже на отброшенных строках. Если LABEL опущен, команда обращается к самому внутреннему охватывающему циклу. &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; форма доступна как в Perl 5.18.0, позволяет имя метки быть вычислена во время выполнения, будучи в противном случае идентичен &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60ee3cf42536d2e0cc61b8039c6f1a0a75072a6a" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above code, it would get executed only on lines discarded by the regex (since redo skips the continue block). A continue block is often used to reset line counters or &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m?pat?&lt;/a&gt;&lt;/code&gt; one-time matches:</source>
          <target state="translated">Обратите внимание, что если бы в приведенном выше коде был блок &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , он бы выполнялся только на строках, отброшенных регулярным выражением (поскольку при повторном выполнении блок продолжения пропускается). Блок продолжения часто используется для сброса счетчиков строк или &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m?pat?&lt;/a&gt;&lt;/code&gt; разовые матчи:</target>
        </trans-unit>
        <trans-unit id="03cca16cecaf26d400e510c53bbfbaac8d0326bf" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что если бы на указанном выше был блок &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , он выполнялся бы даже на отброшенных строках. Если LABEL опущен, команда обращается к самому внутреннему охватывающему циклу. &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; форма доступна как в Perl 5.18.0, позволяет имя метки быть вычислена во время выполнения, будучи в противном случае идентичен &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d19c5d18d3d9efa0c0b12037ddf03239e4ec1d14" translate="yes" xml:space="preserve">
          <source>Note that if this module is imported when &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; has not yet been loaded, then these functions all become no-ops. This makes it possible to write modules that will work in both threaded and non-threaded environments.</source>
          <target state="translated">Обратите внимание, что если этот модуль импортируется, когда &lt;a href=&quot;../threads&quot;&gt;потоки&lt;/a&gt; еще не загружены, все эти функции перестают работать. Это позволяет писать модули, которые будут работать как в поточной, так и в непоточной среде.</target>
        </trans-unit>
        <trans-unit id="a67c2908702a6cdf59ca28b987d8e4a389fc1fa9" translate="yes" xml:space="preserve">
          <source>Note that if this operator is used and NOT inside of an alternation then it acts exactly like the &lt;code&gt;(*PRUNE)&lt;/code&gt; operator.</source>
          <target state="translated">Обратите внимание, что если этот оператор используется, а НЕ внутри чередования, он действует точно так же, как оператор &lt;code&gt;(*PRUNE)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdc2bfbf6748eacea8c87035966d754d0f68c5a3" translate="yes" xml:space="preserve">
          <source>Note that if using gcc, starting from Perl 5.9.5 the Perl core source code files (the ones at the top level of the source code distribution, but not e.g. the extensions under ext/) are automatically compiled with as many as possible of the &lt;code&gt;-std=c89&lt;/code&gt; , &lt;code&gt;-ansi&lt;/code&gt; , &lt;code&gt;-pedantic&lt;/code&gt; , and a selection of &lt;code&gt;-W&lt;/code&gt; flags (see cflags.SH).</source>
          <target state="translated">Обратите внимание, что при использовании gcc, начиная с Perl 5.9.5, файлы исходного кода ядра Perl (те, которые находятся на верхнем уровне распределения исходного кода, но не, например, расширения в ext /) автоматически компилируются с максимально возможным количеством файлов &lt;code&gt;-std=c89&lt;/code&gt; , &lt;code&gt;-ansi&lt;/code&gt; , &lt;code&gt;-pedantic&lt;/code&gt; и набор флагов &lt;code&gt;-W&lt;/code&gt; (см. cflags.SH).</target>
        </trans-unit>
        <trans-unit id="dfe5b081a33f6efff2f505814c3590456b24ec50" translate="yes" xml:space="preserve">
          <source>Note that if you do not have Module::Signature installed, no signature checks will be performed at all.</source>
          <target state="translated">Обратите внимание,что если у вас не установлен модуль Module::Signature,проверка подписи не будет производиться вообще.</target>
        </trans-unit>
        <trans-unit id="7890360c193f0760d43a2add9be2d600e6cb6a32" translate="yes" xml:space="preserve">
          <source>Note that if you do not plan to build the perl itself, it may be possible to fool EMX to truncate file names. This is not supported, read EMX docs to see how to do it.</source>
          <target state="translated">Обратите внимание,что если вы не планируете собирать сам perl,то можно обмануть EMX,чтобы усечь имена файлов.Это не поддерживается,прочитайте EMX-документы,чтобы узнать,как это сделать.</target>
        </trans-unit>
        <trans-unit id="7074505ed79917df5e0904da32c456ed53b1b35d" translate="yes" xml:space="preserve">
          <source>Note that if you have</source>
          <target state="translated">Обратите внимание,что если у вас есть</target>
        </trans-unit>
        <trans-unit id="16452a0ac87813870c05c7095ba75ee11a8d9c6d" translate="yes" xml:space="preserve">
          <source>Note that if you have bytes with the eighth bit on in your script (for example embedded Latin-1 in your string literals), &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; will be unhappy since the bytes are most probably not well-formed UTF-X. If you want to have such bytes under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , you can disable this pragma until the end the block (or file, if at top level) by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8;&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что если у вас есть байты с восьмым битом в вашем скрипте (например, встроенный Latin-1 в ваши строковые литералы), &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; будет неудовлетворительным, поскольку байты, скорее всего, не являются правильно сформированным UTF-X. Если вы хотите, чтобы такие байты &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , вы можете отключить эту директиву до конца блока (или файла, если он находится на верхнем уровне) с помощью &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c4aa42b29cc2c2cbee7d6400738523e5bb46393" translate="yes" xml:space="preserve">
          <source>Note that if you have chdir'ed into the temporary directory and it is subsequently cleaned up (either in the END block or as part of object destruction), then you will get a warning from File::Path::rmtree().</source>
          <target state="translated">Обратите внимание,что если у вас есть chdir'ed во временном каталоге и он впоследствии очищается (либо в блоке END,либо как часть уничтожения объектов),то вы получите предупреждение от File::Path::rmtree().</target>
        </trans-unit>
        <trans-unit id="f635910faf20c1937408464313d28376fda868a1" translate="yes" xml:space="preserve">
          <source>Note that if you have to look for strings that you don't know till runtime, you can build an entire loop as a string and &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; that to avoid recompiling all your patterns all the time. Together with undefining &lt;code&gt;$/&lt;/code&gt; to input entire files as one record, this can be quite fast, often faster than specialized programs like fgrep(1). The following scans a list of files (&lt;code&gt;@files&lt;/code&gt; ) for a list of words (&lt;code&gt;@words&lt;/code&gt; ), and prints out the names of those files that contain a match:</source>
          <target state="translated">Обратите внимание: если вам нужно искать строки, которые вы не знаете до выполнения, вы можете построить весь цикл как строку и &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , чтобы избежать постоянной перекомпиляции всех ваших шаблонов. Вместе с неопределением &lt;code&gt;$/&lt;/code&gt; для ввода целых файлов как одной записи это может быть довольно быстро, часто быстрее, чем специализированные программы, такие как fgrep (1). Следующее сканирует список файлов ( &lt;code&gt;@files&lt;/code&gt; ) на предмет списка слов ( &lt;code&gt;@words&lt;/code&gt; ) и распечатывает имена тех файлов, которые содержат совпадения:</target>
        </trans-unit>
        <trans-unit id="563eabb7ceca135c66cd9da9fa7638ecd48fe576" translate="yes" xml:space="preserve">
          <source>Note that if you have to look for strings that you don't know till runtime, you can build an entire loop as a string and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; that to avoid recompiling all your patterns all the time. Together with undefining &lt;code&gt;$/&lt;/code&gt; to input entire files as one record, this can be quite fast, often faster than specialized programs like fgrep(1). The following scans a list of files (&lt;code&gt;@files&lt;/code&gt; ) for a list of words (&lt;code&gt;@words&lt;/code&gt; ), and prints out the names of those files that contain a match:</source>
          <target state="translated">Обратите внимание: если вам нужно искать строки, которые вы не знаете до выполнения, вы можете построить весь цикл как строку и &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , чтобы избежать постоянной перекомпиляции всех ваших шаблонов. Вместе с неопределением &lt;code&gt;$/&lt;/code&gt; для ввода целых файлов как одной записи это может быть довольно быстро, часто быстрее, чем специализированные программы, такие как fgrep (1). Следующее сканирует список файлов ( &lt;code&gt;@files&lt;/code&gt; ) на предмет списка слов ( &lt;code&gt;@words&lt;/code&gt; ) и распечатывает имена тех файлов, которые содержат совпадения:</target>
        </trans-unit>
        <trans-unit id="472f29cb35dcdd9e0bdaee6718ec77f646cf840a" translate="yes" xml:space="preserve">
          <source>Note that if you take a copy of a scalar with a weakened reference, the copy will be a strong reference.</source>
          <target state="translated">Обратите внимание,что если вы берете копию скаляра с ослабленной ссылкой,то копия будет сильной ссылкой.</target>
        </trans-unit>
        <trans-unit id="c4a0c1fef1effc8f82cf7edc96e6b440867de0be" translate="yes" xml:space="preserve">
          <source>Note that if you want to do a batch conversion of a lot of Pod documents to HTML, you should see the module &lt;a href=&quot;htmlbatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что если вы хотите выполнить пакетное преобразование большого количества документов Pod в HTML, вы должны увидеть модуль &lt;a href=&quot;htmlbatch&quot;&gt;Pod :: Simple :: HTMLBatch&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bef8dc28c2922471f2bbf667ac531cc355fd0094" translate="yes" xml:space="preserve">
          <source>Note that if you want to enable a warnings category registered by a module (e.g. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'File::Find'&lt;/code&gt; ), you must have loaded this module first.</source>
          <target state="translated">Обратите внимание, что если вы хотите включить категорию предупреждений, зарегистрированную модулем (например, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'File::Find'&lt;/code&gt; ), вы должны сначала загрузить этот модуль.</target>
        </trans-unit>
        <trans-unit id="5645d5d10ea8883aafab68e6dc7420fa5396f224" translate="yes" xml:space="preserve">
          <source>Note that if you want to pass on any elements of the C-local environ array to a subprocess which isn't started by fork/exec, or isn't running a C program, you can &quot;promote&quot; them to logical names in the current process, which will then be inherited by all subprocesses, by saying</source>
          <target state="translated">Обратите внимание,что если вы хотите передать какие-либо элементы массива среды C-local подпроцессу,который не запущен fork/exec,или не запущен программой на C,то вы можете &quot;продвинуть&quot; их в текущем процессе по логическим именам,которые затем будут унаследованы всеми подпроцессами,говоря</target>
        </trans-unit>
        <trans-unit id="438e992f414c0fb7d0ae67132225f8fb511bf800" translate="yes" xml:space="preserve">
          <source>Note that if you're using Windows, no solution to this vexing issue is even possible. Even though Perl emulates &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;, you'll still be stuck, because Windows does not have an argc/argv-style API.</source>
          <target state="translated">Обратите внимание: если вы используете Windows, решение этой неприятной проблемы невозможно. Несмотря на то, что Perl эмулирует &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; , вы все равно застрянете, потому что в Windows нет API в стиле argc / argv.</target>
        </trans-unit>
        <trans-unit id="631593fdac38ac18af70717272a4671c53190f39" translate="yes" xml:space="preserve">
          <source>Note that if your forked child inherits system file descriptors like STDIN and STDOUT that are actually connected by a pipe or socket, even if you exit, then the remote server (such as, say, a CGI script or a backgrounded job launched from a remote shell) won't think you're done. You should reopen those to</source>
          <target state="translated">Обратите внимание,что если ваш дочерний процесс наследует системные файловые дескрипторы,такие как STDIN и STDOUT,которые на самом деле подключены через трубу или сокет,даже если вы выйдете,то удаленный сервер (например,CGI скрипт или фоновая работа,запущенная из удаленной оболочки)не подумает,что вы закончили.Вы должны открыть их заново,чтобы</target>
        </trans-unit>
        <trans-unit id="70eb4fc52446e8c7cd71ef0fc3bcc0bd68008c67" translate="yes" xml:space="preserve">
          <source>Note that in Perl 5.17.3 and earlier, the last three constants were also used for the caret variants of the variables.</source>
          <target state="translated">Обратите внимание,что в Perl 5.17.3 и более ранних версиях для каретных вариантов переменных также использовались три последние константы.</target>
        </trans-unit>
        <trans-unit id="8b6ec9401ff25a7e7f20f8f508c8e573ab6cef28" translate="yes" xml:space="preserve">
          <source>Note that in Perl version prior to 5.18 inheritance of the &lt;code&gt;fallback&lt;/code&gt; key was not governed by the above rules. The value of &lt;code&gt;fallback&lt;/code&gt; in the first overloaded ancestor was used. This was fixed in 5.18 to follow the usual rules of inheritance.</source>
          <target state="translated">Обратите внимание, что в версии Perl до 5.18 наследование &lt;code&gt;fallback&lt;/code&gt; ключа не регулировалось приведенными выше правилами. Было использовано значение &lt;code&gt;fallback&lt;/code&gt; в первом перегруженном предке. Это было исправлено в 5.18, чтобы соответствовать обычным правилам наследования.</target>
        </trans-unit>
        <trans-unit id="7dadc679f5466d79da0156797f6b8d65ca1758f1" translate="yes" xml:space="preserve">
          <source>Note that in a few cases this translation can't be perfectly carried back into the source code -- if the loop's initializer declares a my variable, for instance, it won't have the correct scope outside of the loop.</source>
          <target state="translated">Обратите внимание,что в некоторых случаях эта трансляция не может быть идеально перенесена обратно в исходный код --если инициализатор цикла объявит,например,мою переменную,то она не будет иметь корректной области видимости за пределами цикла.</target>
        </trans-unit>
        <trans-unit id="5bedfdd7af45ab7b673c4a8860ff4cc65683c959" translate="yes" xml:space="preserve">
          <source>Note that in a list context, the contents of the original input text (the first argument) are not modified in any way.</source>
          <target state="translated">Обратите внимание,что в контексте списка содержимое исходного входного текста (первый аргумент)никак не изменяется.</target>
        </trans-unit>
        <trans-unit id="19da40726b3583f6544a1c2e542496723da7a424" translate="yes" xml:space="preserve">
          <source>Note that in all cases of &quot;E&amp;lt;whatever&amp;gt;&quot;,</source>
          <target state="translated">Обратите внимание, что во всех случаях &amp;laquo;E &amp;lt;whatever&amp;gt;&amp;raquo;,</target>
        </trans-unit>
        <trans-unit id="9e72d3882d1c9bd4efe9fc3533a3f5c9da90ccbc" translate="yes" xml:space="preserve">
          <source>Note that in contrast with &lt;a href=&quot;#EXAMPLE-1&quot;&gt;EXAMPLE 1&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;EXAMPLE 2&lt;/a&gt; and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;EXAMPLE 3&lt;/a&gt;, this description does not contain the actual</source>
          <target state="translated">Обратите внимание, что в отличие от &lt;a href=&quot;#EXAMPLE-1&quot;&gt;ПРИМЕРА 1&lt;/a&gt; , &lt;a href=&quot;#EXAMPLE-2&quot;&gt;ПРИМЕРА 2&lt;/a&gt; и &lt;a href=&quot;#EXAMPLE-3&quot;&gt;ПРИМЕРА 3&lt;/a&gt; , это описание не содержит фактических</target>
        </trans-unit>
        <trans-unit id="cc47544345a2ab281008488b23e05567f0a20d81" translate="yes" xml:space="preserve">
          <source>Note that in older versions of this module, the &lt;code&gt;error()&lt;/code&gt; method would return an effectively global value even when called an instance method as above. This has since been fixed, and multiple instances of &lt;code&gt;Archive::Tar&lt;/code&gt; now have separate error strings.</source>
          <target state="translated">Обратите внимание, что в более старых версиях этого модуля метод &lt;code&gt;error()&lt;/code&gt; возвращал эффективное глобальное значение даже при вызове метода экземпляра, как указано выше. С тех пор это было исправлено, и несколько экземпляров &lt;code&gt;Archive::Tar&lt;/code&gt; теперь имеют отдельные строки ошибок.</target>
        </trans-unit>
        <trans-unit id="d8bd3a3217fec8f830ea11bdf3eeaefb81cab80f" translate="yes" xml:space="preserve">
          <source>Note that in scalar and void contexts the value of this argument is automatically reset to 1 (under &lt;code&gt;-w&lt;/code&gt; , a warning is issued if the argument has to be reset).</source>
          <target state="translated">Обратите внимание, что в контексте scalar и void значение этого аргумента автоматически сбрасывается до 1 (при &lt;code&gt;-w&lt;/code&gt; выдается предупреждение, если аргумент должен быть сброшен).</target>
        </trans-unit>
        <trans-unit id="41929543f660fb86d6970d86dc2f5cfae1674011" translate="yes" xml:space="preserve">
          <source>Note that in the above cases, &lt;code&gt;thing($foo)&lt;/code&gt; and &lt;code&gt;thing($bar)&lt;/code&gt;</source>
          <target state="translated">Обратите внимание, что в приведенных выше случаях &lt;code&gt;thing($foo)&lt;/code&gt; и &lt;code&gt;thing($bar)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2e34b6badd14d9162b8051b5a13e0d935b53fb3b" translate="yes" xml:space="preserve">
          <source>Note that install() gives no meaningful return value. See uptodate().</source>
          <target state="translated">Обратите внимание,что функция install()не дает никакого осмысленного возвращаемого значения.См.uptodate().</target>
        </trans-unit>
        <trans-unit id="5f8451b3868737fe3b564168fce4efa0bb98f6a4" translate="yes" xml:space="preserve">
          <source>Note that it is a fatal error for any method (including &lt;code&gt;AUTOLOAD&lt;/code&gt; ) to attempt to redispatch any method that does not have the same name. For example:</source>
          <target state="translated">Обратите внимание, что попытка повторной отправки любого метода с другим именем является фатальной ошибкой для любого метода (включая &lt;code&gt;AUTOLOAD&lt;/code&gt; ). Например:</target>
        </trans-unit>
        <trans-unit id="01d339e0f582d233719162f7a04439bf08b5fc04" translate="yes" xml:space="preserve">
          <source>Note that it is generally not a good idea to try to build a perl with INST_DRV and INST_TOP set to a path that already exists from a previous build. In particular, this may cause problems with the lib/ExtUtils/t/Embed.t test, which attempts to build a test program and may end up building against the installed perl's lib/CORE directory rather than the one being tested.</source>
          <target state="translated">Обратите внимание,что обычно не стоит пытаться собрать perl с набором INST_DRV и INST_TOP по пути,который уже существует из предыдущей сборки.В частности,это может вызвать проблемы с тестом lib/ExtUtils/t/Embed.t,который пытается собрать тестовую программу и может закончиться сборкой не из тестируемого,а из установленного каталога perl lib/CORE.</target>
        </trans-unit>
        <trans-unit id="399a43994f597fec22280e4ffa2bc677a89fdfb6" translate="yes" xml:space="preserve">
          <source>Note that it is important to quote the __CALLER__::Roo identifier because a bug in perl 5.8 will refuse to parse it and cause an unknown error.</source>
          <target state="translated">Обратите внимание,что важно процитировать идентификатор __CALLER__::Roo,так как ошибка в perl 5.8 откажет в его разборе и приведет к неизвестной ошибке.</target>
        </trans-unit>
        <trans-unit id="7affed7382c3656cc0a49bfbc4f14899cf69001a" translate="yes" xml:space="preserve">
          <source>Note that it is not advisable to access a file handle within a signal handler where that signal has interrupted an I/O operation on that same handle. While perl will at least try hard not to crash, there are no guarantees of data integrity; for example, some data might get dropped or written twice.</source>
          <target state="translated">Обратите внимание,что не рекомендуется обращаться к файловому дескриптору внутри обработчика сигналов,если этот сигнал прервал операцию ввода/вывода на том же дескрипторе.Хотя perl будет,по крайней мере,стараться не допустить сбоя,гарантии целостности данных отсутствуют;например,некоторые данные могут быть сброшены или записаны дважды.</target>
        </trans-unit>
        <trans-unit id="6d3396c1176b4f12172442de7b35ea46ac2562aa" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to call &lt;code&gt;PUSHMARK&lt;/code&gt; in this instance. This is because</source>
          <target state="translated">Обратите внимание, что в этом случае нет необходимости вызывать &lt;code&gt;PUSHMARK&lt;/code&gt; . Это потому что</target>
        </trans-unit>
        <trans-unit id="2b288b308a1bd032de8fa4a9b9c0a2a922d5b4a8" translate="yes" xml:space="preserve">
          <source>Note that it is okay to create a library which contains a dependent library that is already linked into perl.</source>
          <target state="translated">Обратите внимание,что можно создать библиотеку,содержащую зависимую библиотеку,которая уже скомпонована с perl.</target>
        </trans-unit>
        <trans-unit id="020e05231aab23e5af6e78f2d08d9849390e5ac0" translate="yes" xml:space="preserve">
          <source>Note that it is possible to have &lt;code&gt;__DATA__&lt;/code&gt; tokens in the same package in multiple files, and that the last &lt;code&gt;__DATA__&lt;/code&gt; token in a given package that is encountered by the compiler is the one accessible by the filehandle. This also applies to &lt;code&gt;__END__&lt;/code&gt; and main, i.e. if the 'main' program has an &lt;code&gt;__END__&lt;/code&gt; , but a module 'require'd (_not_ 'use'd) by that program has a 'package main;' declaration followed by an '&lt;code&gt;__DATA__&lt;/code&gt; ', then the &lt;code&gt;DATA&lt;/code&gt; filehandle is set to access the data after the &lt;code&gt;__DATA__&lt;/code&gt; in the module, _not_ the data after the &lt;code&gt;__END__&lt;/code&gt; token in the 'main' program, since the compiler encounters the 'require'd file later.</source>
          <target state="translated">Обратите внимание, что возможно иметь токены &lt;code&gt;__DATA__&lt;/code&gt; в одном пакете в нескольких файлах, и что последний токен &lt;code&gt;__DATA__&lt;/code&gt; в данном пакете, с которым сталкивается компилятор, является токеном, доступным для дескриптора файла. Это также применимо к &lt;code&gt;__END__&lt;/code&gt; и main, то есть если у &amp;laquo;основной&amp;raquo; программы есть &lt;code&gt;__END__&lt;/code&gt; , но у модуля, 'require'd (_not_' use'd) этой программой, есть 'package main;' объявление, за которым следует ' &lt;code&gt;__DATA__&lt;/code&gt; ', то дескриптор файла &lt;code&gt;DATA&lt;/code&gt; устанавливается для доступа к данным после &lt;code&gt;__DATA__&lt;/code&gt; в модуле, _не_ данных после токена &lt;code&gt;__END__&lt;/code&gt; в 'основной' программе, поскольку компилятор обнаруживает 'require'd файл позже.</target>
        </trans-unit>
        <trans-unit id="e02a747b9a7a24aeffcddaceb1b0a554d3946c9f" translate="yes" xml:space="preserve">
          <source>Note that it is possible to write portable code for these by specifying things in Unicode numbers, and using a conversion function:</source>
          <target state="translated">Обратите внимание,что для этого можно написать переносимый код,указав вещи в числах Юникода и используя функцию преобразования:</target>
        </trans-unit>
        <trans-unit id="597951c8ec638d515f08de4fa8f2ce8a96e0a9a0" translate="yes" xml:space="preserve">
          <source>Note that it is probably meaningless to call the functions overload::constant() and overload::remove_constant() from anywhere but import() and unimport() methods. From these methods they may be called as</source>
          <target state="translated">Обратите внимание,что,вероятно,бессмысленно вызывать функции overload::constant()и overload::remove_constant()из любого места,кроме методов import()и unimport().Из этих методов они могут вызываться как</target>
        </trans-unit>
        <trans-unit id="b593f41651d7a872851c870e53e6652c0659531a" translate="yes" xml:space="preserve">
          <source>Note that it isn't a good idea to specify these types of ranges anyway.</source>
          <target state="translated">Обратите внимание,что в любом случае не стоит указывать эти типы диапазонов.</target>
        </trans-unit>
        <trans-unit id="5dd80f85677999c53d6b25deeca079eeb865515a" translate="yes" xml:space="preserve">
          <source>Note that it only confirms the bare minimum structure (so as not to get confused by derived classes which may contain additional hash entries):</source>
          <target state="translated">Обратите внимание,что это только подтверждает минимальную &quot;голую&quot; структуру (чтобы не запутаться в производных классах,которые могут содержать дополнительные записи хэша):</target>
        </trans-unit>
        <trans-unit id="e50d411d2523ee4ff5b0357ec19f1bfed82fa0ca" translate="yes" xml:space="preserve">
          <source>Note that it's perfectly acceptable for some lines to have test numbers and others to not have them. However, when a test number is found, it must be in sequence. The following is also an error:</source>
          <target state="translated">Обратите внимание,что для одних строк вполне допустимо наличие номеров тестов,а для других-их отсутствие.Однако,когда тестовый номер найден,он должен быть последовательным.Следующее также является ошибкой:</target>
        </trans-unit>
        <trans-unit id="9a913045922e1a369e32f6e9094b0a8adfbe43e8" translate="yes" xml:space="preserve">
          <source>Note that it's possible to confuse Perl into thinking &lt;code&gt;//&lt;/code&gt; (the empty regex) is really &lt;code&gt;//&lt;/code&gt; (the defined-or operator). Perl is usually pretty good about this, but some pathological cases might trigger this, such as &lt;code&gt;$x///&lt;/code&gt; (is that &lt;code&gt;($x) / (//)&lt;/code&gt; or &lt;code&gt;$x // /&lt;/code&gt; ?) and &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $fh //&lt;/code&gt; (&lt;code&gt;print $fh(//&lt;/code&gt; or &lt;code&gt;print($fh //&lt;/code&gt;?). In all of these examples, Perl will assume you meant defined-or. If you meant the empty regex, just use parentheses or spaces to disambiguate, or even prefix the empty regex with an &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; (so &lt;code&gt;//&lt;/code&gt; becomes &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, что Perl можно запутать, заставив думать, что &lt;code&gt;//&lt;/code&gt; (пустое регулярное выражение) действительно &lt;code&gt;//&lt;/code&gt; (оператор определенного или). Perl обычно неплохо справляется с этим, но некоторые патологические случаи могут вызвать это, например, &lt;code&gt;$x///&lt;/code&gt; (это &lt;code&gt;($x) / (//)&lt;/code&gt; или &lt;code&gt;$x // /&lt;/code&gt; ?) И &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $fh //&lt;/code&gt; ( &lt;code&gt;print $fh(//&lt;/code&gt; или &lt;code&gt;print($fh //&lt;/code&gt; ?). Во всех этих примерах Perl будет предполагать, что вы имели в виду определенное-или. Если вы имели в виду пустое регулярное выражение, просто используйте круглые скобки или пробелы для устранения неоднозначности или даже префикс пустое регулярное выражение с &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; (поэтому &lt;code&gt;//&lt;/code&gt; становится &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="830a684c09bf9bdd212ea3a74c23e24fe820c679" translate="yes" xml:space="preserve">
          <source>Note that just as in C, Perl doesn't define &lt;b&gt;when&lt;/b&gt; the variable is incremented or decremented. You just know it will be done sometime before or after the value is returned. This also means that modifying a variable twice in the same statement will lead to undefined behavior. Avoid statements like:</source>
          <target state="translated">Обратите внимание, что, как и в C, Perl не определяет, &lt;b&gt;когда&lt;/b&gt; переменная увеличивается или уменьшается. Вы просто знаете, что это будет сделано где-то до или после возврата значения. Это также означает, что изменение переменной дважды в одном операторе приведет к неопределенному поведению. Избегайте таких заявлений, как:</target>
        </trans-unit>
        <trans-unit id="a43f2c8c90c96b6a2393740d3a2acc243f34fc78" translate="yes" xml:space="preserve">
          <source>Note that just because a hash is initialized in that order doesn't mean that it comes out in that order. See &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; for examples of how to arrange for an output ordering.</source>
          <target state="translated">Обратите внимание: то, что хеш инициализируется в таком порядке, не означает, что он появляется в этом порядке. См. В разделе &lt;a href=&quot;functions/sort&quot;&gt;Сортировка&lt;/a&gt; примеры того, как организовать порядок вывода.</target>
        </trans-unit>
        <trans-unit id="c24181c497b3bc3da696d72d56d3b63ee4e8b425" translate="yes" xml:space="preserve">
          <source>Note that like all the punctuation variables, you cannot currently use my() on &lt;code&gt;$^W&lt;/code&gt; , only local().</source>
          <target state="translated">Обратите внимание, что, как и все переменные пунктуации, в настоящее время вы не можете использовать my () для &lt;code&gt;$^W&lt;/code&gt; , только local ().</target>
        </trans-unit>
        <trans-unit id="065e7735efe282ba9a9b62697058bf416b3fcc20" translate="yes" xml:space="preserve">
          <source>Note that macros &lt;code&gt;ST(i)&lt;/code&gt; , &lt;code&gt;XST_m*()&lt;/code&gt; and &lt;code&gt;XSRETURN*()&lt;/code&gt; work equally well in CODE: sections and PPCODE: sections.</source>
          <target state="translated">Обратите внимание, что макросы &lt;code&gt;ST(i)&lt;/code&gt; , &lt;code&gt;XST_m*()&lt;/code&gt; и &lt;code&gt;XSRETURN*()&lt;/code&gt; одинаково хорошо работают в разделах CODE: и PPCODE :.</target>
        </trans-unit>
        <trans-unit id="c14a124574e395835da21cb4f1ebabcb93935e43" translate="yes" xml:space="preserve">
          <source>Note that most Unicode characters don't have a decomposition, so their decomposition type is &lt;code&gt;&quot;None&quot;&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что большинство символов Unicode не имеют разложения, поэтому их тип разложения - &lt;code&gt;&quot;None&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de00dbea9481bda931fa7e30e09096749bd42bf3" translate="yes" xml:space="preserve">
          <source>Note that multiple &quot;front-ends&quot; can latch into this debugging API simultaneously. This is intended to facilitate things like debugging with a command line and GUI at the same time, debugging debuggers etc. [Sounds nice, but this needs some serious support -- GSAR]</source>
          <target state="translated">Обратите внимание,что несколько &quot;фронт-ендов&quot; могут одновременно подключаться к этому отладочному API.Это призвано облегчить такие вещи,как отладка с помощью командной строки и графического интерфейса одновременно,отладка отладчиков и т.д.[Звучит неплохо,но это требует серьезной поддержки --GSAR].</target>
        </trans-unit>
        <trans-unit id="e6f8eb704c4d9544e078aafe993c9c4db8549a7e" translate="yes" xml:space="preserve">
          <source>Note that neither the &lt;b&gt;-w&lt;/b&gt; flag or the &lt;code&gt;$^W&lt;/code&gt; can be used to disable/enable default warnings. They are still mandatory in this case.</source>
          <target state="translated">Обратите внимание, что ни флаг &lt;b&gt;-w,&lt;/b&gt; ни &lt;code&gt;$^W&lt;/code&gt; нельзя использовать для отключения / включения предупреждений по умолчанию. В этом случае они по-прежнему обязательны.</target>
        </trans-unit>
        <trans-unit id="1452a217985729ac34f931918ed05a2f231bb7c5" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;siginfo&lt;/code&gt; values make sense simultaneously (some are valid only for certain signals, for example), and not all values make sense from Perl perspective, you should to consult your system's &lt;code&gt;sigaction&lt;/code&gt; and possibly also &lt;code&gt;siginfo&lt;/code&gt; documentation.</source>
          <target state="translated">Обратите внимание, что не все значения &lt;code&gt;siginfo&lt;/code&gt; имеют смысл одновременно (например, некоторые из них действительны только для определенных сигналов), и не все значения имеют смысл с точки зрения Perl, вам следует обратиться к &lt;code&gt;sigaction&lt;/code&gt; вашей системы и, возможно, также &lt;code&gt;siginfo&lt;/code&gt; документации siginfo .</target>
        </trans-unit>
        <trans-unit id="7821dfbc405ad5ec367d208589dca3baa4ef11c2" translate="yes" xml:space="preserve">
          <source>Note that not all attributes are supported by all terminal types, and some terminals may not support any of these sequences. Dark and faint, italic, blink, and concealed in particular are frequently not implemented.</source>
          <target state="translated">Обратите внимание,что не все атрибуты поддерживаются всеми типами терминалов,и некоторые терминалы могут не поддерживать ни одну из этих последовательностей.Часто не реализованы темные и слабые,курсив,мигание и,в частности,скрытые последовательности.</target>
        </trans-unit>
        <trans-unit id="dd77ba7655fe65f19331164b0a905a5ad5a97693" translate="yes" xml:space="preserve">
          <source>Note that not all displays are ISO 6429-compliant, or even X3.64-compliant (or are even attempting to be so). This module will not work as expected on displays that do not honor these escape sequences, such as cmd.exe, 4nt.exe, and command.com under either Windows NT or Windows 2000. They may just be ignored, or they may display as an ESC character followed by some apparent garbage.</source>
          <target state="translated">Обратите внимание,что не все дисплеи соответствуют стандарту ISO 6429 или даже X3.64 (или даже пытаются им соответствовать).Этот модуль не будет работать так,как ожидалось,на дисплеях,которые не соблюдают эти экранирующие последовательности,такие как cmd.exe,4nt.exe и command.com ни под Windows NT,ни под Windows 2000.Их можно просто проигнорировать или отобразить в виде ESC символа,за которым может следовать некоторый явный мусор.</target>
        </trans-unit>
        <trans-unit id="9d7626cfa2c8cb10194e8906a42cfb46307be1b7" translate="yes" xml:space="preserve">
          <source>Note that not all features of Perl are available under these environments. This depends on the features the</source>
          <target state="translated">Обратите внимание,что не все функции Perl доступны в этих средах.Это зависит от возможностей</target>
        </trans-unit>
        <trans-unit id="6d4d9996a72da721566e95c9b8f64cec116b411b" translate="yes" xml:space="preserve">
          <source>Note that not all incompatibilities are found.</source>
          <target state="translated">Обратите внимание,что не все несовместимости найдены.</target>
        </trans-unit>
        <trans-unit id="e354090ffbf1edbb380e0fa597ae3be4af6cb16d" translate="yes" xml:space="preserve">
          <source>Note that not all modules will work with on all platforms. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for more information on portability issues. Read the documentation to see if the module will work on your system. There are basically three categories of modules that will not work &quot;out of the box&quot; with all platforms (with some possibility of overlap):</source>
          <target state="translated">Обратите внимание, что не все модули будут работать на всех платформах. См. &lt;a href=&quot;perlport&quot;&gt;Perlport&lt;/a&gt; для получения дополнительной информации по вопросам переносимости. Прочтите документацию, чтобы узнать, будет ли модуль работать в вашей системе. В основном есть три категории модулей, которые не будут работать &amp;laquo;из коробки&amp;raquo; со всеми платформами (с некоторой вероятностью перекрытия):</target>
        </trans-unit>
        <trans-unit id="8d15a25a2ad944379a4980717687047ae9148ec3" translate="yes" xml:space="preserve">
          <source>Note that not all of the extensions available from CPAN may work in the Windows environment; you should check the information at &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt; before investing too much effort into porting modules that don't readily build.</source>
          <target state="translated">Обратите внимание, что не все расширения, доступные в CPAN, могут работать в среде Windows; вам следует проверить информацию на &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/,&lt;/a&gt; прежде чем вкладывать слишком много усилий в портирование модулей, которые нелегко собрать.</target>
        </trans-unit>
        <trans-unit id="814895e1fc7075770faad339ecd10e73c24fbc5f" translate="yes" xml:space="preserve">
          <source>Note that numf is called by quant for stringifying all quantifying numbers.</source>
          <target state="translated">Обратите внимание,что число вызывается квантом для строки всех количественных чисел.</target>
        </trans-unit>
        <trans-unit id="f0564c5fce02fbef6630b978932f6aa1e763b70b" translate="yes" xml:space="preserve">
          <source>Note that older Pod formatters might not recognize octal or hex numeric escapes, and that many formatters cannot reliably render characters above 255. (Some formatters may even have to use compromised renderings of Latin-1/CP-1252 characters, like rendering &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; as just a plain &quot;e&quot;.)</source>
          <target state="translated">Обратите внимание, что старые программы форматирования Pod могут не распознавать восьмеричные или шестнадцатеричные числовые escape-последовательности, и что многие программы форматирования не могут надежно отображать символы выше 255. (Некоторым средствам форматирования, возможно, даже придется использовать скомпрометированное отображение символов Latin-1 / CP-1252, например, отображение &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; как просто &quot;е&quot;.)</target>
        </trans-unit>
        <trans-unit id="4fe6034079ad6a013e5f8b58c3a64f050566c116" translate="yes" xml:space="preserve">
          <source>Note that on Windows, address space allocation granularity is 64 KB, therefore, setting the stack smaller than that on Win32 Perl will not save any more memory.</source>
          <target state="translated">Обратите внимание,что в Windows гранулярность распределения адресного пространства составляет 64 КБ,поэтому установка стека меньшего размера,чем в Win32 Perl,не сэкономит больше памяти.</target>
        </trans-unit>
        <trans-unit id="9b131d252a3bfc8b5c8ad8d09c7187e733df7c40" translate="yes" xml:space="preserve">
          <source>Note that on input (string to number) Perl accepts &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; in many forms. Case is ignored, and the Win32-specific forms like &lt;code&gt;1.#INF&lt;/code&gt; are understood, but on output the values are normalized to &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что при вводе (от строки к числу) Perl принимает &lt;code&gt;Inf&lt;/code&gt; и &lt;code&gt;NaN&lt;/code&gt; во многих формах. Регистр игнорируется, и специфичные для Win32 формы, такие как &lt;code&gt;1.#INF&lt;/code&gt; , понимаются, но на выходе значения нормализуются до &lt;code&gt;Inf&lt;/code&gt; и &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb6ba392df3d7fde91ed08ef1f5b7c759eb9d39f" translate="yes" xml:space="preserve">
          <source>Note that on some systems, a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped. See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details, and for other examples.</source>
          <target state="translated">Обратите внимание, что в некоторых системах возвращаемое значение &lt;code&gt;-1&lt;/code&gt; может означать, что дочерние процессы выполняются автоматически. См. Подробности в &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; и другие примеры.</target>
        </trans-unit>
        <trans-unit id="abc04d7473c212695d1b705a8da3b88080d0bbab" translate="yes" xml:space="preserve">
          <source>Note that on some systems, a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details, and for other examples.</source>
          <target state="translated">Обратите внимание, что в некоторых системах возвращаемое значение &lt;code&gt;-1&lt;/code&gt; может означать, что дочерние процессы выполняются автоматически. См. Подробности в &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; и другие примеры.</target>
        </trans-unit>
        <trans-unit id="baef8826a89d43d1f8e9e1ff1d1484160a339674" translate="yes" xml:space="preserve">
          <source>Note that only localized variable changes are undone. Other side effects of code expression execution are permanent. Thus</source>
          <target state="translated">Обратите внимание,что отменяются только локализованные изменения переменных.Другие побочные эффекты от выполнения выражений кода являются постоянными.Таким образом,</target>
        </trans-unit>
        <trans-unit id="9e8b3ca63f560a2fa0e18c2ef188ef76edc6e881" translate="yes" xml:space="preserve">
          <source>Note that only perl can truly parse Perl, so all such CASE tools fall somewhat short of the mark, especially if you don't program your Perl as a C programmer might.</source>
          <target state="translated">Обратите внимание,что только Perl может по-настоящему разобрать,так что все подобные инструменты CASE несколько не подходят,особенно если вы не программируете свой Perl,как программист на Си.</target>
        </trans-unit>
        <trans-unit id="32ee21a94e6bacfd587283dcf64796ed246e6431" translate="yes" xml:space="preserve">
          <source>Note that op_next is not manipulated, and nodes are not freed; that is the responsibility of the caller. It also won't create a new list op for an empty list etc; use higher-level functions like op_append_elem() for that.</source>
          <target state="translated">Обратите внимание,что op_next не манипулируется и узлы не освобождаются;за это отвечает вызывающий абонент.Он также не будет создавать новый список для пустого списка и т.д.;используйте для этого функции более высокого уровня,такие как op_append_elem().</target>
        </trans-unit>
        <trans-unit id="54c807dda3550fe223a1b1c55cd9bed9ee48d31f" translate="yes" xml:space="preserve">
          <source>Note that pad_findlex() is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon protoypes have to store in xlow the index into the parent pad.</source>
          <target state="translated">Обратите внимание,что pad_findlex()является рекурсивной функцией;она возвращает вверх по цепочке CV,затем возвращается вниз,добавляя поддельные записи по ходу работы.Это должно быть так,потому что поддельные имена в анонных протоипах должны храниться в xlow индекса в родительском блоке.</target>
        </trans-unit>
        <trans-unit id="131b045dcad1d95b29a85c93d3a6715d69d24db9" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , rather than as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; rather than as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что скобки необходимы, когда вы перевариваете все, что не является простой переменной. Это потому, что &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; интерпретируется как &lt;code&gt;(&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , а не как &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; вы могли ожидать. Аналогично, &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; интерпретируется как &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; а не как &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="346dbcf702d3c4fdb72e5c159c8678dc946b771c" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , rather than as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; rather than as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что скобки необходимы, когда вы перевариваете все, что не является простой переменной. Это потому, что &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; интерпретируется как &lt;code&gt;(&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , а не как &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; вы могли ожидать. Аналогично, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; интерпретируется как &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; а не как &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61028061478cb52a55b53cfd7830a40515024150" translate="yes" xml:space="preserve">
          <source>Note that parts of this code were derived from &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; with the permission of Adam Kennedy.</source>
          <target state="translated">Обратите внимание, что части этого кода были получены из &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt; с разрешения Адама Кеннеди.</target>
        </trans-unit>
        <trans-unit id="b192f3ab8b3b79b49c3da2be5c05a7696156013b" translate="yes" xml:space="preserve">
          <source>Note that pod translators should look at only paragraphs beginning with a pod directive (it makes parsing easier), whereas the compiler actually knows to look for pod escapes even in the middle of a paragraph. This means that the following secret stuff will be ignored by both the compiler and the translators.</source>
          <target state="translated">Обратите внимание,что трансляторы pod должны смотреть только на параграфы,начинающиеся с директивы pod (это облегчает синтаксический разбор),в то время как компилятор на самом деле знает,что нужно искать экранирования pod даже в середине параграфа.Это означает,что следующая секретная информация будет проигнорирована и компилятором,и переводчиками.</target>
        </trans-unit>
        <trans-unit id="ff72d3ac5b8dd647a96a960672acd7ebcc2f3ccc" translate="yes" xml:space="preserve">
          <source>Note that reports about bugs in old versions of Perl, especially those which indicate you haven't also tested the current stable release of Perl, are likely to receive less attention from the volunteers who build and maintain Perl than reports about bugs in the current release.</source>
          <target state="translated">Обратите внимание,что сообщения об ошибках в старых версиях Perl,особенно те,которые указывают на то,что вы не протестировали текущий стабильный релиз Perl,скорее всего,получат меньше внимания со стороны добровольцев,которые собирают и поддерживают Perl,чем сообщения об ошибках в текущем релизе.</target>
        </trans-unit>
        <trans-unit id="c75bcf48cfe25108045a83673fe9bf46dbdb6cb7" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">Обратите внимание, что обращение массива к самому себе (как в &lt;code&gt;@a = &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) по возможности сохраняет несуществующие элементы; т.е. для немагических массивов или для связанных массивов с методами &lt;code&gt;EXISTS&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3279ef396cd3fe9ed1f5c93958f688b3a02be9e7" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = &lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">Обратите внимание, что обращение массива к самому себе (как в &lt;code&gt;@a = &lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) по возможности сохраняет несуществующие элементы; т.е. для немагических массивов или для связанных массивов с методами &lt;code&gt;EXISTS&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0bebc4223d6e9d86efc4ab961e85c3b37f4d12a" translate="yes" xml:space="preserve">
          <source>Note that rewinddir() has a similar limitation on Windows and will not force readdir() to read the directory again either. Only a newly opened directory handle will reflect changes to the directory.</source>
          <target state="translated">Обратите внимание,что rewinddir()имеет аналогичное ограничение на Windows и не будет заставлять readdir()читать каталог снова.Только недавно открытый дескриптор каталога будет отражать изменения в каталоге.</target>
        </trans-unit>
        <trans-unit id="ac3e7d8ec9774f1fc514c0a850fb3669a2dac43e" translate="yes" xml:space="preserve">
          <source>Note that section names might contain markup. I.e., if a section starts with:</source>
          <target state="translated">Обратите внимание,что названия разделов могут содержать разметку.Т.е.,если секция начинается с:</target>
        </trans-unit>
        <trans-unit id="5cd547b6f9a21623648f43fd2d180495971977d8" translate="yes" xml:space="preserve">
          <source>Note that setting precision and accuracy at the same time is not possible.</source>
          <target state="translated">Обратите внимание,что одновременная настройка точности и точности невозможна.</target>
        </trans-unit>
        <trans-unit id="2489b5c14780b59ec0536b9418bfecf1ef230d00" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.10.0 a // can also be the</source>
          <target state="translated">Обратите внимание,что,поскольку Perl 5.10.0 a //может быть также и</target>
        </trans-unit>
        <trans-unit id="f4f6bc0bb0b72e537a474e9d5b08d81afb1f9c79" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.8.1 the single-number v-strings (like &lt;code&gt;v65&lt;/code&gt; ) are not v-strings before the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (which is usually used to separate a hash key from a hash value); instead they are interpreted as literal strings ('v65'). They were v-strings from Perl 5.6.0 to Perl 5.8.0, but that caused more confusion and breakage than good. Multi-number v-strings like &lt;code&gt;v65.66&lt;/code&gt; and &lt;code&gt;65.66.67&lt;/code&gt; continue to be v-strings always.</source>
          <target state="translated">Обратите внимание, что начиная с Perl 5.8.1 v-строки с одним числом (например, &lt;code&gt;v65&lt;/code&gt; ) не являются v-строками перед оператором &lt;code&gt;=&amp;gt;&lt;/code&gt; (который обычно используется для отделения хеш-ключа от хеш-значения); вместо этого они интерпретируются как буквальные строки ('v65'). Это были v-строки от Perl 5.6.0 до Perl 5.8.0, но это вызвало больше путаницы и поломок, чем пользы. V-строки с несколькими &lt;code&gt;v65.66&lt;/code&gt; такие как v65.66 и &lt;code&gt;65.66.67&lt;/code&gt; ,всегда остаются v-строками.</target>
        </trans-unit>
        <trans-unit id="19ef149a186b458f11686fd9d31157ce1f5a0ebd" translate="yes" xml:space="preserve">
          <source>Note that since Perl version 5.16 this function has been a no-op, but this might change in a future release.</source>
          <target state="translated">Обратите внимание,что с версии 5.16 для Perl эта функция не работает,но в следующем релизе она может измениться.</target>
        </trans-unit>
        <trans-unit id="6c5b88d706c28965b53567c8427b594ad63f74e3" translate="yes" xml:space="preserve">
          <source>Note that skipping white space applies only to the interior of this construct. There must not be any space between any of the characters that form the initial &lt;code&gt;(?[&lt;/code&gt; . Nor may there be space between the closing &lt;code&gt;])&lt;/code&gt; characters.</source>
          <target state="translated">Обратите внимание, что пропуск пустого пространства применяется только к внутренней части этой конструкции. Не должно быть пробелов между символами, образующими начальные &lt;code&gt;(?[&lt;/code&gt; . Также не может быть пробелов между закрывающими &lt;code&gt;])&lt;/code&gt; символами.</target>
        </trans-unit>
        <trans-unit id="1c060aa4bbf33c5b1f0215edf2ae5f526f55cd18" translate="yes" xml:space="preserve">
          <source>Note that some URLs have hexadecimal ASCII code points in them in an attempt to overcome character or protocol limitation issues. For example the tilde character is not on every keyboard hence a URL of the form:</source>
          <target state="translated">Обратите внимание,что некоторые URL-адреса имеют шестнадцатеричный ASCII-код в попытке преодолеть проблемы с ограничением символов или протоколов.Например,символ тильды находится не на каждой клавиатуре,поэтому URL формы:</target>
        </trans-unit>
        <trans-unit id="96757558cf943b3af9fec33e5de374cf8022a75a" translate="yes" xml:space="preserve">
          <source>Note that some types of arguments/return-values for functions may result in XSUB-declarations/typemap-entries which need hand-editing. Such may be objects which cannot be converted from/to a pointer (like &lt;code&gt;long long&lt;/code&gt; ), pointers to functions, or arrays. See also the section on &lt;a href=&quot;#LIMITATIONS-of--x&quot;&gt;LIMITATIONS of -x&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что некоторые типы аргументов / возвращаемых значений для функций могут привести к XSUB-объявлениям / записям typemap, которые требуют редактирования вручную. Такими могут быть объекты, которые нельзя преобразовать из / в указатель (например, &lt;code&gt;long long&lt;/code&gt; ), указатели на функции или массивы. См. Также раздел &lt;a href=&quot;#LIMITATIONS-of--x&quot;&gt;ОГРАНИЧЕНИЯ -x&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fcd18b02b9dc35274d6564c64032ca709a95c4f6" translate="yes" xml:space="preserve">
          <source>Note that spaces in the format argument to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; do not denote literal spaces. If you have space separated data, you may want &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Обратите внимание, что пробелы в аргументе формата для &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; не обозначают буквальные пробелы. Если у вас есть данные, разделенные пробелами, вы можете вместо этого &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2b6650d0cfdddfa7918a6366723469de7b3aca7" translate="yes" xml:space="preserve">
          <source>Note that splitting an EXPR that evaluates to the empty string always produces zero fields, regardless of the LIMIT specified.</source>
          <target state="translated">Обратите внимание,что разделение EXPR,который оценивает пустую строку,всегда приводит к появлению нулевых полей,независимо от указанного LIMIT.</target>
        </trans-unit>
        <trans-unit id="77e878278c2299b62e83869de869a2f9253eaf40" translate="yes" xml:space="preserve">
          <source>Note that starting from Perl 5.7.2 (and consequently 5.8.0) and AIX 4.3 or newer Perl uses the AIX native dynamic loading interface in the so called runtime linking mode instead of the emulated interface that was used in Perl releases 5.6.1 and earlier or, for AIX releases 4.2 and earlier. This change does break backward compatibility with compiled modules from earlier Perl releases. The change was made to make Perl more compliant with other applications like Apache/mod_perl which are using the AIX native interface. This change also enables the use of C++ code with static constructors and destructors in Perl extensions, which was not possible using the emulated interface.</source>
          <target state="translated">Обратите внимание,что начиная с версии Perl 5.7.2 (и,следовательно,5.8.0)и AIX 4.3 или более новой версии Perl использует собственный интерфейс динамической загрузки AIX в так называемом режиме runtime link вместо эмулированного интерфейса,который использовался в версии Perl 5.6.1 и более ранней версии или,для версии AIX 4.2 и более ранней версии.Это изменение нарушает обратную совместимость с скомпилированными модулями из более ранних версий Perl.Изменение было сделано для того,чтобы сделать Perl более совместимым с другими приложениями,такими как Apache/mod_perl,использующими родной интерфейс AIX.Это изменение также позволяет использовать C++код со статическими конструкторами и деструкторами в расширениях Perl,что было невозможно при использовании эмулируемого интерфейса.</target>
        </trans-unit>
        <trans-unit id="e00838249311f81e98bfc06fb08536fb7ec9966f" translate="yes" xml:space="preserve">
          <source>Note that starting in Unicode 6.1, many of the block names have shorter synonyms. These are always given in the new style.</source>
          <target state="translated">Обратите внимание,что,начиная с Юникода 6.1,многие названия блоков имеют более короткие синонимы.Они всегда приводятся в новом стиле.</target>
        </trans-unit>
        <trans-unit id="2ad7004d8cad106c4c2f0c2a7d60864d3c8b1736" translate="yes" xml:space="preserve">
          <source>Note that strtol() and strtoul() may be disguised as Strtol(), Strtoul(), Atol(), Atoul(). Avoid those, too.</source>
          <target state="translated">Обратите внимание,что strtol()и strtoul()могут быть замаскированы под Strtol(),Strtoul(),Atol(),Atoul().Избегайте их тоже.</target>
        </trans-unit>
        <trans-unit id="643a90b7cc572aa8f24a2a4aeec18309319e74d7" translate="yes" xml:space="preserve">
          <source>Note that the</source>
          <target state="translated">Обратите внимание,что</target>
        </trans-unit>
        <trans-unit id="4a13e460ac63aeef5172c4e67fabd8f175a93e35" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%b&lt;/code&gt; , the short forms of the day of the week and the month of the year, may not necessarily be three characters wide.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;%a&lt;/code&gt; и &lt;code&gt;%b&lt;/code&gt; , краткие формы дня недели и месяца года, не обязательно могут состоять из трех символов.</target>
        </trans-unit>
        <trans-unit id="c990c52d20bce03cc1931306413c2445b6287df4" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;-L&lt;/code&gt; and &lt;code&gt;-l&lt;/code&gt; prefixes are &lt;b&gt;not required&lt;/b&gt;, but authors who wish their extensions to be portable to Unix or OS/2 should use the prefixes, since the Unix-OS/2 version of ext() requires them.</source>
          <target state="translated">Обратите внимание, что префиксы &lt;code&gt;-L&lt;/code&gt; и &lt;code&gt;-l&lt;/code&gt; &lt;b&gt;не требуются&lt;/b&gt; , но авторы, которые хотят, чтобы их расширения были переносимы в Unix или OS / 2, должны использовать префиксы, поскольку они требуются для версии ext () для Unix-OS / 2.</target>
        </trans-unit>
        <trans-unit id="1fb35d0c6e79a4294b3591fc47c05224b1801d3d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; FILEHANDLE&lt;/code&gt; form is generally portable.</source>
          <target state="translated">Обратите внимание, что форма &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; FILEHANDLE&lt;/code&gt; обычно переносима.</target>
        </trans-unit>
        <trans-unit id="9806508e6a2529870cc2037f1710d22cb6ace5d5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;XSOPT&lt;/code&gt; MakeMaker option may be used to add these options to any makefiles generated by MakeMaker.</source>
          <target state="translated">Обратите внимание, что параметр &lt;code&gt;XSOPT&lt;/code&gt; MakeMaker может использоваться для добавления этих параметров в любые файлы сборки, созданные MakeMaker.</target>
        </trans-unit>
        <trans-unit id="86802402b451982daee5eec807ff6ea5529eaefd" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; , and &lt;code&gt;u&lt;/code&gt; modifiers are special in that they can only be enabled, not disabled, and the &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;u&lt;/code&gt; modifiers are mutually exclusive: specifying one de-specifies the others, and a maximum of one (or two &lt;code&gt;a&lt;/code&gt; 's) may appear in the construct. Thus, for example, &lt;code&gt;(?-p)&lt;/code&gt; will warn when compiled under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ; &lt;code&gt;(?-d:...)&lt;/code&gt; and &lt;code&gt;(?dl:...)&lt;/code&gt; are fatal errors.</source>
          <target state="translated">Обратите внимание, что модификаторы &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; и &lt;code&gt;u&lt;/code&gt; являются особенными в том смысле, что они могут быть только включены, но не отключены, а модификаторы &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; и &lt;code&gt;u&lt;/code&gt; являются взаимоисключающими: указание одного отменяет определение других, и максимум один (или два &lt;code&gt;a&lt;/code&gt; &amp;laquo;) может появиться в конструкции. Таким образом, например, &lt;code&gt;(?-p)&lt;/code&gt; будет предупреждать при компиляции с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использовании&lt;/a&gt; ; &lt;code&gt;(?-d:...)&lt;/code&gt; и &lt;code&gt;(?dl:...)&lt;/code&gt; являются фатальными ошибками.</target>
        </trans-unit>
        <trans-unit id="b75233b2e52c1643f13c545ab5448e1216afde19" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the $ctx object is automatically &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; and can be used to calculate another digest value. Call $ctx-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">Обратите внимание, что операция &lt;code&gt;digest&lt;/code&gt; является разрушительной операцией с однократным чтением. После выполнения объект $ ctx автоматически &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; и может использоваться для вычисления другого значения дайджеста. Вызовите $ ctx-&amp;gt; clone-&amp;gt; digest, если вы хотите вычислить дайджест без сброса состояния дайджеста.</target>
        </trans-unit>
        <trans-unit id="2e408b4bb22ad308085742938ea428bf4e618d3e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the &lt;code&gt;Digest::MD5&lt;/code&gt; object is automatically &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; and can be used to calculate another digest value. Call $md5-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">Обратите внимание, что операция &lt;code&gt;digest&lt;/code&gt; - это фактически разрушительная операция с однократным чтением. После выполнения объект &lt;code&gt;Digest::MD5&lt;/code&gt; автоматически &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; и может использоваться для вычисления другого значения дайджеста. Вызовите $ md5-&amp;gt; clone-&amp;gt; digest, если вы хотите вычислить дайджест без сброса состояния дайджеста.</target>
        </trans-unit>
        <trans-unit id="d24eeff32ed6f4a19c0009f5d0e023c636e7a94e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;to&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; macros in</source>
          <target state="translated">Обратите внимание, что макросы &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; и &lt;code&gt;to&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="a2d5c53bebb44c78258b20f3af06f6f909ee7256" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;use Pod::Simple::Debug (\$x, &lt;i&gt;somenum&lt;/i&gt;)&lt;/code&gt; mode will make Pod::Simple (et al) run rather slower, since &amp;amp;Pod::Simple::DEBUG won't be a constant sub anymore, and so Pod::Simple (et al) won't compile with constant-folding.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;use Pod::Simple::Debug (\$x, &lt;i&gt;somenum&lt;/i&gt;)&lt;/code&gt; режима Pod :: Simple :: Debug (\ $ x, &lt;i&gt;somenum&lt;/i&gt; ) приведет к тому, что Pod :: Simple (и др.) Будет работать медленнее, поскольку &amp;amp; Pod :: Simple :: DEBUG больше не будет константной подпрограммой, и поэтому Pod :: Simple (и др.) не будет компилироваться с свертыванием констант.</target>
        </trans-unit>
        <trans-unit id="9551d033cb29a27fd5d6bf1fe4833c6cf7eaf2fe" translate="yes" xml:space="preserve">
          <source>Note that the CPU seconds is the &lt;b&gt;minimum&lt;/b&gt; time: CPU scheduling and other operating system factors may complicate the attempt so that a little bit more time is spent. The benchmark output will, however, also tell the number of &lt;code&gt;$code&lt;/code&gt; runs/second, which should be a more interesting number than the actually spent seconds.</source>
          <target state="translated">Обратите внимание, что секунды ЦП - это &lt;b&gt;минимальное&lt;/b&gt; время: планирование ЦП и другие факторы операционной системы могут усложнить попытку, так что будет потрачено немного больше времени. Однако результаты теста также покажут количество запусков &lt;code&gt;$code&lt;/code&gt; секунду, что должно быть более интересным числом, чем фактически потраченные секунды.</target>
        </trans-unit>
        <trans-unit id="28d680a1e0dab71002ed6eded256a885c900ba34" translate="yes" xml:space="preserve">
          <source>Note that the EXPR can be arbitrarily complicated as long as the final operation is a hash or array key lookup or subroutine name:</source>
          <target state="translated">Обратите внимание,что EXPR может быть произвольно сложным,если конечной операцией является поиск хэша или массива ключей или имя подпрограмм:</target>
        </trans-unit>
        <trans-unit id="afc125ebc0373a09cca375f9b07fbcd59b2c703e" translate="yes" xml:space="preserve">
          <source>Note that the G_KEEPERR flag does not propagate into inner evals; these may still set &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что флаг G_KEEPERR не распространяется на внутренние вычисления; они все еще могут установить &lt;code&gt;$@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f14f1b3c2ecac55af54ec64471c279be4e1559f" translate="yes" xml:space="preserve">
          <source>Note that the MAP_TARGET value *must* have the &quot;.exe&quot; extension or you will not create a &quot;perl.exe&quot; to replace the one in &lt;code&gt;($DJDIR)/bin&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что значение MAP_TARGET * должно * иметь расширение &amp;laquo;.exe&amp;raquo;, иначе вы не создадите &amp;laquo;perl.exe&amp;raquo; вместо того, который находится в &lt;code&gt;($DJDIR)/bin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54136d6700549a5defbb3ceccf1ce74752ff9160" translate="yes" xml:space="preserve">
          <source>Note that the MD5 algorithm is not as strong as it used to be. It has since 2005 been easy to generate different messages that produce the same MD5 digest. It still seems hard to generate messages that produce a given digest, but it is probably wise to move to stronger algorithms for applications that depend on the digest to uniquely identify a message.</source>
          <target state="translated">Обратите внимание,что алгоритм MD5 не так силен,как раньше.С 2005 года легко генерировать различные сообщения,которые выдают один и тот же дайджест MD5.Все еще кажется трудным генерировать сообщения,которые производят определенный дайджест,но,вероятно,разумно перейти к более сильным алгоритмам для приложений,которые зависят от дайджеста,чтобы однозначно идентифицировать сообщение.</target>
        </trans-unit>
        <trans-unit id="09f5d2315ce8efb902a4b01848317f36e6d46300" translate="yes" xml:space="preserve">
          <source>Note that the PerlIO equivalents of &lt;code&gt;fread&lt;/code&gt; and &lt;code&gt;fwrite&lt;/code&gt; are slightly different from their C library counterparts:</source>
          <target state="translated">Обратите внимание, что эквиваленты PerlIO для &lt;code&gt;fread&lt;/code&gt; и &lt;code&gt;fwrite&lt;/code&gt; немного отличаются от своих аналогов из библиотеки C:</target>
        </trans-unit>
        <trans-unit id="c898fd225c811d3b33264eb9a5dd3fac5a9a201b" translate="yes" xml:space="preserve">
          <source>Note that the Symbian filesystem is very picky: it strongly prefers the \ instead of the /.</source>
          <target state="translated">Обратите внимание,что файловая система Symbian очень привередлива:она сильно предпочитает \,а не /.</target>
        </trans-unit>
        <trans-unit id="f053db6da6e575d7b066a2e19e4c949dfd7c2c0f" translate="yes" xml:space="preserve">
          <source>Note that the above implementation shuffles an array in place, unlike the &lt;code&gt;List::Util::shuffle()&lt;/code&gt; which takes a list and returns a new shuffled list.</source>
          <target state="translated">Обратите внимание, что вышеупомянутая реализация перемешивает массив на месте, в отличие от &lt;code&gt;List::Util::shuffle()&lt;/code&gt; который принимает список и возвращает новый перемешанный список.</target>
        </trans-unit>
        <trans-unit id="b065a3ad25b4fc5b70a8b34ad20e23ed1b7c3cb3" translate="yes" xml:space="preserve">
          <source>Note that the above two invocations will be very verbose as reachable memory and leak-checking is enabled by default. If you want to just see pure errors, try:</source>
          <target state="translated">Обратите внимание,что два вышеуказанных вызова будут очень многословными,так как по умолчанию включена доступная память и проверка на утечку.Если вы хотите увидеть только чистые ошибки,попробуйте:</target>
        </trans-unit>
        <trans-unit id="64532abb5f09f86d92c621e51038db0bcc100d92" translate="yes" xml:space="preserve">
          <source>Note that the actual meanings of the various fields are not that well standardized, do not expect any great portability. The &lt;code&gt;$sysname&lt;/code&gt; might be the name of the operating system, the &lt;code&gt;$nodename&lt;/code&gt; might be the name of the host, the &lt;code&gt;$release&lt;/code&gt; might be the (major) release number of the operating system, the &lt;code&gt;$version&lt;/code&gt; might be the (minor) release number of the operating system, and the &lt;code&gt;$machine&lt;/code&gt; might be a hardware identifier. Maybe.</source>
          <target state="translated">Обратите внимание, что фактические значения различных полей не так хорошо стандартизированы, не ожидайте большой переносимости. &lt;code&gt;$sysname&lt;/code&gt; может быть названием операционной системы, то &lt;code&gt;$nodename&lt;/code&gt; может быть именем хоста, то &lt;code&gt;$release&lt;/code&gt; может быть (основной) номер версии операционной системы, то &lt;code&gt;$version&lt;/code&gt; может быть (второстепенный) номер версии операционной системы, а &lt;code&gt;$machine&lt;/code&gt; может быть идентификатором оборудования. Может быть.</target>
        </trans-unit>
        <trans-unit id="f2424ff844845a48b6b1b2cd57585ba63cec58ff" translate="yes" xml:space="preserve">
          <source>Note that the alias EU_ALWAYS_COPY will be supported if EU_INSTALL_ALWAYS_COPY is not defined until at least the 1.50 release. Please ensure you use the correct EU_INSTALL_ALWAYS_COPY.</source>
          <target state="translated">Обратите внимание,что псевдоним EU_ALWAYS будет поддерживаться,если EU_INSTALL_ALWAYS не будет определен,по крайней мере,до версии 1.50.Пожалуйста,убедитесь,что вы используете правильный псевдоним EU_INSTALL_ALWAYS.</target>
        </trans-unit>
        <trans-unit id="26b36cb20c7dae889459ec2f6f9db24992abdb43" translate="yes" xml:space="preserve">
          <source>Note that the assignment &lt;code&gt;$\ = $/&lt;/code&gt; is done when the switch is processed, so the input record separator can be different than the output record separator if the &lt;b&gt;-l&lt;/b&gt; switch is followed by a &lt;b&gt;-0&lt;/b&gt; switch:</source>
          <target state="translated">Обратите внимание, что присвоение &lt;code&gt;$\ = $/&lt;/code&gt; выполняется при обработке переключателя, поэтому разделитель входной записи может отличаться от разделителя выходной записи, если за переключателем &lt;b&gt;-l&lt;/b&gt; следует переключатель &lt;b&gt;-0&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="c00bf502c45bde6ba2060e9d911a339007fd5405" translate="yes" xml:space="preserve">
          <source>Note that the backslash itself is special; if you want to match a backslash, you have to escape the backslash with a backslash: &lt;code&gt;/\\/&lt;/code&gt; matches a single backslash.</source>
          <target state="translated">Обратите внимание, что обратная косая черта является особенной; если вы хотите сопоставить обратную косую черту, вы должны экранировать обратную косую черту с помощью обратной косой черты: &lt;code&gt;/\\/&lt;/code&gt; соответствует одной обратной косой черте.</target>
        </trans-unit>
        <trans-unit id="f6ebed0705c42d69729c70593af8e15098cbc1e9" translate="yes" xml:space="preserve">
          <source>Note that the base64 encoded string returned is not padded to be a multiple of 4 bytes long. If you want interoperability with other base64 encoded md5 digests you might want to append the redundant string &quot;==&quot; to the result.</source>
          <target state="translated">Обратите внимание,что возвращаемая строка в кодировке base64 не имеет длины,кратной 4 байтам.Если вам нужна функциональная совместимость с другими md5-дайджестами в кодировке base64,то к результату можно добавить избыточную строку &quot;==&quot;.</target>
        </trans-unit>
        <trans-unit id="772992efab68f2396f54e27fdd4bb3868704a8b7" translate="yes" xml:space="preserve">
          <source>Note that the braces are required in Perl, even if you've only got one line in the block. However, there is a clever way of making your one-line conditional blocks more English like:</source>
          <target state="translated">Обратите внимание,что фигурные скобки требуются в Perl,даже если в блоке только одна строчка.Тем не менее,есть умный способ сделать ваши однострочные условные блоки более похожими на английские:</target>
        </trans-unit>
        <trans-unit id="6f7f794be85b20ad885b31b3bd4e8712126125c7" translate="yes" xml:space="preserve">
          <source>Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL.</source>
          <target state="translated">Обратите внимание, что вызывающая сторона отвечает за соответствующее увеличение счетчика ссылок &lt;code&gt;val&lt;/code&gt; перед вызовом и уменьшение его, если функция вернула NULL.</target>
        </trans-unit>
        <trans-unit id="4f5d7bcf37a5b2a38715b73f67483220347ce0f3" translate="yes" xml:space="preserve">
          <source>Note that the code might be broken into multiple segments if there are nested formatting codes inside a &lt;code&gt;C&amp;lt;...&amp;gt;&lt;/code&gt; sequence. In between the calls to &lt;code&gt;handle_code&lt;/code&gt; other markup tags might have been emitted in that case. The same is true for verbatim sections if the &lt;code&gt;codes_in_verbatim&lt;/code&gt; option is turned on.</source>
          <target state="translated">Обратите внимание, что код может быть разбит на несколько сегментов, если внутри последовательности &lt;code&gt;C&amp;lt;...&amp;gt;&lt;/code&gt; есть вложенные коды форматирования . В этом случае между вызовами &lt;code&gt;handle_code&lt;/code&gt; могли быть сгенерированы другие теги разметки. То же верно и для дословных разделов, если &lt;code&gt;codes_in_verbatim&lt;/code&gt; опция code_in_verbatim .</target>
        </trans-unit>
        <trans-unit id="8cd0e4a20a7367cc4b5ead8187ea067b769ad671" translate="yes" xml:space="preserve">
          <source>Note that the effect is compile-time and immutable once defined. However, the subroutines are passed a single parameter, which is 0 if case-sensitive matching is in effect and non-zero if caseless matching is in effect. The subroutine may return different values depending on the value of the flag, and one set of values will immutably be in effect for all case-sensitive matches, and the other set for all case-insensitive matches.</source>
          <target state="translated">Обратите внимание,что эффект является компилируемым по времени и неизменяемым после его определения.Однако,подпрограммам передается единственный параметр,который равен 0,если действует case-чувствительное совпадение,и ненулевой,если действует бескорпусное совпадение.Подпрограмма может возвращать различные значения в зависимости от значения флага,и один набор значений будет неизменным для всех регистрочувствительных совпадений,а другой набор-для всех регистронечувствительных совпадений.</target>
        </trans-unit>
        <trans-unit id="83d0991fa33934053d27ec9e77b0dcc73eda0b3d" translate="yes" xml:space="preserve">
          <source>Note that the embedded single-quotes in the string don't help in this case, since they have not been specified as acceptable delimiters and are therefore treated as non-delimiter characters (and ignored).</source>
          <target state="translated">Обратите внимание,что встроенные одинарные кавычки в строке в данном случае не помогают,так как они не были указаны как допустимые разделители и поэтому рассматриваются как неделимитируемые символы (и игнорируются).</target>
        </trans-unit>
        <trans-unit id="1eb58ec9da82570c29bbbb5325581cb00b947ded" translate="yes" xml:space="preserve">
          <source>Note that the emulation built with lockf(3) doesn't provide shared locks, and it requires that FILEHANDLE be open with write intent. These are the semantics that lockf(3) implements. Most if not all systems implement lockf(3) in terms of fcntl(2) locking, though, so the differing semantics shouldn't bite too many people.</source>
          <target state="translated">Обратите внимание,что эмуляция,собранная с помощью lockf(3),не предоставляет разделяемых блокировок,и требует,чтобы FILEHANDLE была открыта с намерением записи.Это семантика,которую реализует lockf(3).Большинство,если не все системы,реализуют lockf(3)с точки зрения блокировки fcntl(2),так что различная семантика не должна увлекать слишком много людей.</target>
        </trans-unit>
        <trans-unit id="07238884ca9ae6e9d1b98c9eab9e8272e50d79b1" translate="yes" xml:space="preserve">
          <source>Note that the encoding itself is &lt;b&gt;not&lt;/b&gt; a formally valid language tag. Note also that you cannot, currently, go from an encoding back to a language tag that it's an encoding of.</source>
          <target state="translated">Обратите внимание, что сама кодировка &lt;b&gt;не&lt;/b&gt; является формально допустимым языковым тегом. Также обратите внимание, что в настоящее время вы не можете перейти от кодировки обратно к языковому тегу, кодировке которого она является.</target>
        </trans-unit>
        <trans-unit id="5a48ddc9bb68bd34263110aaa842399866ebadf6" translate="yes" xml:space="preserve">
          <source>Note that the expanded form represents the way perl handles such constructions internally -- this option actually turns off the reverse translation that B::Deparse usually does. On the other hand, note that &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; is not the same as &lt;code&gt;$x = $y&lt;/code&gt; : the former makes the value of $y into a string before doing the assignment.</source>
          <target state="translated">Обратите внимание, что развернутая форма представляет способ внутренней обработки таких конструкций Perl - эта опция фактически отключает обратное преобразование, которое обычно делает B :: Deparse. С другой стороны, обратите внимание, что &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; не то же самое, что &lt;code&gt;$x = $y&lt;/code&gt; : первый преобразует значение $ y в строку перед выполнением присваивания.</target>
        </trans-unit>
        <trans-unit id="ce6c91a770707b555d66e4a287e39136a3141726" translate="yes" xml:space="preserve">
          <source>Note that the extraction with the stored paths is still necessary (default with unzip, specify &lt;code&gt;-d&lt;/code&gt; to pkunzip). However, you need to know where to extract the files. You need also to manually change entries in</source>
          <target state="translated">Обратите внимание, что извлечение с сохраненными путями по-прежнему необходимо (по умолчанию с unzip, укажите &lt;code&gt;-d&lt;/code&gt; для pkunzip). Однако вам нужно знать, где извлечь файлы. Вам также необходимо вручную изменить записи в</target>
        </trans-unit>
        <trans-unit id="fd97b7e25cb09157d47ba2c7b978a7930b9606b8" translate="yes" xml:space="preserve">
          <source>Note that the fcntl(2) emulation of flock(3) requires that FILEHANDLE be open with read intent to use LOCK_SH and requires that it be open with write intent to use LOCK_EX.</source>
          <target state="translated">Обратите внимание,что fcntl(2)эмуляция flock(3)требует,чтобы FILEHANDLE была открыта с намерением чтения для использования LOCK_SH и требует,чтобы она была открыта с намерением записи для использования LOCK_EX.</target>
        </trans-unit>
        <trans-unit id="fe144eb2f290a0a193386ccafda07da2ebb33808" translate="yes" xml:space="preserve">
          <source>Note that the file will not be included twice under the same specified name.</source>
          <target state="translated">Обратите внимание,что файл не будет включен дважды под одним и тем же именем.</target>
        </trans-unit>
        <trans-unit id="7a13c6488a9b380a268109737c1af44124fc53ff" translate="yes" xml:space="preserve">
          <source>Note that the final string may be up to 7 chars longer than pvlim.</source>
          <target state="translated">Обратите внимание,что итоговая строка может быть до 7 символов длиннее,чем pvlim.</target>
        </trans-unit>
        <trans-unit id="772ece35cdf290101677cb798018640a9adccf19" translate="yes" xml:space="preserve">
          <source>Note that the first argument is required. The section number will be parsed from it, and if it's missing will default to 1. The second argument is currently ignored, as &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net&quot;&gt;man.he.net&lt;/a&gt; does not currently include linkable IDs or anchor names in its pages. Subclass to link to a different man page HTTP server.</source>
          <target state="translated">Обратите внимание, что первый аргумент является обязательным. Номер раздела будет извлечен из него, и если он отсутствует, по умолчанию будет равен 1. Второй аргумент в настоящее время игнорируется, так как &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net&quot;&gt;man.he.net в&lt;/a&gt; настоящее время не включает в себя связываемые идентификаторы или имена привязок на своих страницах. Подкласс для ссылки на другой HTTP-сервер справочной страницы.</target>
        </trans-unit>
        <trans-unit id="0926e8149e0f9908feb624f3205e6ac6e35159d1" translate="yes" xml:space="preserve">
          <source>Note that the first of the above returns a Time::Seconds object, so while examining the object will print the number of seconds (because of the overloading), you can also get the number of minutes, hours, days, weeks and years in that delta, using the Time::Seconds API.</source>
          <target state="translated">Обратите внимание,что первый из вышеперечисленных возвращает объект Time::Seconds,поэтому во время осмотра объекта будет выведено количество секунд (из-за перегрузки),вы также можете получить количество минут,часов,дней,недель и лет в этой дельте,используя API Time::Seconds.</target>
        </trans-unit>
        <trans-unit id="533bf74078da55d39eeb6299ea8805b9073e8050" translate="yes" xml:space="preserve">
          <source>Note that the general pattern here is that the accessor-methods read the attribute's value with &lt;code&gt;$value = $parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;&lt;/code&gt; and set the attribute's value with &lt;code&gt;$parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;(&lt;i&gt;newvalue&lt;/i&gt;)&lt;/code&gt;. For each accessor, I typically only mention one syntax or another, based on which I think you are actually most likely to use.</source>
          <target state="translated">Обратите внимание , что общая картина здесь является то , что аксессоры-метода чтения значения атрибута с &lt;code&gt;$value = $parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;&lt;/code&gt; и установить значение атрибута с &lt;code&gt;$parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;(&lt;i&gt;newvalue&lt;/i&gt;)&lt;/code&gt; . Для каждого средства доступа я обычно упоминаю только тот или иной синтаксис, исходя из которого, я думаю, вы, скорее всего, будете использовать его.</target>
        </trans-unit>
        <trans-unit id="9c62e8291c3969aab5799ff59674523f531fd071" translate="yes" xml:space="preserve">
          <source>Note that the global variable &lt;code&gt;$B::OP::does_parent&lt;/code&gt; is undefined on older perls that don't support the &lt;code&gt;parent&lt;/code&gt; method, is defined but false on perls that support the method but were built without &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; , and is true otherwise.</source>
          <target state="translated">Обратите внимание, что глобальная переменная &lt;code&gt;$B::OP::does_parent&lt;/code&gt; не определена в старых perl, которые не поддерживают &lt;code&gt;parent&lt;/code&gt; метод, определена, но ложна для perl, которые поддерживают метод, но были созданы без &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; , и истинна в противном случае.</target>
        </trans-unit>
        <trans-unit id="255f1a96146684091b1e9cb0690908a053fe1866" translate="yes" xml:space="preserve">
          <source>Note that the implementation of &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; in this module does not provide true random access to a compressed file/buffer. It works by uncompressing data from the current offset in the file/buffer until it reaches the uncompressed offset specified in the parameters to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;. For very small files this may be acceptable behaviour. For large files it may cause an unacceptable delay.</source>
          <target state="translated">Обратите внимание, что реализация &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; в этом модуле не обеспечивает истинный произвольный доступ к сжатому файлу / буферу. Он работает, распаковывая данные из текущего смещения в файле / буфере до тех пор, пока они не достигнут несжатого смещения, указанного в параметрах для &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; . Для очень маленьких файлов это может быть приемлемым поведением. Для больших файлов это может вызвать недопустимую задержку.</target>
        </trans-unit>
        <trans-unit id="f257e1d0eedfe176e0664704a0289bfea4406fc3" translate="yes" xml:space="preserve">
          <source>Note that the initializer for a nested class may be specified as an object of that class, or as a reference to a hash of initializers that are passed on to the nested struct's constructor.</source>
          <target state="translated">Заметим,что инициализатор для вложенного класса может быть указан как объект этого класса,так и как ссылка на хэш инициализаторов,которые передаются конструктору вложенной структуры.</target>
        </trans-unit>
        <trans-unit id="80804b39a5da75cc855890b4a2fe869234b33d17" translate="yes" xml:space="preserve">
          <source>Note that the interaction between alarms and sleeps is unspecified.</source>
          <target state="translated">Обратите внимание,что взаимодействие между сигналами тревоги и сном не определено.</target>
        </trans-unit>
        <trans-unit id="e8783b348067a3189a0f06125d399031ed3fee39" translate="yes" xml:space="preserve">
          <source>Note that the inversion lists returned by this function can possibly include non-Unicode code points, that is anything above 0x10FFFF. Unicode properties are not defined on such code points. You might wish to change the output to not include these. Simply add 0x110000 at the end of the non-empty returned list if it isn't already that value; and pop that value if it is; like:</source>
          <target state="translated">Обратите внимание,что возвращаемые этой функцией инверсионные списки могут содержать точки,не относящиеся к Unicode-коду,т.е.не имеющие значения выше 0x10FFFF.Свойства Юникода на таких точках кода не определены.Возможно,вы захотите изменить вывод,чтобы не включать их.Просто добавьте 0x110000 в конец непустого возвращаемого списка,если это еще не то значение;и всплывёт это значение,если оно есть;например:</target>
        </trans-unit>
        <trans-unit id="634311f4edf03951c04e577294ff3bbf805ec5ba" translate="yes" xml:space="preserve">
          <source>Note that the inversion maps returned for the &lt;code&gt;Case_Folding&lt;/code&gt; and &lt;code&gt;Simple_Case_Folding&lt;/code&gt; properties do not include the Turkic-locale mappings. Use &lt;a href=&quot;#casefold()&quot;&gt;casefold()&lt;/a&gt; for these.</source>
          <target state="translated">Обратите внимание, что карты инверсии, возвращаемые для свойств &lt;code&gt;Case_Folding&lt;/code&gt; и &lt;code&gt;Simple_Case_Folding&lt;/code&gt; , не включают сопоставления тюркского языка. Для этого используйте &lt;a href=&quot;#casefold()&quot;&gt;casefold ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31c86684655a1972f5965e0709faf4f9dbe8bb6a" translate="yes" xml:space="preserve">
          <source>Note that the largest code point in Unicode is U+10FFFF.</source>
          <target state="translated">Обратите внимание,что самой большой точкой кода в Юникоде является U+10FFFF.</target>
        </trans-unit>
        <trans-unit id="19d81e07df642a7406f056019f52ad26601c1b9e" translate="yes" xml:space="preserve">
          <source>Note that the last two of these are actually competing projects both delivering complete gcc toolchain for MS Windows:</source>
          <target state="translated">Обратите внимание,что последние два из них на самом деле являются конкурирующими проектами,оба из которых предоставляют полный набор инструментов gcc для MS Windows:</target>
        </trans-unit>
        <trans-unit id="b9b9a1c26be88f08471aaa216414e6d8395e1d57" translate="yes" xml:space="preserve">
          <source>Note that the leading &quot;:&quot; is removed from the filename, so that</source>
          <target state="translated">Обратите внимание,что ведущий &quot;:&quot; удаляется из имени файла,чтобы</target>
        </trans-unit>
        <trans-unit id="df9faf2f3be99fd79d6a15587ce23e5766dfe648" translate="yes" xml:space="preserve">
          <source>Note that the like ordinary associative arrays, the order of the keys retrieved is in an apparently random order.</source>
          <target state="translated">Обратите внимание,что,как и обычные ассоциативные массивы,порядок найденных ключей располагается,по-видимому,в случайном порядке.</target>
        </trans-unit>
        <trans-unit id="b92b7a5bb51e663f2e21cacb04a99284891d33e2" translate="yes" xml:space="preserve">
          <source>Note that the lines are not printed by default. See &lt;a href=&quot;#-p&quot;&gt;-p&lt;/a&gt; to have lines printed. If a file named by an argument cannot be opened for some reason, Perl warns you about it and moves on to the next file.</source>
          <target state="translated">Обратите внимание, что по умолчанию строки не печатаются. Смотрите &lt;a href=&quot;#-p&quot;&gt;-p,&lt;/a&gt; чтобы напечатать строки. Если файл, названный аргументом, не может быть открыт по какой-либо причине, Perl предупреждает вас об этом и переходит к следующему файлу.</target>
        </trans-unit>
        <trans-unit id="04e826f7fe166da89c0048f458c19e7bf2982a08" translate="yes" xml:space="preserve">
          <source>Note that the list is not sorted.</source>
          <target state="translated">Обратите внимание,что список не отсортирован.</target>
        </trans-unit>
        <trans-unit id="5f163f86087018a673bf93b42c4a0a6c49b0abc8" translate="yes" xml:space="preserve">
          <source>Note that the lvalue returned by the three-argument version of substr() acts as a 'magic bullet'; each time it is assigned to, it remembers which part of the original string is being modified; for example:</source>
          <target state="translated">Обратите внимание,что l-значение,возвращаемое трёхпараметрической версией substr(),действует как &quot;волшебная пуля&quot;;каждый раз,когда ей присваивается значение,она запоминает,какая часть исходной строки модифицируется;например:</target>
        </trans-unit>
        <trans-unit id="30652accd17648a773c7cfc6b99b87e2f00a6b4d" translate="yes" xml:space="preserve">
          <source>Note that the mapping is the one that is specified in the Unicode data files, and to get the final decomposition, it may need to be applied recursively.</source>
          <target state="translated">Обратите внимание,что отображение-это то,что указано в файлах данных Юникода,и для получения окончательной декомпозиции может потребоваться рекурсивное применение.</target>
        </trans-unit>
        <trans-unit id="a840d21a1adb331df5f502ec5cce875d624189ca" translate="yes" xml:space="preserve">
          <source>Note that the minimal matching quantifiers, &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt;, and &lt;code&gt;??&lt;/code&gt; appear to be nested quantifiers, but aren't. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что минимальные квантификаторы соответствия &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt; , и &lt;code&gt;??&lt;/code&gt; кажутся вложенными квантификаторами, но это не так. См. &lt;a href=&quot;perlre&quot;&gt;Perlre&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c2a0ab30039f9b1189b998b4a9e776dc39a1982" translate="yes" xml:space="preserve">
          <source>Note that the number of exponent digits in the scientific notation produced by &lt;code&gt;%e&lt;/code&gt; , &lt;code&gt;%E&lt;/code&gt; , &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; for numbers with the modulus of the exponent less than 100 is system-dependent: it may be three or less (zero-padded as necessary). In other words, 1.23 times ten to the 99th may be either &quot;1.23e99&quot; or &quot;1.23e099&quot;. Similarly for &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%A&lt;/code&gt; : the exponent or the hexadecimal digits may float: especially the &quot;long doubles&quot; Perl configuration option may cause surprises.</source>
          <target state="translated">Обратите внимание, что количество цифр экспоненты в экспоненциальной нотации, полученной &lt;code&gt;%e&lt;/code&gt; , &lt;code&gt;%E&lt;/code&gt; , &lt;code&gt;%g&lt;/code&gt; и &lt;code&gt;%G&lt;/code&gt; для чисел с модулем экспоненты меньше 100, зависит от системы: оно может быть три или меньше (с дополнением нулями как надо). Другими словами, 1,23 умноженное на десять до 99-го числа может быть либо &amp;laquo;1,23e99&amp;raquo;, либо &amp;laquo;1,23e099&amp;raquo;. Аналогично для &lt;code&gt;%a&lt;/code&gt; и &lt;code&gt;%A&lt;/code&gt; : показатель степени или шестнадцатеричные цифры могут плавать: особенно параметр конфигурации Perl &quot;длинные удвоения&quot; может вызвать сюрпризы.</target>
        </trans-unit>
        <trans-unit id="a7eeec0bff7c89a12579e992fcf86b0716b7245b" translate="yes" xml:space="preserve">
          <source>Note that the only two changes from the normal way of writing an extension is the addition of a &lt;code&gt;#define PERL_NO_GET_CONTEXT&lt;/code&gt; before including the Perl headers, followed by a &lt;code&gt;dTHX;&lt;/code&gt; declaration at the start of every function that will call the Perl API. (You'll know which functions need this, because the C compiler will complain that there's an undeclared identifier in those functions.) No changes are needed for the XSUBs themselves, because the XS() macro is correctly defined to pass in the implicit context if needed.</source>
          <target state="translated">Обратите внимание, что единственными двумя &lt;code&gt;#define PERL_NO_GET_CONTEXT&lt;/code&gt; от обычного способа написания расширения являются добавление #define PERL_NO_GET_CONTEXT перед включением заголовков Perl, за которым следует &lt;code&gt;dTHX;&lt;/code&gt; объявление в начале каждой функции, которая будет вызывать Perl API. (Вы будете знать, каким функциям это нужно, потому что компилятор C будет жаловаться на необъявленный идентификатор в этих функциях.) Для самих XSUB никаких изменений не требуется, потому что макрос XS () правильно определен для передачи в неявном контексте если нужно.</target>
        </trans-unit>
        <trans-unit id="81cafeed743ff4607118970eeb67b7b39cfee366" translate="yes" xml:space="preserve">
          <source>Note that the opmask doesn't affect the already compiled code, it only affects any</source>
          <target state="translated">Обратите внимание,что опмаска не влияет на уже скомпилированный код,а только на любой</target>
        </trans-unit>
        <trans-unit id="50380a5708cf00fd178289610d3bed5ed2c8b5b4" translate="yes" xml:space="preserve">
          <source>Note that the options terminator (default &lt;code&gt;--&lt;/code&gt; ), if present, will also be passed through in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что терминатор параметров (по умолчанию &lt;code&gt;--&lt;/code&gt; ), если он присутствует, также будет передан в &lt;code&gt;@ARGV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34344d5bf3d39aec43cee250c8b0f5cab594ad8e" translate="yes" xml:space="preserve">
          <source>Note that the parentheses in &lt;code&gt;(?=regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;=regexp)&lt;/code&gt; are non-capturing, since these are zero-width assertions. Thus in the second regexp, the substrings captured are those of the whole regexp itself. Lookahead &lt;code&gt;(?=regexp)&lt;/code&gt; can match arbitrary regexps, but lookbehind &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; only works for regexps of fixed width, i.e., a fixed number of characters long. Thus &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; is fine, but &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; is not. The negated versions of the lookahead and lookbehind assertions are denoted by &lt;code&gt;(?!regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; respectively. They evaluate true if the regexps do</source>
          <target state="translated">Обратите внимание, что круглые скобки в &lt;code&gt;(?=regexp)&lt;/code&gt; и &lt;code&gt;(?&amp;lt;=regexp)&lt;/code&gt; не захватывают, так как это утверждения нулевой ширины. Таким образом, во втором регулярном выражении захваченные подстроки - это подстроки всего регулярного выражения. Предварительный просмотр &lt;code&gt;(?=regexp)&lt;/code&gt; может соответствовать произвольным регулярным выражениям , но предварительный просмотр назад &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; работает только для регулярных выражений фиксированной ширины, т. Е. С фиксированным количеством символов. Таким образом, &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; подходит, а &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; - нет. Инвертированные версии утверждений просмотра вперед и назад обозначаются &lt;code&gt;(?!regexp)&lt;/code&gt; и &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; соответственно. Они оценивают истину, если регулярные выражения</target>
        </trans-unit>
        <trans-unit id="69b12314d048529314e48e1e307c0f68902915bd" translate="yes" xml:space="preserve">
          <source>Note that the perl-mode of emacs will have fits with &lt;code&gt;&quot;main'foo&quot;&lt;/code&gt; (single quote), and mess up the indentation and highlighting. You are probably using &lt;code&gt;&quot;main::foo&quot;&lt;/code&gt; in new Perl code anyway, so this shouldn't be an issue.</source>
          <target state="translated">Обратите внимание, что perl-режим emacs будет соответствовать &lt;code&gt;&quot;main'foo&quot;&lt;/code&gt; (одинарная кавычка) и испортит отступы и выделение. Вы, вероятно, все равно используете &lt;code&gt;&quot;main::foo&quot;&lt;/code&gt; в новом коде Perl, так что это не должно быть проблемой.</target>
        </trans-unit>
        <trans-unit id="f5ca7725b131e21f49d7345fcb2f0711a2a47f63" translate="yes" xml:space="preserve">
          <source>Note that the possessive quantifier modifier can not be be combined with the non-greedy modifier. This is because it would make no sense. Consider the follow equivalency table:</source>
          <target state="translated">Обратите внимание,что притягательный модификатор квантификатора не может быть совмещен с нежирным модификатором.Это потому,что в этом нет никакого смысла.Рассмотрим следующую таблицу эквивалентности:</target>
        </trans-unit>
        <trans-unit id="2853371a63417bfadde728879823337ed5a4d700" translate="yes" xml:space="preserve">
          <source>Note that the process will continue to grow for each file that it uses. In addition, there might be &lt;code&gt;AUTOLOAD&lt;/code&gt; ed subroutines and other conditions that cause Perl's symbol table to grow. You might want to add some logic that keeps track of the process size, or restarts itself after a certain number of requests, to ensure that memory consumption is minimized. You'll also want to scope your variables with &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; whenever possible.</source>
          <target state="translated">Обратите внимание, что процесс будет продолжать расти для каждого используемого файла. Кроме того, могут существовать подпрограммы &lt;code&gt;AUTOLOAD&lt;/code&gt; ed и другие условия, которые вызывают рост таблицы символов Perl. Вы можете добавить некоторую логику, которая отслеживает размер процесса или перезагружается после определенного количества запросов, чтобы минимизировать потребление памяти. Вы также захотите, когда это возможно, охватить свои переменные с помощью &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b2e6d6d10b83461736cd9723d9f047ffdd975d1" translate="yes" xml:space="preserve">
          <source>Note that the properties of the algorithms change over time, as the algorithms are analyzed and machines grow faster. If your application for instance depends on it being &quot;impossible&quot; to generate the same digest for a different message it is wise to make it easy to plug in stronger algorithms as the one used grow weaker. Using the interface documented here should make it easy to change algorithms later.</source>
          <target state="translated">Обратите внимание,что свойства алгоритмов со временем меняются,так как алгоритмы анализируются и машины растут быстрее.Если ваше приложение,например,зависит от того,что &quot;невозможно&quot; сгенерировать один и тот же дайджест для другого сообщения,то разумно сделать так,чтобы было легче подключать более сильные алгоритмы по мере того,как используемый будет слабеть.Использование документированного здесь интерфейса должно облегчить последующую смену алгоритмов.</target>
        </trans-unit>
        <trans-unit id="94680bef919b3e58595e50dc2cef254eecd344d5" translate="yes" xml:space="preserve">
          <source>Note that the reason that keys that start with &quot;_&quot; are immune to _AUTO isn't anything generally magical about the underscore character -- I just wanted a way to have most lexicon keys be autoable, except for possibly a few, and I arbitrarily decided to use a leading underscore as a signal to distinguish those few.</source>
          <target state="translated">Обратите внимание,что причина,по которой ключи,начинающиеся с &quot;_&quot;,невосприимчивы к символу подчеркивания-я просто хотел,чтобы большинство лексических ключей были автоматическими,за исключением,возможно,нескольких,и я произвольно решил использовать ведущий символ подчеркивания в качестве сигнала,чтобы отличить этих немногих.</target>
        </trans-unit>
        <trans-unit id="c52f10e051f2461220787b7a728deb5d7e62b4bd" translate="yes" xml:space="preserve">
          <source>Note that the said &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; is bound by an implicit scope. As a result any newly introduced lexical variable or any modified capture buffer content is lost after the eval. The debugger is a nice environment to learn Perl, but if you interactively experiment using material which should be in the same scope, stuff it in one line.</source>
          <target state="translated">Обратите внимание, что указанный &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; связан неявной областью видимости. В результате любая вновь введенная лексическая переменная или любое измененное содержимое буфера захвата теряется после eval. Отладчик - хорошая среда для изучения Perl, но если вы интерактивно экспериментируете с материалом, который должен быть в той же области, поместите его в одну строку.</target>
        </trans-unit>
        <trans-unit id="55c5f596ab4d97752de506fd4873b64dd76c61e3" translate="yes" xml:space="preserve">
          <source>Note that the single parameter passed to the</source>
          <target state="translated">Обратите внимание,что единственный параметр,переданный в</target>
        </trans-unit>
        <trans-unit id="a34d0fde03ac911613a011adde756943693a9a07" translate="yes" xml:space="preserve">
          <source>Note that the source code is passed as a single string, so any regex that uses &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; to detect line boundaries will need the &lt;code&gt;/m&lt;/code&gt; flag.</source>
          <target state="translated">Обратите внимание, что исходный код передается как одна строка, поэтому для любого регулярного выражения, использующего &lt;code&gt;^&lt;/code&gt; или &lt;code&gt;$&lt;/code&gt; для определения границ строк, потребуется флаг &lt;code&gt;/m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edfabff4ba4038a16af2c755df720dc69793c8b2" translate="yes" xml:space="preserve">
          <source>Note that the special variable &lt;code&gt;$^N&lt;/code&gt; is particularly useful with code blocks to capture the results of submatches in variables without having to keep track of the number of nested parentheses. For example:</source>
          <target state="translated">Обратите внимание, что специальная переменная &lt;code&gt;$^N&lt;/code&gt; особенно полезна с блоками кода для захвата результатов под совпадений в переменных без необходимости отслеживать количество вложенных круглых скобок. Например:</target>
        </trans-unit>
        <trans-unit id="320c096bf4918e52d7bd0e618c2e6a5bc9e4bbc3" translate="yes" xml:space="preserve">
          <source>Note that the specified &lt;code&gt;fail&lt;/code&gt; behaviour applies to nested tags as well.</source>
          <target state="translated">Обратите внимание , что указанный &lt;code&gt;fail&lt;/code&gt; поведения относится к вложенным тегам , а также.</target>
        </trans-unit>
        <trans-unit id="580a625682b8e1814baa151c5f0f7dc24aff6bf1" translate="yes" xml:space="preserve">
          <source>Note that the specified delimiters are automatically quotemeta'd.</source>
          <target state="translated">Обратите внимание,что указанные разделители автоматически являются quotemeta'd.</target>
        </trans-unit>
        <trans-unit id="1f961077ad91e1f5e608c0720760840050533641" translate="yes" xml:space="preserve">
          <source>Note that the stack is popped using &lt;code&gt;POPs&lt;/code&gt; in the block where &lt;code&gt;SvTRUE(ERRSV)&lt;/code&gt; is true. This is necessary because whenever a</source>
          <target state="translated">Обратите внимание, что стек извлекается с использованием &lt;code&gt;POPs&lt;/code&gt; в блоке, где &lt;code&gt;SvTRUE(ERRSV)&lt;/code&gt; истинно. Это необходимо, потому что всякий раз, когда</target>
        </trans-unit>
        <trans-unit id="6462eb454e096d8a1746fdc113a16165357f8c5b" translate="yes" xml:space="preserve">
          <source>Note that the stringified form of infinity varies between platforms: it can be for example any of</source>
          <target state="translated">Обратите внимание,что строковая форма бесконечности варьируется между платформами:это может быть,например,любая из следующих форм</target>
        </trans-unit>
        <trans-unit id="3205ecbbb1a9fb55e62eda6514162f94f7163bfc" translate="yes" xml:space="preserve">
          <source>Note that the syntax here is &lt;code&gt;(?(?{...})yes-regexp|no-regexp)&lt;/code&gt;, not &lt;code&gt;(?((?{...}))yes-regexp|no-regexp)&lt;/code&gt;. In other words, in the case of a code expression, we don't need the extra parentheses around the conditional.</source>
          <target state="translated">Обратите внимание, что здесь используется синтаксис &lt;code&gt;(?(?{...})yes-regexp|no-regexp)&lt;/code&gt; , а не &lt;code&gt;(?((?{...}))yes-regexp|no-regexp)&lt;/code&gt; . Другими словами, в случае кодового выражения нам не нужны лишние круглые скобки вокруг условного выражения.</target>
        </trans-unit>
        <trans-unit id="56d5a14355f9ba6fa06dc53e561fc21f5fed300e" translate="yes" xml:space="preserve">
          <source>Note that the tag names in &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; don't have the leading ':'.</source>
          <target state="translated">Обратите внимание, что имена тегов в &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; не имеют в начале &quot;:&quot;.</target>
        </trans-unit>
        <trans-unit id="0d43c895066c9d58f40f202a5d66994671522d5e" translate="yes" xml:space="preserve">
          <source>Note that the trailing slash is required. This will result in some harmless warnings as Configure is run:</source>
          <target state="translated">Обратите внимание,что трейлинговая косая черта необходима.Это приведет к некоторым безобидным предупреждениям,так как запущена функция Configure:</target>
        </trans-unit>
        <trans-unit id="4c26505297a31083f6416749d3b93a6af60fd352" translate="yes" xml:space="preserve">
          <source>Note that the trapping of the restricted operations is not atomic: for example</source>
          <target state="translated">Обратите внимание,что ловушка ограниченных операций не является атомарной:например</target>
        </trans-unit>
        <trans-unit id="ec116afd50e96fd07d539738d536a8676b15709b" translate="yes" xml:space="preserve">
          <source>Note that the two characters on either side of the hyphen are not necessarily both letters or both digits. Any character is possible, although not advisable. &lt;code&gt;['-?]&lt;/code&gt; contains a range of characters, but most people will not know which characters that means. Furthermore, such ranges may lead to portability problems if the code has to run on a platform that uses a different character set, such as EBCDIC.</source>
          <target state="translated">Обратите внимание, что два символа по обе стороны от дефиса не обязательно являются обеими буквами или обеими цифрами. Возможен любой персонаж, но не рекомендуется. &lt;code&gt;['-?]&lt;/code&gt; содержит ряд символов, но большинство людей не знают, какие символы это означает. Кроме того, такие диапазоны могут привести к проблемам с переносимостью, если код должен выполняться на платформе, которая использует другой набор символов, например EBCDIC.</target>
        </trans-unit>
        <trans-unit id="4f3b0de1587236bfef6be06a1e0b5de9990d1475" translate="yes" xml:space="preserve">
          <source>Note that the user's arguments are also passed to your plugin's &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; function as a list, eg:</source>
          <target state="translated">Обратите внимание, что аргументы пользователя также передаются функции &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; вашего плагина в виде списка, например:</target>
        </trans-unit>
        <trans-unit id="1a9f0c91ad407486da2a0bb856a821fce00b3309" translate="yes" xml:space="preserve">
          <source>Note that the value is parsed every time the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; executes. If EXPR is omitted, evaluates &lt;code&gt;$_&lt;/code&gt; . This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time.</source>
          <target state="translated">Обратите внимание, что значение анализируется каждый раз при выполнении &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . Если EXPR опущен, вычисляет &lt;code&gt;$_&lt;/code&gt; . Эта форма обычно используется для задержки синтаксического анализа и последующего выполнения текста EXPR до времени выполнения.</target>
        </trans-unit>
        <trans-unit id="80c8be42c3096c6bc305f155cfa7b7681593f345" translate="yes" xml:space="preserve">
          <source>Note that the value is parsed every time the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; executes. If EXPR is omitted, evaluates &lt;code&gt;$_&lt;/code&gt; . This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time.</source>
          <target state="translated">Обратите внимание, что значение анализируется каждый раз при выполнении &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . Если EXPR опущен, вычисляет &lt;code&gt;$_&lt;/code&gt; . Эта форма обычно используется для задержки синтаксического анализа и последующего выполнения текста EXPR до времени выполнения.</target>
        </trans-unit>
        <trans-unit id="2890675e6e5968cd2291073021c2fb93c7f31c50" translate="yes" xml:space="preserve">
          <source>Note that the value of &lt;code&gt;RV&lt;/code&gt; coincides with the numbers we see when we stringify $b. The addresses inside IV() are addresses of &lt;code&gt;X***&lt;/code&gt; structures which hold the current state of an &lt;code&gt;SV&lt;/code&gt; . This address may change during lifetime of an SV.</source>
          <target state="translated">Обратите внимание, что значение &lt;code&gt;RV&lt;/code&gt; совпадает с числами, которые мы видим при преобразовании $ b в строку. Адреса внутри IV () - это адреса структур &lt;code&gt;X***&lt;/code&gt; которые содержат текущее состояние &lt;code&gt;SV&lt;/code&gt; . Этот адрес может измениться в течение срока службы SV.</target>
        </trans-unit>
        <trans-unit id="2ef677d9c2b3cc466ca9bce864166dbad6ce21bf" translate="yes" xml:space="preserve">
          <source>Note that the values are not copied, which means modifying them will modify the contents of the hash:</source>
          <target state="translated">Обратите внимание,что значения не копируются,что означает,что их изменение приведет к изменению содержимого хэша:</target>
        </trans-unit>
        <trans-unit id="fa78261a427d9e6af662bdbde0ef46d033f442ef" translate="yes" xml:space="preserve">
          <source>Note that the variables &lt;code&gt;$z0&lt;/code&gt; and &lt;code&gt;$z1&lt;/code&gt; are not substituted when the regexp is compiled, as happens for ordinary variables outside a code expression. Rather, the whole code block is parsed as perl code at the same time as perl is compiling the code containing the literal regexp pattern.</source>
          <target state="translated">Обратите внимание, что переменные &lt;code&gt;$z0&lt;/code&gt; и &lt;code&gt;$z1&lt;/code&gt; не заменяются при компиляции регулярного выражения, как это происходит для обычных переменных вне выражения кода. Скорее, весь блок кода анализируется как код Perl в то же время, когда perl компилирует код, содержащий буквальный шаблон регулярного выражения.</target>
        </trans-unit>
        <trans-unit id="1fe8cdc1e68ec1c1124569f21bcd3994f60be55b" translate="yes" xml:space="preserve">
          <source>Note that there are different &quot;long doubles&quot;: Perl will use whatever the compiler has.</source>
          <target state="translated">Обратите внимание,что существуют различные &quot;длинные двойники&quot;:Perl будет использовать все,что есть у компилятора.</target>
        </trans-unit>
        <trans-unit id="40ec796a3ab0ba742755eb67dcef2d941aab9225" translate="yes" xml:space="preserve">
          <source>Note that there are platform-specific limitations on the maximum length of &lt;code&gt;$0&lt;/code&gt; . In the most extreme case it may be limited to the space occupied by the original &lt;code&gt;$0&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что существуют ограничения для конкретной платформы на максимальную длину в &lt;code&gt;$0&lt;/code&gt; . В самом крайнем случае он может быть ограничен пространством, занимаемым исходным &lt;code&gt;$0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f16f6cc7a1d32290bc8fbd0609f6f10bfa51e1b" translate="yes" xml:space="preserve">
          <source>Note that there are quite a few things that are unaffected by the current locale. Any literal character is the native character for the given platform. Hence 'A' means the character at code point 65 on ASCII platforms, and 193 on EBCDIC. That may or may not be an 'A' in the current locale, if that locale even has an 'A'. Similarly, all the escape sequences for particular characters, &lt;code&gt;\n&lt;/code&gt; for example, always mean the platform's native one. This means, for example, that &lt;code&gt;\N&lt;/code&gt; in regular expressions (every character but new-line) works on the platform character set.</source>
          <target state="translated">Обратите внимание, что текущая локаль не влияет на некоторые вещи. Любой буквальный символ является родным для данной платформы. Следовательно, &amp;laquo;A&amp;raquo; означает символ в кодовой точке 65 на платформах ASCII и 193 на EBCDIC. Это может быть или не быть &amp;laquo;А&amp;raquo; в текущей локали, если в этой локали даже есть &amp;laquo;А&amp;raquo;. Точно так же все escape-последовательности для определенных символов, например &lt;code&gt;\n&lt;/code&gt; , всегда означают собственный код платформы. Это означает, например, что &lt;code&gt;\N&lt;/code&gt; в регулярных выражениях (каждый символ, кроме новой строки) работает с набором символов платформы.</target>
        </trans-unit>
        <trans-unit id="fcd641de5265b4e5cb187918ec80acbf65468caa" translate="yes" xml:space="preserve">
          <source>Note that there is no &lt;code&gt;unlock()&lt;/code&gt; function - the only way to unlock a variable is to allow it to go out of scope.</source>
          <target state="translated">Обратите внимание, что здесь нет функции &lt;code&gt;unlock()&lt;/code&gt; - единственный способ разблокировать переменную - это позволить ей выйти за пределы области видимости.</target>
        </trans-unit>
        <trans-unit id="ee4f05af5f26db870953ddb10f74cf79c107ad1e" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the return value of &lt;code&gt;SvPV()&lt;/code&gt; is equal to &lt;code&gt;SvPVX(sv)&lt;/code&gt; , or that &lt;code&gt;SvPVX(sv)&lt;/code&gt; contains valid data, or that successive calls to &lt;code&gt;SvPV(sv)&lt;/code&gt; will return the same pointer value each time. This is due to the way that things like overloading and Copy-On-Write are handled. In these cases, the return value may point to a temporary buffer or similar. If you absolutely need the SvPVX field to be valid (for example, if you intend to write to it), then see &lt;a href=&quot;#SvPV_force&quot;&gt;SvPV_force&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что нет гарантии, что возвращаемое значение &lt;code&gt;SvPV()&lt;/code&gt; равно &lt;code&gt;SvPVX(sv)&lt;/code&gt; , или что &lt;code&gt;SvPVX(sv)&lt;/code&gt; содержит допустимые данные, или что последовательные вызовы &lt;code&gt;SvPV(sv)&lt;/code&gt; будут возвращать одно и то же значение указателя каждый раз. Это связано с тем, как обрабатываются такие вещи, как перегрузка и копирование при записи. В этих случаях возвращаемое значение может указывать на временный буфер или что-то подобное. Если вам абсолютно необходимо, чтобы поле SvPVX было действительным (например, если вы собираетесь писать в него), см. &lt;a href=&quot;#SvPV_force&quot;&gt;SvPV_force&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61e6ff314bcdd26836be58f3e6e1baf7a7a0e0d1" translate="yes" xml:space="preserve">
          <source>Note that there is no longer any need to import the Tie::Cycle module -- Attribute::Handlers takes care of that automagically. You can even pass arguments to the module's &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine, by appending them to the class name. For example:</source>
          <target state="translated">Обратите внимание, что больше нет необходимости импортировать модуль Tie :: Cycle - Attribute :: Handlers позаботится об этом автоматически. Вы даже можете передать аргументы подпрограмме &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; модуля , добавив их к имени класса. Например:</target>
        </trans-unit>
        <trans-unit id="371ae6320cc7816e3fbef9a78451aa3acb900b80" translate="yes" xml:space="preserve">
          <source>Note that there is no method to obtain the filehandle from the C&amp;lt;:temp&amp;gt; object. The object itself acts as a filehandle. The object isa C&amp;lt;:handle&amp;gt; and isa C&amp;lt;:seekable&amp;gt; so all those methods are available.</source>
          <target state="translated">Обратите внимание, что не существует способа получить дескриптор файла из объекта C &amp;lt;: temp&amp;gt;. Сам объект действует как дескриптор файла. Это объект C &amp;lt;: handle&amp;gt; и C &amp;lt;: seekable&amp;gt;, поэтому доступны все эти методы.</target>
        </trans-unit>
        <trans-unit id="d8cf101c922aec42258fb611024af08532a1bd0f" translate="yes" xml:space="preserve">
          <source>Note that there's nothing wrong with defining multiple subclasses of a given class. This is both common and safe. For example, we might define &lt;code&gt;File::MP3::FixedBitrate&lt;/code&gt; and &lt;code&gt;File::MP3::VariableBitrate&lt;/code&gt; classes to distinguish between different types of mp3 file.</source>
          <target state="translated">Обратите внимание, что нет ничего плохого в определении нескольких подклассов данного класса. Это и распространено, и безопасно. Например, мы могли бы определить классы &lt;code&gt;File::MP3::FixedBitrate&lt;/code&gt; и &lt;code&gt;File::MP3::VariableBitrate&lt;/code&gt; чтобы различать разные типы файлов mp3.</target>
        </trans-unit>
        <trans-unit id="cea78bd68a577c917916111e5f8f914537b91ae3" translate="yes" xml:space="preserve">
          <source>Note that these configuration options are only used for generating</source>
          <target state="translated">Обратите внимание,что эти опции конфигурации используются только для генерации</target>
        </trans-unit>
        <trans-unit id="cf6c8c42d064a6c3523dfd07c74fecf239c950de" translate="yes" xml:space="preserve">
          <source>Note that these functions are compatible with *nix, not with the older ports of '94 - 95. The priorities are absolute, go from 32 to -95, lower is quicker. 0 is the default priority.</source>
          <target state="translated">Обратите внимание,что эти функции совместимы с *nix,а не со старыми портами '94-95.Приоритеты абсолютные,переходим от 32 до -95,ниже-быстрее.0 является приоритетом по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d791cddf7ffd40104e97e407e1f26e145041f7de" translate="yes" xml:space="preserve">
          <source>Note that these functions take &lt;code&gt;SV*&lt;/code&gt; keys, which simplifies writing of extension code that deals with hash structures. These functions also allow passing of &lt;code&gt;SV*&lt;/code&gt; keys to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; functions without forcing you to stringify the keys (unlike the previous set of functions).</source>
          <target state="translated">Обратите внимание, что эти функции используют ключи &lt;code&gt;SV*&lt;/code&gt; , что упрощает написание кода расширения, имеющего дело с хэш-структурами. Эти функции также позволяют передавать ключи &lt;code&gt;SV*&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; функций, не заставляя вас связывать ключи (в отличие от предыдущего набора функций).</target>
        </trans-unit>
        <trans-unit id="ac690cbf2993a60c5814d129da8fb3bc08b59629" translate="yes" xml:space="preserve">
          <source>Note that these macros will only work together within the</source>
          <target state="translated">Обратите внимание,что эти макросы будут работать вместе только внутри</target>
        </trans-unit>
        <trans-unit id="8a5f32d79f24485d8dc52ccd8880da69d87a4d12" translate="yes" xml:space="preserve">
          <source>Note that these problems should not discourage experimenting, since they have a low probability of affecting small programs.</source>
          <target state="translated">Обратите внимание,что эти проблемы не должны препятствовать экспериментам,так как они имеют низкую вероятность влияния на небольшие программы.</target>
        </trans-unit>
        <trans-unit id="0f02b1ce704f868a5bd6cbc730f85ed167d3d361" translate="yes" xml:space="preserve">
          <source>Note that these routines are</source>
          <target state="translated">Обратите внимание,что эти процедуры</target>
        </trans-unit>
        <trans-unit id="5e158a627cf25fb028df016dfe1afff14abe8a74" translate="yes" xml:space="preserve">
          <source>Note that these statistics are summary only. Actual performance will depend on real hit/miss ratios accessing the hash. If you are concerned by hit ratios you are recommended to &quot;oversize&quot; your hash by using something like:</source>
          <target state="translated">Обратите внимание,что эта статистика является только сводной.Фактическая производительность будет зависеть от реального соотношения хит/мисс доступа к хэшу.Если вас беспокоит соотношение попаданий,рекомендуется &quot;увеличить&quot; размер хэша,используя что-нибудь в этом роде:</target>
        </trans-unit>
        <trans-unit id="73ba985ffd1a15a231f5d43e3ffb4a26ab7bba75" translate="yes" xml:space="preserve">
          <source>Note that this API requires disambiguation between successful decoding a &lt;code&gt;NUL&lt;/code&gt; character, and an error return (unless the UTF8_CHECK_ONLY flag is set), as in both cases, 0 is returned. To disambiguate, upon a zero return, see if the first byte of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; is 0 as well. If so, the input was a &lt;code&gt;NUL&lt;/code&gt; ; if not, the input had an error.</source>
          <target state="translated">Обратите внимание, что этот API требует устранения неоднозначности между успешным декодированием символа &lt;code&gt;NUL&lt;/code&gt; и возвращением ошибки (если не установлен флаг UTF8_CHECK_ONLY), поскольку в обоих случаях возвращается 0. Чтобы устранить неоднозначность, при нулевом возврате проверьте, равен ли также 0 первый байт &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; . Если да, то вход был &lt;code&gt;NUL&lt;/code&gt; ; в противном случае на входе была ошибка.</target>
        </trans-unit>
        <trans-unit id="9e7c1fe94057690a3e15fba2814e3a5b075195c1" translate="yes" xml:space="preserve">
          <source>Note that this a lesser issue now when we do not spawn</source>
          <target state="translated">Обратите внимание,что это меньший вопрос сейчас,когда мы не икрометаем.</target>
        </trans-unit>
        <trans-unit id="b5ca0aab168c321c8270a6107199325edc3cbbd7" translate="yes" xml:space="preserve">
          <source>Note that this behaviour differs from version 1.00 of the Safe module where the root module could be used to change the namespace. That functionality has been withdrawn pending deeper consideration.</source>
          <target state="translated">Обратите внимание,что это поведение отличается от версии 1.00 Safe модуля,где корневой модуль может быть использован для изменения пространства имён.Этот функционал был отозван в ожидании более глубокого рассмотрения.</target>
        </trans-unit>
        <trans-unit id="886c9a49ed86dcbe7c33a66300a271b1c555293b" translate="yes" xml:space="preserve">
          <source>Note that this business of escaping a newline is specific to interactive commands typed into the debugger.</source>
          <target state="translated">Обратите внимание,что этот бизнес экранирования новой строки специфичен для интерактивных команд,вводимых в отладчик.</target>
        </trans-unit>
        <trans-unit id="d9af4c6dbd50132dd9aa57c1076bfc7d75c87275" translate="yes" xml:space="preserve">
          <source>Note that this class also provides (but does not export) the function Pod::Simple::HTMLBatch::go. This is basically just a shortcut for &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; . It's meant to be handy for calling from the command line.</source>
          <target state="translated">Обратите внимание, что этот класс также предоставляет (но не экспортирует) функцию Pod :: Simple :: HTMLBatch :: go. По сути, это просто ярлык для &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; . Он предназначен для удобного вызова из командной строки.</target>
        </trans-unit>
        <trans-unit id="cbd3cc83f76f664edbfed1f74f0bb7a74cadfcdb" translate="yes" xml:space="preserve">
          <source>Note that this does *not* collapse</source>
          <target state="translated">Обратите внимание,что это не приводит к краху</target>
        </trans-unit>
        <trans-unit id="00224048b57a554f368bf0ab411d2ec7b380142b" translate="yes" xml:space="preserve">
          <source>Note that this does not respect any locale that might be in effect; it matches according to the platform's native character set.</source>
          <target state="translated">Обратите внимание,что при этом не учитывается любая действующая локаль;она совпадает в соответствии с родным набором символов платформы.</target>
        </trans-unit>
        <trans-unit id="c41629303d26db24c4cf7e890ae9d3b978c9901b" translate="yes" xml:space="preserve">
          <source>Note that this example shows the values of the lexicals, whereas the other examples did not (as they're compile-time only).</source>
          <target state="translated">Обратите внимание,что в этом примере показаны значения лексики,в то время как в других примерах-нет (так как они только на этапе компиляции).</target>
        </trans-unit>
        <trans-unit id="fa65d225bcb30ebd19ec0f94b22dc45327203c89" translate="yes" xml:space="preserve">
          <source>Note that this function does</source>
          <target state="translated">Обратите внимание,что эта функция выполняет</target>
        </trans-unit>
        <trans-unit id="383a0ca4f40d5e081bc8cd1b9b45b6acddf8c873" translate="yes" xml:space="preserve">
          <source>Note that this harness is</source>
          <target state="translated">Обратите внимание,что этот жгут</target>
        </trans-unit>
        <trans-unit id="26765a3c9e68c0777ae5d0fb4a579c61611c0dca" translate="yes" xml:space="preserve">
          <source>Note that this hash does not include numerics (like &quot;64&quot; or &quot;x981c&quot;).</source>
          <target state="translated">Обратите внимание,что этот хэш не включает цифр (например,&quot;64&quot; или &quot;x981c&quot;).</target>
        </trans-unit>
        <trans-unit id="d9c356ba63dd81b549b024d31174e2c723d0a6c7" translate="yes" xml:space="preserve">
          <source>Note that this is a backwards incompatible change from version &lt;code&gt;1.36&lt;/code&gt; and before.</source>
          <target state="translated">Обратите внимание, что это обратно несовместимое изменение по &lt;code&gt;1.36&lt;/code&gt; с версией 1.36 и ранее.</target>
        </trans-unit>
        <trans-unit id="d089b782c3356f4400063cd34b72b66e78bb2e56" translate="yes" xml:space="preserve">
          <source>Note that this is a unary operator, not a list operator.</source>
          <target state="translated">Обратите внимание,что это унарный оператор,а не оператор списка.</target>
        </trans-unit>
        <trans-unit id="dcb3c6a57a75c99d73d6d08c842005a53c2cad92" translate="yes" xml:space="preserve">
          <source>Note that this is an experimental feature which may be changed or removed in a future Perl release.</source>
          <target state="translated">Обратите внимание,что это экспериментальная функция,которая может быть изменена или удалена в будущем релизе Perl.</target>
        </trans-unit>
        <trans-unit id="504d8cb8d0a49d57ae71301eeedf5cb16096e2bb" translate="yes" xml:space="preserve">
          <source>Note that this is not in general possible in shells of more dubious heritage, as the theoretical</source>
          <target state="translated">Отметим,что в целом это невозможно в оболочках более сомнительного наследия,поскольку теоретически</target>
        </trans-unit>
        <trans-unit id="9b1de500fa4baebd7c567a7a827d4c48d84fe735" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; , which begins a new dispatch that is restricted to searching the ancestors of the current class. &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; can backtrack past the current class -- to look for a suitable method in other ancestors of &lt;code&gt;$self&lt;/code&gt; -- whereas &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; cannot.</source>
          <target state="translated">Обратите внимание, что это не то же самое, что &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; , которая начинает новую отправку, ограниченную поиском предков текущего класса. &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; может возвращаться назад мимо текущего класса - чтобы искать подходящий метод в других предках &lt;code&gt;$self&lt;/code&gt; - тогда как &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; не может.</target>
        </trans-unit>
        <trans-unit id="fb474ba009e8c7c8d7bdb3779c16f4d2c9b0cba8" translate="yes" xml:space="preserve">
          <source>Note that this is one of the rare cases where you cannot use the same template for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; because &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; can't determine a repeat count for a &lt;code&gt;()&lt;/code&gt; -group.</source>
          <target state="translated">Обратите внимание, что это один из редких случаев, когда вы не можете использовать один и тот же шаблон для &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; потому что &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; не может определить счетчик повторов для &lt;code&gt;()&lt;/code&gt; -группы.</target>
        </trans-unit>
        <trans-unit id="37d289726dbf38f52d7d747a6f498b593946b256" translate="yes" xml:space="preserve">
          <source>Note that this is the</source>
          <target state="translated">Обратите внимание,что это</target>
        </trans-unit>
        <trans-unit id="051c395ae34aa1a11e3b94b0cb470642628b722b" translate="yes" xml:space="preserve">
          <source>Note that this isn't really a word in the English sense; it's just chunks of consecutive non-whitespace characters.</source>
          <target state="translated">Обратите внимание,что это не совсем слово в английском смысле,это просто куски последовательных не белых пробельных символов.</target>
        </trans-unit>
        <trans-unit id="f98a99684b1c3e2bccd26b3c2631a053bdfaf9be" translate="yes" xml:space="preserve">
          <source>Note that this issue precludes the building of many Macintosh-specific CPAN modules (&lt;code&gt;Mac::*&lt;/code&gt; ), as the required Apple frameworks do not provide PPC64 support. Similarly, downloads from Fink or Darwinports are unlikely to provide 64-bit support; the libraries must be rebuilt from source with the appropriate compiler and linker flags. For further information, see Apple's</source>
          <target state="translated">Обратите внимание, что эта проблема препятствует созданию многих модулей CPAN для Macintosh ( &lt;code&gt;Mac::*&lt;/code&gt; ), поскольку требуемые платформы Apple не обеспечивают поддержку PPC64. Точно так же загрузка из Fink или Darwinports вряд ли обеспечит поддержку 64-битной версии; библиотеки должны быть перестроены из исходного кода с соответствующими флагами компилятора и компоновщика. Для получения дополнительной информации см. Apple</target>
        </trans-unit>
        <trans-unit id="3cf9c28e72f601c60b3c701ee74ca406285e72fe" translate="yes" xml:space="preserve">
          <source>Note that this last example is</source>
          <target state="translated">Обратите внимание,что этот последний пример</target>
        </trans-unit>
        <trans-unit id="d42f0b82dfd8478b8b9451848cff1ed7d60be50b" translate="yes" xml:space="preserve">
          <source>Note that this means that Perl expects other software to work the same way: if Perl has been led to believe that STDIN should be UTF-8, but then STDIN coming in from another command is not UTF-8, Perl will likely complain about the malformed UTF-8.</source>
          <target state="translated">Обратите внимание,что это означает,что Perl ожидает,что другое программное обеспечение будет работать таким же образом:если Perl был убежден,что STDIN должен быть UTF-8,но STDIN,поступающий от другой команды,не UTF-8,Perl,скорее всего,будет жаловаться на некорректную работу UTF-8.</target>
        </trans-unit>
        <trans-unit id="eb14855fa34c491b4e9b69501367a6f35eac94cc" translate="yes" xml:space="preserve">
          <source>Note that this means that there is no way for the inner pattern to refer to a capture group defined outside. (The code block itself can use &lt;code&gt;$1&lt;/code&gt; , etc., to refer to the enclosing pattern's capture groups.) Thus, although</source>
          <target state="translated">Обратите внимание, что это означает, что внутренний шаблон не может ссылаться на группу захвата, определенную снаружи. (Сам кодовый блок может использовать &lt;code&gt;$1&lt;/code&gt; и т. Д. Для ссылки на группы захвата включающего шаблона.) Таким образом, хотя</target>
        </trans-unit>
        <trans-unit id="cb2f7fa1807b6ef282836388add7c29032688f86" translate="yes" xml:space="preserve">
          <source>Note that this method does not write &lt;code&gt;on the fly&lt;/code&gt; as it were; it still reads all the files into memory before writing out the archive. Consult the FAQ below if this is a problem.</source>
          <target state="translated">Обратите внимание, что этот метод не пишет &quot; &lt;code&gt;on the fly&lt;/code&gt; ; он по-прежнему считывает все файлы в память перед записью архива. Если это проблема, обратитесь к FAQ ниже.</target>
        </trans-unit>
        <trans-unit id="9ebf1673f6d5cc53332f54347212529a0a096746" translate="yes" xml:space="preserve">
          <source>Note that this method merely returns the comment preceded by a '# '.</source>
          <target state="translated">Обратите внимание,что этот метод просто возвращает комментарий,которому предшествует '#'.</target>
        </trans-unit>
        <trans-unit id="e4bf33faadadb73f5033c17a03e0a21d5d47bf67" translate="yes" xml:space="preserve">
          <source>Note that this only affects how most of the arithmetic and relational &lt;b&gt;operators&lt;/b&gt; handle their operands and results, and &lt;b&gt;not&lt;/b&gt; how all numbers everywhere are treated. Specifically, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; has the effect that before computing the results of the arithmetic operators (+, -, *, /, %, +=, -=, *=, /=, %=, and unary minus), the comparison operators (&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, ==, !=, &amp;lt;=&amp;gt;), and the bitwise operators (|, &amp;amp;, ^, &amp;lt;&amp;lt;,&amp;gt;&amp;gt;, |=, &amp;amp;=, ^=, &amp;lt;&amp;lt;=,&amp;gt;&amp;gt;=), the operands have their fractional portions truncated (or floored), and the result will have its fractional portion truncated as well. In addition, the range of operands and results is restricted to that of familiar two's complement integers, i.e., -(2**31) .. (2**31-1) on 32-bit architectures, and -(2**63) .. (2**63-1) on 64-bit architectures. For example, this code</source>
          <target state="translated">Обратите внимание, что это влияет только на то, как большинство арифметических и реляционных &lt;b&gt;операторов&lt;/b&gt; обрабатывают свои операнды и результаты, а &lt;b&gt;не на то,&lt;/b&gt; как обрабатываются все числа повсюду. В частности, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; означает, что перед вычислением результатов арифметических операторов (+, -, *, /,%, + =, - =, * =, / =,% = и унарный минус) операторы сравнения (&amp;lt;, &amp;lt; =,&amp;gt;,&amp;gt; =, ==,! =, &amp;lt;=&amp;gt;) и поразрядные операторы (|, &amp;amp;, ^, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, | =, &amp;amp; =, ^ =, &amp;lt;&amp;lt; =, &amp;gt;&amp;gt; =), дробные части операндов будут обрезаны (или закрыты), и результат также будет обрезан дробной частью. Кроме того, диапазон операндов и результатов ограничен диапазоном знакомых двух дополнительных целых чисел, т.е. - (2 ** 31) .. (2 ** 31-1) на 32-битных архитектурах и - (2 ** 63) .. (2 ** 63-1) на 64-битных архитектурах. Например, этот код</target>
        </trans-unit>
        <trans-unit id="641efca71748ee43843d8c870296735b58cb247a" translate="yes" xml:space="preserve">
          <source>Note that this option is probably not useful when converting multiple POD files at once. The convention for Unix man pages for commands is for the man page title to be in all-uppercase even if the command isn't.</source>
          <target state="translated">Обратите внимание,что эта опция,вероятно,не будет полезна при конвертировании нескольких POD-файлов одновременно.Слово для Unix man-страниц для команд заключается в том,что заголовок man-страницы должен быть в верхнем регистре,даже если это не так.</target>
        </trans-unit>
        <trans-unit id="650a0cb19795021c90db4bffb31d952d9b4b0616" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning an AV*. See also: T_AVREF_REFCOUNT_FIXED</source>
          <target state="translated">Обратите внимание,что эта типовая карта не уменьшает счетчик ссылок при возврате AV*.См.также:T_AVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="75948654033e1807460f39019ce055bccbe6d14b" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning an HV*. See also: T_HVREF_REFCOUNT_FIXED</source>
          <target state="translated">Обратите внимание,что эта типовая карта не уменьшает счетчик ссылок при возврате HV*.См.также:T_HVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="4c5b3cb2ecd59af3fa9332d1a075ffadbd08c0cb" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning the reference to an SV*. See also: T_SVREF_REFCOUNT_FIXED</source>
          <target state="translated">Обратите внимание,что эта типовая карта не уменьшает счетчик ссылок при возврате ссылки на SV*.См.также:T_SVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="fdb88d672a97dbd887a0e264f45a135e237c14a4" translate="yes" xml:space="preserve">
          <source>Note that this variable was added in Perl 5.14.0. If you want to detect the global destruction phase on older versions of Perl, you can use the &lt;code&gt;Devel::GlobalDestruction&lt;/code&gt; module on CPAN.</source>
          <target state="translated">Обратите внимание, что эта переменная была добавлена ​​в Perl 5.14.0. Если вы хотите обнаружить фазу глобального уничтожения в старых версиях Perl, вы можете использовать модуль &lt;code&gt;Devel::GlobalDestruction&lt;/code&gt; на CPAN.</target>
        </trans-unit>
        <trans-unit id="79cbc4907067b711c2733dabb85b47c17c625682" translate="yes" xml:space="preserve">
          <source>Note that this version number is not the same as the version number of the Storable module itself. For instance Storable v0.7 create files in format v2.0 and Storable v2.15 create files in format v2.7. The file format version number only increment when additional features that would confuse older versions of the module are added.</source>
          <target state="translated">Обратите внимание,что этот номер версии не совпадает с номером версии самого модуля Storable.Например,Storable v0.7 создает файлы в формате v2.0 и Storable v2.15 создает файлы в формате v2.7.Номер версии файла увеличивается только при добавлении дополнительных возможностей,которые могут запутать старые версии модуля.</target>
        </trans-unit>
        <trans-unit id="c30cc57c265bdbcc01b87c7faff90971cd8cbcd5" translate="yes" xml:space="preserve">
          <source>Note that this will not apply to distributions that failed tests because of missing dependencies. Also, tests can be run regardless of the history using &quot;force&quot;.</source>
          <target state="translated">Обратите внимание,что это не относится к дистрибутивам,которые не прошли тестирование из-за пропущенных зависимостей.Также,тесты могут быть запущены независимо от истории с использованием &quot;силы&quot;.</target>
        </trans-unit>
        <trans-unit id="129dbf47ba2ec65b5d9ac83fd612d686af9cd750" translate="yes" xml:space="preserve">
          <source>Note that this will produce something similar, but it's much harder to read:</source>
          <target state="translated">Обратите внимание,что это даст нечто похожее,но это намного сложнее для чтения:</target>
        </trans-unit>
        <trans-unit id="76667870087c43a89a0c134d31da84f873df4c85" translate="yes" xml:space="preserve">
          <source>Note that to create Bzip2 content, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed.</source>
          <target state="translated">Обратите внимание, что для создания содержимого &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; должен быть установлен модуль IO :: Compress :: Bzip2 .</target>
        </trans-unit>
        <trans-unit id="c112c0c0f309f422ad0d8ea094e2f892edb8359d" translate="yes" xml:space="preserve">
          <source>Note that to create Bzip2 content, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed. A fatal error will be thrown if you attempt to create Bzip2 content when &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; is not available.</source>
          <target state="translated">Обратите внимание, что для создания содержимого &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; должен быть установлен модуль IO :: Compress :: Bzip2 . Если вы попытаетесь создать содержимое Bzip2, когда &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; недоступен, произойдет фатальная ошибка .</target>
        </trans-unit>
        <trans-unit id="91dea059c3c6adecb3e060a72157c015c80d8709" translate="yes" xml:space="preserve">
          <source>Note that to create LZMA content, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed.</source>
          <target state="translated">Обратите внимание, что для создания содержимого LZMA должен быть установлен модуль &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d4a2616c449298e5f9b3c703f0555b52ba58730" translate="yes" xml:space="preserve">
          <source>Note that to create Lzma content, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed. A fatal error will be thrown if you attempt to create Lzma content when &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; is not available.</source>
          <target state="translated">Обратите внимание, что для создания содержимого &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; должен быть установлен модуль IO :: Compress :: Lzma . Если вы попытаетесь создать содержимое Lzma, когда &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; недоступен, произойдет фатальная ошибка .</target>
        </trans-unit>
        <trans-unit id="59026c8cb18df6e69670873afd609b7b5991b245" translate="yes" xml:space="preserve">
          <source>Note that to delete a breakpoint you use 'B'.</source>
          <target state="translated">Обратите внимание,что для удаления точки останова вы используете 'B'.</target>
        </trans-unit>
        <trans-unit id="ccec21a98f6b093bde7ead086f9b2aa6d9fa5cbe" translate="yes" xml:space="preserve">
          <source>Note that to terminate options processing still requires a double dash &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что для завершения обработки опций по-прежнему требуется двойной дефис &lt;code&gt;--&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f1f1b6c5624a2d3ed9722ba6d811a877dbe016a" translate="yes" xml:space="preserve">
          <source>Note that turning this attribute to true won't suppress one or two kinds of complaints about rarely occurring unrecoverable errors.</source>
          <target state="translated">Обратите внимание,что превращение этого атрибута в true не подавит один или два вида жалоб на редко встречающиеся неустранимые ошибки.</target>
        </trans-unit>
        <trans-unit id="6db90d2a3a43a0d1ae1c73a0ecadf4c50a061235" translate="yes" xml:space="preserve">
          <source>Note that under Perls older than 5.8.0, Perl uses the standard C library's' fdopen() to implement the &lt;code&gt;=&lt;/code&gt; functionality. On many Unix systems, fdopen() fails when file descriptors exceed a certain value, typically 255. For Perls 5.8.0 and later, PerlIO is (most often) the default.</source>
          <target state="translated">Обратите внимание, что в Perls старше 5.8.0 Perl использует fdopen () стандартной библиотеки C для реализации функции &lt;code&gt;=&lt;/code&gt; . Во многих системах Unix fdopen () не работает, когда дескрипторы файлов превышают определенное значение, обычно 255. Для Perls 5.8.0 и более поздних версий PerlIO (чаще всего) используется по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ab1035410dccd2a93f4a5e17c32c7a15d00a2658" translate="yes" xml:space="preserve">
          <source>Note that under Win32</source>
          <target state="translated">Обратите внимание,что под Win32</target>
        </trans-unit>
        <trans-unit id="914bcfd8302ee9c0b531fac815eb7bd7d964c235" translate="yes" xml:space="preserve">
          <source>Note that under bigint, the result is truncated to an integer.</source>
          <target state="translated">Обратите внимание,что при значении bigint результат усекается до целого числа.</target>
        </trans-unit>
        <trans-unit id="57f113ec30505dad704cf4b4934d930e547970b7" translate="yes" xml:space="preserve">
          <source>Note that under some systems, like OS/2, there may be different flavors of Perl executables, some of which may support fork, some not. Try changing the name you call Perl by to &lt;code&gt;perl_&lt;/code&gt; , &lt;code&gt;perl__&lt;/code&gt; , and so on.</source>
          <target state="translated">Обратите внимание, что в некоторых системах, таких как OS / 2, могут быть разные варианты исполняемых файлов Perl, некоторые из которых могут поддерживать fork, а некоторые нет. Попробуйте изменить имя, которое вы называете Perl, на &lt;code&gt;perl_&lt;/code&gt; , &lt;code&gt;perl__&lt;/code&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="6c3fb4d37b79c5b47a3b48e544166fc16ead2f30" translate="yes" xml:space="preserve">
          <source>Note that unfortunately none of the above constants are guaranteed to be available on a particular platform. To be on the safe side you can wrap the import in an eval like this:</source>
          <target state="translated">Обратите внимание,что,к сожалению,ни одна из вышеперечисленных констант не гарантируется на определенной платформе.Чтобы быть на всякий случай,вы можете обернуть импорт в оценочный документ,подобный этому:</target>
        </trans-unit>
        <trans-unit id="b70409449e4cf24aa93c5134b0fc7650b311f3ce" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;\s&lt;/code&gt; (and &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; ), &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; always match the same characters, without regard to other factors, such as the active locale or whether the source string is in UTF-8 format.</source>
          <target state="translated">Обратите внимание, что в отличие от &lt;code&gt;\s&lt;/code&gt; (и &lt;code&gt;\d&lt;/code&gt; и &lt;code&gt;\w&lt;/code&gt; ), &lt;code&gt;\h&lt;/code&gt; и &lt;code&gt;\v&lt;/code&gt; всегда соответствуют одним и тем же символам, независимо от других факторов, таких как активный языковой стандарт или то, имеет ли исходная строка формат UTF-8.</target>
        </trans-unit>
        <trans-unit id="4e3b99648e034c07d6ccefb2454f1a213adb3a01" translate="yes" xml:space="preserve">
          <source>Note that version 1.00 of the Safe module supported a second optional parameter, MASK. That functionality has been withdrawn pending deeper consideration. Use the permit and deny methods described below.</source>
          <target state="translated">Обратите внимание,что версия 1.00 модуля Safe поддерживала второй дополнительный параметр,MASK.Этот функционал был отозван в ожидании более глубокого рассмотрения.Используйте методы разрешения и отказа,описанные ниже.</target>
        </trans-unit>
        <trans-unit id="c573631a77e48c40f9d95496d1ab64657ba98bf8" translate="yes" xml:space="preserve">
          <source>Note that we now have to pass the cycling values as an array reference, since the &lt;code&gt;autotie&lt;/code&gt; mechanism passes &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; a list of arguments as a list (as in the Tie::Whatever example),</source>
          <target state="translated">Обратите внимание , что теперь мы должны передать значения задействуя в качестве ссылки на массив, так как &lt;code&gt;autotie&lt;/code&gt; механизм проходит &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; список аргументов в виде списка (как в примере Tie :: Whatever),</target>
        </trans-unit>
        <trans-unit id="97433e963bcde523d9d0fce2f4cd1302dfe4a201" translate="yes" xml:space="preserve">
          <source>Note that when a form of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; that doesn't include all categories is specified, Perl ignores the excluded categories.</source>
          <target state="translated">Обратите внимание, что когда указана форма &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , которая не включает все категории, Perl игнорирует исключенные категории.</target>
        </trans-unit>
        <trans-unit id="d5903fec6aa5f11cb69596fd7a3ca663ff0e5fa7" translate="yes" xml:space="preserve">
          <source>Note that when outputting to a file with streaming mode disabled (&lt;code&gt;Stream&lt;/code&gt; is 0), the output file must be seekable.</source>
          <target state="translated">Обратите внимание, что при выводе в файл с отключенным потоковым режимом ( &lt;code&gt;Stream&lt;/code&gt; равен 0) выходной файл должен быть доступен для поиска.</target>
        </trans-unit>
        <trans-unit id="7344bc816db754cd590cf06e917e5573598a9b73" translate="yes" xml:space="preserve">
          <source>Note that when the zlib sources are built along with this module the &lt;code&gt;&lt;a href=&quot;../../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; flags (bits 24, 25 and 26) should be ignored.</source>
          <target state="translated">Обратите внимание, что когда источники zlib собираются вместе с этим модулем, флаги &lt;code&gt;&lt;a href=&quot;../../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; (биты 24, 25 и 26) следует игнорировать.</target>
        </trans-unit>
        <trans-unit id="9c5df280c1345062d47399d4030c040fff592e61" translate="yes" xml:space="preserve">
          <source>Note that when there is only a section argument the URL will simply be a link to a section in the current document.</source>
          <target state="translated">Обратите внимание,что при наличии только аргумента секции URL будет просто ссылкой на секцию в текущем документе.</target>
        </trans-unit>
        <trans-unit id="71260102fd6d68816796fad6d6c8b41eba351c69" translate="yes" xml:space="preserve">
          <source>Note that when using perl in the default build configuration on Win32 (specifically, when perl is built with PERL_IMPLICIT_SYS), each perl interpreter maintains its own copy of the environment and only the main interpreter will update the process environment seen by strftime.</source>
          <target state="translated">Обратите внимание,что при использовании perl в конфигурации сборки по умолчанию на Win32 (а именно,когда perl собирается с PERL_IMPLICIT_SYS),каждый интерпретатор perl поддерживает свою собственную копию окружения,и только основной интерпретатор будет обновлять процессное окружение,видимое в strftime.</target>
        </trans-unit>
        <trans-unit id="2effebabf11283b202bbac0c8af96deb9da5f75f" translate="yes" xml:space="preserve">
          <source>Note that when using threads and in Linux this is &lt;b&gt;not&lt;/b&gt; a good way to exit a thread because in Linux processes and threads are kind of the same thing (Note: while this is the situation in early 2003 there are projects under way to have threads with more POSIXly semantics in Linux). If you want not to return from a thread, detach the thread.</source>
          <target state="translated">Обратите внимание, что при использовании потоков и в Linux это &lt;b&gt;не&lt;/b&gt; лучший способ выйти из потока, потому что в Linux процессы и потоки - это одно и то же (Примечание: хотя это и была ситуация в начале 2003 г., в настоящее время ведутся проекты с потоками с больше семантики POSIXly в Linux). Если вы не хотите возвращаться из нитки, отсоедините нить.</target>
        </trans-unit>
        <trans-unit id="4736a205597baa102d5326de4253133a227c54d5" translate="yes" xml:space="preserve">
          <source>Note that when you pass in a filehandle, the compression argument is ignored, as all files are printed verbatim to your filehandle. If you wish to enable compression with filehandles, use an &lt;code&gt;IO::Zlib&lt;/code&gt; or &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; filehandle instead.</source>
          <target state="translated">Обратите внимание, что когда вы передаете дескриптор файла, аргумент сжатия игнорируется, так как все файлы дословно выводятся на ваш дескриптор файла. Если вы хотите включить сжатие с помощью дескрипторов файлов, используйте вместо них дескрипторы файлов &lt;code&gt;IO::Zlib&lt;/code&gt; или &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fec466d7589681ffa02822a2ed4bde47bc9a77f7" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что перезапуск &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; после сигналов (скажем, SIGALRM) зависит от реализации. См. Также &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; для получения информации о переносимости &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="948671b067e6b6895231193e86d7353898979d1b" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что перезапуск &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; после сигналов (скажем, SIGALRM) зависит от реализации. См. Также &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; для получения информации о переносимости &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ffc7e69e46e535688eedc16caabf4a74055bdca" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;prove&lt;/code&gt; accepts a list of tests (or things to be tested), &lt;code&gt;new&lt;/code&gt; has a fairly rich set of arguments. You'll probably want to read over this code carefully to see how all of them are being used.</source>
          <target state="translated">Обратите внимание, что в то время как &lt;code&gt;prove&lt;/code&gt; принимает список тестов (или вещей, которые нужно протестировать), &lt;code&gt;new&lt;/code&gt; имеет довольно богатый набор аргументов. Вы, вероятно, захотите внимательно прочитать этот код, чтобы увидеть, как все они используются.</target>
        </trans-unit>
        <trans-unit id="50e7deab8f4fd86f8154084a7e3b56909e616473" translate="yes" xml:space="preserve">
          <source>Note that while the above category system is presently a strict hierarchy, this should not be assumed.</source>
          <target state="translated">Обратите внимание,что хотя в настоящее время система вышеуказанных категорий представляет собой строгую иерархию,это не следует предполагать.</target>
        </trans-unit>
        <trans-unit id="bc9931d84d19856544f694976f9d6846875a28cb" translate="yes" xml:space="preserve">
          <source>Note that while threads themselves are separate execution threads and Perl data is thread-private unless explicitly shared, the threads can affect process-scope state, affecting all the threads.</source>
          <target state="translated">Обратите внимание,что хотя потоки сами по себе являются отдельными потоками выполнения,а данные Perl являются потоково-частными,если они явно не разделяются,они могут влиять на состояние процесса,затрагивая все потоки.</target>
        </trans-unit>
        <trans-unit id="1aeee605f9778048bf8180ea5497c85eb816a43f" translate="yes" xml:space="preserve">
          <source>Note that while we obtained this value using a nice little script, there is no simple way to</source>
          <target state="translated">Обратите внимание,что хотя мы и получили это значение с помощью хорошего маленького скрипта,нет простого способа</target>
        </trans-unit>
        <trans-unit id="7977096f1b31f6699d5f208fb012da3a5261f7ca" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">Обратите внимание, что со списком в скобках &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; можно использовать в качестве фиктивного заполнителя, например, чтобы пропустить присвоение начальных значений:</target>
        </trans-unit>
        <trans-unit id="f05ed1d19fb4f3d163934a654b623969a521af79" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">Обратите внимание, что со списком в скобках &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; можно использовать в качестве фиктивного заполнителя, например, чтобы пропустить присвоение начальных значений:</target>
        </trans-unit>
        <trans-unit id="f837139e0f9184e4fee4005308a9ebc6c5173a19" translate="yes" xml:space="preserve">
          <source>Note that with all the above cases, you can determine which type of &quot;=over&quot; ... &quot;=back&quot; you have, by examining the first (non-&quot;=cut&quot;, non-&quot;=pod&quot;) Pod paragraph after the &quot;=over&quot; command.</source>
          <target state="translated">Обратите внимание,что во всех вышеперечисленных случаях можно определить,какой тип &quot;=over&quot; ...&quot;=назад&quot;,изучив первый (не &quot;=вырезать&quot;,не &quot;=под&quot;)абзац под после команды &quot;=over&quot;.</target>
        </trans-unit>
        <trans-unit id="47d723b6fa427f34bf483595a539dcd989378967" translate="yes" xml:space="preserve">
          <source>Note that write is</source>
          <target state="translated">Обратите внимание,что запись</target>
        </trans-unit>
        <trans-unit id="83605b35f7f66a38c8e887a3f52c350d6d00fd1c" translate="yes" xml:space="preserve">
          <source>Note that you</source>
          <target state="translated">Обратите внимание,что вы</target>
        </trans-unit>
        <trans-unit id="4c6cd8d5f09bd8fe8bd4f6cd6ec9d1cc03592811" translate="yes" xml:space="preserve">
          <source>Note that you always have to rethrow an exception that has been caught. Using these macros, it is not possible to just catch the exception and ignore it. If you have to ignore the exception, you have to use the &lt;code&gt;call_*&lt;/code&gt; function.</source>
          <target state="translated">Обратите внимание, что вы всегда должны повторно генерировать обнаруженное исключение. Используя эти макросы, невозможно просто поймать исключение и проигнорировать его. Если вам нужно игнорировать исключение, вы должны использовать функцию &lt;code&gt;call_*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="294ab6e75ddb8b55c12bca78ca4c1964234fee2f" translate="yes" xml:space="preserve">
          <source>Note that you can also apply two or more of the same type of filter in a single &lt;code&gt;FILTER_ONLY&lt;/code&gt; . For example, here's a simple macro-preprocessor that is only applied within regexes, with a final debugging pass that prints the resulting source code:</source>
          <target state="translated">Обратите внимание, что вы также можете применить два или несколько фильтров одного типа в одном &lt;code&gt;FILTER_ONLY&lt;/code&gt; . Например, вот простой макрос-препроцессор, который применяется только в регулярных выражениях, с последним проходом отладки, который печатает результирующий исходный код:</target>
        </trans-unit>
        <trans-unit id="2c7b682995e33f0fbc55867b39c415016eb6e0ab" translate="yes" xml:space="preserve">
          <source>Note that you can also call &lt;code&gt;batch_convert&lt;/code&gt; as a class method, like so:</source>
          <target state="translated">Обратите внимание, что вы также можете вызвать &lt;code&gt;batch_convert&lt;/code&gt; как метод класса, например:</target>
        </trans-unit>
        <trans-unit id="fd91cd131ba58a9a28d1ab6ce3c7b99f825d3515" translate="yes" xml:space="preserve">
          <source>Note that you can also use:</source>
          <target state="translated">Обратите внимание,что вы также можете использовать:</target>
        </trans-unit>
        <trans-unit id="7f681263fb98ec8c6eb8d4798ad8027fd4826097" translate="yes" xml:space="preserve">
          <source>Note that you can currently &lt;b&gt;not&lt;/b&gt; pass a &lt;code&gt;gzip&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Zlib&lt;/code&gt; , a &lt;code&gt;bzip2&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; , nor a string containing the full archive information (either compressed or uncompressed). These are worth while features, but not currently implemented. See the &lt;code&gt;TODO&lt;/code&gt; section.</source>
          <target state="translated">Обратите внимание , что вы можете в данный момент &lt;b&gt;не&lt;/b&gt; передать &lt;code&gt;gzip&lt;/code&gt; сжатого дескриптора файла, который не открыт &lt;code&gt;IO::Zlib&lt;/code&gt; , в &lt;code&gt;bzip2&lt;/code&gt; сжатом дескрипторе, который не открыт с &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; , ни строку , содержащую полную информацию архива (либо сжатый или несжатый). Это полезные функции, но в настоящее время они не реализованы. См. Раздел &lt;code&gt;TODO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5e3d8e2902a442515aac1df82a9b27598246cd6" translate="yes" xml:space="preserve">
          <source>Note that you can define your own properties; see &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties in perlunicode&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что вы можете определять свои собственные свойства; см. &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;Свойства определяемых пользователем символов в perlunicode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78e5ead015db87b26d2638e6d6d6c409fabb1756" translate="yes" xml:space="preserve">
          <source>Note that you can distinguish URL-links from anything else by the fact that they match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A\w+:[^:\s]\S*\z/&lt;/a&gt;&lt;/code&gt;. So &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.com&quot;&gt;http://www.perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; is a URL, but &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; isn't.</source>
          <target state="translated">Обратите внимание, что вы можете отличить URL-ссылки от всего остального по тому факту, что они соответствуют &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A\w+:[^:\s]\S*\z/&lt;/a&gt;&lt;/code&gt; . Итак, &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.com&quot;&gt;http://www.perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; - это URL, а &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="7fe488ce16efed40af87572587352aab8acda941" translate="yes" xml:space="preserve">
          <source>Note that you can modify the encoding of a file opened by File::Temp also by using C</source>
          <target state="translated">Обратите внимание,что вы можете изменить кодировку файла,открытого с помощью File::Temp,также используя C</target>
        </trans-unit>
        <trans-unit id="11456d05bc1241402ca1d0ee0660f0d072ab6bd4" translate="yes" xml:space="preserve">
          <source>Note that you can use the &lt;code&gt;ls&lt;/code&gt; command to get this path listed.</source>
          <target state="translated">Обратите внимание, что вы можете использовать команду &lt;code&gt;ls&lt;/code&gt; , чтобы получить этот путь в списке.</target>
        </trans-unit>
        <trans-unit id="a185692d5c427a3444515426bf12dadcf9d46376" translate="yes" xml:space="preserve">
          <source>Note that you can use this to nest &quot;todo&quot; tests</source>
          <target state="translated">Обратите внимание,что вы можете использовать это для гнездования &quot;todo&quot; тесты</target>
        </trans-unit>
        <trans-unit id="47332c504fbc5ef10c78203997d49e50906b8018" translate="yes" xml:space="preserve">
          <source>Note that you can't reliably block or unblock a signal from its own signal handler if you're using safe signals. Other signals can be blocked or unblocked reliably.</source>
          <target state="translated">Обратите внимание,что вы не можете надежно заблокировать или разблокировать сигнал от собственного обработчика сигналов,если вы используете безопасные сигналы.Другие сигналы могут быть надежно заблокированы или разблокированы.</target>
        </trans-unit>
        <trans-unit id="6eb3e27a2f3b6ca32cee54a3ce38dc4afb062aed" translate="yes" xml:space="preserve">
          <source>Note that you cannot do (de)composition and casing based solely on the</source>
          <target state="translated">Обратите внимание,что вы не можете сделать (де)композицию и оболочку,основанную исключительно на</target>
        </trans-unit>
        <trans-unit id="87645c57d8e0d5210e8d3327ae60dc3fe4c988b7" translate="yes" xml:space="preserve">
          <source>Note that you cannot explicitly unlock a variable; you can only wait for the lock to go out of scope. This is most easily accomplished by locking the variable inside a block.</source>
          <target state="translated">Обратите внимание,что вы не можете явно разблокировать переменную;вы можете только ждать,пока блокировка выйдет за пределы области видимости.Это легче всего сделать,заблокировав переменную внутри блока.</target>
        </trans-unit>
        <trans-unit id="34d896b03c45dc20f0fdc261eccf832e601b1f41" translate="yes" xml:space="preserve">
          <source>Note that you cannot test for &quot;&lt;code&gt;NaN&lt;/code&gt; -ness&quot; with</source>
          <target state="translated">Обратите внимание, что вы не можете проверить &quot; &lt;code&gt;NaN&lt;/code&gt; - способность&quot; с</target>
        </trans-unit>
        <trans-unit id="5b60fe993473449a8705a6ef4eab6f9f10003061" translate="yes" xml:space="preserve">
          <source>Note that you cannot use tags in @EXPORT or @EXPORT_OK.</source>
          <target state="translated">Обратите внимание,что нельзя использовать теги @ЭКСПОРТ или @ЭКСПОРТ_ОК.</target>
        </trans-unit>
        <trans-unit id="cfbfbe6c89dd9e56f5bfaf163b06f453c16310bb" translate="yes" xml:space="preserve">
          <source>Note that you don't (re-)specify the method name. It forces you to always use the same method name as the method you started in.</source>
          <target state="translated">Обратите внимание,что вы не (повторно)указываете имя метода.Это заставляет вас всегда использовать одно и то же имя метода,с которого вы начали.</target>
        </trans-unit>
        <trans-unit id="765ef1a0a25cf74eb1b9c1fc6e25a760175b0c75" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;code&gt;@ARGV&lt;/code&gt; yourself since &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">Обратите внимание, что вы не можете обрабатывать ошибки &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; таким образом с помощью дескриптора файла &lt;code&gt;ARGV&lt;/code&gt; . В этом случае вам нужно открыть каждый элемент &lt;code&gt;@ARGV&lt;/code&gt; самостоятельно, поскольку &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; обрабатывает &lt;code&gt;ARGV&lt;/code&gt; по- разному.</target>
        </trans-unit>
        <trans-unit id="1d0c63b615c2a51e338a797bd40525e8af9c8f78" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;code&gt;@ARGV&lt;/code&gt; yourself since &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">Обратите внимание, что вы не можете обрабатывать ошибки &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; таким образом с помощью дескриптора файла &lt;code&gt;ARGV&lt;/code&gt; . В этом случае вам нужно открыть каждый элемент &lt;code&gt;@ARGV&lt;/code&gt; самостоятельно, поскольку &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; обрабатывает &lt;code&gt;ARGV&lt;/code&gt; по- разному.</target>
        </trans-unit>
        <trans-unit id="ef1cce341436113e5004762f8ac2a05ec7a6cdad" translate="yes" xml:space="preserve">
          <source>Note that you may have things stored in a lexicon besides just phrases for output: for example, if your program takes input from the keyboard, asking a &quot;(Y/N)&quot; question, you probably need to know what the equivalent of &quot;Y[es]/N[o]&quot; is in whatever language. You probably also need to know what the equivalents of the answers &quot;y&quot; and &quot;n&quot; are. You can store that information in the lexicon (say, under the keys &quot;~answer_y&quot; and &quot;~answer_n&quot;, and the long forms as &quot;~answer_yes&quot; and &quot;~answer_no&quot;, where &quot;~&quot; is just an ad-hoc character meant to indicate to programmers/translators that these are not phrases for output).</source>
          <target state="translated">Обратите внимание,что вы можете хранить вещи в лексиконе,кроме фраз для вывода:например,если ваша программа принимает ввод с клавиатуры,задавая вопрос &quot;(Y/N)&quot;,вы,вероятно,должны знать,что эквивалент &quot;Y[es]/N[o]&quot; на любом языке.Скорее всего,вам также нужно знать,каков эквивалент ответов &quot;y&quot; и &quot;n&quot;.Вы можете хранить эту информацию в лексиконе (скажем,под клавишами &quot;~answer_y&quot; и &quot;~answer_n&quot;,а длинные формы &quot;~answer_yes&quot; и &quot;~answer_no&quot;,где &quot;~&quot;-это просто специальный символ,предназначенный для указания программистам/переводчикам,что это не фразы для вывода).</target>
        </trans-unit>
        <trans-unit id="f229bb516b77586e7a9a248bf3e0f062f311444b" translate="yes" xml:space="preserve">
          <source>Note that you may mix directories and (non-directory) files in the list of directories to be searched by the &lt;code&gt;wanted()&lt;/code&gt; function.</source>
          <target state="translated">Обратите внимание, что вы можете смешивать каталоги и (не каталоги) файлы в списке каталогов, в которых будет выполняться поиск с помощью функции &lt;code&gt;wanted()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cfd4a087008bc37d07992fd270addb262fb108e" translate="yes" xml:space="preserve">
          <source>Note that you might find it useful in some cases to override the &lt;code&gt;maketext&lt;/code&gt; method with an &quot;after method&quot;, if you want to translate encodings, or even scripts:</source>
          <target state="translated">Обратите внимание, что в некоторых случаях может оказаться полезным переопределить метод &lt;code&gt;maketext&lt;/code&gt; с помощью &amp;laquo;метода после&amp;raquo;, если вы хотите перевести кодировки или даже сценарии:</target>
        </trans-unit>
        <trans-unit id="253cba6289667637c7fd05a73ad1fdc58ca96c20" translate="yes" xml:space="preserve">
          <source>Note that you must specify a Unix path for $new_name, since per tar standard, all files in the archive must be Unix paths.</source>
          <target state="translated">Обратите внимание,что вы должны указать Unix путь для $new_name,так как по стандарту tar все файлы в архиве должны быть Unix пути.</target>
        </trans-unit>
        <trans-unit id="af5d3ffce4bc0322633d2e85550797429ad732a8" translate="yes" xml:space="preserve">
          <source>Note that you need to install the Module::Signature module to perform this operation.</source>
          <target state="translated">Обратите внимание,что для выполнения этой операции необходимо установить модуль Module::Signature.</target>
        </trans-unit>
        <trans-unit id="349c9f55c28f43dcb8274d29802632751096cca6" translate="yes" xml:space="preserve">
          <source>Note that you should load this module</source>
          <target state="translated">Обратите внимание,что вы должны загрузить этот модуль</target>
        </trans-unit>
        <trans-unit id="50670d23899cdfce7f241f0aebbebf124020da97" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the die operator is used to raise exceptions.</source>
          <target state="translated">Обратите внимание: поскольку &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; перехватывает фатальные ошибки, он полезен для определения того, реализована ли конкретная функция (например, &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; ). Это также механизм перехвата исключений Perl, в котором оператор die используется для генерации исключений.</target>
        </trans-unit>
        <trans-unit id="b4ffd3921a8026663ffc09712b83a83c559f1527" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the die operator is used to raise exceptions.</source>
          <target state="translated">Обратите внимание: поскольку &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; перехватывает фатальные ошибки, он полезен для определения того, реализована ли конкретная функция (например, &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; ). Это также механизм перехвата исключений Perl, в котором оператор die используется для генерации исключений.</target>
        </trans-unit>
        <trans-unit id="5209cab95dd7fa5e49fd362ada61a9529eae4cb7" translate="yes" xml:space="preserve">
          <source>Note that, because the &lt;code&gt;Cycle&lt;/code&gt; attribute receives its arguments in the &lt;code&gt;$data&lt;/code&gt; variable, if the attribute is given a list of arguments, &lt;code&gt;$data&lt;/code&gt; will consist of a single array reference; otherwise, it will consist of the single argument directly. Since Tie::Cycle requires its cycling values to be passed as an array reference, this means that we need to wrap non-array-reference arguments in an array constructor:</source>
          <target state="translated">Обратите внимание: поскольку атрибут &lt;code&gt;Cycle&lt;/code&gt; получает свои аргументы в переменной &lt;code&gt;$data&lt;/code&gt; , если атрибуту задан список аргументов, &lt;code&gt;$data&lt;/code&gt; будет состоять из единственной ссылки на массив; в противном случае он будет состоять непосредственно из одного аргумента. Поскольку Tie :: Cycle требует, чтобы его циклические значения передавались как ссылка на массив, это означает, что нам нужно обернуть аргументы, не являющиеся ссылками на массив, в конструктор массива:</target>
        </trans-unit>
        <trans-unit id="634d31438b7b96505dfbaf20bfb6d24a32edebe9" translate="yes" xml:space="preserve">
          <source>Note that, for historical compatibility, you can also use &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; instead of &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что для исторической совместимости вы также можете использовать &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; вместо &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc33ef9021f54e035b56392220cb3acd2d2873be" translate="yes" xml:space="preserve">
          <source>Note that, if you have options &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; , and auto_abbrev enabled, possible arguments and option settings are:</source>
          <target state="translated">Обратите внимание, что если у вас есть опции &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; и &lt;code&gt;all&lt;/code&gt; и включена auto_abbrev, возможные аргументы и настройки опции:</target>
        </trans-unit>
        <trans-unit id="35db5062a8071a77478be258b823dc93b2df8d08" translate="yes" xml:space="preserve">
          <source>Note that, if you wish to run Configure non-interactively (see the INSTALL document for details), to have it select the correct hint file, you'll need to provide the argument -Dhintfile=riscos on the Configure command-line.</source>
          <target state="translated">Обратите внимание,что если вы хотите запустить программу Configure не интерактивно (подробнее см.документ INSTALL),чтобы она выбрала правильный hint-файл,вам нужно указать аргумент -Dhintfile=riscos в командной строке Configure.</target>
        </trans-unit>
        <trans-unit id="8223fdc89d45104614b40e3adc04b113ea1e11a1" translate="yes" xml:space="preserve">
          <source>Note that, if your code is running under the recommended &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict
vars&lt;/code&gt; pragma, you will need to declare these package variables with &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание, что если ваш код работает в соответствии с рекомендуемой &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict vars&lt;/code&gt; &lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict vars , вам нужно будет объявить эти переменные пакета с помощью &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b910d090e427c58d2dd17debf4a1b8bec005d534" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt; , failed &lt;code&gt;when&lt;/code&gt; statements always evaluate to an empty list.</source>
          <target state="translated">Обратите внимание на то, что, в отличие от &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;unless&lt;/code&gt; , не удалось, &lt;code&gt;when&lt;/code&gt; операторы всегда вычисляют пустой список.</target>
        </trans-unit>
        <trans-unit id="7888ceb1fb70ed4eb88480b31893c674d725b49f" translate="yes" xml:space="preserve">
          <source>Note the</source>
          <target state="translated">Обратите внимание на</target>
        </trans-unit>
        <trans-unit id="b803d84dee50e438348a270e8179c619e96897b0" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;!&lt;/code&gt; after &lt;code&gt;l&lt;/code&gt; : We want to make sure that we pack a long integer as it is compiled by our C compiler. And even now, it will only work for the platforms where the compiler aligns things as above. And somebody somewhere has a platform where it doesn't. [Probably a Cray, where &lt;code&gt;short&lt;/code&gt; s, &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;long&lt;/code&gt; s are all 8 bytes. :-)]</source>
          <target state="translated">Обратите внимание на &lt;code&gt;!&lt;/code&gt; после &lt;code&gt;l&lt;/code&gt; : мы хотим убедиться, что мы упаковываем длинное целое число, поскольку оно скомпилировано нашим компилятором C. И даже сейчас это будет работать только для платформ, где компилятор выравнивает вещи, как указано выше. И у кого-то где-то есть платформа, а там ее нет. [Вероятно, Cray, где &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;long&lt;/code&gt; - 8 байтов. :-)]</target>
        </trans-unit>
        <trans-unit id="5b281c2225ddfa8f6c2dd45449bba50edd2d3238" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;$]&lt;/code&gt; in the above is not literal. Substitute whatever version of perl you want to honor that entry, e.g. &lt;code&gt;5.6.0&lt;/code&gt; . Paths must be separated with semicolons, as usual on Windows.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;$]&lt;/code&gt; в приведенном выше значении не является буквальным. Замените любую версию perl, которую вы хотите использовать для этой записи, например &lt;code&gt;5.6.0&lt;/code&gt; . Пути должны быть разделены точкой с запятой, как обычно в Windows.</target>
        </trans-unit>
        <trans-unit id="b760e9a6cdd73c2d052d5f85b1252a43b431d01a" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr//&lt;/a&gt;&lt;/code&gt; expression is surrounded by &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq{}&lt;/a&gt;&lt;/code&gt;. The idea behind this is the same as the classic idiom that makes &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 'interpolate':</source>
          <target state="translated">Обратите внимание, что выражение &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr//&lt;/a&gt;&lt;/code&gt; заключено в &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq{}&lt;/a&gt;&lt;/code&gt; . Идея, лежащая в основе этого, та же, что и в классической идиоме, которая заставляет &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; &amp;laquo;интерполировать&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="d4596391d7dda5f4358c63110663675e031494da" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;s: where autogeneration results in the method for a standard operator which does not change either of its operands, such as &lt;code&gt;-&lt;/code&gt; , being used to implement an operator which changes the operand (&quot;mutators&quot;: here, &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;-=&lt;/code&gt; ), Perl passes undef as the third argument. This still evaluates as FALSE, consistent with the fact that the operands have not been swapped, but gives the subroutine a chance to alter its behaviour in these cases.</source>
          <target state="translated">Обратите внимание на &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; s:, где автогенерация приводит к тому, что метод стандартного оператора, который не изменяет ни один из его операндов, например &lt;code&gt;-&lt;/code&gt; , используется для реализации оператора, который изменяет операнд (&amp;laquo;мутаторы&amp;raquo;: здесь &lt;code&gt;--&lt;/code&gt; и &lt;code&gt;-=&lt;/code&gt; ), Perl передает undef в качестве третьего аргумента. Это по-прежнему оценивается как ЛОЖЬ, что соответствует тому факту, что операнды не были переставлены местами, но дает подпрограмме возможность изменить свое поведение в этих случаях.</target>
        </trans-unit>
        <trans-unit id="19e6d5e5eedfcc869e45b8ad3dc4833107e51623" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; to do the reverse.</source>
          <target state="translated">Обратите внимание, что СПИСОК добавляется целиком, а не по одному элементу за раз, поэтому добавленные элементы остаются в том же порядке. Используйте &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; чтобы сделать обратное.</target>
        </trans-unit>
        <trans-unit id="0964c138a8a06a965bf091caaa6b9ea018efcb97" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;code&gt;&lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; to do the reverse.</source>
          <target state="translated">Обратите внимание, что СПИСОК добавляется целиком, а не по одному элементу за раз, поэтому добавленные элементы остаются в том же порядке. Используйте &lt;code&gt;&lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; чтобы сделать обратное.</target>
        </trans-unit>
        <trans-unit id="ddf2e42d261d53e754661957b5687c8859030118" translate="yes" xml:space="preserve">
          <source>Note the calls to PERL_SET_CONTEXT(). These are necessary to initialize the global state that tracks which interpreter is the &quot;current&quot; one on the particular process or thread that may be running it. It should always be used if you have more than one interpreter and are making perl API calls on both interpreters in an interleaved fashion.</source>
          <target state="translated">Обратите внимание на вызовы функции PERL_SET_CONTEXT().Они необходимы для инициализации глобального состояния,которое отслеживает,какой интерпретатор является &quot;текущим&quot; на конкретном процессе или потоке,который может его выполнять.Она всегда должна использоваться,если у вас более одного интерпретатора и вы делаете вызовы perl API на обоих интерпретаторах чередующимся образом.</target>
        </trans-unit>
        <trans-unit id="7596eda7b71ff20655d3bc34a84787b053200c0e" translate="yes" xml:space="preserve">
          <source>Note the gaps marked by &quot;*&quot; before several of the byte entries above. These are caused by legal UTF-8 avoiding non-shortest encodings: it is technically possible to UTF-8-encode a single code point in different ways, but that is explicitly forbidden, and the shortest possible encoding should always be used (and that is what Perl does).</source>
          <target state="translated">Обратите внимание на пробелы,отмеченные знаком &quot;*&quot; перед несколькими записями байтов выше.Это вызвано тем,что легальная кодировка UTF-8 избегает не самых коротких кодировок:технически возможно кодировать одну и ту же точку кода разными способами,но это явно запрещено,и всегда следует использовать как можно более короткую кодировку (и это то,что делает Perl).</target>
        </trans-unit>
        <trans-unit id="924291c98e268b7826585c54d3c30b3f0159b622" translate="yes" xml:space="preserve">
          <source>Note the semicolon. Except for the code inside not being immediately executed, a &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; is not so much a declaration as it is an operator, like &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt;. (However, no matter how many times you execute that particular line (unless you're in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval(&quot;...&quot;)&lt;/a&gt;&lt;/code&gt;), $coderef will still have a reference to the</source>
          <target state="translated">Обратите внимание на точку с запятой. За исключением того, что код внутри не выполняется немедленно, &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; - это не столько объявление, сколько оператор, например &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; . (Однако независимо от того, сколько раз вы выполняете эту конкретную строку (если только вы не находитесь в &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval(&quot;...&quot;)&lt;/a&gt;&lt;/code&gt; ), $ coderef все равно будет иметь ссылку на</target>
        </trans-unit>
        <trans-unit id="245f27d09730a3956ebd88bb73ed91d5802f1f14" translate="yes" xml:space="preserve">
          <source>Note the two following forms:</source>
          <target state="translated">Обратите внимание на две следующие формы:</target>
        </trans-unit>
        <trans-unit id="08a39ac9f8eb20d1bc0ac7dda6dd75ffb57ed8d8" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;$&lt;/code&gt; instead of &lt;code&gt;\&lt;/code&gt; in the last example. Unlike &lt;b&gt;sed&lt;/b&gt;, we use the \&amp;lt;</source>
          <target state="translated">Обратите внимание на использование &lt;code&gt;$&lt;/code&gt; вместо &lt;code&gt;\&lt;/code&gt; в последнем примере. В отличие от &lt;b&gt;sed&lt;/b&gt; , мы используем \ &amp;lt;</target>
        </trans-unit>
        <trans-unit id="845bd8d10b7b2e89645294c110cfa223e574f5d5" translate="yes" xml:space="preserve">
          <source>Note there are two distinct steps there: 1) You'll have to create Wild.pm and put it in your perl lib directory. 2) You'll need to set the PERL5OPT environment variable. If you want argv expansion to be the default, just set PERL5OPT in your default startup environment.</source>
          <target state="translated">Обратите внимание,что там есть два отдельных шага:1)Вы должны создать Wild.pm и поместить его в каталог perl lib.2)Вам нужно будет установить переменную окружения PERL5OPT.Если вы хотите,чтобы расширение argv было по умолчанию,просто установите переменную PERL5OPT в вашем стартовом окружении по умолчанию.</target>
        </trans-unit>
        <trans-unit id="44c0c7dc0dc0ee1847fe2547270344fd07547c80" translate="yes" xml:space="preserve">
          <source>Note this interface is strongly preferred over &lt;code&gt;gv_stashpvn&lt;/code&gt; for performance reasons.</source>
          <target state="translated">Обратите внимание, что этот интерфейс предпочтительнее &lt;code&gt;gv_stashpvn&lt;/code&gt; по соображениям производительности.</target>
        </trans-unit>
        <trans-unit id="3299aefdb3ce5c9a7bffd6e8e1b69e10b1bc969e" translate="yes" xml:space="preserve">
          <source>Note this is current as of patchlevel 0, and could change at any time.</source>
          <target state="translated">Обратите внимание,что он является текущим на уровне 0 патча и может измениться в любое время.</target>
        </trans-unit>
        <trans-unit id="43dee313ad9b91211c8c801e413c783a1b1c90d4" translate="yes" xml:space="preserve">
          <source>Note this may be also triggered for constructs like:</source>
          <target state="translated">Обратите внимание,что это также может быть вызвано для конструкций типа:</target>
        </trans-unit>
        <trans-unit id="479333dc136e44b8ccb0606732973018c80236a3" translate="yes" xml:space="preserve">
          <source>Note this move has made \x{D800}-\x{DFFF} into a forbidden zone but perl does not prohibit the use of characters within this range. To perl, every one of \x{0000_0000} up to \x{ffff_ffff} (*) is</source>
          <target state="translated">Обратите внимание,что этот шаг превратил \x{D800}-\x{DFFF}в запретную зону,но perl не запрещает использование символов в этом диапазоне.К perl,каждый из \x{0000_0000}до \x{ffff_ffff}.(*)это</target>
        </trans-unit>
        <trans-unit id="64c26fc0bfdd3e67c9ece7008879dc6d1a01b402" translate="yes" xml:space="preserve">
          <source>Note to those still using Perl 5.18 or earlier: The use of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; will slow down &lt;b&gt;all&lt;/b&gt; regex use within your program. Consult &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for &lt;code&gt;@-&lt;/code&gt; to see equivalent expressions that won't cause slow down. See also &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::SawAmpersand&quot;&gt;Devel::SawAmpersand&lt;/a&gt;. Starting with Perl 5.10, you can also use the equivalent variables &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , but for them to be defined, you have to specify the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier on your regular expression. In Perl 5.20, the use of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; makes no speed difference.</source>
          <target state="translated">Примечание для тех, кто все еще использует Perl 5.18 или более раннюю версию: использование &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; или &lt;code&gt;$'&lt;/code&gt; замедлит &lt;b&gt;любое&lt;/b&gt; использование регулярных выражений в вашей программе. Проконсультируйтесь с &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; для &lt;code&gt;@-&lt;/code&gt; чтобы увидеть эквивалентные выражения, которые не вызывают замедления. См. Также &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::SawAmpersand&quot;&gt;Devel :: SawAmpersand&lt;/a&gt; . Начиная с Perl 5.10, вы также можете использовать эквивалентные переменные &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; и &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , но для их определения вы должны указать модификатор &lt;code&gt;/p&lt;/code&gt; (сохранить) на вашем регулярное выражение. В Perl 5.20 использование &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; и &lt;code&gt;$'&lt;/code&gt; не имеет значения скорости.</target>
        </trans-unit>
        <trans-unit id="075a00b6d348d2bde80b54d266bd24c03289e88d" translate="yes" xml:space="preserve">
          <source>Note too that, when using the /x modifier on a regex, any comment containing the current pattern delimiter will cause the regex to be immediately terminated. In other words:</source>
          <target state="translated">Заметьте также,что при использовании модификатора /x в регексе,любой комментарий,содержащий текущий разделитель шаблонов,приведет к немедленному прекращению регекса.Другими словами:</target>
        </trans-unit>
        <trans-unit id="a9418a9be85583539aad52da154ad55780878583" translate="yes" xml:space="preserve">
          <source>Note, however, a &quot;=begin</source>
          <target state="translated">Обратите внимание,однако,на то,что &quot;=начаг</target>
        </trans-unit>
        <trans-unit id="6dfa7aab0d54b245f769489b5d31604d4926ff66" translate="yes" xml:space="preserve">
          <source>Note, however, that (unlike most other OO languages) Perl does not ensure or enforce encapsulation in any way. If you want objects to actually</source>
          <target state="translated">Обратите внимание,однако,что (в отличие от большинства других языков OO)Perl никоим образом не обеспечивает и не принуждает к инкапсуляции.Если вы хотите,чтобы объекты на самом деле</target>
        </trans-unit>
        <trans-unit id="9ee559bf7555e3380e5d318f57cb372ff9af8802" translate="yes" xml:space="preserve">
          <source>Note, however, that formatting codes and Z&amp;lt;&amp;gt;'s can occur in any and all parts of an L&amp;lt;...&amp;gt; (i.e., in</source>
          <target state="translated">Однако обратите внимание, что коды форматирования и Z &amp;lt;&amp;gt; могут встречаться в любой части L &amp;lt;...&amp;gt; (т. Е. В</target>
        </trans-unit>
        <trans-unit id="9e68e1c2898e4995bc610c38829131cae377e27c" translate="yes" xml:space="preserve">
          <source>Note, however, that this does not always work for quoting Perl code:</source>
          <target state="translated">Обратите внимание,однако,что это не всегда срабатывает при цитировании Perl-кода:</target>
        </trans-unit>
        <trans-unit id="daa40807202515240a11e4305fe2938d02dab24c" translate="yes" xml:space="preserve">
          <source>Note, however, that this restricts localization of some values ; for example, the following statement dies, as of perl 5.10.0, with an error</source>
          <target state="translated">Обратите внимание,однако,что это ограничивает локализацию некоторых значений;например,следующее утверждение умирает,начиная с версии 5.10.0,с ошибкой</target>
        </trans-unit>
        <trans-unit id="1d6b51a1f71c0a1abcbedef9280d1a614610364d" translate="yes" xml:space="preserve">
          <source>Note, incidentally, that items in each group are comma-separated, not &lt;code&gt;/\s*,\s*/&lt;/code&gt; -separated. That is, you might expect that this bracket group:</source>
          <target state="translated">Обратите внимание, кстати, что элементы в каждой группе разделены запятыми, а не &lt;code&gt;/\s*,\s*/&lt;/code&gt; . То есть можно было ожидать, что эта группа скобок:</target>
        </trans-unit>
        <trans-unit id="328da3257aa2be232f47d8215b8ce26d82b79a88" translate="yes" xml:space="preserve">
          <source>Note, it is possible for the version of a module to be unspecified, whereby the value is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, so use &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $version{$foo}{$bar}&lt;/code&gt; if that's what you're testing for.</source>
          <target state="translated">Обратите внимание: версия модуля может быть не указана, в результате чего значение равно &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , поэтому используйте &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $version{$foo}{$bar}&lt;/code&gt; если это то, что вы тестируете.</target>
        </trans-unit>
        <trans-unit id="59b95364ddb70e31cf0aeb6a61be710b24d1414c" translate="yes" xml:space="preserve">
          <source>Note, starting in Perl 5.18, the name &lt;code&gt;BELL&lt;/code&gt; refers to the Unicode character U+1F514, instead of the traditional U+0007. For the latter, use &lt;code&gt;ALERT&lt;/code&gt; or &lt;code&gt;BEL&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что начиная с Perl 5.18, имя &lt;code&gt;BELL&lt;/code&gt; относится к символу Unicode U + 1F514 вместо традиционного U + 0007. Для последнего используйте &lt;code&gt;ALERT&lt;/code&gt; или &lt;code&gt;BEL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bca239c5c2f598100f4661bdcb782662394e6f1d" translate="yes" xml:space="preserve">
          <source>Note, that in both cases the tilde expansion is done by MakeMaker, not by perl by default, nor by make.</source>
          <target state="translated">Обратите внимание,что в обоих случаях расширение тильды выполняется MakeMaker,а не perl по умолчанию и не make.</target>
        </trans-unit>
        <trans-unit id="2f4993e4338094ef439d0737bf034f424a4d5b79" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; by default.</source>
          <target state="translated">Обратите внимание, что эти константы не импортируются &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="36fe78df4850fd37cfbf75f0174f722ec0a6341e" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; by default.</source>
          <target state="translated">Обратите внимание, что эти константы не импортируются &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d62d5837f1b088899c2335c24b7fb00237a5b01e" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; by default.</source>
          <target state="translated">Обратите внимание, что эти константы не импортируются &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d3aba16133e84e8f9cf404e250371714dd197ffd" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; by default.</source>
          <target state="translated">Обратите внимание, что эти константы не импортируются &lt;code&gt;IO::Compress::Zip&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d20abe192a9c5b05ecdd8b5a009dcb0d1cc347b5" translate="yes" xml:space="preserve">
          <source>Note, use of &lt;code&gt;gv_stashsv&lt;/code&gt; instead of &lt;code&gt;gv_stashpvn&lt;/code&gt; where possible is strongly recommended for performance reasons.</source>
          <target state="translated">Обратите внимание: по возможности настоятельно рекомендуется использовать &lt;code&gt;gv_stashsv&lt;/code&gt; вместо gv_stashpvn из &lt;code&gt;gv_stashpvn&lt;/code&gt; производительности.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="858564b8eb505f163537f56838925cbe62eeb857" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; on directories is not supported on many operating systems. Use &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Примечание: &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; не будет пытаться удалить каталоги, если вы не являетесь суперпользователем и для Perl установлен флаг &lt;b&gt;-U&lt;/b&gt; . Даже если эти условия соблюдены, имейте в виду, что отключение каталога может нанести ущерб вашей файловой системе. Наконец, использование &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; для каталогов не поддерживается во многих операционных системах. Вместо этого используйте &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5634cda13018c382b3c15c0bf989c4dea07045c1" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; isn't needed in this example: &lt;code&gt;strftime()&lt;/code&gt; is a POSIX function which uses the standard system-supplied &lt;code&gt;libc&lt;/code&gt; function that always obeys the current &lt;code&gt;LC_TIME&lt;/code&gt; locale.</source>
          <target state="translated">Примечание: в этом примере &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; не нужно: &lt;code&gt;strftime()&lt;/code&gt; - это функция POSIX, которая использует стандартную системную функцию &lt;code&gt;libc&lt;/code&gt; , которая всегда подчиняется текущей локали &lt;code&gt;LC_TIME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd71952aea843bf37c94c0e84aec5e1493d8dd4a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; isn't shown in some of these examples because it isn't needed: &lt;code&gt;strcoll()&lt;/code&gt; and &lt;code&gt;strxfrm()&lt;/code&gt; are POSIX functions which use the standard system-supplied &lt;code&gt;libc&lt;/code&gt; functions that always obey the current &lt;code&gt;LC_COLLATE&lt;/code&gt; locale.</source>
          <target state="translated">Примечание: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; не показано в некоторых из этих примеров, потому что в этом нет необходимости: &lt;code&gt;strcoll()&lt;/code&gt; и &lt;code&gt;strxfrm()&lt;/code&gt; - это функции POSIX, которые используют стандартные системные функции &lt;code&gt;libc&lt;/code&gt; , которые всегда подчиняются текущей локали &lt;code&gt;LC_COLLATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89c514c1b9de7057dea402c8d0f5122402a932ba" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; on directories is not supported on many operating systems. Use &lt;code&gt;&lt;a href=&quot;rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Примечание: &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; не будет пытаться удалить каталоги, если вы не являетесь суперпользователем и для Perl установлен флаг &lt;b&gt;-U&lt;/b&gt; . Даже если эти условия соблюдены, имейте в виду, что отключение каталога может нанести ущерб вашей файловой системе. Наконец, использование &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; для каталогов не поддерживается во многих операционных системах. Вместо этого используйте &lt;code&gt;&lt;a href=&quot;rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07397ae9451cf5a436657d9cabd9f8d4563f40ae" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; will search the layers for a stdio layer. If it can't find one, it will call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; to generate a new stdio &lt;code&gt;FILE&lt;/code&gt; . Please only call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; if you want a</source>
          <target state="translated">Примечание: &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; будет искать слои для слоя stdio. Если он не может найти его, он вызовет &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; для создания нового stdio &lt;code&gt;FILE&lt;/code&gt; . Пожалуйста, вызывайте &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; если вам нужен</target>
        </trans-unit>
        <trans-unit id="f614956265c278721bb12432048ff10b5826efd9" translate="yes" xml:space="preserve">
          <source>Note: Be careful not to modify &lt;code&gt;@_&lt;/code&gt; at all before you call export_to_level - or people using your package will get very unexplained results!</source>
          <target state="translated">Примечание: будьте осторожны и не изменяйте &lt;code&gt;@_&lt;/code&gt; вообще перед вызовом export_to_level - иначе люди, использующие ваш пакет, получат очень необъяснимые результаты!</target>
        </trans-unit>
        <trans-unit id="fadfe11234c608cf2899bd38b718e46fd2406590" translate="yes" xml:space="preserve">
          <source>Note: Before 5.21.0, the &quot;missing&quot; lexical warnings category was internally defined to be the same as the &quot;uninitialized&quot; category. It is now a top-level category in its own right.</source>
          <target state="translated">Примечание:До версии 5.21.0 категория &quot;отсутствующих&quot; лексических предупреждений внутренне определялась как &quot;неинициализированная&quot;.Теперь она сама по себе является категорией высшего уровня.</target>
        </trans-unit>
        <trans-unit id="78023e67525e4c7a613335c235fa22e549b34845" translate="yes" xml:space="preserve">
          <source>Note: Before Perl 5.8.0, the lexical warnings category &quot;deprecated&quot; was a sub-category of the &quot;syntax&quot; category. It is now a top-level category in its own right.</source>
          <target state="translated">Замечание:До версии Perl 5.8.0 категория лексических предупреждений &quot;устарела&quot; была подкатегорией категории &quot;синтаксис&quot;.Теперь это категория высшего уровня.</target>
        </trans-unit>
        <trans-unit id="5227b82d031bced3044e91e5933630d59be9bc12" translate="yes" xml:space="preserve">
          <source>Note: Do not use a floating point nor a negative sign in &lt;code&gt;$code_point&lt;/code&gt; .</source>
          <target state="translated">Примечание. Не используйте в &lt;code&gt;$code_point&lt;/code&gt; знак с плавающей запятой или отрицательный знак .</target>
        </trans-unit>
        <trans-unit id="83d9951c1347109cd3bedbb4bb7306286ad1d212" translate="yes" xml:space="preserve">
          <source>Note: FCC is unique, as well as four normalization forms (NF*).</source>
          <target state="translated">Примечание:FCC уникальна,как и четыре формы нормализации (NF*).</target>
        </trans-unit>
        <trans-unit id="2bf5a1f9c5d972054186d3e42a82b7b324805893" translate="yes" xml:space="preserve">
          <source>Note: FCD is not always unique, then plural forms may be equivalent each other. &lt;code&gt;FCD()&lt;/code&gt; will return one of these equivalent forms.</source>
          <target state="translated">Примечание: FCD не всегда уникален, тогда формы множественного числа могут быть эквивалентны друг другу. &lt;code&gt;FCD()&lt;/code&gt; вернет одну из этих эквивалентных форм.</target>
        </trans-unit>
        <trans-unit id="56040f615b41a7064a5ef1844f423d8b9a40f330" translate="yes" xml:space="preserve">
          <source>Note: For some extensions, Dave Beazley's SWIG system may provide a significantly more convenient mechanism for creating the extension glue code. See &lt;a href=&quot;http://www.swig.org/&quot;&gt;http://www.swig.org/&lt;/a&gt; for more information.</source>
          <target state="translated">Примечание. Для некоторых расширений система SWIG Дэйва Бизли может предоставить значительно более удобный механизм для создания связующего кода расширения. См. &lt;a href=&quot;http://www.swig.org/&quot;&gt;Http://www.swig.org/&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="b1211fe58a903b5165f5edc276c715ceb521df1e" translate="yes" xml:space="preserve">
          <source>Note: From Mac OS X 10.6 &quot;Snow Leopard&quot; onwards, Apple only supports Intel-based hardware. This means you can safely skip this section unless you have an older Apple computer running on ppc or wish to create a perl binary with backwards compatibility.</source>
          <target state="translated">Примечание:Начиная с Mac OS X 10.6 &quot;Snow Leopard&quot;,Apple поддерживает только аппаратное обеспечение на базе Intel.Это означает,что вы можете безопасно пропустить этот раздел,если у вас нет старого компьютера Apple,работающего на ppc,или если вы не хотите создать двоичный файл perl с обратной совместимостью.</target>
        </trans-unit>
        <trans-unit id="743600644f11d3e8a913feb2e46d0252bdc64043" translate="yes" xml:space="preserve">
          <source>Note: If a string is not in FCD, it must not be in FCC. So &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; should return &lt;code&gt;NO&lt;/code&gt; .</source>
          <target state="translated">Примечание. Если строка не находится в FCD, она не должна входить в FCC. Поэтому &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; должен вернуть &lt;code&gt;NO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b01b3e05bd18ecfe427fbadc48a1cf9f4918f8c" translate="yes" xml:space="preserve">
          <source>Note: If you turn on &lt;code&gt;Sparseseen&lt;/code&gt; , then you must not rely on the content of the seen hash since its contents will be an implementation detail!</source>
          <target state="translated">Примечание: если вы включите &lt;code&gt;Sparseseen&lt;/code&gt; , вы не должны полагаться на содержимое увиденного хэша, поскольку его содержимое будет деталью реализации!</target>
        </trans-unit>
        <trans-unit id="a3278502ab348386cdc09a185533e7816e62b07e" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">Примечание. Многие люди склонны злоупотреблять &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; а затем с удивлением обнаруживают, что число &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;&quot;&quot;&lt;/code&gt; (строка нулевой длины) на самом деле являются определенными значениями. Например, если вы скажете</target>
        </trans-unit>
        <trans-unit id="72cf554b1f74abf911508263cf2a354d76fd9f1a" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">Примечание. Многие люди склонны злоупотреблять &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; а затем с удивлением обнаруживают, что число &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;&quot;&quot;&lt;/code&gt; (строка нулевой длины) на самом деле являются определенными значениями. Например, если вы скажете</target>
        </trans-unit>
        <trans-unit id="a4c4e917877757fb6fc83b2e0f19ffc51d5f6fc8" translate="yes" xml:space="preserve">
          <source>Note: Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; function returns four values, measured in seconds.</source>
          <target state="translated">Примечание: встроенная функция Perl &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; возвращает четыре значения, измеряемых в секундах.</target>
        </trans-unit>
        <trans-unit id="193ad56c42c8c5022f417eca20124d2510809ef1" translate="yes" xml:space="preserve">
          <source>Note: Some folks colloquially refer to this bit of punctuation as a &quot;yada-yada&quot; or &quot;triple-dot&quot;, but its true name is actually an ellipsis.</source>
          <target state="translated">Примечание:Некоторые люди в разговорной речи называют этот бит пунктуации &quot;яда-яда&quot; или &quot;тройная точка&quot;,но на самом деле его истинное название-эллипсис.</target>
        </trans-unit>
        <trans-unit id="c9a4ed3733a9eeadde05bd081437b7ba9d5fa627" translate="yes" xml:space="preserve">
          <source>Note: Some modules downloaded from CPAN may require NetWare related API in order to build on NetWare. Other modules may however build smoothly with or without minor changes depending on the type of module.</source>
          <target state="translated">Примечание:Для некоторых модулей,загруженных из CPAN,может потребоваться API,связанный с NetWare,чтобы построить его на основе NetWare.Другие модули,однако,могут собираться плавно,с небольшими изменениями или без них,в зависимости от типа модуля.</target>
        </trans-unit>
        <trans-unit id="e33603b6b52bf5831bfb6cf75b5a9f26f72dc686" translate="yes" xml:space="preserve">
          <source>Note: Some sites have reported problems when using the file-access tests (&lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; ) on files accessed via DEC's DFS. Specifically, since DFS does not currently provide access to the extended file header of files on remote volumes, attempts to examine the ACL fail, and the file tests will return false, with &lt;code&gt;$!&lt;/code&gt; indicating that the file does not exist. You can use &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; on these files, since that checks UIC-based protection only, and then manually check the appropriate bits, as defined by your C compiler's</source>
          <target state="translated">Примечание. Некоторые сайты сообщают о проблемах при использовании тестов доступа к файлам ( &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; и &lt;code&gt;-x&lt;/code&gt; ) для файлов, доступ к которым осуществляется через DFS DEC. В частности, поскольку DFS в настоящее время не предоставляет доступ к расширенному заголовку файлов на удаленных томах, попытки проверки ACL завершаются неудачно, и тесты файлов возвращают false с &lt;code&gt;$!&lt;/code&gt; указывает на то, что файл не существует. Вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; для этих файлов, поскольку он проверяет только защиту на основе UIC, а затем вручную проверяет соответствующие биты, как определено вашим компилятором C</target>
        </trans-unit>
        <trans-unit id="5b6f6c7fe8a37aa2c65de3e3c606a0b439080ba4" translate="yes" xml:space="preserve">
          <source>Note: Some vendors supply &lt;code&gt;strtod()&lt;/code&gt; and &lt;code&gt;strtol()&lt;/code&gt; but not &lt;code&gt;strtoul()&lt;/code&gt; . Other vendors that do supply &lt;code&gt;strtoul()&lt;/code&gt; parse &quot;-1&quot; as a valid value.</source>
          <target state="translated">Примечание. Некоторые поставщики предоставляют &lt;code&gt;strtod()&lt;/code&gt; и &lt;code&gt;strtol()&lt;/code&gt; но не &lt;code&gt;strtoul()&lt;/code&gt; . Другие поставщики, которые предоставляют &lt;code&gt;strtoul()&lt;/code&gt; анализируют &quot;-1&quot; как допустимое значение.</target>
        </trans-unit>
        <trans-unit id="e2d1626493358bc3d857173bc6af6ddd2a5fc2da" translate="yes" xml:space="preserve">
          <source>Note: The iterator (&lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ) and file test (&lt;code&gt;'-X'&lt;/code&gt; ) operators work as normal: if the operand is not a blessed glob or IO reference then it is converted to a string (using the method for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; , or &lt;code&gt;'bool'&lt;/code&gt; ) to be interpreted as a glob or filename.</source>
          <target state="translated">Примечание. Операторы итератора ( &lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ) и проверки файла ( &lt;code&gt;'-X'&lt;/code&gt; ) работают как обычно: если операнд не является благословенным глобусом или ссылкой ввода-вывода, он преобразуется в строку (с использованием метода для &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; или &lt;code&gt;'bool'&lt;/code&gt; ) для интерпретации как глобус или имя файла.</target>
        </trans-unit>
        <trans-unit id="9a7724723655fcca925e8e2780cbc470ea823e12" translate="yes" xml:space="preserve">
          <source>Note: The keyword 'lib' will warn when the requested library could not be loaded. To suppress the warning use 'try' instead:</source>
          <target state="translated">Замечание:Ключевое слово 'lib' предупредит,когда запрашиваемая библиотека не может быть загружена.Для подавления предупреждения используйте 'try':</target>
        </trans-unit>
        <trans-unit id="7834aa58e75e083860df15db52ef81cbd8591c51" translate="yes" xml:space="preserve">
          <source>Note: The list &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; returns has originated from your current perl and your current install.</source>
          <target state="translated">Примечание: В списке &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; возвращения возникла из текущего Perl и текущая установка.</target>
        </trans-unit>
        <trans-unit id="9e555e53c6f7ef659bcb517427e72585e148bddc" translate="yes" xml:space="preserve">
          <source>Note: The policy of using locale rules for code points that can fit in a byte, and Unicode rules for those that can't is not uniformly applied. Pre-v5.12, it was somewhat haphazard; in v5.12 it was applied fairly consistently to regular expression matching except for bracketed character classes; in v5.14 it was extended to all regex matches; and in v5.16 to the casing operations such as &lt;code&gt;\L&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;. For collation, in all releases so far, the system's &lt;code&gt;strxfrm()&lt;/code&gt; function is called, and whatever it does is what you get.</source>
          <target state="translated">Примечание. Политика использования правил локали для кодовых точек, которые могут умещаться в байтах, и правил Unicode для тех, которые не могут уместиться, не применяется единообразно. До версии 5.12 это было несколько случайно; в v5.12 он довольно последовательно применялся к сопоставлению регулярных выражений, за исключением классов символов в квадратных скобках; в v5.14 он был расширен на все совпадения регулярных выражений; а в v5.16 - к операциям с регистром, таким как &lt;code&gt;\L&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; . Для сопоставления во всех выпусках до сих пор вызывается системная функция &lt;code&gt;strxfrm()&lt;/code&gt; , и все, что она делает, вы получаете.</target>
        </trans-unit>
        <trans-unit id="f932c6f37410ce4ebff00172ee521c9f04d25563" translate="yes" xml:space="preserve">
          <source>Note: This feature was introduced in version 5.57 of Exporter, released with perl 5.8.3.</source>
          <target state="translated">Замечание:Эта функция была представлена в версии 5.57 Exporter,выпущенной на perl 5.8.3.</target>
        </trans-unit>
        <trans-unit id="cd489e52bffb55133a04f9392b0cef79b71a84a0" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; . Any other character than &lt;code&gt;U+FFFE&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt; .</source>
          <target state="translated">Примечание. Это эквивалентно &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; . Любой другой символ, кроме &lt;code&gt;U+FFFE&lt;/code&gt; , может быть изменен &lt;code&gt;entry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e524e8ba90f8c2eceff3ee2b4fe18bbc36f721be" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; . Any other character than &lt;code&gt;U+FFFF&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt; .</source>
          <target state="translated">Примечание. Это эквивалентно &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; . Любой другой символ, кроме &lt;code&gt;U+FFFF&lt;/code&gt; , может быть изменен &lt;code&gt;entry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0455de4d41cf68eed0be49449f753fd507ce98c3" translate="yes" xml:space="preserve">
          <source>Note: This method is only available if you are running zlib 1.0.6 or better.</source>
          <target state="translated">Примечание:Этот метод доступен только если вы используете zlib 1.0.6 или лучше.</target>
        </trans-unit>
        <trans-unit id="d780f7fe644c15c8098f2ec3e635333d65dac99d" translate="yes" xml:space="preserve">
          <source>Note: This method was required from Math::BigInt version 1.78, but the required API version number was not incremented, so there are older libraries that support API version 1, but do not support &lt;code&gt;_as_oct()&lt;/code&gt; .</source>
          <target state="translated">Примечание. Этот метод требовался от Math :: BigInt версии 1.78, но требуемый номер версии API не был увеличен, поэтому существуют более старые библиотеки, которые поддерживают API версии 1, но не поддерживают &lt;code&gt;_as_oct()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="274ea739a039d51482491c2164a8ca995639e789" translate="yes" xml:space="preserve">
          <source>Note: This needs Math::BigInt::GMP installed.</source>
          <target state="translated">Примечание:Для этого необходимо установить Math::BigInt::GMP.</target>
        </trans-unit>
        <trans-unit id="4599f377b1aba694d82426f6489f702538a8bb33" translate="yes" xml:space="preserve">
          <source>Note: When $FTP_PASSIVE is true, &lt;code&gt;ncftp&lt;/code&gt; will not be used to fetch files, since passive mode can only be set interactively for this binary</source>
          <target state="translated">Примечание: если $ FTP_PASSIVE истинно, &lt;code&gt;ncftp&lt;/code&gt; не будет использоваться для выборки файлов, так как пассивный режим может быть установлен только интерактивно для этого двоичного файла.</target>
        </trans-unit>
        <trans-unit id="44108fdd62b6b987695d83d0e866909c28a68c2f" translate="yes" xml:space="preserve">
          <source>Note: When called in list context, $isdst, the last value returned by gmtime, is always &lt;code&gt;0&lt;/code&gt; . There is no Daylight Saving Time in GMT.</source>
          <target state="translated">Примечание. При вызове в контексте списка $ isdst, последнее значение, возвращаемое gmtime, всегда равно &lt;code&gt;0&lt;/code&gt; . В GMT нет перехода на летнее время.</target>
        </trans-unit>
        <trans-unit id="326b015af2e44c2db6ac3ed72580a47dac6e9403" translate="yes" xml:space="preserve">
          <source>Note: Works also for subclasses like &lt;a href=&quot;bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;. Each class has its own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">Примечание: работает также для подклассов, таких как &lt;a href=&quot;bigfloat&quot;&gt;Math :: BigFloat&lt;/a&gt; . Каждый класс имеет свои собственные глобальные переменные, отделенные от Math :: BigInt, но можно создать подкласс Math :: BigInt и сделать глобальные переменные псевдонимов подкласса аналогами из Math :: BigInt.</target>
        </trans-unit>
        <trans-unit id="f017c3d2e2508b08d7d59dc7727c02f156768d30" translate="yes" xml:space="preserve">
          <source>Note: Works also for subclasses like Math::BigFloat. Each class has it's own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">Примечание:Работает также для подклассов типа Math::BigFloat.Каждый класс имеет свои глобусы,отделенные от Math::BigInt,но можно сделать подкласс Math::BigInt и сделать глобусы подкласса псевдонимами Math::BigInt.</target>
        </trans-unit>
        <trans-unit id="eb7b6e328c4f81408ff1a139ac8eaf2a380ca671" translate="yes" xml:space="preserve">
          <source>Note: You have to modify your man.conf file to search for manpages in the /ade/lib/perl5/man/man3 directory, or the man pages for the perl library will not be found.</source>
          <target state="translated">Замечание:Вы должны изменить ваш man.conf файл для поиска man-страниц в каталоге /ade/lib/perl5/man/man3,иначе man-страницы для библиотеки perl не будут найдены.</target>
        </trans-unit>
        <trans-unit id="1e7dc83f4d6c9a8b0d3c0b5924caf0806f95cf13" translate="yes" xml:space="preserve">
          <source>Note: You probably want to use &lt;a href=&quot;#accuracy()&quot;&gt;accuracy()&lt;/a&gt; instead. With &lt;a href=&quot;#accuracy()&quot;&gt;accuracy()&lt;/a&gt; you set the number of digits each result should have, with &lt;a href=&quot;#precision()&quot;&gt;precision()&lt;/a&gt; you set the place where to round!</source>
          <target state="translated">Примечание: вы, вероятно, захотите вместо этого использовать &lt;a href=&quot;#accuracy()&quot;&gt;precision ()&lt;/a&gt; . С &lt;a href=&quot;#accuracy()&quot;&gt;точностью ()&lt;/a&gt; вы установите количество цифр каждый результат должен иметь, с &lt;a href=&quot;#precision()&quot;&gt;точностью ()&lt;/a&gt; вы установили место , где круглый!</target>
        </trans-unit>
        <trans-unit id="e2e12b5547fb4733f2385741dc84813859d3dd2e" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling&lt;/code&gt; also disables &lt;code&gt;bundling_override&lt;/code&gt; .</source>
          <target state="translated">Примечание: отключение &lt;code&gt;bundling&lt;/code&gt; также отключает &lt;code&gt;bundling_override&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dd410d2fbf3af306729dd64454481dab1a79d72" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling_override&lt;/code&gt; also disables &lt;code&gt;bundling&lt;/code&gt; .</source>
          <target state="translated">Примечание: отключение &lt;code&gt;bundling_override&lt;/code&gt; также отключает &lt;code&gt;bundling&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d840b005bb09f5240a311bf0713bd815028ba795" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case&lt;/code&gt; also disables &lt;code&gt;ignore_case_always&lt;/code&gt; .</source>
          <target state="translated">Примечание: отключение &lt;code&gt;ignore_case&lt;/code&gt; также отключает &lt;code&gt;ignore_case_always&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0642b203ace91a0c6c6c1c85ec87408d95d51b9c" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case_always&lt;/code&gt; also disables &lt;code&gt;ignore_case&lt;/code&gt; .</source>
          <target state="translated">Примечание: отключение &lt;code&gt;ignore_case_always&lt;/code&gt; также отключает &lt;code&gt;ignore_case&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc88cd76d85c82ca33031114b858a78699d8dccf" translate="yes" xml:space="preserve">
          <source>Note: if the &lt;code&gt;applypatch&lt;/code&gt; program is installed and &lt;code&gt;CPAN::Config&lt;/code&gt; knows about it &lt;b&gt;and&lt;/b&gt; a patch is written by the &lt;code&gt;makepatch&lt;/code&gt; program, then &lt;code&gt;CPAN.pm&lt;/code&gt; lets &lt;code&gt;applypatch&lt;/code&gt; apply the patch. Both &lt;code&gt;makepatch&lt;/code&gt; and &lt;code&gt;applypatch&lt;/code&gt; are available from CPAN in the &lt;code&gt;JV/makepatch-*&lt;/code&gt; distribution.</source>
          <target state="translated">Примечание: если &lt;code&gt;applypatch&lt;/code&gt; установлена программа и &lt;code&gt;CPAN::Config&lt;/code&gt; знает об этом &lt;b&gt;и&lt;/b&gt; патч написан &lt;code&gt;makepatch&lt;/code&gt; программы, затем &lt;code&gt;CPAN.pm&lt;/code&gt; позволяет &lt;code&gt;applypatch&lt;/code&gt; применить патч. И &lt;code&gt;makepatch&lt;/code&gt; , и &lt;code&gt;applypatch&lt;/code&gt; доступны на CPAN в дистрибутиве &lt;code&gt;JV/makepatch-*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22e2016ea85ed84ee62e9e8de3756c81d1bdf26a" translate="yes" xml:space="preserve">
          <source>Note: if the computation is expensive or the hash has many elements, you may want to look at the Schwartzian Transform to cache the computation results.</source>
          <target state="translated">Замечание:если вычисления дорогие или в хэше много элементов,вы можете посмотреть на преобразование Шварцца для кэширования результатов вычислений.</target>
        </trans-unit>
        <trans-unit id="3a9aff6bff93b9cbae48137737db8e4d2881dc6a" translate="yes" xml:space="preserve">
          <source>Note: in most cases, particularly the &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;, this is unlikely to be appropriate behaviour.</source>
          <target state="translated">Примечание: в большинстве случаев, особенно в &lt;a href=&quot;#Copy-Constructor&quot;&gt;конструкторе копирования&lt;/a&gt; , такое поведение вряд ли будет подходящим.</target>
        </trans-unit>
        <trans-unit id="9947057045b064f583a71d886808757ed0fa7848" translate="yes" xml:space="preserve">
          <source>Note: the behaviour described in this section can be disabled by setting &lt;code&gt;fallback&lt;/code&gt; to FALSE (see &lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt;).</source>
          <target state="translated">Примечание: поведение, описанное в этом разделе, можно отключить, установив для &lt;code&gt;fallback&lt;/code&gt; значение FALSE (см. &lt;a href=&quot;#fallback&quot;&gt;Откат&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ac4c5c965d1db592391a1881313b9980c7ebcd67" translate="yes" xml:space="preserve">
          <source>Note: the preceding paragraph describes what happens when Perl autogenerates the copy constructor for an object based on a scalar. For other cases, see &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;.</source>
          <target state="translated">Примечание: в предыдущем абзаце описывается, что происходит, когда Perl автоматически генерирует конструктор копирования для объекта на основе скаляра. Для других случаев см. &lt;a href=&quot;#Copy-Constructor&quot;&gt;Конструктор копирования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c92c751ce0bf80febdd6e38233f67cab09e15ef" translate="yes" xml:space="preserve">
          <source>Note: this config variable is deprecated and will be removed in a future version of CPAN.pm. It will be replaced with the conventions around the family of $LANG and $LC_* environment variables.</source>
          <target state="translated">Замечание:эта переменная конфигурации устарела и будет удалена в будущей версии CPAN.pm.Она будет заменена соглашениями вокруг семейства переменных окружения $LANG и $LC_*.</target>
        </trans-unit>
        <trans-unit id="f59653e6422c3ee295a49f06549f34191c33d033" translate="yes" xml:space="preserve">
          <source>Note: this feature is still in alpha state and may change in future versions of CPAN.pm</source>
          <target state="translated">Примечание:эта функция все еще находится в альфа-состоянии и может измениться в будущих версиях CPAN.pm.</target>
        </trans-unit>
        <trans-unit id="8a8ebc616c42eb9b0dd9d07b466e6d2d32bcecea" translate="yes" xml:space="preserve">
          <source>Note: this is a reasonably new addition to the family of socket functions, so all systems may not support this yet. If it is unsupported by the system, an attempt to use this method will abort the program.</source>
          <target state="translated">Примечание:это достаточно новое дополнение к семейству функций сокетов,поэтому все системы могут его пока не поддерживать.Если оно не поддерживается системой,попытка использования этого метода приведет к прерыванию работы программы.</target>
        </trans-unit>
        <trans-unit id="b27494dc8cf34b92a043ab41a4f74f0c9f2a3ea4" translate="yes" xml:space="preserve">
          <source>Note: this mechanism is not used when use_sqlite is on and SQLLite is running.</source>
          <target state="translated">Замечание:этот механизм не используется,когда включена функция use_sqlite и запущен SQLLite.</target>
        </trans-unit>
        <trans-unit id="13c903538586e11c4ad7bb5502c59a872fdcc9eb" translate="yes" xml:space="preserve">
          <source>Note: this method of setting config variables often provides more explanation about the functioning of a variable than the manpage.</source>
          <target state="translated">Замечание:этот метод настройки конфигурационных переменных часто дает больше объяснений о функционировании переменной,чем manpage.</target>
        </trans-unit>
        <trans-unit id="20d6330232e8dab848178ce084694142fca2d628" translate="yes" xml:space="preserve">
          <source>Note: you can define up to 20 conversion shortcuts in the gdb section.</source>
          <target state="translated">Примечание:вы можете определить до 20 ярлыков преобразования в разделе gdb.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="87cfdde76898dd31c7d07ddb886016189457f68b" translate="yes" xml:space="preserve">
          <source>Notes for users of Compress::Zlib version 1</source>
          <target state="translated">Примечания для пользователей Compress::Zlib версия 1</target>
        </trans-unit>
        <trans-unit id="d65415edefc0ebcdd623f3ba5f7c329eeb91e917" translate="yes" xml:space="preserve">
          <source>Notes on Implementing Pod Processors</source>
          <target state="translated">Примечания по внедрению процессоров стручки</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="25796957df5d5e9f79fe37e61f8cb9ca4c5a759a" translate="yes" xml:space="preserve">
          <source>Nothing in void context (obviously).</source>
          <target state="translated">Ничего в пустом контексте (очевидно).</target>
        </trans-unit>
        <trans-unit id="945c9d82ead4c25705962fc07336d3f2e51d1d62" translate="yes" xml:space="preserve">
          <source>Nothing is documented.</source>
          <target state="translated">Ничего не задокументировано.</target>
        </trans-unit>
        <trans-unit id="ab9e54f52e7f7c5402697de9fbd9467e290f0479" translate="yes" xml:space="preserve">
          <source>Nothing too unusual here. You can easily do this if you have a cross-compiler available; A usual Configure invocation when targetting a Solaris x86 looks something like this:</source>
          <target state="translated">Здесь нет ничего необычного.Вы можете легко сделать это,если у вас есть доступный кросс-компилятор;Обычный вызов Configure при нацеливании на Solaris x86 выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="a7b38ed2457b5a248dfea4058e6120cef0a01220" translate="yes" xml:space="preserve">
          <source>Nothing worked - die.</source>
          <target state="translated">Ничего не сработало-умри.</target>
        </trans-unit>
        <trans-unit id="1b3f141ab87179d0755abc1d4da67f0c04e3ab7c" translate="yes" xml:space="preserve">
          <source>Nothing.</source>
          <target state="translated">Nothing.</target>
        </trans-unit>
        <trans-unit id="df845adff4c3af8c8d0292f7522181ec1444d9f8" translate="yes" xml:space="preserve">
          <source>Notice also that the warning is reported at the line where the object is first used.</source>
          <target state="translated">Обратите также внимание,что предупреждение сообщается в строке,где объект впервые используется.</target>
        </trans-unit>
        <trans-unit id="45dd83b2a71782cbd9802b63f62a266f8d43184c" translate="yes" xml:space="preserve">
          <source>Notice also the &lt;code&gt;grok_bin&lt;/code&gt; , &lt;code&gt;grok_hex&lt;/code&gt; , and &lt;code&gt;grok_oct&lt;/code&gt; functions in</source>
          <target state="translated">Обратите также внимание на функции &lt;code&gt;grok_bin&lt;/code&gt; , &lt;code&gt;grok_hex&lt;/code&gt; и &lt;code&gt;grok_oct&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="b0adcbd1247e60edf664089189052bb3a50dcbe1" translate="yes" xml:space="preserve">
          <source>Notice here the LEN is 10. (It may differ on your platform.) Extend the length of the string to one less than 10, and do a substitution:</source>
          <target state="translated">Обратите внимание,что ЛЕН 10.(Она может отличаться на вашей платформе.)Увеличьте длину строки до одного меньше 10 и сделайте замену:</target>
        </trans-unit>
        <trans-unit id="4c9ef71a088f9de85175aa974029dc0d63466c4b" translate="yes" xml:space="preserve">
          <source>Notice how at no point does the value &quot;private&quot; get printed. That's because $var only has that value within the block of the lexical() function, and it is hidden from the called subroutine.</source>
          <target state="translated">Заметьте,как ни в коем случае не печатается значение &quot;частное&quot;.Это потому,что $var имеет это значение только в блоке функции lexical(),и оно скрыто от вызываемой подпрограммы.</target>
        </trans-unit>
        <trans-unit id="77c47c9daa0e34a0be8b051a194ec532aabac71d" translate="yes" xml:space="preserve">
          <source>Notice how both parameters to &lt;code&gt;globmap&lt;/code&gt; are strings that are delimited by &amp;lt;&amp;gt;. This is done to make them look more like file globs - it is just syntactic sugar, but it can be handy when you want the strings to be visually distinctive. The enclosing &amp;lt;&amp;gt; are optional, so you don't have to use them - in fact the first thing globmap will do is remove these delimiters if they are present.</source>
          <target state="translated">Обратите внимание, что оба параметра &lt;code&gt;globmap&lt;/code&gt; представляют собой строки, разделенные &amp;lt;&amp;gt;. Это сделано для того, чтобы они больше походили на файловые глобусы - это просто синтаксический сахар, но это может быть удобно, когда вы хотите, чтобы строки были визуально различимы. Заключительные символы &amp;lt;&amp;gt; являются необязательными, поэтому вам не нужно их использовать - фактически, первое, что сделает globmap, это удалит эти разделители, если они есть.</target>
        </trans-unit>
        <trans-unit id="ad17ed98712f08fde401be783e01fddfe4c94277" translate="yes" xml:space="preserve">
          <source>Notice how the return value from the &lt;code&gt;new&lt;/code&gt; constructor is used as a filehandle in the &lt;code&gt;while&lt;/code&gt; loop? That's what's called an</source>
          <target state="translated">Обратите внимание , как возвращаемое значение из &lt;code&gt;new&lt;/code&gt; конструктора используются в качестве дескриптора в &lt;code&gt;while&lt;/code&gt; цикл? Это то, что называется</target>
        </trans-unit>
        <trans-unit id="ca8aa6acc2aa1f6723f38ec594c204d602c7b4d3" translate="yes" xml:space="preserve">
          <source>Notice how the second substitution stopped matching as soon as it encountered &quot;y &quot;. The &lt;code&gt;*?&lt;/code&gt; quantifier effectively tells the regular expression engine to find a match as quickly as possible and pass control on to whatever is next in line, as you would if you were playing hot potato.</source>
          <target state="translated">Обратите внимание, как вторая подстановка перестала соответствовать, как только встретила &amp;laquo;y&amp;raquo;. &lt;code&gt;*?&lt;/code&gt; quantifier эффективно сообщает механизму регулярных выражений, что нужно как можно быстрее найти совпадение и передать управление тому, что будет следующим в очереди, как если бы вы играли в hot potato.</target>
        </trans-unit>
        <trans-unit id="fa6e91727e4ee365f7ee9460c080c792faaad3e9" translate="yes" xml:space="preserve">
          <source>Notice how this (unprototyped) function doesn't care whether it was passed real scalars or arrays. Perl sees all arguments as one big, long, flat parameter list in &lt;code&gt;@_&lt;/code&gt; . This is one area where Perl's simple argument-passing style shines. The &lt;code&gt;upcase()&lt;/code&gt; function would work perfectly well without changing the &lt;code&gt;upcase()&lt;/code&gt; definition even if we fed it things like this:</source>
          <target state="translated">Обратите внимание, что этой (незапрототипированной) функции все равно, переданы ли ей реальные скаляры или массивы. Perl видит все аргументы как один большой, длинный, плоский список параметров в &lt;code&gt;@_&lt;/code&gt; . Это одна из областей, где сияет простой стиль Perl с передачей аргументов. Функция &lt;code&gt;upcase()&lt;/code&gt; будет отлично работать без изменения определения &lt;code&gt;upcase()&lt;/code&gt; даже если мы скармливаем ей что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="4444833b9992f40fcab9e968725d8711a413e3d2" translate="yes" xml:space="preserve">
          <source>Notice that &quot;hello&quot; is only printed once, as when Perl sees that the sixth iteration of the outermost &lt;code&gt;(?:)*&lt;/code&gt; matches a zero-length string, it stops the &lt;code&gt;*&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что &amp;laquo;hello&amp;raquo; печатается только один раз, так как, когда Perl видит, что шестая итерация самого внешнего &lt;code&gt;(?:)*&lt;/code&gt; :) * Соответствует строке нулевой длины, он останавливает &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64a5ba33762b8a3df62c02415bc8d0abd71b566d" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Dump()&lt;/code&gt; prints only elements 10 through 13 in the above code. The following code will print all of the elements.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;Dump()&lt;/code&gt; печатает только элементы с 10 по 13 в приведенном выше коде. Следующий код напечатает все элементы.</target>
        </trans-unit>
        <trans-unit id="e23423f7c29d56c0d20fc2f34471adb3aea96e69" translate="yes" xml:space="preserve">
          <source>Notice that a file glob pattern &lt;code&gt;*.tar.gz&lt;/code&gt; was used to match the &lt;code&gt;.tar.gz&lt;/code&gt; files, then a fairly similar regular expression was used in the substitute to allow the new filename to be created.</source>
          <target state="translated">Обратите внимание , что файл шаблона Glob &lt;code&gt;*.tar.gz&lt;/code&gt; был использован , чтобы соответствовать &lt;code&gt;.tar.gz&lt;/code&gt; файлов, то довольно похоже регулярное выражение было использовано в заменителя , чтобы новое имя файла будет создан.</target>
        </trans-unit>
        <trans-unit id="309a93ea449f47318d5d11f1a3d425f1bac00a22" translate="yes" xml:space="preserve">
          <source>Notice that because of the default behaviour of not doing any conversion upon input if there is no default layer, it is easy to mistakenly write code that keeps on expanding a file by repeatedly encoding the data:</source>
          <target state="translated">Обратите внимание,что из-за поведения по умолчанию,заключающегося в том,что при отсутствии слоя по умолчанию при вводе не выполняется ни одно преобразование,легко по ошибке написать код,который продолжает расширять файл,многократно кодируя данные:</target>
        </trans-unit>
        <trans-unit id="45e2138036f16fd01c487cf4e8627bd64352166d" translate="yes" xml:space="preserve">
          <source>Notice that both times the &lt;code&gt;put&lt;/code&gt; method was used the record index was specified using a variable, &lt;code&gt;$i&lt;/code&gt; , rather than the literal value itself. This is because &lt;code&gt;put&lt;/code&gt; will return the record number of the inserted line via that parameter.</source>
          <target state="translated">Обратите внимание, что оба раза &lt;code&gt;put&lt;/code&gt; метод put, индекс записи был указан с использованием переменной &lt;code&gt;$i&lt;/code&gt; , а не самого буквального значения. Это потому, что &lt;code&gt;put&lt;/code&gt; вернет номер записи вставленной строки через этот параметр.</target>
        </trans-unit>
        <trans-unit id="d32eeef01ddef5893487334cb249c7d79c61492e" translate="yes" xml:space="preserve">
          <source>Notice that in these new test cases, the argument passed to round was a scalar variable. You might be wondering if you can round a constant or literal. To see what happens, temporarily add the following line to Mytest.t:</source>
          <target state="translated">Обратите внимание,что в этих новых тестовых случаях аргумент,переданный на округление,представлял собой скалярную переменную.Вы можете задаться вопросом,можно ли округлить константу или буквально.Чтобы посмотреть,что произойдет,временно добавьте следующую строку в Mytest.t:</target>
        </trans-unit>
        <trans-unit id="dc0dc28dfd6b3af28d5f3f343ec14d50dc738990" translate="yes" xml:space="preserve">
          <source>Notice that it was necessary to define the variable &lt;code&gt;ax&lt;/code&gt; . This is because the &lt;code&gt;ST&lt;/code&gt; macro expects it to exist. If we were in an XSUB it would not be necessary to define &lt;code&gt;ax&lt;/code&gt; as it is already defined for us.</source>
          <target state="translated">Обратите внимание, что необходимо было определить переменную &lt;code&gt;ax&lt;/code&gt; . Это потому, что макрос &lt;code&gt;ST&lt;/code&gt; ожидает его существования. Если бы мы были в XSUB, не было бы необходимости определять &lt;code&gt;ax&lt;/code&gt; , поскольку он уже определен для нас.</target>
        </trans-unit>
        <trans-unit id="4559301041ec62ea61a8a1fd68eda86e54b3ac68" translate="yes" xml:space="preserve">
          <source>Notice that only literals (string or regular expression) having only legacy code points are affected: if you mix data like this</source>
          <target state="translated">Обратите внимание,что затрагиваются только литералы (строковые или регулярные выражения),имеющие только старые кодовые точки:если вы смешиваете данные так</target>
        </trans-unit>
        <trans-unit id="c0f86b253bff23ee24ee05dba74dabc635ca28ee" translate="yes" xml:space="preserve">
          <source>Notice that the core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; maybe rounding rather than truncating. What this means is that the core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; may be reporting the time as one second later than &lt;code&gt;gettimeofday()&lt;/code&gt; and &lt;code&gt;Time::HiRes::time()&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что основное &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; может округляться, а не усекаться. Это означает, что core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; может сообщать время на одну секунду позже, чем &lt;code&gt;gettimeofday()&lt;/code&gt; и &lt;code&gt;Time::HiRes::time()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ed987720b9a7557460b46e7f6aeb89459c4da26" translate="yes" xml:space="preserve">
          <source>Notice that the final match matched &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;p&lt;/code&gt; , which a match without the &lt;code&gt;\G&lt;/code&gt; anchor would have done. Also note that the final match did not update &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; is only updated on a &lt;code&gt;/g&lt;/code&gt; match. If the final match did indeed match &lt;code&gt;p&lt;/code&gt; , it's a good bet that you're running a very old (pre-5.6.0) version of Perl.</source>
          <target state="translated">Обратите внимание, что окончательное совпадение соответствует &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; вместо &lt;code&gt;p&lt;/code&gt; , что было бы сделано в случае совпадения без привязки &lt;code&gt;\G&lt;/code&gt; Также обратите внимание, что в финальном матче &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; обновляется только при совпадении a &lt;code&gt;/g&lt;/code&gt; . Если окончательное совпадение действительно соответствует &lt;code&gt;p&lt;/code&gt; , можно поспорить, что вы используете очень старую (до 5.6.0) версию Perl.</target>
        </trans-unit>
        <trans-unit id="11b14f084bcfbcc93f4c728dc8c7063e0ac84985" translate="yes" xml:space="preserve">
          <source>Notice that the outer bracket type has changed, and so our access syntax has also changed. That's because unlike C, in perl you can't freely interchange arrays and references thereto. $ref_to_AoA is a reference to an array, whereas @AoA is an array proper. Likewise, &lt;code&gt;$AoA[2]&lt;/code&gt; is not an array, but an array ref. So how come you can write these:</source>
          <target state="translated">Обратите внимание, что изменился тип внешней скобки, и поэтому наш синтаксис доступа также изменился. Это потому, что, в отличие от C, в perl нельзя свободно обмениваться массивами и ссылками на них. $ ref_to_AoA - это ссылка на массив, тогда как @AoA - это собственно массив. Точно так же &lt;code&gt;$AoA[2]&lt;/code&gt; - это не массив, а ссылка на массив. Так почему же вы можете написать это:</target>
        </trans-unit>
        <trans-unit id="4b4bf711776ec92640c01168664a95c86695d9a1" translate="yes" xml:space="preserve">
          <source>Notice that the programmer must supply the C code necessary to have the real rpcb_gettime() function called and to have the return values properly placed on the argument stack.</source>
          <target state="translated">Обратите внимание,что программист должен предоставить код на языке Си,необходимый для вызова реальной функции rpcb_gettime()и правильного размещения возвращаемых значений на стеке аргументов.</target>
        </trans-unit>
        <trans-unit id="40afcceb911c695d77d20dfe27b09ee506961834" translate="yes" xml:space="preserve">
          <source>Notice that the resulting directions might be somewhat surprising if you are looking at a flat worldmap: in such map projections the great circles quite often do not look like the shortest routes -- but for example the shortest possible routes from Europe or North America to Asia do often cross the polar regions. (The common Mercator projection does &lt;b&gt;not&lt;/b&gt; show great circles as straight lines: straight lines in the Mercator projection are lines of constant bearing.)</source>
          <target state="translated">Обратите внимание, что полученные направления могут быть несколько неожиданными, если вы смотрите на плоскую карту мира: в таких картографических проекциях большие круги довольно часто выглядят не как кратчайшие маршруты - а, например, как кратчайшие возможные маршруты из Европы или Северной Америки в Азию. часто пересекают полярные регионы. (Обычная проекция Меркатора &lt;b&gt;не&lt;/b&gt; показывает большие круги как прямые: прямые в проекции Меркатора - это линии постоянного направления.)</target>
        </trans-unit>
        <trans-unit id="cf6655a31d0fb590f3023635e120ce3082cf0511" translate="yes" xml:space="preserve">
          <source>Notice that this affects also the return values of the &lt;code&gt;display_format&lt;/code&gt; methods: in list context the whole parameter hash will be returned, as opposed to only the style parameter value. This is a potential incompatibility with earlier versions if you have been calling the &lt;code&gt;display_format&lt;/code&gt; method in list context.</source>
          <target state="translated">Обратите внимание, что это влияет также на возвращаемые значения методов &lt;code&gt;display_format&lt;/code&gt; : в контексте списка будет возвращен весь хэш параметра, а не только значение параметра стиля. Это потенциальная несовместимость с более ранними версиями, если вы &lt;code&gt;display_format&lt;/code&gt; метод display_format в контексте списка.</target>
        </trans-unit>
        <trans-unit id="7d79b02a2f56a81b2e831febdf1350cedb3c1a70" translate="yes" xml:space="preserve">
          <source>Notice that this example differs from the previous example only in its reference count. Compare this to the next example, where we dump &lt;code&gt;$b&lt;/code&gt; instead of &lt;code&gt;$a&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что этот пример отличается от предыдущего только количеством ссылок. Сравните это со следующим примером, где мы выгружаем &lt;code&gt;$b&lt;/code&gt; вместо &lt;code&gt;$a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="666303811970a38b268d6ae06ec62a57190a710e" translate="yes" xml:space="preserve">
          <source>Notice that we don't use the &lt;code&gt;env&lt;/code&gt; pointer. Normally handed to &lt;code&gt;perl_parse&lt;/code&gt; as its final argument, &lt;code&gt;env&lt;/code&gt; here is replaced by &lt;code&gt;NULL&lt;/code&gt; , which means that the current environment will be used.</source>
          <target state="translated">Обратите внимание, что мы не используем указатель &lt;code&gt;env&lt;/code&gt; . Обычно передается &lt;code&gt;perl_parse&lt;/code&gt; в качестве последнего аргумента, &lt;code&gt;env&lt;/code&gt; здесь заменяется на &lt;code&gt;NULL&lt;/code&gt; , что означает, что будет использоваться текущая среда.</target>
        </trans-unit>
        <trans-unit id="14ecce29919a6e670ddbfce3528fa1f7984fab4d" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_c&lt;/code&gt; is not equal to &lt;code&gt;$rho_s&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что когда &lt;code&gt;$z&lt;/code&gt; не равно 0, &lt;code&gt;$rho_c&lt;/code&gt; не равно &lt;code&gt;$rho_s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31ec88b4a9dbb1f747340d0b910dcdd339c4815c" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_s&lt;/code&gt; is not equal to &lt;code&gt;$rho_c&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что когда &lt;code&gt;$z&lt;/code&gt; не равно 0, &lt;code&gt;$rho_s&lt;/code&gt; не равно &lt;code&gt;$rho_c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d590cf6b82e4392a2e3299e1af99133b75ac011" translate="yes" xml:space="preserve">
          <source>Notice that you can choose to specify the length of the string to be assigned by using &lt;code&gt;sv_setpvn&lt;/code&gt; , &lt;code&gt;newSVpvn&lt;/code&gt; , or &lt;code&gt;newSVpv&lt;/code&gt; , or you may allow Perl to calculate the length by using &lt;code&gt;sv_setpv&lt;/code&gt; or by specifying 0 as the second argument to &lt;code&gt;newSVpv&lt;/code&gt; . Be warned, though, that Perl will determine the string's length by using &lt;code&gt;strlen&lt;/code&gt; , which depends on the string terminating with a &lt;code&gt;NUL&lt;/code&gt; character, and not otherwise containing NULs.</source>
          <target state="translated">Обратите внимание, что вы можете указать длину строки, которая будет назначена, с помощью &lt;code&gt;sv_setpvn&lt;/code&gt; , &lt;code&gt;newSVpvn&lt;/code&gt; или &lt;code&gt;newSVpv&lt;/code&gt; , или вы можете разрешить Perl вычислять длину с помощью &lt;code&gt;sv_setpv&lt;/code&gt; или указав 0 в качестве второго аргумента &lt;code&gt;newSVpv&lt;/code&gt; . Однако имейте в виду , что Perl будет определять длину строки с помощью &lt;code&gt;strlen&lt;/code&gt; , который зависит от строки, заканчивающейся символом &lt;code&gt;NUL&lt;/code&gt; и не содержащей других значений NUL.</target>
        </trans-unit>
        <trans-unit id="870ccbb59c66300e9b3ea8f52b5a5f559b3dde16" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;OBJECT&lt;/code&gt; attribute. MakeMaker generates the following variables in</source>
          <target state="translated">Обратите внимание на атрибут &lt;code&gt;OBJECT&lt;/code&gt; . MakeMaker генерирует следующие переменные в</target>
        </trans-unit>
        <trans-unit id="f8aba368fbb68d7c50d7b29b9babed1e8eb186e8" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;_&lt;/code&gt; in the above &lt;code&gt;&lt;a href=&quot;../functions/int&quot;&gt;int&lt;/a&gt;(-M _)&lt;/code&gt; : the &lt;code&gt;_&lt;/code&gt; is a magical filehandle that caches the information from the preceding &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt;, or filetest.</source>
          <target state="translated">Обратите внимание на &lt;code&gt;_&lt;/code&gt; в приведенном выше &lt;code&gt;&lt;a href=&quot;../functions/int&quot;&gt;int&lt;/a&gt;(-M _)&lt;/code&gt; : &lt;code&gt;_&lt;/code&gt; - это волшебный дескриптор файла, который кэширует информацию из предыдущих &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt; или filetest.</target>
        </trans-unit>
        <trans-unit id="4bb3a64dceeceb885b9680e4902401cdf9dc4f74" translate="yes" xml:space="preserve">
          <source>Notice the different order of arguments to &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Move&lt;/code&gt; than used in &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание на другой порядок аргументов для &lt;code&gt;Copy&lt;/code&gt; и &lt;code&gt;Move&lt;/code&gt; чем в &lt;code&gt;memcpy&lt;/code&gt; и &lt;code&gt;memmove&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="679c7845eb58a7c2d0b2d8985266c244821c6fe5" translate="yes" xml:space="preserve">
          <source>Notice the last two: you have an undef value, but a defined key!</source>
          <target state="translated">Обратите внимание на два последних:у вас есть значение undef,но определенный ключ!</target>
        </trans-unit>
        <trans-unit id="448c7dc3dc98fc3fc0f5933ff2892ce9313d9152" translate="yes" xml:space="preserve">
          <source>Notice the two lines commented with &quot;XXXXX&quot;. If you check the first part of the typemap file (or section), you'll see that doubles are of type T_DOUBLE. In the INPUT part of the typemap, an argument that is T_DOUBLE is assigned to the variable arg by calling the routine SvNV on something, then casting it to double, then assigned to the variable arg. Similarly, in the OUTPUT section, once arg has its final value, it is passed to the sv_setnv function to be passed back to the calling subroutine. These two functions are explained in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;; we'll talk more later about what that &quot;ST(0)&quot; means in the section on the argument stack.</source>
          <target state="translated">Обратите внимание на две строки с комментарием &amp;laquo;XXXXX&amp;raquo;. Если вы проверите первую часть файла (или раздела) карты типов, вы увидите, что двойники имеют тип T_DOUBLE. В части INPUT карты типов аргумент T_DOUBLE присваивается переменной arg путем вызова подпрограммы SvNV для чего-то, затем преобразования ее в значение double, а затем присваивается переменной arg. Точно так же в разделе OUTPUT, как только arg принимает окончательное значение, оно передается в функцию sv_setnv, чтобы передать ее обратно вызывающей подпрограмме. Эти две функции объяснены в &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; ; мы поговорим позже о том, что означает &amp;laquo;ST (0)&amp;raquo; в разделе о стеке аргументов.</target>
        </trans-unit>
        <trans-unit id="d783d11df518bc5c15566c5aca0ab336d7d1805f" translate="yes" xml:space="preserve">
          <source>Notice the use of GV_ADD as the second parameter. The new variable can now be set, using the routines appropriate to the data type.</source>
          <target state="translated">Обратите внимание на использование GV_ADD в качестве второго параметра.Новая переменная теперь может быть установлена с помощью процедур,соответствующих типу данных.</target>
        </trans-unit>
        <trans-unit id="08b42440fb285e46d8dc9159db458556192da3bc" translate="yes" xml:space="preserve">
          <source>Notice the white space in these examples. This construct always has the &lt;code&gt;/x&lt;/code&gt; modifier turned on within it.</source>
          <target state="translated">Обратите внимание на пробелы в этих примерах. В этой конструкции всегда включен модификатор &lt;code&gt;/x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf19896e6984078f566d31f89bc10d28920f05df" translate="yes" xml:space="preserve">
          <source>Notice we use &lt;code&gt;Perl_pp_add&lt;/code&gt; and not &lt;code&gt;pp_add&lt;/code&gt; - see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Internal Functions in perlguts&lt;/a&gt;. With the breakpoint in place, we can run our program:</source>
          <target state="translated">Обратите внимание, что мы используем &lt;code&gt;Perl_pp_add&lt;/code&gt; , а не &lt;code&gt;pp_add&lt;/code&gt; - см. &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Внутренние функции в perlguts&lt;/a&gt; . Установив точку останова, мы можем запустить нашу программу:</target>
        </trans-unit>
        <trans-unit id="02cb5b7c921fb7ebbe36d3e0607902dde126730c" translate="yes" xml:space="preserve">
          <source>Notify is used to request Delivery Status Notifications (DSNs), but your SMTP/ESMTP service may not respect this request depending upon its version and your site's SMTP configuration.</source>
          <target state="translated">Уведомление используется для запроса Уведомлений о состоянии доставки (Delivery Status Notifications-DSNs),но ваша служба SMTP/ESMTP может не уважать этот запрос в зависимости от его версии и конфигурации SMTP вашего сайта.</target>
        </trans-unit>
        <trans-unit id="da17090b524f51c10e88d0ac9b7049f8740a008e" translate="yes" xml:space="preserve">
          <source>Notify the server that the current message should be sent to all of the addresses given. Each address is sent as a separate command to the server. Should the sending of any address result in a failure then the process is aborted and a</source>
          <target state="translated">Сообщите серверу,что текущее сообщение должно быть отправлено по всем указанным адресам.Каждый адрес отправляется серверу отдельной командой.Если отправка какого-либо адреса приводит к сбою,то процесс прерывается и команда a</target>
        </trans-unit>
        <trans-unit id="9cbb4030243333159ba8734d1c5fd629386f77ad" translate="yes" xml:space="preserve">
          <source>Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.</source>
          <target state="translated">Novell NetWare наследует поведение File::Spec от File::Spec::Win32.</target>
        </trans-unit>
        <trans-unit id="dd6807acb122cd8525edb3b470a139acef9bafbd" translate="yes" xml:space="preserve">
          <source>November, 2007; by Christophe Grosjean: make cmpthese and timestr compute time consistently with style argument, default is 'all' not 'noc' any more.</source>
          <target state="translated">Ноябрь,2007;по словам Кристофа Грошжана:сделайте cmpthese и timestr вычислить время в соответствии с аргументом стиля,по умолчанию 'all' больше не 'noc'.</target>
        </trans-unit>
        <trans-unit id="e3b82040565bb4be6b11f778a2e3df327ed20a3b" translate="yes" xml:space="preserve">
          <source>Now</source>
          <target state="translated">Now</target>
        </trans-unit>
        <trans-unit id="c93d8b194f0c7fe984e291581c08b1052c5f3a15" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;$f1-&amp;gt;($n)&lt;/code&gt; is always 20 plus whatever $n you pass in, whereas &lt;code&gt;$f2-&amp;gt;($n)&lt;/code&gt; is always 555 plus whatever $n you pass in. The $addpiece in the closure sticks around.</source>
          <target state="translated">Теперь &lt;code&gt;$f1-&amp;gt;($n)&lt;/code&gt; всегда равно 20 плюс все, что вы передаете $ n, тогда как &lt;code&gt;$f2-&amp;gt;($n)&lt;/code&gt; всегда 555 плюс все, что вы передаете. $ Addpiece в закрытии остается.</target>
        </trans-unit>
        <trans-unit id="f44dcb817094334da756769457dbdcc2f78729c5" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; customre&lt;/code&gt; enables the new escape in constant regular expressions, i.e., those without any runtime variable interpolations. As documented in &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;, this conversion will work only over literal parts of regular expressions. For &lt;code&gt;\Y|$re\Y|&lt;/code&gt; the variable part of this regular expression needs to be converted explicitly (but only if the special meaning of &lt;code&gt;\Y|&lt;/code&gt; should be enabled inside $re):</source>
          <target state="translated">Теперь &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; customre&lt;/code&gt; позволяет использовать новый escape- код в постоянных регулярных выражениях, т. Е. Без каких-либо интерполяций переменных времени выполнения. Как описано в &lt;a href=&quot;overload&quot;&gt;перегрузке&lt;/a&gt; , это преобразование будет работать только с буквальными частями регулярных выражений. Для &lt;code&gt;\Y|$re\Y|&lt;/code&gt; переменная часть этого регулярного выражения должна быть преобразована явно (но только если особое значение &lt;code&gt;\Y|&lt;/code&gt; должно быть разрешено внутри $ re):</target>
        </trans-unit>
        <trans-unit id="e5baf71e7fbf158fd008d8c03a7a8fa212d5b45f" translate="yes" xml:space="preserve">
          <source>Now I'll create a C program,</source>
          <target state="translated">Теперь я создам программу на Си,</target>
        </trans-unit>
        <trans-unit id="2b1360bf75473ee9266121d81e1a06dd9911acef" translate="yes" xml:space="preserve">
          <source>Now all those different functions appear to exist independently. You can call red(), RED(), blue(), BLUE(), green(), etc. This technique saves on both compile time and memory use, and is less error-prone as well, since syntax checks happen at compile time. It's critical that any variables in the anonymous subroutine be lexicals in order to create a proper closure. That's the reasons for the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; on the loop iteration variable.</source>
          <target state="translated">Теперь кажется, что все эти разные функции существуют независимо. Вы можете вызывать red (), RED (), blue (), BLUE (), green () и т. Д. Этот метод экономит время компиляции и использование памяти, а также менее подвержен ошибкам, поскольку проверки синтаксиса выполняются в время компиляции. Очень важно, чтобы любые переменные в анонимной подпрограмме были лексическими, чтобы создать правильное закрытие. Это причины для переменной итерации цикла &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fd34829b18de1627725a95c603c191742b917e4" translate="yes" xml:space="preserve">
          <source>Now all you have to do is make.</source>
          <target state="translated">Теперь все,что тебе нужно сделать,это сделать.</target>
        </trans-unit>
        <trans-unit id="49b5690000abd466cabd2983e572f96822c8ad4b" translate="yes" xml:space="preserve">
          <source>Now an example using G_EVAL. Below is a Perl subroutine which computes the difference of its 2 parameters. If this would result in a negative result, the subroutine calls</source>
          <target state="translated">Теперь пример с использованием G_EVAL.Ниже приведена подпрограмма Perl,которая вычисляет разность своих 2 параметров.Если это приведет к отрицательному результату,то подпрограмма вызовет</target>
        </trans-unit>
        <trans-unit id="0107493cf3f67fc1eae2d61845bafd402e29a874" translate="yes" xml:space="preserve">
          <source>Now being maintained by Neil Bowers &amp;lt;neilb@cpan.org&amp;gt;</source>
          <target state="translated">Сейчас поддерживается Нилом Бауэрсом &amp;lt;neilb@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d0a0f59849b2d6f78aa32cc04ac0bc8777dc3df0" translate="yes" xml:space="preserve">
          <source>Now build an on-the-fly object over a couple of lines (note the backslash):</source>
          <target state="translated">Теперь построим объект &quot;на лету&quot; через пару строк (обратите внимание на обратный слеш):</target>
        </trans-unit>
        <trans-unit id="b18a77ba9bd692a2de2351fc4472b7905512dae7" translate="yes" xml:space="preserve">
          <source>Now change that to call a Perl subroutine instead</source>
          <target state="translated">Теперь измените это,чтобы вместо этого вызвать подпрограмму Perl.</target>
        </trans-unit>
        <trans-unit id="5eed8faf15fe7e07bcc558e5fbc255c10a771276" translate="yes" xml:space="preserve">
          <source>Now check whether &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec($read,$n,1)&lt;/a&gt;&lt;/code&gt; is true for some &lt;code&gt;$n&lt;/code&gt; .</source>
          <target state="translated">Теперь проверьте, истинно ли &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec($read,$n,1)&lt;/a&gt;&lt;/code&gt; для некоторого &lt;code&gt;$n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35cab876c88e9037a6396981d2ddc61575d5495f" translate="yes" xml:space="preserve">
          <source>Now comes the clever bit. Lines in our ledger which are just income and not expenditure might end at column 46. Hence, we don't want to tell our &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; pattern that we &lt;b&gt;need&lt;/b&gt; to find another 12 characters; we'll just say &quot;if there's anything left, take it&quot;. As you might guess from regular expressions, that's what the &lt;code&gt;*&lt;/code&gt; means: &quot;use everything remaining&quot;.</source>
          <target state="translated">А теперь самое интересное. Строки в нашей бухгалтерской книге, которые представляют собой только доходы, а не расходы, могут заканчиваться в столбце 46. Следовательно, мы не хотим сообщать нашему шаблону &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; , что нам &lt;b&gt;нужно&lt;/b&gt; найти еще 12 символов; мы просто скажем: &amp;laquo;если что-то осталось, бери&amp;raquo;. Как вы могли догадаться по регулярным выражениям, это означает , что &lt;code&gt;*&lt;/code&gt; означает: &amp;laquo;использовать все, что осталось&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a13bda202e6718f6f18d21a1e47f52cfb3879053" translate="yes" xml:space="preserve">
          <source>Now compile this program (I'll call it</source>
          <target state="translated">Теперь скомпилируйте эту программу (я назову ее</target>
        </trans-unit>
        <trans-unit id="c57d72b147b5753e6d9e423d3502ca9248d5f07f" translate="yes" xml:space="preserve">
          <source>Now compile:</source>
          <target state="translated">Теперь собирай:</target>
        </trans-unit>
        <trans-unit id="f3d2e76534a9f4dbbaafe0b2d7b2922184fb31d5" translate="yes" xml:space="preserve">
          <source>Now consider floating point numbers with exponents. The key observation here is that</source>
          <target state="translated">Теперь рассмотрим числа с плавающей точкой с экспонентами.Ключевое наблюдение здесь заключается в том,что</target>
        </trans-unit>
        <trans-unit id="ff2a183c3b41e6c536df243f1dce108cb53ffa0f" translate="yes" xml:space="preserve">
          <source>Now edit the Mytest2.t script and change the number of tests to &quot;4&quot;, and add the following lines to the end of the script:</source>
          <target state="translated">Теперь отредактируйте скрипт Mytest2.t и измените количество тестов на &quot;4&quot;,и добавьте следующие строки в конец скрипта:</target>
        </trans-unit>
        <trans-unit id="2953f00009a89200e277b692ef57868b268aff69" translate="yes" xml:space="preserve">
          <source>Now for an example of dealing with the items returned from a Perl subroutine.</source>
          <target state="translated">Теперь рассмотрим пример работы с предметами,возвращенными из подпрограммы Perl.</target>
        </trans-unit>
        <trans-unit id="0be3c2c5225baac76521af82d8668e34f7dced50" translate="yes" xml:space="preserve">
          <source>Now for something much more complex: &lt;code&gt;/x(?:foo*|b[a][rR])(foo|bar)$/&lt;/code&gt;</source>
          <target state="translated">Теперь о чем-то более сложном: &lt;code&gt;/x(?:foo*|b[a][rR])(foo|bar)$/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92162dfafb815308e37a13a29bc3866c727f49ac" translate="yes" xml:space="preserve">
          <source>Now if $baz is overloaded like this, then &lt;code&gt;$baz&lt;/code&gt; is a reference to a reference to the intermediate array, which keeps a reference to an actual array, and the access hash. The tie()ing object for the access hash is a reference to a reference to the actual array, so</source>
          <target state="translated">Теперь, если $ baz перегружен таким образом, тогда &lt;code&gt;$baz&lt;/code&gt; является ссылкой на ссылку на промежуточный массив, который хранит ссылку на фактический массив и хэш доступа. Объект tie () для хэша доступа - это ссылка на ссылку на фактический массив, поэтому</target>
        </trans-unit>
        <trans-unit id="442765a41777ec67298b58abdc70ce2f732fb2a5" translate="yes" xml:space="preserve">
          <source>Now if we see a &lt;code&gt;U&lt;/code&gt; which was at the start of the string, we turn on the &lt;code&gt;UTF8&lt;/code&gt; flag for the output SV, &lt;code&gt;cat&lt;/code&gt; :</source>
          <target state="translated">Теперь, если мы видим &lt;code&gt;U&lt;/code&gt; , который был в начале строки, мы &lt;code&gt;UTF8&lt;/code&gt; флаг UTF8 для выходного SV, &lt;code&gt;cat&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9aa71504ceae318c2af66092e17c9a82a7deb8c3" translate="yes" xml:space="preserve">
          <source>Now inner() can only be called from within outer(), because of the temporary assignments of the anonymous subroutine. But when it does, it has normal access to the lexical variable $x from the scope of outer() at the time outer is invoked.</source>
          <target state="translated">Теперь функция inner()может вызываться только изнутри функции outer(),из-за временных назначений анонимной подпрограммы.Но когда она это делает,она имеет нормальный доступ к лексической переменной $x из области видимости outer()в момент вызова outer().</target>
        </trans-unit>
        <trans-unit id="f0dd64db78144735f7994758b886eab3a665aa14" translate="yes" xml:space="preserve">
          <source>Now is the time to build statically linked executable</source>
          <target state="translated">Настало время построить статически привязанный исполняемый файл.</target>
        </trans-unit>
        <trans-unit id="56e8b027d2534e474052d61aa156186a15f1e672" translate="yes" xml:space="preserve">
          <source>Now issue a command all Perl Mongers love:</source>
          <target state="translated">Теперь отдай команду,которую любят все Перл-Монгеры:</target>
        </trans-unit>
        <trans-unit id="a8a1925328e3fa40f64265288667627705914e38" translate="yes" xml:space="preserve">
          <source>Now it really looks like two-dimensional arrays!</source>
          <target state="translated">Теперь это действительно похоже на двухмерные массивы!</target>
        </trans-unit>
        <trans-unit id="6e306ced46a050d218e4778907f520f756de263d" translate="yes" xml:space="preserve">
          <source>Now it's time to print your data structure out. How are you going to do that? Well, if you want only one of the elements, it's trivial:</source>
          <target state="translated">Теперь пришло время распечатать структуру данных.Как ты собираешься это сделать? Ну,если тебе нужен только один из элементов,это тривиально:</target>
        </trans-unit>
        <trans-unit id="54ce2aa34a908b75653982fdea46ab158bc6415a" translate="yes" xml:space="preserve">
          <source>Now just type in any legal Perl code, and it will be immediately evaluated. You can also examine the symbol table, get stack backtraces, check variable values, set breakpoints, and other operations typically found in symbolic debuggers.</source>
          <target state="translated">Теперь просто введите любой легальный Perl-код,и он будет немедленно оценен.Вы также можете просмотреть таблицу символов,получить обратные стеки,проверить значения переменных,установить точки останова и другие операции,обычно встречающиеся в отладчиках символов.</target>
        </trans-unit>
        <trans-unit id="71eab03d0589285d163e163d02feef9a891122b5" translate="yes" xml:space="preserve">
          <source>Now let's add to our extension a subroutine that will take a single numeric argument as input and return 1 if the number is even or 0 if the number is odd.</source>
          <target state="translated">Теперь добавим в наше расширение подпрограмму,которая примет на вход один числовой аргумент и вернёт 1,если число четное или 0,если число нечетное.</target>
        </trans-unit>
        <trans-unit id="b25fbca1c3ebbbe365fafa21da05b0bf381c9042" translate="yes" xml:space="preserve">
          <source>Now let's go on with the show!</source>
          <target state="translated">А теперь давайте продолжим шоу!</target>
        </trans-unit>
        <trans-unit id="56c9d0bafceed9745ea4a5c37d241ab5110ecbe0" translate="yes" xml:space="preserve">
          <source>Now let's look over &lt;code&gt;pp_pack&lt;/code&gt; : we take a pattern into &lt;code&gt;pat&lt;/code&gt; , and then loop over the pattern, taking each format character in turn into &lt;code&gt;datum_type&lt;/code&gt; . Then for each possible format character, we swallow up the other arguments in the pattern (a field width, an asterisk, and so on) and convert the next chunk input into the specified format, adding it onto the output SV &lt;code&gt;cat&lt;/code&gt; .</source>
          <target state="translated">Теперь давайте посмотрим на &lt;code&gt;pp_pack&lt;/code&gt; : мы берем шаблон в &lt;code&gt;pat&lt;/code&gt; , а затем перебираем шаблон, принимая каждый символ формата по очереди в &lt;code&gt;datum_type&lt;/code&gt; . Затем для каждого возможного символа формата мы поглощаем другие аргументы в шаблоне (ширину поля, звездочку и т. Д.) И преобразуем следующий входной блок в указанный формат, добавляя его в выходной SV &lt;code&gt;cat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19bfc0dd7ed8b536789ace2adf6482eed3ae9d5d" translate="yes" xml:space="preserve">
          <source>Now let's make a slightly more complex example. This time we want to call a Perl subroutine, &lt;code&gt;LeftString&lt;/code&gt; , which will take 2 parameters--a string ($s) and an integer ($n). The subroutine will simply print the first $n characters of the string.</source>
          <target state="translated">Теперь давайте сделаем немного более сложный пример. На этот раз мы хотим вызвать подпрограмму Perl &lt;code&gt;LeftString&lt;/code&gt; , которая будет принимать 2 параметра - строку ($ s) и целое число ($ n). Подпрограмма просто напечатает первые $ n символов строки.</target>
        </trans-unit>
        <trans-unit id="6354d1ac356f03ba53418ed6480c6b835c8d11e3" translate="yes" xml:space="preserve">
          <source>Now let's try a harder pattern. We will add a quantifier, so now we have the pattern &lt;code&gt;/foo+/&lt;/code&gt; . We will see that &lt;code&gt;regbranch()&lt;/code&gt; calls &lt;code&gt;regpiece()&lt;/code&gt; twice.</source>
          <target state="translated">Теперь попробуем узор посложнее. Мы добавим квантификатор, так что теперь у нас есть шаблон &lt;code&gt;/foo+/&lt;/code&gt; . Мы увидим , что &lt;code&gt;regbranch()&lt;/code&gt; вызовы &lt;code&gt;regpiece()&lt;/code&gt; дважды.</target>
        </trans-unit>
        <trans-unit id="889bc56f5635509a3bf0cc79dcaae69476badde9" translate="yes" xml:space="preserve">
          <source>Now maintained by Perl5 Porters.</source>
          <target state="translated">Теперь обслуживается Perl5 Porters.</target>
        </trans-unit>
        <trans-unit id="2038fc7801848170606c108e5b8808a37af01abf" translate="yes" xml:space="preserve">
          <source>Now numeric value of $c is 5. After &lt;code&gt;$a = 12; $b = 5&lt;/code&gt; the numeric value of $c becomes 13. To insulate the user of the module add a method</source>
          <target state="translated">Теперь числовое значение $ c равно 5. После &lt;code&gt;$a = 12; $b = 5&lt;/code&gt; числовое значение $ c становится 13. Чтобы изолировать пользователя модуля, добавьте метод</target>
        </trans-unit>
        <trans-unit id="8af21af6d9d9b5497a4644877b2f52927ff73040" translate="yes" xml:space="preserve">
          <source>Now one can access an object using both the array and hash syntax:</source>
          <target state="translated">Теперь можно получить доступ к объекту как с помощью синтаксиса массива,так и с помощью синтаксиса хэша:</target>
        </trans-unit>
        <trans-unit id="0d5501fb3c867cabba9520f061ccb7181169320a" translate="yes" xml:space="preserve">
          <source>Now one can change the last line of the script to</source>
          <target state="translated">Теперь можно изменить последнюю строку скрипта на</target>
        </trans-unit>
        <trans-unit id="36a34b3fdc67a4c118c486e51977f9c88c24fbb9" translate="yes" xml:space="preserve">
          <source>Now one can finish the script by</source>
          <target state="translated">Теперь можно закончить сценарий на</target>
        </trans-unit>
        <trans-unit id="fb12351c6667dd534972c89f66e0ea83ea3b515d" translate="yes" xml:space="preserve">
          <source>Now perform the same steps as before, generating a Makefile from the Makefile.PL file, and running make.</source>
          <target state="translated">Теперь выполните те же действия,что и раньше,сгенерировав Makefile из файла Makefile.PL и запустив make.</target>
        </trans-unit>
        <trans-unit id="176a110722147c376bebc4313178934ce4ec0c61" translate="yes" xml:space="preserve">
          <source>Now process &quot;A&quot; updates the database and happens to change some of the data held in the initial buffer. Process &quot;A&quot; terminates, flushing all cached data to disk and releasing the database lock. At this point the database on disk will correctly reflect the changes made by process &quot;A&quot;.</source>
          <target state="translated">Теперь процесс &quot;А&quot; обновляет БД и случайно меняет часть данных,хранящихся в исходном буфере.Процесс &quot;А&quot; завершается,все кэшированные данные смываются на диск и освобождается блокировка БД.В этот момент БД на диске будет корректно отражать изменения,сделанные процессом &quot;А&quot;.</target>
        </trans-unit>
        <trans-unit id="ef78e970daca9bfe36844c130043d8db552b721e" translate="yes" xml:space="preserve">
          <source>Now re-run make to rebuild our new shared library.</source>
          <target state="translated">Теперь перезапустите make,чтобы перестроить нашу новую общую библиотеку.</target>
        </trans-unit>
        <trans-unit id="b502363c9d43a3258b18dcc28321bf168995d38c" translate="yes" xml:space="preserve">
          <source>Now run</source>
          <target state="translated">Теперь бегите</target>
        </trans-unit>
        <trans-unit id="43d39e890e8ba24fba8997c278066f474d3fd060" translate="yes" xml:space="preserve">
          <source>Now run perl on the top-level Makefile.PL. Notice that it also created a Makefile in the mylib directory. Run make and watch that it does cd into the mylib directory and run make in there as well.</source>
          <target state="translated">Теперь запустите perl на верхнем уровне Makefile.PL.Обратите внимание,что он также создал Makefile в каталоге mylib.Запустите make и посмотрите,что он делает cd в каталоге mylib,а также запустите make там.</target>
        </trans-unit>
        <trans-unit id="9680a56da8828aa80b4fe46f2d0d313dfaabb116" translate="yes" xml:space="preserve">
          <source>Now run:</source>
          <target state="translated">Теперь беги:</target>
        </trans-unit>
        <trans-unit id="431a120b5d4a3c45e45ae8e764d0243bae7f6294" translate="yes" xml:space="preserve">
          <source>Now suppose we have more than one interpreter instance running at the same time. This is feasible, but only if you used the Configure option &lt;code&gt;-Dusemultiplicity&lt;/code&gt; or the options &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; when building perl. By default, enabling one of these Configure options sets the per-interpreter global variable &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; , so that thorough cleaning is automatic and interpreter variables are initialized correctly. Even if you don't intend to run two or more interpreters at the same time, but to run them sequentially, like in the above example, it is recommended to build perl with the &lt;code&gt;-Dusemultiplicity&lt;/code&gt; option otherwise some interpreter variables may not be initialized correctly between consecutive runs and your application may crash.</source>
          <target state="translated">Теперь предположим, что у нас одновременно работает более одного экземпляра интерпретатора. Это возможно, но только если вы использовали параметр Configure &lt;code&gt;-Dusemultiplicity&lt;/code&gt; или параметры &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; при сборке Perl. По умолчанию включение одной из этих опций Configure устанавливает глобальную переменную &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; для каждого интерпретатора в значение &lt;code&gt;1&lt;/code&gt; , поэтому тщательная очистка выполняется автоматически, а переменные интерпретатора инициализируются правильно. Даже если вы не собираетесь запускать два или более интерпретатора одновременно, а запускать их последовательно, как в приведенном выше примере, рекомендуется создавать perl с помощью &lt;code&gt;-Dusemultiplicity&lt;/code&gt; в противном случае некоторые переменные интерпретатора могут быть неправильно инициализированы между последовательными запусками, и ваше приложение может аварийно завершить работу.</target>
        </trans-unit>
        <trans-unit id="4e1ba3c5bd850f498e4d354eafd68e49756fd894" translate="yes" xml:space="preserve">
          <source>Now take a look at your current directory. It should look like this.</source>
          <target state="translated">Теперь посмотрите на свой текущий каталог.Он должен выглядеть так.</target>
        </trans-unit>
        <trans-unit id="afb0ec981d97896d9a67b5f9341746480fee45ab" translate="yes" xml:space="preserve">
          <source>Now that UNTIE exists the class designer can decide which parts of the class functionality are really associated with &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; and which with the object being destroyed. What makes sense for a given class depends on whether the inner references are being kept so that non-tie-related methods can be called on the object. But in most cases it probably makes sense to move the functionality that would have been in DESTROY to the UNTIE method.</source>
          <target state="translated">Теперь, когда UNTIE существует, разработчик класса может решить, какие части функциональности класса действительно связаны с &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; , а какие с уничтожаемым объектом. Что имеет смысл для данного класса, зависит от того, сохраняются ли внутренние ссылки, чтобы для объекта можно было вызывать методы, не связанные с связями. Но в большинстве случаев, вероятно, имеет смысл перенести функциональность, которая была бы в DESTROY, в метод UNTIE.</target>
        </trans-unit>
        <trans-unit id="e6856d572f5c42bc67bf2b06905ca5effd5d4772" translate="yes" xml:space="preserve">
          <source>Now that basic require() and subroutines are tested, you can use the</source>
          <target state="translated">Теперь,когда основные функции require()и подпрограммы протестированы,вы можете воспользоваться функцией</target>
        </trans-unit>
        <trans-unit id="efac8814e4d76977800b30df75313c1fb6bb539a" translate="yes" xml:space="preserve">
          <source>Now that the &quot;native&quot; mechanism is supported by &lt;code&gt;Sys::Syslog&lt;/code&gt; and selected by default, the use of the &lt;code&gt;setlogsock()&lt;/code&gt; function is discouraged because other mechanisms are less portable across operating systems. Authors of modules and programs that use this function, especially its cargo-cult form &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt; , are advised to remove any occurrence of it unless they specifically want to use a given mechanism (like TCP or UDP to connect to a remote host).</source>
          <target state="translated">Теперь, когда &amp;laquo;собственный&amp;raquo; механизм поддерживается &lt;code&gt;Sys::Syslog&lt;/code&gt; и выбран по умолчанию, использование функции &lt;code&gt;setlogsock()&lt;/code&gt; не рекомендуется, поскольку другие механизмы менее переносимы в операционных системах. Авторам модулей и программ, которые используют эту функцию, особенно ее культовой формы &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt; , рекомендуется удалять все ее вхождения, если они специально не хотят использовать данный механизм (например, TCP или UDP для подключения к удаленному компьютеру). хост).</target>
        </trans-unit>
        <trans-unit id="2001533940f7a7dc78b5938ec0ecf76cf899fefd" translate="yes" xml:space="preserve">
          <source>Now that the core of Perl is tested, &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; can and should be used. You can also use the full suite of core modules in the tests.</source>
          <target state="translated">Теперь, когда ядро ​​Perl протестировано, &lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt; можно и нужно использовать. Вы также можете использовать в тестах полный набор основных модулей.</target>
        </trans-unit>
        <trans-unit id="7692728e97a21b18614fd5385fcbfb77d3648e29" translate="yes" xml:space="preserve">
          <source>Now that there is room on the stack, values can be pushed on it using &lt;code&gt;PUSHs&lt;/code&gt; macro. The pushed values will often need to be &quot;mortal&quot; (See &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Reference Counts and Mortality&lt;/a&gt;):</source>
          <target state="translated">Теперь, когда в стеке есть место, значения могут быть &lt;code&gt;PUSHs&lt;/code&gt; него с помощью макроса PUSHs . Передаваемые значения часто должны быть &quot;смертными&quot; (см. &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Подсчет ссылок и смертность&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="30355dc46fa236bc2762d6b874a869adc19e6693" translate="yes" xml:space="preserve">
          <source>Now that we have seen &lt;code&gt;P&lt;/code&gt; at work, we might as well give &lt;code&gt;p&lt;/code&gt; a whirl. Why do we need a second template code for packing pointers at all? The answer lies behind the simple fact that an &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;p&lt;/code&gt; promises a null-terminated string starting at the address taken from the buffer, and that implies a length for the data item to be returned:</source>
          <target state="translated">Теперь, когда мы увидели &lt;code&gt;P&lt;/code&gt; в действии, мы могли бы с таким же успехом крутить &lt;code&gt;p&lt;/code&gt; . Зачем нам вообще нужен второй шаблонный код для упаковки указателей? Ответ кроется в простом факте, что &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; с &lt;code&gt;p&lt;/code&gt; обещает строку с завершающим нулем, начинающуюся с адреса, взятого из буфера, и это подразумевает длину возвращаемого элемента данных:</target>
        </trans-unit>
        <trans-unit id="3289c147e35201c5816ca81ac2c53e6c21248267" translate="yes" xml:space="preserve">
          <source>Now that we have the &lt;code&gt;*foo{THING}&lt;/code&gt; notation, typeglobs aren't used as much for filehandle manipulations, although they're still needed to pass brand new file and directory handles into or out of functions. That's because &lt;code&gt;*HANDLE{IO}&lt;/code&gt; only works if HANDLE has already been used as a handle. In other words, &lt;code&gt;*FH&lt;/code&gt; must be used to create new symbol table entries; &lt;code&gt;*foo{THING}&lt;/code&gt; cannot. When in doubt, use &lt;code&gt;*FH&lt;/code&gt; .</source>
          <target state="translated">Теперь, когда у нас есть нотация &lt;code&gt;*foo{THING}&lt;/code&gt; , typeglobs не так часто используются для манипуляций с дескрипторами файлов, хотя они все еще необходимы для передачи новых дескрипторов файлов и каталогов в функции или из функций. Это потому, что &lt;code&gt;*HANDLE{IO}&lt;/code&gt; работает, только если HANDLE уже использовался как дескриптор. Другими словами, &lt;code&gt;*FH&lt;/code&gt; необходимо использовать для создания новых записей таблицы символов; &lt;code&gt;*foo{THING}&lt;/code&gt; не может. В случае сомнений используйте &lt;code&gt;*FH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94fb438178c3f179a69d1380f1c008b5fe2d33bb" translate="yes" xml:space="preserve">
          <source>Now that we have this pattern stored as a handy string, we might feel tempted to use it as a part of some other pattern:</source>
          <target state="translated">Теперь,когда у нас есть этот шаблон,хранящийся как удобная строка,мы можем почувствовать искушение использовать его как часть какого-нибудь другого шаблона:</target>
        </trans-unit>
        <trans-unit id="c183105c83816c48c77d4c827336e4e813e84f27" translate="yes" xml:space="preserve">
          <source>Now that we've covered the basics of threads, it's time for our next topic: Data. Threading introduces a couple of complications to data access that non-threaded programs never need to worry about.</source>
          <target state="translated">Теперь,когда мы рассмотрели основы нитей,пришло время для нашей следующей темы:Данные.Потоки вводят пару осложнений в доступ к данным,о которых не нужно беспокоиться не-потоковым программам.</target>
        </trans-unit>
        <trans-unit id="17f47b8aedf9a1b8e0f108087ca6f763b020db20" translate="yes" xml:space="preserve">
          <source>Now that you know what the problem is, what can you do to avoid it? Prior to the introduction of the optional UNTIE method the only way was the good old &lt;code&gt;-w&lt;/code&gt; flag. Which will spot any instances where you call untie() and there are still valid references to the tied object. If the second script above this near the top &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'untie'&lt;/code&gt; or was run with the &lt;code&gt;-w&lt;/code&gt; flag, Perl prints this warning message:</source>
          <target state="translated">Теперь, когда вы знаете, в чем проблема, что вы можете сделать, чтобы ее избежать? До введения необязательного метода UNTIE единственным выходом был старый добрый флаг &lt;code&gt;-w&lt;/code&gt; . Это обнаружит любые экземпляры, в которых вы вызываете untie (), и все еще есть действительные ссылки на связанный объект. Если второй сценарий выше этого, рядом с верхним, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'untie'&lt;/code&gt; или был запущен с флагом &lt;code&gt;-w&lt;/code&gt; , Perl выводит это предупреждающее сообщение:</target>
        </trans-unit>
        <trans-unit id="022bdd2be74a4d788e977f99278118a67ba2ad8d" translate="yes" xml:space="preserve">
          <source>Now that you understand how &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for files with a bareword argument, there is a little extra functionality going on behind the scenes. Before &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for a &quot;</source>
          <target state="translated">Теперь, когда вы понимаете, как &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ищет файлы с аргументом bareword, за кулисами происходит небольшая дополнительная функциональность. Прежде чем &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ищет &quot;</target>
        </trans-unit>
        <trans-unit id="597f8013d78df265fd55b188a128a0c6cbbf532e" translate="yes" xml:space="preserve">
          <source>Now that you understand how &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for files with a bareword argument, there is a little extra functionality going on behind the scenes. Before &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for a &quot;</source>
          <target state="translated">Теперь, когда вы понимаете, как &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ищет файлы с аргументом bareword, за кулисами происходит небольшая дополнительная функциональность. Прежде чем &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ищет &quot;</target>
        </trans-unit>
        <trans-unit id="b76e84f2c33cd5c972aa524cad0960f89f22f060" translate="yes" xml:space="preserve">
          <source>Now the command line may look like:</source>
          <target state="translated">Теперь командная строка может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="b70b0be20fc0cb8a073d7d288b92a6e5925d77b2" translate="yes" xml:space="preserve">
          <source>Now the output doesn't have the spaces between the elements because the elements of &lt;code&gt;@animals&lt;/code&gt; simply become part of the list to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Теперь в выводе нет пробелов между элементами, потому что элементы &lt;code&gt;@animals&lt;/code&gt; просто становятся частью списка для &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3c3e5717f93544ac6beb2dcf88b8c55f969febc1" translate="yes" xml:space="preserve">
          <source>Now the output shows that &lt;code&gt;foo&lt;/code&gt; doesn't get the &lt;code&gt;@_&lt;/code&gt; from its caller.</source>
          <target state="translated">Теперь вывод показывает, что &lt;code&gt;foo&lt;/code&gt; не получает &lt;code&gt;@_&lt;/code&gt; от вызывающей стороны.</target>
        </trans-unit>
        <trans-unit id="3fcb9eb262daa67d00f7dccd8fa99c81f713a40e" translate="yes" xml:space="preserve">
          <source>Now the parsing stage is complete, and the finished tree represents the operations that the Perl interpreter needs to perform to execute our program. Next, Perl does a dry run over the tree looking for optimisations: constant expressions such as &lt;code&gt;3 + 4&lt;/code&gt; will be computed now, and the optimizer will also see if any multiple operations can be replaced with a single one. For instance, to fetch the variable &lt;code&gt;$foo&lt;/code&gt; , instead of grabbing the glob &lt;code&gt;*foo&lt;/code&gt; and looking at the scalar component, the optimizer fiddles the op tree to use a function which directly looks up the scalar in question. The main optimizer is &lt;code&gt;peep&lt;/code&gt; in</source>
          <target state="translated">Теперь этап синтаксического анализа завершен, и готовое дерево представляет операции, которые интерпретатор Perl должен выполнить для выполнения нашей программы. Затем Perl выполняет пробный прогон по дереву в поисках оптимизации: теперь будут вычисляться константные выражения, такие как &lt;code&gt;3 + 4&lt;/code&gt; , и оптимизатор также увидит, можно ли заменить какие-либо несколько операций одной. Например, чтобы получить переменную &lt;code&gt;$foo&lt;/code&gt; , вместо того , чтобы брать glob &lt;code&gt;*foo&lt;/code&gt; и смотреть на скалярный компонент, оптимизатор возится с операционным деревом, чтобы использовать функцию, которая напрямую ищет рассматриваемый скаляр. Главный оптимизатор - &lt;code&gt;peep&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="0b0d2c80b383fda949460859c7cc860ad47a12c4" translate="yes" xml:space="preserve">
          <source>Now the rpcb_gettime() function can be used from Perl with the following statement.</source>
          <target state="translated">Теперь функцию rpcb_gettime()можно использовать от Perl со следующим утверждением.</target>
        </trans-unit>
        <trans-unit id="9b44a2219a59e7204e7ee350a2cc75af078d1e4b" translate="yes" xml:space="preserve">
          <source>Now think about</source>
          <target state="translated">Теперь подумайте о</target>
        </trans-unit>
        <trans-unit id="c30cd0c985054472ce92540629db69d82b31ed97" translate="yes" xml:space="preserve">
          <source>Now think of each logical connection between the Perl parser and an individual file as a</source>
          <target state="translated">Теперь подумайте о каждой логической связи между парсером Perl и отдельным файлом как о</target>
        </trans-unit>
        <trans-unit id="63aed2505c6485cbd9c4824f7162c565df48aa33" translate="yes" xml:space="preserve">
          <source>Now type</source>
          <target state="translated">Now type</target>
        </trans-unit>
        <trans-unit id="69d98bfb814f8df94eddba674df944be471dcc9f" translate="yes" xml:space="preserve">
          <source>Now we also need to create a typemap because the default Perl doesn't currently support the &lt;code&gt;const char *&lt;/code&gt; type. Include a new TYPEMAP section in your XS code before the above function:</source>
          <target state="translated">Теперь нам также нужно создать карту типов, потому что Perl по умолчанию в настоящее время не поддерживает тип &lt;code&gt;const char *&lt;/code&gt; . Включите новый раздел TYPEMAP в свой код XS перед вышеуказанной функцией:</target>
        </trans-unit>
        <trans-unit id="ac3c0b8b639b2123b87b956629756b446c6934e9" translate="yes" xml:space="preserve">
          <source>Now we can have a look at that first ($key) variable:</source>
          <target state="translated">Теперь мы можем взглянуть на эту первую ($key)переменную:</target>
        </trans-unit>
        <trans-unit id="185a7b552e431f4b4b46cbef152d792a78593a6f" translate="yes" xml:space="preserve">
          <source>Now we can match the 'a' and the 't'.</source>
          <target state="translated">Теперь мы можем сопоставить &quot;а&quot; и &quot;т&quot;.</target>
        </trans-unit>
        <trans-unit id="2bd64428bd387110ec5af71e395507d7b42d715c" translate="yes" xml:space="preserve">
          <source>Now we can use the subroutine just as any other built-in function:</source>
          <target state="translated">Теперь мы можем использовать подпрограмму так же,как и любую другую встроенную функцию:</target>
        </trans-unit>
        <trans-unit id="5dd4060fc442a49be75b77cb5ad37ebb6eff79fc" translate="yes" xml:space="preserve">
          <source>Now we have a special case. The &lt;code&gt;EXACT&lt;/code&gt; regop has a &lt;code&gt;regnext&lt;/code&gt; of 0. This is because if it matches it should try to match itself again. The &lt;code&gt;PLUS&lt;/code&gt; regop handles the actual failure of the &lt;code&gt;EXACT&lt;/code&gt; regop and acts appropriately (going to regnode 6 if the &lt;code&gt;EXACT&lt;/code&gt; matched at least once, or failing if it didn't).</source>
          <target state="translated">Теперь у нас есть особый случай. &lt;code&gt;EXACT&lt;/code&gt; regop имеет &lt;code&gt;regnext&lt;/code&gt; 0. Это происходит потому , если он соответствует он должен попытаться соответствовать себя снова. &lt;code&gt;PLUS&lt;/code&gt; regop обрабатывает фактический провал &lt;code&gt;EXACT&lt;/code&gt; regop и действует соответствующим образом (будет regnode 6 , если &lt;code&gt;EXACT&lt;/code&gt; соответствует по крайней мере один раз, или неудачны , если это не так).</target>
        </trans-unit>
        <trans-unit id="9e8623792298834d51348eb8a4e63d54b4322603" translate="yes" xml:space="preserve">
          <source>Now we make the script executable (&lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt; +x hello&lt;/code&gt; ), run the script and we should see the following output:</source>
          <target state="translated">Теперь мы делаем скрипт исполняемым ( &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt; +x hello&lt;/code&gt; ), запускаем скрипт, и мы должны увидеть следующий результат:</target>
        </trans-unit>
        <trans-unit id="27be17fcef7387e3ac6e2da3084db2de80fc9a40" translate="yes" xml:space="preserve">
          <source>Now we pass Perl the command line options, and tell it to go:</source>
          <target state="translated">Теперь мы передадим Perl параметры командной строки и скажем ему,чтобы он ушел:</target>
        </trans-unit>
        <trans-unit id="619205ae318e9243260c596997993412134beb8d" translate="yes" xml:space="preserve">
          <source>Now we skip another character and pick up the next 7 characters:</source>
          <target state="translated">Теперь мы пропустим еще одного персонажа и подберем следующие 7 символов:</target>
        </trans-unit>
        <trans-unit id="00d5b0ef9c96351760d2c5c765c6707b0214ca3c" translate="yes" xml:space="preserve">
          <source>Now we'll continue down into our subroutine, this time rather than by line number, we'll use the subroutine name, followed by the now familiar 'v':</source>
          <target state="translated">Теперь мы продолжим вниз в нашу подпрограмму,на этот раз,а не по номеру строки,мы будем использовать имя подпрограммы,за которым последует теперь уже знакомая 'v':</target>
        </trans-unit>
        <trans-unit id="cb9e80e524c6f9e9ce8a182f0f81c0eb761fa3d6" translate="yes" xml:space="preserve">
          <source>Now we'll run &quot;&lt;code&gt;perl Makefile.PL&lt;/code&gt; &quot;. This will create a real Makefile, which make needs. Its output looks something like:</source>
          <target state="translated">Теперь запустим &quot; &lt;code&gt;perl Makefile.PL&lt;/code&gt; &quot;. Это создаст настоящий Makefile, в котором содержатся потребности. Его вывод выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="2de2aee884a419878e3de43e61bda1852424c1b9" translate="yes" xml:space="preserve">
          <source>Now we'll test that we got that space-at-the-beginning business right:</source>
          <target state="translated">Теперь мы проверим,что у нас есть место в начальном бизнесе правильно:</target>
        </trans-unit>
        <trans-unit id="ee9f66c8ea145e68aa8eae836da50bbcb17dec57" translate="yes" xml:space="preserve">
          <source>Now we're finally ready to go: we have compiled Perl byte code, and all that's left to do is run it. The actual execution is done by the &lt;code&gt;runops_standard&lt;/code&gt; function in</source>
          <target state="translated">Теперь мы, наконец, готовы к работе: мы скомпилировали байтовый код Perl, и все, что осталось сделать, это запустить его. Фактическое выполнение выполняется функцией &lt;code&gt;runops_standard&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="952f473e58faf0d44b6ff273d0893bc5ac586a94" translate="yes" xml:space="preserve">
          <source>Now when you run it, perl complains about the 3 undeclared variables and we get four error messages because one variable is referenced twice:</source>
          <target state="translated">Теперь,когда вы его запускаете,perl жалуется на 3 необъявленные переменные,и мы получаем четыре сообщения об ошибках,потому что на одну переменную ссылаются дважды:</target>
        </trans-unit>
        <trans-unit id="0876df351c2b288f71557a0b6c1ab72f84bc0972" translate="yes" xml:space="preserve">
          <source>Now you can add new rows. What about adding new columns? If you're dealing with just matrices, it's often easiest to use simple assignment:</source>
          <target state="translated">Теперь вы можете добавлять новые строки.А как насчет добавления новых столбцов? Если Вы имеете дело только с матрицами,то часто проще всего использовать простое задание:</target>
        </trans-unit>
        <trans-unit id="2be97d39881315756923220b5afaca5ad300443e" translate="yes" xml:space="preserve">
          <source>Now you can check whether &lt;code&gt;$is_blue{$some_color}&lt;/code&gt; . It might have been a good idea to keep the blues all in a hash in the first place.</source>
          <target state="translated">Теперь вы можете проверить, есть ли &lt;code&gt;$is_blue{$some_color}&lt;/code&gt; . Возможно, было бы хорошей идеей сначала держать все блюз в кучу.</target>
        </trans-unit>
        <trans-unit id="1ee59fdf448204f1b7cf0a44d5a105acb3af778e" translate="yes" xml:space="preserve">
          <source>Now you can compile Perl. Type:</source>
          <target state="translated">Теперь ты можешь собрать Perl.Введите:</target>
        </trans-unit>
        <trans-unit id="dc97bf08f7c15142a6f3d523c401171e1e4e28c7" translate="yes" xml:space="preserve">
          <source>Now you can generate the binary distribution. This is done by running the test of the CPAN distribution &lt;code&gt;OS2::SoftInstaller&lt;/code&gt; . Tune up the file</source>
          <target state="translated">Теперь вы можете сгенерировать двоичное распределение. Это делается путем запуска теста дистрибутива CPAN &lt;code&gt;OS2::SoftInstaller&lt;/code&gt; . Настроить файл</target>
        </trans-unit>
        <trans-unit id="b5488e33f64416e81673146fac575b55bb707541" translate="yes" xml:space="preserve">
          <source>Now you can rename the file</source>
          <target state="translated">Теперь вы можете переименовать файл</target>
        </trans-unit>
        <trans-unit id="b4dfea4420493c8513c6f853fcbb48064d4dcaa8" translate="yes" xml:space="preserve">
          <source>Now you can start it with the following (SDF) command:</source>
          <target state="translated">Теперь вы можете запустить его с помощью следующей команды (SDF):</target>
        </trans-unit>
        <trans-unit id="e91ff17e6547bed1e530a38f7ea777276f8d4972" translate="yes" xml:space="preserve">
          <source>Now you can write</source>
          <target state="translated">Теперь вы можете писать</target>
        </trans-unit>
        <trans-unit id="6e8bd31d0e13ce896668841f465f0182170d2759" translate="yes" xml:space="preserve">
          <source>Now you can write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Теперь вы можете писать в этот дескриптор файла, используя любой из &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdb28492c5cef9c671966ba77fa7de09ce89c81d" translate="yes" xml:space="preserve">
          <source>Now you can.</source>
          <target state="translated">Теперь ты можешь.</target>
        </trans-unit>
        <trans-unit id="1a87b9f63332f9de75bca22552a19ed7ae7967b2" translate="yes" xml:space="preserve">
          <source>Now you cannot alter &lt;code&gt;$PI&lt;/code&gt; , which is probably a good thing all in all. This isn't the same as a constant subroutine, which is subject to optimization at compile-time. A constant subroutine is one prototyped to take no arguments and to return a constant expression. See &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; for details on these. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; pragma is a convenient shorthand for these.</source>
          <target state="translated">Теперь вы не можете изменить &lt;code&gt;$PI&lt;/code&gt; , что, вероятно, в целом хорошо. Это не то же самое, что подпрограмма с константой, которая подлежит оптимизации во время компиляции. Подпрограмма с константой - это прототип, который не принимает аргументов и возвращает постоянное выражение. Подробности смотрите в &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; Прагма является удобным сокращением для них.</target>
        </trans-unit>
        <trans-unit id="c321db61248ffe9e9cd3c5b03c9c5342de8be25b" translate="yes" xml:space="preserve">
          <source>Now you check whether $is_tiny_prime[$some_number].</source>
          <target state="translated">Теперь вы проверяете,$is_tiny_prime[$some_number]ли $is_tiny_prime[$some_number].</target>
        </trans-unit>
        <trans-unit id="83fe5a64ce5d7ca3309f06409d39b88da08832f7" translate="yes" xml:space="preserve">
          <source>Now you have all the necessary</source>
          <target state="translated">Теперь у вас есть все необходимое</target>
        </trans-unit>
        <trans-unit id="8fc27d587ac3ae46eb6cab078485ce4e120d86fc" translate="yes" xml:space="preserve">
          <source>Now you have the entire POD document as one great big parse-tree. You can even use the &lt;b&gt;-expand_seq&lt;/b&gt; option to &lt;b&gt;parse_text&lt;/b&gt; to insert whole different kinds of objects. Just don't expect &lt;b&gt;Pod::Parser&lt;/b&gt; to know what to do with them after that. That will need to be in your code. Or, alternatively, you can insert any object you like so long as it conforms to the &lt;b&gt;Pod::ParseTree&lt;/b&gt; interface.</source>
          <target state="translated">Теперь у вас есть весь документ POD как одно большое дерево синтаксического анализа. Вы даже можете использовать параметр &lt;b&gt;-expand_seq&lt;/b&gt; для &lt;b&gt;parse_text,&lt;/b&gt; чтобы вставлять различные типы объектов. Только не ждите, что &lt;b&gt;Pod :: Parser&lt;/b&gt; узнает, что с ними делать после этого. Это должно быть в вашем коде. Или, в качестве альтернативы, вы можете вставить любой объект, который вам нравится, если он соответствует интерфейсу &lt;b&gt;Pod :: ParseTree&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="eb427c950b9b31bacabe117fb02e576d6e7f4125" translate="yes" xml:space="preserve">
          <source>Now you may use functions like &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; on that handle. Probably the most common input function is the one that looks like an operator:</source>
          <target state="translated">Теперь вы можете использовать для этого дескриптора такие функции, как &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; . Вероятно, самая распространенная функция ввода - это та, которая выглядит как оператор:</target>
        </trans-unit>
        <trans-unit id="6e6caee9b93719c7443bbaefae78111aa87180e8" translate="yes" xml:space="preserve">
          <source>Now you should be very careful that the outer bracket type is a round one, that is, a parenthesis. That's because you're assigning to an @array, so you need parentheses. If you wanted there</source>
          <target state="translated">Теперь нужно быть очень осторожным,чтобы тип внешней скобки был круглым,то есть скобкой.Это потому,что вы назначаете @array,так что вам нужны скобки.Если бы вы хотели</target>
        </trans-unit>
        <trans-unit id="62389bcb5052013362af7bc38fbef11d7810e62d" translate="yes" xml:space="preserve">
          <source>Now you're ready to build:</source>
          <target state="translated">Теперь ты готов строить:</target>
        </trans-unit>
        <trans-unit id="3894685c626d75138daa573dc3cd4fad72278a40" translate="yes" xml:space="preserve">
          <source>Now your IO would be ASCII on ASCII partitions and EBCDIC on EBCDIC partitions. See the documentation of PerlIO (without &lt;code&gt;Encode::&lt;/code&gt; !) for further possibilities.</source>
          <target state="translated">Теперь ваш IO будет ASCII для разделов ASCII и EBCDIC для разделов EBCDIC. См. Документацию PerlIO (без &lt;code&gt;Encode::&lt;/code&gt; !) Для получения дополнительных сведений .</target>
        </trans-unit>
        <trans-unit id="4c0c77aa49899b95cf7b7a3e733f8b2e46061080" translate="yes" xml:space="preserve">
          <source>Now!</source>
          <target state="translated">Now!</target>
        </trans-unit>
        <trans-unit id="09be148c7c1b618a5b7b7231898ec72cf009f060" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-h24&lt;/code&gt; will set the option &lt;code&gt;h&lt;/code&gt; to &lt;code&gt;24&lt;/code&gt; , but option bundles like &lt;code&gt;-vxa&lt;/code&gt; and &lt;code&gt;-h24w80&lt;/code&gt; are flagged as errors.</source>
          <target state="translated">Теперь &lt;code&gt;-h24&lt;/code&gt; установит для параметра &lt;code&gt;h&lt;/code&gt; значение &lt;code&gt;24&lt;/code&gt; , но пакеты параметров, такие как &lt;code&gt;-vxa&lt;/code&gt; и &lt;code&gt;-h24w80&lt;/code&gt; ,помечаются как ошибки.</target>
        </trans-unit>
        <trans-unit id="7064702c1fdf6342dfeda7047d72edc982aef863" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-vax&lt;/code&gt; will set the option &lt;code&gt;vax&lt;/code&gt; .</source>
          <target state="translated">Теперь &lt;code&gt;-vax&lt;/code&gt; установит параметр &lt;code&gt;vax&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02476416df4a3a9b63bb6cb2d8be8955b7c384a2" translate="yes" xml:space="preserve">
          <source>Now, as to what you may want to do with these handlers: Maybe you'd want to log what key failed for what class, and then die. Maybe you don't like &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; and instead you want to send the error message to STDOUT (or wherever) and then merely &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Теперь о том, что вы можете делать с этими обработчиками: возможно, вы захотите записать, какой ключ не удалось для какого класса, а затем умереть. Возможно, вам не нравится &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , и вместо этого вы хотите отправить сообщение об ошибке в STDOUT (или куда-нибудь еще), а затем просто &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd735cb44e720407db2d25db6e1b3a8402f3fbeb" translate="yes" xml:space="preserve">
          <source>Now, because the top level contains only references, if you try to print out your array in with a simple print() function, you'll get something that doesn't look very nice, like this:</source>
          <target state="translated">Теперь,поскольку верхний уровень содержит только ссылки,если вы попытаетесь распечатать ваш массив с помощью простой функции print(),вы получите что-то,что выглядит не очень хорошо,например,вот так:</target>
        </trans-unit>
        <trans-unit id="7f590569b440fce72262993e0bb83b771d091b6a" translate="yes" xml:space="preserve">
          <source>Now, consider this:</source>
          <target state="translated">А теперь подумай об этом:</target>
        </trans-unit>
        <trans-unit id="0caa48ba5eb7d274e599b06285edb5dacdee51ca" translate="yes" xml:space="preserve">
          <source>Now, even &lt;code&gt;[0-9]&lt;/code&gt; can be a bother to write multiple times, so in the interest of saving keystrokes and making regexps more readable, Perl has several abbreviations for common character classes, as shown below. Since the introduction of Unicode, unless the &lt;code&gt;//a&lt;/code&gt; modifier is in effect, these character classes match more than just a few characters in the ASCII range.</source>
          <target state="translated">Теперь даже &lt;code&gt;[0-9]&lt;/code&gt; может быть затруднительным записывать несколько раз, поэтому в интересах сохранения нажатий клавиш и повышения читабельности регулярных выражений Perl имеет несколько сокращений для общих классов символов, как показано ниже. С момента введения Unicode, если не &lt;code&gt;//a&lt;/code&gt; модификатор // a , эти классы символов соответствуют более чем нескольким символам в диапазоне ASCII.</target>
        </trans-unit>
        <trans-unit id="fd3c643f4f95c9c07182bc1371cc9ce99bbbace4" translate="yes" xml:space="preserve">
          <source>Now, if &lt;code&gt;junk&lt;/code&gt; is the same as the string we're trying to add, we can grab the string directly from the SV; &lt;code&gt;SvPVX&lt;/code&gt; is the address of the PV in the SV.</source>
          <target state="translated">Теперь, если &lt;code&gt;junk&lt;/code&gt; совпадает со строкой, которую мы пытаемся добавить, мы можем получить строку прямо из SV; &lt;code&gt;SvPVX&lt;/code&gt; - это адрес PV в SV.</target>
        </trans-unit>
        <trans-unit id="22a7c67c64c0df3c947439ef09bc7a1a5018552e" translate="yes" xml:space="preserve">
          <source>Now, imagine that we want to pack the data for a machine with a different byte-order. First, we'll have to figure out how big the data types on the target machine really are. Let's assume that the longs are 32 bits wide and the shorts are 16 bits wide. You can then rewrite the template as:</source>
          <target state="translated">Теперь представьте,что мы хотим упаковать данные для машины с другим порядком байт.Сначала мы должны выяснить,насколько велики типы данных на целевой машине на самом деле.Предположим,что длины-32 бита в ширину,а шорты-16 бит в ширину.Затем вы можете переписать шаблон как:</target>
        </trans-unit>
        <trans-unit id="c4997e53db961cf2c8c2533b9ab14d20123173fb" translate="yes" xml:space="preserve">
          <source>Now, let's extend the previous example to return both the sum of the parameters and the difference.</source>
          <target state="translated">Теперь расширим предыдущий пример,чтобы вернуть как сумму параметров,так и разницу.</target>
        </trans-unit>
        <trans-unit id="8f4d4098c9d3e30a9e536d0fed12c873a45201c2" translate="yes" xml:space="preserve">
          <source>Now, quite a few people have the Acme Transmogrifier, and you've had to write something to talk the protocol from scratch - you'd almost certainly want to make that into a module. The level at which you pitch it is up to you: you might want protocol-level modules analogous to &lt;a href=&quot;net/smtp&quot;&gt;Net::SMTP&lt;/a&gt; which then talk to higher level modules analogous to &lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Send&quot;&gt;Mail::Send&lt;/a&gt;. The choice is yours, but you do want to get a module out for that server protocol.</source>
          <target state="translated">Теперь у довольно многих людей есть Acme Transmogrifier, и вам пришлось что-то написать, чтобы обсудить протокол с нуля - вы почти наверняка захотите превратить это в модуль. Уровень, на котором вы его продвигаете, зависит от вас: вам могут понадобиться модули уровня протокола, аналогичные &lt;a href=&quot;net/smtp&quot;&gt;Net :: SMTP,&lt;/a&gt; которые затем взаимодействуют с модулями более высокого уровня, аналогичными &lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Send&quot;&gt;Mail :: Send&lt;/a&gt; . Выбор за вами, но вы действительно хотите получить модуль для этого серверного протокола.</target>
        </trans-unit>
        <trans-unit id="f84215108517a61b97d5bb763774a7b31e4947af" translate="yes" xml:space="preserve">
          <source>Now, right after you've just written the above lines, you'd normally have to go open the file ThisProject/I18N/en.pm, and immediately add an entry:</source>
          <target state="translated">Теперь,сразу после того,как вы только что записали вышеуказанные строки,вам обычно нужно открыть файл ThisProject/I18N/en.pm и сразу же добавить запись:</target>
        </trans-unit>
        <trans-unit id="1401c823810e265e57226845c8cc3ee51b8e87e5" translate="yes" xml:space="preserve">
          <source>Now, running make will produce output that looks something like this (some long lines have been shortened for clarity and some extraneous lines have been deleted):</source>
          <target state="translated">Теперь,запустив make,вы получите результат,который выглядит примерно так (некоторые длинные строки были укорочены для ясности,а некоторые посторонние были удалены):</target>
        </trans-unit>
        <trans-unit id="6e07caa5beb0db9ce775e3579183bc779cf639f4" translate="yes" xml:space="preserve">
          <source>Now, say you want to search for the single character &lt;code&gt;/GX/&lt;/code&gt; . Perl doesn't know about Martian, so it'll find the two bytes &quot;GX&quot; in the &quot;I am CVSGXX!&quot; string, even though that character isn't there: it just looks like it is because &quot;SG&quot; is next to &quot;XX&quot;, but there's no real &quot;GX&quot;. This is a big problem.</source>
          <target state="translated">Теперь предположим, что вы хотите найти единственный символ &lt;code&gt;/GX/&lt;/code&gt; . Perl ничего не знает о марсианском языке, поэтому он найдет два байта &amp;laquo;GX&amp;raquo; в &amp;laquo;Я - CVSGXX!&amp;raquo; строка, даже если этого символа нет: просто похоже, что это потому, что &amp;laquo;SG&amp;raquo; стоит рядом с &amp;laquo;XX&amp;raquo;, но настоящего &amp;laquo;GX&amp;raquo; нет. Это большая проблема.</target>
        </trans-unit>
        <trans-unit id="8bf6d464fd8f7b3ee530f1f0a89b5dfa201b3c0c" translate="yes" xml:space="preserve">
          <source>Now, suppose you want to use perlio layers in your XS. We'll use the perlio &lt;code&gt;PerlIO_puts()&lt;/code&gt; function as an example.</source>
          <target state="translated">Теперь предположим, что вы хотите использовать слои Perlio в своем XS. В качестве примера мы воспользуемся функцией Perlio &lt;code&gt;PerlIO_puts()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e40eda745c5999056a9033823cfa2202510fb44" translate="yes" xml:space="preserve">
          <source>Now, that's our data parsed. I suppose what we might want to do now is total up our income and expenditure, and add another line to the end of our ledger - in the same format - saying how much we've brought in and how much we've spent:</source>
          <target state="translated">Итак,это наши данные,проанализированные.Полагаю,что сейчас мы можем захотеть суммировать наши доходы и расходы,и добавить в конце нашей бухгалтерской книги еще одну строку-в том же формате-о том,сколько мы принесли и сколько потратили:</target>
        </trans-unit>
        <trans-unit id="fcbc9f96a1673b30ff5469c8a5fcf6cbd912ecbd" translate="yes" xml:space="preserve">
          <source>Now, the following calls to your function are all completely equivalent:</source>
          <target state="translated">Теперь все следующие вызовы к вашей функции полностью эквивалентны:</target>
        </trans-unit>
        <trans-unit id="54e7adec8d59750fec2768d3623709e37ef7d868" translate="yes" xml:space="preserve">
          <source>Now, using &lt;code&gt;--verbose&lt;/code&gt; on the command line will enable &lt;code&gt;$verbose&lt;/code&gt; , as expected. But it is also allowed to use &lt;code&gt;--noverbose&lt;/code&gt; , which will disable &lt;code&gt;$verbose&lt;/code&gt; by setting its value to &lt;code&gt;0&lt;/code&gt; . Using a suitable default value, the program can find out whether &lt;code&gt;$verbose&lt;/code&gt; is false by default, or disabled by using &lt;code&gt;--noverbose&lt;/code&gt; .</source>
          <target state="translated">Теперь использование &lt;code&gt;--verbose&lt;/code&gt; в командной строке , как и ожидалось, включит &lt;code&gt;$verbose&lt;/code&gt; . Но также можно использовать &lt;code&gt;--noverbose&lt;/code&gt; , который отключит &lt;code&gt;$verbose&lt;/code&gt; , установив для него значение &lt;code&gt;0&lt;/code&gt; . Используя подходящее значение по умолчанию, программа может определить, является ли &lt;code&gt;$verbose&lt;/code&gt; ложным по умолчанию или отключено с помощью &lt;code&gt;--noverbose&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="992feec99ff4aecbf2aadccfe96942e35ec305c6" translate="yes" xml:space="preserve">
          <source>Now, we know that in scalar context, &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; returns a true or false value. In list context, however, it returns the list of matched values &lt;code&gt;($1,$2,$3)&lt;/code&gt; . So we could write the code more compactly as</source>
          <target state="translated">Теперь мы знаем, что в скалярном контексте &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; возвращает истинное или ложное значение. Однако в контексте списка он возвращает список совпадающих значений &lt;code&gt;($1,$2,$3)&lt;/code&gt; . Таким образом, мы могли бы написать код более компактно, как</target>
        </trans-unit>
        <trans-unit id="4be0b7f8c6b8fc26bdc74884bb876598542c7964" translate="yes" xml:space="preserve">
          <source>Now, what if you don't want to capitalize that &quot;and&quot;? Just use &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text::Autoformat&lt;/a&gt; and get on with the next problem. :)</source>
          <target state="translated">А что, если вы не хотите использовать это &amp;laquo;и&amp;raquo; с большой буквы? Просто используйте &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text :: Autoformat&lt;/a&gt; и приступайте к следующей проблеме. :)</target>
        </trans-unit>
        <trans-unit id="8949eed359cb576e341a415acaa483f999c583a5" translate="yes" xml:space="preserve">
          <source>Now, what we've done here is to launch the built-in perl debugger on our script. It's stopped at the first line of executable code and is waiting for input.</source>
          <target state="translated">Теперь,то,что мы сделали здесь,это запустили встроенный отладчик на perl в наш скрипт.Он останавливается в первой строке исполняемого кода и ждет ввода.</target>
        </trans-unit>
        <trans-unit id="fe56adc9244a6c6d673f2a408e82ab0b02f6ba4d" translate="yes" xml:space="preserve">
          <source>Now, what's this about?</source>
          <target state="translated">Так в чем дело?</target>
        </trans-unit>
        <trans-unit id="c09652f2cdfd968ba019444826ddffee8c37ace4" translate="yes" xml:space="preserve">
          <source>Null AV pointer.</source>
          <target state="translated">Нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="449c4d119d699360473af11bb566b4e5b4167f76" translate="yes" xml:space="preserve">
          <source>Null CV pointer.</source>
          <target state="translated">Нулевой указатель CV.</target>
        </trans-unit>
        <trans-unit id="91a48ce7cb8839ea533848a64134cf5805e52ca4" translate="yes" xml:space="preserve">
          <source>Null HV pointer.</source>
          <target state="translated">Указка &quot;Null HV&quot;.</target>
        </trans-unit>
        <trans-unit id="d7c8d520f057dea587bf4d58fd9c051240f622ed" translate="yes" xml:space="preserve">
          <source>Null SV pointer. (No longer available when &lt;code&gt;PERL_CORE&lt;/code&gt; is defined.)</source>
          <target state="translated">Нулевой указатель SV. (Больше не доступно, если определено &lt;code&gt;PERL_CORE&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="ae2f5f2d47b6cb2ea376cf5cd766fe09fd6a57af" translate="yes" xml:space="preserve">
          <source>Null character pointer. (No longer available when &lt;code&gt;PERL_CORE&lt;/code&gt; is defined.)</source>
          <target state="translated">Указатель на нулевой символ. (Больше не доступно, если определено &lt;code&gt;PERL_CORE&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="38b0ef271640da14cdf67cd20db21125619c6b53" translate="yes" xml:space="preserve">
          <source>Nullops appear as &lt;code&gt;ex-opname&lt;/code&gt; , where</source>
          <target state="translated">Нуллопы отображаются как &lt;code&gt;ex-opname&lt;/code&gt; , где</target>
        </trans-unit>
        <trans-unit id="c9d82135ee15642aa7ae8817dc570334ab80622b" translate="yes" xml:space="preserve">
          <source>Number of iterations run.</source>
          <target state="translated">Количество запущенных итераций.</target>
        </trans-unit>
        <trans-unit id="78e655a3cb9b2e5174023b5b4b515e74ae0fcc89" translate="yes" xml:space="preserve">
          <source>Number of lines to save?</source>
          <target state="translated">Количество сохраняемых строк?</target>
        </trans-unit>
        <trans-unit id="3230c13d5bd80dac7aacde117d72a74866ed2d4e" translate="yes" xml:space="preserve">
          <source>Number of significant digits. Leading zeros are not counted. A number may have an accuracy greater than the non-zero digits when there are zeros in it or trailing zeros. For example, 123.456 has A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 and 0.000123 has 3.</source>
          <target state="translated">Количество значащих цифр.Значимые нули не учитываются.Число может иметь точность больше,чем ненулевые цифры,если в нем есть нули или следящие нули.Например,123.456 имеет A 6,10203 имеет 5,123.0506 имеет 7,123.450000 имеет 8 и 0.000123 имеет 3.</target>
        </trans-unit>
        <trans-unit id="6588ae11e1dcdc853623ae99d37042a891fc6f6e" translate="yes" xml:space="preserve">
          <source>Number-of-uses is stored as a 16-bit unsigned integer, so can't exceed 65535.</source>
          <target state="translated">Количество использований хранится как 16-битное беззнаковое целое число,поэтому не может превышать 65535.</target>
        </trans-unit>
        <trans-unit id="86074e1eaaba5bdf1182fbfd1a5e5a087cf06d78" translate="yes" xml:space="preserve">
          <source>Numbered capture callbacks</source>
          <target state="translated">Пронумерованные обратные вызовы на захват</target>
        </trans-unit>
        <trans-unit id="7a23d9255bf80cf55daa9a73c5c3503075a5fb9f" translate="yes" xml:space="preserve">
          <source>Numbers don't need quotes around them:</source>
          <target state="translated">Цифры не нуждаются в кавычках вокруг них:</target>
        </trans-unit>
        <trans-unit id="93fc21b9cdd7d3eceb58c305ecfc300113f08a16" translate="yes" xml:space="preserve">
          <source>Numbers endianness and Width</source>
          <target state="translated">Эндианность и ширина чисел</target>
        </trans-unit>
        <trans-unit id="a356a38fbf19c9a7a85fc1034cb6b13b5959c015" translate="yes" xml:space="preserve">
          <source>Numbers in (parentheses) indicate the total number of Unicode code points matched by the property. For emphasis, those properties that match no code points at all are listed as well in a separate section following the table.</source>
          <target state="translated">Цифры в скобках указывают на общее количество точек кода Юникода,совпадающих со свойством.Для выделения тех свойств,которые вообще не совпадают с точками кода,перечисляются также в отдельном разделе,следующем за таблицей.</target>
        </trans-unit>
        <trans-unit id="56e0145e1d23363006c456eb88791d281e2a1493" translate="yes" xml:space="preserve">
          <source>Numbers in the range 160-255 refer to Latin-1 characters (also defined there by Unicode, with the same meaning). Numbers above 255 should be understood to refer to Unicode characters.</source>
          <target state="translated">Цифры в диапазоне 160-255 относятся к символам латинского алфавита-1 (также определяемым там Юникодом,с тем же значением).Цифры выше 255 должны пониматься как относящиеся к символам Юникода.</target>
        </trans-unit>
        <trans-unit id="bdfe233d649ccb45ebc573d4ee247d96a2053e8c" translate="yes" xml:space="preserve">
          <source>Numeric Fields</source>
          <target state="translated">Числовые поля</target>
        </trans-unit>
        <trans-unit id="6101250ca1afcc59baf36ca28be6209c3291e540" translate="yes" xml:space="preserve">
          <source>Numeric conversion</source>
          <target state="translated">числовое преобразование</target>
        </trans-unit>
        <trans-unit id="231f4ec720e19f9416599261f4322593a7b1d213" translate="yes" xml:space="preserve">
          <source>Numeric functions</source>
          <target state="translated">Числовые функции</target>
        </trans-unit>
        <trans-unit id="684a5952f400383c4099f6088a711c758da11a61" translate="yes" xml:space="preserve">
          <source>Numeric literals are specified in any of the following floating point or integer formats:</source>
          <target state="translated">Числовые литералы задаются в любом из следующих форматов с плавающей точкой или в формате целого числа:</target>
        </trans-unit>
        <trans-unit id="a4e50290598ea70f1c5580bbcbcb1b35364e36b2" translate="yes" xml:space="preserve">
          <source>Numeric operators and numeric conversions</source>
          <target state="translated">Числовые операторы и числовые преобразования</target>
        </trans-unit>
        <trans-unit id="0524b0c0ac8bde27b90181fe29d1e0ee87d85606" translate="yes" xml:space="preserve">
          <source>Numification</source>
          <target state="translated">Numification</target>
        </trans-unit>
        <trans-unit id="9070f7ffe825f6632ea9c8c8c4cb452e5ea710fb" translate="yes" xml:space="preserve">
          <source>Numify returns the number of bytes in the instance data.</source>
          <target state="translated">Нумерация возвращает количество байт в данных экземпляра.</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="54d43a5ef4e27b9c279536a9f91a0f278f1c11b7" translate="yes" xml:space="preserve">
          <source>O - Generic interface to Perl Compiler backends</source>
          <target state="translated">O-Общий интерфейс к бэкэндам Perl-компилятора</target>
        </trans-unit>
        <trans-unit id="2f1e5004dfcf9dde92d5fd30ce523548742521cc" translate="yes" xml:space="preserve">
          <source>OBJ</source>
          <target state="translated">OBJ</target>
        </trans-unit>
        <trans-unit id="886bca430376624f1fa6be07dffa149e06727c43" translate="yes" xml:space="preserve">
          <source>OBJECT METHODS</source>
          <target state="translated">ЦЕЛЕВЫЕ МЕТОДЫ</target>
        </trans-unit>
        <trans-unit id="3d6faefbb52c9934839e9dcd31987ac3958fd8ae" translate="yes" xml:space="preserve">
          <source>OBJECT-ORIENTED FUNDAMENTALS</source>
          <target state="translated">ОБЪЕКТНО-ОРИЕНТИРОВАННЫЕ ОСНОВЫ</target>
        </trans-unit>
        <trans-unit id="edf9874a257ef8b1a94138e136d570010b98cb88" translate="yes" xml:space="preserve">
          <source>OBJECT-ORIENTED INTERFACE</source>
          <target state="translated">ОБЪЕКТНО-ОРИЕНТИРОВАННЫЙ ИНТЕРФЕЙС</target>
        </trans-unit>
        <trans-unit id="83ccf14b6fc5001c270b87a25f6dbd0dd2dbdb90" translate="yes" xml:space="preserve">
          <source>OBJECTS</source>
          <target state="translated">OBJECTS</target>
        </trans-unit>
        <trans-unit id="74d964f379ca5f7a63963447b2e66da24098ac03" translate="yes" xml:space="preserve">
          <source>OCTETS</source>
          <target state="translated">OCTETS</target>
        </trans-unit>
        <trans-unit id="20e099ce66f09623331e4f7ac57998439d896891" translate="yes" xml:space="preserve">
          <source>OK (say, this system-dependent module builds in a subdirectory of some other distribution, or is listed as a dependency in a CPAN::Bundle, but the functionality is supported by different means on the current architecture).</source>
          <target state="translated">OK (скажем,этот зависящий от системы модуль строится в поддиректории какого-нибудь другого дистрибутива,или указан как зависимый в CPAN::Bundle,но функциональность поддерживается разными средствами на текущей архитектуре).</target>
        </trans-unit>
        <trans-unit id="01ac8af6582beb05b51e97a2306cc05bed91ec81" translate="yes" xml:space="preserve">
          <source>OK, as opposed to</source>
          <target state="translated">Хорошо,в отличие от</target>
        </trans-unit>
        <trans-unit id="42c8e2f5d8fdbf542c870810fe22e5463fc2fa22" translate="yes" xml:space="preserve">
          <source>OK, it's a start, but what happened to the spaces? We put &lt;code&gt;x&lt;/code&gt; , didn't we? Shouldn't it skip forward? Let's look at what &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; says:</source>
          <target state="translated">Хорошо, это начало, но что случилось с пробелами? Мы поставили &lt;code&gt;x&lt;/code&gt; , не так ли? Не следует ли перескакивать вперед? Посмотрим, что написано на &lt;a href=&quot;functions/pack&quot;&gt;упаковке&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2244411f280d2b7d311acac7ca58215079a5a39f" translate="yes" xml:space="preserve">
          <source>OK, let's have a look at some of our data again; in fact, we'll include the headers, and a handy ruler so we can keep track of where we are.</source>
          <target state="translated">Хорошо,давайте еще раз взглянем на некоторые из наших данных;на самом деле,мы включим заголовки,и удобную линейку,чтобы мы могли отслеживать,где мы находимся.</target>
        </trans-unit>
        <trans-unit id="02b9f4d433d48fd34c45be1068128628f753ca51" translate="yes" xml:space="preserve">
          <source>OK, so let's bite the bullet. Here's one way to get the alignment right by inserting template codes &lt;code&gt;x&lt;/code&gt; , which don't take a corresponding item from the list:</source>
          <target state="translated">Ладно, давайте перекусим. Вот один из способов получить правильное выравнивание, вставив коды шаблона &lt;code&gt;x&lt;/code&gt; , которые не берут соответствующий элемент из списка:</target>
        </trans-unit>
        <trans-unit id="55cced79fbf573273c9277ae4c911cbf530c88fb" translate="yes" xml:space="preserve">
          <source>OK, the last one was actually an Obfuscated Perl Contest entry. :-)</source>
          <target state="translated">Хорошо,последняя запись была на самом деле Обфусцированным Perl Contest.:-)</target>
        </trans-unit>
        <trans-unit id="57ecc84fea778a647ea6d7f2310ef9bca45201e0" translate="yes" xml:space="preserve">
          <source>OK, what's next? Between the date and the description is a blank column; we want to skip over that. The &lt;code&gt;x&lt;/code&gt; template means &quot;skip forward&quot;, so we want one of those. Next, we have another batch of characters, from 12 to 38. That's 27 more characters, hence &lt;code&gt;A27&lt;/code&gt; . (Don't make the fencepost error - there are 27 characters between 12 and 38, not 26. Count 'em!)</source>
          <target state="translated">Хорошо, что дальше? Между датой и описанием стоит пустой столбец; мы хотим пропустить это. В &lt;code&gt;x&lt;/code&gt; означает шаблон &amp;laquo;пропустить вперед&amp;raquo;, поэтому мы хотим , чтобы один из них. Затем у нас есть еще одна группа символов, от 12 до 38. Это еще 27 символов, отсюда &lt;code&gt;A27&lt;/code&gt; . (Не делайте ошибку столбика забора - от 12 до 38 символов 27, а не 26. Считайте их!)</target>
        </trans-unit>
        <trans-unit id="8f26553401469ee2b31b15d3391338fc7e46d2bc" translate="yes" xml:space="preserve">
          <source>OK, you know the basics of regexps and you want to know more. If matching regular expressions is analogous to a walk in the woods, then the tools discussed in Part 1 are analogous to topo maps and a compass, basic tools we use all the time. Most of the tools in part 2 are analogous to flare guns and satellite phones. They aren't used too often on a hike, but when we are stuck, they can be invaluable.</source>
          <target state="translated">Ладно,ты знаешь основы регэкспрессов и хочешь знать больше.Если совпадение регулярных выражений аналогично прогулке в лесу,то инструменты,обсуждаемые в части 1,аналогичны топокартам и компасу,базовым инструментам,которыми мы постоянно пользуемся.Большинство инструментов в части 2 аналогичны ракетным установкам и спутниковым телефонам.Они не очень часто используются в походах,но когда мы застряли,они могут быть бесценны.</target>
        </trans-unit>
        <trans-unit id="2171105911206b856b529e816e5973ea3d92c2e5" translate="yes" xml:space="preserve">
          <source>OK. That's the C part done. Now we must do two additional things before this patch is ready to go: we've changed the behaviour of Perl, and so we must document that change. We must also provide some more regression tests to make sure our patch works and doesn't create a bug somewhere else along the line.</source>
          <target state="translated">ХОРОШО.Это часть С закончена.Теперь мы должны сделать две дополнительные вещи,прежде чем патч будет готов к использованию:мы изменили поведение Perl,и поэтому мы должны задокументировать это изменение.Мы также должны предоставить еще несколько регрессионных тестов,чтобы убедиться,что наш патч работает и не создает ошибку где-нибудь еще.</target>
        </trans-unit>
        <trans-unit id="52e443591494f06d89603d027dbcc15ec5f21ac5" translate="yes" xml:space="preserve">
          <source>OLD BUILD INSTRUCTIONS</source>
          <target state="translated">СТАРЫЕ ИНСТРУКЦИИ ПО СТРОИТЕЛЬСТВУ</target>
        </trans-unit>
        <trans-unit id="1b8244806f0fe85fbdfb28350aa4197cefa6d7d6" translate="yes" xml:space="preserve">
          <source>OLD PERL VERSIONS</source>
          <target state="translated">СТАРЫЕ ВЕРСИИ PERL</target>
        </trans-unit>
        <trans-unit id="b25c8ed636326794258081a0a80bab33a84b2f10" translate="yes" xml:space="preserve">
          <source>ONE STEP FORWARD</source>
          <target state="translated">НА ОДИН ШАГ ВПЕРЕД</target>
        </trans-unit>
        <trans-unit id="3265add34ef90b3d5d5f9d59898e2a3656834e0f" translate="yes" xml:space="preserve">
          <source>ONE STEP SIDEWAYS</source>
          <target state="translated">ОДИН ШАГ В СТОРОНУ</target>
        </trans-unit>
        <trans-unit id="3b12b54c6a3deda565624403d547e7ef70be9c7d" translate="yes" xml:space="preserve">
          <source>ONFAIL</source>
          <target state="translated">ONFAIL</target>
        </trans-unit>
        <trans-unit id="b144599df5b9973435563870d7ba296904ec1710" translate="yes" xml:space="preserve">
          <source>ONLY</source>
          <target state="translated">ONLY</target>
        </trans-unit>
        <trans-unit id="e3c4c3d0eba1879f6f92c682389bed6ffbf94f06" translate="yes" xml:space="preserve">
          <source>OO INTERFACE</source>
          <target state="translated">ООО &quot;ИНТЕРФЕЙС</target>
        </trans-unit>
        <trans-unit id="1433bf1bd15078b056fe76d6547c4bb2a283c920" translate="yes" xml:space="preserve">
          <source>OO Interface</source>
          <target state="translated">интерфейс ООО</target>
        </trans-unit>
        <trans-unit id="e9a2811eef61d81b9e5a20155aec53e34b502e28" translate="yes" xml:space="preserve">
          <source>OO Perl</source>
          <target state="translated">ООО &quot;Перл</target>
        </trans-unit>
        <trans-unit id="3615e232deb829e0d1569b8035de6913840b260b" translate="yes" xml:space="preserve">
          <source>OO Perl is relatively simple and is implemented using references which know what sort of object they are based on Perl's concept of packages. However, OO Perl is largely beyond the scope of this document. Read &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; and &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">OO Perl относительно прост и реализован с использованием ссылок, которые знают, какой тип объектов они основаны на концепции пакетов Perl. Однако OO Perl в значительной степени выходит за рамки этого документа. Прочтите &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; и &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2141f42c40de947ddd0e477a1e88d39467ae8b5d" translate="yes" xml:space="preserve">
          <source>OO System Summary</source>
          <target state="translated">Системная сводка ООО</target>
        </trans-unit>
        <trans-unit id="e22cbd43f54a4419ac3832ce3ab610e1f892e4aa" translate="yes" xml:space="preserve">
          <source>OO interface to the select system call</source>
          <target state="translated">Интерфейс OO к выбранному системному вызову</target>
        </trans-unit>
        <trans-unit id="50841444197610a772ed0bf8061ebbec3fb69d4e" translate="yes" xml:space="preserve">
          <source>OO interface to users netrc file</source>
          <target state="translated">OO-интерфейс к файлу netrc пользователей</target>
        </trans-unit>
        <trans-unit id="e5646c2e78bf00bf2def681a7c47f39c5c233aee" translate="yes" xml:space="preserve">
          <source>OOP style</source>
          <target state="translated">стиль ООП</target>
        </trans-unit>
        <trans-unit id="01de497f472a97643f711e0af439f57cbf98b7cc" translate="yes" xml:space="preserve">
          <source>OP TREES</source>
          <target state="translated">ОПЫ</target>
        </trans-unit>
        <trans-unit id="d97b094405ac341f25845d574d3003452633970d" translate="yes" xml:space="preserve">
          <source>OP class abbreviations</source>
          <target state="translated">аббревиатуры класса ОП</target>
        </trans-unit>
        <trans-unit id="e5a964607f5e2d840aa946796053a87561ef64ff" translate="yes" xml:space="preserve">
          <source>OP flags abbreviations</source>
          <target state="translated">аббревиатуры флагов ОП</target>
        </trans-unit>
        <trans-unit id="c0c894eca9e57589b7dd798f6fc13ef59d8fced2" translate="yes" xml:space="preserve">
          <source>OP flags are either public or private. The public flags alter the behavior of each opcode in consistent ways, and are represented by 0 or more single characters.</source>
          <target state="translated">Флаги ОП являются либо государственными,либо частными.Общедоступные флаги изменяют поведение каждого опкода последовательными способами и представлены 0 или более единичными символами.</target>
        </trans-unit>
        <trans-unit id="4bddb20f13d7f760a35db0afa01405e65b1c65f3" translate="yes" xml:space="preserve">
          <source>OP-RELATED CLASSES</source>
          <target state="translated">СВЯЗАННЫЕ С ОПЕРАЦИЕЙ КЛАССЫ</target>
        </trans-unit>
        <trans-unit id="9931dad0f7eb6ff4da51ab9c192c2a065a7d0255" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="translated">OPERATION - это один из LOCK_SH, LOCK_EX или LOCK_UN, возможно в сочетании с LOCK_NB. Эти константы традиционно имеют значения 1, 2, 8 и 4, но вы можете использовать символьные имена, если импортируете их из модуля &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; либо по отдельности, либо как группу с помощью тега &lt;code&gt;:&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . LOCK_SH запрашивает разделяемую блокировку, LOCK_EX запрашивает исключительную блокировку, а LOCK_UN освобождает ранее запрошенную блокировку. Если LOCK_NB побитовое ИЛИ с LOCK_SH или LOCK_EX, тогда &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; возвращается немедленно, а не блокирует ожидание блокировки; проверьте статус возврата, чтобы узнать, получили ли вы его.</target>
        </trans-unit>
        <trans-unit id="5806c98abb4bc38de2885393f139558efaa4744b" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="translated">OPERATION - это один из LOCK_SH, LOCK_EX или LOCK_UN, возможно в сочетании с LOCK_NB. Эти константы традиционно имеют значения 1, 2, 8 и 4, но вы можете использовать символьные имена, если импортируете их из модуля &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; либо по отдельности, либо как группу с помощью тега &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . LOCK_SH запрашивает разделяемую блокировку, LOCK_EX запрашивает исключительную блокировку, а LOCK_UN освобождает ранее запрошенную блокировку. Если LOCK_NB побитовое ИЛИ с LOCK_SH или LOCK_EX, тогда &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; возвращается немедленно, а не блокирует ожидание блокировки; проверьте статус возврата, чтобы узнать, получили ли вы его.</target>
        </trans-unit>
        <trans-unit id="277a5e5c068658adb7eeea0e8ac338b111cfff2f" translate="yes" xml:space="preserve">
          <source>OPERATIONS</source>
          <target state="translated">OPERATIONS</target>
        </trans-unit>
        <trans-unit id="ae6eaba46b51b460ad70f762d13737864d558ddb" translate="yes" xml:space="preserve">
          <source>OPERATOR DIFFERENCES</source>
          <target state="translated">РАЗЛИЧИЯ ОПЕРАТОРОВ</target>
        </trans-unit>
        <trans-unit id="3b9833465b980fc8907d152fbd1be4ed82789a85" translate="yes" xml:space="preserve">
          <source>OPERATORS</source>
          <target state="translated">OPERATORS</target>
        </trans-unit>
        <trans-unit id="2d0b2762a37fa9b498b0ef0041758a02e1b217bd" translate="yes" xml:space="preserve">
          <source>OPTIONAL SUBROUTINE/METHOD OVERRIDES</source>
          <target state="translated">ДОПОЛНИТЕЛЬНЫЕ ПОДПРОГРАММЫ/ПЕРЕХОДЫ МЕТОДОВ</target>
        </trans-unit>
        <trans-unit id="3c86eca6569badf198a635b289a628e0713ed7b0" translate="yes" xml:space="preserve">
          <source>OPTIONAL-INFO</source>
          <target state="translated">OPTIONAL-INFO</target>
        </trans-unit>
        <trans-unit id="39dd320e8c4e9f06b35e0be0b4942ac2022fb9c1" translate="yes" xml:space="preserve">
          <source>OPTIONS</source>
          <target state="translated">OPTIONS</target>
        </trans-unit>
        <trans-unit id="cfee3b3e47c3ccac4481ec3d455bf43de1a65fd1" translate="yes" xml:space="preserve">
          <source>OPTIONS AND ARGUMENTS</source>
          <target state="translated">ВАРИАНТЫ И АРГУМЕНТЫ</target>
        </trans-unit>
        <trans-unit id="6409ae0433181a6f096278e81922ef91fcf094d5" translate="yes" xml:space="preserve">
          <source>OPTIONS/ARGUMENTS</source>
          <target state="translated">OPTIONS/ARGUMENTS</target>
        </trans-unit>
        <trans-unit id="d02651d637b66f91c995f98ff893920c6613a814" translate="yes" xml:space="preserve">
          <source>OPTS consists of any of the options that are available when creating the &lt;code&gt;$z&lt;/code&gt; object.</source>
          <target state="translated">OPTS состоит из любых параметров, доступных при создании объекта &lt;code&gt;$z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34e983dffbba74010d0b834918e8b9de427ff5bf" translate="yes" xml:space="preserve">
          <source>OPTS is a combination of the following options:</source>
          <target state="translated">OPTS является комбинацией следующих опций:</target>
        </trans-unit>
        <trans-unit id="6b6a53f5c91030f120c92b395563cf165ba2b731" translate="yes" xml:space="preserve">
          <source>ORcpt is also part of the SMTP DSN extension according to RFC3461. It is used to pass along the original recipient that the mail was first sent to. The machine that generates a DSN will use this address to inform the sender, because he can't know if recipients get rewritten by mail servers. It is expected to be in a format as required by RFC3461, xtext-encoded.</source>
          <target state="translated">ORcpt также является частью SMTP DSN расширения согласно RFC3461.Оно используется для передачи оригинального получателя,которому почта была отправлена в первую очередь.Машина,генерирующая DSN,будет использовать этот адрес для информирования отправителя,поскольку он не может знать,переписываются ли получатели почтовыми серверами.Предполагается,что он должен быть в формате,требуемом RFC3461,с xtext-кодировкой.</target>
        </trans-unit>
        <trans-unit id="3e55c8accb9b59a4e2e3860b73d18e283bd63d08" translate="yes" xml:space="preserve">
          <source>OS ISSUES</source>
          <target state="translated">ОС ОС ОС</target>
        </trans-unit>
        <trans-unit id="ca7db916096936ab02b469184b00a31ffb7e99f9" translate="yes" xml:space="preserve">
          <source>OS adjusted ExtUtils::MakeMaker subclass</source>
          <target state="translated">Настройка ОС Экстравиатуры::Подкласс MakeMaker</target>
        </trans-unit>
        <trans-unit id="a507b0570eef10c513490b530ff7cffb662e9519" translate="yes" xml:space="preserve">
          <source>OS level</source>
          <target state="translated">уровень ОС</target>
        </trans-unit>
        <trans-unit id="53b5eb00477f53acb0522cf8349b912973394461" translate="yes" xml:space="preserve">
          <source>OS-Related References</source>
          <target state="translated">Связанные с ОС ссылки</target>
        </trans-unit>
        <trans-unit id="49f5479219ce3d4b44c672d19081b527acbff3f8" translate="yes" xml:space="preserve">
          <source>OS/2</source>
          <target state="translated">OS/2</target>
        </trans-unit>
        <trans-unit id="c2ee378ae6f39b56008cc84e4ccbbff11e3e4428" translate="yes" xml:space="preserve">
          <source>OS/2 _.INF_ file</source>
          <target state="translated">OS/2 _.INF_файл</target>
        </trans-unit>
        <trans-unit id="8170ede7c45b17e28c246c077e40c6bb259a2169" translate="yes" xml:space="preserve">
          <source>OS/2 is OS/2</source>
          <target state="translated">OS/2-это OS/2</target>
        </trans-unit>
        <trans-unit id="9f2b9449bdc8f69e4d1ebfaee7720b50c48e466a" translate="yes" xml:space="preserve">
          <source>OS/2 toolkit</source>
          <target state="translated">набор инструментов OS/2</target>
        </trans-unit>
        <trans-unit id="1adfaba1d7ff8cc9090d93cbfe1b050db4768533" translate="yes" xml:space="preserve">
          <source>OS/390 will support the &lt;code&gt;#!&lt;/code&gt; shebang trick in release 2.8 and beyond. Calls to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and backticks can use POSIX shell syntax on all S/390 systems.</source>
          <target state="translated">OS / 390 будет поддерживать &lt;code&gt;#!&lt;/code&gt; трюк shebang в версии 2.8 и выше. Вызовы &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; и обратные кавычки могут использовать синтаксис оболочки POSIX во всех системах S / 390.</target>
        </trans-unit>
        <trans-unit id="1d34b2e0115c599698c2eaf50db89fcc832b02bf" translate="yes" xml:space="preserve">
          <source>OS/390, z/OS</source>
          <target state="translated">OS/390,z/OS</target>
        </trans-unit>
        <trans-unit id="0a302d149142b54ba805c25c7803eba208bb0727" translate="yes" xml:space="preserve">
          <source>OS/400</source>
          <target state="translated">OS/400</target>
        </trans-unit>
        <trans-unit id="7ffcc4aa191d7c21c744cd8b5d4c95af4f197345" translate="yes" xml:space="preserve">
          <source>OSPEED</source>
          <target state="translated">OSPEED</target>
        </trans-unit>
        <trans-unit id="957c024b38ce820878f03177ce3d2b83c26a82d0" translate="yes" xml:space="preserve">
          <source>OTHER</source>
          <target state="translated">OTHER</target>
        </trans-unit>
        <trans-unit id="5d6ab2bf42c29199bc2595a18bf166b2ca9d58db" translate="yes" xml:space="preserve">
          <source>OTHER COMPONENTS</source>
          <target state="translated">ПРОЧИЕ КОМПОНЕНТЫ</target>
        </trans-unit>
        <trans-unit id="f6c2b40e6c72a2bb0b41071005914975b421d2b3" translate="yes" xml:space="preserve">
          <source>OTHER FACILITIES</source>
          <target state="translated">ДРУГИЕ УЧРЕЖДЕНИЯ</target>
        </trans-unit>
        <trans-unit id="b9ed1fc6bda9c1de960a484858190276f8547802" translate="yes" xml:space="preserve">
          <source>OTHER FUNCTIONS</source>
          <target state="translated">ДРУГИЕ ФУНКЦИИ</target>
        </trans-unit>
        <trans-unit id="cf1596fa6b124742caf502c819fa40b64395f706" translate="yes" xml:space="preserve">
          <source>OUTPUT TIPS</source>
          <target state="translated">ВЫХОДНЫЕ СОВЕТЫ</target>
        </trans-unit>
        <trans-unit id="a32824f28f79811519a5acdabe1d4b373c40ef62" translate="yes" xml:space="preserve">
          <source>OVERRIDDEN METHODS</source>
          <target state="translated">ПЕРЕОПРЕДЕЛЁННЫЕ МЕТОДЫ</target>
        </trans-unit>
        <trans-unit id="bf6107f87a0ec04cb2b618d76df7646acae50937" translate="yes" xml:space="preserve">
          <source>OVERRIDES</source>
          <target state="translated">OVERRIDES</target>
        </trans-unit>
        <trans-unit id="be5d4c45f4cd36cced53ba6c4c1d80a8493a95f3" translate="yes" xml:space="preserve">
          <source>OVERRIDING CORE FUNCTIONS</source>
          <target state="translated">ОСНОВНЫЕ ФУНКЦИИ</target>
        </trans-unit>
        <trans-unit id="f275fdb83760cf7f81c0389520bf2b7351b38004" translate="yes" xml:space="preserve">
          <source>OVERVIEW</source>
          <target state="translated">OVERVIEW</target>
        </trans-unit>
        <trans-unit id="fe6d13a6636d2e856ee66d1e674b0c568eee0ba0" translate="yes" xml:space="preserve">
          <source>OVERVIEW OF CLASSES</source>
          <target state="translated">ОБЗОР КЛАССОВ</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="f0e2a5cc2614159a14f8d24f77aff8cedbb91395" translate="yes" xml:space="preserve">
          <source>Object Methods</source>
          <target state="translated">Методы объекта</target>
        </trans-unit>
        <trans-unit id="7a403b426b3138de1314edbedb502e24fe00906c" translate="yes" xml:space="preserve">
          <source>Object Orientation is not the best solution to every problem. In</source>
          <target state="translated">Ориентация на объект-не лучшее решение каждой проблемы.На сайте</target>
        </trans-unit>
        <trans-unit id="0576faceb2bc930743ea41920355c65b4ff2f401" translate="yes" xml:space="preserve">
          <source>Object Oriented Encoder</source>
          <target state="translated">Объектно-ориентированный кодировщик</target>
        </trans-unit>
        <trans-unit id="1328c7cddf5e1741e60ae0ea7e9cd25feb10a44d" translate="yes" xml:space="preserve">
          <source>Object Oriented time objects</source>
          <target state="translated">Объектно-ориентированные объекты времени</target>
        </trans-unit>
        <trans-unit id="c2554e1cb290677a2fc70d0a43154bdf1c0148ab" translate="yes" xml:space="preserve">
          <source>Object interface for AF_INET domain sockets</source>
          <target state="translated">Объектный интерфейс для доменных сокетов AF_INET</target>
        </trans-unit>
        <trans-unit id="93e56d8e38067f0fd87b11c1619713b42509ffd1" translate="yes" xml:space="preserve">
          <source>Object interface for AF_UNIX domain sockets</source>
          <target state="translated">Объектный интерфейс для доменных сокетов AF_UNIX</target>
        </trans-unit>
        <trans-unit id="3d662b2d2b28e92fa294d9f80685e9709d96e1ab" translate="yes" xml:space="preserve">
          <source>Object interface to socket communications</source>
          <target state="translated">Интерфейс объекта для связи с сокетами</target>
        </trans-unit>
        <trans-unit id="c9adffadbed4d834ac5b856b003595a5f887d57f" translate="yes" xml:space="preserve">
          <source>Object interface to system poll call</source>
          <target state="translated">Интерфейс объекта для вызова системного опроса</target>
        </trans-unit>
        <trans-unit id="cc8d552e462d1eb5f26cd8f9fdf1f0a8654a0735" translate="yes" xml:space="preserve">
          <source>Object interface:</source>
          <target state="translated">Интерфейс объекта:</target>
        </trans-unit>
        <trans-unit id="a4fd25b923092435b59d8ba7f9a4eeafbcc983ac" translate="yes" xml:space="preserve">
          <source>Object oriented interface</source>
          <target state="translated">Объектно-ориентированный интерфейс</target>
        </trans-unit>
        <trans-unit id="e5fa350c821e5eff6e8a902ebb2f0731d1bbc634" translate="yes" xml:space="preserve">
          <source>Object registry is best done when the object is initialized for use with a class. That way, garbage collection and thread safety are established for every object and every field that is initialized.</source>
          <target state="translated">Реестр объектов лучше всего делать,когда объект инициализирован для использования с классом.Таким образом,сборщик мусора и безопасность потока устанавливается для каждого объекта и каждого инициализированного поля.</target>
        </trans-unit>
        <trans-unit id="00830e1926297b7c355fe1aa06dab72200595135" translate="yes" xml:space="preserve">
          <source>Object status (i.e., the class an object is blessed into) is also cloned.</source>
          <target state="translated">Статус объекта (т.е.класс,в который благословлен объект)также клонируется.</target>
        </trans-unit>
        <trans-unit id="88749641a0e24498fbd33e53d44467f3c2c5fba0" translate="yes" xml:space="preserve">
          <source>Objects Are Blessed; Variables Are Not</source>
          <target state="translated">Предметы благословлены;Переменные-нет.</target>
        </trans-unit>
        <trans-unit id="e56ad09ee25c724ca5817035af9f32f714eaf7e7" translate="yes" xml:space="preserve">
          <source>Objects representing POD input paragraphs, commands, etc.</source>
          <target state="translated">Объекты,представляющие собой POD-ввод параграфов,команд и т.д.</target>
        </trans-unit>
        <trans-unit id="1ad3969f34af62c08d92133f049673d28c2645d6" translate="yes" xml:space="preserve">
          <source>Obscure - set count of bytes in the buffer. Deprecated. Only usable if PerlIO_canset_cnt() returns true. Currently used in only doio.c to force count less than -1 to -1. Perhaps should be PerlIO_set_empty or similar. This call may actually do nothing if &quot;count&quot; is deduced from pointer and a &quot;limit&quot;. Do not use this - use PerlIO_set_ptrcnt().</source>
          <target state="translated">Неизвестно-установить счетчик байт в буфере.Исключено.Используется только если PerlIO_canset_cnt()возвращает true.В настоящее время используется только в doio.c,чтобы принудительно устанавливать счетчик меньше чем от -1 до -1.Возможно,следует использовать PerlIO_set_empty или что-то подобное.На самом деле этот вызов может ничего не сделать,если из указателя и &quot;лимита&quot; вычитать &quot;count&quot;.Не используйте это-используйте PerlIO_set_ptrcnt().</target>
        </trans-unit>
        <trans-unit id="e6bd238b055b51008fa691962e5504d6a4300b6b" translate="yes" xml:space="preserve">
          <source>Obsolete backwards compatibility functions</source>
          <target state="translated">Устаревшие функции обратной совместимости</target>
        </trans-unit>
        <trans-unit id="242a752af236cef2e4f67eafc9e86420fe839b22" translate="yes" xml:space="preserve">
          <source>Obsolete, deprecated method. Not used since Version 5.21.</source>
          <target state="translated">Устаревший,устаревший метод.Не используется с версии 5.21.</target>
        </trans-unit>
        <trans-unit id="ae05a67e6b1bdd3a5722aeecd922515ab6353aa5" translate="yes" xml:space="preserve">
          <source>Obsolete. All code points previously matched by this have been moved to &quot;Script=Common&quot;. Consider instead using &quot;Script_Extensions=Katakana&quot; or &quot;Script_Extensions=Hiragana&quot; (or both)</source>
          <target state="translated">Устаревший.Все точки кода,ранее совпадавшие с этим,были перенесены в &quot;Script=Common&quot;.Рассмотрим вместо этого &quot;Script_Extensions=Katakana&quot; или &quot;Script_Extensions=Hiragana&quot; (или оба).</target>
        </trans-unit>
        <trans-unit id="2fc29852a42ef2fda895989b8798adc19e9d7e6c" translate="yes" xml:space="preserve">
          <source>Obtain a response from the server. Upon success the most significant digit of the status code is returned. Upon failure, timeout etc.,</source>
          <target state="translated">Получить ответ от сервера.После успеха возвращается наиболее значимая цифра кода статуса.При неудаче,таймауте и т.д,</target>
        </trans-unit>
        <trans-unit id="c69d89c90bc0675bccad1c0dfa062843dd612b7a" translate="yes" xml:space="preserve">
          <source>Obtain information about all the active newsgroups. The results is a reference to a hash where the key is a group name and each value is a reference to an array. The elements in this array are:- the last article number in the group, the first article number in the group and any information flags about the group.</source>
          <target state="translated">Получать информацию обо всех активных новостных группах.Результат-ссылка на хэш,где ключом является имя группы,а каждое значение-ссылка на массив.Элементами в этом массиве являются:-номер последней статьи в группе,номер первой статьи в группе и любые информационные флаги о группе.</target>
        </trans-unit>
        <trans-unit id="51850565c0039917e1d7c30526e1aece9dd14aed" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for &lt;code&gt;stdin&lt;/code&gt; .</source>
          <target state="translated">Получите атрибуты для стандартного &lt;code&gt;stdin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4897259e0b2ea144f76021c4fb5eb538871e32ce" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for stdout.</source>
          <target state="translated">Получите атрибуты для stdout.</target>
        </trans-unit>
        <trans-unit id="12526129b1b52b63050b51bbb32341d9a8cd1a04" translate="yes" xml:space="preserve">
          <source>Obtain the header field &lt;code&gt;HEADER&lt;/code&gt; for all the messages specified.</source>
          <target state="translated">Получите поле заголовка &lt;code&gt;HEADER&lt;/code&gt; для всех указанных сообщений.</target>
        </trans-unit>
        <trans-unit id="ec15ee25f6bbd0b55463ebbf3ac8647c1d12711a" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt; , or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC867. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt; . The result will be an ASCII string or</source>
          <target state="translated">Получите время на &lt;code&gt;HOST&lt;/code&gt; или на каком-либо хосте по умолчанию, если &lt;code&gt;HOST&lt;/code&gt; не указан или не определен, используя протокол, как определено в RFC867. Необязательный аргумент &lt;code&gt;PROTOCOL&lt;/code&gt; должен определять используемый протокол: &lt;code&gt;tcp&lt;/code&gt; или &lt;code&gt;udp&lt;/code&gt; . Результатом будет строка ASCII или</target>
        </trans-unit>
        <trans-unit id="99f41f8f4a19b089d2fd1f49ca16ff7053ef6795" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt; , or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC868. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt; . The result will be a time value in the same units as returned by time() or</source>
          <target state="translated">Получите время на &lt;code&gt;HOST&lt;/code&gt; или на каком-либо хосте по умолчанию, если &lt;code&gt;HOST&lt;/code&gt; не указан или не определен, используя протокол, определенный в RFC868. Необязательный аргумент &lt;code&gt;PROTOCOL&lt;/code&gt; должен определять используемый протокол: &lt;code&gt;tcp&lt;/code&gt; или &lt;code&gt;udp&lt;/code&gt; . Результатом будет значение времени в тех же единицах, что и time () или</target>
        </trans-unit>
        <trans-unit id="da382120051949707a0c7beb67aab96ce623a328" translate="yes" xml:space="preserve">
          <source>Obviously the first of these will fail to distinguish most ASCII platforms from either a CCSID 0037, a 1047, or a POSIX-BC EBCDIC platform since &lt;code&gt;&quot;\r&quot; &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(13)&lt;/code&gt; under all of those coded character sets. But note too that because &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(13)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;\r&quot;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(10)&lt;/a&gt;&lt;/code&gt; on old Macintosh (which is an ASCII platform) the second &lt;code&gt;$is_ascii&lt;/code&gt; test will lead to trouble there.</source>
          <target state="translated">Очевидно, что первая из них не сможет отличить большинство платформ ASCII от CCSID 0037, 1047 или платформы POSIX-BC EBCDIC, поскольку &lt;code&gt;&quot;\r&quot; &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(13)&lt;/code&gt; под всеми этими кодированными наборами символов. Но обратите внимание, что поскольку &lt;code&gt;&quot;\n&quot;&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(13)&lt;/a&gt;&lt;/code&gt; а &lt;code&gt;&quot;\r&quot;&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(10)&lt;/a&gt;&lt;/code&gt; на старом Macintosh (который является платформой ASCII), второй тест &lt;code&gt;$is_ascii&lt;/code&gt; приведет к проблемам там.</target>
        </trans-unit>
        <trans-unit id="bfc9e42e3d47c901ceac3b16df8f05113274fcf2" translate="yes" xml:space="preserve">
          <source>Obviously this assumes that it is possible to typecast a pointer to an unsigned long and vice versa, which frequently works but should not be taken as a universal law. - Now that we have this pointer the next question is: How can we put it to good use? We need a call to some C function where a pointer is expected. The read(2) system call comes to mind:</source>
          <target state="translated">Очевидно,это предполагает,что можно напечатать указатель на неподписанный длинный и наоборот,что часто срабатывает,но не должно восприниматься как универсальный закон.-Теперь,когда у нас есть этот указатель,следующий вопрос:как его правильно использовать? Нам нужен вызов какой-нибудь функции на Си,где указатель ожидается.На ум приходит системный вызов read(2):</target>
        </trans-unit>
        <trans-unit id="8622bcf5480e2dcfc1e93eb63bd84e889a59eca8" translate="yes" xml:space="preserve">
          <source>Obviously, bugs which include patches are best. If you prefer, you can patch against bleed by via anonymous checkout of the latest version:</source>
          <target state="translated">Очевидно,что ошибки,которые включают исправления,лучше всего подходят.Если вы предпочитаете,вы можете заплатить за кровотечение с помощью анонимной проверки последней версии:</target>
        </trans-unit>
        <trans-unit id="8ad2def711f61d8bfaa27f7b29de908193ec9688" translate="yes" xml:space="preserve">
          <source>Obviously, in the situation of the last type of the signature of an OS/2 API, it is must more convenient for the users if the failure is indicated by die()ing: one does not need to check $^E to know that something went wrong. If, however, this solution is not desirable by some reason, the code in question should reset $^E to 0 before making this OS/2 API call, so that the caller of this Perl-accessible function has a chance to distinguish a success-but-0-return value from a failure. (One may return undef as an alternative way of reporting an error.)</source>
          <target state="translated">Очевидно,что в ситуации с последним типом подписи OS/2 API,пользователю должно быть удобнее,если сбой обозначен функцией die()ing:не нужно проверять $^E,чтобы понять,что что-то пошло не так.Если же по какой-то причине такое решение не желательно,то перед вызовом OS/2 API соответствующий код должен сбросить $^E на 0,чтобы у вызывающего эту Perl-доступную функцию был шанс отличить значение успеха-ноль-0-обратный сбой.(В качестве альтернативного способа сообщения об ошибке можно вернуть undef).</target>
        </trans-unit>
        <trans-unit id="d64ac810883d44e27969b0774d70505e74b53a16" translate="yes" xml:space="preserve">
          <source>Obviously, the second call to &lt;code&gt;complicated&lt;/code&gt; is a waste of time, and storing its return value is a waste of space. Specifying &lt;code&gt;LIST_CACHE
=&amp;gt; MERGE&lt;/code&gt; will make &lt;code&gt;memoize&lt;/code&gt; use the same cache for scalar and list context return values, so that the second call uses the scalar cache that was populated by the first call. &lt;code&gt;complicated&lt;/code&gt; ends up being called only once, and both subsequent calls return &lt;code&gt;3&lt;/code&gt; from the cache, regardless of the calling context.</source>
          <target state="translated">Очевидно, что второй вызов &lt;code&gt;complicated&lt;/code&gt; - пустая трата времени, а сохранение его возвращаемого значения - пустая трата места. Указание &lt;code&gt;LIST_CACHE =&amp;gt; MERGE&lt;/code&gt; заставит &lt;code&gt;memoize&lt;/code&gt; использовать один и тот же кеш для скалярных и возвращаемых значений контекста списка, так что второй вызов будет использовать скалярный кеш, который был заполнен первым вызовом. &lt;code&gt;complicated&lt;/code&gt; заканчивается тем, что вызывается только один раз, и оба последующих вызова возвращают &lt;code&gt;3&lt;/code&gt; из кеша, независимо от вызывающего контекста.</target>
        </trans-unit>
        <trans-unit id="a86730e802eb4eb4e4acf92e33bec8c9303fc96c" translate="yes" xml:space="preserve">
          <source>Occasionally it is important to pass a reference to the object being tied to the TIESCALAR, TIEHASH, etc. that ties it.</source>
          <target state="translated">Иногда важно передать ссылку на привязываемый объект на ТИАСКАЛАР,ТИХАШ и т.д.,которые его связывают.</target>
        </trans-unit>
        <trans-unit id="5cb8a483e38416f865c96e1886ae8adceb1b5292" translate="yes" xml:space="preserve">
          <source>Occasionally the programmer will want to return simply &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list if a function fails rather than a separate status value. The rpcb_gettime() function offers just this situation. If the function succeeds we would like to have it return the time and if it fails we would like to have undef returned. In the following Perl code the value of $timep will either be undef or it will be a valid time.</source>
          <target state="translated">Иногда программист может захотеть вернуть просто &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; или пустой список в случае сбоя функции, а не отдельное значение статуса. Функция rpcb_gettime () предлагает именно такую ​​ситуацию. Если функция завершается успешно, мы хотели бы, чтобы она возвращала время, а если не удается, мы хотели бы вернуть undef. В следующем коде Perl значение $ timep будет либо undef, либо допустимым временем.</target>
        </trans-unit>
        <trans-unit id="fca6836d0056140d86bcc04d81edeb7b7f85d973" translate="yes" xml:space="preserve">
          <source>Occasionally the strenuous efforts Attribute::Handlers makes to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler get in the way.</source>
          <target state="translated">Время от времени Attribute :: Handlers прилагает огромные усилия для преобразования аргумента данных ( &lt;code&gt;$_[4]&lt;/code&gt; ) в пригодную для использования форму перед передачей его обработчику.</target>
        </trans-unit>
        <trans-unit id="3a1a8a18cac1b8ec9d036c1e95c86caa06823297" translate="yes" xml:space="preserve">
          <source>Occasionally, you can't use just a &lt;code&gt;/g&lt;/code&gt; to get all the changes to occur that you might want. Here are two common cases:</source>
          <target state="translated">Иногда вы не можете использовать только a &lt;code&gt;/g&lt;/code&gt; , чтобы получить все необходимые изменения. Вот два распространенных случая:</target>
        </trans-unit>
        <trans-unit id="3642950c84185b95fade3aa22cda9a0e1954ee82" translate="yes" xml:space="preserve">
          <source>Oceania</source>
          <target state="translated">Oceania</target>
        </trans-unit>
        <trans-unit id="b5befcf80da75ec699a5c983fc36244ec375a0c0" translate="yes" xml:space="preserve">
          <source>Octal escapes</source>
          <target state="translated">утечки из осьминога</target>
        </trans-unit>
        <trans-unit id="6d3bc0d39ae545ee26be05b556b7a8cf4ddc990b" translate="yes" xml:space="preserve">
          <source>Octal escapes of the &lt;code&gt;\000&lt;/code&gt; form outside of bracketed character classes potentially clash with old-style backreferences (see &lt;a href=&quot;#Absolute-referencing&quot;&gt;Absolute referencing&lt;/a&gt; below). They both consist of a backslash followed by numbers. So Perl has to use heuristics to determine whether it is a backreference or an octal escape. Perl uses the following rules to disambiguate:</source>
          <target state="translated">Восьмеричные escape-последовательности формы &lt;code&gt;\000&lt;/code&gt; вне классов символов в квадратных скобках потенциально конфликтуют с обратными &lt;a href=&quot;#Absolute-referencing&quot;&gt;ссылками в&lt;/a&gt; старом стиле (см. Абсолютные ссылки ниже). Оба они состоят из обратной косой черты, за которой следуют числа. Таким образом, Perl должен использовать эвристику, чтобы определить, является ли это обратной ссылкой или восьмеричным escape-кодом. Perl использует следующие правила для устранения неоднозначности:</target>
        </trans-unit>
        <trans-unit id="001ed8e6a266e94752602c2df86a674e88e19c2d" translate="yes" xml:space="preserve">
          <source>Of course &lt;a href=&quot;http://search.cpan.org/perldoc/CGI&quot;&gt;CGI&lt;/a&gt; and &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; will tell you more.</source>
          <target state="translated">Конечно, &lt;a href=&quot;http://search.cpan.org/perldoc/CGI&quot;&gt;CGI&lt;/a&gt; и &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; расскажут вам больше.</target>
        </trans-unit>
        <trans-unit id="814879db219b87492dd375dcf6f869266e936b99" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;Moose&lt;/code&gt; isn't perfect.</source>
          <target state="translated">Конечно, &lt;code&gt;Moose&lt;/code&gt; не идеален.</target>
        </trans-unit>
        <trans-unit id="733d5b43433c0be3dd395c3e52526830c10b5e3c" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;vianame&lt;/code&gt; , &lt;code&gt;viacode&lt;/code&gt; , and &lt;code&gt;string_vianame&lt;/code&gt; would need to be overridden as well.</source>
          <target state="translated">Конечно, &lt;code&gt;vianame&lt;/code&gt; , &lt;code&gt;viacode&lt;/code&gt; и &lt;code&gt;string_vianame&lt;/code&gt; также должны быть переопределены.</target>
        </trans-unit>
        <trans-unit id="03c6e1d7d58bd1d130be768a05a694a94d3aba2b" translate="yes" xml:space="preserve">
          <source>Of course, here too, Filter::Simple has to know you're using Exporter before it applies the filter. That's almost never a problem, but if you're nervous about it, you can guarantee that things will work correctly by ensuring that your &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; base Exporter&lt;/code&gt; always precedes your &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; .</source>
          <target state="translated">Конечно, и здесь Filter :: Simple должен знать, что вы используете Exporter, прежде чем применять фильтр. Это почти никогда не проблема, но если вы нервничаете по этому поводу, вы можете гарантировать, что все будет работать правильно, убедившись, что ваш &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; base Exporter&lt;/code&gt; &lt;a href=&quot;../functions/use&quot;&gt;использования&lt;/a&gt; всегда предшествует вашему &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab33e7ed924208df5f517b6f58635c94da06be71" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;@ISA&lt;/code&gt; contained only &lt;code&gt;DynaLoader&lt;/code&gt; , there is no need to have the &lt;code&gt;@ISA&lt;/code&gt; assignment at all; moreover, if instead of &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; one uses the more backward-compatible</source>
          <target state="translated">Конечно, если &lt;code&gt;@ISA&lt;/code&gt; содержит только &lt;code&gt;DynaLoader&lt;/code&gt; , нет необходимости в назначении &lt;code&gt;@ISA&lt;/code&gt; ; более того, если вместо &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; использовать более обратно совместимый</target>
        </trans-unit>
        <trans-unit id="5fe9b52519ed5e683419d8b8de5fb62a2cea4185" translate="yes" xml:space="preserve">
          <source>Of course, if the class name is in a scalar Perl will do the right thing as well:</source>
          <target state="translated">Конечно,если имя класса находится в скаляре Perl,то и это будет правильно:</target>
        </trans-unit>
        <trans-unit id="d886edfc3d346b2f618c821d88c4f77af2ec29fb" translate="yes" xml:space="preserve">
          <source>Of course, if you simply follow the guidelines in &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;, you shouldn't need to reformat. The habit of formatting your code as you write it will help prevent bugs. Your editor can and should help you with this. The perl-mode or newer cperl-mode for emacs can provide remarkable amounts of help with most (but not all) code, and even less programmable editors can provide significant assistance. Tom Christiansen and many other VI users swear by the following settings in vi and its clones:</source>
          <target state="translated">Конечно, если вы просто следуете рекомендациям в &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt; , вам не нужно переформатировать. Привычка форматировать код по мере его написания поможет предотвратить ошибки. Ваш редактор может и должен вам в этом помочь. Perl-mode или более новый cperl-mode для emacs могут оказать значительную помощь с большей частью (но не со всем) кодом, и даже менее программируемые редакторы могут оказать значительную помощь. Том Кристиансен и многие другие пользователи VI придерживаются следующих настроек vi и его клонов:</target>
        </trans-unit>
        <trans-unit id="abb07ecb376ea8ffb38769be127701645f4d0359" translate="yes" xml:space="preserve">
          <source>Of course, in contexts like, for example, &lt;code&gt;$obj + 1&lt;/code&gt; , Perl will invoke &lt;code&gt;$obj&lt;/code&gt; 's implementation of &lt;code&gt;+&lt;/code&gt; rather than (in this example) converting &lt;code&gt;$obj&lt;/code&gt; to a number using the numify method &lt;code&gt;'0+'&lt;/code&gt; (an exception to this is when no method has been provided for &lt;code&gt;'+'&lt;/code&gt; and &lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt; is set to TRUE).</source>
          <target state="translated">Конечно, в условиях , как, например, &lt;code&gt;$obj + 1&lt;/code&gt; , Perl будет вызывать &lt;code&gt;$obj&lt;/code&gt; &amp;laquo;ы Реализация &lt;code&gt;+&lt;/code&gt; , а не (в данном примере) преобразование &lt;code&gt;$obj&lt;/code&gt; в число , используя numify метод &lt;code&gt;'0+'&lt;/code&gt; (исключение для это когда для &lt;code&gt;'+'&lt;/code&gt; не был предоставлен метод, а для &lt;a href=&quot;#fallback&quot;&gt;отката&lt;/a&gt; задано значение TRUE).</target>
        </trans-unit>
        <trans-unit id="837c1a0c6d4394993c9260f47b27824bf6031d2f" translate="yes" xml:space="preserve">
          <source>Of course, in the case of a literal string, one could just as easily use the string comparison &lt;code&gt;$string eq 'bert'&lt;/code&gt; and it would be more efficient. The &lt;code&gt;^...$&lt;/code&gt; regexp really becomes useful when we add in the more powerful regexp tools below.</source>
          <target state="translated">Конечно, в случае буквальной строки можно было бы так же легко использовать сравнение &lt;code&gt;$string eq 'bert'&lt;/code&gt; и это было бы более эффективно. &lt;code&gt;^...$&lt;/code&gt; регулярное выражение действительно становится полезным , если мы добавим в более мощных инструментов регулярных выражений ниже.</target>
        </trans-unit>
        <trans-unit id="27457c444325a83774ce245c93383c8862b5cc3d" translate="yes" xml:space="preserve">
          <source>Of course, in this module-author's humble opinion, I'd be more inclined to use the existing &lt;b&gt;Pod::ParseTree&lt;/b&gt; object than a simple array. That way everything in it, paragraphs and sequences, all respond to the same core interface for all parse-tree nodes. The result would look something like:</source>
          <target state="translated">Конечно, по скромному мнению автора этого модуля, я был бы более склонен использовать существующий объект &lt;b&gt;Pod :: ParseTree,&lt;/b&gt; чем простой массив. Таким образом, все в нем, абзацы и последовательности, все реагируют на один и тот же основной интерфейс для всех узлов дерева синтаксического анализа. Результат будет примерно таким:</target>
        </trans-unit>
        <trans-unit id="11fde9a92a2449ce2e35bf1f4b5fe24a02e9e7d2" translate="yes" xml:space="preserve">
          <source>Of course, it is important to choose the right separator string for each purpose.</source>
          <target state="translated">Конечно,важно выбрать правильную разделительную строку для каждой цели.</target>
        </trans-unit>
        <trans-unit id="dc54d65f65f6922d956316c79b1323c206e201c5" translate="yes" xml:space="preserve">
          <source>Of course, it's up to you to decide whether or not to ignore them.</source>
          <target state="translated">Конечно,вы сами решаете,игнорировать их или нет.</target>
        </trans-unit>
        <trans-unit id="d78604b940d2c66d71607feff9316d4ae5a87f26" translate="yes" xml:space="preserve">
          <source>Of course, one could write such glue code directly in C. However, this would be a tedious task, especially if one needs to write glue for multiple C functions, and/or one is not familiar enough with the Perl stack discipline and other such arcana. XS comes to the rescue here: instead of writing this glue C code in long-hand, one can write a more concise short-hand</source>
          <target state="translated">Конечно,такой клеевой код можно было бы написать прямо на Си.Однако,это было бы утомительной задачей,особенно если нужно написать клей для нескольких функций на Си,и/или человек недостаточно знаком с дисциплиной стека Perl и другими подобными арканами.Здесь на помощь приходит XS:вместо того,чтобы писать этот клеевой C-код длинными руками,можно написать более лаконичный короткими руками</target>
        </trans-unit>
        <trans-unit id="77c72cea76e3d8ea1cda06ed844191d48368487d" translate="yes" xml:space="preserve">
          <source>Of course, test #1 is $tests[0], etc...</source>
          <target state="translated">Конечно,тест #1-это $tests[0]и т.д....</target>
        </trans-unit>
        <trans-unit id="de9f73990ad276e504276095781c4201fd0583f9" translate="yes" xml:space="preserve">
          <source>Of course, the best way to save memory is to not do anything to waste it in the first place. Good programming practices can go a long way toward this:</source>
          <target state="translated">Конечно,лучший способ сохранить память-это не делать ничего,чтобы ее потратить впустую.Надлежащая практика программирования может иметь далеко идущие последствия:</target>
        </trans-unit>
        <trans-unit id="b974b206a7b1862c93ebd148bc1b83add3324aa2" translate="yes" xml:space="preserve">
          <source>Of course, this</source>
          <target state="translated">Конечно,это</target>
        </trans-unit>
        <trans-unit id="5788145c5ae3423e71b1d5b7f96f5fcb341edfab" translate="yes" xml:space="preserve">
          <source>Of course, this requires that the underlying call supports buffers. See the note on buffers above.</source>
          <target state="translated">Конечно,для этого необходимо,чтобы основной вызов поддерживал буферы.См.примечание о буферах выше.</target>
        </trans-unit>
        <trans-unit id="357e4c4fc94af540a4f74537a6571078de606e56" translate="yes" xml:space="preserve">
          <source>Of course, typing in your own password to whoever asks you for it is unwise.</source>
          <target state="translated">Конечно,вводить свой собственный пароль тому,кто вас об этом попросит,неразумно.</target>
        </trans-unit>
        <trans-unit id="aaa47fc8bd024bc87e7c8490eb46dddef3e8914d" translate="yes" xml:space="preserve">
          <source>Of course, unless you know the number of elements in the &lt;code&gt;sometype **&lt;/code&gt; C array, within your XSUB, the return value from &lt;code&gt;foo_t ** XS_unpack_foo_tPtrPtr(...)&lt;/code&gt; will be hard to decipher. Since the details are all up to the XS author (the typemap user), there are several solutions, none of which particularly elegant. The most commonly seen solution has been to allocate memory for N+1 pointers and assign &lt;code&gt;NULL&lt;/code&gt; to the (N+1)th to facilitate iteration.</source>
          <target state="translated">Конечно, если вы не знаете количество элементов в &lt;code&gt;sometype **&lt;/code&gt; C в вашем XSUB, будет трудно расшифровать возвращаемое значение из &lt;code&gt;foo_t ** XS_unpack_foo_tPtrPtr(...)&lt;/code&gt; . Поскольку все детали зависят от автора XS (пользователя typemap), существует несколько решений, ни одно из которых не является особенно элегантным. Наиболее часто встречающимся решением было выделить память для указателей N + 1 и присвоить &lt;code&gt;NULL&lt;/code&gt; (N + 1) -му, чтобы облегчить итерацию.</target>
        </trans-unit>
        <trans-unit id="edd8408b88d74e19ec1265ebd83f3cd07501b352" translate="yes" xml:space="preserve">
          <source>Of course, unless your OS does not implement access(), in which case the pragma is simply ignored. Best not to use &lt;code&gt;_&lt;/code&gt; at all in a file where the filetest pragma is active!</source>
          <target state="translated">Конечно, если ваша ОС не реализует access (), и в этом случае прагма просто игнорируется. Лучше вообще не использовать &lt;code&gt;_&lt;/code&gt; в файле, где активна прагма filetest!</target>
        </trans-unit>
        <trans-unit id="f9a595714c023a195e48ee401212d01b31493781" translate="yes" xml:space="preserve">
          <source>Of course, you don't need the temporary array to have a name at all:</source>
          <target state="translated">Конечно,вам не нужно,чтобы у временного массива вообще было имя:</target>
        </trans-unit>
        <trans-unit id="fb6f67a6165dc8bfd66e5ae946dbcf7584578eef" translate="yes" xml:space="preserve">
          <source>Of the conversions, only one of string, boolean or numeric is needed because each can be generated from either of the other two.</source>
          <target state="translated">Из преобразований требуется только одно из строковых,булевых или числовых,потому что каждое из них может быть сгенерировано из двух других.</target>
        </trans-unit>
        <trans-unit id="f521e0762b4294067b640a105aa4f9fd48ea8238" translate="yes" xml:space="preserve">
          <source>Of these properties, the two important ones are Pattern_Syntax and Pattern_White_Space. They have been set up by Unicode for exactly this purpose of deciding which characters in a regular expression pattern should be quoted. No character that can be in an identifier has these properties.</source>
          <target state="translated">Из этих свойств два важных-Pattern_Syntax и Pattern_White_Space.Они были установлены Unicode именно для этой цели,чтобы решить,какие символы в шаблоне регулярных выражений должны быть кавычками.Ни один символ,который может находиться в идентификаторе,не обладает этими свойствами.</target>
        </trans-unit>
        <trans-unit id="c77879f95662f28e94653e74a629782adc3eeac4" translate="yes" xml:space="preserve">
          <source>Official home page for the ISO 3166 maintenance agency.</source>
          <target state="translated">Официальная домашняя страница для агентства по техническому обслуживанию ISO 3166.</target>
        </trans-unit>
        <trans-unit id="967fc19002ed71d08a174f5ecc4259363a549385" translate="yes" xml:space="preserve">
          <source>Official source of the top-level domain names.</source>
          <target state="translated">Официальный источник доменных имен верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="20daff2f32d6074bbb2255376c7a89b965519ab3" translate="yes" xml:space="preserve">
          <source>Offsets</source>
          <target state="translated">Offsets</target>
        </trans-unit>
        <trans-unit id="6a7926e00c1d5044bed78664357be7137c40f3e0" translate="yes" xml:space="preserve">
          <source>Offsets holds a mapping of offset in the &lt;code&gt;program&lt;/code&gt; to offset in the &lt;code&gt;precomp&lt;/code&gt; string. This is only used by ActiveState's visual regex debugger.</source>
          <target state="translated">Offsets содержит отображение смещения в &lt;code&gt;program&lt;/code&gt; на смещение в строке &lt;code&gt;precomp&lt;/code&gt; . Это используется только отладчиком визуальных регулярных выражений ActiveState.</target>
        </trans-unit>
        <trans-unit id="43d26f6f08e88e91bca4bafe94301f7c42d03d67" translate="yes" xml:space="preserve">
          <source>Often it is useful to allow comma-separated lists of values as well as multiple occurrences of the options. This is easy using Perl's split() and join() operators:</source>
          <target state="translated">Часто бывает полезно разрешить разделенные запятыми списки значений,а также множественные вхождения опций.Это легко сделать с помощью операторов split()и join()Perl:</target>
        </trans-unit>
        <trans-unit id="632c3362322ab6672e961b19c05b72785cd26d84" translate="yes" xml:space="preserve">
          <source>Often it is user friendly to supply alternate mnemonic names for options. For example &lt;code&gt;--height&lt;/code&gt; could be an alternate name for &lt;code&gt;--&lt;a href=&quot;../functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; . Alternate names can be included in the option specification, separated by vertical bar &lt;code&gt;|&lt;/code&gt; characters. To implement the above example:</source>
          <target state="translated">Часто удобно использовать альтернативные мнемонические имена для опций. Например, &lt;code&gt;--height&lt;/code&gt; может быть альтернативным именем для &lt;code&gt;--&lt;a href=&quot;../functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; . Альтернативные имена могут быть включены в спецификацию опции, разделенные вертикальной чертой &lt;code&gt;|&lt;/code&gt; персонажи. Чтобы реализовать приведенный выше пример:</target>
        </trans-unit>
        <trans-unit id="413285a912f30dbf718e8f5cd58feece5f266f30" translate="yes" xml:space="preserve">
          <source>Often there will be another error message associated with the syntax error giving more information. (Sometimes it helps to turn on &lt;b&gt;-w&lt;/b&gt;.) The error message itself often tells you where it was in the line when it decided to give up. Sometimes the actual error is several tokens before this, because Perl is good at understanding random input. Occasionally the line number may be misleading, and once in a blue moon the only way to figure out what's triggering the error is to call &lt;code&gt;perl -c&lt;/code&gt; repeatedly, chopping away half the program each time to see if the error went away. Sort of the cybernetic version of 20 questions.</source>
          <target state="translated">Часто появляется другое сообщение об ошибке, связанное с синтаксической ошибкой, дающее дополнительную информацию. (Иногда помогает включить &lt;b&gt;-w&lt;/b&gt; .) Само сообщение об ошибке часто сообщает вам, где оно было в строке, когда было решено отказаться. Иногда фактическая ошибка происходит за несколько токенов до этого, потому что Perl хорошо понимает случайный ввод. Иногда номер строки может вводить в заблуждение, и однажды в синюю луну единственный способ выяснить, что вызывает ошибку, - это многократно вызывать &lt;code&gt;perl -c&lt;/code&gt; , каждый раз отрубая половину программы, чтобы увидеть, исчезла ли ошибка. Этакая кибернетическая версия из 20 вопросов.</target>
        </trans-unit>
        <trans-unit id="fe51516899ec526908e4919457333ab9ef798f50" translate="yes" xml:space="preserve">
          <source>Often you want to manually set the $VERSION in the main module distribution because this is the version that everybody sees on CPAN and maybe you want to customize it a bit. But for all the other modules in your dist, $VERSION is really just bookkeeping and all that's important is it goes up every time the module is changed. Doing this by hand is a pain and you often forget.</source>
          <target state="translated">Часто вы хотите вручную установить $VERSION в основном дистрибутиве модулей,потому что это версия,которую все видят на CPAN,и,возможно,вы захотите немного ее настроить.Но для всех остальных модулей в вашем дистрибутиве $VERSION на самом деле просто бухгалтерский учет,и все,что важно,это то,что он поднимается каждый раз,когда модуль изменяется.Делать это вручную-больно и часто забываешь.</target>
        </trans-unit>
        <trans-unit id="a8e3c059f398572879c5f613bbb88d9e476377a9" translate="yes" xml:space="preserve">
          <source>Oh, hmm. That didn't quite work. Let's see what happened:</source>
          <target state="translated">О,хм.Это не совсем сработало.Давай посмотрим,что случилось:</target>
        </trans-unit>
        <trans-unit id="2c053114f243927de5bf7cd77c45af1c27a14806" translate="yes" xml:space="preserve">
          <source>Oh, one final bit of advice: take &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt; with you. When you return we expect to see it well-thumbed.</source>
          <target state="translated">О, последний совет: возьмите &lt;a href=&quot;../perlguts&quot;&gt;перлгут&lt;/a&gt; с собой. Когда вы вернетесь, мы ожидаем увидеть его хорошо проработанным.</target>
        </trans-unit>
        <trans-unit id="8773501dbe9f64eda9a34f3bd611a37f1791691b" translate="yes" xml:space="preserve">
          <source>Ok, but how about when you want to really see your data, what's in that dynamic variable, just before using it?</source>
          <target state="translated">Хорошо,но как насчет того,когда вы действительно хотите увидеть свои данные,что в этой динамической переменной,прямо перед ее использованием?</target>
        </trans-unit>
        <trans-unit id="94213f220b40a7c6524e04580b008b30cdf470cf" translate="yes" xml:space="preserve">
          <source>Ok, so that's not very interesting, because it didn't find that particular document. But a long response wouldn't have fit on this page.</source>
          <target state="translated">Хорошо,это не очень интересно,потому что он не нашел этот конкретный документ.Но длинный ответ не помещался бы на этой странице.</target>
        </trans-unit>
        <trans-unit id="98a944759b5b6a428ccfa37e9a4506cd2b44afa1" translate="yes" xml:space="preserve">
          <source>Ok, so there can be more than one Test::Builder object and this is how you get it. You might use this instead of &lt;code&gt;new()&lt;/code&gt; if you're testing a Test::Builder based module, but otherwise you probably want &lt;code&gt;new&lt;/code&gt; .</source>
          <target state="translated">Итак, может быть более одного объекта Test :: Builder, и вот как вы его получите. Вы можете использовать это вместо &lt;code&gt;new()&lt;/code&gt; если тестируете модуль на основе Test :: Builder, но в противном случае вам, вероятно, понадобится &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f313a2347a7e1b7519ec6e24bd0468d6b0162bc3" translate="yes" xml:space="preserve">
          <source>Okay, if you insist: the &quot;internal format&quot; is utf8, not UTF-8. (When it's not some other encoding.)</source>
          <target state="translated">Хорошо,если вы настаиваете:&quot;внутренний формат&quot;-utf8,а не UTF-8.(Когда это не какая-то другая кодировка.)</target>
        </trans-unit>
        <trans-unit id="a1f111382df51fd175ea0dd918cefd5d91a357cd" translate="yes" xml:space="preserve">
          <source>Old byte-oriented programs should magically start working on the new character-oriented data when appropriate.</source>
          <target state="translated">Старые байт-ориентированные программы должны при необходимости магически начинать работать с новыми символьно-ориентированными данными.</target>
        </trans-unit>
        <trans-unit id="484e0a4f10a1f76d63b7cbe120323d7095b0f174" translate="yes" xml:space="preserve">
          <source>Old byte-oriented programs should not spontaneously break on the old byte-oriented data they used to work on.</source>
          <target state="translated">Старые байт-ориентированные программы не должны самопроизвольно ломаться на старых байт-ориентированных данных,над которыми они работали раньше.</target>
        </trans-unit>
        <trans-unit id="ae5d8d02aa4909a49747784b849d74c7097909f2" translate="yes" xml:space="preserve">
          <source>Old perl executable is started when a new executable is running has loaded an extension compiled for the old executable (ouph!). In this case the old executable will get a forwarder DLL instead of the old perl DLL, so would link with the new perl DLL. While not directly fatal, it will behave the same as new executable. This beats the whole purpose of explicitly starting an old executable.</source>
          <target state="translated">Старый исполняемый файл perl запускается,когда новый исполняемый файл загрузил расширение,скомпилированное для старого исполняемого файла (ouph!).В этом случае старый исполняемый файл получит перенаправляющую DLL вместо старой perl DLL,так же как и новый perl DLL.Несмотря на то,что он не является фатальным,он будет вести себя так же,как и новый исполняемый файл.Это превосходит всю цель явного запуска старого исполняемого файла.</target>
        </trans-unit>
        <trans-unit id="b4065d89a2f43100a5cf55aa7a52797bb4059e14" translate="yes" xml:space="preserve">
          <source>Old-style versus new-style block names</source>
          <target state="translated">Имена блоков в старом и новом стиле</target>
        </trans-unit>
        <trans-unit id="69d1a0ab771940cdc9cc69797ad23f167d7d2a58" translate="yes" xml:space="preserve">
          <source>Oldconfig.U</source>
          <target state="translated">Oldconfig.U</target>
        </trans-unit>
        <trans-unit id="0f656bb21c786456d378ff0e1756c02c791362d3" translate="yes" xml:space="preserve">
          <source>Older documentation (and some CPAN modules) encouraged this syntax, particularly for constructors, so you may still find it in the wild. However, we encourage you to avoid using it in new code.</source>
          <target state="translated">Старая документация (и некоторые CPAN модули)поощряли этот синтаксис,особенно для конструкторов,так что вы все еще можете найти его в дикой природе.Тем не менее,мы рекомендуем вам избегать использования его в новом коде.</target>
        </trans-unit>
        <trans-unit id="845ea4ddc5e221b527b9b5fd418aec5c3f3db57a" translate="yes" xml:space="preserve">
          <source>Older releases of VOS (prior to OpenVOS Release 17.0) limit file names to 32 or fewer characters, prohibit file names from starting with a &lt;code&gt;-&lt;/code&gt; character, and prohibit file names from containing any character matching &lt;code&gt;tr/ !#%&amp;amp;'()*;&amp;lt;=&amp;gt;?//&lt;/code&gt; .</source>
          <target state="translated">Старые выпуски СДН (до OpenVOS Release 17,0) имена ограничения файлов до 32 или менее символов, запретить имена файлов из начиная с &lt;code&gt;-&lt;/code&gt; символа, а также запретить имена файлов из которых содержит любой соответствующий символ &lt;code&gt;tr/ !#%&amp;amp;'()*;&amp;lt;=&amp;gt;?//&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4148117b640e73f6a46898d2260720a46ef03ff" translate="yes" xml:space="preserve">
          <source>Older translators might add wording around an L&amp;lt;&amp;gt; link, so that &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; may become &quot;the Foo::Bar manpage&quot;, for example. So you shouldn't write things like &lt;code&gt;the L&amp;lt;foo&amp;gt;
documentation&lt;/code&gt;, if you want the translated document to read sensibly. Instead, write &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; or &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt; , to control how the link comes out.</source>
          <target state="translated">Старые переводчики могут добавить формулировку вокруг ссылки L &amp;lt;&amp;gt;, так что &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; может стать, например, &amp;laquo;man-страницей Foo :: Bar&amp;raquo;. Поэтому вам не следует писать такие вещи, как документация &lt;code&gt;the L&amp;lt;foo&amp;gt; documentation&lt;/code&gt; , если вы хотите, чтобы переведенный документ читался разумно. Вместо этого напишите документацию &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; или &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt; , чтобы контролировать вывод ссылки.</target>
        </trans-unit>
        <trans-unit id="74cfdc9feb194af111f83545c6d1330ca4e4400c" translate="yes" xml:space="preserve">
          <source>Older versions of CPAN.pm had the original root directory of all tarballs in the build directory. Now there are always random characters appended to these directory names. Why was this done?</source>
          <target state="translated">Старые версии CPAN.pm имели оригинальный корневой каталог всех tarballs в каталоге сборки.Теперь к этим именам каталогов всегда добавляются случайные символы.Почему это было сделано?</target>
        </trans-unit>
        <trans-unit id="aa508d12280c1adaeb775241c86d759189c3c71c" translate="yes" xml:space="preserve">
          <source>Older versions of this document recommended to use &lt;code&gt;void&lt;/code&gt; return value in such cases. It was discovered that this could lead to segfaults in cases when XSUB was</source>
          <target state="translated">Более старые версии этого документа рекомендовали использовать в таких случаях возвращаемое значение &lt;code&gt;void&lt;/code&gt; . Было обнаружено, что это может привести к сбою сегментов в случаях, когда XSUB</target>
        </trans-unit>
        <trans-unit id="7dc06c5173c26db9fe80a519eb5a6ebe90623816" translate="yes" xml:space="preserve">
          <source>Oldsyms.U</source>
          <target state="translated">Oldsyms.U</target>
        </trans-unit>
        <trans-unit id="9cf87efb8c04dd4dc674e0b0506f97a5eb0660ea" translate="yes" xml:space="preserve">
          <source>Olivier Mengue</source>
          <target state="translated">Оливье Менге</target>
        </trans-unit>
        <trans-unit id="f3ed24c21f5dd18b200f0c25095d7a6774573e1a" translate="yes" xml:space="preserve">
          <source>Omit &lt;code&gt;constant()&lt;/code&gt; from the .xs file and corresponding specialised &lt;code&gt;AUTOLOAD&lt;/code&gt; from the .pm file.</source>
          <target state="translated">Опустите &lt;code&gt;constant()&lt;/code&gt; из файла .xs и соответствующую специализированную &lt;code&gt;AUTOLOAD&lt;/code&gt; из файла .pm.</target>
        </trans-unit>
        <trans-unit id="9c4aa09aebc98ad6e647cac1f8fffb08291cde09" translate="yes" xml:space="preserve">
          <source>Omit all autoload facilities. This is the same as &lt;b&gt;-c&lt;/b&gt; but also removes the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader&lt;/code&gt; statement from the .pm file.</source>
          <target state="translated">Опустите все средства автозагрузки. Это то же самое, что и &lt;b&gt;-c,&lt;/b&gt; но также удаляет оператор &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader&lt;/code&gt; из файла .pm.</target>
        </trans-unit>
        <trans-unit id="c89bf96a83d88777c4a53a3cada5e03b11bfab80" translate="yes" xml:space="preserve">
          <source>Omit redundant punctuation as long as clarity doesn't suffer.</source>
          <target state="translated">Опустите лишнюю пунктуацию,пока не пострадает ясность.</target>
        </trans-unit>
        <trans-unit id="5939f2980c3053a7b35d91579e70755fbf358beb" translate="yes" xml:space="preserve">
          <source>Omit the XS portion. Used to generate a skeleton pure Perl module. &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-f&lt;/code&gt; are implicitly enabled.</source>
          <target state="translated">Опустите часть XS. Используется для создания скелета чистого модуля Perl. &lt;code&gt;-c&lt;/code&gt; и &lt;code&gt;-f&lt;/code&gt; включены неявно.</target>
        </trans-unit>
        <trans-unit id="ab66b48afb255f3fa8074752a39b329797b5aa56" translate="yes" xml:space="preserve">
          <source>Omit the autogenerated stub POD section.</source>
          <target state="translated">Пропустите секцию POD с автогенерированным шлейфом.</target>
        </trans-unit>
        <trans-unit id="aef75bc39700a2d7f9ba2d4fcc4c938989654f2d" translate="yes" xml:space="preserve">
          <source>Omits creation of the</source>
          <target state="translated">Опускает создание</target>
        </trans-unit>
        <trans-unit id="ce977cba7ea14f47b6252159a9ce77942da917fb" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; section is equivalent to using an empty one, logically enough, so &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="translated">Пропуск раздела &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; эквивалентен использованию пустого раздела, что достаточно логично, поэтому &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; сразу вернуться, чтобы проверить условие в начале цикла.</target>
        </trans-unit>
        <trans-unit id="648601245d456cf14017862c18156a366b17d689" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; section is equivalent to using an empty one, logically enough, so &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="translated">Пропуск раздела &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; эквивалентен использованию пустого раздела, что достаточно логично, поэтому &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; сразу вернуться, чтобы проверить условие в начале цикла.</target>
        </trans-unit>
        <trans-unit id="2170721cf53167c035658d5db7e3986d2f62f2d5" translate="yes" xml:space="preserve">
          <source>Omitting the first argument (input text) means process &lt;code&gt;$_&lt;/code&gt; instead. Omitting the second argument (delimiter brackets) indicates that only &lt;code&gt;'{'&lt;/code&gt; is to be used. Omitting the third argument (prefix argument) implies optional whitespace at the start. Omitting the fourth argument (outermost delimiter brackets) indicates that the value of the second argument is to be used for the outermost delimiters.</source>
          <target state="translated">Пропуск первого аргумента (вводимый текст) означает вместо этого процесс &lt;code&gt;$_&lt;/code&gt; . Отсутствие второго аргумента (скобки-разделители) означает, что следует использовать только &lt;code&gt;'{'&lt;/code&gt; . Отсутствие третьего аргумента (аргумента префикса) подразумевает необязательный пробел в начале. Отсутствие четвертого аргумента (скобки крайних разделителей) указывает, что значение второго аргумента должно использоваться для крайних разделителей.</target>
        </trans-unit>
        <trans-unit id="d19163591bedfb142adf27e96746ef3cf121a26f" translate="yes" xml:space="preserve">
          <source>On AIX 4.2 using xlC, we continue:</source>
          <target state="translated">На AIX 4.2,используя xlC,мы продолжаем:</target>
        </trans-unit>
        <trans-unit id="b7bebcc7500e38fa33da9de2419b5d4507654e3f" translate="yes" xml:space="preserve">
          <source>On AIX 4.3 using vac, we continue:</source>
          <target state="translated">На AIX 4.3,используя отпуск,мы продолжаем:</target>
        </trans-unit>
        <trans-unit id="164f1a22c1ddad7a43b51fc0e97d9cc8c54ba4c2" translate="yes" xml:space="preserve">
          <source>On ASCII platforms, the resulting characters from the list above are the complete set of ASCII controls. This isn't the case on EBCDIC platforms; see &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;OPERATOR DIFFERENCES in perlebcdic&lt;/a&gt; for a full discussion of the differences between these for ASCII versus EBCDIC platforms.</source>
          <target state="translated">На платформах ASCII результирующие символы из приведенного выше списка представляют собой полный набор элементов управления ASCII. На платформах EBCDIC это не так; см. &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;РАЗЛИЧИЯ ОПЕРАТОРОВ в perlebcdic&lt;/a&gt; для полного обсуждения различий между ними для платформ ASCII и EBCDIC.</target>
        </trans-unit>
        <trans-unit id="e4ce9df615081837a49ff8902adf19d0bea73069" translate="yes" xml:space="preserve">
          <source>On ASCII-encoded platforms it is possible to strip characters outside of the printable set using:</source>
          <target state="translated">На платформах с ASCII-кодировкой возможна зачистка символов за пределами печатного набора:</target>
        </trans-unit>
        <trans-unit id="f524bd580ae58f0c6ff9d83f9b34774b97e1a12f" translate="yes" xml:space="preserve">
          <source>On DOS-like platforms, if the program does not contain directory separators, it will first be searched for in the current directory before being searched for on the PATH. On Unix platforms, the program will be searched for strictly on the PATH.</source>
          <target state="translated">На DOS-подобных платформах,если программа не содержит разделителей каталогов,поиск будет сначала произведен в текущем каталоге,а затем в PATH.На Unix-платформах поиск программы будет осуществляться строго по PATH.</target>
        </trans-unit>
        <trans-unit id="1cac4dfb85f7858cf9af4b4f306e4164c94a071a" translate="yes" xml:space="preserve">
          <source>On DOSISH systems, backslash is a valid directory separator character. In this case, use of backslash as a quoting character (via GLOB_QUOTE) interferes with the use of backslash as a directory separator. The best (simplest, most portable) solution is to use forward slashes for directory separators, and backslashes for quoting. However, this does not match &quot;normal practice&quot; on these systems. As a concession to user expectation, therefore, backslashes (under GLOB_QUOTE) only quote the glob metacharacters '[', ']', '{', '}', '-', '~', and backslash itself. All other backslashes are passed through unchanged.</source>
          <target state="translated">На системах DOSISH обратный слеш является допустимым символом разделителя каталогов.В этом случае использование обратного слеша в качестве символа кавычки (через GLOB_QUOTE)препятствует использованию обратного слеша в качестве разделителя каталогов.Лучшим (простым,наиболее переносимым)решением является использование прямого слеша для разделителей каталогов,а обратного слеша-для кавычек.Однако это не соответствует &quot;нормальной практике&quot; на этих системах.Поэтому,в качестве уступки ожиданиям пользователя,обратные слеши (в разделе GLOB_QUOTE)цитируют только глобусные метасимволы '[',']','{','}','-','~',и сам обратный слэш.Все остальные обратные слеши передаются без изменений.</target>
        </trans-unit>
        <trans-unit id="bc353a101a732e619259516d5005fd73e9056d46" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms characters in the Latin 1 character set are treated as being part of a literal UTF-EBCDIC character.</source>
          <target state="translated">На платформах EBCDIC символы в наборе символов Latin 1 рассматриваются как часть буквального UTF-EBCDIC символа.</target>
        </trans-unit>
        <trans-unit id="05835a5188ac319110e1d4a7bb82d82adb8499ed" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, prior to v5.22, using &lt;code&gt;\N{U+...}&lt;/code&gt; doesn't work properly.</source>
          <target state="translated">На платформах EBCDIC до v5.22 использование &lt;code&gt;\N{U+...}&lt;/code&gt; не работает должным образом.</target>
        </trans-unit>
        <trans-unit id="79296614d9a9f53308ccee5fcf367fe461dcdb98" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC instead of UTF-8. The difference is that as UTF-8 is &quot;ASCII-safe&quot; in that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is &quot;EBCDIC-safe&quot;, in that all the basic characters (which includes all those that have ASCII equivalents (like &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; ,</source>
          <target state="translated">На платформах EBCDIC внутренняя форма кодировки Unicode - UTF-EBCDIC вместо UTF-8. Разница в том, что UTF-8 является &amp;laquo;безопасным для ASCII&amp;raquo; в том смысле, что символы ASCII кодируются в UTF-8 как есть, а UTF-EBCDIC &amp;laquo;безопасен для EBCDIC&amp;raquo; в том смысле, что все основные символы (включая все те, которые имеют эквиваленты ASCII (например, &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="24eed6474921c436fc7017c3e9ee9fd9b18bd251" translate="yes" xml:space="preserve">
          <source>On Linux as of perl v5.14.0 the legacy process name will be set with &lt;code&gt;prctl(2)&lt;/code&gt; , in addition to altering the POSIX name via &lt;code&gt;argv[0]&lt;/code&gt; as perl has done since version 4.000. Now system utilities that read the legacy process name such as ps, top and killall will recognize the name you set when assigning to &lt;code&gt;$0&lt;/code&gt; . The string you supply will be cut off at 16 bytes, this is a limitation imposed by Linux.</source>
          <target state="translated">В Linux начиная с perl v5.14.0 унаследованное имя процесса будет установлено с помощью &lt;code&gt;prctl(2)&lt;/code&gt; в дополнение к изменению имени POSIX с помощью &lt;code&gt;argv[0]&lt;/code&gt; как это делал perl начиная с версии 4.000. Теперь системные утилиты, которые читают устаревшее имя процесса, такое как ps, top и killall, распознают имя, которое вы задали при присвоении &lt;code&gt;$0&lt;/code&gt; . Предоставляемая вами строка будет обрезана до 16 байт, это ограничение, наложенное Linux.</target>
        </trans-unit>
        <trans-unit id="acdfac3cee0fd1507f95a5dcb4019d7d46aa51e5" translate="yes" xml:space="preserve">
          <source>On MSWin32, each thread maintains its own set of environment variables.</source>
          <target state="translated">В MSWin32 каждый поток поддерживает свой набор переменных окружения.</target>
        </trans-unit>
        <trans-unit id="07fed63ea1db8f306a3fcf956ae30aa0f5f797ab" translate="yes" xml:space="preserve">
          <source>On MSWin32, each thread maintains its own the current working directory setting.</source>
          <target state="translated">В MSWin32 каждый поток поддерживает свои собственные настройки текущей рабочей директории.</target>
        </trans-unit>
        <trans-unit id="fc9baea2d4ac629b8f41cbaaf2320e912f58f4e6" translate="yes" xml:space="preserve">
          <source>On Mac OS, assumes that the last part of the path is a filename unless $no_file is true or a trailing separator &quot;:&quot; is present.</source>
          <target state="translated">В Mac OS предполагает,что последняя часть пути-это имя файла,если только $no_file не равен true или не присутствует разделитель трейлинга &quot;:&quot;.</target>
        </trans-unit>
        <trans-unit id="2c8cbf9feb69a54cf112ddb280be3a352f96b397" translate="yes" xml:space="preserve">
          <source>On Mac OS, there's nothing to be done. Returns what it's given.</source>
          <target state="translated">На Mac OS ничего не поделаешь.Возвращает то,что дано.</target>
        </trans-unit>
        <trans-unit id="1110960c59d5ed71b666c1e4c9c495538ef1f179" translate="yes" xml:space="preserve">
          <source>On OS/390 or z/OS see the</source>
          <target state="translated">На OS/390 или z/OS смотрите раздел</target>
        </trans-unit>
        <trans-unit id="d3d05f25204078cfb6759aed14497988db83abc4" translate="yes" xml:space="preserve">
          <source>On OSes where temp files are automatically removed when the temp file is closed, calling this function will have no effect other than to remove temporary directories (which may include temporary files).</source>
          <target state="translated">На операционных системах,где временные файлы автоматически удаляются при закрытии временного файла,вызов этой функции не будет иметь никакого эффекта,кроме удаления временных каталогов (которые могут включать временные файлы).</target>
        </trans-unit>
        <trans-unit id="d375d4a0af7ab518303234b7c17d1169f40e9bcc" translate="yes" xml:space="preserve">
          <source>On PA-RISC you need a different compiler for 32-bit applications and for 64-bit applications. On PA-RISC, 32-bit objects and 64-bit objects do not mix. Period. There is no different behaviour for HP C-ANSI-C or GNU gcc. So if you require your perl binary to use 64-bit libraries, like Oracle-64bit, you MUST build a 64-bit perl.</source>
          <target state="translated">На PA-RISC нужен другой компилятор для 32-битных и 64-битных приложений.На PA-RISC 32-битные объекты и 64-битные объекты не смешиваются.Период.Для HP C-ANSI-C или GNU gcc нет различного поведения.Так что если для использования 64-битных библиотек,таких как Oracle-64bit,вам нужен perl,то вы ДОЛЖНЫ собрать 64-битный perl.</target>
        </trans-unit>
        <trans-unit id="92d7a8c18ee051a4b37ffd21066565b5d3a9d46d" translate="yes" xml:space="preserve">
          <source>On POSIX systems, that program will likely be GNU Make; on Microsoft Windows, it will be either Microsoft NMake, DMake or GNU Make. See the section on the &lt;a href=&quot;#MAKE&quot;&gt;MAKE&lt;/a&gt; parameter for details.</source>
          <target state="translated">В системах POSIX этой программой, скорее всего, будет GNU Make; в Microsoft Windows это будет Microsoft NMake, DMake или GNU Make. См. Подробности в разделе о параметре &lt;a href=&quot;#MAKE&quot;&gt;MAKE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec792d74700736cdfd9a5c7544b143a95c42354e" translate="yes" xml:space="preserve">
          <source>On Perl versions before 5.7, Unicode characters with a value over 255 (like lambda or emdash) can't be conveyed. This module does work under such early Perl versions, but in the place of each such character, you get a &quot;?&quot;. Latin-1 characters (characters 160-255) are unaffected.</source>
          <target state="translated">На Perl-версиях до 5.7 символы юникода со значением более 255 (например,лямбда или emdash)не могут быть переданы.Этот модуль работает под такими ранними Perl-версиями,но вместо каждого такого символа вы получаете &quot;?&quot;.Символы латинского алфавита 1 (символы 160-255)не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="1b4fd9509076b696b649edffe06b6748d3a6e8fc" translate="yes" xml:space="preserve">
          <source>On The Road</source>
          <target state="translated">В дороге</target>
        </trans-unit>
        <trans-unit id="3f5f166131dd85ac983f4decac309eb76b2240b2" translate="yes" xml:space="preserve">
          <source>On Unix these calls probably have no effect whatsoever. Elsewhere they alter &quot;\n&quot; to CR,LF translation and possibly cause a special text &quot;end of file&quot; indicator to be written or honoured on read. The effect of making the call after doing any IO to the handle depends on the implementation. (It may be ignored, affect any data which is already buffered as well, or only apply to subsequent data.)</source>
          <target state="translated">На Unix эти звонки,вероятно,не имеют никакого эффекта.В других местах они изменяют &quot;\n&quot; на перевод CR,LF и,возможно,вызывают специальный текстовый индикатор &quot;конец файла&quot; при прочтении.Эффект вызова после выполнения любого ввода-вывода в интерпретатор зависит от реализации.(Он может быть проигнорирован,повлиять на любые данные,которые уже буферизированы,или применяться только к последующим данным).</target>
        </trans-unit>
        <trans-unit id="86c676209565e2d780081a941df86b84b21d9627" translate="yes" xml:space="preserve">
          <source>On Unix,</source>
          <target state="translated">На Unix,</target>
        </trans-unit>
        <trans-unit id="88e8f2f2ac45a9bfa4ec12f4ed8e00688059ccf6" translate="yes" xml:space="preserve">
          <source>On VMS by default, changes to the %ENV hash persist after perl exits. Subsequent invocations of perl in the same process can inadvertently inherit environment settings that were meant to be temporary.</source>
          <target state="translated">В СУБД по умолчанию изменения в хэше %ENV сохраняются после perl выходов.Последующие вызовы perl в том же процессе могут непреднамеренно наследовать настройки среды,которые должны были быть временными.</target>
        </trans-unit>
        <trans-unit id="5a45916e3343efd4a31048a877153354c7f3a445" translate="yes" xml:space="preserve">
          <source>On VMS only, record reads bypass PerlIO layers and any associated buffering, so you must not mix record and non-record reads on the same filehandle. Record mode mixes with line mode only when the same buffering layer is in use for both modes.</source>
          <target state="translated">Только на VMS,запись читает в обход PerlIO слоев и любой связанной буферизации,так что вы не должны смешивать запись и не-запись читает на той же файловой ручке.Режим записи смешивается с режимом линии только в том случае,если для обоих режимов используется один и тот же слой буферизации.</target>
        </trans-unit>
        <trans-unit id="9795304d9e947203c83b021d72efea5ba3031bdc" translate="yes" xml:space="preserve">
          <source>On VMS systems, arrays tied to environment variables are read-only. Attempting to change anything will cause a warning.</source>
          <target state="translated">На системах VMS массивы,привязанные к переменным окружения,доступны только для чтения.Попытка что-либо изменить вызовет предупреждение.</target>
        </trans-unit>
        <trans-unit id="81ce16b2de32a17abe516725e03bc48e7d14b744" translate="yes" xml:space="preserve">
          <source>On VMS, perl determines the UTC offset from the &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; logical name. Although the VMS epoch began at 17-NOV-1858 00:00:00.00, calls to &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; are adjusted to count offsets from 01-JAN-1970 00:00:00.00, just like Unix.</source>
          <target state="translated">В VMS perl определяет смещение UTC по логическому имени &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; . Хотя эпоха VMS началась в 17 ноября 1858 г. 00: 00: 00.00, звонки на &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; время корректируются с учетом смещений с 01-ЯНВ-1970 00: 00: 00.00, как и в Unix.</target>
        </trans-unit>
        <trans-unit id="4640e9f8e338d51c98fb597af9efcb27c56ecf3e" translate="yes" xml:space="preserve">
          <source>On VMS, some entries in the &lt;code&gt;%ENV&lt;/code&gt; hash are dynamically created when their key is used on a read if they did not previously exist. The values for &lt;code&gt;$ENV{HOME}&lt;/code&gt; , &lt;code&gt;$ENV{TERM}&lt;/code&gt; , &lt;code&gt;$ENV{PATH}&lt;/code&gt; , and &lt;code&gt;$ENV{USER}&lt;/code&gt; , are known to be dynamically generated. The specific names that are dynamically generated may vary with the version of the C library on VMS, and more may exist than are documented.</source>
          <target state="translated">В VMS некоторые записи в хэше &lt;code&gt;%ENV&lt;/code&gt; динамически создаются, когда их ключ используется при чтении, если они ранее не существовали. Известно, что значения &lt;code&gt;$ENV{HOME}&lt;/code&gt; , &lt;code&gt;$ENV{TERM}&lt;/code&gt; , &lt;code&gt;$ENV{PATH}&lt;/code&gt; и &lt;code&gt;$ENV{USER}&lt;/code&gt; генерируются динамически. Конкретные имена, которые создаются динамически, могут различаться в зависимости от версии библиотеки C в VMS, и их может существовать больше, чем задокументировано.</target>
        </trans-unit>
        <trans-unit id="00ea6af97bd8140ce5328dca64213948bcea1edc" translate="yes" xml:space="preserve">
          <source>On VMS, which has a volume concept, this field will be empty because VMS file specifications are converted to absolute UNIX format and the volume information is transparently included.</source>
          <target state="translated">На VMS,которая имеет концепцию тома,это поле будет пустым,потому что спецификации файлов VMS преобразуются в абсолютный формат UNIX,а информация об томах включается прозрачно.</target>
        </trans-unit>
        <trans-unit id="7181afce3600b3de6f4aeeecdb2753ed0ec50123" translate="yes" xml:space="preserve">
          <source>On VOS, time values are 32-bit quantities.</source>
          <target state="translated">На VOS значения времени составляют 32-разрядные величины.</target>
        </trans-unit>
        <trans-unit id="260fa2754bf084766a1e3d1258ce83d5b5d3b0dc" translate="yes" xml:space="preserve">
          <source>On Win32 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; needs to open the file to determine the link count and update attributes that may have been changed through hard links. Setting &lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt; to a true value speeds up &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; by not performing this operation. (Win32)</source>
          <target state="translated">В Win32 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; необходимо открыть файл, чтобы определить количество ссылок и обновить атрибуты, которые могли быть изменены с помощью жестких ссылок. Установка &lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt; в истинное значение ускоряет &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; , не выполняя эту операцию. (Win32)</target>
        </trans-unit>
        <trans-unit id="43527614576e6873bffe9e01120e3463ca7900ba" translate="yes" xml:space="preserve">
          <source>On Win32 platforms this</source>
          <target state="translated">На Win32 платформах это</target>
        </trans-unit>
        <trans-unit id="82880baf8efa4ec11213dbe5173474c89dad4fe5" translate="yes" xml:space="preserve">
          <source>On Win32 ports only, may be set to an alternative shell that Perl must use internally for executing &quot;backtick&quot; commands or system(). Default is &lt;code&gt;cmd.exe /x/d/c&lt;/code&gt; on WindowsNT and &lt;code&gt;command.com /c&lt;/code&gt; on Windows95. The value is considered space-separated. Precede any character that needs to be protected, like a space or backslash, with another backslash.</source>
          <target state="translated">Только на портах Win32 может быть установлена ​​альтернативная оболочка, которую Perl должен использовать внутри для выполнения команд с обратным апострофом или system (). По умолчанию это &lt;code&gt;cmd.exe /x/d/c&lt;/code&gt; в WindowsNT и &lt;code&gt;command.com /c&lt;/code&gt; в Windows95. Значение считается разделенным пробелами. Перед любым символом, который необходимо защитить, например пробелом или обратной косой чертой, ставьте другую обратную косую черту.</target>
        </trans-unit>
        <trans-unit id="9e2fd429fcf5069c4431ad927b87b339316ae6b1" translate="yes" xml:space="preserve">
          <source>On Win32 the default in this release (5.14) is &quot;unix crlf&quot;. Win32's &quot;stdio&quot; has a number of bugs/mis-features for Perl IO which are somewhat depending on the version and vendor of the C compiler. Using our own &lt;code&gt;crlf&lt;/code&gt; layer as the buffer avoids those issues and makes things more uniform. The &lt;code&gt;crlf&lt;/code&gt; layer provides CRLF conversion as well as buffering.</source>
          <target state="translated">В Win32 по умолчанию в этом выпуске (5.14) используется &quot;unix crlf&quot;. &quot;Stdio&quot; Win32 имеет ряд ошибок / неправильных функций для Perl IO, которые отчасти зависят от версии и поставщика компилятора C. Использование нашего собственного слоя &lt;code&gt;crlf&lt;/code&gt; в качестве буфера позволяет избежать этих проблем и сделать вещи более единообразными. &lt;code&gt;crlf&lt;/code&gt; слой обеспечивает преобразование CRLF, а также буферизация.</target>
        </trans-unit>
        <trans-unit id="c661dbe60c2c9116c9b6dd06327729491426c6d8" translate="yes" xml:space="preserve">
          <source>On WinNT &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; can change a file's user and group IDs. On Win9x &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; is a no-op, although this is appropriate since there is no security model.</source>
          <target state="translated">В WinNT &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; может изменять идентификаторы пользователя и группы файла. В Win9x &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; не работает, хотя это уместно, поскольку не существует модели безопасности.</target>
        </trans-unit>
        <trans-unit id="691092ab9995db74d07e64291684fba5bdc303c2" translate="yes" xml:space="preserve">
          <source>On Windows this value may be empty if the uri is to a network share, in which case the 'share' property will be defined. Additionally, volume specifications that use '|' as ':' will be converted on read to use ':'.</source>
          <target state="translated">В Windows это значение может быть пустым,если uri принадлежит сетевому ресурсу,в этом случае будет определено свойство 'share'.К тому же,спецификации тома,использующие '|' в качестве ':',будут преобразованы при чтении в ':'.</target>
        </trans-unit>
        <trans-unit id="8d5fbf1c54f4cbef1a178b46ad87cba27e8e2dbd" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;code&gt;make_path&lt;/code&gt; gives you this warning, it may mean that you have exceeded your filesystem's maximum path length.</source>
          <target state="translated">В Windows, если &lt;code&gt;make_path&lt;/code&gt; выдает это предупреждение, это может означать, что вы превысили максимальную длину пути вашей файловой системы.</target>
        </trans-unit>
        <trans-unit id="3c8b57e0402fd5a94f4f0f14b11ffcf0d1fe5e8c" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">В Windows только синтаксис косвенного объекта &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; надежно избегает использования оболочки; &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , даже с более чем одним элементом, вернется к оболочке, если первое порождение не удастся.</target>
        </trans-unit>
        <trans-unit id="3489286293a7a904918509c734ebd323e4463d4f" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">В Windows только синтаксис косвенного объекта &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; надежно избегает использования оболочки; &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , даже с более чем одним элементом, вернется к оболочке, если первое порождение не удастся.</target>
        </trans-unit>
        <trans-unit id="1feb74b008066b7c35338a20235da8f4be77079d" translate="yes" xml:space="preserve">
          <source>On Windows, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; module. After creating an object for the output filehandle you want to affect, call the &lt;code&gt;Cls&lt;/code&gt; method:</source>
          <target state="translated">В Windows вы можете использовать модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32 :: Console&lt;/a&gt; . После создания объекта для дескриптора выходного файла, на который вы хотите воздействовать, вызовите метод &lt;code&gt;Cls&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="868e4a545e3b36ea0e0005a952326d136f092bcb" translate="yes" xml:space="preserve">
          <source>On a 64-bit &lt;code&gt;perl&lt;/code&gt; , you can get even larger dates for those really long running projects:</source>
          <target state="translated">На 64-битном &lt;code&gt;perl&lt;/code&gt; вы можете получить еще большие даты для действительно длительных проектов:</target>
        </trans-unit>
        <trans-unit id="1c8e386d10b1658b7fab41743c4a6c61db5c0bb8" translate="yes" xml:space="preserve">
          <source>On a Unix-like system, these documentation files will usually also be available as manpages for use with the</source>
          <target state="translated">На Unix-подобной системе эти файлы документации обычно также будут доступны в виде manpages для использования с</target>
        </trans-unit>
        <trans-unit id="660953bc195f4695e40bafcb35d1864a5ea40fb9" translate="yes" xml:space="preserve">
          <source>On a binary string, you would do things like:</source>
          <target state="translated">На бинарной строке ты бы делал такие вещи:</target>
        </trans-unit>
        <trans-unit id="c2fd3df54f8bb812f03e4f16967bb0e0784afad2" translate="yes" xml:space="preserve">
          <source>On a new install it is &quot;C:\Windows CE Tools&quot;. Goto &quot;C:\Windows CE Tools&quot; in a file manager and see if &quot;C:\Windows CE Tools\wce400\STANDARDSDK\Include\Armv4&quot; exists on your disk. If not the SDKROOT need to be changed to &quot;C:\Program Files\Windows CE Tools&quot;.</source>
          <target state="translated">При новой установке это &quot;C:\Windows CE Tools&quot;.Загляните в файловый менеджер &quot;C:\Windows CE Tools&quot; и посмотрите,существует ли на диске &quot;C:\Windows CE Tools\wce400\STANDARDSDK\Include\Armv4&quot;.Если нет,то SDKROOT нужно заменить на &quot;C:\Program Files\Windows CE Tools&quot;.</target>
        </trans-unit>
        <trans-unit id="299062bf85cb6925da5e4883a42054b0da9f24d7" translate="yes" xml:space="preserve">
          <source>On a related note, if you do use &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;, then you're going to need a &lt;code&gt;dTARG&lt;/code&gt; in your variable declarations so that the &lt;code&gt;*PUSH*&lt;/code&gt; macros can make use of the local variable &lt;code&gt;TARG&lt;/code&gt; . See also &lt;code&gt;dTARGET&lt;/code&gt; and &lt;code&gt;dXSTARG&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; , если вы используете (X) PUSH [iunp] , вам понадобится &lt;code&gt;dTARG&lt;/code&gt; в объявлениях переменных, чтобы макросы &lt;code&gt;*PUSH*&lt;/code&gt; могли использовать локальную переменную &lt;code&gt;TARG&lt;/code&gt; . См. Также &lt;code&gt;dTARGET&lt;/code&gt; и &lt;code&gt;dXSTARG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d381c7864f9bd0c496e832a74c2bc6e826af96f2" translate="yes" xml:space="preserve">
          <source>On a successful match, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to FALSE, and the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the last &lt;code&gt;(*MARK:NAME)&lt;/code&gt; pattern executed. See the explanation for the &lt;code&gt;(*MARK:NAME)&lt;/code&gt; verb below for more details.</source>
          <target state="translated">В случае успешного совпадения переменной &lt;code&gt;$REGERROR&lt;/code&gt; будет присвоено значение FALSE, а переменной &lt;code&gt;$REGMARK&lt;/code&gt; будет присвоено имя последнего выполненного шаблона &lt;code&gt;(*MARK:NAME)&lt;/code&gt; . Подробнее см. Объяснение глагола &lt;code&gt;(*MARK:NAME)&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="df6a4ca6e213ccefa4b99c6f895a6d3c5870376c" translate="yes" xml:space="preserve">
          <source>On a text string, you would do things like:</source>
          <target state="translated">На текстовой строке ты бы делал такие вещи:</target>
        </trans-unit>
        <trans-unit id="16575e035ca925e5fa5bb99a005281cd0246209f" translate="yes" xml:space="preserve">
          <source>On all platforms except MSWin32, the setting for the current working directory is shared among all threads such that changing it in one thread (e.g., using &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;) will affect all the threads in the application.</source>
          <target state="translated">На всех платформах, кроме MSWin32, настройка текущего рабочего каталога используется всеми потоками, так что изменение его в одном потоке (например, использование &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; ) повлияет на все потоки в приложении.</target>
        </trans-unit>
        <trans-unit id="986faea7525ededb053c5e26524df4fe094d07f8" translate="yes" xml:space="preserve">
          <source>On all the released versions of Solaris (8, 9 and 10) you need to make sure the following packages are installed (this info is extracted from the Solaris FAQ):</source>
          <target state="translated">На всех выпущенных версиях Solaris (8,9 и 10)необходимо убедиться,что установлены следующие пакеты (эта информация взята из Solaris FAQ):</target>
        </trans-unit>
        <trans-unit id="7579bfbb9367171f6983e33cf0c36d410d39ce7e" translate="yes" xml:space="preserve">
          <source>On certain platforms like Win32, OS/2, VMS, and AIX, it is necessary to perform some actions before invoking the linker. The &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; module does this, writing files used by the linker during the creation of shared libraries for dynamic extensions. The names of any files written will be returned as a list.</source>
          <target state="translated">На определенных платформах, таких как Win32, OS / 2, VMS и AIX, перед вызовом компоновщика необходимо выполнить некоторые действия. Модуль &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; делает это, записывая файлы, используемые компоновщиком во время создания общих библиотек для динамических расширений. Имена любых записанных файлов будут возвращены в виде списка.</target>
        </trans-unit>
        <trans-unit id="48eee9c0d3be3641023bdfbc12b873ba074e7d8a" translate="yes" xml:space="preserve">
          <source>On certain platforms, for example Windows, not all the fields returned by stat() can be compared. For example, the C</source>
          <target state="translated">На некоторых платформах,например Windows,не все поля,возвращаемые функцией stat(),можно сравнить.Например,C</target>
        </trans-unit>
        <trans-unit id="0337022749da68904dc67bf7ba7a67afde209ea2" translate="yes" xml:space="preserve">
          <source>On creation of a new message queue &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">При создании новой очереди сообщений &lt;code&gt;FLAGS&lt;/code&gt; используется для установки разрешений. Будьте осторожны, чтобы не устанавливать какие-либо флаги, которые реализация Sys V IPC не позволяет: в некоторых системах установка битов выполнения приводит к сбою операций.</target>
        </trans-unit>
        <trans-unit id="82a6576fe44e35482e50d08d072f3b166203f73f" translate="yes" xml:space="preserve">
          <source>On creation of a new semaphore set &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">При создании нового набора семафоров &lt;code&gt;FLAGS&lt;/code&gt; используется для установки разрешений. Будьте осторожны, чтобы не устанавливать какие-либо флаги, которые реализация Sys V IPC не позволяет: в некоторых системах установка битов выполнения приводит к сбою операций.</target>
        </trans-unit>
        <trans-unit id="2a590d182300640c7833d62b48486238fd75ebb4" translate="yes" xml:space="preserve">
          <source>On creation of a new shared memory segment &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">При создании нового сегмента разделяемой памяти &lt;code&gt;FLAGS&lt;/code&gt; используется для установки разрешений. Будьте осторожны, чтобы не устанавливать какие-либо флаги, которые реализация Sys V IPC не позволяет: в некоторых системах установка битов выполнения приводит к сбою операций.</target>
        </trans-unit>
        <trans-unit id="475139521c9cdabb77d7980af3eb2a8b5f2f65f2" translate="yes" xml:space="preserve">
          <source>On demand loader for PerlIO layers and root of PerlIO::* name space</source>
          <target state="translated">Загрузчик по требованию для слоев PerlIO и корня PerlIO::*пространство имен</target>
        </trans-unit>
        <trans-unit id="f2bd0e6ad9c12f3371f3ea04fa2670eb6d77c58f" translate="yes" xml:space="preserve">
          <source>On each line are two expressions that do the same thing. The left-hand versions operate on the array &lt;code&gt;@a&lt;/code&gt; . The right-hand versions operate on the array that is referred to by &lt;code&gt;$aref&lt;/code&gt; . Once they find the array they're operating on, both versions do the same things to the arrays.</source>
          <target state="translated">В каждой строке два выражения, которые делают то же самое. Левые версии работают с массивом &lt;code&gt;@a&lt;/code&gt; . Правые версии работают с массивом, на который ссылается &lt;code&gt;$aref&lt;/code&gt; . Как только они находят массив, с которым работают, обе версии делают с массивами то же самое.</target>
        </trans-unit>
        <trans-unit id="9b2fc3f2e5f903dbf2df61622a774607772dffe7" translate="yes" xml:space="preserve">
          <source>On entry</source>
          <target state="translated">На въезде</target>
        </trans-unit>
        <trans-unit id="d373dfecfc1b40b4191bc53322c596729a91c216" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;$out&lt;/code&gt; will be</source>
          <target state="translated">В случае ошибки &lt;code&gt;$out&lt;/code&gt; будет</target>
        </trans-unit>
        <trans-unit id="6d9c828155c10075b78663a197d9675f7b0c4a6f" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; behaves just like select(2): it returns -1 and sets &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">В случае ошибки &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; ведет себя так же, как select (2): возвращает -1 и устанавливает &lt;code&gt;$!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44a9825ad010a78ae9dfacedfc100780572dc5b3" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="translated">В случае ошибки &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; не сообщит вам, какие файлы удалить не удалось. Если вы хотите узнать, какие файлы удалить не удалось, попробуйте их по одному:</target>
        </trans-unit>
        <trans-unit id="819a867a035e72ad9106196135c7d9f4e3277f0c" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; behaves just like select(2): it returns -1 and sets &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">В случае ошибки &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; ведет себя так же, как select (2): возвращает -1 и устанавливает &lt;code&gt;$!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a02d8cd61d158290b01862aca1060c57ef007153" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="translated">В случае ошибки &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; не сообщит вам, какие файлы удалить не удалось. Если вы хотите узнать, какие файлы удалить не удалось, попробуйте их по одному:</target>
        </trans-unit>
        <trans-unit id="45e73f10ec8215e1c14a06d24df3320696729415" translate="yes" xml:space="preserve">
          <source>On error, it returns a</source>
          <target state="translated">По ошибке он возвращает</target>
        </trans-unit>
        <trans-unit id="18136bfa0b529aa75c0ac9c1c7bf6a9d9e72f925" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned and &lt;code&gt;$@&lt;/code&gt; will contain the reason for the failure.</source>
          <target state="translated">В случае сбоя будет возвращено &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , а &lt;code&gt;$@&lt;/code&gt; будет содержать причину сбоя.</target>
        </trans-unit>
        <trans-unit id="42061a94fa2069016ce15d6e815f1341a1d2cabd" translate="yes" xml:space="preserve">
          <source>On failure, $decoder now contains an error message so the whole thing would be as follows;</source>
          <target state="translated">При сбое $decoder теперь содержит сообщение об ошибке,так что все будет выглядеть следующим образом;</target>
        </trans-unit>
        <trans-unit id="4946878f668a0186d10fe06797278b27abd1a3bc" translate="yes" xml:space="preserve">
          <source>On failure, all of these values (except the remaining text) are &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В случае ошибки все эти значения (кроме оставшегося текста) становятся &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0a91a2a84ece7b39d4d347acdd9155aefa71bb9" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the ARG value of the verb pattern, if the verb was involved in the failure of the match. If the ARG part of the pattern was omitted, then &lt;code&gt;$REGERROR&lt;/code&gt; will be set to the name of the last &lt;code&gt;(*MARK:NAME)&lt;/code&gt; pattern executed, or to TRUE if there was none. Also, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to FALSE.</source>
          <target state="translated">В случае &lt;code&gt;$REGERROR&lt;/code&gt; переменная $ REGERROR будет установлена ​​в значение ARG шаблона глагола, если глагол был задействован в неудачном сопоставлении. Если часть шаблона ARG была опущена, тогда &lt;code&gt;$REGERROR&lt;/code&gt; будет присвоено имя последнего выполненного шаблона &lt;code&gt;(*MARK:NAME)&lt;/code&gt; или TRUE, если его не было. Кроме того, для переменной &lt;code&gt;$REGMARK&lt;/code&gt; будет установлено значение FALSE.</target>
        </trans-unit>
        <trans-unit id="5064a047349d10718c6c646e1984f32902ee6b9f" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call returns an undefined value and probably sets &lt;code&gt;$!&lt;/code&gt; to contain the reason the file could not be tied.</source>
          <target state="translated">В случае неудачи вызов &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; возвращает неопределенное значение и, вероятно, устанавливает &lt;code&gt;$!&lt;/code&gt; чтобы указать причину, по которой файл не может быть привязан.</target>
        </trans-unit>
        <trans-unit id="6499c88e3c2522e878e6f7bffd23feb1b280e5ce" translate="yes" xml:space="preserve">
          <source>On input, it converts the bytes expected to be in the specified character set and encoding to Perl string data (Unicode and Perl's internal Unicode encoding, UTF-8). On output, it converts Perl string data into the specified character set and encoding.</source>
          <target state="translated">На входе преобразует байты,ожидаемые в указанном наборе символов и кодировке,в данные Perl строки (Юникод и внутренняя кодировка Perl в Юникоде,UTF-8).На выходе преобразует данные Perl-строки в указанный набор символов и кодировку.</target>
        </trans-unit>
        <trans-unit id="a604823a1a15074f7b145c1cca70f834c1350b88" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, the &lt;code&gt;CHLD&lt;/code&gt; (sometimes also known as &lt;code&gt;CLD&lt;/code&gt; ) signal has special behavior with respect to a value of &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . Setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; on such a platform has the effect of not creating zombie processes when the parent process fails to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; on its child processes (i.e., child processes are automatically reaped). Calling &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;$SIG{CHLD}&lt;/code&gt; set to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; usually returns &lt;code&gt;-1&lt;/code&gt; on such platforms.</source>
          <target state="translated">На большинстве платформ Unix &lt;code&gt;CHLD&lt;/code&gt; (иногда также известный как &lt;code&gt;CLD&lt;/code&gt; ) имеет особое поведение по отношению к значению &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . Установка &lt;code&gt;$SIG{CHLD}&lt;/code&gt; к &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; на такой платформе имеет эффект не создавая процессов зомби , когда родительский процесс не может &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; на его дочерние процессы (т.е. автоматически пожали дочерние процессы). Вызов &lt;code&gt;$SIG{CHLD}&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; с параметром $ SIG {CHLD}, установленным на &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; обычно возвращает &lt;code&gt;-1&lt;/code&gt; на таких платформах.</target>
        </trans-unit>
        <trans-unit id="42bca4f6aa51b9c47b8c54f57cf475cd9eb5d60c" translate="yes" xml:space="preserve">
          <source>On most operating systems, memory allocated to a program can never be returned to the system. That's why long-running programs sometimes re- exec themselves. Some operating systems (notably, systems that use mmap(2) for allocating large chunks of memory) can reclaim memory that is no longer used, but on such systems, perl must be configured and compiled to use the OS's malloc, not perl's.</source>
          <target state="translated">На большинстве операционных систем память,выделенная программе,никогда не может быть возвращена в систему.Поэтому долгоработающие программы иногда выполняются заново.Некоторые операционные системы (в частности,системы,использующие mmap(2)для выделения больших участков памяти)могут восстанавливать память,которая больше не используется,но на таких системах perl должен быть сконфигурирован и скомпилирован так,чтобы использовать не perl,а malloc операционной системы.</target>
        </trans-unit>
        <trans-unit id="b3a71ab0d471330a25bbd4385691ed243516aede" translate="yes" xml:space="preserve">
          <source>On most systems, frequent and continual creation and destruction of threads can lead to ever-increasing growth in the memory footprint of the Perl interpreter. While it is simple to just launch threads and then &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; them, for long-lived applications, it is better to maintain a pool of threads, and to reuse them for the work needed, using &lt;a href=&quot;thread/queue&quot;&gt;queues&lt;/a&gt; to notify threads of pending work. The CPAN distribution of this module contains a simple example (</source>
          <target state="translated">В большинстве систем частое и постоянное создание и уничтожение потоков может привести к постоянно растущему объему памяти, занимаемой интерпретатором Perl. Хотя просто запустить потоки, а затем &lt;code&gt;-&amp;gt;join()&lt;/code&gt; или &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; , для долгоживущих приложений лучше поддерживать пул потоков и повторно использовать их для необходимой работы, используя &lt;a href=&quot;thread/queue&quot;&gt;очереди.&lt;/a&gt; чтобы уведомить потоки о незавершенной работе. В дистрибутиве CPAN этого модуля есть простой пример (</target>
        </trans-unit>
        <trans-unit id="09b3ddc53760535691fb4b1738d8256a44f591bc" translate="yes" xml:space="preserve">
          <source>On most systems, you are not allowed to change the ownership of the file unless you're the superuser, although you should be able to change the group to any of your secondary groups. On insecure systems, these restrictions may be relaxed, but this is not a portable assumption. On POSIX systems, you can detect this condition this way:</source>
          <target state="translated">На большинстве систем вам не разрешается изменять право собственности на файл,если только вы не являетесь суперпользователем,хотя вы должны иметь возможность изменять группу на любую из ваших вторичных групп.На небезопасных системах эти ограничения могут быть смягчены,но это не переносное предположение.На POSIX системах вы можете обнаружить это условие таким образом:</target>
        </trans-unit>
        <trans-unit id="2cfd993657bc1e027b5466df69e07a3c252bb4a5" translate="yes" xml:space="preserve">
          <source>On newer 64 bit versions of OpenVMS, a process setting now controls if the quoting is needed to preserve the case of command line arguments.</source>
          <target state="translated">В новых 64-битных версиях OpenVMS настройка процесса теперь контролирует,нужна ли кавычка для сохранения аргументов командной строки.</target>
        </trans-unit>
        <trans-unit id="d67a298149fc32636cbc2cf9ffd43cf9447cc565" translate="yes" xml:space="preserve">
          <source>On older versions of perl, negative epoch (&lt;code&gt;time_t&lt;/code&gt; ) values, which are not officially supported by the POSIX standards, are known not to work on some systems. These include MacOS (pre-OSX) and Win32.</source>
          <target state="translated">В более старых версиях perl отрицательные значения эпохи ( &lt;code&gt;time_t&lt;/code&gt; ), которые официально не поддерживаются стандартами POSIX, не работают в некоторых системах. К ним относятся MacOS (до OSX) и Win32.</target>
        </trans-unit>
        <trans-unit id="b2a99aa4e31ced8b38922d7821d5fd751e2740ad" translate="yes" xml:space="preserve">
          <source>On operating systems with the concept of a volume the second element of a file:// is considered to the be volume specification for the file. Thus on Win32 this routine returns the volume, on other operating systems this returns nothing.</source>
          <target state="translated">На операционных системах с концепцией тома вторым элементом файла://считается спецификация тома для файла.Таким образом,на Win32 эта рутина возвращает том,на других операционных системах-ничего.</target>
        </trans-unit>
        <trans-unit id="4f2532376ddc057f764de9bec478db299bbe8f82" translate="yes" xml:space="preserve">
          <source>On perl version 5.12.0 and newer, negative epoch values are fully supported.</source>
          <target state="translated">На perl версии 5.12.0 и выше отрицательные значения эпохи полностью поддерживаются.</target>
        </trans-unit>
        <trans-unit id="134a9f11ec0d2ae5a78490a1f61d61a762f1fd76" translate="yes" xml:space="preserve">
          <source>On perl versions older than 5.12.0, the range of dates that can be actually be handled depends on the size of &lt;code&gt;time_t&lt;/code&gt; (usually a signed integer) on the given platform. Currently, this is 32 bits for most systems, yielding an approximate range from Dec 1901 to Jan 2038.</source>
          <target state="translated">В версиях Perl старше 5.12.0 диапазон дат, которые могут быть фактически обработаны, зависит от размера &lt;code&gt;time_t&lt;/code&gt; (обычно целого числа со знаком) на данной платформе. В настоящее время для большинства систем это 32 бита, что дает приблизительный диапазон с декабря 1901 года по январь 2038 года.</target>
        </trans-unit>
        <trans-unit id="6022d860b9d735662ef67778672104ce7f7a553c" translate="yes" xml:space="preserve">
          <source>On platforms where &lt;code&gt;need_prelink()&lt;/code&gt; returns true, &lt;code&gt;prelink()&lt;/code&gt; will be called automatically.</source>
          <target state="translated">На платформах, где &lt;code&gt;need_prelink()&lt;/code&gt; возвращает true, &lt;code&gt;prelink()&lt;/code&gt; будет вызываться автоматически.</target>
        </trans-unit>
        <trans-unit id="d4f25eb75f8ca9d9043202ca7699535809aaaa12" translate="yes" xml:space="preserve">
          <source>On platforms where it matters, be sure to call &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; on the descriptors that you pass to Storable functions.</source>
          <target state="translated">На платформах, где это важно, обязательно вызывайте &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; для дескрипторов, которые вы передаете функциям Storable.</target>
        </trans-unit>
        <trans-unit id="741623a3d6fbed74253acab5fef8f32b395ea643" translate="yes" xml:space="preserve">
          <source>On pre-C99 compilers, &lt;code&gt;bool&lt;/code&gt; is defined as equivalent to &lt;code&gt;char&lt;/code&gt; . Consequently assignment of any larger type to a &lt;code&gt;bool&lt;/code&gt; is unsafe and may be truncated. The &lt;code&gt;cBOOL&lt;/code&gt; macro exists to cast it correctly.</source>
          <target state="translated">В компиляторах до C99 &lt;code&gt;bool&lt;/code&gt; определяется как эквивалент &lt;code&gt;char&lt;/code&gt; . Следовательно, присвоение &lt;code&gt;bool&lt;/code&gt; типу любого большего размера небезопасно и может быть усечено. &lt;code&gt;cBOOL&lt;/code&gt; макрос существует правильно брось.</target>
        </trans-unit>
        <trans-unit id="2c58ed64b6e077e0a2ecc28338446ee744bcc90f" translate="yes" xml:space="preserve">
          <source>On rare occasion, such as a database read, you may be given encoded text you need to decode.</source>
          <target state="translated">В редких случаях,например,при чтении базы данных,вам может быть предоставлен закодированный текст,который необходимо декодировать.</target>
        </trans-unit>
        <trans-unit id="b2d3547ac3050c26cb1992ceb42fa15fd067f32b" translate="yes" xml:space="preserve">
          <source>On return, the reference will overwrite the hash slot in the symbol table specified by the *some_hash typeglob. This is a somewhat tricky way of passing around references cheaply when you don't want to have to remember to dereference variables explicitly.</source>
          <target state="translated">При возврате ссылка перезапишет хэш-слот в таблице символов,заданной типографским шрифтом *some_hash.Это несколько хитрый способ дешевой передачи ссылок,когда не нужно явно запоминать разыменование переменных.</target>
        </trans-unit>
        <trans-unit id="aca1e4ba9558a35891aca8fc5a87a5dbef0654bd" translate="yes" xml:space="preserve">
          <source>On simple groups, such as the pattern &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt;, a comparable effect may be achieved by negative look-ahead, as in &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt;. This was only 4 times slower on a string with 1000000 &lt;code&gt;a&lt;/code&gt; s.</source>
          <target state="translated">В простых группах, таких как шаблон &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt; , Сопоставимый эффект может быть достигнут с помощью отрицательного просмотра вперед, как в &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt; . Это было всего в 4 раза медленнее для строки с 1000000 &lt;code&gt;a&lt;/code&gt; с.</target>
        </trans-unit>
        <trans-unit id="85e1720394957ce5ba2b00bf5b14ca83e7b1f8cb" translate="yes" xml:space="preserve">
          <source>On some (but not all) operating systems assigning to &lt;code&gt;$0&lt;/code&gt; modifies the argument area that the &lt;code&gt;ps&lt;/code&gt; program sees. On some platforms you may have to use special &lt;code&gt;ps&lt;/code&gt; options or a different &lt;code&gt;ps&lt;/code&gt; to see the changes. Modifying the &lt;code&gt;$0&lt;/code&gt; is more useful as a way of indicating the current program state than it is for hiding the program you're running.</source>
          <target state="translated">В некоторых (но не во всех) операционных системах присвоение &lt;code&gt;$0&lt;/code&gt; изменяет область аргументов, которую видит программа &lt;code&gt;ps&lt;/code&gt; . На некоторых платформах вам, возможно, придется использовать специальные параметры &lt;code&gt;ps&lt;/code&gt; или другой &lt;code&gt;ps&lt;/code&gt; , чтобы увидеть изменения. Изменение &lt;code&gt;$0&lt;/code&gt; более полезно для указания текущего состояния программы, чем для сокрытия выполняемой программы.</target>
        </trans-unit>
        <trans-unit id="84e7fe0a4e81ece19af2adc12a430c2ffe84e1ae" translate="yes" xml:space="preserve">
          <source>On some OS's where . has special meaning VERSION_SYM may be used in place of VERSION.</source>
          <target state="translated">На некоторых ОС,где.имеет специальное значение,вместо VERSION может использоваться VERSION_SYM.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
