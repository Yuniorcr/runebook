<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="c2df33c30bd450c40b146c186ea09c6cab11e56c" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Session - Abstract base class for harness output delegate</source>
          <target state="translated">СПД::Формат::Сессия-Абстрактный базовый класс для делегата выхода жгута</target>
        </trans-unit>
        <trans-unit id="93ebad31adfaf596a987126afe3d7a3f18d93c05" translate="yes" xml:space="preserve">
          <source>TAP::Harness</source>
          <target state="translated">TAP::Harness</target>
        </trans-unit>
        <trans-unit id="b7d5d266f7a8edc064e0b8c710521d51a2bc894a" translate="yes" xml:space="preserve">
          <source>TAP::Harness - Run test scripts with statistics</source>
          <target state="translated">TAP::Harness-запустить тестовые скрипты со статистикой</target>
        </trans-unit>
        <trans-unit id="a28a3f4d3229f49494c71baca96520e2ecfb6ce6" translate="yes" xml:space="preserve">
          <source>TAP::Harness::Env</source>
          <target state="translated">TAP::Harness::Env</target>
        </trans-unit>
        <trans-unit id="91f28a5a62ef8f799cd7525ba0b5759ca2448d9c" translate="yes" xml:space="preserve">
          <source>TAP::Harness::Env - Parsing harness related environmental variables where appropriate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a70a46bfa38bc1216fe94cb04afcea34c7e8685" translate="yes" xml:space="preserve">
          <source>TAP::Object</source>
          <target state="translated">TAP::Object</target>
        </trans-unit>
        <trans-unit id="f09e3a92ac29a0ecd8a4f02097d67c9251bfb4fd" translate="yes" xml:space="preserve">
          <source>TAP::Object - Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">TAP :: Object - Базовый класс, который обеспечивает общие функции для всех модулей &lt;code&gt;TAP::*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73c55e213830c688e72c24e7e2dc38927a8f526e" translate="yes" xml:space="preserve">
          <source>TAP::Parser</source>
          <target state="translated">TAP::Parser</target>
        </trans-unit>
        <trans-unit id="f762f998d40c617b51b08688208676705b948fa6" translate="yes" xml:space="preserve">
          <source>TAP::Parser - Parse &lt;a href=&quot;Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f07ed865105b4fe8e06f2ed0ef74d2249f0ce1b" translate="yes" xml:space="preserve">
          <source>TAP::Parser - Parse &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; output</source>
          <target state="translated">TAP :: Parser - Разобрать вывод &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="947140d84d6dc3586ce66227c8fbf3b5502269bb" translate="yes" xml:space="preserve">
          <source>TAP::Parser also supports callbacks; bailout, comment, plan, test, unknown, version and yaml are called for the corresponding TAP result types, ALL is called for all results, ELSE is called for all results for which a named callback is not installed and EOF is called once at the end of each TAP stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a216f40bfe5d8c4e9f480503b3353a997f25d9e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Aggregator</source>
          <target state="translated">TAP::Parser::Aggregator</target>
        </trans-unit>
        <trans-unit id="29967243373ff3c2847efa03292cf1394ade91bf" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Aggregator - Aggregate TAP::Parser results</source>
          <target state="translated">TAP::Парсер::Агрегатор-Агрегировать результаты TAP::Парсер</target>
        </trans-unit>
        <trans-unit id="ea252a87adf45624e0915f082cf3a171691e2b87" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Grammar</source>
          <target state="translated">TAP::Parser::Grammar</target>
        </trans-unit>
        <trans-unit id="99d73c9149822b89f098465b0ef15b6e5e432ba4" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Grammar - A grammar for the Test Anything Protocol.</source>
          <target state="translated">TAP::Парсер::Грамматика-грамматика для протокола Test Anything.</target>
        </trans-unit>
        <trans-unit id="f66dcc18cf605bab72f282216bf437fafae85c73" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator</source>
          <target state="translated">TAP::Parser::Iterator</target>
        </trans-unit>
        <trans-unit id="d222e4542e0f93a9f4cabc8a65b724fcc86515cd" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator - Base class for TAP source iterators</source>
          <target state="translated">TAP::Parser::Iterator-Базовый класс для итераторов источника TAP</target>
        </trans-unit>
        <trans-unit id="599e631b6f320b3fc47ee504d90a3e175b821f4e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Array</source>
          <target state="translated">TAP::Parser::Iterator::Array</target>
        </trans-unit>
        <trans-unit id="8849b72265bccd1154b20c5bcfd79b6177e1d979" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Array - Iterator for array-based TAP sources</source>
          <target state="translated">TAP::Parser::Iterator::Array-Iterator для источников TAP на основе массива</target>
        </trans-unit>
        <trans-unit id="8afb640018f748c7abac8e508f78557fe8689509" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Process</source>
          <target state="translated">TAP::Parser::Iterator::Process</target>
        </trans-unit>
        <trans-unit id="ef61fd1ef2ee2ba4a706833aed0bb08fe84a24ba" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Process - Iterator for process-based TAP sources</source>
          <target state="translated">TAP::Парсер::Итератор::Процесс-Итератор для процессных TAP источников</target>
        </trans-unit>
        <trans-unit id="c97751b26f9e6df1ee3c0a7feabeda4e0d9102c3" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Stream</source>
          <target state="translated">TAP::Parser::Iterator::Stream</target>
        </trans-unit>
        <trans-unit id="be38f68275dc99a67c8ac1d8cfd48bb032de4d4a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Stream - Iterator for filehandle-based TAP sources</source>
          <target state="translated">TAP::Parser::Iterator::Stream-Iterator для TAP-источников,основанных на файловых дескрипторах</target>
        </trans-unit>
        <trans-unit id="d89bed7b6f6d5d165f751cac2ac0a13e2dd7f697" translate="yes" xml:space="preserve">
          <source>TAP::Parser::IteratorFactory</source>
          <target state="translated">TAP::Parser::IteratorFactory</target>
        </trans-unit>
        <trans-unit id="8d39f8677b4d63ea3260e5507a930c994a438d70" translate="yes" xml:space="preserve">
          <source>TAP::Parser::IteratorFactory - Figures out which SourceHandler objects to use for a given Source</source>
          <target state="translated">TAP::Parser::IteratorFactory-Выясняет,какие объекты SourceHandler использовать для данного источника.</target>
        </trans-unit>
        <trans-unit id="6f50fafc730902e3aa24fa13c0c429b89a2cc1ff" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Multiplexer</source>
          <target state="translated">TAP::Parser::Multiplexer</target>
        </trans-unit>
        <trans-unit id="2da48d5d830b8cd9138d15d18237febc28e0b498" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Multiplexer - Multiplex multiple TAP::Parsers</source>
          <target state="translated">TAP::Парсер::Мультиплексор-Мультиплексный мультиплексный мультиплексор TAP::Парсер</target>
        </trans-unit>
        <trans-unit id="3c077c3ce874909f47ae77cbcca2c04344198e5b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result</source>
          <target state="translated">TAP::Parser::Result</target>
        </trans-unit>
        <trans-unit id="a422082a9e255b156b40569483bd6f50f2d5a284" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result - Base class for TAP::Parser output objects</source>
          <target state="translated">TAP::Parser::Результат-Базовый класс для объектов вывода TAP::Parser</target>
        </trans-unit>
        <trans-unit id="03b8058105031bc1095218a7667a2ea1b2512b1e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Bailout</source>
          <target state="translated">TAP::Parser::Result::Bailout</target>
        </trans-unit>
        <trans-unit id="00f4b677e9dddb24581e9ed004b7470cf77a617e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Bailout - Bailout result token.</source>
          <target state="translated">TAP::Парсер::Результат::Спасение-маркер результата спасения.</target>
        </trans-unit>
        <trans-unit id="afba56eaac641feaac3daf9f840411e87ecf1e14" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Comment</source>
          <target state="translated">TAP::Parser::Result::Comment</target>
        </trans-unit>
        <trans-unit id="15ac19d49aebc2fdbf7a430ac512a0c55bc03548" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Comment - Comment result token.</source>
          <target state="translated">TAP::Парсер::Результат::Комментарий-Комментарий маркера результата.</target>
        </trans-unit>
        <trans-unit id="8028e0720d8ec37d7287bdb1bc7450078b0bf251" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Plan</source>
          <target state="translated">TAP::Parser::Result::Plan</target>
        </trans-unit>
        <trans-unit id="4383859286c921d76add9716628e055668e9e51d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Plan - Plan result token.</source>
          <target state="translated">TAP::Парсер::Результат::План-Запланировать маркер результата.</target>
        </trans-unit>
        <trans-unit id="f69e80305022a26d3e2f7acc2b0ed1b953372499" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Pragma</source>
          <target state="translated">TAP::Parser::Result::Pragma</target>
        </trans-unit>
        <trans-unit id="14e0c88ebea6563cf55ee8c08b3b9ed300f0d20c" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Pragma - TAP pragma token.</source>
          <target state="translated">TAP::Парсер::Результат::Прагма-TAP прагматический жетон.</target>
        </trans-unit>
        <trans-unit id="2c91344b1f933a9487eebefc220df8812b008445" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Test</source>
          <target state="translated">TAP::Parser::Result::Test</target>
        </trans-unit>
        <trans-unit id="edc9dae5ee4fae6dd91f0295f192573a8fb6a01a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Test - Test result token.</source>
          <target state="translated">TAP::Парсер::Результат::Тест-маркер результата теста.</target>
        </trans-unit>
        <trans-unit id="44c345b7d9dc9992b3e410debbb02b0d29d66e79" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Unknown</source>
          <target state="translated">TAP::Parser::Result::Unknown</target>
        </trans-unit>
        <trans-unit id="2943117d9510c588ee4451eb94edacf47000ab69" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Unknown - Unknown result token.</source>
          <target state="translated">TAP::Парсер::Результат::Неизвестно-Токен неизвестного результата.</target>
        </trans-unit>
        <trans-unit id="c6da177c03a14aa64f029674caca24adf3980051" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Version</source>
          <target state="translated">TAP::Parser::Result::Version</target>
        </trans-unit>
        <trans-unit id="57883e95518fac69c11831c9fff6d78815a22b85" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Version - TAP syntax version token.</source>
          <target state="translated">TAP::Parser::Результат::Версия-токен версии синтаксиса TAP.</target>
        </trans-unit>
        <trans-unit id="0f318e8c966222dedab8b0415294cae97d5f4f64" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::YAML</source>
          <target state="translated">TAP::Parser::Result::YAML</target>
        </trans-unit>
        <trans-unit id="68efbf9d5d727c77c2280206016668c939f6f897" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::YAML - YAML result token.</source>
          <target state="translated">TAP::Парсер::Результат::YAML-YAML маркер результата.</target>
        </trans-unit>
        <trans-unit id="1a3c6d732b12248b1b6d9e14cf320584eb0a7af0" translate="yes" xml:space="preserve">
          <source>TAP::Parser::ResultFactory</source>
          <target state="translated">TAP::Parser::ResultFactory</target>
        </trans-unit>
        <trans-unit id="4f51e316d0426f94634c75bc33e9099d8d304e39" translate="yes" xml:space="preserve">
          <source>TAP::Parser::ResultFactory - Factory for creating TAP::Parser output objects</source>
          <target state="translated">TAP::Парсер::РезультатФабрика-Фабрика для создания TAP::Объекты вывода парсера</target>
        </trans-unit>
        <trans-unit id="50d7a126914ae0138b7bdc512d9ccd5a5d77784d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler</source>
          <target state="translated">TAP::Parser::Scheduler</target>
        </trans-unit>
        <trans-unit id="6da57a5308e690ad2cdb39023741e3d016f8b96b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler - Schedule tests during parallel testing</source>
          <target state="translated">TAP::Парсер::Планировщик-Расписание тестов при параллельном тестировании</target>
        </trans-unit>
        <trans-unit id="81a373608790f502b94224968ea5fc04bfbb7622" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Job</source>
          <target state="translated">TAP::Parser::Scheduler::Job</target>
        </trans-unit>
        <trans-unit id="657d2fb895dc4c666b37510d12e2199629196955" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Job - A single testing job.</source>
          <target state="translated">TAP::Парсер::Планировщик::Работа-одно тестовое задание.</target>
        </trans-unit>
        <trans-unit id="5f18e879edab289da9e626ab0da6617557a360e9" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Spinner</source>
          <target state="translated">TAP::Parser::Scheduler::Spinner</target>
        </trans-unit>
        <trans-unit id="73c0394de64be963748b5ce71edfd4ac21a6b40d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Spinner - A no-op job.</source>
          <target state="translated">Планировщик::Спиннер-безработный.</target>
        </trans-unit>
        <trans-unit id="223a37f35fb2a759c5993cb7f97ef9683ee5bef9" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Source</source>
          <target state="translated">TAP::Parser::Source</target>
        </trans-unit>
        <trans-unit id="ba1432bca02f36d9b7eb2dec89d208a92989961b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Source - a TAP source &amp;amp; meta data about it</source>
          <target state="translated">TAP :: Parser :: Source - источник TAP и метаданные о нем</target>
        </trans-unit>
        <trans-unit id="b88d422ffa232da21769ecf23f36c9215fb7316d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler</source>
          <target state="translated">TAP::Parser::SourceHandler</target>
        </trans-unit>
        <trans-unit id="7a11e510cbf8229cb9deefa589961e1880c0ef0c" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler - Base class for different TAP source handlers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567fb9a0760765f024156fd52b7260852fb83a9f" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Executable</source>
          <target state="translated">TAP::Parser::SourceHandler::Executable</target>
        </trans-unit>
        <trans-unit id="def5a816ec0112a978d703f8596c8df1a84fd5e0" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Executable - Stream output from an executable TAP source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7855e6a236f3f1bba1561cccffbc0253a8b41c1a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::File</source>
          <target state="translated">TAP::Parser::SourceHandler::File</target>
        </trans-unit>
        <trans-unit id="c84a46ff700384567f810cc0dbe5e4d5b91c8613" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::File - Stream TAP from a text file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75757e90ca350dfe386979f74159d3e72435290" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Handle</source>
          <target state="translated">TAP::Parser::SourceHandler::Handle</target>
        </trans-unit>
        <trans-unit id="b6f0bcffb30af38c06936b6bf1545dd5a83277c1" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Handle - Stream TAP from an IO::Handle or a GLOB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4545cce101afaf68b0bd75f8cbbb180c6b160964" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Perl</source>
          <target state="translated">TAP::Parser::SourceHandler::Perl</target>
        </trans-unit>
        <trans-unit id="04e054f8c028c674d2c9287cae69082bbf9ce520" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Perl - Stream TAP from a Perl executable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="849652a7b8f5b288e476708d89c71b634dc488c2" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::RawTAP</source>
          <target state="translated">TAP::Parser::SourceHandler::RawTAP</target>
        </trans-unit>
        <trans-unit id="7fe676e21d00db4b7e1f5adc9ab5a7fc5c10349f" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::RawTAP - Stream output from raw TAP in a scalar/array ref.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75366f8757d0c89dc67745e9e30ae921835fc92" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Reader</source>
          <target state="translated">TAP::Parser::YAMLish::Reader</target>
        </trans-unit>
        <trans-unit id="92a795f40e2bb73376fc045a4635f6fcf7d6a7de" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Reader - Read YAMLish data from iterator</source>
          <target state="translated">TAP::Парсер::YAMLish::Читатель-Чтение данных YAMLish из итератора</target>
        </trans-unit>
        <trans-unit id="08d78eef616ac71669e623449566134b1c6d4b77" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Writer</source>
          <target state="translated">TAP::Parser::YAMLish::Writer</target>
        </trans-unit>
        <trans-unit id="662f33223b14be1ce958a19abee31b207588ba54" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Writer - Write YAMLish data</source>
          <target state="translated">TAP::Парсер::YAMLish::Writer-Write YAMLish data</target>
        </trans-unit>
        <trans-unit id="5b754807c6604c3c6635f1f0f60d367a6cffd283" translate="yes" xml:space="preserve">
          <source>TAPx Developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c4682dfeedc4e9ca5c57ef7dd969ecc22339454" translate="yes" xml:space="preserve">
          <source>TARG</source>
          <target state="translated">TARG</target>
        </trans-unit>
        <trans-unit id="f762108ca727f0bcd961fc7467c248887dfa70dc" translate="yes" xml:space="preserve">
          <source>TARGET</source>
          <target state="translated">TARGET</target>
        </trans-unit>
        <trans-unit id="07ebecac9b2b06cf07f96beb0d4f2199e5361e7a" translate="yes" xml:space="preserve">
          <source>TARGLEN</source>
          <target state="translated">TARGLEN</target>
        </trans-unit>
        <trans-unit id="2bf1079e4526d76e12b857a04bc0e88e77c1a56e" translate="yes" xml:space="preserve">
          <source>TARGOFF</source>
          <target state="translated">TARGOFF</target>
        </trans-unit>
        <trans-unit id="20a7b118ffa37d6b7bbce47ab0257aa206e6a7b5" translate="yes" xml:space="preserve">
          <source>TBC: Remove the stringified coderef; while it provides a 'cookie' for each function rendered, the cookies used should be 1,2,3.. not a random hex-address. It also complicates string comparison of two different trees.</source>
          <target state="translated">TBC:Удалить строковую кодировку;хотя она и предоставляет &quot;куки&quot; для каждой отображаемой функции,используемые куки должны быть 1,2,3...а не случайным шестнадцатиричным адресом.Это также усложняет сравнение строк двух разных деревьев.</target>
        </trans-unit>
        <trans-unit id="75c76515695c04f9554f43d036ad1241bc04ca9e" translate="yes" xml:space="preserve">
          <source>TBC: a hookpoint (and an option to set it) for a user-supplied function to produce a banner appropriate for users needs. It's not ideal, because the rendering-state variables, which are a natural candidate for use in concise.t, are unavailable to the user.</source>
          <target state="translated">TBC:крюк-точка (и возможность ее установки)для предоставляемой пользователем функции для создания баннера,подходящего для нужд пользователя.Это не идеально,потому что переменные состояния рендеринга,которые являются естественным кандидатом для использования в сжатом виде,недоступны пользователю.</target>
        </trans-unit>
        <trans-unit id="f544fb304c83e23652a63e1bb1b28f4fcc7f6ac0" translate="yes" xml:space="preserve">
          <source>TCP</source>
          <target state="translated">TCP</target>
        </trans-unit>
        <trans-unit id="ccb92559aac4354578ea22eca45f6544e0875e36" translate="yes" xml:space="preserve">
          <source>TCP Clients with IO::Socket</source>
          <target state="translated">TCP клиенты с IO::Socket</target>
        </trans-unit>
        <trans-unit id="90251fa6420d40cf40e1d413320c56543c05df3d" translate="yes" xml:space="preserve">
          <source>TCP Servers with IO::Socket</source>
          <target state="translated">TCP-серверы с IO::Socket</target>
        </trans-unit>
        <trans-unit id="5f3be0b4f564336745c1f56bb30fefa5d6b55f59" translate="yes" xml:space="preserve">
          <source>TCP32IP</source>
          <target state="translated">TCP32IP</target>
        </trans-unit>
        <trans-unit id="930107c72c67f45aa5652e4a9e00965774f7a294" translate="yes" xml:space="preserve">
          <source>TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ...</source>
          <target state="translated">TCP_CORK,TCP_KEEPALIVE,TCP_NODELAY,...</target>
        </trans-unit>
        <trans-unit id="f903b5ea6b01e57df921d11ccc31344fae1a17ad" translate="yes" xml:space="preserve">
          <source>TECHNICAL NOTES</source>
          <target state="translated">ТЕХНИЧЕСКИЕ АННОТАЦИИ</target>
        </trans-unit>
        <trans-unit id="b91007f005fd5b0e0252dbeed42578d0d3ba8fe5" translate="yes" xml:space="preserve">
          <source>TELL this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a2096b23211f0508d184fe8003d9fb843bbdcd" translate="yes" xml:space="preserve">
          <source>TEMPLATE available since 0.23</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9335e94443b7e72d405288dde6a7e324e2d4e0cd" translate="yes" xml:space="preserve">
          <source>TEMPLATE available since 0.23.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3db3af9a0e0243f28ed20fcc3b1d5d1faaafbb6" translate="yes" xml:space="preserve">
          <source>TERM</source>
          <target state="translated">TERM</target>
        </trans-unit>
        <trans-unit id="cfc996e2b0441d5f42e4bd8a622b4dd1b2f920a4" translate="yes" xml:space="preserve">
          <source>TERMCAP</source>
          <target state="translated">TERMCAP</target>
        </trans-unit>
        <trans-unit id="4baf6f46b36f22af80f6af8178fa1faa75a5a37d" translate="yes" xml:space="preserve">
          <source>TERMINOLOGY</source>
          <target state="translated">TERMINOLOGY</target>
        </trans-unit>
        <trans-unit id="201ab4b1fe261c4f44a8bfbbdafd62a7606acc46" translate="yes" xml:space="preserve">
          <source>TERMPATH</source>
          <target state="translated">TERMPATH</target>
        </trans-unit>
        <trans-unit id="feb84698a707a37aae3ea67dd9630a278a6ca8f5" translate="yes" xml:space="preserve">
          <source>TERTIARY METHODS</source>
          <target state="translated">ТРЕТИЧНЫЕ МЕТОДЫ</target>
        </trans-unit>
        <trans-unit id="984816fd329622876e14907634264e6f332e9fb3" translate="yes" xml:space="preserve">
          <source>TEST</source>
          <target state="translated">TEST</target>
        </trans-unit>
        <trans-unit id="16731ae62f4aed11f4e128609c52499c94df9c78" translate="yes" xml:space="preserve">
          <source>TEST ON CYGWIN</source>
          <target state="translated">ИСПЫТАНИЕ НА ЦИГВИНЕ</target>
        </trans-unit>
        <trans-unit id="6fc222312636989b4f87037a3c04ed0cc832a677" translate="yes" xml:space="preserve">
          <source>TEST RESULTS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01006d91764e5a9b5b7e2fa6b5505255129d446" translate="yes" xml:space="preserve">
          <source>TEST STATUS</source>
          <target state="translated">КОНТРОЛЬНАЯ СТАТИСТИКА</target>
        </trans-unit>
        <trans-unit id="1aafa503ed48d02972e5772184ca513598703dbe" translate="yes" xml:space="preserve">
          <source>TEST TYPES</source>
          <target state="translated">ИСПЫТАТЕЛЬНЫЕ ТИПЫ</target>
        </trans-unit>
        <trans-unit id="0aec4d9bc52ab96e424cd057a59cc45eff314107" translate="yes" xml:space="preserve">
          <source>TEST2</source>
          <target state="translated">TEST2</target>
        </trans-unit>
        <trans-unit id="cb73eb0155af5a3da3bb4a63646b40201ab650c4" translate="yes" xml:space="preserve">
          <source>TESTING</source>
          <target state="translated">TESTING</target>
        </trans-unit>
        <trans-unit id="942de0a9a9abe9fb219e796c9c0f10b53d3c6b67" translate="yes" xml:space="preserve">
          <source>TESTING FRAMEWORKS</source>
          <target state="translated">ИСПЫТАТЕЛЬНЫЕ СИСТЕМЫ</target>
        </trans-unit>
        <trans-unit id="0653969b83ac74a5d20cdc9c4494d4702f2fe66a" translate="yes" xml:space="preserve">
          <source>TESTING YOUR TOOLS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bee02d2a52a6eefa52f8e6c1723494db5b275c5" translate="yes" xml:space="preserve">
          <source>TEST_REQUIRES</source>
          <target state="translated">TEST_REQUIRES</target>
        </trans-unit>
        <trans-unit id="04209ee7219637d26ee9cd4fa722493ca838116d" translate="yes" xml:space="preserve">
          <source>THANK YOU</source>
          <target state="translated">СПАСИБО</target>
        </trans-unit>
        <trans-unit id="ffa4516bffdd79480b0ffbea2e99e02675eb3752" translate="yes" xml:space="preserve">
          <source>THANKS</source>
          <target state="translated">THANKS</target>
        </trans-unit>
        <trans-unit id="506d81bed6d3b4fa9b202f8f107ea34d18c6fadf" translate="yes" xml:space="preserve">
          <source>THE .netrc FILE</source>
          <target state="translated">файл .netrc</target>
        </trans-unit>
        <trans-unit id="2462f7724da7788ea62fc114cce4eab4e3339b38" translate="yes" xml:space="preserve">
          <source>THE API INTERFACE</source>
          <target state="translated">API-ИНТЕРФЕЙС</target>
        </trans-unit>
        <trans-unit id="eb466ef85e05d613480bb98bc1553047a2722184" translate="yes" xml:space="preserve">
          <source>THE CALL_ FUNCTIONS</source>
          <target state="translated">ФУНКЦИИ CALL_</target>
        </trans-unit>
        <trans-unit id="db00699a00a64bd8eb4f11307ac364af2186b3b7" translate="yes" xml:space="preserve">
          <source>THE Math::BigInt API</source>
          <target state="translated">Математика::Большой API</target>
        </trans-unit>
        <trans-unit id="5bf87badf6e989985ca5cde31b10d699fd946122" translate="yes" xml:space="preserve">
          <source>THE PERL ENCODING API</source>
          <target state="translated">КОДИРОВКА API НА PERL</target>
        </trans-unit>
        <trans-unit id="2036c7632dcc8e78c342e25b215c2cd28f8d5b22" translate="yes" xml:space="preserve">
          <source>THE PERL MODULE LIBRARY</source>
          <target state="translated">БИБЛИОТЕКА МОДУЛЯ PERL</target>
        </trans-unit>
        <trans-unit id="a1c725e21d784bf655d9ab26a4cdce89326e975c" translate="yes" xml:space="preserve">
          <source>THE QUESTIONS</source>
          <target state="translated">ВОПРОСЫ.</target>
        </trans-unit>
        <trans-unit id="fb64ef2c36220a9cb84ef2e67b3a1343a0d67d4d" translate="yes" xml:space="preserve">
          <source>THE RULES OF SYS::SYSLOG</source>
          <target state="translated">ПРАВИЛА SYS::SYSLOG</target>
        </trans-unit>
        <trans-unit id="79e66f9682153b1fcc7f947e99f79c4de4e44b30" translate="yes" xml:space="preserve">
          <source>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</source>
          <target state="translated">ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ &quot;КАК ЕСТЬ&quot;,БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ,ЯВНЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ,ВКЛЮЧАЯ,НО НЕ ОГРАНИЧИВАЯСЬ ГАРАНТИЯМИ ТОВАРНОЙ ПРИГОДНОСТИ,ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ И НЕНАРУШЕНИЯ ПРАВ СОБСТВЕННОСТИ.НИ ПРИ КАКИХ ОБСТОЯТЕЛЬСТВАХ АВТОРЫ ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ ЗА ЛЮБЫЕ ПРЕТЕНЗИИ,УЩЕРБ ИЛИ ДРУГУЮ ОТВЕТСТВЕННОСТЬ,БУДЬ ТО В РАМКАХ КОНТРАКТА,ДЕЛИКТА ИЛИ ИНОГО,ВЫТЕКАЮЩИЕ ИЗ,ИЗ ИЛИ В СВЯЗИ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ ИЛИ ИСПОЛЬЗОВАНИЕМ ИЛИ ИНЫМИ СДЕЛКАМИ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ.</target>
        </trans-unit>
        <trans-unit id="6c98c15d2eefa5232f6a2b60310fc78bdae1017e" translate="yes" xml:space="preserve">
          <source>THE dataconn CLASS</source>
          <target state="translated">засекречивание данных</target>
        </trans-unit>
        <trans-unit id="472f09c67477280b91b7ae79efeb4fde13fbb523" translate="yes" xml:space="preserve">
          <source>THING</source>
          <target state="translated">THING</target>
        </trans-unit>
        <trans-unit id="07b9eb014428dfb38549744f146d6c3dde1b5ea1" translate="yes" xml:space="preserve">
          <source>THINGS THAT BREAK</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2360380b4c35fa48f7e3a9f411a80f126b56989e" translate="yes" xml:space="preserve">
          <source>THINGS TO LOOK OUT FOR</source>
          <target state="translated">НА ЧТО НУЖНО ОБРАТИТЬ ВНИМАНИЕ</target>
        </trans-unit>
        <trans-unit id="89f30bff95de115f49eea92211c4131dff22eee2" translate="yes" xml:space="preserve">
          <source>THIRD PARTY META-DATA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d962f5bb90637331652bdd7361911bfa4f11ec" translate="yes" xml:space="preserve">
          <source>THIS</source>
          <target state="translated">THIS</target>
        </trans-unit>
        <trans-unit id="1e38c114990518154ef0cedaa35a5bd37c0b3725" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584497c8a870243751bafe0429bbe1f5826e0915" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Instead, &lt;b&gt;Almost all code should use &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; or &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;&lt;/b&gt;.</source>
          <target state="translated">ДАННАЯ ФУНКЦИЯ ДОЛЖНА ИСПОЛЬЗОВАТЬСЯ ТОЛЬКО В ОЧЕНЬ СПЕЦИАЛИЗИРОВАННЫХ ОБСТОЯТЕЛЬСТВАХ. Вместо этого &lt;b&gt;почти весь код должен использовать &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; или &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2fe768b556edf71a7a7285e6d6bd4d94874718c9" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Instead, &lt;b&gt;Almost all code should use &lt;a href=&quot;perlapi#uvchr_to_utf8&quot;&gt;&quot;uvchr_to_utf8&quot; in perlapi&lt;/a&gt; or &lt;a href=&quot;perlapi#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot; in perlapi&lt;/a&gt;&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e7f9968d3c36f671d0b0a315ac2b0ae68ef3cb" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Most code should use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;&quot;utf8_to_uvchr_buf&quot;&lt;/a&gt;() rather than call this directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="331b8f63effc7e7d25ea524ca1aa92004125d86f" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Most code should use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;() rather than call this directly.</source>
          <target state="translated">ЭТА ФУНКЦИЯ ДОЛЖНА ИСПОЛЬЗОВАТЬСЯ ТОЛЬКО В ОЧЕНЬ СПЕЦИАЛИЗИРОВАННЫХ ОБСТОЯТЕЛЬСТВАХ. Большая часть кода должна использовать &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; (), а не вызывать ее напрямую.</target>
        </trans-unit>
        <trans-unit id="e500f259933ce04e81376b9418761e8b6b63ca4b" translate="yes" xml:space="preserve">
          <source>THIS IS A BUNDLED COPY OF HASHBASE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87fa10ba30f21359cbeb956cb3e89adeb5a0009" translate="yes" xml:space="preserve">
          <source>THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897ebd5219f0c5caa208699bd4713ae3b784c6e0" translate="yes" xml:space="preserve">
          <source>THREAD CONTEXT</source>
          <target state="translated">ТРЁХСТОРОННИЙ КОНТРАКТ</target>
        </trans-unit>
        <trans-unit id="54e59b7bc3a2e96489d360a7b538367313e355dc" translate="yes" xml:space="preserve">
          <source>THREAD SIGNALLING</source>
          <target state="translated">РЕЗЬБОВАЯ СИГНАЛИЗАЦИЯ</target>
        </trans-unit>
        <trans-unit id="60b08b8acc7a625b8f0d9d41c7e2c28fbb134428" translate="yes" xml:space="preserve">
          <source>THREAD STACK SIZE</source>
          <target state="translated">РАЗМЕР ШТАБЕЛЯ РЕЗЬБЫ</target>
        </trans-unit>
        <trans-unit id="577fa2796ff34704e76d7424a53614775f345523" translate="yes" xml:space="preserve">
          <source>THREAD STATE</source>
          <target state="translated">ТРИДИЧЕСКОЕ ГОСУДАРСТВО</target>
        </trans-unit>
        <trans-unit id="bf2767662599be6d02741631f5d4e162d0241086" translate="yes" xml:space="preserve">
          <source>THREAD SUPPORT</source>
          <target state="translated">ТРЁХСТУПЕНЧАТАЯ ПОДДЕРЖКА</target>
        </trans-unit>
        <trans-unit id="f8c7150e13e8ea5e3603e546c189035146b726df" translate="yes" xml:space="preserve">
          <source>THREADS</source>
          <target state="translated">THREADS</target>
        </trans-unit>
        <trans-unit id="7c9dadbfc59d969a1799e6be175b4787667674b0" translate="yes" xml:space="preserve">
          <source>TIEARRAY classname, LIST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f266b9c4765272a11c0ed3c20127bf1d201638dd" translate="yes" xml:space="preserve">
          <source>TIEHANDLE by Sven Verdoolaege &amp;lt;</source>
          <target state="translated">TIEHANDLE от Свена Вердоолэге &amp;lt;</target>
        </trans-unit>
        <trans-unit id="4347e3f18728473395d10013e97d93a913b225ef" translate="yes" xml:space="preserve">
          <source>TIEHANDLE classname, LIST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d83af8a8f8d7e1fd18b5a0b52b5df410f197b9" translate="yes" xml:space="preserve">
          <source>TIEHASH</source>
          <target state="translated">TIEHASH</target>
        </trans-unit>
        <trans-unit id="114157a2500e26e12e9e4f96b1661f6f0fed2f32" translate="yes" xml:space="preserve">
          <source>TIEHASH classname, LIST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5885b322f223d2e8e46e67617d8c4179f4469494" translate="yes" xml:space="preserve">
          <source>TIESCALAR classname, LIST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="6c2529a2a2e078590190100f8e1c4972e8846bc5" translate="yes" xml:space="preserve">
          <source>TIME is</source>
          <target state="translated">ВРЕМЯ</target>
        </trans-unit>
        <trans-unit id="cb08f6ca3aa0ce4fb2da7065815536bc05346689" translate="yes" xml:space="preserve">
          <source>TITLE specifies an optional window title. The default is &quot;Perl&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6409a515d9fc80e579966498117e7281bd8b98a0" translate="yes" xml:space="preserve">
          <source>TMP or TEMP</source>
          <target state="translated">TMP или TEMP</target>
        </trans-unit>
        <trans-unit id="502251190f55377c3e1679cff641b5206ebe43aa" translate="yes" xml:space="preserve">
          <source>TMPDIR flag available since 0.19.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9767c08e2051436d891f79c96c59ac4496bdaece" translate="yes" xml:space="preserve">
          <source>TMTOWTDI</source>
          <target state="translated">TMTOWTDI</target>
        </trans-unit>
        <trans-unit id="47bd70df0e55aba216736b1db7710c6478ab9cbf" translate="yes" xml:space="preserve">
          <source>TO DO</source>
          <target state="translated">ДО</target>
        </trans-unit>
        <trans-unit id="f8953b7e0e4beba3861ba1d10ca937f8f20fdfee" translate="yes" xml:space="preserve">
          <source>TO DO (maybe)</source>
          <target state="translated">Сделать это (возможно)</target>
        </trans-unit>
        <trans-unit id="b698c11e84460ed5999bfeb5cbf25b865c238f3c" translate="yes" xml:space="preserve">
          <source>TODO</source>
          <target state="translated">TODO</target>
        </trans-unit>
        <trans-unit id="87460dd609011b471c790d7cefae22bfe0f0c49f" translate="yes" xml:space="preserve">
          <source>TODO TESTS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14081c923a6df4129e72afd1550fb67ed4989fb1" translate="yes" xml:space="preserve">
          <source>TODO all (most?) accessorized methods</source>
          <target state="translated">Все (большинство?)аксессуарные методы.</target>
        </trans-unit>
        <trans-unit id="a5b8170989f597b07b48f468f60223ae453a6cc5" translate="yes" xml:space="preserve">
          <source>TODO intro... mention that events are supplied for implicits, like for missing &amp;gt;'s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49b8285ed97f054a4aab1877c59b31a331177c3b" translate="yes" xml:space="preserve">
          <source>TODO plans</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac7481b99347a289b8d37ae17bf40d2f44f1514" translate="yes" xml:space="preserve">
          <source>TODO tests are designed for maintaining an &lt;b&gt;executable TODO list&lt;/b&gt;. These tests are</source>
          <target state="translated">TODO-тесты предназначены для поддержки &lt;b&gt;исполняемого списка TODO&lt;/b&gt; . Эти тесты</target>
        </trans-unit>
        <trans-unit id="fd32d0b7a9d317be835f0befd340eb49cf589cff" translate="yes" xml:space="preserve">
          <source>TODO, see &lt;a href=&quot;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&quot;&gt;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&lt;/a&gt;</source>
          <target state="translated">TODO, см. &lt;a href=&quot;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&quot;&gt;Http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74f7cfa4b2cac04f938a7033d590acfea7e8506e" translate="yes" xml:space="preserve">
          <source>TODO, see &lt;a href=&quot;https://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&quot;&gt;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd529f1aacfef198f05ec640f141ac5fe8d0a0d0" translate="yes" xml:space="preserve">
          <source>TODO...</source>
          <target state="translated">TODO...</target>
        </trans-unit>
        <trans-unit id="643a0382045e00a908788587a0d4b6d602741dc9" translate="yes" xml:space="preserve">
          <source>TODO: An example or two of =extend, then point to Pod::Simple::Subclassing</source>
          <target state="translated">TODO:Пример или два из =extend,затем укажите на Pod::Simple::Subclassing</target>
        </trans-unit>
        <trans-unit id="b95da2f919c7ccb270ebcfb13598d7d2d8b6a01a" translate="yes" xml:space="preserve">
          <source>TODO: Document this</source>
          <target state="translated">ТДО:Задокументируйте это</target>
        </trans-unit>
        <trans-unit id="26dbb18df63ed25641cd65981a2bd8abf41c6420" translate="yes" xml:space="preserve">
          <source>TODO: Document those cases.</source>
          <target state="translated">Задокументируйте эти случаи.</target>
        </trans-unit>
        <trans-unit id="503edd260136cc51f7d583a68da986091421e06f" translate="yes" xml:space="preserve">
          <source>TODO: a corpus of sample Pod input and HTML output? Or common idioms?</source>
          <target state="translated">TODO:корпус примеров Pod-ввода и HTML-вывода? Или общие идиомы?</target>
        </trans-unit>
        <trans-unit id="2804185099bb0257ffff9bf0a6b003ba897a8c8c" translate="yes" xml:space="preserve">
          <source>TOGGLES</source>
          <target state="translated">TOGGLES</target>
        </trans-unit>
        <trans-unit id="fbc5612fa4f39d021c8212de6294e10fc0eb4c60" translate="yes" xml:space="preserve">
          <source>TOPMARK</source>
          <target state="translated">TOPMARK</target>
        </trans-unit>
        <trans-unit id="1b219778d2536bb7cb3443c1e48b1cdc6ec5bbcd" translate="yes" xml:space="preserve">
          <source>TOP_GV</source>
          <target state="translated">TOP_GV</target>
        </trans-unit>
        <trans-unit id="028dc78f2472e443fde9354a9093737ec708fdc1" translate="yes" xml:space="preserve">
          <source>TOP_NAME</source>
          <target state="translated">TOP_NAME</target>
        </trans-unit>
        <trans-unit id="767b9b1886f65db5d2c2efe4d311ec16282ddf3e" translate="yes" xml:space="preserve">
          <source>TOTAL RESULTS</source>
          <target state="translated">ИТОГО РЕЗУЛЬТАТЫ</target>
        </trans-unit>
        <trans-unit id="e69a3c58feb4943f28d4f3916d734de76e706681" translate="yes" xml:space="preserve">
          <source>TR16 implies a method to extend UTF-EBCDIC to encode points up through &lt;code&gt;2 ** 31 - 1&lt;/code&gt;. Perl uses this method for code points up through &lt;code&gt;2 ** 30 - 1&lt;/code&gt;, but uses an incompatible method for larger ones, to enable it to handle much larger code points than otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6168d5c87ca259972f2a01ffcfd10f094db6e548" translate="yes" xml:space="preserve">
          <source>TRANSFORMATION FORMATS</source>
          <target state="translated">ФОРМАТЫ ПРЕОБРАЗОВАНИЯ</target>
        </trans-unit>
        <trans-unit id="08e80e877114a02316e2a85c727dc2ec2e8d050b" translate="yes" xml:space="preserve">
          <source>TRANSLATIONS</source>
          <target state="translated">TRANSLATIONS</target>
        </trans-unit>
        <trans-unit id="881efc13a4ce5c9b7f10acdee48bdf35dab16bcd" translate="yes" xml:space="preserve">
          <source>TREE-BASED PARSING</source>
          <target state="translated">ДРЕВОВИДНЫЙ АНАЛИЗ</target>
        </trans-unit>
        <trans-unit id="8c6a137afc05b19ebfa9464a819fe4c729451ba3" translate="yes" xml:space="preserve">
          <source>TRIEC</source>
          <target state="translated">TRIEC</target>
        </trans-unit>
        <trans-unit id="4c899cd91fe33df0b8e34be446bc5d1535c00392" translate="yes" xml:space="preserve">
          <source>TRIEE</source>
          <target state="translated">TRIEE</target>
        </trans-unit>
        <trans-unit id="4e29af22b66831d0809f9ed161ff9fdacd21c3da" translate="yes" xml:space="preserve">
          <source>TRIEM</source>
          <target state="translated">TRIEM</target>
        </trans-unit>
        <trans-unit id="55c5fdc09a5315c1ab2a4b0b8470a49a53936b60" translate="yes" xml:space="preserve">
          <source>TRIGONOMETRIC FUNCTIONS</source>
          <target state="translated">ТРИГОНОМЕТРИЧЕСКИЕ ФУНКЦИИ</target>
        </trans-unit>
        <trans-unit id="fddf1df7c30cac7908d10246256efd264ce7aa32" translate="yes" xml:space="preserve">
          <source>TRUE</source>
          <target state="translated">TRUE</target>
        </trans-unit>
        <trans-unit id="d814d3e7d55ad64b9a68fdab60bd5741a6c86453" translate="yes" xml:space="preserve">
          <source>TUTORIAL</source>
          <target state="translated">TUTORIAL</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="fe62cb78f4ed9f61dd4406f0f3143d6f618cef25" translate="yes" xml:space="preserve">
          <source>TYPEMAPS</source>
          <target state="translated">TYPEMAPS</target>
        </trans-unit>
        <trans-unit id="40ea9041285003e004a8f6fe2dd14ebb07961af2" translate="yes" xml:space="preserve">
          <source>TYPES</source>
          <target state="translated">TYPES</target>
        </trans-unit>
        <trans-unit id="fcac4a88dd04636da037a74fcf1d813d6bb5c767" translate="yes" xml:space="preserve">
          <source>TYPES OF VERSION OBJECTS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb5c671d380f7e563f1ea67cb13227761e097ff" translate="yes" xml:space="preserve">
          <source>T_ARRAY</source>
          <target state="translated">T_ARRAY</target>
        </trans-unit>
        <trans-unit id="5a44f0733ece8e94e30b4779d69997f4ee33c56f" translate="yes" xml:space="preserve">
          <source>T_AVREF</source>
          <target state="translated">T_AVREF</target>
        </trans-unit>
        <trans-unit id="20c8d07e48603a91f5ad0258a9d7260fecf703f4" translate="yes" xml:space="preserve">
          <source>T_AVREF_REFCOUNT_FIXED</source>
          <target state="translated">T_AVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="441dcc9bf7c8874857cd2f07add2544a7aa18348" translate="yes" xml:space="preserve">
          <source>T_BOOL</source>
          <target state="translated">T_BOOL</target>
        </trans-unit>
        <trans-unit id="c96681120818e54685540689763746057da6c711" translate="yes" xml:space="preserve">
          <source>T_CALLBACK</source>
          <target state="translated">T_CALLBACK</target>
        </trans-unit>
        <trans-unit id="1d4f3aa1dcbc52712656445982d93cb57df8eefd" translate="yes" xml:space="preserve">
          <source>T_CHAR</source>
          <target state="translated">T_CHAR</target>
        </trans-unit>
        <trans-unit id="619c206b9e7e1179f8c572c2e0bbd5418dcbcd9c" translate="yes" xml:space="preserve">
          <source>T_CVREF</source>
          <target state="translated">T_CVREF</target>
        </trans-unit>
        <trans-unit id="6bf16578ac0037942fb294227b378783d6417250" translate="yes" xml:space="preserve">
          <source>T_CVREF_REFCOUNT_FIXED</source>
          <target state="translated">T_CVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="ebd5f4b2b2cdf44ca91f90320178cc872c0e09c7" translate="yes" xml:space="preserve">
          <source>T_DATAUNIT</source>
          <target state="translated">T_DATAUNIT</target>
        </trans-unit>
        <trans-unit id="fe14988da15a2d4fcafb4d4c3fdba996b1d3919b" translate="yes" xml:space="preserve">
          <source>T_DOUBLE</source>
          <target state="translated">T_DOUBLE</target>
        </trans-unit>
        <trans-unit id="fc54a411f035f09e5b26e9d5967f486a6331f42c" translate="yes" xml:space="preserve">
          <source>T_ENUM</source>
          <target state="translated">T_ENUM</target>
        </trans-unit>
        <trans-unit id="d9144dfb59c0a6e098f071eb27226d345bb3b9a3" translate="yes" xml:space="preserve">
          <source>T_FLOAT</source>
          <target state="translated">T_FLOAT</target>
        </trans-unit>
        <trans-unit id="a488a491ef416eedb274173547cc94600a1c1be9" translate="yes" xml:space="preserve">
          <source>T_HVREF</source>
          <target state="translated">T_HVREF</target>
        </trans-unit>
        <trans-unit id="e9eb1cfbb5a736f4b47a7fce8d35e124bff4c588" translate="yes" xml:space="preserve">
          <source>T_HVREF_REFCOUNT_FIXED</source>
          <target state="translated">T_HVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="4baf8db3b4ede993cae1ba43114ca8ba3f059451" translate="yes" xml:space="preserve">
          <source>T_IN</source>
          <target state="translated">T_IN</target>
        </trans-unit>
        <trans-unit id="0d34ad725c5d489d88c10068319bbe41b1372c3f" translate="yes" xml:space="preserve">
          <source>T_INOUT</source>
          <target state="translated">T_INOUT</target>
        </trans-unit>
        <trans-unit id="c9ac30f3bfe7d2f1be494ab16cbb62e6b0281825" translate="yes" xml:space="preserve">
          <source>T_INT</source>
          <target state="translated">T_INT</target>
        </trans-unit>
        <trans-unit id="71be7a946c6f9c8f878e909304790177b9d9322d" translate="yes" xml:space="preserve">
          <source>T_IV</source>
          <target state="translated">T_IV</target>
        </trans-unit>
        <trans-unit id="eaf82e3c7e0aec5ed4944f8734b7934b5d7a9464" translate="yes" xml:space="preserve">
          <source>T_LONG</source>
          <target state="translated">T_LONG</target>
        </trans-unit>
        <trans-unit id="5b8224b3c1fe92d5bae70adacc8eac05fd9a5fda" translate="yes" xml:space="preserve">
          <source>T_NV</source>
          <target state="translated">T_NV</target>
        </trans-unit>
        <trans-unit id="a6b2c10bebc0632668de5a633339c42212334462" translate="yes" xml:space="preserve">
          <source>T_OPAQUE</source>
          <target state="translated">T_OPAQUE</target>
        </trans-unit>
        <trans-unit id="3409e584f0822b2e9f6e17cf539649bef61e2695" translate="yes" xml:space="preserve">
          <source>T_OPAQUE supports input and output of simple types. T_OPAQUEPTR can be used to pass these bytes back into C if a pointer is acceptable.</source>
          <target state="translated">T_OPAQUE поддерживает ввод и вывод простых типов.T_OPAQUEPTR может использоваться для передачи этих байт обратно в C,если указатель является допустимым.</target>
        </trans-unit>
        <trans-unit id="4d81bbcffee2d4d53636e0cfc38c1802b032ce1e" translate="yes" xml:space="preserve">
          <source>T_OPAQUEPTR</source>
          <target state="translated">T_OPAQUEPTR</target>
        </trans-unit>
        <trans-unit id="94ed49f0fcb197292e8b44f17a54e91c96dfd034" translate="yes" xml:space="preserve">
          <source>T_OUT</source>
          <target state="translated">T_OUT</target>
        </trans-unit>
        <trans-unit id="2a34e55dba9603dc2ed22d9cbacb17ec8fa3b7aa" translate="yes" xml:space="preserve">
          <source>T_PACKED</source>
          <target state="translated">T_PACKED</target>
        </trans-unit>
        <trans-unit id="57d9968b716d10e58d7663155b60bcfe636fd9da" translate="yes" xml:space="preserve">
          <source>T_PACKEDARRAY</source>
          <target state="translated">T_PACKEDARRAY</target>
        </trans-unit>
        <trans-unit id="2acdc87aba62301b1c46833bbb0d8a2ab24b5d4c" translate="yes" xml:space="preserve">
          <source>T_PACKEDARRAY is similar to T_PACKED. In fact, the &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) typemap is identical, but the &lt;code&gt;OUTPUT&lt;/code&gt; typemap passes an additional argument to the &lt;code&gt;XS_pack_$ntype&lt;/code&gt; function. This third parameter indicates the number of elements in the output so that the function can handle C arrays sanely. The variable needs to be declared by the user and must have the name &lt;code&gt;count_$ntype&lt;/code&gt; where &lt;code&gt;$ntype&lt;/code&gt; is the normalized C type name as explained above. The signature of the function would be for the example above and &lt;code&gt;foo_t **&lt;/code&gt; :</source>
          <target state="translated">T_PACKEDARRAY похож на T_PACKED. Фактически, карта типов &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) идентична, но карта типов &lt;code&gt;OUTPUT&lt;/code&gt; передает дополнительный аргумент функции &lt;code&gt;XS_pack_$ntype&lt;/code&gt; . Этот третий параметр указывает количество элементов в выводе, чтобы функция могла нормально обрабатывать массивы C. Переменная должна быть объявлена ​​пользователем и иметь имя &lt;code&gt;count_$ntype&lt;/code&gt; где &lt;code&gt;$ntype&lt;/code&gt; - это нормализованное имя типа C, как описано выше. Сигнатура функции будет для примера выше и &lt;code&gt;foo_t **&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1c906d78fc823a0e9f29368dd513ce8a5418cee5" translate="yes" xml:space="preserve">
          <source>T_PACKEDARRAY is similar to T_PACKED. In fact, the &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) typemap is identical, but the &lt;code&gt;OUTPUT&lt;/code&gt; typemap passes an additional argument to the &lt;code&gt;XS_pack_$ntype&lt;/code&gt; function. This third parameter indicates the number of elements in the output so that the function can handle C arrays sanely. The variable needs to be declared by the user and must have the name &lt;code&gt;count_$ntype&lt;/code&gt; where &lt;code&gt;$ntype&lt;/code&gt; is the normalized C type name as explained above. The signature of the function would be for the example above and &lt;code&gt;foo_t **&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e820d7c1bd9a291e980383d064a4e16d0aba0000" translate="yes" xml:space="preserve">
          <source>T_PTR</source>
          <target state="translated">T_PTR</target>
        </trans-unit>
        <trans-unit id="af1f6fafe92e003dd267b2be4f4b4ef95598f8ab" translate="yes" xml:space="preserve">
          <source>T_PTRDESC</source>
          <target state="translated">T_PTRDESC</target>
        </trans-unit>
        <trans-unit id="1dea827458dd7afc9afab55ca4ec0182c83a4fc4" translate="yes" xml:space="preserve">
          <source>T_PTROBJ</source>
          <target state="translated">T_PTROBJ</target>
        </trans-unit>
        <trans-unit id="1ee34e1644f9ab8be830a408f52ae4dc2849ef55" translate="yes" xml:space="preserve">
          <source>T_PTRREF</source>
          <target state="translated">T_PTRREF</target>
        </trans-unit>
        <trans-unit id="c8c1dc76ec8744f6cb9d9c795f9bfbc5484c1e4d" translate="yes" xml:space="preserve">
          <source>T_PV</source>
          <target state="translated">T_PV</target>
        </trans-unit>
        <trans-unit id="3a5d267dcac84a0b73c5ab78fe0237e26042a945" translate="yes" xml:space="preserve">
          <source>T_REFOBJ</source>
          <target state="translated">T_REFOBJ</target>
        </trans-unit>
        <trans-unit id="35b0d1f3ee1694c51f5d1834c393cb455273def0" translate="yes" xml:space="preserve">
          <source>T_REFREF</source>
          <target state="translated">T_REFREF</target>
        </trans-unit>
        <trans-unit id="784caeb6be6fa5307fa5f6a8479f73d2c2a7691b" translate="yes" xml:space="preserve">
          <source>T_REF_IV_PTR</source>
          <target state="translated">T_REF_IV_PTR</target>
        </trans-unit>
        <trans-unit id="b3253f9127be3bdfed118ec52937984abc7c698c" translate="yes" xml:space="preserve">
          <source>T_REF_IV_REF</source>
          <target state="translated">T_REF_IV_REF</target>
        </trans-unit>
        <trans-unit id="586e2f7a6caf54d31aba57fd6ffdf405333ef314" translate="yes" xml:space="preserve">
          <source>T_SHORT</source>
          <target state="translated">T_SHORT</target>
        </trans-unit>
        <trans-unit id="5e2b55747cebf0deadf14e37c20ac8ae0c863ea6" translate="yes" xml:space="preserve">
          <source>T_STDIO</source>
          <target state="translated">T_STDIO</target>
        </trans-unit>
        <trans-unit id="998ce6a132418997f012a8d95a08e955ec444167" translate="yes" xml:space="preserve">
          <source>T_SV</source>
          <target state="translated">T_SV</target>
        </trans-unit>
        <trans-unit id="f74fedb4d19c9aae5df1a9a2556f420561de423a" translate="yes" xml:space="preserve">
          <source>T_SVREF</source>
          <target state="translated">T_SVREF</target>
        </trans-unit>
        <trans-unit id="b31c4d98a369de70efd9e1e28b9897a696583da4" translate="yes" xml:space="preserve">
          <source>T_SVREF_FIXED</source>
          <target state="translated">T_SVREF_FIXED</target>
        </trans-unit>
        <trans-unit id="4512816ed0e7eedba9cb2a4f99052651f37fbd5b" translate="yes" xml:space="preserve">
          <source>T_SYSRET</source>
          <target state="translated">T_SYSRET</target>
        </trans-unit>
        <trans-unit id="fe86ffcf28dab8688bad0d5d6a6ff6be7af3bf8e" translate="yes" xml:space="preserve">
          <source>T_UV</source>
          <target state="translated">T_UV</target>
        </trans-unit>
        <trans-unit id="d8679fa31c93e6fb7cc082350054dc4f5ca62292" translate="yes" xml:space="preserve">
          <source>T_U_CHAR</source>
          <target state="translated">T_U_CHAR</target>
        </trans-unit>
        <trans-unit id="464c580d57f537b018efa810de5fcaf9cd86a995" translate="yes" xml:space="preserve">
          <source>T_U_INT</source>
          <target state="translated">T_U_INT</target>
        </trans-unit>
        <trans-unit id="1df30c0b01ecbd04a2bc7cb066c197a1ef8a203b" translate="yes" xml:space="preserve">
          <source>T_U_LONG</source>
          <target state="translated">T_U_LONG</target>
        </trans-unit>
        <trans-unit id="f31b217f3c82ab68ac7452146830667f22ddb6a9" translate="yes" xml:space="preserve">
          <source>T_U_LONG is used for type &lt;code&gt;U32&lt;/code&gt; in the standard typemap.</source>
          <target state="translated">T_U_LONG используется для типа &lt;code&gt;U32&lt;/code&gt; в стандартной карте типов.</target>
        </trans-unit>
        <trans-unit id="11359764d9baa3629eadc5745b2516619c5dfc84" translate="yes" xml:space="preserve">
          <source>T_U_SHORT</source>
          <target state="translated">T_U_SHORT</target>
        </trans-unit>
        <trans-unit id="067c0c90742a514deacd491758ccd4ba0e1d9275" translate="yes" xml:space="preserve">
          <source>T_U_SHORT is used for type &lt;code&gt;U16&lt;/code&gt; in the standard typemap.</source>
          <target state="translated">T_U_SHORT используется для типа &lt;code&gt;U16&lt;/code&gt; в стандартной карте типов.</target>
        </trans-unit>
        <trans-unit id="267d7ded4fb1f4fe830b757c69adcb120de3c36c" translate="yes" xml:space="preserve">
          <source>Table in hex, sorted in 1047 order</source>
          <target state="translated">Таблица в шестнадцатеричной форме,отсортированная в порядке 1047.</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">Содержание</target>
        </trans-unit>
        <trans-unit id="f6f2ebfa1ea92516cffdbcabbc226ad6201fc14f" translate="yes" xml:space="preserve">
          <source>Tag Handling Utility Functions</source>
          <target state="translated">Функции обработки меток утилита</target>
        </trans-unit>
        <trans-unit id="c4acb5d65a0f18ccc12ec4e74dc4599e0548b6c1" translate="yes" xml:space="preserve">
          <source>Tag that should prefix/identify the main text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6299767c14d608575e773d7c250b1dd1bef09f" translate="yes" xml:space="preserve">
          <source>Tags and names for human languages</source>
          <target state="translated">Теги и имена для человеческих языков</target>
        </trans-unit>
        <trans-unit id="0caddaacf6ffdd3b4a1f2e6c28c9c60f84fe10e3" translate="yes" xml:space="preserve">
          <source>Tags for the Identification of Languages</source>
          <target state="translated">Метки для идентификации языков</target>
        </trans-unit>
        <trans-unit id="3837bf859c22ab45640f5a47597c86d61ec1aac5" translate="yes" xml:space="preserve">
          <source>Tailoring is not maximum</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd10fdbdba33897c84afb3ba431dd5441966417" translate="yes" xml:space="preserve">
          <source>Tailoring tags provided by &lt;code&gt;Unicode::Collate&lt;/code&gt; are allowed as long as they are not used for &lt;code&gt;locale&lt;/code&gt; support. Esp. the &lt;code&gt;table&lt;/code&gt; tag is always untailorable, since it is reserved for DUCET.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a3c4882101734d96d5257d2a74ae5e78eaf3de" translate="yes" xml:space="preserve">
          <source>Taint Mode</source>
          <target state="translated">Режим пятна</target>
        </trans-unit>
        <trans-unit id="f63611c6fa286ffcd2142b28c1284de824194c00" translate="yes" xml:space="preserve">
          <source>Taint an SV. Use &lt;code&gt;SvTAINTED_on&lt;/code&gt; instead.</source>
          <target state="translated">Заразить СВ. &lt;code&gt;SvTAINTED_on&lt;/code&gt; этого используйте SvTAINTED_on .</target>
        </trans-unit>
        <trans-unit id="413e513edb03310442a1614d65a7d4ad85d457e0" translate="yes" xml:space="preserve">
          <source>Taint checking is most useful when although you trust yourself not to have written a program to give away the farm, you don't necessarily trust those who end up using it not to try to trick it into doing something bad. This is the kind of security checking that's useful for set-id programs and programs launched on someone else's behalf, like CGI programs.</source>
          <target state="translated">Проверка на наличие пятен наиболее полезна,когда,хотя вы и доверяете себе,что не написали программу,чтобы выдать ферму,вы не обязательно доверяете тем,кто в конечном итоге использует ее,чтобы не пытаться обманом заставить ее сделать что-то плохое.Это вид проверки безопасности,который полезен для программ set-id и программ,запускаемых от чьего-то имени,таких,как программы CGI.</target>
        </trans-unit>
        <trans-unit id="88ab9771610a9a442e0329746e6647da7d9f316c" translate="yes" xml:space="preserve">
          <source>Taint mode</source>
          <target state="translated">Режим пятна</target>
        </trans-unit>
        <trans-unit id="504eb6d55f3dd75624d53392fb2ec7ee299aa14f" translate="yes" xml:space="preserve">
          <source>Taint mode and @INC</source>
          <target state="translated">Режим пятна и @INC</target>
        </trans-unit>
        <trans-unit id="ca7cdb9c133f6b8c9e0adf757dd404ca3a0059a6" translate="yes" xml:space="preserve">
          <source>Taint mode is a funny thing. It's the globalest of all global features. Once you turn it on, it affects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6624f88ac2856ed8ccebfe23a63eebf43e447bd" translate="yes" xml:space="preserve">
          <source>Tainting is also likely if the pattern is to be matched case-insensitively (via &lt;code&gt;/i&lt;/code&gt;). The exception is if all the code points to be matched this way are above 255 and do not have folds under Unicode rules to below 256. Tainting is not done for these because Perl only uses Unicode rules for such code points, and those rules are the same no matter what the current locale.</source>
          <target state="translated">Также возможно заражение, если шаблон должен быть сопоставлен без учета регистра (через &lt;code&gt;/i&lt;/code&gt; ). Исключением является случай, если все кодовые точки, которые должны быть сопоставлены таким образом, превышают 255 и не имеют сверток по правилам Unicode до значений ниже 256. Для них заражение не выполняется, потому что Perl использует только правила Unicode для таких кодовых точек, и эти правила являются одинаково вне зависимости от текущего языка.</target>
        </trans-unit>
        <trans-unit id="b1e437790166193a4c207aa58d0fb3a4d2a31ed7" translate="yes" xml:space="preserve">
          <source>Taints an SV if tainting is enabled, and if some input to the current expression is tainted--usually a variable, but possibly also implicit inputs such as locale settings. &lt;code&gt;SvTAINT&lt;/code&gt; propagates that taintedness to the outputs of an expression in a pessimistic fashion; i.e., without paying attention to precisely which outputs are influenced by which inputs.</source>
          <target state="translated">Заражает SV, если заражение включено, и если какой-то вход в текущее выражение испорчен - обычно это переменная, но, возможно, также неявные входные данные, такие как настройки локали. &lt;code&gt;SvTAINT&lt;/code&gt; пессимистично распространяет эту порочность на выходные данные выражения; т. е. не обращая внимания на то, на какие выходы влияют какие входы.</target>
        </trans-unit>
        <trans-unit id="094d515b3608fefc6759a36412cee467437417a5" translate="yes" xml:space="preserve">
          <source>Taiwan</source>
          <target state="translated">Taiwan</target>
        </trans-unit>
        <trans-unit id="750e96a06b9d3c66d6ca7a66a25a581164f0d409" translate="yes" xml:space="preserve">
          <source>Taiwan-based Chinese Encodings</source>
          <target state="translated">тайваньские кодировки</target>
        </trans-unit>
        <trans-unit id="721a6538b5b10ed9a1dc1b3ba2e846c06156cf4e" translate="yes" xml:space="preserve">
          <source>Take a look at &lt;a href=&quot;#Good-Practices&quot;&gt;&quot;Good Practices&quot;&lt;/a&gt; for some variants you will like to use in modern Perl code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5b403505c94cab4e9f224e4af932dc5aa9d4c7" translate="yes" xml:space="preserve">
          <source>Take a look at &lt;a href=&quot;#Good-Practices&quot;&gt;Good Practices&lt;/a&gt; for some variants you will like to use in modern Perl code.</source>
          <target state="translated">Взгляните на &lt;a href=&quot;#Good-Practices&quot;&gt;Good Practices&lt;/a&gt; для некоторых вариантов, которые вы хотите использовать в современном коде Perl.</target>
        </trans-unit>
        <trans-unit id="ce0dca464ee27d4966793e761a9ad0e74805bf7a" translate="yes" xml:space="preserve">
          <source>Take a look at the line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0faa440c7d98bab2d9d32df3b6d3a1c7c9671be2" translate="yes" xml:space="preserve">
          <source>Take a sprintf-style format pattern and argument list. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;&quot;mess_sv&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2b74024aba36db1a23fa804fd1c560d6088d9a" translate="yes" xml:space="preserve">
          <source>Take a sprintf-style format pattern and argument list. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;mess_sv&lt;/a&gt;.</source>
          <target state="translated">Возьмите шаблон формата в стиле sprintf и список аргументов. Они используются для создания строкового сообщения. Если сообщение не заканчивается новой строкой, оно будет расширено с некоторым указанием текущего местоположения в коде, как описано для &lt;a href=&quot;#mess_sv&quot;&gt;mess_sv&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb04817116fcc4f36afb8949c5edb0a2147a3489" translate="yes" xml:space="preserve">
          <source>Take care when changing a released module.</source>
          <target state="translated">Будьте осторожны при замене освобожденного модуля.</target>
        </trans-unit>
        <trans-unit id="fcbbed68b647be19cced53ca66bc41d5fb7b63bd" translate="yes" xml:space="preserve">
          <source>Take care when using this function simply as a truth test (such as in &lt;code&gt;&lt;a href=&quot;../functions/if&quot;&gt;if&lt;/a&gt;(blessed $ref)...&lt;/code&gt; ) because the package name &lt;code&gt;&quot;0&quot;&lt;/code&gt; is defined yet false.</source>
          <target state="translated">Будьте осторожны, используя эту функцию просто как проверку истинности (например, в &lt;code&gt;&lt;a href=&quot;../functions/if&quot;&gt;if&lt;/a&gt;(blessed $ref)...&lt;/code&gt; ), потому что имя пакета &lt;code&gt;&quot;0&quot;&lt;/code&gt; определено, но ложно.</target>
        </trans-unit>
        <trans-unit id="ef3657e7016525093062a8f4afb4bc9e87224179" translate="yes" xml:space="preserve">
          <source>Take care when using this function simply as a truth test (such as in &lt;code&gt;if(blessed $ref)...&lt;/code&gt;) because the package name &lt;code&gt;&quot;0&quot;&lt;/code&gt; is defined yet false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c196051206e9d1dadde68b1305cdecd7c48024" translate="yes" xml:space="preserve">
          <source>Take the example case of trying to split a string that is comma-separated into its different fields. You can't use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split(/,/)&lt;/a&gt;&lt;/code&gt; because you shouldn't split if the comma is inside quotes. For example, take a data line like this:</source>
          <target state="translated">Рассмотрим пример попытки разбить строку, разделенную запятыми, на разные поля. Вы не можете использовать &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split(/,/)&lt;/a&gt;&lt;/code&gt; потому что вы не должны разделять, если запятая находится внутри кавычек. Например, возьмем такую ​​строку данных:</target>
        </trans-unit>
        <trans-unit id="5ea9de05e3ee1ea164412af8fdd54572b6cc0c61" translate="yes" xml:space="preserve">
          <source>Take the example case of trying to split a string that is comma-separated into its different fields. You can't use &lt;code&gt;split(/,/)&lt;/code&gt; because you shouldn't split if the comma is inside quotes. For example, take a data line like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4471e2b4acce8ca9f0f3bc156ed9ea2897b12f89" translate="yes" xml:space="preserve">
          <source>Take the opportunity to reconsider and redesign the interfaces.</source>
          <target state="translated">Воспользуйтесь возможностью переосмыслить и перепроектировать интерфейсы.</target>
        </trans-unit>
        <trans-unit id="38337f43effe3e61774eb1d00c750689a8d079b1" translate="yes" xml:space="preserve">
          <source>Taken all together, XS code to hook an op checker should typically look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9469ecd951c6dfc6bb0697f6f2439dea0638b6" translate="yes" xml:space="preserve">
          <source>Taken all together, XS code to install a keyword plugin should typically look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891afd1ff7caaa23526c0cd4250f4fb5063fe719" translate="yes" xml:space="preserve">
          <source>Taken together, these features go a long way towards making Perl's regular expressions more readable. Here's an example:</source>
          <target state="translated">Взятые вместе,эти возможности в значительной степени способствуют тому,чтобы регулярные выражения Perl стали более читабельными.Вот пример:</target>
        </trans-unit>
        <trans-unit id="4a4ea905801094be1d9ff65acd694844f81d1d62" translate="yes" xml:space="preserve">
          <source>Takes STRING and replaces all referenced environment variable names with their defined values. References to environment variables take the form &lt;code&gt;%VariableName%&lt;/code&gt;. Case is ignored when looking up the VariableName in the environment. If the variable is not found then the original &lt;code&gt;%VariableName%&lt;/code&gt; text is retained. Has the same effect as the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4622f933170417209394d51b607728c20fb64f4" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_in6&lt;/code&gt; structure. Returns a list of four elements: the port number, an opaque string representing the IPv6 address, the scope ID, and the flow label. (You can use inet_ntop() to convert the address to the usual string format). Will croak if the structure does not represent an &lt;code&gt;AF_INET6&lt;/code&gt; address.</source>
          <target state="translated">Принимает структуру &lt;code&gt;sockaddr_in6&lt;/code&gt; . Возвращает список из четырех элементов: номер порта, непрозрачную строку, представляющую адрес IPv6, идентификатор области и метку потока. (Вы можете использовать inet_ntop () для преобразования адреса в обычный строковый формат). Будет квакать, если структура не представляет адрес &lt;code&gt;AF_INET6&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ffd8f37fe17f4475f9ac3335803a5668dd9a5a9" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_in&lt;/code&gt; structure (as returned by pack_sockaddr_in(), getpeername() or recv()). Returns a list of two elements: the port and an opaque string representing the IP address (you can use inet_ntoa() to convert the address to the four-dotted numeric format). Will croak if the structure does not represent an &lt;code&gt;AF_INET&lt;/code&gt; address.</source>
          <target state="translated">Принимает структуру &lt;code&gt;sockaddr_in&lt;/code&gt; (возвращаемую функциями pack_sockaddr_in (), getpeername () или recv ()). Возвращает список из двух элементов: порт и непрозрачную строку, представляющую IP-адрес (вы можете использовать inet_ntoa () для преобразования адреса в числовой формат с четырьмя точками). Будет квакать, если структура не представляет адрес &lt;code&gt;AF_INET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d55a321d267dd95843d2a82446b8e074d9b4482" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_un&lt;/code&gt; structure (as returned by pack_sockaddr_un(), getpeername() or recv()). Returns a list of one element: the pathname. Will croak if the structure does not represent an &lt;code&gt;AF_UNIX&lt;/code&gt; address.</source>
          <target state="translated">Принимает структуру &lt;code&gt;sockaddr_un&lt;/code&gt; (возвращаемую функциями pack_sockaddr_un (), getpeername () или recv ()). Возвращает список из одного элемента: путь. Будет квакать, если структура не представляет адрес &lt;code&gt;AF_UNIX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b39b8aaa0796e13f2d536ba4ee5000dfd3368b8e" translate="yes" xml:space="preserve">
          <source>Takes a LIST of values and converts it into a string using the rules given by the TEMPLATE. The resulting string is the concatenation of the converted values. Typically, each converted value looks like its machine-level representation. For example, on 32-bit machines an integer may be represented by a sequence of 4 bytes, which will in Perl be presented as a string that's 4 characters long.</source>
          <target state="translated">Берет СПИСОК значений и преобразует его в строку по правилам,заданным TEMPLATE.Полученная строка представляет собой конкатенцию преобразованных значений.Обычно каждое преобразованное значение выглядит как его машинное представление.Например,на 32-битных машинах целое число может быть представлено последовательностью из 4 байт,которая в Perl будет представлена в виде строки длиной 4 символа.</target>
        </trans-unit>
        <trans-unit id="5d9e5ca84b2f91280b89e01ed94d448f6437f46f" translate="yes" xml:space="preserve">
          <source>Takes a Perl file handle [like &lt;code&gt;STDIN&lt;/code&gt;] and returns the Win32 native file handle associated with it. See &lt;code&gt;FdGetOsFHandle&lt;/code&gt; for more information about Win32 native file handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5777f296cd09b6af58dac04faade91e80e2f742c" translate="yes" xml:space="preserve">
          <source>Takes a UTILITY name as an argument, returns the first perl version by release date where that utility was removed from core. Returns undef if the given utility was never in core or remains in core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7b238435e86c0619ef99b46a51606dfb01c0fc" translate="yes" xml:space="preserve">
          <source>Takes a UTILITY name as an argument, returns the first perl version where that utility was removed from core. Returns undef if the given utility was never in core or remains in core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a15df0cc84f3e918f628b048394d65bbdcbb8c8" translate="yes" xml:space="preserve">
          <source>Takes a Win32 native file handle and returns a &lt;code&gt;FILE_TYPE_*&lt;/code&gt; constant indicating the type of the file opened on that handle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bea2fb93e96bf3299efd7e7cc45533fa8e0d5df" translate="yes" xml:space="preserve">
          <source>Takes a destination path and an optional base path and returns a relative path from the base path to the destination path:</source>
          <target state="translated">Берет путь назначения и необязательный базовый путь и возвращает относительный путь от базового пути к целевому:</target>
        </trans-unit>
        <trans-unit id="95774c404168139c6e80f1611020974553158f89" translate="yes" xml:space="preserve">
          <source>Takes a destination path and an optional base path returns a relative path from the base path to the destination path:</source>
          <target state="translated">Принимает путь назначения,а необязательный базовый путь возвращает относительный путь от базового пути к целевому:</target>
        </trans-unit>
        <trans-unit id="d94b0d11d4ec10ac5d773f5e69a50730359dca25" translate="yes" xml:space="preserve">
          <source>Takes a filename, a scalar full of data and optionally a reference to a hash with specific options.</source>
          <target state="translated">Берет имя файла,скаляр,полный данных и,опционально,ссылку на хэш с конкретными опциями.</target>
        </trans-unit>
        <trans-unit id="ef9cdc80b0d99b082834a1fbb8d5a11a97402e97" translate="yes" xml:space="preserve">
          <source>Takes a list of capabilities as an argument and will croak if one is not found.</source>
          <target state="translated">В качестве аргумента берет список возможностей и будет кричать,если его не найти.</target>
        </trans-unit>
        <trans-unit id="2eadd3f3ba856c4409ed2499d0a3d0b488f0dfce" translate="yes" xml:space="preserve">
          <source>Takes a list of filenames and adds them to the in-memory archive.</source>
          <target state="translated">Берет список имен файлов и добавляет их в архив in-memory.</target>
        </trans-unit>
        <trans-unit id="f1b41457fa3731d32047968d9b9c24bbf39e5764" translate="yes" xml:space="preserve">
          <source>Takes a module name as an argument, returns the first perl version by release date where that module was removed from core. Returns undef if the given module was never in core or remains in core.</source>
          <target state="translated">Принимает имя модуля в качестве аргумента,возвращает первую perl-версию по дате выпуска,когда этот модуль был удален из ядра.Возвращает undef,если данный модуль никогда не был в ядре или остался в ядре.</target>
        </trans-unit>
        <trans-unit id="f46e15336d9744fdb143311ac69c4190fa941309" translate="yes" xml:space="preserve">
          <source>Takes a module name as an argument, returns the first perl version where that module was removed from core. Returns undef if the given module was never in core or remains in core.</source>
          <target state="translated">Принимает имя модуля в качестве аргумента,возвращает первую perl версию,в которой этот модуль был удален из ядра.Возвращает undef,если данный модуль никогда не был в ядре или остался в ядре.</target>
        </trans-unit>
        <trans-unit id="b0cf83e512f827739a6bf491886eab3446e0a621" translate="yes" xml:space="preserve">
          <source>Takes a number, the value of the array base $[. Cannot be non-zero on Perl 5.15.3 or later.</source>
          <target state="translated">Берет число,значение базы массива $[.Не может быть ненулевым на Perl 5.15.3 или более поздней версии.</target>
        </trans-unit>
        <trans-unit id="3cab02ff3e969b64dc6518292e8f9492855489a1" translate="yes" xml:space="preserve">
          <source>Takes a number, the value of the array base $[. Obsolete: cannot be non-zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d4a8a89e95ecb8b9eb4bb3b63296961b32f06d1" translate="yes" xml:space="preserve">
          <source>Takes a numeric mode to apply to each created directory (not modified by the current &lt;code&gt;umask&lt;/code&gt;). If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5735d53ded3f64fc817f32e6801f9c3332c8c742" translate="yes" xml:space="preserve">
          <source>Takes a packed binary address structure such as returned by unpack_sockaddr_in() (or a v-string representing the four octets of the IPv4 address in network order) and translates it into a string of the form &lt;code&gt;d.d.d.d&lt;/code&gt; where the &lt;code&gt;d&lt;/code&gt; s are numbers less than 256 (the normal human-readable four dotted number notation for Internet addresses).</source>
          <target state="translated">Принимает упакованную двоичную структуру адреса, такую ​​как возвращаемая unpack_sockaddr_in () (или v-строка, представляющая четыре октета IPv4-адреса в сетевом порядке), и переводит ее в строку формы &lt;code&gt;d.d.d.d&lt;/code&gt; где &lt;code&gt;d&lt;/code&gt; s - числа меньше 256 (обычное удобочитаемое обозначение адресов Интернет с четырьмя точками).</target>
        </trans-unit>
        <trans-unit id="85cecd3a3130634b28d9c069ebd221905ff6684f" translate="yes" xml:space="preserve">
          <source>Takes a packed binary address structure such as returned by unpack_sockaddr_in() (or a v-string representing the four octets of the IPv4 address in network order) and translates it into a string of the form &lt;code&gt;d.d.d.d&lt;/code&gt; where the &lt;code&gt;d&lt;/code&gt;s are numbers less than 256 (the normal human-readable four dotted number notation for Internet addresses).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2abe4e916de97dcbd3a2d8761e95258307eb47" translate="yes" xml:space="preserve">
          <source>Takes a packed socket address (as returned by pack_sockaddr_in(), pack_sockaddr_un() or the perl builtin functions getsockname() and getpeername()). Returns the address family tag. This will be one of the &lt;code&gt;AF_*&lt;/code&gt; constants, such as &lt;code&gt;AF_INET&lt;/code&gt; for a &lt;code&gt;sockaddr_in&lt;/code&gt; addresses or &lt;code&gt;AF_UNIX&lt;/code&gt; for a &lt;code&gt;sockaddr_un&lt;/code&gt; . It can be used to figure out what unpack to use for a sockaddr of unknown type.</source>
          <target state="translated">Принимает упакованный адрес сокета (возвращаемый функциями pack_sockaddr_in (), pack_sockaddr_un () или встроенными функциями perl getsockname () и getpeername ()). Возвращает тег семейства адресов. Это будет одна из констант &lt;code&gt;AF_*&lt;/code&gt; , например &lt;code&gt;AF_INET&lt;/code&gt; для адресов &lt;code&gt;sockaddr_in&lt;/code&gt; или &lt;code&gt;AF_UNIX&lt;/code&gt; для &lt;code&gt;sockaddr_un&lt;/code&gt; . Его можно использовать, чтобы выяснить, какую распаковку использовать для sockaddr неизвестного типа.</target>
        </trans-unit>
        <trans-unit id="00add5c8a4a149ed8051f75aa539f8eec919c737" translate="yes" xml:space="preserve">
          <source>Takes a packed socket address (as returned by pack_sockaddr_in(), pack_sockaddr_un() or the perl builtin functions getsockname() and getpeername()). Returns the address family tag. This will be one of the &lt;code&gt;AF_*&lt;/code&gt; constants, such as &lt;code&gt;AF_INET&lt;/code&gt; for a &lt;code&gt;sockaddr_in&lt;/code&gt; addresses or &lt;code&gt;AF_UNIX&lt;/code&gt; for a &lt;code&gt;sockaddr_un&lt;/code&gt;. It can be used to figure out what unpack to use for a sockaddr of unknown type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace3db72b47fd10c721426b5e390e2e0c6f992fc" translate="yes" xml:space="preserve">
          <source>Takes a partition type and returns whether that partition is a &quot;container&quot; partition that is supported under Win32, that is, whether it is an &quot;extended&quot; partition that can contain &quot;logical&quot; partitions. &lt;code&gt;$ivPartitonType&lt;/code&gt; is as for &lt;code&gt;IsRecognizedPartition&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d61f271c3866d065bf72b7810d6f1c5dfb4bf3f" translate="yes" xml:space="preserve">
          <source>Takes a partition type and returns whether that partition type is supported under Win32. &lt;code&gt;$ivPartitonType&lt;/code&gt; is an integer value as from the operating system byte of a hard disk's DOS-compatible partition table [that is, a partition table for x86-based Win32, not, for example, one used with Windows NT for Alpha processors]. For example, the &lt;code&gt;PartitionType&lt;/code&gt; member of the &lt;code&gt;PARTITION_INFORMATION&lt;/code&gt; structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fe4b00a1515bab6009cc465d438231923fa5fb" translate="yes" xml:space="preserve">
          <source>Takes a path string and returns an unsigned value with attribute flags. If it fails, it returns INVALID_FILE_ATTRIBUTES, otherwise it can be one or more of the following values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13e8e801bfdc18ca93880299add6c6b51640d38" translate="yes" xml:space="preserve">
          <source>Takes a path to a file or dir and returns an empty string if we don't want to include this file in the library. Otherwise it returns the the $path unchanged.</source>
          <target state="translated">Принимает путь к файлу или dir и возвращает пустую строку,если мы не хотим включать этот файл в библиотеку.В противном случае возвращает $path без изменений.</target>
        </trans-unit>
        <trans-unit id="5857a3f9b8ca80529d602d68d365fa9061a89d78" translate="yes" xml:space="preserve">
          <source>Takes a perl version as an argument. Returns that perl version if it exists or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">В качестве аргумента принимает версию perl. Возвращает эту версию perl, если она существует, или &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="3d9afb26d884d8b2dac4569e9ebf9cb1409e2dee" translate="yes" xml:space="preserve">
          <source>Takes a perl version as an argument. Upon successful completion, returns a reference to a hash. Each element of that hash has a key which is the name of a module (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ef5af0a7a23fbe908b8c6d6bfe7afebb158b73" translate="yes" xml:space="preserve">
          <source>Takes a quoted regular expression produced by &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, or a string representing a regular expression.</source>
          <target state="translated">Принимает регулярное выражение в кавычках, созданное &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; , или строку, представляющую регулярное выражение.</target>
        </trans-unit>
        <trans-unit id="1da3bec748134b01442fc634b8967f8ffc71be4b" translate="yes" xml:space="preserve">
          <source>Takes a quoted regular expression produced by &lt;code&gt;qr//&lt;/code&gt;, or a string representing a regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f021fc102096073a09c0f85c8e63b62bb7905ee" translate="yes" xml:space="preserve">
          <source>Takes a reference to any Perl value, and turns the referred-to value into an object in the appropriate B::OP-derived or B::SV-derived class. Apart from functions such as &lt;code&gt;main_root&lt;/code&gt; , this is the primary way to get an initial &quot;handle&quot; on an internal perl data structure which can then be followed with the other access methods.</source>
          <target state="translated">Принимает ссылку на любое значение Perl и превращает указанное значение в объект в соответствующем производном от B :: OP или B :: SV классе. Помимо таких функций, как &lt;code&gt;main_root&lt;/code&gt; , это основной способ получить начальный &amp;laquo;дескриптор&amp;raquo; внутренней структуры данных Perl, за которым затем могут следовать другие методы доступа.</target>
        </trans-unit>
        <trans-unit id="e9bcf1191796c7d482572c3d5fd8f112b75e9de7" translate="yes" xml:space="preserve">
          <source>Takes a reference to any Perl value, and turns the referred-to value into an object in the appropriate B::OP-derived or B::SV-derived class. Apart from functions such as &lt;code&gt;main_root&lt;/code&gt;, this is the primary way to get an initial &quot;handle&quot; on an internal perl data structure which can then be followed with the other access methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41f495e23e8b7129fbf9bc3a9bb6ededd8628d3" translate="yes" xml:space="preserve">
          <source>Takes a regex as an argument, returns a list of modules that match the regex given. If only a regex is provided applies to all modules in all perl versions. Optionally you may provide a list of perl versions to limit the regex search.</source>
          <target state="translated">В качестве аргумента принимает регекс,возвращает список модулей,соответствующих данному регексу.Если указан только регекс,то он применяется ко всем модулям во всех perl-версиях.Дополнительно вы можете предоставить список perl-версий,чтобы ограничить поиск регексов.</target>
        </trans-unit>
        <trans-unit id="4409b17c674e2781e58d19f638d2dce9b604b410" translate="yes" xml:space="preserve">
          <source>Takes a sprintf-style format pattern and conventional (non-SV) arguments and returns the formatted string.</source>
          <target state="translated">Принимает шаблон формата sprintf и обычные (не-SV)аргументы и возвращает форматированную строку.</target>
        </trans-unit>
        <trans-unit id="33c7557687a090fd43bd56b07499b14fc80993e2" translate="yes" xml:space="preserve">
          <source>Takes a string giving the name of a host, or a textual representation of an IP address and translates that to an packed binary address structure suitable to pass to pack_sockaddr_in(). If passed a hostname that cannot be resolved, returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. For multi-homed hosts (hosts with more than one address), the first address found is returned.</source>
          <target state="translated">Принимает строку, содержащую имя хоста или текстовое представление IP-адреса, и преобразует это в упакованную двоичную структуру адреса, подходящую для передачи в pack_sockaddr_in (). Если передано имя хоста, которое не может быть разрешено, возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Для многосетевых хостов (хостов с более чем одним адресом) возвращается первый найденный адрес.</target>
        </trans-unit>
        <trans-unit id="a5e03d93715b3e17db35edf143d3a334a6aaebce" translate="yes" xml:space="preserve">
          <source>Takes a string giving the name of a host, or a textual representation of an IP address and translates that to an packed binary address structure suitable to pass to pack_sockaddr_in(). If passed a hostname that cannot be resolved, returns &lt;code&gt;undef&lt;/code&gt;. For multi-homed hosts (hosts with more than one address), the first address found is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="223ad84fa206d265b475ea00fd86ad6d14a4bf08" translate="yes" xml:space="preserve">
          <source>Takes a string giving the path to the root directory of a file system [called a &quot;drive&quot; because every file system is assigned a &quot;drive letter&quot;] and returns an unsigned value indicating the type of drive the file system is on. The return value should be one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f86839b95b2c7ce0cd8df0fd7189ee9fa362403" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing a whitespace-separated list of values. The values &quot;all&quot; and &quot;none&quot; are special, again. It's also permissible to pass an array reference here.</source>
          <target state="translated">Берет строку,возможно содержащую разделенный пробелами список значений.Значения &quot;все&quot; и &quot;нет&quot;,опять же,специальные.Здесь также допустимо передавать ссылку на массив.</target>
        </trans-unit>
        <trans-unit id="4925dcea23e5ae74b5fce407317c9fa3709b6b25" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing a whitespace-separated list of values. The values &quot;all&quot; and &quot;none&quot; are special. It's also permissible to pass an array reference here.</source>
          <target state="translated">Берет строку,возможно содержащую разделенный пробелами список значений.Значения &quot;все&quot; и &quot;нет&quot; являются особыми.Здесь также допустимо передавать ссылку на массив.</target>
        </trans-unit>
        <trans-unit id="90662514b3c1c8b5cad150f77c448383f9911cee" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing several values separated by whitespace. The special values &quot;all&quot; and &quot;none&quot; mean what you'd expect.</source>
          <target state="translated">Берет строку,возможно содержащую несколько значений,разделенных пробелами.Специальные значения &quot;все&quot; и &quot;нет&quot; означают то,что вы ожидаете.</target>
        </trans-unit>
        <trans-unit id="8b8cbc4c6f861e88e0cc4c3970f3d7711c8f40ee" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ip_mreq&lt;/code&gt; structure. Returns a list of two elements; the IPv4 multicast address and interface address.</source>
          <target state="translated">Принимает структуру &lt;code&gt;ip_mreq&lt;/code&gt; . Возвращает список из двух элементов; адрес многоадресной рассылки IPv4 и адрес интерфейса.</target>
        </trans-unit>
        <trans-unit id="04696d2255aec363ebf123f1adcef127402d7fca" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ip_mreq_source&lt;/code&gt; structure. Returns a list of three elements; the IPv4 multicast address, source address and interface address.</source>
          <target state="translated">Принимает структуру &lt;code&gt;ip_mreq_source&lt;/code&gt; . Возвращает список из трех элементов; адрес многоадресной рассылки IPv4, адрес источника и адрес интерфейса.</target>
        </trans-unit>
        <trans-unit id="8895fb55870fc5cb5b67d2b6b1ab10511fd087e6" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ipv6_mreq&lt;/code&gt; structure. Returns a list of two elements; the IPv6 address and an interface number.</source>
          <target state="translated">Принимает структуру &lt;code&gt;ipv6_mreq&lt;/code&gt; . Возвращает список из двух элементов; адрес IPv6 и номер интерфейса.</target>
        </trans-unit>
        <trans-unit id="ad12a7e2dccc21686af63739f893c4d2a53e4c04" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt; ). Returns the &lt;code&gt;ip_mreq&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">Принимает многоадресный IPv4-адрес и, возможно, адрес интерфейса (или &lt;code&gt;INADDR_ANY&lt;/code&gt; ). Возвращает &lt;code&gt;ip_mreq&lt;/code&gt; структура с этими аргументами упакованы в. Подходит для использования с &lt;code&gt;IP_ADD_MEMBERSHIP&lt;/code&gt; и &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</target>
        </trans-unit>
        <trans-unit id="daef79d0571cfe13a97a3c30841461dc9af70aa5" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt;). Returns the &lt;code&gt;ip_mreq&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80cd3ce1fd8acb10289fb4bd58c0849f55a8d71" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address, source address, and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt; ). Returns the &lt;code&gt;ip_mreq_source&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_SOURCE_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">Принимает многоадресный адрес IPv4, адрес источника и, необязательно, адрес интерфейса (или &lt;code&gt;INADDR_ANY&lt;/code&gt; ). Возвращает &lt;code&gt;ip_mreq_source&lt;/code&gt; структура с этими аргументами упакованы в. Подходит для использования с &lt;code&gt;IP_ADD_SOURCE_MEMBERSHIP&lt;/code&gt; и &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; sockopts.</target>
        </trans-unit>
        <trans-unit id="0e03de7d098eab496f44ea7920e441314209dd86" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address, source address, and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt;). Returns the &lt;code&gt;ip_mreq_source&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_SOURCE_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414f4fb4a3a1f32b47a120675c30046be162adca" translate="yes" xml:space="preserve">
          <source>Takes an IPv6 multicast address and an interface number. Returns the &lt;code&gt;ipv6_mreq&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IPV6_ADD_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IPV6_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">Принимает групповой адрес IPv6 и номер интерфейса. Возвращает &lt;code&gt;ipv6_mreq&lt;/code&gt; структура с этими аргументами упакованы в. Подходит для использования с &lt;code&gt;IPV6_ADD_MEMBERSHIP&lt;/code&gt; и &lt;code&gt;IPV6_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</target>
        </trans-unit>
        <trans-unit id="84da4affe0802d1076fb7e8fa5b5ab6e38634ce8" translate="yes" xml:space="preserve">
          <source>Takes an address family (such as &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;AF_INET6&lt;/code&gt; ) and a string containing a textual representation of an address in that family and translates that to an packed binary address structure.</source>
          <target state="translated">Принимает семейство адресов (например, &lt;code&gt;AF_INET&lt;/code&gt; или &lt;code&gt;AF_INET6&lt;/code&gt; ) и строку, содержащую текстовое представление адреса в этом семействе, и преобразует это в упакованную двоичную структуру адреса.</target>
        </trans-unit>
        <trans-unit id="7c090993da78e7530e8d560d6312459708f8366d" translate="yes" xml:space="preserve">
          <source>Takes an address family (such as &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;AF_INET6&lt;/code&gt;) and a string containing a textual representation of an address in that family and translates that to an packed binary address structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185fc4d2aaf4353f2b2708aa34a24508e0a971cd" translate="yes" xml:space="preserve">
          <source>Takes an address family and a packed binary address structure and translates it into a human-readable textual representation of the address; typically in &lt;code&gt;d.d.d.d&lt;/code&gt; form for &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;hhhh:hhhh::hhhh&lt;/code&gt; form for &lt;code&gt;AF_INET6&lt;/code&gt; .</source>
          <target state="translated">Принимает семейство адресов и упакованную двоичную структуру адреса и преобразует их в удобочитаемое текстовое представление адреса; обычно в форме &lt;code&gt;d.d.d.d&lt;/code&gt; для &lt;code&gt;AF_INET&lt;/code&gt; или в форме &lt;code&gt;hhhh:hhhh::hhhh&lt;/code&gt; для &lt;code&gt;AF_INET6&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67141b039613b21f893d0875c6a0c29a2e6abaca" translate="yes" xml:space="preserve">
          <source>Takes an address family and a packed binary address structure and translates it into a human-readable textual representation of the address; typically in &lt;code&gt;d.d.d.d&lt;/code&gt; form for &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;hhhh:hhhh::hhhh&lt;/code&gt; form for &lt;code&gt;AF_INET6&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e77ed8250b0ab9eed8ffd2c4c006ad06b6129f6" translate="yes" xml:space="preserve">
          <source>Takes an array of items and turns them into a well-formatted list of arguments. In most cases this is simply something like:</source>
          <target state="translated">Берет массив элементов и превращает их в хорошо отформатированный список аргументов.В большинстве случаев это просто что-то вроде:</target>
        </trans-unit>
        <trans-unit id="21d2a6e85e05ac293f43bf0aadd4c7b6d2f0e70c" translate="yes" xml:space="preserve">
          <source>Takes as argument a path and returns true if it is an absolute path.</source>
          <target state="translated">Принимает в качестве аргумента путь и возвращает истину,если это абсолютный путь.</target>
        </trans-unit>
        <trans-unit id="6dc3e333ed2be58598d7c496ec3d73ebab444c2b" translate="yes" xml:space="preserve">
          <source>Takes as argument a path and returns true, if it is an absolute path. If the path has a leading &quot;:&quot;, it's a relative path. Otherwise, it's an absolute path, unless the path doesn't contain any colons, i.e. it's a name like &quot;a&quot;. In this particular case, the path is considered to be relative (i.e. it is considered to be a filename). Use &quot;:&quot; in the appropriate place in the path if you want to distinguish unambiguously. As a special case, the filename '' is always considered to be absolute. Note that with version 1.2 of File::Spec::Mac, this does no longer consult the local filesystem.</source>
          <target state="translated">Принимает в качестве аргумента путь и возвращает истину,если это абсолютный путь.Если путь имеет ведущее &quot;:&quot;,то это относительный путь.В противном случае,это абсолютный путь,если только он не содержит двоеточия,т.е.это имя типа &quot;a&quot;.В данном конкретном случае путь считается относительным (т.е.он считается именем файла).Используйте &quot;:&quot; в соответствующем месте пути,если хотите различать однозначно.В особом случае имя файла '' всегда считается абсолютным.Обратите внимание,что в версии 1.2 File::Spec::Mac,это больше не учитывается в локальной файловой системе.</target>
        </trans-unit>
        <trans-unit id="f927c21bb3e3c4ff729f953eef64006ef1f031a9" translate="yes" xml:space="preserve">
          <source>Takes as arguments a directory name and a regular expression. Returns all entries in the directory that match the regular expression.</source>
          <target state="translated">В качестве аргументов принимает имя каталога и регулярное выражение.Возвращает все записи в директории,которые соответствуют регулярному выражению.</target>
        </trans-unit>
        <trans-unit id="6047190e6cf9ba865c7d15a28d5823f107249805" translate="yes" xml:space="preserve">
          <source>Takes as its argument a path, and returns true if it is an absolute path.</source>
          <target state="translated">Принимает в качестве аргумента путь и возвращает истину,если это абсолютный путь.</target>
        </trans-unit>
        <trans-unit id="ff1dec49488d5f7d1892eedad0ad929bfc6263b5" translate="yes" xml:space="preserve">
          <source>Takes named parameters: If &lt;code&gt;shallow&lt;/code&gt; is true, the clone will share the actual individual type/input/outputmap objects, but not share their storage. Use with caution. Without &lt;code&gt;shallow&lt;/code&gt;, the clone will be fully independent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d3a8d482e59f44bd119209a124f4322f931d36" translate="yes" xml:space="preserve">
          <source>Takes no argument, returns the environment variable PATH as an array.</source>
          <target state="translated">Не принимает аргументов,возвращает переменную окружения PATH в виде массива.</target>
        </trans-unit>
        <trans-unit id="fabbbd7a986855e1324a147a7f7a2a0ae979a9a1" translate="yes" xml:space="preserve">
          <source>Takes no argument. Returns the environment variable &lt;code&gt;PATH&lt;/code&gt; (or the local platform's equivalent) as a list.</source>
          <target state="translated">Не принимает аргументов. Возвращает переменную среды &lt;code&gt;PATH&lt;/code&gt; (или эквивалент локальной платформы) в виде списка.</target>
        </trans-unit>
        <trans-unit id="904758c12da1c3cf57f2a62e3976ec89f757603e" translate="yes" xml:space="preserve">
          <source>Takes one argument ( 'stdin' | 'stdout' | 'stderr' ) and returns true if the IoIFP of the object is equal to the handle whose name was passed as argument; i.e., $io-&amp;gt;IsSTD('stderr') is true if IoIFP($io) == PerlIO_stderr().</source>
          <target state="translated">Принимает один аргумент ('stdin' | 'stdout' | 'stderr') и возвращает истину, если IoIFP объекта равен дескриптору, имя которого было передано в качестве аргумента; т.е. $ io-&amp;gt; IsSTD ('stderr') истинно, если IoIFP ($ io) == PerlIO_stderr ().</target>
        </trans-unit>
        <trans-unit id="2250c086cb14652296208baa0752736a068d5cdd" translate="yes" xml:space="preserve">
          <source>Takes one argument, a file name, and returns the file name, if the argument is likely to be a perl script. On MM_Unix this is true for any ordinary, readable file.</source>
          <target state="translated">Принимает один аргумент,имя файла,и возвращает имя файла,если этот аргумент,скорее всего,является аргументом perl скрипта.На MM_Unix это справедливо для любого обычного,читаемого файла.</target>
        </trans-unit>
        <trans-unit id="b67ed86e7a795bece24f2642cf574b99635c4b90" translate="yes" xml:space="preserve">
          <source>Takes one argument, a pathname. Returns the &lt;code&gt;sockaddr_un&lt;/code&gt; structure with that path packed in with &lt;code&gt;AF_UNIX&lt;/code&gt; filled in. For &lt;code&gt;PF_UNIX&lt;/code&gt; sockets, this structure is normally what you need for the arguments in bind(), connect(), and send().</source>
          <target state="translated">Принимает один аргумент - путь. Возвращает структуру &lt;code&gt;sockaddr_un&lt;/code&gt; с этим путем, упакованным с заполненным &lt;code&gt;AF_UNIX&lt;/code&gt; . Для сокетов &lt;code&gt;PF_UNIX&lt;/code&gt; эта структура обычно является тем, что вам нужно для аргументов в bind (), connect () и send ().</target>
        </trans-unit>
        <trans-unit id="5460ec5112334feb4ac9398f4b8e6e656f42cd55" translate="yes" xml:space="preserve">
          <source>Takes one argument: &lt;code&gt;$type&lt;/code&gt; . Returns the class for this $type, or &lt;code&gt;croak&lt;/code&gt; s with an error.</source>
          <target state="translated">Принимает один аргумент: &lt;code&gt;$type&lt;/code&gt; . Возвращает класс для этого типа $ или &lt;code&gt;croak&lt;/code&gt; с ошибкой.</target>
        </trans-unit>
        <trans-unit id="f924ea1eb572a2d6d41c219191b1f7ad36177be9" translate="yes" xml:space="preserve">
          <source>Takes one argument: &lt;code&gt;$type&lt;/code&gt;. Returns the class for this $type, or &lt;code&gt;croak&lt;/code&gt;s with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16af72bfdf1441df18765f4029d283a1f7f95693" translate="yes" xml:space="preserve">
          <source>Takes the name of a package, which may be a nested package, in the form 'Foo/Bar.pm' and replaces the slash with &lt;code&gt;::&lt;/code&gt; or something else safe for a man page file name. Returns the replacement.</source>
          <target state="translated">Принимает имя пакета, который может быть вложенным пакетом, в форме 'Foo / Bar.pm' и заменяет косую черту на &lt;code&gt;::&lt;/code&gt; или что-то другое, безопасное для имени файла страницы руководства . Возвращает замену.</target>
        </trans-unit>
        <trans-unit id="778216c494c51654f317b1afb524185f02d3ff50" translate="yes" xml:space="preserve">
          <source>Takes the necessary steps (cache invalidations, mostly) when the &lt;code&gt;@ISA&lt;/code&gt; of the given package has changed. Invoked by the &lt;code&gt;setisa&lt;/code&gt; magic, should not need to invoke directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0d6765017f7f35ad28bb62529040cd32d236cb" translate="yes" xml:space="preserve">
          <source>Takes the necessary steps (cache invalidations, mostly) when the @ISA of the given package has changed. Invoked by the &lt;code&gt;setisa&lt;/code&gt; magic, should not need to invoke directly.</source>
          <target state="translated">Предпринимает необходимые шаги (в основном, аннулирование кеша) при изменении @ISA данного пакета. Вызывается магией &lt;code&gt;setisa&lt;/code&gt; , не нужно вызывать напрямую.</target>
        </trans-unit>
        <trans-unit id="1b306490f4adab44f2505affe31e89e35e98c934" translate="yes" xml:space="preserve">
          <source>Takes the object file as an argument, and returns the portion of compile command-line that will output to the specified object file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98237f7a990bc1f6af918e56a3b7b9f24407d459" translate="yes" xml:space="preserve">
          <source>Takes two arguments, a port number and an opaque string (as returned by inet_aton(), or a v-string). Returns the &lt;code&gt;sockaddr_in&lt;/code&gt; structure with those arguments packed in and &lt;code&gt;AF_INET&lt;/code&gt; filled in. For Internet domain sockets, this structure is normally what you need for the arguments in bind(), connect(), and send().</source>
          <target state="translated">Принимает два аргумента: номер порта и непрозрачную строку (возвращаемую inet_aton () или v-строку). Возвращает структуру &lt;code&gt;sockaddr_in&lt;/code&gt; с упакованными аргументами и заполненным &lt;code&gt;AF_INET&lt;/code&gt; . Для сокетов Интернет-домена эта структура обычно является тем, что вам нужно для аргументов в bind (), connect () и send ().</target>
        </trans-unit>
        <trans-unit id="b14fed1e8f7026c1b53ef7c0d55d1e273446b0ea" translate="yes" xml:space="preserve">
          <source>Takes two arguments: &lt;code&gt;$type&lt;/code&gt; , &lt;code&gt;$class&lt;/code&gt;</source>
          <target state="translated">Принимает два аргумента: &lt;code&gt;$type&lt;/code&gt; , &lt;code&gt;$class&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55ed19e4eb2d24e5b863b8b237b5077e73ee7f56" translate="yes" xml:space="preserve">
          <source>Takes two arguments: &lt;code&gt;$type&lt;/code&gt;, &lt;code&gt;$class&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9f99285830e8621999fc816f54c6c6183fd552" translate="yes" xml:space="preserve">
          <source>Takes two to four arguments, a port number, an opaque string (as returned by inet_pton()), optionally a scope ID number, and optionally a flow label number. Returns the &lt;code&gt;sockaddr_in6&lt;/code&gt; structure with those arguments packed in and &lt;code&gt;AF_INET6&lt;/code&gt; filled in. IPv6 equivalent of pack_sockaddr_in().</source>
          <target state="translated">Принимает от двух до четырех аргументов, номер порта, непрозрачную строку (возвращаемую inet_pton ()), необязательно номер идентификатора области и необязательно номер метки потока. Возвращает структуру &lt;code&gt;sockaddr_in6&lt;/code&gt; с упакованными аргументами и заполненным &lt;code&gt;AF_INET6&lt;/code&gt; . Эквивалент pack_sockaddr_in () в IPv6.</target>
        </trans-unit>
        <trans-unit id="6768416e6b2dea0b5b355ce619b2d42c6c2f27cf" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. On Mac OS, $volume, $directory and $file are concatenated. A ':' is inserted if need be. You may pass an empty string for each portion. If all portions are empty, the empty string is returned. If $volume is empty, the result will be a relative path, beginning with a ':'. If $volume and $directory are empty, a leading &quot;:&quot; (if any) is removed form $file and the remainder is returned. If $file is empty, the resulting path will have a trailing ':'.</source>
          <target state="translated">Берет тома,части каталога и файла и возвращает полный путь.На Mac OS $ том,$ каталог и $ файл объединены.A ':' вставляется при необходимости.Вы можете передать пустую строку для каждой части.Если все части пусты,возвращается пустая строка.Если $ volume пуст,то в результате будет указан относительный путь,начинающийся с символа ':'.Если $ volume и $directory пустые,то ведущая &quot;:&quot; (если есть)удаляется из $file,а остаток возвращается.Если $-файл пуст,то в результирующем пути появится трейлинг &quot;:&quot;.</target>
        </trans-unit>
        <trans-unit id="03fb347623243a59c8c7215b498a631b05381519" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, $volume is ignored, and directory and file are concatenated. A '/' is inserted if needed (though if the directory portion doesn't start with '/' it is not added). On other OSs, $volume is significant.</source>
          <target state="translated">Берет тома,части каталога и файла и возвращает полный путь.В Unix,$ том игнорируется,а каталог и файл конкапсулируются.При необходимости вставляется '/' (хотя если часть каталога не начинается с '/',она не добавляется).В других операционных системах $ volume является существенным.</target>
        </trans-unit>
        <trans-unit id="9945bfbc052c2b04dca187c3550c5f1feee8878d" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, $volume is ignored, and this is just like catfile(). On other OSs, the $volume become significant.</source>
          <target state="translated">Берет тома,части каталога и файла и возвращает полный путь.В Unix $ volume игнорируется,и это как catfile().В других операционных системах $ volume становится значительным.</target>
        </trans-unit>
        <trans-unit id="972a64a368ed52f92018a4453bba5f6c8e73cecd" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, &lt;code&gt;$volume&lt;/code&gt; is ignored, and directory and file are concatenated. A '/' is inserted if need be. On other OSes, &lt;code&gt;$volume&lt;/code&gt; is significant.</source>
          <target state="translated">Принимает части тома, каталога и файла и возвращает полный путь. В Unix &lt;code&gt;$volume&lt;/code&gt; игнорируется, а каталог и файл объединяются. При необходимости вставляется '/'. В других операционных системах &lt;code&gt;$volume&lt;/code&gt; значителен.</target>
        </trans-unit>
        <trans-unit id="510dd54f6700e32b2e33a7ae6bf0b69436048e78" translate="yes" xml:space="preserve">
          <source>Taking a pattern, usually a &lt;b&gt;regular expression&lt;/b&gt;, and trying the pattern various ways on a string to see whether there&amp;rsquo;s any way to make it fit. Often used to pick interesting tidbits out of a file.</source>
          <target state="translated">Взять шаблон, обычно это &lt;b&gt;регулярное выражение&lt;/b&gt; , и попробовать его различными способами в строке, чтобы увидеть, есть ли какой-либо способ сделать его подходящим. Часто используется для извлечения интересных кусочков из файла.</target>
        </trans-unit>
        <trans-unit id="71bab857be3a2f057d5a14d3b22be3dc59b9b4df" translate="yes" xml:space="preserve">
          <source>Taking a reference to an enumerated list is not the same as using square brackets--instead it's the same as creating a list of references!</source>
          <target state="translated">Взять ссылку на перечисленный список-это не то же самое,что использовать квадратные скобки-это то же самое,что создать список ссылок!</target>
        </trans-unit>
        <trans-unit id="15f9cd429dc93becd860c5d004ae9bccaf0f7bef" translate="yes" xml:space="preserve">
          <source>Taking references to the elements of shared arrays and hashes does not autovivify the elements, and neither does slicing a shared array/hash over non-existent indices/keys autovivify the elements.</source>
          <target state="translated">Принятие ссылок на элементы общих массивов и хэшей не приводит к автоповиновению элементов,как и нарезание общего массива/хэша по несуществующим индексам/клавишам автоповиновки элементов.</target>
        </trans-unit>
        <trans-unit id="4c38f4d8d122fb1493ff34d8747e9c4346d4b600" translate="yes" xml:space="preserve">
          <source>Tanenbaum, Andrew S. Distributed Operating Systems. Prentice Hall, 1995, ISBN 0-13-219908-4 (great textbook).</source>
          <target state="translated">Таненбаум,Эндрю С.Распределенные операционные системы.Prentice Hall,1995,ISBN 0-13-219908-4 (отличный учебник).</target>
        </trans-unit>
        <trans-unit id="1dc610a84e3953106d973aac027936828f4fd583" translate="yes" xml:space="preserve">
          <source>TangutSources.txt</source>
          <target state="translated">TangutSources.txt</target>
        </trans-unit>
        <trans-unit id="2c7e55c8c22c8578371b576097055d97d0b00faf" translate="yes" xml:space="preserve">
          <source>Tar</source>
          <target state="translated">Tar</target>
        </trans-unit>
        <trans-unit id="6fa1266b6a5ee03e688676077ed07cbe3831ca7d" translate="yes" xml:space="preserve">
          <source>Tar command verbosity level (none or v or vv)?</source>
          <target state="translated">Уровень глаголовичности команды Tar (нет или v или vv)?</target>
        </trans-unit>
        <trans-unit id="ad911c00bd7a291ef3efa483132270f4863e5d78" translate="yes" xml:space="preserve">
          <source>Tar magic string -- not useful for most users</source>
          <target state="translated">Волшебная строка тара --не полезна для большинства пользователей.</target>
        </trans-unit>
        <trans-unit id="6c049aa004ef5f9f848604b292466698be913578" translate="yes" xml:space="preserve">
          <source>Tar version string -- not useful for most users</source>
          <target state="translated">Строка версии Tar --не полезна для большинства пользователей</target>
        </trans-unit>
        <trans-unit id="61ad50a9b9189cc3cf1874568e35e7901ff4c982" translate="yes" xml:space="preserve">
          <source>Target</source>
          <target state="translated">Target</target>
        </trans-unit>
        <trans-unit id="1826e633e69fd1415d51f9f2a918eb7307883a23" translate="yes" xml:space="preserve">
          <source>Target &lt;code&gt;dist&lt;/code&gt; prepares distribution file set. Target &lt;code&gt;zipdist&lt;/code&gt; performs same as &lt;code&gt;dist&lt;/code&gt; but additionally compresses distribution files into zip archive.</source>
          <target state="translated">Target &lt;code&gt;dist&lt;/code&gt; подготавливает набор файлов дистрибутива. Целевой &lt;code&gt;zipdist&lt;/code&gt; работает так же, как &lt;code&gt;dist&lt;/code&gt; , но дополнительно сжимает файлы распространения в zip-архив.</target>
        </trans-unit>
        <trans-unit id="3775eca859de6dcfb4c426728c102c801b4a309a" translate="yes" xml:space="preserve">
          <source>Target of goto is too deeply nested</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35260a00f655f27edcc35a7eb16da44a4f671a6" translate="yes" xml:space="preserve">
          <source>Targets</source>
          <target state="translated">Targets</target>
        </trans-unit>
        <trans-unit id="cb47f8fe09a055e30fa78d0ffd45295628f69b2c" translate="yes" xml:space="preserve">
          <source>Task-Oriented</source>
          <target state="translated">Task-Oriented</target>
        </trans-unit>
        <trans-unit id="a84eec2edc9ad24f299c8e16c921ff89b0a72d34" translate="yes" xml:space="preserve">
          <source>Tatsuhiko Miyagawa &amp;lt;miyagawa@bulknews.net&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184d6c1f032beb495ac0920ba867a330761f1d3a" translate="yes" xml:space="preserve">
          <source>Tautologous boolean operators are still going to be optimized away. Don't be tempted to write</source>
          <target state="translated">Таутологические булевые операторы все равно будут оптимизированы.Не поддавайтесь искушению написать</target>
        </trans-unit>
        <trans-unit id="b7381d80f99d092ee04058e78cf491f1a66d6d65" translate="yes" xml:space="preserve">
          <source>Technical note</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3954704c666cb5b3d49966b92f96bca0955f9f5c" translate="yes" xml:space="preserve">
          <source>Technically speaking casting between function pointers and data pointers is unportable and undefined, but practically speaking it seems to work, but you should use the FPTR2DPTR() and DPTR2FPTR() macros. Sometimes you can also play games with unions.</source>
          <target state="translated">Технически говоря,кастинг между указателями на функции и указателями на данные является непредсказуемым и неопределенным,но на практике это вроде бы работает,но следует использовать макросы FPTR2DPTR()и DPTR2FPTR().Иногда можно играть и с союзами.</target>
        </trans-unit>
        <trans-unit id="789a9f1903bc34d24a4cbcecb6e7df34821ef6e1" translate="yes" xml:space="preserve">
          <source>Technically speaking, any extra semantics attached to a variable such as &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;%ENV&lt;/code&gt; , or &lt;code&gt;%SIG&lt;/code&gt; , or to any tied variable. Magical things happen when you diddle those variables.</source>
          <target state="translated">Технически говоря, любая дополнительная семантика, прикрепленная к такой переменной, как &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;%ENV&lt;/code&gt; или &lt;code&gt;%SIG&lt;/code&gt; , или любой связанной переменной. Когда вы изменяете эти переменные, происходят волшебные вещи.</target>
        </trans-unit>
        <trans-unit id="37c0cdada9acbef172bbad2abeee43e9c265bf5f" translate="yes" xml:space="preserve">
          <source>Technically speaking, any extra semantics attached to a variable such as &lt;code&gt;$!&lt;/code&gt;, &lt;code&gt;$0&lt;/code&gt;, &lt;code&gt;%ENV&lt;/code&gt;, or &lt;code&gt;%SIG&lt;/code&gt;, or to any tied variable. Magical things happen when you diddle those variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6e2f047cca74ccc3c9d17a9bfaad25ab5dfd70e" translate="yes" xml:space="preserve">
          <source>Technically, or mathematically, speaking, a character set encoded in such a CES that maps character by character may form a CCS. EUC is such an example. The CES of EUC is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bceeda0d1cb49658a382ae82742f6ea314f38047" translate="yes" xml:space="preserve">
          <source>Tell</source>
          <target state="translated">Tell</target>
        </trans-unit>
        <trans-unit id="36cdc28b89efb53a06a6917a07b767fb68103199" translate="yes" xml:space="preserve">
          <source>Tell all procs/threads it is time to be done</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9278f94e7a82313efec40ca2dd22098d512b4425" translate="yes" xml:space="preserve">
          <source>Tell other processes and events that an event is pending. &lt;code&gt;$uniq_val&lt;/code&gt; should be a unique value no other thread/process will generate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7dda96092209462b6b29c0664b9391938707a82" translate="yes" xml:space="preserve">
          <source>Tell other processes and threads there is a pending event. &lt;code&gt;$val&lt;/code&gt; should be a unique value no other thread/process will generate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3fc1fc6f28fa057e70de617f17fd53df2eeea80" translate="yes" xml:space="preserve">
          <source>Tell the grammar which TAP syntax version to support. The lowest supported version is 12. Although 'TAP version' isn't valid version 12 syntax it is accepted so that higher version numbers may be parsed.</source>
          <target state="translated">Скажите грамматике,какую версию синтаксиса TAP поддерживать.Самая низкая поддерживаемая версия-12.Хотя 'Версия TAP' и не является действительной версией синтаксиса 12,она принята для того,чтобы можно было разобрать более высокие номера версий.</target>
        </trans-unit>
        <trans-unit id="bf7b0d797da557d31ab2a71f5864f39fe5a06aac" translate="yes" xml:space="preserve">
          <source>Tell the parser to ignore the exit status from the test when determining whether the test passed. Normally tests with non-zero exit status are considered to have failed even if all individual tests passed. In cases where it is not possible to control the exit value of the test script use this option to ignore it.</source>
          <target state="translated">Скажите синтаксическому анализатору игнорировать статус выхода из теста при определении того,прошел ли тест.Обычно тесты с ненулевым статусом выхода считаются неудачными,даже если все отдельные тесты прошли.В тех случаях,когда невозможно контролировать значение выхода тестового скрипта,используйте эту опцию,чтобы игнорировать его.</target>
        </trans-unit>
        <trans-unit id="bf2d615f3aae044f0b7af594b2368699ca553959" translate="yes" xml:space="preserve">
          <source>Tell the parser where should the output go. In this case it will be placed in the $html variable:</source>
          <target state="translated">Скажите парсеру,куда должен идти выход.В этом случае он будет помещен в переменную $html:</target>
        </trans-unit>
        <trans-unit id="29533c09561de1801d031a71f8c7c8a01e5f03c1" translate="yes" xml:space="preserve">
          <source>Tell the remote server that I am not a user client, but probably another news server.</source>
          <target state="translated">Скажите удаленному серверу,что я не клиент-пользователь,а,возможно,другой сервер новостей.</target>
        </trans-unit>
        <trans-unit id="08608b0e566d4fb7e89ec44318b59ab07dde69d0" translate="yes" xml:space="preserve">
          <source>Tell the remote server the mail domain which you are in using the EHLO command (or HELO if EHLO fails). Since this method is invoked automatically when the Net::SMTP object is constructed the user should normally not have to call it manually.</source>
          <target state="translated">Сообщите удаленному серверу почтовый домен,в котором вы находитесь,с помощью команды EHLO (или HELO,если EHLO не удается).Так как этот метод вызывается автоматически при создании Net::SMTP объекта,пользователю обычно не нужно вызывать его вручную.</target>
        </trans-unit>
        <trans-unit id="1f6b5a09a58a8567f17dcd614ece669f9d14b0d0" translate="yes" xml:space="preserve">
          <source>Tell the server that we want to append some data to the end of a file called &lt;code&gt;FILE&lt;/code&gt; . If this file does not exist then create it.</source>
          <target state="translated">Сообщите серверу, что мы хотим добавить некоторые данные в конец файла с именем &lt;code&gt;FILE&lt;/code&gt; . Если этого файла не существует, создайте его.</target>
        </trans-unit>
        <trans-unit id="8ff5b934cbf9d3fd05d80b879d5b2e694a3f82ae" translate="yes" xml:space="preserve">
          <source>Tell the server that we want to append some data to the end of a file called &lt;code&gt;FILE&lt;/code&gt;. If this file does not exist then create it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995cb880453aaa8bd60b7aae252f5462234be732" translate="yes" xml:space="preserve">
          <source>Tell the server that you are a reader and not another server.</source>
          <target state="translated">Скажите серверу,что вы читатель,а не другой сервер.</target>
        </trans-unit>
        <trans-unit id="055d9e27b5b7d5b8f2d504557166da8931089570" translate="yes" xml:space="preserve">
          <source>Tell the server that you wish to store a file. &lt;code&gt;FILE&lt;/code&gt; is the name of the new file that should be created.</source>
          <target state="translated">Сообщите серверу, что вы хотите сохранить файл. &lt;code&gt;FILE&lt;/code&gt; - это имя нового файла, который необходимо создать.</target>
        </trans-unit>
        <trans-unit id="9366b9a09ea150c339542dc64664840e4fc85da8" translate="yes" xml:space="preserve">
          <source>Tell the server to go into passive mode (&lt;code&gt;pasv&lt;/code&gt; for IPv4, &lt;code&gt;epsv&lt;/code&gt; for IPv6). Returns the text that represents the port on which the server is listening, this text is in a suitable form to send to another ftp server using the &lt;code&gt;port&lt;/code&gt; or &lt;code&gt;eprt&lt;/code&gt; method.</source>
          <target state="translated">Скажите серверу перейти в пассивный режим ( &lt;code&gt;pasv&lt;/code&gt; для IPv4, &lt;code&gt;epsv&lt;/code&gt; для IPv6). Возвращает текст, представляющий порт, на котором сервер прослушивает, этот текст находится в подходящей форме для отправки на другой ftp-сервер с использованием метода &lt;code&gt;port&lt;/code&gt; или &lt;code&gt;eprt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07221dbb3d1c9d6040ef943ff42c4107c54603a8" translate="yes" xml:space="preserve">
          <source>Telling &lt;a href=&quot;Email::Stuffer&quot;&gt;Email::Stuffer&lt;/a&gt; to use your transport is straightforward.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d551aaf2266eb9d86adea81d4570cc191bb729" translate="yes" xml:space="preserve">
          <source>Telling &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email::Sender::Simple&lt;/a&gt; to use your transport is straightforward.</source>
          <target state="translated">Сообщаем &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email :: Sender ::&lt;/a&gt; Ваш транспорт очень прост в использовании.</target>
        </trans-unit>
        <trans-unit id="dd2c3160deeb317e223ba57be41f996c28b1ec03" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; the given string in scalar context and return an SV* result.</source>
          <target state="translated">Сообщает Perl &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; данную строку в скалярном контексте и вернуть результат SV *.</target>
        </trans-unit>
        <trans-unit id="d9e092fa3e1e256147594ca30bda8c3f4672e0ee" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; the string in the SV. It supports the same flags as &lt;code&gt;call_sv&lt;/code&gt; , with the obvious exception of G_EVAL. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">Указывает Perl &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; строку в SV. Он поддерживает те же флаги, что и &lt;code&gt;call_sv&lt;/code&gt; , за очевидным исключением G_EVAL. См. &lt;a href=&quot;perlcall&quot;&gt;Perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a71daae5e0e57d93d6228536edc45b69ba84a875" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; the file named by the string argument. It is analogous to the Perl code &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require '$file'&quot;&lt;/code&gt; . It's even implemented that way; consider using load_module instead.</source>
          <target state="translated">Сообщает Perl о &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; файла, названного строковым аргументом. Это аналог Perl-кода &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require '$file'&quot;&lt;/code&gt; . Это даже реализовано таким образом; рассмотрите возможность использования load_module вместо этого.</target>
        </trans-unit>
        <trans-unit id="1b1b082272b9bd4181468eabc6b8e44fc8fe6c64" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;eval&lt;/code&gt; the given string in scalar context and return an SV* result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3df8e8a89eba38389eed572b608ff46f9135ee" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;eval&lt;/code&gt; the string in the SV. It supports the same flags as &lt;code&gt;call_sv&lt;/code&gt;, with the obvious exception of &lt;code&gt;G_EVAL&lt;/code&gt;. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835ee5f386d4eccf5016f84f3d99b790dcda5f79" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;require&lt;/code&gt; the file named by the string argument. It is analogous to the Perl code &lt;code&gt;eval &quot;require '$file'&quot;&lt;/code&gt;. It's even implemented that way; consider using load_module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1bf556e6d9dede28e015a565e8d9027e099de7d" translate="yes" xml:space="preserve">
          <source>Tells Test::Builder what package you exported your functions to.</source>
          <target state="translated">Tells Test::Builder,в какой пакет вы экспортировали свои функции.</target>
        </trans-unit>
        <trans-unit id="21d8020c0986f9af967d2434489f1dff7dddc2b6" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to parse a Perl script. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">Сообщает интерпретатору Perl разобрать сценарий Perl. См. &lt;a href=&quot;perlembed&quot;&gt;Perlembed&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fc8f2629186f20e45a65a6df178e8841854cf49" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to parse a Perl script. This performs most of the initialisation of a Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt; for a tutorial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af02c41897ccb1ab6624206547ff7270321f616" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to run its main program. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt; for a tutorial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90de9fbbe619d0267fd7167e5dc1db64eb361247" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to run. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">Указывает интерпретатору Perl запускаться. См. &lt;a href=&quot;perlembed&quot;&gt;Perlembed&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2794a27373eb4499d2dd0fc224b3c502ced9a12f" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a double and disables all other OK bits.</source>
          <target state="translated">Говорит SV,что он двойной и отключает все остальные OK-биты.</target>
        </trans-unit>
        <trans-unit id="cde3486f8b34dcc836358775446f605a6e5f5219" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a double.</source>
          <target state="translated">Скажет спецназу,что это двойник.</target>
        </trans-unit>
        <trans-unit id="38d5abd50f24b07310ee29175bef33b4202c7809" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other &lt;code&gt;OK&lt;/code&gt; bits, and leaves the UTF-8 status as it was.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31fe87231b97a4e4ddb62ec499c5ee8942eac05a" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other &lt;code&gt;OK&lt;/code&gt; bits. Will also turn off the UTF-8 status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29a05e0eb81580dedcd3ec32c30e53e3f465ef8" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other OK bits, and leaves the UTF-8 status as it was.</source>
          <target state="translated">Говорит SV,что это строка и отключает все остальные OK-биты,и оставляет UTF-8 статус как есть.</target>
        </trans-unit>
        <trans-unit id="826cf5cb563ce76cd986386302e8a1a458503e48" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other OK bits. Will also turn off the UTF-8 status.</source>
          <target state="translated">Говорит SV,что это строка,и отключает все остальные OK-биты.Также отключает статус UTF-8.</target>
        </trans-unit>
        <trans-unit id="3a0e0af0ea20a9f25152c6d76518063affb1c7ae" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string.</source>
          <target state="translated">Скажет SV,что это строка.</target>
        </trans-unit>
        <trans-unit id="9359d018a66deddebc4670552c35dfa39c5db6a1" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an RV.</source>
          <target state="translated">Скажет спецназу,что это фургон.</target>
        </trans-unit>
        <trans-unit id="6c3d42b807cb60d5c1d3b6f5a5dbefd19d80f738" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an integer and disables all other &lt;code&gt;OK&lt;/code&gt; bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ea638c533f4384730e93210ef4a899bb9d756b" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an integer and disables all other OK bits.</source>
          <target state="translated">Говорит SV,что это целое число,и отключает все остальные OK-биты.</target>
        </trans-unit>
        <trans-unit id="6d0dafe3ace125974c920e3d5dd9ad0e37849cd8" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an integer.</source>
          <target state="translated">Говорит SV,что это целое число.</target>
        </trans-unit>
        <trans-unit id="32b076858cb529d5d1d166704ef6d15c34643322" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an unsigned integer and disables all other &lt;code&gt;OK&lt;/code&gt; bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b98f3f753198e2b29067e4cd07e7535b94339d" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an unsigned integer and disables all other OK bits.</source>
          <target state="translated">Говорит SV,что это беззнаковое целое число,и отключает все остальные OK-биты.</target>
        </trans-unit>
        <trans-unit id="2f015ae08c2ba0f00c29151908ca6bc489974130" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Implemented by calling &lt;code&gt;sv_usepvn_flags&lt;/code&gt; with &lt;code&gt;flags&lt;/code&gt; of 0, hence does not handle 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_usepvn_flags&quot;&gt;&quot;sv_usepvn_flags&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e3c3ca5f6df324b9d092553470d578100c40eb" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Implemented by calling &lt;code&gt;sv_usepvn_flags&lt;/code&gt; with &lt;code&gt;flags&lt;/code&gt; of 0, hence does not handle 'set' magic. See &lt;code&gt;sv_usepvn_flags&lt;/code&gt; .</source>
          <target state="translated">Указывает SV использовать &lt;code&gt;ptr&lt;/code&gt; для поиска своего строкового значения. Реализуется путем вызова &lt;code&gt;sv_usepvn_flags&lt;/code&gt; с &lt;code&gt;flags&lt;/code&gt; 0, следовательно, не обрабатывает магию set. См. &lt;code&gt;sv_usepvn_flags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f1684ac88b387a920693532449fce7adef04529" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Normally the string is stored inside the SV, but sv_usepvn allows the SV to use an outside string. &lt;code&gt;ptr&lt;/code&gt; should point to memory that was allocated by &lt;a href=&quot;perlclib#Memory-Management-and-String-Handling&quot;&gt;&lt;code&gt;Newx&lt;/code&gt;&lt;/a&gt;. It must be the start of a &lt;code&gt;Newx&lt;/code&gt;-ed block of memory, and not a pointer to the middle of it (beware of &lt;a href=&quot;perlguts#Offsets&quot;&gt;&lt;code&gt;OOK&lt;/code&gt;&lt;/a&gt; and copy-on-write), and not be from a non-&lt;code&gt;Newx&lt;/code&gt; memory allocator like &lt;code&gt;malloc&lt;/code&gt;. The string length, &lt;code&gt;len&lt;/code&gt;, must be supplied. By default this function will &lt;code&gt;Renew&lt;/code&gt; (i.e. realloc, move) the memory pointed to by &lt;code&gt;ptr&lt;/code&gt;, so that pointer should not be freed or used by the programmer after giving it to &lt;code&gt;sv_usepvn&lt;/code&gt;, and neither should any pointers from &quot;behind&quot; that pointer (e.g. ptr + 1) be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898e0cc9cfb0dad2df7d68beacd47f39b7ca2406" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Normally the string is stored inside the SV, but sv_usepvn allows the SV to use an outside string. The &lt;code&gt;ptr&lt;/code&gt; should point to memory that was allocated by &lt;a href=&quot;perlclib#Memory-Management-and-String-Handling&quot;&gt;Newx&lt;/a&gt;. It must be the start of a Newx-ed block of memory, and not a pointer to the middle of it (beware of &lt;a href=&quot;perlguts#Offsets&quot;&gt;OOK&lt;/a&gt; and copy-on-write), and not be from a non-Newx memory allocator like &lt;code&gt;malloc&lt;/code&gt; . The string length, &lt;code&gt;len&lt;/code&gt; , must be supplied. By default this function will &lt;code&gt;Renew&lt;/code&gt; (i.e. realloc, move) the memory pointed to by &lt;code&gt;ptr&lt;/code&gt; , so that pointer should not be freed or used by the programmer after giving it to sv_usepvn, and neither should any pointers from &quot;behind&quot; that pointer (e.g. ptr + 1) be used.</source>
          <target state="translated">Указывает SV использовать &lt;code&gt;ptr&lt;/code&gt; для поиска своего строкового значения. Обычно строка хранится внутри SV, но sv_usepvn позволяет SV использовать внешнюю строку. &lt;code&gt;ptr&lt;/code&gt; должен указывать на память , которая была выделена с помощью &lt;a href=&quot;perlclib#Memory-Management-and-String-Handling&quot;&gt;Newx&lt;/a&gt; . Это должно быть начало блока памяти Newx-ed, а не указатель на его середину (остерегайтесь &lt;a href=&quot;perlguts#Offsets&quot;&gt;OOK&lt;/a&gt; и копирования при записи), а не из распределителя памяти не-Newx, такого как &lt;code&gt;malloc&lt;/code&gt; . Должна быть указана длина строки &lt;code&gt;len&lt;/code&gt; . По умолчанию эта функция &lt;code&gt;Renew&lt;/code&gt; (т.е. перераспределяет, перемещает) память, на которую указывает &lt;code&gt;ptr&lt;/code&gt; , так что этот указатель не должен освобождаться или использоваться программистом после его передачи sv_usepvn, а также не должны использоваться какие-либо указатели &amp;laquo;позади&amp;raquo; этого указателя (например, ptr + 1).</target>
        </trans-unit>
        <trans-unit id="fa94c122bdfc00ca551536773f45fe7b4444a81f" translate="yes" xml:space="preserve">
          <source>Tells the debugger that we'll want to pause execution when we reach either the named function (but see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;&quot;Internal Functions&quot; in perlguts&lt;/a&gt;!) or the given line in the named source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1983bb2952566f54d05f0ce7c7dc4c67383643" translate="yes" xml:space="preserve">
          <source>Tells the debugger that we'll want to pause execution when we reach either the named function (but see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Internal Functions in perlguts&lt;/a&gt;!) or the given line in the named source file.</source>
          <target state="translated">Сообщает отладчику, что мы хотим приостановить выполнение, когда мы дойдем до названной функции (но см. &amp;laquo; &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Внутренние функции в perlguts&lt;/a&gt; !&amp;raquo;) Или данной строки в названном исходном файле.</target>
        </trans-unit>
        <trans-unit id="d14b1bd32ddb84a178c8e757f0eede95fcc4f56d" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on characters. The definition of character varies depending on if the target string is a UTF-8 string.</source>
          <target state="translated">Сказывает оператору сплит разделить целевую строку на символы.Определение символов варьируется в зависимости от того,является ли целевая строка строкой UTF-8.</target>
        </trans-unit>
        <trans-unit id="184bc1d12ee8da813cda422d2ca1e00df540f884" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on newlines (&lt;code&gt;\n&lt;/code&gt; ) without invoking the regex engine.</source>
          <target state="translated">Сообщает оператору разделения разделить целевую строку на новые строки ( &lt;code&gt;\n&lt;/code&gt; ) без вызова механизма регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="7add2a85af4113fd669c82c4ee4e7afc64bec786" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on newlines (&lt;code&gt;\n&lt;/code&gt;) without invoking the regex engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48808542e716e16e3adb670d9889b9528897056" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on whitespace without invoking the regex engine. The definition of whitespace varies depending on if the target string is a UTF-8 string and on if RXf_PMf_LOCALE is set.</source>
          <target state="translated">Сказывает оператору сплит разделить целевую строку на белые пробела без вызова регрессионного двигателя.Определение пробела варьируется в зависимости от того,является ли целевая строка UTF-8 строкой и установлена ли RXf_PMf_LOCALE.</target>
        </trans-unit>
        <trans-unit id="e150384486349cedc8729ff69a3903d6982a4a60" translate="yes" xml:space="preserve">
          <source>Tells whether the object is renewed (and how many times). Some modules emit &lt;code&gt;Use of uninitialized value in null operation&lt;/code&gt; warning unless the value is numeric so return 0 for false.</source>
          <target state="translated">Сообщает, обновляется ли объект (и сколько раз). Некоторые модули выдают предупреждение об &lt;code&gt;Use of uninitialized value in null operation&lt;/code&gt; предупреждении о нулевой операции, если значение не является числовым, поэтому верните 0 для false.</target>
        </trans-unit>
        <trans-unit id="fe08a0c4d36ed96cbb4447cc6f3eff3004614a0a" translate="yes" xml:space="preserve">
          <source>Tels &lt;a href=&quot;http://bloodgate.com/&quot;&gt;http://bloodgate.com/&lt;/a&gt; 2001-2009.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7760f2328a8cb1216abc5d480c3f7c025535cee" translate="yes" xml:space="preserve">
          <source>Temp dir + Files concurrency model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="716ec42869a03408fcb77c9873e5ac4f7f2b0aad" translate="yes" xml:space="preserve">
          <source>Template Grouping</source>
          <target state="translated">Группировка шаблонов</target>
        </trans-unit>
        <trans-unit id="c9f888d973643e39eea58ba0d4385df9a5d27ccf" translate="yes" xml:space="preserve">
          <source>Template code &lt;code&gt;P&lt;/code&gt; promises to pack a &quot;pointer to a fixed length string&quot;. Isn't this what we want? Let's try:</source>
          <target state="translated">Код шаблона &lt;code&gt;P&lt;/code&gt; обещает упаковать &amp;laquo;указатель на строку фиксированной длины&amp;raquo;. Разве мы не этого хотим? Давай попробуем:</target>
        </trans-unit>
        <trans-unit id="a108586754857c54e59b71ddb85b8b2a3279733a" translate="yes" xml:space="preserve">
          <source>Template is the same as that required by mkstemp().</source>
          <target state="translated">Шаблон совпадает с шаблоном,требуемым функцией mkstemp().</target>
        </trans-unit>
        <trans-unit id="3d3a072632618e86894944ff55a4538808fd8ea6" translate="yes" xml:space="preserve">
          <source>Temporaries Stack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58aad47f3a12a51d4d52aa8432c69a9c8ebbb3e7" translate="yes" xml:space="preserve">
          <source>Temporarily disable a member of the XOP, by clearing the appropriate flag.</source>
          <target state="translated">Временно отключить члена XOP,очистив соответствующий флаг.</target>
        </trans-unit>
        <trans-unit id="d80af7efaaaefafc73c5845cc5b267960e4626cc" translate="yes" xml:space="preserve">
          <source>Temporarily disable an entry in this BHK structure, by clearing the appropriate flag.</source>
          <target state="translated">Временно отключите запись в этой структуре BHK,сняв соответствующий флаг.</target>
        </trans-unit>
        <trans-unit id="e7f1b0942dc03abbb9406810a4ca16b57247a87e" translate="yes" xml:space="preserve">
          <source>Temporarily disable an entry in this BHK structure, by clearing the appropriate flag. &lt;code&gt;which&lt;/code&gt; is a preprocessor token indicating which entry to disable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3f1700e4dfa66cdfab75739db179821b620308" translate="yes" xml:space="preserve">
          <source>Temporarily fixing locale problems</source>
          <target state="translated">Временное решение локальных проблем</target>
        </trans-unit>
        <trans-unit id="48915beb5208adc13703e622845e9d9286a425c6" translate="yes" xml:space="preserve">
          <source>Temporarily override assorted &lt;code&gt;CPAN.pm&lt;/code&gt; configuration variables.</source>
          <target state="translated">Временно переопределить различные переменные конфигурации &lt;code&gt;CPAN.pm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d8d27f44975a51a83ee576661872ef78010f131" translate="yes" xml:space="preserve">
          <source>Temporary (no file directory).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6563ecf47ef5662e753d4670106fb233c800e886" translate="yes" xml:space="preserve">
          <source>Temporary Values via local()</source>
          <target state="translated">Временные значения с помощью функции local()</target>
        </trans-unit>
        <trans-unit id="966d13f8587efdadd4d1a975aa3423e8769b72b3" translate="yes" xml:space="preserve">
          <source>Temporary delete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab6577ed3ab16dc6a0a24e8a29b8f2320a3f1bea" translate="yes" xml:space="preserve">
          <source>Temporary files and NFS</source>
          <target state="translated">Временные файлы и NFS</target>
        </trans-unit>
        <trans-unit id="972e2ab11e7ed25c1af63f02f49c51ed09f64187" translate="yes" xml:space="preserve">
          <source>Tend to fail, not succeed.</source>
          <target state="translated">Склонность к неудаче,а не к успеху.</target>
        </trans-unit>
        <trans-unit id="81ac69447a0c644cecd1c09f31f389b73f4febee" translate="yes" xml:space="preserve">
          <source>Tenon Machten</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="038c9aeb7bb05d375a32b9ab2979691faa497330" translate="yes" xml:space="preserve">
          <source>Term used by language lawyers for a storage location you can assign a new &lt;b&gt;value&lt;/b&gt; to, such as a &lt;b&gt;variable&lt;/b&gt; or an element of an &lt;b&gt;array&lt;/b&gt;. The &amp;ldquo;l&amp;rdquo; is short for &amp;ldquo;left&amp;rdquo;, as in the left side of an assignment, a typical place for lvalues. An &lt;b&gt;lvaluable&lt;/b&gt; function or expression is one to which a value may be assigned, as in &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;($x) = 10&lt;/code&gt; .</source>
          <target state="translated">Термин, используемый юристами в области языка для обозначения места хранения, которому вы можете присвоить новое &lt;b&gt;значение&lt;/b&gt; , например &lt;b&gt;переменной&lt;/b&gt; или элементу &lt;b&gt;массива&lt;/b&gt; . &amp;laquo;L&amp;raquo; - это сокращение от &amp;laquo;left&amp;raquo;, так как в левой части присваивания, типичное место для lvalues. &lt;b&gt;Левосторонняя&lt;/b&gt; функция или выражение , к которому один объект может быть назначен, как в &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;($x) = 10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3570ded95db6a210fa183ad2282d08a349916fef" translate="yes" xml:space="preserve">
          <source>Term used by language lawyers for a storage location you can assign a new &lt;b&gt;value&lt;/b&gt; to, such as a &lt;b&gt;variable&lt;/b&gt; or an element of an &lt;b&gt;array&lt;/b&gt;. The &amp;ldquo;l&amp;rdquo; is short for &amp;ldquo;left&amp;rdquo;, as in the left side of an assignment, a typical place for lvalues. An &lt;b&gt;lvaluable&lt;/b&gt; function or expression is one to which a value may be assigned, as in &lt;code&gt;pos($x) = 10&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0028d995c201a4db08a4f29da91c7c14dbfb31" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor</source>
          <target state="translated">Term::ANSIColor</target>
        </trans-unit>
        <trans-unit id="a16dc007b248f41d8a8b48934fc42c79241aa183" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor - Color screen output using ANSI escape sequences</source>
          <target state="translated">Термин::ANSIColor-вывод цветного экрана с использованием ANSI-эвакуационных последовательностей</target>
        </trans-unit>
        <trans-unit id="db406ea9117455f0b666b6ba8f4edfbd34a6728b" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor is used to get colors and therefore must be installed to use this module.</source>
          <target state="translated">Термин::ANSIColor используется для получения цветов и поэтому должен быть установлен для использования этого модуля.</target>
        </trans-unit>
        <trans-unit id="f7bdc8f03c4b5d2f5d03a99d6b589da67ba2844c" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor was first included with Perl in Perl 5.6.0.</source>
          <target state="translated">Термин::ANSIColor был впервые включен с Perl в Perl 5.6.0.</target>
        </trans-unit>
        <trans-unit id="3973a6639b848462a9aba2fb3883fdeeeee93564" translate="yes" xml:space="preserve">
          <source>Term::Cap</source>
          <target state="translated">Term::Cap</target>
        </trans-unit>
        <trans-unit id="82cd629b4593ce6a72b220343056170a7eb3d545" translate="yes" xml:space="preserve">
          <source>Term::Cap - Perl termcap interface</source>
          <target state="translated">Термин::Пробка-Терминальный интерфейс на Perl-носителе</target>
        </trans-unit>
        <trans-unit id="3d3bfe455e655790515f3b006edeb99748236633" translate="yes" xml:space="preserve">
          <source>Term::Complete</source>
          <target state="translated">Term::Complete</target>
        </trans-unit>
        <trans-unit id="6d23da7c53fbf0f4faebaefa6851bd7ad00eee31" translate="yes" xml:space="preserve">
          <source>Term::Complete - Perl word completion module</source>
          <target state="translated">Терминал::Завершение-Модуль завершения слова на Perl</target>
        </trans-unit>
        <trans-unit id="23ebd3bc9f5af49b1131c82bd5eefd1ac9f6bc11" translate="yes" xml:space="preserve">
          <source>Term::ReadLine</source>
          <target state="translated">Term::ReadLine</target>
        </trans-unit>
        <trans-unit id="bfadfd7a83f6920cfb9038f1942ac1ea2e3b25c1" translate="yes" xml:space="preserve">
          <source>Term::ReadLine - Perl interface to various &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; packages. If no real package is found, substitutes stubs instead of basic functions.</source>
          <target state="translated">Term :: ReadLine - Perl-интерфейс для различных пакетов &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; . Если реальный пакет не найден, подставляет заглушки вместо основных функций.</target>
        </trans-unit>
        <trans-unit id="7113fd2a1763597777139799d4259876fd00d022" translate="yes" xml:space="preserve">
          <source>Term::ReadLine - Perl interface to various &lt;code&gt;readline&lt;/code&gt; packages. If no real package is found, substitutes stubs instead of basic functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b36cab4785101b615f79c20885ccd2eda2f048" translate="yes" xml:space="preserve">
          <source>Terminal emulators that support color divide into four types: ones that support only eight colors, ones that support sixteen, ones that support 256, and ones that support 24-bit color. This module provides the ANSI escape codes for all of them. These colors are referred to as ANSI colors 0 through 7 (normal), 8 through 15 (16-color), 16 through 255 (256-color), and true color (called direct-color by &lt;b&gt;xterm&lt;/b&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8379c22e18e11951de951761db8a9d7c5f2195" translate="yes" xml:space="preserve">
          <source>Terminal emulators that support color divide into two types: ones that support only eight colors, ones that support sixteen, and ones that support 256. This module provides the ANSI escape codes all of them. These colors are referred to as ANSI colors 0 through 7 (normal), 8 through 15 (16-color), and 16 through 255 (256-color).</source>
          <target state="translated">Терминальные эмуляторы,поддерживающие цвет,делятся на два типа:те,которые поддерживают только восемь цветов,те,которые поддерживают шестнадцать,и те,которые поддерживают 256.Этот модуль предоставляет ANSI-экскпозитные коды всех из них.Эти цвета называются ANSI цветами от 0 до 7 (нормальный),от 8 до 15 (16-цветный)и от 16 до 255 (256-цветной).</target>
        </trans-unit>
        <trans-unit id="06b99286ab352f9eeaab809a6a34ccd3528b3299" translate="yes" xml:space="preserve">
          <source>Terminal interface values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b13399f2e2e5cbdb3d2ac7675630b976b3e5443" translate="yes" xml:space="preserve">
          <source>Terminate use of a parser. Typically used and/or overridden in subclasses. The parser isn't destroyed as a result of this.</source>
          <target state="translated">Прекратить использование парсера.Обычно используется и/или переопределяется в подклассах.В результате этого парсер не уничтожается.</target>
        </trans-unit>
        <trans-unit id="6b2081166b6ec9fa584db14b8bc64a4e53b287d9" translate="yes" xml:space="preserve">
          <source>Terminates the compressed data stream and flushes any pending compressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">Завершает поток сжатых данных и сбрасывает все ожидающие сжатые данные в &lt;code&gt;$output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2aa7fbea2d0e607309e315ba46eefb556163b2c8" translate="yes" xml:space="preserve">
          <source>Terminates the compressed data stream and flushes any pending compressed data to &lt;code&gt;$output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="2c65f89cb90bf010c5c15d59ad7362f6575faeff" translate="yes" xml:space="preserve">
          <source>Terms and List Operators (Leftward)</source>
          <target state="translated">Условия и список операторов (слева)</target>
        </trans-unit>
        <trans-unit id="aadfdbce37d51dbb8148884093a756d6e68d99bd" translate="yes" xml:space="preserve">
          <source>Termux</source>
          <target state="translated">Termux</target>
        </trans-unit>
        <trans-unit id="f7687808514bd6fdef254462f2ef21603ff94c5d" translate="yes" xml:space="preserve">
          <source>Ternary &lt;code&gt;&quot;?:&quot;&lt;/code&gt; is the conditional operator, just as in C. It works much like an if-then-else. If the argument before the &lt;code&gt;?&lt;/code&gt; is true, the argument before the &lt;code&gt;:&lt;/code&gt; is returned, otherwise the argument after the &lt;code&gt;:&lt;/code&gt; is returned. For example:</source>
          <target state="translated">Тернарный &lt;code&gt;&quot;?:&quot;&lt;/code&gt; - это условный оператор, как и в C. Он работает так же, как if-then-else. Если аргумент перед &lt;code&gt;?&lt;/code&gt; Правда, аргумент перед &lt;code&gt;:&lt;/code&gt; возвращается, в противном случае аргумент после &lt;code&gt;:&lt;/code&gt; возвращается. Например:</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="a606ccac095617dc9512d70db5efd42e7bb98a43" translate="yes" xml:space="preserve">
          <source>Test - provides a simple framework for writing test scripts</source>
          <target state="translated">Тест-предоставляет простую основу для написания тестовых скриптов.</target>
        </trans-unit>
        <trans-unit id="39cded9148b38cec922514bd35a2aef5469fc539" translate="yes" xml:space="preserve">
          <source>Test Status and Info</source>
          <target state="translated">Статус тестирования и информация</target>
        </trans-unit>
        <trans-unit id="0f42e18af9e42f65883381d95b6da9a9beb625ba" translate="yes" xml:space="preserve">
          <source>Test _all_ behaviors of a given operator, library, or function.</source>
          <target state="translated">Тест _all_поведения заданного оператора,библиотеки или функции.</target>
        </trans-unit>
        <trans-unit id="ccbf4ddf89827f1aef746e7810ae2a433cf06e90" translate="yes" xml:space="preserve">
          <source>Test all optional arguments.</source>
          <target state="translated">Проверьте все необязательные аргументы.</target>
        </trans-unit>
        <trans-unit id="ee2236a26189cf2bce4daa0c312f2ad998013277" translate="yes" xml:space="preserve">
          <source>Test an SV for taintedness. Use &lt;code&gt;SvTAINTED&lt;/code&gt; instead.</source>
          <target state="translated">Проверьте SV на заражение. &lt;code&gt;SvTAINTED&lt;/code&gt; этого используйте SvTAINTED .</target>
        </trans-unit>
        <trans-unit id="435f6b9009ca18e663fe202fc1240deccf2b918a" translate="yes" xml:space="preserve">
          <source>Test building utility methods</source>
          <target state="translated">Испытать методы эксплуатации зданий</target>
        </trans-unit>
        <trans-unit id="b4b87c6940ff3faed10366f7a463d3bfb89e71a4" translate="yes" xml:space="preserve">
          <source>Test control</source>
          <target state="translated">Управление испытаниями</target>
        </trans-unit>
        <trans-unit id="5f7408dbafe0232db081d945ae171586f08aae05" translate="yes" xml:space="preserve">
          <source>Test files not found under</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d741ad5424269aabb883c550c337fb9f577347" translate="yes" xml:space="preserve">
          <source>Test for Memoize expiration semantics</source>
          <target state="translated">Тест на семантику истечения срока действия Memoize</target>
        </trans-unit>
        <trans-unit id="f76975f4d894de42ed86a6b96159814a64e69414" translate="yes" xml:space="preserve">
          <source>Test for end of file.</source>
          <target state="translated">Тест на конец файла.</target>
        </trans-unit>
        <trans-unit id="79382a00ce637c0c3d356c1d16aa7f8ddce716b6" translate="yes" xml:space="preserve">
          <source>Test for the value of &amp;amp;Time::HiRes::d_hires_stat to find out whether the operating system supports subsecond file timestamps: a value larger than zero means yes. There are unfortunately no easy ways to find out whether the filesystem supports such timestamps. UNIX filesystems often do; NTFS does; FAT doesn't (FAT timestamp granularity is &lt;b&gt;two&lt;/b&gt; seconds).</source>
          <target state="translated">Проверьте значение &amp;amp; Time :: HiRes :: d_hires_stat, чтобы узнать, поддерживает ли операционная система временные метки субсекундных файлов: значение больше нуля означает да. К сожалению, нет простых способов узнать, поддерживает ли файловая система такие отметки времени. Файловые системы UNIX часто делают; NTFS делает; FAT - нет (детализация временной метки FAT составляет &lt;b&gt;две&lt;/b&gt; секунды).</target>
        </trans-unit>
        <trans-unit id="feacda2f5709bb28aab0498393394934934708d7" translate="yes" xml:space="preserve">
          <source>Test for the value of &amp;amp;Time::HiRes::d_hires_utime to find out whether the operating system supports setting subsecond file timestamps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d9cdf0f1500007619c451c5eaa7ecb15e59b66" translate="yes" xml:space="preserve">
          <source>Test if the content of an SV looks like a number (or is a number). &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt; are treated as numbers (so will not issue a non-numeric warning), even if your &lt;code&gt;atof()&lt;/code&gt; doesn't grok them. Get-magic is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f831cc3a669b4e57bff2b2ef159b4ea5dded3cc" translate="yes" xml:space="preserve">
          <source>Test if the content of an SV looks like a number (or is a number). &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt; are treated as numbers (so will not issue a non-numeric warning), even if your atof() doesn't grok them. Get-magic is ignored.</source>
          <target state="translated">Проверьте, выглядит ли содержимое SV как число (или как число). &lt;code&gt;Inf&lt;/code&gt; и &lt;code&gt;Infinity&lt;/code&gt; обрабатываются как числа (поэтому не будут выдавать нечисловые предупреждения), даже если ваш atof () не распознает их. Get-magic игнорируется.</target>
        </trans-unit>
        <trans-unit id="eff6484209621d4819416b73c20e645cef64569b" translate="yes" xml:space="preserve">
          <source>Test mode. Makes it possible to command perlbug from a pipe or file, for testing purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f13862d482c878134330e38991502bcc64e1f31" translate="yes" xml:space="preserve">
          <source>Test mode. The target address defaults to &lt;b&gt;perlbug-test@perl.org&lt;/b&gt;.</source>
          <target state="translated">Тестовый режим. Целевой адрес по умолчанию - &lt;b&gt;perlbug-test@perl.org&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="69080e5c49da5d3bba9b15a273b20b2df3903f2b" translate="yes" xml:space="preserve">
          <source>Test names</source>
          <target state="translated">Имена тестов</target>
        </trans-unit>
        <trans-unit id="06b20000ce74a97fae877b75a137b770c99da787" translate="yes" xml:space="preserve">
          <source>Test numbers out of sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df0db78620ddd32bfd4efd442e6b3f36d8261a7" translate="yes" xml:space="preserve">
          <source>Test result token.</source>
          <target state="translated">Жетон с результатами теста.</target>
        </trans-unit>
        <trans-unit id="ee151a1ef75c0ed5024755e133172ea9006bb555" translate="yes" xml:space="preserve">
          <source>Test results vary depending on your host system and your Cygwin configuration. If a test can pass in some Cygwin setup, it is always attempted and explainable test failures are documented. It is possible for Perl to pass all the tests, but it is more likely that some tests will fail for one of the reasons listed below.</source>
          <target state="translated">Результаты тестов варьируются в зависимости от хост-системы и конфигурации Cygwin.Если тест может быть пройден в некоторых настройках Cygwin,всегда предпринимаются попытки,и объяснимые ошибки теста документируются.Perl может пройти все тесты,но более вероятно,что некоторые тесты будут неудачными по одной из причин,перечисленных ниже.</target>
        </trans-unit>
        <trans-unit id="a10b429173c58a1c6dcb960c4e6c1c09b38479a1" translate="yes" xml:space="preserve">
          <source>Test results will be added to the supplied &lt;a href=&quot;TAP::Parser::Aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;. &lt;code&gt;aggregate_tests&lt;/code&gt; may be called multiple times to run several sets of tests. Multiple &lt;code&gt;Test::Harness&lt;/code&gt; instances may be used to pass results to a single aggregator so that different parts of a complex test suite may be run using different &lt;code&gt;TAP::Harness&lt;/code&gt; settings. This is useful, for example, in the case where some tests should run in parallel but others are unsuitable for parallel execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aeb2301cd878b4bea322bf5867e98635082f17a" translate="yes" xml:space="preserve">
          <source>Test results will be added to the supplied &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;. &lt;code&gt;aggregate_tests&lt;/code&gt; may be called multiple times to run several sets of tests. Multiple &lt;code&gt;Test::Harness&lt;/code&gt; instances may be used to pass results to a single aggregator so that different parts of a complex test suite may be run using different &lt;code&gt;TAP::Harness&lt;/code&gt; settings. This is useful, for example, in the case where some tests should run in parallel but others are unsuitable for parallel execution.</source>
          <target state="translated">Результаты тестирования будут добавлены в прилагаемый &lt;a href=&quot;parser/aggregator&quot;&gt;TAP :: Parser :: Aggregator&lt;/a&gt; . &lt;code&gt;aggregate_tests&lt;/code&gt; можно вызывать несколько раз для запуска нескольких наборов тестов. Несколько экземпляров &lt;code&gt;Test::Harness&lt;/code&gt; могут использоваться для передачи результатов одному агрегатору, чтобы разные части сложного набора тестов могли запускаться с использованием разных настроек &lt;code&gt;TAP::Harness&lt;/code&gt; . Это полезно, например, в случае, когда некоторые тесты должны выполняться параллельно, но другие не подходят для параллельного выполнения.</target>
        </trans-unit>
        <trans-unit id="30bf8d2a1f537e3de40966fbaca2a259bafa1326" translate="yes" xml:space="preserve">
          <source>Test return values in various contexts (boolean, scalar, list, lvalue).</source>
          <target state="translated">Тестовые возвращаемые значения в различных контекстах (булевы,скаляры,списки,lvalue).</target>
        </trans-unit>
        <trans-unit id="87b25e7182a4957634bdf28eb60aa42f52a26bbf" translate="yes" xml:space="preserve">
          <source>Test style</source>
          <target state="translated">Стиль тестирования</target>
        </trans-unit>
        <trans-unit id="5f967f7d2e1f440aeb4c91e854d76b62157077cf" translate="yes" xml:space="preserve">
          <source>Test suite</source>
          <target state="translated">Тестовый набор</target>
        </trans-unit>
        <trans-unit id="26b3f7125d4977a4c818431649628fa0924ccde1" translate="yes" xml:space="preserve">
          <source>Test testsuites that have been built with</source>
          <target state="translated">Тестовые площадки,которые были построены с помощью</target>
        </trans-unit>
        <trans-unit id="166736fddcc4133d965dff627cc8b8b46442426f" translate="yes" xml:space="preserve">
          <source>Test that a &lt;code&gt;long double&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;. Takes no arguments - the test value is hard-wired into the function (as &quot;7&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0fd920652142c713f4086b5b623b0b9e9398272" translate="yes" xml:space="preserve">
          <source>Test that a double-precision floating point number is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8f9b4911bc55fcaaec09b2bda811ea7944f490" translate="yes" xml:space="preserve">
          <source>Test that a single-precision floating point number is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b615cea701e2b923c5f71779b58c9f119e965fa" translate="yes" xml:space="preserve">
          <source>Test that an &lt;code&gt;IV&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb28175623956ac2c7f684099558f1e73fc257b6" translate="yes" xml:space="preserve">
          <source>Test that an &lt;code&gt;NV&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb348ab3a2e878a4d2162fc950e38514289fa424" translate="yes" xml:space="preserve">
          <source>Test that an &lt;code&gt;UV&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62afa7b2c53f556142fec29768d4906ba6d2d520" translate="yes" xml:space="preserve">
          <source>Test that an &lt;code&gt;int&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3320bceb2035430c2e25314087b45b576a7104" translate="yes" xml:space="preserve">
          <source>Test that an &lt;code&gt;long&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8692c5f618e42142701d067170ebb338d0f048" translate="yes" xml:space="preserve">
          <source>Test that the given &lt;code&gt;pv&lt;/code&gt; (with length &lt;code&gt;len&lt;/code&gt;) doesn't contain any internal &lt;code&gt;NUL&lt;/code&gt; characters. If it does, set &lt;code&gt;errno&lt;/code&gt; to &lt;code&gt;ENOENT&lt;/code&gt;, optionally warn using the &lt;code&gt;syscalls&lt;/code&gt; category, and return FALSE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c743b9b50bdf1cbd4320751b7b3e3e77099e55b4" translate="yes" xml:space="preserve">
          <source>Test that the given &lt;code&gt;pv&lt;/code&gt; doesn't contain any internal &lt;code&gt;NUL&lt;/code&gt; characters. If it does, set &lt;code&gt;errno&lt;/code&gt; to ENOENT, optionally warn, and return FALSE.</source>
          <target state="translated">Проверьте, что данный &lt;code&gt;pv&lt;/code&gt; не содержит внутренних символов &lt;code&gt;NUL&lt;/code&gt; . Если это так, установите для &lt;code&gt;errno&lt;/code&gt; значение ENOENT, при необходимости предупредите и верните FALSE.</target>
        </trans-unit>
        <trans-unit id="935dc1f2c1449831bdafed1f538dec539127ac6a" translate="yes" xml:space="preserve">
          <source>Test the manual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e7a9e15ab34cf742c942e50d6aff3c06043d08" translate="yes" xml:space="preserve">
          <source>Test the perl C API</source>
          <target state="translated">Тестировать perl C API</target>
        </trans-unit>
        <trans-unit id="1cda04f681171086e794af0b5d23d5d5ea0b6cdd" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if the first, &lt;code&gt;s1&lt;/code&gt;, is greater than or equal to the second, &lt;code&gt;s2&lt;/code&gt;. Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a2e1515505333499048cba86227c80971a3aef" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if the first, &lt;code&gt;s1&lt;/code&gt;, is greater than the second, &lt;code&gt;s2&lt;/code&gt;. Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7397a89d009fad58a08d3b40bff3d58047b11288" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if the first, &lt;code&gt;s1&lt;/code&gt;, is less than or equal to the second, &lt;code&gt;s2&lt;/code&gt;. Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a4b766ad17990b550cf6d6e46e8c56bae5a196" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if the first, &lt;code&gt;s1&lt;/code&gt;, is less than the second, &lt;code&gt;s2&lt;/code&gt;. Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67520e6cf1cb4f8414cc48c33fe0e43d736ba00" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if they are different. Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07ce0712b3cc2e909c79e8b8e4be508ac97e959" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if they are different. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0d79dd5feda7353def275a91909ef78bf53ffc" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if they are equal. Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b1fdf525381a678ac204c899e59ed1ee66b437b" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if they are equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c712f8219cebd35791babf9ed3b703a8351ea8b" translate="yes" xml:space="preserve">
          <source>Test two buffers (which may contain embedded &lt;code&gt;NUL&lt;/code&gt; characters, to see if they are equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns zero if equal, or non-zero if non-equal.</source>
          <target state="translated">Проверьте два буфера (которые могут содержать встроенные символы &lt;code&gt;NUL&lt;/code&gt; , чтобы убедиться, что они равны. Параметр &lt;code&gt;len&lt;/code&gt; указывает количество байтов для сравнения. Возвращает ноль, если они равны, или ненулевые, если они не равны.</target>
        </trans-unit>
        <trans-unit id="aa66181e4ff9ebce0ccdea0d81358cf4b122fa39" translate="yes" xml:space="preserve">
          <source>Test two buffers (which may contain embedded &lt;code&gt;NUL&lt;/code&gt; characters, to see if they are not equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns zero if non-equal, or non-zero if equal.</source>
          <target state="translated">Проверьте два буфера (которые могут содержать встроенные символы &lt;code&gt;NUL&lt;/code&gt; , чтобы убедиться, что они не равны. Параметр &lt;code&gt;len&lt;/code&gt; указывает количество байтов для сравнения. Возвращает ноль, если они не равны, или ненулевые, если они равны.</target>
        </trans-unit>
        <trans-unit id="7588b6c061b826b0f7a0fe2738aa760c611f4b7d" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is greater than or equal to the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">Проверьте две строки, чтобы убедиться, что первая, &lt;code&gt;s1&lt;/code&gt; , больше или равна второй, &lt;code&gt;s2&lt;/code&gt; . Возвращает истину или ложь.</target>
        </trans-unit>
        <trans-unit id="960024a856f809dce4509cd90004cd8da3ca6ba1" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is greater than the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">Проверьте две строки, чтобы убедиться, что первая, &lt;code&gt;s1&lt;/code&gt; , больше, чем вторая, &lt;code&gt;s2&lt;/code&gt; . Возвращает истину или ложь.</target>
        </trans-unit>
        <trans-unit id="ee2367cd81142917d4f07c520dafb2f8d390eb84" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is less than or equal to the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">Проверьте две строки, чтобы убедиться, что первая, &lt;code&gt;s1&lt;/code&gt; , меньше или равна второй, &lt;code&gt;s2&lt;/code&gt; . Возвращает истину или ложь.</target>
        </trans-unit>
        <trans-unit id="57ddc2e399365a286280a07fe9ed50d6bfa9604c" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is less than the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">Проверьте две строки, чтобы убедиться, что первая, &lt;code&gt;s1&lt;/code&gt; , меньше второй, &lt;code&gt;s2&lt;/code&gt; . Возвращает истину или ложь.</target>
        </trans-unit>
        <trans-unit id="237ab8c0b99038db78a7c54fb0bfdbb2ab764cbb" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are different. Returns true or false.</source>
          <target state="translated">Протестируйте две строки,чтобы проверить,не отличаются ли они друг от друга.Возвращает правду или ложь.</target>
        </trans-unit>
        <trans-unit id="fb2934866aafd7ff65638c4caf1d299244cb4e65" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are different. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt; ).</source>
          <target state="translated">Проверьте две строки, чтобы убедиться, что они разные. Параметр &lt;code&gt;len&lt;/code&gt; указывает количество байтов для сравнения. Возвращает истину или ложь. (Обертка для &lt;code&gt;strncmp&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="44326cf741b4ea53c3861e1c04224785c2787564" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are equal. Returns true or false.</source>
          <target state="translated">Протестируйте две строки,чтобы убедиться,что они равны.Возвращает правду или ложь.</target>
        </trans-unit>
        <trans-unit id="f0b60c1b2d7c48750566bd13231437cae4745024" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt; ).</source>
          <target state="translated">Проверьте две строки, чтобы убедиться, что они равны. Параметр &lt;code&gt;len&lt;/code&gt; указывает количество байтов для сравнения. Возвращает истину или ложь. (Обертка для &lt;code&gt;strncmp&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5ea556cadafc54f605e5e63d55b8b6c8576ae334" translate="yes" xml:space="preserve">
          <source>Test your change</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368b5822e8d2728701a3f8f8b37d0363f9573092" translate="yes" xml:space="preserve">
          <source>Test.pl</source>
          <target state="translated">Test.pl</target>
        </trans-unit>
        <trans-unit id="2b84f621c0fd4ba8bd514c5c43ab9a897c8c014e" translate="yes" xml:space="preserve">
          <source>Test2</source>
          <target state="translated">Test2</target>
        </trans-unit>
        <trans-unit id="eda8c363c27f97460f067dbb6abdfc09dc29c0c8" translate="yes" xml:space="preserve">
          <source>Test2 - Framework for writing test tools that all work together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7914da6063f1d3eee08e8be56ecff6a038d13b7" translate="yes" xml:space="preserve">
          <source>Test2 based tools produce events which get passed through a processing system before being output by a formatter. This event system allows for rich plugin and extension support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398a86dff1e296880e5d0b4d74bd2ff1122d7b20" translate="yes" xml:space="preserve">
          <source>Test2 is a new testing framework produced by forking &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;, completely refactoring it, adding many new features and capabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ec663be5e2702eeee07b6691bdb59dd7f152b6" translate="yes" xml:space="preserve">
          <source>Test2 support for forking and threading can be turned on using &lt;a href=&quot;Test2::IPC&quot;&gt;Test2::IPC&lt;/a&gt;. Once turned on threading and forking operate sanely and work as one would expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85c00e9e770edcdcec782d15abea07abe8e90329" translate="yes" xml:space="preserve">
          <source>Test2 uses an &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2::API::Context&lt;/a&gt; object to track filename, line number, and tool details. This object greatly simplifies tracking for where errors should be reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e285ff9d0222e729d45ac11b2fa114520dbd2f49" translate="yes" xml:space="preserve">
          <source>Test2::</source>
          <target state="translated">Test2::</target>
        </trans-unit>
        <trans-unit id="aed608f477d17069118048380cb834a46100702e" translate="yes" xml:space="preserve">
          <source>Test2::API</source>
          <target state="translated">Test2::API</target>
        </trans-unit>
        <trans-unit id="b64e44401f91aa4335033516e0e358ab2918bb91" translate="yes" xml:space="preserve">
          <source>Test2::API - Primary interface for writing Test2 based testing tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd3f4fa6597ae4905596818a71dd6f194f5a192" translate="yes" xml:space="preserve">
          <source>Test2::API::</source>
          <target state="translated">Test2::API::</target>
        </trans-unit>
        <trans-unit id="823aa9e1a97b79904e6a3b276b63d70ac1eaf933" translate="yes" xml:space="preserve">
          <source>Test2::API::Breakage</source>
          <target state="translated">Test2::API::Breakage</target>
        </trans-unit>
        <trans-unit id="0861d9570e8c51fbb90b7b320182f504e2357c33" translate="yes" xml:space="preserve">
          <source>Test2::API::Breakage - What breaks at what version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c2ccf18a794e7b19dd498228e83500720827311" translate="yes" xml:space="preserve">
          <source>Test2::API::Context</source>
          <target state="translated">Test2::API::Context</target>
        </trans-unit>
        <trans-unit id="6392ed68dbc48f41c56e98e3b78066ea6fd6f6e7" translate="yes" xml:space="preserve">
          <source>Test2::API::Context - Object to represent a testing context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8928930b42eb0f1f15f9f1786db57584d36450f7" translate="yes" xml:space="preserve">
          <source>Test2::API::Instance</source>
          <target state="translated">Test2::API::Instance</target>
        </trans-unit>
        <trans-unit id="e9d71ad619dcb1f03cb3d047e079b7b873049690" translate="yes" xml:space="preserve">
          <source>Test2::API::Instance - Object used by Test2::API under the hood</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4ef69b915bbedef7a6aa2e3dfda1acb8e00023" translate="yes" xml:space="preserve">
          <source>Test2::API::Stack</source>
          <target state="translated">Test2::API::Stack</target>
        </trans-unit>
        <trans-unit id="db39e7f918f59026c6ba1b1479540073a74dbe65" translate="yes" xml:space="preserve">
          <source>Test2::API::Stack - Object to manage a stack of &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt; instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4066ca94daf4532238cf36f016b1d069a5ab7793" translate="yes" xml:space="preserve">
          <source>Test2::Bundle::</source>
          <target state="translated">Test2::Bundle::</target>
        </trans-unit>
        <trans-unit id="f57cc1ec8f9d37fc1b16d1973aeb44165f00421d" translate="yes" xml:space="preserve">
          <source>Test2::Event</source>
          <target state="translated">Test2::Event</target>
        </trans-unit>
        <trans-unit id="c7ab55a64912c0845c79bb212cfd817d09025066" translate="yes" xml:space="preserve">
          <source>Test2::Event - Base class for events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a208964b54ed95543dd315c416ecedfe690fe40" translate="yes" xml:space="preserve">
          <source>Test2::Event::</source>
          <target state="translated">Test2::Event::</target>
        </trans-unit>
        <trans-unit id="222da9b43da2c10e075571dbaaecb7acb8971f5c" translate="yes" xml:space="preserve">
          <source>Test2::Event::Bail</source>
          <target state="translated">Test2::Event::Bail</target>
        </trans-unit>
        <trans-unit id="c6639f4ee1d50a38a83d0aa08dbfdceab90fd9da" translate="yes" xml:space="preserve">
          <source>Test2::Event::Bail - Bailout!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa3e3ba5854331919870c8337d909e52e4a076b8" translate="yes" xml:space="preserve">
          <source>Test2::Event::Diag</source>
          <target state="translated">Test2::Event::Diag</target>
        </trans-unit>
        <trans-unit id="dccbb51341c8ea96ae5a977ee141eea8bc86dbe4" translate="yes" xml:space="preserve">
          <source>Test2::Event::Diag - Diag event type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8ebae9408bcb7bc43915bb7a2b06de25a46dec" translate="yes" xml:space="preserve">
          <source>Test2::Event::Encoding</source>
          <target state="translated">Test2::Event::Encoding</target>
        </trans-unit>
        <trans-unit id="38074f2997521b7c59670e4af13f02f3260f0037" translate="yes" xml:space="preserve">
          <source>Test2::Event::Encoding - Set the encoding for the output stream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75cdd65e18d257d6b093ce75ab07ea83b0a1f0f3" translate="yes" xml:space="preserve">
          <source>Test2::Event::Exception</source>
          <target state="translated">Test2::Event::Exception</target>
        </trans-unit>
        <trans-unit id="4701028ce3df2eea964013cdb647d8bf16f01e39" translate="yes" xml:space="preserve">
          <source>Test2::Event::Exception - Exception event</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213b2187e0041e341c0be41fb190191567647040" translate="yes" xml:space="preserve">
          <source>Test2::Event::Fail</source>
          <target state="translated">Test2::Event::Fail</target>
        </trans-unit>
        <trans-unit id="aa94f0e56a9c0ead034b1b33c0cc1605dfbd21ef" translate="yes" xml:space="preserve">
          <source>Test2::Event::Fail - Event for a simple failed assertion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe59b86d85778b040125f222a3d01e10a712a40" translate="yes" xml:space="preserve">
          <source>Test2::Event::Generic</source>
          <target state="translated">Test2::Event::Generic</target>
        </trans-unit>
        <trans-unit id="dd44b53a7b2f21504f4c3cdcdd24bf5b428034bb" translate="yes" xml:space="preserve">
          <source>Test2::Event::Generic - Generic event type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5232466de0a182c8ac4368fe4af490d4cec125c5" translate="yes" xml:space="preserve">
          <source>Test2::Event::Note</source>
          <target state="translated">Test2::Event::Note</target>
        </trans-unit>
        <trans-unit id="2110f8724d8546b8c1bc6d82d78c7a0be5217629" translate="yes" xml:space="preserve">
          <source>Test2::Event::Note - Note event type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413b4924db2b9633fc53631d16b5f8d56d2a8ec5" translate="yes" xml:space="preserve">
          <source>Test2::Event::Ok</source>
          <target state="translated">Test2::Event::Ok</target>
        </trans-unit>
        <trans-unit id="d26917c93a4a1ca59d02bfdcd1ca1e882315f897" translate="yes" xml:space="preserve">
          <source>Test2::Event::Ok - Ok event type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8166088489a5bc91739c87f976810c6ecf6646a" translate="yes" xml:space="preserve">
          <source>Test2::Event::Pass</source>
          <target state="translated">Test2::Event::Pass</target>
        </trans-unit>
        <trans-unit id="e2c3f6ccdfd606b354f26fb929f5aa4379851e17" translate="yes" xml:space="preserve">
          <source>Test2::Event::Pass - Event for a simple passing assertion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2baa0f71c7bde397357a6a05ab0a4b2170b6e32a" translate="yes" xml:space="preserve">
          <source>Test2::Event::Plan</source>
          <target state="translated">Test2::Event::Plan</target>
        </trans-unit>
        <trans-unit id="333336f9de46850c8a8c5e170a7fcf9c57fb3486" translate="yes" xml:space="preserve">
          <source>Test2::Event::Plan - The event of a plan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f279cfd9072e8f5890e09755a89a14ab46a9338" translate="yes" xml:space="preserve">
          <source>Test2::Event::Skip</source>
          <target state="translated">Test2::Event::Skip</target>
        </trans-unit>
        <trans-unit id="523d29ebe5be339549d30bbd996c98332c98058b" translate="yes" xml:space="preserve">
          <source>Test2::Event::Skip - Skip event type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0daedf830e1bee09f664aaa317a6afed11518990" translate="yes" xml:space="preserve">
          <source>Test2::Event::Subtest</source>
          <target state="translated">Test2::Event::Subtest</target>
        </trans-unit>
        <trans-unit id="f8e158cbc6534e5249fe882a4e9a0da5cc30a140" translate="yes" xml:space="preserve">
          <source>Test2::Event::Subtest - Event for subtest types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb06c64fdc632db67dc9bffd6c588a6a624ce76a" translate="yes" xml:space="preserve">
          <source>Test2::Event::TAP::Version</source>
          <target state="translated">Test2::Event::TAP::Version</target>
        </trans-unit>
        <trans-unit id="1c62f8d2de6366a8d87dd20fc3501e28352856dd" translate="yes" xml:space="preserve">
          <source>Test2::Event::TAP::Version - Event for TAP version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adbc479c6c5dbbd07debac51d2e47f71debe301b" translate="yes" xml:space="preserve">
          <source>Test2::Event::V2</source>
          <target state="translated">Test2::Event::V2</target>
        </trans-unit>
        <trans-unit id="5d24bd5feb73d8653a7b629d67988cafd589322b" translate="yes" xml:space="preserve">
          <source>Test2::Event::V2 - Second generation event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e16dd367cf4872654a6dce5ce401595d087cd64a" translate="yes" xml:space="preserve">
          <source>Test2::Event::Waiting</source>
          <target state="translated">Test2::Event::Waiting</target>
        </trans-unit>
        <trans-unit id="db005487809f2d8acd788bd2d2dc8b6a91556697" translate="yes" xml:space="preserve">
          <source>Test2::Event::Waiting - Tell all procs/threads it is time to be done</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43b423903d35c0f3149a55b5aa7482144c6e821" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet</source>
          <target state="translated">Test2::EventFacet</target>
        </trans-unit>
        <trans-unit id="c11dcded6ce506a6e2d04a5f680ab6b7c80a91eb" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet - Base class for all event facets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d94b66b18c3d8c49c0f173453f4e670dd80f895" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::About</source>
          <target state="translated">Test2::EventFacet::About</target>
        </trans-unit>
        <trans-unit id="a7424501dd01bcb804f3da012e536a50271a2499" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::About - Facet with event details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7721bca6966ae188d61ed02c3583a52be94f3308" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Amnesty</source>
          <target state="translated">Test2::EventFacet::Amnesty</target>
        </trans-unit>
        <trans-unit id="75a05106886d311b44b3bdfccd8778e0c3f3f498" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Amnesty - Facet for assertion amnesty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0d1e162c4b6553c9b71ed64f5b8b1f9ed0917c" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Assert</source>
          <target state="translated">Test2::EventFacet::Assert</target>
        </trans-unit>
        <trans-unit id="7920cf94c19ae0f16a489d74a6da88912a69561f" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Assert - Facet representing an assertion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0154d814220406d368d99e18a174a4dddfb3bcd5" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Control</source>
          <target state="translated">Test2::EventFacet::Control</target>
        </trans-unit>
        <trans-unit id="5bcc831f6a254f05cbb0f0fadb63ba1c90548e4a" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Control - Facet for hub actions and behaviors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b62ade42351eb9bb31e48e3b2e93713fe6baeef8" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Error</source>
          <target state="translated">Test2::EventFacet::Error</target>
        </trans-unit>
        <trans-unit id="94ed284eb9c51ff089cc0a134463bf0d7a5d9b9b" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Error - Facet for errors that need to be shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0f76e55accd6e82edf385f2c62f6f3fe2ff466" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Hub</source>
          <target state="translated">Test2::EventFacet::Hub</target>
        </trans-unit>
        <trans-unit id="ccf5d98be7eb2630ce4c2c621f114c26ae3ab3b1" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Hub - Facet for the hubs an event passes through.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ac4e48a99349567b0a89ac444d73d09d49cdd1" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Info</source>
          <target state="translated">Test2::EventFacet::Info</target>
        </trans-unit>
        <trans-unit id="531a04a3d9a3002254fb82228c4742a0058169ae" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Info - Facet for information a developer might care about.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7657cf6e0d3cbe826429bd19cce6329342e8371e" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Info::Table</source>
          <target state="translated">Test2::EventFacet::Info::Table</target>
        </trans-unit>
        <trans-unit id="919c466811c6c1ce82b3d1a77373a5994bc4ad1d" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Info::Table - Intermediary representation of a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e10762a18172dac09cb1485390bf5a8c468e654" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Meta</source>
          <target state="translated">Test2::EventFacet::Meta</target>
        </trans-unit>
        <trans-unit id="15764a4129b9ed520f0a3054a182ad077401eb37" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Meta - Facet for meta-data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ba28b1fef317b322342598dd7b5b1f2a0bfed2" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Parent</source>
          <target state="translated">Test2::EventFacet::Parent</target>
        </trans-unit>
        <trans-unit id="fc580dac3b702094a3a37054e781da56753a8202" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Parent - Facet for events contains other events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f017f4ef4b9f563bbf579d69dd0b07d01d083216" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Plan</source>
          <target state="translated">Test2::EventFacet::Plan</target>
        </trans-unit>
        <trans-unit id="1b853027bef935f244330f0dd4212616d550dd50" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Plan - Facet for setting the plan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5beff3ccc1dfe7e21a8d1577127506388549038" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Render</source>
          <target state="translated">Test2::EventFacet::Render</target>
        </trans-unit>
        <trans-unit id="8fdb0b599c005170ba486c3ab26ed301b039dad4" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Render - Facet that dictates how to render an event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f454a15df1938741674595a2355fd8747d3246c4" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Trace</source>
          <target state="translated">Test2::EventFacet::Trace</target>
        </trans-unit>
        <trans-unit id="68b35a88e0341af14e6394c735722451fceca859" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Trace - Debug information for events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22810101357ee04450379aa51c30db96603d1bc0" translate="yes" xml:space="preserve">
          <source>Test2::Formatter</source>
          <target state="translated">Test2::Formatter</target>
        </trans-unit>
        <trans-unit id="24090f00c8f368b00c6a6e3049b282ad6483fd26" translate="yes" xml:space="preserve">
          <source>Test2::Formatter - Namespace for formatters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d7ad9843e47802da1064f10a6ed0f941b4c6996" translate="yes" xml:space="preserve">
          <source>Test2::Formatter::</source>
          <target state="translated">Test2::Formatter::</target>
        </trans-unit>
        <trans-unit id="d8aebf053e28ed7412794daf98128ef12f654d34" translate="yes" xml:space="preserve">
          <source>Test2::Formatter::TAP</source>
          <target state="translated">Test2::Formatter::TAP</target>
        </trans-unit>
        <trans-unit id="46b4d5b6e41ec7c63f10f2b81b8d25b6ad48c467" translate="yes" xml:space="preserve">
          <source>Test2::Formatter::TAP - Standard TAP formatter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec1636c628a393391f1bd9b891d1aac73f6842e" translate="yes" xml:space="preserve">
          <source>Test2::Hub</source>
          <target state="translated">Test2::Hub</target>
        </trans-unit>
        <trans-unit id="9ef2e13502d5f0974e131f5f83a726361d1b54dd" translate="yes" xml:space="preserve">
          <source>Test2::Hub - The conduit through which all events flow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17e83b628262986793f10b10b71b5803fa827b55" translate="yes" xml:space="preserve">
          <source>Test2::Hub::</source>
          <target state="translated">Test2::Hub::</target>
        </trans-unit>
        <trans-unit id="d987d21918e08ef541654a1bdfad5ccaedf59e4f" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Interceptor</source>
          <target state="translated">Test2::Hub::Interceptor</target>
        </trans-unit>
        <trans-unit id="259de78dc48b81a26c6c8f30e8cd739349d3c52a" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Interceptor - Hub used by interceptor to grab results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bfea7d0c04ab6a462bbac2592d6b16be7ef2d79" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Interceptor::Terminator</source>
          <target state="translated">Test2::Hub::Interceptor::Terminator</target>
        </trans-unit>
        <trans-unit id="060da97eee8500d95c5711415f3dc7a4d015f4e9" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Interceptor::Terminator - Exception class used by Test2::Hub::Interceptor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3808bc674ba623811b11d43abef5d54200006dc8" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Subtest</source>
          <target state="translated">Test2::Hub::Subtest</target>
        </trans-unit>
        <trans-unit id="daea2dc40ad5baee611aefac07d76a5653258a74" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Subtest - Hub used by subtests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8f1da2d2d8e1dfdea6539c7c3b6cde2e255e80" translate="yes" xml:space="preserve">
          <source>Test2::IPC</source>
          <target state="translated">Test2::IPC</target>
        </trans-unit>
        <trans-unit id="259b7962c108b108b99848b7164604ace25b603c" translate="yes" xml:space="preserve">
          <source>Test2::IPC - Turn on IPC for threading or forking support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bae70236953a3ba88d368a2555897a3a683c900" translate="yes" xml:space="preserve">
          <source>Test2::IPC::</source>
          <target state="translated">Test2::IPC::</target>
        </trans-unit>
        <trans-unit id="2aa0e1ea9908aa1517ccfba9e9ebdec9f7fd42a9" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver</source>
          <target state="translated">Test2::IPC::Driver</target>
        </trans-unit>
        <trans-unit id="e89eb8d9a5b88689747eb6772d8891a3419ee002" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver - Base class for Test2 IPC drivers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa014e96987947baf8aa2b996530d5e78494607" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver has an &lt;code&gt;import()&lt;/code&gt; method. All drivers inherit this import method. This import method registers the driver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6247baaa37b5aa0c0b858ebf17f525faa50a3a74" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver::</source>
          <target state="translated">Test2::IPC::Driver::</target>
        </trans-unit>
        <trans-unit id="df1632079981d93c731c27fbf0953b8c0110780f" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver::Files</source>
          <target state="translated">Test2::IPC::Driver::Files</target>
        </trans-unit>
        <trans-unit id="d766b8fd7d9bfdba9a657a1322fd6250e8131728" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver::Files - Temp dir + Files concurrency model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b37bcccaea4a2ac8fe8762dc5b314baa0c51f3" translate="yes" xml:space="preserve">
          <source>Test2::Plugin::</source>
          <target state="translated">Test2::Plugin::</target>
        </trans-unit>
        <trans-unit id="d68f31cbce13d814ae88248b74be13195971bcb1" translate="yes" xml:space="preserve">
          <source>Test2::Require::</source>
          <target state="translated">Test2::Require::</target>
        </trans-unit>
        <trans-unit id="92e3f4464ca08722bdba5e6448503ce92bb9a7b7" translate="yes" xml:space="preserve">
          <source>Test2::Tools::</source>
          <target state="translated">Test2::Tools::</target>
        </trans-unit>
        <trans-unit id="9f1a4ef48602a8e2128f3a0e8099a06fc4b66142" translate="yes" xml:space="preserve">
          <source>Test2::Tools::Tiny</source>
          <target state="translated">Test2::Tools::Tiny</target>
        </trans-unit>
        <trans-unit id="79dcd377299ffd1fe20b0bcd73f822a0e9ace962" translate="yes" xml:space="preserve">
          <source>Test2::Tools::Tiny - Tiny set of tools for unfortunate souls who cannot use &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e2aa276cb0ac9a0d3011cd620cb67dae65f37b" translate="yes" xml:space="preserve">
          <source>Test2::Transition</source>
          <target state="translated">Test2::Transition</target>
        </trans-unit>
        <trans-unit id="c87fd265441b37b65c97051a7a8d33c3d3df3323" translate="yes" xml:space="preserve">
          <source>Test2::Transition - Transition notes when upgrading to Test2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e290a0acf731a8e4ae28c48d463af20b82b5a396" translate="yes" xml:space="preserve">
          <source>Test2::Util</source>
          <target state="translated">Test2::Util</target>
        </trans-unit>
        <trans-unit id="9916e2fd617bea077d82a5dd41a45672a41cb8fe" translate="yes" xml:space="preserve">
          <source>Test2::Util - Tools used by Test2 and friends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6eb9596151fedd72d3d41a6e72618282af596f" translate="yes" xml:space="preserve">
          <source>Test2::Util::</source>
          <target state="translated">Test2::Util::</target>
        </trans-unit>
        <trans-unit id="d73a9b09244115670914ff2509686dc192be586b" translate="yes" xml:space="preserve">
          <source>Test2::Util::ExternalMeta</source>
          <target state="translated">Test2::Util::ExternalMeta</target>
        </trans-unit>
        <trans-unit id="4ce376298fd6e6528e5f02c77d1d3b4e0a46cece" translate="yes" xml:space="preserve">
          <source>Test2::Util::ExternalMeta - Allow third party tools to safely attach meta-data to your instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7604014ee8769c4f1c915fbdad0d5f25e9283637" translate="yes" xml:space="preserve">
          <source>Test2::Util::Facets2Legacy</source>
          <target state="translated">Test2::Util::Facets2Legacy</target>
        </trans-unit>
        <trans-unit id="8247e29b1a8250a4ea6c8a5f5a060d7f0399d878" translate="yes" xml:space="preserve">
          <source>Test2::Util::Facets2Legacy - Convert facet data to the legacy event API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0178a14e7a539df0e8eac67b9f265a91905f03e7" translate="yes" xml:space="preserve">
          <source>Test2::Util::HashBase</source>
          <target state="translated">Test2::Util::HashBase</target>
        </trans-unit>
        <trans-unit id="e3d53ed10a22c3962563aa98b744234fa941f302" translate="yes" xml:space="preserve">
          <source>Test2::Util::HashBase - Build hash based classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304c4e0ff5d5cb770757f774f08ee2ed78611096" translate="yes" xml:space="preserve">
          <source>Test2::Util::HashBase provides a function for retrieving a list of attributes for an Test2::Util::HashBase class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df7257ba0ff26dcc04c2983cb8974045fd2c82f" translate="yes" xml:space="preserve">
          <source>Test2::Util::Trace</source>
          <target state="translated">Test2::Util::Trace</target>
        </trans-unit>
        <trans-unit id="30e52b1d2e0031f38bdbbe2f1f65a20ef1bbc1b0" translate="yes" xml:space="preserve">
          <source>Test2::Util::Trace - Legacy wrapper fro &lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2::EventFacet::Trace&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2534f8dc09bc938850916623cc51a245fb3b04e8" translate="yes" xml:space="preserve">
          <source>Test::Able</source>
          <target state="translated">Test::Able</target>
        </trans-unit>
        <trans-unit id="1136a495270cb45dd3267352c039b37399d8bfdd" translate="yes" xml:space="preserve">
          <source>Test::Aggregate</source>
          <target state="translated">Test::Aggregate</target>
        </trans-unit>
        <trans-unit id="193904736b8940fdc2ba17861b0cc502cad2d12e" translate="yes" xml:space="preserve">
          <source>Test::Builder</source>
          <target state="translated">Test::Builder</target>
        </trans-unit>
        <trans-unit id="ab9974f668e2c6c0ffc2992746669dd361b94a4d" translate="yes" xml:space="preserve">
          <source>Test::Builder - Backend for building test libraries</source>
          <target state="translated">Тест::Builder-Бэкэнд для создания тестовых библиотек</target>
        </trans-unit>
        <trans-unit id="5111b242105d59084cb31e09df1b0f811c5f66e6" translate="yes" xml:space="preserve">
          <source>Test::Builder assumed everything would end up as TAP. Test2 makes no such assumption. Test2 provides ways for you to specify alternative and custom formatters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b54af1fc0cfa765b71e78e4e18039fd43150ca" translate="yes" xml:space="preserve">
          <source>Test::Builder is only thread-aware if threads.pm is loaded</source>
          <target state="translated">Test::Builder только если threads.pm загружен.</target>
        </trans-unit>
        <trans-unit id="882498aa0deee0eaf2786e1c013e62fc64bca99d" translate="yes" xml:space="preserve">
          <source>Test::Builder only provided a handful of methods for generating lines of TAP. Test2 took inventory of everything people were doing with Test::Builder that required hacking it up. Test2 made public API functions for nearly all the desired functionality people didn't previously have.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f281cea5cb958fbaba27c76fd1089904c4d2e8" translate="yes" xml:space="preserve">
          <source>Test::Builder subclass of Test2::Event::Diag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e1fd996c21804da41e7fd365d9b5baae50ea4e" translate="yes" xml:space="preserve">
          <source>Test::Builder subclass of Test2::Formatter::TAP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49fdf2299317bf9d9dff7fce116cd0d0e8a3c2b" translate="yes" xml:space="preserve">
          <source>Test::Builder.</source>
          <target state="translated">Test::Builder.</target>
        </trans-unit>
        <trans-unit id="79c6ceab8e308a67e42d8cf4c5b83ab3491afc98" translate="yes" xml:space="preserve">
          <source>Test::Builder1.5/2 conditionals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b68144843ad4490acc1cceea81edee533ae15a" translate="yes" xml:space="preserve">
          <source>Test::Builder::Clutch</source>
          <target state="translated">Test::Builder::Clutch</target>
        </trans-unit>
        <trans-unit id="c2aadab602bd18d0f63c1096df14d2661c5c645e" translate="yes" xml:space="preserve">
          <source>Test::Builder::Formatter</source>
          <target state="translated">Test::Builder::Formatter</target>
        </trans-unit>
        <trans-unit id="b65d47cb23a2aae086b24a276b41605a5607bc8a" translate="yes" xml:space="preserve">
          <source>Test::Builder::Formatter - Test::Builder subclass of Test2::Formatter::TAP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a921037b78151ec674b9e8b2042772f638e1ae3" translate="yes" xml:space="preserve">
          <source>Test::Builder::IO::Scalar</source>
          <target state="translated">Test::Builder::IO::Scalar</target>
        </trans-unit>
        <trans-unit id="8598b4873ed01a8a8a65021f790976f5909cde97" translate="yes" xml:space="preserve">
          <source>Test::Builder::IO::Scalar - A copy of IO::Scalar for Test::Builder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a007e7488b132a0e9d1aa8009a01ac991651ac14" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module</source>
          <target state="translated">Test::Builder::Module</target>
        </trans-unit>
        <trans-unit id="3ed23c6a90bd99e62a3c52acce5c4439a1d74951" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module - Base class for test modules</source>
          <target state="translated">Тест::Builder::Module-Базовый класс для тестовых модулей</target>
        </trans-unit>
        <trans-unit id="cc216e7a80df8491f0b761fca22c7d52cff231ca" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module is a subclass of &lt;a href=&quot;../../exporter&quot;&gt;Exporter&lt;/a&gt; which means your module is also a subclass of Exporter. @EXPORT, @EXPORT_OK, etc... all act normally.</source>
          <target state="translated">Test :: Builder :: Module - это подкласс &lt;a href=&quot;../../exporter&quot;&gt;Exporter,&lt;/a&gt; что означает, что ваш модуль также является подклассом Exporter. @EXPORT, @EXPORT_OK и т. Д. Все работают нормально.</target>
        </trans-unit>
        <trans-unit id="beddeafc2200fcc739f218f443081251d72a00e9" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module is a subclass of &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; which means your module is also a subclass of Exporter. @EXPORT, @EXPORT_OK, etc... all act normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59c85c34391e2a59a9a1aebf543278d41eaede1e" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module provides an &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; method which acts in the same basic way as &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt;'s, setting the plan and controlling exporting of functions and variables. This allows your module to set the plan independent of &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt;.</source>
          <target state="translated">Test :: Builder :: Module предоставляет метод &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; который действует так же, как и метод &lt;a href=&quot;../more&quot;&gt;Test :: More&lt;/a&gt; , устанавливая план и контролируя экспорт функций и переменных. Это позволяет вашему модулю устанавливать план независимо от &lt;a href=&quot;../more&quot;&gt;Test :: More&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f6c2ece6f56adee6a05f3b497d85cec7b976b9a" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module provides an &lt;code&gt;import()&lt;/code&gt; method which acts in the same basic way as &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;'s, setting the plan and controlling exporting of functions and variables. This allows your module to set the plan independent of &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1860964402a6fbbf4a8ee83b8ff81c101e436168" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module provides some methods of getting at the underlying Test::Builder object.</source>
          <target state="translated">Модуль Test::Builder::предоставляет некоторые методы получения базового объекта Test::Builder.</target>
        </trans-unit>
        <trans-unit id="dfe8750e469aab07b5d8dadae68c198e1a6ea505" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester</source>
          <target state="translated">Test::Builder::Tester</target>
        </trans-unit>
        <trans-unit id="99afed4f8190d67c7ca9fceff64feafac8a2c27f" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester - test testsuites that have been built with Test::Builder</source>
          <target state="translated">Test::Builder::Tester-тестовые наборы,которые были построены с помощью Test::Builder</target>
        </trans-unit>
        <trans-unit id="a5daa4b264c9be76b3e43bc5b6e1208a2a0f3088" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester does not handle plans well. It has never done anything special with plans. This means that plans from outside Test::Builder::Tester will effect Test::Builder::Tester, worse plans when using Test::Builder::Tester will effect overall testing. At this point there are no plans to fix this bug as people have come to depend on it, and Test::Builder::Tester is now discouraged in favor of &lt;code&gt;Test2::API::intercept()&lt;/code&gt;. See &lt;a href=&quot;https://github.com/Test-More/test-more/issues/667&quot;&gt;https://github.com/Test-More/test-more/issues/667&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b5ba34db69a6e0e7e2db842da88dc2874db319" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester::Color</source>
          <target state="translated">Test::Builder::Tester::Color</target>
        </trans-unit>
        <trans-unit id="2d500c7bf4e510506ebc84f5c768b05a6cccce1c" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester::Color - turn on colour in Test::Builder::Tester</source>
          <target state="translated">Тест::Строитель::Тестер::Цвет-включение цвета Тест::Строитель::Тестер</target>
        </trans-unit>
        <trans-unit id="53667487e4c182cc6c194b110fdd4bf8602e9ca2" translate="yes" xml:space="preserve">
          <source>Test::Builder::TodoDiag</source>
          <target state="translated">Test::Builder::TodoDiag</target>
        </trans-unit>
        <trans-unit id="3002af054c03a9c23ba9d877d3c154ef71a2f214" translate="yes" xml:space="preserve">
          <source>Test::Builder::TodoDiag - Test::Builder subclass of Test2::Event::Diag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c62394a96db894e9826fa86cbfb9739d5ef32c0" translate="yes" xml:space="preserve">
          <source>Test::DBIx::Class::Schema</source>
          <target state="translated">Test::DBIx::Class::Schema</target>
        </trans-unit>
        <trans-unit id="5b5ccd27092122c879d215a96c52ebaf02aa4964" translate="yes" xml:space="preserve">
          <source>Test::Dist::VersionSync</source>
          <target state="translated">Test::Dist::VersionSync</target>
        </trans-unit>
        <trans-unit id="8c38eb7023c514bb86f58038021705c167c2100e" translate="yes" xml:space="preserve">
          <source>Test::Exception</source>
          <target state="translated">Test::Exception</target>
        </trans-unit>
        <trans-unit id="fa3770b25c372094da5ee1db5052ae09e83ef8c9" translate="yes" xml:space="preserve">
          <source>Test::FITesque</source>
          <target state="translated">Test::FITesque</target>
        </trans-unit>
        <trans-unit id="a7d826918b9640ee5aefda9817fc5812e0f756da" translate="yes" xml:space="preserve">
          <source>Test::Flatten</source>
          <target state="translated">Test::Flatten</target>
        </trans-unit>
        <trans-unit id="3a3efe85ae6b44923e15a1815a66c74e76451413" translate="yes" xml:space="preserve">
          <source>Test::Group</source>
          <target state="translated">Test::Group</target>
        </trans-unit>
        <trans-unit id="d22ac9fb1a5b65be8b995c5c95d6e3ef8ecf556f" translate="yes" xml:space="preserve">
          <source>Test::Harness</source>
          <target state="translated">Test::Harness</target>
        </trans-unit>
        <trans-unit id="999566fc7acbd2379a803a5571ff7ae9c8a53f12" translate="yes" xml:space="preserve">
          <source>Test::Harness - Run Perl standard test scripts with statistics</source>
          <target state="translated">Тест::Harness-запуск стандартных тестовых скриптов на Perl со статистикой</target>
        </trans-unit>
        <trans-unit id="468e0078216124f369b31903b11b8bc081cc36e2" translate="yes" xml:space="preserve">
          <source>Test::Harness is responsible for running test scripts, analysing their output and reporting success or failure. When I type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a7d2d4bb460e39ef11a61cdb53eb1618e9aac3" translate="yes" xml:space="preserve">
          <source>Test::Harness::Beyond</source>
          <target state="translated">Test::Harness::Beyond</target>
        </trans-unit>
        <trans-unit id="710da8f3b5001dc747ab1add20a7485f6580ee6f" translate="yes" xml:space="preserve">
          <source>Test::Harness::Beyond - Beyond make test</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a575600ccb79ef75baad46fa5507b8a5c4e30ec7" translate="yes" xml:space="preserve">
          <source>Test::Kit</source>
          <target state="translated">Test::Kit</target>
        </trans-unit>
        <trans-unit id="e0d9d27235388a3f369fc7bba1f8eedaa8e97fe0" translate="yes" xml:space="preserve">
          <source>Test::Modern</source>
          <target state="translated">Test::Modern</target>
        </trans-unit>
        <trans-unit id="192bb93f9defdd2612446bcb1a3d05713afa6106" translate="yes" xml:space="preserve">
          <source>Test::Module::Used</source>
          <target state="translated">Test::Module::Used</target>
        </trans-unit>
        <trans-unit id="ba56db031e8622af899875ba4ed0dd10651ade7c" translate="yes" xml:space="preserve">
          <source>Test::Moose::More</source>
          <target state="translated">Test::Moose::More</target>
        </trans-unit>
        <trans-unit id="8bc418104ff43998dd3e36faf2584e579de681bc" translate="yes" xml:space="preserve">
          <source>Test::More</source>
          <target state="translated">Test::More</target>
        </trans-unit>
        <trans-unit id="6bfa9c991e549bd99bf8bd638cf1236dd03e5675" translate="yes" xml:space="preserve">
          <source>Test::More - yet another framework for writing test scripts</source>
          <target state="translated">Test::More-еще один фреймворк для написания тестовых скриптов</target>
        </trans-unit>
        <trans-unit id="09cadd12e0ce824bc15b5cc2302b3277911f9d5d" translate="yes" xml:space="preserve">
          <source>Test::More is loaded. This is ok:</source>
          <target state="translated">Тест::Больше загружено.Это нормально:</target>
        </trans-unit>
        <trans-unit id="298bd3075d22676dbcd8f6e949f1684dca1178d5" translate="yes" xml:space="preserve">
          <source>Test::More will only be aware of threads if &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; has been done</source>
          <target state="translated">Test :: More будет знать о потоках только в том случае, если было выполнено &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="196636e03a49e3d95a68eb5d1e772f5b446bf075" translate="yes" xml:space="preserve">
          <source>Test::More will only be aware of threads if &lt;code&gt;use threads&lt;/code&gt; has been done</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a20537d51a274a0fa5bf1a1b0842f5d372eac9" translate="yes" xml:space="preserve">
          <source>Test::More works with Perls as old as 5.8.1.</source>
          <target state="translated">Тест::Больше работает с Perls,начиная с 5.8.1.</target>
        </trans-unit>
        <trans-unit id="8218b4a58d60c04b93980b51121cc27fdf92c29b" translate="yes" xml:space="preserve">
          <source>Test::More::Prefix</source>
          <target state="translated">Test::More::Prefix</target>
        </trans-unit>
        <trans-unit id="ec61f56547ff7cd28c4fd12d8d489f875c46dac9" translate="yes" xml:space="preserve">
          <source>Test::ParallelSubtest</source>
          <target state="translated">Test::ParallelSubtest</target>
        </trans-unit>
        <trans-unit id="b9283666c0f7ee8bee524021520b4a58fc6faf53" translate="yes" xml:space="preserve">
          <source>Test::Pretty</source>
          <target state="translated">Test::Pretty</target>
        </trans-unit>
        <trans-unit id="6b788f39836a6b433e5df6d0783c10c859e93117" translate="yes" xml:space="preserve">
          <source>Test::SharedFork</source>
          <target state="translated">Test::SharedFork</target>
        </trans-unit>
        <trans-unit id="1daa106bfbe0f2bf149e9e695740563a8ed4ebb6" translate="yes" xml:space="preserve">
          <source>Test::Simple</source>
          <target state="translated">Test::Simple</target>
        </trans-unit>
        <trans-unit id="3b9ad9cea20f592f35fa16d26cd1276645b8b0c3" translate="yes" xml:space="preserve">
          <source>Test::Simple - Basic utilities for writing tests.</source>
          <target state="translated">Test::Simple-основные утилиты для написания тестов.</target>
        </trans-unit>
        <trans-unit id="475687d59b9799eb28a9bf920c296a61e431b89f" translate="yes" xml:space="preserve">
          <source>Test::Simple is &lt;b&gt;explicitly&lt;/b&gt; tested all the way back to perl 5.6.0.</source>
          <target state="translated">Test :: Simple &lt;b&gt;явно&lt;/b&gt; протестирован вплоть до perl 5.6.0.</target>
        </trans-unit>
        <trans-unit id="5f28cc996a292888e74e1d0b0e1cee8d8ca4199f" translate="yes" xml:space="preserve">
          <source>Test::Simple is thread-safe in perl 5.8.1 and up.</source>
          <target state="translated">Тест::Простота-нитепроницаемость в perl 5.8.1 и выше.</target>
        </trans-unit>
        <trans-unit id="73bb7e431ecc9d090ef6327ee2db2dd9ad7a8638" translate="yes" xml:space="preserve">
          <source>Test::Simple will only report a maximum of 254 failures in its exit code. If this is a problem, you probably have a huge test script. Split it into multiple files. (Otherwise blame the Unix folks for using an unsigned short integer as the exit status).</source>
          <target state="translated">Test::Simple сообщит о максимуме 254 сбоях в своем коде выхода.Если это проблема,то,вероятно,у вас есть огромный тестовый скрипт.Разделите его на несколько файлов.(Иначе вините Unix-пользователей за использование короткого беззнакового числа в качестве состояния выхода).</target>
        </trans-unit>
        <trans-unit id="8aa960dec0e59265b42ae7c53ff6c2bb33cb537d" translate="yes" xml:space="preserve">
          <source>Test::Simple will start by printing number of tests run in the form &quot;1..M&quot; (so &quot;1..5&quot; means you're going to run 5 tests). This strange format lets &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; know how many tests you plan on running in case something goes horribly wrong.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7410d0684050e7e2cf37f448e25d1181f683a339" translate="yes" xml:space="preserve">
          <source>Test::Simple will start by printing number of tests run in the form &quot;1..M&quot; (so &quot;1..5&quot; means you're going to run 5 tests). This strange format lets &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; know how many tests you plan on running in case something goes horribly wrong.</source>
          <target state="translated">Test :: Simple начнется с вывода количества выполненных тестов в форме &amp;laquo;1..M&amp;raquo; (так что &amp;laquo;1..5&amp;raquo; означает, что вы собираетесь запустить 5 тестов). Этот странный формат позволяет &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; узнать, сколько тестов вы планируете запустить на случай, если что-то пойдет не так.</target>
        </trans-unit>
        <trans-unit id="dad41aad99148e817cb791ab1874c49f4dd7b526" translate="yes" xml:space="preserve">
          <source>Test::Tester</source>
          <target state="translated">Test::Tester</target>
        </trans-unit>
        <trans-unit id="8acb8c70dcb4cd96a3e80ad8c60dfdc954c732ae" translate="yes" xml:space="preserve">
          <source>Test::Tester - Ease testing test modules built with Test::Builder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c807179d1ac6c0d1012cd2c0455c92e0bc574a1" translate="yes" xml:space="preserve">
          <source>Test::Tester::Capture</source>
          <target state="translated">Test::Tester::Capture</target>
        </trans-unit>
        <trans-unit id="34d5b01db7ffd8049c2fce4af0432b62a248b560" translate="yes" xml:space="preserve">
          <source>Test::Tester::Capture - Help testing test modules built with Test::Builder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a458c6dc8e9ff30e8f733b126620031229080ac" translate="yes" xml:space="preserve">
          <source>Test::Tester::Capture is a cut down and hacked up version of Test::Builder. Test::Builder was written by chromatic &amp;lt;chromatic@wgz.org&amp;gt; and Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e02cff79037d04f0d5bb99326725d2ece3d0d2" translate="yes" xml:space="preserve">
          <source>Test::Tester::CaptureRunner</source>
          <target state="translated">Test::Tester::CaptureRunner</target>
        </trans-unit>
        <trans-unit id="91c101deb36c07d85cffc331897f08c9b07bf3e8" translate="yes" xml:space="preserve">
          <source>Test::Tester::CaptureRunner - Help testing test modules built with Test::Builder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26dc9e7487fca0c9f4cffd8168312e798d0afc9" translate="yes" xml:space="preserve">
          <source>Test::Tutorial</source>
          <target state="translated">Test::Tutorial</target>
        </trans-unit>
        <trans-unit id="02f397dd5054f86d8966d3c1290f138f6ebe0f4c" translate="yes" xml:space="preserve">
          <source>Test::Tutorial - A tutorial about writing really basic tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a895a2ec6601bf0432d22dd921492b16b90ab206" translate="yes" xml:space="preserve">
          <source>Test::UseAllModules</source>
          <target state="translated">Test::UseAllModules</target>
        </trans-unit>
        <trans-unit id="bf429510e44f5fd6da7cc7782aa21fed2fafa3e5" translate="yes" xml:space="preserve">
          <source>Test::Wrapper</source>
          <target state="translated">Test::Wrapper</target>
        </trans-unit>
        <trans-unit id="2041e8b48dd73d1c03506e63605772b484021ff1" translate="yes" xml:space="preserve">
          <source>Test::use::ok</source>
          <target state="translated">Test::use::ok</target>
        </trans-unit>
        <trans-unit id="85de35d70454052811bfbba08699cf789b433ab6" translate="yes" xml:space="preserve">
          <source>Test::use::ok - Alternative to Test::More::use_ok</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="df0cbdcfcbefab8ee9cdb49385d677707edb64f0" translate="yes" xml:space="preserve">
          <source>Testing Anomalies with Perl on OS/390</source>
          <target state="translated">Тестирование аномалий с Perl на OS/390</target>
        </trans-unit>
        <trans-unit id="5570491e686f99f120f682632ae7878ad3d5e6f3" translate="yes" xml:space="preserve">
          <source>Testing Perl on AmigaOS</source>
          <target state="translated">Тестирование Perl на AmigaOS</target>
        </trans-unit>
        <trans-unit id="8fcfced2bef4012741d97c1ae50789df4c2ca1a7" translate="yes" xml:space="preserve">
          <source>Testing Perl on BS2000</source>
          <target state="translated">Тестирование Perl на BS2000</target>
        </trans-unit>
        <trans-unit id="d2f23703acfdab063aa7e2b458c49da1d7edf65c" translate="yes" xml:space="preserve">
          <source>Testing Perl on DOS</source>
          <target state="translated">Тестирование Perl на DOS</target>
        </trans-unit>
        <trans-unit id="06d9fe11979b660c9a4ee9181d453bdc4d62d418" translate="yes" xml:space="preserve">
          <source>Testing Perl on Tru64</source>
          <target state="translated">Тестирование Perl на Tru64</target>
        </trans-unit>
        <trans-unit id="ad2407f8ab58aad232d3d10c4a28600678ba9ac4" translate="yes" xml:space="preserve">
          <source>Testing Perl on Windows</source>
          <target state="translated">Тестирование Perl на Windows</target>
        </trans-unit>
        <trans-unit id="77bcc7871b8f58fd20b1c5a5350ee1211c163038" translate="yes" xml:space="preserve">
          <source>Testing for broken locales</source>
          <target state="translated">Тестирование на разбитые локали</target>
        </trans-unit>
        <trans-unit id="8a625de0654c02e74db29ae73bd5e3bde68f2ba9" translate="yes" xml:space="preserve">
          <source>Testing for exact floating-point equality or inequality is not a good idea. Here's a (relatively expensive) work-around to compare whether two floating-point numbers are equal to a particular number of decimal places. See Knuth, volume II, for a more robust treatment of this topic.</source>
          <target state="translated">Тестирование на точное равенство или неравенство с плавающей запятой не является хорошей идеей.Вот (относительно дорогой)обходной метод для сравнения того,равны ли два числа с плавающей точкой определенному числу десятичных разрядов.См.Кнут,том II,для более тщательного рассмотрения этой темы.</target>
        </trans-unit>
        <trans-unit id="ce74fac01896559c610eb3a5a4dbe52a84d8dafc" translate="yes" xml:space="preserve">
          <source>Testing for operating systems or versions when should be testing for features</source>
          <target state="translated">Тестирование для операционных систем или версий,когда должно быть тестирование на функциональность</target>
        </trans-unit>
        <trans-unit id="2d25b81a3e33ddcbb9c9dc8657d0fadaaa4f4848" translate="yes" xml:space="preserve">
          <source>Testing lots of values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e225b583da27a200eb4cb29e5d543c5d33dff11a" translate="yes" xml:space="preserve">
          <source>Testing results: &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt;</source>
          <target state="translated">Результаты тестирования: &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7fb7daa9466444fb2d40197eaff882519cbfe5af" translate="yes" xml:space="preserve">
          <source>Testing results: &lt;a href=&quot;https://www.cpantesters.org/&quot;&gt;https://www.cpantesters.org/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062a3b44009f84b9f2800778be4849f48c73f2e1" translate="yes" xml:space="preserve">
          <source>Testing the patch</source>
          <target state="translated">Тестирование заплаты</target>
        </trans-unit>
        <trans-unit id="3d3998625037d01c3f0c18b46c8e2f6a0db08edf" translate="yes" xml:space="preserve">
          <source>Testing tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73860e29950984e7ebc73550412c5d939d1b2f02" translate="yes" xml:space="preserve">
          <source>Testing with taint mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">Tests</target>
        </trans-unit>
        <trans-unit id="16d924262049c4868fcbd9b1e4dbe661fd3a3f60" translate="yes" xml:space="preserve">
          <source>Tests are run from the top level of your distribution. So inside a test you would refer to ./lib to enter the lib directory, for example.</source>
          <target state="translated">Тесты проводятся с верхнего уровня распределения.Поэтому внутри теста вы будете обращаться к ./lib,чтобы,например,войти в каталог lib.</target>
        </trans-unit>
        <trans-unit id="f8610f229cb8bffff5963f6ac85b8ed60c32307d" translate="yes" xml:space="preserve">
          <source>Tests break due to subtest indentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a6b8165e3eb024d50e4aac5941e40919fd1c85" translate="yes" xml:space="preserve">
          <source>Tests for basic control structures, &lt;code&gt;if/else&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; , subroutines, etc.</source>
          <target state="translated">Тесты основных структур управления, &lt;code&gt;if/else&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , подпрограмм и т. Д.</target>
        </trans-unit>
        <trans-unit id="43a6cf885d16a46b82e0be5400cae40cc21567ca" translate="yes" xml:space="preserve">
          <source>Tests for basic control structures, &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, subroutines, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23a0f9aaa05867bc6031160779c65549d0d4574" translate="yes" xml:space="preserve">
          <source>Tests for basic issues of how Perl parses and compiles itself.</source>
          <target state="translated">Тесты на основные вопросы того,как Perl разбирает и компилирует сам себя.</target>
        </trans-unit>
        <trans-unit id="308c251d349eaa69d0bf0cd8f27225db41d2132b" translate="yes" xml:space="preserve">
          <source>Tests for built-in IO functions, including command line arguments.</source>
          <target state="translated">Тесты для встроенных функций ввода-вывода,включая аргументы командной строки.</target>
        </trans-unit>
        <trans-unit id="19b2942a8db27974454d5941c50ac27e7e57bf55" translate="yes" xml:space="preserve">
          <source>Tests for core modules in the</source>
          <target state="translated">Тесты для основных модулей в</target>
        </trans-unit>
        <trans-unit id="b5bc9dd6c6b565df077d3e101f86339fa68c2de9" translate="yes" xml:space="preserve">
          <source>Tests for features of how perl actually runs, including exit codes and handling of PERL* environment variables.</source>
          <target state="translated">Тесты на наличие особенностей того,как perl на самом деле работает,включая выходные коды и обработку переменных окружения PERL*.</target>
        </trans-unit>
        <trans-unit id="3267c94afb370d057a2cbf7d80804c00a071b8c7" translate="yes" xml:space="preserve">
          <source>Tests for modules in</source>
          <target state="translated">Тесты для модулей в</target>
        </trans-unit>
        <trans-unit id="546a42daa356e4d754d8415b0cf28f28144cb38f" translate="yes" xml:space="preserve">
          <source>Tests for perl's built in functions that don't fit into any of the other directories.</source>
          <target state="translated">Тесты для встроенных функций perl,которые не вписываются ни в один из других каталогов.</target>
        </trans-unit>
        <trans-unit id="7dde17b953b0dbe2392223a460035fd53ab6fcb8" translate="yes" xml:space="preserve">
          <source>Tests for perl's built in functions which, like those in</source>
          <target state="translated">Тесты для встроенных функций perl,которые,как и те,что в</target>
        </trans-unit>
        <trans-unit id="cee38a612a6bf39e0ad8abf7e176cb7eb3696a9c" translate="yes" xml:space="preserve">
          <source>Tests for perl's method resolution order implementations (see &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt;).</source>
          <target state="translated">Тесты для реализации порядка разрешения методов Perl (см. &lt;a href=&quot;mro&quot;&gt;Mro&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="20b59967ab49cfe543876fa9d6d79f51e0848a3e" translate="yes" xml:space="preserve">
          <source>Tests for regex related functions or behaviour. (These used to live in t/op).</source>
          <target state="translated">Тесты на регекс-функции или поведение.(Раньше они жили в т/п).</target>
        </trans-unit>
        <trans-unit id="9a9539800599d59b0f69e2e288d490ed3068858e" translate="yes" xml:space="preserve">
          <source>Tests for the absolute basic functionality of Perl. This includes &lt;code&gt;if&lt;/code&gt; , basic file reads and writes, simple regexes, etc. These are run first in the test suite and if any of them fail, something is</source>
          <target state="translated">Тесты на абсолютную базовую функциональность Perl. Это включает в себя &lt;code&gt;if&lt;/code&gt; , базовые операции чтения и записи файлов, простые регулярные выражения и т. Д. Они запускаются сначала в тестовом наборе, и если какое-либо из них не удается, что-то</target>
        </trans-unit>
        <trans-unit id="8ad550acb94fcd95cceafdb6277d5fdd95b24d49" translate="yes" xml:space="preserve">
          <source>Tests for the absolute basic functionality of Perl. This includes &lt;code&gt;if&lt;/code&gt;, basic file reads and writes, simple regexes, etc. These are run first in the test suite and if any of them fail, something is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c72675b2d7c270a253600fe2e92bb83c326034f" translate="yes" xml:space="preserve">
          <source>Tests for the core support of Unicode.</source>
          <target state="translated">Тесты на поддержку ядра Юникода.</target>
        </trans-unit>
        <trans-unit id="5399480a16c4de144214dd4ce3a72127bb1a23c7" translate="yes" xml:space="preserve">
          <source>Tests for your modules go here. Each test filename ends with a .t. So</source>
          <target state="translated">Тесты для ваших модулей идите сюда.Имя каждого тестового файла заканчивается на .t.Так что...</target>
        </trans-unit>
        <trans-unit id="3b09fe0c89b9d62c4f3f3bd0ca9b2eec4dcf9e3b" translate="yes" xml:space="preserve">
          <source>Tests if a directory exists.</source>
          <target state="translated">Проверяет,существует ли каталог.</target>
        </trans-unit>
        <trans-unit id="46dcf6b14fde2f007d3642aeb765c51b6d6d9ef7" translate="yes" xml:space="preserve">
          <source>Tests if a file exists and is not empty (size &amp;gt; 0).</source>
          <target state="translated">Проверяет, существует ли файл и не является ли он пустым (размер&amp;gt; 0).</target>
        </trans-unit>
        <trans-unit id="6b574534ebbfa4f25620de8b753e474bc0774320" translate="yes" xml:space="preserve">
          <source>Tests if a file exists.</source>
          <target state="translated">Проверяет,существует ли файл.</target>
        </trans-unit>
        <trans-unit id="cbd83d5913990ad1027b8f9518f00ff7c97af8a7" translate="yes" xml:space="preserve">
          <source>Tests if some arbitrary number of bytes begins in a valid UTF-8 character. Note that an INVARIANT (i.e. ASCII on non-EBCDIC machines) character is a valid UTF-8 character. The actual number of bytes in the UTF-8 character will be returned if it is valid, otherwise 0.</source>
          <target state="translated">Тестирует,если некоторое произвольное количество байт начинается с допустимого символа UTF-8.Обратите внимание,что символ INVARIANT (т.е.ASCII на машинах без EBCDIC)является действительным символом UTF-8.Реальное количество байтов в символе UTF-8 будет возвращено,если он действителен,в противном случае 0.</target>
        </trans-unit>
        <trans-unit id="44e861c8808d6c4fdc4afa5679c3cee1a9b5d6ca" translate="yes" xml:space="preserve">
          <source>Tests if the SV is an RV.</source>
          <target state="translated">Проверяет,является ли SV фургоном.</target>
        </trans-unit>
        <trans-unit id="e941f360f3702d2e201c15e9113b9156e131c64f" translate="yes" xml:space="preserve">
          <source>Tests if the source file exists and is not empty (size &amp;gt; 0). If it is not empty it copies it to the given destination with the given permissions.</source>
          <target state="translated">Проверяет, существует ли исходный файл и не является ли он пустым (размер&amp;gt; 0). Если он не пустой, он копирует его в указанное место назначения с указанными разрешениями.</target>
        </trans-unit>
        <trans-unit id="8add41d28c736769282eb5984bc3956add793925" translate="yes" xml:space="preserve">
          <source>Tests if two threads objects are the same thread or not. This is overloaded to the more natural forms:</source>
          <target state="translated">Проверяет,являются ли объекты двух потоков одними и теми же или нет.Это перегружает более естественные формы:</target>
        </trans-unit>
        <trans-unit id="374b92e6c8d9a3ee7da76fc28e0b35de614ef062" translate="yes" xml:space="preserve">
          <source>Tests that have never failed will not be selected. To run all tests with the most recently failed first use</source>
          <target state="translated">Тесты,которые никогда не терпели неудач,не будут выбраны.Для запуска всех тестов с самым последним неудачным первым использованием</target>
        </trans-unit>
        <trans-unit id="0b32728377a8f935217ef765a504aecedda1d3ff" translate="yes" xml:space="preserve">
          <source>Tests the SigSet object to see if it contains a specific signal.</source>
          <target state="translated">Тестирует объект SigSet на наличие определенного сигнала.</target>
        </trans-unit>
        <trans-unit id="018f42b8eff88fccb00a8501792db561a99e45b3" translate="yes" xml:space="preserve">
          <source>Tests the state of the source tree for various common errors. For example, it tests that everyone who is listed in the git log has a corresponding entry in the</source>
          <target state="translated">Тестирует состояние дерева исходных текстов на наличие различных распространенных ошибок.Например,он проверяет,что у каждого,кто указан в git-журнале,есть соответствующая запись в</target>
        </trans-unit>
        <trans-unit id="ea2ffd035ac28e433a00f696dde2f14824fdd414" translate="yes" xml:space="preserve">
          <source>Tests will be run in the order found.</source>
          <target state="translated">Тесты будут проведены в порядке найденных.</target>
        </trans-unit>
        <trans-unit id="98125dc77105eee722883e53962bb713d1532fbc" translate="yes" xml:space="preserve">
          <source>Texas</source>
          <target state="translated">Texas</target>
        </trans-unit>
        <trans-unit id="e7d8144d0e2f5125039e56e9f410b15ff3f27544" translate="yes" xml:space="preserve">
          <source>Texas Instruments</source>
          <target state="translated">Техасские инструменты</target>
        </trans-unit>
        <trans-unit id="c1c3994d542e6e140e686559285de68d361dbc43" translate="yes" xml:space="preserve">
          <source>Text Fields</source>
          <target state="translated">Текстовые поля</target>
        </trans-unit>
        <trans-unit id="5295b0156f97937927214f3e61425549fb5528ba" translate="yes" xml:space="preserve">
          <source>Text after __DATA__ may be read via the filehandle &lt;code&gt;PACKNAME::DATA&lt;/code&gt; , where &lt;code&gt;PACKNAME&lt;/code&gt; is the package that was current when the __DATA__ token was encountered. The filehandle is left open pointing to the line after __DATA__. The program should &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; DATA&lt;/code&gt; when it is done reading from it. (Leaving it open leaks filehandles if the module is reloaded for any reason, so it's a safer practice to close it.) For compatibility with older scripts written before __DATA__ was introduced, __END__ behaves like __DATA__ in the top level script (but not in files loaded with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;) and leaves the remaining contents of the file accessible via &lt;code&gt;main::DATA&lt;/code&gt; .</source>
          <target state="translated">Текст после __DATA__ может быть прочитан с помощью дескриптора файла &lt;code&gt;PACKNAME::DATA&lt;/code&gt; , где &lt;code&gt;PACKNAME&lt;/code&gt; - это пакет, который был текущим на момент обнаружения токена __DATA__. Дескриптор файла остается открытым, указывая на строку после __DATA__. Программа должна &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; DATA&lt;/code&gt; по завершении чтения из них. (Если по какой-либо причине модуль будет перезагружен, это приведет к утечке файловых дескрипторов, поэтому безопаснее его закрыть.) Для совместимости со старыми скриптами, написанными до появления __DATA__, __END__ ведет себя как __DATA__ в скрипте верхнего уровня (но не в файлах). загружается с помощью &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; ), а остальное содержимое файла остается доступным через &lt;code&gt;main::DATA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3842cca55ef2d8dd670adcc834aa3853a804149a" translate="yes" xml:space="preserve">
          <source>Text after __DATA__ may be read via the filehandle &lt;code&gt;PACKNAME::DATA&lt;/code&gt;, where &lt;code&gt;PACKNAME&lt;/code&gt; is the package that was current when the __DATA__ token was encountered. The filehandle is left open pointing to the line after __DATA__. The program should &lt;code&gt;close DATA&lt;/code&gt; when it is done reading from it. (Leaving it open leaks filehandles if the module is reloaded for any reason, so it's a safer practice to close it.) For compatibility with older scripts written before __DATA__ was introduced, __END__ behaves like __DATA__ in the top level script (but not in files loaded with &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt;) and leaves the remaining contents of the file accessible via &lt;code&gt;main::DATA&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b961306ccde8b23c4b7e5620da4263be5fc453" translate="yes" xml:space="preserve">
          <source>Text from a &lt;code&gt;&quot;#&quot;&lt;/code&gt; character until the end of the line is a comment, and is ignored. Exceptions include &lt;code&gt;&quot;#&quot;&lt;/code&gt; inside a string or regular expression.</source>
          <target state="translated">Текст от символа &lt;code&gt;&quot;#&quot;&lt;/code&gt; до конца строки является комментарием и игнорируется. Исключения включают &lt;code&gt;&quot;#&quot;&lt;/code&gt; внутри строки или регулярного выражения.</target>
        </trans-unit>
        <trans-unit id="612222022f1b46958ab65767470934164201705e" translate="yes" xml:space="preserve">
          <source>Text sorted by numeric codepoint follows no reasonable alphabetic order; use the UCA for sorting text.</source>
          <target state="translated">Текст,отсортированный по цифровой кодовой точке,не следует разумному алфавитному порядку;используйте UCA для сортировки текста.</target>
        </trans-unit>
        <trans-unit id="2c6fa58228dea3c204f1dbf0a6dfadcd17082dee" translate="yes" xml:space="preserve">
          <source>Text strings (character strings)</source>
          <target state="translated">Текстовые строки (строки символов)</target>
        </trans-unit>
        <trans-unit id="3b64142186315d3b56e626d60aec3cca8845fddf" translate="yes" xml:space="preserve">
          <source>Text-mode filehandles</source>
          <target state="translated">Ручки файлов в текстовом режиме</target>
        </trans-unit>
        <trans-unit id="5f66be9f33facdd2db9a099e59f4d627dc79cb6a" translate="yes" xml:space="preserve">
          <source>Text-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Текст-токены из Pod::Простой::PullParser</target>
        </trans-unit>
        <trans-unit id="538841f5b8d0f8755431ba6c721b56da44fdedea" translate="yes" xml:space="preserve">
          <source>Text/Binary</source>
          <target state="translated">Text/Binary</target>
        </trans-unit>
        <trans-unit id="0ff712854e85b7ca719cd920d585fda4d395d5a6" translate="yes" xml:space="preserve">
          <source>Text/Soundex.pm</source>
          <target state="translated">Text/Soundex.pm</target>
        </trans-unit>
        <trans-unit id="e496659a9c65305c9d5cc245d38c0b1cea09e5cd" translate="yes" xml:space="preserve">
          <source>Text2</source>
          <target state="translated">Text2</target>
        </trans-unit>
        <trans-unit id="76fdd8573b883583b24f2ee565ca6b0eb2a5486b" translate="yes" xml:space="preserve">
          <source>Text::Abbrev</source>
          <target state="translated">Text::Abbrev</target>
        </trans-unit>
        <trans-unit id="2068aa4164bd7ee8a2ded8f7cd23b18d6c9d99cd" translate="yes" xml:space="preserve">
          <source>Text::Abbrev - abbrev - create an abbreviation table from a list</source>
          <target state="translated">Текст::Аббревиатура-аббревиатура-создать таблицу аббревиатур из списка</target>
        </trans-unit>
        <trans-unit id="3fa2f6e623c8f3b7b036f20657d7a8f10bb6417e" translate="yes" xml:space="preserve">
          <source>Text::Balanced</source>
          <target state="translated">Text::Balanced</target>
        </trans-unit>
        <trans-unit id="ed925f6d474c4516a347932710d3ebe30e7e56cb" translate="yes" xml:space="preserve">
          <source>Text::Balanced - Extract delimited text sequences from strings.</source>
          <target state="translated">Текст::Balanced-Извлечение отграниченных текстовых последовательностей из строк.</target>
        </trans-unit>
        <trans-unit id="e4b49cafa2ac97b401d3d68d8bed306fe21eb79b" translate="yes" xml:space="preserve">
          <source>Text::ParseWords</source>
          <target state="translated">Text::ParseWords</target>
        </trans-unit>
        <trans-unit id="4524c2c613f4d738713e1d030d34e60049e80d95" translate="yes" xml:space="preserve">
          <source>Text::ParseWords - parse text into an array of tokens or array of arrays</source>
          <target state="translated">Text::ParseWords-парсинг текста в массив токенов или массив массивов.</target>
        </trans-unit>
        <trans-unit id="bdadcd3fc912962eb41c1688bb499f95c2ac99b6" translate="yes" xml:space="preserve">
          <source>Text::Tabs</source>
          <target state="translated">Text::Tabs</target>
        </trans-unit>
        <trans-unit id="d895b382c2e881055f9eeb7a0411fad11058bd8a" translate="yes" xml:space="preserve">
          <source>Text::Tabs - expand and unexpand tabs like unix expand(1) and unexpand(1)</source>
          <target state="translated">Text::Tabs-вкладки расширения и расширения типа unix expansion(1)и unexpand(1).</target>
        </trans-unit>
        <trans-unit id="4b087dde2df1e77a15a3f15af552e2d614eda1ab" translate="yes" xml:space="preserve">
          <source>Text::Tabs does most of what the unix utilities expand(1) and unexpand(1) do. Given a line with tabs in it, &lt;code&gt;expand&lt;/code&gt; replaces those tabs with the appropriate number of spaces. Given a line with or without tabs in it, &lt;code&gt;unexpand&lt;/code&gt; adds tabs when it can save bytes by doing so, like the &lt;code&gt;unexpand -a&lt;/code&gt; command.</source>
          <target state="translated">Text :: Tabs выполняет большую часть того, что делают утилиты unix expand (1) и undepand (1). Если у вас есть строка с табуляциями, команда &lt;code&gt;expand&lt;/code&gt; заменяет эти табуляции на соответствующее количество пробелов. Для &lt;code&gt;unexpand&lt;/code&gt; строки с вкладками или без них, Unpand добавляет вкладки, если это позволяет сохранить байты, например, команда &lt;code&gt;unexpand -a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f269210fd9d87098c23ad7f43c52bf42decefb07" translate="yes" xml:space="preserve">
          <source>Text::Tabs handles only tabs (&lt;code&gt;&quot;\t&quot;&lt;/code&gt; ) and combining characters (&lt;code&gt;/\pM/&lt;/code&gt; ). It doesn't count backwards for backspaces (&lt;code&gt;&quot;\t&quot;&lt;/code&gt; ), omit other non-printing control characters (&lt;code&gt;/\pC/&lt;/code&gt; ), or otherwise deal with any other zero-, half-, and full-width characters.</source>
          <target state="translated">Text :: Tabs обрабатывает только табуляции ( &lt;code&gt;&quot;\t&quot;&lt;/code&gt; ) и комбинирующие символы ( &lt;code&gt;/\pM/&lt;/code&gt; ). Он не считает в обратном направлении для обратных пробелов ( &lt;code&gt;&quot;\t&quot;&lt;/code&gt; ), пропускает другие непечатаемые управляющие символы ( &lt;code&gt;/\pC/&lt;/code&gt; ) или иным образом обрабатывает любые другие символы нулевой, половинной и полной ширины.</target>
        </trans-unit>
        <trans-unit id="b575607717c2ca75293a1a2f973ea2178607244e" translate="yes" xml:space="preserve">
          <source>Text::Tabs handles only tabs (&lt;code&gt;&quot;\t&quot;&lt;/code&gt;) and combining characters (&lt;code&gt;/\pM/&lt;/code&gt;). It doesn't count backwards for backspaces (&lt;code&gt;&quot;\t&quot;&lt;/code&gt;), omit other non-printing control characters (&lt;code&gt;/\pC/&lt;/code&gt;), or otherwise deal with any other zero-, half-, and full-width characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b226bf7a7ae42bd7cbd6a0b3ba78466abba19e61" translate="yes" xml:space="preserve">
          <source>Text::Wrap</source>
          <target state="translated">Text::Wrap</target>
        </trans-unit>
        <trans-unit id="8aabd1ad489c52bb200edd21bc6dce9b91083963" translate="yes" xml:space="preserve">
          <source>Text::Wrap - line wrapping to form simple paragraphs</source>
          <target state="translated">Текст::Обёртывание-обёртывание в строки для формирования простых параграфов</target>
        </trans-unit>
        <trans-unit id="f934f68f6305075635ab21032f0c6eb35d0fa39c" translate="yes" xml:space="preserve">
          <source>Thai encoding TCVN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b50e31a7e1337db9ecb0e2fcb6e65ca27f57df5" translate="yes" xml:space="preserve">
          <source>Thank you</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e8cd6c504322691d26989da020afe0ebedb22f" translate="yes" xml:space="preserve">
          <source>Thank you to (in chronological order):</source>
          <target state="translated">Спасибо (в хронологическом порядке):</target>
        </trans-unit>
        <trans-unit id="b05872aaf946f643e0804715742f143fabda127d" translate="yes" xml:space="preserve">
          <source>Thanks (in no particular order) to Chaim Frenkel, Steve Fink, Gurusamy Sarathy, Ilya Zakharevich, Benjamin Sugars, J&amp;uuml;rgen Christoffel, Joshua Pritikin, and Alan Burlison, for their help in reality-checking and polishing this article. Big thanks to Tom Christiansen for his rewrite of the prime number generator.</source>
          <target state="translated">Спасибо (в произвольном порядке) Хаиму Френкелю, Стиву Финку, Гурусами Сарати, Илье Захаревичу, Бенджамину Сугарсу, Юргену Кристоффелю, Джошуа Притикину и Алану Берлисону за их помощь в проверке реальности и полировке этой статьи. Большое спасибо Тому Кристиансену за его переписывание генератора простых чисел.</target>
        </trans-unit>
        <trans-unit id="624dc0ad0c4a285c56d022996d1083a11fac8944" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://he.net/&quot;&gt;Hurricane Electric&lt;/a&gt; for permission to use its &lt;a href=&quot;http://man.he.net/&quot;&gt;Linux man pages online&lt;/a&gt; site for man page links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d197026943bb6167685c48d3d3074cfb2a40bd" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://search.cpan.org/&quot;&gt;search.cpan.org&lt;/a&gt; for permission to use the site for Perl module links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515198f3ec489e991661ee9be0d3531260928534" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fhe.net%2f&quot;&gt;Hurricane Electric&lt;/a&gt; for permission to use its &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net%2f&quot;&gt;Linux man pages online&lt;/a&gt; site for man page links.</source>
          <target state="translated">Спасибо &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fhe.net%2f&quot;&gt;Hurricane Electric&lt;/a&gt; за разрешение использовать его &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net%2f&quot;&gt;онлайн-&lt;/a&gt; страницу справочника Linux для ссылок на справочную страницу.</target>
        </trans-unit>
        <trans-unit id="4a56281c4f40d78c915f83cd7dcb75140989545c" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2f&quot;&gt;search.cpan.org&lt;/a&gt; for permission to use the site for Perl module links.</source>
          <target state="translated">Спасибо &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2f&quot;&gt;search.cpan.org&lt;/a&gt; за разрешение использовать сайт для ссылок на модули Perl.</target>
        </trans-unit>
        <trans-unit id="444d0503771db0d31f8257285cffffd1831b8683" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;https://he.net/&quot;&gt;Hurricane Electric&lt;/a&gt; for permission to use its &lt;a href=&quot;http://man.he.net/&quot;&gt;Linux man pages online&lt;/a&gt; site for man page links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf7d45d74afe72eed5d28a1078191c21d4ed94f" translate="yes" xml:space="preserve">
          <source>Thanks to Chia-Liang Kao for suggesting &lt;code&gt;Path&lt;/code&gt; and &lt;code&gt;loc_lang&lt;/code&gt; .</source>
          <target state="translated">Спасибо Чиа-Лян Као за предложение &lt;code&gt;Path&lt;/code&gt; и &lt;code&gt;loc_lang&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1eb6da0d25f176736a52f5327efe1222256fcc7" translate="yes" xml:space="preserve">
          <source>Thanks to Chia-Liang Kao for suggesting &lt;code&gt;Path&lt;/code&gt; and &lt;code&gt;loc_lang&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28343241fc627e1ddfa37f27bcd25a3afbba56c2" translate="yes" xml:space="preserve">
          <source>Thanks to Gerard Goossen from TTY. His presentation &quot;UTF-8 in the wild&quot; (Dutch Perl Workshop 2006) inspired me to publish my thoughts and write this tutorial.</source>
          <target state="translated">Спасибо Джерарду Гуссену из TTY.Его презентация &quot;UTF-8 в дикой природе&quot; (Dutch Perl Workshop 2006)вдохновила меня на публикацию моих мыслей и написание этого учебника.</target>
        </trans-unit>
        <trans-unit id="eebcdc028466185c372d461642a6d1089c91d63f" translate="yes" xml:space="preserve">
          <source>Thanks to Graham Barr for contributing the following paragraphs about the interaction between perl, and various firewall configurations. For further information on firewalls, it is recommended to consult the documentation that comes with the</source>
          <target state="translated">Благодарим Грэма Барра за его вклад в работу над следующими параграфами,посвященными взаимодействию между perl и различными конфигурациями брандмауэра.Для получения более подробной информации о брандмауэрах рекомендуется обратиться к документации,которая поставляется с</target>
        </trans-unit>
        <trans-unit id="4ae64bcb3e2de31c99abdd50b43bda8476faf81d" translate="yes" xml:space="preserve">
          <source>Thanks to James Mastros and Martijn van der Streek for their help in getting &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt; to behave nicely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d72a4f35680c5e9eebf1d781be27639e4c1c23" translate="yes" xml:space="preserve">
          <source>Thanks to James Mastros and Martijn van der Streek for their help in getting &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt; to behave nicely.</source>
          <target state="translated">Спасибо Джеймсу Мастросу и Мартин ван дер Стрик за их помощь в обеспечении &lt;a href=&quot;open3&quot;&gt;хорошего&lt;/a&gt; поведения IPC :: Open3 .</target>
        </trans-unit>
        <trans-unit id="7dd46c60691bdec97830a740ba5397edf654eae8" translate="yes" xml:space="preserve">
          <source>Thanks to Johan Vromans from Squirrel Consultancy. His UTF-8 rants during the Amsterdam Perl Mongers meetings got me interested and determined to find out how to use character encodings in Perl in ways that don't break easily.</source>
          <target state="translated">Спасибо Йохану Вроману из &quot;Сквиррел Консалтанси&quot;.Его тиражи UTF-8 во время встреч с Amsterdam Perl Mongers заинтересовали меня и решили выяснить,как использовать кодировку символов на Perl таким образом,чтобы она не нарушалась легко.</target>
        </trans-unit>
        <trans-unit id="6253d9253e0f2874bf9d499be7a8e0251aa0083e" translate="yes" xml:space="preserve">
          <source>Thanks to Jonas B. Nielsen for making explicit imports work.</source>
          <target state="translated">Спасибо Джонасу Б.Нильсену за откровенный импорт.</target>
        </trans-unit>
        <trans-unit id="485f1de2dc0f3f17fa293a32651cd066b318634d" translate="yes" xml:space="preserve">
          <source>Thanks to Jos I. Boumans for suggesting this module to be written.</source>
          <target state="translated">Спасибо Джозефу И.Буману за то,что предложил написать этот модуль.</target>
        </trans-unit>
        <trans-unit id="5e83291fa2c7af3f2f4cad5da93414b81429569b" translate="yes" xml:space="preserve">
          <source>Thanks to Petya Kohts for the &lt;code&gt;run_forked&lt;/code&gt; code.</source>
          <target state="translated">Спасибо Пете &lt;code&gt;run_forked&lt;/code&gt; код run_forked .</target>
        </trans-unit>
        <trans-unit id="c916a51d90472cf9a92ff461a1e0369e54a45763" translate="yes" xml:space="preserve">
          <source>Thanks to Richard Clamp &amp;lt;richardc@unixbeard.net&amp;gt; for letting me use his testing system to try this module out on.</source>
          <target state="translated">Спасибо Ричарду Клэмпу &amp;lt;richardc@unixbeard.net&amp;gt; за то, что позволил мне использовать его систему тестирования, чтобы опробовать этот модуль.</target>
        </trans-unit>
        <trans-unit id="d8791cdde7f82c928089217628fa54dbdfb5e400" translate="yes" xml:space="preserve">
          <source>Thanks to Richard Soderberg for his performance improvements.</source>
          <target state="translated">Спасибо Ричарду Содербергу за его улучшение производительности.</target>
        </trans-unit>
        <trans-unit id="1d0320e05ae32871d886bed9f5bf625ba37f166b" translate="yes" xml:space="preserve">
          <source>Thanks to Sean Burke, Chris Nandor, Chip Salzenberg, Tim Heaney, Gisle Aas, Rainer Tammer and especially Andrew Savige for their help and suggestions.</source>
          <target state="translated">Спасибо Шону Берку,Крису Нандору,Чипу Зальценбергу,Тиму Хини,Жизлю Аасу,Райнеру Таммеру и особенно Эндрю Савиджу за их помощь и предложения.</target>
        </trans-unit>
        <trans-unit id="3c490099b710a18daaafdd3d9d34a147de5b78a3" translate="yes" xml:space="preserve">
          <source>Thanks to Tom Christiansen for suggesting that this module should be written and providing ideas for code improvements and security enhancements.</source>
          <target state="translated">Спасибо Тому Кристиансену за то,что он предложил написать этот модуль и поделился идеями по улучшению кода и повышению безопасности.</target>
        </trans-unit>
        <trans-unit id="243da9ccc28383d127f497ef267f78f655f69ef4" translate="yes" xml:space="preserve">
          <source>Thanks to overloading, the handling of arithmetics with complex numbers is simple and almost transparent.</source>
          <target state="translated">Благодаря перегрузке обработка арифметики со сложными числами проста и почти прозрачна.</target>
        </trans-unit>
        <trans-unit id="e1237be2e8e888521e762a958f2915acb036e56d" translate="yes" xml:space="preserve">
          <source>Thanks to the kind readers of the perl5-porters@perl.org, perl-unicode@perl.org, linux-utf8@nl.linux.org, and unicore@unicode.org mailing lists for their valuable feedback.</source>
          <target state="translated">Спасибо добрым читателям списков рассылки perl5-porters@perl.org,perl-unicode@perl.org,linux-utf8@nl.linux.org и unicore@unicode.org за их ценные отзывы.</target>
        </trans-unit>
        <trans-unit id="895e96674a21c983f493504acc0807a09ac741d7" translate="yes" xml:space="preserve">
          <source>Thanks to the people who asked about this kind of stuff in several Perl IRC channels, and have constantly reminded me that a simpler explanation was needed.</source>
          <target state="translated">Спасибо людям,которые спрашивали о таких вещах на нескольких IRC-каналах Perl,и постоянно напоминали мне,что нужно более простое объяснение.</target>
        </trans-unit>
        <trans-unit id="5daafe91df31a9585afc5052640e7074b414f20e" translate="yes" xml:space="preserve">
          <source>Thanks to the people who reviewed this document for me, before it went public. They are: Benjamin Smith, Jan-Pieter Cornet, Johan Vromans, Lukas Mai, Nathan Gray.</source>
          <target state="translated">Спасибо людям,которые просмотрели этот документ для меня,прежде чем он стал достоянием общественности.Так и есть:Бенджамин Смит,Ян-Питер Корнет,Йохан Вроманс,Лукас Май,Натан Грей.</target>
        </trans-unit>
        <trans-unit id="e2ecff3d05e183be8e4afb3075781b60cf077a08" translate="yes" xml:space="preserve">
          <source>Thanks to these efforts most encodings that come with Encode support PerlIO but that still leaves following encodings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f69c9fb3b65301a9a56633220645f84a279dc1" translate="yes" xml:space="preserve">
          <source>That a certain field exists in a struct</source>
          <target state="translated">Что определенное поле существует в структуре</target>
        </trans-unit>
        <trans-unit id="13e180f49380db1e610eb63f2836d65fe6a7ff96" translate="yes" xml:space="preserve">
          <source>That a field is of certain signedness, sizeof, or type</source>
          <target state="translated">Что поле имеет определенную подпись,размер или тип.</target>
        </trans-unit>
        <trans-unit id="ba8c7890c4018f7372ea3dd0b44efd4aac702fe3" translate="yes" xml:space="preserve">
          <source>That being said, there are several ways to approach this. If you are going to make this query many times over arbitrary string values, the fastest way is probably to invert the original array and maintain a hash whose keys are the first array's values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34dd8b430aa837e89a7b0c15eb719863c536f5a" translate="yes" xml:space="preserve">
          <source>That being said, there are several ways to approach this. In Perl 5.10 and later, you can use the smart match operator to check that an item is contained in an array or a hash:</source>
          <target state="translated">Учитывая это,есть несколько способов к этому подойти.В Perl 5.10 и более поздних версиях можно использовать оператор smart match для проверки того,что элемент содержится в массиве или хэше:</target>
        </trans-unit>
        <trans-unit id="0c260ee0a50dde66d3ef426f496fd0710d1eecdf" translate="yes" xml:space="preserve">
          <source>That being said, we value Perl's stability and security and have long had an unwritten covenant with the broader Perl community to support and maintain releases of Perl.</source>
          <target state="translated">Тем не менее,мы ценим стабильность и безопасность Perl и уже давно заключили неписаный договор с широким сообществом Perl о поддержке и поддержании освобождения Perl.</target>
        </trans-unit>
        <trans-unit id="bbe53d4c6627e25c7f5c04a5ce2e7f7fde39b418" translate="yes" xml:space="preserve">
          <source>That block is a proper block like any other, so you can put more complicated code there. This sends the message out to one of two places:</source>
          <target state="translated">Этот блок,как и любой другой,является правильным блоком,поэтому туда можно поместить более сложный код.Это отправляет сообщение в одно из двух мест:</target>
        </trans-unit>
        <trans-unit id="b8b88815853e7b011e14c857de7c3f74f6afc9bd" translate="yes" xml:space="preserve">
          <source>That build was a portable hppa-1.1 multithread build that supports large files compiled with gcc-2.9-hppa-991112.</source>
          <target state="translated">Это была портативная многопоточная сборка hppa-1.1,поддерживающая большие файлы,скомпилированные с gcc-2.9-hppa-991112.</target>
        </trans-unit>
        <trans-unit id="a5173e93037f4e02bac658ae6058928a497347a4" translate="yes" xml:space="preserve">
          <source>That can be achieved by overriding &lt;code&gt;init&lt;/code&gt; in your class and working on the main lexicon with code like that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51461163b856a03794ba96810bf1373b9d61492c" translate="yes" xml:space="preserve">
          <source>That clarifies the situation with regards Berkeley DB itself. What about &lt;b&gt;DB_File&lt;/b&gt;? Well, the behavior defined in the quote above is quite useful, so &lt;b&gt;DB_File&lt;/b&gt; conforms to it.</source>
          <target state="translated">Это проясняет ситуацию в отношении самой Berkeley DB. А как насчет &lt;b&gt;DB_File&lt;/b&gt; ? Что ж, поведение, определенное в приведенной выше цитате, весьма полезно, поэтому &lt;b&gt;DB_File ему&lt;/b&gt; соответствует.</target>
        </trans-unit>
        <trans-unit id="e4e253e3979e75b31e42c03e2604d27318e57461" translate="yes" xml:space="preserve">
          <source>That does the same thing as the previous code. &lt;code&gt;ok()&lt;/code&gt; is the backbone of Perl testing, and we'll be using it instead of roll-your-own from here on. If &lt;code&gt;ok()&lt;/code&gt; gets a true value, the test passes. False, it fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42854bfa17d6ca63556d6a3b16e69afee421b58e" translate="yes" xml:space="preserve">
          <source>That example prints something like &lt;code&gt;&quot;1314363215shiftbbb&quot;&lt;/code&gt; , because the &lt;code&gt;=&amp;gt;&lt;/code&gt; implicitly quotes the &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; immediately on its left, ignoring the fact that &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time.shift&lt;/a&gt;&lt;/code&gt; is the entire left operand.</source>
          <target state="translated">В этом примере печатается что-то вроде &lt;code&gt;&quot;1314363215shiftbbb&quot;&lt;/code&gt; , потому что &lt;code&gt;=&amp;gt;&lt;/code&gt; неявно цитирует &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; непосредственно слева от него, игнорируя тот факт, что &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time.shift&lt;/a&gt;&lt;/code&gt; - это весь левый операнд.</target>
        </trans-unit>
        <trans-unit id="159d20ef613406bd732f05ac0e1faa07f34a47ec" translate="yes" xml:space="preserve">
          <source>That example prints something like &lt;code&gt;&quot;1314363215shiftbbb&quot;&lt;/code&gt;, because the &lt;code&gt;=&amp;gt;&lt;/code&gt; implicitly quotes the &lt;code&gt;shift&lt;/code&gt; immediately on its left, ignoring the fact that &lt;code&gt;time.shift&lt;/code&gt; is the entire left operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435a3c58eaf95bd7ca9114e558f52a39c1b31273" translate="yes" xml:space="preserve">
          <source>That example will print &quot;I like dogs. I like cats&quot;. Notice the original &lt;code&gt;$x&lt;/code&gt; variable has not been affected. The overall result of the substitution is instead stored in &lt;code&gt;$y&lt;/code&gt; . If the substitution doesn't affect anything then the original string is returned:</source>
          <target state="translated">В этом примере будет напечатано &amp;laquo;Я люблю собак. Я люблю кошек&amp;raquo;. Обратите внимание, что исходная переменная &lt;code&gt;$x&lt;/code&gt; не изменилась. Вместо этого общий результат замены сохраняется в &lt;code&gt;$y&lt;/code&gt; . Если подстановка ни на что не влияет, возвращается исходная строка:</target>
        </trans-unit>
        <trans-unit id="7278130041b031a5215a18d766074e98a320d921" translate="yes" xml:space="preserve">
          <source>That example will print &quot;I like dogs. I like cats&quot;. Notice the original &lt;code&gt;$x&lt;/code&gt; variable has not been affected. The overall result of the substitution is instead stored in &lt;code&gt;$y&lt;/code&gt;. If the substitution doesn't affect anything then the original string is returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8395ebcf27841eba05938be973987efc8d458043" translate="yes" xml:space="preserve">
          <source>That explicit association is created by the built-in &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function, which is typically used within the</source>
          <target state="translated">Эта явная ассоциация создается встроенной функцией &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; , которая обычно используется в</target>
        </trans-unit>
        <trans-unit id="27b1cd2c668785cd9bb2dd2e3093b4e98220cdc9" translate="yes" xml:space="preserve">
          <source>That explicit association is created by the built-in &lt;code&gt;bless&lt;/code&gt; function, which is typically used within the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ec0978d45de2f32fa9de32d3062c113e6a14e6" translate="yes" xml:space="preserve">
          <source>That extra space comes from the interpolation of the array. If you don't want to put anything between your array elements, don't use the array in double quotes. You can send it to print without them:</source>
          <target state="translated">Это дополнительное пространство поступает из интерполяции массива.Если Вы не хотите помещать что-либо между элементами массива,не используйте массив в двойных кавычках.Вы можете отправить его на печать без них:</target>
        </trans-unit>
        <trans-unit id="9b298824efc1a224419fada1ed430ca9a977cee5" translate="yes" xml:space="preserve">
          <source>That function can be called with either of the following statements. Note the different argument lists.</source>
          <target state="translated">Эта функция может быть вызвана одним из следующих утверждений.Обратите внимание на различные списки аргументов.</target>
        </trans-unit>
        <trans-unit id="5a589d98a381dc121a0ca9e45213c36fe88d4b95" translate="yes" xml:space="preserve">
          <source>That gives you a parse-tree for each paragraph - so now all you need is an ordered list of paragraphs. You can maintain that yourself as a data element in the object/hash. The most straightforward way would be simply to use an array-ref, with the desired set of custom &quot;options&quot; for each invocation of &lt;b&gt;parse_text&lt;/b&gt;. Let's assume the desired option-set is given by the hash &lt;code&gt;%options&lt;/code&gt; . Then we might do something like the following:</source>
          <target state="translated">Это дает вам дерево синтаксического анализа для каждого абзаца - так что теперь все, что вам нужно, это упорядоченный список абзацев. Вы можете сохранить это сами как элемент данных в объекте / хэше. Самый простой способ - просто использовать array-ref с желаемым набором настраиваемых &amp;laquo;параметров&amp;raquo; для каждого вызова &lt;b&gt;parse_text&lt;/b&gt; . Предположим, что желаемый набор опций задается &lt;code&gt;%options&lt;/code&gt; hash % . Тогда мы могли бы сделать что-то вроде следующего:</target>
        </trans-unit>
        <trans-unit id="64f729272f1f6cba682dfada58129c0e19d1beec" translate="yes" xml:space="preserve">
          <source>That has historically been Perl's notion of UTF-8, as that is how UTF-8 was first conceived by Ken Thompson when he invented it. However, thanks to later revisions to the applicable standards, official UTF-8 is now rather stricter than that. For example, its range is much narrower (0 .. 0x10_FFFF to cover only 21 bits instead of 32 or 64 bits) and some sequences are not allowed, like those used in surrogate pairs, the 31 non-character code points 0xFDD0 .. 0xFDEF, the last two code points in</source>
          <target state="translated">Исторически это было понятие Перла о UTF-8,так как именно так UTF-8 был впервые задуман Кеном Томпсоном,когда он его изобрел.Однако,благодаря более поздним изменениям в применимых стандартах,официальная UTF-8 теперь более строгая.Например,его диапазон значительно сужается (0 ...0x10_FFFFF,чтобы покрыть только 21 бит вместо 32 или 64 бит),а некоторые последовательности не допускаются,как те,что используются в суррогатных парах,31 несимвольный код указывает на 0xFDD0 ...0xFDEF,последние два кода указывают на то,что в</target>
        </trans-unit>
        <trans-unit id="d65679687da0ceb818cf54be11aba010b00841bb" translate="yes" xml:space="preserve">
          <source>That has the same effect as</source>
          <target state="translated">Это имеет тот же эффект,что и</target>
        </trans-unit>
        <trans-unit id="70ca5d290cf7d16b2ad0d56ac0c8bb778d981254" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. Perl is C89. Using the //-comments is silently allowed by many C compilers but cranking up the ANSI C89 strictness (which we like to do) causes the compilation to fail.</source>
          <target state="translated">Это C99 или C++.Перл-это С89.Использование //-комментариев беззвучно разрешено многими компиляторами Си,но включение строгости ANSI C89 (что нам нравится делать)приводит к ошибке компиляции.</target>
        </trans-unit>
        <trans-unit id="fbc80ae07cc14a3e9ed515ddb417d3903b3e2d4c" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. Some C compilers allow that, but you shouldn't.</source>
          <target state="translated">Это C99 или C++.Некоторые компиляторы Си позволяют это,но не стоит.</target>
        </trans-unit>
        <trans-unit id="828feba24600ccd2337dfee90dbb710d49a4eff3" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. While it would indeed be awfully nice to have that also in C89, to limit the scope of the loop variable, alas, we cannot.</source>
          <target state="translated">Это C99 или C++.Хотя было бы действительно ужасно здорово,если бы это было и в C89,но ограничить область действия переменной цикла,увы,мы не можем.</target>
        </trans-unit>
        <trans-unit id="7473aa8c2d92485250630b49f5d5752d8eea9b3d" translate="yes" xml:space="preserve">
          <source>That is all covered in the documentation for Locale::Maketext and the modules that come with it, available in CPAN. After having read this article, which covers the why's of Maketext, the documentation, which covers the how's of it, should be quite straightforward.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c6f4c7bbbd6286d0fe21947d2ba8ade38beb92" translate="yes" xml:space="preserve">
          <source>That is because the translation from EBCDIC to ASCII is done by the web server in this case. Consult your web server's documentation for further details.</source>
          <target state="translated">Это связано с тем,что перевод с EBCDIC на ASCII в данном случае выполняется веб-сервером.Для получения более подробной информации обратитесь к документации Вашего веб-сервера.</target>
        </trans-unit>
        <trans-unit id="942bc883ec6c98a20c711318e17853f42162c195" translate="yes" xml:space="preserve">
          <source>That is exactly equivalent to</source>
          <target state="translated">Это в точности эквивалентно</target>
        </trans-unit>
        <trans-unit id="755dfd149254cee016be67859ecceb8b680f03fe" translate="yes" xml:space="preserve">
          <source>That is fine as far as it goes. The thing is, the Perl subroutine can be specified as only a string, however, Perl allows references to subroutines and anonymous subroutines. This is where</source>
          <target state="translated">Это нормально,насколько это возможно.Дело в том,что подпрограмма Perl может быть указана только как строка,однако Perl допускает ссылки на подпрограммы и анонимные подпрограммы.Вот где</target>
        </trans-unit>
        <trans-unit id="f6e51945777f4de56dfd6b06b12bc029f8de1ebc" translate="yes" xml:space="preserve">
          <source>That is just short for this:</source>
          <target state="translated">Это просто сокращение от этого:</target>
        </trans-unit>
        <trans-unit id="48a322119a3ce010a99cb16daaa24fe8a2a63a40" translate="yes" xml:space="preserve">
          <source>That is, a &quot;start&quot; character followed by any number of &quot;continue&quot; characters. Perl requires every character in an identifier to also match &lt;code&gt;\w&lt;/code&gt; (this prevents some problematic cases); and Perl additionally accepts identfier names beginning with an underscore.</source>
          <target state="translated">То есть за &amp;laquo;начальным&amp;raquo; символом следует любое количество &amp;laquo;продолжающих&amp;raquo; символов. Perl требует, чтобы каждый символ в идентификаторе также соответствовал &lt;code&gt;\w&lt;/code&gt; (это предотвращает некоторые проблемные случаи); а Perl дополнительно принимает имена идентификаторов, начинающиеся с подчеркивания.</target>
        </trans-unit>
        <trans-unit id="6558436d977d36dc225d2cf7090e600f732d6f4d" translate="yes" xml:space="preserve">
          <source>That is, a &lt;code&gt;'code...'&lt;/code&gt; filter</source>
          <target state="translated">То есть фильтр &lt;code&gt;'code...'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f4f6b5b263faf39b0387453cc01be5508d1f769" translate="yes" xml:space="preserve">
          <source>That is, a complex number with the real part of approximately &lt;code&gt;1.571&lt;/code&gt; and the imaginary part of approximately &lt;code&gt;-1.317&lt;/code&gt; .</source>
          <target state="translated">То есть комплексное число с действительной частью примерно &lt;code&gt;1.571&lt;/code&gt; и мнимой частью примерно &lt;code&gt;-1.317&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="482980394273a0467a584ab6d2a57dbf1c99aa5d" translate="yes" xml:space="preserve">
          <source>That is, a complex number with the real part of approximately &lt;code&gt;1.571&lt;/code&gt; and the imaginary part of approximately &lt;code&gt;-1.317&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eeeaa892b3243ba38eb1a4d1d75a40e3e83e990" translate="yes" xml:space="preserve">
          <source>That is, any word character in the ASCII range, as long as the first character is not a digit.</source>
          <target state="translated">То есть любой символ слова в диапазоне ASCII,если первый символ не является цифрой.</target>
        </trans-unit>
        <trans-unit id="36c759497b0b38fb79d0c364113b1512a2c43723" translate="yes" xml:space="preserve">
          <source>That is, both are like this:</source>
          <target state="translated">То есть,и то,и другое вот так:</target>
        </trans-unit>
        <trans-unit id="cbeb96e56e49bccd6548d94f7137868a0f109bb7" translate="yes" xml:space="preserve">
          <source>That is, fetch the &lt;code&gt;a&lt;/code&gt; entry from the main symbol table, and then look at the scalar component of it: &lt;code&gt;gvsv&lt;/code&gt; (&lt;code&gt;pp_gvsv&lt;/code&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75581dadc9573c00040ace36ddd58570a8c1a03a" translate="yes" xml:space="preserve">
          <source>That is, fetch the &lt;code&gt;a&lt;/code&gt; entry from the main symbol table, and then look at the scalar component of it: &lt;code&gt;gvsv&lt;/code&gt; (&lt;code&gt;pp_gvsv&lt;/code&gt; into</source>
          <target state="translated">То есть выберите запись &lt;code&gt;a&lt;/code&gt; из основной таблицы символов, а затем посмотрите на ее скалярный компонент: &lt;code&gt;gvsv&lt;/code&gt; ( &lt;code&gt;pp_gvsv&lt;/code&gt; into</target>
        </trans-unit>
        <trans-unit id="f3442fe5454be65a5f12295c4981af0a997452b8" translate="yes" xml:space="preserve">
          <source>That is, instead of writing this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe7215514db7a28aa89b16be5f49f87245a3434d" translate="yes" xml:space="preserve">
          <source>That is, it creates a region consisting of a single paragraph; that paragraph is to be treated as a normal paragraph if &quot;formatname&quot; begins with a &quot;:&quot;; if &quot;formatname&quot;</source>
          <target state="translated">Иными словами,он создает регион,состоящий из одного пункта;этот пункт следует рассматривать как обычный пункт,если &quot;имя формата&quot; начинается со слова &quot;:&quot;;если &quot;имя формата&quot;.</target>
        </trans-unit>
        <trans-unit id="7678e34c3ebdef14cc53701ea7fd891c9a91f614" translate="yes" xml:space="preserve">
          <source>That is, it runs a conversion with default options, for whatever inputdirs and output dir you specify.</source>
          <target state="translated">То есть,он запускает преобразование с опциями по умолчанию,для любых входных и выходных dir,которые вы укажете.</target>
        </trans-unit>
        <trans-unit id="27a7e3645a7eb93795bc368264f8f8cb79cd561d" translate="yes" xml:space="preserve">
          <source>That is, it treated both matches as undefined, and converted that to false (raising a warning on each). The first case is the expected result, but the second is likely counterintuitive: &quot;How could both be false when they are complements?&quot; Another problem was that the implementation optimized many Unicode property matches down to already existing simpler, faster operations, which don't raise the warning. We chose to not forgo those optimizations, which help the vast majority of matches, just to generate a warning for the unlikely event that an above-Unicode code point is being matched against.</source>
          <target state="translated">То есть,он рассматривал оба совпадения как неопределенные и преобразовывал их в ложные (повышая предупреждение на каждое).В первом случае это ожидаемый результат,а во втором,скорее всего,это противоречит интуиции:&quot;Как оба могут быть ложными,когда они являются дополнениями?&quot;.Другая проблема заключается в том,что реализация оптимизировала многие совпадения свойств Юникода вплоть до уже существующих более простых и быстрых операций,которые не повышают предупреждение.Мы решили не отказываться от этих оптимизаций,которые помогают подавляющему большинству совпадений,только для того,чтобы выдать предупреждение на маловероятный случай,когда сопоставляется точка над кодом Юникода.</target>
        </trans-unit>
        <trans-unit id="b2448cc58794e445286f5f6bd3ff90ad3138eeba" translate="yes" xml:space="preserve">
          <source>That is, there should be (at least roughly) equal spacing between items as between paragraphs (although that spacing may well be less than the full height of a line of text). This leaves it to the reader to use (con)textual cues to figure out whether the &quot;Qui dolorem ipsum...&quot; paragraph applies to the &quot;Quisquam Est&quot; item or to all three items &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;. While not an ideal situation, this is preferable to providing formatting cues that may be actually contrary to the author's intent.</source>
          <target state="translated">То есть между пунктами должно быть (по крайней мере,примерно)равное расстояние,как и между абзацами (хотя это расстояние вполне может быть меньше,чем полная высота строки текста).Это оставляет за читателем право использовать (кон)текстовые подсказки,чтобы выяснить,применяется ли абзац &quot;Qui dolorem ipsum...&quot; к пункту &quot;Quisquam Est&quot; или ко всем трем пунктам &quot;Neque&quot;,&quot;Porro&quot; и &quot;Quisquam Est&quot;.Хотя эта ситуация и не является идеальной,она предпочтительнее,чем форматирование подсказок,которые могут фактически противоречить намерениям автора.</target>
        </trans-unit>
        <trans-unit id="1e5a6f76070bd03364763274b3558ec3c231e14e" translate="yes" xml:space="preserve">
          <source>That is, they all produce the same event structure (for the most part), namely:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a300a2c4d8d472deffaf92f425ba9342ddb708" translate="yes" xml:space="preserve">
          <source>That is, to get a number between 10 and 15, inclusive, you want a random number between 0 and 5 that you can then add to 10.</source>
          <target state="translated">То есть,чтобы получить число от 10 до 15,включительно,вы хотите случайное число от 0 до 5,которое вы можете затем добавить к 10.</target>
        </trans-unit>
        <trans-unit id="951f36d3e716f12408c22757558026bf31602523" translate="yes" xml:space="preserve">
          <source>That is, with &quot;=for&quot;, you can have only one paragraph's worth of text (i.e., the text in &quot;=foo targetname text...&quot;), but with &quot;=begin targetname&quot; ... &quot;=end targetname&quot;, you can have any amount of stuff in between. (Note that there still must be a blank line after the &quot;=begin&quot; command and a blank line before the &quot;=end&quot; command.)</source>
          <target state="translated">То есть,с помощью &quot;=for&quot; можно получить только один абзац текста (т.е.текст в &quot;=foo targetname text...&quot;),но с помощью &quot;=begin targetname&quot;...&quot;=имя цели&quot;,вы можете иметь любое количество вещей между ними.(Обратите внимание,что после команды &quot;=begin&quot; должна остаться пустая строка,а перед командой &quot;=end&quot;-пустая).</target>
        </trans-unit>
        <trans-unit id="bc1a3360b8c34a0baef326cea1af80815467c26c" translate="yes" xml:space="preserve">
          <source>That last test line above should have the number '3' instead of '2'.</source>
          <target state="translated">В последней тестовой строке выше должно быть число '3' вместо '2'.</target>
        </trans-unit>
        <trans-unit id="c5a055a52b37b46f2d6c0e63eaf4e182af37b495" translate="yes" xml:space="preserve">
          <source>That looks a bit nicer; but we've got to take apart that weird template. Where did I pull that out of?</source>
          <target state="translated">Выглядит немного лучше,но мы должны разобрать этот странный шаблон.Где я его вытащил?</target>
        </trans-unit>
        <trans-unit id="61626fcd66a349166c06495de786a6747ef2482c" translate="yes" xml:space="preserve">
          <source>That may be what you want, but if what you really want is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c566d34d221f1316f52ee4a141ea9a232b591ec1" translate="yes" xml:space="preserve">
          <source>That means all the gzip support has to be done by hand - in this case by creating a tied filehandle to deal with creating the gzip header and trailer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d5efec9cd6d8da4fb36301f3de63b6888e753f1" translate="yes" xml:space="preserve">
          <source>That means that the address comes back in binary for the host functions, and as a regular perl integer for the net ones. This seems a bug, but here's how to deal with it:</source>
          <target state="translated">Это означает,что адрес возвращается в двоичном виде для функций хоста,и в виде обычного числа perl для сетевых.Это кажется ошибкой,но вот как с ней справиться:</target>
        </trans-unit>
        <trans-unit id="f3988f8ba5df3605cc3a35c620ff3fb6ee001ddb" translate="yes" xml:space="preserve">
          <source>That means that the inheritance tree of the object is traversed breadth-first and the resulting order of classes is used as the sequence in which methods are called. However, that sequence is modified by imposing a rule that the appropriate method of a derived class must be called before the same method of any ancestral class. That's why, in the above example, &lt;code&gt;X::foo&lt;/code&gt; is called before &lt;code&gt;D::foo&lt;/code&gt; , even though &lt;code&gt;D&lt;/code&gt; comes before &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;@B::ISA&lt;/code&gt; .</source>
          <target state="translated">Это означает, что дерево наследования объекта просматривается в ширину, и результирующий порядок классов используется как последовательность, в которой вызываются методы. Однако эта последовательность модифицируется путем введения правила, согласно которому соответствующий метод производного класса должен вызываться перед тем же методом любого родительского класса. Вот почему в приведенном выше примере &lt;code&gt;X::foo&lt;/code&gt; вызывается перед &lt;code&gt;D::foo&lt;/code&gt; , хотя &lt;code&gt;D&lt;/code&gt; стоит перед &lt;code&gt;X&lt;/code&gt; в &lt;code&gt;@B::ISA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5e47decd3f17a0dbcacce7016d0aedaa3f7c7e2" translate="yes" xml:space="preserve">
          <source>That means that the inheritance tree of the object is traversed breadth-first and the resulting order of classes is used as the sequence in which methods are called. However, that sequence is modified by imposing a rule that the appropriate method of a derived class must be called before the same method of any ancestral class. That's why, in the above example, &lt;code&gt;X::foo&lt;/code&gt; is called before &lt;code&gt;D::foo&lt;/code&gt;, even though &lt;code&gt;D&lt;/code&gt; comes before &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;@B::ISA&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a75b8fa4871b84e34a76476fddd056744d525a" translate="yes" xml:space="preserve">
          <source>That means that you can specify other options (e.g. cachesize) and still have bval default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; for variable length records, and space for fixed length records.</source>
          <target state="translated">Это означает, что вы можете указать другие параметры (например, cachesize) и по-прежнему иметь значение по умолчанию для bval &lt;code&gt;&quot;\n&quot;&lt;/code&gt; для записей переменной длины и пространство для записей фиксированной длины.</target>
        </trans-unit>
        <trans-unit id="7045c7edb73bdaec4db668503265f3c3aee4ce06" translate="yes" xml:space="preserve">
          <source>That means you can only use this function to look at or manipulate text before or after complete JSON objects, not while the parser is in the middle of parsing a JSON object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f3ac9162c57e4899c7d0b17b547a39f0dc6701" translate="yes" xml:space="preserve">
          <source>That means, for example, that you can freely add or remove white space adjacent to (but within) the braces and the colon or equal sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccd6e36decb0fa14e4cd9ccfdb15ab74bfe0e9c" translate="yes" xml:space="preserve">
          <source>That means, for example, that you can freely add or remove white space adjacent to (but within) the braces without affecting the meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef48d86c4cc8b17f43db860898bcc6635d718b02" translate="yes" xml:space="preserve">
          <source>That method may be best because otherwise you won't treat IEEE notations like &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt; properly. At other times, you might prefer to determine whether string data can be used numerically by calling the POSIX::strtod() function or by inspecting your string with a regular expression (as documented in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;).</source>
          <target state="translated">Этот метод может быть лучшим, потому что в противном случае вы не будете правильно обрабатывать нотации IEEE, такие как &lt;code&gt;NaN&lt;/code&gt; или &lt;code&gt;Infinity&lt;/code&gt; . В других случаях вы можете предпочесть определить, могут ли строковые данные использоваться численно, вызвав функцию POSIX :: strtod () или &lt;a href=&quot;perlre&quot;&gt;проверив&lt;/a&gt; вашу строку с помощью регулярного выражения (как описано в perlre ).</target>
        </trans-unit>
        <trans-unit id="6fd672a313da74831278f92221ca3146d4b9f20c" translate="yes" xml:space="preserve">
          <source>That no other fields exist besides the ones you know of</source>
          <target state="translated">Что других полей не существует,кроме тех,о которых вы знаете.</target>
        </trans-unit>
        <trans-unit id="5527de36ef73a03f5b5a63ba8cbaf8b4f3a8fcb3" translate="yes" xml:space="preserve">
          <source>That now parses as you'd expect, but you still ought to get in the habit of using parentheses in that situation. For more on prototypes, see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">Теперь анализируется так, как вы и ожидали, но вы все равно должны иметь привычку использовать круглые скобки в этой ситуации. Подробнее о прототипах см. &lt;a href=&quot;perlsub&quot;&gt;Perlsub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7cb196541b3b7a98e0a23cefd4f853e129fa465" translate="yes" xml:space="preserve">
          <source>That output isn't terribly descriptive, is it? When you have two tests you can figure out which one is #2, but what if you have 102 tests?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37fa65fedd67f278b74cbc5a381d76fb677b39a" translate="yes" xml:space="preserve">
          <source>That prints &lt;code&gt;&quot;unphooey&quot;&lt;/code&gt; . (Yes, there are still unresolved issues having to do with visibility of &lt;code&gt;@_&lt;/code&gt; . I'm ignoring that question for the moment. (But note that if we make &lt;code&gt;@_&lt;/code&gt; lexically scoped, those anonymous subroutines can act like closures... (Gee, is this sounding a little Lispish? (Never mind.))))</source>
          <target state="translated">Это печатает &lt;code&gt;&quot;unphooey&quot;&lt;/code&gt; . (Да, все еще есть нерешенные проблемы, связанные с видимостью &lt;code&gt;@_&lt;/code&gt; . Я пока игнорирую этот вопрос. (Но обратите внимание, что если мы сделаем &lt;code&gt;@_&lt;/code&gt; лексически ограниченным, эти анонимные подпрограммы могут действовать как замыкания ... ( Ну и дела, это звучит немного по-лиспийски? (Неважно.))))</target>
        </trans-unit>
        <trans-unit id="b70a77bf7cab1beed053568dab5acfb8d2eb3eda" translate="yes" xml:space="preserve">
          <source>That prints &lt;code&gt;&quot;unphooey&quot;&lt;/code&gt;. (Yes, there are still unresolved issues having to do with visibility of &lt;code&gt;@_&lt;/code&gt;. I'm ignoring that question for the moment. (But note that if we make &lt;code&gt;@_&lt;/code&gt; lexically scoped, those anonymous subroutines can act like closures... (Gee, is this sounding a little Lispish? (Never mind.))))</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f34b1d00199940c59db31a2c92190f8c2d18ac" translate="yes" xml:space="preserve">
          <source>That prints out: &lt;code&gt;&quot;The third fish is a red one.&quot;&lt;/code&gt; You can also use a repetition count and repeated pattern like this:</source>
          <target state="translated">Это выводит на печать: &lt;code&gt;&quot;The third fish is a red one.&quot;&lt;/code&gt; Вы также можете использовать счетчик повторений и повторяющийся шаблон следующим образом:</target>
        </trans-unit>
        <trans-unit id="efe950f82cdddb13c9f97d9e858479f8a7148487" translate="yes" xml:space="preserve">
          <source>That problem is corrected by using the &lt;code&gt;&amp;amp;&lt;/code&gt; operator. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will now turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; correctly with parameters &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; . It does this by carrying the &lt;code&gt;&amp;amp;&lt;/code&gt; through, so the function call looks like &lt;code&gt;rpcb_gettime(host, &amp;amp;timep)&lt;/code&gt; .</source>
          <target state="translated">Эта проблема исправляется с помощью оператора &lt;code&gt;&amp;amp;&lt;/code&gt; . &lt;b&gt;Xsubpp&lt;/b&gt; компилятор теперь превратить это в код , который вызывает &lt;code&gt;rpcb_gettime()&lt;/code&gt; правильно с параметрами &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; . Он делает это, &lt;code&gt;rpcb_gettime(host, &amp;amp;timep)&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; , поэтому вызов функции выглядит как rpcb_gettime (host, &amp;amp; timep) .</target>
        </trans-unit>
        <trans-unit id="9cdeebf2bdaf24e4c227b81d4e7ade3f1477fb5b" translate="yes" xml:space="preserve">
          <source>That problem is corrected by using the &lt;code&gt;&amp;amp;&lt;/code&gt; operator. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will now turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; correctly with parameters &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt;. It does this by carrying the &lt;code&gt;&amp;amp;&lt;/code&gt; through, so the function call looks like &lt;code&gt;rpcb_gettime(host, &amp;amp;timep)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd92600acf1aacb4bb45d3c98acc1cde89639e0e" translate="yes" xml:space="preserve">
          <source>That produces a new perl binary in the current directory with all extensions linked in that can be found in INST_ARCHLIB, SITELIBEXP, and PERL_ARCHLIB. To do that, MakeMaker writes a new Makefile, on UNIX, this is called</source>
          <target state="translated">Это создает новый двоичный файл perl в текущем каталоге со всеми расширениями,связанными с ним,которые можно найти в INST_ARCHLIB,SITELIBEXP и PERL_ARCHLIB.Для этого MakeMaker пишет новый Makefile,на UNIX,который называется</target>
        </trans-unit>
        <trans-unit id="4fc05162b844f86aa42257bcfb3642341ec2e119" translate="yes" xml:space="preserve">
          <source>That sadly does not (yet) work on QorIQ. At the moment of writing, the supported architectures are armv5, armv7, mipsel, wl500g, x86_32, and x86_64. Check &lt;a href=&quot;https://pkg.entware.net/binaries/&quot;&gt;here&lt;/a&gt; for supported platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2351c4ce268ed6ae21d8f1fadbceac3b965331bf" translate="yes" xml:space="preserve">
          <source>That said, &lt;code&gt;miniperl -Ilib -MConfig -we 1&lt;/code&gt; should report an error, because it can not find</source>
          <target state="translated">Тем не менее, &lt;code&gt;miniperl -Ilib -MConfig -we 1&lt;/code&gt; должен сообщать об ошибке, потому что не может найти</target>
        </trans-unit>
        <trans-unit id="55a11affd308eca30c6c076da831e9e75ab6c62b" translate="yes" xml:space="preserve">
          <source>That said, be aware that Perl version 5.14 introduces an exception to the rule, for syntactic convenience. Experimental array and hash container function behavior allows array and hash references to be handled by Perl as if they had been explicitly syntactically dereferenced. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl5140delta.html#Syntactical-Enhancements&quot;&gt;Syntactical Enhancements in perl5140delta&lt;/a&gt; and &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details.</source>
          <target state="translated">Тем не менее, имейте в виду, что Perl версии 5.14 вводит исключение из правила для синтаксического удобства. Экспериментальное поведение функции массива и хеш-контейнера позволяет Perl обрабатывать ссылки на массивы и хеш-коды, как если бы они были явно синтаксически разыменованы. См. Подробности в разделе &amp;laquo; &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl5140delta.html#Syntactical-Enhancements&quot;&gt;Синтаксические улучшения в perl5140delta&lt;/a&gt; и &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd96836988cad318a9323c182f881952adb3274c" translate="yes" xml:space="preserve">
          <source>That said, there are a number of steps that can be taken to make life difficult for the potential cracker. The most important: Write your decryption filter in C and statically link the decryption module into the Perl binary. For further tips to make life difficult for the potential cracker, see the file</source>
          <target state="translated">Тем не менее,есть ряд шагов,которые могут быть предприняты для того,чтобы усложнить жизнь потенциальному взломщику.Самое важное:Запишите дешифровальный фильтр на C и установите статическую связь между модулем дешифровки и бинарным файлом Perl.Дальнейшие советы,которые могут усложнить жизнь потенциальному взломщику,см.в файле</target>
        </trans-unit>
        <trans-unit id="6ebc1959c7e697a446f0d0678eca3b28f8c37055" translate="yes" xml:space="preserve">
          <source>That said, there will always be small, focused, special-purpose languages dedicated to a specific problem domain that are simply more convenient for certain kinds of problems. Perl tries to be all things to all people, but nothing special to anyone. Examples of specialized languages that come to mind include prolog and matlab.</source>
          <target state="translated">При этом всегда будут существовать небольшие,целенаправленные,специализированные языки,посвященные конкретной проблемной области,которые просто более удобны для решения определенного рода проблем.Perl старается быть всем для всех людей,но ничего особенного ни для кого.Примерами специализированных языков,которые приходят на ум,являются пролог и matlab.</target>
        </trans-unit>
        <trans-unit id="e78afc53e325aea84cf9c7e198003b89094d500a" translate="yes" xml:space="preserve">
          <source>That same loop could be replaced with a slice operation:</source>
          <target state="translated">Эту же петлю можно заменить операцией на срез:</target>
        </trans-unit>
        <trans-unit id="c28091748ec2b3306715e341483bb158b9c0cd3f" translate="yes" xml:space="preserve">
          <source>That second argument may be either a &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt;'d regular expression (which is then used to match the terminator line), or a defined false value (which indicates that no terminator line should be looked for), or a reference to a hash (in which case the terminator is the value associated with the key &lt;code&gt;'terminator'&lt;/code&gt; .</source>
          <target state="translated">Этот второй аргумент может быть либо регулярным выражением &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt; 'd (которое затем используется для сопоставления строки терминатора), либо определенным ложным значением (которое указывает, что не следует искать строку терминатора), либо ссылкой на хэш (в в этом случае терминатор - это значение, связанное с ключом &lt;code&gt;'terminator'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75416fa5f847a38d5ad02218210c2358173e5f41" translate="yes" xml:space="preserve">
          <source>That second argument may be either a &lt;code&gt;qr&lt;/code&gt;'d regular expression (which is then used to match the terminator line), or a defined false value (which indicates that no terminator line should be looked for), or a reference to a hash (in which case the terminator is the value associated with the key &lt;code&gt;'terminator'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0abf2ef0e2b7f166486ede4264164097c7510116" translate="yes" xml:space="preserve">
          <source>That should be written:</source>
          <target state="translated">Это должно быть написано:</target>
        </trans-unit>
        <trans-unit id="21e34acb57e36768d34631cec4d8c18d970f96ef" translate="yes" xml:space="preserve">
          <source>That should probably be written more simply as:</source>
          <target state="translated">Это,наверное,должно быть написано проще:</target>
        </trans-unit>
        <trans-unit id="6c2b874251fc59b8ebf4af56444c528d2be2ade1" translate="yes" xml:space="preserve">
          <source>That shows the &lt;code&gt;UTF8&lt;/code&gt; flag in FLAGS and both the UTF-8 bytes and Unicode characters in &lt;code&gt;PV&lt;/code&gt; . See also later in this document the discussion about the &lt;code&gt;utf8::is_utf8()&lt;/code&gt; function.</source>
          <target state="translated">Это показывает флаг &lt;code&gt;UTF8&lt;/code&gt; в FLAGS и байты UTF-8 и символы Unicode в &lt;code&gt;PV&lt;/code&gt; . См. Также далее в этом документе обсуждение функции &lt;code&gt;utf8::is_utf8()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85f3321460ffe7c824d8d5e2118a4e8f2a1ba235" translate="yes" xml:space="preserve">
          <source>That shows the &lt;code&gt;UTF8&lt;/code&gt; flag in FLAGS and both the UTF-8 bytes and Unicode characters in &lt;code&gt;PV&lt;/code&gt;. See also later in this document the discussion about the &lt;code&gt;utf8::is_utf8()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90310d92761cded68c459a20fa9fa044cf2b05ae" translate="yes" xml:space="preserve">
          <source>That speeds things up but I have to make a note of which tests are failing and make sure that I run those tests. Instead I can use prove's --state switch and have it keep track of failing tests for me. First I do a complete run of the test suite and tell prove to save the results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f7e088596d63a221ae18b14ab5e5b19e9feddc" translate="yes" xml:space="preserve">
          <source>That stores a machine readable summary of the test run in a file called '.prove' in the current directory. If I have failures I can then run just the failing scripts like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032b01f3384ab611cdf4fd40994fa76549ad8c4f" translate="yes" xml:space="preserve">
          <source>That syntax simply won't work. It sets just &lt;code&gt;@a&lt;/code&gt; or &lt;code&gt;%a&lt;/code&gt; and clears the &lt;code&gt;@b&lt;/code&gt; or &lt;code&gt;%b&lt;/code&gt; . Plus the function didn't get passed into two separate arrays or hashes: it got one long list in &lt;code&gt;@_&lt;/code&gt; , as always.</source>
          <target state="translated">Этот синтаксис просто не работает. Он устанавливает только &lt;code&gt;@a&lt;/code&gt; или &lt;code&gt;%a&lt;/code&gt; и очищает &lt;code&gt;@b&lt;/code&gt; или &lt;code&gt;%b&lt;/code&gt; . К тому же функция не попала в два отдельных массива или хэшей: как всегда, она получила один длинный список в &lt;code&gt;@_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="129289f49f37b2d5f60aa742ea447f8c63a26d22" translate="yes" xml:space="preserve">
          <source>That syntax simply won't work. It sets just &lt;code&gt;@a&lt;/code&gt; or &lt;code&gt;%a&lt;/code&gt; and clears the &lt;code&gt;@b&lt;/code&gt; or &lt;code&gt;%b&lt;/code&gt;. Plus the function didn't get passed into two separate arrays or hashes: it got one long list in &lt;code&gt;@_&lt;/code&gt;, as always.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7adc8c9bedd29857f8a7951c4ad397c707680f4" translate="yes" xml:space="preserve">
          <source>That temporarily undefs your record separator, and will automatically close the file at block exit. If the file is already open, just use this:</source>
          <target state="translated">Это временно отменяет разделитель записей и автоматически закрывает файл при выходе из блока.Если файл уже открыт,просто используйте это:</target>
        </trans-unit>
        <trans-unit id="e79dac633171d977159db125388db2bf16415ce0" translate="yes" xml:space="preserve">
          <source>That the fields are in a certain order</source>
          <target state="translated">Что поля в определенном порядке</target>
        </trans-unit>
        <trans-unit id="5adec0092e434c8b7770e6ed721609aafb6fb0d1" translate="yes" xml:space="preserve">
          <source>That the sizeof(struct) or the alignments are the same everywhere</source>
          <target state="translated">Что sizeof(struct)или выравнивание везде одинаковы.</target>
        </trans-unit>
        <trans-unit id="ff9ccf09dc2dc150e284071ebd76e3a60583513f" translate="yes" xml:space="preserve">
          <source>That third argument tests the byte size of the data on the &lt;code&gt;$fh&lt;/code&gt; filehandle and reads that many bytes into the buffer &lt;code&gt;$var&lt;/code&gt; .</source>
          <target state="translated">Этот третий аргумент проверяет размер байта данных в дескрипторе файла &lt;code&gt;$fh&lt;/code&gt; и считывает это количество байтов в буфер &lt;code&gt;$var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="949fbe166b991dbecc0e8400e8a8c343a056cb09" translate="yes" xml:space="preserve">
          <source>That third argument tests the byte size of the data on the &lt;code&gt;$fh&lt;/code&gt; filehandle and reads that many bytes into the buffer &lt;code&gt;$var&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38036119f27283dda19af4e5c3596941c97c5a13" translate="yes" xml:space="preserve">
          <source>That way, quant just has to chose which form it needs, without having to look up or generate anything. While possibly not optimal for Russian, this should work well for most other languages, where quantification is not as complicated an operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f38824e1c7c399bcd876c5d796e89f3c65e609e8" translate="yes" xml:space="preserve">
          <source>That will efficiently match a nonempty group with matching parentheses two levels deep or less. However, if there is no such group, it will take virtually forever on a long string. That's because there are so many different ways to split a long string into several substrings. This is what &lt;code&gt;(.+)+&lt;/code&gt; is doing, and &lt;code&gt;(.+)+&lt;/code&gt; is similar to a subpattern of the above pattern. Consider how the pattern above detects no-match on &lt;code&gt;((()aaaaaaaaaaaaaaaaaa&lt;/code&gt; in several seconds, but that each extra letter doubles this time. This exponential performance will make it appear that your program has hung. However, a tiny change to this pattern</source>
          <target state="translated">Это будет эффективно соответствовать непустой группе с соответствующими круглыми скобками на два уровня или меньше. Однако, если такой группы нет, это займет практически вечность на длинной цепочке. Это потому, что существует так много разных способов разбить длинную строку на несколько подстрок. Это то, что делает &lt;code&gt;(.+)+&lt;/code&gt; , А &lt;code&gt;(.+)+&lt;/code&gt; Похож на подшаблон вышеуказанного шаблона. Подумайте, как приведенный выше шаблон обнаруживает &lt;code&gt;((()aaaaaaaaaaaaaaaaaa&lt;/code&gt; на (() aaaaaaaaaaaaaaaaaa за несколько секунд, но что каждая дополнительная буква на этот раз удваивается. Эта экспоненциальная производительность создаст впечатление, что ваша программа зависла. Однако небольшое изменение в этом шаблоне</target>
        </trans-unit>
        <trans-unit id="d2c33811186783297750533407ae69a2c30dbe1c" translate="yes" xml:space="preserve">
          <source>That will print out &lt;code&gt;20&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt; .</source>
          <target state="translated">Это напечатает &lt;code&gt;20&lt;/code&gt; и &lt;code&gt;10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e40934849066a98371a45c630d963f7be828b226" translate="yes" xml:space="preserve">
          <source>That will print out &lt;code&gt;20&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844b1a95e3bd3c94e0935eae872c27cb6a3ae275" translate="yes" xml:space="preserve">
          <source>That will print out:</source>
          <target state="translated">Это распечатает:</target>
        </trans-unit>
        <trans-unit id="05490647754607e7eecb9c45fdd4f2b090c65042" translate="yes" xml:space="preserve">
          <source>That will run all tests in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6db72df23e281596a803d5b93d6efaedb2438e" translate="yes" xml:space="preserve">
          <source>That will run the script &lt;b&gt;myprogram&lt;/b&gt; without human intervention, printing out the call tree with entry and exit points. Note that &lt;code&gt;NonStop=1 frame=2&lt;/code&gt; is equivalent to &lt;code&gt;N f=2&lt;/code&gt; , and that originally, options could be uniquely abbreviated by the first letter (modulo the &lt;code&gt;Dump*&lt;/code&gt; options). It is nevertheless recommended that you always spell them out in full for legibility and future compatibility.</source>
          <target state="translated">Это запустит скрипт &lt;b&gt;myprogram&lt;/b&gt; без вмешательства человека, распечатав дерево вызовов с точками входа и выхода. Обратите внимание, что &lt;code&gt;NonStop=1 frame=2&lt;/code&gt; эквивалентно &lt;code&gt;N f=2&lt;/code&gt; , и что изначально параметры могли быть однозначно сокращены по первой букве (по модулю параметров &lt;code&gt;Dump*&lt;/code&gt; ). Тем не менее рекомендуется всегда описывать их полностью для удобства чтения и совместимости в будущем.</target>
        </trans-unit>
        <trans-unit id="9b8798239553ae3afadcaa20b0a364d6ef25290e" translate="yes" xml:space="preserve">
          <source>That will run the script &lt;b&gt;myprogram&lt;/b&gt; without human intervention, printing out the call tree with entry and exit points. Note that &lt;code&gt;NonStop=1 frame=2&lt;/code&gt; is equivalent to &lt;code&gt;N f=2&lt;/code&gt;, and that originally, options could be uniquely abbreviated by the first letter (modulo the &lt;code&gt;Dump*&lt;/code&gt; options). It is nevertheless recommended that you always spell them out in full for legibility and future compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06ee710fae521075f5d16e4386c06facdb36dbc" translate="yes" xml:space="preserve">
          <source>That won't work at all, because &lt;code&gt;.*&lt;/code&gt; was greedy and gobbled up the whole string. As &lt;code&gt;\d*&lt;/code&gt; can match on an empty string the complete regular expression matched successfully.</source>
          <target state="translated">Это вообще не сработает, потому что &lt;code&gt;.*&lt;/code&gt; Был жадным и сожрал всю строку. Поскольку &lt;code&gt;\d*&lt;/code&gt; может соответствовать пустой строке, полное регулярное выражение успешно сопоставлено.</target>
        </trans-unit>
        <trans-unit id="cf6d51f1f160810f3ac3cc94b21320c749d1f295" translate="yes" xml:space="preserve">
          <source>That'll get you scolded on perl5-porters, so don't do that. Be Awesome.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025065d41f91f68021f87b4bc88af80b714297bb" translate="yes" xml:space="preserve">
          <source>That's a bit better, but we still have that last column which needs to be moved further over. There's an easy way to fix this up: unfortunately, we can't get &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; to right-justify our fields, but we can get &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; to do it:</source>
          <target state="translated">Это немного лучше, но у нас все еще есть последний столбец, который нужно переместить дальше. Есть простой способ исправить это: к сожалению, мы не можем заставить &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; выравнивать наши поля по правому краю, но мы можем заставить &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; сделать это:</target>
        </trans-unit>
        <trans-unit id="28a77e110fbf943f3cd364152b5e3d00190d5f60" translate="yes" xml:space="preserve">
          <source>That's a bit better, but we still have that last column which needs to be moved further over. There's an easy way to fix this up: unfortunately, we can't get &lt;code&gt;pack&lt;/code&gt; to right-justify our fields, but we can get &lt;code&gt;sprintf&lt;/code&gt; to do it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ac81e130e91631a9d78d2d6a68196fcf7146e7" translate="yes" xml:space="preserve">
          <source>That's about all there is to it. Actually, it's more than all there is to it, because we've done a few nice things here for the sake of completeness, robustness, and general aesthetics. Simpler TIESCALAR classes are certainly possible.</source>
          <target state="translated">Это все,что есть.На самом деле,это больше,чем все,что есть в этом,потому что мы сделали несколько приятных вещей здесь ради полноты,прочности и общей эстетики.Более простые классы TIESCALAR,безусловно,возможны.</target>
        </trans-unit>
        <trans-unit id="eb3acd01c2e3336fdfd272a108c9af206f049bc1" translate="yes" xml:space="preserve">
          <source>That's all that's strictly necessary. There's additional files you might want:</source>
          <target state="translated">Это все,что строго необходимо.Есть дополнительные файлы,которые вам могут понадобиться:</target>
        </trans-unit>
        <trans-unit id="f4b60ee9e69236a73adb2c3c53252dab7254d2c9" translate="yes" xml:space="preserve">
          <source>That's all well and good for declaration of a fixed data structure, but what if you wanted to add new elements on the fly, or build it up entirely from scratch?</source>
          <target state="translated">Это все хорошо и хорошо для объявления фиксированной структуры данных,но что,если вы захотите добавить новые элементы на лету,или построить их полностью с нуля?</target>
        </trans-unit>
        <trans-unit id="10d195eb40678f2e435ff6368a25ea9770d7ae62" translate="yes" xml:space="preserve">
          <source>That's all you need to do on Unix systems with dynamic linking. Most Unix systems have dynamic linking. If yours doesn't, or if for another reason you have a statically-linked perl, &lt;b&gt;and&lt;/b&gt; the module requires compilation, you'll need to build a new Perl binary that includes the module. Again, you'll probably need to be root.</source>
          <target state="translated">Это все, что вам нужно сделать в системах Unix с динамической компоновкой. Большинство систем Unix имеют динамическое связывание. Если у вас нет, или если по другой причине у вас есть статически связанный Perl, &lt;b&gt;и&lt;/b&gt; модуль требует компиляции, вам нужно будет создать новый двоичный файл Perl, который включает модуль. Опять же, вам, вероятно, понадобится root.</target>
        </trans-unit>
        <trans-unit id="a00ede3b70bdf4862c08ec2dce8548cbf40dc38c" translate="yes" xml:space="preserve">
          <source>That's all. Similarly for ncftp or ftp, you would configure something like</source>
          <target state="translated">Вот и все.Аналогично для ncftp или ftp,вы бы настроили что-то вроде</target>
        </trans-unit>
        <trans-unit id="6a90902fefb78efc91bb4045efc7ccd96cd2b158" translate="yes" xml:space="preserve">
          <source>That's autovivification. You can get around this in a few ways. The easiest way is to just turn it off. The lexical &lt;code&gt;autovivification&lt;/code&gt; pragma is available on CPAN. Now you don't add to the hash:</source>
          <target state="translated">Это автовивификация. Вы можете обойти это несколькими способами. Самый простой способ - просто выключить его. &lt;code&gt;autovivification&lt;/code&gt; лексической автовивификации доступна на CPAN. Теперь вы не добавляете в хеш:</target>
        </trans-unit>
        <trans-unit id="9f49d51a5d99f95a36f28eae4b0601a8a32ea05a" translate="yes" xml:space="preserve">
          <source>That's because &lt;code&gt;.*&lt;/code&gt; was greedy, so you get everything between the</source>
          <target state="translated">Это потому, что &lt;code&gt;.*&lt;/code&gt; Был жадным, поэтому вы получите все между</target>
        </trans-unit>
        <trans-unit id="1b898ba735cd15a6bd993ec3d75a6b0058359915" translate="yes" xml:space="preserve">
          <source>That's because Perl doesn't (ever) implicitly dereference your variables. If you want to get at the thing a reference is referring to, then you have to do this yourself using either prefix typing indicators, like &lt;code&gt;${$blah}&lt;/code&gt; , &lt;code&gt;@{$blah}&lt;/code&gt; , &lt;code&gt;@{$blah[$i]}&lt;/code&gt; , or else postfix pointer arrows, like &lt;code&gt;$a-&amp;gt;[3]&lt;/code&gt; , &lt;code&gt;$h-&amp;gt;{fred}&lt;/code&gt; , or even &lt;code&gt;$ob-&amp;gt;method()-&amp;gt;[3]&lt;/code&gt; .</source>
          <target state="translated">Это потому, что Perl (никогда) не разыменовывает ваши переменные неявно. Если вы хотите понять, на что ссылается ссылка, вам нужно сделать это самостоятельно, используя либо индикаторы префикса ввода, например &lt;code&gt;${$blah}&lt;/code&gt; , &lt;code&gt;@{$blah}&lt;/code&gt; , &lt;code&gt;@{$blah[$i]}&lt;/code&gt; , или же стрелки-указатели постфикса, например &lt;code&gt;$a-&amp;gt;[3]&lt;/code&gt; , &lt;code&gt;$h-&amp;gt;{fred}&lt;/code&gt; , или даже &lt;code&gt;$ob-&amp;gt;method()-&amp;gt;[3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7a4a3776ff01d004644640252dd53fc3704e0e2" translate="yes" xml:space="preserve">
          <source>That's because Perl doesn't (ever) implicitly dereference your variables. If you want to get at the thing a reference is referring to, then you have to do this yourself using either prefix typing indicators, like &lt;code&gt;${$blah}&lt;/code&gt;, &lt;code&gt;@{$blah}&lt;/code&gt;, &lt;code&gt;@{$blah[$i]}&lt;/code&gt;, or else postfix pointer arrows, like &lt;code&gt;$a-&amp;gt;[3]&lt;/code&gt;, &lt;code&gt;$h-&amp;gt;{fred}&lt;/code&gt;, or even &lt;code&gt;$ob-&amp;gt;method()-&amp;gt;[3]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d4ba2bfdf5f5b21a00717fd39047d39da3c192" translate="yes" xml:space="preserve">
          <source>That's because Perl's precedence rules on its five prefix dereferencers (which look like someone swearing: &lt;code&gt;$ @ * % &amp;amp;&lt;/code&gt; ) make them bind more tightly than the postfix subscripting brackets or braces! This will no doubt come as a great shock to the C or C++ programmer, who is quite accustomed to using &lt;code&gt;*a[i]&lt;/code&gt; to mean what's pointed to by the</source>
          <target state="translated">Это потому, что правила приоритета Perl для его пяти разыменователей префиксов (которые выглядят так, как будто кто-то ругается: &lt;code&gt;$ @ * % &amp;amp;&lt;/code&gt; ) заставляют их связываться более жестко, чем скобки постфиксного индекса или фигурные скобки! Это, несомненно, станет большим шоком для программиста на C или C ++, который привык использовать &lt;code&gt;*a[i]&lt;/code&gt; для обозначения того, на что указывает</target>
        </trans-unit>
        <trans-unit id="41187fe54a62e820e1df501181075a2f61202104" translate="yes" xml:space="preserve">
          <source>That's because Perl's precedence rules on its five prefix dereferencers (which look like someone swearing: &lt;code&gt;$ @ * % &amp;amp;&lt;/code&gt;) make them bind more tightly than the postfix subscripting brackets or braces! This will no doubt come as a great shock to the C or C++ programmer, who is quite accustomed to using &lt;code&gt;*a[i]&lt;/code&gt; to mean what's pointed to by the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f393c4bb027f44afad135cf4530852dabaa1d38" translate="yes" xml:space="preserve">
          <source>That's because it treats &lt;code&gt;$fh&lt;/code&gt; as a string like &lt;code&gt;&quot;IO::Handle=GLOB(0x8039e0)&quot;&lt;/code&gt; , then pattern matches against that.</source>
          <target state="translated">Это потому, что он обрабатывает &lt;code&gt;$fh&lt;/code&gt; как строку типа &lt;code&gt;&quot;IO::Handle=GLOB(0x8039e0)&quot;&lt;/code&gt; , тогда шаблон соответствует этому.</target>
        </trans-unit>
        <trans-unit id="e5243109f1982ab10b2f341fa04b05232d301e22" translate="yes" xml:space="preserve">
          <source>That's because it treats &lt;code&gt;$fh&lt;/code&gt; as a string like &lt;code&gt;&quot;IO::Handle=GLOB(0x8039e0)&quot;&lt;/code&gt;, then pattern matches against that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef987861945b1d2e7a185649ce3d062e04bb5bf" translate="yes" xml:space="preserve">
          <source>That's because my() is more of a run-time statement than it is a compile-time declaration</source>
          <target state="translated">Это потому,что моя()больше похожа на операцию выполнения,чем на операцию компиляции.</target>
        </trans-unit>
        <trans-unit id="62587e053e8900b6dd6dfce6fa04010b4761573b" translate="yes" xml:space="preserve">
          <source>That's certainly better, but we still have to know how long all the integers are, and portability is far away. Rather than &lt;code&gt;2&lt;/code&gt; , for instance, we want to say &quot;however long a short is&quot;. But this can be done by enclosing the appropriate pack code in brackets: &lt;code&gt;[s]&lt;/code&gt;. So, here's the very best we can do:</source>
          <target state="translated">Это, конечно, лучше, но нам все еще нужно знать, какова длина всех целых чисел, а переносимость еще далеко. Вместо &lt;code&gt;2&lt;/code&gt; , например, мы хотим сказать &amp;laquo;какой бы длины ни был короткий&amp;raquo;. Но это можно сделать, заключив соответствующий код пакета в скобки: &lt;code&gt;[s]&lt;/code&gt; . Итак, вот лучшее, что мы можем сделать:</target>
        </trans-unit>
        <trans-unit id="d3165047d193a37d5ff71109d566914086cc04dd" translate="yes" xml:space="preserve">
          <source>That's certainly better, but we still have to know how long all the integers are, and portability is far away. Rather than &lt;code&gt;2&lt;/code&gt;, for instance, we want to say &quot;however long a short is&quot;. But this can be done by enclosing the appropriate pack code in brackets: &lt;code&gt;[s]&lt;/code&gt;. So, here's the very best we can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0971c7f378d8883abc6949fc548118faa7827c21" translate="yes" xml:space="preserve">
          <source>That's faster, cleaner, and safer than the previous approach. Of course, you don't need to use a dollar sign. You could use your own scheme to make it less confusing, like bracketed percent symbols, etc.</source>
          <target state="translated">Это быстрее,чище и безопаснее,чем предыдущий подход.Конечно,не нужно использовать знак доллара.Вы можете использовать свою собственную схему,чтобы сделать ее менее запутанной,например,символы процента в скобках и т.д.</target>
        </trans-unit>
        <trans-unit id="c29a101730c3253b24f4d81e9d501b9e43d3a5b6" translate="yes" xml:space="preserve">
          <source>That's fine for Internet-domain clients and servers, but what about local communications? While you can use the same setup, sometimes you don't want to. Unix-domain sockets are local to the current host, and are often used internally to implement pipes. Unlike Internet domain sockets, Unix domain sockets can show up in the file system with an ls(1) listing.</source>
          <target state="translated">Это нормально для клиентов и серверов интернет-доменов,но как насчет локальных коммуникаций? Хотя вы можете использовать одну и ту же настройку,иногда вы этого не хотите.Сокеты Unix-доменов локальны к текущему хосту,и часто используются внутренне для реализации труб.В отличие от доменных сокетов в Интернете,доменные сокеты Unix могут отображаться в файловой системе со списком ls(1).</target>
        </trans-unit>
        <trans-unit id="931aa8f88f4f387e1b11a09a91636eb5c2525c4d" translate="yes" xml:space="preserve">
          <source>That's how Perl parsed the program, from top to bottom:</source>
          <target state="translated">Так Перл разбирал программу сверху вниз:</target>
        </trans-unit>
        <trans-unit id="8a9ad9d817fc65f643335d0c0e239182a33f908e" translate="yes" xml:space="preserve">
          <source>That's how it works. It's pretty simple; as with many Perl programs, the explanation is much longer than the program.</source>
          <target state="translated">Вот как это работает.Это довольно просто;как и во многих программах на Perl,объяснение намного длиннее,чем программа.</target>
        </trans-unit>
        <trans-unit id="a4ec64876254c2b08386415f463aa4c3731a3571" translate="yes" xml:space="preserve">
          <source>That's how the &lt;code&gt;*PL_keyword_plugin&lt;/code&gt; function needs to behave overall. Conventionally, however, one does not completely replace the existing handler function. Instead, take a copy of &lt;code&gt;PL_keyword_plugin&lt;/code&gt; before assigning your own function pointer to it. Your handler function should look for keywords that it is interested in and handle those. Where it is not interested, it should call the saved plugin function, passing on the arguments it received. Thus &lt;code&gt;PL_keyword_plugin&lt;/code&gt; actually points at a chain of handler functions, all of which have an opportunity to handle keywords, and only the last function in the chain (built into the Perl core) will normally return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; .</source>
          <target state="translated">Вот как функция &lt;code&gt;*PL_keyword_plugin&lt;/code&gt; должна вести себя в целом. Однако обычно полностью не заменяют существующую функцию-обработчик. Вместо этого возьмите копию &lt;code&gt;PL_keyword_plugin&lt;/code&gt; , прежде чем назначать ему свой собственный указатель на функцию. Ваша функция-обработчик должна искать ключевые слова, которые ее интересуют, и обрабатывать их. Если это не интересно, он должен вызвать сохраненную функцию плагина, передав ей полученные аргументы. Таким образом, &lt;code&gt;PL_keyword_plugin&lt;/code&gt; фактически указывает на цепочку функций-обработчиков, каждая из которых имеет возможность обрабатывать ключевые слова, и только последняя функция в цепочке (встроенная в ядро ​​Perl) обычно возвращает &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b08fbd323cdcfc2a59e5f4cc2312d748230aa97" translate="yes" xml:space="preserve">
          <source>That's how the &lt;code&gt;*PL_keyword_plugin&lt;/code&gt; function needs to behave overall. Conventionally, however, one does not completely replace the existing handler function. Instead, take a copy of &lt;code&gt;PL_keyword_plugin&lt;/code&gt; before assigning your own function pointer to it. Your handler function should look for keywords that it is interested in and handle those. Where it is not interested, it should call the saved plugin function, passing on the arguments it received. Thus &lt;code&gt;PL_keyword_plugin&lt;/code&gt; actually points at a chain of handler functions, all of which have an opportunity to handle keywords, and only the last function in the chain (built into the Perl core) will normally return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417bb675fe45cc9c0d3fa87fb632598764e6a64d" translate="yes" xml:space="preserve">
          <source>That's it for creating references. By now you're probably dying to know how to use references to get back to your long-lost data. There are several basic methods.</source>
          <target state="translated">Это для создания ссылок.Вероятно,сейчас вы умираете от желания узнать,как использовать ссылки,чтобы вернуться к давно потерянным данным.Есть несколько основных методов.</target>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="translated">Вот так!</target>
        </trans-unit>
        <trans-unit id="4ad43787f3a61735da906162ae4566f1716a8e9d" translate="yes" xml:space="preserve">
          <source>That's it, you're back on home turf again.</source>
          <target state="translated">Вот и все,ты снова на домашней территории.</target>
        </trans-unit>
        <trans-unit id="ad818b8edee0b9dd293a16c07bd537675f5226f7" translate="yes" xml:space="preserve">
          <source>That's just the simple case of assigning an array to a scalar and getting its element count. If that's what you really and truly want, then you might do well to consider being a tad more explicit about it, like this:</source>
          <target state="translated">Это простой случай назначения массива скаляру и получения количества его элементов.Если это то,чего Вы действительно хотите,то Вам стоит подумать о том,чтобы быть немного более откровенным в этом вопросе,например,вот так:</target>
        </trans-unit>
        <trans-unit id="64d9d2742b71e9220af551f7c7046f7f081af6aa" translate="yes" xml:space="preserve">
          <source>That's not much help, a couple of welcomes in there, but no indication of which are keys, and which are values, it's just a listed array dump and, in this case, not particularly helpful. The trick here, is to use a &lt;b&gt;reference&lt;/b&gt; to the data structure:</source>
          <target state="translated">Это не очень помогает, пара приветствий там, но нет указания, какие ключи, а какие значения, это просто дамп массива в списке и, в этом случае, не особенно полезен. Уловка здесь заключается в использовании &lt;b&gt;ссылки&lt;/b&gt; на структуру данных:</target>
        </trans-unit>
        <trans-unit id="33e7ab43a8b3ad63335115c42e08832229acf410" translate="yes" xml:space="preserve">
          <source>That's not particularly efficient. It would be more space-efficient to use:</source>
          <target state="translated">Это не особенно эффективно.Было бы более эффективно использовать пространство:</target>
        </trans-unit>
        <trans-unit id="69885b7848b259e032939450164926f255956e80" translate="yes" xml:space="preserve">
          <source>That's pretty much it. Now write</source>
          <target state="translated">Вот и все.Теперь пишите</target>
        </trans-unit>
        <trans-unit id="0e0f898332e33495bcec31fc5e9658f137da2c67" translate="yes" xml:space="preserve">
          <source>That's probably because you forgot libraries, or library paths differ. You really should build the whole distribution on the machine it will eventually live on, and then type &lt;code&gt;make install&lt;/code&gt; . Most other approaches are doomed to failure.</source>
          <target state="translated">Вероятно, это потому, что вы забыли библиотеки или пути к библиотекам различаются. Вам действительно следует собрать весь дистрибутив на машине, на которой он в конечном итоге будет жить, а затем набрать &lt;code&gt;make install&lt;/code&gt; . Большинство других подходов обречены на провал.</target>
        </trans-unit>
        <trans-unit id="bd1f4414e3c5b98a871dc22bff9ce2a5552a8c42" translate="yes" xml:space="preserve">
          <source>That's probably because you forgot libraries, or library paths differ. You really should build the whole distribution on the machine it will eventually live on, and then type &lt;code&gt;make install&lt;/code&gt;. Most other approaches are doomed to failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f563351f204013afa271606ba9bd745aa56dda" translate="yes" xml:space="preserve">
          <source>That's shown below, in a program I'll call</source>
          <target state="translated">Это показано ниже,в программе,которую я буду вызывать</target>
        </trans-unit>
        <trans-unit id="651cfe39b8f69bca0fd98eae5d4edf4fd6370a67" translate="yes" xml:space="preserve">
          <source>That's where the glue code can be inserted to create the initial contact between Perl and linked C/C++ routines. Let's take a look some pieces of</source>
          <target state="translated">Здесь можно вставить клеевой код для создания первоначального контакта между Perl и связанными C/C++подпрограммами.Давайте посмотрим на некоторые кусочки</target>
        </trans-unit>
        <trans-unit id="9608b4f77e4cb870b25879f8aef6ee06bf6a1b9f" translate="yes" xml:space="preserve">
          <source>That's why &lt;code&gt;STORABLE_freeze&lt;/code&gt; lets you provide a list of references to serialize. The engine guarantees that those will be serialized in the same context as the other objects, and therefore that shared objects will stay shared.</source>
          <target state="translated">Вот почему &lt;code&gt;STORABLE_freeze&lt;/code&gt; позволяет вам предоставить список ссылок для сериализации. Механизм гарантирует, что они будут сериализованы в том же контексте, что и другие объекты, и поэтому общие объекты останутся общими.</target>
        </trans-unit>
        <trans-unit id="735b594fd42209c8688db3bd34982beb910ab493" translate="yes" xml:space="preserve">
          <source>That's why they're called 'options'.</source>
          <target state="translated">Вот почему их называют &quot;опционами&quot;.</target>
        </trans-unit>
        <trans-unit id="8301b3f815f17c3dd7076e96039e1678841b82a4" translate="yes" xml:space="preserve">
          <source>Thatclassname</source>
          <target state="translated">Thatclassname</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="2ebc0d199c8eb44a7ac92ea22e10498f30092a55" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; above stands for some Unicode version number, such as &lt;code&gt;1.1&lt;/code&gt; or &lt;code&gt;12.0&lt;/code&gt;; or the &quot;*&quot; can also be &lt;code&gt;Unassigned&lt;/code&gt;. This property will match the code points whose final disposition has been settled as of the Unicode release given by the version number; &lt;code&gt;\p{Present_In: Unassigned}&lt;/code&gt; will match those code points whose meaning has yet to be assigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f203dc849e9f4f723b6a77e413f463ccf14a492" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; above stands for some two digit Unicode version number, such as &lt;code&gt;1.1&lt;/code&gt; or &lt;code&gt;4.0&lt;/code&gt; ; or the &quot;*&quot; can also be &lt;code&gt;Unassigned&lt;/code&gt; . This property will match the code points whose final disposition has been settled as of the Unicode release given by the version number; &lt;code&gt;\p{Present_In: Unassigned}&lt;/code&gt; will match those code points whose meaning has yet to be assigned.</source>
          <target state="translated">Знак &amp;laquo;*&amp;raquo; выше означает номер версии Unicode из двух цифр, например &lt;code&gt;1.1&lt;/code&gt; или &lt;code&gt;4.0&lt;/code&gt; ; или &quot;*&quot; также может быть &lt;code&gt;Unassigned&lt;/code&gt; . Это свойство будет соответствовать кодовым точкам, окончательное расположение которых было определено в выпуске Unicode, заданном номером версии; &lt;code&gt;\p{Present_In: Unassigned}&lt;/code&gt; будет соответствовать тем кодовым точкам, значение которых еще не было присвоено.</target>
        </trans-unit>
        <trans-unit id="a22d3668e744bc1f40c2f7d6bd90a8803737c69c" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; character will be replaced with the complete input filename.</source>
          <target state="translated">Символ &quot;*&quot; будет заменен на полное имя входного файла.</target>
        </trans-unit>
        <trans-unit id="3b9595dacd7d80fdab60d4dc5871376b0675fb8c" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; quantifier is equivalent to &lt;code&gt;{0,}&lt;/code&gt; , the &quot;+&quot; quantifier to &lt;code&gt;{1,}&lt;/code&gt; , and the &quot;?&quot; quantifier to &lt;code&gt;{0,1}&lt;/code&gt; . n and m are limited to non-negative integral values less than a preset limit defined when perl is built. This is usually 32766 on the most common platforms. The actual limit can be seen in the error message generated by code such as this:</source>
          <target state="translated">Квантификатор &amp;laquo;*&amp;raquo; эквивалентен &lt;code&gt;{0,}&lt;/code&gt; , квантор &amp;laquo;+&amp;raquo; - &lt;code&gt;{1,}&lt;/code&gt; и знаку &amp;laquo;?&amp;raquo; квантификатор на &lt;code&gt;{0,1}&lt;/code&gt; . n и m ограничены неотрицательными целыми значениями, меньшими предустановленного предела, определенного при построении perl. Обычно это 32766 на наиболее распространенных платформах. Фактический предел можно увидеть в сообщении об ошибке, созданном таким кодом:</target>
        </trans-unit>
        <trans-unit id="ef1a900f188939b7338bcc6047d7f99f423bcf86" translate="yes" xml:space="preserve">
          <source>The &quot;:&quot; on these identifiers means simply &quot;process this stuff normally, even though the result will be for some special target&quot;. I suggest that parser APIs report &quot;biblio&quot; as the target identifier, but also report that it had a &quot;:&quot; prefix. (And similarly, with the above &quot;html&quot;, report &quot;html&quot; as the target identifier, and note the</source>
          <target state="translated">&quot;:&quot; на этих идентификаторах означает просто &quot;обрабатывать этот материал нормально,даже если результат будет для какой-то специальной цели&quot;.Я предлагаю,чтобы парсерные API сообщали &quot;biblio&quot; в качестве идентификатора цели,но также сообщали,что он имеет префикс &quot;:&quot;.(И аналогично,с вышеуказанным &quot;html&quot;,сообщите &quot;html&quot; в качестве идентификатора цели,и обратите внимание на то.</target>
        </trans-unit>
        <trans-unit id="64b5d9da126d3d99727eec1708f648b1bd4f7983" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;rules&lt;/code&gt; &quot; data structure is the the heart of the scheduler. It allows you to express simple rules like &quot;run all tests in sequence&quot; or &quot;run all tests in parallel except these five tests.&quot;. However, the rules structure also supports glob-style pattern matching and recursive definitions, so you can also express arbitarily complicated patterns.</source>
          <target state="translated">Структура данных &quot; &lt;code&gt;rules&lt;/code&gt; &quot; - это сердце планировщика. Он позволяет выражать простые правила, такие как &amp;laquo;запускать все тесты последовательно&amp;raquo; или &amp;laquo;запускать все тесты параллельно, кроме этих пяти тестов&amp;raquo;. Однако структура правил также поддерживает сопоставление шаблонов в стиле глобуса и рекурсивные определения, поэтому вы также можете выражать произвольно сложные шаблоны.</target>
        </trans-unit>
        <trans-unit id="2ed0d091df98bc8db977a3f32a7cda06b5707b99" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;rules&lt;/code&gt;&quot; data structure is the the heart of the scheduler. It allows you to express simple rules like &quot;run all tests in sequence&quot; or &quot;run all tests in parallel except these five tests.&quot;. However, the rules structure also supports glob-style pattern matching and recursive definitions, so you can also express arbitarily complicated patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1074d5a9a7dcd2040a3f0c45e46a4676237c27c8" translate="yes" xml:space="preserve">
          <source>The &quot;=begin</source>
          <target state="translated">&quot;=начало</target>
        </trans-unit>
        <trans-unit id="15a448a46373702e33d38bd4498490c44fd2b70f" translate="yes" xml:space="preserve">
          <source>The &quot;=item [text]&quot; paragraph should not match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\*\s*\z/&lt;/a&gt;&lt;/code&gt;, nor should it match just &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s*\z/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Абзац &amp;laquo;= item [text]&amp;raquo; не должен соответствовать &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\*\s*\z/&lt;/a&gt;&lt;/code&gt; , ни если он соответствует только &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s*\z/&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb00107a8cd7306f310a4e41cd2188b092574511" translate="yes" xml:space="preserve">
          <source>The &quot;=item [text]&quot; paragraph should not match &lt;code&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/code&gt; or &lt;code&gt;m/\A=item\s+\*\s*\z/&lt;/code&gt;, nor should it match just &lt;code&gt;m/\A=item\s*\z/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cea2af4ab6ab309f2a49ef717323c3929bef20" translate="yes" xml:space="preserve">
          <source>The &quot;=pod&quot; command by itself doesn't do much of anything, but it signals to Perl (and Pod formatters) that a Pod block starts here. A Pod block starts with</source>
          <target state="translated">Команда &quot;=pod&quot; сама по себе ничего не делает,но сигнализирует Perl (и форматорам Pod),что здесь начинается блок Pod.Блок под начинается с</target>
        </trans-unit>
        <trans-unit id="45c9bcf242eeaf20585053facd6dddbfcd2e77f0" translate="yes" xml:space="preserve">
          <source>The &quot;English&quot; operators (&lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt; , and &lt;code&gt;not&lt;/code&gt; ) deliberately have precedence lower than that of list operators for just such situations as the one above.</source>
          <target state="translated">&amp;laquo;Английские&amp;raquo; операторы ( &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt; , and &lt;code&gt;not&lt;/code&gt; ) намеренно имеют более низкий приоритет, чем операторы списка, как раз для таких ситуаций, как описанная выше.</target>
        </trans-unit>
        <trans-unit id="c776db1d67057122c329ee64bd76a151ecfea104" translate="yes" xml:space="preserve">
          <source>The &quot;English&quot; operators (&lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;xor&lt;/code&gt;, and &lt;code&gt;not&lt;/code&gt;) deliberately have precedence lower than that of list operators for just such situations as the one above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c4bf3828130bdd16f6f681093f66656168cc64" translate="yes" xml:space="preserve">
          <source>The &quot;MIT&quot; License</source>
          <target state="translated">Лицензия &quot;MIT&quot;</target>
        </trans-unit>
        <trans-unit id="809b368cf33985ff1e068eaf70e57337041ab266" translate="yes" xml:space="preserve">
          <source>The &quot;Tree&quot; subsubsection in XML::Parser</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6804bf4d1b752ec09b4b554040a4294aa2c28e2" translate="yes" xml:space="preserve">
          <source>The &quot;U&quot; mode is modeled on Python's &quot;Universal Newlines&quot; concept, whereby DOS and Mac OS line terminators are converted internally to UNIX newlines before processing. This ensures consistent digest values when working simultaneously across multiple file systems. &lt;b&gt;The &quot;U&quot; mode influences only text files&lt;/b&gt;, namely those passing Perl's</source>
          <target state="translated">Режим &amp;laquo;U&amp;raquo; смоделирован на основе концепции Python &amp;laquo;Универсальные символы новой строки&amp;raquo;, согласно которой терминаторы строк в DOS и Mac OS перед обработкой преобразуются внутренне в символы новой строки UNIX. Это обеспечивает согласованные значения дайджеста при одновременной работе в нескольких файловых системах. &lt;b&gt;Режим &quot;U&quot; влияет только на текстовые файлы&lt;/b&gt; , а именно на те, которые передают Perl's</target>
        </trans-unit>
        <trans-unit id="3825414166fcae7ca1f01fa808eb7b2edebcc1b6" translate="yes" xml:space="preserve">
          <source>The &quot;Unicode Bug&quot;</source>
          <target state="translated">&quot;Жучок Юникода&quot;</target>
        </trans-unit>
        <trans-unit id="0ec3a96aade5dbc6ee323c533eb4507821e58ebe" translate="yes" xml:space="preserve">
          <source>The &quot;access&quot; sub-pragma</source>
          <target state="translated">Суб-прагма &quot;доступа&quot;</target>
        </trans-unit>
        <trans-unit id="c5bfb037ae6662a8b7a6614931ff100518e1954f" translate="yes" xml:space="preserve">
          <source>The &quot;bad interpreter&quot; message comes from the shell, not perl. The actual message may vary depending on your platform, shell, and locale settings.</source>
          <target state="translated">Сообщение &quot;плохой переводчик&quot; приходит из оболочки,а не с perl.Фактическое сообщение может варьироваться в зависимости от вашей платформы,оболочки и настроек локали.</target>
        </trans-unit>
        <trans-unit id="7324c65fe364cafe1f0b648f9b09ee839b62c197" translate="yes" xml:space="preserve">
          <source>The &quot;else if&quot; keyword is spelled &lt;code&gt;elsif&lt;/code&gt; in Perl. There's no &lt;code&gt;elif&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;else&quot;&gt;else&lt;/a&gt; &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;&lt;/code&gt; either. It does parse &lt;code&gt;&lt;a href=&quot;elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt;, but only to warn you about not using it.</source>
          <target state="translated">Ключевое слово else if пишется на Perl как &lt;code&gt;elsif&lt;/code&gt; . Там нет &lt;code&gt;elif&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;else&quot;&gt;else&lt;/a&gt; &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;&lt;/code&gt; либо. Он выполняет синтаксический анализ &lt;code&gt;&lt;a href=&quot;elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt; , но только чтобы предупредить вас о том, что вы его не используете.</target>
        </trans-unit>
        <trans-unit id="dcec7b786aaf98a8eb4d77d89e7fe0ef405e7fc1" translate="yes" xml:space="preserve">
          <source>The &quot;else if&quot; keyword is spelled &lt;code&gt;elsif&lt;/code&gt; in Perl. There's no &lt;code&gt;elif&lt;/code&gt; or &lt;code&gt;else if&lt;/code&gt; either. It does parse &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt;, but only to warn you about not using it.</source>
          <target state="translated">Ключевое слово else if пишется на Perl как &lt;code&gt;elsif&lt;/code&gt; . Нет ни &lt;code&gt;elif&lt;/code&gt; ни &lt;code&gt;else if&lt;/code&gt; . Он выполняет синтаксический анализ &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt; , но только чтобы предупредить вас о том, что вы его не используете.</target>
        </trans-unit>
        <trans-unit id="376964f7b7dc051fc5e877b839e65e771ea6ae93" translate="yes" xml:space="preserve">
          <source>The &quot;else if&quot; keyword is spelled &lt;code&gt;elsif&lt;/code&gt; in Perl. There's no &lt;code&gt;elif&lt;/code&gt; or &lt;code&gt;else if&lt;/code&gt; either. It does parse &lt;code&gt;elseif&lt;/code&gt;, but only to warn you about not using it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0a3bbed813bc00b5b829d702e3237f3e106a1b" translate="yes" xml:space="preserve">
          <source>The &quot;fail&quot; attribute can be accessed with the &lt;code&gt;fail_with&lt;/code&gt; method:</source>
          <target state="translated">К атрибуту &amp;laquo;fail&amp;raquo; можно получить доступ с &lt;code&gt;fail_with&lt;/code&gt; метода fail_with :</target>
        </trans-unit>
        <trans-unit id="f145fe55bdca7d5323b2fa4d4c3d2d68727a4e71" translate="yes" xml:space="preserve">
          <source>The &quot;grab all you can, and do not give anything back&quot; semantic is desirable in many situations where on the first sight a simple &lt;code&gt;()*&lt;/code&gt; looks like the correct solution. Suppose we parse text with comments being delimited by &lt;code&gt;&quot;#&quot;&lt;/code&gt; followed by some optional (horizontal) whitespace. Contrary to its appearance, &lt;code&gt;#[ \t]*&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfcc407b9b43637eb6bd977679586bbeebf2328" translate="yes" xml:space="preserve">
          <source>The &quot;grab all you can, and do not give anything back&quot; semantic is desirable in many situations where on the first sight a simple &lt;code&gt;()*&lt;/code&gt; looks like the correct solution. Suppose we parse text with comments being delimited by &lt;code&gt;#&lt;/code&gt; followed by some optional (horizontal) whitespace. Contrary to its appearance, &lt;code&gt;#[ \t]*&lt;/code&gt;</source>
          <target state="translated">Семантика &amp;laquo;хватай все, что можешь, и ничего не возвращай&amp;raquo; желательна во многих ситуациях, когда на первый взгляд simple &lt;code&gt;()*&lt;/code&gt; кажется правильным решением. Предположим, мы анализируем текст с комментариями, разделенными знаком &lt;code&gt;#&lt;/code&gt; , за которым следует необязательный (горизонтальный) пробел. В отличие от внешнего вида, &lt;code&gt;#[ \t]*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43c9200741055f798210ca5b9a02d181e70102c1" translate="yes" xml:space="preserve">
          <source>The &quot;in most cases&quot; hedge is because local TCP state machine behavior may depend on the peer's socket options. In particular, if the peer socket has &lt;code&gt;SO_LINGER&lt;/code&gt; enabled with a zero timeout, then the peer's &lt;code&gt;close&lt;/code&gt; will generate a &lt;code&gt;RST&lt;/code&gt; segment. Upon receipt of that segment, the local TCP transitions immediately to &lt;b&gt;CLOSED&lt;/b&gt;, and in that state, this method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64504831dda4d8442cac5969f1512970ea2ab8e" translate="yes" xml:space="preserve">
          <source>The &quot;in most cases&quot; hedge is because local TCP state machine behavior may depend on the peer's socket options. In particular, if the peer socket has SO_LINGER enabled with a zero timeout, then the peer's close() will generate a RST segment, upon receipt of which the local TCP transitions immediately to &lt;b&gt;CLOSED&lt;/b&gt;, and in that state, connected()</source>
          <target state="translated">Хеджирование &amp;laquo;в большинстве случаев&amp;raquo; связано с тем, что поведение локального конечного автомата TCP может зависеть от параметров сокета однорангового узла. В частности, если на одноранговом сокете включен SO_LINGER с нулевым таймаутом, тогда close () однорангового узла сгенерирует сегмент RST, после получения которого локальный TCP сразу переходит в состояние &lt;b&gt;CLOSED&lt;/b&gt; , а в этом состоянии connected ()</target>
        </trans-unit>
        <trans-unit id="191bee2290fcd83ba60b79d930b2194e317ac84f" translate="yes" xml:space="preserve">
          <source>The &quot;inode change timestamp&quot; (the &lt;a href=&quot;perlfunc#-X-FILEHANDLE&quot;&gt;&lt;code&gt;-C&lt;/code&gt;&lt;/a&gt; filetest) may really be the &quot;creation timestamp&quot; (which it is not in Unix).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ff934381d4470548d727908956bd70f3d20831" translate="yes" xml:space="preserve">
          <source>The &quot;inode change timestamp&quot; (the &lt;code&gt;-C&lt;/code&gt; filetest) may really be the &quot;creation timestamp&quot; (which it is not in Unix).</source>
          <target state="translated">&amp;laquo;Отметка времени изменения индексного дескриптора&amp;raquo; ( &lt;code&gt;-C&lt;/code&gt; filetest) действительно может быть &amp;laquo;отметкой времени создания&amp;raquo; (которой нет в Unix).</target>
        </trans-unit>
        <trans-unit id="d5dae6e25029009f346d93a94005c0b2df86ea03" translate="yes" xml:space="preserve">
          <source>The &quot;interpreter-based threads&quot; provided by Perl are not the fast, lightweight system for multitasking that one might expect or hope for. Threads are implemented in a way that make them easy to misuse. Few people know how to use them correctly or will be able to provide help.</source>
          <target state="translated">Потоки,основанные на интерпретаторах&quot;,предоставляемые Perl,не являются быстрой и легкой системой для многозадачности,на которую можно было бы рассчитывать или надеяться.Потоки реализованы таким образом,что их легко использовать не по назначению.Мало кто знает,как ими правильно пользоваться,и не сможет оказать помощь.</target>
        </trans-unit>
        <trans-unit id="17303b20d10d9ca1d72a771659e0ed0ddf3d30b9" translate="yes" xml:space="preserve">
          <source>The &quot;interpreter-based threads&quot; provided by Perl are not the fast, lightweight system for multitasking that one might expect or hope for. Threads are implemented in a way that makes them easy to misuse. Few people know how to use them correctly or will be able to provide help.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="611cc4fe5613cabb6ac2b4cb6c84bf4897881a2a" translate="yes" xml:space="preserve">
          <source>The &quot;like&quot; code entry is not always an exact rendition. For example, the smartmatch operator short-circuits whenever possible, but &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; does not. Also, &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in scalar context returns the number of matches, but &lt;code&gt;~~&lt;/code&gt; returns only true or false.</source>
          <target state="translated">Код &amp;laquo;нравится&amp;raquo; не всегда является точным воспроизведением. Например, оператор smartmatch по возможности выполняет короткое замыкание, а &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; - нет. Кроме того, &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; в скалярном контексте возвращает количество совпадений, а &lt;code&gt;~~&lt;/code&gt; возвращает только истину или ложь.</target>
        </trans-unit>
        <trans-unit id="6ea890b70f56a5f9e0d36cf926a8647084d27520" translate="yes" xml:space="preserve">
          <source>The &quot;like&quot; code entry is not always an exact rendition. For example, the smartmatch operator short-circuits whenever possible, but &lt;code&gt;grep&lt;/code&gt; does not. Also, &lt;code&gt;grep&lt;/code&gt; in scalar context returns the number of matches, but &lt;code&gt;~~&lt;/code&gt; returns only true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812d0b36924ed8327e26e7bd66db9f34693b1e0d" translate="yes" xml:space="preserve">
          <source>The &quot;locked&quot; attribute is deprecated, and has no effect in 5.10.0 and later. It was used as part of the now-removed &quot;Perl 5.005 threads&quot;.</source>
          <target state="translated">Атрибут &quot;заблокирован&quot; устарел и не имеет эффекта в 5.10.0 и более поздних версиях.Использовался в составе удаленного &quot;Perl 5.005 threads&quot;.</target>
        </trans-unit>
        <trans-unit id="9dcce4d393c04df7e129e843600a4cbb41352ba2" translate="yes" xml:space="preserve">
          <source>The &quot;make test&quot; step runs a Perl Verification Procedure, usually before installation. You might encounter STDERR messages even during a successful run of &quot;make test&quot;. Here is a guide to some of the more commonly seen anomalies:</source>
          <target state="translated">На шаге &quot;сделать тест&quot; выполняется процедура верификации Perl,обычно перед установкой.Вы можете столкнуться с сообщениями STDERR даже во время успешного выполнения &quot;make test&quot;.Вот руководство по некоторым наиболее часто встречающимся аномалиям:</target>
        </trans-unit>
        <trans-unit id="c90503a55170e15efc4d9ae431c0e36ee6a25e33" translate="yes" xml:space="preserve">
          <source>The &quot;maketext&quot; Method</source>
          <target state="translated">Метод &quot;maketext&quot;</target>
        </trans-unit>
        <trans-unit id="7968697304f2035aa2639422d611288498d75cab" translate="yes" xml:space="preserve">
          <source>The &quot;mro&quot; namespace provides several utilities for dealing with method resolution order and method caching in general.</source>
          <target state="translated">Пространство имён &quot;mro&quot; предоставляет несколько утилит для работы с порядком разрешения методов и кэширования методов в целом.</target>
        </trans-unit>
        <trans-unit id="71bf414e13a483c3f8866e169ca7ae68644d2c78" translate="yes" xml:space="preserve">
          <source>The &quot;next&quot; pointers of all regops except &lt;code&gt;BRANCH&lt;/code&gt; implement concatenation; a &quot;next&quot; pointer with a &lt;code&gt;BRANCH&lt;/code&gt; on both ends of it is connecting two alternatives. [Here we have one of the subtle syntax dependencies: an individual &lt;code&gt;BRANCH&lt;/code&gt; (as opposed to a collection of them) is never concatenated with anything because of operator precedence.]</source>
          <target state="translated">Указатели &quot;next&quot; всех регистров, кроме &lt;code&gt;BRANCH&lt;/code&gt; , реализуют конкатенацию; указатель &amp;laquo;следующий&amp;raquo; с &lt;code&gt;BRANCH&lt;/code&gt; на обоих концах соединяет две альтернативы. [Здесь у нас есть одна из тонких синтаксических зависимостей: отдельный &lt;code&gt;BRANCH&lt;/code&gt; (в отличие от их коллекции) никогда не соединяется ни с чем из-за приоритета оператора.]</target>
        </trans-unit>
        <trans-unit id="7475859558b8ac99b6dbae28949b5ee5991af403" translate="yes" xml:space="preserve">
          <source>The &quot;p&quot; mode differs from &quot;U&quot; only in that it treats &quot;\r\r\n&quot; as a single newline, a quirky feature designed to accommodate legacy applications that occasionally added an extra carriage return before DOS line terminators. The &quot;p&quot; mode will be phased out eventually in favor of the cleaner and more well-established Universal Newlines concept.</source>
          <target state="translated">Режим &quot;p&quot; отличается от режима &quot;U&quot; только тем,что он рассматривает &quot;\r\r\n&quot; как единую новую строку,причудливую функцию,предназначенную для размещения устаревших приложений,которые иногда добавляли дополнительный возврат каретки перед оконечными устройствами линии DOS.Режим &quot;p&quot; со временем будет постепенно отменен в пользу более чистой и устоявшейся концепции Universal Newlines.</target>
        </trans-unit>
        <trans-unit id="21a4e20c8659f7cc84f2dc6e2b2235449667f421" translate="yes" xml:space="preserve">
          <source>The &quot;prototype&quot; attribute is an alternate means of specifying a prototype on a sub. The desired prototype is within the parens.</source>
          <target state="translated">Атрибут &quot;прототип&quot; является альтернативным средством указания прототипа на подлодке.Желаемый прототип находится внутри парен.</target>
        </trans-unit>
        <trans-unit id="dd5b998a91e6bf19722acfe03146f25538072352" translate="yes" xml:space="preserve">
          <source>The &quot;quality&quot; of a hash is defined as the total number of comparisons needed to access every element once, relative to the expected number needed for a random hash. The value can go over 100%.</source>
          <target state="translated">Качество&quot; хэша определяется как общее количество сравнений,необходимое для доступа к каждому элементу один раз,по отношению к ожидаемому количеству,необходимому для случайного хэша.Значение может превышать 100%.</target>
        </trans-unit>
        <trans-unit id="0fa71c4992e21ca9d0f8816931658731741f8823" translate="yes" xml:space="preserve">
          <source>The &quot;root&quot; of the namespace (i.e. &quot;main::&quot;) is changed to a different package and code evaluated in the compartment cannot refer to variables outside this namespace, even with run-time glob lookups and other tricks.</source>
          <target state="translated">Корень&quot; пространства имен (т.е.&quot;main::&quot;)изменяется на другой пакет,и код,вычисляемый в этом отделении,не может ссылаться на переменные вне этого пространства имен,даже при выполнении поиска с помощью глобуса и других трюков.</target>
        </trans-unit>
        <trans-unit id="40e9eeb816659a4d78537c8ea14e7c775679daaf" translate="yes" xml:space="preserve">
          <source>The &quot;status value&quot; returned in &lt;code&gt;$?&lt;/code&gt; is synthesized from the actual exit status of the subprocess in a way that approximates POSIX wait(5) semantics, in order to allow Perl programs to portably test for successful completion of subprocesses. The low order 8 bits of &lt;code&gt;$?&lt;/code&gt; are always 0 under VMS, since the termination status of a process may or may not have been generated by an exception.</source>
          <target state="translated">&amp;laquo;Значение статуса&amp;raquo;, возвращенное в &lt;code&gt;$?&lt;/code&gt; синтезируется из фактического статуса выхода подпроцесса способом, который приближается к семантике POSIX wait (5), чтобы программы Perl могли переносимо тестировать успешное завершение подпроцессов. Младшие 8 бит &lt;code&gt;$?&lt;/code&gt; всегда равны 0 в VMS, поскольку статус завершения процесса может быть или не быть сгенерирован исключением.</target>
        </trans-unit>
        <trans-unit id="9220e93c05c2e58fcb6c44f1b19d591bad6f075c" translate="yes" xml:space="preserve">
          <source>The &quot;unique&quot; attribute is deprecated, and has no effect in 5.10.0 and later. It used to indicate that a single copy of an &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; variable was to be used by all interpreters should the program happen to be running in a multi-interpreter environment.</source>
          <target state="translated">Атрибут &amp;laquo;unique&amp;raquo; устарел и не действует в 5.10.0 и новее. Раньше он указывал, что одна копия &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; переменной должна использоваться всеми интерпретаторами, если программа запускается в среде с несколькими интерпретаторами.</target>
        </trans-unit>
        <trans-unit id="72e1eabd61e84fec8e9b71e8964b6733954ac85d" translate="yes" xml:space="preserve">
          <source>The &quot;use locale&quot; pragma</source>
          <target state="translated">Прагма &quot;используй местность&quot;</target>
        </trans-unit>
        <trans-unit id="ec6d1363cbbe06a4225f4f4c8cb504676b9d9ab8" translate="yes" xml:space="preserve">
          <source>The &quot;version&quot; key has a reference to an AV as its value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127c26381686cdc6cb6db8e06a75ac1b05a13d0e" translate="yes" xml:space="preserve">
          <source>The #endif and #else cannot portably have anything non-comment after them. If you want to document what is going (which is a good idea especially if the branches are long), use (C) comments:</source>
          <target state="translated">У #endif и #else не может быть ничего без комментариев после них.Если вы хотите задокументировать,что происходит (что является хорошей идеей,особенно если ветки длинные),используйте комментарии (C):</target>
        </trans-unit>
        <trans-unit id="6d394482dea20b84087d97ed59f1a7ab0353698f" translate="yes" xml:space="preserve">
          <source>The $algorithm is a string like &quot;MD2&quot;, &quot;MD5&quot;, &quot;SHA-1&quot;, &quot;SHA-512&quot;. Additional arguments are passed to the constructor for the implementation of the given algorithm.</source>
          <target state="translated">$алгоритм-это строка типа &quot;MD2&quot;,&quot;MD5&quot;,&quot;SHA-1&quot;,&quot;SHA-512&quot;.Дополнительные аргументы передаются конструктору для реализации данного алгоритма.</target>
        </trans-unit>
        <trans-unit id="060c7393d1a230b15152f168cb6702d886a2c8e8" translate="yes" xml:space="preserve">
          <source>The $always_copy parameter which when true causes files to be updated regardless as to whether they have changed, if it is defined but false then copies are made only if the files have changed, if it is undefined then the value of the environment variable EU_INSTALL_ALWAYS_COPY is used as default.</source>
          <target state="translated">Параметр $always_copy,который при значении true приводит к обновлению файлов независимо от того,изменились ли они,если он определен,но ложен,то копии делаются только в том случае,если файлы изменились,если он не определен,то по умолчанию используется значение переменной окружения EU_INSTALL_ALWAYS.</target>
        </trans-unit>
        <trans-unit id="2195889fc63370a441ff8bf1c8a9db960470ff14" translate="yes" xml:space="preserve">
          <source>The $buffer should be a Storable image or the first few bytes of it. If $buffer starts with a Storable header, then a hash describing the image is returned, otherwise &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">$ Buffer должен быть сохраняемым изображением или его первыми несколькими байтами. Если $ buffer начинается с заголовка Storable, то возвращается хеш, описывающий изображение, в противном случае возвращается &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78cacc3a4b41df98d6d490128b52baa4b5d2d0fc" translate="yes" xml:space="preserve">
          <source>The $buffer should be a Storable image or the first few bytes of it. If $buffer starts with a Storable header, then a hash describing the image is returned, otherwise &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90557aa2dce112e348d655279a7a2af9b8d9198" translate="yes" xml:space="preserve">
          <source>The $chld_in filehandle will have autoflush turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f3f95232308dda6cf28aa29e85f72c7757c618" translate="yes" xml:space="preserve">
          <source>The $data provided as argument are appended to the message we calculate the digest for. The return value is the $md5 object itself.</source>
          <target state="translated">Данные $data,предоставленные в качестве аргумента,добавляются к сообщению,для которого мы вычисляем дайджест.Возвращаемым значением является сам объект $md5.</target>
        </trans-unit>
        <trans-unit id="0b852897867aa68fb0b59cef6457c36880f5fe89" translate="yes" xml:space="preserve">
          <source>The $f that has &quot;bar&quot; added to it three times should be a new &lt;code&gt;$f&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; should create a new lexical variable each time through the loop. The expected output is:</source>
          <target state="translated">$ F, к которому трижды добавлена ​​&amp;laquo;полоса&amp;raquo;, должен быть новым &lt;code&gt;$f&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; должен каждый раз создавать новую лексическую переменную в цикле. Ожидаемый результат:</target>
        </trans-unit>
        <trans-unit id="9804e7c51be3b218136a0732d780cc554d28fa80" translate="yes" xml:space="preserve">
          <source>The $f that has &quot;bar&quot; added to it three times should be a new &lt;code&gt;$f&lt;/code&gt;&lt;code&gt;my $f&lt;/code&gt; should create a new lexical variable each time through the loop. The expected output is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1718e632a613e4c3f044b1d3a129d6229eab251a" translate="yes" xml:space="preserve">
          <source>The $filename parameter is used by Perl to identify the source file for the function if required by die(), caller() or the debugger. If $filename is not defined then &quot;DynaLoader&quot; will be used.</source>
          <target state="translated">Параметр $filename используется Perl для идентификации исходного файла функции,если этого требует функция die(),caller()или отладчик.Если $filename не определено,то будет использоваться &quot;DynaLoader&quot;.</target>
        </trans-unit>
        <trans-unit id="84c0a13d8949255c1b3abd5830e5bb4ca9af26b0" translate="yes" xml:space="preserve">
          <source>The $flags argument to alters dl_load_file behaviour. Assigned bits:</source>
          <target state="translated">Аргумент $flags изменяет поведение dl_load_file.Присваиваемые биты:</target>
        </trans-unit>
        <trans-unit id="533efbe36456ad5f0b2eb4a7940fb956d6dc8359" translate="yes" xml:space="preserve">
          <source>The $host argument can be omitted when specifying the &lt;code&gt;host&lt;/code&gt; option to new().</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
